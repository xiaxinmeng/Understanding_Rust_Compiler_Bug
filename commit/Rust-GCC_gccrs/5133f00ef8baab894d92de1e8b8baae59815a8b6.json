{"sha": "5133f00ef8baab894d92de1e8b8baae59815a8b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEzM2YwMGVmOGJhYWI4OTRkOTJkZTFlOGI4YmFhZTU5ODE1YThiNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-16T23:05:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-16T23:05:44Z"}, "message": "Update to current version of Go library (revision 94d654be2064).\n\nFrom-SVN: r171076", "tree": {"sha": "44176975832a3faf1626836e70c97d5edd674122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44176975832a3faf1626836e70c97d5edd674122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5133f00ef8baab894d92de1e8b8baae59815a8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5133f00ef8baab894d92de1e8b8baae59815a8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5133f00ef8baab894d92de1e8b8baae59815a8b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5133f00ef8baab894d92de1e8b8baae59815a8b6/comments", "author": null, "committer": null, "parents": [{"sha": "f617201f55938fc89b532f2240bdf77bea946471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f617201f55938fc89b532f2240bdf77bea946471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f617201f55938fc89b532f2240bdf77bea946471"}], "stats": {"total": 21152, "additions": 16272, "deletions": 4880}, "files": [{"sha": "2eecafd89d6d2e579b21a7f2a1b373ca30ad8ad4", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1078,7 +1078,7 @@ Type::make_type_descriptor_type()\n \t\t\t\t\t\t    bloc);\n \n       Struct_type* type_descriptor_type =\n-\tType::make_builtin_struct_type(9,\n+\tType::make_builtin_struct_type(10,\n \t\t\t\t       \"Kind\", uint8_type,\n \t\t\t\t       \"align\", uint8_type,\n \t\t\t\t       \"fieldAlign\", uint8_type,\n@@ -1087,7 +1087,9 @@ Type::make_type_descriptor_type()\n \t\t\t\t       \"hashfn\", hashfn_type,\n \t\t\t\t       \"equalfn\", equalfn_type,\n \t\t\t\t       \"string\", pointer_string_type,\n-\t\t\t\t       \"\", pointer_uncommon_type);\n+\t\t\t\t       \"\", pointer_uncommon_type,\n+\t\t\t\t       \"ptrToThis\",\n+\t\t\t\t       pointer_type_descriptor_type);\n \n       Named_type* named = Type::make_builtin_named_type(\"commonType\",\n \t\t\t\t\t\t\ttype_descriptor_type);\n@@ -1259,6 +1261,16 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n \t\t\t\t\t\t      only_value_methods));\n     }\n \n+  ++p;\n+  gcc_assert(p->field_name() == \"ptrToThis\");\n+  if (name == NULL)\n+    vals->push_back(Expression::make_nil(bloc));\n+  else\n+    {\n+      Type* pt = Type::make_pointer_type(name);\n+      vals->push_back(Expression::make_type_descriptor(pt, bloc));\n+    }\n+\n   ++p;\n   gcc_assert(p == fields->end());\n "}, {"sha": "e572b232450bea48d7a3b27a1292a3d9490bec39", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1,4 +1,4 @@\n-559f12e8fcd5\n+94d654be2064\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "0715a9911bfc7cd1fd44c586a2a785fb3d978a17", "filename": "libgo/Makefile.am", "status": "modified", "additions": 178, "deletions": 42, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -105,6 +105,7 @@ toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n \tcmath.gox \\\n+\tcrypto.gox \\\n \tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n@@ -158,8 +159,10 @@ toolexeclibgoarchive_DATA = \\\n toolexeclibgocompressdir = $(toolexeclibgodir)/compress\n \n toolexeclibgocompress_DATA = \\\n+\tcompress/bzip2.gox \\\n \tcompress/flate.gox \\\n \tcompress/gzip.gox \\\n+\tcompress/lzw.gox \\\n \tcompress/zlib.gox\n \n toolexeclibgocontainerdir = $(toolexeclibgodir)/container\n@@ -178,11 +181,13 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n+\tcrypto/dsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n \tcrypto/ocsp.gox \\\n+\tcrypto/openpgp.gox \\\n \tcrypto/rand.gox \\\n \tcrypto/rc4.gox \\\n \tcrypto/ripemd160.gox \\\n@@ -201,6 +206,7 @@ toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n \tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n@@ -306,6 +312,11 @@ toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n \truntime/pprof.gox\n \n+toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n+\n+toolexeclibgosync_DATA = \\\n+\tsync/atomic.gox\n+\n toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n \n toolexeclibgotesting_DATA = \\\n@@ -411,8 +422,6 @@ runtime_files = \\\n \truntime/mfixalloc.c \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n-\truntime/mheapmap32.c \\\n-\truntime/mheapmap64.c \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/thread.c \\\n@@ -489,6 +498,9 @@ go_cmath_files = \\\n \tgo/cmath/sqrt.go \\\n \tgo/cmath/tan.go\n \n+go_crypto_files = \\\n+\tgo/crypto/crypto.go\n+\n go_ebnf_files = \\\n \tgo/ebnf/ebnf.go \\\n \tgo/ebnf/parser.go\n@@ -533,13 +545,15 @@ go_http_files = \\\n \tgo/http/client.go \\\n \tgo/http/dump.go \\\n \tgo/http/fs.go \\\n+\tgo/http/header.go \\\n \tgo/http/lex.go \\\n \tgo/http/persist.go \\\n \tgo/http/request.go \\\n \tgo/http/response.go \\\n \tgo/http/server.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n+\tgo/http/transport.go \\\n \tgo/http/url.go\n \n go_image_files = \\\n@@ -693,6 +707,7 @@ go_os_files = \\\n \tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n \tgo/os/exec.go \\\n+\tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n@@ -738,8 +753,6 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n-\tgo/runtime/malloc_defs.go \\\n-\tgo/runtime/runtime_defs.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -781,11 +794,11 @@ go_strings_files = \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n+\tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n-\tgo/sync/rwmutex.go\n-go_sync_c_files = \\\n-\tgo/sync/cas.c\n+\tgo/sync/rwmutex.go \\\n+\tgo/sync/waitgroup.go\n \n if LIBGO_IS_SOLARIS\n go_syslog_file = go/syslog/syslog_solaris.go\n@@ -851,6 +864,12 @@ go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n \tgo/archive/zip/struct.go\n \n+go_compress_bzip2_files = \\\n+\tgo/compress/bzip2/bit_reader.go \\\n+\tgo/compress/bzip2/bzip2.go \\\n+\tgo/compress/bzip2/huffman.go \\\n+\tgo/compress/bzip2/move_to_front.go\n+\n go_compress_flate_files = \\\n \tgo/compress/flate/deflate.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n@@ -864,6 +883,10 @@ go_compress_gzip_files = \\\n \tgo/compress/gzip/gzip.go \\\n \tgo/compress/gzip/gunzip.go\n \n+go_compress_lzw_files = \\\n+\tgo/compress/lzw/reader.go \\\n+\tgo/compress/lzw/writer.go\n+\n go_compress_zlib_files = \\\n \tgo/compress/zlib/reader.go \\\n \tgo/compress/zlib/writer.go\n@@ -911,6 +934,8 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/io.go \\\n \tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n+go_crypto_dsa_files = \\\n+\tgo/crypto/dsa/dsa.go\n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go\n go_crypto_hmac_files = \\\n@@ -923,6 +948,11 @@ go_crypto_md5_files = \\\n \tgo/crypto/md5/md5block.go\n go_crypto_ocsp_files = \\\n \tgo/crypto/ocsp/ocsp.go\n+go_crypto_openpgp_files = \\\n+\tgo/crypto/openpgp/canonical_text.go \\\n+\tgo/crypto/openpgp/keys.go \\\n+\tgo/crypto/openpgp/read.go \\\n+\tgo/crypto/openpgp/write.go\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go\n@@ -970,6 +1000,19 @@ go_crypto_openpgp_armor_files = \\\n \tgo/crypto/openpgp/armor/encode.go\n go_crypto_openpgp_error_files = \\\n \tgo/crypto/openpgp/error/error.go\n+go_crypto_openpgp_packet_files = \\\n+\tgo/crypto/openpgp/packet/compressed.go \\\n+\tgo/crypto/openpgp/packet/encrypted_key.go \\\n+\tgo/crypto/openpgp/packet/literal.go \\\n+\tgo/crypto/openpgp/packet/one_pass_signature.go \\\n+\tgo/crypto/openpgp/packet/packet.go \\\n+\tgo/crypto/openpgp/packet/private_key.go \\\n+\tgo/crypto/openpgp/packet/public_key.go \\\n+\tgo/crypto/openpgp/packet/reader.go \\\n+\tgo/crypto/openpgp/packet/signature.go \\\n+\tgo/crypto/openpgp/packet/symmetric_key_encrypted.go \\\n+\tgo/crypto/openpgp/packet/symmetrically_encrypted.go \\\n+\tgo/crypto/openpgp/packet/userid.go\n go_crypto_openpgp_s2k_files = \\\n \tgo/crypto/openpgp/s2k/s2k.go\n \n@@ -1095,6 +1138,7 @@ go_net_dict_files = \\\n \tgo/net/dict/dict.go\n \n go_net_textproto_files = \\\n+\tgo/net/textproto/header.go \\\n \tgo/net/textproto/pipeline.go \\\n \tgo/net/textproto/reader.go \\\n \tgo/net/textproto/textproto.go \\\n@@ -1116,6 +1160,11 @@ go_runtime_debug_files = \\\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n+go_sync_atomic_files = \\\n+\tgo/sync/atomic/doc.go\n+go_sync_atomic_c_files = \\\n+\tgo/sync/atomic/atomic.c\n+\n go_testing_iotest_files = \\\n \tgo/testing/iotest/logger.go \\\n \tgo/testing/iotest/reader.go \\\n@@ -1268,6 +1317,7 @@ libgo_go_objs = \\\n \tbytes/bytes.lo \\\n \tbytes/index.lo \\\n \tcmath/cmath.lo \\\n+\tcrypto/crypto.lo \\\n \tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n@@ -1298,8 +1348,7 @@ libgo_go_objs = \\\n \tsort/sort.lo \\\n \tstrconv/strconv.lo \\\n \tstrings/strings.lo \\\n-\tsync/mutex.lo \\\n-\tsync/cas.lo \\\n+\tsync/sync.lo \\\n \tsyslog/syslog.lo \\\n \tsyslog/syslog_c.lo \\\n \ttabwriter/tabwriter.lo \\\n@@ -1313,8 +1362,10 @@ libgo_go_objs = \\\n \txml/xml.lo \\\n \tarchive/tar.lo \\\n \tarchive/zip.lo \\\n+\tcompress/bzip2.lo \\\n \tcompress/flate.lo \\\n \tcompress/gzip.lo \\\n+\tcompress/lzw.lo \\\n \tcompress/zlib.lo \\\n \tcontainer/heap.lo \\\n \tcontainer/list.lo \\\n@@ -1325,11 +1376,13 @@ libgo_go_objs = \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n+\tcrypto/dsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n \tcrypto/md4.lo \\\n \tcrypto/md5.lo \\\n \tcrypto/ocsp.lo \\\n+\tcrypto/openpgp.lo \\\n \tcrypto/rand.lo \\\n \tcrypto/rc4.lo \\\n \tcrypto/ripemd160.lo \\\n@@ -1344,6 +1397,7 @@ libgo_go_objs = \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n \tcrypto/openpgp/error.lo \\\n+\tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n@@ -1385,6 +1439,8 @@ libgo_go_objs = \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n+\tsync/atomic.lo \\\n+\tsync/atomic_c.lo \\\n \tsyscalls/syscall.lo \\\n \tsyscalls/errno.lo \\\n \ttesting/testing.lo \\\n@@ -1500,14 +1556,20 @@ cmath/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: cmath/check\n \n+crypto/crypto.lo: $(go_crypto_files) hash.gox\n+\t$(BUILDPACKAGE)\n+crypto/check: $(CHECK_DEPS)\n+\t$(CHECK)\n+.PHONY: crypto/check\n+\n ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n \t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n ebnf/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: ebnf/check\n \n-exec/exec.lo: $(go_exec_files) os.gox strings.gox\n+exec/exec.lo: $(go_exec_files) os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n exec/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1526,8 +1588,8 @@ flag/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: flag/check\n \n-fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox os.gox reflect.gox strconv.gox \\\n-\t\tstrings.gox unicode.gox utf8.gox\n+fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox math.gox os.gox reflect.gox \\\n+\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n fmt/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1554,10 +1616,10 @@ html/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: html/check\n \n-http/http.lo: $(go_http_files) bufio.gox bytes.gox container/list.gox \\\n-\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n-\t\tmime.gox mime/multipart.gox net.gox os.gox path.gox sort.gox \\\n+http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n+\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n+\t\tnet.gox net/textproto.gox os.gox path.gox sort.gox \\\n \t\tstrconv.gox strings.gox sync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n@@ -1576,9 +1638,10 @@ io/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: io/check\n \n-json/json.lo: $(go_json_files) bytes.gox container/vector.gox fmt.gox io.gox \\\n-\t\tmath.gox os.gox reflect.gox runtime.gox strconv.gox \\\n-\t\tstrings.gox unicode.gox utf16.gox utf8.gox\n+json/json.lo: $(go_json_files) bytes.gox container/vector.gox \\\n+\t\tencoding/base64.gox fmt.gox io.gox math.gox os.gox \\\n+\t\treflect.gox runtime.gox strconv.gox strings.gox unicode.gox \\\n+\t\tutf16.gox utf8.gox\n \t$(BUILDPACKAGE)\n json/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1611,14 +1674,14 @@ net/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/check\n \n-netchan/netchan.lo: $(go_netchan_files) gob.gox log.gox net.gox os.gox \\\n+netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n \t\treflect.gox strconv.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n netchan/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: netchan/check\n \n-os/os.lo: $(go_os_files) sync.gox syscall.gox\n+os/os.lo: $(go_os_files) runtime.gox sync.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1706,10 +1769,8 @@ strings/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: strings/check\n \n-sync/mutex.lo: $(go_sync_files) runtime.gox\n+sync/sync.lo: $(go_sync_files) runtime.gox sync/atomic.gox\n \t$(BUILDPACKAGE)\n-sync/cas.lo: $(go_sync_c_files) sync/mutex.lo\n-\t$(LTCOMPILE) -c -o sync/cas.lo $(srcdir)/go/sync/cas.c\n sync/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: sync/check\n@@ -1806,6 +1867,13 @@ archive/zip/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: archive/zip/check\n \n+compress/bzip2.lo: $(go_compress_bzip2_files) bufio.gox io.gox os.gox sort.gox\n+\t$(BUILDPACKAGE)\n+compress/bzip2/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) compress/bzip2\n+\t$(CHECK)\n+.PHONY: compress/bzip2/check\n+\n compress/flate.lo: $(go_compress_flate_files) bufio.gox io.gox math.gox \\\n \t\tos.gox sort.gox strconv.gox\n \t$(BUILDPACKAGE)\n@@ -1822,6 +1890,13 @@ compress/gzip/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: compress/gzip/check\n \n+compress/lzw.lo: $(go_compress_lzw_files) bufio.gox fmt.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+compress/lzw/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) compress/lzw\n+\t$(CHECK)\n+.PHONY: compress/lzw/check\n+\n compress/zlib.lo: $(go_compress_zlib_files) bufio.gox compress/flate.gox \\\n \t\thash.gox hash/adler32.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n@@ -1893,6 +1968,13 @@ crypto/cipher/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/cipher/check\n \n+crypto/dsa.lo: $(go_crypto_dsa_files) big.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+crypto/dsa/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/dsa\n+\t$(CHECK)\n+.PHONY: crypto/dsa/check\n+\n crypto/elliptic.lo: $(go_crypto_elliptic_files) big.gox io.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n crypto/elliptic/check: $(CHECK_DEPS)\n@@ -1908,30 +1990,40 @@ crypto/hmac/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/hmac/check\n \n-crypto/md4.lo: $(go_crypto_md4_files) hash.gox os.gox\n+crypto/md4.lo: $(go_crypto_md4_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/md4/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/md4\n \t$(CHECK)\n .PHONY: crypto/md4/check\n \n-crypto/md5.lo: $(go_crypto_md5_files) hash.gox os.gox\n+crypto/md5.lo: $(go_crypto_md5_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/md5/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/md5\n \t$(CHECK)\n .PHONY: crypto/md5/check\n \n-crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto/rsa.gox \\\n+crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto.gox crypto/rsa.gox \\\n \t\tcrypto/sha1.gox crypto/x509.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/ocsp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ocsp\n \t$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/rand.lo: $(go_crypto_rand_files) crypto/aes.gox io.gox os.gox sync.gox \\\n-\t\ttime.gox\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n+\t\t crypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n+\t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n+\t\thash.gox io.gox os.gox strconv.gox time.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/check\n+\n+crypto/rand.lo: $(go_crypto_rand_files) bufio.gox crypto/aes.gox io.gox \\\n+\t\tos.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/rand/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rand\n@@ -1945,36 +2037,36 @@ crypto/rc4/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/rc4/check\n \n-crypto/ripemd160.lo: $(go_crypto_ripemd160_files) hash.gox os.gox\n+crypto/ripemd160.lo: $(go_crypto_ripemd160_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/ripemd160/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ripemd160\n \t$(CHECK)\n .PHONY: crypto/ripemd160/check\n \n-crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto/sha1.gox \\\n+crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n \t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n \t$(CHECK)\n .PHONY: crypto/rsa/check\n \n-crypto/sha1.lo: $(go_crypto_sha1_files) hash.gox os.gox\n+crypto/sha1.lo: $(go_crypto_sha1_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha1/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha1\n \t$(CHECK)\n .PHONY: crypto/sha1/check\n \n-crypto/sha256.lo: $(go_crypto_sha256_files) hash.gox os.gox\n+crypto/sha256.lo: $(go_crypto_sha256_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha256/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha256\n \t$(CHECK)\n .PHONY: crypto/sha256/check\n \n-crypto/sha512.lo: $(go_crypto_sha512_files) hash.gox os.gox\n+crypto/sha512.lo: $(go_crypto_sha512_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha512/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha512\n@@ -1989,7 +2081,7 @@ crypto/subtle/check: $(CHECK_DEPS)\n .PHONY: crypto/subtle/check\n \n crypto/tls.lo: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n-\t\tcontainer/list.gox crypto/aes.gox crypto/cipher.gox \\\n+\t\tcontainer/list.gox crypto.gox crypto/aes.gox crypto/cipher.gox \\\n \t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n \t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n \t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n@@ -2009,8 +2101,8 @@ crypto/twofish/check: $(CHECK_DEPS)\n .PHONY: crypto/twofish/check\n \n crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox container/vector.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox hash.gox os.gox strings.gox \\\n-\t\ttime.gox\n+\t\tcrypto.gox crypto/rsa.gox crypto/sha1.gox hash.gox os.gox \\\n+\t\tstrings.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/x509\n@@ -2033,16 +2125,30 @@ crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/openpgp/armor/check\n \n-crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files)\n+crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files) strconv.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/error/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/error\n \t$(CHECK)\n .PHONY: crypto/openpgp/error/check\n \n-crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto/md5.gox \\\n-\t\tcrypto/openpgp/error.gox crypto/ripemd160.gox crypto/sha1.gox \\\n-\t\tcrypto/sha256.gox crypto/sha512.gox hash.gox io.gox os.gox\n+crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n+\t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox encoding/binary.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox os.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/packet/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/packet\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/packet/check\n+\n+crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto.gox \\\n+\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/ripemd160.gox \\\n+\t\tcrypto/sha1.gox crypto/sha256.gox crypto/sha512.gox hash.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/s2k/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/s2k\n@@ -2361,6 +2467,15 @@ runtime/pprof/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: runtime/pprof/check\n \n+sync/atomic.lo: $(go_sync_atomic_files)\n+\t$(BUILDPACKAGE)\n+sync/atomic_c.lo: $(go_sync_atomic_c_files) sync/atomic.lo\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/sync/atomic/atomic.c\n+sync/atomic/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) sync/atomic\n+\t$(CHECK)\n+.PHONY: sync/atomic/check\n+\n testing/iotest.lo: $(go_testing_iotest_files) io.gox log.gox os.gox\n \t$(BUILDPACKAGE)\n testing/iotest/check: $(CHECK_DEPS)\n@@ -2410,6 +2525,8 @@ bytes.gox: bytes/bytes.lo\n \t$(BUILDGOX)\n cmath.gox: cmath/cmath.lo\n \t$(BUILDGOX)\n+crypto.gox: crypto/crypto.lo\n+\t$(BUILDGOX)\n ebnf.gox: ebnf/ebnf.lo\n \t$(BUILDGOX)\n exec.gox: exec/exec.lo\n@@ -2470,7 +2587,7 @@ strconv.gox: strconv/strconv.lo\n \t$(BUILDGOX)\n strings.gox: strings/strings.lo\n \t$(BUILDGOX)\n-sync.gox: sync/mutex.lo\n+sync.gox: sync/sync.lo\n \t$(BUILDGOX)\n syslog.gox: syslog/syslog.lo\n \t$(BUILDGOX)\n@@ -2502,10 +2619,14 @@ archive/tar.gox: archive/tar.lo\n archive/zip.gox: archive/zip.lo\n \t$(BUILDGOX)\n \n+compress/bzip2.gox: compress/bzip2.lo\n+\t$(BUILDGOX)\n compress/flate.gox: compress/flate.lo\n \t$(BUILDGOX)\n compress/gzip.gox: compress/gzip.lo\n \t$(BUILDGOX)\n+compress/lzw.gox: compress/lzw.lo\n+\t$(BUILDGOX)\n compress/zlib.gox: compress/zlib.lo\n \t$(BUILDGOX)\n \n@@ -2528,6 +2649,8 @@ crypto/cast5.gox: crypto/cast5.lo\n \t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n+crypto/dsa.gox: crypto/dsa.lo\n+\t$(BUILDGOX)\n crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n@@ -2538,6 +2661,8 @@ crypto/md5.gox: crypto/md5.lo\n \t$(BUILDGOX)\n crypto/ocsp.gox: crypto/ocsp.lo\n \t$(BUILDGOX)\n+crypto/openpgp.gox: crypto/openpgp.lo\n+\t$(BUILDGOX)\n crypto/rand.gox: crypto/rand.lo\n \t$(BUILDGOX)\n crypto/rc4.gox: crypto/rc4.lo\n@@ -2567,6 +2692,8 @@ crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n crypto/openpgp/error.gox: crypto/openpgp/error.lo\n \t$(BUILDGOX)\n+crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n+\t$(BUILDGOX)\n crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n \t$(BUILDGOX)\n \n@@ -2664,6 +2791,9 @@ runtime/debug.gox: runtime/debug.lo\n runtime/pprof.gox: runtime/pprof.lo\n \t$(BUILDGOX)\n \n+sync/atomic.gox: sync/atomic.lo\n+\t$(BUILDGOX)\n+\n testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo\n@@ -2725,8 +2855,10 @@ TEST_PACKAGES = \\\n \txml/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n+\tcompress/lzw/check \\\n \tcompress/zlib/check \\\n \tcontainer/heap/check \\\n \tcontainer/list/check \\\n@@ -2737,11 +2869,13 @@ TEST_PACKAGES = \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n+\tcrypto/dsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n \tcrypto/md5/check \\\n \tcrypto/ocsp/check \\\n+\tcrypto/openpgp/check \\\n \tcrypto/rand/check \\\n \tcrypto/rc4/check \\\n \tcrypto/ripemd160/check \\\n@@ -2755,6 +2889,7 @@ TEST_PACKAGES = \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n \tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n@@ -2787,6 +2922,7 @@ TEST_PACKAGES = \\\n \t$(os_inotify_check) \\\n \tos/signal/check \\\n \trpc/jsonrpc/check \\\n+\tsync/atomic/check \\\n \ttesting/quick/check \\\n \ttesting/script/check\n "}, {"sha": "c9f018791899daf7c45daab636de9f65a5890307", "filename": "libgo/Makefile.in", "status": "modified", "additions": 239, "deletions": 94, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -112,6 +112,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoosdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgorpcdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoruntimedir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgosyncdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotestingdir)\"\n LIBRARIES = $(toolexeclib_LIBRARIES)\n ARFLAGS = cru\n@@ -122,43 +123,45 @@ libgobegin_a_OBJECTS = $(am_libgobegin_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n-\tbytes/bytes.lo bytes/index.lo cmath/cmath.lo ebnf/ebnf.lo \\\n-\texec/exec.lo expvar/expvar.lo flag/flag.lo fmt/fmt.lo \\\n-\tgob/gob.lo hash/hash.lo html/html.lo http/http.lo \\\n+\tbytes/bytes.lo bytes/index.lo cmath/cmath.lo crypto/crypto.lo \\\n+\tebnf/ebnf.lo exec/exec.lo expvar/expvar.lo flag/flag.lo \\\n+\tfmt/fmt.lo gob/gob.lo hash/hash.lo html/html.lo http/http.lo \\\n \timage/image.lo io/io.lo json/json.lo log/log.lo math/math.lo \\\n \tmime/mime.lo net/net.lo netchan/netchan.lo os/os.lo \\\n \tpatch/patch.lo path/path.lo rand/rand.lo reflect/reflect.lo \\\n \tregexp/regexp.lo rpc/rpc.lo runtime/runtime.lo \\\n \tscanner/scanner.lo smtp/smtp.lo sort/sort.lo \\\n-\tstrconv/strconv.lo strings/strings.lo sync/mutex.lo \\\n-\tsync/cas.lo syslog/syslog.lo syslog/syslog_c.lo \\\n-\ttabwriter/tabwriter.lo template/template.lo time/time.lo \\\n-\ttry/try.lo unicode/unicode.lo utf16/utf16.lo utf8/utf8.lo \\\n+\tstrconv/strconv.lo strings/strings.lo sync/sync.lo \\\n+\tsyslog/syslog.lo syslog/syslog_c.lo tabwriter/tabwriter.lo \\\n+\ttemplate/template.lo time/time.lo try/try.lo \\\n+\tunicode/unicode.lo utf16/utf16.lo utf8/utf8.lo \\\n \twebsocket/websocket.lo xml/xml.lo archive/tar.lo \\\n-\tarchive/zip.lo compress/flate.lo compress/gzip.lo \\\n-\tcompress/zlib.lo container/heap.lo container/list.lo \\\n-\tcontainer/ring.lo container/vector.lo crypto/aes.lo \\\n-\tcrypto/block.lo crypto/blowfish.lo crypto/cast5.lo \\\n-\tcrypto/cipher.lo crypto/elliptic.lo crypto/hmac.lo \\\n-\tcrypto/md4.lo crypto/md5.lo crypto/ocsp.lo crypto/rand.lo \\\n+\tarchive/zip.lo compress/bzip2.lo compress/flate.lo \\\n+\tcompress/gzip.lo compress/lzw.lo compress/zlib.lo \\\n+\tcontainer/heap.lo container/list.lo container/ring.lo \\\n+\tcontainer/vector.lo crypto/aes.lo crypto/block.lo \\\n+\tcrypto/blowfish.lo crypto/cast5.lo crypto/cipher.lo \\\n+\tcrypto/dsa.lo crypto/elliptic.lo crypto/hmac.lo crypto/md4.lo \\\n+\tcrypto/md5.lo crypto/ocsp.lo crypto/openpgp.lo crypto/rand.lo \\\n \tcrypto/rc4.lo crypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n \tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n \tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo crypto/openpgp/error.lo \\\n-\tcrypto/openpgp/s2k.lo debug/dwarf.lo debug/elf.lo \\\n-\tdebug/gosym.lo debug/macho.lo debug/pe.lo debug/proc.lo \\\n-\tencoding/ascii85.lo encoding/base32.lo encoding/base64.lo \\\n-\tencoding/binary.lo encoding/git85.lo encoding/hex.lo \\\n-\tencoding/line.lo encoding/pem.lo exp/datafmt.lo exp/draw.lo \\\n-\texp/eval.lo go/ast.lo go/doc.lo go/parser.lo go/printer.lo \\\n-\tgo/scanner.lo go/token.lo go/typechecker.lo hash/adler32.lo \\\n-\thash/crc32.lo hash/crc64.lo http/pprof.lo image/jpeg.lo \\\n-\timage/png.lo index/suffixarray.lo io/ioutil.lo \\\n-\tmime/multipart.lo net/dict.lo net/textproto.lo \\\n+\tcrypto/openpgp/packet.lo crypto/openpgp/s2k.lo debug/dwarf.lo \\\n+\tdebug/elf.lo debug/gosym.lo debug/macho.lo debug/pe.lo \\\n+\tdebug/proc.lo encoding/ascii85.lo encoding/base32.lo \\\n+\tencoding/base64.lo encoding/binary.lo encoding/git85.lo \\\n+\tencoding/hex.lo encoding/line.lo encoding/pem.lo \\\n+\texp/datafmt.lo exp/draw.lo exp/eval.lo go/ast.lo go/doc.lo \\\n+\tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n+\tgo/typechecker.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n+\thttp/pprof.lo image/jpeg.lo image/png.lo index/suffixarray.lo \\\n+\tio/ioutil.lo mime/multipart.lo net/dict.lo net/textproto.lo \\\n \t$(am__DEPENDENCIES_1) os/signal.lo rpc/jsonrpc.lo \\\n-\truntime/debug.lo runtime/pprof.lo syscalls/syscall.lo \\\n-\tsyscalls/errno.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo\n+\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n+\tsync/atomic_c.lo syscalls/syscall.lo syscalls/errno.lo \\\n+\ttesting/testing.lo testing/iotest.lo testing/quick.lo \\\n+\ttesting/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -204,8 +207,7 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/mcache.c runtime/mcentral.c \\\n \truntime/mem_posix_memalign.c runtime/mem.c runtime/mfinal.c \\\n \truntime/mfixalloc.c runtime/mgc0.c runtime/mheap.c \\\n-\truntime/mheapmap32.c runtime/mheapmap64.c runtime/msize.c \\\n-\truntime/proc.c runtime/thread.c \\\n+\truntime/msize.c runtime/proc.c runtime/thread.c \\\n \truntime/rtems-task-variable-add.c chan.c iface.c malloc.c \\\n \tmap.c mprof.c reflect.c sigqueue.c string.c\n @HAVE_SYS_MMAN_H_FALSE@am__objects_1 = mem_posix_memalign.lo\n@@ -237,9 +239,8 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n \tgo-unsafe-pointer.lo go-unwind.lo mcache.lo mcentral.lo \\\n \t$(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo mheap.lo \\\n-\tmheapmap32.lo mheapmap64.lo msize.lo proc.lo thread.lo \\\n-\t$(am__objects_2) chan.lo iface.lo malloc.lo map.lo mprof.lo \\\n-\treflect.lo sigqueue.lo string.lo\n+\tmsize.lo proc.lo thread.lo $(am__objects_2) chan.lo iface.lo \\\n+\tmalloc.lo map.lo mprof.lo reflect.lo sigqueue.lo string.lo\n am_libgo_la_OBJECTS = $(am__objects_3)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -280,7 +281,7 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgomime_DATA) \\\n \t$(toolexeclibgonet_DATA) $(toolexeclibgoos_DATA) \\\n \t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgotesting_DATA)\n+\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -546,6 +547,7 @@ toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n \tcmath.gox \\\n+\tcrypto.gox \\\n \tebnf.gox \\\n \texec.gox \\\n \texpvar.gox \\\n@@ -597,8 +599,10 @@ toolexeclibgoarchive_DATA = \\\n \n toolexeclibgocompressdir = $(toolexeclibgodir)/compress\n toolexeclibgocompress_DATA = \\\n+\tcompress/bzip2.gox \\\n \tcompress/flate.gox \\\n \tcompress/gzip.gox \\\n+\tcompress/lzw.gox \\\n \tcompress/zlib.gox\n \n toolexeclibgocontainerdir = $(toolexeclibgodir)/container\n@@ -615,11 +619,13 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n+\tcrypto/dsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n \tcrypto/md5.gox \\\n \tcrypto/ocsp.gox \\\n+\tcrypto/openpgp.gox \\\n \tcrypto/rand.gox \\\n \tcrypto/rc4.gox \\\n \tcrypto/ripemd160.gox \\\n@@ -637,6 +643,7 @@ toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n \tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n toolexeclibgodebugdir = $(toolexeclibgodir)/debug\n@@ -725,6 +732,10 @@ toolexeclibgoruntime_DATA = \\\n \truntime/debug.gox \\\n \truntime/pprof.gox\n \n+toolexeclibgosyncdir = $(toolexeclibgodir)/sync\n+toolexeclibgosync_DATA = \\\n+\tsync/atomic.gox\n+\n toolexeclibgotestingdir = $(toolexeclibgodir)/testing\n toolexeclibgotesting_DATA = \\\n \ttesting/iotest.gox \\\n@@ -821,8 +832,6 @@ runtime_files = \\\n \truntime/mfixalloc.c \\\n \truntime/mgc0.c \\\n \truntime/mheap.c \\\n-\truntime/mheapmap32.c \\\n-\truntime/mheapmap64.c \\\n \truntime/msize.c \\\n \truntime/proc.c \\\n \truntime/thread.c \\\n@@ -874,6 +883,9 @@ go_cmath_files = \\\n \tgo/cmath/sqrt.go \\\n \tgo/cmath/tan.go\n \n+go_crypto_files = \\\n+\tgo/crypto/crypto.go\n+\n go_ebnf_files = \\\n \tgo/ebnf/ebnf.go \\\n \tgo/ebnf/parser.go\n@@ -918,13 +930,15 @@ go_http_files = \\\n \tgo/http/client.go \\\n \tgo/http/dump.go \\\n \tgo/http/fs.go \\\n+\tgo/http/header.go \\\n \tgo/http/lex.go \\\n \tgo/http/persist.go \\\n \tgo/http/request.go \\\n \tgo/http/response.go \\\n \tgo/http/server.go \\\n \tgo/http/status.go \\\n \tgo/http/transfer.go \\\n+\tgo/http/transport.go \\\n \tgo/http/url.go\n \n go_image_files = \\\n@@ -1051,6 +1065,7 @@ go_os_files = \\\n \tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n \tgo/os/exec.go \\\n+\tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n@@ -1096,8 +1111,6 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n-\tgo/runtime/malloc_defs.go \\\n-\tgo/runtime/runtime_defs.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -1128,12 +1141,11 @@ go_strings_files = \\\n \tgo/strings/strings.go\n \n go_sync_files = \\\n+\tgo/sync/cond.go \\\n \tgo/sync/mutex.go \\\n \tgo/sync/once.go \\\n-\tgo/sync/rwmutex.go\n-\n-go_sync_c_files = \\\n-\tgo/sync/cas.c\n+\tgo/sync/rwmutex.go \\\n+\tgo/sync/waitgroup.go\n \n @LIBGO_IS_SOLARIS_FALSE@go_syslog_file = go/syslog/syslog_unix.go\n @LIBGO_IS_SOLARIS_TRUE@go_syslog_file = go/syslog/syslog_solaris.go\n@@ -1196,6 +1208,12 @@ go_archive_zip_files = \\\n \tgo/archive/zip/reader.go \\\n \tgo/archive/zip/struct.go\n \n+go_compress_bzip2_files = \\\n+\tgo/compress/bzip2/bit_reader.go \\\n+\tgo/compress/bzip2/bzip2.go \\\n+\tgo/compress/bzip2/huffman.go \\\n+\tgo/compress/bzip2/move_to_front.go\n+\n go_compress_flate_files = \\\n \tgo/compress/flate/deflate.go \\\n \tgo/compress/flate/huffman_bit_writer.go \\\n@@ -1209,6 +1227,10 @@ go_compress_gzip_files = \\\n \tgo/compress/gzip/gzip.go \\\n \tgo/compress/gzip/gunzip.go\n \n+go_compress_lzw_files = \\\n+\tgo/compress/lzw/reader.go \\\n+\tgo/compress/lzw/writer.go\n+\n go_compress_zlib_files = \\\n \tgo/compress/zlib/reader.go \\\n \tgo/compress/zlib/writer.go\n@@ -1261,6 +1283,9 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n \n+go_crypto_dsa_files = \\\n+\tgo/crypto/dsa/dsa.go\n+\n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go\n \n@@ -1278,6 +1303,12 @@ go_crypto_md5_files = \\\n go_crypto_ocsp_files = \\\n \tgo/crypto/ocsp/ocsp.go\n \n+go_crypto_openpgp_files = \\\n+\tgo/crypto/openpgp/canonical_text.go \\\n+\tgo/crypto/openpgp/keys.go \\\n+\tgo/crypto/openpgp/read.go \\\n+\tgo/crypto/openpgp/write.go\n+\n go_crypto_rand_files = \\\n \tgo/crypto/rand/rand.go \\\n \tgo/crypto/rand/rand_unix.go\n@@ -1338,6 +1369,20 @@ go_crypto_openpgp_armor_files = \\\n go_crypto_openpgp_error_files = \\\n \tgo/crypto/openpgp/error/error.go\n \n+go_crypto_openpgp_packet_files = \\\n+\tgo/crypto/openpgp/packet/compressed.go \\\n+\tgo/crypto/openpgp/packet/encrypted_key.go \\\n+\tgo/crypto/openpgp/packet/literal.go \\\n+\tgo/crypto/openpgp/packet/one_pass_signature.go \\\n+\tgo/crypto/openpgp/packet/packet.go \\\n+\tgo/crypto/openpgp/packet/private_key.go \\\n+\tgo/crypto/openpgp/packet/public_key.go \\\n+\tgo/crypto/openpgp/packet/reader.go \\\n+\tgo/crypto/openpgp/packet/signature.go \\\n+\tgo/crypto/openpgp/packet/symmetric_key_encrypted.go \\\n+\tgo/crypto/openpgp/packet/symmetrically_encrypted.go \\\n+\tgo/crypto/openpgp/packet/userid.go\n+\n go_crypto_openpgp_s2k_files = \\\n \tgo/crypto/openpgp/s2k/s2k.go\n \n@@ -1484,6 +1529,7 @@ go_net_dict_files = \\\n \tgo/net/dict/dict.go\n \n go_net_textproto_files = \\\n+\tgo/net/textproto/header.go \\\n \tgo/net/textproto/pipeline.go \\\n \tgo/net/textproto/reader.go \\\n \tgo/net/textproto/textproto.go \\\n@@ -1506,6 +1552,12 @@ go_runtime_debug_files = \\\n go_runtime_pprof_files = \\\n \tgo/runtime/pprof/pprof.go\n \n+go_sync_atomic_files = \\\n+\tgo/sync/atomic/doc.go\n+\n+go_sync_atomic_c_files = \\\n+\tgo/sync/atomic/atomic.c\n+\n go_testing_iotest_files = \\\n \tgo/testing/iotest/logger.go \\\n \tgo/testing/iotest/reader.go \\\n@@ -1606,6 +1658,7 @@ libgo_go_objs = \\\n \tbytes/bytes.lo \\\n \tbytes/index.lo \\\n \tcmath/cmath.lo \\\n+\tcrypto/crypto.lo \\\n \tebnf/ebnf.lo \\\n \texec/exec.lo \\\n \texpvar/expvar.lo \\\n@@ -1636,8 +1689,7 @@ libgo_go_objs = \\\n \tsort/sort.lo \\\n \tstrconv/strconv.lo \\\n \tstrings/strings.lo \\\n-\tsync/mutex.lo \\\n-\tsync/cas.lo \\\n+\tsync/sync.lo \\\n \tsyslog/syslog.lo \\\n \tsyslog/syslog_c.lo \\\n \ttabwriter/tabwriter.lo \\\n@@ -1651,8 +1703,10 @@ libgo_go_objs = \\\n \txml/xml.lo \\\n \tarchive/tar.lo \\\n \tarchive/zip.lo \\\n+\tcompress/bzip2.lo \\\n \tcompress/flate.lo \\\n \tcompress/gzip.lo \\\n+\tcompress/lzw.lo \\\n \tcompress/zlib.lo \\\n \tcontainer/heap.lo \\\n \tcontainer/list.lo \\\n@@ -1663,11 +1717,13 @@ libgo_go_objs = \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n+\tcrypto/dsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n \tcrypto/md4.lo \\\n \tcrypto/md5.lo \\\n \tcrypto/ocsp.lo \\\n+\tcrypto/openpgp.lo \\\n \tcrypto/rand.lo \\\n \tcrypto/rc4.lo \\\n \tcrypto/ripemd160.lo \\\n@@ -1682,6 +1738,7 @@ libgo_go_objs = \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n \tcrypto/openpgp/error.lo \\\n+\tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tdebug/dwarf.lo \\\n \tdebug/elf.lo \\\n@@ -1723,6 +1780,8 @@ libgo_go_objs = \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n+\tsync/atomic.lo \\\n+\tsync/atomic_c.lo \\\n \tsyscalls/syscall.lo \\\n \tsyscalls/errno.lo \\\n \ttesting/testing.lo \\\n@@ -1857,8 +1916,10 @@ TEST_PACKAGES = \\\n \txml/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n+\tcompress/lzw/check \\\n \tcompress/zlib/check \\\n \tcontainer/heap/check \\\n \tcontainer/list/check \\\n@@ -1869,11 +1930,13 @@ TEST_PACKAGES = \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n+\tcrypto/dsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n \tcrypto/md5/check \\\n \tcrypto/ocsp/check \\\n+\tcrypto/openpgp/check \\\n \tcrypto/rand/check \\\n \tcrypto/rc4/check \\\n \tcrypto/ripemd160/check \\\n@@ -1887,6 +1950,7 @@ TEST_PACKAGES = \\\n \tcrypto/x509/check \\\n \tcrypto/xtea/check \\\n \tcrypto/openpgp/armor/check \\\n+\tcrypto/openpgp/packet/check \\\n \tcrypto/openpgp/s2k/check \\\n \tdebug/dwarf/check \\\n \tdebug/elf/check \\\n@@ -1919,6 +1983,7 @@ TEST_PACKAGES = \\\n \t$(os_inotify_check) \\\n \tos/signal/check \\\n \trpc/jsonrpc/check \\\n+\tsync/atomic/check \\\n \ttesting/quick/check \\\n \ttesting/script/check\n \n@@ -2146,8 +2211,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mfixalloc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mgc0.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mheap.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mheapmap32.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mheapmap64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mprof.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/msize.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n@@ -2794,20 +2857,6 @@ mheap.lo: runtime/mheap.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mheap.lo `test -f 'runtime/mheap.c' || echo '$(srcdir)/'`runtime/mheap.c\n \n-mheapmap32.lo: runtime/mheapmap32.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mheapmap32.lo -MD -MP -MF $(DEPDIR)/mheapmap32.Tpo -c -o mheapmap32.lo `test -f 'runtime/mheapmap32.c' || echo '$(srcdir)/'`runtime/mheapmap32.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mheapmap32.Tpo $(DEPDIR)/mheapmap32.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/mheapmap32.c' object='mheapmap32.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mheapmap32.lo `test -f 'runtime/mheapmap32.c' || echo '$(srcdir)/'`runtime/mheapmap32.c\n-\n-mheapmap64.lo: runtime/mheapmap64.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mheapmap64.lo -MD -MP -MF $(DEPDIR)/mheapmap64.Tpo -c -o mheapmap64.lo `test -f 'runtime/mheapmap64.c' || echo '$(srcdir)/'`runtime/mheapmap64.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mheapmap64.Tpo $(DEPDIR)/mheapmap64.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/mheapmap64.c' object='mheapmap64.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mheapmap64.lo `test -f 'runtime/mheapmap64.c' || echo '$(srcdir)/'`runtime/mheapmap64.c\n-\n msize.lo: runtime/msize.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT msize.lo -MD -MP -MF $(DEPDIR)/msize.Tpo -c -o msize.lo `test -f 'runtime/msize.c' || echo '$(srcdir)/'`runtime/msize.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/msize.Tpo $(DEPDIR)/msize.Plo\n@@ -3261,6 +3310,26 @@ uninstall-toolexeclibgoruntimeDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoruntimedir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoruntimedir)\" && rm -f $$files\n+install-toolexeclibgosyncDATA: $(toolexeclibgosync_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgosyncdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgosyncdir)\"\n+\t@list='$(toolexeclibgosync_DATA)'; test -n \"$(toolexeclibgosyncdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgosyncdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgosyncdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgosyncDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgosync_DATA)'; test -n \"$(toolexeclibgosyncdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgosyncdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgosyncdir)\" && rm -f $$files\n install-toolexeclibgotestingDATA: $(toolexeclibgotesting_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgotestingdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgotestingdir)\"\n@@ -3598,7 +3667,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -3672,7 +3741,7 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgoosDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotestingDATA\n \n install-html: install-html-recursive\n@@ -3732,6 +3801,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n+\tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotestingDATA\n \n .MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n@@ -3766,7 +3836,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n \tinstall-toolexeclibgoosDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n \tinstall-toolexeclibgotestingDATA installcheck installcheck-am \\\n \tinstalldirs installdirs-am maintainer-clean \\\n \tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n@@ -3790,6 +3860,7 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n \tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n+\tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotestingDATA\n \n \n@@ -3872,14 +3943,20 @@ cmath/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: cmath/check\n \n+crypto/crypto.lo: $(go_crypto_files) hash.gox\n+\t$(BUILDPACKAGE)\n+crypto/check: $(CHECK_DEPS)\n+\t$(CHECK)\n+.PHONY: crypto/check\n+\n ebnf/ebnf.lo: $(go_ebnf_files) container/vector.gox go/scanner.gox \\\n \t\tgo/token.gox os.gox strconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n ebnf/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: ebnf/check\n \n-exec/exec.lo: $(go_exec_files) os.gox strings.gox\n+exec/exec.lo: $(go_exec_files) os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n exec/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -3898,8 +3975,8 @@ flag/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: flag/check\n \n-fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox os.gox reflect.gox strconv.gox \\\n-\t\tstrings.gox unicode.gox utf8.gox\n+fmt/fmt.lo: $(go_fmt_files) bytes.gox io.gox math.gox os.gox reflect.gox \\\n+\t\tstrconv.gox strings.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n fmt/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -3926,10 +4003,10 @@ html/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: html/check\n \n-http/http.lo: $(go_http_files) bufio.gox bytes.gox container/list.gox \\\n-\t\tcontainer/vector.gox crypto/rand.gox crypto/tls.gox \\\n-\t\tencoding/base64.gox fmt.gox io.gox io/ioutil.gox log.gox \\\n-\t\tmime.gox mime/multipart.gox net.gox os.gox path.gox sort.gox \\\n+http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n+\t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n+\t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n+\t\tnet.gox net/textproto.gox os.gox path.gox sort.gox \\\n \t\tstrconv.gox strings.gox sync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n@@ -3948,9 +4025,10 @@ io/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: io/check\n \n-json/json.lo: $(go_json_files) bytes.gox container/vector.gox fmt.gox io.gox \\\n-\t\tmath.gox os.gox reflect.gox runtime.gox strconv.gox \\\n-\t\tstrings.gox unicode.gox utf16.gox utf8.gox\n+json/json.lo: $(go_json_files) bytes.gox container/vector.gox \\\n+\t\tencoding/base64.gox fmt.gox io.gox math.gox os.gox \\\n+\t\treflect.gox runtime.gox strconv.gox strings.gox unicode.gox \\\n+\t\tutf16.gox utf8.gox\n \t$(BUILDPACKAGE)\n json/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -3983,14 +4061,14 @@ net/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: net/check\n \n-netchan/netchan.lo: $(go_netchan_files) gob.gox log.gox net.gox os.gox \\\n+netchan/netchan.lo: $(go_netchan_files) gob.gox io.gox log.gox net.gox os.gox \\\n \t\treflect.gox strconv.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n netchan/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: netchan/check\n \n-os/os.lo: $(go_os_files) sync.gox syscall.gox\n+os/os.lo: $(go_os_files) runtime.gox sync.gox syscall.gox\n \t$(BUILDPACKAGE)\n os/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4078,10 +4156,8 @@ strings/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: strings/check\n \n-sync/mutex.lo: $(go_sync_files) runtime.gox\n+sync/sync.lo: $(go_sync_files) runtime.gox sync/atomic.gox\n \t$(BUILDPACKAGE)\n-sync/cas.lo: $(go_sync_c_files) sync/mutex.lo\n-\t$(LTCOMPILE) -c -o sync/cas.lo $(srcdir)/go/sync/cas.c\n sync/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: sync/check\n@@ -4178,6 +4254,13 @@ archive/zip/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: archive/zip/check\n \n+compress/bzip2.lo: $(go_compress_bzip2_files) bufio.gox io.gox os.gox sort.gox\n+\t$(BUILDPACKAGE)\n+compress/bzip2/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) compress/bzip2\n+\t$(CHECK)\n+.PHONY: compress/bzip2/check\n+\n compress/flate.lo: $(go_compress_flate_files) bufio.gox io.gox math.gox \\\n \t\tos.gox sort.gox strconv.gox\n \t$(BUILDPACKAGE)\n@@ -4194,6 +4277,13 @@ compress/gzip/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: compress/gzip/check\n \n+compress/lzw.lo: $(go_compress_lzw_files) bufio.gox fmt.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+compress/lzw/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) compress/lzw\n+\t$(CHECK)\n+.PHONY: compress/lzw/check\n+\n compress/zlib.lo: $(go_compress_zlib_files) bufio.gox compress/flate.gox \\\n \t\thash.gox hash/adler32.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n@@ -4265,6 +4355,13 @@ crypto/cipher/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/cipher/check\n \n+crypto/dsa.lo: $(go_crypto_dsa_files) big.gox io.gox os.gox\n+\t$(BUILDPACKAGE)\n+crypto/dsa/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/dsa\n+\t$(CHECK)\n+.PHONY: crypto/dsa/check\n+\n crypto/elliptic.lo: $(go_crypto_elliptic_files) big.gox io.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n crypto/elliptic/check: $(CHECK_DEPS)\n@@ -4280,30 +4377,40 @@ crypto/hmac/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/hmac/check\n \n-crypto/md4.lo: $(go_crypto_md4_files) hash.gox os.gox\n+crypto/md4.lo: $(go_crypto_md4_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/md4/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/md4\n \t$(CHECK)\n .PHONY: crypto/md4/check\n \n-crypto/md5.lo: $(go_crypto_md5_files) hash.gox os.gox\n+crypto/md5.lo: $(go_crypto_md5_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/md5/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/md5\n \t$(CHECK)\n .PHONY: crypto/md5/check\n \n-crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto/rsa.gox \\\n+crypto/ocsp.lo: $(go_crypto_ocsp_files) asn1.gox crypto.gox crypto/rsa.gox \\\n \t\tcrypto/sha1.gox crypto/x509.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/ocsp/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ocsp\n \t$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/rand.lo: $(go_crypto_rand_files) crypto/aes.gox io.gox os.gox sync.gox \\\n-\t\ttime.gox\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n+\t\t crypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n+\t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n+\t\thash.gox io.gox os.gox strconv.gox time.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/check\n+\n+crypto/rand.lo: $(go_crypto_rand_files) bufio.gox crypto/aes.gox io.gox \\\n+\t\tos.gox sync.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/rand/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rand\n@@ -4317,36 +4424,36 @@ crypto/rc4/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/rc4/check\n \n-crypto/ripemd160.lo: $(go_crypto_ripemd160_files) hash.gox os.gox\n+crypto/ripemd160.lo: $(go_crypto_ripemd160_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/ripemd160/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/ripemd160\n \t$(CHECK)\n .PHONY: crypto/ripemd160/check\n \n-crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto/sha1.gox \\\n+crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n \t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n \t$(CHECK)\n .PHONY: crypto/rsa/check\n \n-crypto/sha1.lo: $(go_crypto_sha1_files) hash.gox os.gox\n+crypto/sha1.lo: $(go_crypto_sha1_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha1/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha1\n \t$(CHECK)\n .PHONY: crypto/sha1/check\n \n-crypto/sha256.lo: $(go_crypto_sha256_files) hash.gox os.gox\n+crypto/sha256.lo: $(go_crypto_sha256_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha256/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha256\n \t$(CHECK)\n .PHONY: crypto/sha256/check\n \n-crypto/sha512.lo: $(go_crypto_sha512_files) hash.gox os.gox\n+crypto/sha512.lo: $(go_crypto_sha512_files) crypto.gox hash.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/sha512/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/sha512\n@@ -4361,7 +4468,7 @@ crypto/subtle/check: $(CHECK_DEPS)\n .PHONY: crypto/subtle/check\n \n crypto/tls.lo: $(go_crypto_tls_files) big.gox bufio.gox bytes.gox \\\n-\t\tcontainer/list.gox crypto/aes.gox crypto/cipher.gox \\\n+\t\tcontainer/list.gox crypto.gox crypto/aes.gox crypto/cipher.gox \\\n \t\tcrypto/elliptic.gox crypto/hmac.gox crypto/md5.gox \\\n \t\tcrypto/rc4.gox crypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n \t\tcrypto/subtle.gox crypto/rsa.gox crypto/sha1.gox \\\n@@ -4381,8 +4488,8 @@ crypto/twofish/check: $(CHECK_DEPS)\n .PHONY: crypto/twofish/check\n \n crypto/x509.lo: $(go_crypto_x509_files) asn1.gox big.gox container/vector.gox \\\n-\t\tcrypto/rsa.gox crypto/sha1.gox hash.gox os.gox strings.gox \\\n-\t\ttime.gox\n+\t\tcrypto.gox crypto/rsa.gox crypto/sha1.gox hash.gox os.gox \\\n+\t\tstrings.gox time.gox\n \t$(BUILDPACKAGE)\n crypto/x509/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/x509\n@@ -4405,16 +4512,30 @@ crypto/openpgp/armor/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/openpgp/armor/check\n \n-crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files)\n+crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files) strconv.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/error/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/error\n \t$(CHECK)\n .PHONY: crypto/openpgp/error/check\n \n-crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto/md5.gox \\\n-\t\tcrypto/openpgp/error.gox crypto/ripemd160.gox crypto/sha1.gox \\\n-\t\tcrypto/sha256.gox crypto/sha512.gox hash.gox io.gox os.gox\n+crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n+\t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n+\t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n+\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n+\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n+\t\tcrypto/subtle.gox encoding/binary.gox hash.gox io.gox \\\n+\t\tio/ioutil.gox os.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+crypto/openpgp/packet/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/packet\n+\t$(CHECK)\n+.PHONY: crypto/openpgp/packet/check\n+\n+crypto/openpgp/s2k.lo: $(go_crypto_openpgp_s2k_files) crypto.gox \\\n+\t\tcrypto/md5.gox crypto/openpgp/error.gox crypto/ripemd160.gox \\\n+\t\tcrypto/sha1.gox crypto/sha256.gox crypto/sha512.gox hash.gox \\\n+\t\tio.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/s2k/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/s2k\n@@ -4733,6 +4854,15 @@ runtime/pprof/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: runtime/pprof/check\n \n+sync/atomic.lo: $(go_sync_atomic_files)\n+\t$(BUILDPACKAGE)\n+sync/atomic_c.lo: $(go_sync_atomic_c_files) sync/atomic.lo\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/sync/atomic/atomic.c\n+sync/atomic/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) sync/atomic\n+\t$(CHECK)\n+.PHONY: sync/atomic/check\n+\n testing/iotest.lo: $(go_testing_iotest_files) io.gox log.gox os.gox\n \t$(BUILDPACKAGE)\n testing/iotest/check: $(CHECK_DEPS)\n@@ -4777,6 +4907,8 @@ bytes.gox: bytes/bytes.lo\n \t$(BUILDGOX)\n cmath.gox: cmath/cmath.lo\n \t$(BUILDGOX)\n+crypto.gox: crypto/crypto.lo\n+\t$(BUILDGOX)\n ebnf.gox: ebnf/ebnf.lo\n \t$(BUILDGOX)\n exec.gox: exec/exec.lo\n@@ -4837,7 +4969,7 @@ strconv.gox: strconv/strconv.lo\n \t$(BUILDGOX)\n strings.gox: strings/strings.lo\n \t$(BUILDGOX)\n-sync.gox: sync/mutex.lo\n+sync.gox: sync/sync.lo\n \t$(BUILDGOX)\n syslog.gox: syslog/syslog.lo\n \t$(BUILDGOX)\n@@ -4869,10 +5001,14 @@ archive/tar.gox: archive/tar.lo\n archive/zip.gox: archive/zip.lo\n \t$(BUILDGOX)\n \n+compress/bzip2.gox: compress/bzip2.lo\n+\t$(BUILDGOX)\n compress/flate.gox: compress/flate.lo\n \t$(BUILDGOX)\n compress/gzip.gox: compress/gzip.lo\n \t$(BUILDGOX)\n+compress/lzw.gox: compress/lzw.lo\n+\t$(BUILDGOX)\n compress/zlib.gox: compress/zlib.lo\n \t$(BUILDGOX)\n \n@@ -4895,6 +5031,8 @@ crypto/cast5.gox: crypto/cast5.lo\n \t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n+crypto/dsa.gox: crypto/dsa.lo\n+\t$(BUILDGOX)\n crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n@@ -4905,6 +5043,8 @@ crypto/md5.gox: crypto/md5.lo\n \t$(BUILDGOX)\n crypto/ocsp.gox: crypto/ocsp.lo\n \t$(BUILDGOX)\n+crypto/openpgp.gox: crypto/openpgp.lo\n+\t$(BUILDGOX)\n crypto/rand.gox: crypto/rand.lo\n \t$(BUILDGOX)\n crypto/rc4.gox: crypto/rc4.lo\n@@ -4934,6 +5074,8 @@ crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n crypto/openpgp/error.gox: crypto/openpgp/error.lo\n \t$(BUILDGOX)\n+crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n+\t$(BUILDGOX)\n crypto/openpgp/s2k.gox: crypto/openpgp/s2k.lo\n \t$(BUILDGOX)\n \n@@ -5031,6 +5173,9 @@ runtime/debug.gox: runtime/debug.lo\n runtime/pprof.gox: runtime/pprof.lo\n \t$(BUILDGOX)\n \n+sync/atomic.gox: sync/atomic.lo\n+\t$(BUILDGOX)\n+\n testing/iotest.gox: testing/iotest.lo\n \t$(BUILDGOX)\n testing/quick.gox: testing/quick.lo"}, {"sha": "d8d9bba60bc56e977c43213a236af5732360d0e4", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -42,6 +42,10 @@ type File struct {\n \tbodyOffset   int64\n }\n \n+func (f *File) hasDataDescriptor() bool {\n+\treturn f.Flags&0x8 != 0\n+}\n+\n // OpenReader will open the Zip file specified by name and return a Reader.\n func OpenReader(name string) (*Reader, os.Error) {\n \tf, err := os.Open(name, os.O_RDONLY, 0644)\n@@ -93,7 +97,16 @@ func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n \t\t\treturn\n \t\t}\n \t}\n-\tr := io.NewSectionReader(f.zipr, off+f.bodyOffset, int64(f.CompressedSize))\n+\tsize := int64(f.CompressedSize)\n+\tif f.hasDataDescriptor() {\n+\t\tif size == 0 {\n+\t\t\t// permit SectionReader to see the rest of the file\n+\t\t\tsize = f.zipsize - (off + f.bodyOffset)\n+\t\t} else {\n+\t\t\tsize += dataDescriptorLen\n+\t\t}\n+\t}\n+\tr := io.NewSectionReader(f.zipr, off+f.bodyOffset, size)\n \tswitch f.Method {\n \tcase 0: // store (no compression)\n \t\trc = nopCloser{r}\n@@ -103,15 +116,16 @@ func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n \t\terr = UnsupportedMethod\n \t}\n \tif rc != nil {\n-\t\trc = &checksumReader{rc, crc32.NewIEEE(), f.CRC32}\n+\t\trc = &checksumReader{rc, crc32.NewIEEE(), f, r}\n \t}\n \treturn\n }\n \n type checksumReader struct {\n \trc   io.ReadCloser\n \thash hash.Hash32\n-\tsum  uint32\n+\tf    *File\n+\tzipr io.Reader // for reading the data descriptor\n }\n \n func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n@@ -120,7 +134,12 @@ func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n \tif err != os.EOF {\n \t\treturn\n \t}\n-\tif r.hash.Sum32() != r.sum {\n+\tif r.f.hasDataDescriptor() {\n+\t\tif err = readDataDescriptor(r.zipr, r.f); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tif r.hash.Sum32() != r.f.CRC32 {\n \t\terr = ChecksumError\n \t}\n \treturn\n@@ -205,6 +224,18 @@ func readDirectoryHeader(f *File, r io.Reader) (err os.Error) {\n \treturn\n }\n \n+func readDataDescriptor(r io.Reader, f *File) (err os.Error) {\n+\tdefer func() {\n+\t\tif rerr, ok := recover().(os.Error); ok {\n+\t\t\terr = rerr\n+\t\t}\n+\t}()\n+\tread(r, &f.CRC32)\n+\tread(r, &f.CompressedSize)\n+\tread(r, &f.UncompressedSize)\n+\treturn\n+}\n+\n func readDirectoryEnd(r io.ReaderAt, size int64) (d *directoryEnd, err os.Error) {\n \t// look for directoryEndSignature in the last 1k, then in the last 65k\n \tvar b []byte"}, {"sha": "72e8cccfd47dc58c5e33e449cf13772d01cf0b43", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -52,6 +52,15 @@ var tests = []ZipTest{\n \t},\n \t{Name: \"readme.zip\"},\n \t{Name: \"readme.notzip\", Error: FormatError},\n+\t{\n+\t\tName: \"dd.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"filename\",\n+\t\t\t\tContent: []byte(\"This is a test textfile.\\n\"),\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n func TestReader(t *testing.T) {\n@@ -102,16 +111,18 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t}\n \n \t// test invalid checksum\n-\tz.File[0].CRC32++ // invalidate\n-\tr, err := z.File[0].Open()\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tvar b bytes.Buffer\n-\t_, err = io.Copy(&b, r)\n-\tif err != ChecksumError {\n-\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ChecksumError)\n+\tif !z.File[0].hasDataDescriptor() { // skip test when crc32 in dd\n+\t\tz.File[0].CRC32++ // invalidate\n+\t\tr, err := z.File[0].Open()\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\tvar b bytes.Buffer\n+\t\t_, err = io.Copy(&b, r)\n+\t\tif err != ChecksumError {\n+\t\t\tt.Errorf(\"%s: copy error=%v, want %v\", z.File[0].Name, err, ChecksumError)\n+\t\t}\n \t}\n }\n "}, {"sha": "bfe0aae2e9a2ac8ac8fefdc0a242fd59fb4aea6f", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -4,6 +4,7 @@ const (\n \tfileHeaderSignature      = 0x04034b50\n \tdirectoryHeaderSignature = 0x02014b50\n \tdirectoryEndSignature    = 0x06054b50\n+\tdataDescriptorLen        = 12\n )\n \n type FileHeader struct {"}, {"sha": "57b8f20ba7f00a8090e106089a35b73b50a2c261", "filename": "libgo/go/asn1/marshal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fasn1%2Fmarshal.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -317,7 +317,7 @@ func marshalBody(out *forkableWriter, value reflect.Value, params fieldParameter\n \tswitch v := value.(type) {\n \tcase *reflect.BoolValue:\n \t\tif v.Get() {\n-\t\t\treturn out.WriteByte(1)\n+\t\t\treturn out.WriteByte(255)\n \t\t} else {\n \t\t\treturn out.WriteByte(0)\n \t\t}"}, {"sha": "eae5c5ce9754e094ee85e1a92d074ba26d976e88", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -286,7 +286,8 @@ func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error) {\n // returning a slice containing the data up to and including the delimiter.\n // If ReadBytes encounters an error before finding a delimiter,\n // it returns the data read before the error and the error itself (often os.EOF).\n-// ReadBytes returns err != nil if and only if line does not end in delim.\n+// ReadBytes returns err != nil if and only if the returned data does not end in\n+// delim.\n func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {\n \t// Use ReadSlice to look for array,\n \t// accumulating full buffers.\n@@ -332,7 +333,8 @@ func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error) {\n // returning a string containing the data up to and including the delimiter.\n // If ReadString encounters an error before finding a delimiter,\n // it returns the data read before the error and the error itself (often os.EOF).\n-// ReadString returns err != nil if and only if line does not end in delim.\n+// ReadString returns err != nil if and only if the returned data does not end in\n+// delim.\n func (b *Reader) ReadString(delim byte) (line string, err os.Error) {\n \tbytes, e := b.ReadBytes(delim)\n \treturn string(bytes), e\n@@ -383,6 +385,9 @@ func (b *Writer) Flush() os.Error {\n \tif b.err != nil {\n \t\treturn b.err\n \t}\n+\tif b.n == 0 {\n+\t\treturn nil\n+\t}\n \tn, e := b.wr.Write(b.buf[0:b.n])\n \tif n < b.n && e == nil {\n \t\te = io.ErrShortWrite"}, {"sha": "1acd4e05cae3a8c1ec238cda8a3ac881117877bd", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -154,17 +154,20 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error) {\n }\n \n // WriteTo writes data to w until the buffer is drained or an error\n-// occurs. The return value n is the number of bytes written.\n+// occurs. The return value n is the number of bytes written; it always\n+// fits into an int, but it is int64 to match the io.WriterTo interface.\n // Any error encountered during the write is also returned.\n func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error) {\n \tb.lastRead = opInvalid\n-\tfor b.off < len(b.buf) {\n+\tif b.off < len(b.buf) {\n \t\tm, e := w.Write(b.buf[b.off:])\n-\t\tn += int64(m)\n \t\tb.off += m\n+\t\tn = int64(m)\n \t\tif e != nil {\n \t\t\treturn n, e\n \t\t}\n+\t\t// otherwise all bytes were written, by definition of\n+\t\t// Write method in io.Writer\n \t}\n \t// Buffer is now empty; reset.\n \tb.Truncate(0)\n@@ -301,6 +304,36 @@ func (b *Buffer) UnreadByte() os.Error {\n \treturn nil\n }\n \n+// ReadBytes reads until the first occurrence of delim in the input,\n+// returning a slice containing the data up to and including the delimiter.\n+// If ReadBytes encounters an error before finding a delimiter,\n+// it returns the data read before the error and the error itself (often os.EOF).\n+// ReadBytes returns err != nil if and only if the returned data does not end in\n+// delim.\n+func (b *Buffer) ReadBytes(delim byte) (line []byte, err os.Error) {\n+\ti := IndexByte(b.buf[b.off:], delim)\n+\tsize := i + 1\n+\tif i < 0 {\n+\t\tsize = len(b.buf) - b.off\n+\t\terr = os.EOF\n+\t}\n+\tline = make([]byte, size)\n+\tcopy(line, b.buf[b.off:])\n+\tb.off += size\n+\treturn\n+}\n+\n+// ReadString reads until the first occurrence of delim in the input,\n+// returning a string containing the data up to and including the delimiter.\n+// If ReadString encounters an error before finding a delimiter,\n+// it returns the data read before the error and the error itself (often os.EOF).\n+// ReadString returns err != nil if and only if the returned data does not end\n+// in delim.\n+func (b *Buffer) ReadString(delim byte) (line string, err os.Error) {\n+\tbytes, err := b.ReadBytes(delim)\n+\treturn string(bytes), err\n+}\n+\n // NewBuffer creates and initializes a new Buffer using buf as its initial\n // contents.  It is intended to prepare a Buffer to read existing data.  It\n // can also be used to size the internal buffer for writing.  To do that,"}, {"sha": "56a2d927539007b68433df33afb3a5f4f0950b54", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,7 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"os\"\n \t\"rand\"\n \t\"testing\"\n \t\"utf8\"\n@@ -238,7 +239,7 @@ func TestMixedReadsAndWrites(t *testing.T) {\n func TestNil(t *testing.T) {\n \tvar b *Buffer\n \tif b.String() != \"<nil>\" {\n-\t\tt.Errorf(\"expcted <nil>; got %q\", b.String())\n+\t\tt.Errorf(\"expected <nil>; got %q\", b.String())\n \t}\n }\n \n@@ -347,3 +348,38 @@ func TestNext(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var readBytesTests = []struct {\n+\tbuffer   string\n+\tdelim    byte\n+\texpected []string\n+\terr      os.Error\n+}{\n+\t{\"\", 0, []string{\"\"}, os.EOF},\n+\t{\"a\\x00\", 0, []string{\"a\\x00\"}, nil},\n+\t{\"abbbaaaba\", 'b', []string{\"ab\", \"b\", \"b\", \"aaab\"}, nil},\n+\t{\"hello\\x01world\", 1, []string{\"hello\\x01\"}, nil},\n+\t{\"foo\\nbar\", 0, []string{\"foo\\nbar\"}, os.EOF},\n+\t{\"alpha\\nbeta\\ngamma\\n\", '\\n', []string{\"alpha\\n\", \"beta\\n\", \"gamma\\n\"}, nil},\n+\t{\"alpha\\nbeta\\ngamma\", '\\n', []string{\"alpha\\n\", \"beta\\n\", \"gamma\"}, os.EOF},\n+}\n+\n+func TestReadBytes(t *testing.T) {\n+\tfor _, test := range readBytesTests {\n+\t\tbuf := NewBufferString(test.buffer)\n+\t\tvar err os.Error\n+\t\tfor _, expected := range test.expected {\n+\t\t\tvar bytes []byte\n+\t\t\tbytes, err = buf.ReadBytes(test.delim)\n+\t\t\tif string(bytes) != expected {\n+\t\t\t\tt.Errorf(\"expected %q, got %q\", expected, bytes)\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif err != test.err {\n+\t\t\tt.Errorf(\"expected error %v, got %v\", test.err, err)\n+\t\t}\n+\t}\n+}"}, {"sha": "50f0ec836b4bcd377be6c85250e7211cbb5ad1d7", "filename": "libgo/go/compress/bzip2/bit_reader.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbit_reader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bzip2\n+\n+import (\n+\t\"bufio\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// bitReader wraps an io.Reader and provides the ability to read values,\n+// bit-by-bit, from it. Its Read* methods don't return the usual os.Error\n+// because the error handling was verbose. Instead, any error is kept and can\n+// be checked afterwards.\n+type bitReader struct {\n+\tr    byteReader\n+\tn    uint64\n+\tbits uint\n+\terr  os.Error\n+}\n+\n+// bitReader needs to read bytes from an io.Reader. We attempt to cast the\n+// given io.Reader to this interface and, if it doesn't already fit, we wrap in\n+// a bufio.Reader.\n+type byteReader interface {\n+\tReadByte() (byte, os.Error)\n+}\n+\n+func newBitReader(r io.Reader) bitReader {\n+\tbyter, ok := r.(byteReader)\n+\tif !ok {\n+\t\tbyter = bufio.NewReader(r)\n+\t}\n+\treturn bitReader{r: byter}\n+}\n+\n+// ReadBits64 reads the given number of bits and returns them in the\n+// least-significant part of a uint64. In the event of an error, it returns 0\n+// and the error can be obtained by calling Error().\n+func (br *bitReader) ReadBits64(bits uint) (n uint64) {\n+\tfor bits > br.bits {\n+\t\tb, err := br.r.ReadByte()\n+\t\tif err == os.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tbr.err = err\n+\t\t\treturn 0\n+\t\t}\n+\t\tbr.n <<= 8\n+\t\tbr.n |= uint64(b)\n+\t\tbr.bits += 8\n+\t}\n+\n+\t// br.n looks like this (assuming that br.bits = 14 and bits = 6):\n+\t// Bit: 111111\n+\t//      5432109876543210\n+\t//\n+\t//         (6 bits, the desired output)\n+\t//        |-----|\n+\t//        V     V\n+\t//      0101101101001110\n+\t//        ^            ^\n+\t//        |------------|\n+\t//           br.bits (num valid bits)\n+\t//\n+\t// This the next line right shifts the desired bits into the\n+\t// least-significant places and masks off anything above.\n+\tn = (br.n >> (br.bits - bits)) & ((1 << bits) - 1)\n+\tbr.bits -= bits\n+\treturn\n+}\n+\n+func (br *bitReader) ReadBits(bits uint) (n int) {\n+\tn64 := br.ReadBits64(bits)\n+\treturn int(n64)\n+}\n+\n+func (br *bitReader) ReadBit() bool {\n+\tn := br.ReadBits(1)\n+\treturn n != 0\n+}\n+\n+func (br *bitReader) Error() os.Error {\n+\treturn br.err\n+}"}, {"sha": "9e97edec17599fe8c2bf01ae4d253d00f8cf00a2", "filename": "libgo/go/compress/bzip2/bzip2.go", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,390 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package bzip2 implements bzip2 decompression.\n+package bzip2\n+\n+import (\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// There's no RFC for bzip2. I used the Wikipedia page for reference and a lot\n+// of guessing: http://en.wikipedia.org/wiki/Bzip2\n+// The source code to pyflate was useful for debugging:\n+// http://www.paul.sladen.org/projects/pyflate\n+\n+// A StructuralError is returned when the bzip2 data is found to be\n+// syntactically invalid.\n+type StructuralError string\n+\n+func (s StructuralError) String() string {\n+\treturn \"bzip2 data invalid: \" + string(s)\n+}\n+\n+// A reader decompresses bzip2 compressed data.\n+type reader struct {\n+\tbr        bitReader\n+\tsetupDone bool // true if we have parsed the bzip2 header.\n+\tblockSize int  // blockSize in bytes, i.e. 900 * 1024.\n+\teof       bool\n+\tbuf       []byte    // stores Burrows-Wheeler transformed data.\n+\tc         [256]uint // the `C' array for the inverse BWT.\n+\ttt        []uint32  // mirrors the `tt' array in the bzip2 source and contains the P array in the upper 24 bits.\n+\ttPos      uint32    // Index of the next output byte in tt.\n+\n+\tpreRLE      []uint32 // contains the RLE data still to be processed.\n+\tpreRLEUsed  int      // number of entries of preRLE used.\n+\tlastByte    int      // the last byte value seen.\n+\tbyteRepeats uint     // the number of repeats of lastByte seen.\n+\trepeats     uint     // the number of copies of lastByte to output.\n+}\n+\n+// NewReader returns an io.Reader which decompresses bzip2 data from r.\n+func NewReader(r io.Reader) io.Reader {\n+\tbz2 := new(reader)\n+\tbz2.br = newBitReader(r)\n+\treturn bz2\n+}\n+\n+const bzip2FileMagic = 0x425a // \"BZ\"\n+const bzip2BlockMagic = 0x314159265359\n+const bzip2FinalMagic = 0x177245385090\n+\n+// setup parses the bzip2 header.\n+func (bz2 *reader) setup() os.Error {\n+\tbr := &bz2.br\n+\n+\tmagic := br.ReadBits(16)\n+\tif magic != bzip2FileMagic {\n+\t\treturn StructuralError(\"bad magic value\")\n+\t}\n+\n+\tt := br.ReadBits(8)\n+\tif t != 'h' {\n+\t\treturn StructuralError(\"non-Huffman entropy encoding\")\n+\t}\n+\n+\tlevel := br.ReadBits(8)\n+\tif level < '1' || level > '9' {\n+\t\treturn StructuralError(\"invalid compression level\")\n+\t}\n+\n+\tbz2.blockSize = 100 * 1024 * (int(level) - '0')\n+\tbz2.tt = make([]uint32, bz2.blockSize)\n+\treturn nil\n+}\n+\n+func (bz2 *reader) Read(buf []byte) (n int, err os.Error) {\n+\tif bz2.eof {\n+\t\treturn 0, os.EOF\n+\t}\n+\n+\tif !bz2.setupDone {\n+\t\terr = bz2.setup()\n+\t\tbrErr := bz2.br.Error()\n+\t\tif brErr != nil {\n+\t\t\terr = brErr\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tbz2.setupDone = true\n+\t}\n+\n+\tn, err = bz2.read(buf)\n+\tbrErr := bz2.br.Error()\n+\tif brErr != nil {\n+\t\terr = brErr\n+\t}\n+\treturn\n+}\n+\n+func (bz2 *reader) read(buf []byte) (n int, err os.Error) {\n+\t// bzip2 is a block based compressor, except that it has a run-length\n+\t// preprocessing step. The block based nature means that we can\n+\t// preallocate fixed-size buffers and reuse them. However, the RLE\n+\t// preprocessing would require allocating huge buffers to store the\n+\t// maximum expansion. Thus we process blocks all at once, except for\n+\t// the RLE which we decompress as required.\n+\n+\tfor (bz2.repeats > 0 || bz2.preRLEUsed < len(bz2.preRLE)) && n < len(buf) {\n+\t\t// We have RLE data pending.\n+\n+\t\t// The run-length encoding works like this:\n+\t\t// Any sequence of four equal bytes is followed by a length\n+\t\t// byte which contains the number of repeats of that byte to\n+\t\t// include. (The number of repeats can be zero.) Because we are\n+\t\t// decompressing on-demand our state is kept in the reader\n+\t\t// object.\n+\n+\t\tif bz2.repeats > 0 {\n+\t\t\tbuf[n] = byte(bz2.lastByte)\n+\t\t\tn++\n+\t\t\tbz2.repeats--\n+\t\t\tif bz2.repeats == 0 {\n+\t\t\t\tbz2.lastByte = -1\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tbz2.tPos = bz2.preRLE[bz2.tPos]\n+\t\tb := byte(bz2.tPos)\n+\t\tbz2.tPos >>= 8\n+\t\tbz2.preRLEUsed++\n+\n+\t\tif bz2.byteRepeats == 3 {\n+\t\t\tbz2.repeats = uint(b)\n+\t\t\tbz2.byteRepeats = 0\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif bz2.lastByte == int(b) {\n+\t\t\tbz2.byteRepeats++\n+\t\t} else {\n+\t\t\tbz2.byteRepeats = 0\n+\t\t}\n+\t\tbz2.lastByte = int(b)\n+\n+\t\tbuf[n] = b\n+\t\tn++\n+\t}\n+\n+\tif n > 0 {\n+\t\treturn\n+\t}\n+\n+\t// No RLE data is pending so we need to read a block.\n+\n+\tbr := &bz2.br\n+\tmagic := br.ReadBits64(48)\n+\tif magic == bzip2FinalMagic {\n+\t\tbr.ReadBits64(32) // ignored CRC\n+\t\tbz2.eof = true\n+\t\treturn 0, os.EOF\n+\t} else if magic != bzip2BlockMagic {\n+\t\treturn 0, StructuralError(\"bad magic value found\")\n+\t}\n+\n+\terr = bz2.readBlock()\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\treturn bz2.read(buf)\n+}\n+\n+// readBlock reads a bzip2 block. The magic number should already have been consumed.\n+func (bz2 *reader) readBlock() (err os.Error) {\n+\tbr := &bz2.br\n+\tbr.ReadBits64(32) // skip checksum. TODO: check it if we can figure out what it is.\n+\trandomized := br.ReadBits(1)\n+\tif randomized != 0 {\n+\t\treturn StructuralError(\"deprecated randomized files\")\n+\t}\n+\torigPtr := uint(br.ReadBits(24))\n+\n+\t// If not every byte value is used in the block (i.e., it's text) then\n+\t// the symbol set is reduced. The symbols used are stored as a\n+\t// two-level, 16x16 bitmap.\n+\tsymbolRangeUsedBitmap := br.ReadBits(16)\n+\tsymbolPresent := make([]bool, 256)\n+\tnumSymbols := 0\n+\tfor symRange := uint(0); symRange < 16; symRange++ {\n+\t\tif symbolRangeUsedBitmap&(1<<(15-symRange)) != 0 {\n+\t\t\tbits := br.ReadBits(16)\n+\t\t\tfor symbol := uint(0); symbol < 16; symbol++ {\n+\t\t\t\tif bits&(1<<(15-symbol)) != 0 {\n+\t\t\t\t\tsymbolPresent[16*symRange+symbol] = true\n+\t\t\t\t\tnumSymbols++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// A block uses between two and six different Huffman trees.\n+\tnumHuffmanTrees := br.ReadBits(3)\n+\tif numHuffmanTrees < 2 || numHuffmanTrees > 6 {\n+\t\treturn StructuralError(\"invalid number of Huffman trees\")\n+\t}\n+\n+\t// The Huffman tree can switch every 50 symbols so there's a list of\n+\t// tree indexes telling us which tree to use for each 50 symbol block.\n+\tnumSelectors := br.ReadBits(15)\n+\ttreeIndexes := make([]uint8, numSelectors)\n+\n+\t// The tree indexes are move-to-front transformed and stored as unary\n+\t// numbers.\n+\tmtfTreeDecoder := newMTFDecoderWithRange(numHuffmanTrees)\n+\tfor i := range treeIndexes {\n+\t\tc := 0\n+\t\tfor {\n+\t\t\tinc := br.ReadBits(1)\n+\t\t\tif inc == 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tc++\n+\t\t}\n+\t\tif c >= numHuffmanTrees {\n+\t\t\treturn StructuralError(\"tree index too large\")\n+\t\t}\n+\t\ttreeIndexes[i] = uint8(mtfTreeDecoder.Decode(c))\n+\t}\n+\n+\t// The list of symbols for the move-to-front transform is taken from\n+\t// the previously decoded symbol bitmap.\n+\tsymbols := make([]byte, numSymbols)\n+\tnextSymbol := 0\n+\tfor i := 0; i < 256; i++ {\n+\t\tif symbolPresent[i] {\n+\t\t\tsymbols[nextSymbol] = byte(i)\n+\t\t\tnextSymbol++\n+\t\t}\n+\t}\n+\tmtf := newMTFDecoder(symbols)\n+\n+\tnumSymbols += 2 // to account for RUNA and RUNB symbols\n+\thuffmanTrees := make([]huffmanTree, numHuffmanTrees)\n+\n+\t// Now we decode the arrays of code-lengths for each tree.\n+\tlengths := make([]uint8, numSymbols)\n+\tfor i := 0; i < numHuffmanTrees; i++ {\n+\t\t// The code lengths are delta encoded from a 5-bit base value.\n+\t\tlength := br.ReadBits(5)\n+\t\tfor j := 0; j < numSymbols; j++ {\n+\t\t\tfor {\n+\t\t\t\tif !br.ReadBit() {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif br.ReadBit() {\n+\t\t\t\t\tlength--\n+\t\t\t\t} else {\n+\t\t\t\t\tlength++\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif length < 0 || length > 20 {\n+\t\t\t\treturn StructuralError(\"Huffman length out of range\")\n+\t\t\t}\n+\t\t\tlengths[j] = uint8(length)\n+\t\t}\n+\t\thuffmanTrees[i], err = newHuffmanTree(lengths)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\tselectorIndex := 1 // the next tree index to use\n+\tcurrentHuffmanTree := huffmanTrees[treeIndexes[0]]\n+\tbufIndex := 0 // indexes bz2.buf, the output buffer.\n+\t// The output of the move-to-front transform is run-length encoded and\n+\t// we merge the decoding into the Huffman parsing loop. These two\n+\t// variables accumulate the repeat count. See the Wikipedia page for\n+\t// details.\n+\trepeat := 0\n+\trepeat_power := 0\n+\n+\t// The `C' array (used by the inverse BWT) needs to be zero initialised.\n+\tfor i := range bz2.c {\n+\t\tbz2.c[i] = 0\n+\t}\n+\n+\tdecoded := 0 // counts the number of symbols decoded by the current tree.\n+\tfor {\n+\t\tif decoded == 50 {\n+\t\t\tcurrentHuffmanTree = huffmanTrees[treeIndexes[selectorIndex]]\n+\t\t\tselectorIndex++\n+\t\t\tdecoded = 0\n+\t\t}\n+\n+\t\tv := currentHuffmanTree.Decode(br)\n+\t\tdecoded++\n+\n+\t\tif v < 2 {\n+\t\t\t// This is either the RUNA or RUNB symbol.\n+\t\t\tif repeat == 0 {\n+\t\t\t\trepeat_power = 1\n+\t\t\t}\n+\t\t\trepeat += repeat_power << v\n+\t\t\trepeat_power <<= 1\n+\n+\t\t\t// This limit of 2 million comes from the bzip2 source\n+\t\t\t// code. It prevents repeat from overflowing.\n+\t\t\tif repeat > 2*1024*1024 {\n+\t\t\t\treturn StructuralError(\"repeat count too large\")\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif repeat > 0 {\n+\t\t\t// We have decoded a complete run-length so we need to\n+\t\t\t// replicate the last output symbol.\n+\t\t\tfor i := 0; i < repeat; i++ {\n+\t\t\t\tb := byte(mtf.First())\n+\t\t\t\tbz2.tt[bufIndex] = uint32(b)\n+\t\t\t\tbz2.c[b]++\n+\t\t\t\tbufIndex++\n+\t\t\t}\n+\t\t\trepeat = 0\n+\t\t}\n+\n+\t\tif int(v) == numSymbols-1 {\n+\t\t\t// This is the EOF symbol. Because it's always at the\n+\t\t\t// end of the move-to-front list, and nevers gets moved\n+\t\t\t// to the front, it has this unique value.\n+\t\t\tbreak\n+\t\t}\n+\n+\t\t// Since two metasymbols (RUNA and RUNB) have values 0 and 1,\n+\t\t// one would expect |v-2| to be passed to the MTF decoder.\n+\t\t// However, the front of the MTF list is never referenced as 0,\n+\t\t// it's always referenced with a run-length of 1. Thus 0\n+\t\t// doesn't need to be encoded and we have |v-1| in the next\n+\t\t// line.\n+\t\tb := byte(mtf.Decode(int(v - 1)))\n+\t\tbz2.tt[bufIndex] = uint32(b)\n+\t\tbz2.c[b]++\n+\t\tbufIndex++\n+\t}\n+\n+\tif origPtr >= uint(bufIndex) {\n+\t\treturn StructuralError(\"origPtr out of bounds\")\n+\t}\n+\n+\t// We have completed the entropy decoding. Now we can perform the\n+\t// inverse BWT and setup the RLE buffer.\n+\tbz2.preRLE = bz2.tt[:bufIndex]\n+\tbz2.preRLEUsed = 0\n+\tbz2.tPos = inverseBWT(bz2.preRLE, origPtr, bz2.c[:])\n+\tbz2.lastByte = -1\n+\tbz2.byteRepeats = 0\n+\tbz2.repeats = 0\n+\n+\treturn nil\n+}\n+\n+// inverseBWT implements the inverse Burrows-Wheeler transform as described in\n+// http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-124.pdf, section 4.2.\n+// In that document, origPtr is called `I' and c is the `C' array after the\n+// first pass over the data. It's an argument here because we merge the first\n+// pass with the Huffman decoding.\n+//\n+// This also implements the `single array' method from the bzip2 source code\n+// which leaves the output, still shuffled, in the bottom 8 bits of tt with the\n+// index of the next byte in the top 24-bits. The index of the first byte is\n+// returned.\n+func inverseBWT(tt []uint32, origPtr uint, c []uint) uint32 {\n+\tsum := uint(0)\n+\tfor i := 0; i < 256; i++ {\n+\t\tsum += c[i]\n+\t\tc[i] = sum - c[i]\n+\t}\n+\n+\tfor i := range tt {\n+\t\tb := tt[i] & 0xff\n+\t\ttt[c[b]] |= uint32(i) << 8\n+\t\tc[b]++\n+\t}\n+\n+\treturn tt[origPtr] >> 8\n+}"}, {"sha": "156eea83ff22743b358bb8c898e3e47dcf6f834d", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bzip2\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/hex\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestBitReader(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte{0xaa})\n+\tbr := newBitReader(buf)\n+\tif n := br.ReadBits(1); n != 1 {\n+\t\tt.Errorf(\"read 1 wrong\")\n+\t}\n+\tif n := br.ReadBits(1); n != 0 {\n+\t\tt.Errorf(\"read 2 wrong\")\n+\t}\n+\tif n := br.ReadBits(1); n != 1 {\n+\t\tt.Errorf(\"read 3 wrong\")\n+\t}\n+\tif n := br.ReadBits(1); n != 0 {\n+\t\tt.Errorf(\"read 4 wrong\")\n+\t}\n+}\n+\n+func TestBitReaderLarge(t *testing.T) {\n+\tbuf := bytes.NewBuffer([]byte{0x12, 0x34, 0x56, 0x78})\n+\tbr := newBitReader(buf)\n+\tif n := br.ReadBits(32); n != 0x12345678 {\n+\t\tt.Errorf(\"got: %x want: %x\", n, 0x12345678)\n+\t}\n+}\n+\n+func readerFromHex(s string) io.Reader {\n+\tdata, err := hex.DecodeString(s)\n+\tif err != nil {\n+\t\tpanic(\"readerFromHex: bad input\")\n+\t}\n+\treturn bytes.NewBuffer(data)\n+}\n+\n+func decompressHex(s string) (out []byte, err os.Error) {\n+\tr := NewReader(readerFromHex(s))\n+\treturn ioutil.ReadAll(r)\n+}\n+\n+func TestHelloWorldBZ2(t *testing.T) {\n+\tout, err := decompressHex(helloWorldBZ2Hex)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif !bytes.Equal(helloWorld, out) {\n+\t\tt.Errorf(\"got %x, want %x\", out, helloWorld)\n+\t}\n+}\n+\n+func testZeros(t *testing.T, inHex string, n int) {\n+\tout, err := decompressHex(inHex)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\texpected := make([]byte, n)\n+\n+\tif !bytes.Equal(expected, out) {\n+\t\tallZeros := true\n+\t\tfor _, b := range out {\n+\t\t\tif b != 0 {\n+\t\t\t\tallZeros = false\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tt.Errorf(\"incorrect result, got %d bytes (allZeros: %t)\", len(out), allZeros)\n+\t}\n+}\n+\n+func Test32Zeros(t *testing.T) {\n+\ttestZeros(t, thirtyTwoZerosBZ2Hex, 32)\n+}\n+\n+func Test1MBZeros(t *testing.T) {\n+\ttestZeros(t, oneMBZerosBZ2Hex, 1024*1024)\n+}\n+\n+func testRandomData(t *testing.T, compressedHex, uncompressedHex string) {\n+\tout, err := decompressHex(compressedHex)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\texpected, _ := hex.DecodeString(uncompressedHex)\n+\n+\tif !bytes.Equal(out, expected) {\n+\t\tt.Errorf(\"incorrect result\\ngot:  %x\\nwant: %x\", out, expected)\n+\t}\n+}\n+\n+func TestRandomData1(t *testing.T) {\n+\ttestRandomData(t, randBZ2Hex, randHex)\n+}\n+\n+func TestRandomData2(t *testing.T) {\n+\t// This test involves several repeated bytes in the output, but they\n+\t// should trigger RLE decoding.\n+\ttestRandomData(t, rand2BZ2Hex, rand2Hex)\n+}\n+\n+func TestRandomData3(t *testing.T) {\n+\t// This test uses the full range of symbols.\n+\ttestRandomData(t, rand3BZ2Hex, rand3Hex)\n+}\n+\n+func Test1MBSawtooth(t *testing.T) {\n+\tout, err := decompressHex(oneMBSawtoothBZ2Hex)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\n+\texpected := make([]byte, 1024*1024)\n+\n+\tfor i := range expected {\n+\t\texpected[i] = byte(i)\n+\t}\n+\n+\tif !bytes.Equal(out, expected) {\n+\t\tt.Error(\"incorrect result\")\n+\t}\n+}\n+\n+const helloWorldBZ2Hex = \"425a68393141592653594eece83600000251800010400006449080200031064c4101a7a9a580bb9431f8bb9229c28482776741b0\"\n+\n+var helloWorld = []byte(\"hello world\\n\")\n+\n+const thirtyTwoZerosBZ2Hex = \"425a6839314159265359b5aa5098000000600040000004200021008283177245385090b5aa5098\"\n+const oneMBZerosBZ2Hex = \"425a683931415926535938571ce50008084000c0040008200030cc0529a60806c4201e2ee48a70a12070ae39ca\"\n+\n+const randBZ2Hex = \"425a6839314159265359905d990d0001957fffffffffffafffffffffffffffffbfff6fffdfffffffffffffffffffffffffffffc002b6dd75676ed5b77720098320d11a64626981323d4da47a83131a13d09e8040f534cd4f4d27a464d193008cd09804601347a980026350c9886234d36864193d1351b44c136919e90340d26127a4cd264c32023009898981310c0344c340027a8303427a99a04c00003534c230d034f5006468d268cf54d36a3009a69a62626261311b40026013d34201a6934c9a604c98ca6c8460989fa9346234d30d3469a2604fd4131a7aa6d0046043d4c62098479269e89e835190d018d4c046001a11e801a0264792321932308c43a130688c260d46686804cd01a9e80981193684c6a68c00000004c4c20c04627a4c0000260003400d04c0681a01334026009a6f48041466132581ec5212b081d96b0effc16543e2228b052fcd30f2567ee8d970e0f10aabca68dd8270591c376cfc1baae0dba00aaff2d6caf6b211322c997cc18eaee5927f75185336bf907021324c71626c1dd20e22b9b0977f05d0f901eaa51db9fbaf7c603b4c87bc82890e6dd7e61d0079e27ec050dd788fd958152061cd01e222f9547cb9efc465d775b6fc98bac7d387bffd151ae09dadf19494f7a638e2eae58e550faba5fe6820ea520eb986096de4e527d80def3ba625e71fbefdcf7e7844e0a25d29b52dcd1344fca083737d42692aab38d230485f3c8ed54c2ed31f15cf0270c8143765b10b92157233fa1dfe0d7ce8ffe70b8b8f7250071701dfe9f1c94de362c9031455951c93eb098a6b50ee45c6131fefc3b6f9643e21f4adc59497138e246f5c57d834aa67c4f10d8bd8b3908d8130dd7388409c299a268eab3664fa4907c5c31574874bd8d388a4ab22b339660804e53e1b8d05867d40e3082560608d35d5d2c6054e8bab23da28f61f83efd41d25529ad6ea15fb50505cacfabb0902166427354ca3830a2c8415f21b19e592690fbe447020d685a4bcd16ecc4ff1a1c0e572627d0ef6265c008a43fc243240541061ed7840606be466d1c0dac2c53250ed567507d926c844154560d631960c65e15157829b2c7f16859f111a3a8cb72bf24ffa57a680c3be67b1be67c8dd8aea73ac2437a78df5b686d427080ebc01bd30b71a49f6ea31dc0f08e4849e38face96717690239538bc08b6cc5aa8d467cb9c36aa83d40ac7e58bddbfa185b22065e89a86c0145569d9e23726651aec49e31588d70f40fe9a4449dcf4f89eac220171e9c938e803dc195679651004b79ad33cc0c13aeeba5941b33ffeeb8fbe16e76c7811445c67b4269c90479433ddf9e8ed1d00c166b6c17217fb22c3ef1b0c1c7e28e185446a111c37f1ea6c07a59fbcc6546ecc6968d36ba58bc5489a5640647e426b0c39350cb6f07d5dc7a717648c4ec7f841467597ae1f65f408fd2d9940a4b1b860b3c9ae351dcae0b4425f7e8538710f2e40b7f70d13b51ac05ccc6ecda8264a88cad2d721d18132a9b9110a9e759c2483c77dcefc7e464ec88588174cb0c9abff93230ea0bed8decdd8ed8bfe2b5df0a253803678df04fab44c03b9ab7cc97d6e6d6fd0c4c840ce0efc498436f453bbb181603459471f2b588724592b222ec990614db530e10cadd84705621cfdd9261fa44a5f5806a2d74b575056b3c915255c65678f9c16e6dc00a99180fef1a840aff0e842ac02731080cc92782538360a60a727991013984da4fad95f79d5030677b7528d076b2483685fca4429edf804682fdc110dfc2f7c30e23e20a72e039108a0ad6fdee2f76985a4b4be4f5afc6101bf9d5042b657a05dc914e1424241766434\"\n+const randHex = \"c95138082bdf2b9bfa5b1072b23f729735d42c785eeb94320fb14c265b9c2ca421d01a3db986df1ac2acde5a0e6bf955d6f95e61261540905928e195f1a66644cc7f37281744fff4dc6df35566a494c41a8167151950eb74f5fc45f85ad0e5ed28b49adfe218aa7ec1707e8e1d55825f61f72beda3b4c006b8c9188d7336a5d875329b1b58c27cc4e89ecbae02c7712400c39dd131d2c6de82e2863da51d472bdfb21ecce62cc9cf769ed28aedc7583d755da45a0d90874bda269dd53283a9bdfd05f95fc8e9a304bb338ea1a2111894678c18134f17d31a15d9bfc1237894650f3e715e2548639ecbddb845cfe4a46a7b3a3c540f48629488e8c869f1e9f3f4c552243a8105b20eb8e264994214349dae83b165fd6c2a5b8e83fce09fc0a80d3281c8d53a9a08095bd19cbc1388df23975646ed259e003d39261ee68cbece8bcf32971f7fe7e588e8ba8f5e8597909abaea693836a79a1964050ed910a45a0f13a58cd2d3ae18992c5b23082407fd920d0bf01e33118a017bb5e39f44931346845af52128f7965206759433a346034ea481671f501280067567619f5ecef6cded077f92ed7f3b3ce8e308c80f34ba06939e9303f91b4318c8c1dd4cc223c1f057ac0c91211c629cd30e46ee9ec1d9fd493086b7bc2bc83e33f08749a5d430b0ed4f79d70f481940c9b0930b16321886a0df4fa5a1465d5208c7d3494a7987d9a5e42aa256f0c9523947f8318d0ef0af3d59a45cfc2418d0785c9a548b32b81e7de18be7d55a69a4c156bbb3d7579c0ac8e9c72b24646e54b0d0e8725f8f49fb44ae3c6b9d0287be118586255a90a4a83483ed0328518037e52aa959c5748ed83e13023e532306be98b8288da306bbb040bcf5d92176f84a9306dc6b274b040370b61d71fde58dd6d20e6fee348eae0c54bd0a5a487b2d005f329794f2a902c296af0a4c1f638f63292a1fa18e006c1b1838636f4de71c73635b25660d32e88a0917e1a5677f6a02ca65585b82cbd99fb4badbfa97a585da1e6cadf6737b4ec6ca33f245d66ee6a9fae6785d69b003c17b9fc6ec34fe5824ab8caae5e8e14dc6f9e116e7bf4a60c04388783c8ae929e1b46b3ef3bbe81b38f2fa6da771bf39dfba2374d3d2ed356b8e2c42081d885a91a3afb2f31986d2f9873354c48cf5448492c32e62385af423aa4f83db6d1b2669650379a1134b0a04cbca0862d6f9743c791cbb527d36cd5d1f0fc7f503831c8bd1b7a0ef8ae1a5ed1155dfdd9e32b6bb33138112d3d476b802179cb85a2a6c354ccfed2f31604fbd8d6ec4baf9f1c8454f72c6588c06a7df3178c43a6970bfa02dd6f74cb5ec3b63f9eddaa17db5cbf27fac6de8e57c384afd0954179f7b5690c3bee42abc4fa79b4b12101a9cf5f0b9aecdda945def0bd04163237247d3539850e123fe18139f316fa0256d5bd2faa8\"\n+\n+const oneMBSawtoothBZ2Hex = \"425a683931415926535971931ea00006ddffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe007de00000000000000024c00130001300000000000000000000000000000000000000000000000000000000126000980009800000000000000000000000000000000000000000000000000000000930004c0004c000000000000000000000000000000000000000000000000000000004980026000260000000000000000000000000000000000000000000000000000000009aaaaa0000000000000000000000000000000000000000000000000000000000000000498002600026000000000000000000000000000000000000000000000000000000007fc42271980d044c0a822607411304a08982d044c1a82260f411308a08984d044c2a82261741130ca08986d044c3a82261f411310a08988d044c4a822627411314a0898ad044c5a82262f411318a0898cd044c6a82263741131ca0898ed044c7a82263f411320a08990d044c8a822647411324a08992d044c9a82264f411328a08994d044caa82265741132ca08996d044cba82265f411330a08998d044cca822667411334a0899ad044cda82266f411338a0899cd044cea82267741133ca0899ed044cfa82267f411340a089a0d044d0a822687411344a089a2d044d1a82268f411348a089a4d044d2a82269741134ca089a6d044d3a82269f411350a089a8d044d4a8226a7411354a089aad044d5a8226af411358a089acd044d6a8226b741135ca089aed044d7a8226bf411360a089b0d044d8a8226c7411364a089b2d044d9a8226cf411368a089b4d044daa8226d741136ca089b6d044dba8226df411370a089b8d044dca8226e7411374a089bad044dda8226ef411378a089bcd044dea8226f741137ca089bed044dfa8226ff411380a089c0d044e0a822707411384a089c2d044e1a82270f411388a089c4d044e2a82271741138ca089c59089c69089c71089c79089c81089c89089c91089c99089ca1089ca9089cb1089cb9089cc1089cc9089cd1089cd9089ce1089ce9089cf1089cf9089d01089d09089d11089d19089d21089d29089d31089d39089d41089d49089d51089d59089d61089d69089d71089d79089d81089d89089d91089d99089da1089da9089db1089db9089dc1089dc9089dd1089dd9089de1089de9089df1089df9089e01089e09089e11089e19089e21089e29089e31089e39089e41089e49089e51089e59089e61089e69089e71089e79089e81089e89089e91089e99089ea1089ea9089eb1089eb9089ec1089ec9089ed1089ed9089ee1089ee9089ef1089ef9089f01089f09089f11089f19089f21089f29089f31089f39089f41089f49089f51089f59089f61089f69089f71089f79089f81089f89089f91089f99089fa1089fa9089fb1089fb9089fc1089fc9089fd1089fd9089fe1089fe9089ff1089ff98a0ac9329acf23ba884804fdd3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0034f800000000000024c00130001300000000000000000000000000000000000000000000000000000000126000980009800000000000000000000000000000000000000000000000000000000930004c0004c000000000000000000000000000000000000000000000000000000004980026000260000000000000000000000000000000000000000000000000000000024c0013000130000000000000000000000000000000000000000000000000000000002955540000000000000000000000000000000000000000000000000000000000000001ff108c00846024230221181908c108460a4230621183908c20846124230a21185908c308461a4230e21187908c40846224231221189908c508462a423162118b908c60846324231a2118d908c708463a4231e2118f908c80846424232221191908c908464a4232621193908ca0846524232a21195908cb08465a4232e21197908cc0846624233221199908cd08466a423362119b908ce0846724233a2119d908cf08467a4233e2119f908d008468242342211a1908d108468a42346211a3908d20846924234a211a5908d308469a4234e211a7908d40846a242352211a9908d50846aa42356211ab908d60846b24235a211ad908d70846ba4235e211af908d80846c242362211b1908d90846ca42366211b3908da0846d24236a211b5908db0846da4236e211b7908dc0846e242372211b9908dd0846ea42376211bb908de0846f24237a211bd908df0846fa4237e211bf908e008470242382211c1908e108470a42386211c3908e20847124238a211c5908e2f8c211c6c8471d211c7c84721211c8c84725211c9c84729211cac8472d211cbc84731211ccc84735211cdc84739211cec8473d211cfc84741211d0c84745211d1c84749211d2c8474d211d3c84751211d4c84755211d5c84759211d6c8475d211d7c84761211d8c84765211d9c84769211dac8476d211dbc84771211dcc84775211ddc84779211dec8477d211dfc84781211e0c84785211e1c84789211e2c8478d211e3c84791211e4c84795211e5c84799211e6c8479d211e7c847a1211e8c847a5211e9c847a9211eac847ad211ebc847b1211ecc847b5211edc847b9211eec847bd211efc847c1211f0c847c5211f1c847c9211f2c847cd211f3c847d1211f4c847d5211f5c847d9211f6c847dd211f7c847e1211f8c847e5211f9c847e9211fac847ed211fbc847f1211fcc847f5211fdc847f9211fec847fd211ff8bb9229c284803a8b6248\"\n+\n+const rand2BZ2Hex = \"425a6839314159265359d992d0f60000137dfe84020310091c1e280e100e042801099210094806c0110002e70806402000546034000034000000f2830000032000d3403264049270eb7a9280d308ca06ad28f6981bee1bf8160727c7364510d73a1e123083421b63f031f63993a0f40051fbf177245385090d992d0f60\"\n+const rand2Hex = \"92d5652616ac444a4a04af1a8a3964aca0450d43d6cf233bd03233f4ba92f8719e6c2a2bd4f5f88db07ecd0da3a33b263483db9b2c158786ad6363be35d17335ba\"\n+\n+const rand3BZ2Hex = \"425a68393141592653593be669d00000327ffffffffffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffffc002b3b2b1b6e2bae400004c00132300004c0d268c004c08c0130026001a008683234c0684c34008c230261a04c0260064d07a8d00034000d27a1268c9931a8d327a3427a41faa69ea0da264c1a34219326869b51b49a6469a3268c689fa53269a62794687a9a68f5189994c9e487a8f534fd49a3d34043629e8c93d04da4f4648d30d4f44d3234c4d3023d0840680984d309934c234d3131a000640984f536a6132601300130130c8d00d04d1841ea7a8d31a02609b40023460010c01a34d4c1a0d04d3069306810034d0d0d4c0046130d034d0131a9a64d321804c68003400098344c13000991808c0001a00000000098004d3d4da4604c47a13012140aadf8d673c922c607ef6212a8c0403adea4b28aee578900e653b9cdeb8d11e6b838815f3ebaad5a01c5408d84a332170aff8734d4e06612d3c2889f31925fb89e33561f5100ae89b1f7047102e729373d3667e58d73aaa80fa7be368a1cc2dadd81d81ec8e1b504bd772ca31d03649269b01ceddaca07bf3d4eba24de141be3f86f93601e03714c0f64654671684f9f9528626fd4e1b76753dc0c54b842486b8d59d8ab314e86ca818e7a1f079463cbbd70d9b79b283c7edc419406311022e4be98c2c1374df9cdde2d008ce1d00e5f06ad1024baf555631f70831fc1023034e62be7c4bcb648caf276963ffa20e96bb50377fe1c113da0db4625b50741c35a058edb009c6ee5dbf93b8a6b060eec568180e8db791b82aab96cbf4326ca98361461379425ba8dcc347be670bdba7641883e5526ae3d833f6e9cb9bac9557747c79e206151072f7f0071dff3880411846f66bf4075c7462f302b53cb3400a74cf35652ad5641ed33572fd54e7ed7f85f58a0acba89327e7c6be5c58cb71528b99df2431f1d0358f8d28d81d95292da631fb06701decabb205fac59ff0fb1df536afc681eece6ea658c4d9eaa45f1342aa1ff70bdaff2ddaf25ec88c22f12829a0553db1ec2505554cb17d7b282e213a5a2aa30431ded2bce665bb199d023840832fedb2c0c350a27291407ff77440792872137df281592e82076a05c64c345ffb058c64f7f7c207ef78420b7010520610f17e302cc4dfcfaef72a0ed091aab4b541eb0531bbe941ca2f792bf7b31ca6162882b68054a8470115bc2c19f2df2023f7800432b39b04d3a304e8085ba3f1f0ca5b1ba4d38d339e6084de979cdea6d0e244c6c9fa0366bd890621e3d30846f5e8497e21597b8f29bbf52c961a485dfbea647600da0fc1f25ce4d203a8352ece310c39073525044e7ac46acf2ed9120bae1b4f6f02364abfe343f80b290983160c103557af1c68416480d024cc31b6c06cfec011456f1e95c420a12b48b1c3fe220c2879a982fb099948ac440db844b9a112a5188c7783fd3b19593290785f908d95c9db4b280bafe89c1313aeec24772046d9bc089645f0d182a21184e143823c5f52de50e5d7e98d3d7ab56f5413bbccd1415c9bcff707def475b643fb7f29842582104d4cc1dbaaca8f10a2f44273c339e0984f2b1e06ab2f0771db01fafa8142298345f3196f23e5847bda024034b6f59b11c29e981c881456e40d211929fd4f766200258aad8212016322bd5c605790dcfdf1bd2a93d99c9b8f498722d311d7eae7ff420496a31804c55f4759a7b13aaaf5f7ce006c3a8a998897d5e0a504398c2b627852545baf440798bcc5cc049357cf3f17d9771e4528a1af3d77dc794a11346e1bdf5efe37a405b127b4c43b616d61fbc5dc914e14240ef99a7400\"\n+const rand3Hex = \"1744b384d68c042371244e13500d4bfb98c6244e3d71a5b700224420b59c593553f33bd786e3d0ce31626f511bc985f59d1a88aa38ba8ad6218d306abee60dd9172540232b95be1af146c69e72e5fde667a090dc3f93bdc5c5af0ab80acdbaa7a505f628c59dc0247b31a439cacf5010a94376d71521df08c178b02fb96fdb1809144ea38c68536187c53201fea8631fb0a880b4451ccdca7cc61f6aafca21cc7449d920599db61789ac3b1e164b3390124f95022aeea39ccca3ec1053f4fa10de2978e2861ea58e477085c2220021a0927aa94c5d0006b5055abba340e4f9eba22e969978dfd18e278a8b89d877328ae34268bc0174cfe211954c0036f078025217d1269fac1932a03b05a0b616012271bbe1fb554171c7a59b196d8a4479f45a77931b5d97aaf6c0c673cbe597b79b96e2a0c1eae2e66e46ccc8c85798e23ffe972ebdaa3f6caea243c004e60321eb47cd79137d78fd0613be606feacc5b3637bdc96a89c13746db8cad886f3ccf912b2178c823bcac395f06d28080269bdca2debf3419c66c690fd1adcfbd53e32e79443d7a42511a84cb22ca94fffad9149275a075b2f8ae0b021dcde9bf62b102db920733b897560518b06e1ad7f4b03458493ddaa7f4fa2c1609f7a1735aeeb1b3e2cea3ab45fc376323cc91873b7e9c90d07c192e38d3f5dfc9bfab1fd821c854da9e607ea596c391c7ec4161c6c4493929a8176badaa5a5af7211c623f29643a937677d3df0da9266181b7c4da5dd40376db677fe8f4a1dc456adf6f33c1e37cec471dd318c2647644fe52f93707a77da7d1702380a80e14cc0fdce7bf2eed48a529090bae0388ee277ce6c7018c5fb00b88362554362205c641f0d0fab94fd5b8357b5ff08b207fee023709bc126ec90cfb17c006754638f8186aaeb1265e80be0c1189ec07d01d5f6f96cb9ce82744147d18490de7dc72862f42f024a16968891a356f5e7e0e695d8c933ba5b5e43ad4c4ade5399bc2cae9bb6189b7870d7f22956194d277f28b10e01c10c6ffe3e065f7e2d6d056aa790db5649ca84dc64c35566c0af1b68c32b5b7874aaa66467afa44f40e9a0846a07ae75360a641dd2acc69d93219b2891f190621511e62a27f5e4fbe641ece1fa234fc7e9a74f48d2a760d82160d9540f649256b169d1fed6fbefdc491126530f3cbad7913e19fbd7aa53b1e243fbf28d5f38c10ebd77c8b986775975cc1d619efb27cdcd733fa1ca36cffe9c0a33cc9f02463c91a886601fd349efee85ef1462065ef9bd2c8f533220ad93138b8382d5938103ab25b2d9af8ae106e1211eb9b18793fba033900c809c02cd6d17e2f3e6fc84dae873411f8e87c3f0a8f1765b7825d185ce3730f299c3028d4a62da9ee95c2b870fb70c79370d485f9d5d9acb78926d20444033d960524d2776dc31988ec7c0dbf23b9905d\""}, {"sha": "732bc4a21da1617a1773504f2a2178686ff0be3d", "filename": "libgo/go/compress/bzip2/huffman.go", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bzip2\n+\n+import (\n+\t\"os\"\n+\t\"sort\"\n+)\n+\n+// A huffmanTree is a binary tree which is navigated, bit-by-bit to reach a\n+// symbol.\n+type huffmanTree struct {\n+\t// nodes contains all the non-leaf nodes in the tree. nodes[0] is the\n+\t// root of the tree and nextNode contains the index of the next element\n+\t// of nodes to use when the tree is being constructed.\n+\tnodes    []huffmanNode\n+\tnextNode int\n+}\n+\n+// A huffmanNode is a node in the tree. left and right contain indexes into the\n+// nodes slice of the tree. If left or right is invalidNodeValue then the child\n+// is a left node and its value is in leftValue/rightValue.\n+//\n+// The symbols are uint16s because bzip2 encodes not only MTF indexes in the\n+// tree, but also two magic values for run-length encoding and an EOF symbol.\n+// Thus there are more than 256 possible symbols.\n+type huffmanNode struct {\n+\tleft, right           uint16\n+\tleftValue, rightValue uint16\n+}\n+\n+// invalidNodeValue is an invalid index which marks a leaf node in the tree.\n+const invalidNodeValue = 0xffff\n+\n+// Decode reads bits from the given bitReader and navigates the tree until a\n+// symbol is found.\n+func (t huffmanTree) Decode(br *bitReader) (v uint16) {\n+\tnodeIndex := uint16(0) // node 0 is the root of the tree.\n+\n+\tfor {\n+\t\tnode := &t.nodes[nodeIndex]\n+\t\tbit := br.ReadBit()\n+\t\t// bzip2 encodes left as a true bit.\n+\t\tif bit {\n+\t\t\t// left\n+\t\t\tif node.left == invalidNodeValue {\n+\t\t\t\treturn node.leftValue\n+\t\t\t}\n+\t\t\tnodeIndex = node.left\n+\t\t} else {\n+\t\t\t// right\n+\t\t\tif node.right == invalidNodeValue {\n+\t\t\t\treturn node.rightValue\n+\t\t\t}\n+\t\t\tnodeIndex = node.right\n+\t\t}\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// newHuffmanTree builds a Huffman tree from a slice containing the code\n+// lengths of each symbol. The maximum code length is 32 bits.\n+func newHuffmanTree(lengths []uint8) (huffmanTree, os.Error) {\n+\t// There are many possible trees that assign the same code length to\n+\t// each symbol (consider reflecting a tree down the middle, for\n+\t// example). Since the code length assignments determine the\n+\t// efficiency of the tree, each of these trees is equally good. In\n+\t// order to minimise the amount of information needed to build a tree\n+\t// bzip2 uses a canonical tree so that it can be reconstructed given\n+\t// only the code length assignments.\n+\n+\tif len(lengths) < 2 {\n+\t\tpanic(\"newHuffmanTree: too few symbols\")\n+\t}\n+\n+\tvar t huffmanTree\n+\n+\t// First we sort the code length assignments by ascending code length,\n+\t// using the symbol value to break ties.\n+\tpairs := huffmanSymbolLengthPairs(make([]huffmanSymbolLengthPair, len(lengths)))\n+\tfor i, length := range lengths {\n+\t\tpairs[i].value = uint16(i)\n+\t\tpairs[i].length = length\n+\t}\n+\n+\tsort.Sort(pairs)\n+\n+\t// Now we assign codes to the symbols, starting with the longest code.\n+\t// We keep the codes packed into a uint32, at the most-significant end.\n+\t// So branches are taken from the MSB downwards. This makes it easy to\n+\t// sort them later.\n+\tcode := uint32(0)\n+\tlength := uint8(32)\n+\n+\tcodes := huffmanCodes(make([]huffmanCode, len(lengths)))\n+\tfor i := len(pairs) - 1; i >= 0; i-- {\n+\t\tif length > pairs[i].length {\n+\t\t\t// If the code length decreases we shift in order to\n+\t\t\t// zero any bits beyond the end of the code.\n+\t\t\tlength >>= 32 - pairs[i].length\n+\t\t\tlength <<= 32 - pairs[i].length\n+\t\t\tlength = pairs[i].length\n+\t\t}\n+\t\tcodes[i].code = code\n+\t\tcodes[i].codeLen = length\n+\t\tcodes[i].value = pairs[i].value\n+\t\t// We need to 'increment' the code, which means treating |code|\n+\t\t// like a |length| bit number.\n+\t\tcode += 1 << (32 - length)\n+\t}\n+\n+\t// Now we can sort by the code so that the left half of each branch are\n+\t// grouped together, recursively.\n+\tsort.Sort(codes)\n+\n+\tt.nodes = make([]huffmanNode, len(codes))\n+\t_, err := buildHuffmanNode(&t, codes, 0)\n+\treturn t, err\n+}\n+\n+// huffmanSymbolLengthPair contains a symbol and its code length.\n+type huffmanSymbolLengthPair struct {\n+\tvalue  uint16\n+\tlength uint8\n+}\n+\n+// huffmanSymbolLengthPair is used to provide an interface for sorting.\n+type huffmanSymbolLengthPairs []huffmanSymbolLengthPair\n+\n+func (h huffmanSymbolLengthPairs) Len() int {\n+\treturn len(h)\n+}\n+\n+func (h huffmanSymbolLengthPairs) Less(i, j int) bool {\n+\tif h[i].length < h[j].length {\n+\t\treturn true\n+\t}\n+\tif h[i].length > h[j].length {\n+\t\treturn false\n+\t}\n+\tif h[i].value < h[j].value {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func (h huffmanSymbolLengthPairs) Swap(i, j int) {\n+\th[i], h[j] = h[j], h[i]\n+}\n+\n+// huffmanCode contains a symbol, its code and code length.\n+type huffmanCode struct {\n+\tcode    uint32\n+\tcodeLen uint8\n+\tvalue   uint16\n+}\n+\n+// huffmanCodes is used to provide an interface for sorting.\n+type huffmanCodes []huffmanCode\n+\n+func (n huffmanCodes) Len() int {\n+\treturn len(n)\n+}\n+\n+func (n huffmanCodes) Less(i, j int) bool {\n+\treturn n[i].code < n[j].code\n+}\n+\n+func (n huffmanCodes) Swap(i, j int) {\n+\tn[i], n[j] = n[j], n[i]\n+}\n+\n+// buildHuffmanNode takes a slice of sorted huffmanCodes and builds a node in\n+// the Huffman tree at the given level. It returns the index of the newly\n+// constructed node.\n+func buildHuffmanNode(t *huffmanTree, codes []huffmanCode, level uint32) (nodeIndex uint16, err os.Error) {\n+\ttest := uint32(1) << (31 - level)\n+\n+\t// We have to search the list of codes to find the divide between the left and right sides.\n+\tfirstRightIndex := len(codes)\n+\tfor i, code := range codes {\n+\t\tif code.code&test != 0 {\n+\t\t\tfirstRightIndex = i\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tleft := codes[:firstRightIndex]\n+\tright := codes[firstRightIndex:]\n+\n+\tif len(left) == 0 || len(right) == 0 {\n+\t\treturn 0, StructuralError(\"superfluous level in Huffman tree\")\n+\t}\n+\n+\tnodeIndex = uint16(t.nextNode)\n+\tnode := &t.nodes[t.nextNode]\n+\tt.nextNode++\n+\n+\tif len(left) == 1 {\n+\t\t// leaf node\n+\t\tnode.left = invalidNodeValue\n+\t\tnode.leftValue = left[0].value\n+\t} else {\n+\t\tnode.left, err = buildHuffmanNode(t, left, level+1)\n+\t}\n+\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif len(right) == 1 {\n+\t\t// leaf node\n+\t\tnode.right = invalidNodeValue\n+\t\tnode.rightValue = right[0].value\n+\t} else {\n+\t\tnode.right, err = buildHuffmanNode(t, right, level+1)\n+\t}\n+\n+\treturn\n+}"}, {"sha": "0ed19dec39c54b8cc22668e2ccdd983627506c9b", "filename": "libgo/go/compress/bzip2/move_to_front.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fmove_to_front.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package bzip2\n+\n+// moveToFrontDecoder implements a move-to-front list. Such a list is an\n+// efficient way to transform a string with repeating elements into one with\n+// many small valued numbers, which is suitable for entropy encoding. It works\n+// by starting with an initial list of symbols and references symbols by their\n+// index into that list. When a symbol is referenced, it's moved to the front\n+// of the list. Thus, a repeated symbol ends up being encoded with many zeros,\n+// as the symbol will be at the front of the list after the first access.\n+type moveToFrontDecoder struct {\n+\t// Rather than actually keep the list in memory, the symbols are stored\n+\t// as a circular, double linked list with the symbol indexed by head\n+\t// at the front of the list.\n+\tsymbols []byte\n+\tnext    []uint8\n+\tprev    []uint8\n+\thead    uint8\n+}\n+\n+// newMTFDecoder creates a move-to-front decoder with an explicit initial list\n+// of symbols.\n+func newMTFDecoder(symbols []byte) *moveToFrontDecoder {\n+\tif len(symbols) > 256 {\n+\t\tpanic(\"too many symbols\")\n+\t}\n+\n+\tm := &moveToFrontDecoder{\n+\t\tsymbols: symbols,\n+\t\tnext:    make([]uint8, len(symbols)),\n+\t\tprev:    make([]uint8, len(symbols)),\n+\t}\n+\n+\tm.threadLinkedList()\n+\treturn m\n+}\n+\n+// newMTFDecoderWithRange creates a move-to-front decoder with an initial\n+// symbol list of 0...n-1.\n+func newMTFDecoderWithRange(n int) *moveToFrontDecoder {\n+\tif n > 256 {\n+\t\tpanic(\"newMTFDecoderWithRange: cannot have > 256 symbols\")\n+\t}\n+\n+\tm := &moveToFrontDecoder{\n+\t\tsymbols: make([]uint8, n),\n+\t\tnext:    make([]uint8, n),\n+\t\tprev:    make([]uint8, n),\n+\t}\n+\n+\tfor i := 0; i < n; i++ {\n+\t\tm.symbols[i] = byte(i)\n+\t}\n+\n+\tm.threadLinkedList()\n+\treturn m\n+}\n+\n+// threadLinkedList creates the initial linked-list pointers.\n+func (m *moveToFrontDecoder) threadLinkedList() {\n+\tif len(m.symbols) == 0 {\n+\t\treturn\n+\t}\n+\n+\tm.prev[0] = uint8(len(m.symbols) - 1)\n+\n+\tfor i := 0; i < len(m.symbols)-1; i++ {\n+\t\tm.next[i] = uint8(i + 1)\n+\t\tm.prev[i+1] = uint8(i)\n+\t}\n+\n+\tm.next[len(m.symbols)-1] = 0\n+}\n+\n+func (m *moveToFrontDecoder) Decode(n int) (b byte) {\n+\t// Most of the time, n will be zero so it's worth dealing with this\n+\t// simple case.\n+\tif n == 0 {\n+\t\treturn m.symbols[m.head]\n+\t}\n+\n+\ti := m.head\n+\tfor j := 0; j < n; j++ {\n+\t\ti = m.next[i]\n+\t}\n+\tb = m.symbols[i]\n+\n+\tm.next[m.prev[i]] = m.next[i]\n+\tm.prev[m.next[i]] = m.prev[i]\n+\tm.next[i] = m.head\n+\tm.prev[i] = m.prev[m.head]\n+\tm.next[m.prev[m.head]] = i\n+\tm.prev[m.head] = i\n+\tm.head = i\n+\n+\treturn\n+}\n+\n+// First returns the symbol at the front of the list.\n+func (m *moveToFrontDecoder) First() byte {\n+\treturn m.symbols[m.head]\n+}"}, {"sha": "ff54164b2cce81244ca6887626e067ca795ae25f", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 14, "deletions": 133, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -116,9 +116,16 @@ func (b *syncBuffer) Read(p []byte) (n int, err os.Error) {\n \tpanic(\"unreachable\")\n }\n \n+func (b *syncBuffer) signal() {\n+\tselect {\n+\tcase b.ready <- true:\n+\tdefault:\n+\t}\n+}\n+\n func (b *syncBuffer) Write(p []byte) (n int, err os.Error) {\n \tn, err = b.buf.Write(p)\n-\t_ = b.ready <- true\n+\tb.signal()\n \treturn\n }\n \n@@ -128,12 +135,12 @@ func (b *syncBuffer) WriteMode() {\n \n func (b *syncBuffer) ReadMode() {\n \tb.mu.Unlock()\n-\t_ = b.ready <- true\n+\tb.signal()\n }\n \n func (b *syncBuffer) Close() os.Error {\n \tb.closed = true\n-\t_ = b.ready <- true\n+\tb.signal()\n \treturn nil\n }\n \n@@ -255,135 +262,9 @@ func TestReverseBits(t *testing.T) {\n }\n \n func TestDeflateInflateString(t *testing.T) {\n-\tgold := bytes.NewBufferString(getEdata()).Bytes()\n+\tgold, err := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n \ttestToFromWithLevel(t, 1, gold, \"2.718281828...\")\n }\n-\n-func getEdata() string {\n-\treturn \"2.718281828459045235360287471352662497757247093699959574966967627724076630353547\" +\n-\t\t\"59457138217852516642742746639193200305992181741359662904357290033429526059563073\" +\n-\t\t\"81323286279434907632338298807531952510190115738341879307021540891499348841675092\" +\n-\t\t\"44761460668082264800168477411853742345442437107539077744992069551702761838606261\" +\n-\t\t\"33138458300075204493382656029760673711320070932870912744374704723069697720931014\" +\n-\t\t\"16928368190255151086574637721112523897844250569536967707854499699679468644549059\" +\n-\t\t\"87931636889230098793127736178215424999229576351482208269895193668033182528869398\" +\n-\t\t\"49646510582093923982948879332036250944311730123819706841614039701983767932068328\" +\n-\t\t\"23764648042953118023287825098194558153017567173613320698112509961818815930416903\" +\n-\t\t\"51598888519345807273866738589422879228499892086805825749279610484198444363463244\" +\n-\t\t\"96848756023362482704197862320900216099023530436994184914631409343173814364054625\" +\n-\t\t\"31520961836908887070167683964243781405927145635490613031072085103837505101157477\" +\n-\t\t\"04171898610687396965521267154688957035035402123407849819334321068170121005627880\" +\n-\t\t\"23519303322474501585390473041995777709350366041699732972508868769664035557071622\" +\n-\t\t\"68447162560798826517871341951246652010305921236677194325278675398558944896970964\" +\n-\t\t\"09754591856956380236370162112047742722836489613422516445078182442352948636372141\" +\n-\t\t\"74023889344124796357437026375529444833799801612549227850925778256209262264832627\" +\n-\t\t\"79333865664816277251640191059004916449982893150566047258027786318641551956532442\" +\n-\t\t\"58698294695930801915298721172556347546396447910145904090586298496791287406870504\" +\n-\t\t\"89585867174798546677575732056812884592054133405392200011378630094556068816674001\" +\n-\t\t\"69842055804033637953764520304024322566135278369511778838638744396625322498506549\" +\n-\t\t\"95886234281899707733276171783928034946501434558897071942586398772754710962953741\" +\n-\t\t\"52111513683506275260232648472870392076431005958411661205452970302364725492966693\" +\n-\t\t\"81151373227536450988890313602057248176585118063036442812314965507047510254465011\" +\n-\t\t\"72721155519486685080036853228183152196003735625279449515828418829478761085263981\" +\n-\t\t\"39559900673764829224437528718462457803619298197139914756448826260390338144182326\" +\n-\t\t\"25150974827987779964373089970388867782271383605772978824125611907176639465070633\" +\n-\t\t\"04527954661855096666185664709711344474016070462621568071748187784437143698821855\" +\n-\t\t\"96709591025968620023537185887485696522000503117343920732113908032936344797273559\" +\n-\t\t\"55277349071783793421637012050054513263835440001863239914907054797780566978533580\" +\n-\t\t\"48966906295119432473099587655236812859041383241160722602998330535370876138939639\" +\n-\t\t\"17795745401613722361878936526053815584158718692553860616477983402543512843961294\" +\n-\t\t\"60352913325942794904337299085731580290958631382683291477116396337092400316894586\" +\n-\t\t\"36060645845925126994655724839186564209752685082307544254599376917041977780085362\" +\n-\t\t\"73094171016343490769642372229435236612557250881477922315197477806056967253801718\" +\n-\t\t\"07763603462459278778465850656050780844211529697521890874019660906651803516501792\" +\n-\t\t\"50461950136658543663271254963990854914420001457476081930221206602433009641270489\" +\n-\t\t\"43903971771951806990869986066365832322787093765022601492910115171776359446020232\" +\n-\t\t\"49300280401867723910288097866605651183260043688508817157238669842242201024950551\" +\n-\t\t\"88169480322100251542649463981287367765892768816359831247788652014117411091360116\" +\n-\t\t\"49950766290779436460058519419985601626479076153210387275571269925182756879893027\" +\n-\t\t\"61761146162549356495903798045838182323368612016243736569846703785853305275833337\" +\n-\t\t\"93990752166069238053369887956513728559388349989470741618155012539706464817194670\" +\n-\t\t\"83481972144888987906765037959036696724949925452790337296361626589760394985767413\" +\n-\t\t\"97359441023744329709355477982629614591442936451428617158587339746791897571211956\" +\n-\t\t\"18738578364475844842355558105002561149239151889309946342841393608038309166281881\" +\n-\t\t\"15037152849670597416256282360921680751501777253874025642534708790891372917228286\" +\n-\t\t\"11515915683725241630772254406337875931059826760944203261924285317018781772960235\" +\n-\t\t\"41306067213604600038966109364709514141718577701418060644363681546444005331608778\" +\n-\t\t\"31431744408119494229755993140118886833148328027065538330046932901157441475631399\" +\n-\t\t\"97221703804617092894579096271662260740718749975359212756084414737823303270330168\" +\n-\t\t\"23719364800217328573493594756433412994302485023573221459784328264142168487872167\" +\n-\t\t\"33670106150942434569844018733128101079451272237378861260581656680537143961278887\" +\n-\t\t\"32527373890392890506865324138062796025930387727697783792868409325365880733988457\" +\n-\t\t\"21874602100531148335132385004782716937621800490479559795929059165547050577751430\" +\n-\t\t\"81751126989851884087185640260353055837378324229241856256442550226721559802740126\" +\n-\t\t\"17971928047139600689163828665277009752767069777036439260224372841840883251848770\" +\n-\t\t\"47263844037953016690546593746161932384036389313136432713768884102681121989127522\" +\n-\t\t\"30562567562547017250863497653672886059667527408686274079128565769963137897530346\" +\n-\t\t\"60616669804218267724560530660773899624218340859882071864682623215080288286359746\" +\n-\t\t\"83965435885668550377313129658797581050121491620765676995065971534476347032085321\" +\n-\t\t\"56036748286083786568030730626576334697742956346437167093971930608769634953288468\" +\n-\t\t\"33613038829431040800296873869117066666146800015121143442256023874474325250769387\" +\n-\t\t\"07777519329994213727721125884360871583483562696166198057252661220679754062106208\" +\n-\t\t\"06498829184543953015299820925030054982570433905535701686531205264956148572492573\" +\n-\t\t\"86206917403695213533732531666345466588597286659451136441370331393672118569553952\" +\n-\t\t\"10845840724432383558606310680696492485123263269951460359603729725319836842336390\" +\n-\t\t\"46321367101161928217111502828016044880588023820319814930963695967358327420249882\" +\n-\t\t\"45684941273860566491352526706046234450549227581151709314921879592718001940968866\" +\n-\t\t\"98683703730220047531433818109270803001720593553052070070607223399946399057131158\" +\n-\t\t\"70996357773590271962850611465148375262095653467132900259943976631145459026858989\" +\n-\t\t\"79115837093419370441155121920117164880566945938131183843765620627846310490346293\" +\n-\t\t\"95002945834116482411496975832601180073169943739350696629571241027323913874175492\" +\n-\t\t\"30718624545432220395527352952402459038057445028922468862853365422138157221311632\" +\n-\t\t\"88112052146489805180092024719391710555390113943316681515828843687606961102505171\" +\n-\t\t\"00739276238555338627255353883096067164466237092264680967125406186950214317621166\" +\n-\t\t\"81400975952814939072226011126811531083873176173232352636058381731510345957365382\" +\n-\t\t\"23534992935822836851007810884634349983518404451704270189381994243410090575376257\" +\n-\t\t\"76757111809008816418331920196262341628816652137471732547772778348877436651882875\" +\n-\t\t\"21566857195063719365653903894493664217640031215278702223664636357555035655769488\" +\n-\t\t\"86549500270853923617105502131147413744106134445544192101336172996285694899193369\" +\n-\t\t\"18472947858072915608851039678195942983318648075608367955149663644896559294818785\" +\n-\t\t\"17840387733262470519450504198477420141839477312028158868457072905440575106012852\" +\n-\t\t\"58056594703046836344592652552137008068752009593453607316226118728173928074623094\" +\n-\t\t\"68536782310609792159936001994623799343421068781349734695924646975250624695861690\" +\n-\t\t\"91785739765951993929939955675427146549104568607020990126068187049841780791739240\" +\n-\t\t\"71945996323060254707901774527513186809982284730860766536866855516467702911336827\" +\n-\t\t\"56310722334672611370549079536583453863719623585631261838715677411873852772292259\" +\n-\t\t\"47433737856955384562468010139057278710165129666367644518724656537304024436841408\" +\n-\t\t\"14488732957847348490003019477888020460324660842875351848364959195082888323206522\" +\n-\t\t\"12810419044804724794929134228495197002260131043006241071797150279343326340799596\" +\n-\t\t\"05314460532304885289729176598760166678119379323724538572096075822771784833616135\" +\n-\t\t\"82612896226118129455927462767137794487586753657544861407611931125958512655759734\" +\n-\t\t\"57301533364263076798544338576171533346232527057200530398828949903425956623297578\" +\n-\t\t\"24887350292591668258944568946559926584547626945287805165017206747854178879822768\" +\n-\t\t\"06536650641910973434528878338621726156269582654478205672987756426325321594294418\" +\n-\t\t\"03994321700009054265076309558846589517170914760743713689331946909098190450129030\" +\n-\t\t\"70995662266203031826493657336984195557769637876249188528656866076005660256054457\" +\n-\t\t\"11337286840205574416030837052312242587223438854123179481388550075689381124935386\" +\n-\t\t\"31863528708379984569261998179452336408742959118074745341955142035172618420084550\" +\n-\t\t\"91708456823682008977394558426792142734775608796442792027083121501564063413416171\" +\n-\t\t\"66448069815483764491573900121217041547872591998943825364950514771379399147205219\" +\n-\t\t\"52907939613762110723849429061635760459623125350606853765142311534966568371511660\" +\n-\t\t\"42207963944666211632551577290709784731562782775987881364919512574833287937715714\" +\n-\t\t\"59091064841642678309949723674420175862269402159407924480541255360431317992696739\" +\n-\t\t\"15754241929660731239376354213923061787675395871143610408940996608947141834069836\" +\n-\t\t\"29936753626215452472984642137528910798843813060955526227208375186298370667872244\" +\n-\t\t\"30195793793786072107254277289071732854874374355781966511716618330881129120245204\" +\n-\t\t\"04868220007234403502544820283425418788465360259150644527165770004452109773558589\" +\n-\t\t\"76226554849416217149895323834216001140629507184904277892585527430352213968356790\" +\n-\t\t\"18076406042138307308774460170842688272261177180842664333651780002171903449234264\" +\n-\t\t\"26629226145600433738386833555534345300426481847398921562708609565062934040526494\" +\n-\t\t\"32442614456659212912256488935696550091543064261342526684725949143142393988454324\" +\n-\t\t\"86327461842846655985332312210466259890141712103446084271616619001257195870793217\" +\n-\t\t\"56969854401339762209674945418540711844643394699016269835160784892451405894094639\" +\n-\t\t\"52678073545797003070511636825194877011897640028276484141605872061841852971891540\" +\n-\t\t\"19688253289309149665345753571427318482016384644832499037886069008072709327673127\" +\n-\t\t\"58196656394114896171683298045513972950668760474091542042842999354102582911350224\" +\n-\t\t\"16907694316685742425225090269390348148564513030699251995904363840284292674125734\" +\n-\t\t\"22447765584177886171737265462085498294498946787350929581652632072258992368768457\" +\n-\t\t\"01782303809656788311228930580914057261086588484587310165815116753332767488701482\" +\n-\t\t\"91674197015125597825727074064318086014281490241467804723275976842696339357735429\" +\n-\t\t\"30186739439716388611764209004068663398856841681003872389214483176070116684503887\" +\n-\t\t\"21236436704331409115573328018297798873659091665961240202177855885487617616198937\" +\n-\t\t\"07943800566633648843650891448055710397652146960276625835990519870423001794655367\" +\n-\t\t\"9\"\n-}"}, {"sha": "8a540cbe6a11c686cc036cfd05bf759ae1349d98", "filename": "libgo/go/compress/lzw/reader.go", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The lzw package implements the Lempel-Ziv-Welch compressed data format,\n+// described in T. A. Welch, ``A Technique for High-Performance Data\n+// Compression'', Computer, 17(6) (June 1984), pp 8-19.\n+//\n+// In particular, it implements LZW as used by the GIF, TIFF and PDF file\n+// formats, which means variable-width codes up to 12 bits and the first\n+// two non-literal codes are a clear code and an EOF code.\n+package lzw\n+\n+// TODO(nigeltao): check that TIFF and PDF use LZW in the same way as GIF,\n+// modulo LSB/MSB packing order.\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Order specifies the bit ordering in an LZW data stream.\n+type Order int\n+\n+const (\n+\t// LSB means Least Significant Bits first, as used in the GIF file format.\n+\tLSB Order = iota\n+\t// MSB means Most Significant Bits first, as used in the TIFF and PDF\n+\t// file formats.\n+\tMSB\n+)\n+\n+// decoder is the state from which the readXxx method converts a byte\n+// stream into a code stream.\n+type decoder struct {\n+\tr     io.ByteReader\n+\tbits  uint32\n+\tnBits uint\n+\twidth uint\n+}\n+\n+// readLSB returns the next code for \"Least Significant Bits first\" data.\n+func (d *decoder) readLSB() (uint16, os.Error) {\n+\tfor d.nBits < d.width {\n+\t\tx, err := d.r.ReadByte()\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\td.bits |= uint32(x) << d.nBits\n+\t\td.nBits += 8\n+\t}\n+\tcode := uint16(d.bits & (1<<d.width - 1))\n+\td.bits >>= d.width\n+\td.nBits -= d.width\n+\treturn code, nil\n+}\n+\n+// readMSB returns the next code for \"Most Significant Bits first\" data.\n+func (d *decoder) readMSB() (uint16, os.Error) {\n+\tfor d.nBits < d.width {\n+\t\tx, err := d.r.ReadByte()\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\td.bits |= uint32(x) << (24 - d.nBits)\n+\t\td.nBits += 8\n+\t}\n+\tcode := uint16(d.bits >> (32 - d.width))\n+\td.bits <<= d.width\n+\td.nBits -= d.width\n+\treturn code, nil\n+}\n+\n+// decode decompresses bytes from r and writes them to pw.\n+// read specifies how to decode bytes into codes.\n+// litWidth is the width in bits of literal codes.\n+func decode(r io.Reader, read func(*decoder) (uint16, os.Error), litWidth int, pw *io.PipeWriter) {\n+\tbr, ok := r.(io.ByteReader)\n+\tif !ok {\n+\t\tbr = bufio.NewReader(r)\n+\t}\n+\tpw.CloseWithError(decode1(pw, br, read, uint(litWidth)))\n+}\n+\n+func decode1(pw *io.PipeWriter, r io.ByteReader, read func(*decoder) (uint16, os.Error), litWidth uint) os.Error {\n+\tconst (\n+\t\tmaxWidth    = 12\n+\t\tinvalidCode = 0xffff\n+\t)\n+\td := decoder{r, 0, 0, 1 + litWidth}\n+\tw := bufio.NewWriter(pw)\n+\t// The first 1<<litWidth codes are literal codes.\n+\t// The next two codes mean clear and EOF.\n+\t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n+\t// with the upper bound incrementing on each code seen.\n+\tclear := uint16(1) << litWidth\n+\teof, hi := clear+1, clear+1\n+\t// overflow is the code at which hi overflows the code width.\n+\toverflow := uint16(1) << d.width\n+\tvar (\n+\t\t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n+\t\t//   suffix[c] is the last of these bytes.\n+\t\t//   prefix[c] is the code for all but the last byte.\n+\t\t//   This code can either be a literal code or another code in [lo, c).\n+\t\t// The c == hi case is a special case.\n+\t\tsuffix [1 << maxWidth]uint8\n+\t\tprefix [1 << maxWidth]uint16\n+\t\t// buf is a scratch buffer for reconstituting the bytes that a code expands to.\n+\t\t// Code suffixes are written right-to-left from the end of the buffer.\n+\t\tbuf [1 << maxWidth]byte\n+\t)\n+\n+\t// Loop over the code stream, converting codes into decompressed bytes.\n+\tlast := uint16(invalidCode)\n+\tfor {\n+\t\tcode, err := read(&d)\n+\t\tif err != nil {\n+\t\t\tif err == os.EOF {\n+\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\treturn err\n+\t\t}\n+\t\tswitch {\n+\t\tcase code < clear:\n+\t\t\t// We have a literal code.\n+\t\t\tif err := w.WriteByte(uint8(code)); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif last != invalidCode {\n+\t\t\t\t// Save what the hi code expands to.\n+\t\t\t\tsuffix[hi] = uint8(code)\n+\t\t\t\tprefix[hi] = last\n+\t\t\t}\n+\t\tcase code == clear:\n+\t\t\td.width = 1 + litWidth\n+\t\t\thi = eof\n+\t\t\toverflow = 1 << d.width\n+\t\t\tlast = invalidCode\n+\t\t\tcontinue\n+\t\tcase code == eof:\n+\t\t\treturn w.Flush()\n+\t\tcase code <= hi:\n+\t\t\tc, i := code, len(buf)-1\n+\t\t\tif code == hi {\n+\t\t\t\t// code == hi is a special case which expands to the last expansion\n+\t\t\t\t// followed by the head of the last expansion. To find the head, we walk\n+\t\t\t\t// the prefix chain until we find a literal code.\n+\t\t\t\tc = last\n+\t\t\t\tfor c >= clear {\n+\t\t\t\t\tc = prefix[c]\n+\t\t\t\t}\n+\t\t\t\tbuf[i] = uint8(c)\n+\t\t\t\ti--\n+\t\t\t\tc = last\n+\t\t\t}\n+\t\t\t// Copy the suffix chain into buf and then write that to w.\n+\t\t\tfor c >= clear {\n+\t\t\t\tbuf[i] = suffix[c]\n+\t\t\t\ti--\n+\t\t\t\tc = prefix[c]\n+\t\t\t}\n+\t\t\tbuf[i] = uint8(c)\n+\t\t\tif _, err := w.Write(buf[i:]); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\t// Save what the hi code expands to.\n+\t\t\tsuffix[hi] = uint8(c)\n+\t\t\tprefix[hi] = last\n+\t\tdefault:\n+\t\t\treturn os.NewError(\"lzw: invalid code\")\n+\t\t}\n+\t\tlast, hi = code, hi+1\n+\t\tif hi == overflow {\n+\t\t\tif d.width == maxWidth {\n+\t\t\t\treturn os.NewError(\"lzw: missing clear code\")\n+\t\t\t}\n+\t\t\td.width++\n+\t\t\toverflow <<= 1\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n+// NewReader creates a new io.ReadCloser that satisfies reads by decompressing\n+// the data read from r.\n+// It is the caller's responsibility to call Close on the ReadCloser when\n+// finished reading.\n+// The number of bits to use for literal codes, litWidth, must be in the\n+// range [2,8] and is typically 8.\n+func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser {\n+\tpr, pw := io.Pipe()\n+\tvar read func(*decoder) (uint16, os.Error)\n+\tswitch order {\n+\tcase LSB:\n+\t\tread = (*decoder).readLSB\n+\tcase MSB:\n+\t\tread = (*decoder).readMSB\n+\tdefault:\n+\t\tpw.CloseWithError(os.NewError(\"lzw: unknown order\"))\n+\t\treturn pr\n+\t}\n+\tif litWidth < 2 || 8 < litWidth {\n+\t\tpw.CloseWithError(fmt.Errorf(\"lzw: litWidth %d out of range\", litWidth))\n+\t\treturn pr\n+\t}\n+\tgo decode(r, read, litWidth, pw)\n+\treturn pr\n+}"}, {"sha": "7795a4c14896486f07129ebea00addf3a9c0a27a", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package lzw\n+\n+import (\n+\t\"bytes\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+type lzwTest struct {\n+\tdesc       string\n+\traw        string\n+\tcompressed string\n+\terr        os.Error\n+}\n+\n+var lzwTests = []lzwTest{\n+\t{\n+\t\t\"empty;LSB;8\",\n+\t\t\"\",\n+\t\t\"\\x01\\x01\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"empty;MSB;8\",\n+\t\t\"\",\n+\t\t\"\\x80\\x80\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"tobe;LSB;7\",\n+\t\t\"TOBEORNOTTOBEORTOBEORNOT\",\n+\t\t\"\\x54\\x4f\\x42\\x45\\x4f\\x52\\x4e\\x4f\\x54\\x82\\x84\\x86\\x8b\\x85\\x87\\x89\\x81\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"tobe;LSB;8\",\n+\t\t\"TOBEORNOTTOBEORTOBEORNOT\",\n+\t\t\"\\x54\\x9e\\x08\\x29\\xf2\\x44\\x8a\\x93\\x27\\x54\\x04\\x12\\x34\\xb8\\xb0\\xe0\\xc1\\x84\\x01\\x01\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"tobe;MSB;7\",\n+\t\t\"TOBEORNOTTOBEORTOBEORNOT\",\n+\t\t\"\\x54\\x4f\\x42\\x45\\x4f\\x52\\x4e\\x4f\\x54\\x82\\x84\\x86\\x8b\\x85\\x87\\x89\\x81\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"tobe;MSB;8\",\n+\t\t\"TOBEORNOTTOBEORTOBEORNOT\",\n+\t\t\"\\x2a\\x13\\xc8\\x44\\x52\\x79\\x48\\x9c\\x4f\\x2a\\x40\\xa0\\x90\\x68\\x5c\\x16\\x0f\\x09\\x80\\x80\",\n+\t\tnil,\n+\t},\n+\t{\n+\t\t\"tobe-truncated;LSB;8\",\n+\t\t\"TOBEORNOTTOBEORTOBEORNOT\",\n+\t\t\"\\x54\\x9e\\x08\\x29\\xf2\\x44\\x8a\\x93\\x27\\x54\\x04\",\n+\t\tio.ErrUnexpectedEOF,\n+\t},\n+\t// This example comes from http://en.wikipedia.org/wiki/Graphics_Interchange_Format.\n+\t{\n+\t\t\"gif;LSB;8\",\n+\t\t\"\\x28\\xff\\xff\\xff\\x28\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\",\n+\t\t\"\\x00\\x51\\xfc\\x1b\\x28\\x70\\xa0\\xc1\\x83\\x01\\x01\",\n+\t\tnil,\n+\t},\n+\t// This example comes from http://compgroups.net/comp.lang.ruby/Decompressing-LZW-compression-from-PDF-file\n+\t{\n+\t\t\"pdf;MSB;8\",\n+\t\t\"-----A---B\",\n+\t\t\"\\x80\\x0b\\x60\\x50\\x22\\x0c\\x0c\\x85\\x01\",\n+\t\tnil,\n+\t},\n+}\n+\n+func TestReader(t *testing.T) {\n+\tb := bytes.NewBuffer(nil)\n+\tfor _, tt := range lzwTests {\n+\t\td := strings.Split(tt.desc, \";\", -1)\n+\t\tvar order Order\n+\t\tswitch d[1] {\n+\t\tcase \"LSB\":\n+\t\t\torder = LSB\n+\t\tcase \"MSB\":\n+\t\t\torder = MSB\n+\t\tdefault:\n+\t\t\tt.Errorf(\"%s: bad order %q\", tt.desc, d[1])\n+\t\t}\n+\t\tlitWidth, _ := strconv.Atoi(d[2])\n+\t\trc := NewReader(strings.NewReader(tt.compressed), order, litWidth)\n+\t\tdefer rc.Close()\n+\t\tb.Reset()\n+\t\tn, err := io.Copy(b, rc)\n+\t\tif err != nil {\n+\t\t\tif err != tt.err {\n+\t\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\ts := b.String()\n+\t\tif s != tt.raw {\n+\t\t\tt.Errorf(\"%s: got %d-byte %q want %d-byte %q\", tt.desc, n, s, len(tt.raw), tt.raw)\n+\t\t}\n+\t}\n+}\n+\n+type devNull struct{}\n+\n+func (devNull) Write(p []byte) (int, os.Error) {\n+\treturn len(p), nil\n+}\n+\n+func BenchmarkDecoder(b *testing.B) {\n+\tb.StopTimer()\n+\tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tcompressed := bytes.NewBuffer(nil)\n+\tw := NewWriter(compressed, LSB, 8)\n+\tio.Copy(w, bytes.NewBuffer(buf0))\n+\tw.Close()\n+\tbuf1 := compressed.Bytes()\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tio.Copy(devNull{}, NewReader(bytes.NewBuffer(buf1), LSB, 8))\n+\t}\n+}"}, {"sha": "87143b7aa94806be5d5fe2971b2f05e32505ad41", "filename": "libgo/go/compress/lzw/writer.go", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,259 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package lzw\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// A writer is a buffered, flushable writer.\n+type writer interface {\n+\tWriteByte(byte) os.Error\n+\tFlush() os.Error\n+}\n+\n+// An errWriteCloser is an io.WriteCloser that always returns a given error.\n+type errWriteCloser struct {\n+\terr os.Error\n+}\n+\n+func (e *errWriteCloser) Write([]byte) (int, os.Error) {\n+\treturn 0, e.err\n+}\n+\n+func (e *errWriteCloser) Close() os.Error {\n+\treturn e.err\n+}\n+\n+const (\n+\t// A code is a 12 bit value, stored as a uint32 when encoding to avoid\n+\t// type conversions when shifting bits.\n+\tmaxCode     = 1<<12 - 1\n+\tinvalidCode = 1<<32 - 1\n+\t// There are 1<<12 possible codes, which is an upper bound on the number of\n+\t// valid hash table entries at any given point in time. tableSize is 4x that.\n+\ttableSize = 4 * 1 << 12\n+\ttableMask = tableSize - 1\n+\t// A hash table entry is a uint32. Zero is an invalid entry since the\n+\t// lower 12 bits of a valid entry must be a non-literal code.\n+\tinvalidEntry = 0\n+)\n+\n+// encoder is LZW compressor.\n+type encoder struct {\n+\t// w is the writer that compressed bytes are written to.\n+\tw writer\n+\t// write, bits, nBits and width are the state for converting a code stream\n+\t// into a byte stream.\n+\twrite func(*encoder, uint32) os.Error\n+\tbits  uint32\n+\tnBits uint\n+\twidth uint\n+\t// litWidth is the width in bits of literal codes.\n+\tlitWidth uint\n+\t// hi is the code implied by the next code emission.\n+\t// overflow is the code at which hi overflows the code width.\n+\thi, overflow uint32\n+\t// savedCode is the accumulated code at the end of the most recent Write\n+\t// call. It is equal to invalidCode if there was no such call.\n+\tsavedCode uint32\n+\t// err is the first error encountered during writing. Closing the encoder\n+\t// will make any future Write calls return os.EINVAL.\n+\terr os.Error\n+\t// table is the hash table from 20-bit keys to 12-bit values. Each table\n+\t// entry contains key<<12|val and collisions resolve by linear probing.\n+\t// The keys consist of a 12-bit code prefix and an 8-bit byte suffix.\n+\t// The values are a 12-bit code.\n+\ttable [tableSize]uint32\n+}\n+\n+// writeLSB writes the code c for \"Least Significant Bits first\" data.\n+func (e *encoder) writeLSB(c uint32) os.Error {\n+\te.bits |= c << e.nBits\n+\te.nBits += e.width\n+\tfor e.nBits >= 8 {\n+\t\tif err := e.w.WriteByte(uint8(e.bits)); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\te.bits >>= 8\n+\t\te.nBits -= 8\n+\t}\n+\treturn nil\n+}\n+\n+// writeMSB writes the code c for \"Most Significant Bits first\" data.\n+func (e *encoder) writeMSB(c uint32) os.Error {\n+\te.bits |= c << (32 - e.width - e.nBits)\n+\te.nBits += e.width\n+\tfor e.nBits >= 8 {\n+\t\tif err := e.w.WriteByte(uint8(e.bits >> 24)); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\te.bits <<= 8\n+\t\te.nBits -= 8\n+\t}\n+\treturn nil\n+}\n+\n+// errOutOfCodes is an internal error that means that the encoder has run out\n+// of unused codes and a clear code needs to be sent next.\n+var errOutOfCodes = os.NewError(\"lzw: out of codes\")\n+\n+// incHi increments e.hi and checks for both overflow and running out of\n+// unused codes. In the latter case, incHi sends a clear code, resets the\n+// encoder state and returns errOutOfCodes.\n+func (e *encoder) incHi() os.Error {\n+\te.hi++\n+\tif e.hi == e.overflow {\n+\t\te.width++\n+\t\te.overflow <<= 1\n+\t}\n+\tif e.hi == maxCode {\n+\t\tclear := uint32(1) << e.litWidth\n+\t\tif err := e.write(e, clear); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\te.width = uint(e.litWidth) + 1\n+\t\te.hi = clear + 1\n+\t\te.overflow = clear << 1\n+\t\tfor i := range e.table {\n+\t\t\te.table[i] = invalidEntry\n+\t\t}\n+\t\treturn errOutOfCodes\n+\t}\n+\treturn nil\n+}\n+\n+// Write writes a compressed representation of p to e's underlying writer.\n+func (e *encoder) Write(p []byte) (int, os.Error) {\n+\tif e.err != nil {\n+\t\treturn 0, e.err\n+\t}\n+\tif len(p) == 0 {\n+\t\treturn 0, nil\n+\t}\n+\tlitMask := uint32(1<<e.litWidth - 1)\n+\tcode := e.savedCode\n+\tif code == invalidCode {\n+\t\t// The first code sent is always a literal code.\n+\t\tcode, p = uint32(p[0])&litMask, p[1:]\n+\t}\n+loop:\n+\tfor _, x := range p {\n+\t\tliteral := uint32(x) & litMask\n+\t\tkey := code<<8 | literal\n+\t\t// If there is a hash table hit for this key then we continue the loop\n+\t\t// and do not emit a code yet.\n+\t\thash := (key>>12 ^ key) & tableMask\n+\t\tfor h, t := hash, e.table[hash]; t != invalidEntry; {\n+\t\t\tif key == t>>12 {\n+\t\t\t\tcode = t & maxCode\n+\t\t\t\tcontinue loop\n+\t\t\t}\n+\t\t\th = (h + 1) & tableMask\n+\t\t\tt = e.table[h]\n+\t\t}\n+\t\t// Otherwise, write the current code, and literal becomes the start of\n+\t\t// the next emitted code.\n+\t\tif e.err = e.write(e, code); e.err != nil {\n+\t\t\treturn 0, e.err\n+\t\t}\n+\t\tcode = literal\n+\t\t// Increment e.hi, the next implied code. If we run out of codes, reset\n+\t\t// the encoder state (including clearing the hash table) and continue.\n+\t\tif err := e.incHi(); err != nil {\n+\t\t\tif err == errOutOfCodes {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\te.err = err\n+\t\t\treturn 0, e.err\n+\t\t}\n+\t\t// Otherwise, insert key -> e.hi into the map that e.table represents.\n+\t\tfor {\n+\t\t\tif e.table[hash] == invalidEntry {\n+\t\t\t\te.table[hash] = (key << 12) | e.hi\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\thash = (hash + 1) & tableMask\n+\t\t}\n+\t}\n+\te.savedCode = code\n+\treturn len(p), nil\n+}\n+\n+// Close closes the encoder, flushing any pending output. It does not close or\n+// flush e's underlying writer.\n+func (e *encoder) Close() os.Error {\n+\tif e.err != nil {\n+\t\tif e.err == os.EINVAL {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn e.err\n+\t}\n+\t// Make any future calls to Write return os.EINVAL.\n+\te.err = os.EINVAL\n+\t// Write the savedCode if valid.\n+\tif e.savedCode != invalidCode {\n+\t\tif err := e.write(e, e.savedCode); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif err := e.incHi(); err != nil && err != errOutOfCodes {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\t// Write the eof code.\n+\teof := uint32(1)<<e.litWidth + 1\n+\tif err := e.write(e, eof); err != nil {\n+\t\treturn err\n+\t}\n+\t// Write the final bits.\n+\tif e.nBits > 0 {\n+\t\tif e.write == (*encoder).writeMSB {\n+\t\t\te.bits >>= 24\n+\t\t}\n+\t\tif err := e.w.WriteByte(uint8(e.bits)); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn e.w.Flush()\n+}\n+\n+// NewWriter creates a new io.WriteCloser that satisfies writes by compressing\n+// the data and writing it to w.\n+// It is the caller's responsibility to call Close on the WriteCloser when\n+// finished writing.\n+// The number of bits to use for literal codes, litWidth, must be in the\n+// range [2,8] and is typically 8.\n+func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser {\n+\tvar write func(*encoder, uint32) os.Error\n+\tswitch order {\n+\tcase LSB:\n+\t\twrite = (*encoder).writeLSB\n+\tcase MSB:\n+\t\twrite = (*encoder).writeMSB\n+\tdefault:\n+\t\treturn &errWriteCloser{os.NewError(\"lzw: unknown order\")}\n+\t}\n+\tif litWidth < 2 || 8 < litWidth {\n+\t\treturn &errWriteCloser{fmt.Errorf(\"lzw: litWidth %d out of range\", litWidth)}\n+\t}\n+\tbw, ok := w.(writer)\n+\tif !ok {\n+\t\tbw = bufio.NewWriter(w)\n+\t}\n+\tlw := uint(litWidth)\n+\treturn &encoder{\n+\t\tw:         bw,\n+\t\twrite:     write,\n+\t\twidth:     1 + lw,\n+\t\tlitWidth:  lw,\n+\t\thi:        1<<lw + 1,\n+\t\toverflow:  1 << (lw + 1),\n+\t\tsavedCode: invalidCode,\n+\t}\n+}"}, {"sha": "715b974aa1ec20ab11fcb65ef1e95a51e938d2ab", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package lzw\n+\n+import (\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+var filenames = []string{\n+\t\"../testdata/e.txt\",\n+\t\"../testdata/pi.txt\",\n+}\n+\n+// testFile tests that compressing and then decompressing the given file with\n+// the given options yields equivalent bytes to the original file.\n+func testFile(t *testing.T, fn string, order Order, litWidth int) {\n+\t// Read the file, as golden output.\n+\tgolden, err := os.Open(fn, os.O_RDONLY, 0400)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err)\n+\t\treturn\n+\t}\n+\tdefer golden.Close()\n+\n+\t// Read the file again, and push it through a pipe that compresses at the write end, and decompresses at the read end.\n+\traw, err := os.Open(fn, os.O_RDONLY, 0400)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err)\n+\t\treturn\n+\t}\n+\n+\tpiper, pipew := io.Pipe()\n+\tdefer piper.Close()\n+\tgo func() {\n+\t\tdefer raw.Close()\n+\t\tdefer pipew.Close()\n+\t\tlzww := NewWriter(pipew, order, litWidth)\n+\t\tdefer lzww.Close()\n+\t\tvar b [4096]byte\n+\t\tfor {\n+\t\t\tn, err0 := raw.Read(b[:])\n+\t\t\tif err0 != nil && err0 != os.EOF {\n+\t\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err0)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t_, err1 := lzww.Write(b[:n])\n+\t\t\tif err1 == os.EPIPE {\n+\t\t\t\t// Fail, but do not report the error, as some other (presumably reportable) error broke the pipe.\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err1 != nil {\n+\t\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err1)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err0 == os.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}()\n+\tlzwr := NewReader(piper, order, litWidth)\n+\tdefer lzwr.Close()\n+\n+\t// Compare the two.\n+\tb0, err0 := ioutil.ReadAll(golden)\n+\tb1, err1 := ioutil.ReadAll(lzwr)\n+\tif err0 != nil {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err0)\n+\t\treturn\n+\t}\n+\tif err1 != nil {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err1)\n+\t\treturn\n+\t}\n+\tif len(b0) != len(b1) {\n+\t\tt.Errorf(\"%s (order=%d litWidth=%d): length mismatch %d versus %d\", fn, order, litWidth, len(b0), len(b1))\n+\t\treturn\n+\t}\n+\tfor i := 0; i < len(b0); i++ {\n+\t\tif b0[i] != b1[i] {\n+\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): mismatch at %d, 0x%02x versus 0x%02x\\n\", fn, order, litWidth, i, b0[i], b1[i])\n+\t\t\treturn\n+\t\t}\n+\t}\n+}\n+\n+func TestWriter(t *testing.T) {\n+\tfor _, filename := range filenames {\n+\t\tfor _, order := range [...]Order{LSB, MSB} {\n+\t\t\t// The test data \"2.71828 etcetera\" is ASCII text requiring at least 6 bits.\n+\t\t\tfor _, litWidth := range [...]int{6, 7, 8} {\n+\t\t\t\ttestFile(t, filename, order, litWidth)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEncoder(b *testing.B) {\n+\tb.StopTimer()\n+\tbuf, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tw := NewWriter(devNull{}, LSB, 8)\n+\t\tw.Write(buf)\n+\t\tw.Close()\n+\t}\n+}"}, {"sha": "76cf2a7b69172d2863e3a363df2714d65c3ad64f", "filename": "libgo/go/compress/testdata/e.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2Fe.txt?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1 @@\n+2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919320030599218174135966290435729003342952605956307381323286279434907632338298807531952510190115738341879307021540891499348841675092447614606680822648001684774118537423454424371075390777449920695517027618386062613313845830007520449338265602976067371132007093287091274437470472306969772093101416928368190255151086574637721112523897844250569536967707854499699679468644549059879316368892300987931277361782154249992295763514822082698951936680331825288693984964651058209392398294887933203625094431173012381970684161403970198376793206832823764648042953118023287825098194558153017567173613320698112509961818815930416903515988885193458072738667385894228792284998920868058257492796104841984443634632449684875602336248270419786232090021609902353043699418491463140934317381436405462531520961836908887070167683964243781405927145635490613031072085103837505101157477041718986106873969655212671546889570350354021234078498193343210681701210056278802351930332247450158539047304199577770935036604169973297250886876966403555707162268447162560798826517871341951246652010305921236677194325278675398558944896970964097545918569563802363701621120477427228364896134225164450781824423529486363721417402388934412479635743702637552944483379980161254922785092577825620926226483262779333865664816277251640191059004916449982893150566047258027786318641551956532442586982946959308019152987211725563475463964479101459040905862984967912874068705048958586717479854667757573205681288459205413340539220001137863009455606881667400169842055804033637953764520304024322566135278369511778838638744396625322498506549958862342818997077332761717839280349465014345588970719425863987727547109629537415211151368350627526023264847287039207643100595841166120545297030236472549296669381151373227536450988890313602057248176585118063036442812314965507047510254465011727211555194866850800368532281831521960037356252794495158284188294787610852639813955990067376482922443752871846245780361929819713991475644882626039033814418232625150974827987779964373089970388867782271383605772978824125611907176639465070633045279546618550966661856647097113444740160704626215680717481877844371436988218559670959102596862002353718588748569652200050311734392073211390803293634479727355955277349071783793421637012050054513263835440001863239914907054797780566978533580489669062951194324730995876552368128590413832411607226029983305353708761389396391779574540161372236187893652605381558415871869255386061647798340254351284396129460352913325942794904337299085731580290958631382683291477116396337092400316894586360606458459251269946557248391865642097526850823075442545993769170419777800853627309417101634349076964237222943523661255725088147792231519747780605696725380171807763603462459278778465850656050780844211529697521890874019660906651803516501792504619501366585436632712549639908549144200014574760819302212066024330096412704894390397177195180699086998606636583232278709376502260149291011517177635944602023249300280401867723910288097866605651183260043688508817157238669842242201024950551881694803221002515426494639812873677658927688163598312477886520141174110913601164995076629077943646005851941998560162647907615321038727557126992518275687989302761761146162549356495903798045838182323368612016243736569846703785853305275833337939907521660692380533698879565137285593883499894707416181550125397064648171946708348197214488898790676503795903669672494992545279033729636162658976039498576741397359441023744329709355477982629614591442936451428617158587339746791897571211956187385783644758448423555581050025611492391518893099463428413936080383091662818811503715284967059741625628236092168075150177725387402564253470879089137291722828611515915683725241630772254406337875931059826760944203261924285317018781772960235413060672136046000389661093647095141417185777014180606443636815464440053316087783143174440811949422975599314011888683314832802706553833004693290115744147563139997221703804617092894579096271662260740718749975359212756084414737823303270330168237193648002173285734935947564334129943024850235732214597843282641421684878721673367010615094243456984401873312810107945127223737886126058165668053714396127888732527373890392890506865324138062796025930387727697783792868409325365880733988457218746021005311483351323850047827169376218004904795597959290591655470505777514308175112698985188408718564026035305583737832422924185625644255022672155980274012617971928047139600689163828665277009752767069777036439260224372841840883251848770472638440379530166905465937461619323840363893131364327137688841026811219891275223056256756254701725086349765367288605966752740868627407912856576996313789753034660616669804218267724560530660773899624218340859882071864682623215080288286359746839654358856685503773131296587975810501214916207656769950659715344763470320853215603674828608378656803073062657633469774295634643716709397193060876963495328846833613038829431040800296873869117066666146800015121143442256023874474325250769387077775193299942137277211258843608715834835626961661980572526612206797540621062080649882918454395301529982092503005498257043390553570168653120526495614857249257386206917403695213533732531666345466588597286659451136441370331393672118569553952108458407244323835586063106806964924851232632699514603596037297253198368423363904632136710116192821711150282801604488058802382031981493096369596735832742024988245684941273860566491352526706046234450549227581151709314921879592718001940968866986837037302200475314338181092708030017205935530520700706072233999463990571311587099635777359027196285061146514837526209565346713290025994397663114545902685898979115837093419370441155121920117164880566945938131183843765620627846310490346293950029458341164824114969758326011800731699437393506966295712410273239138741754923071862454543222039552735295240245903805744502892246886285336542213815722131163288112052146489805180092024719391710555390113943316681515828843687606961102505171007392762385553386272553538830960671644662370922646809671254061869502143176211668140097595281493907222601112681153108387317617323235263605838173151034595736538223534992935822836851007810884634349983518404451704270189381994243410090575376257767571118090088164183319201962623416288166521374717325477727783488774366518828752156685719506371936565390389449366421764003121527870222366463635755503565576948886549500270853923617105502131147413744106134445544192101336172996285694899193369184729478580729156088510396781959429833186480756083679551496636448965592948187851784038773326247051945050419847742014183947731202815886845707290544057510601285258056594703046836344592652552137008068752009593453607316226118728173928074623094685367823106097921599360019946237993434210687813497346959246469752506246958616909178573976595199392993995567542714654910456860702099012606818704984178079173924071945996323060254707901774527513186809982284730860766536866855516467702911336827563107223346726113705490795365834538637196235856312618387156774118738527722922594743373785695538456246801013905727871016512966636764451872465653730402443684140814488732957847348490003019477888020460324660842875351848364959195082888323206522128104190448047247949291342284951970022601310430062410717971502793433263407995960531446053230488528972917659876016667811937932372453857209607582277178483361613582612896226118129455927462767137794487586753657544861407611931125958512655759734573015333642630767985443385761715333462325270572005303988289499034259566232975782488735029259166825894456894655992658454762694528780516501720674785417887982276806536650641910973434528878338621726156269582654478205672987756426325321594294418039943217000090542650763095588465895171709147607437136893319469090981904501290307099566226620303182649365733698419555776963787624918852865686607600566025605445711337286840205574416030837052312242587223438854123179481388550075689381124935386318635287083799845692619981794523364087429591180747453419551420351726184200845509170845682368200897739455842679214273477560879644279202708312150156406341341617166448069815483764491573900121217041547872591998943825364950514771379399147205219529079396137621107238494290616357604596231253506068537651423115349665683715116604220796394466621163255157729070978473156278277598788136491951257483328793771571459091064841642678309949723674420175862269402159407924480541255360431317992696739157542419296607312393763542139230617876753958711436104089409966089471418340698362993675362621545247298464213752891079884381306095552622720837518629837066787224430195793793786072107254277289071732854874374355781966511716618330881129120245204048682200072344035025448202834254187884653602591506445271657700044521097735585897622655484941621714989532383421600114062950718490427789258552743035221396835679018076406042138307308774460170842688272261177180842664333651780002171903449234264266292261456004337383868335555343453004264818473989215627086095650629340405264943244261445665921291225648893569655009154306426134252668472594914314239398845432486327461842846655985332312210466259890141712103446084271616619001257195870793217569698544013397622096749454185407118446433946990162698351607848924514058940946395267807354579700307051163682519487701189764002827648414160587206184185297189154019688253289309149665345753571427318482016384644832499037886069008072709327673127581966563941148961716832980455139729506687604740915420428429993541025829113502241690769431668574242522509026939034814856451303069925199590436384028429267412573422447765584177886171737265462085498294498946787350929581652632072258992368768457017823038096567883112289305809140572610865884845873101658151167533327674887014829167419701512559782572707406431808601428149024146780472327597684269633935773542930186739439716388611764209004068663398856841681003872389214483176070116684503887212364367043314091155733280182977988736590916659612402021778558854876176161989370794380056663364884365089144805571039765214696027662583599051987042300179465536788"}, {"sha": "58d8f3b6dd433d041d0c02f16950b252e1be3860", "filename": "libgo/go/compress/testdata/pi.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Ftestdata%2Fpi.txt?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1 @@\n+3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275900994657640789512694683983525957098258226205224894077267194782684826014769909026401363944374553050682034962524517493996514314298091906592509372216964615157098583874105978859597729754989301617539284681382686838689427741559918559252459539594310499725246808459872736446958486538367362226260991246080512438843904512441365497627807977156914359977001296160894416948685558484063534220722258284886481584560285060168427394522674676788952521385225499546667278239864565961163548862305774564980355936345681743241125150760694794510965960940252288797108931456691368672287489405601015033086179286809208747609178249385890097149096759852613655497818931297848216829989487226588048575640142704775551323796414515237462343645428584447952658678210511413547357395231134271661021359695362314429524849371871101457654035902799344037420073105785390621983874478084784896833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080951465502252316038819301420937621378559566389377870830390697920773467221825625996615014215030680384477345492026054146659252014974428507325186660021324340881907104863317346496514539057962685610055081066587969981635747363840525714591028970641401109712062804390397595156771577004203378699360072305587631763594218731251471205329281918261861258673215791984148488291644706095752706957220917567116722910981690915280173506712748583222871835209353965725121083579151369882091444210067510334671103141267111369908658516398315019701651511685171437657618351556508849099898599823873455283316355076479185358932261854896321329330898570642046752590709154814165498594616371802709819943099244889575712828905923233260972997120844335732654893823911932597463667305836041428138830320382490375898524374417029132765618093773444030707469211201913020330380197621101100449293215160842444859637669838952286847831235526582131449576857262433441893039686426243410773226978028073189154411010446823252716201052652272111660396665573092547110557853763466820653109896526918620564769312570586356620185581007293606598764861179104533488503461136576867532494416680396265797877185560845529654126654085306143444318586769751456614068007002378776591344017127494704205622305389945613140711270004078547332699390814546646458807972708266830634328587856983052358089330657574067954571637752542021149557615814002501262285941302164715509792592309907965473761255176567513575178296664547791745011299614890304639947132962107340437518957359614589019389713111790429782856475032031986915140287080859904801094121472213179476477726224142548545403321571853061422881375850430633217518297986622371721591607716692547487389866549494501146540628433663937900397692656721463853067360965712091807638327166416274888800786925602902284721040317211860820419000422966171196377921337575114959501566049631862947265473642523081770367515906735023507283540567040386743513622224771589150495309844489333096340878076932599397805419341447377441842631298608099888687413260472156951623965864573021631598193195167353812974167729478672422924654366800980676928238280689964004824354037014163149658979409243237896907069779422362508221688957383798623001593776471651228935786015881617557829735233446042815126272037343146531977774160319906655418763979293344195215413418994854447345673831624993419131814809277771038638773431772075456545322077709212019051660962804909263601975988281613323166636528619326686336062735676303544776280350450777235547105859548702790814356240145171806246436267945612753181340783303362542327839449753824372058353114771199260638133467768796959703098339130771098704085913374641442822772634659470474587847787201927715280731767907707157213444730605700733492436931138350493163128404251219256517980694113528013147013047816437885185290928545201165839341965621349143415956258658655705526904965209858033850722426482939728584783163057777560688876446248246857926039535277348030480290058760758251047470916439613626760449256274204208320856611906254543372131535958450687724602901618766795240616342522577195429162991930645537799140373404328752628889639958794757291746426357455254079091451357111369410911939325191076020825202618798531887705842972591677813149699009019211697173727847684726860849003377024242916513005005168323364350389517029893922334517220138128069650117844087451960121228599371623130171144484640903890644954440061986907548516026327505298349187407866808818338510228334508504860825039302133219715518430635455007668282949304137765527939751754613953984683393638304746119966538581538420568533862186725233402830871123282789212507712629463229563989898935821167456270102183564622013496715188190973038119800497340723961036854066431939509790190699639552453005450580685501956730229219139339185680344903982059551002263535361920419947455385938102343955449597783779023742161727111723643435439478221818528624085140066604433258885698670543154706965747458550332323342107301545940516553790686627333799585115625784322988273723198987571415957811196358330059408730681216028764962867446047746491599505497374256269010490377819868359381465741268049256487985561453723478673303904688383436346553794986419270563872931748723320837601123029911367938627089438799362016295154133714248928307220126901475466847653576164773794675200490757155527819653621323926406160136358155907422020203187277605277219005561484255518792530343513984425322341576233610642506390497500865627109535919465897514131034822769306247435363256916078154781811528436679570611086153315044521274739245449454236828860613408414863776700961207151249140430272538607648236341433462351897576645216413767969031495019108575984423919862916421939949072362346468441173940326591840443780513338945257423995082965912285085558215725031071257012668302402929525220118726767562204154205161841634847565169998116141010029960783869092916030288400269104140792886215078424516709087000699282120660418371806535567252532567532861291042487761825829765157959847035622262934860034158722980534989650226291748788202734209222245339856264766914905562842503912757710284027998066365825488926488025456610172967026640765590429099456815065265305371829412703369313785178609040708667114965583434347693385781711386455873678123014587687126603489139095620099393610310291616152881384379099042317473363948045759314931405297634757481193567091101377517210080315590248530906692037671922033229094334676851422144773793937517034436619910403375111735471918550464490263655128162288244625759163330391072253837421821408835086573917715096828874782656995995744906617583441375223970968340800535598491754173818839994469748676265516582765848358845314277568790029095170283529716344562129640435231176006651012412006597558512761785838292041974844236080071930457618932349229279650198751872127267507981255470958904556357921221033346697499235630254947802490114195212382815309114079073860251522742995818072471625916685451333123948049470791191532673430282441860414263639548000448002670496248201792896476697583183271314251702969234889627668440323260927524960357996469256504936818360900323809293459588970695365349406034021665443755890045632882250545255640564482465151875471196218443965825337543885690941130315095261793780029741207665147939425902989695946995565761218656196733786236256125216320862869222103274889218654364802296780705765615144632046927906821207388377814233562823608963208068222468012248261177185896381409183903673672220888321513755600372798394004152970028783076670944474560134556417254370906979396122571429894671543578468788614445812314593571984922528471605049221242470141214780573455105008019086996033027634787081081754501193071412233908663938339529425786905076431006383519834389341596131854347546495569781038293097164651438407007073604112373599843452251610507027056235266012764848308407611830130527932054274628654036036745328651057065874882256981579367897669742205750596834408697350201410206723585020072452256326513410559240190274216248439140359989535394590944070469120914093870012645600162374288021092764579310657922955249887275846101264836999892256959688159205600101655256375678"}, {"sha": "5a13ba82573c19097e63a33000cc3a75a36448a4", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -12,8 +12,8 @@ import (\n )\n \n var filenames = []string{\n-\t\"testdata/e.txt\",\n-\t\"testdata/pi.txt\",\n+\t\"../testdata/e.txt\",\n+\t\"../testdata/pi.txt\",\n }\n \n // Tests that compressing and then decompressing the given file at the given compression level"}, {"sha": "5925164e9db5f6c0e59dc4608bd22f2857ff753f", "filename": "libgo/go/container/ring/ring.go", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -138,16 +138,13 @@ func (r *Ring) Len() int {\n }\n \n \n-func (r *Ring) Iter() <-chan interface{} {\n-\tc := make(chan interface{})\n-\tgo func() {\n-\t\tif r != nil {\n-\t\t\tc <- r.Value\n-\t\t\tfor p := r.Next(); p != r; p = p.next {\n-\t\t\t\tc <- p.Value\n-\t\t\t}\n+// Do calls function f on each element of the ring, in forward order.\n+// The behavior of Do is undefined if f changes *r.\n+func (r *Ring) Do(f func(interface{})) {\n+\tif r != nil {\n+\t\tf(r.Value)\n+\t\tfor p := r.Next(); p != r; p = p.next {\n+\t\t\tf(p.Value)\n \t\t}\n-\t\tclose(c)\n-\t}()\n-\treturn c\n+\t}\n }"}, {"sha": "778c083d02bfd4ec65560ef9fe508b6c99bcf9f8", "filename": "libgo/go/container/ring/ring_test.go", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fring%2Fring_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -35,12 +35,12 @@ func verify(t *testing.T, r *Ring, N int, sum int) {\n \t// iteration\n \tn = 0\n \ts := 0\n-\tfor p := range r.Iter() {\n+\tr.Do(func(p interface{}) {\n \t\tn++\n \t\tif p != nil {\n \t\t\ts += p.(int)\n \t\t}\n-\t}\n+\t})\n \tif n != N {\n \t\tt.Errorf(\"number of forward iterations == %d; expected %d\", n, N)\n \t}\n@@ -128,16 +128,6 @@ func makeN(n int) *Ring {\n \treturn r\n }\n \n-\n-func sum(r *Ring) int {\n-\ts := 0\n-\tfor p := range r.Iter() {\n-\t\ts += p.(int)\n-\t}\n-\treturn s\n-}\n-\n-\n func sumN(n int) int { return (n*n + n) / 2 }\n \n "}, {"sha": "b2d87759115cd132dd15344816c2daeb78762efa", "filename": "libgo/go/crypto/cipher/ocfb.go", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -12,11 +12,21 @@ type ocfbEncrypter struct {\n \toutUsed int\n }\n \n+// An OCFBResyncOption determines if the \"resynchronization step\" of OCFB is\n+// performed.\n+type OCFBResyncOption bool\n+\n+const (\n+\tOCFBResync   OCFBResyncOption = true\n+\tOCFBNoResync OCFBResyncOption = false\n+)\n+\n // NewOCFBEncrypter returns a Stream which encrypts data with OpenPGP's cipher\n // feedback mode using the given Block, and an initial amount of ciphertext.\n // randData must be random bytes and be the same length as the Block's block\n-// size.\n-func NewOCFBEncrypter(block Block, randData []byte) (Stream, []byte) {\n+// size. Resync determines if the \"resynchronization step\" from RFC 4880, 13.9\n+// step 7 is performed. Different parts of OpenPGP vary on this point.\n+func NewOCFBEncrypter(block Block, randData []byte, resync OCFBResyncOption) (Stream, []byte) {\n \tblockSize := block.BlockSize()\n \tif len(randData) != blockSize {\n \t\treturn nil, nil\n@@ -38,7 +48,13 @@ func NewOCFBEncrypter(block Block, randData []byte) (Stream, []byte) {\n \tprefix[blockSize] = x.fre[0] ^ randData[blockSize-2]\n \tprefix[blockSize+1] = x.fre[1] ^ randData[blockSize-1]\n \n-\tblock.Encrypt(x.fre, prefix[2:])\n+\tif resync {\n+\t\tblock.Encrypt(x.fre, prefix[2:])\n+\t} else {\n+\t\tx.fre[0] = prefix[blockSize]\n+\t\tx.fre[1] = prefix[blockSize+1]\n+\t\tx.outUsed = 2\n+\t}\n \treturn x, prefix\n }\n \n@@ -64,8 +80,10 @@ type ocfbDecrypter struct {\n // NewOCFBDecrypter returns a Stream which decrypts data with OpenPGP's cipher\n // feedback mode using the given Block. Prefix must be the first blockSize + 2\n // bytes of the ciphertext, where blockSize is the Block's block size. If an\n-// incorrect key is detected then nil is returned.\n-func NewOCFBDecrypter(block Block, prefix []byte) Stream {\n+// incorrect key is detected then nil is returned. Resync determines if the\n+// \"resynchronization step\" from RFC 4880, 13.9 step 7 is performed. Different\n+// parts of OpenPGP vary on this point.\n+func NewOCFBDecrypter(block Block, prefix []byte, resync OCFBResyncOption) Stream {\n \tblockSize := block.BlockSize()\n \tif len(prefix) != blockSize+2 {\n \t\treturn nil\n@@ -93,7 +111,13 @@ func NewOCFBDecrypter(block Block, prefix []byte) Stream {\n \t\treturn nil\n \t}\n \n-\tblock.Encrypt(x.fre, prefix[2:])\n+\tif resync {\n+\t\tblock.Encrypt(x.fre, prefix[2:])\n+\t} else {\n+\t\tx.fre[0] = prefix[blockSize]\n+\t\tx.fre[1] = prefix[blockSize+1]\n+\t\tx.outUsed = 2\n+\t}\n \treturn x\n }\n "}, {"sha": "40938b589233819bdbadbee3c6f51faebcda1293", "filename": "libgo/go/crypto/cipher/ocfb_test.go", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -11,29 +11,34 @@ import (\n \t\"testing\"\n )\n \n-func TestOCFB(t *testing.T) {\n+func testOCFB(t *testing.T, resync OCFBResyncOption) {\n \tblock, err := aes.NewCipher(commonKey128)\n \tif err != nil {\n \t\tt.Error(err)\n \t\treturn\n \t}\n \n-\tplaintext := []byte(\"this is the plaintext\")\n+\tplaintext := []byte(\"this is the plaintext, which is long enough to span several blocks.\")\n \trandData := make([]byte, block.BlockSize())\n \trand.Reader.Read(randData)\n-\tocfb, prefix := NewOCFBEncrypter(block, randData)\n+\tocfb, prefix := NewOCFBEncrypter(block, randData, resync)\n \tciphertext := make([]byte, len(plaintext))\n \tocfb.XORKeyStream(ciphertext, plaintext)\n \n-\tocfbdec := NewOCFBDecrypter(block, prefix)\n+\tocfbdec := NewOCFBDecrypter(block, prefix, resync)\n \tif ocfbdec == nil {\n-\t\tt.Error(\"NewOCFBDecrypter failed\")\n+\t\tt.Errorf(\"NewOCFBDecrypter failed (resync: %t)\", resync)\n \t\treturn\n \t}\n \tplaintextCopy := make([]byte, len(plaintext))\n \tocfbdec.XORKeyStream(plaintextCopy, ciphertext)\n \n \tif !bytes.Equal(plaintextCopy, plaintext) {\n-\t\tt.Errorf(\"got: %x, want: %x\", plaintextCopy, plaintext)\n+\t\tt.Errorf(\"got: %x, want: %x (resync: %t)\", plaintextCopy, plaintext, resync)\n \t}\n }\n+\n+func TestOCFB(t *testing.T) {\n+\ttestOCFB(t, OCFBNoResync)\n+\ttestOCFB(t, OCFBResync)\n+}"}, {"sha": "be6b34adf28442c9f3dbe1a9c8e838df7f44dc3e", "filename": "libgo/go/crypto/crypto.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The crypto package collects common cryptographic constants.\n+package crypto\n+\n+import (\n+\t\"hash\"\n+)\n+\n+// Hash identifies a cryptographic hash function that is implemented in another\n+// package.\n+type Hash uint\n+\n+const (\n+\tMD4       Hash = 1 + iota // in package crypto/md4\n+\tMD5                       // in package crypto/md5\n+\tSHA1                      // in package crypto/sha1\n+\tSHA224                    // in package crypto/sha256\n+\tSHA256                    // in package crypto/sha256\n+\tSHA384                    // in package crypto/sha512\n+\tSHA512                    // in package crypto/sha512\n+\tMD5SHA1                   // no implementation; MD5+SHA1 used for TLS RSA\n+\tRIPEMD160                 // in package crypto/ripemd160\n+\tmaxHash\n+)\n+\n+var digestSizes = []uint8{\n+\tMD4:       16,\n+\tMD5:       16,\n+\tSHA1:      20,\n+\tSHA224:    28,\n+\tSHA256:    32,\n+\tSHA384:    48,\n+\tSHA512:    64,\n+\tMD5SHA1:   36,\n+\tRIPEMD160: 20,\n+}\n+\n+// Size returns the length, in bytes, of a digest resulting from the given hash\n+// function. It doesn't require that the hash function in question be linked\n+// into the program.\n+func (h Hash) Size() int {\n+\tif h > 0 && h < maxHash {\n+\t\treturn int(digestSizes[h])\n+\t}\n+\tpanic(\"crypto: Size of unknown hash function\")\n+}\n+\n+var hashes = make([]func() hash.Hash, maxHash)\n+\n+// New returns a new hash.Hash calculating the given hash function. If the\n+// hash function is not linked into the binary, New returns nil.\n+func (h Hash) New() hash.Hash {\n+\tif h > 0 && h < maxHash {\n+\t\tf := hashes[h]\n+\t\tif f != nil {\n+\t\t\treturn f()\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// RegisterHash registers a function that returns a new instance of the given\n+// hash function. This is intended to be called from the init function in\n+// packages that implement hash functions.\n+func RegisterHash(h Hash, f func() hash.Hash) {\n+\tif h >= maxHash {\n+\t\tpanic(\"crypto: RegisterHash of unknown hash function\")\n+\t}\n+\thashes[h] = f\n+}"}, {"sha": "f0af8bb427ed2f6a0cf6cf289c25093952cfc0e3", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,276 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3\n+package dsa\n+\n+import (\n+\t\"big\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Parameters represents the domain parameters for a key. These parameters can\n+// be shared across many keys. The bit length of Q must be a multiple of 8.\n+type Parameters struct {\n+\tP, Q, G *big.Int\n+}\n+\n+// PublicKey represents a DSA public key.\n+type PublicKey struct {\n+\tParameters\n+\tY *big.Int\n+}\n+\n+// PrivateKey represents a DSA private key.\n+type PrivateKey struct {\n+\tPublicKey\n+\tX *big.Int\n+}\n+\n+type invalidPublicKeyError int\n+\n+func (invalidPublicKeyError) String() string {\n+\treturn \"crypto/dsa: invalid public key\"\n+}\n+\n+// InvalidPublicKeyError results when a public key is not usable by this code.\n+// FIPS is quite strict about the format of DSA keys, but other code may be\n+// less so. Thus, when using keys which may have been generated by other code,\n+// this error must be handled.\n+var InvalidPublicKeyError = invalidPublicKeyError(0)\n+\n+// ParameterSizes is a enumeration of the acceptable bit lengths of the primes\n+// in a set of DSA parameters. See FIPS 186-3, section 4.2.\n+type ParameterSizes int\n+\n+const (\n+\tL1024N160 ParameterSizes = iota\n+\tL2048N224\n+\tL2048N256\n+\tL3072N256\n+)\n+\n+// numMRTests is the number of Miller-Rabin primality tests that we perform. We\n+// pick the largest recommended number from table C.1 of FIPS 186-3.\n+const numMRTests = 64\n+\n+// GenerateParameters puts a random, valid set of DSA parameters into params.\n+// This function takes many seconds, even on fast machines.\n+func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) (err os.Error) {\n+\t// This function doesn't follow FIPS 186-3 exactly in that it doesn't\n+\t// use a verification seed to generate the primes. The verification\n+\t// seed doesn't appear to be exported or used by other code and\n+\t// omitting it makes the code cleaner.\n+\n+\tvar L, N int\n+\tswitch sizes {\n+\tcase L1024N160:\n+\t\tL = 1024\n+\t\tN = 160\n+\tcase L2048N224:\n+\t\tL = 2048\n+\t\tN = 224\n+\tcase L2048N256:\n+\t\tL = 2048\n+\t\tN = 256\n+\tcase L3072N256:\n+\t\tL = 3072\n+\t\tN = 256\n+\tdefault:\n+\t\treturn os.ErrorString(\"crypto/dsa: invalid ParameterSizes\")\n+\t}\n+\n+\tqBytes := make([]byte, N/8)\n+\tpBytes := make([]byte, L/8)\n+\n+\tq := new(big.Int)\n+\tp := new(big.Int)\n+\trem := new(big.Int)\n+\tone := new(big.Int)\n+\tone.SetInt64(1)\n+\n+GeneratePrimes:\n+\tfor {\n+\t\t_, err = io.ReadFull(rand, qBytes)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tqBytes[len(qBytes)-1] |= 1\n+\t\tqBytes[0] |= 0x80\n+\t\tq.SetBytes(qBytes)\n+\n+\t\tif !big.ProbablyPrime(q, numMRTests) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor i := 0; i < 4*L; i++ {\n+\t\t\t_, err = io.ReadFull(rand, pBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tpBytes[len(pBytes)-1] |= 1\n+\t\t\tpBytes[0] |= 0x80\n+\n+\t\t\tp.SetBytes(pBytes)\n+\t\t\trem.Mod(p, q)\n+\t\t\trem.Sub(rem, one)\n+\t\t\tp.Sub(p, rem)\n+\t\t\tif p.BitLen() < L {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif !big.ProbablyPrime(p, numMRTests) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tparams.P = p\n+\t\t\tparams.Q = q\n+\t\t\tbreak GeneratePrimes\n+\t\t}\n+\t}\n+\n+\th := new(big.Int)\n+\th.SetInt64(2)\n+\tg := new(big.Int)\n+\n+\tpm1 := new(big.Int).Sub(p, one)\n+\te := new(big.Int).Div(pm1, q)\n+\n+\tfor {\n+\t\tg.Exp(h, e, p)\n+\t\tif g.Cmp(one) == 0 {\n+\t\t\th.Add(h, one)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tparams.G = g\n+\t\treturn\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// GenerateKey generates a public&private key pair. The Parameters of the\n+// PrivateKey must already be valid (see GenerateParameters).\n+func GenerateKey(priv *PrivateKey, rand io.Reader) os.Error {\n+\tif priv.P == nil || priv.Q == nil || priv.G == nil {\n+\t\treturn os.ErrorString(\"crypto/dsa: parameters not set up before generating key\")\n+\t}\n+\n+\tx := new(big.Int)\n+\txBytes := make([]byte, priv.Q.BitLen()/8)\n+\n+\tfor {\n+\t\t_, err := io.ReadFull(rand, xBytes)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tx.SetBytes(xBytes)\n+\t\tif x.Sign() != 0 && x.Cmp(priv.Q) < 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tpriv.X = x\n+\tpriv.Y = new(big.Int)\n+\tpriv.Y.Exp(priv.G, x, priv.P)\n+\treturn nil\n+}\n+\n+// Sign signs an arbitrary length hash (which should be the result of hashing a\n+// larger message) using the private key, priv. It returns the signature as a\n+// pair of integers. The security of the private key depends on the entropy of\n+// rand.\n+func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err os.Error) {\n+\t// FIPS 186-3, section 4.6\n+\n+\tn := priv.Q.BitLen()\n+\tif n&7 != 0 {\n+\t\terr = InvalidPublicKeyError\n+\t\treturn\n+\t}\n+\tn >>= 3\n+\n+\tfor {\n+\t\tk := new(big.Int)\n+\t\tbuf := make([]byte, n)\n+\t\tfor {\n+\t\t\t_, err = io.ReadFull(rand, buf)\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tk.SetBytes(buf)\n+\t\t\tif k.Sign() > 0 && k.Cmp(priv.Q) < 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\tkInv := new(big.Int).ModInverse(k, priv.Q)\n+\n+\t\tr = new(big.Int).Exp(priv.G, k, priv.P)\n+\t\tr.Mod(r, priv.Q)\n+\n+\t\tif r.Sign() == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif n > len(hash) {\n+\t\t\tn = len(hash)\n+\t\t}\n+\t\tz := k.SetBytes(hash[:n])\n+\n+\t\ts = new(big.Int).Mul(priv.X, r)\n+\t\ts.Add(s, z)\n+\t\ts.Mod(s, priv.Q)\n+\t\ts.Mul(s, kInv)\n+\t\ts.Mod(s, priv.Q)\n+\n+\t\tif s.Sign() != 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// Verify verifies the signature in r, s of hash using the public key, pub. It\n+// returns true iff the signature is valid.\n+func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n+\t// FIPS 186-3, section 4.7\n+\n+\tif r.Sign() < 1 || r.Cmp(pub.Q) >= 0 {\n+\t\treturn false\n+\t}\n+\tif s.Sign() < 1 || s.Cmp(pub.Q) >= 0 {\n+\t\treturn false\n+\t}\n+\n+\tw := new(big.Int).ModInverse(s, pub.Q)\n+\n+\tn := pub.Q.BitLen()\n+\tif n&7 != 0 {\n+\t\treturn false\n+\t}\n+\tn >>= 3\n+\n+\tif n > len(hash) {\n+\t\tn = len(hash)\n+\t}\n+\tz := new(big.Int).SetBytes(hash[:n])\n+\n+\tu1 := new(big.Int).Mul(z, w)\n+\tu1.Mod(u1, pub.Q)\n+\tu2 := w.Mul(r, w)\n+\tu2.Mod(u2, pub.Q)\n+\tv := u1.Exp(pub.G, u1, pub.P)\n+\tu2.Exp(pub.Y, u2, pub.P)\n+\tv.Mul(v, u2)\n+\tv.Mod(v, pub.P)\n+\tv.Mod(v, pub.Q)\n+\n+\treturn v.Cmp(r) == 0\n+}"}, {"sha": "deec08dfd8adad17da19d68ff96dadcd6cf7219e", "filename": "libgo/go/crypto/dsa/dsa_test.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package dsa\n+\n+import (\n+\t\"big\"\n+\t\"crypto/rand\"\n+\t\"testing\"\n+)\n+\n+func testSignAndVerify(t *testing.T, i int, priv *PrivateKey) {\n+\thashed := []byte(\"testing\")\n+\tr, s, err := Sign(rand.Reader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%d: error signing: %s\", i, err)\n+\t\treturn\n+\t}\n+\n+\tif !Verify(&priv.PublicKey, hashed, r, s) {\n+\t\tt.Errorf(\"%d: Verify failed\", i)\n+\t}\n+}\n+\n+func testParameterGeneration(t *testing.T, sizes ParameterSizes, L, N int) {\n+\tvar priv PrivateKey\n+\tparams := &priv.Parameters\n+\n+\terr := GenerateParameters(params, rand.Reader, sizes)\n+\tif err != nil {\n+\t\tt.Errorf(\"%d: %s\", int(sizes), err)\n+\t\treturn\n+\t}\n+\n+\tif params.P.BitLen() != L {\n+\t\tt.Errorf(\"%d: params.BitLen got:%d want:%d\", int(sizes), params.P.BitLen(), L)\n+\t}\n+\n+\tif params.Q.BitLen() != N {\n+\t\tt.Errorf(\"%d: q.BitLen got:%d want:%d\", int(sizes), params.Q.BitLen(), L)\n+\t}\n+\n+\tone := new(big.Int)\n+\tone.SetInt64(1)\n+\tpm1 := new(big.Int).Sub(params.P, one)\n+\tquo, rem := new(big.Int).DivMod(pm1, params.Q, new(big.Int))\n+\tif rem.Sign() != 0 {\n+\t\tt.Errorf(\"%d: p-1 mod q != 0\", int(sizes))\n+\t}\n+\tx := new(big.Int).Exp(params.G, quo, params.P)\n+\tif x.Cmp(one) == 0 {\n+\t\tt.Errorf(\"%d: invalid generator\", int(sizes))\n+\t}\n+\n+\terr = GenerateKey(&priv, rand.Reader)\n+\tif err != nil {\n+\t\tt.Errorf(\"error generating key: %s\", err)\n+\t\treturn\n+\t}\n+\n+\ttestSignAndVerify(t, int(sizes), &priv)\n+}\n+\n+func TestParameterGeneration(t *testing.T) {\n+\t// This test is too slow to run all the time.\n+\treturn\n+\n+\ttestParameterGeneration(t, L1024N160, 1024, 160)\n+\ttestParameterGeneration(t, L2048N224, 2048, 224)\n+\ttestParameterGeneration(t, L2048N256, 2048, 256)\n+\ttestParameterGeneration(t, L3072N256, 3072, 256)\n+}\n+\n+func TestSignAndVerify(t *testing.T) {\n+\tvar priv PrivateKey\n+\tpriv.P, _ = new(big.Int).SetString(\"A9B5B793FB4785793D246BAE77E8FF63CA52F442DA763C440259919FE1BC1D6065A9350637A04F75A2F039401D49F08E066C4D275A5A65DA5684BC563C14289D7AB8A67163BFBF79D85972619AD2CFF55AB0EE77A9002B0EF96293BDD0F42685EBB2C66C327079F6C98000FBCB79AACDE1BC6F9D5C7B1A97E3D9D54ED7951FEF\", 16)\n+\tpriv.Q, _ = new(big.Int).SetString(\"E1D3391245933D68A0714ED34BBCB7A1F422B9C1\", 16)\n+\tpriv.G, _ = new(big.Int).SetString(\"634364FC25248933D01D1993ECABD0657CC0CB2CEED7ED2E3E8AECDFCDC4A25C3B15E9E3B163ACA2984B5539181F3EFF1A5E8903D71D5B95DA4F27202B77D2C44B430BB53741A8D59A8F86887525C9F2A6A5980A195EAA7F2FF910064301DEF89D3AA213E1FAC7768D89365318E370AF54A112EFBA9246D9158386BA1B4EEFDA\", 16)\n+\tpriv.Y, _ = new(big.Int).SetString(\"32969E5780CFE1C849A1C276D7AEB4F38A23B591739AA2FE197349AEEBD31366AEE5EB7E6C6DDB7C57D02432B30DB5AA66D9884299FAA72568944E4EEDC92EA3FBC6F39F53412FBCC563208F7C15B737AC8910DBC2D9C9B8C001E72FDC40EB694AB1F06A5A2DBD18D9E36C66F31F566742F11EC0A52E9F7B89355C02FB5D32D2\", 16)\n+\tpriv.X, _ = new(big.Int).SetString(\"5078D4D29795CBE76D3AACFE48C9AF0BCDBEE91A\", 16)\n+\n+\ttestSignAndVerify(t, 0, &priv)\n+}"}, {"sha": "ee46544a920b32ee67864c9ed7508016769126ea", "filename": "libgo/go/crypto/md4/md4.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd4%2Fmd4.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,10 +6,15 @@\n package md4\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.MD4, New)\n+}\n+\n // The size of an MD4 checksum in bytes.\n const Size = 16\n "}, {"sha": "8f93fc4b354eecf94a467bad45352dfe47462969", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,10 +6,15 @@\n package md5\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.MD5, New)\n+}\n+\n // The size of an MD5 checksum in bytes.\n const Size = 16\n "}, {"sha": "f42d8088884c30f0127f4c71468611af7f5b9e18", "filename": "libgo/go/crypto/ocsp/ocsp.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Focsp%2Focsp.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -9,8 +9,9 @@ package ocsp\n \n import (\n \t\"asn1\"\n+\t\"crypto\"\n \t\"crypto/rsa\"\n-\t\"crypto/sha1\"\n+\t_ \"crypto/sha1\"\n \t\"crypto/x509\"\n \t\"os\"\n \t\"time\"\n@@ -168,8 +169,8 @@ func ParseResponse(bytes []byte) (*Response, os.Error) {\n \t\treturn nil, x509.UnsupportedAlgorithmError{}\n \t}\n \n-\th := sha1.New()\n-\thashType := rsa.HashSHA1\n+\thashType := crypto.SHA1\n+\th := hashType.New()\n \n \tpub := ret.Certificate.PublicKey.(*rsa.PublicKey)\n \th.Write(basicResp.TBSResponseData.Raw)"}, {"sha": "0c5ae9d716c0b3e9aa47b74f645925fc907037be", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -112,7 +112,7 @@ func (l *lineReader) Read(p []byte) (n int, err os.Error) {\n \t\treturn 0, os.EOF\n \t}\n \n-\tif len(line) != 64 {\n+\tif len(line) > 64 {\n \t\treturn 0, ArmorCorrupt\n \t}\n "}, {"sha": "9334e94e96cdd01c35180f88b2d81a667bb35ab5", "filename": "libgo/go/crypto/openpgp/armor/armor_test.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -34,7 +34,7 @@ func TestDecodeEncode(t *testing.T) {\n \t\tt.Error(err)\n \t}\n \n-\tif adler32.Checksum(contents) != 0x789d7f00 {\n+\tif adler32.Checksum(contents) != 0x27b144be {\n \t\tt.Errorf(\"contents: got: %x\", contents)\n \t}\n \n@@ -73,13 +73,11 @@ func TestLongHeader(t *testing.T) {\n const armorExample1 = `-----BEGIN PGP SIGNATURE-----\n Version: GnuPG v1.4.10 (GNU/Linux)\n \n-iQEcBAABAgAGBQJMtFESAAoJEKsQXJGvOPsVj40H/1WW6jaMXv4BW+1ueDSMDwM8\n-kx1fLOXbVM5/Kn5LStZNt1jWWnpxdz7eq3uiqeCQjmqUoRde3YbB2EMnnwRbAhpp\n-cacnAvy9ZQ78OTxUdNW1mhX5bS6q1MTEJnl+DcyigD70HG/yNNQD7sOPMdYQw0TA\n-byQBwmLwmTsuZsrYqB68QyLHI+DUugn+kX6Hd2WDB62DKa2suoIUIHQQCd/ofwB3\n-WfCYInXQKKOSxu2YOg2Eb4kLNhSMc1i9uKUWAH+sdgJh7NBgdoE4MaNtBFkHXRvv\n-okWuf3+xA9ksp1npSY/mDvgHijmjvtpRDe6iUeqfCn8N9u9CBg8geANgaG8+QA4=\n-=wfQG\n+iJwEAAECAAYFAk1Fv/0ACgkQo01+GMIMMbsYTwQAiAw+QAaNfY6WBdplZ/uMAccm\n+4g+81QPmTSGHnetSb6WBiY13kVzK4HQiZH8JSkmmroMLuGeJwsRTEL4wbjRyUKEt\n+p1xwUZDECs234F1xiG5enc5SGlRtP7foLBz9lOsjx+LEcA4sTl5/2eZR9zyFZqWW\n+TxRjs+fJCIFuo71xb1g=\n+=/teI\n -----END PGP SIGNATURE-----`\n \n const armorLongLine = `-----BEGIN PGP SIGNATURE-----"}, {"sha": "0f7de024127784358e186083c58f1c6b602ca9c4", "filename": "libgo/go/crypto/openpgp/armor/encode.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Fencode.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -116,6 +116,7 @@ func (e *encoding) Close() (err os.Error) {\n \tif err != nil {\n \t\treturn\n \t}\n+\te.breaker.Close()\n \n \tvar checksumBytes [3]byte\n \tchecksumBytes[0] = byte(e.crc >> 16)\n@@ -144,11 +145,9 @@ func Encode(out io.Writer, blockType string, headers map[string]string) (w io.Wr\n \t\t}\n \t}\n \n-\tif len(headers) > 0 {\n-\t\t_, err := out.Write(newline)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n+\t_, err = out.Write(newline)\n+\tif err != nil {\n+\t\treturn\n \t}\n \n \te := &encoding{"}, {"sha": "293eff3542db5a6a7d5042e418bf1e310465588d", "filename": "libgo/go/crypto/openpgp/canonical_text.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"hash\"\n+\t\"os\"\n+)\n+\n+// NewCanonicalTextHash reformats text written to it into the canonical\n+// form and then applies the hash h.  See RFC 4880, section 5.2.1.\n+func NewCanonicalTextHash(h hash.Hash) hash.Hash {\n+\treturn &canonicalTextHash{h, 0}\n+}\n+\n+type canonicalTextHash struct {\n+\th hash.Hash\n+\ts int\n+}\n+\n+var newline = []byte{'\\r', '\\n'}\n+\n+func (cth *canonicalTextHash) Write(buf []byte) (int, os.Error) {\n+\tstart := 0\n+\n+\tfor i, c := range buf {\n+\t\tswitch cth.s {\n+\t\tcase 0:\n+\t\t\tif c == '\\r' {\n+\t\t\t\tcth.s = 1\n+\t\t\t} else if c == '\\n' {\n+\t\t\t\tcth.h.Write(buf[start:i])\n+\t\t\t\tcth.h.Write(newline)\n+\t\t\t\tstart = i + 1\n+\t\t\t}\n+\t\tcase 1:\n+\t\t\tcth.s = 0\n+\t\t}\n+\t}\n+\n+\tcth.h.Write(buf[start:])\n+\treturn len(buf), nil\n+}\n+\n+func (cth *canonicalTextHash) Sum() []byte {\n+\treturn cth.h.Sum()\n+}\n+\n+func (cth *canonicalTextHash) Reset() {\n+\tcth.h.Reset()\n+\tcth.s = 0\n+}\n+\n+func (cth *canonicalTextHash) Size() int {\n+\treturn cth.h.Size()\n+}"}, {"sha": "69ecf91a8359841a409cc4d7ebb949fb92f5ee56", "filename": "libgo/go/crypto/openpgp/canonical_text_test.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fcanonical_text_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+type recordingHash struct {\n+\tbuf *bytes.Buffer\n+}\n+\n+func (r recordingHash) Write(b []byte) (n int, err os.Error) {\n+\treturn r.buf.Write(b)\n+}\n+\n+func (r recordingHash) Sum() []byte {\n+\treturn r.buf.Bytes()\n+}\n+\n+func (r recordingHash) Reset() {\n+\tpanic(\"shouldn't be called\")\n+}\n+\n+func (r recordingHash) Size() int {\n+\tpanic(\"shouldn't be called\")\n+}\n+\n+\n+func testCanonicalText(t *testing.T, input, expected string) {\n+\tr := recordingHash{bytes.NewBuffer(nil)}\n+\tc := NewCanonicalTextHash(r)\n+\tc.Write([]byte(input))\n+\tresult := c.Sum()\n+\tif expected != string(result) {\n+\t\tt.Errorf(\"input: %x got: %x want: %x\", input, result, expected)\n+\t}\n+}\n+\n+func TestCanonicalText(t *testing.T) {\n+\ttestCanonicalText(t, \"foo\\n\", \"foo\\r\\n\")\n+\ttestCanonicalText(t, \"foo\", \"foo\")\n+\ttestCanonicalText(t, \"foo\\r\\n\", \"foo\\r\\n\")\n+\ttestCanonicalText(t, \"foo\\r\\nbar\", \"foo\\r\\nbar\")\n+\ttestCanonicalText(t, \"foo\\r\\nbar\\n\\n\", \"foo\\r\\nbar\\r\\n\\r\\n\")\n+}"}, {"sha": "053d159672627c0bf64b8344befcf0c7b14b4f9d", "filename": "libgo/go/crypto/openpgp/error/error.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -5,6 +5,10 @@\n // This package contains common error types for the OpenPGP packages.\n package error\n \n+import (\n+\t\"strconv\"\n+)\n+\n // A StructuralError is returned when OpenPGP data is found to be syntactically\n // invalid.\n type StructuralError string\n@@ -44,3 +48,17 @@ func (ki keyIncorrect) String() string {\n }\n \n var KeyIncorrectError = keyIncorrect(0)\n+\n+type unknownIssuer int\n+\n+func (unknownIssuer) String() string {\n+\treturn \"signature make by unknown entity\"\n+}\n+\n+var UnknownIssuerError = unknownIssuer(0)\n+\n+type UnknownPacketTypeError uint8\n+\n+func (upte UnknownPacketTypeError) String() string {\n+\treturn \"unknown OpenPGP packet type: \" + strconv.Itoa(int(upte))\n+}"}, {"sha": "ecaa86f2828adc9157d44a48591e88ae9e4fcd49", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,280 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/packet\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// PublicKeyType is the armor type for a PGP public key.\n+var PublicKeyType = \"PGP PUBLIC KEY BLOCK\"\n+\n+// An Entity represents the components of an OpenPGP key: a primary public key\n+// (which must be a signing key), one or more identities claimed by that key,\n+// and zero or more subkeys, which may be encryption keys.\n+type Entity struct {\n+\tPrimaryKey *packet.PublicKey\n+\tPrivateKey *packet.PrivateKey\n+\tIdentities map[string]*Identity // indexed by Identity.Name\n+\tSubkeys    []Subkey\n+}\n+\n+// An Identity represents an identity claimed by an Entity and zero or more\n+// assertions by other entities about that claim.\n+type Identity struct {\n+\tName          string // by convention, has the form \"Full Name (comment) <email@example.com>\"\n+\tUserId        *packet.UserId\n+\tSelfSignature *packet.Signature\n+\tSignatures    []*packet.Signature\n+}\n+\n+// A Subkey is an additional public key in an Entity. Subkeys can be used for\n+// encryption.\n+type Subkey struct {\n+\tPublicKey  *packet.PublicKey\n+\tPrivateKey *packet.PrivateKey\n+\tSig        *packet.Signature\n+}\n+\n+// A Key identifies a specific public key in an Entity. This is either the\n+// Entity's primary key or a subkey.\n+type Key struct {\n+\tEntity        *Entity\n+\tPublicKey     *packet.PublicKey\n+\tPrivateKey    *packet.PrivateKey\n+\tSelfSignature *packet.Signature\n+}\n+\n+// A KeyRing provides access to public and private keys.\n+type KeyRing interface {\n+\t// KeysById returns the set of keys that have the given key id.\n+\tKeysById(id uint64) []Key\n+\t// DecryptionKeys returns all private keys that are valid for\n+\t// decryption.\n+\tDecryptionKeys() []Key\n+}\n+\n+// An EntityList contains one or more Entities.\n+type EntityList []*Entity\n+\n+// KeysById returns the set of keys that have the given key id.\n+func (el EntityList) KeysById(id uint64) (keys []Key) {\n+\tfor _, e := range el {\n+\t\tif e.PrimaryKey.KeyId == id {\n+\t\t\tvar selfSig *packet.Signature\n+\t\t\tfor _, ident := range e.Identities {\n+\t\t\t\tif selfSig == nil {\n+\t\t\t\t\tselfSig = ident.SelfSignature\n+\t\t\t\t} else if ident.SelfSignature.IsPrimaryId != nil && *ident.SelfSignature.IsPrimaryId {\n+\t\t\t\t\tselfSig = ident.SelfSignature\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tkeys = append(keys, Key{e, e.PrimaryKey, e.PrivateKey, selfSig})\n+\t\t}\n+\n+\t\tfor _, subKey := range e.Subkeys {\n+\t\t\tif subKey.PublicKey.KeyId == id {\n+\t\t\t\tkeys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// DecryptionKeys returns all private keys that are valid for decryption.\n+func (el EntityList) DecryptionKeys() (keys []Key) {\n+\tfor _, e := range el {\n+\t\tfor _, subKey := range e.Subkeys {\n+\t\t\tif subKey.PrivateKey != nil && (!subKey.Sig.FlagsValid || subKey.Sig.FlagEncryptStorage || subKey.Sig.FlagEncryptCommunications) {\n+\t\t\t\tkeys = append(keys, Key{e, subKey.PublicKey, subKey.PrivateKey, subKey.Sig})\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// ReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.\n+func ReadArmoredKeyRing(r io.Reader) (EntityList, os.Error) {\n+\tbody, err := readArmored(r, PublicKeyType)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn ReadKeyRing(body)\n+}\n+\n+// ReadKeyRing reads one or more public/private keys, ignoring unsupported keys.\n+func ReadKeyRing(r io.Reader) (el EntityList, err os.Error) {\n+\tpackets := packet.NewReader(r)\n+\n+\tfor {\n+\t\tvar e *Entity\n+\t\te, err = readEntity(packets)\n+\t\tif err != nil {\n+\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\t\terr = readToNextPublicKey(packets)\n+\t\t\t}\n+\t\t\tif err == os.EOF {\n+\t\t\t\terr = nil\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tel = nil\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t} else {\n+\t\t\tel = append(el, e)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// readToNextPublicKey reads packets until the start of the entity and leaves\n+// the first packet of the new entity in the Reader.\n+func readToNextPublicKey(packets *packet.Reader) (err os.Error) {\n+\tvar p packet.Packet\n+\tfor {\n+\t\tp, err = packets.Next()\n+\t\tif err == os.EOF {\n+\t\t\treturn\n+\t\t} else if err != nil {\n+\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\t\terr = nil\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif pk, ok := p.(*packet.PublicKey); ok && !pk.IsSubkey {\n+\t\t\tpackets.Unread(p)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// readEntity reads an entity (public key, identities, subkeys etc) from the\n+// given Reader.\n+func readEntity(packets *packet.Reader) (*Entity, os.Error) {\n+\te := new(Entity)\n+\te.Identities = make(map[string]*Identity)\n+\n+\tp, err := packets.Next()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar ok bool\n+\tif e.PrimaryKey, ok = p.(*packet.PublicKey); !ok {\n+\t\tif e.PrivateKey, ok = p.(*packet.PrivateKey); !ok {\n+\t\t\tpackets.Unread(p)\n+\t\t\treturn nil, error.StructuralError(\"first packet was not a public/private key\")\n+\t\t} else {\n+\t\t\te.PrimaryKey = &e.PrivateKey.PublicKey\n+\t\t}\n+\t}\n+\n+\tvar current *Identity\n+EachPacket:\n+\tfor {\n+\t\tp, err := packets.Next()\n+\t\tif err == os.EOF {\n+\t\t\tbreak\n+\t\t} else if err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tswitch pkt := p.(type) {\n+\t\tcase *packet.UserId:\n+\t\t\tcurrent = new(Identity)\n+\t\t\tcurrent.Name = pkt.Id\n+\t\t\tcurrent.UserId = pkt\n+\t\t\te.Identities[pkt.Id] = current\n+\t\t\tp, err = packets.Next()\n+\t\t\tif err == os.EOF {\n+\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\tif _, ok := err.(error.UnsupportedError); ok {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\treturn nil, error.StructuralError(\"identity self-signature invalid: \" + err.String())\n+\t\t\t}\n+\t\t\tcurrent.SelfSignature, ok = p.(*packet.Signature)\n+\t\t\tif !ok {\n+\t\t\t\treturn nil, error.StructuralError(\"user ID packet not followed by self signature\")\n+\t\t\t}\n+\t\t\tif current.SelfSignature.SigType != packet.SigTypePositiveCert {\n+\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature with wrong type\")\n+\t\t\t}\n+\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, current.SelfSignature); err != nil {\n+\t\t\t\treturn nil, error.StructuralError(\"user ID self-signature invalid: \" + err.String())\n+\t\t\t}\n+\t\tcase *packet.Signature:\n+\t\t\tif current == nil {\n+\t\t\t\treturn nil, error.StructuralError(\"signature packet found before user id packet\")\n+\t\t\t}\n+\t\t\tcurrent.Signatures = append(current.Signatures, pkt)\n+\t\tcase *packet.PrivateKey:\n+\t\t\tif pkt.IsSubkey == false {\n+\t\t\t\tpackets.Unread(p)\n+\t\t\t\tbreak EachPacket\n+\t\t\t}\n+\t\t\terr = addSubkey(e, packets, &pkt.PublicKey, pkt)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\tcase *packet.PublicKey:\n+\t\t\tif pkt.IsSubkey == false {\n+\t\t\t\tpackets.Unread(p)\n+\t\t\t\tbreak EachPacket\n+\t\t\t}\n+\t\t\terr = addSubkey(e, packets, pkt, nil)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// we ignore unknown packets\n+\t\t}\n+\t}\n+\n+\tif len(e.Identities) == 0 {\n+\t\treturn nil, error.StructuralError(\"entity without any identities\")\n+\t}\n+\n+\treturn e, nil\n+}\n+\n+func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *packet.PrivateKey) os.Error {\n+\tvar subKey Subkey\n+\tsubKey.PublicKey = pub\n+\tsubKey.PrivateKey = priv\n+\tp, err := packets.Next()\n+\tif err == os.EOF {\n+\t\treturn io.ErrUnexpectedEOF\n+\t}\n+\tif err != nil {\n+\t\treturn error.StructuralError(\"subkey signature invalid: \" + err.String())\n+\t}\n+\tvar ok bool\n+\tsubKey.Sig, ok = p.(*packet.Signature)\n+\tif !ok {\n+\t\treturn error.StructuralError(\"subkey packet not followed by signature\")\n+\t}\n+\tif subKey.Sig.SigType != packet.SigTypeSubkeyBinding {\n+\t\treturn error.StructuralError(\"subkey signature with wrong type\")\n+\t}\n+\terr = e.PrimaryKey.VerifyKeySignature(subKey.PublicKey, subKey.Sig)\n+\tif err != nil {\n+\t\treturn error.StructuralError(\"subkey signature invalid: \" + err.String())\n+\t}\n+\te.Subkeys = append(e.Subkeys, subKey)\n+\treturn nil\n+}"}, {"sha": "1c15c24c4b60b648703c43660bf8dd3623d2427d", "filename": "libgo/go/crypto/openpgp/packet/compressed.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"compress/flate\"\n+\t\"compress/zlib\"\n+\t\"crypto/openpgp/error\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// Compressed represents a compressed OpenPGP packet. The decompressed contents\n+// will contain more OpenPGP packets. See RFC 4880, section 5.6.\n+type Compressed struct {\n+\tBody io.Reader\n+}\n+\n+func (c *Compressed) parse(r io.Reader) os.Error {\n+\tvar buf [1]byte\n+\t_, err := readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tswitch buf[0] {\n+\tcase 1:\n+\t\tc.Body = flate.NewReader(r)\n+\tcase 2:\n+\t\tc.Body, err = zlib.NewReader(r)\n+\tdefault:\n+\t\terr = error.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n+\t}\n+\n+\treturn err\n+}"}, {"sha": "24fe501edbab96cbc4b3995c27ac461715ccc933", "filename": "libgo/go/crypto/openpgp/packet/compressed_test.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/hex\"\n+\t\"os\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+func TestCompressed(t *testing.T) {\n+\tpacket, err := Read(readerFromHex(compressedHex))\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to read Compressed: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tc, ok := packet.(*Compressed)\n+\tif !ok {\n+\t\tt.Error(\"didn't find Compressed packet\")\n+\t\treturn\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(c.Body)\n+\tif err != nil && err != os.EOF {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\texpected, _ := hex.DecodeString(compressedExpectedHex)\n+\tif !bytes.Equal(expected, contents) {\n+\t\tt.Errorf(\"got:%x want:%x\", contents, expected)\n+\t}\n+}\n+\n+const compressedHex = \"a3013b2d90c4e02b72e25f727e5e496a5e49b11e1700\"\n+const compressedExpectedHex = \"cb1062004d14c8fe636f6e74656e74732e0a\""}, {"sha": "b11a9b8301af696910e2ac5d1db9f72a45ad4c2a", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key.go", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// EncryptedKey represents a public-key encrypted session key. See RFC 4880,\n+// section 5.1.\n+type EncryptedKey struct {\n+\tKeyId      uint64\n+\tAlgo       PublicKeyAlgorithm\n+\tEncrypted  []byte\n+\tCipherFunc CipherFunction // only valid after a successful Decrypt\n+\tKey        []byte         // only valid after a successful Decrypt\n+}\n+\n+func (e *EncryptedKey) parse(r io.Reader) (err os.Error) {\n+\tvar buf [10]byte\n+\t_, err = readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0] != 3 {\n+\t\treturn error.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n+\t}\n+\te.KeyId = binary.BigEndian.Uint64(buf[1:9])\n+\te.Algo = PublicKeyAlgorithm(buf[9])\n+\tif e.Algo == PubKeyAlgoRSA || e.Algo == PubKeyAlgoRSAEncryptOnly {\n+\t\te.Encrypted, _, err = readMPI(r)\n+\t}\n+\t_, err = consumeAll(r)\n+\treturn\n+}\n+\n+// DecryptRSA decrypts an RSA encrypted session key with the given private key.\n+func (e *EncryptedKey) DecryptRSA(priv *rsa.PrivateKey) (err os.Error) {\n+\tif e.Algo != PubKeyAlgoRSA && e.Algo != PubKeyAlgoRSAEncryptOnly {\n+\t\treturn error.InvalidArgumentError(\"EncryptedKey not RSA encrypted\")\n+\t}\n+\tb, err := rsa.DecryptPKCS1v15(rand.Reader, priv, e.Encrypted)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\te.CipherFunc = CipherFunction(b[0])\n+\te.Key = b[1 : len(b)-2]\n+\texpectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])\n+\tvar checksum uint16\n+\tfor _, v := range e.Key {\n+\t\tchecksum += uint16(v)\n+\t}\n+\tif checksum != expectedChecksum {\n+\t\treturn error.StructuralError(\"EncryptedKey checksum incorrect\")\n+\t}\n+\n+\treturn\n+}"}, {"sha": "755ae7a3074c8b2d4313276f260961c6bf549da2", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"big\"\n+\t\"crypto/rsa\"\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func bigFromBase10(s string) *big.Int {\n+\tb, ok := new(big.Int).SetString(s, 10)\n+\tif !ok {\n+\t\tpanic(\"bigFromBase10 failed\")\n+\t}\n+\treturn b\n+}\n+\n+func TestEncryptedKey(t *testing.T) {\n+\tp, err := Read(readerFromHex(encryptedKeyHex))\n+\tif err != nil {\n+\t\tt.Errorf(\"error from Read: %s\", err)\n+\t\treturn\n+\t}\n+\tek, ok := p.(*EncryptedKey)\n+\tif !ok {\n+\t\tt.Errorf(\"didn't parse an EncryptedKey, got %#v\", p)\n+\t\treturn\n+\t}\n+\n+\tif ek.KeyId != 0x2a67d68660df41c7 || ek.Algo != PubKeyAlgoRSA {\n+\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n+\t\treturn\n+\t}\n+\n+\tpub := rsa.PublicKey{\n+\t\tE: 65537,\n+\t\tN: bigFromBase10(\"115804063926007623305902631768113868327816898845124614648849934718568541074358183759250136204762053879858102352159854352727097033322663029387610959884180306668628526686121021235757016368038585212410610742029286439607686208110250133174279811431933746643015923132833417396844716207301518956640020862630546868823\"),\n+\t}\n+\n+\tpriv := &rsa.PrivateKey{\n+\t\tPublicKey: pub,\n+\t\tD:         bigFromBase10(\"32355588668219869544751561565313228297765464314098552250409557267371233892496951383426602439009993875125222579159850054973310859166139474359774543943714622292329487391199285040721944491839695981199720170366763547754915493640685849961780092241140181198779299712578774460837139360803883139311171713302987058393\"),\n+\t}\n+\n+\terr = ek.DecryptRSA(priv)\n+\tif err != nil {\n+\t\tt.Errorf(\"error from DecryptRSA: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif ek.CipherFunc != CipherAES256 {\n+\t\tt.Errorf(\"unexpected EncryptedKey contents: %#v\", ek)\n+\t\treturn\n+\t}\n+\n+\tkeyHex := fmt.Sprintf(\"%x\", ek.Key)\n+\tif keyHex != expectedKeyHex {\n+\t\tt.Errorf(\"bad key, got %s want %x\", keyHex, expectedKeyHex)\n+\t}\n+}\n+\n+const encryptedKeyHex = \"c18c032a67d68660df41c70104005789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8\"\n+const expectedKeyHex = \"d930363f7e0308c333b9618617ea728963d8df993665ae7be1092d4926fd864b\""}, {"sha": "04f50e53e130da9ecfcbeddf98f9679e43ece29f", "filename": "libgo/go/crypto/openpgp/packet/literal.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fliteral.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// LiteralData represents an encrypted file. See RFC 4880, section 5.9.\n+type LiteralData struct {\n+\tIsBinary bool\n+\tFileName string\n+\tTime     uint32 // Unix epoch time. Either creation time or modification time. 0 means undefined.\n+\tBody     io.Reader\n+}\n+\n+// ForEyesOnly returns whether the contents of the LiteralData have been marked\n+// as especially sensitive.\n+func (l *LiteralData) ForEyesOnly() bool {\n+\treturn l.FileName == \"_CONSOLE\"\n+}\n+\n+func (l *LiteralData) parse(r io.Reader) (err os.Error) {\n+\tvar buf [256]byte\n+\n+\t_, err = readFull(r, buf[:2])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tl.IsBinary = buf[0] == 'b'\n+\tfileNameLen := int(buf[1])\n+\n+\t_, err = readFull(r, buf[:fileNameLen])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tl.FileName = string(buf[:fileNameLen])\n+\n+\t_, err = readFull(r, buf[:4])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tl.Time = binary.BigEndian.Uint32(buf[:4])\n+\tl.Body = r\n+\treturn\n+}"}, {"sha": "acbf58bbefb319e927c2570d5ac4cf5de11b5364", "filename": "libgo/go/crypto/openpgp/packet/one_pass_signature.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/s2k\"\n+\t\"encoding/binary\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// OnePassSignature represents a one-pass signature packet. See RFC 4880,\n+// section 5.4.\n+type OnePassSignature struct {\n+\tSigType    SignatureType\n+\tHash       crypto.Hash\n+\tPubKeyAlgo PublicKeyAlgorithm\n+\tKeyId      uint64\n+\tIsLast     bool\n+}\n+\n+func (ops *OnePassSignature) parse(r io.Reader) (err os.Error) {\n+\tvar buf [13]byte\n+\n+\t_, err = readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0] != 3 {\n+\t\terr = error.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t}\n+\n+\tvar ok bool\n+\tops.Hash, ok = s2k.HashIdToHash(buf[2])\n+\tif !ok {\n+\t\treturn error.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n+\t}\n+\n+\tops.SigType = SignatureType(buf[1])\n+\tops.PubKeyAlgo = PublicKeyAlgorithm(buf[3])\n+\tops.KeyId = binary.BigEndian.Uint64(buf[4:12])\n+\tops.IsLast = buf[12] != 0\n+\treturn\n+}"}, {"sha": "269603ba4985557a0885db6c43a85697cf22a318", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,395 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This package implements parsing and serialisation of OpenPGP packets, as\n+// specified in RFC 4880.\n+package packet\n+\n+import (\n+\t\"crypto/aes\"\n+\t\"crypto/cast5\"\n+\t\"crypto/cipher\"\n+\t\"crypto/openpgp/error\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// readFull is the same as io.ReadFull except that reading zero bytes returns\n+// ErrUnexpectedEOF rather than EOF.\n+func readFull(r io.Reader, buf []byte) (n int, err os.Error) {\n+\tn, err = io.ReadFull(r, buf)\n+\tif err == os.EOF {\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn\n+}\n+\n+// readLength reads an OpenPGP length from r. See RFC 4880, section 4.2.2.\n+func readLength(r io.Reader) (length int64, isPartial bool, err os.Error) {\n+\tvar buf [4]byte\n+\t_, err = readFull(r, buf[:1])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tswitch {\n+\tcase buf[0] < 192:\n+\t\tlength = int64(buf[0])\n+\tcase buf[0] < 224:\n+\t\tlength = int64(buf[0]-192) << 8\n+\t\t_, err = readFull(r, buf[0:1])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tlength += int64(buf[0]) + 192\n+\tcase buf[0] < 255:\n+\t\tlength = int64(1) << (buf[0] & 0x1f)\n+\t\tisPartial = true\n+\tdefault:\n+\t\t_, err = readFull(r, buf[0:4])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tlength = int64(buf[0])<<24 |\n+\t\t\tint64(buf[1])<<16 |\n+\t\t\tint64(buf[2])<<8 |\n+\t\t\tint64(buf[3])\n+\t}\n+\treturn\n+}\n+\n+// partialLengthReader wraps an io.Reader and handles OpenPGP partial lengths.\n+// The continuation lengths are parsed and removed from the stream and EOF is\n+// returned at the end of the packet. See RFC 4880, section 4.2.2.4.\n+type partialLengthReader struct {\n+\tr         io.Reader\n+\tremaining int64\n+\tisPartial bool\n+}\n+\n+func (r *partialLengthReader) Read(p []byte) (n int, err os.Error) {\n+\tfor r.remaining == 0 {\n+\t\tif !r.isPartial {\n+\t\t\treturn 0, os.EOF\n+\t\t}\n+\t\tr.remaining, r.isPartial, err = readLength(r.r)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t}\n+\n+\ttoRead := int64(len(p))\n+\tif toRead > r.remaining {\n+\t\ttoRead = r.remaining\n+\t}\n+\n+\tn, err = r.r.Read(p[:int(toRead)])\n+\tr.remaining -= int64(n)\n+\tif n < int(toRead) && err == os.EOF {\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn\n+}\n+\n+// A spanReader is an io.LimitReader, but it returns ErrUnexpectedEOF if the\n+// underlying Reader returns EOF before the limit has been reached.\n+type spanReader struct {\n+\tr io.Reader\n+\tn int64\n+}\n+\n+func (l *spanReader) Read(p []byte) (n int, err os.Error) {\n+\tif l.n <= 0 {\n+\t\treturn 0, os.EOF\n+\t}\n+\tif int64(len(p)) > l.n {\n+\t\tp = p[0:l.n]\n+\t}\n+\tn, err = l.r.Read(p)\n+\tl.n -= int64(n)\n+\tif l.n > 0 && err == os.EOF {\n+\t\terr = io.ErrUnexpectedEOF\n+\t}\n+\treturn\n+}\n+\n+// readHeader parses a packet header and returns an io.Reader which will return\n+// the contents of the packet. See RFC 4880, section 4.2.\n+func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader, err os.Error) {\n+\tvar buf [4]byte\n+\t_, err = io.ReadFull(r, buf[:1])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0]&0x80 == 0 {\n+\t\terr = error.StructuralError(\"tag byte does not have MSB set\")\n+\t\treturn\n+\t}\n+\tif buf[0]&0x40 == 0 {\n+\t\t// Old format packet\n+\t\ttag = packetType((buf[0] & 0x3f) >> 2)\n+\t\tlengthType := buf[0] & 3\n+\t\tif lengthType == 3 {\n+\t\t\tlength = -1\n+\t\t\tcontents = r\n+\t\t\treturn\n+\t\t}\n+\t\tlengthBytes := 1 << lengthType\n+\t\t_, err = readFull(r, buf[0:lengthBytes])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tfor i := 0; i < lengthBytes; i++ {\n+\t\t\tlength <<= 8\n+\t\t\tlength |= int64(buf[i])\n+\t\t}\n+\t\tcontents = &spanReader{r, length}\n+\t\treturn\n+\t}\n+\n+\t// New format packet\n+\ttag = packetType(buf[0] & 0x3f)\n+\tlength, isPartial, err := readLength(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif isPartial {\n+\t\tcontents = &partialLengthReader{\n+\t\t\tremaining: length,\n+\t\t\tisPartial: true,\n+\t\t\tr:         r,\n+\t\t}\n+\t\tlength = -1\n+\t} else {\n+\t\tcontents = &spanReader{r, length}\n+\t}\n+\treturn\n+}\n+\n+// serialiseHeader writes an OpenPGP packet header to w. See RFC 4880, section\n+// 4.2.\n+func serialiseHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n+\tvar buf [5]byte\n+\tvar n int\n+\n+\tbuf[0] = 0x80 | 0x40 | byte(ptype)\n+\tif length < 192 {\n+\t\tbuf[1] = byte(length)\n+\t\tn = 2\n+\t} else if length < 8384 {\n+\t\tlength -= 192\n+\t\tbuf[1] = byte(length >> 8)\n+\t\tbuf[2] = byte(length)\n+\t\tn = 3\n+\t} else {\n+\t\tbuf[0] = 255\n+\t\tbuf[1] = byte(length >> 24)\n+\t\tbuf[2] = byte(length >> 16)\n+\t\tbuf[3] = byte(length >> 8)\n+\t\tbuf[4] = byte(length)\n+\t\tn = 5\n+\t}\n+\n+\t_, err = w.Write(buf[:n])\n+\treturn\n+}\n+\n+// Packet represents an OpenPGP packet. Users are expected to try casting\n+// instances of this interface to specific packet types.\n+type Packet interface {\n+\tparse(io.Reader) os.Error\n+}\n+\n+// consumeAll reads from the given Reader until error, returning the number of\n+// bytes read.\n+func consumeAll(r io.Reader) (n int64, err os.Error) {\n+\tvar m int\n+\tvar buf [1024]byte\n+\n+\tfor {\n+\t\tm, err = r.Read(buf[:])\n+\t\tn += int64(m)\n+\t\tif err == os.EOF {\n+\t\t\terr = nil\n+\t\t\treturn\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tpanic(\"unreachable\")\n+}\n+\n+// packetType represents the numeric ids of the different OpenPGP packet types. See\n+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-2\n+type packetType uint8\n+\n+const (\n+\tpacketTypeEncryptedKey              packetType = 1\n+\tpacketTypeSignature                 packetType = 2\n+\tpacketTypeSymmetricKeyEncrypted     packetType = 3\n+\tpacketTypeOnePassSignature          packetType = 4\n+\tpacketTypePrivateKey                packetType = 5\n+\tpacketTypePublicKey                 packetType = 6\n+\tpacketTypePrivateSubkey             packetType = 7\n+\tpacketTypeCompressed                packetType = 8\n+\tpacketTypeSymmetricallyEncrypted    packetType = 9\n+\tpacketTypeLiteralData               packetType = 11\n+\tpacketTypeUserId                    packetType = 13\n+\tpacketTypePublicSubkey              packetType = 14\n+\tpacketTypeSymmetricallyEncryptedMDC packetType = 18\n+)\n+\n+// Read reads a single OpenPGP packet from the given io.Reader. If there is an\n+// error parsing a packet, the whole packet is consumed from the input.\n+func Read(r io.Reader) (p Packet, err os.Error) {\n+\ttag, _, contents, err := readHeader(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tswitch tag {\n+\tcase packetTypeEncryptedKey:\n+\t\tp = new(EncryptedKey)\n+\tcase packetTypeSignature:\n+\t\tp = new(Signature)\n+\tcase packetTypeSymmetricKeyEncrypted:\n+\t\tp = new(SymmetricKeyEncrypted)\n+\tcase packetTypeOnePassSignature:\n+\t\tp = new(OnePassSignature)\n+\tcase packetTypePrivateKey, packetTypePrivateSubkey:\n+\t\tpk := new(PrivateKey)\n+\t\tif tag == packetTypePrivateSubkey {\n+\t\t\tpk.IsSubkey = true\n+\t\t}\n+\t\tp = pk\n+\tcase packetTypePublicKey, packetTypePublicSubkey:\n+\t\tpk := new(PublicKey)\n+\t\tif tag == packetTypePublicSubkey {\n+\t\t\tpk.IsSubkey = true\n+\t\t}\n+\t\tp = pk\n+\tcase packetTypeCompressed:\n+\t\tp = new(Compressed)\n+\tcase packetTypeSymmetricallyEncrypted:\n+\t\tp = new(SymmetricallyEncrypted)\n+\tcase packetTypeLiteralData:\n+\t\tp = new(LiteralData)\n+\tcase packetTypeUserId:\n+\t\tp = new(UserId)\n+\tcase packetTypeSymmetricallyEncryptedMDC:\n+\t\tse := new(SymmetricallyEncrypted)\n+\t\tse.MDC = true\n+\t\tp = se\n+\tdefault:\n+\t\terr = error.UnknownPacketTypeError(tag)\n+\t}\n+\tif p != nil {\n+\t\terr = p.parse(contents)\n+\t}\n+\tif err != nil {\n+\t\tconsumeAll(contents)\n+\t}\n+\treturn\n+}\n+\n+// SignatureType represents the different semantic meanings of an OpenPGP\n+// signature. See RFC 4880, section 5.2.1.\n+type SignatureType uint8\n+\n+const (\n+\tSigTypeBinary        SignatureType = 0\n+\tSigTypeText          = 1\n+\tSigTypeGenericCert   = 0x10\n+\tSigTypePersonaCert   = 0x11\n+\tSigTypeCasualCert    = 0x12\n+\tSigTypePositiveCert  = 0x13\n+\tSigTypeSubkeyBinding = 0x18\n+)\n+\n+// PublicKeyAlgorithm represents the different public key system specified for\n+// OpenPGP. See\n+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-12\n+type PublicKeyAlgorithm uint8\n+\n+const (\n+\tPubKeyAlgoRSA            PublicKeyAlgorithm = 1\n+\tPubKeyAlgoRSAEncryptOnly PublicKeyAlgorithm = 2\n+\tPubKeyAlgoRSASignOnly    PublicKeyAlgorithm = 3\n+\tPubKeyAlgoElgamal        PublicKeyAlgorithm = 16\n+\tPubKeyAlgoDSA            PublicKeyAlgorithm = 17\n+)\n+\n+// CipherFunction represents the different block ciphers specified for OpenPGP. See\n+// http://www.iana.org/assignments/pgp-parameters/pgp-parameters.xhtml#pgp-parameters-13\n+type CipherFunction uint8\n+\n+const (\n+\tCipherCAST5  = 3\n+\tCipherAES128 = 7\n+\tCipherAES192 = 8\n+\tCipherAES256 = 9\n+)\n+\n+// keySize returns the key size, in bytes, of cipher.\n+func (cipher CipherFunction) keySize() int {\n+\tswitch cipher {\n+\tcase CipherCAST5:\n+\t\treturn cast5.KeySize\n+\tcase CipherAES128:\n+\t\treturn 16\n+\tcase CipherAES192:\n+\t\treturn 24\n+\tcase CipherAES256:\n+\t\treturn 32\n+\t}\n+\treturn 0\n+}\n+\n+// blockSize returns the block size, in bytes, of cipher.\n+func (cipher CipherFunction) blockSize() int {\n+\tswitch cipher {\n+\tcase CipherCAST5:\n+\t\treturn 8\n+\tcase CipherAES128, CipherAES192, CipherAES256:\n+\t\treturn 16\n+\t}\n+\treturn 0\n+}\n+\n+// new returns a fresh instance of the given cipher.\n+func (cipher CipherFunction) new(key []byte) (block cipher.Block) {\n+\tswitch cipher {\n+\tcase CipherCAST5:\n+\t\tblock, _ = cast5.NewCipher(key)\n+\tcase CipherAES128, CipherAES192, CipherAES256:\n+\t\tblock, _ = aes.NewCipher(key)\n+\t}\n+\treturn\n+}\n+\n+// readMPI reads a big integer from r. The bit length returned is the bit\n+// length that was specified in r. This is preserved so that the integer can be\n+// reserialised exactly.\n+func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err os.Error) {\n+\tvar buf [2]byte\n+\t_, err = readFull(r, buf[0:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tbitLength = uint16(buf[0])<<8 | uint16(buf[1])\n+\tnumBytes := (int(bitLength) + 7) / 8\n+\tmpi = make([]byte, numBytes)\n+\t_, err = readFull(r, mpi)\n+\treturn\n+}\n+\n+// writeMPI serialises a big integer to r.\n+func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err os.Error) {\n+\t_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})\n+\tif err == nil {\n+\t\t_, err = w.Write(mpiBytes)\n+\t}\n+\treturn\n+}"}, {"sha": "6789d2abc792b30967bc999b1b0c1f6b6ec0b5bc", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/openpgp/error\"\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestReadFull(t *testing.T) {\n+\tvar out [4]byte\n+\n+\tb := bytes.NewBufferString(\"foo\")\n+\tn, err := readFull(b, out[:3])\n+\tif n != 3 || err != nil {\n+\t\tt.Errorf(\"full read failed n:%d err:%s\", n, err)\n+\t}\n+\n+\tb = bytes.NewBufferString(\"foo\")\n+\tn, err = readFull(b, out[:4])\n+\tif n != 3 || err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"partial read failed n:%d err:%s\", n, err)\n+\t}\n+\n+\tb = bytes.NewBuffer(nil)\n+\tn, err = readFull(b, out[:3])\n+\tif n != 0 || err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"empty read failed n:%d err:%s\", n, err)\n+\t}\n+}\n+\n+func readerFromHex(s string) io.Reader {\n+\tdata, err := hex.DecodeString(s)\n+\tif err != nil {\n+\t\tpanic(\"readerFromHex: bad input\")\n+\t}\n+\treturn bytes.NewBuffer(data)\n+}\n+\n+var readLengthTests = []struct {\n+\thexInput  string\n+\tlength    int64\n+\tisPartial bool\n+\terr       os.Error\n+}{\n+\t{\"\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"1f\", 31, false, nil},\n+\t{\"c0\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"c101\", 256 + 1 + 192, false, nil},\n+\t{\"e0\", 1, true, nil},\n+\t{\"e1\", 2, true, nil},\n+\t{\"e2\", 4, true, nil},\n+\t{\"ff\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"ff00\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"ff0000\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"ff000000\", 0, false, io.ErrUnexpectedEOF},\n+\t{\"ff00000000\", 0, false, nil},\n+\t{\"ff01020304\", 16909060, false, nil},\n+}\n+\n+func TestReadLength(t *testing.T) {\n+\tfor i, test := range readLengthTests {\n+\t\tlength, isPartial, err := readLength(readerFromHex(test.hexInput))\n+\t\tif test.err != nil {\n+\t\t\tif err != test.err {\n+\t\t\t\tt.Errorf(\"%d: expected different error got:%s want:%s\", i, err, test.err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: unexpected error: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif length != test.length || isPartial != test.isPartial {\n+\t\t\tt.Errorf(\"%d: bad result got:(%d,%t) want:(%d,%t)\", i, length, isPartial, test.length, test.isPartial)\n+\t\t}\n+\t}\n+}\n+\n+var partialLengthReaderTests = []struct {\n+\thexInput  string\n+\terr       os.Error\n+\thexOutput string\n+}{\n+\t{\"e0\", io.ErrUnexpectedEOF, \"\"},\n+\t{\"e001\", io.ErrUnexpectedEOF, \"\"},\n+\t{\"e0010102\", nil, \"0102\"},\n+\t{\"ff00000000\", nil, \"\"},\n+\t{\"e10102e1030400\", nil, \"01020304\"},\n+\t{\"e101\", io.ErrUnexpectedEOF, \"\"},\n+}\n+\n+func TestPartialLengthReader(t *testing.T) {\n+\tfor i, test := range partialLengthReaderTests {\n+\t\tr := &partialLengthReader{readerFromHex(test.hexInput), 0, true}\n+\t\tout, err := ioutil.ReadAll(r)\n+\t\tif test.err != nil {\n+\t\t\tif err != test.err {\n+\t\t\t\tt.Errorf(\"%d: expected different error got:%s want:%s\", i, err, test.err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: unexpected error: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tgot := fmt.Sprintf(\"%x\", out)\n+\t\tif got != test.hexOutput {\n+\t\t\tt.Errorf(\"%d: got:%s want:%s\", i, test.hexOutput, got)\n+\t\t}\n+\t}\n+}\n+\n+var readHeaderTests = []struct {\n+\thexInput        string\n+\tstructuralError bool\n+\tunexpectedEOF   bool\n+\ttag             int\n+\tlength          int64\n+\thexOutput       string\n+}{\n+\t{\"\", false, false, 0, 0, \"\"},\n+\t{\"7f\", true, false, 0, 0, \"\"},\n+\n+\t// Old format headers\n+\t{\"80\", false, true, 0, 0, \"\"},\n+\t{\"8001\", false, true, 0, 1, \"\"},\n+\t{\"800102\", false, false, 0, 1, \"02\"},\n+\t{\"81000102\", false, false, 0, 1, \"02\"},\n+\t{\"820000000102\", false, false, 0, 1, \"02\"},\n+\t{\"860000000102\", false, false, 1, 1, \"02\"},\n+\t{\"83010203\", false, false, 0, -1, \"010203\"},\n+\n+\t// New format headers\n+\t{\"c0\", false, true, 0, 0, \"\"},\n+\t{\"c000\", false, false, 0, 0, \"\"},\n+\t{\"c00102\", false, false, 0, 1, \"02\"},\n+\t{\"c0020203\", false, false, 0, 2, \"0203\"},\n+\t{\"c00202\", false, true, 0, 2, \"\"},\n+\t{\"c3020203\", false, false, 3, 2, \"0203\"},\n+}\n+\n+func TestReadHeader(t *testing.T) {\n+\tfor i, test := range readHeaderTests {\n+\t\ttag, length, contents, err := readHeader(readerFromHex(test.hexInput))\n+\t\tif test.structuralError {\n+\t\t\tif _, ok := err.(error.StructuralError); ok {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tt.Errorf(\"%d: expected StructuralError, got:%s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tif len(test.hexInput) == 0 && err == os.EOF {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !test.unexpectedEOF || err != io.ErrUnexpectedEOF {\n+\t\t\t\tt.Errorf(\"%d: unexpected error from readHeader: %s\", i, err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif int(tag) != test.tag || length != test.length {\n+\t\t\tt.Errorf(\"%d: got:(%d,%d) want:(%d,%d)\", i, int(tag), length, test.tag, test.length)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tbody, err := ioutil.ReadAll(contents)\n+\t\tif err != nil {\n+\t\t\tif !test.unexpectedEOF || err != io.ErrUnexpectedEOF {\n+\t\t\t\tt.Errorf(\"%d: unexpected error from contents: %s\", i, err)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif test.unexpectedEOF {\n+\t\t\tt.Errorf(\"%d: expected ErrUnexpectedEOF from contents but got no error\", i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tgot := fmt.Sprintf(\"%x\", body)\n+\t\tif got != test.hexOutput {\n+\t\t\tt.Errorf(\"%d: got:%s want:%s\", i, got, test.hexOutput)\n+\t\t}\n+\t}\n+}"}, {"sha": "b22891755e3ea49ea2ea2a6b9385ab9df7a2e543", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"big\"\n+\t\"bytes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/s2k\"\n+\t\"crypto/rsa\"\n+\t\"crypto/sha1\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// PrivateKey represents a possibly encrypted private key. See RFC 4880,\n+// section 5.5.3.\n+type PrivateKey struct {\n+\tPublicKey\n+\tEncrypted     bool // if true then the private key is unavailable until Decrypt has been called.\n+\tencryptedData []byte\n+\tcipher        CipherFunction\n+\ts2k           func(out, in []byte)\n+\tPrivateKey    interface{} // An *rsa.PrivateKey.\n+\tsha1Checksum  bool\n+\tiv            []byte\n+}\n+\n+func (pk *PrivateKey) parse(r io.Reader) (err os.Error) {\n+\terr = (&pk.PublicKey).parse(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar buf [1]byte\n+\t_, err = readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\ts2kType := buf[0]\n+\n+\tswitch s2kType {\n+\tcase 0:\n+\t\tpk.s2k = nil\n+\t\tpk.Encrypted = false\n+\tcase 254, 255:\n+\t\t_, err = readFull(r, buf[:])\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tpk.cipher = CipherFunction(buf[0])\n+\t\tpk.Encrypted = true\n+\t\tpk.s2k, err = s2k.Parse(r)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif s2kType == 254 {\n+\t\t\tpk.sha1Checksum = true\n+\t\t}\n+\tdefault:\n+\t\treturn error.UnsupportedError(\"deprecated s2k function in private key\")\n+\t}\n+\n+\tif pk.Encrypted {\n+\t\tblockSize := pk.cipher.blockSize()\n+\t\tif blockSize == 0 {\n+\t\t\treturn error.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n+\t\t}\n+\t\tpk.iv = make([]byte, blockSize)\n+\t\t_, err = readFull(r, pk.iv)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tpk.encryptedData, err = ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif !pk.Encrypted {\n+\t\treturn pk.parsePrivateKey(pk.encryptedData)\n+\t}\n+\n+\treturn\n+}\n+\n+// Decrypt decrypts an encrypted private key using a passphrase.\n+func (pk *PrivateKey) Decrypt(passphrase []byte) os.Error {\n+\tif !pk.Encrypted {\n+\t\treturn nil\n+\t}\n+\n+\tkey := make([]byte, pk.cipher.keySize())\n+\tpk.s2k(key, passphrase)\n+\tblock := pk.cipher.new(key)\n+\tcfb := cipher.NewCFBDecrypter(block, pk.iv)\n+\n+\tdata := pk.encryptedData\n+\tcfb.XORKeyStream(data, data)\n+\n+\tif pk.sha1Checksum {\n+\t\tif len(data) < sha1.Size {\n+\t\t\treturn error.StructuralError(\"truncated private key data\")\n+\t\t}\n+\t\th := sha1.New()\n+\t\th.Write(data[:len(data)-sha1.Size])\n+\t\tsum := h.Sum()\n+\t\tif !bytes.Equal(sum, data[len(data)-sha1.Size:]) {\n+\t\t\treturn error.StructuralError(\"private key checksum failure\")\n+\t\t}\n+\t\tdata = data[:len(data)-sha1.Size]\n+\t} else {\n+\t\tif len(data) < 2 {\n+\t\t\treturn error.StructuralError(\"truncated private key data\")\n+\t\t}\n+\t\tvar sum uint16\n+\t\tfor i := 0; i < len(data)-2; i++ {\n+\t\t\tsum += uint16(data[i])\n+\t\t}\n+\t\tif data[len(data)-2] != uint8(sum>>8) ||\n+\t\t\tdata[len(data)-1] != uint8(sum) {\n+\t\t\treturn error.StructuralError(\"private key checksum failure\")\n+\t\t}\n+\t\tdata = data[:len(data)-2]\n+\t}\n+\n+\treturn pk.parsePrivateKey(data)\n+}\n+\n+func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n+\t// TODO(agl): support DSA and ECDSA private keys.\n+\trsaPub := pk.PublicKey.PublicKey.(*rsa.PublicKey)\n+\trsaPriv := new(rsa.PrivateKey)\n+\trsaPriv.PublicKey = *rsaPub\n+\n+\tbuf := bytes.NewBuffer(data)\n+\td, _, err := readMPI(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tp, _, err := readMPI(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tq, _, err := readMPI(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\trsaPriv.D = new(big.Int).SetBytes(d)\n+\trsaPriv.P = new(big.Int).SetBytes(p)\n+\trsaPriv.Q = new(big.Int).SetBytes(q)\n+\tpk.PrivateKey = rsaPriv\n+\tpk.Encrypted = false\n+\tpk.encryptedData = nil\n+\n+\treturn nil\n+}"}, {"sha": "e941cc735cf7048d36d65de13273e59cabfb6fa6", "filename": "libgo/go/crypto/openpgp/packet/private_key_test.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestPrivateKeyRead(t *testing.T) {\n+\tpacket, err := Read(readerFromHex(privKeyHex))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tprivKey := packet.(*PrivateKey)\n+\n+\tif !privKey.Encrypted {\n+\t\tt.Error(\"private key isn't encrypted\")\n+\t\treturn\n+\t}\n+\n+\terr = privKey.Decrypt([]byte(\"testing\"))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tif privKey.CreationTime != 0x4cc349a8 || privKey.Encrypted {\n+\t\tt.Errorf(\"failed to parse, got: %#v\", privKey)\n+\t}\n+}\n+\n+// Generated with `gpg --export-secret-keys \"Test Key 2\"`\n+const privKeyHex = \"9501fe044cc349a8010400b70ca0010e98c090008d45d1ee8f9113bd5861fd57b88bacb7c68658747663f1e1a3b5a98f32fda6472373c024b97359cd2efc88ff60f77751adfbf6af5e615e6a1408cfad8bf0cea30b0d5f53aa27ad59089ba9b15b7ebc2777a25d7b436144027e3bcd203909f147d0e332b240cf63d3395f5dfe0df0a6c04e8655af7eacdf0011010001fe0303024a252e7d475fd445607de39a265472aa74a9320ba2dac395faa687e9e0336aeb7e9a7397e511b5afd9dc84557c80ac0f3d4d7bfec5ae16f20d41c8c84a04552a33870b930420e230e179564f6d19bb153145e76c33ae993886c388832b0fa042ddda7f133924f3854481533e0ede31d51278c0519b29abc3bf53da673e13e3e1214b52413d179d7f66deee35cac8eacb060f78379d70ef4af8607e68131ff529439668fc39c9ce6dfef8a5ac234d234802cbfb749a26107db26406213ae5c06d4673253a3cbee1fcbae58d6ab77e38d6e2c0e7c6317c48e054edadb5a40d0d48acb44643d998139a8a66bb820be1f3f80185bc777d14b5954b60effe2448a036d565c6bc0b915fcea518acdd20ab07bc1529f561c58cd044f723109b93f6fd99f876ff891d64306b5d08f48bab59f38695e9109c4dec34013ba3153488ce070268381ba923ee1eb77125b36afcb4347ec3478c8f2735b06ef17351d872e577fa95d0c397c88c71b59629a36aec\""}, {"sha": "8866bdaaa9474c280c2fd06bb7703eccd74b2a1d", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,260 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"big\"\n+\t\"crypto/dsa\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/rsa\"\n+\t\"crypto/sha1\"\n+\t\"encoding/binary\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// PublicKey represents an OpenPGP public key. See RFC 4880, section 5.5.2.\n+type PublicKey struct {\n+\tCreationTime uint32 // seconds since the epoch\n+\tPubKeyAlgo   PublicKeyAlgorithm\n+\tPublicKey    interface{} // Either a *rsa.PublicKey or *dsa.PublicKey\n+\tFingerprint  [20]byte\n+\tKeyId        uint64\n+\tIsSubkey     bool\n+\n+\tn, e, p, q, g, y parsedMPI\n+}\n+\n+func (pk *PublicKey) parse(r io.Reader) (err os.Error) {\n+\t// RFC 4880, section 5.5.2\n+\tvar buf [6]byte\n+\t_, err = readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0] != 4 {\n+\t\treturn error.UnsupportedError(\"public key version\")\n+\t}\n+\tpk.CreationTime = uint32(buf[1])<<24 | uint32(buf[2])<<16 | uint32(buf[3])<<8 | uint32(buf[4])\n+\tpk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])\n+\tswitch pk.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n+\t\terr = pk.parseRSA(r)\n+\tcase PubKeyAlgoDSA:\n+\t\terr = pk.parseDSA(r)\n+\tdefault:\n+\t\terr = error.UnsupportedError(\"public key type\")\n+\t}\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// RFC 4880, section 12.2\n+\tfingerPrint := sha1.New()\n+\tpk.SerializeSignaturePrefix(fingerPrint)\n+\tpk.Serialize(fingerPrint)\n+\tcopy(pk.Fingerprint[:], fingerPrint.Sum())\n+\tpk.KeyId = binary.BigEndian.Uint64(pk.Fingerprint[12:20])\n+\n+\treturn\n+}\n+\n+// parseRSA parses RSA public key material from the given Reader. See RFC 4880,\n+// section 5.5.2.\n+func (pk *PublicKey) parseRSA(r io.Reader) (err os.Error) {\n+\tpk.n.bytes, pk.n.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.e.bytes, pk.e.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif len(pk.e.bytes) > 3 {\n+\t\terr = error.UnsupportedError(\"large public exponent\")\n+\t\treturn\n+\t}\n+\trsa := &rsa.PublicKey{\n+\t\tN: new(big.Int).SetBytes(pk.n.bytes),\n+\t\tE: 0,\n+\t}\n+\tfor i := 0; i < len(pk.e.bytes); i++ {\n+\t\trsa.E <<= 8\n+\t\trsa.E |= int(pk.e.bytes[i])\n+\t}\n+\tpk.PublicKey = rsa\n+\treturn\n+}\n+\n+// parseRSA parses DSA public key material from the given Reader. See RFC 4880,\n+// section 5.5.2.\n+func (pk *PublicKey) parseDSA(r io.Reader) (err os.Error) {\n+\tpk.p.bytes, pk.p.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.q.bytes, pk.q.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.g.bytes, pk.g.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tpk.y.bytes, pk.y.bitLength, err = readMPI(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tdsa := new(dsa.PublicKey)\n+\tdsa.P = new(big.Int).SetBytes(pk.p.bytes)\n+\tdsa.Q = new(big.Int).SetBytes(pk.q.bytes)\n+\tdsa.G = new(big.Int).SetBytes(pk.g.bytes)\n+\tdsa.Y = new(big.Int).SetBytes(pk.y.bytes)\n+\tpk.PublicKey = dsa\n+\treturn\n+}\n+\n+// SerializeSignaturePrefix writes the prefix for this public key to the given Writer.\n+// The prefix is used when calculating a signature over this public key. See\n+// RFC 4880, section 5.2.4.\n+func (pk *PublicKey) SerializeSignaturePrefix(h hash.Hash) {\n+\tvar pLength uint16\n+\tswitch pk.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n+\t\tpLength += 2 + uint16(len(pk.n.bytes))\n+\t\tpLength += 2 + uint16(len(pk.e.bytes))\n+\tcase PubKeyAlgoDSA:\n+\t\tpLength += 2 + uint16(len(pk.p.bytes))\n+\t\tpLength += 2 + uint16(len(pk.q.bytes))\n+\t\tpLength += 2 + uint16(len(pk.g.bytes))\n+\t\tpLength += 2 + uint16(len(pk.y.bytes))\n+\tdefault:\n+\t\tpanic(\"unknown public key algorithm\")\n+\t}\n+\tpLength += 6\n+\th.Write([]byte{0x99, byte(pLength >> 8), byte(pLength)})\n+\treturn\n+}\n+\n+// Serialize marshals the PublicKey to w in the form of an OpenPGP public key\n+// packet, not including the packet header.\n+func (pk *PublicKey) Serialize(w io.Writer) (err os.Error) {\n+\tvar buf [6]byte\n+\tbuf[0] = 4\n+\tbuf[1] = byte(pk.CreationTime >> 24)\n+\tbuf[2] = byte(pk.CreationTime >> 16)\n+\tbuf[3] = byte(pk.CreationTime >> 8)\n+\tbuf[4] = byte(pk.CreationTime)\n+\tbuf[5] = byte(pk.PubKeyAlgo)\n+\n+\t_, err = w.Write(buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tswitch pk.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSAEncryptOnly, PubKeyAlgoRSASignOnly:\n+\t\treturn writeMPIs(w, pk.n, pk.e)\n+\tcase PubKeyAlgoDSA:\n+\t\treturn writeMPIs(w, pk.p, pk.q, pk.g, pk.y)\n+\t}\n+\treturn error.InvalidArgumentError(\"bad public-key algorithm\")\n+}\n+\n+// CanSign returns true iff this public key can generate signatures\n+func (pk *PublicKey) CanSign() bool {\n+\treturn pk.PubKeyAlgo != PubKeyAlgoRSAEncryptOnly && pk.PubKeyAlgo != PubKeyAlgoElgamal\n+}\n+\n+// VerifySignature returns nil iff sig is a valid signature, made by this\n+// public key, of the data hashed into signed. signed is mutated by this call.\n+func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.Error) {\n+\tif !pk.CanSign() {\n+\t\treturn error.InvalidArgumentError(\"public key cannot generate signatures\")\n+\t}\n+\n+\trsaPublicKey, ok := pk.PublicKey.(*rsa.PublicKey)\n+\tif !ok {\n+\t\t// TODO(agl): support DSA and ECDSA keys.\n+\t\treturn error.UnsupportedError(\"non-RSA public key\")\n+\t}\n+\n+\tsigned.Write(sig.HashSuffix)\n+\thashBytes := signed.Sum()\n+\n+\tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n+\t\treturn error.SignatureError(\"hash tag doesn't match\")\n+\t}\n+\n+\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.Signature)\n+\tif err != nil {\n+\t\treturn error.SignatureError(\"RSA verification failure\")\n+\t}\n+\treturn nil\n+}\n+\n+// VerifyKeySignature returns nil iff sig is a valid signature, make by this\n+// public key, of the public key in signed.\n+func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err os.Error) {\n+\th := sig.Hash.New()\n+\tif h == nil {\n+\t\treturn error.UnsupportedError(\"hash function\")\n+\t}\n+\n+\t// RFC 4880, section 5.2.4\n+\tpk.SerializeSignaturePrefix(h)\n+\tpk.Serialize(h)\n+\tsigned.SerializeSignaturePrefix(h)\n+\tsigned.Serialize(h)\n+\n+\treturn pk.VerifySignature(h, sig)\n+}\n+\n+// VerifyUserIdSignature returns nil iff sig is a valid signature, make by this\n+// public key, of the given user id.\n+func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Error) {\n+\th := sig.Hash.New()\n+\tif h == nil {\n+\t\treturn error.UnsupportedError(\"hash function\")\n+\t}\n+\n+\t// RFC 4880, section 5.2.4\n+\tpk.SerializeSignaturePrefix(h)\n+\tpk.Serialize(h)\n+\n+\tvar buf [5]byte\n+\tbuf[0] = 0xb4\n+\tbuf[1] = byte(len(id) >> 24)\n+\tbuf[2] = byte(len(id) >> 16)\n+\tbuf[3] = byte(len(id) >> 8)\n+\tbuf[4] = byte(len(id))\n+\th.Write(buf[:])\n+\th.Write([]byte(id))\n+\n+\treturn pk.VerifySignature(h, sig)\n+}\n+\n+// A parsedMPI is used to store the contents of a big integer, along with the\n+// bit length that was specified in the original input. This allows the MPI to\n+// be reserialised exactly.\n+type parsedMPI struct {\n+\tbytes     []byte\n+\tbitLength uint16\n+}\n+\n+// writeMPIs is a utility function for serialising several big integers to the\n+// given Writer.\n+func writeMPIs(w io.Writer, mpis ...parsedMPI) (err os.Error) {\n+\tfor _, mpi := range mpis {\n+\t\terr = writeMPI(w, mpi.bitLength, mpi.bytes)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+}"}, {"sha": "c015f64aec965005861863fbb45945d48a99224d", "filename": "libgo/go/crypto/openpgp/packet/public_key_test.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+var pubKeyTests = []struct {\n+\thexData        string\n+\thexFingerprint string\n+\tcreationTime   uint32\n+\tpubKeyAlgo     PublicKeyAlgorithm\n+\tkeyId          uint64\n+}{\n+\t{rsaPkDataHex, rsaFingerprintHex, 0x4d3c5c10, PubKeyAlgoRSA, 0xa34d7e18c20c31bb},\n+\t{dsaPkDataHex, dsaFingerprintHex, 0x4d432f89, PubKeyAlgoDSA, 0x8e8fbe54062f19ed},\n+}\n+\n+func TestPublicKeyRead(t *testing.T) {\n+\tfor i, test := range pubKeyTests {\n+\t\tpacket, err := Read(readerFromHex(test.hexData))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: Read error: %s\", i, err)\n+\t\t\treturn\n+\t\t}\n+\t\tpk, ok := packet.(*PublicKey)\n+\t\tif !ok {\n+\t\t\tt.Errorf(\"#%d: failed to parse, got: %#v\", i, packet)\n+\t\t\treturn\n+\t\t}\n+\t\tif pk.PubKeyAlgo != test.pubKeyAlgo {\n+\t\t\tt.Errorf(\"#%d: bad public key algorithm got:%x want:%x\", i, pk.PubKeyAlgo, test.pubKeyAlgo)\n+\t\t}\n+\t\tif pk.CreationTime != test.creationTime {\n+\t\t\tt.Errorf(\"#%d: bad creation time got:%x want:%x\", i, pk.CreationTime, test.creationTime)\n+\t\t}\n+\t\texpectedFingerprint, _ := hex.DecodeString(test.hexFingerprint)\n+\t\tif !bytes.Equal(expectedFingerprint, pk.Fingerprint[:]) {\n+\t\t\tt.Errorf(\"#%d: bad fingerprint got:%x want:%x\", i, pk.Fingerprint[:], expectedFingerprint)\n+\t\t}\n+\t\tif pk.KeyId != test.keyId {\n+\t\t\tt.Errorf(\"#%d: bad keyid got:%x want:%x\", i, pk.KeyId, test.keyId)\n+\t\t}\n+\t}\n+}\n+\n+const rsaFingerprintHex = \"5fb74b1d03b1e3cb31bc2f8aa34d7e18c20c31bb\"\n+\n+const rsaPkDataHex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001\"\n+\n+const dsaFingerprintHex = \"eece4c094db002103714c63c8e8fbe54062f19ed\"\n+\n+const dsaPkDataHex = \"9901a2044d432f89110400cd581334f0d7a1e1bdc8b9d6d8c0baf68793632735d2bb0903224cbaa1dfbf35a60ee7a13b92643421e1eb41aa8d79bea19a115a677f6b8ba3c7818ce53a6c2a24a1608bd8b8d6e55c5090cbde09dd26e356267465ae25e69ec8bdd57c7bbb2623e4d73336f73a0a9098f7f16da2e25252130fd694c0e8070c55a812a423ae7f00a0ebf50e70c2f19c3520a551bd4b08d30f23530d3d03ff7d0bf4a53a64a09dc5e6e6e35854b7d70c882b0c60293401958b1bd9e40abec3ea05ba87cf64899299d4bd6aa7f459c201d3fbbd6c82004bdc5e8a9eb8082d12054cc90fa9d4ec251a843236a588bf49552441817436c4f43326966fe85447d4e6d0acf8fa1ef0f014730770603ad7634c3088dc52501c237328417c31c89ed70400b2f1a98b0bf42f11fefc430704bebbaa41d9f355600c3facee1e490f64208e0e094ea55e3a598a219a58500bf78ac677b670a14f4e47e9cf8eab4f368cc1ddcaa18cc59309d4cc62dd4f680e73e6cc3e1ce87a84d0925efbcb26c575c093fc42eecf45135fabf6403a25c2016e1774c0484e440a18319072c617cc97ac0a3bb0\""}, {"sha": "5febc3bc8dcad011a70d3ad40eb34257a012799c", "filename": "libgo/go/crypto/openpgp/packet/reader.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto/openpgp/error\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// Reader reads packets from an io.Reader and allows packets to be 'unread' so\n+// that they result from the next call to Next.\n+type Reader struct {\n+\tq       []Packet\n+\treaders []io.Reader\n+}\n+\n+// Next returns the most recently unread Packet, or reads another packet from\n+// the top-most io.Reader. Unknown packet types are skipped.\n+func (r *Reader) Next() (p Packet, err os.Error) {\n+\tif len(r.q) > 0 {\n+\t\tp = r.q[len(r.q)-1]\n+\t\tr.q = r.q[:len(r.q)-1]\n+\t\treturn\n+\t}\n+\n+\tfor len(r.readers) > 0 {\n+\t\tp, err = Read(r.readers[len(r.readers)-1])\n+\t\tif err == nil {\n+\t\t\treturn\n+\t\t}\n+\t\tif err == os.EOF {\n+\t\t\tr.readers = r.readers[:len(r.readers)-1]\n+\t\t\tcontinue\n+\t\t}\n+\t\tif _, ok := err.(error.UnknownPacketTypeError); !ok {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn nil, os.EOF\n+}\n+\n+// Push causes the Reader to start reading from a new io.Reader. When an EOF\n+// error is seen from the new io.Reader, it is popped and the Reader continues\n+// to read from the next most recent io.Reader.\n+func (r *Reader) Push(reader io.Reader) {\n+\tr.readers = append(r.readers, reader)\n+}\n+\n+// Unread causes the given Packet to be returned from the next call to Next.\n+func (r *Reader) Unread(p Packet) {\n+\tr.q = append(r.q, p)\n+}\n+\n+func NewReader(r io.Reader) *Reader {\n+\treturn &Reader{\n+\t\tq:       nil,\n+\t\treaders: []io.Reader{r},\n+\t}\n+}"}, {"sha": "fd2518ab41eaa92a837b5f36ec58b330eda84d10", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,468 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/s2k\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"encoding/binary\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// Signature represents a signature. See RFC 4880, section 5.2.\n+type Signature struct {\n+\tSigType    SignatureType\n+\tPubKeyAlgo PublicKeyAlgorithm\n+\tHash       crypto.Hash\n+\n+\t// HashSuffix is extra data that is hashed in after the signed data.\n+\tHashSuffix []byte\n+\t// HashTag contains the first two bytes of the hash for fast rejection\n+\t// of bad signed data.\n+\tHashTag      [2]byte\n+\tCreationTime uint32 // Unix epoch time\n+\tSignature    []byte\n+\n+\t// The following are optional so are nil when not included in the\n+\t// signature.\n+\n+\tSigLifetimeSecs, KeyLifetimeSecs                        *uint32\n+\tPreferredSymmetric, PreferredHash, PreferredCompression []uint8\n+\tIssuerKeyId                                             *uint64\n+\tIsPrimaryId                                             *bool\n+\n+\t// FlagsValid is set if any flags were given. See RFC 4880, section\n+\t// 5.2.3.21 for details.\n+\tFlagsValid                                                           bool\n+\tFlagCertify, FlagSign, FlagEncryptCommunications, FlagEncryptStorage bool\n+\n+\toutSubpackets []outputSubpacket\n+}\n+\n+func (sig *Signature) parse(r io.Reader) (err os.Error) {\n+\t// RFC 4880, section 5.2.3\n+\tvar buf [5]byte\n+\t_, err = readFull(r, buf[:1])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0] != 4 {\n+\t\terr = error.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t\treturn\n+\t}\n+\n+\t_, err = readFull(r, buf[:5])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tsig.SigType = SignatureType(buf[0])\n+\tsig.PubKeyAlgo = PublicKeyAlgorithm(buf[1])\n+\tswitch sig.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\tdefault:\n+\t\terr = error.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t\treturn\n+\t}\n+\n+\tvar ok bool\n+\tsig.Hash, ok = s2k.HashIdToHash(buf[2])\n+\tif !ok {\n+\t\treturn error.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n+\t}\n+\n+\thashedSubpacketsLength := int(buf[3])<<8 | int(buf[4])\n+\tl := 6 + hashedSubpacketsLength\n+\tsig.HashSuffix = make([]byte, l+6)\n+\tsig.HashSuffix[0] = 4\n+\tcopy(sig.HashSuffix[1:], buf[:5])\n+\thashedSubpackets := sig.HashSuffix[6:l]\n+\t_, err = readFull(r, hashedSubpackets)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t// See RFC 4880, section 5.2.4\n+\ttrailer := sig.HashSuffix[l:]\n+\ttrailer[0] = 4\n+\ttrailer[1] = 0xff\n+\ttrailer[2] = uint8(l >> 24)\n+\ttrailer[3] = uint8(l >> 16)\n+\ttrailer[4] = uint8(l >> 8)\n+\ttrailer[5] = uint8(l)\n+\n+\terr = parseSignatureSubpackets(sig, hashedSubpackets, true)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = readFull(r, buf[:2])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tunhashedSubpacketsLength := int(buf[0])<<8 | int(buf[1])\n+\tunhashedSubpackets := make([]byte, unhashedSubpacketsLength)\n+\t_, err = readFull(r, unhashedSubpackets)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\terr = parseSignatureSubpackets(sig, unhashedSubpackets, false)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = readFull(r, sig.HashTag[:2])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t// We have already checked that the public key algorithm is RSA.\n+\tsig.Signature, _, err = readMPI(r)\n+\treturn\n+}\n+\n+// parseSignatureSubpackets parses subpackets of the main signature packet. See\n+// RFC 4880, section 5.2.3.1.\n+func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool) (err os.Error) {\n+\tfor len(subpackets) > 0 {\n+\t\tsubpackets, err = parseSignatureSubpacket(sig, subpackets, isHashed)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tif sig.CreationTime == 0 {\n+\t\terr = error.StructuralError(\"no creation time in signature\")\n+\t}\n+\n+\treturn\n+}\n+\n+type signatureSubpacketType uint8\n+\n+const (\n+\tcreationTimeSubpacket        signatureSubpacketType = 2\n+\tsignatureExpirationSubpacket signatureSubpacketType = 3\n+\tkeyExpirySubpacket           signatureSubpacketType = 9\n+\tprefSymmetricAlgosSubpacket  signatureSubpacketType = 11\n+\tissuerSubpacket              signatureSubpacketType = 16\n+\tprefHashAlgosSubpacket       signatureSubpacketType = 21\n+\tprefCompressionSubpacket     signatureSubpacketType = 22\n+\tprimaryUserIdSubpacket       signatureSubpacketType = 25\n+\tkeyFlagsSubpacket            signatureSubpacketType = 27\n+)\n+\n+// parseSignatureSubpacket parses a single subpacket. len(subpacket) is >= 1.\n+func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (rest []byte, err os.Error) {\n+\t// RFC 4880, section 5.2.3.1\n+\tvar length uint32\n+\tswitch {\n+\tcase subpacket[0] < 192:\n+\t\tlength = uint32(subpacket[0])\n+\t\tsubpacket = subpacket[1:]\n+\tcase subpacket[0] < 255:\n+\t\tif len(subpacket) < 2 {\n+\t\t\tgoto Truncated\n+\t\t}\n+\t\tlength = uint32(subpacket[0]-192)<<8 + uint32(subpacket[1]) + 192\n+\t\tsubpacket = subpacket[2:]\n+\tdefault:\n+\t\tif len(subpacket) < 5 {\n+\t\t\tgoto Truncated\n+\t\t}\n+\t\tlength = uint32(subpacket[1])<<24 |\n+\t\t\tuint32(subpacket[2])<<16 |\n+\t\t\tuint32(subpacket[3])<<8 |\n+\t\t\tuint32(subpacket[4])\n+\t\tsubpacket = subpacket[5:]\n+\t}\n+\tif length > uint32(len(subpacket)) {\n+\t\tgoto Truncated\n+\t}\n+\trest = subpacket[length:]\n+\tsubpacket = subpacket[:length]\n+\tif len(subpacket) == 0 {\n+\t\terr = error.StructuralError(\"zero length signature subpacket\")\n+\t\treturn\n+\t}\n+\tpacketType := subpacket[0] & 0x7f\n+\tisCritial := subpacket[0]&0x80 == 0x80\n+\tsubpacket = subpacket[1:]\n+\tswitch signatureSubpacketType(packetType) {\n+\tcase creationTimeSubpacket:\n+\t\tif !isHashed {\n+\t\t\terr = error.StructuralError(\"signature creation time in non-hashed area\")\n+\t\t\treturn\n+\t\t}\n+\t\tif len(subpacket) != 4 {\n+\t\t\terr = error.StructuralError(\"signature creation time not four bytes\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.CreationTime = binary.BigEndian.Uint32(subpacket)\n+\tcase signatureExpirationSubpacket:\n+\t\t// Signature expiration time, section 5.2.3.10\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(subpacket) != 4 {\n+\t\t\terr = error.StructuralError(\"expiration subpacket with bad length\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.SigLifetimeSecs = new(uint32)\n+\t\t*sig.SigLifetimeSecs = binary.BigEndian.Uint32(subpacket)\n+\tcase keyExpirySubpacket:\n+\t\t// Key expiration time, section 5.2.3.6\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(subpacket) != 4 {\n+\t\t\terr = error.StructuralError(\"key expiration subpacket with bad length\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.KeyLifetimeSecs = new(uint32)\n+\t\t*sig.KeyLifetimeSecs = binary.BigEndian.Uint32(subpacket)\n+\tcase prefSymmetricAlgosSubpacket:\n+\t\t// Preferred symmetric algorithms, section 5.2.3.7\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tsig.PreferredSymmetric = make([]byte, len(subpacket))\n+\t\tcopy(sig.PreferredSymmetric, subpacket)\n+\tcase issuerSubpacket:\n+\t\t// Issuer, section 5.2.3.5\n+\t\tif len(subpacket) != 8 {\n+\t\t\terr = error.StructuralError(\"issuer subpacket with bad length\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.IssuerKeyId = new(uint64)\n+\t\t*sig.IssuerKeyId = binary.BigEndian.Uint64(subpacket)\n+\tcase prefHashAlgosSubpacket:\n+\t\t// Preferred hash algorithms, section 5.2.3.8\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tsig.PreferredHash = make([]byte, len(subpacket))\n+\t\tcopy(sig.PreferredHash, subpacket)\n+\tcase prefCompressionSubpacket:\n+\t\t// Preferred compression algorithms, section 5.2.3.9\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tsig.PreferredCompression = make([]byte, len(subpacket))\n+\t\tcopy(sig.PreferredCompression, subpacket)\n+\tcase primaryUserIdSubpacket:\n+\t\t// Primary User ID, section 5.2.3.19\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(subpacket) != 1 {\n+\t\t\terr = error.StructuralError(\"primary user id subpacket with bad length\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.IsPrimaryId = new(bool)\n+\t\tif subpacket[0] > 0 {\n+\t\t\t*sig.IsPrimaryId = true\n+\t\t}\n+\tcase keyFlagsSubpacket:\n+\t\t// Key flags, section 5.2.3.21\n+\t\tif !isHashed {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(subpacket) == 0 {\n+\t\t\terr = error.StructuralError(\"empty key flags subpacket\")\n+\t\t\treturn\n+\t\t}\n+\t\tsig.FlagsValid = true\n+\t\tif subpacket[0]&1 != 0 {\n+\t\t\tsig.FlagCertify = true\n+\t\t}\n+\t\tif subpacket[0]&2 != 0 {\n+\t\t\tsig.FlagSign = true\n+\t\t}\n+\t\tif subpacket[0]&4 != 0 {\n+\t\t\tsig.FlagEncryptCommunications = true\n+\t\t}\n+\t\tif subpacket[0]&8 != 0 {\n+\t\t\tsig.FlagEncryptStorage = true\n+\t\t}\n+\n+\tdefault:\n+\t\tif isCritial {\n+\t\t\terr = error.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n+\n+Truncated:\n+\terr = error.StructuralError(\"signature subpacket truncated\")\n+\treturn\n+}\n+\n+// subpacketLengthLength returns the length, in bytes, of an encoded length value.\n+func subpacketLengthLength(length int) int {\n+\tif length < 192 {\n+\t\treturn 1\n+\t}\n+\tif length < 16320 {\n+\t\treturn 2\n+\t}\n+\treturn 5\n+}\n+\n+// serialiseSubpacketLength marshals the given length into to.\n+func serialiseSubpacketLength(to []byte, length int) int {\n+\tif length < 192 {\n+\t\tto[0] = byte(length)\n+\t\treturn 1\n+\t}\n+\tif length < 16320 {\n+\t\tlength -= 192\n+\t\tto[0] = byte(length >> 8)\n+\t\tto[1] = byte(length)\n+\t\treturn 2\n+\t}\n+\tto[0] = 255\n+\tto[1] = byte(length >> 24)\n+\tto[2] = byte(length >> 16)\n+\tto[3] = byte(length >> 8)\n+\tto[4] = byte(length)\n+\treturn 5\n+}\n+\n+// subpacketsLength returns the serialised length, in bytes, of the given\n+// subpackets.\n+func subpacketsLength(subpackets []outputSubpacket, hashed bool) (length int) {\n+\tfor _, subpacket := range subpackets {\n+\t\tif subpacket.hashed == hashed {\n+\t\t\tlength += subpacketLengthLength(len(subpacket.contents) + 1)\n+\t\t\tlength += 1 // type byte\n+\t\t\tlength += len(subpacket.contents)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// serialiseSubpackets marshals the given subpackets into to.\n+func serialiseSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n+\tfor _, subpacket := range subpackets {\n+\t\tif subpacket.hashed == hashed {\n+\t\t\tn := serialiseSubpacketLength(to, len(subpacket.contents)+1)\n+\t\t\tto[n] = byte(subpacket.subpacketType)\n+\t\t\tto = to[1+n:]\n+\t\t\tn = copy(to, subpacket.contents)\n+\t\t\tto = to[n:]\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// buildHashSuffix constructs the HashSuffix member of sig in preparation for signing.\n+func (sig *Signature) buildHashSuffix() (err os.Error) {\n+\tsig.outSubpackets = sig.buildSubpackets()\n+\thashedSubpacketsLen := subpacketsLength(sig.outSubpackets, true)\n+\n+\tvar ok bool\n+\tl := 6 + hashedSubpacketsLen\n+\tsig.HashSuffix = make([]byte, l+6)\n+\tsig.HashSuffix[0] = 4\n+\tsig.HashSuffix[1] = uint8(sig.SigType)\n+\tsig.HashSuffix[2] = uint8(sig.PubKeyAlgo)\n+\tsig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)\n+\tif !ok {\n+\t\tsig.HashSuffix = nil\n+\t\treturn error.InvalidArgumentError(\"hash cannot be repesented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n+\t}\n+\tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n+\tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n+\tserialiseSubpackets(sig.HashSuffix[6:l], sig.outSubpackets, true)\n+\ttrailer := sig.HashSuffix[l:]\n+\ttrailer[0] = 4\n+\ttrailer[1] = 0xff\n+\ttrailer[2] = byte(l >> 24)\n+\ttrailer[3] = byte(l >> 16)\n+\ttrailer[4] = byte(l >> 8)\n+\ttrailer[5] = byte(l)\n+\treturn\n+}\n+\n+// SignRSA signs a message with an RSA private key. The hash, h, must contain\n+// the hash of message to be signed and will be mutated by this function.\n+func (sig *Signature) SignRSA(h hash.Hash, priv *rsa.PrivateKey) (err os.Error) {\n+\terr = sig.buildHashSuffix()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\th.Write(sig.HashSuffix)\n+\tdigest := h.Sum()\n+\tcopy(sig.HashTag[:], digest)\n+\tsig.Signature, err = rsa.SignPKCS1v15(rand.Reader, priv, sig.Hash, digest)\n+\treturn\n+}\n+\n+// Serialize marshals sig to w. SignRSA must have been called first.\n+func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n+\tif sig.Signature == nil {\n+\t\treturn error.InvalidArgumentError(\"Signature: need to call SignRSA before Serialize\")\n+\t}\n+\n+\tunhashedSubpacketsLen := subpacketsLength(sig.outSubpackets, false)\n+\tlength := len(sig.HashSuffix) - 6 /* trailer not included */ +\n+\t\t2 /* length of unhashed subpackets */ + unhashedSubpacketsLen +\n+\t\t2 /* hash tag */ + 2 /* length of signature MPI */ + len(sig.Signature)\n+\terr = serialiseHeader(w, packetTypeSignature, length)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = w.Write(sig.HashSuffix[:len(sig.HashSuffix)-6])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tunhashedSubpackets := make([]byte, 2+unhashedSubpacketsLen)\n+\tunhashedSubpackets[0] = byte(unhashedSubpacketsLen >> 8)\n+\tunhashedSubpackets[1] = byte(unhashedSubpacketsLen)\n+\tserialiseSubpackets(unhashedSubpackets[2:], sig.outSubpackets, false)\n+\n+\t_, err = w.Write(unhashedSubpackets)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\t_, err = w.Write(sig.HashTag[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn writeMPI(w, 8*uint16(len(sig.Signature)), sig.Signature)\n+}\n+\n+// outputSubpacket represents a subpacket to be marshaled.\n+type outputSubpacket struct {\n+\thashed        bool // true if this subpacket is in the hashed area.\n+\tsubpacketType signatureSubpacketType\n+\tcontents      []byte\n+}\n+\n+func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {\n+\tcreationTime := make([]byte, 4)\n+\tcreationTime[0] = byte(sig.CreationTime >> 24)\n+\tcreationTime[1] = byte(sig.CreationTime >> 16)\n+\tcreationTime[2] = byte(sig.CreationTime >> 8)\n+\tcreationTime[3] = byte(sig.CreationTime)\n+\tsubpackets = append(subpackets, outputSubpacket{true, creationTimeSubpacket, creationTime})\n+\n+\tif sig.IssuerKeyId != nil {\n+\t\tkeyId := make([]byte, 8)\n+\t\tbinary.BigEndian.PutUint64(keyId, *sig.IssuerKeyId)\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, keyId})\n+\t}\n+\n+\treturn\n+}"}, {"sha": "1305548b2aeb3af95cb8d8c27b227b1a73a541a4", "filename": "libgo/go/crypto/openpgp/packet/signature_test.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto\"\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+func TestSignatureRead(t *testing.T) {\n+\tsignatureData, _ := hex.DecodeString(signatureDataHex)\n+\tbuf := bytes.NewBuffer(signatureData)\n+\tpacket, err := Read(buf)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tsig, ok := packet.(*Signature)\n+\tif !ok || sig.SigType != SigTypeBinary || sig.PubKeyAlgo != PubKeyAlgoRSA || sig.Hash != crypto.SHA1 {\n+\t\tt.Errorf(\"failed to parse, got: %#v\", packet)\n+\t}\n+}\n+\n+const signatureDataHex = \"89011c04000102000605024cb45112000a0910ab105c91af38fb158f8d07ff5596ea368c5efe015bed6e78348c0f033c931d5f2ce5db54ce7f2a7e4b4ad64db758d65a7a71773edeab7ba2a9e0908e6a94a1175edd86c1d843279f045b021a6971a72702fcbd650efc393c5474d5b59a15f96d2eaad4c4c426797e0dcca2803ef41c6ff234d403eec38f31d610c344c06f2401c262f0993b2e66cad8a81ebc4322c723e0d4ba09fe917e8777658307ad8329adacba821420741009dfe87f007759f0982275d028a392c6ed983a0d846f890b36148c7358bdb8a516007fac760261ecd06076813831a36d0459075d1befa245ae7f7fb103d92ca759e9498fe60ef8078a39a3beda510deea251ea9f0a7f0df6ef42060f20780360686f3e400e\""}, {"sha": "d9010f88a3d62de1c4f7b6a93d3722f067ef6bd7", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/s2k\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// This is the largest session key that we'll support. Since no 512-bit cipher\n+// has even been seriously used, this is comfortably large.\n+const maxSessionKeySizeInBytes = 64\n+\n+// SymmetricKeyEncrypted represents a passphrase protected session key. See RFC\n+// 4880, section 5.3.\n+type SymmetricKeyEncrypted struct {\n+\tCipherFunc   CipherFunction\n+\tEncrypted    bool\n+\tKey          []byte // Empty unless Encrypted is false.\n+\ts2k          func(out, in []byte)\n+\tencryptedKey []byte\n+}\n+\n+func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err os.Error) {\n+\t// RFC 4880, section 5.3.\n+\tvar buf [2]byte\n+\t_, err = readFull(r, buf[:])\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tif buf[0] != 4 {\n+\t\treturn error.UnsupportedError(\"SymmetricKeyEncrypted version\")\n+\t}\n+\tske.CipherFunc = CipherFunction(buf[1])\n+\n+\tif ske.CipherFunc.keySize() == 0 {\n+\t\treturn error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n+\t}\n+\n+\tske.s2k, err = s2k.Parse(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tencryptedKey := make([]byte, maxSessionKeySizeInBytes)\n+\t// The session key may follow. We just have to try and read to find\n+\t// out. If it exists then we limit it to maxSessionKeySizeInBytes.\n+\tn, err := readFull(r, encryptedKey)\n+\tif err != nil && err != io.ErrUnexpectedEOF {\n+\t\treturn\n+\t}\n+\terr = nil\n+\tif n != 0 {\n+\t\tif n == maxSessionKeySizeInBytes {\n+\t\t\treturn error.UnsupportedError(\"oversized encrypted session key\")\n+\t\t}\n+\t\tske.encryptedKey = encryptedKey[:n]\n+\t}\n+\n+\tske.Encrypted = true\n+\n+\treturn\n+}\n+\n+// Decrypt attempts to decrypt an encrypted session key. If it returns nil,\n+// ske.Key will contain the session key.\n+func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) os.Error {\n+\tif !ske.Encrypted {\n+\t\treturn nil\n+\t}\n+\n+\tkey := make([]byte, ske.CipherFunc.keySize())\n+\tske.s2k(key, passphrase)\n+\n+\tif len(ske.encryptedKey) == 0 {\n+\t\tske.Key = key\n+\t} else {\n+\t\t// the IV is all zeros\n+\t\tiv := make([]byte, ske.CipherFunc.blockSize())\n+\t\tc := cipher.NewCFBDecrypter(ske.CipherFunc.new(key), iv)\n+\t\tc.XORKeyStream(ske.encryptedKey, ske.encryptedKey)\n+\t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n+\t\tif ske.CipherFunc.blockSize() == 0 {\n+\t\t\treturn error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n+\t\t}\n+\t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n+\t\tske.Key = ske.encryptedKey[1:]\n+\t\tif len(ske.Key)%ske.CipherFunc.blockSize() != 0 {\n+\t\t\tske.Key = nil\n+\t\t\treturn error.StructuralError(\"length of decrypted key not a multiple of block size\")\n+\t\t}\n+\t}\n+\n+\tske.Encrypted = false\n+\treturn nil\n+}"}, {"sha": "717c8ffa6d6c36bbd41ceda90bc0322c576928de", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/hex\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestSymmetricKeyEncrypted(t *testing.T) {\n+\tbuf := readerFromHex(symmetricallyEncryptedHex)\n+\tpacket, err := Read(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to read SymmetricKeyEncrypted: %s\", err)\n+\t\treturn\n+\t}\n+\tske, ok := packet.(*SymmetricKeyEncrypted)\n+\tif !ok {\n+\t\tt.Error(\"didn't find SymmetricKeyEncrypted packet\")\n+\t\treturn\n+\t}\n+\terr = ske.Decrypt([]byte(\"password\"))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tpacket, err = Read(buf)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to read SymmetricallyEncrypted: %s\", err)\n+\t\treturn\n+\t}\n+\tse, ok := packet.(*SymmetricallyEncrypted)\n+\tif !ok {\n+\t\tt.Error(\"didn't find SymmetricallyEncrypted packet\")\n+\t\treturn\n+\t}\n+\tr, err := se.Decrypt(ske.CipherFunc, ske.Key)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(r)\n+\tif err != nil && err != os.EOF {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\texpectedContents, _ := hex.DecodeString(symmetricallyEncryptedContentsHex)\n+\tif !bytes.Equal(expectedContents, contents) {\n+\t\tt.Errorf(\"bad contents got:%x want:%x\", contents, expectedContents)\n+\t}\n+}\n+\n+const symmetricallyEncryptedHex = \"8c0d04030302371a0b38d884f02060c91cf97c9973b8e58e028e9501708ccfe618fb92afef7fa2d80ddadd93cf\"\n+const symmetricallyEncryptedContentsHex = \"cb1062004d14c4df636f6e74656e74732e0a\""}, {"sha": "fc19ffe809a17213ed16d27cd7bc7cbc2e8e5f8d", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,206 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"crypto/cipher\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/sha1\"\n+\t\"crypto/subtle\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// SymmetricallyEncrypted represents a symmetrically encrypted byte string. The\n+// encrypted contents will consist of more OpenPGP packets. See RFC 4880,\n+// sections 5.7 and 5.13.\n+type SymmetricallyEncrypted struct {\n+\tMDC      bool // true iff this is a type 18 packet and thus has an embedded MAC.\n+\tcontents io.Reader\n+\tprefix   []byte\n+}\n+\n+func (se *SymmetricallyEncrypted) parse(r io.Reader) os.Error {\n+\tif se.MDC {\n+\t\t// See RFC 4880, section 5.13.\n+\t\tvar buf [1]byte\n+\t\t_, err := readFull(r, buf[:])\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif buf[0] != 1 {\n+\t\t\treturn error.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n+\t\t}\n+\t}\n+\tse.contents = r\n+\treturn nil\n+}\n+\n+// Decrypt returns a ReadCloser, from which the decrypted contents of the\n+// packet can be read. An incorrect key can, with high probability, be detected\n+// immediately and this will result in a KeyIncorrect error being returned.\n+func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, os.Error) {\n+\tkeySize := c.keySize()\n+\tif keySize == 0 {\n+\t\treturn nil, error.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n+\t}\n+\tif len(key) != keySize {\n+\t\treturn nil, error.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n+\t}\n+\n+\tif se.prefix == nil {\n+\t\tse.prefix = make([]byte, c.blockSize()+2)\n+\t\t_, err := readFull(se.contents, se.prefix)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t} else if len(se.prefix) != c.blockSize()+2 {\n+\t\treturn nil, error.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n+\t}\n+\n+\tocfbResync := cipher.OCFBResync\n+\tif se.MDC {\n+\t\t// MDC packets use a different form of OCFB mode.\n+\t\tocfbResync = cipher.OCFBNoResync\n+\t}\n+\n+\ts := cipher.NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)\n+\tif s == nil {\n+\t\treturn nil, error.KeyIncorrectError\n+\t}\n+\n+\tplaintext := cipher.StreamReader{S: s, R: se.contents}\n+\n+\tif se.MDC {\n+\t\t// MDC packets have an embedded hash that we need to check.\n+\t\th := sha1.New()\n+\t\th.Write(se.prefix)\n+\t\treturn &seMDCReader{in: plaintext, h: h}, nil\n+\t}\n+\n+\t// Otherwise, we just need to wrap plaintext so that it's a valid ReadCloser.\n+\treturn seReader{plaintext}, nil\n+}\n+\n+// seReader wraps an io.Reader with a no-op Close method.\n+type seReader struct {\n+\tin io.Reader\n+}\n+\n+func (ser seReader) Read(buf []byte) (int, os.Error) {\n+\treturn ser.in.Read(buf)\n+}\n+\n+func (ser seReader) Close() os.Error {\n+\treturn nil\n+}\n+\n+const mdcTrailerSize = 1 /* tag byte */ + 1 /* length byte */ + sha1.Size\n+\n+// An seMDCReader wraps an io.Reader, maintains a running hash and keeps hold\n+// of the most recent 22 bytes (mdcTrailerSize). Upon EOF, those bytes form an\n+// MDC packet containing a hash of the previous contents which is checked\n+// against the running hash. See RFC 4880, section 5.13.\n+type seMDCReader struct {\n+\tin          io.Reader\n+\th           hash.Hash\n+\ttrailer     [mdcTrailerSize]byte\n+\tscratch     [mdcTrailerSize]byte\n+\ttrailerUsed int\n+\terror       bool\n+\teof         bool\n+}\n+\n+func (ser *seMDCReader) Read(buf []byte) (n int, err os.Error) {\n+\tif ser.error {\n+\t\terr = io.ErrUnexpectedEOF\n+\t\treturn\n+\t}\n+\tif ser.eof {\n+\t\terr = os.EOF\n+\t\treturn\n+\t}\n+\n+\t// If we haven't yet filled the trailer buffer then we must do that\n+\t// first.\n+\tfor ser.trailerUsed < mdcTrailerSize {\n+\t\tn, err = ser.in.Read(ser.trailer[ser.trailerUsed:])\n+\t\tser.trailerUsed += n\n+\t\tif err == os.EOF {\n+\t\t\tif ser.trailerUsed != mdcTrailerSize {\n+\t\t\t\tn = 0\n+\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t\tser.error = true\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tser.eof = true\n+\t\t\tn = 0\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\tn = 0\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// If it's a short read then we read into a temporary buffer and shift\n+\t// the data into the caller's buffer.\n+\tif len(buf) <= mdcTrailerSize {\n+\t\tn, err = readFull(ser.in, ser.scratch[:len(buf)])\n+\t\tcopy(buf, ser.trailer[:n])\n+\t\tser.h.Write(buf[:n])\n+\t\tcopy(ser.trailer[:], ser.trailer[n:])\n+\t\tcopy(ser.trailer[mdcTrailerSize-n:], ser.scratch[:])\n+\t\tif n < len(buf) {\n+\t\t\tser.eof = true\n+\t\t\terr = os.EOF\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tn, err = ser.in.Read(buf[mdcTrailerSize:])\n+\tcopy(buf, ser.trailer[:])\n+\tser.h.Write(buf[:n])\n+\tcopy(ser.trailer[:], buf[n:])\n+\n+\tif err == os.EOF {\n+\t\tser.eof = true\n+\t}\n+\treturn\n+}\n+\n+func (ser *seMDCReader) Close() os.Error {\n+\tif ser.error {\n+\t\treturn error.SignatureError(\"error during reading\")\n+\t}\n+\n+\tfor !ser.eof {\n+\t\t// We haven't seen EOF so we need to read to the end\n+\t\tvar buf [1024]byte\n+\t\t_, err := ser.Read(buf[:])\n+\t\tif err == os.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn error.SignatureError(\"error during reading\")\n+\t\t}\n+\t}\n+\n+\t// This is a new-format packet tag byte for a type 19 (MDC) packet.\n+\tconst mdcPacketTagByte = byte(0x80) | 0x40 | 19\n+\tif ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {\n+\t\treturn error.SignatureError(\"MDC packet not found\")\n+\t}\n+\tser.h.Write(ser.trailer[:2])\n+\n+\tfinal := ser.h.Sum()\n+\tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) == 1 {\n+\t\treturn error.SignatureError(\"hash mismatch\")\n+\t}\n+\treturn nil\n+}"}, {"sha": "5543b20297a6f5ae11059d0c94f406cfebc46994", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted_test.go", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/sha1\"\n+\t\"encoding/hex\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+// TestReader wraps a []byte and returns reads of a specific length.\n+type testReader struct {\n+\tdata   []byte\n+\tstride int\n+}\n+\n+func (t *testReader) Read(buf []byte) (n int, err os.Error) {\n+\tn = t.stride\n+\tif n > len(t.data) {\n+\t\tn = len(t.data)\n+\t}\n+\tif n > len(buf) {\n+\t\tn = len(buf)\n+\t}\n+\tcopy(buf, t.data)\n+\tt.data = t.data[n:]\n+\tif len(t.data) == 0 {\n+\t\terr = os.EOF\n+\t}\n+\treturn\n+}\n+\n+func testMDCReader(t *testing.T) {\n+\tmdcPlaintext, _ := hex.DecodeString(mdcPlaintextHex)\n+\n+\tfor stride := 1; stride < len(mdcPlaintext)/2; stride++ {\n+\t\tr := &testReader{data: mdcPlaintext, stride: stride}\n+\t\tmdcReader := &seMDCReader{in: r, h: sha1.New()}\n+\t\tbody, err := ioutil.ReadAll(mdcReader)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"stride: %d, error: %s\", stride, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !bytes.Equal(body, mdcPlaintext[:len(mdcPlaintext)-22]) {\n+\t\t\tt.Errorf(\"stride: %d: bad contents %x\", stride, body)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\terr = mdcReader.Close()\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"stride: %d, error on Close: %s\", stride, err)\n+\t\t}\n+\t}\n+\n+\tmdcPlaintext[15] ^= 80\n+\n+\tr := &testReader{data: mdcPlaintext, stride: 2}\n+\tmdcReader := &seMDCReader{in: r, h: sha1.New()}\n+\t_, err := ioutil.ReadAll(mdcReader)\n+\tif err != nil {\n+\t\tt.Errorf(\"corruption test, error: %s\", err)\n+\t\treturn\n+\t}\n+\terr = mdcReader.Close()\n+\tif err == nil {\n+\t\tt.Error(\"corruption: no error\")\n+\t} else if _, ok := err.(*error.SignatureError); !ok {\n+\t\tt.Errorf(\"corruption: expected SignatureError, got: %s\", err)\n+\t}\n+}\n+\n+const mdcPlaintextHex = \"a302789c3b2d93c4e0eb9aba22283539b3203335af44a134afb800c849cb4c4de10200aff40b45d31432c80cb384299a0655966d6939dfdeed1dddf980\""}, {"sha": "ed2ad777486feb2615f944841b034fdde587644f", "filename": "libgo/go/crypto/openpgp/packet/userid.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+// UserId contains text that is intended to represent the name and email\n+// address of the key holder. See RFC 4880, section 5.11. By convention, this\n+// takes the form \"Full Name (Comment) <email@example.com>\"\n+type UserId struct {\n+\tId string // By convention, this takes the form \"Full Name (Comment) <email@example.com>\" which is split out in the fields below.\n+\n+\tName, Comment, Email string\n+}\n+\n+func (uid *UserId) parse(r io.Reader) (err os.Error) {\n+\t// RFC 4880, section 5.11\n+\tb, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tuid.Id = string(b)\n+\tuid.Name, uid.Comment, uid.Email = parseUserId(uid.Id)\n+\treturn\n+}\n+\n+// parseUserId extracts the name, comment and email from a user id string that\n+// is formatted as \"Full Name (Comment) <email@example.com>\".\n+func parseUserId(id string) (name, comment, email string) {\n+\tvar n, c, e struct {\n+\t\tstart, end int\n+\t}\n+\tvar state int\n+\n+\tfor offset, rune := range id {\n+\t\tswitch state {\n+\t\tcase 0:\n+\t\t\t// Entering name\n+\t\t\tn.start = offset\n+\t\t\tstate = 1\n+\t\t\tfallthrough\n+\t\tcase 1:\n+\t\t\t// In name\n+\t\t\tif rune == '(' {\n+\t\t\t\tstate = 2\n+\t\t\t\tn.end = offset\n+\t\t\t} else if rune == '<' {\n+\t\t\t\tstate = 5\n+\t\t\t\tn.end = offset\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\t// Entering comment\n+\t\t\tc.start = offset\n+\t\t\tstate = 3\n+\t\t\tfallthrough\n+\t\tcase 3:\n+\t\t\t// In comment\n+\t\t\tif rune == ')' {\n+\t\t\t\tstate = 4\n+\t\t\t\tc.end = offset\n+\t\t\t}\n+\t\tcase 4:\n+\t\t\t// Between comment and email\n+\t\t\tif rune == '<' {\n+\t\t\t\tstate = 5\n+\t\t\t}\n+\t\tcase 5:\n+\t\t\t// Entering email\n+\t\t\te.start = offset\n+\t\t\tstate = 6\n+\t\t\tfallthrough\n+\t\tcase 6:\n+\t\t\t// In email\n+\t\t\tif rune == '>' {\n+\t\t\t\tstate = 7\n+\t\t\t\te.end = offset\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// After email\n+\t\t}\n+\t}\n+\tswitch state {\n+\tcase 1:\n+\t\t// ended in the name\n+\t\tn.end = len(id)\n+\tcase 3:\n+\t\t// ended in comment\n+\t\tc.end = len(id)\n+\tcase 6:\n+\t\t// ended in email\n+\t\te.end = len(id)\n+\t}\n+\n+\tname = strings.TrimSpace(id[n.start:n.end])\n+\tcomment = strings.TrimSpace(id[c.start:c.end])\n+\temail = strings.TrimSpace(id[e.start:e.end])\n+\treturn\n+}"}, {"sha": "394873dc38ca9727065b4a135e7a873b979760de", "filename": "libgo/go/crypto/openpgp/packet/userid_test.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fuserid_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package packet\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var userIdTests = []struct {\n+\tid                   string\n+\tname, comment, email string\n+}{\n+\t{\"\", \"\", \"\", \"\"},\n+\t{\"John Smith\", \"John Smith\", \"\", \"\"},\n+\t{\"John Smith ()\", \"John Smith\", \"\", \"\"},\n+\t{\"John Smith () <>\", \"John Smith\", \"\", \"\"},\n+\t{\"(comment\", \"\", \"comment\", \"\"},\n+\t{\"(comment)\", \"\", \"comment\", \"\"},\n+\t{\"<email\", \"\", \"\", \"email\"},\n+\t{\"<email>   sdfk\", \"\", \"\", \"email\"},\n+\t{\"  John Smith  (  Comment ) asdkflj < email > lksdfj\", \"John Smith\", \"Comment\", \"email\"},\n+\t{\"  John Smith  < email > lksdfj\", \"John Smith\", \"\", \"email\"},\n+\t{\"(<foo\", \"\", \"<foo\", \"\"},\n+\t{\"Ren\u00e9 Descartes (\u0627\u0644\u0639\u0631\u0628\u064a)\", \"Ren\u00e9 Descartes\", \"\u0627\u0644\u0639\u0631\u0628\u064a\", \"\"},\n+}\n+\n+func TestParseUserId(t *testing.T) {\n+\tfor i, test := range userIdTests {\n+\t\tname, comment, email := parseUserId(test.id)\n+\t\tif name != test.name {\n+\t\t\tt.Errorf(\"%d: name mismatch got:%s want:%s\", i, name, test.name)\n+\t\t}\n+\t\tif comment != test.comment {\n+\t\t\tt.Errorf(\"%d: comment mismatch got:%s want:%s\", i, comment, test.comment)\n+\t\t}\n+\t\tif email != test.email {\n+\t\t\tt.Errorf(\"%d: email mismatch got:%s want:%s\", i, email, test.email)\n+\t\t}\n+\t}\n+}"}, {"sha": "ac6998f0d247914676fe64f00191285f63e37dfa", "filename": "libgo/go/crypto/openpgp/read.go", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,413 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This openpgp package implements high level operations on OpenPGP messages.\n+package openpgp\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/openpgp/armor\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/packet\"\n+\t\"crypto/rsa\"\n+\t_ \"crypto/sha256\"\n+\t\"hash\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// SignatureType is the armor type for a PGP signature.\n+var SignatureType = \"PGP SIGNATURE\"\n+\n+// readArmored reads an armored block with the given type.\n+func readArmored(r io.Reader, expectedType string) (body io.Reader, err os.Error) {\n+\tblock, err := armor.Decode(r)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tif block.Type != expectedType {\n+\t\treturn nil, error.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n+\t}\n+\n+\treturn block.Body, nil\n+}\n+\n+// MessageDetails contains the result of parsing an OpenPGP encrypted and/or\n+// signed message.\n+type MessageDetails struct {\n+\tIsEncrypted              bool                // true if the message was encrypted.\n+\tEncryptedToKeyIds        []uint64            // the list of recipient key ids.\n+\tIsSymmetricallyEncrypted bool                // true if a passphrase could have decrypted the message.\n+\tDecryptedWith            Key                 // the private key used to decrypt the message, if any.\n+\tIsSigned                 bool                // true if the message is signed.\n+\tSignedByKeyId            uint64              // the key id of the signer, if any.\n+\tSignedBy                 *Key                // the key of the signer, if availible.\n+\tLiteralData              *packet.LiteralData // the metadata of the contents\n+\tUnverifiedBody           io.Reader           // the contents of the message.\n+\n+\t// If IsSigned is true and SignedBy is non-zero then the signature will\n+\t// be verified as UnverifiedBody is read. The signature cannot be\n+\t// checked until the whole of UnverifiedBody is read so UnverifiedBody\n+\t// must be consumed until EOF before the data can trusted. Even if a\n+\t// message isn't signed (or the signer is unknown) the data may contain\n+\t// an authentication code that is only checked once UnverifiedBody has\n+\t// been consumed. Once EOF has been seen, the following fields are\n+\t// valid. (An authentication code failure is reported as a\n+\t// SignatureError error when reading from UnverifiedBody.)\n+\n+\tSignatureError os.Error          // nil if the signature is good.\n+\tSignature      *packet.Signature // the signature packet itself.\n+\n+\tdecrypted io.ReadCloser\n+}\n+\n+// A PromptFunction is used as a callback by functions that may need to decrypt\n+// a private key, or prompt for a passphrase. It is called with a list of\n+// acceptable, encrypted private keys and a boolean that indicates whether a\n+// passphrase is usable. It should either decrypt a private key or return a\n+// passphrase to try. If the decrypted private key or given passphrase isn't\n+// correct, the function will be called again, forever. Any error returned will\n+// be passed up.\n+type PromptFunction func(keys []Key, symmetric bool) ([]byte, os.Error)\n+\n+// A keyEnvelopePair is used to store a private key with the envelope that\n+// contains a symmetric key, encrypted with that key.\n+type keyEnvelopePair struct {\n+\tkey          Key\n+\tencryptedKey *packet.EncryptedKey\n+}\n+\n+// ReadMessage parses an OpenPGP message that may be signed and/or encrypted.\n+// The given KeyRing should contain both public keys (for signature\n+// verification) and, possibly encrypted, private keys for decrypting.\n+func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction) (md *MessageDetails, err os.Error) {\n+\tvar p packet.Packet\n+\n+\tvar symKeys []*packet.SymmetricKeyEncrypted\n+\tvar pubKeys []keyEnvelopePair\n+\tvar se *packet.SymmetricallyEncrypted\n+\n+\tpackets := packet.NewReader(r)\n+\tmd = new(MessageDetails)\n+\tmd.IsEncrypted = true\n+\n+\t// The message, if encrypted, starts with a number of packets\n+\t// containing an encrypted decryption key. The decryption key is either\n+\t// encrypted to a public key, or with a passphrase. This loop\n+\t// collects these packets.\n+ParsePackets:\n+\tfor {\n+\t\tp, err = packets.Next()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch p := p.(type) {\n+\t\tcase *packet.SymmetricKeyEncrypted:\n+\t\t\t// This packet contains the decryption key encrypted with a passphrase.\n+\t\t\tmd.IsSymmetricallyEncrypted = true\n+\t\t\tsymKeys = append(symKeys, p)\n+\t\tcase *packet.EncryptedKey:\n+\t\t\t// This packet contains the decryption key encrypted to a public key.\n+\t\t\tmd.EncryptedToKeyIds = append(md.EncryptedToKeyIds, p.KeyId)\n+\t\t\tif p.Algo != packet.PubKeyAlgoRSA && p.Algo != packet.PubKeyAlgoRSAEncryptOnly {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvar keys []Key\n+\t\t\tif p.KeyId == 0 {\n+\t\t\t\tkeys = keyring.DecryptionKeys()\n+\t\t\t} else {\n+\t\t\t\tkeys = keyring.KeysById(p.KeyId)\n+\t\t\t}\n+\t\t\tfor _, k := range keys {\n+\t\t\t\tpubKeys = append(pubKeys, keyEnvelopePair{k, p})\n+\t\t\t}\n+\t\tcase *packet.SymmetricallyEncrypted:\n+\t\t\tse = p\n+\t\t\tbreak ParsePackets\n+\t\tcase *packet.Compressed, *packet.LiteralData, *packet.OnePassSignature:\n+\t\t\t// This message isn't encrypted.\n+\t\t\tif len(symKeys) != 0 || len(pubKeys) != 0 {\n+\t\t\t\treturn nil, error.StructuralError(\"key material not followed by encrypted message\")\n+\t\t\t}\n+\t\t\tpackets.Unread(p)\n+\t\t\treturn readSignedMessage(packets, nil, keyring)\n+\t\t}\n+\t}\n+\n+\tvar candidates []Key\n+\tvar decrypted io.ReadCloser\n+\n+\t// Now that we have the list of encrypted keys we need to decrypt at\n+\t// least one of them or, if we cannot, we need to call the prompt\n+\t// function so that it can decrypt a key or give us a passphrase.\n+FindKey:\n+\tfor {\n+\t\t// See if any of the keys already have a private key availible\n+\t\tcandidates = candidates[:0]\n+\t\tcandidateFingerprints := make(map[string]bool)\n+\n+\t\tfor _, pk := range pubKeys {\n+\t\t\tif pk.key.PrivateKey == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif !pk.key.PrivateKey.Encrypted {\n+\t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n+\t\t\t\t\tpk.encryptedKey.DecryptRSA(pk.key.PrivateKey.PrivateKey.(*rsa.PrivateKey))\n+\t\t\t\t}\n+\t\t\t\tif len(pk.encryptedKey.Key) == 0 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tdecrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)\n+\t\t\t\tif err != nil && err != error.KeyIncorrectError {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\tif decrypted != nil {\n+\t\t\t\t\tmd.DecryptedWith = pk.key\n+\t\t\t\t\tbreak FindKey\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfpr := string(pk.key.PublicKey.Fingerprint[:])\n+\t\t\t\tif v := candidateFingerprints[fpr]; v {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tcandidates = append(candidates, pk.key)\n+\t\t\t\tcandidateFingerprints[fpr] = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(candidates) == 0 && len(symKeys) == 0 {\n+\t\t\treturn nil, error.KeyIncorrectError\n+\t\t}\n+\n+\t\tif prompt == nil {\n+\t\t\treturn nil, error.KeyIncorrectError\n+\t\t}\n+\n+\t\tpassphrase, err := prompt(candidates, len(symKeys) != 0)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Try the symmetric passphrase first\n+\t\tif len(symKeys) != 0 && passphrase != nil {\n+\t\t\tfor _, s := range symKeys {\n+\t\t\t\terr = s.Decrypt(passphrase)\n+\t\t\t\tif err == nil && !s.Encrypted {\n+\t\t\t\t\tdecrypted, err = se.Decrypt(s.CipherFunc, s.Key)\n+\t\t\t\t\tif err != nil && err != error.KeyIncorrectError {\n+\t\t\t\t\t\treturn nil, err\n+\t\t\t\t\t}\n+\t\t\t\t\tif decrypted != nil {\n+\t\t\t\t\t\tbreak FindKey\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tmd.decrypted = decrypted\n+\tpackets.Push(decrypted)\n+\treturn readSignedMessage(packets, md, keyring)\n+}\n+\n+// readSignedMessage reads a possibily signed message if mdin is non-zero then\n+// that structure is updated and returned. Otherwise a fresh MessageDetails is\n+// used.\n+func readSignedMessage(packets *packet.Reader, mdin *MessageDetails, keyring KeyRing) (md *MessageDetails, err os.Error) {\n+\tif mdin == nil {\n+\t\tmdin = new(MessageDetails)\n+\t}\n+\tmd = mdin\n+\n+\tvar p packet.Packet\n+\tvar h hash.Hash\n+\tvar wrappedHash hash.Hash\n+FindLiteralData:\n+\tfor {\n+\t\tp, err = packets.Next()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tswitch p := p.(type) {\n+\t\tcase *packet.Compressed:\n+\t\t\tpackets.Push(p.Body)\n+\t\tcase *packet.OnePassSignature:\n+\t\t\tif !p.IsLast {\n+\t\t\t\treturn nil, error.UnsupportedError(\"nested signatures\")\n+\t\t\t}\n+\n+\t\t\th, wrappedHash, err = hashForSignature(p.Hash, p.SigType)\n+\t\t\tif err != nil {\n+\t\t\t\tmd = nil\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tmd.IsSigned = true\n+\t\t\tmd.SignedByKeyId = p.KeyId\n+\t\t\tkeys := keyring.KeysById(p.KeyId)\n+\t\t\tfor _, key := range keys {\n+\t\t\t\tif key.SelfSignature.FlagsValid && !key.SelfSignature.FlagSign {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tmd.SignedBy = &key\n+\t\t\t}\n+\t\tcase *packet.LiteralData:\n+\t\t\tmd.LiteralData = p\n+\t\t\tbreak FindLiteralData\n+\t\t}\n+\t}\n+\n+\tif md.SignedBy != nil {\n+\t\tmd.UnverifiedBody = &signatureCheckReader{packets, h, wrappedHash, md}\n+\t} else if md.decrypted != nil {\n+\t\tmd.UnverifiedBody = checkReader{md}\n+\t} else {\n+\t\tmd.UnverifiedBody = md.LiteralData.Body\n+\t}\n+\n+\treturn md, nil\n+}\n+\n+// hashForSignature returns a pair of hashes that can be used to verify a\n+// signature. The signature may specify that the contents of the signed message\n+// should be preprocessed (i.e. to normalise line endings). Thus this function\n+// returns two hashes. The second should be used to hash the message itself and\n+// performs any needed preprocessing.\n+func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, os.Error) {\n+\th := hashId.New()\n+\tif h == nil {\n+\t\treturn nil, nil, error.UnsupportedError(\"hash not availible: \" + strconv.Itoa(int(hashId)))\n+\t}\n+\n+\tswitch sigType {\n+\tcase packet.SigTypeBinary:\n+\t\treturn h, h, nil\n+\tcase packet.SigTypeText:\n+\t\treturn h, NewCanonicalTextHash(h), nil\n+\t}\n+\n+\treturn nil, nil, error.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n+}\n+\n+// checkReader wraps an io.Reader from a LiteralData packet. When it sees EOF\n+// it closes the ReadCloser from any SymmetricallyEncrypted packet to trigger\n+// MDC checks.\n+type checkReader struct {\n+\tmd *MessageDetails\n+}\n+\n+func (cr checkReader) Read(buf []byte) (n int, err os.Error) {\n+\tn, err = cr.md.LiteralData.Body.Read(buf)\n+\tif err == os.EOF {\n+\t\tmdcErr := cr.md.decrypted.Close()\n+\t\tif mdcErr != nil {\n+\t\t\terr = mdcErr\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// signatureCheckReader wraps an io.Reader from a LiteralData packet and hashes\n+// the data as it is read. When it sees an EOF from the underlying io.Reader\n+// it parses and checks a trailing Signature packet and triggers any MDC checks.\n+type signatureCheckReader struct {\n+\tpackets        *packet.Reader\n+\th, wrappedHash hash.Hash\n+\tmd             *MessageDetails\n+}\n+\n+func (scr *signatureCheckReader) Read(buf []byte) (n int, err os.Error) {\n+\tn, err = scr.md.LiteralData.Body.Read(buf)\n+\tscr.wrappedHash.Write(buf[:n])\n+\tif err == os.EOF {\n+\t\tvar p packet.Packet\n+\t\tp, scr.md.SignatureError = scr.packets.Next()\n+\t\tif scr.md.SignatureError != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar ok bool\n+\t\tif scr.md.Signature, ok = p.(*packet.Signature); !ok {\n+\t\t\tscr.md.SignatureError = error.StructuralError(\"LiteralData not followed by Signature\")\n+\t\t\treturn\n+\t\t}\n+\n+\t\tscr.md.SignatureError = scr.md.SignedBy.PublicKey.VerifySignature(scr.h, scr.md.Signature)\n+\n+\t\t// The SymmetricallyEncrypted packet, if any, might have an\n+\t\t// unsigned hash of its own. In order to check this we need to\n+\t\t// close that Reader.\n+\t\tif scr.md.decrypted != nil {\n+\t\t\tmdcErr := scr.md.decrypted.Close()\n+\t\t\tif mdcErr != nil {\n+\t\t\t\terr = mdcErr\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+// CheckDetachedSignature takes a signed file and a detached signature and\n+// returns the signer if the signature is valid. If the signer isn't know,\n+// UnknownIssuerError is returned.\n+func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error) {\n+\tp, err := packet.Read(signature)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tsig, ok := p.(*packet.Signature)\n+\tif !ok {\n+\t\treturn nil, error.StructuralError(\"non signature packet found\")\n+\t}\n+\n+\tif sig.IssuerKeyId == nil {\n+\t\treturn nil, error.StructuralError(\"signature doesn't have an issuer\")\n+\t}\n+\n+\tkeys := keyring.KeysById(*sig.IssuerKeyId)\n+\tif len(keys) == 0 {\n+\t\treturn nil, error.UnknownIssuerError\n+\t}\n+\n+\th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\t_, err = io.Copy(wrappedHash, signed)\n+\tif err != nil && err != os.EOF {\n+\t\treturn\n+\t}\n+\n+\tfor _, key := range keys {\n+\t\tif key.SelfSignature.FlagsValid && !key.SelfSignature.FlagSign {\n+\t\t\tcontinue\n+\t\t}\n+\t\terr = key.PublicKey.VerifySignature(h, sig)\n+\t\tif err == nil {\n+\t\t\treturn key.Entity, nil\n+\t\t}\n+\t}\n+\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treturn nil, error.UnknownIssuerError\n+}\n+\n+// CheckArmoredDetachedSignature performs the same actions as\n+// CheckDetachedSignature but expects the signature to be armored.\n+func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error) {\n+\tbody, err := readArmored(signature, SignatureType)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treturn CheckDetachedSignature(keyring, signed, body)\n+}"}, {"sha": "58199e1329738f0dc5b3548be3dec22d81e20367", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/openpgp/error\"\n+\t\"encoding/hex\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func readerFromHex(s string) io.Reader {\n+\tdata, err := hex.DecodeString(s)\n+\tif err != nil {\n+\t\tpanic(\"readerFromHex: bad input\")\n+\t}\n+\treturn bytes.NewBuffer(data)\n+}\n+\n+func TestReadKeyRing(t *testing.T) {\n+\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tif len(kring) != 2 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB || uint32(kring[1].PrimaryKey.KeyId) != 0x1E35246B {\n+\t\tt.Errorf(\"bad keyring: %#v\", kring)\n+\t}\n+}\n+\n+func TestReadPrivateKeyRing(t *testing.T) {\n+\tkring, err := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tif len(kring) != 2 || uint32(kring[0].PrimaryKey.KeyId) != 0xC20C31BB || uint32(kring[1].PrimaryKey.KeyId) != 0x1E35246B || kring[0].PrimaryKey == nil {\n+\t\tt.Errorf(\"bad keyring: %#v\", kring)\n+\t}\n+}\n+\n+func TestGetKeyById(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n+\n+\tkeys := kring.KeysById(0xa34d7e18c20c31bb)\n+\tif len(keys) != 1 || keys[0].Entity != kring[0] {\n+\t\tt.Errorf(\"bad result for 0xa34d7e18c20c31bb: %#v\", keys)\n+\t}\n+\n+\tkeys = kring.KeysById(0xfd94408d4543314f)\n+\tif len(keys) != 1 || keys[0].Entity != kring[0] {\n+\t\tt.Errorf(\"bad result for 0xa34d7e18c20c31bb: %#v\", keys)\n+\t}\n+}\n+\n+func checkSignedMessage(t *testing.T, signedHex, expected string) {\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n+\n+\tmd, err := ReadMessage(readerFromHex(signedHex), kring, nil)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tif !md.IsSigned || md.SignedByKeyId != 0xa34d7e18c20c31bb || md.SignedBy == nil || md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) != 0 || md.IsSymmetricallyEncrypted {\n+\t\tt.Errorf(\"bad MessageDetails: %#v\", md)\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n+\t}\n+\tif string(contents) != expected {\n+\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n+\t}\n+\tif md.SignatureError != nil || md.Signature == nil {\n+\t\tt.Errorf(\"failed to validate: %s\", md.SignatureError)\n+\t}\n+}\n+\n+func TestSignedMessage(t *testing.T) {\n+\tcheckSignedMessage(t, signedMessageHex, signedInput)\n+}\n+\n+func TestTextSignedMessage(t *testing.T) {\n+\tcheckSignedMessage(t, signedTextMessageHex, signedTextInput)\n+}\n+\n+func TestSignedEncryptedMessage(t *testing.T) {\n+\texpected := \"Signed and encrypted message\\n\"\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n+\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\t\tif symmetric {\n+\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n+\t\t\treturn nil, error.KeyIncorrectError\n+\t\t}\n+\n+\t\tif len(keys) == 0 {\n+\t\t\tt.Error(\"prompt: no keys requested\")\n+\t\t\treturn nil, error.KeyIncorrectError\n+\t\t}\n+\n+\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n+\t\t\treturn nil, error.KeyIncorrectError\n+\t\t}\n+\n+\t\treturn nil, nil\n+\t}\n+\n+\tmd, err := ReadMessage(readerFromHex(signedEncryptedMessageHex), kring, prompt)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading message: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tif !md.IsSigned || md.SignedByKeyId != 0xa34d7e18c20c31bb || md.SignedBy == nil || !md.IsEncrypted || md.IsSymmetricallyEncrypted || len(md.EncryptedToKeyIds) == 0 || md.EncryptedToKeyIds[0] != 0x2a67d68660df41c7 {\n+\t\tt.Errorf(\"bad MessageDetails: %#v\", md)\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n+\t}\n+\tif string(contents) != expected {\n+\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n+\t}\n+\n+\tif md.SignatureError != nil || md.Signature == nil {\n+\t\tt.Errorf(\"failed to validate: %s\", md.SignatureError)\n+\t}\n+}\n+\n+func TestUnspecifiedRecipient(t *testing.T) {\n+\texpected := \"Recipient unspecified\\n\"\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n+\n+\tmd, err := ReadMessage(readerFromHex(recipientUnspecifiedHex), kring, nil)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading message: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading UnverifiedBody: %s\", err)\n+\t}\n+\tif string(contents) != expected {\n+\t\tt.Errorf(\"bad UnverifiedBody got:%s want:%s\", string(contents), expected)\n+\t}\n+}\n+\n+func TestSymmetricallyEncrypted(t *testing.T) {\n+\texpected := \"Symmetrically encrypted.\\n\"\n+\n+\tprompt := func(keys []Key, symmetric bool) ([]byte, os.Error) {\n+\t\tif len(keys) != 0 {\n+\t\t\tt.Errorf(\"prompt: len(keys) = %d (want 0)\", len(keys))\n+\t\t}\n+\n+\t\tif !symmetric {\n+\t\t\tt.Errorf(\"symmetric is not set\")\n+\t\t}\n+\n+\t\treturn []byte(\"password\"), nil\n+\t}\n+\n+\tmd, err := ReadMessage(readerFromHex(symmetricallyEncryptedCompressedHex), nil, prompt)\n+\tif err != nil {\n+\t\tt.Errorf(\"ReadMessage: %s\", err)\n+\t\treturn\n+\t}\n+\n+\tcontents, err := ioutil.ReadAll(md.UnverifiedBody)\n+\tif err != nil {\n+\t\tt.Errorf(\"ReadAll: %s\", err)\n+\t}\n+\n+\texpectedCreatationTime := uint32(1295992998)\n+\tif md.LiteralData.Time != expectedCreatationTime {\n+\t\tt.Errorf(\"LiteralData.Time is %d, want %d\", md.LiteralData.Time, expectedCreatationTime)\n+\t}\n+\n+\tif string(contents) != expected {\n+\t\tt.Errorf(\"contents got: %s want: %s\", string(contents), expected)\n+\t}\n+}\n+\n+func testDetachedSignature(t *testing.T, kring KeyRing, signature io.Reader, sigInput, tag string) {\n+\tsigned := bytes.NewBufferString(sigInput)\n+\tsigner, err := CheckDetachedSignature(kring, signed, signature)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: signature error: %s\", tag, err)\n+\t\treturn\n+\t}\n+\tif signer == nil {\n+\t\tt.Errorf(\"%s: signer is nil\", tag)\n+\t\treturn\n+\t}\n+\texpectedSignerKeyId := uint64(0xa34d7e18c20c31bb)\n+\tif signer.PrimaryKey.KeyId != expectedSignerKeyId {\n+\t\tt.Errorf(\"%s: wrong signer got:%x want:%x\", tag, signer.PrimaryKey.KeyId, expectedSignerKeyId)\n+\t}\n+}\n+\n+func TestDetachedSignature(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n+\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureHex), signedInput, \"binary\")\n+\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureTextHex), signedInput, \"text\")\n+}\n+\n+const signedInput = \"Signed message\\nline 2\\nline 3\\n\"\n+const signedTextInput = \"Signed message\\r\\nline 2\\r\\nline 3\\r\\n\"\n+\n+const recipientUnspecifiedHex = \"848c0300000000000000000103ff62d4d578d03cf40c3da998dfe216c074fa6ddec5e31c197c9666ba292830d91d18716a80f699f9d897389a90e6d62d0238f5f07a5248073c0f24920e4bc4a30c2d17ee4e0cae7c3d4aaa4e8dced50e3010a80ee692175fa0385f62ecca4b56ee6e9980aa3ec51b61b077096ac9e800edaf161268593eedb6cc7027ff5cb32745d250010d407a6221ae22ef18469b444f2822478c4d190b24d36371a95cb40087cdd42d9399c3d06a53c0673349bfb607927f20d1e122bde1e2bf3aa6cae6edf489629bcaa0689539ae3b718914d88ededc3b\"\n+\n+const detachedSignatureHex = \"889c04000102000605024d449cd1000a0910a34d7e18c20c31bb167603ff57718d09f28a519fdc7b5a68b6a3336da04df85e38c5cd5d5bd2092fa4629848a33d85b1729402a2aab39c3ac19f9d573f773cc62c264dc924c067a79dfd8a863ae06c7c8686120760749f5fd9b1e03a64d20a7df3446ddc8f0aeadeaeba7cbaee5c1e366d65b6a0c6cc749bcb912d2f15013f812795c2e29eb7f7b77f39ce77\"\n+\n+const detachedSignatureTextHex = \"889c04010102000605024d449d21000a0910a34d7e18c20c31bbc8c60400a24fbef7342603a41cb1165767bd18985d015fb72fe05db42db36cfb2f1d455967f1e491194fbf6cf88146222b23bf6ffbd50d17598d976a0417d3192ff9cc0034fd00f287b02e90418bbefe609484b09231e4e7a5f3562e199bf39909ab5276c4d37382fe088f6b5c3426fc1052865da8b3ab158672d58b6264b10823dc4b39\"\n+\n+const testKeys1And2Hex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b0020003b88d044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f0011010001889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab0020003988d044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b0020003b88d044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020003\"\n+\n+const testKeys1And2PrivateHex = \"9501d8044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd00110100010003ff4d91393b9a8e3430b14d6209df42f98dc927425b881f1209f319220841273a802a97c7bdb8b3a7740b3ab5866c4d1d308ad0d3a79bd1e883aacf1ac92dfe720285d10d08752a7efe3c609b1d00f17f2805b217be53999a7da7e493bfc3e9618fd17018991b8128aea70a05dbce30e4fbe626aa45775fa255dd9177aabf4df7cf0200c1ded12566e4bc2bb590455e5becfb2e2c9796482270a943343a7835de41080582c2be3caf5981aa838140e97afa40ad652a0b544f83eb1833b0957dce26e47b0200eacd6046741e9ce2ec5beb6fb5e6335457844fb09477f83b050a96be7da043e17f3a9523567ed40e7a521f818813a8b8a72209f1442844843ccc7eb9805442570200bdafe0438d97ac36e773c7162028d65844c4d463e2420aa2228c6e50dc2743c3d6c72d0d782a5173fe7be2169c8a9f4ef8a7cf3e37165e8c61b89c346cdc6c1799d2b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b00200009d01d8044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f00110100010003fd17a7490c22a79c59281fb7b20f5e6553ec0c1637ae382e8adaea295f50241037f8997cf42c1ce26417e015091451b15424b2c59eb8d4161b0975630408e394d3b00f88d4b4e18e2cc85e8251d4753a27c639c83f5ad4a571c4f19d7cd460b9b73c25ade730c99df09637bd173d8e3e981ac64432078263bb6dc30d3e974150dd0200d0ee05be3d4604d2146fb0457f31ba17c057560785aa804e8ca5530a7cd81d3440d0f4ba6851efcfd3954b7e68908fc0ba47f7ac37bf559c6c168b70d3a7c8cd0200da1c677c4bce06a068070f2b3733b0a714e88d62aa3f9a26c6f5216d48d5c2b5624144f3807c0df30be66b3268eeeca4df1fbded58faf49fc95dc3c35f134f8b01fd1396b6c0fc1b6c4f0eb8f5e44b8eace1e6073e20d0b8bc5385f86f1cf3f050f66af789f3ef1fc107b7f4421e19e0349c730c68f0a226981f4e889054fdb4dc149e8e889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab00200009501fe044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001fe030302e9030f3c783e14856063f16938530e148bc57a7aa3f3e4f90df9dceccdc779bc0835e1ad3d006e4a8d7b36d08b8e0de5a0d947254ecfbd22037e6572b426bcfdc517796b224b0036ff90bc574b5509bede85512f2eefb520fb4b02aa523ba739bff424a6fe81c5041f253f8d757e69a503d3563a104d0d49e9e890b9d0c26f96b55b743883b472caa7050c4acfd4a21f875bdf1258d88bd61224d303dc9df77f743137d51e6d5246b88c406780528fd9a3e15bab5452e5b93970d9dcc79f48b38651b9f15bfbcf6da452837e9cc70683d1bdca94507870f743e4ad902005812488dd342f836e72869afd00ce1850eea4cfa53ce10e3608e13d3c149394ee3cbd0e23d018fcbcb6e2ec5a1a22972d1d462ca05355d0d290dd2751e550d5efb38c6c89686344df64852bf4ff86638708f644e8ec6bd4af9b50d8541cb91891a431326ab2e332faa7ae86cfb6e0540aa63160c1e5cdd5a4add518b303fff0a20117c6bc77f7cfbaf36b04c865c6c2b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b00200009d01fe044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001fe030302e9030f3c783e148560f936097339ae381d63116efcf802ff8b1c9360767db5219cc987375702a4123fd8657d3e22700f23f95020d1b261eda5257e9a72f9a918e8ef22dd5b3323ae03bbc1923dd224db988cadc16acc04b120a9f8b7e84da9716c53e0334d7b66586ddb9014df604b41be1e960dcfcbc96f4ed150a1a0dd070b9eb14276b9b6be413a769a75b519a53d3ecc0c220e85cd91ca354d57e7344517e64b43b6e29823cbd87eae26e2b2e78e6dedfbb76e3e9f77bcb844f9a8932eb3db2c3f9e44316e6f5d60e9e2a56e46b72abe6b06dc9a31cc63f10023d1f5e12d2a3ee93b675c96f504af0001220991c88db759e231b3320dcedf814dcf723fd9857e3d72d66a0f2af26950b915abdf56c1596f46a325bf17ad4810d3535fb02a259b247ac3dbd4cc3ecf9c51b6c07cebb009c1506fba0a89321ec8683e3fd009a6e551d50243e2d5092fefb3321083a4bad91320dc624bd6b5dddf93553e3d53924c05bfebec1fb4bd47e89a1a889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020000\"\n+\n+const signedMessageHex = \"a3019bc0cbccc0c4b8d8b74ee2108fe16ec6d3ca490cbe362d3f8333d3f352531472538b8b13d353b97232f352158c20943157c71c16064626063656269052062e4e01987e9b6fccff4b7df3a34c534b23e679cbec3bc0f8f6e64dfb4b55fe3f8efa9ce110ddb5cd79faf1d753c51aecfa669f7e7aa043436596cccc3359cb7dd6bbe9ecaa69e5989d9e57209571edc0b2fa7f57b9b79a64ee6e99ce1371395fee92fec2796f7b15a77c386ff668ee27f6d38f0baa6c438b561657377bf6acff3c5947befd7bf4c196252f1d6e5c524d0300\"\n+\n+const signedTextMessageHex = \"a3019bc0cbccc8c4b8d8b74ee2108fe16ec6d36a250cbece0c178233d3f352531472538b8b13d35379b97232f352158ca0b4312f57c71c1646462606365626906a062e4e019811591798ff99bf8afee860b0d8a8c2a85c3387e3bcf0bb3b17987f2bbcfab2aa526d930cbfd3d98757184df3995c9f3e7790e36e3e9779f06089d4c64e9e47dd6202cb6e9bc73c5d11bb59fbaf89d22d8dc7cf199ddf17af96e77c5f65f9bbed56f427bd8db7af37f6c9984bf9385efaf5f184f986fb3e6adb0ecfe35bbf92d16a7aa2a344fb0bc52fb7624f0200\"\n+\n+const signedEncryptedMessageHex = \"848c032a67d68660df41c70103ff5789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8d2c03b018bd210b1d3791e1aba74b0f1034e122ab72e760492c192383cf5e20b5628bd043272d63df9b923f147eb6091cd897553204832aba48fec54aa447547bb16305a1024713b90e77fd0065f1918271947549205af3c74891af22ee0b56cd29bfec6d6e351901cd4ab3ece7c486f1e32a792d4e474aed98ee84b3f591c7dff37b64e0ecd68fd036d517e412dcadf85840ce184ad7921ad446c4ee28db80447aea1ca8d4f574db4d4e37688158ddd19e14ee2eab4873d46947d65d14a23e788d912cf9a19624ca7352469b72a83866b7c23cb5ace3deab3c7018061b0ba0f39ed2befe27163e5083cf9b8271e3e3d52cc7ad6e2a3bd81d4c3d7022f8d\"\n+\n+const symmetricallyEncryptedCompressedHex = \"8c0d04030302eb4a03808145d0d260c92f714339e13de5a79881216431925bf67ee2898ea61815f07894cd0703c50d0a76ef64d482196f47a8bc729af9b80bb6\""}, {"sha": "873b33dc0d54d99ffd971c647905624890296de8", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,15 +7,12 @@\n package s2k\n \n import (\n-\t\"crypto/md5\"\n+\t\"crypto\"\n \t\"crypto/openpgp/error\"\n-\t\"crypto/ripemd160\"\n-\t\"crypto/sha1\"\n-\t\"crypto/sha256\"\n-\t\"crypto/sha512\"\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n+\t\"strconv\"\n )\n \n // Simple writes to out the result of computing the Simple S2K function (RFC\n@@ -87,9 +84,13 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \t\treturn\n \t}\n \n-\th := hashFuncFromType(buf[1])\n+\thash, ok := HashIdToHash(buf[1])\n+\tif !ok {\n+\t\treturn nil, error.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n+\t}\n+\th := hash.New()\n \tif h == nil {\n-\t\treturn nil, error.UnsupportedError(\"hash for S2K function\")\n+\t\treturn nil, error.UnsupportedError(\"hash not availible: \" + strconv.Itoa(int(hash)))\n \t}\n \n \tswitch buf[0] {\n@@ -122,25 +123,38 @@ func Parse(r io.Reader) (f func(out, in []byte), err os.Error) {\n \treturn nil, error.UnsupportedError(\"S2K function\")\n }\n \n-// hashFuncFromType returns a hash.Hash which corresponds to the given hash\n-// type byte. See RFC 4880, section 9.4.\n-func hashFuncFromType(hashType byte) hash.Hash {\n-\tswitch hashType {\n-\tcase 1:\n-\t\treturn md5.New()\n-\tcase 2:\n-\t\treturn sha1.New()\n-\tcase 3:\n-\t\treturn ripemd160.New()\n-\tcase 8:\n-\t\treturn sha256.New()\n-\tcase 9:\n-\t\treturn sha512.New384()\n-\tcase 10:\n-\t\treturn sha512.New()\n-\tcase 11:\n-\t\treturn sha256.New224()\n+// hashToHashIdMapping contains pairs relating OpenPGP's hash identifier with\n+// Go's crypto.Hash type. See RFC 4880, section 9.4.\n+var hashToHashIdMapping = []struct {\n+\tid   byte\n+\thash crypto.Hash\n+}{\n+\t{1, crypto.MD5},\n+\t{2, crypto.SHA1},\n+\t{3, crypto.RIPEMD160},\n+\t{8, crypto.SHA256},\n+\t{9, crypto.SHA384},\n+\t{10, crypto.SHA512},\n+\t{11, crypto.SHA224},\n+}\n+\n+// HashIdToHash returns a crypto.Hash which corresponds to the given OpenPGP\n+// hash id.\n+func HashIdToHash(id byte) (h crypto.Hash, ok bool) {\n+\tfor _, m := range hashToHashIdMapping {\n+\t\tif m.id == id {\n+\t\t\treturn m.hash, true\n+\t\t}\n \t}\n+\treturn 0, false\n+}\n \n-\treturn nil\n+// HashIdToHash returns an OpenPGP hash id which corresponds the given Hash.\n+func HashToHashId(h crypto.Hash) (id byte, ok bool) {\n+\tfor _, m := range hashToHashIdMapping {\n+\t\tif m.hash == h {\n+\t\t\treturn m.id, true\n+\t\t}\n+\t}\n+\treturn 0, false\n }"}, {"sha": "1a2e2bf040782b516ed7d1028f7745a19fe5e0de", "filename": "libgo/go/crypto/openpgp/write.go", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"crypto\"\n+\t\"crypto/openpgp/armor\"\n+\t\"crypto/openpgp/error\"\n+\t\"crypto/openpgp/packet\"\n+\t\"crypto/rsa\"\n+\t_ \"crypto/sha256\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"time\"\n+)\n+\n+// DetachSign signs message with the private key from signer (which must\n+// already have been decrypted) and writes the signature to w.\n+func DetachSign(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+\treturn detachSign(w, signer, message, packet.SigTypeBinary)\n+}\n+\n+// ArmoredDetachSign signs message with the private key from signer (which\n+// must already have been decrypted) and writes an armored signature to w.\n+func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader) (err os.Error) {\n+\treturn armoredDetachSign(w, signer, message, packet.SigTypeBinary)\n+}\n+\n+// DetachSignText signs message (after canonicalising the line endings) with\n+// the private key from signer (which must already have been decrypted) and\n+// writes the signature to w.\n+func DetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+\treturn detachSign(w, signer, message, packet.SigTypeText)\n+}\n+\n+// ArmoredDetachSignText signs message (after canonicalising the line endings)\n+// with the private key from signer (which must already have been decrypted)\n+// and writes an armored signature to w.\n+func SignTextDetachedArmored(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+\treturn armoredDetachSign(w, signer, message, packet.SigTypeText)\n+}\n+\n+func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err os.Error) {\n+\tout, err := armor.Encode(w, SignatureType, nil)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\terr = detachSign(out, signer, message, sigType)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn out.Close()\n+}\n+\n+func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err os.Error) {\n+\tif signer.PrivateKey == nil {\n+\t\treturn error.InvalidArgumentError(\"signing key doesn't have a private key\")\n+\t}\n+\tif signer.PrivateKey.Encrypted {\n+\t\treturn error.InvalidArgumentError(\"signing key is encrypted\")\n+\t}\n+\n+\tsig := new(packet.Signature)\n+\tsig.SigType = sigType\n+\tsig.PubKeyAlgo = signer.PrivateKey.PubKeyAlgo\n+\tsig.Hash = crypto.SHA256\n+\tsig.CreationTime = uint32(time.Seconds())\n+\tsig.IssuerKeyId = &signer.PrivateKey.KeyId\n+\n+\th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tio.Copy(wrappedHash, message)\n+\n+\tswitch signer.PrivateKey.PubKeyAlgo {\n+\tcase packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSASignOnly:\n+\t\tpriv := signer.PrivateKey.PrivateKey.(*rsa.PrivateKey)\n+\t\terr = sig.SignRSA(h, priv)\n+\tdefault:\n+\t\terr = error.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t}\n+\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treturn sig.Serialize(w)\n+}"}, {"sha": "33e8809f224bc84f531c33c185e5b4e917e85c08", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package openpgp\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+func TestSignDetached(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n+\tout := bytes.NewBuffer(nil)\n+\tmessage := bytes.NewBufferString(signedInput)\n+\terr := DetachSign(out, kring[0], message)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\ttestDetachedSignature(t, kring, out, signedInput, \"check\")\n+}\n+\n+func TestSignTextDetached(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2PrivateHex))\n+\tout := bytes.NewBuffer(nil)\n+\tmessage := bytes.NewBufferString(signedInput)\n+\terr := DetachSignText(out, kring[0], message)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\ttestDetachedSignature(t, kring, out, signedInput, \"check\")\n+}"}, {"sha": "66b72c07662f78915d3dd0b0d96f26c5883b7dcf", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -8,6 +8,7 @@\n package rand\n \n import (\n+\t\"bufio\"\n \t\"crypto/aes\"\n \t\"io\"\n \t\"os\"\n@@ -23,21 +24,20 @@ func init() { Reader = &devReader{name: \"/dev/urandom\"} }\n // A devReader satisfies reads by reading the file named name.\n type devReader struct {\n \tname string\n-\tf    *os.File\n+\tf    io.Reader\n \tmu   sync.Mutex\n }\n \n func (r *devReader) Read(b []byte) (n int, err os.Error) {\n \tr.mu.Lock()\n+\tdefer r.mu.Unlock()\n \tif r.f == nil {\n \t\tf, err := os.Open(r.name, os.O_RDONLY, 0)\n \t\tif f == nil {\n-\t\t\tr.mu.Unlock()\n \t\t\treturn 0, err\n \t\t}\n-\t\tr.f = f\n+\t\tr.f = bufio.NewReader(f)\n \t}\n-\tr.mu.Unlock()\n \treturn r.f.Read(b)\n }\n "}, {"sha": "281d6dc6aaf14e1355cc8521af7d64fe98163233", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -28,15 +28,15 @@ func (r *rngReader) Read(b []byte) (n int, err os.Error) {\n \tif r.prov == 0 {\n \t\tconst provType = syscall.PROV_RSA_FULL\n \t\tconst flags = syscall.CRYPT_VERIFYCONTEXT | syscall.CRYPT_SILENT\n-\t\tok, errno := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)\n-\t\tif !ok {\n+\t\terrno := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)\n+\t\tif errno != 0 {\n \t\t\tr.mu.Unlock()\n \t\t\treturn 0, os.NewSyscallError(\"CryptAcquireContext\", errno)\n \t\t}\n \t}\n \tr.mu.Unlock()\n-\tok, errno := syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])\n-\tif !ok {\n+\terrno := syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])\n+\tif errno != 0 {\n \t\treturn 0, os.NewSyscallError(\"CryptGenRandom\", errno)\n \t}\n \treturn len(b), nil"}, {"sha": "6e88521c3f6c58c7afee82d390e4c04a868bd90b", "filename": "libgo/go/crypto/ripemd160/ripemd160.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fripemd160%2Fripemd160.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -10,10 +10,15 @@ package ripemd160\n // http://homes.esat.kuleuven.be/~cosicart/pdf/AB-9601/AB-9601.pdf.\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.RIPEMD160, New)\n+}\n+\n // The size of the checksum in bytes.\n const Size = 20\n "}, {"sha": "2eaadee24c2e964d042e1d94109d5a4fc1ff3762", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,7 @@ package rsa\n \n import (\n \t\"big\"\n+\t\"crypto\"\n \t\"crypto/subtle\"\n \t\"io\"\n \t\"os\"\n@@ -139,19 +140,6 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n \treturn\n }\n \n-// Due to the design of PKCS#1 v1.5, we need to know the exact hash function in\n-// use. A generic hash.Hash will not do.\n-type PKCS1v15Hash int\n-\n-const (\n-\tHashMD5 PKCS1v15Hash = iota\n-\tHashSHA1\n-\tHashSHA256\n-\tHashSHA384\n-\tHashSHA512\n-\tHashMD5SHA1 // combined MD5 and SHA1 hash used for RSA signing in TLS.\n-)\n-\n // These are ASN1 DER structures:\n //   DigestInfo ::= SEQUENCE {\n //     digestAlgorithm AlgorithmIdentifier,\n@@ -160,25 +148,20 @@ const (\n // For performance, we don't use the generic ASN1 encoder. Rather, we\n // precompute a prefix of the digest value that makes a valid ASN1 DER string\n // with the correct contents.\n-var hashPrefixes = [][]byte{\n-\t// HashMD5\n-\t{0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n-\t// HashSHA1\n-\t{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n-\t// HashSHA256\n-\t{0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n-\t// HashSHA384\n-\t{0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n-\t// HashSHA512\n-\t{0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},\n-\t// HashMD5SHA1\n-\t{}, // A special TLS case which doesn't use an ASN1 prefix.\n+var hashPrefixes = map[crypto.Hash][]byte{\n+\tcrypto.MD5:       []byte{0x30, 0x20, 0x30, 0x0c, 0x06, 0x08, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x02, 0x05, 0x05, 0x00, 0x04, 0x10},\n+\tcrypto.SHA1:      []byte{0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14},\n+\tcrypto.SHA256:    []byte{0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20},\n+\tcrypto.SHA384:    []byte{0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30},\n+\tcrypto.SHA512:    {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40},\n+\tcrypto.MD5SHA1:   {}, // A special TLS case which doesn't use an ASN1 prefix.\n+\tcrypto.RIPEMD160: {0x30, 0x20, 0x30, 0x08, 0x06, 0x06, 0x28, 0xcf, 0x06, 0x03, 0x00, 0x31, 0x04, 0x14},\n }\n \n-// SignPKCS1v15 calcuates the signature of hashed using RSASSA-PSS-SIGN from RSA PKCS#1 v1.5.\n+// SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.\n // Note that hashed must be the result of hashing the input message using the\n // given hash function.\n-func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash PKCS1v15Hash, hashed []byte) (s []byte, err os.Error) {\n+func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err os.Error) {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n \t\treturn\n@@ -211,7 +194,7 @@ func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash PKCS1v15Hash, hashed []\n // hashed is the result of hashing the input message using the given hash\n // function and sig is the signature. A valid signature is indicated by\n // returning a nil error.\n-func VerifyPKCS1v15(pub *PublicKey, hash PKCS1v15Hash, hashed []byte, sig []byte) (err os.Error) {\n+func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err os.Error) {\n \thashLen, prefix, err := pkcs1v15HashInfo(hash, len(hashed))\n \tif err != nil {\n \t\treturn\n@@ -246,28 +229,14 @@ func VerifyPKCS1v15(pub *PublicKey, hash PKCS1v15Hash, hashed []byte, sig []byte\n \treturn nil\n }\n \n-func pkcs1v15HashInfo(hash PKCS1v15Hash, inLen int) (hashLen int, prefix []byte, err os.Error) {\n-\tswitch hash {\n-\tcase HashMD5:\n-\t\thashLen = 16\n-\tcase HashSHA1:\n-\t\thashLen = 20\n-\tcase HashSHA256:\n-\t\thashLen = 32\n-\tcase HashSHA384:\n-\t\thashLen = 48\n-\tcase HashSHA512:\n-\t\thashLen = 64\n-\tcase HashMD5SHA1:\n-\t\thashLen = 36\n-\tdefault:\n-\t\treturn 0, nil, os.ErrorString(\"unknown hash function\")\n-\t}\n-\n+func pkcs1v15HashInfo(hash crypto.Hash, inLen int) (hashLen int, prefix []byte, err os.Error) {\n+\thashLen = hash.Size()\n \tif inLen != hashLen {\n \t\treturn 0, nil, os.ErrorString(\"input must be hashed message\")\n \t}\n-\n-\tprefix = hashPrefixes[int(hash)]\n+\tprefix, ok := hashPrefixes[hash]\n+\tif !ok {\n+\t\treturn 0, nil, os.ErrorString(\"unsupported hash function\")\n+\t}\n \treturn\n }"}, {"sha": "7b2ce08cb0bf5c96f43cfcad228e8a46bbc5fb3f", "filename": "libgo/go/crypto/rsa/pkcs1v15_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,6 +7,7 @@ package rsa\n import (\n \t\"big\"\n \t\"bytes\"\n+\t\"crypto\"\n \t\"crypto/rand\"\n \t\"crypto/sha1\"\n \t\"encoding/base64\"\n@@ -165,7 +166,7 @@ func TestSignPKCS1v15(t *testing.T) {\n \t\th.Write([]byte(test.in))\n \t\tdigest := h.Sum()\n \n-\t\ts, err := SignPKCS1v15(nil, rsaPrivateKey, HashSHA1, digest)\n+\t\ts, err := SignPKCS1v15(nil, rsaPrivateKey, crypto.SHA1, digest)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d %s\", i, err)\n \t\t}\n@@ -185,7 +186,7 @@ func TestVerifyPKCS1v15(t *testing.T) {\n \n \t\tsig, _ := hex.DecodeString(test.out)\n \n-\t\terr := VerifyPKCS1v15(&rsaPrivateKey.PublicKey, HashSHA1, digest, sig)\n+\t\terr := VerifyPKCS1v15(&rsaPrivateKey.PublicKey, crypto.SHA1, digest, sig)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d %s\", i, err)\n \t\t}"}, {"sha": "faf914991d06310b54d6c2ddfbfc1d0680128a3c", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -274,6 +274,14 @@ func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, lab\n \tm.SetBytes(em)\n \tc := encrypt(new(big.Int), pub, m)\n \tout = c.Bytes()\n+\n+\tif len(out) < k {\n+\t\t// If the output is too small, we need to left-pad with zeros.\n+\t\tt := make([]byte, k)\n+\t\tcopy(t[k-len(out):], out)\n+\t\tout = t\n+\t}\n+\n \treturn\n }\n "}, {"sha": "22d4576e8dd527afad8bc87f43fb517bb0356202", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -66,7 +66,7 @@ func TestEncryptOAEP(t *testing.T) {\n \t\t\t\tt.Errorf(\"#%d,%d error: %s\", i, j, err)\n \t\t\t}\n \t\t\tif bytes.Compare(out, message.out) != 0 {\n-\t\t\t\tt.Errorf(\"#%d,%d bad result: %s (want %s)\", i, j, out, message.out)\n+\t\t\t\tt.Errorf(\"#%d,%d bad result: %x (want %x)\", i, j, out, message.out)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "e6aa096e2a6b9c07ae1f7e8687b4d18efa1b4a12", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,10 +6,15 @@\n package sha1\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.SHA1, New)\n+}\n+\n // The size of a SHA1 checksum in bytes.\n const Size = 20\n "}, {"sha": "69b356b4e5132297fad466df20b5bb159a1f06bb", "filename": "libgo/go/crypto/sha256/sha256.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,10 +6,16 @@\n package sha256\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.SHA224, New224)\n+\tcrypto.RegisterHash(crypto.SHA256, New)\n+}\n+\n // The size of a SHA256 checksum in bytes.\n const Size = 32\n "}, {"sha": "7e9f330e594a4c08c212d2d47ea28ebd09d9c802", "filename": "libgo/go/crypto/sha512/sha512.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,10 +6,16 @@\n package sha512\n \n import (\n+\t\"crypto\"\n \t\"hash\"\n \t\"os\"\n )\n \n+func init() {\n+\tcrypto.RegisterHash(crypto.SHA384, New384)\n+\tcrypto.RegisterHash(crypto.SHA512, New)\n+}\n+\n // The size of a SHA512 checksum in bytes.\n const Size = 64\n "}, {"sha": "a325a9b953cf9a0d011bc564dfee01667c0286ce", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -5,6 +5,7 @@\n package tls\n \n import (\n+\t\"crypto\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n@@ -56,7 +57,7 @@ func (c *Conn) clientHandshake() os.Error {\n \n \tvers, ok := mutualVersion(serverHello.vers)\n \tif !ok {\n-\t\tc.sendAlert(alertProtocolVersion)\n+\t\treturn c.sendAlert(alertProtocolVersion)\n \t}\n \tc.vers = vers\n \tc.haveVers = true\n@@ -248,7 +249,7 @@ func (c *Conn) clientHandshake() os.Error {\n \t\tvar digest [36]byte\n \t\tcopy(digest[0:16], finishedHash.serverMD5.Sum())\n \t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum())\n-\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, rsa.HashMD5SHA1, digest[0:])\n+\t\tsigned, err := rsa.SignPKCS1v15(c.config.rand(), c.config.Certificates[0].PrivateKey, crypto.MD5SHA1, digest[0:])\n \t\tif err != nil {\n \t\t\treturn c.sendAlert(alertInternalError)\n \t\t}"}, {"sha": "fd1f145cfc4e37754131282a9c80f9639dff1513", "filename": "libgo/go/crypto/tls/handshake_client_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -61,7 +61,7 @@ func TestRunClient(t *testing.T) {\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in client mode:\n-//   % gotest -match \"TestRunClient\" -connect\n+//   % gotest -test.run \"TestRunClient\" -connect\n // and then:\n //   % gnutls-serv -p 10443 --debug 100 --x509keyfile key.pem --x509certfile cert.pem -a > /tmp/log 2>&1\n //   % python parse-gnutls-cli-debug-log.py < /tmp/log"}, {"sha": "809c8c15e5df19a2db9e3d4387c11c9bc1b39859", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -5,6 +5,7 @@\n package tls\n \n import (\n+\t\"crypto\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n@@ -56,6 +57,7 @@ Curves:\n \n \tvar suite *cipherSuite\n \tvar suiteId uint16\n+FindCipherSuite:\n \tfor _, id := range clientHello.cipherSuites {\n \t\tfor _, supported := range config.cipherSuites() {\n \t\t\tif id == supported {\n@@ -66,7 +68,7 @@ Curves:\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tsuiteId = id\n-\t\t\t\tbreak\n+\t\t\t\tbreak FindCipherSuite\n \t\t\t}\n \t\t}\n \t}\n@@ -213,7 +215,7 @@ Curves:\n \t\tdigest := make([]byte, 36)\n \t\tcopy(digest[0:16], finishedHash.serverMD5.Sum())\n \t\tcopy(digest[16:36], finishedHash.serverSHA1.Sum())\n-\t\terr = rsa.VerifyPKCS1v15(pub, rsa.HashMD5SHA1, digest, certVerify.signature)\n+\t\terr = rsa.VerifyPKCS1v15(pub, crypto.MD5SHA1, digest, certVerify.signature)\n \t\tif err != nil {\n \t\t\tc.sendAlert(alertBadCertificate)\n \t\t\treturn os.ErrorString(\"could not validate signature of connection nonces: \" + err.String())"}, {"sha": "6beb6a9f62b64f725238a7072b7dc03bb636a220", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -194,7 +194,7 @@ var testPrivateKey = &rsa.PrivateKey{\n \n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in server mode:\n-//   % gotest -match \"TestRunServer\" -serve\n+//   % gotest -test.run \"TestRunServer\" -serve\n // and then:\n //   % gnutls-cli --insecure --debug 100 -p 10443 localhost > /tmp/log 2>&1\n //   % python parse-gnutls-cli-debug-log.py < /tmp/log"}, {"sha": "8edbb11900c5f1dfa2b8f2db9b08c67d46cafc2e", "filename": "libgo/go/crypto/tls/key_agreement.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fkey_agreement.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,7 @@ package tls\n \n import (\n \t\"big\"\n+\t\"crypto\"\n \t\"crypto/elliptic\"\n \t\"crypto/md5\"\n \t\"crypto/rsa\"\n@@ -143,7 +144,7 @@ Curve:\n \tcopy(serverECDHParams[4:], ecdhePublic)\n \n \tmd5sha1 := md5SHA1Hash(clientHello.random, hello.random, serverECDHParams)\n-\tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, rsa.HashMD5SHA1, md5sha1)\n+\tsig, err := rsa.SignPKCS1v15(config.rand(), config.Certificates[0].PrivateKey, crypto.MD5SHA1, md5sha1)\n \tif err != nil {\n \t\treturn nil, os.ErrorString(\"failed to sign ECDHE parameters: \" + err.String())\n \t}\n@@ -216,7 +217,7 @@ func (ka *ecdheRSAKeyAgreement) processServerKeyExchange(config *Config, clientH\n \tsig = sig[2:]\n \n \tmd5sha1 := md5SHA1Hash(clientHello.random, serverHello.random, serverECDHParams)\n-\treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), rsa.HashMD5SHA1, md5sha1, sig)\n+\treturn rsa.VerifyPKCS1v15(cert.PublicKey.(*rsa.PublicKey), crypto.MD5SHA1, md5sha1, sig)\n \n Error:\n \treturn os.ErrorString(\"invalid ServerKeyExchange\")"}, {"sha": "e8290d728dd80153835ef5f8b178f5917436a00e", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -124,14 +124,22 @@ func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.\n \t\treturn\n \t}\n \n-\tcertDERBlock, _ := pem.Decode(certPEMBlock)\n-\tif certDERBlock == nil {\n+\tvar certDERBlock *pem.Block\n+\tfor {\n+\t\tcertDERBlock, certPEMBlock = pem.Decode(certPEMBlock)\n+\t\tif certDERBlock == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif certDERBlock.Type == \"CERTIFICATE\" {\n+\t\t\tcert.Certificate = append(cert.Certificate, certDERBlock.Bytes)\n+\t\t}\n+\t}\n+\n+\tif len(cert.Certificate) == 0 {\n \t\terr = os.ErrorString(\"crypto/tls: failed to parse certificate PEM data\")\n \t\treturn\n \t}\n \n-\tcert.Certificate = [][]byte{certDERBlock.Bytes}\n-\n \tkeyPEMBlock, err := ioutil.ReadFile(keyFile)\n \tif err != nil {\n \t\treturn\n@@ -153,7 +161,7 @@ func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.\n \n \t// We don't need to parse the public key for TLS, but we so do anyway\n \t// to check that it looks sane and matches the private key.\n-\tx509Cert, err := x509.ParseCertificate(certDERBlock.Bytes)\n+\tx509Cert, err := x509.ParseCertificate(cert.Certificate[0])\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "3af8ba8ca24f0186422763616a706ceb6dc8034b", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 77, "deletions": 5, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"asn1\"\n \t\"big\"\n \t\"container/vector\"\n+\t\"crypto\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"hash\"\n@@ -330,6 +331,10 @@ type Certificate struct {\n \tDNSNames       []string\n \tEmailAddresses []string\n \n+\t// Name constraints\n+\tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n+\tPermittedDNSDomains         []string\n+\n \tPolicyIdentifiers []asn1.ObjectIdentifier\n }\n \n@@ -374,12 +379,12 @@ func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error) {\n \t// TODO(agl): don't ignore the path length constraint.\n \n \tvar h hash.Hash\n-\tvar hashType rsa.PKCS1v15Hash\n+\tvar hashType crypto.Hash\n \n \tswitch c.SignatureAlgorithm {\n \tcase SHA1WithRSA:\n \t\th = sha1.New()\n-\t\thashType = rsa.HashSHA1\n+\t\thashType = crypto.SHA1\n \tdefault:\n \t\treturn UnsupportedAlgorithmError{}\n \t}\n@@ -474,6 +479,18 @@ type policyInformation struct {\n \t// policyQualifiers omitted\n }\n \n+// RFC 5280, 4.2.1.10\n+type nameConstraints struct {\n+\tPermitted []generalSubtree \"optional,tag:0\"\n+\tExcluded  []generalSubtree \"optional,tag:1\"\n+}\n+\n+type generalSubtree struct {\n+\tName string \"tag:2,optional,ia5\"\n+\tMin  int    \"optional,tag:0\"\n+\tMax  int    \"optional,tag:1\"\n+}\n+\n func parsePublicKey(algo PublicKeyAlgorithm, asn1Data []byte) (interface{}, os.Error) {\n \tswitch algo {\n \tcase RSA:\n@@ -602,6 +619,43 @@ func parseCertificate(in *certificate) (*Certificate, os.Error) {\n \t\t\t\t// If we didn't parse any of the names then we\n \t\t\t\t// fall through to the critical check below.\n \n+\t\t\tcase 30:\n+\t\t\t\t// RFC 5280, 4.2.1.10\n+\n+\t\t\t\t// NameConstraints ::= SEQUENCE {\n+\t\t\t\t//      permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,\n+\t\t\t\t//      excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }\n+\t\t\t\t//\n+\t\t\t\t// GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree\n+\t\t\t\t//\n+\t\t\t\t// GeneralSubtree ::= SEQUENCE {\n+\t\t\t\t//      base                    GeneralName,\n+\t\t\t\t//      minimum         [0]     BaseDistance DEFAULT 0,\n+\t\t\t\t//      maximum         [1]     BaseDistance OPTIONAL }\n+\t\t\t\t//\n+\t\t\t\t// BaseDistance ::= INTEGER (0..MAX)\n+\n+\t\t\t\tvar constraints nameConstraints\n+\t\t\t\t_, err := asn1.Unmarshal(e.Value, &constraints)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\n+\t\t\t\tif len(constraints.Excluded) > 0 && e.Critical {\n+\t\t\t\t\treturn out, UnhandledCriticalExtension{}\n+\t\t\t\t}\n+\n+\t\t\t\tfor _, subtree := range constraints.Permitted {\n+\t\t\t\t\tif subtree.Min > 0 || subtree.Max > 0 || len(subtree.Name) == 0 {\n+\t\t\t\t\t\tif e.Critical {\n+\t\t\t\t\t\t\treturn out, UnhandledCriticalExtension{}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tout.PermittedDNSDomains = append(out.PermittedDNSDomains, subtree.Name)\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\n \t\t\tcase 35:\n \t\t\t\t// RFC 5280, 4.2.1.1\n \t\t\t\tvar a authKeyId\n@@ -698,10 +752,11 @@ var (\n \toidExtensionBasicConstraints    = []int{2, 5, 29, 19}\n \toidExtensionSubjectAltName      = []int{2, 5, 29, 17}\n \toidExtensionCertificatePolicies = []int{2, 5, 29, 32}\n+\toidExtensionNameConstraints     = []int{2, 5, 29, 30}\n )\n \n func buildExtensions(template *Certificate) (ret []extension, err os.Error) {\n-\tret = make([]extension, 6 /* maximum number of elements. */ )\n+\tret = make([]extension, 7 /* maximum number of elements. */ )\n \tn := 0\n \n \tif template.KeyUsage != 0 {\n@@ -778,6 +833,22 @@ func buildExtensions(template *Certificate) (ret []extension, err os.Error) {\n \t\tn++\n \t}\n \n+\tif len(template.PermittedDNSDomains) > 0 {\n+\t\tret[n].Id = oidExtensionNameConstraints\n+\t\tret[n].Critical = template.PermittedDNSDomainsCritical\n+\n+\t\tvar out nameConstraints\n+\t\tout.Permitted = make([]generalSubtree, len(template.PermittedDNSDomains))\n+\t\tfor i, permitted := range template.PermittedDNSDomains {\n+\t\t\tout.Permitted[i] = generalSubtree{Name: permitted}\n+\t\t}\n+\t\tret[n].Value, err = asn1.Marshal(out)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t\tn++\n+\t}\n+\n \t// Adding another extension here? Remember to update the maximum number\n \t// of elements in the make() at the top of the function.\n \n@@ -792,7 +863,8 @@ var (\n // CreateSelfSignedCertificate creates a new certificate based on\n // a template. The following members of template are used: SerialNumber,\n // Subject, NotBefore, NotAfter, KeyUsage, BasicConstraintsValid, IsCA,\n-// MaxPathLen, SubjectKeyId, DNSNames.\n+// MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\n+// PermittedDNSDomains.\n //\n // The certificate is signed by parent. If parent is equal to template then the\n // certificate is self-signed. The parameter pub is the public key of the\n@@ -840,7 +912,7 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.P\n \th.Write(tbsCertContents)\n \tdigest := h.Sum()\n \n-\tsignature, err := rsa.SignPKCS1v15(rand, priv, rsa.HashSHA1, digest)\n+\tsignature, err := rsa.SignPKCS1v15(rand, priv, crypto.SHA1, digest)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "57889e7e12201dc2bd961695051a63496c8d278c", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -171,7 +171,8 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\tIsCA:                  true,\n \t\tDNSNames:              []string{\"test.example.com\"},\n \n-\t\tPolicyIdentifiers: []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n+\t\tPolicyIdentifiers:   []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n+\t\tPermittedDNSDomains: []string{\".example.com\", \"example.com\"},\n \t}\n \n \tderBytes, err := CreateCertificate(random, &template, &template, &priv.PublicKey, priv)\n@@ -190,6 +191,10 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\tt.Errorf(\"Failed to parse policy identifiers: got:%#v want:%#v\", cert.PolicyIdentifiers, template.PolicyIdentifiers)\n \t}\n \n+\tif len(cert.PermittedDNSDomains) != 2 || cert.PermittedDNSDomains[0] != \".example.com\" || cert.PermittedDNSDomains[1] != \"example.com\" {\n+\t\tt.Errorf(\"Failed to parse name constraints: %#v\", cert.PermittedDNSDomains)\n+\t}\n+\n \terr = cert.CheckSignatureFrom(cert)\n \tif err != nil {\n \t\tt.Errorf(\"Signature verification failed: %s\", err)"}, {"sha": "1bcbdc5e9a5706af9af14d09b14b255ca94b33f7", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -57,7 +57,6 @@ type ImportDirectory struct {\n \tFirstThunk         uint32\n \n \tdll string\n-\trva []uint32\n }\n \n // Data reads and returns the contents of the PE section.\n@@ -267,34 +266,28 @@ func (f *File) ImportedSymbols() ([]string, os.Error) {\n \t\t}\n \t\tida = append(ida, dt)\n \t}\n-\tfor i, _ := range ida {\n+\tnames, _ := ds.Data()\n+\tvar all []string\n+\tfor _, dt := range ida {\n+\t\tdt.dll, _ = getString(names, int(dt.Name-ds.VirtualAddress))\n+\t\td, _ = ds.Data()\n+\t\t// seek to OriginalFirstThunk\n+\t\td = d[dt.OriginalFirstThunk-ds.VirtualAddress:]\n \t\tfor len(d) > 0 {\n \t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n \t\t\td = d[4:]\n \t\t\tif va == 0 {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tida[i].rva = append(ida[i].rva, va)\n-\t\t}\n-\t}\n-\tfor _, _ = range ida {\n-\t\tfor len(d) > 0 {\n-\t\t\tva := binary.LittleEndian.Uint32(d[0:4])\n-\t\t\td = d[4:]\n-\t\t\tif va == 0 {\n-\t\t\t\tbreak\n+\t\t\tif va&0x80000000 > 0 { // is Ordinal\n+\t\t\t\t// TODO add dynimport ordinal support.\n+\t\t\t\t//ord := va&0x0000FFFF\n+\t\t\t} else {\n+\t\t\t\tfn, _ := getString(names, int(va-ds.VirtualAddress+2))\n+\t\t\t\tall = append(all, fn+\":\"+dt.dll)\n \t\t\t}\n \t\t}\n \t}\n-\tnames, _ := ds.Data()\n-\tvar all []string\n-\tfor _, dt := range ida {\n-\t\tdt.dll, _ = getString(names, int(dt.Name-ds.VirtualAddress))\n-\t\tfor _, va := range dt.rva {\n-\t\t\tfn, _ := getString(names, int(va-ds.VirtualAddress+2))\n-\t\t\tall = append(all, fn+\":\"+dt.dll)\n-\t\t}\n-\t}\n \n \treturn all, nil\n }"}, {"sha": "69ad5fed1cf6aa05c4c2bcc79fcf69ddc4326e30", "filename": "libgo/go/ebnf/ebnf_test.go", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Febnf%2Febnf_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Febnf%2Febnf_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Febnf%2Febnf_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -15,31 +15,31 @@ var fset = token.NewFileSet()\n \n \n var grammars = []string{\n-\t`Program = .\n-\t`,\n-\n-\t`Program = foo .\n-\tfoo = \"foo\" .\n-\t`,\n-\n-\t`Program = \"a\" | \"b\" \"c\" .\n-\t`,\n-\n-\t`Program = \"a\" ... \"z\" .\n-\t`,\n-\n-\t`Program = Song .\n-\t Song = { Note } .\n-\t Note = Do | (Re | Mi | Fa | So | La) | Ti .\n-\t Do = \"c\" .\n-\t Re = \"d\" .\n-\t Mi = \"e\" .\n-\t Fa = \"f\" .\n-\t So = \"g\" .\n-\t La = \"a\" .\n-\t Ti = ti .\n-\t ti = \"b\" .\n-\t`,\n+`Program = .\n+`,\n+\n+`Program = foo .\n+foo = \"foo\" .\n+`,\n+\n+`Program = \"a\" | \"b\" \"c\" .\n+`,\n+\n+`Program = \"a\" ... \"z\" .\n+`,\n+\n+`Program = Song .\n+ Song = { Note } .\n+ Note = Do | (Re | Mi | Fa | So | La) | Ti .\n+ Do = \"c\" .\n+ Re = \"d\" .\n+ Mi = \"e\" .\n+ Fa = \"f\" .\n+ So = \"g\" .\n+ La = \"a\" .\n+ Ti = ti .\n+ ti = \"b\" .\n+`,\n }\n \n "}, {"sha": "ee2f23dbba2774f3373c19175f0695a769ea712a", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -2,8 +2,9 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements translation between\n-// unsigned integer values and byte sequences.\n+// Package binary implements translation between\n+// unsigned integer values and byte sequences\n+// and the reading and writing of fixed-size values.\n package binary\n \n import ("}, {"sha": "f46ce1c83a05711c4a0eb87d3ed241eaf94f600f", "filename": "libgo/go/encoding/line/line.go", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fline%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -2,29 +2,49 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This package implements a Reader which handles reading \\r and \\r\\n\n-// deliminated lines.\n+// The line package implements a Reader that reads lines delimited by '\\n' or ' \\r\\n'.\n package line\n \n import (\n \t\"io\"\n \t\"os\"\n )\n \n-// Reader reads lines from an io.Reader (which may use either '\\n' or\n-// '\\r\\n').\n+// Reader reads lines, delimited by '\\n' or \\r\\n', from an io.Reader.\n type Reader struct {\n \tbuf      []byte\n \tconsumed int\n \tin       io.Reader\n \terr      os.Error\n }\n \n-func NewReader(in io.Reader, maxLineLength int) *Reader {\n+// NewReader returns a new Reader that will read successive\n+// lines from the input Reader.\n+func NewReader(input io.Reader, maxLineLength int) *Reader {\n \treturn &Reader{\n \t\tbuf:      make([]byte, 0, maxLineLength),\n \t\tconsumed: 0,\n-\t\tin:       in,\n+\t\tin:       input,\n+\t}\n+}\n+\n+// Read reads from any buffered data past the last line read, or from the underlying\n+// io.Reader if the buffer is empty.\n+func (l *Reader) Read(p []byte) (n int, err os.Error) {\n+\tl.removeConsumedFromBuffer()\n+\tif len(l.buf) > 0 {\n+\t\tn = copy(p, l.buf)\n+\t\tl.consumed += n\n+\t\treturn\n+\t}\n+\treturn l.in.Read(p)\n+}\n+\n+func (l *Reader) removeConsumedFromBuffer() {\n+\tif l.consumed > 0 {\n+\t\tn := copy(l.buf, l.buf[l.consumed:])\n+\t\tl.buf = l.buf[:n]\n+\t\tl.consumed = 0\n \t}\n }\n \n@@ -36,11 +56,7 @@ func NewReader(in io.Reader, maxLineLength int) *Reader {\n // the Reader and is only valid until the next call to ReadLine. ReadLine\n // either returns a non-nil line or it returns an error, never both.\n func (l *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n-\tif l.consumed > 0 {\n-\t\tn := copy(l.buf, l.buf[l.consumed:])\n-\t\tl.buf = l.buf[:n]\n-\t\tl.consumed = 0\n-\t}\n+\tl.removeConsumedFromBuffer()\n \n \tif len(l.buf) == 0 && l.err != nil {\n \t\terr = l.err\n@@ -89,6 +105,9 @@ func (l *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error) {\n \t\tl.buf = l.buf[:oldLen+n]\n \t\tif readErr != nil {\n \t\t\tl.err = readErr\n+\t\t\tif len(l.buf) == 0 {\n+\t\t\t\treturn nil, false, readErr\n+\t\t\t}\n \t\t}\n \t}\n \tpanic(\"unreachable\")"}, {"sha": "ff3d51669b54326646975bd1a9ce2fa12e69a7e6", "filename": "libgo/go/encoding/line/line_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fline%2Fline_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,8 @@ package line\n \n import (\n \t\"bytes\"\n+\t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"testing\"\n )\n@@ -87,3 +89,45 @@ func TestLineTooLong(t *testing.T) {\n \t\tt.Errorf(\"bad result for third line: %x\", line)\n \t}\n }\n+\n+func TestReadAfterLines(t *testing.T) {\n+\tline1 := \"line1\"\n+\trestData := \"line2\\nline 3\\n\"\n+\tinbuf := bytes.NewBuffer([]byte(line1 + \"\\n\" + restData))\n+\toutbuf := new(bytes.Buffer)\n+\tmaxLineLength := len(line1) + len(restData)/2\n+\tl := NewReader(inbuf, maxLineLength)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif isPrefix || err != nil || string(line) != line1 {\n+\t\tt.Errorf(\"bad result for first line: isPrefix=%v err=%v line=%q\", isPrefix, err, string(line))\n+\t}\n+\tn, err := io.Copy(outbuf, l)\n+\tif int(n) != len(restData) || err != nil {\n+\t\tt.Errorf(\"bad result for Read: n=%d err=%v\", n, err)\n+\t}\n+\tif outbuf.String() != restData {\n+\t\tt.Errorf(\"bad result for Read: got %q; expected %q\", outbuf.String(), restData)\n+\t}\n+}\n+\n+func TestReadEmptyBuffer(t *testing.T) {\n+\tl := NewReader(bytes.NewBuffer(nil), 10)\n+\tline, isPrefix, err := l.ReadLine()\n+\tif err != os.EOF {\n+\t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n+\t}\n+}\n+\n+func TestLinesAfterRead(t *testing.T) {\n+\tl := NewReader(bytes.NewBuffer([]byte(\"foo\")), 10)\n+\t_, err := ioutil.ReadAll(l)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\n+\tline, isPrefix, err := l.ReadLine()\n+\tif err != os.EOF {\n+\t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n+\t}\n+}"}, {"sha": "80f6f3c7dd489d28535e026501c2b4852c26ff35", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,6 +7,7 @@ package exec\n \n import (\n \t\"os\"\n+\t\"strconv\"\n )\n \n // Arguments to Run.\n@@ -21,12 +22,22 @@ const (\n // Stdin, Stdout, and Stderr are Files representing pipes\n // connected to the running command's standard input, output, and error,\n // or else nil, depending on the arguments to Run.\n-// Pid is the running command's operating system process ID.\n+// Process represents the underlying operating system process.\n type Cmd struct {\n-\tStdin  *os.File\n-\tStdout *os.File\n-\tStderr *os.File\n-\tPid    int\n+\tStdin   *os.File\n+\tStdout  *os.File\n+\tStderr  *os.File\n+\tProcess *os.Process\n+}\n+\n+// PathError records the name of a binary that was not\n+// found on the current $PATH.\n+type PathError struct {\n+\tName string\n+}\n+\n+func (e *PathError) String() string {\n+\treturn \"command \" + strconv.Quote(e.Name) + \" not found in $PATH\"\n }\n \n // Given mode (DevNull, etc), return file for child\n@@ -77,24 +88,24 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {\n // If a parameter is Pipe, then the corresponding field (Stdin, Stdout, Stderr)\n // of the returned Cmd is the other end of the pipe.\n // Otherwise the field in Cmd is nil.\n-func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int) (p *Cmd, err os.Error) {\n-\tp = new(Cmd)\n+func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int) (c *Cmd, err os.Error) {\n+\tc = new(Cmd)\n \tvar fd [3]*os.File\n \n-\tif fd[0], p.Stdin, err = modeToFiles(stdin, 0); err != nil {\n+\tif fd[0], c.Stdin, err = modeToFiles(stdin, 0); err != nil {\n \t\tgoto Error\n \t}\n-\tif fd[1], p.Stdout, err = modeToFiles(stdout, 1); err != nil {\n+\tif fd[1], c.Stdout, err = modeToFiles(stdout, 1); err != nil {\n \t\tgoto Error\n \t}\n \tif stderr == MergeWithStdout {\n \t\tfd[2] = fd[1]\n-\t} else if fd[2], p.Stderr, err = modeToFiles(stderr, 2); err != nil {\n+\t} else if fd[2], c.Stderr, err = modeToFiles(stderr, 2); err != nil {\n \t\tgoto Error\n \t}\n \n \t// Run command.\n-\tp.Pid, err = os.ForkExec(name, argv, envv, dir, fd[0:])\n+\tc.Process, err = os.StartProcess(name, argv, envv, dir, fd[0:])\n \tif err != nil {\n \t\tgoto Error\n \t}\n@@ -107,7 +118,7 @@ func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int\n \tif fd[2] != os.Stderr && fd[2] != fd[1] {\n \t\tfd[2].Close()\n \t}\n-\treturn p, nil\n+\treturn c, nil\n \n Error:\n \tif fd[0] != os.Stdin && fd[0] != nil {\n@@ -119,63 +130,67 @@ Error:\n \tif fd[2] != os.Stderr && fd[2] != nil && fd[2] != fd[1] {\n \t\tfd[2].Close()\n \t}\n-\tif p.Stdin != nil {\n-\t\tp.Stdin.Close()\n+\tif c.Stdin != nil {\n+\t\tc.Stdin.Close()\n+\t}\n+\tif c.Stdout != nil {\n+\t\tc.Stdout.Close()\n \t}\n-\tif p.Stdout != nil {\n-\t\tp.Stdout.Close()\n+\tif c.Stderr != nil {\n+\t\tc.Stderr.Close()\n \t}\n-\tif p.Stderr != nil {\n-\t\tp.Stderr.Close()\n+\tif c.Process != nil {\n+\t\tc.Process.Release()\n \t}\n \treturn nil, err\n }\n \n-// Wait waits for the running command p,\n-// returning the Waitmsg returned by os.Wait and an error.\n-// The options are passed through to os.Wait.\n-// Setting options to 0 waits for p to exit;\n+// Wait waits for the running command c,\n+// returning the Waitmsg returned when the process exits.\n+// The options are passed to the process's Wait method.\n+// Setting options to 0 waits for c to exit;\n // other options cause Wait to return for other\n // process events; see package os for details.\n-func (p *Cmd) Wait(options int) (*os.Waitmsg, os.Error) {\n-\tif p.Pid <= 0 {\n+func (c *Cmd) Wait(options int) (*os.Waitmsg, os.Error) {\n+\tif c.Process == nil {\n \t\treturn nil, os.ErrorString(\"exec: invalid use of Cmd.Wait\")\n \t}\n-\tw, err := os.Wait(p.Pid, options)\n+\tw, err := c.Process.Wait(options)\n \tif w != nil && (w.Exited() || w.Signaled()) {\n-\t\tp.Pid = -1\n+\t\tc.Process.Release()\n+\t\tc.Process = nil\n \t}\n \treturn w, err\n }\n \n-// Close waits for the running command p to exit,\n+// Close waits for the running command c to exit,\n // if it hasn't already, and then closes the non-nil file descriptors\n-// p.Stdin, p.Stdout, and p.Stderr.\n-func (p *Cmd) Close() os.Error {\n-\tif p.Pid > 0 {\n+// c.Stdin, c.Stdout, and c.Stderr.\n+func (c *Cmd) Close() os.Error {\n+\tif c.Process != nil {\n \t\t// Loop on interrupt, but\n \t\t// ignore other errors -- maybe\n \t\t// caller has already waited for pid.\n-\t\t_, err := p.Wait(0)\n+\t\t_, err := c.Wait(0)\n \t\tfor err == os.EINTR {\n-\t\t\t_, err = p.Wait(0)\n+\t\t\t_, err = c.Wait(0)\n \t\t}\n \t}\n \n \t// Close the FDs that are still open.\n \tvar err os.Error\n-\tif p.Stdin != nil && p.Stdin.Fd() >= 0 {\n-\t\tif err1 := p.Stdin.Close(); err1 != nil {\n+\tif c.Stdin != nil && c.Stdin.Fd() >= 0 {\n+\t\tif err1 := c.Stdin.Close(); err1 != nil {\n \t\t\terr = err1\n \t\t}\n \t}\n-\tif p.Stdout != nil && p.Stdout.Fd() >= 0 {\n-\t\tif err1 := p.Stdout.Close(); err1 != nil && err != nil {\n+\tif c.Stdout != nil && c.Stdout.Fd() >= 0 {\n+\t\tif err1 := c.Stdout.Close(); err1 != nil && err != nil {\n \t\t\terr = err1\n \t\t}\n \t}\n-\tif p.Stderr != nil && p.Stderr != p.Stdout && p.Stderr.Fd() >= 0 {\n-\t\tif err1 := p.Stderr.Close(); err1 != nil && err != nil {\n+\tif c.Stderr != nil && c.Stderr != c.Stdout && c.Stderr.Fd() >= 0 {\n+\t\tif err1 := c.Stderr.Close(); err1 != nil && err != nil {\n \t\t\terr = err1\n \t\t}\n \t}"}, {"sha": "54081771eccc8bb3bfb875a39fa225cd24c8f0aa", "filename": "libgo/go/exec/lp_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package exec\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var nonExistentPaths = []string{\n+\t\"some-non-existent-path\",\n+\t\"non-existent-path/slashed\",\n+}\n+\n+func TestLookPathNotFound(t *testing.T) {\n+\tfor _, name := range nonExistentPaths {\n+\t\tpath, err := LookPath(name)\n+\t\tif err == nil {\n+\t\t\tt.Fatalf(\"LookPath found %q in $PATH\", name)\n+\t\t}\n+\t\tif path != \"\" {\n+\t\t\tt.Fatalf(\"LookPath path == %q when err != nil\", path)\n+\t\t}\n+\t\tperr, ok := err.(*PathError)\n+\t\tif !ok {\n+\t\t\tt.Fatal(\"LookPath error is not a PathError\")\n+\t\t}\n+\t\tif perr.Name != name {\n+\t\t\tt.Fatalf(\"want PathError name %q, got %q\", name, perr.Name)\n+\t\t}\n+\t}\n+}"}, {"sha": "44f84347b99c4f71476382002ec9b5dca75c73df", "filename": "libgo/go/exec/lp_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_unix.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -29,7 +29,7 @@ func LookPath(file string) (string, os.Error) {\n \t\tif canExec(file) {\n \t\t\treturn file, nil\n \t\t}\n-\t\treturn \"\", &os.PathError{\"lookpath\", file, os.ENOENT}\n+\t\treturn \"\", &PathError{file}\n \t}\n \tpathenv := os.Getenv(\"PATH\")\n \tfor _, dir := range strings.Split(pathenv, \":\", -1) {\n@@ -41,5 +41,5 @@ func LookPath(file string) (string, os.Error) {\n \t\t\treturn dir + \"/\" + file, nil\n \t\t}\n \t}\n-\treturn \"\", &os.PathError{\"lookpath\", file, os.ENOENT}\n+\treturn \"\", &PathError{file}\n }"}, {"sha": "d357575fdbe884b66e486ec1b278e1285fe58cc0", "filename": "libgo/go/exec/lp_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexec%2Flp_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Flp_windows.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -49,7 +49,7 @@ func LookPath(file string) (string, os.Error) {\n \t\tif f, ok := canExec(file, exts); ok {\n \t\t\treturn f, nil\n \t\t}\n-\t\treturn ``, &os.PathError{\"lookpath\", file, os.ENOENT}\n+\t\treturn ``, &PathError{file}\n \t}\n \tif pathenv := os.Getenv(`PATH`); pathenv == `` {\n \t\tif f, ok := canExec(`.\\`+file, exts); ok {\n@@ -62,5 +62,5 @@ func LookPath(file string) (string, os.Error) {\n \t\t\t}\n \t\t}\n \t}\n-\treturn ``, &os.PathError{\"lookpath\", file, os.ENOENT}\n+\treturn ``, &PathError{file}\n }"}, {"sha": "e28fb217065dfcf470c1a7ecc5198f0cb7917835", "filename": "libgo/go/exp/draw/x11/conn.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fconn.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -122,10 +122,13 @@ func (c *conn) writeSocket() {\n func (c *conn) Screen() draw.Image { return c.img }\n \n func (c *conn) FlushImage() {\n-\t// We do the send (the <- operator) in an expression context, rather than in\n-\t// a statement context, so that it does not block, and fails if the buffered\n-\t// channel is full (in which case there already is a flush request pending).\n-\t_ = c.flush <- false\n+\tselect {\n+\tcase c.flush <- false:\n+\t\t// Flush notification sent.\n+\tdefault:\n+\t\t// Could not send.\n+\t\t// Flush notification must be pending already.\n+\t}\n }\n \n func (c *conn) Close() os.Error {"}, {"sha": "5c5d4338a1d87598b08ceaa2da5891f4531052d0", "filename": "libgo/go/exp/eval/stmt.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -908,7 +908,7 @@ func (a *stmtCompiler) compileBranchStmt(s *ast.BranchStmt) {\n \t\treturn\n \n \tdefault:\n-\t\tlog.Panic(\"Unexpected branch token %v\", s.Tok)\n+\t\tlog.Panicf(\"Unexpected branch token %v\", s.Tok)\n \t}\n \n \ta.flow.put1(false, pc)"}, {"sha": "4a883ef5ee79b2460f8bee76f5a613cb6b4db055", "filename": "libgo/go/exp/eval/stmt_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -217,7 +217,7 @@ var stmtTests = []test{\n \tVal2(\"if false { i = 2 } else { i = 3 }; i2 = 4\", \"i\", 3, \"i2\", 4),\n \tVal2(\"if i == i2 { i = 2 } else { i = 3 }; i2 = 4\", \"i\", 3, \"i2\", 4),\n \t// Omit optional parts\n-\tVal2(\"if { i = 2 } else { i = 3 }; i2 = 4\", \"i\", 2, \"i2\", 4),\n+\tVal2(\"if true { i = 2 } else { i = 3 }; i2 = 4\", \"i\", 2, \"i2\", 4),\n \tVal2(\"if true { i = 2 }; i2 = 4\", \"i\", 2, \"i2\", 4),\n \tVal2(\"if false { i = 2 }; i2 = 4\", \"i\", 1, \"i2\", 4),\n \t// Init\n@@ -243,11 +243,11 @@ var stmtTests = []test{\n \tCErr(\"fn1 := func() int { if true { return 1 } }\", \"return\"),\n \tCErr(\"fn1 := func() int { if true { } }\", \"return\"),\n \tRun(\"fn1 := func() int { if true { }; return 1 }\"),\n-\tCErr(\"fn1 := func() int { if { } }\", \"return\"),\n-\tCErr(\"fn1 := func() int { if { } else { return 2 } }\", \"return\"),\n-\tRun(\"fn1 := func() int { if { return 1 } }\"),\n-\tRun(\"fn1 := func() int { if { return 1 } else { } }\"),\n-\tRun(\"fn1 := func() int { if { return 1 } else { } }\"),\n+\tCErr(\"fn1 := func() int { if true { } }\", \"return\"),\n+\tCErr(\"fn1 := func() int { if true { } else { return 2 } }\", \"return\"),\n+\tRun(\"fn1 := func() int { if true { return 1 }; return 0 }\"),\n+\tRun(\"fn1 := func() int { if true { return 1 } else { }; return 0 }\"),\n+\tRun(\"fn1 := func() int { if true { return 1 } else { }; return 0 }\"),\n \n \t// Switch\n \tVal1(\"switch { case false: i += 2; case true: i += 4; default: i += 8 }\", \"i\", 1+4),"}, {"sha": "cf392934c5bb654d8f895767f7b86d91c4e46906", "filename": "libgo/go/exp/wingui/gui.go", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fgui.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"syscall\"\n+\t\"os\"\n+\t\"unsafe\"\n+)\n+\n+// some help functions\n+\n+func abortf(format string, a ...interface{}) {\n+\tfmt.Fprintf(os.Stdout, format, a...)\n+\tos.Exit(1)\n+}\n+\n+func abortErrNo(funcname string, err int) {\n+\tabortf(\"%s failed: %d %s\\n\", funcname, err, syscall.Errstr(err))\n+}\n+\n+// global vars\n+\n+var (\n+\tmh uint32\n+\tbh uint32\n+)\n+\n+// WinProc called by windows to notify us of all windows events we might be interested in.\n+func WndProc(hwnd, msg uint32, wparam, lparam int32) uintptr {\n+\tvar rc int32\n+\tswitch msg {\n+\tcase WM_CREATE:\n+\t\tvar e int\n+\t\t// CreateWindowEx\n+\t\tbh, e = CreateWindowEx(\n+\t\t\t0,\n+\t\t\tsyscall.StringToUTF16Ptr(\"button\"),\n+\t\t\tsyscall.StringToUTF16Ptr(\"Quit\"),\n+\t\t\tWS_CHILD|WS_VISIBLE|BS_DEFPUSHBUTTON,\n+\t\t\t75, 70, 140, 25,\n+\t\t\thwnd, 1, mh, 0)\n+\t\tif e != 0 {\n+\t\t\tabortErrNo(\"CreateWindowEx\", e)\n+\t\t}\n+\t\tfmt.Printf(\"button handle is %x\\n\", bh)\n+\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n+\tcase WM_COMMAND:\n+\t\tswitch uint32(lparam) {\n+\t\tcase bh:\n+\t\t\te := PostMessage(hwnd, WM_CLOSE, 0, 0)\n+\t\t\tif e != 0 {\n+\t\t\t\tabortErrNo(\"PostMessage\", e)\n+\t\t\t}\n+\t\tdefault:\n+\t\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n+\t\t}\n+\tcase WM_CLOSE:\n+\t\tDestroyWindow(hwnd)\n+\tcase WM_DESTROY:\n+\t\tPostQuitMessage(0)\n+\tdefault:\n+\t\trc = DefWindowProc(hwnd, msg, wparam, lparam)\n+\t}\n+\t//fmt.Printf(\"WndProc(0x%08x, %d, 0x%08x, 0x%08x) (%d)\\n\", hwnd, msg, wparam, lparam, rc)\n+\treturn uintptr(rc)\n+}\n+\n+func rungui() int {\n+\tvar e int\n+\n+\t// GetModuleHandle\n+\tmh, e = GetModuleHandle(nil)\n+\tif e != 0 {\n+\t\tabortErrNo(\"GetModuleHandle\", e)\n+\t}\n+\n+\t// Get icon we're going to use.\n+\tmyicon, e := LoadIcon(0, IDI_APPLICATION)\n+\tif e != 0 {\n+\t\tabortErrNo(\"LoadIcon\", e)\n+\t}\n+\n+\t// Get cursor we're going to use.\n+\tmycursor, e := LoadCursor(0, IDC_ARROW)\n+\tif e != 0 {\n+\t\tabortErrNo(\"LoadCursor\", e)\n+\t}\n+\n+\t// Create callback\n+\twproc := syscall.NewCallback(WndProc)\n+\n+\t// RegisterClassEx\n+\twcname := syscall.StringToUTF16Ptr(\"myWindowClass\")\n+\tvar wc Wndclassex\n+\twc.Size = uint32(unsafe.Sizeof(wc))\n+\twc.WndProc = wproc\n+\twc.Instance = mh\n+\twc.Icon = myicon\n+\twc.Cursor = mycursor\n+\twc.Background = COLOR_BTNFACE + 1\n+\twc.MenuName = nil\n+\twc.ClassName = wcname\n+\twc.IconSm = myicon\n+\tif _, e := RegisterClassEx(&wc); e != 0 {\n+\t\tabortErrNo(\"RegisterClassEx\", e)\n+\t}\n+\n+\t// CreateWindowEx\n+\twh, e := CreateWindowEx(\n+\t\tWS_EX_CLIENTEDGE,\n+\t\twcname,\n+\t\tsyscall.StringToUTF16Ptr(\"My window\"),\n+\t\tWS_OVERLAPPEDWINDOW,\n+\t\tCW_USEDEFAULT, CW_USEDEFAULT, 300, 200,\n+\t\t0, 0, mh, 0)\n+\tif e != 0 {\n+\t\tabortErrNo(\"CreateWindowEx\", e)\n+\t}\n+\tfmt.Printf(\"main window handle is %x\\n\", wh)\n+\n+\t// ShowWindow\n+\tShowWindow(wh, SW_SHOWDEFAULT)\n+\n+\t// UpdateWindow\n+\tif e := UpdateWindow(wh); e != 0 {\n+\t\tabortErrNo(\"UpdateWindow\", e)\n+\t}\n+\n+\t// Process all windows messages until WM_QUIT.\n+\tvar m Msg\n+\tfor {\n+\t\tr, e := GetMessage(&m, 0, 0, 0)\n+\t\tif e != 0 {\n+\t\t\tabortErrNo(\"GetMessage\", e)\n+\t\t}\n+\t\tif r == 0 {\n+\t\t\t// WM_QUIT received -> get out\n+\t\t\tbreak\n+\t\t}\n+\t\tTranslateMessage(&m)\n+\t\tDispatchMessage(&m)\n+\t}\n+\treturn int(m.Wparam)\n+}\n+\n+func main() {\n+\trc := rungui()\n+\tos.Exit(rc)\n+}"}, {"sha": "c96f452999f8c362e7692084ea7125e77828824c", "filename": "libgo/go/exp/wingui/winapi.go", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fwinapi.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+func loadDll(fname string) uint32 {\n+\th, e := syscall.LoadLibrary(fname)\n+\tif e != 0 {\n+\t\tabortf(\"LoadLibrary(%s) failed with err=%d.\\n\", fname, e)\n+\t}\n+\treturn h\n+}\n+\n+func getSysProcAddr(m uint32, pname string) uintptr {\n+\tp, e := syscall.GetProcAddress(m, pname)\n+\tif e != 0 {\n+\t\tabortf(\"GetProcAddress(%s) failed with err=%d.\\n\", pname, e)\n+\t}\n+\treturn uintptr(p)\n+}\n+\n+type Wndclassex struct {\n+\tSize       uint32\n+\tStyle      uint32\n+\tWndProc    uintptr\n+\tClsExtra   int32\n+\tWndExtra   int32\n+\tInstance   uint32\n+\tIcon       uint32\n+\tCursor     uint32\n+\tBackground uint32\n+\tMenuName   *uint16\n+\tClassName  *uint16\n+\tIconSm     uint32\n+}\n+\n+type Point struct {\n+\tX int32\n+\tY int32\n+}\n+\n+type Msg struct {\n+\tHwnd    uint32\n+\tMessage uint32\n+\tWparam  int32\n+\tLparam  int32\n+\tTime    uint32\n+\tPt      Point\n+}\n+\n+const (\n+\t// Window styles\n+\tWS_OVERLAPPED   = 0\n+\tWS_POPUP        = 0x80000000\n+\tWS_CHILD        = 0x40000000\n+\tWS_MINIMIZE     = 0x20000000\n+\tWS_VISIBLE      = 0x10000000\n+\tWS_DISABLED     = 0x8000000\n+\tWS_CLIPSIBLINGS = 0x4000000\n+\tWS_CLIPCHILDREN = 0x2000000\n+\tWS_MAXIMIZE     = 0x1000000\n+\tWS_CAPTION      = WS_BORDER | WS_DLGFRAME\n+\tWS_BORDER       = 0x800000\n+\tWS_DLGFRAME     = 0x400000\n+\tWS_VSCROLL      = 0x200000\n+\tWS_HSCROLL      = 0x100000\n+\tWS_SYSMENU      = 0x80000\n+\tWS_THICKFRAME   = 0x40000\n+\tWS_GROUP        = 0x20000\n+\tWS_TABSTOP      = 0x10000\n+\tWS_MINIMIZEBOX  = 0x20000\n+\tWS_MAXIMIZEBOX  = 0x10000\n+\tWS_TILED        = WS_OVERLAPPED\n+\tWS_ICONIC       = WS_MINIMIZE\n+\tWS_SIZEBOX      = WS_THICKFRAME\n+\t// Common Window Styles\n+\tWS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX\n+\tWS_TILEDWINDOW      = WS_OVERLAPPEDWINDOW\n+\tWS_POPUPWINDOW      = WS_POPUP | WS_BORDER | WS_SYSMENU\n+\tWS_CHILDWINDOW      = WS_CHILD\n+\n+\tWS_EX_CLIENTEDGE = 0x200\n+\n+\t// Some windows messages\n+\tWM_CREATE  = 1\n+\tWM_DESTROY = 2\n+\tWM_CLOSE   = 16\n+\tWM_COMMAND = 273\n+\n+\t// Some button control styles\n+\tBS_DEFPUSHBUTTON = 1\n+\n+\t// Some colour constants\n+\tCOLOR_WINDOW  = 5\n+\tCOLOR_BTNFACE = 15\n+\n+\t// Default window position\n+\tCW_USEDEFAULT = 0x80000000 - 0x100000000\n+\n+\t// Show window default style\n+\tSW_SHOWDEFAULT = 10\n+)\n+\n+var (\n+\t// Some globaly known cusrors\n+\tIDC_ARROW = MakeIntResource(32512)\n+\tIDC_IBEAM = MakeIntResource(32513)\n+\tIDC_WAIT  = MakeIntResource(32514)\n+\tIDC_CROSS = MakeIntResource(32515)\n+\n+\t// Some globaly known icons\n+\tIDI_APPLICATION = MakeIntResource(32512)\n+\tIDI_HAND        = MakeIntResource(32513)\n+\tIDI_QUESTION    = MakeIntResource(32514)\n+\tIDI_EXCLAMATION = MakeIntResource(32515)\n+\tIDI_ASTERISK    = MakeIntResource(32516)\n+\tIDI_WINLOGO     = MakeIntResource(32517)\n+\tIDI_WARNING     = IDI_EXCLAMATION\n+\tIDI_ERROR       = IDI_HAND\n+\tIDI_INFORMATION = IDI_ASTERISK\n+)\n+\n+//sys\tGetModuleHandle(modname *uint16) (handle uint32, errno int) = GetModuleHandleW\n+//sys\tRegisterClassEx(wndclass *Wndclassex) (atom uint16, errno int) = user32.RegisterClassExW\n+//sys\tCreateWindowEx(exstyle uint32, classname *uint16, windowname *uint16, style uint32, x int32, y int32, width int32, height int32, wndparent uint32, menu uint32, instance uint32, param uintptr) (hwnd uint32, errno int) = user32.CreateWindowExW\n+//sys\tDefWindowProc(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) = user32.DefWindowProcW\n+//sys\tDestroyWindow(hwnd uint32) (errno int) = user32.DestroyWindow\n+//sys\tPostQuitMessage(exitcode int32) = user32.PostQuitMessage\n+//sys\tShowWindow(hwnd uint32, cmdshow int32) (wasvisible bool) = user32.ShowWindow\n+//sys\tUpdateWindow(hwnd uint32) (errno int) = user32.UpdateWindow\n+//sys\tGetMessage(msg *Msg, hwnd uint32, MsgFilterMin uint32, MsgFilterMax uint32) (ret int32, errno int) [failretval==-1] = user32.GetMessageW\n+//sys\tTranslateMessage(msg *Msg) (done bool) = user32.TranslateMessage\n+//sys\tDispatchMessage(msg *Msg) (ret int32) = user32.DispatchMessageW\n+//sys\tLoadIcon(instance uint32, iconname *uint16) (icon uint32, errno int) = user32.LoadIconW\n+//sys\tLoadCursor(instance uint32, cursorname *uint16) (cursor uint32, errno int) = user32.LoadCursorW\n+//sys\tSetCursor(cursor uint32) (precursor uint32, errno int) = user32.SetCursor\n+//sys\tSendMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) = user32.SendMessageW\n+//sys\tPostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (errno int) = user32.PostMessageW\n+\n+func MakeIntResource(id uint16) *uint16 {\n+\treturn (*uint16)(unsafe.Pointer(uintptr(id)))\n+}"}, {"sha": "60aaac6cf16f97d8394a7f38caf47710c81783a3", "filename": "libgo/go/exp/wingui/zwinapi.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwingui%2Fzwinapi.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,211 @@\n+// mksyscall_windows.sh winapi.go\n+// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n+\n+package main\n+\n+import \"unsafe\"\n+import \"syscall\"\n+\n+var (\n+\tmodkernel32 = loadDll(\"kernel32.dll\")\n+\tmoduser32   = loadDll(\"user32.dll\")\n+\n+\tprocGetModuleHandleW = getSysProcAddr(modkernel32, \"GetModuleHandleW\")\n+\tprocRegisterClassExW = getSysProcAddr(moduser32, \"RegisterClassExW\")\n+\tprocCreateWindowExW  = getSysProcAddr(moduser32, \"CreateWindowExW\")\n+\tprocDefWindowProcW   = getSysProcAddr(moduser32, \"DefWindowProcW\")\n+\tprocDestroyWindow    = getSysProcAddr(moduser32, \"DestroyWindow\")\n+\tprocPostQuitMessage  = getSysProcAddr(moduser32, \"PostQuitMessage\")\n+\tprocShowWindow       = getSysProcAddr(moduser32, \"ShowWindow\")\n+\tprocUpdateWindow     = getSysProcAddr(moduser32, \"UpdateWindow\")\n+\tprocGetMessageW      = getSysProcAddr(moduser32, \"GetMessageW\")\n+\tprocTranslateMessage = getSysProcAddr(moduser32, \"TranslateMessage\")\n+\tprocDispatchMessageW = getSysProcAddr(moduser32, \"DispatchMessageW\")\n+\tprocLoadIconW        = getSysProcAddr(moduser32, \"LoadIconW\")\n+\tprocLoadCursorW      = getSysProcAddr(moduser32, \"LoadCursorW\")\n+\tprocSetCursor        = getSysProcAddr(moduser32, \"SetCursor\")\n+\tprocSendMessageW     = getSysProcAddr(moduser32, \"SendMessageW\")\n+\tprocPostMessageW     = getSysProcAddr(moduser32, \"PostMessageW\")\n+)\n+\n+func GetModuleHandle(modname *uint16) (handle uint32, errno int) {\n+\tr0, _, e1 := syscall.Syscall(procGetModuleHandleW, 1, uintptr(unsafe.Pointer(modname)), 0, 0)\n+\thandle = uint32(r0)\n+\tif handle == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func RegisterClassEx(wndclass *Wndclassex) (atom uint16, errno int) {\n+\tr0, _, e1 := syscall.Syscall(procRegisterClassExW, 1, uintptr(unsafe.Pointer(wndclass)), 0, 0)\n+\tatom = uint16(r0)\n+\tif atom == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func CreateWindowEx(exstyle uint32, classname *uint16, windowname *uint16, style uint32, x int32, y int32, width int32, height int32, wndparent uint32, menu uint32, instance uint32, param uintptr) (hwnd uint32, errno int) {\n+\tr0, _, e1 := syscall.Syscall12(procCreateWindowExW, 12, uintptr(exstyle), uintptr(unsafe.Pointer(classname)), uintptr(unsafe.Pointer(windowname)), uintptr(style), uintptr(x), uintptr(y), uintptr(width), uintptr(height), uintptr(wndparent), uintptr(menu), uintptr(instance), uintptr(param))\n+\thwnd = uint32(r0)\n+\tif hwnd == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func DefWindowProc(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) {\n+\tr0, _, _ := syscall.Syscall6(procDefWindowProcW, 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n+\tlresult = int32(r0)\n+\treturn\n+}\n+\n+func DestroyWindow(hwnd uint32) (errno int) {\n+\tr1, _, e1 := syscall.Syscall(procDestroyWindow, 1, uintptr(hwnd), 0, 0)\n+\tif int(r1) == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func PostQuitMessage(exitcode int32) {\n+\tsyscall.Syscall(procPostQuitMessage, 1, uintptr(exitcode), 0, 0)\n+\treturn\n+}\n+\n+func ShowWindow(hwnd uint32, cmdshow int32) (wasvisible bool) {\n+\tr0, _, _ := syscall.Syscall(procShowWindow, 2, uintptr(hwnd), uintptr(cmdshow), 0)\n+\twasvisible = bool(r0 != 0)\n+\treturn\n+}\n+\n+func UpdateWindow(hwnd uint32) (errno int) {\n+\tr1, _, e1 := syscall.Syscall(procUpdateWindow, 1, uintptr(hwnd), 0, 0)\n+\tif int(r1) == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func GetMessage(msg *Msg, hwnd uint32, MsgFilterMin uint32, MsgFilterMax uint32) (ret int32, errno int) {\n+\tr0, _, e1 := syscall.Syscall6(procGetMessageW, 4, uintptr(unsafe.Pointer(msg)), uintptr(hwnd), uintptr(MsgFilterMin), uintptr(MsgFilterMax), 0, 0)\n+\tret = int32(r0)\n+\tif ret == -1 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func TranslateMessage(msg *Msg) (done bool) {\n+\tr0, _, _ := syscall.Syscall(procTranslateMessage, 1, uintptr(unsafe.Pointer(msg)), 0, 0)\n+\tdone = bool(r0 != 0)\n+\treturn\n+}\n+\n+func DispatchMessage(msg *Msg) (ret int32) {\n+\tr0, _, _ := syscall.Syscall(procDispatchMessageW, 1, uintptr(unsafe.Pointer(msg)), 0, 0)\n+\tret = int32(r0)\n+\treturn\n+}\n+\n+func LoadIcon(instance uint32, iconname *uint16) (icon uint32, errno int) {\n+\tr0, _, e1 := syscall.Syscall(procLoadIconW, 2, uintptr(instance), uintptr(unsafe.Pointer(iconname)), 0)\n+\ticon = uint32(r0)\n+\tif icon == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func LoadCursor(instance uint32, cursorname *uint16) (cursor uint32, errno int) {\n+\tr0, _, e1 := syscall.Syscall(procLoadCursorW, 2, uintptr(instance), uintptr(unsafe.Pointer(cursorname)), 0)\n+\tcursor = uint32(r0)\n+\tif cursor == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func SetCursor(cursor uint32) (precursor uint32, errno int) {\n+\tr0, _, e1 := syscall.Syscall(procSetCursor, 1, uintptr(cursor), 0, 0)\n+\tprecursor = uint32(r0)\n+\tif precursor == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}\n+\n+func SendMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (lresult int32) {\n+\tr0, _, _ := syscall.Syscall6(procSendMessageW, 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n+\tlresult = int32(r0)\n+\treturn\n+}\n+\n+func PostMessage(hwnd uint32, msg uint32, wparam int32, lparam int32) (errno int) {\n+\tr1, _, e1 := syscall.Syscall6(procPostMessageW, 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)\n+\tif int(r1) == 0 {\n+\t\tif e1 != 0 {\n+\t\t\terrno = int(e1)\n+\t\t} else {\n+\t\t\terrno = syscall.EINVAL\n+\t\t}\n+\t} else {\n+\t\terrno = 0\n+\t}\n+\treturn\n+}"}, {"sha": "be972057ed74c08720e1bc6dd727fcd613223d58", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -96,7 +96,7 @@ func newIntValue(val int, p *int) *intValue {\n }\n \n func (i *intValue) Set(s string) bool {\n-\tv, err := strconv.Atoi(s)\n+\tv, err := strconv.Btoi64(s, 0)\n \t*i = intValue(v)\n \treturn err == nil\n }\n@@ -112,7 +112,7 @@ func newInt64Value(val int64, p *int64) *int64Value {\n }\n \n func (i *int64Value) Set(s string) bool {\n-\tv, err := strconv.Atoi64(s)\n+\tv, err := strconv.Btoi64(s, 0)\n \t*i = int64Value(v)\n \treturn err == nil\n }\n@@ -128,7 +128,7 @@ func newUintValue(val uint, p *uint) *uintValue {\n }\n \n func (i *uintValue) Set(s string) bool {\n-\tv, err := strconv.Atoui(s)\n+\tv, err := strconv.Btoui64(s, 0)\n \t*i = uintValue(v)\n \treturn err == nil\n }\n@@ -144,7 +144,7 @@ func newUint64Value(val uint64, p *uint64) *uint64Value {\n }\n \n func (i *uint64Value) Set(s string) bool {\n-\tv, err := strconv.Atoui64(s)\n+\tv, err := strconv.Btoui64(s, 0)\n \t*i = uint64Value(v)\n \treturn err == nil\n }"}, {"sha": "30a21e61ae2d46d91be9f5e887c0d633edd46505", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -106,7 +106,7 @@ func TestParse(t *testing.T) {\n \t\t\"-bool\",\n \t\t\"-bool2=true\",\n \t\t\"--int\", \"22\",\n-\t\t\"--int64\", \"23\",\n+\t\t\"--int64\", \"0x23\",\n \t\t\"-uint\", \"24\",\n \t\t\"--uint64\", \"25\",\n \t\t\"-string\", \"hello\",\n@@ -125,8 +125,8 @@ func TestParse(t *testing.T) {\n \tif *intFlag != 22 {\n \t\tt.Error(\"int flag should be 22, is \", *intFlag)\n \t}\n-\tif *int64Flag != 23 {\n-\t\tt.Error(\"int64 flag should be 23, is \", *int64Flag)\n+\tif *int64Flag != 0x23 {\n+\t\tt.Error(\"int64 flag should be 0x23, is \", *int64Flag)\n \t}\n \tif *uintFlag != 24 {\n \t\tt.Error(\"uint flag should be 24, is \", *uintFlag)"}, {"sha": "77ee62bb1dda69b6d2b8c6df1efe08daad595476", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -16,6 +16,7 @@\n \t\t\twhen printing structs, the plus flag (%+v) adds field names\n \t\t%#v\ta Go-syntax representation of the value\n \t\t%T\ta Go-syntax representation of the type of the value\n+\t\t%%\ta literal percent sign; consumes no value\n \n \tBoolean:\n \t\t%t\tthe word true or false\n@@ -26,8 +27,10 @@\n \t\t%o\tbase 8\n \t\t%x\tbase 16, with lower-case letters for a-f\n \t\t%X\tbase 16, with upper-case letters for A-F\n-\t\t%U\tunicode format: U+1234; same as \"U+%x\" with 4 digits default\n+\t\t%U\tUnicode format: U+1234; same as \"U+%x\" with 4 digits default\n \tFloating-point and complex constituents:\n+\t\t%b\tdecimalless scientific notation with exponent a power\n+\t\t\tof two, in the manner of strconv.Ftoa32, e.g. -123456p-78\n \t\t%e\tscientific notation, e.g. -1234.456e+78\n \t\t%E\tscientific notation, e.g. -1234.456E+78\n \t\t%f\tdecimal point but no exponent, e.g. 123.456\n@@ -44,14 +47,19 @@\n \tThere is no 'u' flag.  Integers are printed unsigned if they have unsigned type.\n \tSimilarly, there is no need to specify the size of the operand (int8, int64).\n \n-\tFor numeric values, the width and precision flags control\n-\tformatting; width sets the width of the field, precision the\n-\tnumber of places after the decimal, if appropriate.  The\n-\tformat %6.2f prints 123.45. The width of a field is the number\n-\tof Unicode code points in the string. This differs from C's printf where\n-\tthe field width is the number of bytes.  Either or both of the\n-\tflags may be replaced with the character '*', causing their values\n-\tto be obtained from the next operand, which must be of type int.\n+\tThe width and precision control formatting and are in units of Unicode\n+\tcode points.  (This differs from C's printf where the units are numbers\n+\tof bytes.) Either or both of the flags may be replaced with the\n+\tcharacter '*', causing their values to be obtained from the next\n+\toperand, which must be of type int.\n+\n+\tFor numeric values, width sets the width of the field and precision\n+\tsets the number of places after the decimal, if appropriate.  For\n+\texample, the format %6.2f prints 123.45.\n+\n+\tFor strings, width is the minimum number of characters to output,\n+\tpadding with spaces if necessary, and precision is the maximum\n+\tnumber of characters to output, truncating if necessary.\n \n \tOther flags:\n \t\t+\talways print a sign for numeric values\n@@ -112,7 +120,7 @@\n \tAn analogous set of functions scans formatted text to yield\n \tvalues.  Scan, Scanf and Scanln read from os.Stdin; Fscan,\n \tFscanf and Fscanln read from a specified os.Reader; Sscan,\n-\tSscanf and Sscanln read from an argument string.  Sscanln,\n+\tSscanf and Sscanln read from an argument string.  Scanln,\n \tFscanln and Sscanln stop scanning at a newline and require that\n \tthe items be followed by one; Sscanf, Fscanf and Sscanf require\n \tnewlines in the input to match newlines in the format; the other\n@@ -131,6 +139,10 @@\n \t%e %E %f %F %g %g are all equivalent and scan any floating point or complex value\n \t%s and %v on strings scan a space-delimited token\n \n+\tThe familiar base-setting prefixes 0 (octal) and 0x\n+\t(hexadecimal) are accepted when scanning integers without a\n+\tformat or with the %v verb.\n+\n \tWidth is interpreted in the input text (%5s means at most\n \tfive runes of input will be read to scan a string) but there\n \tis no syntax for scanning with a precision (no %5.2f, just\n@@ -152,13 +164,15 @@\n \tAll arguments to be scanned must be either pointers to basic\n \ttypes or implementations of the Scanner interface.\n \n-\tNote: Fscan etc. can read one character (rune) past the\n-\tinput they return, which means that a loop calling a scan\n-\troutine may skip some of the input.  This is usually a\n-\tproblem only when there is no space between input values.\n-\tHowever, if the reader provided to Fscan implements UnreadRune,\n+\tNote: Fscan etc. can read one character (rune) past the input\n+\tthey return, which means that a loop calling a scan routine\n+\tmay skip some of the input.  This is usually a problem only\n+\twhen there is no space between input values.  If the reader\n+\tprovided to Fscan implements ReadRune, that method will be used\n+\tto read characters.  If the reader also implements UnreadRune,\n \tthat method will be used to save the character and successive\n-\tcalls will not lose data.  To attach an UnreadRune method\n-\tto a reader without that capability, use bufio.NewReader.\n+\tcalls will not lose data.  To attach ReadRune and UnreadRune\n+\tmethods to a reader without that capability, use\n+\tbufio.NewReader.\n */\n package fmt"}, {"sha": "c8aa6090bbf7f489deeee87dddb44fb00157541b", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -311,9 +311,9 @@ var fmttests = []struct {\n \n \t// go syntax\n \t{\"%#v\", A{1, 2, \"a\", []int{1, 2}}, `fmt_test.A{i:1, j:0x2, s:\"a\", x:[]int{1, 2}}`},\n-\t{\"%#v\", &b, \"(*uint8)(PTR)\"},\n-\t{\"%#v\", TestFmtInterface, \"(func(*testing.T))(PTR)\"},\n-\t{\"%#v\", make(chan int), \"(chan int)(PTR)\"},\n+\t{\"%#v\", &b, \"(*uint8)(0xPTR)\"},\n+\t{\"%#v\", TestFmtInterface, \"(func(*testing.T))(0xPTR)\"},\n+\t{\"%#v\", make(chan int), \"(chan int)(0xPTR)\"},\n \t{\"%#v\", uint64(1<<64 - 1), \"0xffffffffffffffff\"},\n \t{\"%#v\", 1000000000, \"1000000000\"},\n \t{\"%#v\", map[string]int{\"a\": 1, \"b\": 2}, `map[string] int{\"a\":1, \"b\":2}`},\n@@ -365,14 +365,15 @@ var fmttests = []struct {\n \t{\"%6T\", &intVal, \"  *int\"},\n \n \t// %p\n-\t{\"p0=%p\", new(int), \"p0=PTR\"},\n+\t{\"p0=%p\", new(int), \"p0=0xPTR\"},\n \t{\"p1=%s\", &pValue, \"p1=String(p)\"}, // String method...\n-\t{\"p2=%p\", &pValue, \"p2=PTR\"},       // ... not called with %p\n+\t{\"p2=%p\", &pValue, \"p2=0xPTR\"},     // ... not called with %p\n+\t{\"p4=%#p\", new(int), \"p4=PTR\"},\n \n \t// %p on non-pointers\n-\t{\"%p\", make(chan int), \"PTR\"},\n-\t{\"%p\", make(map[int]int), \"PTR\"},\n-\t{\"%p\", make([]int, 1), \"PTR\"},\n+\t{\"%p\", make(chan int), \"0xPTR\"},\n+\t{\"%p\", make(map[int]int), \"0xPTR\"},\n+\t{\"%p\", make([]int, 1), \"0xPTR\"},\n \t{\"%p\", 27, \"%!p(int=27)\"}, // not a pointer at all\n \n \t// erroneous things\n@@ -388,8 +389,8 @@ var fmttests = []struct {\n func TestSprintf(t *testing.T) {\n \tfor _, tt := range fmttests {\n \t\ts := Sprintf(tt.fmt, tt.val)\n-\t\tif i := strings.Index(s, \"0x\"); i >= 0 && strings.Contains(tt.out, \"PTR\") {\n-\t\t\tj := i + 2\n+\t\tif i := strings.Index(tt.out, \"PTR\"); i >= 0 {\n+\t\t\tj := i\n \t\t\tfor ; j < len(s); j++ {\n \t\t\t\tc := s[j]\n \t\t\t\tif (c < '0' || c > '9') && (c < 'a' || c > 'f') && (c < 'A' || c > 'F') {"}, {"sha": "4e14fdaa4a7436f0672110df1889a9ca5dac9119", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -74,15 +74,42 @@ type pp struct {\n \tfmt     fmt\n }\n \n-// A leaky bucket of reusable pp structures.\n-var ppFree = make(chan *pp, 100)\n+// A cache holds a set of reusable objects.\n+// The buffered channel holds the currently available objects.\n+// If more are needed, the cache creates them by calling new.\n+type cache struct {\n+\tsaved chan interface{}\n+\tnew   func() interface{}\n+}\n+\n+func (c *cache) put(x interface{}) {\n+\tselect {\n+\tcase c.saved <- x:\n+\t\t// saved in cache\n+\tdefault:\n+\t\t// discard\n+\t}\n+}\n \n-// Allocate a new pp struct.  Probably can grab the previous one from ppFree.\n-func newPrinter() *pp {\n-\tp, ok := <-ppFree\n-\tif !ok {\n-\t\tp = new(pp)\n+func (c *cache) get() interface{} {\n+\tselect {\n+\tcase x := <-c.saved:\n+\t\treturn x // reused from cache\n+\tdefault:\n+\t\treturn c.new()\n \t}\n+\tpanic(\"not reached\")\n+}\n+\n+func newCache(f func() interface{}) *cache {\n+\treturn &cache{make(chan interface{}, 100), f}\n+}\n+\n+var ppFree = newCache(func() interface{} { return new(pp) })\n+\n+// Allocate a new pp struct or grab a cached one.\n+func newPrinter() *pp {\n+\tp := ppFree.get().(*pp)\n \tp.fmt.init(&p.buf)\n \treturn p\n }\n@@ -94,7 +121,7 @@ func (p *pp) free() {\n \t\treturn\n \t}\n \tp.buf.Reset()\n-\t_ = ppFree <- p\n+\tppFree.put(p)\n }\n \n func (p *pp) Width() (wid int, ok bool) { return p.fmt.wid, p.fmt.widPresent }\n@@ -321,11 +348,11 @@ func (p *pp) fmtInt64(v int64, verb int, value interface{}) {\n \t}\n }\n \n-// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x by\n-// temporarily turning on the sharp flag.\n-func (p *pp) fmt0x64(v uint64) {\n+// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or\n+// not, as requested, by temporarily setting the sharp flag.\n+func (p *pp) fmt0x64(v uint64, leading0x bool) {\n \tsharp := p.fmt.sharp\n-\tp.fmt.sharp = true // turn on 0x\n+\tp.fmt.sharp = leading0x\n \tp.fmt.integer(int64(v), 16, unsigned, ldigits)\n \tp.fmt.sharp = sharp\n }\n@@ -357,7 +384,7 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool, value interface{}) {\n \t\tp.fmt.integer(int64(v), 10, unsigned, ldigits)\n \tcase 'v':\n \t\tif goSyntax {\n-\t\t\tp.fmt0x64(v)\n+\t\t\tp.fmt0x64(v, true)\n \t\t} else {\n \t\t\tp.fmt.integer(int64(v), 10, unsigned, ldigits)\n \t\t}\n@@ -507,11 +534,11 @@ func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSynt\n \t\tif u == 0 {\n \t\t\tp.buf.Write(nilBytes)\n \t\t} else {\n-\t\t\tp.fmt0x64(uint64(v.Get()))\n+\t\t\tp.fmt0x64(uint64(v.Get()), true)\n \t\t}\n \t\tp.add(')')\n \t} else {\n-\t\tp.fmt0x64(uint64(u))\n+\t\tp.fmt0x64(uint64(u), !p.fmt.sharp)\n \t}\n }\n \n@@ -774,7 +801,7 @@ BigSwitch:\n \t\t\tif v == 0 {\n \t\t\t\tp.buf.Write(nilBytes)\n \t\t\t} else {\n-\t\t\t\tp.fmt0x64(uint64(v))\n+\t\t\t\tp.fmt0x64(uint64(v), true)\n \t\t\t}\n \t\t\tp.buf.WriteByte(')')\n \t\t\tbreak\n@@ -783,7 +810,7 @@ BigSwitch:\n \t\t\tp.buf.Write(nilAngleBytes)\n \t\t\tbreak\n \t\t}\n-\t\tp.fmt0x64(uint64(v))\n+\t\tp.fmt0x64(uint64(v), true)\n \tcase uintptrGetter:\n \t\tp.fmtPointer(field, value, verb, goSyntax)\n \tdefault:"}, {"sha": "c0f2bacb69be934e19d14fccfb5507820b229ae0", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 203, "deletions": 121, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,6 +7,7 @@ package fmt\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"math\"\n \t\"os\"\n \t\"reflect\"\n \t\"strconv\"\n@@ -15,42 +16,42 @@ import (\n \t\"utf8\"\n )\n \n-// readRuner is the interface to something that can read runes.  If\n-// the object provided to Scan does not satisfy this interface, the\n-// object will be wrapped by a readRune object.\n-type readRuner interface {\n-\tReadRune() (rune int, size int, err os.Error)\n-}\n-\n-// unreadRuner is the interface to something that can unread runes.\n+// runeUnreader is the interface to something that can unread runes.\n // If the object provided to Scan does not satisfy this interface,\n // a local buffer will be used to back up the input, but its contents\n // will be lost when Scan returns.\n-type unreadRuner interface {\n+type runeUnreader interface {\n \tUnreadRune() os.Error\n }\n \n // ScanState represents the scanner state passed to custom scanners.\n // Scanners may do rune-at-a-time scanning or ask the ScanState\n // to discover the next space-delimited token.\n type ScanState interface {\n-\t// GetRune reads the next rune (Unicode code point) from the input.\n-\tGetRune() (rune int, err os.Error)\n-\t// UngetRune causes the next call to GetRune to return the rune.\n-\tUngetRune()\n-\t// Width returns the value of the width option and whether it has been set.\n-\t// The unit is Unicode code points.\n-\tWidth() (wid int, ok bool)\n+\t// ReadRune reads the next rune (Unicode code point) from the input.\n+\t// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n+\t// return EOF after returning the first '\\n' or when reading beyond\n+\t// the specified width.\n+\tReadRune() (rune int, size int, err os.Error)\n+\t// UnreadRune causes the next call to ReadRune to return the same rune.\n+\tUnreadRune() os.Error\n \t// Token returns the next space-delimited token from the input. If\n \t// a width has been specified, the returned token will be no longer\n \t// than the width.\n \tToken() (token string, err os.Error)\n+\t// Width returns the value of the width option and whether it has been set.\n+\t// The unit is Unicode code points.\n+\tWidth() (wid int, ok bool)\n+\t// Because ReadRune is implemented by the interface, Read should never be\n+\t// called by the scanning routines and a valid implementation of\n+\t// ScanState may choose always to return an error from Read.\n+\tRead(buf []byte) (n int, err os.Error)\n }\n \n // Scanner is implemented by any value that has a Scan method, which scans\n // the input for the representation of a value and stores the result in the\n // receiver, which must be a pointer to be useful.  The Scan method is called\n-// for any argument to Scan or Scanln that implements it.\n+// for any argument to Scan, Scanf, or Scanln that implements it.\n type Scanner interface {\n \tScan(state ScanState, verb int) os.Error\n }\n@@ -102,28 +103,28 @@ func Sscanf(str string, format string, a ...interface{}) (n int, err os.Error) {\n // returns the number of items successfully scanned.  If that is less\n // than the number of arguments, err will report why.\n func Fscan(r io.Reader, a ...interface{}) (n int, err os.Error) {\n-\ts := newScanState(r, true)\n+\ts, old := newScanState(r, true, false)\n \tn, err = s.doScan(a)\n-\ts.free()\n+\ts.free(old)\n \treturn\n }\n \n // Fscanln is similar to Fscan, but stops scanning at a newline and\n // after the final item there must be a newline or EOF.\n func Fscanln(r io.Reader, a ...interface{}) (n int, err os.Error) {\n-\ts := newScanState(r, false)\n+\ts, old := newScanState(r, false, true)\n \tn, err = s.doScan(a)\n-\ts.free()\n+\ts.free(old)\n \treturn\n }\n \n // Fscanf scans text read from r, storing successive space-separated\n // values into successive arguments as determined by the format.  It\n // returns the number of items successfully parsed.\n func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err os.Error) {\n-\ts := newScanState(r, false)\n+\ts, old := newScanState(r, false, false)\n \tn, err = s.doScanf(format, a)\n-\ts.free()\n+\ts.free(old)\n \treturn\n }\n \n@@ -137,89 +138,96 @@ const EOF = -1\n \n // ss is the internal implementation of ScanState.\n type ss struct {\n-\trr         readRuner    // where to read input\n-\tbuf        bytes.Buffer // token accumulator\n-\tnlIsSpace  bool         // whether newline counts as white space\n-\tpeekRune   int          // one-rune lookahead\n-\tprevRune   int          // last rune returned by GetRune\n-\tatEOF      bool         // already read EOF\n-\tmaxWid     int          // max width of field, in runes\n-\twidPresent bool         // width was specified\n-\twid        int          // width consumed so far; used in accept()\n-}\n-\n-func (s *ss) GetRune() (rune int, err os.Error) {\n+\trr       io.RuneReader // where to read input\n+\tbuf      bytes.Buffer  // token accumulator\n+\tpeekRune int           // one-rune lookahead\n+\tprevRune int           // last rune returned by ReadRune\n+\tcount    int           // runes consumed so far.\n+\tatEOF    bool          // already read EOF\n+\tssave\n+}\n+\n+// ssave holds the parts of ss that need to be\n+// saved and restored on recursive scans.\n+type ssave struct {\n+\tvalidSave  bool // is or was a part of an actual ss.\n+\tnlIsEnd    bool // whether newline terminates scan\n+\tnlIsSpace  bool // whether newline counts as white space\n+\tfieldLimit int  // max value of ss.count for this field; fieldLimit <= limit\n+\tlimit      int  // max value of ss.count.\n+\tmaxWid     int  // width of this field.\n+}\n+\n+// The Read method is only in ScanState so that ScanState\n+// satisfies io.Reader. It will never be called when used as\n+// intended, so there is no need to make it actually work.\n+func (s *ss) Read(buf []byte) (n int, err os.Error) {\n+\treturn 0, os.ErrorString(\"ScanState's Read should not be called. Use ReadRune\")\n+}\n+\n+func (s *ss) ReadRune() (rune int, size int, err os.Error) {\n \tif s.peekRune >= 0 {\n+\t\ts.count++\n \t\trune = s.peekRune\n+\t\tsize = utf8.RuneLen(rune)\n \t\ts.prevRune = rune\n \t\ts.peekRune = -1\n \t\treturn\n \t}\n-\trune, _, err = s.rr.ReadRune()\n+\tif s.atEOF || s.nlIsEnd && s.prevRune == '\\n' || s.count >= s.fieldLimit {\n+\t\terr = os.EOF\n+\t\treturn\n+\t}\n+\n+\trune, size, err = s.rr.ReadRune()\n \tif err == nil {\n+\t\ts.count++\n \t\ts.prevRune = rune\n+\t} else if err == os.EOF {\n+\t\ts.atEOF = true\n \t}\n \treturn\n }\n \n func (s *ss) Width() (wid int, ok bool) {\n-\treturn s.maxWid, s.widPresent\n+\tif s.maxWid == hugeWid {\n+\t\treturn 0, false\n+\t}\n+\treturn s.maxWid, true\n }\n \n // The public method returns an error; this private one panics.\n // If getRune reaches EOF, the return value is EOF (-1).\n func (s *ss) getRune() (rune int) {\n-\tif s.atEOF {\n-\t\treturn EOF\n-\t}\n-\tif s.peekRune >= 0 {\n-\t\trune = s.peekRune\n-\t\ts.prevRune = rune\n-\t\ts.peekRune = -1\n-\t\treturn\n-\t}\n-\trune, _, err := s.rr.ReadRune()\n-\tif err == nil {\n-\t\ts.prevRune = rune\n-\t} else if err != nil {\n+\trune, _, err := s.ReadRune()\n+\tif err != nil {\n \t\tif err == os.EOF {\n-\t\t\ts.atEOF = true\n \t\t\treturn EOF\n \t\t}\n \t\ts.error(err)\n \t}\n \treturn\n }\n \n-// mustGetRune turns os.EOF into a panic(io.ErrUnexpectedEOF).\n+// mustReadRune turns os.EOF into a panic(io.ErrUnexpectedEOF).\n // It is called in cases such as string scanning where an EOF is a\n // syntax error.\n-func (s *ss) mustGetRune() (rune int) {\n-\tif s.atEOF {\n+func (s *ss) mustReadRune() (rune int) {\n+\trune = s.getRune()\n+\tif rune == EOF {\n \t\ts.error(io.ErrUnexpectedEOF)\n \t}\n-\tif s.peekRune >= 0 {\n-\t\trune = s.peekRune\n-\t\ts.peekRune = -1\n-\t\treturn\n-\t}\n-\trune, _, err := s.rr.ReadRune()\n-\tif err != nil {\n-\t\tif err == os.EOF {\n-\t\t\terr = io.ErrUnexpectedEOF\n-\t\t}\n-\t\ts.error(err)\n-\t}\n \treturn\n }\n \n-\n-func (s *ss) UngetRune() {\n-\tif u, ok := s.rr.(unreadRuner); ok {\n+func (s *ss) UnreadRune() os.Error {\n+\tif u, ok := s.rr.(runeUnreader); ok {\n \t\tu.UnreadRune()\n \t} else {\n \t\ts.peekRune = s.prevRune\n \t}\n+\ts.count--\n+\treturn nil\n }\n \n func (s *ss) error(err os.Error) {\n@@ -246,7 +254,7 @@ func (s *ss) Token() (tok string, err os.Error) {\n \n // readRune is a structure to enable reading UTF-8 encoded code points\n // from an io.Reader.  It is used if the Reader given to the scanner does\n-// not already implement ReadRuner.\n+// not already implement io.RuneReader.\n type readRune struct {\n \treader  io.Reader\n \tbuf     [utf8.UTFMax]byte // used only inside ReadRune\n@@ -303,37 +311,53 @@ func (r *readRune) ReadRune() (rune int, size int, err os.Error) {\n }\n \n \n-// A leaky bucket of reusable ss structures.\n-var ssFree = make(chan *ss, 100)\n+var ssFree = newCache(func() interface{} { return new(ss) })\n \n-// Allocate a new ss struct.  Probably can grab the previous one from ssFree.\n-func newScanState(r io.Reader, nlIsSpace bool) *ss {\n-\ts, ok := <-ssFree\n-\tif !ok {\n-\t\ts = new(ss)\n+// Allocate a new ss struct or grab a cached one.\n+func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) {\n+\t// If the reader is a *ss, then we've got a recursive\n+\t// call to Scan, so re-use the scan state.\n+\ts, ok := r.(*ss)\n+\tif ok {\n+\t\told = s.ssave\n+\t\ts.limit = s.fieldLimit\n+\t\ts.nlIsEnd = nlIsEnd || s.nlIsEnd\n+\t\ts.nlIsSpace = nlIsSpace\n+\t\treturn\n \t}\n-\tif rr, ok := r.(readRuner); ok {\n+\n+\ts = ssFree.get().(*ss)\n+\tif rr, ok := r.(io.RuneReader); ok {\n \t\ts.rr = rr\n \t} else {\n \t\ts.rr = &readRune{reader: r}\n \t}\n \ts.nlIsSpace = nlIsSpace\n+\ts.nlIsEnd = nlIsEnd\n+\ts.prevRune = -1\n \ts.peekRune = -1\n \ts.atEOF = false\n-\ts.maxWid = 0\n-\ts.widPresent = false\n-\treturn s\n+\ts.limit = hugeWid\n+\ts.fieldLimit = hugeWid\n+\ts.maxWid = hugeWid\n+\ts.validSave = true\n+\treturn\n }\n \n // Save used ss structs in ssFree; avoid an allocation per invocation.\n-func (s *ss) free() {\n+func (s *ss) free(old ssave) {\n+\t// If it was used recursively, just restore the old state.\n+\tif old.validSave {\n+\t\ts.ssave = old\n+\t\treturn\n+\t}\n \t// Don't hold on to ss structs with large buffers.\n \tif cap(s.buf.Bytes()) > 1024 {\n \t\treturn\n \t}\n \ts.buf.Reset()\n \ts.rr = nil\n-\t_ = ssFree <- s\n+\tssFree.put(s)\n }\n \n // skipSpace skips spaces and maybe newlines.\n@@ -354,7 +378,7 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n \t\t\treturn\n \t\t}\n \t\tif !unicode.IsSpace(rune) {\n-\t\t\ts.UngetRune()\n+\t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n \t}\n@@ -366,13 +390,13 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n func (s *ss) token() string {\n \ts.skipSpace(false)\n \t// read until white space or newline\n-\tfor nrunes := 0; !s.widPresent || nrunes < s.maxWid; nrunes++ {\n+\tfor {\n \t\trune := s.getRune()\n \t\tif rune == EOF {\n \t\t\tbreak\n \t\t}\n \t\tif unicode.IsSpace(rune) {\n-\t\t\ts.UngetRune()\n+\t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n \t\ts.buf.WriteRune(rune)\n@@ -391,28 +415,31 @@ var boolError = os.ErrorString(\"syntax error scanning boolean\")\n // consume reads the next rune in the input and reports whether it is in the ok string.\n // If accept is true, it puts the character into the input token.\n func (s *ss) consume(ok string, accept bool) bool {\n-\tif s.wid >= s.maxWid {\n-\t\treturn false\n-\t}\n \trune := s.getRune()\n \tif rune == EOF {\n \t\treturn false\n \t}\n-\tfor i := 0; i < len(ok); i++ {\n-\t\tif int(ok[i]) == rune {\n-\t\t\tif accept {\n-\t\t\t\ts.buf.WriteRune(rune)\n-\t\t\t\ts.wid++\n-\t\t\t}\n-\t\t\treturn true\n+\tif strings.IndexRune(ok, rune) >= 0 {\n+\t\tif accept {\n+\t\t\ts.buf.WriteRune(rune)\n \t\t}\n+\t\treturn true\n \t}\n \tif rune != EOF && accept {\n-\t\ts.UngetRune()\n+\t\ts.UnreadRune()\n \t}\n \treturn false\n }\n \n+// peek reports whether the next character is in the ok string, without consuming it.\n+func (s *ss) peek(ok string) bool {\n+\trune := s.getRune()\n+\tif rune != EOF {\n+\t\ts.UnreadRune()\n+\t}\n+\treturn strings.IndexRune(ok, rune) >= 0\n+}\n+\n // accept checks the next rune in the input.  If it's a byte (sic) in the string, it puts it in the\n // buffer and returns true. Otherwise it return false.\n func (s *ss) accept(ok string) bool {\n@@ -436,7 +463,7 @@ func (s *ss) scanBool(verb int) bool {\n \t\treturn false\n \t}\n \t// Syntax-checking a boolean is annoying.  We're not fastidious about case.\n-\tswitch s.mustGetRune() {\n+\tswitch s.mustReadRune() {\n \tcase '0':\n \t\treturn false\n \tcase '1':\n@@ -463,7 +490,7 @@ const (\n \thexadecimalDigits = \"0123456789aAbBcCdDeEfF\"\n \tsign              = \"+-\"\n \tperiod            = \".\"\n-\texponent          = \"eE\"\n+\texponent          = \"eEp\"\n )\n \n // getBase returns the numeric base represented by the verb and its digit string.\n@@ -486,8 +513,8 @@ func (s *ss) getBase(verb int) (base int, digits string) {\n }\n \n // scanNumber returns the numerical string with specified digits starting here.\n-func (s *ss) scanNumber(digits string) string {\n-\tif !s.accept(digits) {\n+func (s *ss) scanNumber(digits string, haveDigits bool) string {\n+\tif !haveDigits && !s.accept(digits) {\n \t\ts.errorString(\"expected integer\")\n \t}\n \tfor s.accept(digits) {\n@@ -497,7 +524,7 @@ func (s *ss) scanNumber(digits string) string {\n \n // scanRune returns the next rune value in the input.\n func (s *ss) scanRune(bitSize int) int64 {\n-\trune := int64(s.mustGetRune())\n+\trune := int64(s.mustReadRune())\n \tn := uint(bitSize)\n \tx := (rune << (64 - n)) >> (64 - n)\n \tif x != rune {\n@@ -506,22 +533,44 @@ func (s *ss) scanRune(bitSize int) int64 {\n \treturn rune\n }\n \n+// scanBasePrefix reports whether the integer begins with a 0 or 0x,\n+// and returns the base, digit string, and whether a zero was found.\n+// It is called only if the verb is %v.\n+func (s *ss) scanBasePrefix() (base int, digits string, found bool) {\n+\tif !s.peek(\"0\") {\n+\t\treturn 10, decimalDigits, false\n+\t}\n+\ts.accept(\"0\")\n+\tfound = true // We've put a digit into the token buffer.\n+\t// Special cases for '0' && '0x'\n+\tbase, digits = 8, octalDigits\n+\tif s.peek(\"xX\") {\n+\t\ts.consume(\"xX\", false)\n+\t\tbase, digits = 16, hexadecimalDigits\n+\t}\n+\treturn\n+}\n+\n // scanInt returns the value of the integer represented by the next\n // token, checking for overflow.  Any error is stored in s.err.\n func (s *ss) scanInt(verb int, bitSize int) int64 {\n \tif verb == 'c' {\n \t\treturn s.scanRune(bitSize)\n \t}\n-\tbase, digits := s.getBase(verb)\n \ts.skipSpace(false)\n+\tbase, digits := s.getBase(verb)\n+\thaveDigits := false\n \tif verb == 'U' {\n \t\tif !s.consume(\"U\", false) || !s.consume(\"+\", false) {\n \t\t\ts.errorString(\"bad unicode format \")\n \t\t}\n \t} else {\n \t\ts.accept(sign) // If there's a sign, it will be left in the token buffer.\n+\t\tif verb == 'v' {\n+\t\t\tbase, digits, haveDigits = s.scanBasePrefix()\n+\t\t}\n \t}\n-\ttok := s.scanNumber(digits)\n+\ttok := s.scanNumber(digits, haveDigits)\n \ti, err := strconv.Btoi64(tok, base)\n \tif err != nil {\n \t\ts.error(err)\n@@ -540,14 +589,17 @@ func (s *ss) scanUint(verb int, bitSize int) uint64 {\n \tif verb == 'c' {\n \t\treturn uint64(s.scanRune(bitSize))\n \t}\n-\tbase, digits := s.getBase(verb)\n \ts.skipSpace(false)\n+\tbase, digits := s.getBase(verb)\n+\thaveDigits := false\n \tif verb == 'U' {\n \t\tif !s.consume(\"U\", false) || !s.consume(\"+\", false) {\n \t\t\ts.errorString(\"bad unicode format \")\n \t\t}\n+\t} else if verb == 'v' {\n+\t\tbase, digits, haveDigits = s.scanBasePrefix()\n \t}\n-\ttok := s.scanNumber(digits)\n+\ttok := s.scanNumber(digits, haveDigits)\n \ti, err := strconv.Btoui64(tok, base)\n \tif err != nil {\n \t\ts.error(err)\n@@ -621,6 +673,27 @@ func (s *ss) complexTokens() (real, imag string) {\n \n // convertFloat converts the string to a float64value.\n func (s *ss) convertFloat(str string, n int) float64 {\n+\tif p := strings.Index(str, \"p\"); p >= 0 {\n+\t\t// Atof doesn't handle power-of-2 exponents,\n+\t\t// but they're easy to evaluate.\n+\t\tf, err := strconv.AtofN(str[:p], n)\n+\t\tif err != nil {\n+\t\t\t// Put full string into error.\n+\t\t\tif e, ok := err.(*strconv.NumError); ok {\n+\t\t\t\te.Num = str\n+\t\t\t}\n+\t\t\ts.error(err)\n+\t\t}\n+\t\tn, err := strconv.Atoi(str[p+1:])\n+\t\tif err != nil {\n+\t\t\t// Put full string into error.\n+\t\t\tif e, ok := err.(*strconv.NumError); ok {\n+\t\t\t\te.Num = str\n+\t\t\t}\n+\t\t\ts.error(err)\n+\t\t}\n+\t\treturn math.Ldexp(f, n)\n+\t}\n \tf, err := strconv.AtofN(str, n)\n \tif err != nil {\n \t\ts.error(err)\n@@ -667,12 +740,12 @@ func (s *ss) convertString(verb int) (str string) {\n \n // quotedString returns the double- or back-quoted string represented by the next input characters.\n func (s *ss) quotedString() string {\n-\tquote := s.mustGetRune()\n+\tquote := s.mustReadRune()\n \tswitch quote {\n \tcase '`':\n \t\t// Back-quoted: Anything goes until EOF or back quote.\n \t\tfor {\n-\t\t\trune := s.mustGetRune()\n+\t\t\trune := s.mustReadRune()\n \t\t\tif rune == quote {\n \t\t\t\tbreak\n \t\t\t}\n@@ -683,13 +756,13 @@ func (s *ss) quotedString() string {\n \t\t// Double-quoted: Include the quotes and let strconv.Unquote do the backslash escapes.\n \t\ts.buf.WriteRune(quote)\n \t\tfor {\n-\t\t\trune := s.mustGetRune()\n+\t\t\trune := s.mustReadRune()\n \t\t\ts.buf.WriteRune(rune)\n \t\t\tif rune == '\\\\' {\n \t\t\t\t// In a legal backslash escape, no matter how long, only the character\n \t\t\t\t// immediately after the escape can itself be a backslash or quote.\n \t\t\t\t// Thus we only need to protect the first character after the backslash.\n-\t\t\t\trune := s.mustGetRune()\n+\t\t\t\trune := s.mustReadRune()\n \t\t\t\ts.buf.WriteRune(rune)\n \t\t\t} else if rune == '\"' {\n \t\t\t\tbreak\n@@ -728,10 +801,10 @@ func (s *ss) hexByte() (b byte, ok bool) {\n \t\treturn\n \t}\n \tif unicode.IsSpace(rune1) {\n-\t\ts.UngetRune()\n+\t\ts.UnreadRune()\n \t\treturn\n \t}\n-\trune2 := s.mustGetRune()\n+\trune2 := s.mustReadRune()\n \treturn byte(s.hexDigit(rune1)<<4 | s.hexDigit(rune2)), true\n }\n \n@@ -751,7 +824,9 @@ func (s *ss) hexString() string {\n \treturn s.buf.String()\n }\n \n-const floatVerbs = \"eEfFgGv\"\n+const floatVerbs = \"beEfFgGv\"\n+\n+const hugeWid = 1 << 30\n \n // scanOne scans a single value, deriving the scanner from the type of the argument.\n func (s *ss) scanOne(verb int, field interface{}) {\n@@ -761,14 +836,13 @@ func (s *ss) scanOne(verb int, field interface{}) {\n \tif v, ok := field.(Scanner); ok {\n \t\terr = v.Scan(s, verb)\n \t\tif err != nil {\n+\t\t\tif err == os.EOF {\n+\t\t\t\terr = io.ErrUnexpectedEOF\n+\t\t\t}\n \t\t\ts.error(err)\n \t\t}\n \t\treturn\n \t}\n-\tif !s.widPresent {\n-\t\ts.maxWid = 1 << 30 // Huge\n-\t}\n-\ts.wid = 0\n \tswitch v := field.(type) {\n \tcase *bool:\n \t\t*v = s.scanBool(verb)\n@@ -869,7 +943,6 @@ func errorHandler(errp *os.Error) {\n }\n \n // doScan does the real work for scanning without a format string.\n-// At the moment, it handles only pointers to basic types.\n func (s *ss) doScan(a []interface{}) (numProcessed int, err os.Error) {\n \tdefer errorHandler(&err)\n \tfor _, field := range a {\n@@ -930,9 +1003,9 @@ func (s *ss) advance(format string) (i int) {\n \t\t\ts.skipSpace(true)\n \t\t\tcontinue\n \t\t}\n-\t\tinputc := s.mustGetRune()\n+\t\tinputc := s.mustReadRune()\n \t\tif fmtc != inputc {\n-\t\t\ts.UngetRune()\n+\t\t\ts.UnreadRune()\n \t\t\treturn -1\n \t\t}\n \t\ti += w\n@@ -964,7 +1037,15 @@ func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err os.E\n \t\ti++ // % is one byte\n \n \t\t// do we have 20 (width)?\n-\t\ts.maxWid, s.widPresent, i = parsenum(format, i, end)\n+\t\tvar widPresent bool\n+\t\ts.maxWid, widPresent, i = parsenum(format, i, end)\n+\t\tif !widPresent {\n+\t\t\ts.maxWid = hugeWid\n+\t\t}\n+\t\ts.fieldLimit = s.limit\n+\t\tif f := s.count + s.maxWid; f < s.fieldLimit {\n+\t\t\ts.fieldLimit = f\n+\t\t}\n \n \t\tc, w := utf8.DecodeRuneInString(format[i:])\n \t\ti += w\n@@ -977,6 +1058,7 @@ func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err os.E\n \n \t\ts.scanOne(c, field)\n \t\tnumProcessed++\n+\t\ts.fieldLimit = s.limit\n \t}\n \tif numProcessed < len(a) {\n \t\ts.errorString(\"too many operands\")"}, {"sha": "65adb023686e8323a46e2612966b0633b59c5b4a", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 224, "deletions": 19, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,7 @@ package fmt_test\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n \t. \"fmt\"\n \t\"io\"\n \t\"math\"\n@@ -87,21 +88,7 @@ type FloatTest struct {\n type Xs string\n \n func (x *Xs) Scan(state ScanState, verb int) os.Error {\n-\tvar tok string\n-\tvar c int\n-\tvar err os.Error\n-\twid, present := state.Width()\n-\tif !present {\n-\t\ttok, err = state.Token()\n-\t} else {\n-\t\tfor i := 0; i < wid; i++ {\n-\t\t\tc, err = state.GetRune()\n-\t\t\tif err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ttok += string(c)\n-\t\t}\n-\t}\n+\ttok, err := state.Token()\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -114,6 +101,26 @@ func (x *Xs) Scan(state ScanState, verb int) os.Error {\n \n var xVal Xs\n \n+// IntString accepts an integer followed immediately by a string.\n+// It tests the embedding of a scan within a scan.\n+type IntString struct {\n+\ti int\n+\ts string\n+}\n+\n+func (s *IntString) Scan(state ScanState, verb int) os.Error {\n+\tif _, err := Fscan(state, &s.i); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif _, err := Fscan(state, &s.s); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+var intStringVal IntString\n+\n // myStringReader implements Read but not ReadRune, allowing us to test our readRune wrapper\n // type that creates something that can read runes given only Read().\n type myStringReader struct {\n@@ -129,10 +136,20 @@ func newReader(s string) *myStringReader {\n }\n \n var scanTests = []ScanTest{\n-\t// Numbers\n+\t// Basic types\n \t{\"T\\n\", &boolVal, true},  // boolean test vals toggle to be sure they are written\n \t{\"F\\n\", &boolVal, false}, // restored to zero value\n \t{\"21\\n\", &intVal, 21},\n+\t{\"0\\n\", &intVal, 0},\n+\t{\"000\\n\", &intVal, 0},\n+\t{\"0x10\\n\", &intVal, 0x10},\n+\t{\"-0x10\\n\", &intVal, -0x10},\n+\t{\"0377\\n\", &intVal, 0377},\n+\t{\"-0377\\n\", &intVal, -0377},\n+\t{\"0\\n\", &uintVal, uint(0)},\n+\t{\"000\\n\", &uintVal, uint(0)},\n+\t{\"0x10\\n\", &uintVal, uint(0x10)},\n+\t{\"0377\\n\", &uintVal, uint(0377)},\n \t{\"22\\n\", &int8Val, int8(22)},\n \t{\"23\\n\", &int16Val, int16(23)},\n \t{\"24\\n\", &int32Val, int32(24)},\n@@ -160,6 +177,10 @@ var scanTests = []ScanTest{\n \t{\"2.3\\n\", &float64Val, 2.3},\n \t{\"2.3e1\\n\", &float32Val, float32(2.3e1)},\n \t{\"2.3e2\\n\", &float64Val, 2.3e2},\n+\t{\"2.3p2\\n\", &float64Val, 2.3 * 4},\n+\t{\"2.3p+2\\n\", &float64Val, 2.3 * 4},\n+\t{\"2.3p+66\\n\", &float64Val, 2.3 * (1 << 32) * (1 << 32) * 4},\n+\t{\"2.3p-66\\n\", &float64Val, 2.3 / ((1 << 32) * (1 << 32) * 4)},\n \t{\"2.35\\n\", &stringVal, \"2.35\"},\n \t{\"2345678\\n\", &bytesVal, []byte(\"2345678\")},\n \t{\"(3.4e1-2i)\\n\", &complex128Val, 3.4e1 - 2i},\n@@ -186,8 +207,9 @@ var scanTests = []ScanTest{\n \t{\"114\\n\", &renamedStringVal, renamedString(\"114\")},\n \t{\"115\\n\", &renamedBytesVal, renamedBytes([]byte(\"115\"))},\n \n-\t// Custom scanner.\n+\t// Custom scanners.\n \t{\"  vvv \", &xVal, Xs(\"vvv\")},\n+\t{\" 1234hello\", &intStringVal, IntString{1234, \"hello\"}},\n \n \t// Fixed bugs\n \t{\"2147483648\\n\", &int64Val, int64(2147483648)}, // was: integer overflow\n@@ -197,6 +219,8 @@ var scanfTests = []ScanfTest{\n \t{\"%v\", \"TRUE\\n\", &boolVal, true},\n \t{\"%t\", \"false\\n\", &boolVal, false},\n \t{\"%v\", \"-71\\n\", &intVal, -71},\n+\t{\"%v\", \"0377\\n\", &intVal, 0377},\n+\t{\"%v\", \"0x44\\n\", &intVal, 0x44},\n \t{\"%d\", \"72\\n\", &intVal, 72},\n \t{\"%c\", \"a\\n\", &intVal, 'a'},\n \t{\"%c\", \"\\u5072\\n\", &intVal, 0x5072},\n@@ -292,6 +316,7 @@ var f float64\n var s, t string\n var c complex128\n var x, y Xs\n+var z IntString\n \n var multiTests = []ScanfMultiTest{\n \t{\"\", \"\", nil, nil, \"\"},\n@@ -305,8 +330,9 @@ var multiTests = []ScanfMultiTest{\n \t{\"%d%s\", \"123abc\", args(&i, &s), args(123, \"abc\"), \"\"},\n \t{\"%c%c%c\", \"2\\u50c2X\", args(&i, &j, &k), args('2', '\\u50c2', 'X'), \"\"},\n \n-\t// Custom scanner.\n+\t// Custom scanners.\n \t{\"%2e%f\", \"eefffff\", args(&x, &y), args(Xs(\"ee\"), Xs(\"fffff\")), \"\"},\n+\t{\"%4v%s\", \"12abcd\", args(&z, &s), args(IntString{12, \"ab\"}, \"cd\"), \"\"},\n \n \t// Errors\n \t{\"%t\", \"23 18\", args(&i), nil, \"bad verb\"},\n@@ -329,7 +355,11 @@ func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}\n \t\t}\n \t\tn, err := scan(r, test.in)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"%s got error scanning %q: %s\", name, test.text, err)\n+\t\t\tm := \"\"\n+\t\t\tif n > 0 {\n+\t\t\t\tm = Sprintf(\" (%d fields ok)\", n)\n+\t\t\t}\n+\t\t\tt.Errorf(\"%s got error scanning %q: %s%s\", name, test.text, err, m)\n \t\t\tcontinue\n \t\t}\n \t\tif n != 1 {\n@@ -657,3 +687,178 @@ func TestUnreadRuneWithBufio(t *testing.T) {\n \t\tt.Errorf(\"expected \u03b1b; got %q\", a)\n \t}\n }\n+\n+type TwoLines string\n+\n+// Attempt to read two lines into the object.  Scanln should prevent this\n+// because it stops at newline; Scan and Scanf should be fine.\n+func (t *TwoLines) Scan(state ScanState, verb int) os.Error {\n+\tchars := make([]int, 0, 100)\n+\tfor nlCount := 0; nlCount < 2; {\n+\t\tc, _, err := state.ReadRune()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tchars = append(chars, c)\n+\t\tif c == '\\n' {\n+\t\t\tnlCount++\n+\t\t}\n+\t}\n+\t*t = TwoLines(string(chars))\n+\treturn nil\n+}\n+\n+func TestMultiLine(t *testing.T) {\n+\tinput := \"abc\\ndef\\n\"\n+\t// Sscan should work\n+\tvar tscan TwoLines\n+\tn, err := Sscan(input, &tscan)\n+\tif n != 1 {\n+\t\tt.Errorf(\"Sscan: expected 1 item; got %d\", n)\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"Sscan: expected no error; got %s\", err)\n+\t}\n+\tif string(tscan) != input {\n+\t\tt.Errorf(\"Sscan: expected %q; got %q\", input, tscan)\n+\t}\n+\t// Sscanf should work\n+\tvar tscanf TwoLines\n+\tn, err = Sscanf(input, \"%s\", &tscanf)\n+\tif n != 1 {\n+\t\tt.Errorf(\"Sscanf: expected 1 item; got %d\", n)\n+\t}\n+\tif err != nil {\n+\t\tt.Errorf(\"Sscanf: expected no error; got %s\", err)\n+\t}\n+\tif string(tscanf) != input {\n+\t\tt.Errorf(\"Sscanf: expected %q; got %q\", input, tscanf)\n+\t}\n+\t// Sscanln should not work\n+\tvar tscanln TwoLines\n+\tn, err = Sscanln(input, &tscanln)\n+\tif n != 0 {\n+\t\tt.Errorf(\"Sscanln: expected 0 items; got %d: %q\", n, tscanln)\n+\t}\n+\tif err == nil {\n+\t\tt.Error(\"Sscanln: expected error; got none\")\n+\t} else if err != io.ErrUnexpectedEOF {\n+\t\tt.Errorf(\"Sscanln: expected io.ErrUnexpectedEOF (ha!); got %s\", err)\n+\t}\n+}\n+\n+// RecursiveInt accepts an string matching %d.%d.%d....\n+// and parses it into a linked list.\n+// It allows us to benchmark recursive descent style scanners.\n+type RecursiveInt struct {\n+\ti    int\n+\tnext *RecursiveInt\n+}\n+\n+func (r *RecursiveInt) Scan(state ScanState, verb int) (err os.Error) {\n+\t_, err = Fscan(state, &r.i)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tnext := new(RecursiveInt)\n+\t_, err = Fscanf(state, \".%v\", next)\n+\tif err != nil {\n+\t\tif err == os.ErrorString(\"input does not match format\") || err == io.ErrUnexpectedEOF {\n+\t\t\terr = nil\n+\t\t}\n+\t\treturn\n+\t}\n+\tr.next = next\n+\treturn\n+}\n+\n+// Perform the same scanning task as RecursiveInt.Scan\n+// but without recurring through scanner, so we can compare\n+// performance more directly.\n+func scanInts(r *RecursiveInt, b *bytes.Buffer) (err os.Error) {\n+\tr.next = nil\n+\t_, err = Fscan(b, &r.i)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tvar c int\n+\tc, _, err = b.ReadRune()\n+\tif err != nil {\n+\t\tif err == os.EOF {\n+\t\t\terr = nil\n+\t\t}\n+\t\treturn\n+\t}\n+\tif c != '.' {\n+\t\treturn\n+\t}\n+\tnext := new(RecursiveInt)\n+\terr = scanInts(next, b)\n+\tif err == nil {\n+\t\tr.next = next\n+\t}\n+\treturn\n+}\n+\n+func makeInts(n int) []byte {\n+\tvar buf bytes.Buffer\n+\tFprintf(&buf, \"1\")\n+\tfor i := 1; i < n; i++ {\n+\t\tFprintf(&buf, \".%d\", i+1)\n+\t}\n+\treturn buf.Bytes()\n+}\n+\n+func TestScanInts(t *testing.T) {\n+\ttestScanInts(t, scanInts)\n+\ttestScanInts(t, func(r *RecursiveInt, b *bytes.Buffer) (err os.Error) {\n+\t\t_, err = Fscan(b, r)\n+\t\treturn\n+\t})\n+}\n+\n+const intCount = 1000\n+\n+func testScanInts(t *testing.T, scan func(*RecursiveInt, *bytes.Buffer) os.Error) {\n+\tr := new(RecursiveInt)\n+\tints := makeInts(intCount)\n+\tbuf := bytes.NewBuffer(ints)\n+\terr := scan(r, buf)\n+\tif err != nil {\n+\t\tt.Error(\"unexpected error\", err)\n+\t}\n+\ti := 1\n+\tfor ; r != nil; r = r.next {\n+\t\tif r.i != i {\n+\t\t\tt.Fatal(\"bad scan: expected %d got %d\", i, r.i)\n+\t\t}\n+\t\ti++\n+\t}\n+\tif i-1 != intCount {\n+\t\tt.Fatal(\"bad scan count: expected %d got %d\", intCount, i-1)\n+\t}\n+}\n+\n+func BenchmarkScanInts(b *testing.B) {\n+\tb.ResetTimer()\n+\tints := makeInts(intCount)\n+\tvar r RecursiveInt\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\tbuf := bytes.NewBuffer(ints)\n+\t\tb.StartTimer()\n+\t\tscanInts(&r, buf)\n+\t\tb.StopTimer()\n+\t}\n+}\n+\n+func BenchmarkScanRecursiveInt(b *testing.B) {\n+\tb.ResetTimer()\n+\tints := makeInts(intCount)\n+\tvar r RecursiveInt\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\tbuf := bytes.NewBuffer(ints)\n+\t\tb.StartTimer()\n+\t\tFscan(buf, &r)\n+\t\tb.StopTimer()\n+\t}\n+}"}, {"sha": "abafb5663b3baf0ef0dcfdebfc9d303be68a6ae1", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -535,6 +535,13 @@ type (\n \t\tX Expr // expression\n \t}\n \n+\t// A SendStmt node represents a send statement.\n+\tSendStmt struct {\n+\t\tChan  Expr\n+\t\tArrow token.Pos // position of \"<-\"\n+\t\tValue Expr\n+\t}\n+\n \t// An IncDecStmt node represents an increment or decrement statement.\n \tIncDecStmt struct {\n \t\tX      Expr\n@@ -590,7 +597,7 @@ type (\n \tIfStmt struct {\n \t\tIf   token.Pos // position of \"if\" keyword\n \t\tInit Stmt      // initalization statement; or nil\n-\t\tCond Expr      // condition; or nil\n+\t\tCond Expr      // condition\n \t\tBody *BlockStmt\n \t\tElse Stmt // else branch; or nil\n \t}\n@@ -629,11 +636,10 @@ type (\n \n \t// A CommClause node represents a case of a select statement.\n \tCommClause struct {\n-\t\tCase     token.Pos   // position of \"case\" or \"default\" keyword\n-\t\tTok      token.Token // ASSIGN or DEFINE (valid only if Lhs != nil)\n-\t\tLhs, Rhs Expr        // Rhs == nil means default case\n-\t\tColon    token.Pos   // position of \":\"\n-\t\tBody     []Stmt      // statement list; or nil\n+\t\tCase  token.Pos // position of \"case\" or \"default\" keyword\n+\t\tComm  Stmt      // send or receive statement; nil means default case\n+\t\tColon token.Pos // position of \":\"\n+\t\tBody  []Stmt    // statement list; or nil\n \t}\n \n \t// An SelectStmt node represents a select statement.\n@@ -670,6 +676,7 @@ func (s *DeclStmt) Pos() token.Pos       { return s.Decl.Pos() }\n func (s *EmptyStmt) Pos() token.Pos      { return s.Semicolon }\n func (s *LabeledStmt) Pos() token.Pos    { return s.Label.Pos() }\n func (s *ExprStmt) Pos() token.Pos       { return s.X.Pos() }\n+func (s *SendStmt) Pos() token.Pos       { return s.Chan.Pos() }\n func (s *IncDecStmt) Pos() token.Pos     { return s.X.Pos() }\n func (s *AssignStmt) Pos() token.Pos     { return s.Lhs[0].Pos() }\n func (s *GoStmt) Pos() token.Pos         { return s.Go }\n@@ -695,6 +702,7 @@ func (s *EmptyStmt) End() token.Pos {\n }\n func (s *LabeledStmt) End() token.Pos { return s.Stmt.End() }\n func (s *ExprStmt) End() token.Pos    { return s.X.End() }\n+func (s *SendStmt) End() token.Pos    { return s.Value.End() }\n func (s *IncDecStmt) End() token.Pos {\n \treturn s.TokPos + 2 /* len(\"++\") */\n }\n@@ -753,6 +761,7 @@ func (s *DeclStmt) stmtNode()       {}\n func (s *EmptyStmt) stmtNode()      {}\n func (s *LabeledStmt) stmtNode()    {}\n func (s *ExprStmt) stmtNode()       {}\n+func (s *SendStmt) stmtNode()       {}\n func (s *IncDecStmt) stmtNode()     {}\n func (s *AssignStmt) stmtNode()     {}\n func (s *GoStmt) stmtNode()         {}"}, {"sha": "20c337c3be98b8f469da3f9d42f29979f03a78a7", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -195,6 +195,10 @@ func Walk(v Visitor, node Node) {\n \tcase *ExprStmt:\n \t\tWalk(v, n.X)\n \n+\tcase *SendStmt:\n+\t\tWalk(v, n.Chan)\n+\t\tWalk(v, n.Value)\n+\n \tcase *IncDecStmt:\n \t\tWalk(v, n.X)\n \n@@ -223,9 +227,7 @@ func Walk(v Visitor, node Node) {\n \t\tif n.Init != nil {\n \t\t\tWalk(v, n.Init)\n \t\t}\n-\t\tif n.Cond != nil {\n-\t\t\tWalk(v, n.Cond)\n-\t\t}\n+\t\tWalk(v, n.Cond)\n \t\tWalk(v, n.Body)\n \t\tif n.Else != nil {\n \t\t\tWalk(v, n.Else)\n@@ -258,11 +260,8 @@ func Walk(v Visitor, node Node) {\n \t\tWalk(v, n.Body)\n \n \tcase *CommClause:\n-\t\tif n.Lhs != nil {\n-\t\t\tWalk(v, n.Lhs)\n-\t\t}\n-\t\tif n.Rhs != nil {\n-\t\t\tWalk(v, n.Rhs)\n+\t\tif n.Comm != nil {\n+\t\t\tWalk(v, n.Comm)\n \t\t}\n \t\twalkStmtList(v, n.Body)\n "}, {"sha": "7c5843f36371a19b23b476edf985bc13f666a633", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 121, "deletions": 62, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1193,18 +1193,6 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \tx := p.parseExprList()\n \n \tswitch p.tok {\n-\tcase token.COLON:\n-\t\t// labeled statement\n-\t\tcolon := p.pos\n-\t\tp.next()\n-\t\tif labelOk && len(x) == 1 {\n-\t\t\tif label, isIdent := x[0].(*ast.Ident); isIdent {\n-\t\t\t\treturn &ast.LabeledStmt{label, colon, p.parseStmt()}\n-\t\t\t}\n-\t\t}\n-\t\tp.error(x[0].Pos(), \"illegal label declaration\")\n-\t\treturn &ast.BadStmt{x[0].Pos(), colon + 1}\n-\n \tcase\n \t\ttoken.DEFINE, token.ASSIGN, token.ADD_ASSIGN,\n \t\ttoken.SUB_ASSIGN, token.MUL_ASSIGN, token.QUO_ASSIGN,\n@@ -1218,11 +1206,29 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t}\n \n \tif len(x) > 1 {\n-\t\tp.error(x[0].Pos(), \"only one expression allowed\")\n+\t\tp.errorExpected(x[0].Pos(), \"1 expression\")\n \t\t// continue with first expression\n \t}\n \n-\tif p.tok == token.INC || p.tok == token.DEC {\n+\tswitch p.tok {\n+\tcase token.COLON:\n+\t\t// labeled statement\n+\t\tcolon := p.pos\n+\t\tp.next()\n+\t\tif label, isIdent := x[0].(*ast.Ident); labelOk && isIdent {\n+\t\t\treturn &ast.LabeledStmt{label, colon, p.parseStmt()}\n+\t\t}\n+\t\tp.error(x[0].Pos(), \"illegal label declaration\")\n+\t\treturn &ast.BadStmt{x[0].Pos(), colon + 1}\n+\n+\tcase token.ARROW:\n+\t\t// send statement\n+\t\tarrow := p.pos\n+\t\tp.next() // consume \"<-\"\n+\t\ty := p.parseExpr()\n+\t\treturn &ast.SendStmt{x[0], arrow, y}\n+\n+\tcase token.INC, token.DEC:\n \t\t// increment or decrement\n \t\ts := &ast.IncDecStmt{x[0], p.pos, p.tok}\n \t\tp.next() // consume \"++\" or \"--\"\n@@ -1321,44 +1327,34 @@ func (p *parser) makeExpr(s ast.Stmt) ast.Expr {\n }\n \n \n-func (p *parser) parseControlClause(isForStmt bool) (s1, s2, s3 ast.Stmt) {\n-\tif p.tok != token.LBRACE {\n+func (p *parser) parseIfStmt() *ast.IfStmt {\n+\tif p.trace {\n+\t\tdefer un(trace(p, \"IfStmt\"))\n+\t}\n+\n+\tpos := p.expect(token.IF)\n+\n+\tvar s ast.Stmt\n+\tvar x ast.Expr\n+\t{\n \t\tprevLev := p.exprLev\n \t\tp.exprLev = -1\n-\n-\t\tif p.tok != token.SEMICOLON {\n-\t\t\ts1 = p.parseSimpleStmt(false)\n-\t\t}\n \t\tif p.tok == token.SEMICOLON {\n \t\t\tp.next()\n-\t\t\tif p.tok != token.LBRACE && p.tok != token.SEMICOLON {\n-\t\t\t\ts2 = p.parseSimpleStmt(false)\n-\t\t\t}\n-\t\t\tif isForStmt {\n-\t\t\t\t// for statements have a 3rd section\n-\t\t\t\tp.expectSemi()\n-\t\t\t\tif p.tok != token.LBRACE {\n-\t\t\t\t\ts3 = p.parseSimpleStmt(false)\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tx = p.parseExpr()\n \t\t} else {\n-\t\t\ts1, s2 = nil, s1\n+\t\t\ts = p.parseSimpleStmt(false)\n+\t\t\tif p.tok == token.SEMICOLON {\n+\t\t\t\tp.next()\n+\t\t\t\tx = p.parseExpr()\n+\t\t\t} else {\n+\t\t\t\tx = p.makeExpr(s)\n+\t\t\t\ts = nil\n+\t\t\t}\n \t\t}\n-\n \t\tp.exprLev = prevLev\n \t}\n \n-\treturn s1, s2, s3\n-}\n-\n-\n-func (p *parser) parseIfStmt() *ast.IfStmt {\n-\tif p.trace {\n-\t\tdefer un(trace(p, \"IfStmt\"))\n-\t}\n-\n-\tpos := p.expect(token.IF)\n-\ts1, s2, _ := p.parseControlClause(false)\n \tbody := p.parseBlockStmt()\n \tvar else_ ast.Stmt\n \tif p.tok == token.ELSE {\n@@ -1368,7 +1364,7 @@ func (p *parser) parseIfStmt() *ast.IfStmt {\n \t\tp.expectSemi()\n \t}\n \n-\treturn &ast.IfStmt{pos, s1, p.makeExpr(s2), body, else_}\n+\treturn &ast.IfStmt{pos, s, x, body, else_}\n }\n \n \n@@ -1451,7 +1447,24 @@ func (p *parser) parseSwitchStmt() ast.Stmt {\n \t}\n \n \tpos := p.expect(token.SWITCH)\n-\ts1, s2, _ := p.parseControlClause(false)\n+\n+\tvar s1, s2 ast.Stmt\n+\tif p.tok != token.LBRACE {\n+\t\tprevLev := p.exprLev\n+\t\tp.exprLev = -1\n+\t\tif p.tok != token.SEMICOLON {\n+\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t}\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t\ts1 = s2\n+\t\t\ts2 = nil\n+\t\t\tif p.tok != token.LBRACE {\n+\t\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t}\n+\t\tp.exprLev = prevLev\n+\t}\n \n \tif isExprSwitch(s2) {\n \t\tlbrace := p.expect(token.LBRACE)\n@@ -1486,28 +1499,52 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \n \t// CommCase\n \tpos := p.pos\n-\tvar tok token.Token\n-\tvar lhs, rhs ast.Expr\n+\tvar comm ast.Stmt\n \tif p.tok == token.CASE {\n \t\tp.next()\n+\t\tlhs := p.parseExprList()\n \t\tif p.tok == token.ARROW {\n-\t\t\t// RecvExpr without assignment\n-\t\t\trhs = p.parseExpr()\n+\t\t\t// SendStmt\n+\t\t\tif len(lhs) > 1 {\n+\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n+\t\t\t\t// continue with first expression\n+\t\t\t}\n+\t\t\tarrow := p.pos\n+\t\t\tp.next()\n+\t\t\trhs := p.parseExpr()\n+\t\t\tcomm = &ast.SendStmt{lhs[0], arrow, rhs}\n \t\t} else {\n-\t\t\t// SendExpr or RecvExpr\n-\t\t\trhs = p.parseExpr()\n+\t\t\t// RecvStmt\n+\t\t\tpos := p.pos\n+\t\t\ttok := p.tok\n+\t\t\tvar rhs ast.Expr\n \t\t\tif p.tok == token.ASSIGN || p.tok == token.DEFINE {\n-\t\t\t\t// RecvExpr with assignment\n-\t\t\t\ttok = p.tok\n+\t\t\t\t// RecvStmt with assignment\n+\t\t\t\tif len(lhs) > 2 {\n+\t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 or 2 expressions\")\n+\t\t\t\t\t// continue with first two expressions\n+\t\t\t\t\tlhs = lhs[0:2]\n+\t\t\t\t}\n \t\t\t\tp.next()\n-\t\t\t\tlhs = rhs\n-\t\t\t\tif p.tok == token.ARROW {\n-\t\t\t\t\trhs = p.parseExpr()\n-\t\t\t\t} else {\n-\t\t\t\t\tp.expect(token.ARROW) // use expect() error handling\n+\t\t\t\trhs = p.parseExpr()\n+\t\t\t} else {\n+\t\t\t\t// rhs must be single receive operation\n+\t\t\t\tif len(lhs) > 1 {\n+\t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 expression\")\n+\t\t\t\t\t// continue with first expression\n \t\t\t\t}\n+\t\t\t\trhs = lhs[0]\n+\t\t\t\tlhs = nil // there is no lhs\n+\t\t\t}\n+\t\t\tif x, isUnary := rhs.(*ast.UnaryExpr); !isUnary || x.Op != token.ARROW {\n+\t\t\t\tp.errorExpected(rhs.Pos(), \"send or receive operation\")\n+\t\t\t\trhs = &ast.BadExpr{rhs.Pos(), rhs.End()}\n+\t\t\t}\n+\t\t\tif lhs != nil {\n+\t\t\t\tcomm = &ast.AssignStmt{lhs, pos, tok, []ast.Expr{rhs}}\n+\t\t\t} else {\n+\t\t\t\tcomm = &ast.ExprStmt{rhs}\n \t\t\t}\n-\t\t\t// else SendExpr\n \t\t}\n \t} else {\n \t\tp.expect(token.DEFAULT)\n@@ -1516,7 +1553,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \tcolon := p.expect(token.COLON)\n \tbody := p.parseStmtList()\n \n-\treturn &ast.CommClause{pos, tok, lhs, rhs, colon, body}\n+\treturn &ast.CommClause{pos, comm, colon, body}\n }\n \n \n@@ -1545,7 +1582,29 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t}\n \n \tpos := p.expect(token.FOR)\n-\ts1, s2, s3 := p.parseControlClause(true)\n+\n+\tvar s1, s2, s3 ast.Stmt\n+\tif p.tok != token.LBRACE {\n+\t\tprevLev := p.exprLev\n+\t\tp.exprLev = -1\n+\t\tif p.tok != token.SEMICOLON {\n+\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t}\n+\t\tif p.tok == token.SEMICOLON {\n+\t\t\tp.next()\n+\t\t\ts1 = s2\n+\t\t\ts2 = nil\n+\t\t\tif p.tok != token.SEMICOLON {\n+\t\t\t\ts2 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t\tp.expectSemi()\n+\t\t\tif p.tok != token.LBRACE {\n+\t\t\t\ts3 = p.parseSimpleStmt(false)\n+\t\t\t}\n+\t\t}\n+\t\tp.exprLev = prevLev\n+\t}\n+\n \tbody := p.parseBlockStmt()\n \tp.expectSemi()\n \n@@ -1568,7 +1627,7 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t\t}\n \t\t// check rhs\n \t\tif len(as.Rhs) != 1 {\n-\t\t\tp.errorExpected(as.Rhs[0].Pos(), \"1 expressions\")\n+\t\t\tp.errorExpected(as.Rhs[0].Pos(), \"1 expression\")\n \t\t\treturn &ast.BadStmt{pos, body.End()}\n \t\t}\n \t\tif rhs, isUnary := as.Rhs[0].(*ast.UnaryExpr); isUnary && rhs.Op == token.RANGE {"}, {"sha": "38535627a75ec76029993c986f53e25b04a82c00", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -18,6 +18,9 @@ var illegalInputs = []interface{}{\n \t3.14,\n \t[]byte(nil),\n \t\"foo!\",\n+\t`package p; func f() { if /* should have condition */ {} };`,\n+\t`package p; func f() { if ; /* should have condition */ {} };`,\n+\t`package p; func f() { if f(); /* should have condition */ {} };`,\n }\n \n \n@@ -32,20 +35,23 @@ func TestParseIllegalInputs(t *testing.T) {\n \n \n var validPrograms = []interface{}{\n-\t\"package main\\n\",\n-\t`package main;`,\n-\t`package main; import \"fmt\"; func main() { fmt.Println(\"Hello, World!\") };`,\n-\t`package main; func main() { if f(T{}) {} };`,\n-\t`package main; func main() { _ = (<-chan int)(x) };`,\n-\t`package main; func main() { _ = (<-chan <-chan int)(x) };`,\n-\t`package main; func f(func() func() func());`,\n-\t`package main; func f(...T);`,\n-\t`package main; func f(float, ...int);`,\n-\t`package main; func f(x int, a ...int) { f(0, a...); f(1, a...,) };`,\n-\t`package main; type T []int; var a []bool; func f() { if a[T{42}[0]] {} };`,\n-\t`package main; type T []int; func g(int) bool { return true }; func f() { if g(T{42}[0]) {} };`,\n-\t`package main; type T []int; func f() { for _ = range []int{T{42}[0]} {} };`,\n-\t`package main; var a = T{{1, 2}, {3, 4}}`,\n+\t\"package p\\n\",\n+\t`package p;`,\n+\t`package p; import \"fmt\"; func f() { fmt.Println(\"Hello, World!\") };`,\n+\t`package p; func f() { if f(T{}) {} };`,\n+\t`package p; func f() { _ = (<-chan int)(x) };`,\n+\t`package p; func f() { _ = (<-chan <-chan int)(x) };`,\n+\t`package p; func f(func() func() func());`,\n+\t`package p; func f(...T);`,\n+\t`package p; func f(float, ...int);`,\n+\t`package p; func f(x int, a ...int) { f(0, a...); f(1, a...,) };`,\n+\t`package p; type T []int; var a []bool; func f() { if a[T{42}[0]] {} };`,\n+\t`package p; type T []int; func g(int) bool { return true }; func f() { if g(T{42}[0]) {} };`,\n+\t`package p; type T []int; func f() { for _ = range []int{T{42}[0]} {} };`,\n+\t`package p; var a = T{{1, 2}, {3, 4}}`,\n+\t`package p; func f() { select { case <- c: case c <- d: case c <- <- d: case <-c <- d: } };`,\n+\t`package p; func f() { if ; true {} };`,\n+\t`package p; func f() { switch ; {} };`,\n }\n \n "}, {"sha": "7933c2f182003a0ab631d5c785b005bcf2b9bed1", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -506,12 +506,12 @@ const (\n )\n \n \n-func walkBinary(e *ast.BinaryExpr) (has5, has6 bool, maxProblem int) {\n+func walkBinary(e *ast.BinaryExpr) (has4, has5 bool, maxProblem int) {\n \tswitch e.Op.Precedence() {\n+\tcase 4:\n+\t\thas4 = true\n \tcase 5:\n \t\thas5 = true\n-\tcase 6:\n-\t\thas6 = true\n \t}\n \n \tswitch l := e.X.(type) {\n@@ -521,9 +521,9 @@ func walkBinary(e *ast.BinaryExpr) (has5, has6 bool, maxProblem int) {\n \t\t\t// pretend this is an *ast.ParenExpr and do nothing.\n \t\t\tbreak\n \t\t}\n-\t\th5, h6, mp := walkBinary(l)\n+\t\th4, h5, mp := walkBinary(l)\n+\t\thas4 = has4 || h4\n \t\thas5 = has5 || h5\n-\t\thas6 = has6 || h6\n \t\tif maxProblem < mp {\n \t\t\tmaxProblem = mp\n \t\t}\n@@ -536,25 +536,25 @@ func walkBinary(e *ast.BinaryExpr) (has5, has6 bool, maxProblem int) {\n \t\t\t// pretend this is an *ast.ParenExpr and do nothing.\n \t\t\tbreak\n \t\t}\n-\t\th5, h6, mp := walkBinary(r)\n+\t\th4, h5, mp := walkBinary(r)\n+\t\thas4 = has4 || h4\n \t\thas5 = has5 || h5\n-\t\thas6 = has6 || h6\n \t\tif maxProblem < mp {\n \t\t\tmaxProblem = mp\n \t\t}\n \n \tcase *ast.StarExpr:\n \t\tif e.Op.String() == \"/\" {\n-\t\t\tmaxProblem = 6\n+\t\t\tmaxProblem = 5\n \t\t}\n \n \tcase *ast.UnaryExpr:\n \t\tswitch e.Op.String() + r.Op.String() {\n \t\tcase \"/*\", \"&&\", \"&^\":\n-\t\t\tmaxProblem = 6\n+\t\t\tmaxProblem = 5\n \t\tcase \"++\", \"--\":\n-\t\t\tif maxProblem < 5 {\n-\t\t\t\tmaxProblem = 5\n+\t\t\tif maxProblem < 4 {\n+\t\t\t\tmaxProblem = 4\n \t\t\t}\n \t\t}\n \t}\n@@ -563,20 +563,20 @@ func walkBinary(e *ast.BinaryExpr) (has5, has6 bool, maxProblem int) {\n \n \n func cutoff(e *ast.BinaryExpr, depth int) int {\n-\thas5, has6, maxProblem := walkBinary(e)\n+\thas4, has5, maxProblem := walkBinary(e)\n \tif maxProblem > 0 {\n \t\treturn maxProblem + 1\n \t}\n-\tif has5 && has6 {\n+\tif has4 && has5 {\n \t\tif depth == 1 {\n-\t\t\treturn 6\n+\t\t\treturn 5\n \t\t}\n-\t\treturn 5\n+\t\treturn 4\n \t}\n \tif depth == 1 {\n-\t\treturn 7\n+\t\treturn 6\n \t}\n-\treturn 5\n+\treturn 4\n }\n \n \n@@ -603,37 +603,36 @@ func reduceDepth(depth int) int {\n // (Algorithm suggestion by Russ Cox.)\n //\n // The precedences are:\n-//\t6             *  /  %  <<  >>  &  &^\n-//\t5             +  -  |  ^\n-//\t4             ==  !=  <  <=  >  >=\n-//\t3             <-\n+//\t5             *  /  %  <<  >>  &  &^\n+//\t4             +  -  |  ^\n+//\t3             ==  !=  <  <=  >  >=\n //\t2             &&\n //\t1             ||\n //\n-// The only decision is whether there will be spaces around levels 5 and 6.\n-// There are never spaces at level 7 (unary), and always spaces at levels 4 and below.\n+// The only decision is whether there will be spaces around levels 4 and 5.\n+// There are never spaces at level 6 (unary), and always spaces at levels 3 and below.\n //\n // To choose the cutoff, look at the whole expression but excluding primary\n // expressions (function calls, parenthesized exprs), and apply these rules:\n //\n //\t1) If there is a binary operator with a right side unary operand\n //\t   that would clash without a space, the cutoff must be (in order):\n //\n-//\t\t/*\t7\n-//\t\t&&\t7\n-//\t\t&^\t7\n-//\t\t++\t6\n-//\t\t--\t6\n+//\t\t/*\t6\n+//\t\t&&\t6\n+//\t\t&^\t6\n+//\t\t++\t5\n+//\t\t--\t5\n //\n //         (Comparison operators always have spaces around them.)\n //\n-//\t2) If there is a mix of level 6 and level 5 operators, then the cutoff\n-//\t   is 6 (use spaces to distinguish precedence) in Normal mode\n-//\t   and 5 (never use spaces) in Compact mode.\n+//\t2) If there is a mix of level 5 and level 4 operators, then the cutoff\n+//\t   is 5 (use spaces to distinguish precedence) in Normal mode\n+//\t   and 4 (never use spaces) in Compact mode.\n //\n-//\t3) If there are no level 5 operators or no level 6 operators, then the\n-//\t   cutoff is 7 (always use spaces) in Normal mode\n-//\t   and 5 (never use spaces) in Compact mode.\n+//\t3) If there are no level 4 operators or no level 5 operators, then the\n+//\t   cutoff is 6 (always use spaces) in Normal mode\n+//\t   and 4 (never use spaces) in Compact mode.\n //\n // Sets multiLine to true if the binary expression spans multiple lines.\n func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiLine *bool) {\n@@ -1083,6 +1082,12 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\tconst depth = 1\n \t\tp.expr0(s.X, depth, multiLine)\n \n+\tcase *ast.SendStmt:\n+\t\tconst depth = 1\n+\t\tp.expr0(s.Chan, depth, multiLine)\n+\t\tp.print(blank, s.Arrow, token.ARROW, blank)\n+\t\tp.expr0(s.Value, depth, multiLine)\n+\n \tcase *ast.IncDecStmt:\n \t\tconst depth = 1\n \t\tp.expr0(s.X, depth+1, multiLine)\n@@ -1179,13 +1184,9 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\t*multiLine = true\n \n \tcase *ast.CommClause:\n-\t\tif s.Rhs != nil {\n+\t\tif s.Comm != nil {\n \t\t\tp.print(token.CASE, blank)\n-\t\t\tif s.Lhs != nil {\n-\t\t\t\tp.expr(s.Lhs, multiLine)\n-\t\t\t\tp.print(blank, s.Tok, blank)\n-\t\t\t}\n-\t\t\tp.expr(s.Rhs, multiLine)\n+\t\t\tp.stmt(s.Comm, false, ignoreMultiLine)\n \t\t} else {\n \t\t\tp.print(token.DEFAULT)\n \t\t}"}, {"sha": "48e2af1b736af7ac1b74fea78b38d9fca17792b8", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 113, "deletions": 168, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -34,18 +34,18 @@ const (\n )\n \n \n+const (\n+\tesc2 = '\\xfe'                        // an escape byte that cannot occur in regular UTF-8\n+\t_    = 1 / (esc2 - tabwriter.Escape) // cause compiler error if esc2 == tabwriter.Escape\n+)\n+\n+\n var (\n \tesc       = []byte{tabwriter.Escape}\n \thtab      = []byte{'\\t'}\n \thtabs     = []byte(\"\\t\\t\\t\\t\\t\\t\\t\\t\")\n \tnewlines  = []byte(\"\\n\\n\\n\\n\\n\\n\\n\\n\") // more than the max determined by nlines\n \tformfeeds = []byte(\"\\f\\f\\f\\f\\f\\f\\f\\f\") // more than the max determined by nlines\n-\n-\tesc_quot = []byte(\"&#34;\") // shorter than \"&quot;\"\n-\tesc_apos = []byte(\"&#39;\") // shorter than \"&apos;\"\n-\tesc_amp  = []byte(\"&amp;\")\n-\tesc_lt   = []byte(\"&lt;\")\n-\tesc_gt   = []byte(\"&gt;\")\n )\n \n \n@@ -145,18 +145,20 @@ func (p *printer) nlines(n, min int) int {\n // write0 does not indent after newlines, and does not HTML-escape or update p.pos.\n //\n func (p *printer) write0(data []byte) {\n-\tn, err := p.output.Write(data)\n-\tp.written += n\n-\tif err != nil {\n-\t\tp.errors <- err\n-\t\truntime.Goexit()\n+\tif len(data) > 0 {\n+\t\tn, err := p.output.Write(data)\n+\t\tp.written += n\n+\t\tif err != nil {\n+\t\t\tp.errors <- err\n+\t\t\truntime.Goexit()\n+\t\t}\n \t}\n }\n \n \n // write interprets data and writes it to p.output. It inserts indentation\n-// after a line break unless in a tabwriter escape sequence, and it HTML-\n-// escapes characters if GenHTML is set. It updates p.pos as a side-effect.\n+// after a line break unless in a tabwriter escape sequence.\n+// It updates p.pos as a side-effect.\n //\n func (p *printer) write(data []byte) {\n \ti0 := 0\n@@ -189,36 +191,6 @@ func (p *printer) write(data []byte) {\n \t\t\t// next segment start\n \t\t\ti0 = i + 1\n \n-\t\tcase '\"', '\\'', '&', '<', '>':\n-\t\t\tif p.Mode&GenHTML != 0 {\n-\t\t\t\t// write segment ending in b\n-\t\t\t\tp.write0(data[i0:i])\n-\n-\t\t\t\t// write HTML-escaped b\n-\t\t\t\tvar esc []byte\n-\t\t\t\tswitch b {\n-\t\t\t\tcase '\"':\n-\t\t\t\t\tesc = esc_quot\n-\t\t\t\tcase '\\'':\n-\t\t\t\t\tesc = esc_apos\n-\t\t\t\tcase '&':\n-\t\t\t\t\tesc = esc_amp\n-\t\t\t\tcase '<':\n-\t\t\t\t\tesc = esc_lt\n-\t\t\t\tcase '>':\n-\t\t\t\t\tesc = esc_gt\n-\t\t\t\t}\n-\t\t\t\tp.write0(esc)\n-\n-\t\t\t\t// update p.pos\n-\t\t\t\td := i + 1 - i0\n-\t\t\t\tp.pos.Offset += d\n-\t\t\t\tp.pos.Column += d\n-\n-\t\t\t\t// next segment start\n-\t\t\t\ti0 = i + 1\n-\t\t\t}\n-\n \t\tcase tabwriter.Escape:\n \t\t\tp.mode ^= inLiteral\n \n@@ -251,29 +223,13 @@ func (p *printer) writeNewlines(n int, useFF bool) {\n }\n \n \n-func (p *printer) writeTaggedItem(data []byte, tag HTMLTag) {\n-\t// write start tag, if any\n-\t// (no html-escaping and no p.pos update for tags - use write0)\n-\tif tag.Start != \"\" {\n-\t\tp.write0([]byte(tag.Start))\n-\t}\n-\tp.write(data)\n-\t// write end tag, if any\n-\tif tag.End != \"\" {\n-\t\tp.write0([]byte(tag.End))\n-\t}\n-}\n-\n-\n // writeItem writes data at position pos. data is the text corresponding to\n // a single lexical token, but may also be comment text. pos is the actual\n // (or at least very accurately estimated) position of the data in the original\n-// source text. If tags are present and GenHTML is set, the tags are written\n-// before and after the data. writeItem updates p.last to the position\n-// immediately following the data.\n+// source text. writeItem updates p.last to the position immediately following\n+// the data.\n //\n-func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {\n-\tfileChanged := false\n+func (p *printer) writeItem(pos token.Position, data []byte) {\n \tif pos.IsValid() {\n \t\t// continue with previous position if we don't have a valid pos\n \t\tif p.last.IsValid() && p.last.Filename != pos.Filename {\n@@ -283,7 +239,6 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {\n \t\t\tp.indent = 0\n \t\t\tp.mode = 0\n \t\t\tp.buffer = p.buffer[0:0]\n-\t\t\tfileChanged = true\n \t\t}\n \t\tp.pos = pos\n \t}\n@@ -292,18 +247,7 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {\n \t\t_, filename := path.Split(pos.Filename)\n \t\tp.write0([]byte(fmt.Sprintf(\"[%s:%d:%d]\", filename, pos.Line, pos.Column)))\n \t}\n-\tif p.Mode&GenHTML != 0 {\n-\t\t// write line tag if on a new line\n-\t\t// TODO(gri): should write line tags on each line at the start\n-\t\t//            will be more useful (e.g. to show line numbers)\n-\t\tif p.Styler != nil && (pos.Line != p.lastTaggedLine || fileChanged) {\n-\t\t\tp.writeTaggedItem(p.Styler.LineTag(pos.Line))\n-\t\t\tp.lastTaggedLine = pos.Line\n-\t\t}\n-\t\tp.writeTaggedItem(data, tag)\n-\t} else {\n-\t\tp.write(data)\n-\t}\n+\tp.write(data)\n \tp.last = p.pos\n }\n \n@@ -312,14 +256,13 @@ func (p *printer) writeItem(pos token.Position, data []byte, tag HTMLTag) {\n // If there is any pending whitespace, it consumes as much of\n // it as is likely to help position the comment nicely.\n // pos is the comment position, next the position of the item\n-// after all pending comments, isFirst indicates if this is the\n-// first comment in a group of comments, and isKeyword indicates\n-// if the next item is a keyword.\n+// after all pending comments, prev is the previous comment in\n+// a group of comments (or nil), and isKeyword indicates if the\n+// next item is a keyword.\n //\n-func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeyword bool) {\n-\tif !p.last.IsValid() {\n-\t\t// there was no preceeding item and the comment is the\n-\t\t// first item to be printed - don't write any whitespace\n+func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment, isKeyword bool) {\n+\tif p.written == 0 {\n+\t\t// the comment is the first item to be printed - don't write any whitespace\n \t\treturn\n \t}\n \n@@ -329,11 +272,12 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor\n \t\treturn\n \t}\n \n-\tif pos.IsValid() && pos.Line == p.last.Line {\n+\tif pos.Line == p.last.Line && (prev == nil || prev.Text[1] != '/') {\n \t\t// comment on the same line as last item:\n \t\t// separate with at least one separator\n \t\thasSep := false\n-\t\tif isFirst {\n+\t\tif prev == nil {\n+\t\t\t// first comment of a comment group\n \t\t\tj := 0\n \t\t\tfor i, ch := range p.buffer {\n \t\t\t\tswitch ch {\n@@ -370,7 +314,8 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor\n \t} else {\n \t\t// comment on a different line:\n \t\t// separate with at least one line break\n-\t\tif isFirst {\n+\t\tif prev == nil {\n+\t\t\t// first comment of a comment group\n \t\t\tj := 0\n \t\t\tfor i, ch := range p.buffer {\n \t\t\t\tswitch ch {\n@@ -402,32 +347,25 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, isFirst, isKeywor\n \t\t}\n \t\t// use formfeeds to break columns before a comment;\n \t\t// this is analogous to using formfeeds to separate\n-\t\t// individual lines of /*-style comments\n-\t\t// (if !pos.IsValid(), pos.Line == 0, and this will\n-\t\t// print no newlines)\n-\t\tp.writeNewlines(pos.Line-p.last.Line, true)\n+\t\t// individual lines of /*-style comments - but make\n+\t\t// sure there is at least one line break if the previous\n+\t\t// comment was a line comment\n+\t\tn := pos.Line - p.last.Line // if !pos.IsValid(), pos.Line == 0, and n will be 0\n+\t\tif n <= 0 && prev != nil && prev.Text[1] == '/' {\n+\t\t\tn = 1\n+\t\t}\n+\t\tp.writeNewlines(n, true)\n \t}\n }\n \n \n func (p *printer) writeCommentLine(comment *ast.Comment, pos token.Position, line []byte) {\n \t// line must pass through unchanged, bracket it with tabwriter.Escape\n \tline = bytes.Join([][]byte{esc, line, esc}, nil)\n-\n-\t// apply styler, if any\n-\tvar tag HTMLTag\n-\tif p.Styler != nil {\n-\t\tline, tag = p.Styler.Comment(comment, line)\n-\t}\n-\n-\tp.writeItem(pos, line, tag)\n+\tp.writeItem(pos, line)\n }\n \n \n-// TODO(gri): Similar (but not quite identical) functionality for\n-//            comment processing can be found in go/doc/comment.go.\n-//            Perhaps this can be factored eventually.\n-\n // Split comment text into lines\n func split(text []byte) [][]byte {\n \t// count lines (comment text never ends in a newline)\n@@ -680,7 +618,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (dro\n \tvar last *ast.Comment\n \tfor ; p.commentBefore(next); p.cindex++ {\n \t\tfor _, c := range p.comments[p.cindex].List {\n-\t\t\tp.writeCommentPrefix(p.fset.Position(c.Pos()), next, last == nil, tok.IsKeyword())\n+\t\t\tp.writeCommentPrefix(p.fset.Position(c.Pos()), next, last, tok.IsKeyword())\n \t\t\tp.writeComment(c)\n \t\t\tlast = c\n \t\t}\n@@ -796,7 +734,6 @@ func (p *printer) print(args ...interface{}) {\n \tfor _, f := range args {\n \t\tnext := p.pos // estimated position of next item\n \t\tvar data []byte\n-\t\tvar tag HTMLTag\n \t\tvar tok token.Token\n \n \t\tswitch x := f.(type) {\n@@ -821,28 +758,31 @@ func (p *printer) print(args ...interface{}) {\n \t\t\tp.buffer = p.buffer[0 : i+1]\n \t\t\tp.buffer[i] = x\n \t\tcase *ast.Ident:\n-\t\t\tif p.Styler != nil {\n-\t\t\t\tdata, tag = p.Styler.Ident(x)\n-\t\t\t} else {\n-\t\t\t\tdata = []byte(x.Name)\n-\t\t\t}\n+\t\t\tdata = []byte(x.Name)\n \t\t\ttok = token.IDENT\n \t\tcase *ast.BasicLit:\n-\t\t\tif p.Styler != nil {\n-\t\t\t\tdata, tag = p.Styler.BasicLit(x)\n-\t\t\t} else {\n-\t\t\t\tdata = x.Value\n-\t\t\t}\n \t\t\t// escape all literals so they pass through unchanged\n \t\t\t// (note that valid Go programs cannot contain\n \t\t\t// tabwriter.Escape bytes since they do not appear in\n \t\t\t// legal UTF-8 sequences)\n-\t\t\tescData := make([]byte, 0, len(data)+2)\n-\t\t\tescData = append(escData, tabwriter.Escape)\n-\t\t\tescData = append(escData, data...)\n-\t\t\tescData = append(escData, tabwriter.Escape)\n-\t\t\tdata = escData\n+\t\t\tdata = make([]byte, 0, len(x.Value)+2)\n+\t\t\tdata = append(data, tabwriter.Escape)\n+\t\t\tdata = append(data, x.Value...)\n+\t\t\tdata = append(data, tabwriter.Escape)\n \t\t\ttok = x.Kind\n+\t\t\t// If we have a raw string that spans multiple lines and\n+\t\t\t// the opening quote (`) is on a line preceded only by\n+\t\t\t// indentation, we don't want to write that indentation\n+\t\t\t// because the following lines of the raw string are not\n+\t\t\t// indented. It's easiest to correct the output at the end\n+\t\t\t// via the trimmer (because of the complex handling of\n+\t\t\t// white space).\n+\t\t\t// Mark multi-line raw strings by replacing the opening\n+\t\t\t// quote with esc2 and have the trimmer take care of fixing\n+\t\t\t// it up. (Do this _after_ making a copy of data!)\n+\t\t\tif data[1] == '`' && bytes.IndexByte(data, '\\n') > 0 {\n+\t\t\t\tdata[1] = esc2\n+\t\t\t}\n \t\tcase token.Token:\n \t\t\ts := x.String()\n \t\t\tif mayCombine(p.lastTok, s[0]) {\n@@ -858,11 +798,7 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\tp.buffer = p.buffer[0:1]\n \t\t\t\tp.buffer[0] = ' '\n \t\t\t}\n-\t\t\tif p.Styler != nil {\n-\t\t\t\tdata, tag = p.Styler.Token(x)\n-\t\t\t} else {\n-\t\t\t\tdata = []byte(s)\n-\t\t\t}\n+\t\t\tdata = []byte(s)\n \t\t\ttok = x\n \t\tcase token.Pos:\n \t\t\tif x.IsValid() {\n@@ -885,7 +821,7 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t// before\n \t\t\tp.writeNewlines(next.Line-p.pos.Line, droppedFF)\n \n-\t\t\tp.writeItem(next, data, tag)\n+\t\t\tp.writeItem(next, data)\n \t\t}\n \t}\n }\n@@ -927,29 +863,40 @@ func (p *printer) flush(next token.Position, tok token.Token) (droppedFF bool) {\n // through unchanged.\n //\n type trimmer struct {\n-\toutput io.Writer\n-\tspace  bytes.Buffer\n-\tstate  int\n+\toutput  io.Writer\n+\tstate   int\n+\tspace   bytes.Buffer\n+\thasText bool\n }\n \n \n // trimmer is implemented as a state machine.\n // It can be in one of the following states:\n const (\n-\tinSpace = iota\n-\tinEscape\n-\tinText\n+\tinSpace  = iota // inside space\n+\tatEscape        // inside space and the last char was an opening tabwriter.Escape\n+\tinEscape        // inside text bracketed by tabwriter.Escapes\n+\tinText          // inside text\n )\n \n \n+var backquote = []byte{'`'}\n+\n+\n // Design note: It is tempting to eliminate extra blanks occurring in\n //              whitespace in this function as it could simplify some\n //              of the blanks logic in the node printing functions.\n //              However, this would mess up any formatting done by\n //              the tabwriter.\n \n func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n-\tm := 0 // if p.state != inSpace, data[m:n] is unwritten\n+\t// invariants:\n+\t// p.state == inSpace, atEscape:\n+\t//\tp.space is unwritten\n+\t//\tp.hasText indicates if there is any text on this line\n+\t// p.state == inEscape, inText:\n+\t//\tdata[m:n] is unwritten\n+\tm := 0\n \tvar b byte\n \tfor n, b = range data {\n \t\tif b == '\\v' {\n@@ -960,37 +907,55 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t\t\tswitch b {\n \t\t\tcase '\\t', ' ':\n \t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n-\t\t\tcase '\\f', '\\n':\n+\t\t\tcase '\\n', '\\f':\n \t\t\t\tp.space.Reset()                        // discard trailing space\n \t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n+\t\t\t\tp.hasText = false\n \t\t\tcase tabwriter.Escape:\n-\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n-\t\t\t\tp.space.Reset()\n-\t\t\t\tp.state = inEscape\n-\t\t\t\tm = n + 1 // drop tabwriter.Escape\n+\t\t\t\tp.state = atEscape\n \t\t\tdefault:\n \t\t\t\t_, err = p.output.Write(p.space.Bytes())\n-\t\t\t\tp.space.Reset()\n \t\t\t\tp.state = inText\n \t\t\t\tm = n\n \t\t\t}\n+\t\tcase atEscape:\n+\t\t\t// discard indentation if we have a multi-line raw string\n+\t\t\t// (see printer.print for details)\n+\t\t\tif b != esc2 || p.hasText {\n+\t\t\t\t_, err = p.output.Write(p.space.Bytes())\n+\t\t\t}\n+\t\t\tp.state = inEscape\n+\t\t\tm = n\n+\t\t\tif b == esc2 {\n+\t\t\t\t_, err = p.output.Write(backquote) // convert back\n+\t\t\t\tm++\n+\t\t\t}\n \t\tcase inEscape:\n \t\t\tif b == tabwriter.Escape {\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inSpace\n+\t\t\t\tp.space.Reset()\n+\t\t\t\tp.hasText = true\n \t\t\t}\n \t\tcase inText:\n \t\t\tswitch b {\n \t\t\tcase '\\t', ' ':\n \t\t\t\t_, err = p.output.Write(data[m:n])\n \t\t\t\tp.state = inSpace\n+\t\t\t\tp.space.Reset()\n \t\t\t\tp.space.WriteByte(b) // WriteByte returns no errors\n-\t\t\tcase '\\f':\n-\t\t\t\tdata[n] = '\\n' // convert to newline\n+\t\t\t\tp.hasText = true\n+\t\t\tcase '\\n', '\\f':\n+\t\t\t\t_, err = p.output.Write(data[m:n])\n+\t\t\t\tp.state = inSpace\n+\t\t\t\tp.space.Reset()\n+\t\t\t\t_, err = p.output.Write(newlines[0:1]) // write newline\n+\t\t\t\tp.hasText = false\n \t\t\tcase tabwriter.Escape:\n \t\t\t\t_, err = p.output.Write(data[m:n])\n-\t\t\t\tp.state = inEscape\n-\t\t\t\tm = n + 1 // drop tabwriter.Escape\n+\t\t\t\tp.state = atEscape\n+\t\t\t\tp.space.Reset()\n+\t\t\t\tp.hasText = true\n \t\t\t}\n \t\t}\n \t\tif err != nil {\n@@ -999,9 +964,12 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \t}\n \tn = len(data)\n \n-\tif p.state != inSpace {\n+\tswitch p.state {\n+\tcase inEscape, inText:\n \t\t_, err = p.output.Write(data[m:n])\n \t\tp.state = inSpace\n+\t\tp.space.Reset()\n+\t\tp.hasText = true\n \t}\n \n \treturn\n@@ -1013,36 +981,16 @@ func (p *trimmer) Write(data []byte) (n int, err os.Error) {\n \n // General printing is controlled with these Config.Mode flags.\n const (\n-\tGenHTML   uint = 1 << iota // generate HTML\n-\tRawFormat                  // do not use a tabwriter; if set, UseSpaces is ignored\n+\tRawFormat uint = 1 << iota // do not use a tabwriter; if set, UseSpaces is ignored\n \tTabIndent                  // use tabs for indentation independent of UseSpaces\n \tUseSpaces                  // use spaces instead of tabs for alignment\n )\n \n \n-// An HTMLTag specifies a start and end tag.\n-type HTMLTag struct {\n-\tStart, End string // empty if tags are absent\n-}\n-\n-\n-// A Styler specifies formatting of line tags and elementary Go words.\n-// A format consists of text and a (possibly empty) surrounding HTML tag.\n-//\n-type Styler interface {\n-\tLineTag(line int) ([]byte, HTMLTag)\n-\tComment(c *ast.Comment, line []byte) ([]byte, HTMLTag)\n-\tBasicLit(x *ast.BasicLit) ([]byte, HTMLTag)\n-\tIdent(id *ast.Ident) ([]byte, HTMLTag)\n-\tToken(tok token.Token) ([]byte, HTMLTag)\n-}\n-\n-\n // A Config node controls the output of Fprint.\n type Config struct {\n-\tMode     uint   // default: 0\n-\tTabwidth int    // default: 8\n-\tStyler   Styler // default: nil\n+\tMode     uint // default: 0\n+\tTabwidth int  // default: 8\n }\n \n \n@@ -1070,9 +1018,6 @@ func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{\n \t\t}\n \n \t\ttwmode := tabwriter.DiscardEmptyColumns\n-\t\tif cfg.Mode&GenHTML != 0 {\n-\t\t\ttwmode |= tabwriter.FilterHTML\n-\t\t}\n \t\tif cfg.Mode&TabIndent != 0 {\n \t\t\tminwidth = 0\n \t\t\ttwmode |= tabwriter.TabIndent"}, {"sha": "565075aa20cd948ee07db7c33679fcdb48108b16", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -127,7 +127,7 @@ var data = []entry{\n }\n \n \n-func Test(t *testing.T) {\n+func TestFiles(t *testing.T) {\n \tfor _, e := range data {\n \t\tsource := path.Join(dataDir, e.source)\n \t\tgolden := path.Join(dataDir, e.golden)\n@@ -136,3 +136,38 @@ func Test(t *testing.T) {\n \t\t//check(t, golden, golden, e.mode);\n \t}\n }\n+\n+\n+// TestLineComments, using a simple test case, checks that consequtive line\n+// comments are properly terminated with a newline even if the AST position\n+// information is incorrect.\n+//\n+func TestLineComments(t *testing.T) {\n+\tconst src = `// comment 1\n+\t// comment 2\n+\t// comment 3\n+\tpackage main\n+\t`\n+\n+\tfset := token.NewFileSet()\n+\tast1, err1 := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n+\tif err1 != nil {\n+\t\tpanic(err1)\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tfset = token.NewFileSet() // use the wrong file set\n+\tFprint(&buf, fset, ast1)\n+\n+\tnlines := 0\n+\tfor _, ch := range buf.Bytes() {\n+\t\tif ch == '\\n' {\n+\t\t\tnlines++\n+\t\t}\n+\t}\n+\n+\tconst expected = 3\n+\tif nlines < expected {\n+\t\tt.Errorf(\"got %d, expected %d\\n\", nlines, expected)\n+\t}\n+}"}, {"sha": "7f18f338a633ccf8fc45a4e434b1d61b10e55e44", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -247,6 +247,77 @@ they must not be removed`\n }\n \n \n+func _() {\n+\t// smart handling of indentation for multi-line raw strings\n+\tvar _ = ``\n+\tvar _ = `foo`\n+\tvar _ = `foo\n+bar`\n+\n+\tvar _ = ``\n+\tvar _ = `foo`\n+\tvar _ =\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar _ =\t// comment\n+\t``\n+\tvar _ =\t// comment\n+\t`foo`\n+\tvar _ =\t// comment\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar _ = /* comment */ ``\n+\tvar _ = /* comment */ `foo`\n+\tvar _ = /* comment */ `foo\n+bar`\n+\n+\tvar _ =\t/* comment */\n+\t``\n+\tvar _ =\t/* comment */\n+\t`foo`\n+\tvar _ =\t/* comment */\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar board = []int(\n+`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`)\n+\n+\tvar state = S{\n+\t\t\"foo\",\n+\t\t// the next line should not be indented\n+`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`,\n+\t\t\"bar\",\n+\t}\n+}\n+\n+\n func _() {\n \t// one-line function literals (body is on a single line)\n \t_ = func() {}"}, {"sha": "6bcd9b5f89ebd37a2d368c342e9026e7db952886", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -243,6 +243,85 @@ they must not be removed`\n }\n \n \n+func _() {\n+\t// smart handling of indentation for multi-line raw strings\n+\tvar _ = ``\n+\tvar _ = `foo`\n+\tvar _ = `foo\n+bar`\n+\n+\n+var _ =\n+\t``\n+var _ =\n+\t`foo`\n+var _ =\n+\t// the next line should not be indented\n+\t`foo\n+bar`\n+\n+\n+\tvar _ = // comment\n+\t\t``\n+\tvar _ = // comment\n+\t\t`foo`\n+\tvar _ = // comment\n+\t\t// the next line should not be indented\n+\t\t`foo\n+bar`\n+\n+\n+var _ = /* comment */ ``\n+var _ = /* comment */ `foo`\n+var _ = /* comment */ `foo\n+bar`\n+\n+\n+\tvar _ = /* comment */\n+\t\t``\n+\tvar _ = /* comment */\n+\t\t`foo`\n+\tvar _ = /* comment */\n+\t\t// the next line should not be indented\n+\t\t`foo\n+bar`\n+\n+\n+var board = []int(\n+\t`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`)\n+\n+\n+\tvar state = S{\n+\t\t\"foo\",\n+\t\t// the next line should not be indented\n+\t\t`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`,\n+\t\t\"bar\",\n+\t}\n+}\n+\n+\n func _() {\n \t// one-line function literals (body is on a single line)\n \t_ = func() {}"}, {"sha": "f1944c94bb4d9ebd3fbac8fc480cf9e204d433c1", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -243,7 +243,77 @@ func _() {\n \t_ = `foo\n \t\tbar`\n \t_ = `three spaces before the end of the line starting here:   \n-they must not be removed`\n+they must not be removed`\f}\n+\n+\n+func _() {\n+\t// smart handling of indentation for multi-line raw strings\n+\tvar _ = ``\n+\tvar _ = `foo`\n+\tvar _ = `foo\n+bar`\n+\n+\tvar _ = ``\n+\tvar _ = `foo`\n+\tvar _ =\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar _ =\t// comment\n+\t``\n+\tvar _ =\t// comment\n+\t`foo`\n+\tvar _ =\t// comment\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar _ = /* comment */ ``\n+\tvar _ = /* comment */ `foo`\n+\tvar _ = /* comment */ `foo\n+bar`\n+\n+\tvar _ =\t/* comment */\n+\t``\n+\tvar _ =\t/* comment */\n+\t`foo`\n+\tvar _ =\t/* comment */\n+\t// the next line should not be indented\n+`foo\n+bar`\n+\n+\tvar board = []int(\n+`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`)\n+\n+\tvar state = S{\n+\t\t\"foo\",\n+\t\t// the next line should not be indented\n+`...........\n+...........\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cb\u25cf\u25cf\u25cf..\n+..\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf\u25cf..\n+....\u25cf\u25cf\u25cf....\n+....\u25cf\u25cf\u25cf....\n+...........\n+...........\n+`,\n+\t\t\"bar\",\n+\t}\n }\n \n "}, {"sha": "2900602699ffbd0450b6cb100fb8059e59708974", "filename": "libgo/go/go/printer/testdata/statements.golden", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.golden?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -10,9 +10,9 @@ func use(x interface{})\t{}\n \n // Formatting of if-statement headers.\n func _() {\n-\tif {\n+\tif true {\n \t}\n-\tif {\n+\tif true {\n \t}\t// no semicolon printed\n \tif expr {\n \t}\n@@ -22,7 +22,7 @@ func _() {\n \t}\t// no parens printed\n \tif expr {\n \t}\t// no semicolon and parens printed\n-\tif x := expr; {\n+\tif x := expr; true {\n \t\tuse(x)\n \t}\n \tif x := expr; expr {\n@@ -354,14 +354,14 @@ func _() {\n \n \n func _() {\n-\tif {\n+\tif true {\n \t\t_ = 0\n \t}\n \t_ = 0\t// the indentation here should not be affected by the long label name\n AnOverlongLabel:\n \t_ = 0\n \n-\tif {\n+\tif true {\n \t\t_ = 0\n \t}\n \t_ = 0"}, {"sha": "21e61efc4f8f308d38bde6d6eb60f8fd59212217", "filename": "libgo/go/go/printer/testdata/statements.input", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fstatements.input?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -10,13 +10,13 @@ func use(x interface{}) {}\n \n // Formatting of if-statement headers.\n func _() {\n-\tif {}\n-\tif;{}  // no semicolon printed\n+\tif true {}\n+\tif; true {}  // no semicolon printed\n \tif expr{}\n \tif;expr{}  // no semicolon printed\n \tif (expr){}  // no parens printed\n \tif;((expr)){}  // no semicolon and parens printed\n-\tif x:=expr;{\n+\tif x:=expr;true{\n \tuse(x)}\n \tif x:=expr; expr {use(x)}\n }\n@@ -271,14 +271,14 @@ func _() {\n \n \n func _() {\n-\tif {\n+\tif true {\n \t\t_ = 0\n \t}\n \t_ = 0  // the indentation here should not be affected by the long label name\n AnOverlongLabel:\n \t_ = 0\n \t\n-\tif {\n+\tif true {\n \t\t_ = 0\n \t}\n \t_ = 0"}, {"sha": "2ae296b3f1595dbafd42590380725a4fa77b2d78", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -8,7 +8,8 @@\n //\n //\tvar s Scanner\n //\tfset := token.NewFileSet()  // position information is relative to fset\n-//\ts.Init(fset, filename, src, nil /* no error handler */, 0)\n+//      file := fset.AddFile(filename, fset.Base(), len(src))  // register file\n+//\ts.Init(file, src, nil /* no error handler */, 0)\n //\tfor {\n //\t\tpos, tok, lit := s.Scan()\n //\t\tif tok == token.EOF {"}, {"sha": "c622ff482f34bb19d68751f5f2f15787b332f929", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -223,7 +223,7 @@ func TestScan(t *testing.T) {\n \tfor _, e := range tokens {\n \t\tsrc += e.lit + whitespace\n \t}\n-\tsrc_linecount := newlineCount(src) + 1\n+\tsrc_linecount := newlineCount(src)\n \twhitespace_linecount := newlineCount(whitespace)\n \n \t// verify scan\n@@ -241,7 +241,7 @@ func TestScan(t *testing.T) {\n \t\tif tok == token.EOF {\n \t\t\tlit = \"<EOF>\"\n \t\t\tepos.Line = src_linecount\n-\t\t\tepos.Column = 1\n+\t\t\tepos.Column = 2\n \t\t}\n \t\tcheckPos(t, lit, pos, epos)\n \t\tif tok != e.tok {"}, {"sha": "809e53f0aa23d673be3929284ffbf68c07f82edc", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -153,15 +153,15 @@ type lineInfo struct {\n \n // AddLineInfo adds alternative file and line number information for\n // a given file offset. The offset must be larger than the offset for\n-// the previously added alternative line info and not larger than the\n+// the previously added alternative line info and smaller than the\n // file size; otherwise the information is ignored.\n //\n // AddLineInfo is typically used to register alternative position\n // information for //line filename:line comments in source files.\n //\n func (f *File) AddLineInfo(offset int, filename string, line int) {\n \tf.set.mutex.Lock()\n-\tif i := len(f.infos); i == 0 || f.infos[i-1].offset < offset && offset <= f.size {\n+\tif i := len(f.infos); i == 0 || f.infos[i-1].offset < offset && offset < f.size {\n \t\tf.infos = append(f.infos, lineInfo{offset, filename, line})\n \t}\n \tf.set.mutex.Unlock()\n@@ -212,27 +212,30 @@ func (f *File) LineCount() int {\n \n // AddLine adds the line offset for a new line.\n // The line offset must be larger than the offset for the previous line\n-// and not larger than the file size; otherwise the line offset is ignored.\n+// and smaller than the file size; otherwise the line offset is ignored.\n //\n func (f *File) AddLine(offset int) {\n \tf.set.mutex.Lock()\n-\tif i := len(f.lines); (i == 0 || f.lines[i-1] < offset) && offset <= f.size {\n+\tif i := len(f.lines); (i == 0 || f.lines[i-1] < offset) && offset < f.size {\n \t\tf.lines = append(f.lines, offset)\n \t}\n \tf.set.mutex.Unlock()\n }\n \n \n-// SetLines sets all line offsets for a file and returns true if successful.\n+// SetLines sets the line offsets for a file and returns true if successful.\n+// The line offsets are the offsets of the first character of each line;\n+// for instance for the content \"ab\\nc\\n\" the line offsets are {0, 3}.\n+// An empty file has an empty line offset table.\n // Each line offset must be larger than the offset for the previous line\n-// and not larger than the file size; otherwise the SetLines fails and returns\n+// and smaller than the file size; otherwise SetLines fails and returns\n // false.\n //\n func (f *File) SetLines(lines []int) bool {\n \t// verify validity of lines table\n \tsize := f.size\n \tfor i, offset := range lines {\n-\t\tif i > 0 && offset <= lines[i-1] || size < offset {\n+\t\tif i > 0 && offset <= lines[i-1] || size <= offset {\n \t\t\treturn false\n \t\t}\n \t}\n@@ -245,6 +248,27 @@ func (f *File) SetLines(lines []int) bool {\n }\n \n \n+// SetLinesForContent sets the line offsets for the given file content.\n+func (f *File) SetLinesForContent(content []byte) {\n+\tvar lines []int\n+\tline := 0\n+\tfor offset, b := range content {\n+\t\tif line >= 0 {\n+\t\t\tlines = append(lines, line)\n+\t\t}\n+\t\tline = -1\n+\t\tif b == '\\n' {\n+\t\t\tline = offset + 1\n+\t\t}\n+\t}\n+\n+\t// set lines table\n+\tf.set.mutex.Lock()\n+\tf.lines = lines\n+\tf.set.mutex.Unlock()\n+}\n+\n+\n // Pos returns the Pos value for the given file offset;\n // the offset must be <= f.Size().\n // f.Pos(f.Offset(p)) == p."}, {"sha": "979c9b1e8e7f9008aab2899d61585585d164a62f", "filename": "libgo/go/go/token/position_test.go", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -39,14 +39,18 @@ func TestNoPos(t *testing.T) {\n \n var tests = []struct {\n \tfilename string\n+\tsource   []byte // may be nil\n \tsize     int\n \tlines    []int\n }{\n-\t{\"a\", 0, []int{}},\n-\t{\"b\", 5, []int{0}},\n-\t{\"c\", 10, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}},\n-\t{\"d\", 100, []int{0, 5, 10, 20, 30, 70, 71, 72, 80, 85, 90, 99}},\n-\t{\"e\", 777, []int{0, 80, 100, 120, 130, 180, 267, 455, 500, 567, 620}},\n+\t{\"a\", []byte{}, 0, []int{}},\n+\t{\"b\", []byte(\"01234\"), 5, []int{0}},\n+\t{\"c\", []byte(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\"), 9, []int{0, 1, 2, 3, 4, 5, 6, 7, 8}},\n+\t{\"d\", nil, 100, []int{0, 5, 10, 20, 30, 70, 71, 72, 80, 85, 90, 99}},\n+\t{\"e\", nil, 777, []int{0, 80, 100, 120, 130, 180, 267, 455, 500, 567, 620}},\n+\t{\"f\", []byte(\"package p\\n\\nimport \\\"fmt\\\"\"), 23, []int{0, 10, 11}},\n+\t{\"g\", []byte(\"package p\\n\\nimport \\\"fmt\\\"\\n\"), 24, []int{0, 10, 11}},\n+\t{\"h\", []byte(\"package p\\n\\nimport \\\"fmt\\\"\\n \"), 25, []int{0, 10, 11, 24}},\n }\n \n \n@@ -77,10 +81,26 @@ func verifyPositions(t *testing.T, fset *FileSet, f *File, lines []int) {\n }\n \n \n+func makeTestSource(size int, lines []int) []byte {\n+\tsrc := make([]byte, size)\n+\tfor _, offs := range lines {\n+\t\tif offs > 0 {\n+\t\t\tsrc[offs-1] = '\\n'\n+\t\t}\n+\t}\n+\treturn src\n+}\n+\n+\n func TestPositions(t *testing.T) {\n \tconst delta = 7 // a non-zero base offset increment\n \tfset := NewFileSet()\n \tfor _, test := range tests {\n+\t\t// verify consistency of test case\n+\t\tif test.source != nil && len(test.source) != test.size {\n+\t\t\tt.Errorf(\"%s: inconsistent test case: expected file size %d; got %d\", test.filename, test.size, len(test.source))\n+\t\t}\n+\n \t\t// add file and verify name and size\n \t\tf := fset.AddFile(test.filename, fset.Base()+delta, test.size)\n \t\tif f.Name() != test.filename {\n@@ -107,15 +127,26 @@ func TestPositions(t *testing.T) {\n \t\t\tverifyPositions(t, fset, f, test.lines[0:i+1])\n \t\t}\n \n-\t\t// add lines at once and verify all positions\n-\t\tok := f.SetLines(test.lines)\n-\t\tif !ok {\n+\t\t// add lines with SetLines and verify all positions\n+\t\tif ok := f.SetLines(test.lines); !ok {\n \t\t\tt.Errorf(\"%s: SetLines failed\", f.Name())\n \t\t}\n \t\tif f.LineCount() != len(test.lines) {\n \t\t\tt.Errorf(\"%s, SetLines: expected line count %d; got %d\", f.Name(), len(test.lines), f.LineCount())\n \t\t}\n \t\tverifyPositions(t, fset, f, test.lines)\n+\n+\t\t// add lines with SetLinesForContent and verify all positions\n+\t\tsrc := test.source\n+\t\tif src == nil {\n+\t\t\t// no test source available - create one from scratch\n+\t\t\tsrc = makeTestSource(test.size, test.lines)\n+\t\t}\n+\t\tf.SetLinesForContent(src)\n+\t\tif f.LineCount() != len(test.lines) {\n+\t\t\tt.Errorf(\"%s, SetLinesForContent: expected line count %d; got %d\", f.Name(), len(test.lines), f.LineCount())\n+\t\t}\n+\t\tverifyPositions(t, fset, f, test.lines)\n \t}\n }\n "}, {"sha": "2a2d3ecc4fb99afdc7839be118b436f9dd3eb8a8", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -252,8 +252,8 @@ func (tok Token) String() string {\n //\n const (\n \tLowestPrec  = 0 // non-operators\n-\tUnaryPrec   = 7\n-\tHighestPrec = 8\n+\tUnaryPrec   = 6\n+\tHighestPrec = 7\n )\n \n \n@@ -267,14 +267,12 @@ func (op Token) Precedence() int {\n \t\treturn 1\n \tcase LAND:\n \t\treturn 2\n-\tcase ARROW:\n-\t\treturn 3\n \tcase EQL, NEQ, LSS, LEQ, GTR, GEQ:\n-\t\treturn 4\n+\t\treturn 3\n \tcase ADD, SUB, OR, XOR:\n-\t\treturn 5\n+\t\treturn 4\n \tcase MUL, QUO, REM, SHL, SHR, AND, AND_NOT:\n-\t\treturn 6\n+\t\treturn 5\n \t}\n \treturn LowestPrec\n }"}, {"sha": "c822d6863ac6eb868a92b6156e52cd1598138447", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -58,7 +58,7 @@ func TestUintCodec(t *testing.T) {\n \t\t\tt.Errorf(\"encodeUint: %#x encode: expected % x got % x\", tt.x, tt.b, b.Bytes())\n \t\t}\n \t}\n-\tdecState := newDecodeState(nil, &b)\n+\tdecState := newDecodeState(nil, b)\n \tfor u := uint64(0); ; u = (u + 1) * 7 {\n \t\tb.Reset()\n \t\tencState.encodeUint(u)\n@@ -77,7 +77,7 @@ func verifyInt(i int64, t *testing.T) {\n \tvar b = new(bytes.Buffer)\n \tencState := newEncoderState(nil, b)\n \tencState.encodeInt(i)\n-\tdecState := newDecodeState(nil, &b)\n+\tdecState := newDecodeState(nil, b)\n \tdecState.buf = make([]byte, 8)\n \tj := decState.decodeInt()\n \tif i != j {\n@@ -315,7 +315,7 @@ func execDec(typ string, instr *decInstr, state *decodeState, t *testing.T, p un\n \n func newDecodeStateFromData(data []byte) *decodeState {\n \tb := bytes.NewBuffer(data)\n-\tstate := newDecodeState(nil, &b)\n+\tstate := newDecodeState(nil, b)\n \tstate.fieldnum = -1\n \treturn state\n }\n@@ -342,7 +342,7 @@ func TestScalarDecInstructions(t *testing.T) {\n \t\tvar data struct {\n \t\t\ta int\n \t\t}\n-\t\tinstr := &decInstr{decOpMap[reflect.Int], 6, 0, 0, ovfl}\n+\t\tinstr := &decInstr{decOpTable[reflect.Int], 6, 0, 0, ovfl}\n \t\tstate := newDecodeStateFromData(signedResult)\n \t\texecDec(\"int\", instr, state, t, unsafe.Pointer(&data))\n \t\tif data.a != 17 {\n@@ -355,7 +355,7 @@ func TestScalarDecInstructions(t *testing.T) {\n \t\tvar data struct {\n \t\t\ta uint\n \t\t}\n-\t\tinstr := &decInstr{decOpMap[reflect.Uint], 6, 0, 0, ovfl}\n+\t\tinstr := &decInstr{decOpTable[reflect.Uint], 6, 0, 0, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n \t\texecDec(\"uint\", instr, state, t, unsafe.Pointer(&data))\n \t\tif data.a != 17 {\n@@ -446,7 +446,7 @@ func TestScalarDecInstructions(t *testing.T) {\n \t\tvar data struct {\n \t\t\ta uintptr\n \t\t}\n-\t\tinstr := &decInstr{decOpMap[reflect.Uintptr], 6, 0, 0, ovfl}\n+\t\tinstr := &decInstr{decOpTable[reflect.Uintptr], 6, 0, 0, ovfl}\n \t\tstate := newDecodeStateFromData(unsignedResult)\n \t\texecDec(\"uintptr\", instr, state, t, unsafe.Pointer(&data))\n \t\tif data.a != 17 {\n@@ -511,7 +511,7 @@ func TestScalarDecInstructions(t *testing.T) {\n \t\tvar data struct {\n \t\t\ta complex64\n \t\t}\n-\t\tinstr := &decInstr{decOpMap[reflect.Complex64], 6, 0, 0, ovfl}\n+\t\tinstr := &decInstr{decOpTable[reflect.Complex64], 6, 0, 0, ovfl}\n \t\tstate := newDecodeStateFromData(complexResult)\n \t\texecDec(\"complex\", instr, state, t, unsafe.Pointer(&data))\n \t\tif data.a != 17+19i {\n@@ -524,7 +524,7 @@ func TestScalarDecInstructions(t *testing.T) {\n \t\tvar data struct {\n \t\t\ta complex128\n \t\t}\n-\t\tinstr := &decInstr{decOpMap[reflect.Complex128], 6, 0, 0, ovfl}\n+\t\tinstr := &decInstr{decOpTable[reflect.Complex128], 6, 0, 0, ovfl}\n \t\tstate := newDecodeStateFromData(complexResult)\n \t\texecDec(\"complex\", instr, state, t, unsafe.Pointer(&data))\n \t\tif data.a != 17+19i {\n@@ -973,18 +973,32 @@ func TestIgnoredFields(t *testing.T) {\n \t}\n }\n \n+\n+func TestBadRecursiveType(t *testing.T) {\n+\ttype Rec ***Rec\n+\tvar rec Rec\n+\tb := new(bytes.Buffer)\n+\terr := NewEncoder(b).Encode(&rec)\n+\tif err == nil {\n+\t\tt.Error(\"expected error; got none\")\n+\t} else if strings.Index(err.String(), \"recursive\") < 0 {\n+\t\tt.Error(\"expected recursive type error; got\", err)\n+\t}\n+\t// Can't test decode easily because we can't encode one, so we can't pass one to a Decoder.\n+}\n+\n type Bad0 struct {\n-\tch chan int\n-\tc  float64\n+\tCH chan int\n+\tC  float64\n }\n \n-var nilEncoder *Encoder\n \n func TestInvalidField(t *testing.T) {\n \tvar bad0 Bad0\n-\tbad0.ch = make(chan int)\n+\tbad0.CH = make(chan int)\n \tb := new(bytes.Buffer)\n-\terr := nilEncoder.encode(b, reflect.NewValue(&bad0))\n+\tvar nilEncoder *Encoder\n+\terr := nilEncoder.encode(b, reflect.NewValue(&bad0), userType(reflect.Typeof(&bad0)))\n \tif err == nil {\n \t\tt.Error(\"expected error; got none\")\n \t} else if strings.Index(err.String(), \"type\") < 0 {\n@@ -1088,11 +1102,11 @@ func (v Vector) Square() int {\n }\n \n type Point struct {\n-\ta, b int\n+\tX, Y int\n }\n \n func (p Point) Square() int {\n-\treturn p.a*p.a + p.b*p.b\n+\treturn p.X*p.X + p.Y*p.Y\n }\n \n // A struct with interfaces in it.\n@@ -1162,7 +1176,6 @@ func TestInterface(t *testing.T) {\n \t\t\t}\n \t\t}\n \t}\n-\n }\n \n // A struct with all basic types, stored in interfaces.\n@@ -1182,7 +1195,7 @@ func TestInterfaceBasic(t *testing.T) {\n \t\tint(1), int8(1), int16(1), int32(1), int64(1),\n \t\tuint(1), uint8(1), uint16(1), uint32(1), uint64(1),\n \t\tfloat32(1), 1.0,\n-\t\tcomplex64(0i), complex128(0i),\n+\t\tcomplex64(1i), complex128(1i),\n \t\ttrue,\n \t\t\"hello\",\n \t\t[]byte(\"sailor\"),\n@@ -1307,6 +1320,31 @@ func TestUnexportedFields(t *testing.T) {\n \t}\n }\n \n+var singletons = []interface{}{\n+\ttrue,\n+\t7,\n+\t3.2,\n+\t\"hello\",\n+\t[3]int{11, 22, 33},\n+\t[]float32{0.5, 0.25, 0.125},\n+\tmap[string]int{\"one\": 1, \"two\": 2},\n+}\n+\n+func TestDebugSingleton(t *testing.T) {\n+\tif debugFunc == nil {\n+\t\treturn\n+\t}\n+\tb := new(bytes.Buffer)\n+\t// Accumulate a number of values and print them out all at once.\n+\tfor _, x := range singletons {\n+\t\terr := NewEncoder(b).Encode(x)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"encode:\", err)\n+\t\t}\n+\t}\n+\tdebugFunc(b)\n+}\n+\n // A type that won't be defined in the gob until we send it in an interface value.\n type OnTheFly struct {\n \tA int\n@@ -1325,7 +1363,7 @@ type DT struct {\n \tS     []string\n }\n \n-func TestDebug(t *testing.T) {\n+func TestDebugStruct(t *testing.T) {\n \tif debugFunc == nil {\n \t\treturn\n \t}"}, {"sha": "8f599e100413c1f371da25d0c52b5a49786aeb7a", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 141, "deletions": 64, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -30,15 +30,17 @@ type decodeState struct {\n \tdec *Decoder\n \t// The buffer is stored with an extra indirection because it may be replaced\n \t// if we load a type during decode (when reading an interface value).\n-\tb        **bytes.Buffer\n+\tb        *bytes.Buffer\n \tfieldnum int // the last field number read.\n \tbuf      []byte\n }\n \n-func newDecodeState(dec *Decoder, b **bytes.Buffer) *decodeState {\n+// We pass the bytes.Buffer separately for easier testing of the infrastructure\n+// without requiring a full Decoder.\n+func newDecodeState(dec *Decoder, buf *bytes.Buffer) *decodeState {\n \td := new(decodeState)\n \td.dec = dec\n-\td.b = b\n+\td.b = buf\n \td.buf = make([]byte, uint64Size)\n \treturn d\n }\n@@ -49,14 +51,15 @@ func overflow(name string) os.ErrorString {\n \n // decodeUintReader reads an encoded unsigned integer from an io.Reader.\n // Used only by the Decoder to read the message length.\n-func decodeUintReader(r io.Reader, buf []byte) (x uint64, err os.Error) {\n-\t_, err = r.Read(buf[0:1])\n+func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err os.Error) {\n+\twidth = 1\n+\t_, err = r.Read(buf[0:width])\n \tif err != nil {\n \t\treturn\n \t}\n \tb := buf[0]\n \tif b <= 0x7f {\n-\t\treturn uint64(b), nil\n+\t\treturn uint64(b), width, nil\n \t}\n \tnb := -int(int8(b))\n \tif nb > uint64Size {\n@@ -75,6 +78,7 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, err os.Error) {\n \tfor i := 0; i < n; i++ {\n \t\tx <<= 8\n \t\tx |= uint64(buf[i])\n+\t\twidth++\n \t}\n \treturn\n }\n@@ -405,10 +409,9 @@ func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n \treturn *(*uintptr)(up)\n }\n \n-func (dec *Decoder) decodeSingle(engine *decEngine, rtyp reflect.Type, b **bytes.Buffer, p uintptr, indir int) (err os.Error) {\n-\tdefer catchError(&err)\n-\tp = allocate(rtyp, p, indir)\n-\tstate := newDecodeState(dec, b)\n+func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, p uintptr) (err os.Error) {\n+\tp = allocate(ut.base, p, ut.indir)\n+\tstate := newDecodeState(dec, &dec.buf)\n \tstate.fieldnum = singletonField\n \tbasep := p\n \tdelta := int(state.decodeUint())\n@@ -424,10 +427,13 @@ func (dec *Decoder) decodeSingle(engine *decEngine, rtyp reflect.Type, b **bytes\n \treturn nil\n }\n \n-func (dec *Decoder) decodeStruct(engine *decEngine, rtyp *reflect.StructType, b **bytes.Buffer, p uintptr, indir int) (err os.Error) {\n-\tdefer catchError(&err)\n-\tp = allocate(rtyp, p, indir)\n-\tstate := newDecodeState(dec, b)\n+// Indir is for the value, not the type.  At the time of the call it may\n+// differ from ut.indir, which was computed when the engine was built.\n+// This state cannot arise for decodeSingle, which is called directly\n+// from the user's value, not from the innards of an engine.\n+func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr, indir int) (err os.Error) {\n+\tp = allocate(ut.base.(*reflect.StructType), p, indir)\n+\tstate := newDecodeState(dec, &dec.buf)\n \tstate.fieldnum = -1\n \tbasep := p\n \tfor state.b.Len() > 0 {\n@@ -454,9 +460,8 @@ func (dec *Decoder) decodeStruct(engine *decEngine, rtyp *reflect.StructType, b\n \treturn nil\n }\n \n-func (dec *Decoder) ignoreStruct(engine *decEngine, b **bytes.Buffer) (err os.Error) {\n-\tdefer catchError(&err)\n-\tstate := newDecodeState(dec, b)\n+func (dec *Decoder) ignoreStruct(engine *decEngine) (err os.Error) {\n+\tstate := newDecodeState(dec, &dec.buf)\n \tstate.fieldnum = -1\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n@@ -477,6 +482,18 @@ func (dec *Decoder) ignoreStruct(engine *decEngine, b **bytes.Buffer) (err os.Er\n \treturn nil\n }\n \n+func (dec *Decoder) ignoreSingle(engine *decEngine) (err os.Error) {\n+\tstate := newDecodeState(dec, &dec.buf)\n+\tstate.fieldnum = singletonField\n+\tdelta := int(state.decodeUint())\n+\tif delta != 0 {\n+\t\terrorf(\"gob decode: corrupted data: non-zero delta for singleton\")\n+\t}\n+\tinstr := &engine.instr[singletonField]\n+\tinstr.op(instr, state, unsafe.Pointer(nil))\n+\treturn nil\n+}\n+\n func (dec *Decoder) decodeArrayHelper(state *decodeState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl os.ErrorString) {\n \tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n \tfor i := 0; i < length; i++ {\n@@ -501,7 +518,7 @@ func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decodeState, p u\n \n func decodeIntoValue(state *decodeState, op decOp, indir int, v reflect.Value, ovfl os.ErrorString) reflect.Value {\n \tinstr := &decInstr{op, 0, indir, 0, ovfl}\n-\tup := unsafe.Pointer(v.Addr())\n+\tup := unsafe.Pointer(v.UnsafeAddr())\n \tif indir > 1 {\n \t\tup = decIndirect(up, indir)\n \t}\n@@ -612,9 +629,17 @@ func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decodeSt\n \tif !ok {\n \t\terrorf(\"gob: name not registered for interface: %q\", name)\n \t}\n+\t// Read the type id of the concrete value.\n+\tconcreteId := dec.decodeTypeSequence(true)\n+\tif concreteId < 0 {\n+\t\terror(dec.err)\n+\t}\n+\t// Byte count of value is next; we don't care what it is (it's there\n+\t// in case we want to ignore the value by skipping it completely).\n+\tstate.decodeUint()\n \t// Read the concrete value.\n \tvalue := reflect.MakeZero(typ)\n-\tdec.decodeValueFromBuffer(value, false, true)\n+\tdec.decodeValue(concreteId, value)\n \tif dec.err != nil {\n \t\terror(dec.err)\n \t}\n@@ -637,14 +662,16 @@ func (dec *Decoder) ignoreInterface(state *decodeState) {\n \tif err != nil {\n \t\terror(err)\n \t}\n-\tdec.decodeValueFromBuffer(nil, true, true)\n-\tif dec.err != nil {\n-\t\terror(err)\n+\tid := dec.decodeTypeSequence(true)\n+\tif id < 0 {\n+\t\terror(dec.err)\n \t}\n+\t// At this point, the decoder buffer contains a delimited value. Just toss it.\n+\tstate.b.Next(int(state.decodeUint()))\n }\n \n // Index by Go types.\n-var decOpMap = []decOp{\n+var decOpTable = [...]decOp{\n \treflect.Bool:       decBool,\n \treflect.Int8:       decInt8,\n \treflect.Int16:      decInt16,\n@@ -674,35 +701,43 @@ var decIgnoreOpMap = map[typeId]decOp{\n \n // Return the decoding op for the base type under rt and\n // the indirection count to reach it.\n-func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string) (decOp, int) {\n-\ttyp, indir := indirect(rt)\n+func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProgress map[reflect.Type]*decOp) (*decOp, int) {\n+\tut := userType(rt)\n+\t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n+\t// Return the pointer to the op we're already building.\n+\tif opPtr := inProgress[rt]; opPtr != nil {\n+\t\treturn opPtr, ut.indir\n+\t}\n+\ttyp := ut.base\n+\tindir := ut.indir\n \tvar op decOp\n \tk := typ.Kind()\n-\tif int(k) < len(decOpMap) {\n-\t\top = decOpMap[k]\n+\tif int(k) < len(decOpTable) {\n+\t\top = decOpTable[k]\n \t}\n \tif op == nil {\n+\t\tinProgress[rt] = &op\n \t\t// Special cases\n \t\tswitch t := typ.(type) {\n \t\tcase *reflect.ArrayType:\n \t\t\tname = \"element of \" + name\n \t\t\telemId := dec.wireType[wireId].ArrayT.Elem\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name)\n+\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeArray(t, state, uintptr(p), elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n+\t\t\t\tstate.dec.decodeArray(t, state, uintptr(p), *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase *reflect.MapType:\n \t\t\tname = \"element of \" + name\n \t\t\tkeyId := dec.wireType[wireId].MapT.Key\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n-\t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), name)\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name)\n+\t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), name, inProgress)\n+\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t\t\t\tup := unsafe.Pointer(p)\n-\t\t\t\tstate.dec.decodeMap(t, state, uintptr(up), keyOp, elemOp, i.indir, keyIndir, elemIndir, ovfl)\n+\t\t\t\tstate.dec.decodeMap(t, state, uintptr(up), *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase *reflect.SliceType:\n@@ -717,10 +752,10 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string) (decOp\n \t\t\t} else {\n \t\t\t\telemId = dec.wireType[wireId].SliceT.Elem\n \t\t\t}\n-\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name)\n+\t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n \t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n-\t\t\t\tstate.dec.decodeSlice(t, state, uintptr(p), elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)\n+\t\t\t\tstate.dec.decodeSlice(t, state, uintptr(p), *elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase *reflect.StructType:\n@@ -730,8 +765,8 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string) (decOp\n \t\t\t\terror(err)\n \t\t\t}\n \t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n-\t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs\n-\t\t\t\terr = dec.decodeStruct(*enginePtr, t, state.b, uintptr(p), i.indir)\n+\t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n+\t\t\t\terr = dec.decodeStruct(*enginePtr, userType(typ), uintptr(p), i.indir)\n \t\t\t\tif err != nil {\n \t\t\t\t\terror(err)\n \t\t\t\t}\n@@ -745,7 +780,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string) (decOp\n \tif op == nil {\n \t\terrorf(\"gob: decode can't handle type %s\", rt.String())\n \t}\n-\treturn op, indir\n+\treturn &op, indir\n }\n \n // Return the decoding op for a field that has no destination.\n@@ -796,7 +831,7 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\t}\n \t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs\n-\t\t\t\tstate.dec.ignoreStruct(*enginePtr, state.b)\n+\t\t\t\tstate.dec.ignoreStruct(*enginePtr)\n \t\t\t}\n \t\t}\n \t}\n@@ -809,11 +844,15 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n // Are these two gob Types compatible?\n // Answers the question for basic types, arrays, and slices.\n // Structs are considered ok; fields will be checked later.\n-func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId) bool {\n-\tfr, _ = indirect(fr)\n+func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[reflect.Type]typeId) bool {\n+\tif rhs, ok := inProgress[fr]; ok {\n+\t\treturn rhs == fw\n+\t}\n+\tinProgress[fr] = fw\n+\tfr = userType(fr).base\n \tswitch t := fr.(type) {\n \tdefault:\n-\t\t// map, chan, etc: cannot handle.\n+\t\t// chan, etc: cannot handle.\n \t\treturn false\n \tcase *reflect.BoolType:\n \t\treturn fw == tBool\n@@ -835,14 +874,14 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId) bool {\n \t\t\treturn false\n \t\t}\n \t\tarray := wire.ArrayT\n-\t\treturn t.Len() == array.Len && dec.compatibleType(t.Elem(), array.Elem)\n+\t\treturn t.Len() == array.Len && dec.compatibleType(t.Elem(), array.Elem, inProgress)\n \tcase *reflect.MapType:\n \t\twire, ok := dec.wireType[fw]\n \t\tif !ok || wire.MapT == nil {\n \t\t\treturn false\n \t\t}\n \t\tMapType := wire.MapT\n-\t\treturn dec.compatibleType(t.Key(), MapType.Key) && dec.compatibleType(t.Elem(), MapType.Elem)\n+\t\treturn dec.compatibleType(t.Key(), MapType.Key, inProgress) && dec.compatibleType(t.Elem(), MapType.Elem, inProgress)\n \tcase *reflect.SliceType:\n \t\t// Is it an array of bytes?\n \t\tif t.Elem().Kind() == reflect.Uint8 {\n@@ -855,8 +894,8 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId) bool {\n \t\t} else {\n \t\t\tsw = dec.wireType[fw].SliceT\n \t\t}\n-\t\telem, _ := indirect(t.Elem())\n-\t\treturn sw != nil && dec.compatibleType(elem, sw.Elem)\n+\t\telem := userType(t.Elem()).base\n+\t\treturn sw != nil && dec.compatibleType(elem, sw.Elem, inProgress)\n \tcase *reflect.StructType:\n \t\treturn true\n \t}\n@@ -877,12 +916,22 @@ func (dec *Decoder) compileSingle(remoteId typeId, rt reflect.Type) (engine *dec\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, 1) // one item\n \tname := rt.String()                // best we can do\n-\tif !dec.compatibleType(rt, remoteId) {\n+\tif !dec.compatibleType(rt, remoteId, make(map[reflect.Type]typeId)) {\n \t\treturn nil, os.ErrorString(\"gob: wrong type received for local value \" + name + \": \" + dec.typeString(remoteId))\n \t}\n-\top, indir := dec.decOpFor(remoteId, rt, name)\n+\top, indir := dec.decOpFor(remoteId, rt, name, make(map[reflect.Type]*decOp))\n \tovfl := os.ErrorString(`value for \"` + name + `\" out of range`)\n-\tengine.instr[singletonField] = decInstr{op, singletonField, indir, 0, ovfl}\n+\tengine.instr[singletonField] = decInstr{*op, singletonField, indir, 0, ovfl}\n+\tengine.numInstr = 1\n+\treturn\n+}\n+\n+func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err os.Error) {\n+\tengine = new(decEngine)\n+\tengine.instr = make([]decInstr, 1) // one item\n+\top := dec.decIgnoreOpFor(remoteId)\n+\tovfl := overflow(dec.typeString(remoteId))\n+\tengine.instr[0] = decInstr{op, 0, 0, 0, ovfl}\n \tengine.numInstr = 1\n \treturn\n }\n@@ -894,7 +943,6 @@ func isExported(name string) bool {\n }\n \n func (dec *Decoder) compileDec(remoteId typeId, rt reflect.Type) (engine *decEngine, err os.Error) {\n-\tdefer catchError(&err)\n \tsrt, ok := rt.(*reflect.StructType)\n \tif !ok {\n \t\treturn dec.compileSingle(remoteId, rt)\n@@ -905,13 +953,18 @@ func (dec *Decoder) compileDec(remoteId typeId, rt reflect.Type) (engine *decEng\n \tif t, ok := builtinIdToType[remoteId]; ok {\n \t\twireStruct, _ = t.(*structType)\n \t} else {\n-\t\twireStruct = dec.wireType[remoteId].StructT\n+\t\twire := dec.wireType[remoteId]\n+\t\tif wire == nil {\n+\t\t\terror(errBadType)\n+\t\t}\n+\t\twireStruct = wire.StructT\n \t}\n \tif wireStruct == nil {\n \t\terrorf(\"gob: type mismatch in decoder: want struct type %s; got non-struct\", rt.String())\n \t}\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, len(wireStruct.Field))\n+\tseen := make(map[reflect.Type]*decOp)\n \t// Loop over the fields of the wire type.\n \tfor fieldnum := 0; fieldnum < len(wireStruct.Field); fieldnum++ {\n \t\twireField := wireStruct.Field[fieldnum]\n@@ -927,11 +980,11 @@ func (dec *Decoder) compileDec(remoteId typeId, rt reflect.Type) (engine *decEng\n \t\t\tengine.instr[fieldnum] = decInstr{op, fieldnum, 0, 0, ovfl}\n \t\t\tcontinue\n \t\t}\n-\t\tif !dec.compatibleType(localField.Type, wireField.Id) {\n+\t\tif !dec.compatibleType(localField.Type, wireField.Id, make(map[reflect.Type]typeId)) {\n \t\t\terrorf(\"gob: wrong type (%s) for received field %s.%s\", localField.Type, wireStruct.Name, wireField.Name)\n \t\t}\n-\t\top, indir := dec.decOpFor(wireField.Id, localField.Type, localField.Name)\n-\t\tengine.instr[fieldnum] = decInstr{op, fieldnum, indir, uintptr(localField.Offset), ovfl}\n+\t\top, indir := dec.decOpFor(wireField.Id, localField.Type, localField.Name, seen)\n+\t\tengine.instr[fieldnum] = decInstr{*op, fieldnum, indir, uintptr(localField.Offset), ovfl}\n \t\tengine.numInstr++\n \t}\n \treturn\n@@ -966,30 +1019,54 @@ func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, er\n \t\t// To handle recursive types, mark this engine as underway before compiling.\n \t\tenginePtr = new(*decEngine)\n \t\tdec.ignorerCache[wireId] = enginePtr\n-\t\t*enginePtr, err = dec.compileDec(wireId, emptyStructType)\n+\t\twire := dec.wireType[wireId]\n+\t\tif wire != nil && wire.StructT != nil {\n+\t\t\t*enginePtr, err = dec.compileDec(wireId, emptyStructType)\n+\t\t} else {\n+\t\t\t*enginePtr, err = dec.compileIgnoreSingle(wireId)\n+\t\t}\n \t\tif err != nil {\n \t\t\tdec.ignorerCache[wireId] = nil, false\n \t\t}\n \t}\n \treturn\n }\n \n-func (dec *Decoder) decode(wireId typeId, val reflect.Value) os.Error {\n+func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) (err os.Error) {\n+\tdefer catchError(&err)\n+\t// If the value is nil, it means we should just ignore this item.\n+\tif val == nil {\n+\t\treturn dec.decodeIgnoredValue(wireId)\n+\t}\n \t// Dereference down to the underlying struct type.\n-\trt, indir := indirect(val.Type())\n-\tenginePtr, err := dec.getDecEnginePtr(wireId, rt)\n+\tut := userType(val.Type())\n+\tbase := ut.base\n+\tindir := ut.indir\n+\tenginePtr, err := dec.getDecEnginePtr(wireId, base)\n \tif err != nil {\n \t\treturn err\n \t}\n \tengine := *enginePtr\n-\tif st, ok := rt.(*reflect.StructType); ok {\n+\tif st, ok := base.(*reflect.StructType); ok {\n \t\tif engine.numInstr == 0 && st.NumField() > 0 && len(dec.wireType[wireId].StructT.Field) > 0 {\n-\t\t\tname := rt.Name()\n+\t\t\tname := base.Name()\n \t\t\treturn os.ErrorString(\"gob: type mismatch: no fields matched compiling decoder for \" + name)\n \t\t}\n-\t\treturn dec.decodeStruct(engine, st, dec.state.b, uintptr(val.Addr()), indir)\n+\t\treturn dec.decodeStruct(engine, ut, uintptr(val.UnsafeAddr()), indir)\n+\t}\n+\treturn dec.decodeSingle(engine, ut, uintptr(val.UnsafeAddr()))\n+}\n+\n+func (dec *Decoder) decodeIgnoredValue(wireId typeId) os.Error {\n+\tenginePtr, err := dec.getIgnoreEnginePtr(wireId)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\twire := dec.wireType[wireId]\n+\tif wire != nil && wire.StructT != nil {\n+\t\treturn dec.ignoreStruct(*enginePtr)\n \t}\n-\treturn dec.decodeSingle(engine, rt, dec.state.b, uintptr(val.Addr()), indir)\n+\treturn dec.ignoreSingle(*enginePtr)\n }\n \n func init() {\n@@ -1004,8 +1081,8 @@ func init() {\n \tdefault:\n \t\tpanic(\"gob: unknown size of int/uint\")\n \t}\n-\tdecOpMap[reflect.Int] = iop\n-\tdecOpMap[reflect.Uint] = uop\n+\tdecOpTable[reflect.Int] = iop\n+\tdecOpTable[reflect.Uint] = uop\n \n \t// Finally uintptr\n \tswitch reflect.Typeof(uintptr(0)).Bits() {\n@@ -1016,5 +1093,5 @@ func init() {\n \tdefault:\n \t\tpanic(\"gob: unknown size of uintptr\")\n \t}\n-\tdecOpMap[reflect.Uintptr] = uop\n+\tdecOpTable[reflect.Uintptr] = uop\n }"}, {"sha": "f7c994ffa7844ec5d3e99be41deffce168d5647a", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 100, "deletions": 69, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -17,14 +17,13 @@ import (\n type Decoder struct {\n \tmutex        sync.Mutex                              // each item must be received atomically\n \tr            io.Reader                               // source of the data\n+\tbuf          bytes.Buffer                            // buffer for more efficient i/o from r\n \twireType     map[typeId]*wireType                    // map from remote ID to local description\n \tdecoderCache map[reflect.Type]map[typeId]**decEngine // cache of compiled engines\n \tignorerCache map[typeId]**decEngine                  // ditto for ignored objects\n-\tstate        *decodeState                            // reads data from in-memory buffer\n \tcountState   *decodeState                            // reads counts from wire\n-\tbuf          []byte\n-\tcountBuf     [9]byte // counts may be uint64s (unlikely!), require 9 bytes\n-\tbyteBuffer   *bytes.Buffer\n+\tcountBuf     []byte                                  // used for decoding integers while parsing messages\n+\ttmp          []byte                                  // temporary storage for i/o; saves reallocating\n \terr          os.Error\n }\n \n@@ -33,128 +32,160 @@ func NewDecoder(r io.Reader) *Decoder {\n \tdec := new(Decoder)\n \tdec.r = r\n \tdec.wireType = make(map[typeId]*wireType)\n-\tdec.state = newDecodeState(dec, &dec.byteBuffer) // buffer set in Decode()\n \tdec.decoderCache = make(map[reflect.Type]map[typeId]**decEngine)\n \tdec.ignorerCache = make(map[typeId]**decEngine)\n+\tdec.countBuf = make([]byte, 9) // counts may be uint64s (unlikely!), require 9 bytes\n \n \treturn dec\n }\n \n-// recvType loads the definition of a type and reloads the Decoder's buffer.\n+// recvType loads the definition of a type.\n func (dec *Decoder) recvType(id typeId) {\n \t// Have we already seen this type?  That's an error\n-\tif dec.wireType[id] != nil {\n+\tif id < firstUserId || dec.wireType[id] != nil {\n \t\tdec.err = os.ErrorString(\"gob: duplicate type received\")\n \t\treturn\n \t}\n \n \t// Type:\n \twire := new(wireType)\n-\tdec.err = dec.decode(tWireType, reflect.NewValue(wire))\n+\tdec.err = dec.decodeValue(tWireType, reflect.NewValue(wire))\n \tif dec.err != nil {\n \t\treturn\n \t}\n \t// Remember we've seen this type.\n \tdec.wireType[id] = wire\n-\n-\t// Load the next parcel.\n-\tdec.recv()\n }\n \n-// Decode reads the next value from the connection and stores\n-// it in the data represented by the empty interface value.\n-// The value underlying e must be the correct type for the next\n-// data item received, and must be a pointer.\n-func (dec *Decoder) Decode(e interface{}) os.Error {\n-\tvalue := reflect.NewValue(e)\n-\t// If e represents a value as opposed to a pointer, the answer won't\n-\t// get back to the caller.  Make sure it's a pointer.\n-\tif value.Type().Kind() != reflect.Ptr {\n-\t\tdec.err = os.ErrorString(\"gob: attempt to decode into a non-pointer\")\n-\t\treturn dec.err\n+// recvMessage reads the next count-delimited item from the input. It is the converse\n+// of Encoder.writeMessage. It returns false on EOF or other error reading the message.\n+func (dec *Decoder) recvMessage() bool {\n+\t// Read a count.\n+\tnbytes, _, err := decodeUintReader(dec.r, dec.countBuf)\n+\tif err != nil {\n+\t\tdec.err = err\n+\t\treturn false\n \t}\n-\treturn dec.DecodeValue(value)\n+\tdec.readMessage(int(nbytes))\n+\treturn dec.err == nil\n }\n \n-// recv reads the next count-delimited item from the input. It is the converse\n-// of Encoder.send.\n-func (dec *Decoder) recv() {\n-\t// Read a count.\n-\tvar nbytes uint64\n-\tnbytes, dec.err = decodeUintReader(dec.r, dec.countBuf[0:])\n-\tif dec.err != nil {\n-\t\treturn\n-\t}\n+// readMessage reads the next nbytes bytes from the input.\n+func (dec *Decoder) readMessage(nbytes int) {\n \t// Allocate the buffer.\n-\tif nbytes > uint64(len(dec.buf)) {\n-\t\tdec.buf = make([]byte, nbytes+1000)\n+\tif cap(dec.tmp) < nbytes {\n+\t\tdec.tmp = make([]byte, nbytes+100) // room to grow\n \t}\n-\tdec.byteBuffer = bytes.NewBuffer(dec.buf[0:nbytes])\n+\tdec.tmp = dec.tmp[:nbytes]\n \n \t// Read the data\n-\t_, dec.err = io.ReadFull(dec.r, dec.buf[0:nbytes])\n+\t_, dec.err = io.ReadFull(dec.r, dec.tmp)\n \tif dec.err != nil {\n \t\tif dec.err == os.EOF {\n \t\t\tdec.err = io.ErrUnexpectedEOF\n \t\t}\n \t\treturn\n \t}\n+\tdec.buf.Write(dec.tmp)\n }\n \n-// decodeValueFromBuffer grabs the next value from the input. The Decoder's\n-// buffer already contains data.  If the next item in the buffer is a type\n-// descriptor, it may be necessary to reload the buffer, but recvType does that.\n-func (dec *Decoder) decodeValueFromBuffer(value reflect.Value, ignoreInterfaceValue, countPresent bool) {\n-\tfor dec.state.b.Len() > 0 {\n-\t\t// Receive a type id.\n-\t\tid := typeId(dec.state.decodeInt())\n+// toInt turns an encoded uint64 into an int, according to the marshaling rules.\n+func toInt(x uint64) int64 {\n+\ti := int64(x >> 1)\n+\tif x&1 != 0 {\n+\t\ti = ^i\n+\t}\n+\treturn i\n+}\n+\n+func (dec *Decoder) nextInt() int64 {\n+\tn, _, err := decodeUintReader(&dec.buf, dec.countBuf)\n+\tif err != nil {\n+\t\tdec.err = err\n+\t}\n+\treturn toInt(n)\n+}\n \n-\t\t// Is it a new type?\n-\t\tif id < 0 { // 0 is the error state, handled above\n-\t\t\t// If the id is negative, we have a type.\n-\t\t\tdec.recvType(-id)\n-\t\t\tif dec.err != nil {\n+func (dec *Decoder) nextUint() uint64 {\n+\tn, _, err := decodeUintReader(&dec.buf, dec.countBuf)\n+\tif err != nil {\n+\t\tdec.err = err\n+\t}\n+\treturn n\n+}\n+\n+// decodeTypeSequence parses:\n+// TypeSequence\n+//\t(TypeDefinition DelimitedTypeDefinition*)?\n+// and returns the type id of the next value.  It returns -1 at\n+// EOF.  Upon return, the remainder of dec.buf is the value to be\n+// decoded.  If this is an interface value, it can be ignored by\n+// simply resetting that buffer.\n+func (dec *Decoder) decodeTypeSequence(isInterface bool) typeId {\n+\tfor dec.err == nil {\n+\t\tif dec.buf.Len() == 0 {\n+\t\t\tif !dec.recvMessage() {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tcontinue\n \t\t}\n-\n-\t\t// Make sure the type has been defined already or is a builtin type (for\n-\t\t// top-level singleton values).\n-\t\tif dec.wireType[id] == nil && builtinIdToType[id] == nil {\n-\t\t\tdec.err = errBadType\n-\t\t\tbreak\n+\t\t// Receive a type id.\n+\t\tid := typeId(dec.nextInt())\n+\t\tif id >= 0 {\n+\t\t\t// Value follows.\n+\t\t\treturn id\n \t\t}\n-\t\t// An interface value is preceded by a byte count.\n-\t\tif countPresent {\n-\t\t\tcount := int(dec.state.decodeUint())\n-\t\t\tif ignoreInterfaceValue {\n-\t\t\t\t// An interface value is preceded by a byte count. Just skip that many bytes.\n-\t\t\t\tdec.state.b.Next(int(count))\n+\t\t// Type definition for (-id) follows.\n+\t\tdec.recvType(-id)\n+\t\t// When decoding an interface, after a type there may be a\n+\t\t// DelimitedValue still in the buffer.  Skip its count.\n+\t\t// (Alternatively, the buffer is empty and the byte count\n+\t\t// will be absorbed by recvMessage.)\n+\t\tif dec.buf.Len() > 0 {\n+\t\t\tif !isInterface {\n+\t\t\t\tdec.err = os.ErrorString(\"extra data in buffer\")\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\t// Otherwise fall through and decode it.\n+\t\t\tdec.nextUint()\n \t\t}\n-\t\tdec.err = dec.decode(id, value)\n-\t\tbreak\n \t}\n+\treturn -1\n+}\n+\n+// Decode reads the next value from the connection and stores\n+// it in the data represented by the empty interface value.\n+// If e is nil, the value will be discarded. Otherwise,\n+// the value underlying e must either be the correct type for the next\n+// data item received, and must be a pointer.\n+func (dec *Decoder) Decode(e interface{}) os.Error {\n+\tif e == nil {\n+\t\treturn dec.DecodeValue(nil)\n+\t}\n+\tvalue := reflect.NewValue(e)\n+\t// If e represents a value as opposed to a pointer, the answer won't\n+\t// get back to the caller.  Make sure it's a pointer.\n+\tif value.Type().Kind() != reflect.Ptr {\n+\t\tdec.err = os.ErrorString(\"gob: attempt to decode into a non-pointer\")\n+\t\treturn dec.err\n+\t}\n+\treturn dec.DecodeValue(value)\n }\n \n // DecodeValue reads the next value from the connection and stores\n // it in the data represented by the reflection value.\n // The value must be the correct type for the next\n-// data item received.\n+// data item received, or it may be nil, which means the\n+// value will be discarded.\n func (dec *Decoder) DecodeValue(value reflect.Value) os.Error {\n \t// Make sure we're single-threaded through here.\n \tdec.mutex.Lock()\n \tdefer dec.mutex.Unlock()\n \n+\tdec.buf.Reset() // In case data lingers from previous invocation.\n \tdec.err = nil\n-\tdec.recv()\n-\tif dec.err != nil {\n-\t\treturn dec.err\n+\tid := dec.decodeTypeSequence(false)\n+\tif dec.err == nil {\n+\t\tdec.err = dec.decodeValue(id, value)\n \t}\n-\tdec.decodeValueFromBuffer(value, false, false)\n \treturn dec.err\n }\n "}, {"sha": "613974a000fbdc9c6109b33c3de96084bac8af87", "filename": "libgo/go/gob/doc.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdoc.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -219,6 +219,54 @@ be predefined or be defined before the value in the stream.\n */\n package gob\n \n+/*\n+Grammar:\n+\n+Tokens starting with a lower case letter are terminals; int(n)\n+and uint(n) represent the signed/unsigned encodings of the value n.\n+\n+GobStream:\n+\tDelimitedMessage*\n+DelimitedMessage:\n+\tuint(lengthOfMessage) Message\n+Message:\n+\tTypeSequence TypedValue\n+TypeSequence\n+\t(TypeDefinition DelimitedTypeDefinition*)?\n+DelimitedTypeDefinition:\n+\tuint(lengthOfTypeDefinition) TypeDefinition\n+TypedValue:\n+\tint(typeId) Value\n+TypeDefinition:\n+\tint(-typeId) encodingOfWireType\n+Value:\n+\tSingletonValue | StructValue\n+SingletonValue:\n+\tuint(0) FieldValue\n+FieldValue:\n+\tbuiltinValue | ArrayValue | MapValue | SliceValue | StructValue | InterfaceValue\n+InterfaceValue:\n+\tNilInterfaceValue | NonNilInterfaceValue\n+NilInterfaceValue:\n+\tuint(0)\n+NonNilInterfaceValue:\n+\tConcreteTypeName TypeSequence InterfaceContents\n+ConcreteTypeName:\n+\tuint(lengthOfName) [already read=n] name\n+InterfaceContents:\n+\tint(concreteTypeId) DelimitedValue\n+DelimitedValue:\n+\tuint(length) Value\n+ArrayValue:\n+\tuint(n) FieldValue*n [n elements]\n+MapValue:\n+\tuint(n) (FieldValue FieldValue)*n  [n (key, value) pairs]\n+SliceValue:\n+\tuint(n) FieldValue*n [n elements]\n+StructValue:\n+\t(uint(fieldDelta) FieldValue)*\n+*/\n+\n /*\n For implementers and the curious, here is an encoded example.  Given\n \ttype Point struct {x, y int}"}, {"sha": "e92db74ffdda3e0b743f109b6f9b7eff03511d38", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 55, "deletions": 45, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -264,9 +264,6 @@ func encComplex128(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n-func encNoOp(i *encInstr, state *encoderState, p unsafe.Pointer) {\n-}\n-\n // Byte arrays are encoded as an unsigned count followed by the raw bytes.\n func encUint8Array(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tb := *(*[]byte)(p)\n@@ -359,7 +356,7 @@ func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir in\n \tif v == nil {\n \t\terrorf(\"gob: encodeReflectValue: nil element\")\n \t}\n-\top(nil, state, unsafe.Pointer(v.Addr()))\n+\top(nil, state, unsafe.Pointer(v.UnsafeAddr()))\n }\n \n func (enc *Encoder) encodeMap(b *bytes.Buffer, mv *reflect.MapValue, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n@@ -387,33 +384,37 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue)\n \t\treturn\n \t}\n \n-\ttyp, _ := indirect(iv.Elem().Type())\n-\tname, ok := concreteTypeToName[typ]\n+\tut := userType(iv.Elem().Type())\n+\tname, ok := concreteTypeToName[ut.base]\n \tif !ok {\n-\t\terrorf(\"gob: type not registered for interface: %s\", typ)\n+\t\terrorf(\"gob: type not registered for interface: %s\", ut.base)\n \t}\n \t// Send the name.\n \tstate.encodeUint(uint64(len(name)))\n \t_, err := io.WriteString(state.b, name)\n \tif err != nil {\n \t\terror(err)\n \t}\n-\t// Send (and maybe first define) the type id.\n-\tenc.sendTypeDescriptor(typ)\n-\t// Encode the value into a new buffer.\n+\t// Define the type id if necessary.\n+\tenc.sendTypeDescriptor(enc.writer(), state, ut)\n+\t// Send the type id.\n+\tenc.sendTypeId(state, ut)\n+\t// Encode the value into a new buffer.  Any nested type definitions\n+\t// should be written to b, before the encoded value.\n+\tenc.pushWriter(b)\n \tdata := new(bytes.Buffer)\n-\terr = enc.encode(data, iv.Elem())\n+\terr = enc.encode(data, iv.Elem(), ut)\n \tif err != nil {\n \t\terror(err)\n \t}\n-\tstate.encodeUint(uint64(data.Len()))\n-\t_, err = state.b.Write(data.Bytes())\n-\tif err != nil {\n+\tenc.popWriter()\n+\tenc.writeMessage(b, data)\n+\tif enc.err != nil {\n \t\terror(err)\n \t}\n }\n \n-var encOpMap = []encOp{\n+var encOpTable = [...]encOp{\n \treflect.Bool:       encBool,\n \treflect.Int:        encInt,\n \treflect.Int8:       encInt8,\n@@ -433,16 +434,24 @@ var encOpMap = []encOp{\n \treflect.String:     encString,\n }\n \n-// Return the encoding op for the base type under rt and\n+// Return (a pointer to) the encoding op for the base type under rt and\n // the indirection count to reach it.\n-func (enc *Encoder) encOpFor(rt reflect.Type) (encOp, int) {\n-\ttyp, indir := indirect(rt)\n-\tvar op encOp\n+func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp) (*encOp, int) {\n+\tut := userType(rt)\n+\t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n+\t// Return the pointer to the op we're already building.\n+\tif opPtr := inProgress[rt]; opPtr != nil {\n+\t\treturn opPtr, ut.indir\n+\t}\n+\ttyp := ut.base\n+\tindir := ut.indir\n \tk := typ.Kind()\n-\tif int(k) < len(encOpMap) {\n-\t\top = encOpMap[k]\n+\tvar op encOp\n+\tif int(k) < len(encOpTable) {\n+\t\top = encOpTable[k]\n \t}\n \tif op == nil {\n+\t\tinProgress[rt] = &op\n \t\t// Special cases\n \t\tswitch t := typ.(type) {\n \t\tcase *reflect.SliceType:\n@@ -451,25 +460,25 @@ func (enc *Encoder) encOpFor(rt reflect.Type) (encOp, int) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\t// Slices have a header; we decode it to find the underlying array.\n-\t\t\telemOp, indir := enc.encOpFor(t.Elem())\n+\t\t\telemOp, indir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tslice := (*reflect.SliceHeader)(p)\n \t\t\t\tif !state.sendZero && slice.Len == 0 {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, slice.Data, elemOp, t.Elem().Size(), indir, int(slice.Len))\n+\t\t\t\tstate.enc.encodeArray(state.b, slice.Data, *elemOp, t.Elem().Size(), indir, int(slice.Len))\n \t\t\t}\n \t\tcase *reflect.ArrayType:\n \t\t\t// True arrays have size in the type.\n-\t\t\telemOp, indir := enc.encOpFor(t.Elem())\n+\t\t\telemOp, indir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeArray(state.b, uintptr(p), elemOp, t.Elem().Size(), indir, t.Len())\n+\t\t\t\tstate.enc.encodeArray(state.b, uintptr(p), *elemOp, t.Elem().Size(), indir, t.Len())\n \t\t\t}\n \t\tcase *reflect.MapType:\n-\t\t\tkeyOp, keyIndir := enc.encOpFor(t.Key())\n-\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem())\n+\t\t\tkeyOp, keyIndir := enc.encOpFor(t.Key(), inProgress)\n+\t\t\telemOp, elemIndir := enc.encOpFor(t.Elem(), inProgress)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\t// Maps cannot be accessed by moving addresses around the way\n \t\t\t\t// that slices etc. can.  We must recover a full reflection value for\n@@ -480,7 +489,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type) (encOp, int) {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tstate.update(i)\n-\t\t\t\tstate.enc.encodeMap(state.b, mv, keyOp, elemOp, keyIndir, elemIndir)\n+\t\t\t\tstate.enc.encodeMap(state.b, mv, *keyOp, *elemOp, keyIndir, elemIndir)\n \t\t\t}\n \t\tcase *reflect.StructType:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n@@ -508,28 +517,31 @@ func (enc *Encoder) encOpFor(rt reflect.Type) (encOp, int) {\n \tif op == nil {\n \t\terrorf(\"gob enc: can't happen: encode type %s\", rt.String())\n \t}\n-\treturn op, indir\n+\treturn &op, indir\n }\n \n // The local Type was compiled from the actual value, so we know it's compatible.\n func (enc *Encoder) compileEnc(rt reflect.Type) *encEngine {\n \tsrt, isStruct := rt.(*reflect.StructType)\n \tengine := new(encEngine)\n+\tseen := make(map[reflect.Type]*encOp)\n \tif isStruct {\n-\t\tengine.instr = make([]encInstr, srt.NumField()+1) // +1 for terminator\n-\t\tfor fieldnum := 0; fieldnum < srt.NumField(); fieldnum++ {\n-\t\t\tf := srt.Field(fieldnum)\n-\t\t\top, indir := enc.encOpFor(f.Type)\n+\t\tfor fieldNum := 0; fieldNum < srt.NumField(); fieldNum++ {\n+\t\t\tf := srt.Field(fieldNum)\n \t\t\tif !isExported(f.Name) {\n-\t\t\t\top = encNoOp\n+\t\t\t\tcontinue\n \t\t\t}\n-\t\t\tengine.instr[fieldnum] = encInstr{op, fieldnum, indir, uintptr(f.Offset)}\n+\t\t\top, indir := enc.encOpFor(f.Type, seen)\n+\t\t\tengine.instr = append(engine.instr, encInstr{*op, fieldNum, indir, uintptr(f.Offset)})\n+\t\t}\n+\t\tif srt.NumField() > 0 && len(engine.instr) == 0 {\n+\t\t\terrorf(\"type %s has no exported fields\", rt)\n \t\t}\n-\t\tengine.instr[srt.NumField()] = encInstr{encStructTerminator, 0, 0, 0}\n+\t\tengine.instr = append(engine.instr, encInstr{encStructTerminator, 0, 0, 0})\n \t} else {\n \t\tengine.instr = make([]encInstr, 1)\n-\t\top, indir := enc.encOpFor(rt)\n-\t\tengine.instr[0] = encInstr{op, singletonField, indir, 0} // offset is zero\n+\t\top, indir := enc.encOpFor(rt, seen)\n+\t\tengine.instr[0] = encInstr{*op, singletonField, indir, 0} // offset is zero\n \t}\n \treturn engine\n }\n@@ -556,18 +568,16 @@ func (enc *Encoder) lockAndGetEncEngine(rt reflect.Type) *encEngine {\n \treturn enc.getEncEngine(rt)\n }\n \n-func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value) (err os.Error) {\n+func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInfo) (err os.Error) {\n \tdefer catchError(&err)\n-\t// Dereference down to the underlying object.\n-\trt, indir := indirect(value.Type())\n-\tfor i := 0; i < indir; i++ {\n+\tfor i := 0; i < ut.indir; i++ {\n \t\tvalue = reflect.Indirect(value)\n \t}\n-\tengine := enc.lockAndGetEncEngine(rt)\n+\tengine := enc.lockAndGetEncEngine(ut.base)\n \tif value.Type().Kind() == reflect.Struct {\n-\t\tenc.encodeStruct(b, engine, value.Addr())\n+\t\tenc.encodeStruct(b, engine, value.UnsafeAddr())\n \t} else {\n-\t\tenc.encodeSingle(b, engine, value.Addr())\n+\t\tenc.encodeSingle(b, engine, value.UnsafeAddr())\n \t}\n \treturn nil\n }"}, {"sha": "92d036c11c3578846dbbaaf6e637d890ee3676ee", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 56, "deletions": 37, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -16,9 +16,8 @@ import (\n // other side of a connection.\n type Encoder struct {\n \tmutex      sync.Mutex              // each item must be sent atomically\n-\tw          io.Writer               // where to send the data\n+\tw          []io.Writer             // where to send the data\n \tsent       map[reflect.Type]typeId // which types we've already sent\n-\tstate      *encoderState           // so we can encode integers, strings directly\n \tcountState *encoderState           // stage for writing counts\n \tbuf        []byte                  // for collecting the output.\n \terr        os.Error\n@@ -27,13 +26,27 @@ type Encoder struct {\n // NewEncoder returns a new encoder that will transmit on the io.Writer.\n func NewEncoder(w io.Writer) *Encoder {\n \tenc := new(Encoder)\n-\tenc.w = w\n+\tenc.w = []io.Writer{w}\n \tenc.sent = make(map[reflect.Type]typeId)\n-\tenc.state = newEncoderState(enc, new(bytes.Buffer))\n \tenc.countState = newEncoderState(enc, new(bytes.Buffer))\n \treturn enc\n }\n \n+// writer() returns the innermost writer the encoder is using\n+func (enc *Encoder) writer() io.Writer {\n+\treturn enc.w[len(enc.w)-1]\n+}\n+\n+// pushWriter adds a writer to the encoder.\n+func (enc *Encoder) pushWriter(w io.Writer) {\n+\tenc.w = append(enc.w, w)\n+}\n+\n+// popWriter pops the innermost writer.\n+func (enc *Encoder) popWriter() {\n+\tenc.w = enc.w[0 : len(enc.w)-1]\n+}\n+\n func (enc *Encoder) badType(rt reflect.Type) {\n \tenc.setError(os.ErrorString(\"gob: can't encode type \" + rt.String()))\n }\n@@ -42,34 +55,33 @@ func (enc *Encoder) setError(err os.Error) {\n \tif enc.err == nil { // remember the first.\n \t\tenc.err = err\n \t}\n-\tenc.state.b.Reset()\n }\n \n-// Send the data item preceded by a unsigned count of its length.\n-func (enc *Encoder) send() {\n-\t// Encode the length.\n-\tenc.countState.encodeUint(uint64(enc.state.b.Len()))\n+// writeMessage sends the data item preceded by a unsigned count of its length.\n+func (enc *Encoder) writeMessage(w io.Writer, b *bytes.Buffer) {\n+\tenc.countState.encodeUint(uint64(b.Len()))\n \t// Build the buffer.\n \tcountLen := enc.countState.b.Len()\n-\ttotal := countLen + enc.state.b.Len()\n+\ttotal := countLen + b.Len()\n \tif total > len(enc.buf) {\n \t\tenc.buf = make([]byte, total+1000) // extra for growth\n \t}\n \t// Place the length before the data.\n \t// TODO(r): avoid the extra copy here.\n \tenc.countState.b.Read(enc.buf[0:countLen])\n \t// Now the data.\n-\tenc.state.b.Read(enc.buf[countLen:total])\n+\tb.Read(enc.buf[countLen:total])\n \t// Write the data.\n-\t_, err := enc.w.Write(enc.buf[0:total])\n+\t_, err := w.Write(enc.buf[0:total])\n \tif err != nil {\n \t\tenc.setError(err)\n \t}\n }\n \n-func (enc *Encoder) sendType(origt reflect.Type) (sent bool) {\n+func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Type) (sent bool) {\n \t// Drill down to the base type.\n-\trt, _ := indirect(origt)\n+\tut := userType(origt)\n+\trt := ut.base\n \n \tswitch rt := rt.(type) {\n \tdefault:\n@@ -112,10 +124,10 @@ func (enc *Encoder) sendType(origt reflect.Type) (sent bool) {\n \t}\n \t// Send the pair (-id, type)\n \t// Id:\n-\tenc.state.encodeInt(-int64(info.id))\n+\tstate.encodeInt(-int64(info.id))\n \t// Type:\n-\tenc.encode(enc.state.b, reflect.NewValue(info.wire))\n-\tenc.send()\n+\tenc.encode(state.b, reflect.NewValue(info.wire), wireTypeUserInfo)\n+\tenc.writeMessage(w, state.b)\n \tif enc.err != nil {\n \t\treturn\n \t}\n@@ -128,10 +140,10 @@ func (enc *Encoder) sendType(origt reflect.Type) (sent bool) {\n \tswitch st := rt.(type) {\n \tcase *reflect.StructType:\n \t\tfor i := 0; i < st.NumField(); i++ {\n-\t\t\tenc.sendType(st.Field(i).Type)\n+\t\t\tenc.sendType(w, state, st.Field(i).Type)\n \t\t}\n \tcase reflect.ArrayOrSliceType:\n-\t\tenc.sendType(st.Elem())\n+\t\tenc.sendType(w, state, st.Elem())\n \t}\n \treturn true\n }\n@@ -142,15 +154,16 @@ func (enc *Encoder) Encode(e interface{}) os.Error {\n \treturn enc.EncodeValue(reflect.NewValue(e))\n }\n \n-// sendTypeId makes sure the remote side knows about this type.\n+// sendTypeDescriptor makes sure the remote side knows about this type.\n // It will send a descriptor if this is the first time the type has been\n-// sent.  Regardless, it sends the id.\n-func (enc *Encoder) sendTypeDescriptor(rt reflect.Type) {\n+// sent.\n+func (enc *Encoder) sendTypeDescriptor(w io.Writer, state *encoderState, ut *userTypeInfo) {\n \t// Make sure the type is known to the other side.\n-\t// First, have we already sent this type?\n-\tif _, alreadySent := enc.sent[rt]; !alreadySent {\n+\t// First, have we already sent this (base) type?\n+\tbase := ut.base\n+\tif _, alreadySent := enc.sent[base]; !alreadySent {\n \t\t// No, so send it.\n-\t\tsent := enc.sendType(rt)\n+\t\tsent := enc.sendType(w, state, base)\n \t\tif enc.err != nil {\n \t\t\treturn\n \t\t}\n@@ -159,18 +172,21 @@ func (enc *Encoder) sendTypeDescriptor(rt reflect.Type) {\n \t\t// need to send the type info but we do need to update enc.sent.\n \t\tif !sent {\n \t\t\ttypeLock.Lock()\n-\t\t\tinfo, err := getTypeInfo(rt)\n+\t\t\tinfo, err := getTypeInfo(base)\n \t\t\ttypeLock.Unlock()\n \t\t\tif err != nil {\n \t\t\t\tenc.setError(err)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tenc.sent[rt] = info.id\n+\t\t\tenc.sent[base] = info.id\n \t\t}\n \t}\n+}\n \n+// sendTypeId sends the id, which must have already been defined.\n+func (enc *Encoder) sendTypeId(state *encoderState, ut *userTypeInfo) {\n \t// Identify the type of this top-level value.\n-\tenc.state.encodeInt(int64(enc.sent[rt]))\n+\tstate.encodeInt(int64(enc.sent[ut.base]))\n }\n \n // EncodeValue transmits the data item represented by the reflection value,\n@@ -181,26 +197,29 @@ func (enc *Encoder) EncodeValue(value reflect.Value) os.Error {\n \tenc.mutex.Lock()\n \tdefer enc.mutex.Unlock()\n \n-\tenc.err = nil\n-\trt, _ := indirect(value.Type())\n+\t// Remove any nested writers remaining due to previous errors.\n+\tenc.w = enc.w[0:1]\n \n-\t// Sanity check only: encoder should never come in with data present.\n-\tif enc.state.b.Len() > 0 || enc.countState.b.Len() > 0 {\n-\t\tenc.err = os.ErrorString(\"encoder: buffer not empty\")\n-\t\treturn enc.err\n+\tut, err := validUserType(value.Type())\n+\tif err != nil {\n+\t\treturn err\n \t}\n \n-\tenc.sendTypeDescriptor(rt)\n+\tenc.err = nil\n+\tstate := newEncoderState(enc, new(bytes.Buffer))\n+\n+\tenc.sendTypeDescriptor(enc.writer(), state, ut)\n+\tenc.sendTypeId(state, ut)\n \tif enc.err != nil {\n \t\treturn enc.err\n \t}\n \n \t// Encode the object.\n-\terr := enc.encode(enc.state.b, value)\n+\terr = enc.encode(state.b, value, ut)\n \tif err != nil {\n \t\tenc.setError(err)\n \t} else {\n-\t\tenc.send()\n+\t\tenc.writeMessage(enc.writer(), state.b)\n \t}\n \n \treturn enc.err"}, {"sha": "a0c713b81dfa0357119b5a2e8ce763002897be7d", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 133, "deletions": 2, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,6 +6,7 @@ package gob\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"os\"\n \t\"reflect\"\n@@ -120,7 +121,7 @@ func corruptDataCheck(s string, err os.Error, t *testing.T) {\n \tdec := NewDecoder(b)\n \terr1 := dec.Decode(new(ET2))\n \tif err1 != err {\n-\t\tt.Error(\"expected error\", err, \"got\", err1)\n+\t\tt.Errorf(\"from %q expected error %s; got %s\", s, err, err1)\n \t}\n }\n \n@@ -220,7 +221,7 @@ func TestSlice(t *testing.T) {\n func TestValueError(t *testing.T) {\n \t// Encode a *T, decode a T\n \ttype Type4 struct {\n-\t\ta int\n+\t\tA int\n \t}\n \tt4p := &Type4{3}\n \tvar t4 Type4 // note: not a pointer.\n@@ -248,6 +249,24 @@ func TestArray(t *testing.T) {\n \t}\n }\n \n+func TestRecursiveMapType(t *testing.T) {\n+\ttype recursiveMap map[string]recursiveMap\n+\tr1 := recursiveMap{\"A\": recursiveMap{\"B\": nil, \"C\": nil}, \"D\": nil}\n+\tr2 := make(recursiveMap)\n+\tif err := encAndDec(r1, &r2); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func TestRecursiveSliceType(t *testing.T) {\n+\ttype recursiveSlice []recursiveSlice\n+\tr1 := recursiveSlice{0: recursiveSlice{0: nil}, 1: nil}\n+\tr2 := make(recursiveSlice, 0)\n+\tif err := encAndDec(r1, &r2); err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n // Regression test for bug: must send zero values inside arrays\n func TestDefaultsInArray(t *testing.T) {\n \ttype Type7 struct {\n@@ -383,3 +402,115 @@ func TestInterfaceIndirect(t *testing.T) {\n \t\tt.Fatal(\"decode error:\", err)\n \t}\n }\n+\n+// Now follow various tests that decode into things that can't represent the\n+// encoded value, all of which should be legal.\n+\n+// Also, when the ignored object contains an interface value, it may define\n+// types. Make sure that skipping the value still defines the types by using\n+// the encoder/decoder pair to send a value afterwards.  If an interface\n+// is sent, its type in the test is always NewType0, so this checks that the\n+// encoder and decoder don't skew with respect to type definitions.\n+\n+type Struct0 struct {\n+\tI interface{}\n+}\n+\n+type NewType0 struct {\n+\tS string\n+}\n+\n+type ignoreTest struct {\n+\tin, out interface{}\n+}\n+\n+var ignoreTests = []ignoreTest{\n+\t// Decode normal struct into an empty struct\n+\t{&struct{ A int }{23}, &struct{}{}},\n+\t// Decode normal struct into a nil.\n+\t{&struct{ A int }{23}, nil},\n+\t// Decode singleton string into a nil.\n+\t{\"hello, world\", nil},\n+\t// Decode singleton slice into a nil.\n+\t{[]int{1, 2, 3, 4}, nil},\n+\t// Decode struct containing an interface into a nil.\n+\t{&Struct0{&NewType0{\"value0\"}}, nil},\n+\t// Decode singleton slice of interfaces into a nil.\n+\t{[]interface{}{\"hi\", &NewType0{\"value1\"}, 23}, nil},\n+}\n+\n+func TestDecodeIntoNothing(t *testing.T) {\n+\tRegister(new(NewType0))\n+\tfor i, test := range ignoreTests {\n+\t\tb := new(bytes.Buffer)\n+\t\tenc := NewEncoder(b)\n+\t\terr := enc.Encode(test.in)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: encode error %s:\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tdec := NewDecoder(b)\n+\t\terr = dec.Decode(test.out)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%d: decode error: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Now see if the encoder and decoder are in a consistent state.\n+\t\tstr := fmt.Sprintf(\"Value %d\", i)\n+\t\terr = enc.Encode(&NewType0{str})\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%d: NewType0 encode error: %s\", i, err)\n+\t\t}\n+\t\tns := new(NewType0)\n+\t\terr = dec.Decode(ns)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%d: NewType0 decode error: %s\", i, err)\n+\t\t}\n+\t\tif ns.S != str {\n+\t\t\tt.Fatalf(\"%d: expected %q got %q\", i, str, ns.S)\n+\t\t}\n+\t}\n+}\n+\n+// Another bug from golang-nuts, involving nested interfaces.\n+type Bug0Outer struct {\n+\tBug0Field interface{}\n+}\n+\n+type Bug0Inner struct {\n+\tA int\n+}\n+\n+func TestNestedInterfaces(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\te := NewEncoder(&buf)\n+\td := NewDecoder(&buf)\n+\tRegister(new(Bug0Outer))\n+\tRegister(new(Bug0Inner))\n+\tf := &Bug0Outer{&Bug0Outer{&Bug0Inner{7}}}\n+\tvar v interface{} = f\n+\terr := e.Encode(&v)\n+\tif err != nil {\n+\t\tt.Fatal(\"Encode:\", err)\n+\t}\n+\terr = d.Decode(&v)\n+\tif err != nil {\n+\t\tt.Fatal(\"Decode:\", err)\n+\t}\n+\t// Make sure it decoded correctly.\n+\touter1, ok := v.(*Bug0Outer)\n+\tif !ok {\n+\t\tt.Fatalf(\"v not Bug0Outer: %T\", v)\n+\t}\n+\touter2, ok := outer1.Bug0Field.(*Bug0Outer)\n+\tif !ok {\n+\t\tt.Fatalf(\"v.Bug0Field not Bug0Outer: %T\", outer1.Bug0Field)\n+\t}\n+\tinner, ok := outer2.Bug0Field.(*Bug0Inner)\n+\tif !ok {\n+\t\tt.Fatalf(\"v.Bug0Field.Bug0Field not Bug0Inner: %T\", outer2.Bug0Field)\n+\t}\n+\tif inner.A != 7 {\n+\t\tt.Fatalf(\"final value %d; expected %d\", inner.A, 7)\n+\t}\n+}"}, {"sha": "6e3f148b4e7d3e95e3a773b064e0533315ebb9d2", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 151, "deletions": 53, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -11,13 +11,76 @@ import (\n \t\"sync\"\n )\n \n-// Reflection types are themselves interface values holding structs\n-// describing the type.  Each type has a different struct so that struct can\n-// be the kind.  For example, if typ is the reflect type for an int8, typ is\n-// a pointer to a reflect.Int8Type struct; if typ is the reflect type for a\n-// function, typ is a pointer to a reflect.FuncType struct; we use the type\n-// of that pointer as the kind.\n+// userTypeInfo stores the information associated with a type the user has handed\n+// to the package.  It's computed once and stored in a map keyed by reflection\n+// type.\n+type userTypeInfo struct {\n+\tuser  reflect.Type // the type the user handed us\n+\tbase  reflect.Type // the base type after all indirections\n+\tindir int          // number of indirections to reach the base type\n+}\n+\n+var (\n+\t// Protected by an RWMutex because we read it a lot and write\n+\t// it only when we see a new type, typically when compiling.\n+\tuserTypeLock  sync.RWMutex\n+\tuserTypeCache = make(map[reflect.Type]*userTypeInfo)\n+)\n+\n+// validType returns, and saves, the information associated with user-provided type rt.\n+// If the user type is not valid, err will be non-nil.  To be used when the error handler\n+// is not set up.\n+func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n+\tuserTypeLock.RLock()\n+\tut = userTypeCache[rt]\n+\tuserTypeLock.RUnlock()\n+\tif ut != nil {\n+\t\treturn\n+\t}\n+\t// Now set the value under the write lock.\n+\tuserTypeLock.Lock()\n+\tdefer userTypeLock.Unlock()\n+\tif ut = userTypeCache[rt]; ut != nil {\n+\t\t// Lost the race; not a problem.\n+\t\treturn\n+\t}\n+\tut = new(userTypeInfo)\n+\tut.base = rt\n+\tut.user = rt\n+\t// A type that is just a cycle of pointers (such as type T *T) cannot\n+\t// be represented in gobs, which need some concrete data.  We use a\n+\t// cycle detection algorithm from Knuth, Vol 2, Section 3.1, Ex 6,\n+\t// pp 539-540.  As we step through indirections, run another type at\n+\t// half speed. If they meet up, there's a cycle.\n+\tslowpoke := ut.base // walks half as fast as ut.base\n+\tfor {\n+\t\tpt, ok := ut.base.(*reflect.PtrType)\n+\t\tif !ok {\n+\t\t\tbreak\n+\t\t}\n+\t\tut.base = pt.Elem()\n+\t\tif ut.base == slowpoke { // ut.base lapped slowpoke\n+\t\t\t// recursive pointer type.\n+\t\t\treturn nil, os.ErrorString(\"can't represent recursive pointer type \" + ut.base.String())\n+\t\t}\n+\t\tif ut.indir%2 == 0 {\n+\t\t\tslowpoke = slowpoke.(*reflect.PtrType).Elem()\n+\t\t}\n+\t\tut.indir++\n+\t}\n+\tuserTypeCache[rt] = ut\n+\treturn\n+}\n \n+// userType returns, and saves, the information associated with user-provided type rt.\n+// If the user type is not valid, it calls error.\n+func userType(rt reflect.Type) *userTypeInfo {\n+\tut, err := validUserType(rt)\n+\tif err != nil {\n+\t\terror(err)\n+\t}\n+\treturn ut\n+}\n // A typeId represents a gob Type as an integer that can be passed on the wire.\n // Internally, typeIds are used as keys to a map to recover the underlying type info.\n type typeId int32\n@@ -93,7 +156,7 @@ var (\n \ttBool      = bootstrapType(\"bool\", false, 1)\n \ttInt       = bootstrapType(\"int\", int(0), 2)\n \ttUint      = bootstrapType(\"uint\", uint(0), 3)\n-\ttFloat     = bootstrapType(\"float\", 0.0, 4)\n+\ttFloat     = bootstrapType(\"float\", float64(0), 4)\n \ttBytes     = bootstrapType(\"bytes\", make([]byte, 0), 5)\n \ttString    = bootstrapType(\"string\", \"\", 6)\n \ttComplex   = bootstrapType(\"complex\", 0+0i, 7)\n@@ -110,6 +173,7 @@ var (\n \n // Predefined because it's needed by the Decoder\n var tWireType = mustGetTypeInfo(reflect.Typeof(wireType{})).id\n+var wireTypeUserInfo *userTypeInfo // userTypeInfo of (*wireType)\n \n func init() {\n \t// Some magic numbers to make sure there are no surprises.\n@@ -133,6 +197,7 @@ func init() {\n \t}\n \tnextId = firstUserId\n \tregisterBasics()\n+\twireTypeUserInfo = userType(reflect.Typeof((*wireType)(nil)))\n }\n \n // Array type\n@@ -142,12 +207,18 @@ type arrayType struct {\n \tLen  int\n }\n \n-func newArrayType(name string, elem gobType, length int) *arrayType {\n-\ta := &arrayType{CommonType{Name: name}, elem.id(), length}\n-\tsetTypeId(a)\n+func newArrayType(name string) *arrayType {\n+\ta := &arrayType{CommonType{Name: name}, 0, 0}\n \treturn a\n }\n \n+func (a *arrayType) init(elem gobType, len int) {\n+\t// Set our type id before evaluating the element's, in case it's our own.\n+\tsetTypeId(a)\n+\ta.Elem = elem.id()\n+\ta.Len = len\n+}\n+\n func (a *arrayType) safeString(seen map[typeId]bool) string {\n \tif seen[a.Id] {\n \t\treturn a.Name\n@@ -165,12 +236,18 @@ type mapType struct {\n \tElem typeId\n }\n \n-func newMapType(name string, key, elem gobType) *mapType {\n-\tm := &mapType{CommonType{Name: name}, key.id(), elem.id()}\n-\tsetTypeId(m)\n+func newMapType(name string) *mapType {\n+\tm := &mapType{CommonType{Name: name}, 0, 0}\n \treturn m\n }\n \n+func (m *mapType) init(key, elem gobType) {\n+\t// Set our type id before evaluating the element's, in case it's our own.\n+\tsetTypeId(m)\n+\tm.Key = key.id()\n+\tm.Elem = elem.id()\n+}\n+\n func (m *mapType) safeString(seen map[typeId]bool) string {\n \tif seen[m.Id] {\n \t\treturn m.Name\n@@ -189,12 +266,17 @@ type sliceType struct {\n \tElem typeId\n }\n \n-func newSliceType(name string, elem gobType) *sliceType {\n-\ts := &sliceType{CommonType{Name: name}, elem.id()}\n-\tsetTypeId(s)\n+func newSliceType(name string) *sliceType {\n+\ts := &sliceType{CommonType{Name: name}, 0}\n \treturn s\n }\n \n+func (s *sliceType) init(elem gobType) {\n+\t// Set our type id before evaluating the element's, in case it's our own.\n+\tsetTypeId(s)\n+\ts.Elem = elem.id()\n+}\n+\n func (s *sliceType) safeString(seen map[typeId]bool) string {\n \tif seen[s.Id] {\n \t\treturn s.Name\n@@ -236,26 +318,26 @@ func (s *structType) string() string { return s.safeString(make(map[typeId]bool)\n \n func newStructType(name string) *structType {\n \ts := &structType{CommonType{Name: name}, nil}\n+\t// For historical reasons we set the id here rather than init.\n+\t// Se the comment in newTypeObject for details.\n \tsetTypeId(s)\n \treturn s\n }\n \n-// Step through the indirections on a type to discover the base type.\n-// Return the base type and the number of indirections.\n-func indirect(t reflect.Type) (rt reflect.Type, count int) {\n-\trt = t\n-\tfor {\n-\t\tpt, ok := rt.(*reflect.PtrType)\n-\t\tif !ok {\n-\t\t\tbreak\n-\t\t}\n-\t\trt = pt.Elem()\n-\t\tcount++\n-\t}\n-\treturn\n+func (s *structType) init(field []*fieldType) {\n+\ts.Field = field\n }\n \n func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n+\tvar err os.Error\n+\tvar type0, type1 gobType\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\ttypes[rt] = nil, false\n+\t\t}\n+\t}()\n+\t// Install the top-level type before the subtypes (e.g. struct before\n+\t// fields) so recursive types can be constructed safely.\n \tswitch t := rt.(type) {\n \t// All basic types are easy: they are predefined.\n \tcase *reflect.BoolType:\n@@ -280,47 +362,62 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \t\treturn tInterface.gobType(), nil\n \n \tcase *reflect.ArrayType:\n-\t\tgt, err := getType(\"\", t.Elem())\n+\t\tat := newArrayType(name)\n+\t\ttypes[rt] = at\n+\t\ttype0, err = getType(\"\", t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn newArrayType(name, gt, t.Len()), nil\n+\t\t// Historical aside:\n+\t\t// For arrays, maps, and slices, we set the type id after the elements\n+\t\t// are constructed. This is to retain the order of type id allocation after\n+\t\t// a fix made to handle recursive types, which changed the order in\n+\t\t// which types are built.  Delaying the setting in this way preserves\n+\t\t// type ids while allowing recursive types to be described. Structs,\n+\t\t// done below, were already handling recursion correctly so they\n+\t\t// assign the top-level id before those of the field.\n+\t\tat.init(type0, t.Len())\n+\t\treturn at, nil\n \n \tcase *reflect.MapType:\n-\t\tkt, err := getType(\"\", t.Key())\n+\t\tmt := newMapType(name)\n+\t\ttypes[rt] = mt\n+\t\ttype0, err = getType(\"\", t.Key())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tvt, err := getType(\"\", t.Elem())\n+\t\ttype1, err = getType(\"\", t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn newMapType(name, kt, vt), nil\n+\t\tmt.init(type0, type1)\n+\t\treturn mt, nil\n \n \tcase *reflect.SliceType:\n \t\t// []byte == []uint8 is a special case\n \t\tif t.Elem().Kind() == reflect.Uint8 {\n \t\t\treturn tBytes.gobType(), nil\n \t\t}\n-\t\tgt, err := getType(t.Elem().Name(), t.Elem())\n+\t\tst := newSliceType(name)\n+\t\ttypes[rt] = st\n+\t\ttype0, err = getType(t.Elem().Name(), t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\treturn newSliceType(name, gt), nil\n+\t\tst.init(type0)\n+\t\treturn st, nil\n \n \tcase *reflect.StructType:\n-\t\t// Install the struct type itself before the fields so recursive\n-\t\t// structures can be constructed safely.\n-\t\tstrType := newStructType(name)\n-\t\ttypes[rt] = strType\n-\t\tidToType[strType.id()] = strType\n+\t\tst := newStructType(name)\n+\t\ttypes[rt] = st\n+\t\tidToType[st.id()] = st\n \t\tfield := make([]*fieldType, t.NumField())\n \t\tfor i := 0; i < t.NumField(); i++ {\n \t\t\tf := t.Field(i)\n-\t\t\ttyp, _ := indirect(f.Type)\n+\t\t\ttyp := userType(f.Type).base\n \t\t\ttname := typ.Name()\n \t\t\tif tname == \"\" {\n-\t\t\t\tt, _ := indirect(f.Type)\n+\t\t\t\tt := userType(f.Type).base\n \t\t\t\ttname = t.String()\n \t\t\t}\n \t\t\tgt, err := getType(tname, f.Type)\n@@ -329,8 +426,8 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \t\t\t}\n \t\t\tfield[i] = &fieldType{f.Name, gt.id()}\n \t\t}\n-\t\tstrType.Field = field\n-\t\treturn strType, nil\n+\t\tst.init(field)\n+\t\treturn st, nil\n \n \tdefault:\n \t\treturn nil, os.ErrorString(\"gob NewTypeObject can't handle type: \" + rt.String())\n@@ -341,7 +438,7 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n // getType returns the Gob type describing the given reflect.Type.\n // typeLock must be held.\n func getType(name string, rt reflect.Type) (gobType, os.Error) {\n-\trt, _ = indirect(rt)\n+\trt = userType(rt).base\n \ttyp, present := types[rt]\n \tif present {\n \t\treturn typ, nil\n@@ -371,6 +468,7 @@ func bootstrapType(name string, e interface{}, expect typeId) typeId {\n \ttypes[rt] = typ\n \tsetTypeId(typ)\n \tcheckId(expect, nextId)\n+\tuserType(rt) // might as well cache it now\n \treturn nextId\n }\n \n@@ -381,7 +479,7 @@ func bootstrapType(name string, e interface{}, expect typeId) typeId {\n // For bootstrapping purposes, we assume that the recipient knows how\n // to decode a wireType; it is exactly the wireType struct here, interpreted\n // using the gob rules for sending a structure, except that we assume the\n-// ids for wireType and structType are known.  The relevant pieces\n+// ids for wireType and structType etc. are known.  The relevant pieces\n // are built in encode.go's init() function.\n // To maintain binary compatibility, if you extend this type, always put\n // the new fields last.\n@@ -473,18 +571,18 @@ func RegisterName(name string, value interface{}) {\n \t\t// reserved for nil\n \t\tpanic(\"attempt to register empty name\")\n \t}\n-\trt, _ := indirect(reflect.Typeof(value))\n+\tbase := userType(reflect.Typeof(value)).base\n \t// Check for incompatible duplicates.\n-\tif t, ok := nameToConcreteType[name]; ok && t != rt {\n+\tif t, ok := nameToConcreteType[name]; ok && t != base {\n \t\tpanic(\"gob: registering duplicate types for \" + name)\n \t}\n-\tif n, ok := concreteTypeToName[rt]; ok && n != name {\n-\t\tpanic(\"gob: registering duplicate names for \" + rt.String())\n+\tif n, ok := concreteTypeToName[base]; ok && n != name {\n+\t\tpanic(\"gob: registering duplicate names for \" + base.String())\n \t}\n \t// Store the name and type provided by the user....\n \tnameToConcreteType[name] = reflect.Typeof(value)\n \t// but the flattened type in the type table, since that's what decode needs.\n-\tconcreteTypeToName[rt] = name\n+\tconcreteTypeToName[base] = name\n }\n \n // Register records a type, identified by a value for that type, under its\n@@ -530,7 +628,7 @@ func registerBasics() {\n \tRegister(uint32(0))\n \tRegister(uint64(0))\n \tRegister(float32(0))\n-\tRegister(0.0)\n+\tRegister(float64(0))\n \tRegister(complex64(0i))\n \tRegister(complex128(0i))\n \tRegister(false)"}, {"sha": "4f5dee72da32a135a16bb5ba631f4b4f42473d3a", "filename": "libgo/go/html/doc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoc.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -69,6 +69,9 @@ call to Next. For example, to extract an HTML page's anchor text:\n \t\t}\n \t}\n \n+A Tokenizer typically skips over HTML comments. To return comment tokens, set\n+Tokenizer.ReturnComments to true before looping over calls to Next.\n+\n Parsing is done by calling Parse with an io.Reader, which returns the root of\n the parse tree (the document element) as a *Node. It is the caller's\n responsibility to ensure that the Reader provides UTF-8 encoded HTML. For"}, {"sha": "ad03241ed920adce0c49540fc7fd7b4a2a09da00", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 102, "deletions": 33, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -25,6 +25,8 @@ const (\n \tEndTagToken\n \t// A SelfClosingTagToken tag looks like <br/>.\n \tSelfClosingTagToken\n+\t// A CommentToken looks like <!--x-->.\n+\tCommentToken\n )\n \n // String returns a string representation of the TokenType.\n@@ -40,6 +42,8 @@ func (t TokenType) String() string {\n \t\treturn \"EndTag\"\n \tcase SelfClosingTagToken:\n \t\treturn \"SelfClosingTag\"\n+\tcase CommentToken:\n+\t\treturn \"Comment\"\n \t}\n \treturn \"Invalid(\" + strconv.Itoa(int(t)) + \")\"\n }\n@@ -52,8 +56,8 @@ type Attribute struct {\n }\n \n // A Token consists of a TokenType and some Data (tag name for start and end\n-// tags, content for text). A tag Token may also contain a slice of Attributes.\n-// Data is unescaped for both tag and text Tokens (it looks like \"a<b\" rather\n+// tags, content for text and comments). A tag Token may also contain a slice\n+// of Attributes. Data is unescaped for all Tokens (it looks like \"a<b\" rather\n // than \"a&lt;b\").\n type Token struct {\n \tType TokenType\n@@ -91,12 +95,18 @@ func (t Token) String() string {\n \t\treturn \"</\" + t.tagString() + \">\"\n \tcase SelfClosingTagToken:\n \t\treturn \"<\" + t.tagString() + \"/>\"\n+\tcase CommentToken:\n+\t\treturn \"<!--\" + EscapeString(t.Data) + \"-->\"\n \t}\n \treturn \"Invalid(\" + strconv.Itoa(int(t.Type)) + \")\"\n }\n \n // A Tokenizer returns a stream of HTML Tokens.\n type Tokenizer struct {\n+\t// If ReturnComments is set, Next returns comment tokens;\n+\t// otherwise it skips over comments (default).\n+\tReturnComments bool\n+\n \t// r is the source of the HTML text.\n \tr io.Reader\n \t// tt is the TokenType of the most recently read token. If tt == Error\n@@ -176,6 +186,39 @@ func (z *Tokenizer) readTo(x uint8) os.Error {\n \tpanic(\"unreachable\")\n }\n \n+// nextMarkupDeclaration returns the next TokenType starting with \"<!\".\n+func (z *Tokenizer) nextMarkupDeclaration() (TokenType, os.Error) {\n+\t// TODO: check for <!DOCTYPE ... >, don't just assume that it's a comment.\n+\tfor i := 0; i < 2; i++ {\n+\t\tc, err := z.readByte()\n+\t\tif err != nil {\n+\t\t\treturn TextToken, err\n+\t\t}\n+\t\tif c != '-' {\n+\t\t\treturn z.nextText(), nil\n+\t\t}\n+\t}\n+\t// <!--> is a valid comment.\n+\tfor dashCount := 2; ; {\n+\t\tc, err := z.readByte()\n+\t\tif err != nil {\n+\t\t\treturn TextToken, err\n+\t\t}\n+\t\tswitch c {\n+\t\tcase '-':\n+\t\t\tdashCount++\n+\t\tcase '>':\n+\t\t\tif dashCount >= 2 {\n+\t\t\t\treturn CommentToken, nil\n+\t\t\t}\n+\t\t\tfallthrough\n+\t\tdefault:\n+\t\t\tdashCount = 0\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n // nextTag returns the next TokenType starting from the tag open state.\n func (z *Tokenizer) nextTag() (tt TokenType, err os.Error) {\n \tc, err := z.readByte()\n@@ -189,7 +232,7 @@ func (z *Tokenizer) nextTag() (tt TokenType, err os.Error) {\n \tcase 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':\n \t\ttt = StartTagToken\n \tcase c == '!':\n-\t\treturn ErrorToken, os.NewError(\"html: TODO(nigeltao): implement comments\")\n+\t\treturn z.nextMarkupDeclaration()\n \tcase c == '?':\n \t\treturn ErrorToken, os.NewError(\"html: TODO(nigeltao): implement XML processing instructions\")\n \tdefault:\n@@ -221,22 +264,8 @@ func (z *Tokenizer) nextTag() (tt TokenType, err os.Error) {\n \tpanic(\"unreachable\")\n }\n \n-// Next scans the next token and returns its type.\n-func (z *Tokenizer) Next() TokenType {\n-\tif z.err != nil {\n-\t\tz.tt = ErrorToken\n-\t\treturn z.tt\n-\t}\n-\tz.p0 = z.p1\n-\tc, err := z.readByte()\n-\tif err != nil {\n-\t\tz.tt, z.err = ErrorToken, err\n-\t\treturn z.tt\n-\t}\n-\tif c == '<' {\n-\t\tz.tt, z.err = z.nextTag()\n-\t\treturn z.tt\n-\t}\n+// nextText reads all text up until an '<'.\n+func (z *Tokenizer) nextText() TokenType {\n \tfor {\n \t\tc, err := z.readByte()\n \t\tif err != nil {\n@@ -255,6 +284,31 @@ func (z *Tokenizer) Next() TokenType {\n \tpanic(\"unreachable\")\n }\n \n+// Next scans the next token and returns its type.\n+func (z *Tokenizer) Next() TokenType {\n+\tfor {\n+\t\tif z.err != nil {\n+\t\t\tz.tt = ErrorToken\n+\t\t\treturn z.tt\n+\t\t}\n+\t\tz.p0 = z.p1\n+\t\tc, err := z.readByte()\n+\t\tif err != nil {\n+\t\t\tz.tt, z.err = ErrorToken, err\n+\t\t\treturn z.tt\n+\t\t}\n+\t\tif c == '<' {\n+\t\t\tz.tt, z.err = z.nextTag()\n+\t\t\tif z.tt == CommentToken && !z.ReturnComments {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn z.tt\n+\t\t}\n+\t\treturn z.nextText()\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n // trim returns the largest j such that z.buf[i:j] contains only white space,\n // or only white space plus the final \">\" or \"/>\" of the raw data.\n func (z *Tokenizer) trim(i int) int {\n@@ -299,18 +353,33 @@ loop:\n \treturn z.buf[i0:i], z.trim(i)\n }\n \n-// Text returns the raw data after unescaping.\n+// Text returns the unescaped text of a TextToken or a CommentToken.\n // The contents of the returned slice may change on the next call to Next.\n func (z *Tokenizer) Text() []byte {\n-\ts := unescape(z.Raw())\n-\tz.p0 = z.p1\n-\treturn s\n+\tswitch z.tt {\n+\tcase TextToken:\n+\t\ts := unescape(z.Raw())\n+\t\tz.p0 = z.p1\n+\t\treturn s\n+\tcase CommentToken:\n+\t\t// We trim the \"<!--\" from the left and the \"-->\" from the right.\n+\t\t// \"<!-->\" is a valid comment, so the adjusted endpoints might overlap.\n+\t\ti0 := z.p0 + 4\n+\t\ti1 := z.p1 - 3\n+\t\tz.p0 = z.p1\n+\t\tvar s []byte\n+\t\tif i0 < i1 {\n+\t\t\ts = unescape(z.buf[i0:i1])\n+\t\t}\n+\t\treturn s\n+\t}\n+\treturn nil\n }\n \n // TagName returns the lower-cased name of a tag token (the `img` out of\n-// `<IMG SRC=\"foo\">`), and whether the tag has attributes.\n+// `<IMG SRC=\"foo\">`) and whether the tag has attributes.\n // The contents of the returned slice may change on the next call to Next.\n-func (z *Tokenizer) TagName() (name []byte, remaining bool) {\n+func (z *Tokenizer) TagName() (name []byte, hasAttr bool) {\n \ti := z.p0 + 1\n \tif i >= z.p1 {\n \t\tz.p0 = z.p1\n@@ -320,14 +389,14 @@ func (z *Tokenizer) TagName() (name []byte, remaining bool) {\n \t\ti++\n \t}\n \tname, z.p0 = z.lower(i)\n-\tremaining = z.p0 != z.p1\n+\thasAttr = z.p0 != z.p1\n \treturn\n }\n \n // TagAttr returns the lower-cased key and unescaped value of the next unparsed\n-// attribute for the current tag token, and whether there are more attributes.\n+// attribute for the current tag token and whether there are more attributes.\n // The contents of the returned slices may change on the next call to Next.\n-func (z *Tokenizer) TagAttr() (key, val []byte, remaining bool) {\n+func (z *Tokenizer) TagAttr() (key, val []byte, moreAttr bool) {\n \tkey, i := z.lower(z.p0)\n \t// Get past the \"=\\\"\".\n \tif i == z.p1 || z.buf[i] != '=' {\n@@ -363,7 +432,7 @@ loop:\n \t\t}\n \t}\n \tval, z.p0 = z.buf[i:dst], z.trim(src)\n-\tremaining = z.p0 != z.p1\n+\tmoreAttr = z.p0 != z.p1\n \treturn\n }\n \n@@ -372,14 +441,14 @@ loop:\n func (z *Tokenizer) Token() Token {\n \tt := Token{Type: z.tt}\n \tswitch z.tt {\n-\tcase TextToken:\n+\tcase TextToken, CommentToken:\n \t\tt.Data = string(z.Text())\n \tcase StartTagToken, EndTagToken, SelfClosingTagToken:\n \t\tvar attr []Attribute\n-\t\tname, remaining := z.TagName()\n-\t\tfor remaining {\n+\t\tname, moreAttr := z.TagName()\n+\t\tfor moreAttr {\n \t\t\tvar key, val []byte\n-\t\t\tkey, val, remaining = z.TagAttr()\n+\t\t\tkey, val, moreAttr = z.TagAttr()\n \t\t\tattr = append(attr, Attribute{string(key), string(val)})\n \t\t}\n \t\tt.Data = string(name)"}, {"sha": "5cf1f6dac30b9df19b899a7503c5ce2421c7941e", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,6 +7,7 @@ package html\n import (\n \t\"bytes\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -15,8 +16,8 @@ type tokenTest struct {\n \tdesc string\n \t// The HTML to parse.\n \thtml string\n-\t// The string representations of the expected tokens.\n-\ttokens []string\n+\t// The string representations of the expected tokens, joined by '$'.\n+\tgolden string\n }\n \n var tokenTests = []tokenTest{\n@@ -25,69 +26,94 @@ var tokenTests = []tokenTest{\n \t{\n \t\t\"text\",\n \t\t\"foo  bar\",\n-\t\t[]string{\n-\t\t\t\"foo  bar\",\n-\t\t},\n+\t\t\"foo  bar\",\n \t},\n \t// An entity.\n \t{\n \t\t\"entity\",\n \t\t\"one &lt; two\",\n-\t\t[]string{\n-\t\t\t\"one &lt; two\",\n-\t\t},\n+\t\t\"one &lt; two\",\n \t},\n \t// A start, self-closing and end tag. The tokenizer does not care if the start\n \t// and end tokens don't match; that is the job of the parser.\n \t{\n \t\t\"tags\",\n \t\t\"<a>b<c/>d</e>\",\n-\t\t[]string{\n-\t\t\t\"<a>\",\n-\t\t\t\"b\",\n-\t\t\t\"<c/>\",\n-\t\t\t\"d\",\n-\t\t\t\"</e>\",\n-\t\t},\n+\t\t\"<a>$b$<c/>$d$</e>\",\n+\t},\n+\t// Comments.\n+\t{\n+\t\t\"comment0\",\n+\t\t\"abc<b><!-- skipme --></b>def\",\n+\t\t\"abc$<b>$</b>$def\",\n+\t},\n+\t{\n+\t\t\"comment1\",\n+\t\t\"a<!-->z\",\n+\t\t\"a$z\",\n+\t},\n+\t{\n+\t\t\"comment2\",\n+\t\t\"a<!--->z\",\n+\t\t\"a$z\",\n+\t},\n+\t{\n+\t\t\"comment3\",\n+\t\t\"a<!--x>-->z\",\n+\t\t\"a$z\",\n+\t},\n+\t{\n+\t\t\"comment4\",\n+\t\t\"a<!--x->-->z\",\n+\t\t\"a$z\",\n+\t},\n+\t{\n+\t\t\"comment5\",\n+\t\t\"a<!>z\",\n+\t\t\"a$&lt;!&gt;z\",\n+\t},\n+\t{\n+\t\t\"comment6\",\n+\t\t\"a<!->z\",\n+\t\t\"a$&lt;!-&gt;z\",\n+\t},\n+\t{\n+\t\t\"comment7\",\n+\t\t\"a<!---<>z\",\n+\t\t\"a$&lt;!---&lt;&gt;z\",\n+\t},\n+\t{\n+\t\t\"comment8\",\n+\t\t\"a<!--z\",\n+\t\t\"a$&lt;!--z\",\n \t},\n \t// An attribute with a backslash.\n \t{\n \t\t\"backslash\",\n \t\t`<p id=\"a\\\"b\">`,\n-\t\t[]string{\n-\t\t\t`<p id=\"a&quot;b\">`,\n-\t\t},\n+\t\t`<p id=\"a&quot;b\">`,\n \t},\n \t// Entities, tag name and attribute key lower-casing, and whitespace\n \t// normalization within a tag.\n \t{\n \t\t\"tricky\",\n \t\t\"<p \\t\\n iD=\\\"a&quot;B\\\"  foo=\\\"bar\\\"><EM>te&lt;&amp;;xt</em></p>\",\n-\t\t[]string{\n-\t\t\t`<p id=\"a&quot;B\" foo=\"bar\">`,\n-\t\t\t\"<em>\",\n-\t\t\t\"te&lt;&amp;;xt\",\n-\t\t\t\"</em>\",\n-\t\t\t\"</p>\",\n-\t\t},\n+\t\t`<p id=\"a&quot;B\" foo=\"bar\">$<em>$te&lt;&amp;;xt$</em>$</p>`,\n \t},\n \t// A non-existant entity. Tokenizing and converting back to a string should\n \t// escape the \"&\" to become \"&amp;\".\n \t{\n \t\t\"noSuchEntity\",\n \t\t`<a b=\"c&noSuchEntity;d\">&lt;&alsoDoesntExist;&`,\n-\t\t[]string{\n-\t\t\t`<a b=\"c&amp;noSuchEntity;d\">`,\n-\t\t\t\"&lt;&amp;alsoDoesntExist;&amp;\",\n-\t\t},\n+\t\t`<a b=\"c&amp;noSuchEntity;d\">$&lt;&amp;alsoDoesntExist;&amp;`,\n \t},\n }\n \n func TestTokenizer(t *testing.T) {\n loop:\n \tfor _, tt := range tokenTests {\n \t\tz := NewTokenizer(bytes.NewBuffer([]byte(tt.html)))\n-\t\tfor i, s := range tt.tokens {\n+\t\tfor i, s := range strings.Split(tt.golden, \"$\", -1) {\n \t\t\tif z.Next() == ErrorToken {\n \t\t\t\tt.Errorf(\"%s token %d: want %q got error %v\", tt.desc, i, s, z.Error())\n \t\t\t\tcontinue loop"}, {"sha": "b1fe5ec67803454a823dd37cb374e1f2a4d86b00", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 150, "deletions": 66, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,18 +7,41 @@\n package http\n \n import (\n-\t\"bufio\"\n \t\"bytes\"\n-\t\"crypto/tls\"\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"io\"\n-\t\"net\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n )\n \n+// A Client is an HTTP client. Its zero value (DefaultClient) is a usable client\n+// that uses DefaultTransport.\n+// Client is not yet very configurable.\n+type Client struct {\n+\tTransport ClientTransport // if nil, DefaultTransport is used\n+}\n+\n+// DefaultClient is the default Client and is used by Get, Head, and Post.\n+var DefaultClient = &Client{}\n+\n+// ClientTransport is an interface representing the ability to execute a\n+// single HTTP transaction, obtaining the Response for a given Request.\n+type ClientTransport interface {\n+\t// Do executes a single HTTP transaction, returning the Response for the\n+\t// request req.  Do should not attempt to interpret the response.\n+\t// In particular, Do must return err == nil if it obtained a response,\n+\t// regardless of the response's HTTP status code.  A non-nil err should\n+\t// be reserved for failure to obtain a response.  Similarly, Do should\n+\t// not attempt to handle higher-level protocol details such as redirects,\n+\t// authentication, or cookies.\n+\t//\n+\t// Transports may modify the request. The request Headers field is\n+\t// guaranteed to be initalized.\n+\tDo(req *Request) (resp *Response, err os.Error)\n+}\n+\n // Given a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\",\n // return true if the string includes a port.\n func hasPort(s string) bool { return strings.LastIndex(s, \":\") > strings.LastIndex(s, \"]\") }\n@@ -31,67 +54,83 @@ type readClose struct {\n \tio.Closer\n }\n \n-// Send issues an HTTP request.  Caller should close resp.Body when done reading it.\n+// matchNoProxy returns true if requests to addr should not use a proxy,\n+// according to the NO_PROXY or no_proxy environment variable.\n+func matchNoProxy(addr string) bool {\n+\tif len(addr) == 0 {\n+\t\treturn false\n+\t}\n+\tno_proxy := os.Getenv(\"NO_PROXY\")\n+\tif len(no_proxy) == 0 {\n+\t\tno_proxy = os.Getenv(\"no_proxy\")\n+\t}\n+\tif no_proxy == \"*\" {\n+\t\treturn true\n+\t}\n+\n+\taddr = strings.ToLower(strings.TrimSpace(addr))\n+\tif hasPort(addr) {\n+\t\taddr = addr[:strings.LastIndex(addr, \":\")]\n+\t}\n+\n+\tfor _, p := range strings.Split(no_proxy, \",\", -1) {\n+\t\tp = strings.ToLower(strings.TrimSpace(p))\n+\t\tif len(p) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif hasPort(p) {\n+\t\t\tp = p[:strings.LastIndex(p, \":\")]\n+\t\t}\n+\t\tif addr == p || (p[0] == '.' && (strings.HasSuffix(addr, p) || addr == p[1:])) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// Do sends an HTTP request and returns an HTTP response, following\n+// policy (e.g. redirects, cookies, auth) as configured on the client.\n+//\n+// Callers should close resp.Body when done reading from it.\n+//\n+// Generally Get, Post, or PostForm will be used instead of Do.\n+func (c *Client) Do(req *Request) (resp *Response, err os.Error) {\n+\treturn send(req, c.Transport)\n+}\n+\n+\n+// send issues an HTTP request.  Caller should close resp.Body when done reading from it.\n //\n // TODO: support persistent connections (multiple requests on a single connection).\n // send() method is nonpublic because, when we refactor the code for persistent\n // connections, it may no longer make sense to have a method with this signature.\n-func send(req *Request) (resp *Response, err os.Error) {\n-\tif req.URL.Scheme != \"http\" && req.URL.Scheme != \"https\" {\n-\t\treturn nil, &badStringError{\"unsupported protocol scheme\", req.URL.Scheme}\n+func send(req *Request, t ClientTransport) (resp *Response, err os.Error) {\n+\tif t == nil {\n+\t\tt = DefaultTransport\n+\t\tif t == nil {\n+\t\t\terr = os.NewError(\"no http.Client.Transport or http.DefaultTransport\")\n+\t\t\treturn\n+\t\t}\n \t}\n \n-\taddr := req.URL.Host\n-\tif !hasPort(addr) {\n-\t\taddr += \":\" + req.URL.Scheme\n+\t// Most the callers of send (Get, Post, et al) don't need\n+\t// Headers, leaving it uninitialized.  We guarantee to the\n+\t// ClientTransport that this has been initialized, though.\n+\tif req.Header == nil {\n+\t\treq.Header = Header(make(map[string][]string))\n \t}\n+\n \tinfo := req.URL.RawUserinfo\n \tif len(info) > 0 {\n \t\tenc := base64.URLEncoding\n \t\tencoded := make([]byte, enc.EncodedLen(len(info)))\n \t\tenc.Encode(encoded, []byte(info))\n \t\tif req.Header == nil {\n-\t\t\treq.Header = make(map[string]string)\n+\t\t\treq.Header = make(Header)\n \t\t}\n-\t\treq.Header[\"Authorization\"] = \"Basic \" + string(encoded)\n-\t}\n-\n-\tvar conn io.ReadWriteCloser\n-\tif req.URL.Scheme == \"http\" {\n-\t\tconn, err = net.Dial(\"tcp\", \"\", addr)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t} else { // https\n-\t\tconn, err = tls.Dial(\"tcp\", \"\", addr, nil)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\th := req.URL.Host\n-\t\tif hasPort(h) {\n-\t\t\th = h[0:strings.LastIndex(h, \":\")]\n-\t\t}\n-\t\tif err := conn.(*tls.Conn).VerifyHostname(h); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\terr = req.Write(conn)\n-\tif err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n+\t\treq.Header.Set(\"Authorization\", \"Basic \"+string(encoded))\n \t}\n-\n-\treader := bufio.NewReader(conn)\n-\tresp, err = ReadResponse(reader, req.Method)\n-\tif err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n-\t}\n-\n-\tresp.Body = readClose{resp.Body, conn}\n-\n-\treturn\n+\treturn t.Do(req)\n }\n \n // True if the specified HTTP status code is one for which the Get utility should\n@@ -115,19 +154,42 @@ func shouldRedirect(statusCode int) bool {\n // finalURL is the URL from which the response was fetched -- identical to the\n // input URL unless redirects were followed.\n //\n-// Caller should close r.Body when done reading it.\n+// Caller should close r.Body when done reading from it.\n+//\n+// Get is a convenience wrapper around DefaultClient.Get.\n func Get(url string) (r *Response, finalURL string, err os.Error) {\n+\treturn DefaultClient.Get(url)\n+}\n+\n+// Get issues a GET to the specified URL.  If the response is one of the following\n+// redirect codes, it follows the redirect, up to a maximum of 10 redirects:\n+//\n+//    301 (Moved Permanently)\n+//    302 (Found)\n+//    303 (See Other)\n+//    307 (Temporary Redirect)\n+//\n+// finalURL is the URL from which the response was fetched -- identical to the\n+// input URL unless redirects were followed.\n+//\n+// Caller should close r.Body when done reading from it.\n+func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error) {\n \t// TODO: if/when we add cookie support, the redirected request shouldn't\n \t// necessarily supply the same cookies as the original.\n \t// TODO: set referrer header on redirects.\n \tvar base *URL\n+\t// TODO: remove this hard-coded 10 and use the Client's policy\n+\t// (ClientConfig) instead.\n \tfor redirect := 0; ; redirect++ {\n \t\tif redirect >= 10 {\n \t\t\terr = os.ErrorString(\"stopped after 10 redirects\")\n \t\t\tbreak\n \t\t}\n \n \t\tvar req Request\n+\t\treq.Method = \"GET\"\n+\t\treq.ProtoMajor = 1\n+\t\treq.ProtoMinor = 1\n \t\tif base == nil {\n \t\t\treq.URL, err = ParseURL(url)\n \t\t} else {\n@@ -137,12 +199,12 @@ func Get(url string) (r *Response, finalURL string, err os.Error) {\n \t\t\tbreak\n \t\t}\n \t\turl = req.URL.String()\n-\t\tif r, err = send(&req); err != nil {\n+\t\tif r, err = send(&req, c.Transport); err != nil {\n \t\t\tbreak\n \t\t}\n \t\tif shouldRedirect(r.StatusCode) {\n \t\t\tr.Body.Close()\n-\t\t\tif url = r.GetHeader(\"Location\"); url == \"\" {\n+\t\t\tif url = r.Header.Get(\"Location\"); url == \"\" {\n \t\t\t\terr = os.ErrorString(fmt.Sprintf(\"%d response missing Location header\", r.StatusCode))\n \t\t\t\tbreak\n \t\t\t}\n@@ -159,16 +221,25 @@ func Get(url string) (r *Response, finalURL string, err os.Error) {\n \n // Post issues a POST to the specified URL.\n //\n-// Caller should close r.Body when done reading it.\n+// Caller should close r.Body when done reading from it.\n+//\n+// Post is a wrapper around DefaultClient.Post\n func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error) {\n+\treturn DefaultClient.Post(url, bodyType, body)\n+}\n+\n+// Post issues a POST to the specified URL.\n+//\n+// Caller should close r.Body when done reading from it.\n+func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error) {\n \tvar req Request\n \treq.Method = \"POST\"\n \treq.ProtoMajor = 1\n \treq.ProtoMinor = 1\n \treq.Close = true\n \treq.Body = nopCloser{body}\n-\treq.Header = map[string]string{\n-\t\t\"Content-Type\": bodyType,\n+\treq.Header = Header{\n+\t\t\"Content-Type\": {bodyType},\n \t}\n \treq.TransferEncoding = []string{\"chunked\"}\n \n@@ -177,24 +248,34 @@ func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Erro\n \t\treturn nil, err\n \t}\n \n-\treturn send(&req)\n+\treturn send(&req, c.Transport)\n }\n \n // PostForm issues a POST to the specified URL, \n // with data's keys and values urlencoded as the request body.\n //\n-// Caller should close r.Body when done reading it.\n+// Caller should close r.Body when done reading from it.\n+//\n+// PostForm is a wrapper around DefaultClient.PostForm\n func PostForm(url string, data map[string]string) (r *Response, err os.Error) {\n+\treturn DefaultClient.PostForm(url, data)\n+}\n+\n+// PostForm issues a POST to the specified URL, \n+// with data's keys and values urlencoded as the request body.\n+//\n+// Caller should close r.Body when done reading from it.\n+func (c *Client) PostForm(url string, data map[string]string) (r *Response, err os.Error) {\n \tvar req Request\n \treq.Method = \"POST\"\n \treq.ProtoMajor = 1\n \treq.ProtoMinor = 1\n \treq.Close = true\n \tbody := urlencode(data)\n \treq.Body = nopCloser{body}\n-\treq.Header = map[string]string{\n-\t\t\"Content-Type\":   \"application/x-www-form-urlencoded\",\n-\t\t\"Content-Length\": strconv.Itoa(body.Len()),\n+\treq.Header = Header{\n+\t\t\"Content-Type\":   {\"application/x-www-form-urlencoded\"},\n+\t\t\"Content-Length\": {strconv.Itoa(body.Len())},\n \t}\n \treq.ContentLength = int64(body.Len())\n \n@@ -203,7 +284,7 @@ func PostForm(url string, data map[string]string) (r *Response, err os.Error) {\n \t\treturn nil, err\n \t}\n \n-\treturn send(&req)\n+\treturn send(&req, c.Transport)\n }\n \n // TODO: remove this function when PostForm takes a multimap.\n@@ -216,17 +297,20 @@ func urlencode(data map[string]string) (b *bytes.Buffer) {\n }\n \n // Head issues a HEAD to the specified URL.\n+//\n+// Head is a wrapper around DefaultClient.Head\n func Head(url string) (r *Response, err os.Error) {\n+\treturn DefaultClient.Head(url)\n+}\n+\n+// Head issues a HEAD to the specified URL.\n+func (c *Client) Head(url string) (r *Response, err os.Error) {\n \tvar req Request\n \treq.Method = \"HEAD\"\n \tif req.URL, err = ParseURL(url); err != nil {\n \t\treturn\n \t}\n-\turl = req.URL.String()\n-\tif r, err = send(&req); err != nil {\n-\t\treturn\n-\t}\n-\treturn\n+\treturn send(&req, c.Transport)\n }\n \n type nopCloser struct {"}, {"sha": "c89ecbce2d0d1a1a8fe422e775857adaebfa3bc9", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -8,6 +8,7 @@ package http\n \n import (\n \t\"io/ioutil\"\n+\t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -38,3 +39,28 @@ func TestClientHead(t *testing.T) {\n \t\tt.Error(\"Last-Modified header not found.\")\n \t}\n }\n+\n+type recordingTransport struct {\n+\treq *Request\n+}\n+\n+func (t *recordingTransport) Do(req *Request) (resp *Response, err os.Error) {\n+\tt.req = req\n+\treturn nil, os.NewError(\"dummy impl\")\n+}\n+\n+func TestGetRequestFormat(t *testing.T) {\n+\ttr := &recordingTransport{}\n+\tclient := &Client{Transport: tr}\n+\turl := \"http://dummy.faketld/\"\n+\tclient.Get(url) // Note: doesn't hit network\n+\tif tr.req.Method != \"GET\" {\n+\t\tt.Errorf(\"expected method %q; got %q\", \"GET\", tr.req.Method)\n+\t}\n+\tif tr.req.URL.String() != url {\n+\t\tt.Errorf(\"expected URL %q; got %q\", url, tr.req.URL.String())\n+\t}\n+\tif tr.req.Header == nil {\n+\t\tt.Errorf(\"expected non-nil request Header\")\n+\t}\n+}"}, {"sha": "8e16992e0f088839f5070db37485a6b898682aa5", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -104,7 +104,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t\t}\n \t}\n \n-\tif t, _ := time.Parse(TimeFormat, r.Header[\"If-Modified-Since\"]); t != nil && d.Mtime_ns/1e9 <= t.Seconds() {\n+\tif t, _ := time.Parse(TimeFormat, r.Header.Get(\"If-Modified-Since\")); t != nil && d.Mtime_ns/1e9 <= t.Seconds() {\n \t\tw.WriteHeader(StatusNotModified)\n \t\treturn\n \t}\n@@ -153,7 +153,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \n \t// handle Content-Range header.\n \t// TODO(adg): handle multiple ranges\n-\tranges, err := parseRange(r.Header[\"Range\"], size)\n+\tranges, err := parseRange(r.Header.Get(\"Range\"), size)\n \tif err != nil || len(ranges) > 1 {\n \t\tError(w, err.String(), StatusRequestedRangeNotSatisfiable)\n \t\treturn"}, {"sha": "a8b67e3f08c0e2fd3a73683a167bfc7aae2ce390", "filename": "libgo/go/http/fs_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -109,7 +109,7 @@ func TestServeFile(t *testing.T) {\n \n \t// set up the Request (re-used for all tests)\n \tvar req Request\n-\treq.Header = make(map[string]string)\n+\treq.Header = make(Header)\n \tif req.URL, err = ParseURL(\"http://\" + serverAddr + \"/ServeFile\"); err != nil {\n \t\tt.Fatal(\"ParseURL:\", err)\n \t}\n@@ -123,9 +123,9 @@ func TestServeFile(t *testing.T) {\n \n \t// Range tests\n \tfor _, rt := range ServeFileRangeTests {\n-\t\treq.Header[\"Range\"] = \"bytes=\" + rt.r\n+\t\treq.Header.Set(\"Range\", \"bytes=\"+rt.r)\n \t\tif rt.r == \"\" {\n-\t\t\treq.Header[\"Range\"] = \"\"\n+\t\t\treq.Header[\"Range\"] = nil\n \t\t}\n \t\tr, body := getBody(t, req)\n \t\tif r.StatusCode != rt.code {\n@@ -138,8 +138,9 @@ func TestServeFile(t *testing.T) {\n \t\tif rt.r == \"\" {\n \t\t\th = \"\"\n \t\t}\n-\t\tif r.Header[\"Content-Range\"] != h {\n-\t\t\tt.Errorf(\"header mismatch: range=%q: got %q, want %q\", rt.r, r.Header[\"Content-Range\"], h)\n+\t\tcr := r.Header.Get(\"Content-Range\")\n+\t\tif cr != h {\n+\t\t\tt.Errorf(\"header mismatch: range=%q: got %q, want %q\", rt.r, cr, h)\n \t\t}\n \t\tif !equal(body, file[rt.start:rt.end]) {\n \t\t\tt.Errorf(\"body mismatch: range=%q: got %q, want %q\", rt.r, body, file[rt.start:rt.end])\n@@ -148,7 +149,7 @@ func TestServeFile(t *testing.T) {\n }\n \n func getBody(t *testing.T, req Request) (*Response, []byte) {\n-\tr, err := send(&req)\n+\tr, err := send(&req, DefaultTransport)\n \tif err != nil {\n \t\tt.Fatal(req.URL.String(), \"send:\", err)\n \t}"}, {"sha": "95b0f3db6bb156a4ceb48580c8df2af8a76598e6", "filename": "libgo/go/http/header.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fheader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2010 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import \"net/textproto\"\n+\n+// A Header represents the key-value pairs in an HTTP header.\n+type Header map[string][]string\n+\n+// Add adds the key, value pair to the header.\n+// It appends to any existing values associated with key.\n+func (h Header) Add(key, value string) {\n+\ttextproto.MIMEHeader(h).Add(key, value)\n+}\n+\n+// Set sets the header entries associated with key to\n+// the single element value.  It replaces any existing\n+// values associated with key.\n+func (h Header) Set(key, value string) {\n+\ttextproto.MIMEHeader(h).Set(key, value)\n+}\n+\n+// Get gets the first value associated with the given key.\n+// If there are no values associated with the key, Get returns \"\".\n+// Get is a convenience method.  For more complex queries,\n+// access the map directly.\n+func (h Header) Get(key string) string {\n+\treturn textproto.MIMEHeader(h).Get(key)\n+}\n+\n+// Del deletes the values associated with key.\n+func (h Header) Del(key string) {\n+\ttextproto.MIMEHeader(h).Del(key)\n+}\n+\n+// CanonicalHeaderKey returns the canonical format of the\n+// header key s.  The canonicalization converts the first\n+// letter and any letter following a hyphen to upper case;\n+// the rest are converted to lowercase.  For example, the\n+// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n+func CanonicalHeaderKey(s string) string { return textproto.CanonicalMIMEHeaderKey(s) }"}, {"sha": "000a4200e59a8a4d7e8730ffe2e93948585346b1", "filename": "libgo/go/http/persist.go", "status": "modified", "additions": 98, "deletions": 38, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpersist.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -6,14 +6,17 @@ package http\n \n import (\n \t\"bufio\"\n-\t\"container/list\"\n \t\"io\"\n \t\"net\"\n+\t\"net/textproto\"\n \t\"os\"\n \t\"sync\"\n )\n \n-var ErrPersistEOF = &ProtocolError{\"persistent connection closed\"}\n+var (\n+\tErrPersistEOF = &ProtocolError{\"persistent connection closed\"}\n+\tErrPipeline   = &ProtocolError{\"pipeline error\"}\n+)\n \n // A ServerConn reads requests and sends responses over an underlying\n // connection, until the HTTP keepalive logic commands an end. ServerConn\n@@ -26,8 +29,10 @@ type ServerConn struct {\n \tr               *bufio.Reader\n \tclsd            bool     // indicates a graceful close\n \tre, we          os.Error // read/write errors\n-\tlastBody        io.ReadCloser\n+\tlastbody        io.ReadCloser\n \tnread, nwritten int\n+\tpipe            textproto.Pipeline\n+\tpipereq         map[*Request]uint\n \tlk              sync.Mutex // protected read/write to re,we\n }\n \n@@ -37,7 +42,7 @@ func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn {\n \tif r == nil {\n \t\tr = bufio.NewReader(c)\n \t}\n-\treturn &ServerConn{c: c, r: r}\n+\treturn &ServerConn{c: c, r: r, pipereq: make(map[*Request]uint)}\n }\n \n // Close detaches the ServerConn and returns the underlying connection as well\n@@ -57,10 +62,25 @@ func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader) {\n // Read returns the next request on the wire. An ErrPersistEOF is returned if\n // it is gracefully determined that there are no more requests (e.g. after the\n // first request on an HTTP/1.0 connection, or after a Connection:close on a\n-// HTTP/1.1 connection). Read can be called concurrently with Write, but not\n-// with another Read.\n+// HTTP/1.1 connection).\n func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \n+\t// Ensure ordered execution of Reads and Writes\n+\tid := sc.pipe.Next()\n+\tsc.pipe.StartRequest(id)\n+\tdefer func() {\n+\t\tsc.pipe.EndRequest(id)\n+\t\tif req == nil {\n+\t\t\tsc.pipe.StartResponse(id)\n+\t\t\tsc.pipe.EndResponse(id)\n+\t\t} else {\n+\t\t\t// Remember the pipeline id of this request\n+\t\t\tsc.lk.Lock()\n+\t\t\tsc.pipereq[req] = id\n+\t\t\tsc.lk.Unlock()\n+\t\t}\n+\t}()\n+\n \tsc.lk.Lock()\n \tif sc.we != nil { // no point receiving if write-side broken or closed\n \t\tdefer sc.lk.Unlock()\n@@ -73,12 +93,12 @@ func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \tsc.lk.Unlock()\n \n \t// Make sure body is fully consumed, even if user does not call body.Close\n-\tif sc.lastBody != nil {\n+\tif sc.lastbody != nil {\n \t\t// body.Close is assumed to be idempotent and multiple calls to\n \t\t// it should return the error that its first invokation\n \t\t// returned.\n-\t\terr = sc.lastBody.Close()\n-\t\tsc.lastBody = nil\n+\t\terr = sc.lastbody.Close()\n+\t\tsc.lastbody = nil\n \t\tif err != nil {\n \t\t\tsc.lk.Lock()\n \t\t\tdefer sc.lk.Unlock()\n@@ -102,7 +122,7 @@ func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \t\t\treturn\n \t\t}\n \t}\n-\tsc.lastBody = req.Body\n+\tsc.lastbody = req.Body\n \tsc.nread++\n \tif req.Close {\n \t\tsc.lk.Lock()\n@@ -121,11 +141,24 @@ func (sc *ServerConn) Pending() int {\n \treturn sc.nread - sc.nwritten\n }\n \n-// Write writes a repsonse. To close the connection gracefully, set the\n+// Write writes resp in response to req. To close the connection gracefully, set the\n // Response.Close field to true. Write should be considered operational until\n // it returns an error, regardless of any errors returned on the Read side.\n-// Write can be called concurrently with Read, but not with another Write.\n-func (sc *ServerConn) Write(resp *Response) os.Error {\n+func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n+\n+\t// Retrieve the pipeline ID of this request/response pair\n+\tsc.lk.Lock()\n+\tid, ok := sc.pipereq[req]\n+\tsc.pipereq[req] = 0, false\n+\tif !ok {\n+\t\tsc.lk.Unlock()\n+\t\treturn ErrPipeline\n+\t}\n+\tsc.lk.Unlock()\n+\n+\t// Ensure pipeline order\n+\tsc.pipe.StartResponse(id)\n+\tdefer sc.pipe.EndResponse(id)\n \n \tsc.lk.Lock()\n \tif sc.we != nil {\n@@ -166,10 +199,11 @@ type ClientConn struct {\n \tc               net.Conn\n \tr               *bufio.Reader\n \tre, we          os.Error // read/write errors\n-\tlastBody        io.ReadCloser\n+\tlastbody        io.ReadCloser\n \tnread, nwritten int\n-\treqm            list.List  // request methods in order of execution\n-\tlk              sync.Mutex // protects read/write to reqm,re,we\n+\tpipe            textproto.Pipeline\n+\tpipereq         map[*Request]uint\n+\tlk              sync.Mutex // protects read/write to re,we,pipereq,etc.\n }\n \n // NewClientConn returns a new ClientConn reading and writing c.  If r is not\n@@ -178,7 +212,7 @@ func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn {\n \tif r == nil {\n \t\tr = bufio.NewReader(c)\n \t}\n-\treturn &ClientConn{c: c, r: r}\n+\treturn &ClientConn{c: c, r: r, pipereq: make(map[*Request]uint)}\n }\n \n // Close detaches the ClientConn and returns the underlying connection as well\n@@ -191,7 +225,6 @@ func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader) {\n \tr = cc.r\n \tcc.c = nil\n \tcc.r = nil\n-\tcc.reqm.Init()\n \tcc.lk.Unlock()\n \treturn\n }\n@@ -201,8 +234,23 @@ func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader) {\n // keepalive connection is logically closed after this request and the opposing\n // server is informed. An ErrUnexpectedEOF indicates the remote closed the\n // underlying TCP connection, which is usually considered as graceful close.\n-// Write can be called concurrently with Read, but not with another Write.\n-func (cc *ClientConn) Write(req *Request) os.Error {\n+func (cc *ClientConn) Write(req *Request) (err os.Error) {\n+\n+\t// Ensure ordered execution of Writes\n+\tid := cc.pipe.Next()\n+\tcc.pipe.StartRequest(id)\n+\tdefer func() {\n+\t\tcc.pipe.EndRequest(id)\n+\t\tif err != nil {\n+\t\t\tcc.pipe.StartResponse(id)\n+\t\t\tcc.pipe.EndResponse(id)\n+\t\t} else {\n+\t\t\t// Remember the pipeline id of this request\n+\t\t\tcc.lk.Lock()\n+\t\t\tcc.pipereq[req] = id\n+\t\t\tcc.lk.Unlock()\n+\t\t}\n+\t}()\n \n \tcc.lk.Lock()\n \tif cc.re != nil { // no point sending if read-side closed or broken\n@@ -223,17 +271,14 @@ func (cc *ClientConn) Write(req *Request) os.Error {\n \t\tcc.lk.Unlock()\n \t}\n \n-\terr := req.Write(cc.c)\n+\terr = req.Write(cc.c)\n \tif err != nil {\n \t\tcc.lk.Lock()\n \t\tdefer cc.lk.Unlock()\n \t\tcc.we = err\n \t\treturn err\n \t}\n \tcc.nwritten++\n-\tcc.lk.Lock()\n-\tcc.reqm.PushBack(req.Method)\n-\tcc.lk.Unlock()\n \n \treturn nil\n }\n@@ -250,7 +295,21 @@ func (cc *ClientConn) Pending() int {\n // returned together with an ErrPersistEOF, which means that the remote\n // requested that this be the last request serviced. Read can be called\n // concurrently with Write, but not with another Read.\n-func (cc *ClientConn) Read() (resp *Response, err os.Error) {\n+func (cc *ClientConn) Read(req *Request) (resp *Response, err os.Error) {\n+\n+\t// Retrieve the pipeline ID of this request/response pair\n+\tcc.lk.Lock()\n+\tid, ok := cc.pipereq[req]\n+\tcc.pipereq[req] = 0, false\n+\tif !ok {\n+\t\tcc.lk.Unlock()\n+\t\treturn nil, ErrPipeline\n+\t}\n+\tcc.lk.Unlock()\n+\n+\t// Ensure pipeline order\n+\tcc.pipe.StartResponse(id)\n+\tdefer cc.pipe.EndResponse(id)\n \n \tcc.lk.Lock()\n \tif cc.re != nil {\n@@ -259,17 +318,13 @@ func (cc *ClientConn) Read() (resp *Response, err os.Error) {\n \t}\n \tcc.lk.Unlock()\n \n-\tif cc.nread >= cc.nwritten {\n-\t\treturn nil, os.NewError(\"persist client pipe count\")\n-\t}\n-\n \t// Make sure body is fully consumed, even if user does not call body.Close\n-\tif cc.lastBody != nil {\n+\tif cc.lastbody != nil {\n \t\t// body.Close is assumed to be idempotent and multiple calls to\n \t\t// it should return the error that its first invokation\n \t\t// returned.\n-\t\terr = cc.lastBody.Close()\n-\t\tcc.lastBody = nil\n+\t\terr = cc.lastbody.Close()\n+\t\tcc.lastbody = nil\n \t\tif err != nil {\n \t\t\tcc.lk.Lock()\n \t\t\tdefer cc.lk.Unlock()\n@@ -278,18 +333,14 @@ func (cc *ClientConn) Read() (resp *Response, err os.Error) {\n \t\t}\n \t}\n \n-\tcc.lk.Lock()\n-\tm := cc.reqm.Front()\n-\tcc.reqm.Remove(m)\n-\tcc.lk.Unlock()\n-\tresp, err = ReadResponse(cc.r, m.Value.(string))\n+\tresp, err = ReadResponse(cc.r, req.Method)\n \tif err != nil {\n \t\tcc.lk.Lock()\n \t\tdefer cc.lk.Unlock()\n \t\tcc.re = err\n \t\treturn\n \t}\n-\tcc.lastBody = resp.Body\n+\tcc.lastbody = resp.Body\n \n \tcc.nread++\n \n@@ -301,3 +352,12 @@ func (cc *ClientConn) Read() (resp *Response, err os.Error) {\n \t}\n \treturn\n }\n+\n+// Do is convenience method that writes a request and reads a response.\n+func (cc *ClientConn) Do(req *Request) (resp *Response, err os.Error) {\n+\terr = cc.Write(req)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn cc.Read(req)\n+}"}, {"sha": "0f2ca458fed2c53d03781a95f462875da9384f28", "filename": "libgo/go/http/proxy_test.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fproxy_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+// TODO(mattn):\n+//\ttest ProxyAuth\n+\n+var MatchNoProxyTests = []struct {\n+\thost  string\n+\tmatch bool\n+}{\n+\t{\"localhost\", true},        // match completely\n+\t{\"barbaz.net\", true},       // match as .barbaz.net\n+\t{\"foobar.com:443\", true},   // have a port but match \n+\t{\"foofoobar.com\", false},   // not match as a part of foobar.com\n+\t{\"baz.com\", false},         // not match as a part of barbaz.com\n+\t{\"localhost.net\", false},   // not match as suffix of address\n+\t{\"local.localhost\", false}, // not match as prefix as address\n+\t{\"barbarbaz.net\", false},   // not match because NO_PROXY have a '.'\n+\t{\"www.foobar.com\", false},  // not match because NO_PROXY is not .foobar.com\n+}\n+\n+func TestMatchNoProxy(t *testing.T) {\n+\toldenv := os.Getenv(\"NO_PROXY\")\n+\tno_proxy := \"foobar.com, .barbaz.net   , localhost\"\n+\tos.Setenv(\"NO_PROXY\", no_proxy)\n+\tdefer os.Setenv(\"NO_PROXY\", oldenv)\n+\n+\tfor _, test := range MatchNoProxyTests {\n+\t\tif matchNoProxy(test.host) != test.match {\n+\t\t\tif test.match {\n+\t\t\t\tt.Errorf(\"matchNoProxy(%v) = %v, want %v\", test.host, !test.match, test.match)\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"not expected: '%s' shouldn't match as '%s'\", test.host, no_proxy)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "6ee07bc9148a2687894d036ff7423ce96123de5f", "filename": "libgo/go/http/readrequest_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freadrequest_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -50,14 +50,14 @@ var reqTests = []reqTest{\n \t\t\tProto:      \"HTTP/1.1\",\n \t\t\tProtoMajor: 1,\n \t\t\tProtoMinor: 1,\n-\t\t\tHeader: map[string]string{\n-\t\t\t\t\"Accept\":           \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n-\t\t\t\t\"Accept-Language\":  \"en-us,en;q=0.5\",\n-\t\t\t\t\"Accept-Encoding\":  \"gzip,deflate\",\n-\t\t\t\t\"Accept-Charset\":   \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\",\n-\t\t\t\t\"Keep-Alive\":       \"300\",\n-\t\t\t\t\"Proxy-Connection\": \"keep-alive\",\n-\t\t\t\t\"Content-Length\":   \"7\",\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Accept\":           {\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"},\n+\t\t\t\t\"Accept-Language\":  {\"en-us,en;q=0.5\"},\n+\t\t\t\t\"Accept-Encoding\":  {\"gzip,deflate\"},\n+\t\t\t\t\"Accept-Charset\":   {\"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"},\n+\t\t\t\t\"Keep-Alive\":       {\"300\"},\n+\t\t\t\t\"Proxy-Connection\": {\"keep-alive\"},\n+\t\t\t\t\"Content-Length\":   {\"7\"},\n \t\t\t},\n \t\t\tClose:         false,\n \t\t\tContentLength: 7,\n@@ -93,7 +93,7 @@ var reqTests = []reqTest{\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    1,\n-\t\t\tHeader:        map[string]string{},\n+\t\t\tHeader:        map[string][]string{},\n \t\t\tClose:         false,\n \t\t\tContentLength: -1,\n \t\t\tHost:          \"test\","}, {"sha": "a7dc328a0075c75f1eb17fa58fa5c491c7170454", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 49, "deletions": 159, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -11,13 +11,13 @@ package http\n \n import (\n \t\"bufio\"\n-\t\"bytes\"\n \t\"container/vector\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"mime\"\n \t\"mime/multipart\"\n+\t\"net/textproto\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n@@ -90,7 +90,7 @@ type Request struct {\n \t// The request parser implements this by canonicalizing the\n \t// name, making the first character and any characters\n \t// following a hyphen uppercase and the rest lowercase.\n-\tHeader map[string]string\n+\tHeader Header\n \n \t// The message body.\n \tBody io.ReadCloser\n@@ -133,7 +133,7 @@ type Request struct {\n \t// Trailer maps trailer keys to values.  Like for Header, if the\n \t// response has multiple trailer lines with the same key, they will be\n \t// concatenated, delimited by commas.\n-\tTrailer map[string]string\n+\tTrailer Header\n }\n \n // ProtoAtLeast returns whether the HTTP protocol used\n@@ -146,8 +146,8 @@ func (r *Request) ProtoAtLeast(major, minor int) bool {\n // MultipartReader returns a MIME multipart reader if this is a\n // multipart/form-data POST request, else returns nil and an error.\n func (r *Request) MultipartReader() (multipart.Reader, os.Error) {\n-\tv, ok := r.Header[\"Content-Type\"]\n-\tif !ok {\n+\tv := r.Header.Get(\"Content-Type\")\n+\tif v == \"\" {\n \t\treturn nil, ErrNotMultipart\n \t}\n \td, params := mime.ParseMediaType(v)\n@@ -184,6 +184,17 @@ const defaultUserAgent = \"Go http package\"\n // If Body is present, Write forces \"Transfer-Encoding: chunked\" as a header\n // and then closes Body when finished sending it.\n func (req *Request) Write(w io.Writer) os.Error {\n+\treturn req.write(w, false)\n+}\n+\n+// WriteProxy is like Write but writes the request in the form\n+// expected by an HTTP proxy.  It includes the scheme and host\n+// name in the URI instead of using a separate Host: header line.\n+func (req *Request) WriteProxy(w io.Writer) os.Error {\n+\treturn req.write(w, true)\n+}\n+\n+func (req *Request) write(w io.Writer, usingProxy bool) os.Error {\n \thost := req.Host\n \tif host == \"\" {\n \t\thost = req.URL.Host\n@@ -197,10 +208,19 @@ func (req *Request) Write(w io.Writer) os.Error {\n \t\t}\n \t}\n \n+\tif usingProxy {\n+\t\tif uri == \"\" || uri[0] != '/' {\n+\t\t\turi = \"/\" + uri\n+\t\t}\n+\t\turi = req.URL.Scheme + \"://\" + host + uri\n+\t}\n+\n \tfmt.Fprintf(w, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), uri)\n \n \t// Header lines\n-\tfmt.Fprintf(w, \"Host: %s\\r\\n\", host)\n+\tif !usingProxy {\n+\t\tfmt.Fprintf(w, \"Host: %s\\r\\n\", host)\n+\t}\n \tfmt.Fprintf(w, \"User-Agent: %s\\r\\n\", valueOrDefault(req.UserAgent, defaultUserAgent))\n \tif req.Referer != \"\" {\n \t\tfmt.Fprintf(w, \"Referer: %s\\r\\n\", req.Referer)\n@@ -277,78 +297,6 @@ func readLine(b *bufio.Reader) (s string, err os.Error) {\n \treturn string(p), nil\n }\n \n-var colon = []byte{':'}\n-\n-// Read a key/value pair from b.\n-// A key/value has the form Key: Value\\r\\n\n-// and the Value can continue on multiple lines if each continuation line\n-// starts with a space.\n-func readKeyValue(b *bufio.Reader) (key, value string, err os.Error) {\n-\tline, e := readLineBytes(b)\n-\tif e != nil {\n-\t\treturn \"\", \"\", e\n-\t}\n-\tif len(line) == 0 {\n-\t\treturn \"\", \"\", nil\n-\t}\n-\n-\t// Scan first line for colon.\n-\ti := bytes.Index(line, colon)\n-\tif i < 0 {\n-\t\tgoto Malformed\n-\t}\n-\n-\tkey = string(line[0:i])\n-\tif strings.Contains(key, \" \") {\n-\t\t// Key field has space - no good.\n-\t\tgoto Malformed\n-\t}\n-\n-\t// Skip initial space before value.\n-\tfor i++; i < len(line); i++ {\n-\t\tif line[i] != ' ' {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tvalue = string(line[i:])\n-\n-\t// Look for extension lines, which must begin with space.\n-\tfor {\n-\t\tc, e := b.ReadByte()\n-\t\tif c != ' ' {\n-\t\t\tif e != os.EOF {\n-\t\t\t\tb.UnreadByte()\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\n-\t\t// Eat leading space.\n-\t\tfor c == ' ' {\n-\t\t\tif c, e = b.ReadByte(); e != nil {\n-\t\t\t\tif e == os.EOF {\n-\t\t\t\t\te = io.ErrUnexpectedEOF\n-\t\t\t\t}\n-\t\t\t\treturn \"\", \"\", e\n-\t\t\t}\n-\t\t}\n-\t\tb.UnreadByte()\n-\n-\t\t// Read the rest of the line and add to value.\n-\t\tif line, e = readLineBytes(b); e != nil {\n-\t\t\treturn \"\", \"\", e\n-\t\t}\n-\t\tvalue += \" \" + string(line)\n-\n-\t\tif len(value) >= maxValueLength {\n-\t\t\treturn \"\", \"\", &badStringError{\"value too long for key\", key}\n-\t\t}\n-\t}\n-\treturn key, value, nil\n-\n-Malformed:\n-\treturn \"\", \"\", &badStringError{\"malformed header line\", string(line)}\n-}\n-\n // Convert decimal at s[i:len(s)] to integer,\n // returning value, string position where the digits stopped,\n // and whether there was a valid number (digits, not too big).\n@@ -367,60 +315,23 @@ func atoi(s string, i int) (n, i1 int, ok bool) {\n \treturn n, i, true\n }\n \n-// Parse HTTP version: \"HTTP/1.2\" -> (1, 2, true).\n-func parseHTTPVersion(vers string) (int, int, bool) {\n+// ParseHTTPVersion parses a HTTP version string.\n+// \"HTTP/1.0\" returns (1, 0, true).\n+func ParseHTTPVersion(vers string) (major, minor int, ok bool) {\n \tif len(vers) < 5 || vers[0:5] != \"HTTP/\" {\n \t\treturn 0, 0, false\n \t}\n \tmajor, i, ok := atoi(vers, 5)\n \tif !ok || i >= len(vers) || vers[i] != '.' {\n \t\treturn 0, 0, false\n \t}\n-\tvar minor int\n \tminor, i, ok = atoi(vers, i+1)\n \tif !ok || i != len(vers) {\n \t\treturn 0, 0, false\n \t}\n \treturn major, minor, true\n }\n \n-// CanonicalHeaderKey returns the canonical format of the\n-// HTTP header key s.  The canonicalization converts the first\n-// letter and any letter following a hyphen to upper case;\n-// the rest are converted to lowercase.  For example, the\n-// canonical key for \"accept-encoding\" is \"Accept-Encoding\".\n-func CanonicalHeaderKey(s string) string {\n-\t// canonicalize: first letter upper case\n-\t// and upper case after each dash.\n-\t// (Host, User-Agent, If-Modified-Since).\n-\t// HTTP headers are ASCII only, so no Unicode issues.\n-\tvar a []byte\n-\tupper := true\n-\tfor i := 0; i < len(s); i++ {\n-\t\tv := s[i]\n-\t\tif upper && 'a' <= v && v <= 'z' {\n-\t\t\tif a == nil {\n-\t\t\t\ta = []byte(s)\n-\t\t\t}\n-\t\t\ta[i] = v + 'A' - 'a'\n-\t\t}\n-\t\tif !upper && 'A' <= v && v <= 'Z' {\n-\t\t\tif a == nil {\n-\t\t\t\ta = []byte(s)\n-\t\t\t}\n-\t\t\ta[i] = v + 'a' - 'A'\n-\t\t}\n-\t\tupper = false\n-\t\tif v == '-' {\n-\t\t\tupper = true\n-\t\t}\n-\t}\n-\tif a != nil {\n-\t\treturn string(a)\n-\t}\n-\treturn s\n-}\n-\n type chunkedReader struct {\n \tr   *bufio.Reader\n \tn   uint64 // unread bytes in chunk\n@@ -486,11 +397,16 @@ func (cr *chunkedReader) Read(b []uint8) (n int, err os.Error) {\n \n // ReadRequest reads and parses a request from b.\n func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n+\n+\ttp := textproto.NewReader(b)\n \treq = new(Request)\n \n \t// First line: GET /index.html HTTP/1.0\n \tvar s string\n-\tif s, err = readLine(b); err != nil {\n+\tif s, err = tp.ReadLine(); err != nil {\n+\t\tif err == os.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t}\n \t\treturn nil, err\n \t}\n \n@@ -500,7 +416,7 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n \t}\n \treq.Method, req.RawURL, req.Proto = f[0], f[1], f[2]\n \tvar ok bool\n-\tif req.ProtoMajor, req.ProtoMinor, ok = parseHTTPVersion(req.Proto); !ok {\n+\tif req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok {\n \t\treturn nil, &badStringError{\"malformed HTTP version\", req.Proto}\n \t}\n \n@@ -509,32 +425,11 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n \t}\n \n \t// Subsequent lines: Key: value.\n-\tnheader := 0\n-\treq.Header = make(map[string]string)\n-\tfor {\n-\t\tvar key, value string\n-\t\tif key, value, err = readKeyValue(b); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif key == \"\" {\n-\t\t\tbreak\n-\t\t}\n-\t\tif nheader++; nheader >= maxHeaderLines {\n-\t\t\treturn nil, ErrHeaderTooLong\n-\t\t}\n-\n-\t\tkey = CanonicalHeaderKey(key)\n-\n-\t\t// RFC 2616 says that if you send the same header key\n-\t\t// multiple times, it has to be semantically equivalent\n-\t\t// to concatenating the values separated by commas.\n-\t\toldvalue, present := req.Header[key]\n-\t\tif present {\n-\t\t\treq.Header[key] = oldvalue + \",\" + value\n-\t\t} else {\n-\t\t\treq.Header[key] = value\n-\t\t}\n+\tmimeHeader, err := tp.ReadMIMEHeader()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n+\treq.Header = Header(mimeHeader)\n \n \t// RFC2616: Must treat\n \t//\tGET /index.html HTTP/1.1\n@@ -545,18 +440,18 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n \t// the same.  In the second case, any Host line is ignored.\n \treq.Host = req.URL.Host\n \tif req.Host == \"\" {\n-\t\treq.Host = req.Header[\"Host\"]\n+\t\treq.Host = req.Header.Get(\"Host\")\n \t}\n-\treq.Header[\"Host\"] = \"\", false\n+\treq.Header.Del(\"Host\")\n \n \tfixPragmaCacheControl(req.Header)\n \n \t// Pull out useful fields as a convenience to clients.\n-\treq.Referer = req.Header[\"Referer\"]\n-\treq.Header[\"Referer\"] = \"\", false\n+\treq.Referer = req.Header.Get(\"Referer\")\n+\treq.Header.Del(\"Referer\")\n \n-\treq.UserAgent = req.Header[\"User-Agent\"]\n-\treq.Header[\"User-Agent\"] = \"\", false\n+\treq.UserAgent = req.Header.Get(\"User-Agent\")\n+\treq.Header.Del(\"User-Agent\")\n \n \t// TODO: Parse specific header values:\n \t//\tAccept\n@@ -642,7 +537,7 @@ func (r *Request) ParseForm() (err os.Error) {\n \t\tif r.Body == nil {\n \t\t\treturn os.ErrorString(\"missing form body\")\n \t\t}\n-\t\tct := r.Header[\"Content-Type\"]\n+\t\tct := r.Header.Get(\"Content-Type\")\n \t\tswitch strings.Split(ct, \";\", 2)[0] {\n \t\tcase \"text/plain\", \"application/x-www-form-urlencoded\", \"\":\n \t\t\tb, e := ioutil.ReadAll(r.Body)\n@@ -677,17 +572,12 @@ func (r *Request) FormValue(key string) string {\n }\n \n func (r *Request) expectsContinue() bool {\n-\texpectation, ok := r.Header[\"Expect\"]\n-\treturn ok && strings.ToLower(expectation) == \"100-continue\"\n+\treturn strings.ToLower(r.Header.Get(\"Expect\")) == \"100-continue\"\n }\n \n func (r *Request) wantsHttp10KeepAlive() bool {\n \tif r.ProtoMajor != 1 || r.ProtoMinor != 0 {\n \t\treturn false\n \t}\n-\tvalue, exists := r.Header[\"Connection\"]\n-\tif !exists {\n-\t\treturn false\n-\t}\n-\treturn strings.Contains(strings.ToLower(value), \"keep-alive\")\n+\treturn strings.Contains(strings.ToLower(r.Header.Get(\"Connection\")), \"keep-alive\")\n }"}, {"sha": "ae1c4e98245212f9d48d1d2c28f843d99405966c", "filename": "libgo/go/http/request_test.go", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -74,7 +74,9 @@ func TestQuery(t *testing.T) {\n func TestPostQuery(t *testing.T) {\n \treq := &Request{Method: \"POST\"}\n \treq.URL, _ = ParseURL(\"http://www.google.com/search?q=foo&q=bar&both=x\")\n-\treq.Header = map[string]string{\"Content-Type\": \"application/x-www-form-urlencoded; boo!\"}\n+\treq.Header = Header{\n+\t\t\"Content-Type\": {\"application/x-www-form-urlencoded; boo!\"},\n+\t}\n \treq.Body = nopCloser{strings.NewReader(\"z=post&both=y\")}\n \tif q := req.FormValue(\"q\"); q != \"foo\" {\n \t\tt.Errorf(`req.FormValue(\"q\") = %q, want \"foo\"`, q)\n@@ -87,18 +89,18 @@ func TestPostQuery(t *testing.T) {\n \t}\n }\n \n-type stringMap map[string]string\n+type stringMap map[string][]string\n type parseContentTypeTest struct {\n \tcontentType stringMap\n \terror       bool\n }\n \n var parseContentTypeTests = []parseContentTypeTest{\n-\t{contentType: stringMap{\"Content-Type\": \"text/plain\"}},\n-\t{contentType: stringMap{\"Content-Type\": \"\"}},\n-\t{contentType: stringMap{\"Content-Type\": \"text/plain; boundary=\"}},\n+\t{contentType: stringMap{\"Content-Type\": {\"text/plain\"}}},\n+\t{contentType: stringMap{}}, // Non-existent keys are not placed. The value nil is illegal.\n+\t{contentType: stringMap{\"Content-Type\": {\"text/plain; boundary=\"}}},\n \t{\n-\t\tcontentType: stringMap{\"Content-Type\": \"application/unknown\"},\n+\t\tcontentType: stringMap{\"Content-Type\": {\"application/unknown\"}},\n \t\terror:       true,\n \t},\n }\n@@ -107,7 +109,7 @@ func TestPostContentTypeParsing(t *testing.T) {\n \tfor i, test := range parseContentTypeTests {\n \t\treq := &Request{\n \t\t\tMethod: \"POST\",\n-\t\t\tHeader: test.contentType,\n+\t\t\tHeader: Header(test.contentType),\n \t\t\tBody:   nopCloser{bytes.NewBufferString(\"body\")},\n \t\t}\n \t\terr := req.ParseForm()\n@@ -123,15 +125,15 @@ func TestPostContentTypeParsing(t *testing.T) {\n func TestMultipartReader(t *testing.T) {\n \treq := &Request{\n \t\tMethod: \"POST\",\n-\t\tHeader: stringMap{\"Content-Type\": `multipart/form-data; boundary=\"foo123\"`},\n+\t\tHeader: Header{\"Content-Type\": {`multipart/form-data; boundary=\"foo123\"`}},\n \t\tBody:   nopCloser{new(bytes.Buffer)},\n \t}\n \tmultipart, err := req.MultipartReader()\n \tif multipart == nil {\n \t\tt.Errorf(\"expected multipart; error: %v\", err)\n \t}\n \n-\treq.Header = stringMap{\"Content-Type\": \"text/plain\"}\n+\treq.Header = Header{\"Content-Type\": {\"text/plain\"}}\n \tmultipart, err = req.MultipartReader()\n \tif multipart != nil {\n \t\tt.Errorf(\"unexpected multipart for text/plain\")"}, {"sha": "55ca745d58c34fddc84478c311ccd0bdd8619cff", "filename": "libgo/go/http/requestwrite_test.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -34,13 +34,13 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tProto:      \"HTTP/1.1\",\n \t\t\tProtoMajor: 1,\n \t\t\tProtoMinor: 1,\n-\t\t\tHeader: map[string]string{\n-\t\t\t\t\"Accept\":           \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n-\t\t\t\t\"Accept-Charset\":   \"ISO-8859-1,utf-8;q=0.7,*;q=0.7\",\n-\t\t\t\t\"Accept-Encoding\":  \"gzip,deflate\",\n-\t\t\t\t\"Accept-Language\":  \"en-us,en;q=0.5\",\n-\t\t\t\t\"Keep-Alive\":       \"300\",\n-\t\t\t\t\"Proxy-Connection\": \"keep-alive\",\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Accept\":           {\"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"},\n+\t\t\t\t\"Accept-Charset\":   {\"ISO-8859-1,utf-8;q=0.7,*;q=0.7\"},\n+\t\t\t\t\"Accept-Encoding\":  {\"gzip,deflate\"},\n+\t\t\t\t\"Accept-Language\":  {\"en-us,en;q=0.5\"},\n+\t\t\t\t\"Keep-Alive\":       {\"300\"},\n+\t\t\t\t\"Proxy-Connection\": {\"keep-alive\"},\n \t\t\t},\n \t\t\tBody:      nil,\n \t\t\tClose:     false,\n@@ -53,10 +53,10 @@ var reqWriteTests = []reqWriteTest{\n \t\t\"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.techcrunch.com\\r\\n\" +\n \t\t\t\"User-Agent: Fake\\r\\n\" +\n+\t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n \t\t\t\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\\r\\n\" +\n \t\t\t\"Accept-Encoding: gzip,deflate\\r\\n\" +\n \t\t\t\"Accept-Language: en-us,en;q=0.5\\r\\n\" +\n-\t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n \t\t\t\"Keep-Alive: 300\\r\\n\" +\n \t\t\t\"Proxy-Connection: keep-alive\\r\\n\\r\\n\",\n \t},\n@@ -71,7 +71,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t},\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n-\t\t\tHeader:           map[string]string{},\n+\t\t\tHeader:           map[string][]string{},\n \t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n@@ -93,7 +93,7 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t},\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n-\t\t\tHeader:           map[string]string{},\n+\t\t\tHeader:           map[string][]string{},\n \t\t\tClose:            true,\n \t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tTransferEncoding: []string{\"chunked\"},"}, {"sha": "3f919c86a3cb775baa6f051439a5d04376594c64", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"bufio\"\n \t\"fmt\"\n \t\"io\"\n+\t\"net/textproto\"\n \t\"os\"\n \t\"sort\"\n \t\"strconv\"\n@@ -43,7 +44,7 @@ type Response struct {\n \t// omitted from Header.\n \t//\n \t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n-\tHeader map[string]string\n+\tHeader Header\n \n \t// Body represents the response body.\n \tBody io.ReadCloser\n@@ -66,7 +67,7 @@ type Response struct {\n \t// Trailer maps trailer keys to values.  Like for Header, if the\n \t// response has multiple trailer lines with the same key, they will be\n \t// concatenated, delimited by commas.\n-\tTrailer map[string]string\n+\tTrailer map[string][]string\n }\n \n // ReadResponse reads and returns an HTTP response from r.  The RequestMethod\n@@ -76,13 +77,17 @@ type Response struct {\n // key/value pairs included in the response trailer.\n func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error) {\n \n+\ttp := textproto.NewReader(r)\n \tresp = new(Response)\n \n \tresp.RequestMethod = strings.ToUpper(requestMethod)\n \n \t// Parse the first line of the response.\n-\tline, err := readLine(r)\n+\tline, err := tp.ReadLine()\n \tif err != nil {\n+\t\tif err == os.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t}\n \t\treturn nil, err\n \t}\n \tf := strings.Split(line, \" \", 3)\n@@ -101,26 +106,16 @@ func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os\n \n \tresp.Proto = f[0]\n \tvar ok bool\n-\tif resp.ProtoMajor, resp.ProtoMinor, ok = parseHTTPVersion(resp.Proto); !ok {\n+\tif resp.ProtoMajor, resp.ProtoMinor, ok = ParseHTTPVersion(resp.Proto); !ok {\n \t\treturn nil, &badStringError{\"malformed HTTP version\", resp.Proto}\n \t}\n \n \t// Parse the response headers.\n-\tnheader := 0\n-\tresp.Header = make(map[string]string)\n-\tfor {\n-\t\tkey, value, err := readKeyValue(r)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif key == \"\" {\n-\t\t\tbreak // end of response header\n-\t\t}\n-\t\tif nheader++; nheader >= maxHeaderLines {\n-\t\t\treturn nil, ErrHeaderTooLong\n-\t\t}\n-\t\tresp.AddHeader(key, value)\n+\tmimeHeader, err := tp.ReadMIMEHeader()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n+\tresp.Header = Header(mimeHeader)\n \n \tfixPragmaCacheControl(resp.Header)\n \n@@ -136,34 +131,14 @@ func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os\n //\tPragma: no-cache\n // like\n //\tCache-Control: no-cache\n-func fixPragmaCacheControl(header map[string]string) {\n-\tif header[\"Pragma\"] == \"no-cache\" {\n+func fixPragmaCacheControl(header Header) {\n+\tif hp, ok := header[\"Pragma\"]; ok && len(hp) > 0 && hp[0] == \"no-cache\" {\n \t\tif _, presentcc := header[\"Cache-Control\"]; !presentcc {\n-\t\t\theader[\"Cache-Control\"] = \"no-cache\"\n+\t\t\theader[\"Cache-Control\"] = []string{\"no-cache\"}\n \t\t}\n \t}\n }\n \n-// AddHeader adds a value under the given key.  Keys are not case sensitive.\n-func (r *Response) AddHeader(key, value string) {\n-\tkey = CanonicalHeaderKey(key)\n-\n-\toldValues, oldValuesPresent := r.Header[key]\n-\tif oldValuesPresent {\n-\t\tr.Header[key] = oldValues + \",\" + value\n-\t} else {\n-\t\tr.Header[key] = value\n-\t}\n-}\n-\n-// GetHeader returns the value of the response header with the given key.\n-// If there were multiple headers with this key, their values are concatenated,\n-// with a comma delimiter.  If there were no response headers with the given\n-// key, GetHeader returns an empty string.  Keys are not case sensitive.\n-func (r *Response) GetHeader(key string) (value string) {\n-\treturn r.Header[CanonicalHeaderKey(key)]\n-}\n-\n // ProtoAtLeast returns whether the HTTP protocol used\n // in the response is at least major.minor.\n func (r *Response) ProtoAtLeast(major, minor int) bool {\n@@ -231,20 +206,19 @@ func (resp *Response) Write(w io.Writer) os.Error {\n \treturn nil\n }\n \n-func writeSortedKeyValue(w io.Writer, kvm map[string]string, exclude map[string]bool) os.Error {\n-\tkva := make([]string, len(kvm))\n-\ti := 0\n-\tfor k, v := range kvm {\n+func writeSortedKeyValue(w io.Writer, kvm map[string][]string, exclude map[string]bool) os.Error {\n+\tkeys := make([]string, 0, len(kvm))\n+\tfor k := range kvm {\n \t\tif !exclude[k] {\n-\t\t\tkva[i] = fmt.Sprint(k + \": \" + v + \"\\r\\n\")\n-\t\t\ti++\n+\t\t\tkeys = append(keys, k)\n \t\t}\n \t}\n-\tkva = kva[0:i]\n-\tsort.SortStrings(kva)\n-\tfor _, l := range kva {\n-\t\tif _, err := io.WriteString(w, l); err != nil {\n-\t\t\treturn err\n+\tsort.SortStrings(keys)\n+\tfor _, k := range keys {\n+\t\tfor _, v := range kvm[k] {\n+\t\t\tif _, err := fmt.Fprintf(w, \"%s: %s\\r\\n\", k, v); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n \t\t}\n \t}\n \treturn nil"}, {"sha": "bf63ccb9e9655a5c12869e35d61fa3e67184ba80", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -34,8 +34,8 @@ var respTests = []respTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader: map[string]string{\n-\t\t\t\t\"Connection\": \"close\", // TODO(rsc): Delete?\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Connection\": {\"close\"}, // TODO(rsc): Delete?\n \t\t\t},\n \t\t\tClose:         true,\n \t\t\tContentLength: -1,\n@@ -44,6 +44,47 @@ var respTests = []respTest{\n \t\t\"Body here\\n\",\n \t},\n \n+\t// Unchunked HTTP/1.1 response without Content-Length or\n+\t// Connection headers.\n+\t{\n+\t\t\"HTTP/1.1 200 OK\\r\\n\" +\n+\t\t\t\"\\r\\n\" +\n+\t\t\t\"Body here\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:        \"200 OK\",\n+\t\t\tStatusCode:    200,\n+\t\t\tProto:         \"HTTP/1.1\",\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    1,\n+\t\t\tRequestMethod: \"GET\",\n+\t\t\tClose:         true,\n+\t\t\tContentLength: -1,\n+\t\t},\n+\n+\t\t\"Body here\\n\",\n+\t},\n+\n+\t// Unchunked HTTP/1.1 204 response without Content-Length.\n+\t{\n+\t\t\"HTTP/1.1 204 No Content\\r\\n\" +\n+\t\t\t\"\\r\\n\" +\n+\t\t\t\"Body should not be read!\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:        \"204 No Content\",\n+\t\t\tStatusCode:    204,\n+\t\t\tProto:         \"HTTP/1.1\",\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    1,\n+\t\t\tRequestMethod: \"GET\",\n+\t\t\tClose:         false,\n+\t\t\tContentLength: 0,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n \t// Unchunked response with Content-Length.\n \t{\n \t\t\"HTTP/1.0 200 OK\\r\\n\" +\n@@ -59,9 +100,9 @@ var respTests = []respTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader: map[string]string{\n-\t\t\t\t\"Connection\":     \"close\", // TODO(rsc): Delete?\n-\t\t\t\t\"Content-Length\": \"10\",    // TODO(rsc): Delete?\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Connection\":     {\"close\"}, // TODO(rsc): Delete?\n+\t\t\t\t\"Content-Length\": {\"10\"},    // TODO(rsc): Delete?\n \t\t\t},\n \t\t\tClose:         true,\n \t\t\tContentLength: 10,\n@@ -87,7 +128,7 @@ var respTests = []respTest{\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       0,\n \t\t\tRequestMethod:    \"GET\",\n-\t\t\tHeader:           map[string]string{},\n+\t\t\tHeader:           Header{},\n \t\t\tClose:            true,\n \t\t\tContentLength:    -1,\n \t\t\tTransferEncoding: []string{\"chunked\"},\n@@ -114,7 +155,7 @@ var respTests = []respTest{\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       0,\n \t\t\tRequestMethod:    \"GET\",\n-\t\t\tHeader:           map[string]string{},\n+\t\t\tHeader:           Header{},\n \t\t\tClose:            true,\n \t\t\tContentLength:    -1, // TODO(rsc): Fix?\n \t\t\tTransferEncoding: []string{\"chunked\"},\n@@ -134,7 +175,7 @@ var respTests = []respTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string]string{},\n+\t\t\tHeader:        Header{},\n \t\t\tClose:         true,\n \t\t\tContentLength: -1,\n \t\t},\n@@ -153,7 +194,7 @@ var respTests = []respTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string]string{},\n+\t\t\tHeader:        Header{},\n \t\t\tClose:         true,\n \t\t\tContentLength: -1,\n \t\t},"}, {"sha": "aabb833f9c867123dca2cab03195a04b1b16cd06", "filename": "libgo/go/http/responsewrite_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -22,7 +22,7 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string]string{},\n+\t\t\tHeader:        map[string][]string{},\n \t\t\tBody:          nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tContentLength: 6,\n \t\t},\n@@ -38,7 +38,7 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string]string{},\n+\t\t\tHeader:        map[string][]string{},\n \t\t\tBody:          nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tContentLength: -1,\n \t\t},\n@@ -53,7 +53,7 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n \t\t\tRequestMethod:    \"GET\",\n-\t\t\tHeader:           map[string]string{},\n+\t\t\tHeader:           map[string][]string{},\n \t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tContentLength:    6,\n \t\t\tTransferEncoding: []string{\"chunked\"},"}, {"sha": "42fe3e5e4d2e9f0420082efc315df347d957ac61", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -9,10 +9,14 @@ package http\n import (\n \t\"bufio\"\n \t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"net\"\n+\t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type dummyAddr string\n@@ -136,6 +140,71 @@ func TestConsumingBodyOnNextConn(t *testing.T) {\n \t}\n }\n \n+type stringHandler string\n+\n+func (s stringHandler) ServeHTTP(w ResponseWriter, r *Request) {\n+\tw.SetHeader(\"Result\", string(s))\n+}\n+\n+var handlers = []struct {\n+\tpattern string\n+\tmsg     string\n+}{\n+\t{\"/\", \"Default\"},\n+\t{\"/someDir/\", \"someDir\"},\n+\t{\"someHost.com/someDir/\", \"someHost.com/someDir\"},\n+}\n+\n+var vtests = []struct {\n+\turl      string\n+\texpected string\n+}{\n+\t{\"http://localhost/someDir/apage\", \"someDir\"},\n+\t{\"http://localhost/otherDir/apage\", \"Default\"},\n+\t{\"http://someHost.com/someDir/apage\", \"someHost.com/someDir\"},\n+\t{\"http://otherHost.com/someDir/apage\", \"someDir\"},\n+\t{\"http://otherHost.com/aDir/apage\", \"Default\"},\n+}\n+\n+func TestHostHandlers(t *testing.T) {\n+\tfor _, h := range handlers {\n+\t\tHandle(h.pattern, stringHandler(h.msg))\n+\t}\n+\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\") // any port\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer l.Close()\n+\tgo Serve(l, nil)\n+\tconn, err := net.Dial(\"tcp\", \"\", l.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer conn.Close()\n+\tcc := NewClientConn(conn, nil)\n+\tfor _, vt := range vtests {\n+\t\tvar r *Response\n+\t\tvar req Request\n+\t\tif req.URL, err = ParseURL(vt.url); err != nil {\n+\t\t\tt.Errorf(\"cannot parse url: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := cc.Write(&req); err != nil {\n+\t\t\tt.Errorf(\"writing request: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tr, err := cc.Read(&req)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"reading response: %v\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\ts := r.Header.Get(\"Result\")\n+\t\tif s != vt.expected {\n+\t\t\tt.Errorf(\"Get(%q) = %q, want %q\", vt.url, s, vt.expected)\n+\t\t}\n+\t}\n+}\n+\n type responseWriterMethodCall struct {\n \tmethod                 string\n \theaderKey, headerValue string // if method == \"SetHeader\"\n@@ -218,3 +287,148 @@ func TestMuxRedirectLeadingSlashes(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestServerTimeouts(t *testing.T) {\n+\tl, err := net.ListenTCP(\"tcp\", &net.TCPAddr{Port: 0})\n+\tif err != nil {\n+\t\tt.Fatalf(\"listen error: %v\", err)\n+\t}\n+\taddr, _ := l.Addr().(*net.TCPAddr)\n+\n+\treqNum := 0\n+\thandler := HandlerFunc(func(res ResponseWriter, req *Request) {\n+\t\treqNum++\n+\t\tfmt.Fprintf(res, \"req=%d\", reqNum)\n+\t})\n+\n+\tconst second = 1000000000 /* nanos */\n+\tserver := &Server{Handler: handler, ReadTimeout: 0.25 * second, WriteTimeout: 0.25 * second}\n+\tgo server.Serve(l)\n+\n+\turl := fmt.Sprintf(\"http://localhost:%d/\", addr.Port)\n+\n+\t// Hit the HTTP server successfully.\n+\tr, _, err := Get(url)\n+\tif err != nil {\n+\t\tt.Fatalf(\"http Get #1: %v\", err)\n+\t}\n+\tgot, _ := ioutil.ReadAll(r.Body)\n+\texpected := \"req=1\"\n+\tif string(got) != expected {\n+\t\tt.Errorf(\"Unexpected response for request #1; got %q; expected %q\",\n+\t\t\tstring(got), expected)\n+\t}\n+\n+\t// Slow client that should timeout.\n+\tt1 := time.Nanoseconds()\n+\tconn, err := net.Dial(\"tcp\", \"\", fmt.Sprintf(\"localhost:%d\", addr.Port))\n+\tif err != nil {\n+\t\tt.Fatalf(\"Dial: %v\", err)\n+\t}\n+\tbuf := make([]byte, 1)\n+\tn, err := conn.Read(buf)\n+\tlatency := time.Nanoseconds() - t1\n+\tif n != 0 || err != os.EOF {\n+\t\tt.Errorf(\"Read = %v, %v, wanted %v, %v\", n, err, 0, os.EOF)\n+\t}\n+\tif latency < second*0.20 /* fudge from 0.25 above */ {\n+\t\tt.Errorf(\"got EOF after %d ns, want >= %d\", latency, second*0.20)\n+\t}\n+\n+\t// Hit the HTTP server successfully again, verifying that the\n+\t// previous slow connection didn't run our handler.  (that we\n+\t// get \"req=2\", not \"req=3\")\n+\tr, _, err = Get(url)\n+\tif err != nil {\n+\t\tt.Fatalf(\"http Get #2: %v\", err)\n+\t}\n+\tgot, _ = ioutil.ReadAll(r.Body)\n+\texpected = \"req=2\"\n+\tif string(got) != expected {\n+\t\tt.Errorf(\"Get #2 got %q, want %q\", string(got), expected)\n+\t}\n+\n+\tl.Close()\n+}\n+\n+// TestIdentityResponse verifies that a handler can unset \n+func TestIdentityResponse(t *testing.T) {\n+\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to listen on a port: %v\", err)\n+\t}\n+\tdefer l.Close()\n+\turlBase := \"http://\" + l.Addr().String() + \"/\"\n+\n+\thandler := HandlerFunc(func(rw ResponseWriter, req *Request) {\n+\t\trw.SetHeader(\"Content-Length\", \"3\")\n+\t\trw.SetHeader(\"Transfer-Encoding\", req.FormValue(\"te\"))\n+\t\tswitch {\n+\t\tcase req.FormValue(\"overwrite\") == \"1\":\n+\t\t\t_, err := rw.Write([]byte(\"foo TOO LONG\"))\n+\t\t\tif err != ErrContentLength {\n+\t\t\t\tt.Errorf(\"expected ErrContentLength; got %v\", err)\n+\t\t\t}\n+\t\tcase req.FormValue(\"underwrite\") == \"1\":\n+\t\t\trw.SetHeader(\"Content-Length\", \"500\")\n+\t\t\trw.Write([]byte(\"too short\"))\n+\t\tdefault:\n+\t\t\trw.Write([]byte(\"foo\"))\n+\t\t}\n+\t})\n+\n+\tserver := &Server{Handler: handler}\n+\tgo server.Serve(l)\n+\n+\t// Note: this relies on the assumption (which is true) that\n+\t// Get sends HTTP/1.1 or greater requests.  Otherwise the\n+\t// server wouldn't have the choice to send back chunked\n+\t// responses.\n+\tfor _, te := range []string{\"\", \"identity\"} {\n+\t\turl := urlBase + \"?te=\" + te\n+\t\tres, _, err := Get(url)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error with Get of %s: %v\", url, err)\n+\t\t}\n+\t\tif cl, expected := res.ContentLength, int64(3); cl != expected {\n+\t\t\tt.Errorf(\"for %s expected res.ContentLength of %d; got %d\", url, expected, cl)\n+\t\t}\n+\t\tif cl, expected := res.Header.Get(\"Content-Length\"), \"3\"; cl != expected {\n+\t\t\tt.Errorf(\"for %s expected Content-Length header of %q; got %q\", url, expected, cl)\n+\t\t}\n+\t\tif tl, expected := len(res.TransferEncoding), 0; tl != expected {\n+\t\t\tt.Errorf(\"for %s expected len(res.TransferEncoding) of %d; got %d (%v)\",\n+\t\t\t\turl, expected, tl, res.TransferEncoding)\n+\t\t}\n+\t}\n+\n+\t// Verify that ErrContentLength is returned\n+\turl := urlBase + \"?overwrite=1\"\n+\t_, _, err = Get(url)\n+\tif err != nil {\n+\t\tt.Fatalf(\"error with Get of %s: %v\", url, err)\n+\t}\n+\n+\t// Verify that the connection is closed when the declared Content-Length\n+\t// is larger than what the handler wrote.\n+\tconn, err := net.Dial(\"tcp\", \"\", l.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatalf(\"error dialing: %v\", err)\n+\t}\n+\t_, err = conn.Write([]byte(\"GET /?underwrite=1 HTTP/1.1\\r\\nHost: foo\\r\\n\\r\\n\"))\n+\tif err != nil {\n+\t\tt.Fatalf(\"error writing: %v\", err)\n+\t}\n+\t// The next ReadAll will hang for a failing test, so use a Timer instead\n+\t// to fail more traditionally\n+\ttimer := time.AfterFunc(2e9, func() {\n+\t\tt.Fatalf(\"Timeout expired in ReadAll.\")\n+\t})\n+\tdefer timer.Stop()\n+\tgot, _ := ioutil.ReadAll(conn)\n+\texpectedSuffix := \"\\r\\n\\r\\ntoo short\"\n+\tif !strings.HasSuffix(string(got), expectedSuffix) {\n+\t\tt.Fatalf(\"Expected output to end with %q; got response body %q\",\n+\t\t\texpectedSuffix, string(got))\n+\t}\n+}"}, {"sha": "977c8c2297a10b09dbdc0b041efb3664860b4f23", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 165, "deletions": 67, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -31,6 +31,7 @@ var (\n \tErrWriteAfterFlush = os.NewError(\"Conn.Write called after Flush\")\n \tErrBodyNotAllowed  = os.NewError(\"http: response status code does not allow body\")\n \tErrHijacked        = os.NewError(\"Conn has been hijacked\")\n+\tErrContentLength   = os.NewError(\"Conn.Write wrote more than the declared Content-Length\")\n )\n \n // Objects implementing the Handler interface can be\n@@ -60,10 +61,10 @@ type ResponseWriter interface {\n \t//\n \t//\tContent-Type: text/html; charset=utf-8\n \t//\n-\t// being sent.  UTF-8 encoded HTML is the default setting for\n+\t// being sent. UTF-8 encoded HTML is the default setting for\n \t// Content-Type in this library, so users need not make that\n-\t// particular call.  Calls to SetHeader after WriteHeader (or Write)\n-\t// are ignored.\n+\t// particular call. Calls to SetHeader after WriteHeader (or Write)\n+\t// are ignored. An empty value removes the header if previously set.\n \tSetHeader(string, string)\n \n \t// Write writes the data to the connection as part of an HTTP reply.\n@@ -108,6 +109,7 @@ type response struct {\n \twroteContinue bool              // 100 Continue response was written\n \theader        map[string]string // reply header parameters\n \twritten       int64             // number of bytes written in body\n+\tcontentLength int64             // explicitly-declared Content-Length; or -1\n \tstatus        int               // status code passed to WriteHeader\n \n \t// close connection after this reply.  set on request and\n@@ -170,33 +172,13 @@ func (c *conn) readRequest() (w *response, err os.Error) {\n \tw.conn = c\n \tw.req = req\n \tw.header = make(map[string]string)\n+\tw.contentLength = -1\n \n \t// Expect 100 Continue support\n \tif req.expectsContinue() && req.ProtoAtLeast(1, 1) {\n \t\t// Wrap the Body reader with one that replies on the connection\n \t\treq.Body = &expectContinueReader{readCloser: req.Body, resp: w}\n \t}\n-\n-\t// Default output is HTML encoded in UTF-8.\n-\tw.SetHeader(\"Content-Type\", \"text/html; charset=utf-8\")\n-\tw.SetHeader(\"Date\", time.UTC().Format(TimeFormat))\n-\n-\tif req.Method == \"HEAD\" {\n-\t\t// do nothing\n-\t} else if req.ProtoAtLeast(1, 1) {\n-\t\t// HTTP/1.1 or greater: use chunked transfer encoding\n-\t\t// to avoid closing the connection at EOF.\n-\t\tw.chunking = true\n-\t\tw.SetHeader(\"Transfer-Encoding\", \"chunked\")\n-\t} else {\n-\t\t// HTTP version < 1.1: cannot do chunked transfer\n-\t\t// encoding, so signal EOF by closing connection.\n-\t\t// Will be overridden if the HTTP handler ends up\n-\t\t// writing a Content-Length and the client requested\n-\t\t// \"Connection: keep-alive\"\n-\t\tw.closeAfterReply = true\n-\t}\n-\n \treturn w, nil\n }\n \n@@ -209,7 +191,10 @@ func (w *response) UsingTLS() bool {\n func (w *response) RemoteAddr() string { return w.conn.remoteAddr }\n \n // SetHeader implements the ResponseWriter.SetHeader method\n-func (w *response) SetHeader(hdr, val string) { w.header[CanonicalHeaderKey(hdr)] = val }\n+// An empty value removes the header from the map.\n+func (w *response) SetHeader(hdr, val string) {\n+\tw.header[CanonicalHeaderKey(hdr)] = val, val != \"\"\n+}\n \n // WriteHeader implements the ResponseWriter.WriteHeader method\n func (w *response) WriteHeader(code int) {\n@@ -225,13 +210,83 @@ func (w *response) WriteHeader(code int) {\n \tw.status = code\n \tif code == StatusNotModified {\n \t\t// Must not have body.\n-\t\tw.header[\"Content-Type\"] = \"\", false\n-\t\tw.header[\"Transfer-Encoding\"] = \"\", false\n+\t\tfor _, header := range []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"} {\n+\t\t\tif w.header[header] != \"\" {\n+\t\t\t\t// TODO: return an error if WriteHeader gets a return parameter\n+\t\t\t\t// or set a flag on w to make future Writes() write an error page?\n+\t\t\t\t// for now just log and drop the header.\n+\t\t\t\tlog.Printf(\"http: StatusNotModified response with header %q defined\", header)\n+\t\t\t\tw.header[header] = \"\", false\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\t// Default output is HTML encoded in UTF-8.\n+\t\tif w.header[\"Content-Type\"] == \"\" {\n+\t\t\tw.SetHeader(\"Content-Type\", \"text/html; charset=utf-8\")\n+\t\t}\n+\t}\n+\n+\tif w.header[\"Date\"] == \"\" {\n+\t\tw.SetHeader(\"Date\", time.UTC().Format(TimeFormat))\n+\t}\n+\n+\t// Check for a explicit (and valid) Content-Length header.\n+\tvar hasCL bool\n+\tvar contentLength int64\n+\tif clenStr, ok := w.header[\"Content-Length\"]; ok {\n+\t\tvar err os.Error\n+\t\tcontentLength, err = strconv.Atoi64(clenStr)\n+\t\tif err == nil {\n+\t\t\thasCL = true\n+\t\t} else {\n+\t\t\tlog.Printf(\"http: invalid Content-Length of %q sent\", clenStr)\n+\t\t\tw.SetHeader(\"Content-Length\", \"\")\n+\t\t}\n+\t}\n+\n+\tte, hasTE := w.header[\"Transfer-Encoding\"]\n+\tif hasCL && hasTE && te != \"identity\" {\n+\t\t// TODO: return an error if WriteHeader gets a return parameter\n+\t\t// For now just ignore the Content-Length.\n+\t\tlog.Printf(\"http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d\",\n+\t\t\tte, contentLength)\n+\t\tw.SetHeader(\"Content-Length\", \"\")\n+\t\thasCL = false\n+\t}\n+\n+\tif w.req.Method == \"HEAD\" {\n+\t\t// do nothing\n+\t} else if hasCL {\n \t\tw.chunking = false\n+\t\tw.contentLength = contentLength\n+\t\tw.SetHeader(\"Transfer-Encoding\", \"\")\n+\t} else if w.req.ProtoAtLeast(1, 1) {\n+\t\t// HTTP/1.1 or greater: use chunked transfer encoding\n+\t\t// to avoid closing the connection at EOF.\n+\t\t// TODO: this blows away any custom or stacked Transfer-Encoding they\n+\t\t// might have set.  Deal with that as need arises once we have a valid\n+\t\t// use case.\n+\t\tw.chunking = true\n+\t\tw.SetHeader(\"Transfer-Encoding\", \"chunked\")\n+\t} else {\n+\t\t// HTTP version < 1.1: cannot do chunked transfer\n+\t\t// encoding and we don't know the Content-Length so\n+\t\t// signal EOF by closing connection.\n+\t\tw.closeAfterReply = true\n+\t\tw.chunking = false                   // redundant\n+\t\tw.SetHeader(\"Transfer-Encoding\", \"\") // in case already set\n+\t}\n+\n+\tif w.req.wantsHttp10KeepAlive() && (w.req.Method == \"HEAD\" || hasCL) {\n+\t\t_, connectionHeaderSet := w.header[\"Connection\"]\n+\t\tif !connectionHeaderSet {\n+\t\t\tw.SetHeader(\"Connection\", \"keep-alive\")\n+\t\t}\n \t}\n+\n \t// Cannot use Content-Length with non-identity Transfer-Encoding.\n \tif w.chunking {\n-\t\tw.header[\"Content-Length\"] = \"\", false\n+\t\tw.SetHeader(\"Content-Length\", \"\")\n \t}\n \tif !w.req.ProtoAtLeast(1, 0) {\n \t\treturn\n@@ -259,15 +314,6 @@ func (w *response) Write(data []byte) (n int, err os.Error) {\n \t\treturn 0, ErrHijacked\n \t}\n \tif !w.wroteHeader {\n-\t\tif w.req.wantsHttp10KeepAlive() {\n-\t\t\t_, hasLength := w.header[\"Content-Length\"]\n-\t\t\tif hasLength {\n-\t\t\t\t_, connectionHeaderSet := w.header[\"Connection\"]\n-\t\t\t\tif !connectionHeaderSet {\n-\t\t\t\t\tw.header[\"Connection\"] = \"keep-alive\"\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \t\tw.WriteHeader(StatusOK)\n \t}\n \tif len(data) == 0 {\n@@ -280,6 +326,9 @@ func (w *response) Write(data []byte) (n int, err os.Error) {\n \t}\n \n \tw.written += int64(len(data)) // ignoring errors, for errorKludge\n+\tif w.contentLength != -1 && w.written > w.contentLength {\n+\t\treturn 0, ErrContentLength\n+\t}\n \n \t// TODO(rsc): if chunking happened after the buffering,\n \t// then there would be fewer chunk headers.\n@@ -369,6 +418,11 @@ func (w *response) finishRequest() {\n \t}\n \tw.conn.buf.Flush()\n \tw.req.Body.Close()\n+\n+\tif w.contentLength != -1 && w.contentLength != w.written {\n+\t\t// Did not write enough. Avoid getting out of sync.\n+\t\tw.closeAfterReply = true\n+\t}\n }\n \n // Flush implements the ResponseWriter.Flush method.\n@@ -539,21 +593,20 @@ func RedirectHandler(url string, code int) Handler {\n // patterns and calls the handler for the pattern that\n // most closely matches the URL.\n //\n-// Patterns named fixed paths, like \"/favicon.ico\",\n-// or subtrees, like \"/images/\" (note the trailing slash).\n-// Patterns must begin with /.\n+// Patterns named fixed, rooted paths, like \"/favicon.ico\",\n+// or rooted subtrees, like \"/images/\" (note the trailing slash).\n // Longer patterns take precedence over shorter ones, so that\n // if there are handlers registered for both \"/images/\"\n // and \"/images/thumbnails/\", the latter handler will be\n // called for paths beginning \"/images/thumbnails/\" and the\n // former will receiver requests for any other paths in the\n // \"/images/\" subtree.\n //\n-// In the future, the pattern syntax may be relaxed to allow\n-// an optional host-name at the beginning of the pattern,\n-// so that a handler might register for the two patterns\n-// \"/codesearch\" and \"codesearch.google.com/\"\n-// without taking over requests for http://www.google.com/.\n+// Patterns may optionally begin with a host name, restricting matches to\n+// URLs on that host only.  Host-specific patterns take precedence over\n+// general patterns, so that a handler might register for the two patterns\n+// \"/codesearch\" and \"codesearch.google.com/\" without also taking over\n+// requests for \"http://www.google.com/\".\n //\n // ServeMux also takes care of sanitizing the URL request path,\n // redirecting any request containing . or .. elements to an\n@@ -598,28 +651,37 @@ func cleanPath(p string) string {\n \treturn np\n }\n \n-// ServeHTTP dispatches the request to the handler whose\n-// pattern most closely matches the request URL.\n-func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n-\t// Clean path to canonical form and redirect.\n-\tif p := cleanPath(r.URL.Path); p != r.URL.Path {\n-\t\tw.SetHeader(\"Location\", p)\n-\t\tw.WriteHeader(StatusMovedPermanently)\n-\t\treturn\n-\t}\n-\n-\t// Most-specific (longest) pattern wins.\n+// Find a handler on a handler map given a path string\n+// Most-specific (longest) pattern wins\n+func (mux *ServeMux) match(path string) Handler {\n \tvar h Handler\n \tvar n = 0\n \tfor k, v := range mux.m {\n-\t\tif !pathMatch(k, r.URL.Path) {\n+\t\tif !pathMatch(k, path) {\n \t\t\tcontinue\n \t\t}\n \t\tif h == nil || len(k) > n {\n \t\t\tn = len(k)\n \t\t\th = v\n \t\t}\n \t}\n+\treturn h\n+}\n+\n+// ServeHTTP dispatches the request to the handler whose\n+// pattern most closely matches the request URL.\n+func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n+\t// Clean path to canonical form and redirect.\n+\tif p := cleanPath(r.URL.Path); p != r.URL.Path {\n+\t\tw.SetHeader(\"Location\", p)\n+\t\tw.WriteHeader(StatusMovedPermanently)\n+\t\treturn\n+\t}\n+\t// Host-specific pattern takes precedence over generic ones\n+\th := mux.match(r.Host + r.URL.Path)\n+\tif h == nil {\n+\t\th = mux.match(r.URL.Path)\n+\t}\n \tif h == nil {\n \t\th = NotFoundHandler()\n \t}\n@@ -628,7 +690,7 @@ func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n \n // Handle registers the handler for the given pattern.\n func (mux *ServeMux) Handle(pattern string, handler Handler) {\n-\tif pattern == \"\" || pattern[0] != '/' {\n+\tif pattern == \"\" {\n \t\tpanic(\"http: invalid pattern \" + pattern)\n \t}\n \n@@ -649,10 +711,12 @@ func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Re\n \n // Handle registers the handler for the given pattern\n // in the DefaultServeMux.\n+// The documentation for ServeMux explains how patterns are matched.\n func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n \n // HandleFunc registers the handler function for the given pattern\n // in the DefaultServeMux.\n+// The documentation for ServeMux explains how patterns are matched.\n func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n \tDefaultServeMux.HandleFunc(pattern, handler)\n }\n@@ -662,6 +726,39 @@ func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n // read requests and then call handler to reply to them.\n // Handler is typically nil, in which case the DefaultServeMux is used.\n func Serve(l net.Listener, handler Handler) os.Error {\n+\tsrv := &Server{Handler: handler}\n+\treturn srv.Serve(l)\n+}\n+\n+// A Server defines parameters for running an HTTP server.\n+type Server struct {\n+\tAddr         string  // TCP address to listen on, \":http\" if empty\n+\tHandler      Handler // handler to invoke, http.DefaultServeMux if nil\n+\tReadTimeout  int64   // the net.Conn.SetReadTimeout value for new connections\n+\tWriteTimeout int64   // the net.Conn.SetWriteTimeout value for new connections\n+}\n+\n+// ListenAndServe listens on the TCP network address srv.Addr and then\n+// calls Serve to handle requests on incoming connections.  If\n+// srv.Addr is blank, \":http\" is used.\n+func (srv *Server) ListenAndServe() os.Error {\n+\taddr := srv.Addr\n+\tif addr == \"\" {\n+\t\taddr = \":http\"\n+\t}\n+\tl, e := net.Listen(\"tcp\", addr)\n+\tif e != nil {\n+\t\treturn e\n+\t}\n+\treturn srv.Serve(l)\n+}\n+\n+// Serve accepts incoming connections on the Listener l, creating a\n+// new service thread for each.  The service threads read requests and\n+// then call srv.Handler to reply to them.\n+func (srv *Server) Serve(l net.Listener) os.Error {\n+\tdefer l.Close()\n+\thandler := srv.Handler\n \tif handler == nil {\n \t\thandler = DefaultServeMux\n \t}\n@@ -670,6 +767,12 @@ func Serve(l net.Listener, handler Handler) os.Error {\n \t\tif e != nil {\n \t\t\treturn e\n \t\t}\n+\t\tif srv.ReadTimeout != 0 {\n+\t\t\trw.SetReadTimeout(srv.ReadTimeout)\n+\t\t}\n+\t\tif srv.WriteTimeout != 0 {\n+\t\t\trw.SetWriteTimeout(srv.WriteTimeout)\n+\t\t}\n \t\tc, err := newConn(rw, handler)\n \t\tif err != nil {\n \t\t\tcontinue\n@@ -703,17 +806,12 @@ func Serve(l net.Listener, handler Handler) os.Error {\n //\t\thttp.HandleFunc(\"/hello\", HelloServer)\n //\t\terr := http.ListenAndServe(\":12345\", nil)\n //\t\tif err != nil {\n-//\t\t\tlog.Exit(\"ListenAndServe: \", err.String())\n+//\t\t\tlog.Fatal(\"ListenAndServe: \", err.String())\n //\t\t}\n //\t}\n func ListenAndServe(addr string, handler Handler) os.Error {\n-\tl, e := net.Listen(\"tcp\", addr)\n-\tif e != nil {\n-\t\treturn e\n-\t}\n-\te = Serve(l, handler)\n-\tl.Close()\n-\treturn e\n+\tserver := &Server{Addr: addr, Handler: handler}\n+\treturn server.ListenAndServe()\n }\n \n // ListenAndServeTLS acts identically to ListenAndServe, except that it\n@@ -737,7 +835,7 @@ func ListenAndServe(addr string, handler Handler) os.Error {\n //\t\tlog.Printf(\"About to listen on 10443. Go to https://127.0.0.1:10443/\")\n //\t\terr := http.ListenAndServeTLS(\":10443\", \"cert.pem\", \"key.pem\", nil)\n //\t\tif err != nil {\n-//\t\t\tlog.Exit(err)\n+//\t\t\tlog.Fatal(err)\n //\t\t}\n //\t}\n //"}, {"sha": "996e2897325384355aba1b1e20f020c3b55fb773", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -21,7 +21,7 @@ type transferWriter struct {\n \tContentLength    int64\n \tClose            bool\n \tTransferEncoding []string\n-\tTrailer          map[string]string\n+\tTrailer          Header\n }\n \n func newTransferWriter(r interface{}) (t *transferWriter, err os.Error) {\n@@ -159,7 +159,7 @@ func (t *transferWriter) WriteBody(w io.Writer) (err os.Error) {\n \n type transferReader struct {\n \t// Input\n-\tHeader        map[string]string\n+\tHeader        Header\n \tStatusCode    int\n \tRequestMethod string\n \tProtoMajor    int\n@@ -169,7 +169,21 @@ type transferReader struct {\n \tContentLength    int64\n \tTransferEncoding []string\n \tClose            bool\n-\tTrailer          map[string]string\n+\tTrailer          Header\n+}\n+\n+// bodyAllowedForStatus returns whether a given response status code\n+// permits a body.  See RFC2616, section 4.4.\n+func bodyAllowedForStatus(status int) bool {\n+\tswitch {\n+\tcase status >= 100 && status <= 199:\n+\t\treturn false\n+\tcase status == 204:\n+\t\treturn false\n+\tcase status == 304:\n+\t\treturn false\n+\t}\n+\treturn true\n }\n \n // msg is *Request or *Response.\n@@ -217,6 +231,19 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err os.Error) {\n \t\treturn err\n \t}\n \n+\t// If there is no Content-Length or chunked Transfer-Encoding on a *Response\n+\t// and the status is not 1xx, 204 or 304, then the body is unbounded.\n+\t// See RFC2616, section 4.4.\n+\tswitch msg.(type) {\n+\tcase *Response:\n+\t\tif t.ContentLength == -1 &&\n+\t\t\t!chunked(t.TransferEncoding) &&\n+\t\t\tbodyAllowedForStatus(t.StatusCode) {\n+\t\t\t// Unbounded body.\n+\t\t\tt.Close = true\n+\t\t}\n+\t}\n+\n \t// Prepare body reader.  ContentLength < 0 means chunked encoding\n \t// or close connection when finished, since multipart is not supported yet\n \tswitch {\n@@ -262,14 +289,14 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err os.Error) {\n func chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n \n // Sanitize transfer encoding\n-func fixTransferEncoding(header map[string]string) ([]string, os.Error) {\n+func fixTransferEncoding(header Header) ([]string, os.Error) {\n \traw, present := header[\"Transfer-Encoding\"]\n \tif !present {\n \t\treturn nil, nil\n \t}\n \n-\theader[\"Transfer-Encoding\"] = \"\", false\n-\tencodings := strings.Split(raw, \",\", -1)\n+\theader[\"Transfer-Encoding\"] = nil, false\n+\tencodings := strings.Split(raw[0], \",\", -1)\n \tte := make([]string, 0, len(encodings))\n \t// TODO: Even though we only support \"identity\" and \"chunked\"\n \t// encodings, the loop below is designed with foresight. One\n@@ -294,7 +321,7 @@ func fixTransferEncoding(header map[string]string) ([]string, os.Error) {\n \t\t// Chunked encoding trumps Content-Length. See RFC 2616\n \t\t// Section 4.4. Currently len(te) > 0 implies chunked\n \t\t// encoding.\n-\t\theader[\"Content-Length\"] = \"\", false\n+\t\theader[\"Content-Length\"] = nil, false\n \t\treturn te, nil\n \t}\n \n@@ -304,7 +331,7 @@ func fixTransferEncoding(header map[string]string) ([]string, os.Error) {\n // Determine the expected body length, using RFC 2616 Section 4.4. This\n // function is not a method, because ultimately it should be shared by\n // ReadResponse and ReadRequest.\n-func fixLength(status int, requestMethod string, header map[string]string, te []string) (int64, os.Error) {\n+func fixLength(status int, requestMethod string, header Header, te []string) (int64, os.Error) {\n \n \t// Logic based on response type or status\n \tif noBodyExpected(requestMethod) {\n@@ -324,23 +351,21 @@ func fixLength(status int, requestMethod string, header map[string]string, te []\n \t}\n \n \t// Logic based on Content-Length\n-\tif cl, present := header[\"Content-Length\"]; present {\n-\t\tcl = strings.TrimSpace(cl)\n-\t\tif cl != \"\" {\n-\t\t\tn, err := strconv.Atoi64(cl)\n-\t\t\tif err != nil || n < 0 {\n-\t\t\t\treturn -1, &badStringError{\"bad Content-Length\", cl}\n-\t\t\t}\n-\t\t\treturn n, nil\n-\t\t} else {\n-\t\t\theader[\"Content-Length\"] = \"\", false\n+\tcl := strings.TrimSpace(header.Get(\"Content-Length\"))\n+\tif cl != \"\" {\n+\t\tn, err := strconv.Atoi64(cl)\n+\t\tif err != nil || n < 0 {\n+\t\t\treturn -1, &badStringError{\"bad Content-Length\", cl}\n \t\t}\n+\t\treturn n, nil\n+\t} else {\n+\t\theader.Del(\"Content-Length\")\n \t}\n \n \t// Logic based on media type. The purpose of the following code is just\n \t// to detect whether the unsupported \"multipart/byteranges\" is being\n \t// used. A proper Content-Type parser is needed in the future.\n-\tif strings.Contains(strings.ToLower(header[\"Content-Type\"]), \"multipart/byteranges\") {\n+\tif strings.Contains(strings.ToLower(header.Get(\"Content-Type\")), \"multipart/byteranges\") {\n \t\treturn -1, ErrNotSupported\n \t}\n \n@@ -351,47 +376,42 @@ func fixLength(status int, requestMethod string, header map[string]string, te []\n // Determine whether to hang up after sending a request and body, or\n // receiving a response and body\n // 'header' is the request headers\n-func shouldClose(major, minor int, header map[string]string) bool {\n+func shouldClose(major, minor int, header Header) bool {\n \tif major < 1 {\n \t\treturn true\n \t} else if major == 1 && minor == 0 {\n-\t\tv, present := header[\"Connection\"]\n-\t\tif !present {\n-\t\t\treturn true\n-\t\t}\n-\t\tv = strings.ToLower(v)\n-\t\tif !strings.Contains(v, \"keep-alive\") {\n+\t\tif !strings.Contains(strings.ToLower(header.Get(\"Connection\")), \"keep-alive\") {\n \t\t\treturn true\n \t\t}\n \t\treturn false\n-\t} else if v, present := header[\"Connection\"]; present {\n+\t} else {\n \t\t// TODO: Should split on commas, toss surrounding white space,\n \t\t// and check each field.\n-\t\tif v == \"close\" {\n-\t\t\theader[\"Connection\"] = \"\", false\n+\t\tif strings.ToLower(header.Get(\"Connection\")) == \"close\" {\n+\t\t\theader.Del(\"Connection\")\n \t\t\treturn true\n \t\t}\n \t}\n \treturn false\n }\n \n // Parse the trailer header\n-func fixTrailer(header map[string]string, te []string) (map[string]string, os.Error) {\n-\traw, present := header[\"Trailer\"]\n-\tif !present {\n+func fixTrailer(header Header, te []string) (Header, os.Error) {\n+\traw := header.Get(\"Trailer\")\n+\tif raw == \"\" {\n \t\treturn nil, nil\n \t}\n \n-\theader[\"Trailer\"] = \"\", false\n-\ttrailer := make(map[string]string)\n+\theader.Del(\"Trailer\")\n+\ttrailer := make(Header)\n \tkeys := strings.Split(raw, \",\", -1)\n \tfor _, key := range keys {\n \t\tkey = CanonicalHeaderKey(strings.TrimSpace(key))\n \t\tswitch key {\n \t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n \t\t\treturn nil, &badStringError{\"bad trailer key\", key}\n \t\t}\n-\t\ttrailer[key] = \"\"\n+\t\ttrailer.Del(key)\n \t}\n \tif len(trailer) == 0 {\n \t\treturn nil, nil"}, {"sha": "41d639c7e2feca508cc36c2eb3570ed20c4e9888", "filename": "libgo/go/http/transport.go", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"bufio\"\n+\t\"crypto/tls\"\n+\t\"encoding/base64\"\n+\t\"fmt\"\n+\t\"net\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// DefaultTransport is the default implementation of ClientTransport\n+// and is used by DefaultClient.  It establishes a new network connection for\n+// each call to Do and uses HTTP proxies as directed by the $HTTP_PROXY and\n+// $NO_PROXY (or $http_proxy and $no_proxy) environment variables.\n+var DefaultTransport ClientTransport = &transport{}\n+\n+// transport implements http.ClientTranport for the default case,\n+// using TCP connections to either the host or a proxy, serving\n+// http or https schemes.  In the future this may become public\n+// and support options on keep-alive connection duration, pipelining\n+// controls, etc.  For now this is simply a port of the old Go code\n+// client code to the http.ClientTransport interface.\n+type transport struct {\n+\t// TODO: keep-alives, pipelining, etc using a map from\n+\t// scheme/host to a connection.  Something like:\n+\tl        sync.Mutex\n+\thostConn map[string]*ClientConn\n+}\n+\n+func (ct *transport) Do(req *Request) (resp *Response, err os.Error) {\n+\tif req.URL.Scheme != \"http\" && req.URL.Scheme != \"https\" {\n+\t\treturn nil, &badStringError{\"unsupported protocol scheme\", req.URL.Scheme}\n+\t}\n+\n+\taddr := req.URL.Host\n+\tif !hasPort(addr) {\n+\t\taddr += \":\" + req.URL.Scheme\n+\t}\n+\n+\tvar proxyURL *URL\n+\tproxyAuth := \"\"\n+\tproxy := \"\"\n+\tif !matchNoProxy(addr) {\n+\t\tproxy = os.Getenv(\"HTTP_PROXY\")\n+\t\tif proxy == \"\" {\n+\t\t\tproxy = os.Getenv(\"http_proxy\")\n+\t\t}\n+\t}\n+\n+\tif proxy != \"\" {\n+\t\tproxyURL, err = ParseRequestURL(proxy)\n+\t\tif err != nil {\n+\t\t\treturn nil, os.ErrorString(\"invalid proxy address\")\n+\t\t}\n+\t\tif proxyURL.Host == \"\" {\n+\t\t\tproxyURL, err = ParseRequestURL(\"http://\" + proxy)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, os.ErrorString(\"invalid proxy address\")\n+\t\t\t}\n+\t\t}\n+\t\taddr = proxyURL.Host\n+\t\tproxyInfo := proxyURL.RawUserinfo\n+\t\tif proxyInfo != \"\" {\n+\t\t\tenc := base64.URLEncoding\n+\t\t\tencoded := make([]byte, enc.EncodedLen(len(proxyInfo)))\n+\t\t\tenc.Encode(encoded, []byte(proxyInfo))\n+\t\t\tproxyAuth = \"Basic \" + string(encoded)\n+\t\t}\n+\t}\n+\n+\t// Connect to server or proxy\n+\tconn, err := net.Dial(\"tcp\", \"\", addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif req.URL.Scheme == \"http\" {\n+\t\t// Include proxy http header if needed.\n+\t\tif proxyAuth != \"\" {\n+\t\t\treq.Header.Set(\"Proxy-Authorization\", proxyAuth)\n+\t\t}\n+\t} else { // https\n+\t\tif proxyURL != nil {\n+\t\t\t// Ask proxy for direct connection to server.\n+\t\t\t// addr defaults above to \":https\" but we need to use numbers\n+\t\t\taddr = req.URL.Host\n+\t\t\tif !hasPort(addr) {\n+\t\t\t\taddr += \":443\"\n+\t\t\t}\n+\t\t\tfmt.Fprintf(conn, \"CONNECT %s HTTP/1.1\\r\\n\", addr)\n+\t\t\tfmt.Fprintf(conn, \"Host: %s\\r\\n\", addr)\n+\t\t\tif proxyAuth != \"\" {\n+\t\t\t\tfmt.Fprintf(conn, \"Proxy-Authorization: %s\\r\\n\", proxyAuth)\n+\t\t\t}\n+\t\t\tfmt.Fprintf(conn, \"\\r\\n\")\n+\n+\t\t\t// Read response.\n+\t\t\t// Okay to use and discard buffered reader here, because\n+\t\t\t// TLS server will not speak until spoken to.\n+\t\t\tbr := bufio.NewReader(conn)\n+\t\t\tresp, err := ReadResponse(br, \"CONNECT\")\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tif resp.StatusCode != 200 {\n+\t\t\t\tf := strings.Split(resp.Status, \" \", 2)\n+\t\t\t\treturn nil, os.ErrorString(f[1])\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Initiate TLS and check remote host name against certificate.\n+\t\tconn = tls.Client(conn, nil)\n+\t\tif err = conn.(*tls.Conn).Handshake(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\th := req.URL.Host\n+\t\tif hasPort(h) {\n+\t\t\th = h[:strings.LastIndex(h, \":\")]\n+\t\t}\n+\t\tif err = conn.(*tls.Conn).VerifyHostname(h); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\terr = req.Write(conn)\n+\tif err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\treader := bufio.NewReader(conn)\n+\tresp, err = ReadResponse(reader, req.Method)\n+\tif err != nil {\n+\t\tconn.Close()\n+\t\treturn nil, err\n+\t}\n+\n+\tresp.Body = readClose{resp.Body, conn}\n+\treturn\n+}"}, {"sha": "5b87344c50aecffad48ec1258625eb3ba0fa6f93", "filename": "libgo/go/image/decode_test.go", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package image_test\n+\n+import (\n+\t\"bufio\"\n+\t\"image\"\n+\t\"os\"\n+\t\"testing\"\n+\n+\t// TODO(nigeltao): implement bmp, gif and tiff decoders.\n+\t_ \"image/jpeg\"\n+\t_ \"image/png\"\n+)\n+\n+const goldenFile = \"testdata/video-001.png\"\n+\n+type imageTest struct {\n+\tfilename  string\n+\ttolerance int\n+}\n+\n+var imageTests = []imageTest{\n+\t//{\"testdata/video-001.bmp\", 0},\n+\t// GIF images are restricted to a 256-color palette and the conversion\n+\t// to GIF loses significant image quality.\n+\t//{\"testdata/video-001.gif\", 64<<8},\n+\t// JPEG is a lossy format and hence needs a non-zero tolerance.\n+\t{\"testdata/video-001.jpeg\", 8 << 8},\n+\t{\"testdata/video-001.png\", 0},\n+\t//{\"testdata/video-001.tiff\", 0},\n+}\n+\n+func decode(filename string) (image.Image, string, os.Error) {\n+\tf, err := os.Open(filename, os.O_RDONLY, 0400)\n+\tif err != nil {\n+\t\treturn nil, \"\", err\n+\t}\n+\tdefer f.Close()\n+\treturn image.Decode(bufio.NewReader(f))\n+}\n+\n+func delta(u0, u1 uint32) int {\n+\td := int(u0) - int(u1)\n+\tif d < 0 {\n+\t\treturn -d\n+\t}\n+\treturn d\n+}\n+\n+func withinTolerance(c0, c1 image.Color, tolerance int) bool {\n+\tr0, g0, b0, a0 := c0.RGBA()\n+\tr1, g1, b1, a1 := c1.RGBA()\n+\tr := delta(r0, r1)\n+\tg := delta(g0, g1)\n+\tb := delta(b0, b1)\n+\ta := delta(a0, a1)\n+\treturn r <= tolerance && g <= tolerance && b <= tolerance && a <= tolerance\n+}\n+\n+func TestDecode(t *testing.T) {\n+\tgolden, _, err := decode(goldenFile)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: %v\", goldenFile, err)\n+\t}\n+loop:\n+\tfor _, it := range imageTests {\n+\t\tm, _, err := decode(it.filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", it.filename, err)\n+\t\t\tcontinue loop\n+\t\t}\n+\t\tb := golden.Bounds()\n+\t\tif !b.Eq(m.Bounds()) {\n+\t\t\tt.Errorf(\"%s: want bounds %v got %v\", it.filename, b, m.Bounds())\n+\t\t\tcontinue loop\n+\t\t}\n+\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n+\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n+\t\t\t\tif !withinTolerance(golden.At(x, y), m.At(x, y), it.tolerance) {\n+\t\t\t\t\tt.Errorf(\"%s: at (%d, %d), want %v got %v\", it.filename, x, y, golden.At(x, y), m.At(x, y))\n+\t\t\t\t\tcontinue loop\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "eee4eac2e1527a17cf256a548f208f7931282ac5", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 147, "deletions": 27, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -29,11 +29,19 @@ const (\n // A cb is a combination of color type and bit depth.\n const (\n \tcbInvalid = iota\n+\tcbG1\n+\tcbG2\n+\tcbG4\n \tcbG8\n+\tcbGA8\n \tcbTC8\n+\tcbP1\n+\tcbP2\n+\tcbP4\n \tcbP8\n \tcbTCA8\n \tcbG16\n+\tcbGA16\n \tcbTC16\n \tcbTCA16\n )\n@@ -70,6 +78,7 @@ type imgOrErr struct {\n \n type decoder struct {\n \twidth, height int\n+\tdepth         int\n \tpalette       image.PalettedColorModel\n \tcb            int\n \tstage         int\n@@ -138,7 +147,29 @@ func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \t\treturn UnsupportedError(\"dimension overflow\")\n \t}\n \td.cb = cbInvalid\n-\tswitch d.tmp[8] {\n+\td.depth = int(d.tmp[8])\n+\tswitch d.depth {\n+\tcase 1:\n+\t\tswitch d.tmp[9] {\n+\t\tcase ctGrayscale:\n+\t\t\td.cb = cbG1\n+\t\tcase ctPaletted:\n+\t\t\td.cb = cbP1\n+\t\t}\n+\tcase 2:\n+\t\tswitch d.tmp[9] {\n+\t\tcase ctGrayscale:\n+\t\t\td.cb = cbG2\n+\t\tcase ctPaletted:\n+\t\t\td.cb = cbP2\n+\t\t}\n+\tcase 4:\n+\t\tswitch d.tmp[9] {\n+\t\tcase ctGrayscale:\n+\t\t\td.cb = cbG4\n+\t\tcase ctPaletted:\n+\t\t\td.cb = cbP4\n+\t\t}\n \tcase 8:\n \t\tswitch d.tmp[9] {\n \t\tcase ctGrayscale:\n@@ -147,6 +178,8 @@ func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \t\t\td.cb = cbTC8\n \t\tcase ctPaletted:\n \t\t\td.cb = cbP8\n+\t\tcase ctGrayscaleAlpha:\n+\t\t\td.cb = cbGA8\n \t\tcase ctTrueColorAlpha:\n \t\t\td.cb = cbTCA8\n \t\t}\n@@ -156,6 +189,8 @@ func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \t\t\td.cb = cbG16\n \t\tcase ctTrueColor:\n \t\t\td.cb = cbTC16\n+\t\tcase ctGrayscaleAlpha:\n+\t\t\td.cb = cbGA16\n \t\tcase ctTrueColorAlpha:\n \t\t\td.cb = cbTCA16\n \t\t}\n@@ -169,7 +204,7 @@ func (d *decoder) parseIHDR(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \n func (d *decoder) parsePLTE(r io.Reader, crc hash.Hash32, length uint32) os.Error {\n \tnp := int(length / 3) // The number of palette entries.\n-\tif length%3 != 0 || np <= 0 || np > 256 {\n+\tif length%3 != 0 || np <= 0 || np > 256 || np > 1<<uint(d.depth) {\n \t\treturn FormatError(\"bad PLTE length\")\n \t}\n \tn, err := io.ReadFull(r, d.tmp[0:3*np])\n@@ -178,7 +213,7 @@ func (d *decoder) parsePLTE(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \t}\n \tcrc.Write(d.tmp[0:n])\n \tswitch d.cb {\n-\tcase cbP8:\n+\tcase cbP1, cbP2, cbP4, cbP8:\n \t\td.palette = image.PalettedColorModel(make([]image.Color, np))\n \t\tfor i := 0; i < np; i++ {\n \t\t\td.palette[i] = image.RGBAColor{d.tmp[3*i+0], d.tmp[3*i+1], d.tmp[3*i+2], 0xff}\n@@ -206,15 +241,15 @@ func (d *decoder) parsetRNS(r io.Reader, crc hash.Hash32, length uint32) os.Erro\n \t\treturn UnsupportedError(\"grayscale transparency\")\n \tcase cbTC8, cbTC16:\n \t\treturn UnsupportedError(\"truecolor transparency\")\n-\tcase cbP8:\n+\tcase cbP1, cbP2, cbP4, cbP8:\n \t\tif n > len(d.palette) {\n \t\t\treturn FormatError(\"bad tRNS length\")\n \t\t}\n \t\tfor i := 0; i < n; i++ {\n \t\t\trgba := d.palette[i].(image.RGBAColor)\n \t\t\td.palette[i] = image.RGBAColor{rgba.R, rgba.G, rgba.B, d.tmp[i]}\n \t\t}\n-\tcase cbTCA8, cbTCA16:\n+\tcase cbGA8, cbGA16, cbTCA8, cbTCA16:\n \t\treturn FormatError(\"tRNS, color type mismatch\")\n \t}\n \treturn nil\n@@ -240,7 +275,7 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\treturn nil, err\n \t}\n \tdefer r.Close()\n-\tbpp := 0 // Bytes per pixel.\n+\tbitsPerPixel := 0\n \tmaxPalette := uint8(0)\n \tvar (\n \t\tgray     *image.Gray\n@@ -253,40 +288,50 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\timg      image.Image\n \t)\n \tswitch d.cb {\n-\tcase cbG8:\n-\t\tbpp = 1\n+\tcase cbG1, cbG2, cbG4, cbG8:\n+\t\tbitsPerPixel = d.depth\n \t\tgray = image.NewGray(d.width, d.height)\n \t\timg = gray\n+\tcase cbGA8:\n+\t\tbitsPerPixel = 16\n+\t\tnrgba = image.NewNRGBA(d.width, d.height)\n+\t\timg = nrgba\n \tcase cbTC8:\n-\t\tbpp = 3\n+\t\tbitsPerPixel = 24\n \t\trgba = image.NewRGBA(d.width, d.height)\n \t\timg = rgba\n-\tcase cbP8:\n-\t\tbpp = 1\n+\tcase cbP1, cbP2, cbP4, cbP8:\n+\t\tbitsPerPixel = d.depth\n \t\tpaletted = image.NewPaletted(d.width, d.height, d.palette)\n \t\timg = paletted\n \t\tmaxPalette = uint8(len(d.palette) - 1)\n \tcase cbTCA8:\n-\t\tbpp = 4\n+\t\tbitsPerPixel = 32\n \t\tnrgba = image.NewNRGBA(d.width, d.height)\n \t\timg = nrgba\n \tcase cbG16:\n-\t\tbpp = 2\n+\t\tbitsPerPixel = 16\n \t\tgray16 = image.NewGray16(d.width, d.height)\n \t\timg = gray16\n+\tcase cbGA16:\n+\t\tbitsPerPixel = 32\n+\t\tnrgba64 = image.NewNRGBA64(d.width, d.height)\n+\t\timg = nrgba64\n \tcase cbTC16:\n-\t\tbpp = 6\n+\t\tbitsPerPixel = 48\n \t\trgba64 = image.NewRGBA64(d.width, d.height)\n \t\timg = rgba64\n \tcase cbTCA16:\n-\t\tbpp = 8\n+\t\tbitsPerPixel = 64\n \t\tnrgba64 = image.NewNRGBA64(d.width, d.height)\n \t\timg = nrgba64\n \t}\n+\tbytesPerPixel := (bitsPerPixel + 7) / 8\n+\n \t// cr and pr are the bytes for the current and previous row.\n \t// The +1 is for the per-row filter type, which is at cr[0].\n-\tcr := make([]uint8, 1+bpp*d.width)\n-\tpr := make([]uint8, 1+bpp*d.width)\n+\tcr := make([]uint8, 1+(bitsPerPixel*d.width+7)/8)\n+\tpr := make([]uint8, 1+(bitsPerPixel*d.width+7)/8)\n \n \tfor y := 0; y < d.height; y++ {\n \t\t// Read the decompressed bytes.\n@@ -302,41 +347,106 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\tcase ftNone:\n \t\t\t// No-op.\n \t\tcase ftSub:\n-\t\t\tfor i := bpp; i < len(cdat); i++ {\n-\t\t\t\tcdat[i] += cdat[i-bpp]\n+\t\t\tfor i := bytesPerPixel; i < len(cdat); i++ {\n+\t\t\t\tcdat[i] += cdat[i-bytesPerPixel]\n \t\t\t}\n \t\tcase ftUp:\n \t\t\tfor i := 0; i < len(cdat); i++ {\n \t\t\t\tcdat[i] += pdat[i]\n \t\t\t}\n \t\tcase ftAverage:\n-\t\t\tfor i := 0; i < bpp; i++ {\n+\t\t\tfor i := 0; i < bytesPerPixel; i++ {\n \t\t\t\tcdat[i] += pdat[i] / 2\n \t\t\t}\n-\t\t\tfor i := bpp; i < len(cdat); i++ {\n-\t\t\t\tcdat[i] += uint8((int(cdat[i-bpp]) + int(pdat[i])) / 2)\n+\t\t\tfor i := bytesPerPixel; i < len(cdat); i++ {\n+\t\t\t\tcdat[i] += uint8((int(cdat[i-bytesPerPixel]) + int(pdat[i])) / 2)\n \t\t\t}\n \t\tcase ftPaeth:\n-\t\t\tfor i := 0; i < bpp; i++ {\n+\t\t\tfor i := 0; i < bytesPerPixel; i++ {\n \t\t\t\tcdat[i] += paeth(0, pdat[i], 0)\n \t\t\t}\n-\t\t\tfor i := bpp; i < len(cdat); i++ {\n-\t\t\t\tcdat[i] += paeth(cdat[i-bpp], pdat[i], pdat[i-bpp])\n+\t\t\tfor i := bytesPerPixel; i < len(cdat); i++ {\n+\t\t\t\tcdat[i] += paeth(cdat[i-bytesPerPixel], pdat[i], pdat[i-bytesPerPixel])\n \t\t\t}\n \t\tdefault:\n \t\t\treturn nil, FormatError(\"bad filter type\")\n \t\t}\n \n \t\t// Convert from bytes to colors.\n \t\tswitch d.cb {\n+\t\tcase cbG1:\n+\t\t\tfor x := 0; x < d.width; x += 8 {\n+\t\t\t\tb := cdat[x/8]\n+\t\t\t\tfor x2 := 0; x2 < 8 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 7) * 0xff})\n+\t\t\t\t\tb <<= 1\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase cbG2:\n+\t\t\tfor x := 0; x < d.width; x += 4 {\n+\t\t\t\tb := cdat[x/4]\n+\t\t\t\tfor x2 := 0; x2 < 4 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 6) * 0x55})\n+\t\t\t\t\tb <<= 2\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase cbG4:\n+\t\t\tfor x := 0; x < d.width; x += 2 {\n+\t\t\t\tb := cdat[x/2]\n+\t\t\t\tfor x2 := 0; x2 < 2 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tgray.Set(x+x2, y, image.GrayColor{(b >> 4) * 0x11})\n+\t\t\t\t\tb <<= 4\n+\t\t\t\t}\n+\t\t\t}\n \t\tcase cbG8:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\tgray.Set(x, y, image.GrayColor{cdat[x]})\n \t\t\t}\n+\t\tcase cbGA8:\n+\t\t\tfor x := 0; x < d.width; x++ {\n+\t\t\t\tycol := cdat[2*x+0]\n+\t\t\t\tnrgba.Set(x, y, image.NRGBAColor{ycol, ycol, ycol, cdat[2*x+1]})\n+\t\t\t}\n \t\tcase cbTC8:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\trgba.Set(x, y, image.RGBAColor{cdat[3*x+0], cdat[3*x+1], cdat[3*x+2], 0xff})\n \t\t\t}\n+\t\tcase cbP1:\n+\t\t\tfor x := 0; x < d.width; x += 8 {\n+\t\t\t\tb := cdat[x/8]\n+\t\t\t\tfor x2 := 0; x2 < 8 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tidx := b >> 7\n+\t\t\t\t\tif idx > maxPalette {\n+\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\t}\n+\t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n+\t\t\t\t\tb <<= 1\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase cbP2:\n+\t\t\tfor x := 0; x < d.width; x += 4 {\n+\t\t\t\tb := cdat[x/4]\n+\t\t\t\tfor x2 := 0; x2 < 4 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tidx := b >> 6\n+\t\t\t\t\tif idx > maxPalette {\n+\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\t}\n+\t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n+\t\t\t\t\tb <<= 2\n+\t\t\t\t}\n+\t\t\t}\n+\t\tcase cbP4:\n+\t\t\tfor x := 0; x < d.width; x += 2 {\n+\t\t\t\tb := cdat[x/2]\n+\t\t\t\tfor x2 := 0; x2 < 2 && x+x2 < d.width; x2++ {\n+\t\t\t\t\tidx := b >> 4\n+\t\t\t\t\tif idx > maxPalette {\n+\t\t\t\t\t\treturn nil, FormatError(\"palette index out of range\")\n+\t\t\t\t\t}\n+\t\t\t\t\tpaletted.SetColorIndex(x+x2, y, idx)\n+\t\t\t\t\tb <<= 4\n+\t\t\t\t}\n+\t\t\t}\n \t\tcase cbP8:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\tif cdat[x] > maxPalette {\n@@ -353,6 +463,12 @@ func (d *decoder) idatReader(idat io.Reader) (image.Image, os.Error) {\n \t\t\t\tycol := uint16(cdat[2*x+0])<<8 | uint16(cdat[2*x+1])\n \t\t\t\tgray16.Set(x, y, image.Gray16Color{ycol})\n \t\t\t}\n+\t\tcase cbGA16:\n+\t\t\tfor x := 0; x < d.width; x++ {\n+\t\t\t\tycol := uint16(cdat[4*x+0])<<8 | uint16(cdat[4*x+1])\n+\t\t\t\tacol := uint16(cdat[4*x+2])<<8 | uint16(cdat[4*x+3])\n+\t\t\t\tnrgba64.Set(x, y, image.NRGBA64Color{ycol, ycol, ycol, acol})\n+\t\t\t}\n \t\tcase cbTC16:\n \t\t\tfor x := 0; x < d.width; x++ {\n \t\t\t\trcol := uint16(cdat[6*x+0])<<8 | uint16(cdat[6*x+1])\n@@ -565,16 +681,20 @@ func DecodeConfig(r io.Reader) (image.Config, os.Error) {\n \t}\n \tvar cm image.ColorModel\n \tswitch d.cb {\n-\tcase cbG8:\n+\tcase cbG1, cbG2, cbG4, cbG8:\n \t\tcm = image.GrayColorModel\n+\tcase cbGA8:\n+\t\tcm = image.NRGBAColorModel\n \tcase cbTC8:\n \t\tcm = image.RGBAColorModel\n-\tcase cbP8:\n+\tcase cbP1, cbP2, cbP4, cbP8:\n \t\tcm = d.palette\n \tcase cbTCA8:\n \t\tcm = image.NRGBAColorModel\n \tcase cbG16:\n \t\tcm = image.Gray16ColorModel\n+\tcase cbGA16:\n+\t\tcm = image.NRGBA64ColorModel\n \tcase cbTC16:\n \t\tcm = image.RGBA64ColorModel\n \tcase cbTCA16:"}, {"sha": "8314a8338775914e55d703a986fbe0bccb4c0180", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -13,23 +13,23 @@ import (\n \t\"testing\"\n )\n \n-// The go PNG library currently supports only a subset of the full PNG specification.\n-// In particular, bit depths other than 8 or 16 are not supported, nor are grayscale-\n-// alpha images.\n var filenames = []string{\n-\t//\"basn0g01\",\t// bit depth is not 8 or 16\n-\t//\"basn0g02\",\t// bit depth is not 8 or 16\n-\t//\"basn0g04\",\t// bit depth is not 8 or 16\n+\t\"basn0g01\",\n+\t\"basn0g01-30\",\n+\t\"basn0g02\",\n+\t\"basn0g02-29\",\n+\t\"basn0g04\",\n+\t\"basn0g04-31\",\n \t\"basn0g08\",\n \t\"basn0g16\",\n \t\"basn2c08\",\n \t\"basn2c16\",\n-\t//\"basn3p01\",\t// bit depth is not 8 or 16\n-\t//\"basn3p02\",\t// bit depth is not 8 or 16\n-\t//\"basn3p04\",\t// bit depth is not 8 or 16\n+\t\"basn3p01\",\n+\t\"basn3p02\",\n+\t\"basn3p04\",\n \t\"basn3p08\",\n-\t//\"basn4a08\",\t// grayscale-alpha color model\n-\t//\"basn4a16\",\t// grayscale-alpha color model\n+\t\"basn4a08\",\n+\t\"basn4a16\",\n \t\"basn6a08\",\n \t\"basn6a16\",\n }\n@@ -58,7 +58,16 @@ func sng(w io.WriteCloser, filename string, png image.Image) {\n \tcpm, _ := cm.(image.PalettedColorModel)\n \tvar paletted *image.Paletted\n \tif cpm != nil {\n-\t\tbitdepth = 8\n+\t\tswitch {\n+\t\tcase len(cpm) <= 2:\n+\t\t\tbitdepth = 1\n+\t\tcase len(cpm) <= 4:\n+\t\t\tbitdepth = 2\n+\t\tcase len(cpm) <= 16:\n+\t\t\tbitdepth = 4\n+\t\tdefault:\n+\t\t\tbitdepth = 8\n+\t\t}\n \t\tpaletted = png.(*image.Paletted)\n \t}\n \n@@ -131,8 +140,15 @@ func sng(w io.WriteCloser, filename string, png image.Image) {\n \t\t\t\tfmt.Fprintf(w, \"%04x%04x%04x%04x \", nrgba64.R, nrgba64.G, nrgba64.B, nrgba64.A)\n \t\t\t}\n \t\tcase cpm != nil:\n+\t\t\tvar b, c int\n \t\t\tfor x := bounds.Min.X; x < bounds.Max.X; x++ {\n-\t\t\t\tfmt.Fprintf(w, \"%02x\", paletted.ColorIndexAt(x, y))\n+\t\t\t\tb = b<<uint(bitdepth) | int(paletted.ColorIndexAt(x, y))\n+\t\t\t\tc++\n+\t\t\t\tif c == 8/bitdepth {\n+\t\t\t\t\tfmt.Fprintf(w, \"%02x\", b)\n+\t\t\t\t\tb = 0\n+\t\t\t\t\tc = 0\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tio.WriteString(w, \"\\n\")\n@@ -143,14 +159,25 @@ func sng(w io.WriteCloser, filename string, png image.Image) {\n func TestReader(t *testing.T) {\n \tfor _, fn := range filenames {\n \t\t// Read the .png file.\n-\t\timage, err := readPng(\"testdata/pngsuite/\" + fn + \".png\")\n+\t\timg, err := readPng(\"testdata/pngsuite/\" + fn + \".png\")\n \t\tif err != nil {\n \t\t\tt.Error(fn, err)\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif fn == \"basn4a16\" {\n+\t\t\t// basn4a16.sng is gray + alpha but sng() will produce true color + alpha\n+\t\t\t// so we just check a single random pixel.\n+\t\t\tc := img.At(2, 1).(image.NRGBA64Color)\n+\t\t\tif c.R != 0x11a7 || c.G != 0x11a7 || c.B != 0x11a7 || c.A != 0x1085 {\n+\t\t\t\tt.Error(fn, fmt.Errorf(\"wrong pixel value at (2, 1): %x\", c))\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tpiper, pipew := io.Pipe()\n \t\tpb := bufio.NewReader(piper)\n-\t\tgo sng(pipew, fn, image)\n+\t\tgo sng(pipew, fn, img)\n \t\tdefer piper.Close()\n \n \t\t// Read the .sng file."}, {"sha": "abe3ecb201d6c61b2e63c82d236257245c6218cd", "filename": "libgo/go/image/png/testdata/pngsuite/README", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2FREADME?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -5,5 +5,14 @@ README.original gives the following license for those files:\n \tPermission to use, copy, and distribute these images for any purpose\n \tand without fee is hereby granted.\n \n+\n+The files basn0g01-30.png, basn0g02-29.png and basn0g04-31.png are in fact\n+not part of pngsuite but were created from files in pngsuite. Their non-power-\n+of-two sizes makes them useful for testing bit-depths smaller than a byte.\n+\n The *.sng files in this directory were generated from the *.png files\n-by the sng command-line tool.\n+by the sng command-line tool and some hand editing. The files\n+basn0g0{1,2,4}.sng were actually generated by first converting the PNG\n+to a bitdepth of 8 and then running sng on them. basn4a08.sng was generated\n+by from a 16-bit rgba version of basn4a08.png rather than the original\n+gray + alpha."}, {"sha": "7fa35710ca5d096ca33a0bf78ba826fe82276cd1", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g01-30.sng", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01-30.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01-30.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01-30.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,39 @@\n+#SNG: from basn0g01-30.png\n+IHDR {\n+    width: 30; height: 30; bitdepth: 8;\n+    using grayscale;\n+}\n+gAMA {1.0000}\n+IMAGE {\n+    pixels hex\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffffffff000000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffffff00000000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffff0000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffffffff000000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffffff00000000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffff0000000000000000\n+ffffffffff0000000000000000ffffffffffffffff000000000000000000\n+ffffffffff0000000000000000ffffffffffffff00000000000000000000\n+ffffffffffff0000ffff0000ffffffffffffff0000000000000000000000\n+ffffffffffff0000ffff0000ffffffffffff000000000000000000000000\n+ffffffffffffffffffffffffffffffffff00000000000000000000000000\n+ffffffffffffffffffffffffffffffff0000000000000000000000000000\n+ffffffffffffffffffffffffffffff000000000000000000000000000000\n+ffffffffffffffffffffffffffff00000000000000000000000000000000\n+ffffffffffffffffffffffffff00000000000000ffffffffffffff000000\n+ffffffffffffffffffffffff0000000000000000ffffffffffffff000000\n+ffffffffffffffffffffff000000000000000000ffff00000000ffff0000\n+ffffffffffffffffffff00000000000000000000ffff00000000ffff0000\n+ffffffffffffffffff0000000000000000000000ffffffffffffff000000\n+ffffffffffffffff000000000000000000000000ffffffffffffff000000\n+ffffffffffffff00000000000000000000000000ffff00000000ffff0000\n+ffffffffffff0000000000000000000000000000ffff00000000ffff0000\n+ffffffffff000000000000000000000000000000ffffffffffffff000000\n+ffffffff00000000000000000000000000000000ffffffffffffff000000\n+ffffff000000000000000000000000000000000000000000000000000000\n+ffff00000000000000000000000000000000000000000000000000000000\n+}"}, {"sha": "2ce069de2644155291b395bdbdd983e4ee3eac8f", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g01.sng", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g01.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1,41 +1,41 @@\n #SNG: from basn0g01.png\n IHDR {\n-    width: 32; height: 32; bitdepth: 1;\n+    width: 32; height: 32; bitdepth: 8;\n     using grayscale;\n }\n gAMA {1.0000}\n IMAGE {\n     pixels hex\n-fffffffe\n-fffffffc\n-fffffff8\n-fffffff0\n-f3f3ffe0\n-f3f3ffc0\n-f3f3ff80\n-f333ff00\n-f333fe00\n-f333fc00\n-f807f800\n-f807f000\n-fccfe000\n-fccfc000\n-ffff8000\n-ffff0000\n-fffe0000\n-fffc0000\n-fff80fe0\n-fff00fe0\n-ffe00c30\n-ffc00c30\n-ff800fe0\n-ff000fe0\n-fe000c30\n-fc000c30\n-f8000fe0\n-f0000fe0\n-e0000000\n-c0000000\n-80000000\n-00000000\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000\n+ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffffffff0000000000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffffff000000000000\n+ffffffff0000ffffffffffff0000ffffffffffffffffffffff00000000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffffffff0000000000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffffff000000000000000000\n+ffffffff0000ffff0000ffff0000ffffffffffffffff00000000000000000000\n+ffffffffff0000000000000000ffffffffffffffff0000000000000000000000\n+ffffffffff0000000000000000ffffffffffffff000000000000000000000000\n+ffffffffffff0000ffff0000ffffffffffffff00000000000000000000000000\n+ffffffffffff0000ffff0000ffffffffffff0000000000000000000000000000\n+ffffffffffffffffffffffffffffffffff000000000000000000000000000000\n+ffffffffffffffffffffffffffffffff00000000000000000000000000000000\n+ffffffffffffffffffffffffffffff0000000000000000000000000000000000\n+ffffffffffffffffffffffffffff000000000000000000000000000000000000\n+ffffffffffffffffffffffffff00000000000000ffffffffffffff0000000000\n+ffffffffffffffffffffffff0000000000000000ffffffffffffff0000000000\n+ffffffffffffffffffffff000000000000000000ffff00000000ffff00000000\n+ffffffffffffffffffff00000000000000000000ffff00000000ffff00000000\n+ffffffffffffffffff0000000000000000000000ffffffffffffff0000000000\n+ffffffffffffffff000000000000000000000000ffffffffffffff0000000000\n+ffffffffffffff00000000000000000000000000ffff00000000ffff00000000\n+ffffffffffff0000000000000000000000000000ffff00000000ffff00000000\n+ffffffffff000000000000000000000000000000ffffffffffffff0000000000\n+ffffffff00000000000000000000000000000000ffffffffffffff0000000000\n+ffffff0000000000000000000000000000000000000000000000000000000000\n+ffff000000000000000000000000000000000000000000000000000000000000\n+ff00000000000000000000000000000000000000000000000000000000000000\n+0000000000000000000000000000000000000000000000000000000000000000\n }"}, {"sha": "afb5dba48002c643dbad84c85cf0bc02ec055e50", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g02-29.sng", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02-29.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02-29.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02-29.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,38 @@\n+#SNG: from basn0g02-29.png\n+IHDR {\n+    width: 29; height: 29; bitdepth: 8;\n+    using grayscale;\n+}\n+gAMA {1.0000}\n+IMAGE {\n+    pixels hex\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aa\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaff\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aa\n+}"}, {"sha": "bb53d750df9d0e86b028de7496023b3ec3377212", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g02.sng", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g02.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1,41 +1,41 @@\n #SNG: from basn0g02.png\n IHDR {\n-    width: 32; height: 32; bitdepth: 2;\n+    width: 32; height: 32; bitdepth: 8;\n     using grayscale;\n }\n gAMA {1.0000}\n IMAGE {\n     pixels hex\n-0055aaff0055aaff\n-0055aaff0055aaff\n-0055aaff0055aaff\n-0055aaff0055aaff\n-55aaff0055aaff00\n-55aaff0055aaff00\n-55aaff0055aaff00\n-55aaff0055aaff00\n-aaff0055aaff0055\n-aaff0055aaff0055\n-aaff0055aaff0055\n-aaff0055aaff0055\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n-0055aaff0055aaff\n-0055aaff0055aaff\n-0055aaff0055aaff\n-0055aaff0055aaff\n-55aaff0055aaff00\n-55aaff0055aaff00\n-55aaff0055aaff00\n-55aaff0055aaff00\n-aaff0055aaff0055\n-aaff0055aaff0055\n-aaff0055aaff0055\n-aaff0055aaff0055\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n-ff0055aaff0055aa\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+55555555aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff00000000\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+aaaaaaaaffffffff0000000055555555aaaaaaaaffffffff0000000055555555\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n+ffffffff0000000055555555aaaaaaaaffffffff0000000055555555aaaaaaaa\n }"}, {"sha": "7f7948e1f7bd2bb556975e3046a07821b68458cd", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g04-31.sng", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04-31.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04-31.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04-31.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -0,0 +1,40 @@\n+#SNG: from basn0g04-31.png\n+IHDR {\n+    width: 31; height: 31; bitdepth: 8;\n+    using grayscale;\n+}\n+gAMA {1.0000}\n+IMAGE {\n+    pixels hex\n+00000000111111112222222233333333444444445555555566666666777777\n+00000000111111112222222233333333444444445555555566666666777777\n+00000000111111112222222233333333444444445555555566666666777777\n+00000000111111112222222233333333444444445555555566666666777777\n+11111111222222223333333344444444555555556666666677777777888888\n+11111111222222223333333344444444555555556666666677777777888888\n+11111111222222223333333344444444555555556666666677777777888888\n+11111111222222223333333344444444555555556666666677777777888888\n+22222222333333334444444455555555666666667777777788888888999999\n+22222222333333334444444455555555666666667777777788888888999999\n+22222222333333334444444455555555666666667777777788888888999999\n+22222222333333334444444455555555666666667777777788888888999999\n+33333333444444445555555566666666777777778888888899999999aaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaa\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbb\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccc\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddd\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeee\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeee\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeee\n+}"}, {"sha": "a95ad01a355486c7df939a12ce1fd8fb19b047b1", "filename": "libgo/go/image/png/testdata/pngsuite/basn0g04.sng", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn0g04.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1,41 +1,41 @@\n #SNG: from basn0g04.png\n IHDR {\n-    width: 32; height: 32; bitdepth: 4;\n+    width: 32; height: 32; bitdepth: 8;\n     using grayscale;\n }\n gAMA {1.0000}\n IMAGE {\n     pixels hex\n-00001111222233334444555566667777\n-00001111222233334444555566667777\n-00001111222233334444555566667777\n-00001111222233334444555566667777\n-11112222333344445555666677778888\n-11112222333344445555666677778888\n-11112222333344445555666677778888\n-11112222333344445555666677778888\n-22223333444455556666777788889999\n-22223333444455556666777788889999\n-22223333444455556666777788889999\n-22223333444455556666777788889999\n-3333444455556666777788889999aaaa\n-3333444455556666777788889999aaaa\n-3333444455556666777788889999aaaa\n-3333444455556666777788889999aaaa\n-444455556666777788889999aaaabbbb\n-444455556666777788889999aaaabbbb\n-444455556666777788889999aaaabbbb\n-444455556666777788889999aaaabbbb\n-55556666777788889999aaaabbbbcccc\n-55556666777788889999aaaabbbbcccc\n-55556666777788889999aaaabbbbcccc\n-55556666777788889999aaaabbbbcccc\n-6666777788889999aaaabbbbccccdddd\n-6666777788889999aaaabbbbccccdddd\n-6666777788889999aaaabbbbccccdddd\n-6666777788889999aaaabbbbccccdddd\n-777788889999aaaabbbbccccddddeeee\n-777788889999aaaabbbbccccddddeeee\n-777788889999aaaabbbbccccddddeeee\n-777788889999aaaabbbbccccddddeeee\n+0000000011111111222222223333333344444444555555556666666677777777\n+0000000011111111222222223333333344444444555555556666666677777777\n+0000000011111111222222223333333344444444555555556666666677777777\n+0000000011111111222222223333333344444444555555556666666677777777\n+1111111122222222333333334444444455555555666666667777777788888888\n+1111111122222222333333334444444455555555666666667777777788888888\n+1111111122222222333333334444444455555555666666667777777788888888\n+1111111122222222333333334444444455555555666666667777777788888888\n+2222222233333333444444445555555566666666777777778888888899999999\n+2222222233333333444444445555555566666666777777778888888899999999\n+2222222233333333444444445555555566666666777777778888888899999999\n+2222222233333333444444445555555566666666777777778888888899999999\n+33333333444444445555555566666666777777778888888899999999aaaaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaaaa\n+33333333444444445555555566666666777777778888888899999999aaaaaaaa\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbbbb\n+444444445555555566666666777777778888888899999999aaaaaaaabbbbbbbb\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccccc\n+5555555566666666777777778888888899999999aaaaaaaabbbbbbbbcccccccc\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddddd\n+66666666777777778888888899999999aaaaaaaabbbbbbbbccccccccdddddddd\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee\n+777777778888888899999999aaaaaaaabbbbbbbbccccccccddddddddeeeeeeee\n }"}, {"sha": "ab3fb375fc406768fdf1151bfec82559fe8565ff", "filename": "libgo/go/image/png/testdata/pngsuite/basn3p02.sng", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p02.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p02.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p02.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -4,14 +4,11 @@ IHDR {\n     using color palette;\n }\n gAMA {1.0000}\n-sBIT {\n-    red: 1; green: 1; blue: 1;\n-}\n PLTE {\n-    (  0,255,  0)     # rgb = (0x00,0xff,0x00) green1\n-    (255,  0,  0)     # rgb = (0xff,0x00,0x00) red1\n-    (255,255,  0)     # rgb = (0xff,0xff,0x00) yellow1\n-    (  0,  0,255)     # rgb = (0x00,0x00,0xff) blue1\n+    (  0,255,  0)     # rgb = (0x00,0xff,0x00)\n+    (255,  0,  0)     # rgb = (0xff,0x00,0x00)\n+    (255,255,  0)     # rgb = (0xff,0xff,0x00)\n+    (  0,  0,255)     # rgb = (0x00,0x00,0xff)\n }\n IMAGE {\n     pixels hex"}, {"sha": "a2b2fb53c28df35ce87d6b0437f78f467d26c4bc", "filename": "libgo/go/image/png/testdata/pngsuite/basn3p04.sng", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p04.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p04.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn3p04.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -4,19 +4,16 @@ IHDR {\n     using color palette;\n }\n gAMA {1.0000}\n-sBIT {\n-    red: 4; green: 4; blue: 4;\n-}\n PLTE {\n     ( 34,  0,255)     # rgb = (0x22,0x00,0xff)\n-    (  0,255,255)     # rgb = (0x00,0xff,0xff) cyan1\n+    (  0,255,255)     # rgb = (0x00,0xff,0xff)\n     (136,  0,255)     # rgb = (0x88,0x00,0xff)\n     ( 34,255,  0)     # rgb = (0x22,0xff,0x00)\n     (  0,153,255)     # rgb = (0x00,0x99,0xff)\n     (255,102,  0)     # rgb = (0xff,0x66,0x00)\n     (221,  0,255)     # rgb = (0xdd,0x00,0xff)\n     (119,255,  0)     # rgb = (0x77,0xff,0x00)\n-    (255,  0,  0)     # rgb = (0xff,0x00,0x00) red1\n+    (255,  0,  0)     # rgb = (0xff,0x00,0x00)\n     (  0,255,153)     # rgb = (0x00,0xff,0x99)\n     (221,255,  0)     # rgb = (0xdd,0xff,0x00)\n     (255,  0,187)     # rgb = (0xff,0x00,0xbb)"}, {"sha": "cc4096fac5db7bf09f914a0aae466dfe29985386", "filename": "libgo/go/image/png/testdata/pngsuite/basn4a08.sng", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn4a08.sng", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn4a08.sng", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Ftestdata%2Fpngsuite%2Fbasn4a08.sng?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -1,41 +1,41 @@\n #SNG: from basn4a08.png\n IHDR {\n     width: 32; height: 32; bitdepth: 8;\n-    using grayscale alpha;\n+    using color alpha;\n }\n gAMA {1.0000}\n IMAGE {\n     pixels hex\n-ff00 ff08 ff10 ff18 ff20 ff29 ff31 ff39 ff41 ff4a ff52 ff5a ff62 ff6a ff73 ff7b ff83 ff8b ff94 ff9c ffa4 ffac ffb4 ffbd ffc5 ffcd ffd5 ffde ffe6 ffee fff6 ffff \n-f600 f608 f610 f618 f620 f629 f631 f639 f641 f64a f652 f65a f662 f66a f673 f67b f683 f68b f694 f69c f6a4 f6ac f6b4 f6bd f6c5 f6cd f6d5 f6de f6e6 f6ee f6f6 f6ff \n-ee00 ee08 ee10 ee18 ee20 ee29 ee31 ee39 ee41 ee4a ee52 ee5a ee62 ee6a ee73 ee7b ee83 ee8b ee94 ee9c eea4 eeac eeb4 eebd eec5 eecd eed5 eede eee6 eeee eef6 eeff \n-e600 e608 e610 e618 e620 e629 e631 e639 e641 e64a e652 e65a e662 e66a e673 e67b e683 e68b e694 e69c e6a4 e6ac e6b4 e6bd e6c5 e6cd e6d5 e6de e6e6 e6ee e6f6 e6ff \n-de00 de08 de10 de18 de20 de29 de31 de39 de41 de4a de52 de5a de62 de6a de73 de7b de83 de8b de94 de9c dea4 deac deb4 debd dec5 decd ded5 dede dee6 deee def6 deff \n-d500 d508 d510 d518 d520 d529 d531 d539 d541 d54a d552 d55a d562 d56a d573 d57b d583 d58b d594 d59c d5a4 d5ac d5b4 d5bd d5c5 d5cd d5d5 d5de d5e6 d5ee d5f6 d5ff \n-cd00 cd08 cd10 cd18 cd20 cd29 cd31 cd39 cd41 cd4a cd52 cd5a cd62 cd6a cd73 cd7b cd83 cd8b cd94 cd9c cda4 cdac cdb4 cdbd cdc5 cdcd cdd5 cdde cde6 cdee cdf6 cdff \n-c500 c508 c510 c518 c520 c529 c531 c539 c541 c54a c552 c55a c562 c56a c573 c57b c583 c58b c594 c59c c5a4 c5ac c5b4 c5bd c5c5 c5cd c5d5 c5de c5e6 c5ee c5f6 c5ff \n-bd00 bd08 bd10 bd18 bd20 bd29 bd31 bd39 bd41 bd4a bd52 bd5a bd62 bd6a bd73 bd7b bd83 bd8b bd94 bd9c bda4 bdac bdb4 bdbd bdc5 bdcd bdd5 bdde bde6 bdee bdf6 bdff \n-b400 b408 b410 b418 b420 b429 b431 b439 b441 b44a b452 b45a b462 b46a b473 b47b b483 b48b b494 b49c b4a4 b4ac b4b4 b4bd b4c5 b4cd b4d5 b4de b4e6 b4ee b4f6 b4ff \n-ac00 ac08 ac10 ac18 ac20 ac29 ac31 ac39 ac41 ac4a ac52 ac5a ac62 ac6a ac73 ac7b ac83 ac8b ac94 ac9c aca4 acac acb4 acbd acc5 accd acd5 acde ace6 acee acf6 acff \n-a400 a408 a410 a418 a420 a429 a431 a439 a441 a44a a452 a45a a462 a46a a473 a47b a483 a48b a494 a49c a4a4 a4ac a4b4 a4bd a4c5 a4cd a4d5 a4de a4e6 a4ee a4f6 a4ff \n-9c00 9c08 9c10 9c18 9c20 9c29 9c31 9c39 9c41 9c4a 9c52 9c5a 9c62 9c6a 9c73 9c7b 9c83 9c8b 9c94 9c9c 9ca4 9cac 9cb4 9cbd 9cc5 9ccd 9cd5 9cde 9ce6 9cee 9cf6 9cff \n-9400 9408 9410 9418 9420 9429 9431 9439 9441 944a 9452 945a 9462 946a 9473 947b 9483 948b 9494 949c 94a4 94ac 94b4 94bd 94c5 94cd 94d5 94de 94e6 94ee 94f6 94ff \n-8b00 8b08 8b10 8b18 8b20 8b29 8b31 8b39 8b41 8b4a 8b52 8b5a 8b62 8b6a 8b73 8b7b 8b83 8b8b 8b94 8b9c 8ba4 8bac 8bb4 8bbd 8bc5 8bcd 8bd5 8bde 8be6 8bee 8bf6 8bff \n-8300 8308 8310 8318 8320 8329 8331 8339 8341 834a 8352 835a 8362 836a 8373 837b 8383 838b 8394 839c 83a4 83ac 83b4 83bd 83c5 83cd 83d5 83de 83e6 83ee 83f6 83ff \n-7b00 7b08 7b10 7b18 7b20 7b29 7b31 7b39 7b41 7b4a 7b52 7b5a 7b62 7b6a 7b73 7b7b 7b83 7b8b 7b94 7b9c 7ba4 7bac 7bb4 7bbd 7bc5 7bcd 7bd5 7bde 7be6 7bee 7bf6 7bff \n-7300 7308 7310 7318 7320 7329 7331 7339 7341 734a 7352 735a 7362 736a 7373 737b 7383 738b 7394 739c 73a4 73ac 73b4 73bd 73c5 73cd 73d5 73de 73e6 73ee 73f6 73ff \n-6a00 6a08 6a10 6a18 6a20 6a29 6a31 6a39 6a41 6a4a 6a52 6a5a 6a62 6a6a 6a73 6a7b 6a83 6a8b 6a94 6a9c 6aa4 6aac 6ab4 6abd 6ac5 6acd 6ad5 6ade 6ae6 6aee 6af6 6aff \n-6200 6208 6210 6218 6220 6229 6231 6239 6241 624a 6252 625a 6262 626a 6273 627b 6283 628b 6294 629c 62a4 62ac 62b4 62bd 62c5 62cd 62d5 62de 62e6 62ee 62f6 62ff \n-5a00 5a08 5a10 5a18 5a20 5a29 5a31 5a39 5a41 5a4a 5a52 5a5a 5a62 5a6a 5a73 5a7b 5a83 5a8b 5a94 5a9c 5aa4 5aac 5ab4 5abd 5ac5 5acd 5ad5 5ade 5ae6 5aee 5af6 5aff \n-5200 5208 5210 5218 5220 5229 5231 5239 5241 524a 5252 525a 5262 526a 5273 527b 5283 528b 5294 529c 52a4 52ac 52b4 52bd 52c5 52cd 52d5 52de 52e6 52ee 52f6 52ff \n-4a00 4a08 4a10 4a18 4a20 4a29 4a31 4a39 4a41 4a4a 4a52 4a5a 4a62 4a6a 4a73 4a7b 4a83 4a8b 4a94 4a9c 4aa4 4aac 4ab4 4abd 4ac5 4acd 4ad5 4ade 4ae6 4aee 4af6 4aff \n-4100 4108 4110 4118 4120 4129 4131 4139 4141 414a 4152 415a 4162 416a 4173 417b 4183 418b 4194 419c 41a4 41ac 41b4 41bd 41c5 41cd 41d5 41de 41e6 41ee 41f6 41ff \n-3900 3908 3910 3918 3920 3929 3931 3939 3941 394a 3952 395a 3962 396a 3973 397b 3983 398b 3994 399c 39a4 39ac 39b4 39bd 39c5 39cd 39d5 39de 39e6 39ee 39f6 39ff \n-3100 3108 3110 3118 3120 3129 3131 3139 3141 314a 3152 315a 3162 316a 3173 317b 3183 318b 3194 319c 31a4 31ac 31b4 31bd 31c5 31cd 31d5 31de 31e6 31ee 31f6 31ff \n-2900 2908 2910 2918 2920 2929 2931 2939 2941 294a 2952 295a 2962 296a 2973 297b 2983 298b 2994 299c 29a4 29ac 29b4 29bd 29c5 29cd 29d5 29de 29e6 29ee 29f6 29ff \n-2000 2008 2010 2018 2020 2029 2031 2039 2041 204a 2052 205a 2062 206a 2073 207b 2083 208b 2094 209c 20a4 20ac 20b4 20bd 20c5 20cd 20d5 20de 20e6 20ee 20f6 20ff \n-1800 1808 1810 1818 1820 1829 1831 1839 1841 184a 1852 185a 1862 186a 1873 187b 1883 188b 1894 189c 18a4 18ac 18b4 18bd 18c5 18cd 18d5 18de 18e6 18ee 18f6 18ff \n-1000 1008 1010 1018 1020 1029 1031 1039 1041 104a 1052 105a 1062 106a 1073 107b 1083 108b 1094 109c 10a4 10ac 10b4 10bd 10c5 10cd 10d5 10de 10e6 10ee 10f6 10ff \n-0800 0808 0810 0818 0820 0829 0831 0839 0841 084a 0852 085a 0862 086a 0873 087b 0883 088b 0894 089c 08a4 08ac 08b4 08bd 08c5 08cd 08d5 08de 08e6 08ee 08f6 08ff \n-0000 0008 0010 0018 0020 0029 0031 0039 0041 004a 0052 005a 0062 006a 0073 007b 0083 008b 0094 009c 00a4 00ac 00b4 00bd 00c5 00cd 00d5 00de 00e6 00ee 00f6 00ff \n+ffffff00 ffffff08 ffffff10 ffffff18 ffffff20 ffffff29 ffffff31 ffffff39 ffffff41 ffffff4a ffffff52 ffffff5a ffffff62 ffffff6a ffffff73 ffffff7b ffffff83 ffffff8b ffffff94 ffffff9c ffffffa4 ffffffac ffffffb4 ffffffbd ffffffc5 ffffffcd ffffffd5 ffffffde ffffffe6 ffffffee fffffff6 ffffffff \n+f6f6f600 f6f6f608 f6f6f610 f6f6f618 f6f6f620 f6f6f629 f6f6f631 f6f6f639 f6f6f641 f6f6f64a f6f6f652 f6f6f65a f6f6f662 f6f6f66a f6f6f673 f6f6f67b f6f6f683 f6f6f68b f6f6f694 f6f6f69c f6f6f6a4 f6f6f6ac f6f6f6b4 f6f6f6bd f6f6f6c5 f6f6f6cd f6f6f6d5 f6f6f6de f6f6f6e6 f6f6f6ee f6f6f6f6 f6f6f6ff \n+eeeeee00 eeeeee08 eeeeee10 eeeeee18 eeeeee20 eeeeee29 eeeeee31 eeeeee39 eeeeee41 eeeeee4a eeeeee52 eeeeee5a eeeeee62 eeeeee6a eeeeee73 eeeeee7b eeeeee83 eeeeee8b eeeeee94 eeeeee9c eeeeeea4 eeeeeeac eeeeeeb4 eeeeeebd eeeeeec5 eeeeeecd eeeeeed5 eeeeeede eeeeeee6 eeeeeeee eeeeeef6 eeeeeeff \n+e6e6e600 e6e6e608 e6e6e610 e6e6e618 e6e6e620 e6e6e629 e6e6e631 e6e6e639 e6e6e641 e6e6e64a e6e6e652 e6e6e65a e6e6e662 e6e6e66a e6e6e673 e6e6e67b e6e6e683 e6e6e68b e6e6e694 e6e6e69c e6e6e6a4 e6e6e6ac e6e6e6b4 e6e6e6bd e6e6e6c5 e6e6e6cd e6e6e6d5 e6e6e6de e6e6e6e6 e6e6e6ee e6e6e6f6 e6e6e6ff \n+dedede00 dedede08 dedede10 dedede18 dedede20 dedede29 dedede31 dedede39 dedede41 dedede4a dedede52 dedede5a dedede62 dedede6a dedede73 dedede7b dedede83 dedede8b dedede94 dedede9c dededea4 dededeac dededeb4 dededebd dededec5 dededecd dededed5 dededede dededee6 dededeee dededef6 dededeff \n+d5d5d500 d5d5d508 d5d5d510 d5d5d518 d5d5d520 d5d5d529 d5d5d531 d5d5d539 d5d5d541 d5d5d54a d5d5d552 d5d5d55a d5d5d562 d5d5d56a d5d5d573 d5d5d57b d5d5d583 d5d5d58b d5d5d594 d5d5d59c d5d5d5a4 d5d5d5ac d5d5d5b4 d5d5d5bd d5d5d5c5 d5d5d5cd d5d5d5d5 d5d5d5de d5d5d5e6 d5d5d5ee d5d5d5f6 d5d5d5ff \n+cdcdcd00 cdcdcd08 cdcdcd10 cdcdcd18 cdcdcd20 cdcdcd29 cdcdcd31 cdcdcd39 cdcdcd41 cdcdcd4a cdcdcd52 cdcdcd5a cdcdcd62 cdcdcd6a cdcdcd73 cdcdcd7b cdcdcd83 cdcdcd8b cdcdcd94 cdcdcd9c cdcdcda4 cdcdcdac cdcdcdb4 cdcdcdbd cdcdcdc5 cdcdcdcd cdcdcdd5 cdcdcdde cdcdcde6 cdcdcdee cdcdcdf6 cdcdcdff \n+c5c5c500 c5c5c508 c5c5c510 c5c5c518 c5c5c520 c5c5c529 c5c5c531 c5c5c539 c5c5c541 c5c5c54a c5c5c552 c5c5c55a c5c5c562 c5c5c56a c5c5c573 c5c5c57b c5c5c583 c5c5c58b c5c5c594 c5c5c59c c5c5c5a4 c5c5c5ac c5c5c5b4 c5c5c5bd c5c5c5c5 c5c5c5cd c5c5c5d5 c5c5c5de c5c5c5e6 c5c5c5ee c5c5c5f6 c5c5c5ff \n+bdbdbd00 bdbdbd08 bdbdbd10 bdbdbd18 bdbdbd20 bdbdbd29 bdbdbd31 bdbdbd39 bdbdbd41 bdbdbd4a bdbdbd52 bdbdbd5a bdbdbd62 bdbdbd6a bdbdbd73 bdbdbd7b bdbdbd83 bdbdbd8b bdbdbd94 bdbdbd9c bdbdbda4 bdbdbdac bdbdbdb4 bdbdbdbd bdbdbdc5 bdbdbdcd bdbdbdd5 bdbdbdde bdbdbde6 bdbdbdee bdbdbdf6 bdbdbdff \n+b4b4b400 b4b4b408 b4b4b410 b4b4b418 b4b4b420 b4b4b429 b4b4b431 b4b4b439 b4b4b441 b4b4b44a b4b4b452 b4b4b45a b4b4b462 b4b4b46a b4b4b473 b4b4b47b b4b4b483 b4b4b48b b4b4b494 b4b4b49c b4b4b4a4 b4b4b4ac b4b4b4b4 b4b4b4bd b4b4b4c5 b4b4b4cd b4b4b4d5 b4b4b4de b4b4b4e6 b4b4b4ee b4b4b4f6 b4b4b4ff \n+acacac00 acacac08 acacac10 acacac18 acacac20 acacac29 acacac31 acacac39 acacac41 acacac4a acacac52 acacac5a acacac62 acacac6a acacac73 acacac7b acacac83 acacac8b acacac94 acacac9c acacaca4 acacacac acacacb4 acacacbd acacacc5 acacaccd acacacd5 acacacde acacace6 acacacee acacacf6 acacacff \n+a4a4a400 a4a4a408 a4a4a410 a4a4a418 a4a4a420 a4a4a429 a4a4a431 a4a4a439 a4a4a441 a4a4a44a a4a4a452 a4a4a45a a4a4a462 a4a4a46a a4a4a473 a4a4a47b a4a4a483 a4a4a48b a4a4a494 a4a4a49c a4a4a4a4 a4a4a4ac a4a4a4b4 a4a4a4bd a4a4a4c5 a4a4a4cd a4a4a4d5 a4a4a4de a4a4a4e6 a4a4a4ee a4a4a4f6 a4a4a4ff \n+9c9c9c00 9c9c9c08 9c9c9c10 9c9c9c18 9c9c9c20 9c9c9c29 9c9c9c31 9c9c9c39 9c9c9c41 9c9c9c4a 9c9c9c52 9c9c9c5a 9c9c9c62 9c9c9c6a 9c9c9c73 9c9c9c7b 9c9c9c83 9c9c9c8b 9c9c9c94 9c9c9c9c 9c9c9ca4 9c9c9cac 9c9c9cb4 9c9c9cbd 9c9c9cc5 9c9c9ccd 9c9c9cd5 9c9c9cde 9c9c9ce6 9c9c9cee 9c9c9cf6 9c9c9cff \n+94949400 94949408 94949410 94949418 94949420 94949429 94949431 94949439 94949441 9494944a 94949452 9494945a 94949462 9494946a 94949473 9494947b 94949483 9494948b 94949494 9494949c 949494a4 949494ac 949494b4 949494bd 949494c5 949494cd 949494d5 949494de 949494e6 949494ee 949494f6 949494ff \n+8b8b8b00 8b8b8b08 8b8b8b10 8b8b8b18 8b8b8b20 8b8b8b29 8b8b8b31 8b8b8b39 8b8b8b41 8b8b8b4a 8b8b8b52 8b8b8b5a 8b8b8b62 8b8b8b6a 8b8b8b73 8b8b8b7b 8b8b8b83 8b8b8b8b 8b8b8b94 8b8b8b9c 8b8b8ba4 8b8b8bac 8b8b8bb4 8b8b8bbd 8b8b8bc5 8b8b8bcd 8b8b8bd5 8b8b8bde 8b8b8be6 8b8b8bee 8b8b8bf6 8b8b8bff \n+83838300 83838308 83838310 83838318 83838320 83838329 83838331 83838339 83838341 8383834a 83838352 8383835a 83838362 8383836a 83838373 8383837b 83838383 8383838b 83838394 8383839c 838383a4 838383ac 838383b4 838383bd 838383c5 838383cd 838383d5 838383de 838383e6 838383ee 838383f6 838383ff \n+7b7b7b00 7b7b7b08 7b7b7b10 7b7b7b18 7b7b7b20 7b7b7b29 7b7b7b31 7b7b7b39 7b7b7b41 7b7b7b4a 7b7b7b52 7b7b7b5a 7b7b7b62 7b7b7b6a 7b7b7b73 7b7b7b7b 7b7b7b83 7b7b7b8b 7b7b7b94 7b7b7b9c 7b7b7ba4 7b7b7bac 7b7b7bb4 7b7b7bbd 7b7b7bc5 7b7b7bcd 7b7b7bd5 7b7b7bde 7b7b7be6 7b7b7bee 7b7b7bf6 7b7b7bff \n+73737300 73737308 73737310 73737318 73737320 73737329 73737331 73737339 73737341 7373734a 73737352 7373735a 73737362 7373736a 73737373 7373737b 73737383 7373738b 73737394 7373739c 737373a4 737373ac 737373b4 737373bd 737373c5 737373cd 737373d5 737373de 737373e6 737373ee 737373f6 737373ff \n+6a6a6a00 6a6a6a08 6a6a6a10 6a6a6a18 6a6a6a20 6a6a6a29 6a6a6a31 6a6a6a39 6a6a6a41 6a6a6a4a 6a6a6a52 6a6a6a5a 6a6a6a62 6a6a6a6a 6a6a6a73 6a6a6a7b 6a6a6a83 6a6a6a8b 6a6a6a94 6a6a6a9c 6a6a6aa4 6a6a6aac 6a6a6ab4 6a6a6abd 6a6a6ac5 6a6a6acd 6a6a6ad5 6a6a6ade 6a6a6ae6 6a6a6aee 6a6a6af6 6a6a6aff \n+62626200 62626208 62626210 62626218 62626220 62626229 62626231 62626239 62626241 6262624a 62626252 6262625a 62626262 6262626a 62626273 6262627b 62626283 6262628b 62626294 6262629c 626262a4 626262ac 626262b4 626262bd 626262c5 626262cd 626262d5 626262de 626262e6 626262ee 626262f6 626262ff \n+5a5a5a00 5a5a5a08 5a5a5a10 5a5a5a18 5a5a5a20 5a5a5a29 5a5a5a31 5a5a5a39 5a5a5a41 5a5a5a4a 5a5a5a52 5a5a5a5a 5a5a5a62 5a5a5a6a 5a5a5a73 5a5a5a7b 5a5a5a83 5a5a5a8b 5a5a5a94 5a5a5a9c 5a5a5aa4 5a5a5aac 5a5a5ab4 5a5a5abd 5a5a5ac5 5a5a5acd 5a5a5ad5 5a5a5ade 5a5a5ae6 5a5a5aee 5a5a5af6 5a5a5aff \n+52525200 52525208 52525210 52525218 52525220 52525229 52525231 52525239 52525241 5252524a 52525252 5252525a 52525262 5252526a 52525273 5252527b 52525283 5252528b 52525294 5252529c 525252a4 525252ac 525252b4 525252bd 525252c5 525252cd 525252d5 525252de 525252e6 525252ee 525252f6 525252ff \n+4a4a4a00 4a4a4a08 4a4a4a10 4a4a4a18 4a4a4a20 4a4a4a29 4a4a4a31 4a4a4a39 4a4a4a41 4a4a4a4a 4a4a4a52 4a4a4a5a 4a4a4a62 4a4a4a6a 4a4a4a73 4a4a4a7b 4a4a4a83 4a4a4a8b 4a4a4a94 4a4a4a9c 4a4a4aa4 4a4a4aac 4a4a4ab4 4a4a4abd 4a4a4ac5 4a4a4acd 4a4a4ad5 4a4a4ade 4a4a4ae6 4a4a4aee 4a4a4af6 4a4a4aff \n+41414100 41414108 41414110 41414118 41414120 41414129 41414131 41414139 41414141 4141414a 41414152 4141415a 41414162 4141416a 41414173 4141417b 41414183 4141418b 41414194 4141419c 414141a4 414141ac 414141b4 414141bd 414141c5 414141cd 414141d5 414141de 414141e6 414141ee 414141f6 414141ff \n+39393900 39393908 39393910 39393918 39393920 39393929 39393931 39393939 39393941 3939394a 39393952 3939395a 39393962 3939396a 39393973 3939397b 39393983 3939398b 39393994 3939399c 393939a4 393939ac 393939b4 393939bd 393939c5 393939cd 393939d5 393939de 393939e6 393939ee 393939f6 393939ff \n+31313100 31313108 31313110 31313118 31313120 31313129 31313131 31313139 31313141 3131314a 31313152 3131315a 31313162 3131316a 31313173 3131317b 31313183 3131318b 31313194 3131319c 313131a4 313131ac 313131b4 313131bd 313131c5 313131cd 313131d5 313131de 313131e6 313131ee 313131f6 313131ff \n+29292900 29292908 29292910 29292918 29292920 29292929 29292931 29292939 29292941 2929294a 29292952 2929295a 29292962 2929296a 29292973 2929297b 29292983 2929298b 29292994 2929299c 292929a4 292929ac 292929b4 292929bd 292929c5 292929cd 292929d5 292929de 292929e6 292929ee 292929f6 292929ff \n+20202000 20202008 20202010 20202018 20202020 20202029 20202031 20202039 20202041 2020204a 20202052 2020205a 20202062 2020206a 20202073 2020207b 20202083 2020208b 20202094 2020209c 202020a4 202020ac 202020b4 202020bd 202020c5 202020cd 202020d5 202020de 202020e6 202020ee 202020f6 202020ff \n+18181800 18181808 18181810 18181818 18181820 18181829 18181831 18181839 18181841 1818184a 18181852 1818185a 18181862 1818186a 18181873 1818187b 18181883 1818188b 18181894 1818189c 181818a4 181818ac 181818b4 181818bd 181818c5 181818cd 181818d5 181818de 181818e6 181818ee 181818f6 181818ff \n+10101000 10101008 10101010 10101018 10101020 10101029 10101031 10101039 10101041 1010104a 10101052 1010105a 10101062 1010106a 10101073 1010107b 10101083 1010108b 10101094 1010109c 101010a4 101010ac 101010b4 101010bd 101010c5 101010cd 101010d5 101010de 101010e6 101010ee 101010f6 101010ff \n+08080800 08080808 08080810 08080818 08080820 08080829 08080831 08080839 08080841 0808084a 08080852 0808085a 08080862 0808086a 08080873 0808087b 08080883 0808088b 08080894 0808089c 080808a4 080808ac 080808b4 080808bd 080808c5 080808cd 080808d5 080808de 080808e6 080808ee 080808f6 080808ff \n+00000000 00000008 00000010 00000018 00000020 00000029 00000031 00000039 00000041 0000004a 00000052 0000005a 00000062 0000006a 00000073 0000007b 00000083 0000008b 00000094 0000009c 000000a4 000000ac 000000b4 000000bd 000000c5 000000cd 000000d5 000000de 000000e6 000000ee 000000f6 000000ff \n }"}, {"sha": "9751b5c7663e499b8da59915ade97874fba41d60", "filename": "libgo/go/index/suffixarray/qsufsort.go", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fqsufsort.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -146,19 +146,25 @@ func (x *suffixSortable) Swap(i, j int)      { x.sa[i], x.sa[j] = x.sa[j], x.sa[\n \n \n func (x *suffixSortable) updateGroups(offset int) {\n-\tprev := len(x.sa) - 1\n-\tgroup := x.inv[x.sa[prev]+x.h]\n-\tfor i := prev; i >= 0; i-- {\n-\t\tif g := x.inv[x.sa[i]+x.h]; g < group {\n-\t\t\tif prev == i+1 { // previous group had size 1 and is thus sorted\n-\t\t\t\tx.sa[i+1] = -1\n-\t\t\t}\n+\tbounds := make([]int, 0, 4)\n+\tgroup := x.inv[x.sa[0]+x.h]\n+\tfor i := 1; i < len(x.sa); i++ {\n+\t\tif g := x.inv[x.sa[i]+x.h]; g > group {\n+\t\t\tbounds = append(bounds, i)\n \t\t\tgroup = g\n-\t\t\tprev = i\n \t\t}\n-\t\tx.inv[x.sa[i]] = prev + offset\n-\t\tif prev == 0 { // first group has size 1 and is thus sorted\n-\t\t\tx.sa[0] = -1\n+\t}\n+\tbounds = append(bounds, len(x.sa))\n+\n+\t// update the group numberings after all new groups are determined\n+\tprev := 0\n+\tfor _, b := range bounds {\n+\t\tfor i := prev; i < b; i++ {\n+\t\t\tx.inv[x.sa[i]] = offset + b - 1\n+\t\t}\n+\t\tif b-prev == 1 {\n+\t\t\tx.sa[prev] = -1\n \t\t}\n+\t\tprev = b\n \t}\n }"}, {"sha": "d8c6fc91b489ae67ca55f704cff918022265e1f3", "filename": "libgo/go/index/suffixarray/suffixarray.go", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -50,27 +50,33 @@ func (x *Index) at(i int) []byte {\n }\n \n \n-func (x *Index) search(s []byte) int {\n-\treturn sort.Search(len(x.sa), func(i int) bool { return bytes.Compare(x.at(i), s) >= 0 })\n+// lookupAll returns a slice into the matching region of the index.\n+// The runtime is O(log(N)*len(s)).\n+func (x *Index) lookupAll(s []byte) []int {\n+\t// find matching suffix index range [i:j]\n+\t// find the first index where s would be the prefix\n+\ti := sort.Search(len(x.sa), func(i int) bool { return bytes.Compare(x.at(i), s) >= 0 })\n+\t// starting at i, find the first index at which s is not a prefix\n+\tj := i + sort.Search(len(x.sa)-i, func(j int) bool { return !bytes.HasPrefix(x.at(j+i), s) })\n+\treturn x.sa[i:j]\n }\n \n \n // Lookup returns an unsorted list of at most n indices where the byte string s\n // occurs in the indexed data. If n < 0, all occurrences are returned.\n // The result is nil if s is empty, s is not found, or n == 0.\n-// Lookup time is O((log(N) + len(result))*len(s)) where N is the\n+// Lookup time is O(log(N)*len(s) + len(result)) where N is the\n // size of the indexed data.\n //\n func (x *Index) Lookup(s []byte, n int) (result []int) {\n \tif len(s) > 0 && n != 0 {\n-\t\t// find matching suffix index i\n-\t\ti := x.search(s)\n-\t\t// x.at(i-1) < s <= x.at(i)\n-\n-\t\t// collect the following suffixes with matching prefixes\n-\t\tfor (n < 0 || len(result) < n) && i < len(x.sa) && bytes.HasPrefix(x.at(i), s) {\n-\t\t\tresult = append(result, x.sa[i])\n-\t\t\ti++\n+\t\tmatches := x.lookupAll(s)\n+\t\tif len(matches) < n || n < 0 {\n+\t\t\tn = len(matches)\n+\t\t}\n+\t\tif n > 0 {\n+\t\t\tresult = make([]int, n)\n+\t\t\tcopy(result, matches)\n \t\t}\n \t}\n \treturn"}, {"sha": "e85267f17f53920e68debcd81a89325e3c46be7b", "filename": "libgo/go/index/suffixarray/suffixarray_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Findex%2Fsuffixarray%2Fsuffixarray_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -99,6 +99,12 @@ var testCases = []testCase{\n \t\t\t\"to (come|the)?\",\n \t\t},\n \t},\n+\n+\t{\n+\t\t\"godoc simulation\",\n+\t\t\"package main\\n\\nimport(\\n    \\\"rand\\\"\\n    \",\n+\t\t[]string{},\n+\t},\n }\n \n "}, {"sha": "3b8791897988399a7c9a7ec7db0373ef105a59a2", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -150,14 +150,23 @@ type WriterAt interface {\n \tWriteAt(p []byte, off int64) (n int, err os.Error)\n }\n \n-// ReadByter is the interface that wraps the ReadByte method.\n+// ByteReader is the interface that wraps the ReadByte method.\n //\n // ReadByte reads and returns the next byte from the input.\n // If no byte is available, err will be set.\n-type ReadByter interface {\n+type ByteReader interface {\n \tReadByte() (c byte, err os.Error)\n }\n \n+// RuneReader is the interface that wraps the ReadRune method.\n+//\n+// ReadRune reads a single UTF-8 encoded Unicode character\n+// and returns the rune and its size in bytes. If no character is\n+// available, err will be set.\n+type RuneReader interface {\n+\tReadRune() (rune int, size int, err os.Error)\n+}\n+\n // WriteString writes the contents of the string s to w, which accepts an array of bytes.\n func WriteString(w Writer, s string) (n int, err os.Error) {\n \treturn w.Write([]byte(s))"}, {"sha": "c7cc67b1b7462a25c642bfd6db242065ff60e73c", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -46,6 +46,7 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n \n \tnconflict := 0\n \tfor i := 0; i < 10000; i++ {\n+\t\t// TODO(rsc): use filepath.Join\n \t\tname := dir + \"/\" + prefix + nextSuffix()\n \t\tf, err = os.Open(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n \t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n@@ -58,3 +59,34 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n \t}\n \treturn\n }\n+\n+// TempDir creates a new temporary directory in the directory dir\n+// with a name beginning with prefix and returns the path of the\n+// new directory.  If dir is the empty string, TempDir uses the\n+// default directory for temporary files (see os.TempDir).\n+// Multiple programs calling TempDir simultaneously\n+// will not choose the same directory.  It is the caller's responsibility\n+// to remove the directory when no longer needed.\n+func TempDir(dir, prefix string) (name string, err os.Error) {\n+\tif dir == \"\" {\n+\t\tdir = os.TempDir()\n+\t}\n+\n+\tnconflict := 0\n+\tfor i := 0; i < 10000; i++ {\n+\t\t// TODO(rsc): use filepath.Join\n+\t\ttry := dir + \"/\" + prefix + nextSuffix()\n+\t\terr = os.Mkdir(try, 0700)\n+\t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n+\t\t\tif nconflict++; nconflict > 10 {\n+\t\t\t\trand = reseed()\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err == nil {\n+\t\t\tname = try\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn\n+}"}, {"sha": "6013ec1d4a42aa87ba5afe640a39550a917b992c", "filename": "libgo/go/io/ioutil/tempfile_test.go", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -23,11 +23,31 @@ func TestTempFile(t *testing.T) {\n \t\tt.Errorf(\"TempFile(dir, `ioutil_test`) = %v, %v\", f, err)\n \t}\n \tif f != nil {\n+\t\tf.Close()\n+\t\tos.Remove(f.Name())\n \t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(dir) + \"/ioutil_test[0-9]+$\")\n \t\tif !re.MatchString(f.Name()) {\n \t\t\tt.Errorf(\"TempFile(`\"+dir+\"`, `ioutil_test`) created bad name %s\", f.Name())\n \t\t}\n-\t\tos.Remove(f.Name())\n \t}\n-\tf.Close()\n+}\n+\n+func TestTempDir(t *testing.T) {\n+\tname, err := TempDir(\"/_not_exists_\", \"foo\")\n+\tif name != \"\" || err == nil {\n+\t\tt.Errorf(\"TempDir(`/_not_exists_`, `foo`) = %v, %v\", name, err)\n+\t}\n+\n+\tdir := os.TempDir()\n+\tname, err = TempDir(dir, \"ioutil_test\")\n+\tif name == \"\" || err != nil {\n+\t\tt.Errorf(\"TempDir(dir, `ioutil_test`) = %v, %v\", name, err)\n+\t}\n+\tif name != \"\" {\n+\t\tos.Remove(name)\n+\t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(dir) + \"/ioutil_test[0-9]+$\")\n+\t\tif !re.MatchString(name) {\n+\t\t\tt.Errorf(\"TempDir(`\"+dir+\"`, `ioutil_test`) created bad name %s\", name)\n+\t\t}\n+\t}\n }"}, {"sha": "501230c0c05669371fdc1a35b73b191dd588514d", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -9,6 +9,7 @@ package json\n \n import (\n \t\"container/vector\"\n+\t\"encoding/base64\"\n \t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n@@ -466,13 +467,15 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t} else {\n \t\t\tvar f reflect.StructField\n \t\t\tvar ok bool\n-\t\t\t// First try for field with that tag.\n \t\t\tst := sv.Type().(*reflect.StructType)\n-\t\t\tfor i := 0; i < sv.NumField(); i++ {\n-\t\t\t\tf = st.Field(i)\n-\t\t\t\tif f.Tag == key {\n-\t\t\t\t\tok = true\n-\t\t\t\t\tbreak\n+\t\t\t// First try for field with that tag.\n+\t\t\tif isValidTag(key) {\n+\t\t\t\tfor i := 0; i < sv.NumField(); i++ {\n+\t\t\t\t\tf = st.Field(i)\n+\t\t\t\t\tif f.Tag == key {\n+\t\t\t\t\t\tok = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif !ok {\n@@ -568,17 +571,29 @@ func (d *decodeState) literal(v reflect.Value) {\n \t\t}\n \n \tcase '\"': // string\n-\t\ts, ok := unquote(item)\n+\t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n \t\t\td.error(errPhase)\n \t\t}\n \t\tswitch v := v.(type) {\n \t\tdefault:\n \t\t\td.saveError(&UnmarshalTypeError{\"string\", v.Type()})\n+\t\tcase *reflect.SliceValue:\n+\t\t\tif v.Type() != byteSliceType {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"string\", v.Type()})\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tb := make([]byte, base64.StdEncoding.DecodedLen(len(s)))\n+\t\t\tn, err := base64.StdEncoding.Decode(b, s)\n+\t\t\tif err != nil {\n+\t\t\t\td.saveError(err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tv.Set(reflect.NewValue(b[0:n]).(*reflect.SliceValue))\n \t\tcase *reflect.StringValue:\n-\t\t\tv.Set(s)\n+\t\t\tv.Set(string(s))\n \t\tcase *reflect.InterfaceValue:\n-\t\t\tv.Set(reflect.NewValue(s))\n+\t\t\tv.Set(reflect.NewValue(string(s)))\n \t\t}\n \n \tdefault: // number\n@@ -772,12 +787,43 @@ func getu4(s []byte) int {\n // unquote converts a quoted JSON string literal s into an actual string t.\n // The rules are different than for Go, so cannot use strconv.Unquote.\n func unquote(s []byte) (t string, ok bool) {\n+\ts, ok = unquoteBytes(s)\n+\tt = string(s)\n+\treturn\n+}\n+\n+func unquoteBytes(s []byte) (t []byte, ok bool) {\n \tif len(s) < 2 || s[0] != '\"' || s[len(s)-1] != '\"' {\n \t\treturn\n \t}\n+\ts = s[1 : len(s)-1]\n+\n+\t// Check for unusual characters. If there are none,\n+\t// then no unquoting is needed, so return a slice of the\n+\t// original bytes.\n+\tr := 0\n+\tfor r < len(s) {\n+\t\tc := s[r]\n+\t\tif c == '\\\\' || c == '\"' || c < ' ' {\n+\t\t\tbreak\n+\t\t}\n+\t\tif c < utf8.RuneSelf {\n+\t\t\tr++\n+\t\t\tcontinue\n+\t\t}\n+\t\trune, size := utf8.DecodeRune(s[r:])\n+\t\tif rune == utf8.RuneError && size == 1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tr += size\n+\t}\n+\tif r == len(s) {\n+\t\treturn s, true\n+\t}\n+\n \tb := make([]byte, len(s)+2*utf8.UTFMax)\n-\tw := 0\n-\tfor r := 1; r < len(s)-1; {\n+\tw := copy(b, s[0:r])\n+\tfor r < len(s) {\n \t\t// Out of room?  Can only happen if s is full of\n \t\t// malformed UTF-8 and we're replacing each\n \t\t// byte with RuneError.\n@@ -789,7 +835,7 @@ func unquote(s []byte) (t string, ok bool) {\n \t\tswitch c := s[r]; {\n \t\tcase c == '\\\\':\n \t\t\tr++\n-\t\t\tif r >= len(s)-1 {\n+\t\t\tif r >= len(s) {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tswitch s[r] {\n@@ -857,5 +903,5 @@ func unquote(s []byte) (t string, ok bool) {\n \t\t\tw += utf8.EncodeRune(b[w:], rune)\n \t\t}\n \t}\n-\treturn string(b[0:w]), true\n+\treturn b[0:w], true\n }"}, {"sha": "ad6026363b5158f772946f9c98143cbe131447b3", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -40,6 +40,11 @@ var (\n \tumtrue   = unmarshaler{true}\n )\n \n+type badTag struct {\n+\tX string\n+\tY string \"y\"\n+\tZ string \"@#*%(#@\"\n+}\n \n type unmarshalTest struct {\n \tin  string\n@@ -62,6 +67,9 @@ var unmarshalTests = []unmarshalTest{\n \t{`{\"X\": [1,2,3], \"Y\": 4}`, new(T), T{Y: 4}, &UnmarshalTypeError{\"array\", reflect.Typeof(\"\")}},\n \t{`{\"x\": 1}`, new(tx), tx{}, &UnmarshalFieldError{\"x\", txType, txType.Field(0)}},\n \n+\t// skip invalid tags\n+\t{`{\"X\":\"a\", \"y\":\"b\", \"Z\":\"c\"}`, new(badTag), badTag{\"a\", \"b\", \"c\"}, nil},\n+\n \t// syntax errors\n \t{`{\"X\": \"foo\", \"Y\"}`, nil, nil, SyntaxError(\"invalid character '}' after object key\")},\n \n@@ -164,6 +172,25 @@ func TestUnmarshalMarshal(t *testing.T) {\n \t}\n }\n \n+func TestLargeByteSlice(t *testing.T) {\n+\ts0 := make([]byte, 2000)\n+\tfor i := range s0 {\n+\t\ts0[i] = byte(i)\n+\t}\n+\tb, err := Marshal(s0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\tvar s1 []byte\n+\tif err := Unmarshal(b, &s1); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %v\", err)\n+\t}\n+\tif bytes.Compare(s0, s1) != 0 {\n+\t\tt.Errorf(\"Marshal large byte slice\")\n+\t\tdiff(t, s0, s1)\n+\t}\n+}\n+\n type Xint struct {\n \tX int\n }\n@@ -412,11 +439,7 @@ var allValueIndent = `{\n \t\t\"str25\",\n \t\t\"str26\"\n \t],\n-\t\"ByteSlice\": [\n-\t\t27,\n-\t\t28,\n-\t\t29\n-\t],\n+\t\"ByteSlice\": \"Gxwd\",\n \t\"Small\": {\n \t\t\"Tag\": \"tag30\"\n \t},\n@@ -502,7 +525,7 @@ var pallValueIndent = `{\n \t\"EmptySlice\": [],\n \t\"NilSlice\": [],\n \t\"StringSlice\": [],\n-\t\"ByteSlice\": [],\n+\t\"ByteSlice\": \"\",\n \t\"Small\": {\n \t\t\"Tag\": \"\"\n \t},"}, {"sha": "26ce47039f6e742933aab8b42849e1adcc476ca9", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -7,12 +7,14 @@\n package json\n \n import (\n-\t\"os\"\n \t\"bytes\"\n+\t\"encoding/base64\"\n+\t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"sort\"\n \t\"strconv\"\n+\t\"unicode\"\n \t\"utf8\"\n )\n \n@@ -31,13 +33,14 @@ import (\n // String values encode as JSON strings, with each invalid UTF-8 sequence\n // replaced by the encoding of the Unicode replacement character U+FFFD.\n //\n-// Array and slice values encode as JSON arrays.\n+// Array and slice values encode as JSON arrays, except that\n+// []byte encodes as a base64-encoded string.\n //\n // Struct values encode as JSON objects.  Each struct field becomes\n // a member of the object.  By default the object's key name is the\n-// struct field name converted to lower case.  If the struct field\n-// has a tag, that tag will be used as the name instead.\n-// Only exported fields will be encoded.\n+// struct field name.  If the struct field has a non-empty tag consisting\n+// of only Unicode letters, digits, and underscores, that tag will be used\n+// as the name instead.  Only exported fields will be encoded.\n //\n // Map values encode as JSON objects.\n // The map's key type must be string; the object keys are used directly\n@@ -177,6 +180,8 @@ func (e *encodeState) error(err os.Error) {\n \tpanic(err)\n }\n \n+var byteSliceType = reflect.Typeof([]byte(nil))\n+\n func (e *encodeState) reflectValue(v reflect.Value) {\n \tif v == nil {\n \t\te.WriteString(\"null\")\n@@ -231,7 +236,7 @@ func (e *encodeState) reflectValue(v reflect.Value) {\n \t\t\t} else {\n \t\t\t\te.WriteByte(',')\n \t\t\t}\n-\t\t\tif f.Tag != \"\" {\n+\t\t\tif isValidTag(f.Tag) {\n \t\t\t\te.string(f.Tag)\n \t\t\t} else {\n \t\t\t\te.string(f.Name)\n@@ -263,6 +268,24 @@ func (e *encodeState) reflectValue(v reflect.Value) {\n \t\te.WriteByte('}')\n \n \tcase reflect.ArrayOrSliceValue:\n+\t\tif v.Type() == byteSliceType {\n+\t\t\te.WriteByte('\"')\n+\t\t\ts := v.Interface().([]byte)\n+\t\t\tif len(s) < 1024 {\n+\t\t\t\t// for small buffers, using Encode directly is much faster.\n+\t\t\t\tdst := make([]byte, base64.StdEncoding.EncodedLen(len(s)))\n+\t\t\t\tbase64.StdEncoding.Encode(dst, s)\n+\t\t\t\te.Write(dst)\n+\t\t\t} else {\n+\t\t\t\t// for large buffers, avoid unnecessary extra temporary\n+\t\t\t\t// buffer space.\n+\t\t\t\tenc := base64.NewEncoder(base64.StdEncoding, e)\n+\t\t\t\tenc.Write(s)\n+\t\t\t\tenc.Close()\n+\t\t\t}\n+\t\t\te.WriteByte('\"')\n+\t\t\tbreak\n+\t\t}\n \t\te.WriteByte('[')\n \t\tn := v.Len()\n \t\tfor i := 0; i < n; i++ {\n@@ -286,6 +309,18 @@ func (e *encodeState) reflectValue(v reflect.Value) {\n \treturn\n }\n \n+func isValidTag(s string) bool {\n+\tif s == \"\" {\n+\t\treturn false\n+\t}\n+\tfor _, c := range s {\n+\t\tif c != '_' && !unicode.IsLetter(c) && !unicode.IsDigit(c) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // stringValues is a slice of reflect.Value holding *reflect.StringValue.\n // It implements the methods to sort by string.\n type stringValues []reflect.Value"}, {"sha": "e98ddef5cc15a4fe9dd2e7b3cb616b4b8d14c8c5", "filename": "libgo/go/json/scanner.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -416,7 +416,7 @@ func state0(s *scanner, c int) int {\n \t\ts.step = stateDot\n \t\treturn scanContinue\n \t}\n-\tif c == 'e' {\n+\tif c == 'e' || c == 'E' {\n \t\ts.step = stateE\n \t\treturn scanContinue\n \t}\n@@ -440,7 +440,7 @@ func stateDot0(s *scanner, c int) int {\n \t\ts.step = stateDot0\n \t\treturn scanContinue\n \t}\n-\tif c == 'e' {\n+\tif c == 'e' || c == 'E' {\n \t\ts.step = stateE\n \t\treturn scanContinue\n \t}"}, {"sha": "658e3bd94b1b3b8835e860f37bfdf2a305d9063c", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -4,11 +4,11 @@\n \n // Simple logging package. It defines a type, Logger, with methods\n // for formatting output. It also has a predefined 'standard' Logger\n-// accessible through helper functions Print[f|ln], Exit[f|ln], and\n+// accessible through helper functions Print[f|ln], Fatal[f|ln], and\n // Panic[f|ln], which are easier to use than creating a Logger manually.\n // That logger writes to standard error and prints the date and time\n // of each logged message.\n-// The Exit functions call os.Exit(1) after writing the log message.\n+// The Fatal functions call os.Exit(1) after writing the log message.\n // The Panic functions call panic after writing the log message.\n package log\n \n@@ -164,20 +164,20 @@ func (l *Logger) Print(v ...interface{}) { l.Output(2, fmt.Sprint(v...)) }\n // Arguments are handled in the manner of fmt.Println.\n func (l *Logger) Println(v ...interface{}) { l.Output(2, fmt.Sprintln(v...)) }\n \n-// Exit is equivalent to l.Print() followed by a call to os.Exit(1).\n-func (l *Logger) Exit(v ...interface{}) {\n+// Fatal is equivalent to l.Print() followed by a call to os.Exit(1).\n+func (l *Logger) Fatal(v ...interface{}) {\n \tl.Output(2, fmt.Sprint(v...))\n \tos.Exit(1)\n }\n \n-// Exitf is equivalent to l.Printf() followed by a call to os.Exit(1).\n-func (l *Logger) Exitf(format string, v ...interface{}) {\n+// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).\n+func (l *Logger) Fatalf(format string, v ...interface{}) {\n \tl.Output(2, fmt.Sprintf(format, v...))\n \tos.Exit(1)\n }\n \n-// Exitln is equivalent to l.Println() followed by a call to os.Exit(1).\n-func (l *Logger) Exitln(v ...interface{}) {\n+// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).\n+func (l *Logger) Fatalln(v ...interface{}) {\n \tl.Output(2, fmt.Sprintln(v...))\n \tos.Exit(1)\n }\n@@ -238,20 +238,20 @@ func Println(v ...interface{}) {\n \tstd.Output(2, fmt.Sprintln(v...))\n }\n \n-// Exit is equivalent to Print() followed by a call to os.Exit(1).\n-func Exit(v ...interface{}) {\n+// Fatal is equivalent to Print() followed by a call to os.Exit(1).\n+func Fatal(v ...interface{}) {\n \tstd.Output(2, fmt.Sprint(v...))\n \tos.Exit(1)\n }\n \n-// Exitf is equivalent to Printf() followed by a call to os.Exit(1).\n-func Exitf(format string, v ...interface{}) {\n+// Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n+func Fatalf(format string, v ...interface{}) {\n \tstd.Output(2, fmt.Sprintf(format, v...))\n \tos.Exit(1)\n }\n \n-// Exitln is equivalent to Println() followed by a call to os.Exit(1).\n-func Exitln(v ...interface{}) {\n+// Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n+func Fatalln(v ...interface{}) {\n \tstd.Output(2, fmt.Sprintln(v...))\n \tos.Exit(1)\n }"}, {"sha": "1cf8e79159e2243b62445c830cf8051641f70fd6", "filename": "libgo/go/net/dial.go", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fdial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fdial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -24,7 +24,7 @@ import \"os\"\n //\tDial(\"tcp\", \"127.0.0.1:123\", \"127.0.0.1:88\")\n //\n func Dial(net, laddr, raddr string) (c Conn, err os.Error) {\n-\tswitch prefixBefore(net, ':') {\n+\tswitch net {\n \tcase \"tcp\", \"tcp4\", \"tcp6\":\n \t\tvar la, ra *TCPAddr\n \t\tif laddr != \"\" {\n@@ -137,7 +137,7 @@ func Listen(net, laddr string) (l Listener, err os.Error) {\n // The network string net must be a packet-oriented network:\n // \"udp\", \"udp4\", \"udp6\", or \"unixgram\".\n func ListenPacket(net, laddr string) (c PacketConn, err os.Error) {\n-\tswitch prefixBefore(net, ':') {\n+\tswitch net {\n \tcase \"udp\", \"udp4\", \"udp6\":\n \t\tvar la *UDPAddr\n \t\tif laddr != \"\" {\n@@ -162,18 +162,24 @@ func ListenPacket(net, laddr string) (c PacketConn, err os.Error) {\n \t\t\treturn nil, err\n \t\t}\n \t\treturn c, nil\n-\tcase \"ip\", \"ip4\", \"ip6\":\n-\t\tvar la *IPAddr\n-\t\tif laddr != \"\" {\n-\t\t\tif la, err = ResolveIPAddr(laddr); err != nil {\n+\t}\n+\n+\tif i := last(net, ':'); i > 0 {\n+\t\tswitch net[0:i] {\n+\t\tcase \"ip\", \"ip4\", \"ip6\":\n+\t\t\tvar la *IPAddr\n+\t\t\tif laddr != \"\" {\n+\t\t\t\tif la, err = ResolveIPAddr(laddr); err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tc, err := ListenIP(net, la)\n+\t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n+\t\t\treturn c, nil\n \t\t}\n-\t\tc, err := ListenIP(net, la)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn c, nil\n \t}\n+\n \treturn nil, UnknownNetworkError(net)\n }"}, {"sha": "3252dd454068e9c3e9e45e5e18d26d6faad12935", "filename": "libgo/go/net/dnsclient.go", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fdnsclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fdnsclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -98,18 +98,18 @@ func exchange(cfg *dnsConfig, c Conn, name string, qtype uint16) (*dnsMsg, os.Er\n \n // Find answer for name in dns message.\n // On return, if err == nil, addrs != nil.\n-func answer(name, server string, dns *dnsMsg, qtype uint16) (addrs []dnsRR, err os.Error) {\n+func answer(name, server string, dns *dnsMsg, qtype uint16) (cname string, addrs []dnsRR, err os.Error) {\n \taddrs = make([]dnsRR, 0, len(dns.answer))\n \n \tif dns.rcode == dnsRcodeNameError && dns.recursion_available {\n-\t\treturn nil, &DNSError{Error: noSuchHost, Name: name}\n+\t\treturn \"\", nil, &DNSError{Error: noSuchHost, Name: name}\n \t}\n \tif dns.rcode != dnsRcodeSuccess {\n \t\t// None of the error codes make sense\n \t\t// for the query we sent.  If we didn't get\n \t\t// a name error and we didn't get success,\n \t\t// the server is behaving incorrectly.\n-\t\treturn nil, &DNSError{Error: \"server misbehaving\", Name: name, Server: server}\n+\t\treturn \"\", nil, &DNSError{Error: \"server misbehaving\", Name: name, Server: server}\n \t}\n \n \t// Look for the name.\n@@ -137,19 +137,19 @@ Cname:\n \t\t\t}\n \t\t}\n \t\tif len(addrs) == 0 {\n-\t\t\treturn nil, &DNSError{Error: noSuchHost, Name: name, Server: server}\n+\t\t\treturn \"\", nil, &DNSError{Error: noSuchHost, Name: name, Server: server}\n \t\t}\n-\t\treturn addrs, nil\n+\t\treturn name, addrs, nil\n \t}\n \n-\treturn nil, &DNSError{Error: \"too many redirects\", Name: name, Server: server}\n+\treturn \"\", nil, &DNSError{Error: \"too many redirects\", Name: name, Server: server}\n }\n \n // Do a lookup for a single name, which must be rooted\n // (otherwise answer will not find the answers).\n-func tryOneName(cfg *dnsConfig, name string, qtype uint16) (addrs []dnsRR, err os.Error) {\n+func tryOneName(cfg *dnsConfig, name string, qtype uint16) (cname string, addrs []dnsRR, err os.Error) {\n \tif len(cfg.servers) == 0 {\n-\t\treturn nil, &DNSError{Error: \"no DNS servers\", Name: name}\n+\t\treturn \"\", nil, &DNSError{Error: \"no DNS servers\", Name: name}\n \t}\n \tfor i := 0; i < len(cfg.servers); i++ {\n \t\t// Calling Dial here is scary -- we have to be sure\n@@ -170,7 +170,7 @@ func tryOneName(cfg *dnsConfig, name string, qtype uint16) (addrs []dnsRR, err o\n \t\t\terr = merr\n \t\t\tcontinue\n \t\t}\n-\t\taddrs, err = answer(name, server, msg, qtype)\n+\t\tcname, addrs, err = answer(name, server, msg, qtype)\n \t\tif err == nil || err.(*DNSError).Error == noSuchHost {\n \t\t\tbreak\n \t\t}\n@@ -261,9 +261,8 @@ func lookup(name string, qtype uint16) (cname string, addrs []dnsRR, err os.Erro\n \t\t\trname += \".\"\n \t\t}\n \t\t// Can try as ordinary name.\n-\t\taddrs, err = tryOneName(cfg, rname, qtype)\n+\t\tcname, addrs, err = tryOneName(cfg, rname, qtype)\n \t\tif err == nil {\n-\t\t\tcname = rname\n \t\t\treturn\n \t\t}\n \t}\n@@ -277,9 +276,8 @@ func lookup(name string, qtype uint16) (cname string, addrs []dnsRR, err os.Erro\n \t\tif rname[len(rname)-1] != '.' {\n \t\t\trname += \".\"\n \t\t}\n-\t\taddrs, err = tryOneName(cfg, rname, qtype)\n+\t\tcname, addrs, err = tryOneName(cfg, rname, qtype)\n \t\tif err == nil {\n-\t\t\tcname = rname\n \t\t\treturn\n \t\t}\n \t}\n@@ -289,9 +287,8 @@ func lookup(name string, qtype uint16) (cname string, addrs []dnsRR, err os.Erro\n \tif !rooted {\n \t\trname += \".\"\n \t}\n-\taddrs, err = tryOneName(cfg, rname, qtype)\n+\tcname, addrs, err = tryOneName(cfg, rname, qtype)\n \tif err == nil {\n-\t\tcname = rname\n \t\treturn\n \t}\n \treturn"}, {"sha": "d48aefe2cdd8031e459efb236ad4816037e39a6b", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6", "patch": "@@ -220,11 +220,16 @@ func (s *pollServer) Run() {\n \t\t\t\tnn, _ = s.pr.Read(scratch[0:])\n \t\t\t}\n \t\t\t// Read from channels\n-\t\t\tfor fd, ok := <-s.cr; ok; fd, ok = <-s.cr {\n-\t\t\t\ts.AddFD(fd, 'r')\n-\t\t\t}\n-\t\t\tfor fd, ok := <-s.cw; ok; fd, ok = <-s.cw {\n-\t\t\t\ts.AddFD(fd, 'w')\n+\t\tUpdate:\n+\t\t\tfor {\n+\t\t\t\tselect {\n+\t\t\t\tcase fd := <-s.cr:\n+\t\t\t\t\ts.AddFD(fd, 'r')\n+\t\t\t\tcase fd := <-s.cw:\n+\t\t\t\t\ts.AddFD(fd, 'w')\n+\t\t\t\tdefault:\n+\t\t\t\t\tbreak Update\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tnetfd := s.LookupFD(fd, mode)"}, {"sha": "63a8fbc44898a202ee57613f8d64443d3074b21b", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "81a918ce5cb710909e10aa5623e59430258e3302", "filename": "libgo/go/net/iprawsock.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fiprawsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fiprawsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ae4204b48aa48b1bf092cb81621afff554e476d5", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "32fdec85bdeb07d9848befe282f60ddf9f282694", "filename": "libgo/go/net/multicast_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "04a898a9aac04824421672eea0e76ef1054190f5", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "2bc0db4655a2fe3f4cd0d44264bd4e7c173858cf", "filename": "libgo/go/net/parse.go", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "3dda500e585608d7765f7efc76b79ee02f5883d1", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "288deb2ceb49c13dcb0a0354a120dc08d9307344", "filename": "libgo/go/net/textproto/header.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Fheader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Fheader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Fheader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ac1278689a4902c5695567d805698cd2290e8c30", "filename": "libgo/go/net/textproto/reader.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "0658e58b82dedc373b5e8ce175baf4049595ce40", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "f9274493e602a39173cf40b0c4240342887ba632", "filename": "libgo/go/net/udpsock.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fudpsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnet%2Fudpsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "dd06050ee50f0f49eed56ade78e4f8f0d126358c", "filename": "libgo/go/netchan/common.go", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fcommon.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "55eba0e2e0f61fb5cf5f7780a3000cbc74c1a6da", "filename": "libgo/go/netchan/export.go", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fexport.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "30edcd8123bd1b2f159255aad5963fb6a11b9c63", "filename": "libgo/go/netchan/import.go", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fimport.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "1c84a9d14dee485b3b2804ecf8b1d4d0ee9758e2", "filename": "libgo/go/netchan/netchan_test.go", "status": "modified", "additions": 30, "deletions": 120, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "a45d79be32a56b54faa3eaec2d13dab203ed6a70", "filename": "libgo/go/os/env_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_windows.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "635a3fe50aa350213d1a37bd274a3f230fe7f935", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "dbdfacc5857744f5426ac550e63ece539e70efdf", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "8990d6a97ece5c8f7e8b1a5765a0fdb0f45b3266", "filename": "libgo/go/os/exec_unix.go", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ae8ffeab2e9bd173ed98ecb73ad6276724ae3c78", "filename": "libgo/go/os/exec_windows.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "96c229e7b744a1cfcc5e13d928e026775c771e93", "filename": "libgo/go/os/inotify/inotify_linux.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "be5f4824e4fcdc8d58d9791074d881e9daffe050", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ab0b48ad6ad94a3cf470104c84340cf5119e9a6b", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "42afadd85c08cbcdb04229ece2e8df5362307b8e", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "c9beec5066659682be423f00ca7e31c8bb7b15c9", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "fb798802815f0759a9434bfbcfd6b4ffb3b1d8c4", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 104, "deletions": 6, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "e7b68b3e720b2479117064736f05d04c0a7f6ca8", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 115, "deletions": 43, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "c7ee4c879707f06a8bdd6a7d43769e6ed5460b6b", "filename": "libgo/go/regexp/all_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fall_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "83b249e3cef686d7666098e5501c4958f6571d01", "filename": "libgo/go/regexp/find_test.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Ffind_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Ffind_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Ffind_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "e3221ac9d68e70948641beee70fd8eccfaf34f5e", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 223, "deletions": 73, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "6de6d1325b6388891f65be0b7af24f4c78f5e967", "filename": "libgo/go/rpc/client.go", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fclient.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "32dc8a18ba212daac06758a63452250acf9e1947", "filename": "libgo/go/rpc/debug.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fdebug.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "5b806bd6e250ab6be94511af1ef4c4a2ad27f556", "filename": "libgo/go/rpc/jsonrpc/client.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fclient.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "9c6b8b40d68daa1e4b1d0cf5859320e4c54b652e", "filename": "libgo/go/rpc/jsonrpc/server.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fserver.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "9dcda41480785faec736fdf071bdde64847e4530", "filename": "libgo/go/rpc/server.go", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "05aaebceb487bf132a17deeb56efe01afe8f572b", "filename": "libgo/go/rpc/server_test.go", "status": "modified", "additions": 43, "deletions": 74, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "5cfea6e15a8979836da4fa3b92d1c5b34507e5f6", "filename": "libgo/go/runtime/chan_defs.go", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fchan_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fchan_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "74010b394b069a2b64196d07192de5947052782e", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "c6e664abbbb90354efe0d8b8a842edfe2b67fdb0", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "57780df879ba7b7059a4e0c60729f25a1d409384", "filename": "libgo/go/runtime/hashmap_defs.go", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fhashmap_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fhashmap_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "69d52ef9a6b887421f528bc4ab1d0d14f59fd26f", "filename": "libgo/go/runtime/iface_defs.go", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fiface_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fiface_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "11d6627e11032fcb8b8070716bbc65b23db756dd", "filename": "libgo/go/runtime/malloc_defs.go", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmalloc_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmalloc_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "755725b460619a98c7426e654920458946660650", "filename": "libgo/go/runtime/mheapmap32_defs.go", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmheapmap32_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmheapmap32_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheapmap32_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "d7ba2b420014ec9f9b5dcde3b3e7f1ae8d2f37c2", "filename": "libgo/go/runtime/mheapmap64_defs.go", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmheapmap64_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fmheapmap64_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheapmap64_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "9bee5112819dff25ded674bbe3023ec77973f6a6", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "deea320b5afb237e98a0690eac2722741b00bbb4", "filename": "libgo/go/runtime/runtime_defs.go", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fruntime_defs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fruntime%2Fruntime_defs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime_defs.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "f5f3ef1baadc8a60ce9a0c0e9866b711c65acd65", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "2396cdd9a190591a6ccf19512d2e98108a0a9e47", "filename": "libgo/go/scanner/scanner.go", "status": "modified", "additions": 84, "deletions": 33, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "002252de8a8d1255191b502b76aafdfd074d2d5d", "filename": "libgo/go/scanner/scanner_test.go", "status": "modified", "additions": 89, "deletions": 25, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "6d8396ee73baa6e088f9491d82dbbcc41b23e2e1", "filename": "libgo/go/strconv/atof_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "b6049c545899330847d96c02f15be8b456cb3124", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "6d361a138efe81638a69c247ed51a1afad219899", "filename": "libgo/go/strconv/ftoa_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "e2d9b242fbdd39c6263a182a47fac52ea5762bbb", "filename": "libgo/go/sync/atomic/atomic.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "7b204b1d9f0e552216ff6ac2279ac0faa4ec64c0", "filename": "libgo/go/sync/atomic/atomic_test.go", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "1335def59f6239edc1f7eecb4a3226dbb3bae776", "filename": "libgo/go/sync/atomic/doc.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fdoc.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ea48f2e7a98b37f92a7efcb95e4627d4452e8e45", "filename": "libgo/go/sync/cond.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fcond.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fcond.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fcond.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "846f98bf39de292352e9151a2c57f3f178dd705f", "filename": "libgo/go/sync/cond_test.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fcond_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fcond_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fcond_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "da565d38defe7df07592e2d3031b2be178406605", "filename": "libgo/go/sync/mutex.go", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "f5c20ca49b40fc367de65b6b612b4d526949b06e", "filename": "libgo/go/sync/mutex_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "b6f5f5a87264346c264025e1e0496716ac73f8a2", "filename": "libgo/go/sync/once.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fonce.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fonce.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fonce.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "9248b4b03700207758f0214c450e658164353a40", "filename": "libgo/go/sync/rwmutex.go", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Frwmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Frwmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "405079270dcc7254c657ac5c241b516d0a1c4962", "filename": "libgo/go/sync/rwmutex_test.go", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Frwmutex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Frwmutex_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "68e1d509f4811c8161901396fd880f2d098289e7", "filename": "libgo/go/sync/waitgroup.go", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "fe35732e7a613d1e7b85af4c942f6766ed9dd681", "filename": "libgo/go/sync/waitgroup_test.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "8b2ef76e6baa339405e860b04ca68ed418f81e67", "filename": "libgo/go/sync/xadd_test.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fsync%2Fxadd_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fgo%2Fsync%2Fxadd_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fxadd_test.go?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "2958bcb1f8e5dd3660c0a26d53464746ad97f317", "filename": "libgo/go/syslog/syslog_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsyslog%2Fsyslog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fsyslog%2Fsyslog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyslog%2Fsyslog_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "c3cb8901a09f473290ee60d3fec1e6ef60d7a50b", "filename": "libgo/go/template/template.go", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Ftemplate.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "d21a5397a15a1070e62d9b08643e6166e6f6d448", "filename": "libgo/go/template/template_test.go", "status": "modified", "additions": 164, "deletions": 61, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftemplate%2Ftemplate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftemplate%2Ftemplate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Ftemplate_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "cf73e2b48f8ece11cb114807436869f6a8c1070e", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "324b5a70e1fa3c64899c69c91f462c9de1139a93", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "833552d68412ca22fe0495a66223cd02f9c3d776", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 123, "deletions": 71, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "8bf599c3e1a96d3dc5a893331692b10efa0a43a7", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "6c21bf19b92c9a091bf07a9b99bc53ec801ab0a6", "filename": "libgo/go/time/tick.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Ftick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Ftick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "4dcb63956b2ce1c8bcd4563ce86316d30ffdc108", "filename": "libgo/go/time/tick_test.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Ftick_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Ftime%2Ftick_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "432ffb67130446a35ca68b25623ff533161a41b0", "filename": "libgo/go/unicode/letter_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Fletter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Fletter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fletter_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "ff452b75cedc6d27900bd2b5fb2440dbfc939b10", "filename": "libgo/go/unicode/script_test.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fscript_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "89fd99411bcaed15549c3bff4793ed288f275efb", "filename": "libgo/go/unicode/tables.go", "status": "modified", "additions": 298, "deletions": 181, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Funicode%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Ftables.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "d8a7aa0a266c916c610be46385390ec0222edf1a", "filename": "libgo/go/websocket/client.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fclient.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "25f057ba5b0b4d7763aad84b97b9be9dc1262469", "filename": "libgo/go/websocket/server.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fserver.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "204a9de1e12957125464a6500677444bd438cc75", "filename": "libgo/go/websocket/websocket_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "a6b9a8ed18b936d98185b002eb037b7a050847ae", "filename": "libgo/go/xml/read_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fread_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "691c13a1188a4f8c11f620bf46f9a512e265037d", "filename": "libgo/go/xml/xml.go", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fxml.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "887bc3d140fec48ff96fc109119e90ee3e0c653b", "filename": "libgo/go/xml/xml_test.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fgo%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fxml_test.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "033c3ecbe3bf6a53728634e9aa9a5ca33679a30e", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "1b9ac2d79649a80a28f1648e816e4dc99cd1dfaa", "filename": "libgo/runtime/go-byte-array-to-string.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-byte-array-to-string.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "c16589f01a2760f52f650a420a318de7ba3c67b7", "filename": "libgo/runtime/go-int-array-to-string.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-int-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-int-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-int-array-to-string.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "af58015ed8fa8b870abe34035f1fc0bb9c314f67", "filename": "libgo/runtime/go-int-to-string.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-int-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-int-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-int-to-string.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "8f25c5730ef0f2c7f76e4cfd02c12e725da9105b", "filename": "libgo/runtime/go-new.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-new.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-new.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "b684779cda81345a909976c86f1a64550a1200e0", "filename": "libgo/runtime/go-panic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "10c565e39a50e5d68f7571703300621bb0b76089", "filename": "libgo/runtime/go-string-to-byte-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-string-to-byte-array.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "f59df6739f158426ef7b6ee2c3b961877d426933", "filename": "libgo/runtime/go-string-to-int-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-string-to-int-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-string-to-int-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-string-to-int-array.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "e4dea9c4690ac4bd1afbbf974fe05bc8faee08f7", "filename": "libgo/runtime/go-strplus.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-strplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-strplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-strplus.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "76681217fdf67cd2d9d290522087c8d79a2313f4", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "9ec18003f1f57e2ca27bcbaacb343baff6b92335", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "5f99c4b73a42b79e8ca27474445ab5e4f9fa96d3", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 160, "deletions": 56, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "8131e964e49a6fad8dce4ce03cee2d58e1ba4882", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "cd3d6ca5ede5b1f2b6a3155b0c4eed2d2d7e3c8b", "filename": "libgo/runtime/mcentral.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmcentral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmcentral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmcentral.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "f62a4d37ee791e05d2dea7712814ff7742ee98d0", "filename": "libgo/runtime/mem.c", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "2318be8da1110d97ff334d5d4db1b100f5a014a7", "filename": "libgo/runtime/mem_posix_memalign.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmem_posix_memalign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmem_posix_memalign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmem_posix_memalign.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "04d58dddda97bb104715b2ed41c3542df60d3da2", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "27fc3cdcc4df2dee72803ef0a476666ce69e15e5", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 597, "deletions": 174, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "b36df25881884fed8054009c4a1a17a924f970cf", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 67, "deletions": 36, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "547c602fe3f34b1dadbccc732884edb575716ced", "filename": "libgo/runtime/mheapmap32.c", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheapmap32.c?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "2861624690f1afe97fd3f0cabbdfed969a3a6d44", "filename": "libgo/runtime/mheapmap32.h", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheapmap32.h?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "d6305953ad557a4bf4cff5dfdc6ac9180f64f1dd", "filename": "libgo/runtime/mheapmap64.c", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheapmap64.c?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "be304cb2e8bbf4995c1fc16d9820937f23dbd989", "filename": "libgo/runtime/mheapmap64.h", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f617201f55938fc89b532f2240bdf77bea946471/libgo%2Fruntime%2Fmheapmap64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheapmap64.h?ref=f617201f55938fc89b532f2240bdf77bea946471"}, {"sha": "2e147edda02f1d9a0fd58ea5e6f5c017a4fa3281", "filename": "libgo/runtime/mprof.goc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmprof.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmprof.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmprof.goc?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "6e82885bab4f0e17582ac73af791d44d5dac2068", "filename": "libgo/runtime/msize.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmsize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fmsize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmsize.c?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "011ba7dab6bf303beb55b70affbf45b81ec794b9", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "7cbd739e51e7347fba1e7dbe3b0807e38521936e", "filename": "libgo/runtime/sigqueue.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fsigqueue.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fruntime%2Fsigqueue.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fsigqueue.goc?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "7a9ee2825dccd0f7732e560a1fccdb1fedd18cdf", "filename": "libgo/syscalls/exec.go", "status": "modified", "additions": 84, "deletions": 79, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fsyscalls%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fsyscalls%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fexec.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "e786653705b08c1eec2b203835b0fd7ccd358dda", "filename": "libgo/syscalls/socket.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fsyscalls%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Fsyscalls%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket.go?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}, {"sha": "93db3462e8ac09ffb13fc901e95889b4e754bf09", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5133f00ef8baab894d92de1e8b8baae59815a8b6/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=5133f00ef8baab894d92de1e8b8baae59815a8b6"}]}