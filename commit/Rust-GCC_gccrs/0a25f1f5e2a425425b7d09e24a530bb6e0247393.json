{"sha": "0a25f1f5e2a425425b7d09e24a530bb6e0247393", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyNWYxZjVlMmE0MjU0MjViN2QwOWUyNGE1MzBiYjZlMDI0NzM5Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-04T18:25:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-04T18:25:41Z"}, "message": "Makefile.in (GGC, GGC_LIB): New.\n\n\t* Makefile.in (GGC, GGC_LIB): New.\n\t(HOST_RTL): Include ggc-none.o.\n\t(ggc-simple.o): New target.\n\t(ggc-none.o): Likewise.\n\t* tree.h (tree_common): Add gc_mark.\n\t* rtl.h (struct rtx_def): Steal a bit from code to make gc_mark.\n\t(struct rtvec_def): Add gc_mark.\n\t* emit-rtl.c (global_rtl): Update static initializers to contain\n\tenough initializers.\n\t* ggc.h, ggc-none.c, ggc-simple.c: New files.\n\t* toplev.c (gc_time): New variable.\n\t(all_time): New variable.\n\t(compile_file): Print gc time.\n\t(print_time): Calculate percentage of the whole.\n\nFrom-SVN: r29106", "tree": {"sha": "068cd2859713068d2e717951d385915d6b99a4df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/068cd2859713068d2e717951d385915d6b99a4df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a25f1f5e2a425425b7d09e24a530bb6e0247393", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a25f1f5e2a425425b7d09e24a530bb6e0247393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a25f1f5e2a425425b7d09e24a530bb6e0247393", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a25f1f5e2a425425b7d09e24a530bb6e0247393/comments", "author": null, "committer": null, "parents": [{"sha": "482cbc74aacb9f764edb4d97722fb0df3c3fd73e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482cbc74aacb9f764edb4d97722fb0df3c3fd73e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482cbc74aacb9f764edb4d97722fb0df3c3fd73e"}], "stats": {"total": 925, "additions": 906, "deletions": 19}, "files": [{"sha": "ed79892a25c76b3fe3e512f04e00690d498590cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -1,3 +1,20 @@\n+Sat Sep  4 11:19:52 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* Makefile.in (GGC, GGC_LIB): New.\n+\t(HOST_RTL): Include ggc-none.o.\n+\t(ggc-simple.o): New target.\n+\t(ggc-none.o): Likewise.\n+\t* tree.h (tree_common): Add gc_mark.\n+\t* rtl.h (struct rtx_def): Steal a bit from code to make gc_mark.\n+\t(struct rtvec_def): Add gc_mark.\n+\t* emit-rtl.c (global_rtl): Update static initializers to contain\n+\tenough initializers.\n+\t* ggc.h, ggc-none.c, ggc-simple.c: New files.\n+\t* toplev.c (gc_time): New variable.\n+\t(all_time): New variable.\n+\t(compile_file): Print gc time.\n+\t(print_time): Calculate percentage of the whole.\n+\t\n Sat Sep  4 13:11:01 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \tChange obstack memory management and varasm constant pool handling so"}, {"sha": "333da82d4950a746afa37c9c59967e6f36f6d125", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -316,6 +316,12 @@ CLIB=\n # system library.\n OBSTACK=obstack.o\n \n+# The GC method to be used on this system.\n+GGC=ggc-simple.o\n+\n+# If a supplementary library is being used for the GC.\n+GGC_LIB=\n+\n # Configure will set these if you need vfprintf and possibly _doprnt support.\n VFPRINTF=@vfprintf@\n DOPRINT=@doprint@\n@@ -572,7 +578,7 @@ HOST_LIBS = $(USE_HOST_OBSTACK) $(USE_HOST_ALLOCA) $(USE_HOST_MALLOC)  \\\n \t    $(HOST_INTLLIBS) $(USE_HOST_VFPRINTF) $(USE_HOST_DOPRINT) \\\n \t    $(HOST_CLIB)\n \n-HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o\n+HOST_RTL = $(HOST_PREFIX)rtl.o $(HOST_PREFIX)bitmap.o $(HOST_PREFIX)ggc-none.o\n HOST_RTLANAL = $(HOST_PREFIX)rtlanal.o\n HOST_PRINT = $(HOST_PREFIX)print-rtl.o\n HOST_ERRORS = $(HOST_PREFIX)errors.o\n@@ -1424,6 +1430,11 @@ gencheck.o : gencheck.c tree.def $(CONFIG_H) hconfig.h system.h\n dumpvers: dumpvers.c\n \n version.o: version.c\n+\n+ggc-simple.o: ggc-simple.c $(CONFIG_H) $(RTL_BASE_H) $(TREE_H) flags.h ggc.h\n+\n+ggc-none.o: ggc-none.c $(CONFIG_H) $(RTL_BASE_H) ggc.h\n+\n obstack.o: $(srcdir)/../libiberty/obstack.c $(CONFIG_H)\n \trm -f obstack.c\n \t$(LN_S) $(srcdir)/../libiberty/obstack.c obstack.c"}, {"sha": "c16ffe4da404add60824b01c1acaa38058a41f8b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -93,17 +93,17 @@ static int no_line_numbers;\n \n struct _global_rtl global_rtl =\n {\n-  {PC, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI },  /* pc_rtx */\n-  {CC0, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* cc0_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* stack_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* frame_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* hard_frame_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* arg_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_incoming_args_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_vars_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_dynamic_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_outgoing_args_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_cfa_rtx */\n+  {PC, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI },  /* pc_rtx */\n+  {CC0, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* cc0_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* stack_pointer_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* frame_pointer_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* hard_frame_pointer_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* arg_pointer_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_incoming_args_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_vars_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_dynamic_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_outgoing_args_rtx */\n+  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_cfa_rtx */\n };\n \n /* We record floating-point CONST_DOUBLEs in each floating-point mode for"}, {"sha": "5fff1045fabb28326460b9c1b1c57f913ae8312c", "filename": "gcc/ggc-none.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -0,0 +1,58 @@\n+/* Null garbage collection for the GNU compiler.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* This version is used by the gen* programs, where we don't really\n+   need GC at all.  This prevents problems with pulling in all the\n+   tree stuff.  */\n+\n+/* We are used by gengenrtl, before genrtl.h exists.  But we don't \n+   need it either.  */\n+#define NO_GENRTL_H\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"ggc.h\"\n+\n+rtx\n+ggc_alloc_rtx (nslots)\n+     int nslots;\n+{\n+  int size = sizeof(struct rtx_def) + (nslots - 1) * sizeof(rtunion);\n+  rtx n;\n+\n+  n = (rtx) xmalloc (size);\n+  bzero ((char *) n, size);\n+\n+  return n;\n+}\n+\n+rtvec\n+ggc_alloc_rtvec (nelt)\n+     int nelt;\n+{\n+  int size = sizeof (struct rtvec_def) + (nelt - 1) * sizeof (rtunion);\n+  rtvec v;\n+\n+  v = (rtvec) xmalloc (size);\n+  bzero ((char *) v, size);\n+\n+  return v;\n+}"}, {"sha": "3ce7bcb596b93e9df9202be7a48bde40d1e02a64", "filename": "gcc/ggc-simple.c", "status": "added", "additions": 714, "deletions": 0, "changes": 714, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -0,0 +1,714 @@\n+/* Simple garbage collection for the GNU compiler.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"ggc.h\"\n+#include \"flags.h\"\n+\n+/* Debugging flags.  */\n+#undef GGC_DUMP\n+#define GGC_POISON\n+\n+/* Global lists of roots, rtxs, and trees.  */\n+\n+struct ggc_root\n+{\n+  struct ggc_root *next;\n+  void *base;\n+  int nelt;\n+  int size;\n+  void (*cb)(void *);\n+};\n+\n+static struct ggc_root *roots;\n+\n+struct ggc_rtx\n+{\n+  struct ggc_rtx *chain;\n+  struct rtx_def rtx;\n+};\n+\n+static struct ggc_rtx *rtxs;\n+\n+struct ggc_rtvec\n+{\n+  struct ggc_rtvec *chain;\n+  struct rtvec_def vec;\n+};\n+\n+static struct ggc_rtvec *vecs;\n+\n+struct ggc_tree\n+{\n+  struct ggc_tree *chain;\n+  union tree_node tree;\n+};\n+\n+static struct ggc_tree *trees;\n+\n+struct ggc_string\n+{\n+  struct ggc_string *chain;\n+  int magic_mark;\n+  char string[1];\n+};\n+\n+#define GGC_STRING_MAGIC\t((unsigned int)0xa1b2c3d4)\n+\n+static struct ggc_string *strings;\n+\n+/* Some statistics.  */\n+\n+static int n_rtxs_collected;\n+static int n_vecs_collected;\n+static int n_trees_collected;\n+static int n_strings_collected;\n+static int bytes_alloced_since_gc;\n+extern int gc_time;\n+\n+#ifdef GGC_DUMP\n+static FILE *dump;\n+#endif\n+\n+/* Local function prototypes.  */\n+\n+static void ggc_free_rtx PROTO ((struct ggc_rtx *r));\n+static void ggc_free_tree PROTO ((struct ggc_tree *t));\n+static void ggc_mark_rtx_ptr PROTO ((void *elt));\n+static void ggc_mark_tree_ptr PROTO ((void *elt));\n+\n+/* These allocators are dreadfully simple, with no caching whatsoever so\n+   that Purify-like tools that do allocation versioning can catch errors.\n+   This collector is never going to go fast anyway.  */\n+\n+rtx\n+ggc_alloc_rtx (nslots)\n+     int nslots;\n+{\n+  struct ggc_rtx *n;\n+  int size = sizeof(*n) + (nslots-1) * sizeof(rtunion);\n+\n+  n = (struct ggc_rtx *) xmalloc (size);\n+  bzero ((char *) n, size);\n+  n->chain = rtxs;\n+  rtxs = n;\n+\n+#ifdef GGC_DUMP\n+  fprintf (dump, \"alloc rtx %p\\n\", &n->rtx);\n+#endif\n+\n+  bytes_alloced_since_gc += size;\n+\n+  return &n->rtx;\n+}\n+\n+rtvec\n+ggc_alloc_rtvec (nelt)\n+     int nelt;\n+{\n+  struct ggc_rtvec *v;\n+  int size = sizeof (*v) + (nelt - 1) * sizeof (rtunion);\n+\n+  v = (struct ggc_rtvec *) xmalloc (size);\n+  bzero ((char *) v, size);\n+  v->chain = vecs;\n+  vecs = v;\n+\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"alloc vec %p\\n\", &v->vec);\n+#endif\n+\n+  bytes_alloced_since_gc += size;\n+\n+  return &v->vec;\n+}\n+\n+tree\n+ggc_alloc_tree (length)\n+     int length;\n+{\n+  struct ggc_tree *n;\n+  int size = sizeof(*n) - sizeof(n->tree) + length;\n+\n+  n = (struct ggc_tree *) xmalloc (size);\n+  bzero ((char *) n, size);\n+  n->chain = trees;\n+  trees = n;\n+\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"alloc tree %p\\n\", &n->tree);\n+#endif\n+\n+  bytes_alloced_since_gc += size;\n+\n+  return &n->tree;\n+}\n+\n+char *\n+ggc_alloc_string (contents, length)\n+     const char *contents;\n+     int length;\n+{\n+  struct ggc_string *s;\n+  int size;\n+\n+  if (length < 0)\n+    {\n+      if (contents == NULL)\n+\treturn NULL;\n+      length = strlen (contents);\n+    }\n+\n+  size = (s->string - (char *)s) + length + 1;\n+  s = (struct ggc_string *) xmalloc(size);\n+  s->chain = strings;\n+  s->magic_mark = GGC_STRING_MAGIC;\n+  if (contents)\n+    bcopy (contents, s->string, length);\n+  s->string[length] = 0;\n+  strings = s;\n+\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"alloc string %p\\n\", &n->tree);\n+#endif\n+\n+  bytes_alloced_since_gc += size;\n+\n+  return s->string;\n+}\n+\n+\n+/* Freeing a bit of rtl isn't quite as simple as calling free, there are\n+   a few associated bits that might need freeing as well.  */\n+\n+static void\n+ggc_free_rtx (r)\n+     struct ggc_rtx *r;\n+{\n+#ifdef GGC_DUMP\n+  fprintf (dump, \"collect rtx %p\\n\", &r->rtx);\n+#endif\n+#ifdef GGC_POISON\n+  memset (r, 0xAA, sizeof(*r));\n+#endif\n+\n+  free (r);\n+}\n+\n+/* Freeing an rtvec is as simple as calling free.  */\n+\n+static void\n+ggc_free_rtvec (v)\n+     struct ggc_rtvec *v;\n+{\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"collect vec %p\\n\", &v->vec);\n+#endif\n+#ifdef GGC_POISON\n+  memset (v, 0xBB, sizeof (*v) + ((GET_NUM_ELEM (&v->vec) - 1)\n+\t\t\t\t  * sizeof (rtunion)));\n+#endif\n+\n+  free (v);\n+}\n+\n+/* Freeing a tree node is almost, but not quite, as simple as calling free.\n+   Mostly we need to let the language clean up its lang_specific bits.  */\n+\n+static void\n+ggc_free_tree (t)\n+     struct ggc_tree *t;\n+{\n+  switch (TREE_CODE_CLASS (TREE_CODE (&t->tree)))\n+    {\n+    case 'd': /* A decl node.  */\n+    case 't': /* A type node.  */\n+      lang_cleanup_tree (&t->tree);\n+      break;\n+    }\n+\n+#ifdef GGC_DUMP\n+  fprintf (dump, \"collect tree %p\\n\", &t->tree);\n+#endif\n+#ifdef GGC_POISON\n+  memset(&t->tree.common, 0xCC, sizeof(t->tree.common));\n+#endif\n+\n+  free (t);\n+}\n+\n+/* Freeing a string is as simple as calling free.  */\n+\n+static void\n+ggc_free_string (s)\n+     struct ggc_string *s;\n+{\n+#ifdef GGC_DUMP\n+  fprintf(dump, \"collect string %p\\n\", s->string);\n+#endif\n+#ifdef GGC_POISON\n+  s->magic_mark = 0xDDDDDDDD;\n+  s->string[0] = 0xDD;\n+#endif\n+\n+  free (s);\n+}\n+\n+/* Mark a node.  */\n+\n+void\n+ggc_mark_rtx (r)\n+     rtx r;\n+{\n+  const char *fmt;\n+  int i;\n+\n+  if (r == NULL_RTX || r->gc_mark)\n+    return;\n+  r->gc_mark = 1;\n+\n+  /* ??? If (some of) these are really pass-dependant info, do we have\n+     any right poking our noses in?  */\n+  switch (GET_CODE (r))\n+    {\n+    case JUMP_INSN:\n+      ggc_mark_rtx (JUMP_LABEL (r));\n+      break;\n+    case CODE_LABEL:\n+      ggc_mark_rtx (LABEL_REFS (r));\n+      break;\n+    case LABEL_REF:\n+      ggc_mark_rtx (LABEL_NEXTREF (r));\n+      ggc_mark_rtx (CONTAINING_INSN (r));\n+      break;\n+    case ADDRESSOF:\n+      ggc_mark_tree (ADDRESSOF_DECL (r));\n+      break;\n+    case CONST_DOUBLE:\n+      ggc_mark_rtx (CONST_DOUBLE_CHAIN (r));\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (fmt = GET_RTX_FORMAT (GET_CODE (r)), i = 0; *fmt ; ++fmt, ++i)\n+    {\n+      switch (*fmt)\n+\t{\n+\tcase 'e': case 'u':\n+\t  ggc_mark_rtx (XEXP (r, i));\n+\t  break;\n+\tcase 'V': case 'E':\n+\t  ggc_mark_rtvec (XVEC (r, i));\n+\t  break;\n+\tcase 'S': case 's':\n+\t  ggc_mark_string (XSTR (r, i));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+void\n+ggc_mark_rtvec (v)\n+     rtvec v;\n+{\n+  int i;\n+\n+  if (v == NULL || v->gc_mark)\n+    return;\n+  v->gc_mark = 1;\n+\n+  i = GET_NUM_ELEM (v);\n+  while (--i >= 0)\n+    ggc_mark_rtx (RTVEC_ELT (v, i));\n+}\n+\n+void\n+ggc_mark_tree (t)\n+     tree t;\n+{\n+  if (t == NULL_TREE || t->common.gc_mark)\n+    return;\n+  t->common.gc_mark = 1;\n+\n+  /* Bits from common.  */\n+  ggc_mark_tree (TREE_TYPE (t));\n+  ggc_mark_tree (TREE_CHAIN (t));\n+\n+  /* Some nodes require special handling.  */\n+  switch (TREE_CODE (t))\n+    {\n+    case TREE_LIST:\n+      ggc_mark_tree (TREE_PURPOSE (t));\n+      ggc_mark_tree (TREE_VALUE (t));\n+      return;\n+\n+    case TREE_VEC:\n+      {\n+\tint i = TREE_VEC_LENGTH (t);\n+\twhile (--i >= 0)\n+\t  ggc_mark_tree (TREE_VEC_ELT (t, i));\n+\treturn;\n+      }\n+\n+    case SAVE_EXPR:\n+      ggc_mark_tree (TREE_OPERAND (t, 0));\n+      ggc_mark_tree (SAVE_EXPR_CONTEXT (t));\n+      ggc_mark_rtx (SAVE_EXPR_RTL (t));\n+      return;\n+\n+    case RTL_EXPR:\n+      ggc_mark_rtx (RTL_EXPR_SEQUENCE (t));\n+      ggc_mark_rtx (RTL_EXPR_RTL (t));\n+      return;\n+\n+    case CALL_EXPR:\n+      ggc_mark_tree (TREE_OPERAND (t, 0));\n+      ggc_mark_tree (TREE_OPERAND (t, 1));\n+      ggc_mark_rtx (CALL_EXPR_RTL (t));\n+      return;\n+\n+    case COMPLEX_CST:\n+      ggc_mark_tree (TREE_REALPART (t));\n+      ggc_mark_tree (TREE_IMAGPART (t));\n+      break;\n+\n+    case STRING_CST:\n+      ggc_mark_string (TREE_STRING_POINTER (t));\n+      break;\n+\n+    case PARM_DECL:\n+      ggc_mark_rtx (DECL_INCOMING_RTL (t));\n+      break;\n+\n+    case IDENTIFIER_NODE:\n+      ggc_mark_string (IDENTIFIER_POINTER (t));\n+      lang_mark_tree (t);\n+      return;\n+\n+    default:\n+      break;\n+    }\n+  \n+  /* But in general we can handle them by class.  */\n+  switch (TREE_CODE_CLASS (TREE_CODE (t)))\n+    {\n+    case 'd': /* A decl node.  */\n+      ggc_mark_tree (DECL_SIZE (t));\n+      ggc_mark_tree (DECL_NAME (t));\n+      ggc_mark_tree (DECL_CONTEXT (t));\n+      ggc_mark_tree (DECL_ARGUMENTS (t));\n+      ggc_mark_tree (DECL_RESULT (t));\n+      ggc_mark_tree (DECL_INITIAL (t));\n+      ggc_mark_tree (DECL_ABSTRACT_ORIGIN (t));\n+      ggc_mark_tree (DECL_ASSEMBLER_NAME (t));\n+      ggc_mark_tree (DECL_SECTION_NAME (t));\n+      ggc_mark_tree (DECL_MACHINE_ATTRIBUTES (t));\n+      ggc_mark_rtx (DECL_RTL (t));\n+      ggc_mark_tree (DECL_VINDEX (t));\n+      lang_mark_tree (t);\n+      break;\n+\n+    case 't': /* A type node.  */\n+      ggc_mark_tree (TYPE_SIZE (t));\n+      ggc_mark_tree (TYPE_SIZE_UNIT (t));\n+      ggc_mark_tree (TYPE_ATTRIBUTES (t));\n+      ggc_mark_tree (TYPE_VALUES (t));\n+      ggc_mark_tree (TYPE_POINTER_TO (t));\n+      ggc_mark_tree (TYPE_REFERENCE_TO (t));\n+      ggc_mark_tree (TYPE_NAME (t));\n+      ggc_mark_tree (TYPE_MIN_VALUE (t));\n+      ggc_mark_tree (TYPE_MAX_VALUE (t));\n+      ggc_mark_tree (TYPE_NEXT_VARIANT (t));\n+      ggc_mark_tree (TYPE_MAIN_VARIANT (t));\n+      ggc_mark_tree (TYPE_BINFO (t));\n+      ggc_mark_tree (TYPE_NONCOPIED_PARTS (t));\n+      ggc_mark_tree (TYPE_CONTEXT (t));\n+      lang_mark_tree (t);\n+      break;\n+\n+    case 'b': /* A lexical block.  */\n+      ggc_mark_tree (BLOCK_VARS (t));\n+      ggc_mark_tree (BLOCK_TYPE_TAGS (t));\n+      ggc_mark_tree (BLOCK_SUBBLOCKS (t));\n+      ggc_mark_tree (BLOCK_SUPERCONTEXT (t));\n+      ggc_mark_tree (BLOCK_ABSTRACT_ORIGIN (t));\n+      ggc_mark_rtx (BLOCK_END_NOTE (t));\n+      break;\n+\n+    case 'c': /* A constant.  */\n+      ggc_mark_rtx (TREE_CST_RTL (t));\n+      break;\n+\n+    case 'r': case '<': case '1':\n+    case '2': case 'e': case 's': /* Expressions.  */\n+      {\n+\tint i = tree_code_length[TREE_CODE (t)];\n+\twhile (--i >= 0)\n+\t  ggc_mark_tree (TREE_OPERAND (t, i));\n+\tbreak;\n+      }\n+    }\n+}\n+\n+void\n+ggc_mark_string (s)\n+     char *s;\n+{\n+  unsigned int *magic = (unsigned int *)s - 1;\n+\n+  if (s == NULL)\n+    return;\n+\n+  if ((*magic & ~(unsigned)1) != GGC_STRING_MAGIC)\n+    return;   /* abort? */\n+  *magic = GGC_STRING_MAGIC | 1;\n+}\n+\n+/* The top level mark-and-sweep routine.  */\n+\n+void\n+ggc_collect ()\n+{\n+  struct ggc_rtx *r, **rp;\n+  struct ggc_rtvec *v, **vp;\n+  struct ggc_tree *t, **tp;\n+  struct ggc_string *s, **sp;\n+  struct ggc_root *x;\n+  int time, n_rtxs, n_trees, n_vecs, n_strings;\n+\n+#ifndef ENABLE_CHECKING\n+  /* See if it's even worth our while.  */\n+  if (bytes_alloced_since_gc < 64*1024)\n+    return;\n+#endif\n+\n+  if (!quiet_flag)\n+    fputs (\" {GC \", stderr);\n+\n+  time = get_run_time ();\n+\n+  /* Clean out all of the GC marks.  */\n+  for (r = rtxs; r != NULL; r = r->chain)\n+    r->rtx.gc_mark = 0;\n+  for (v = vecs; v != NULL; v = v->chain)\n+    v->vec.gc_mark = 0;\n+  for (t = trees; t != NULL; t = t->chain)\n+    t->tree.common.gc_mark = 0;\n+  for (s = strings; s != NULL; s = s->chain)\n+    s->magic_mark = GGC_STRING_MAGIC;\n+\n+  /* Mark through all the roots.  */\n+  for (x = roots; x != NULL; x = x->next)\n+    {\n+      char *elt = x->base;\n+      int s = x->size, n = x->nelt;\n+      void (*cb)(void *) = x->cb;\n+      int i;\n+\n+      for (i = 0; i < n; ++i, elt += s)\n+\t(*cb)(elt);\n+    }\n+\n+  /* Sweep the resulting dead nodes.  */\n+  rp = &rtxs, r = rtxs, n_rtxs = 0;\n+  while (r != NULL)\n+    {\n+      struct ggc_rtx *chain = r->chain;\n+      if (!r->rtx.gc_mark)\n+        {\n+\t  ggc_free_rtx (r);\n+\t  *rp = chain;\n+\t  n_rtxs++;\n+        }\n+      else\n+\trp = &r->chain;\n+      r = chain;\n+    }\n+  *rp = NULL;\n+  n_rtxs_collected += n_rtxs;\n+\n+  vp = &vecs, v = vecs, n_vecs = 0;\n+  while (v != NULL)\n+    {\n+      struct ggc_rtvec *chain = v->chain;\n+      if (!v->vec.gc_mark)\n+        {\n+\t  ggc_free_rtvec (v);\n+\t  *vp = chain;\n+\t  n_vecs++;\n+        }\n+      else\n+\tvp = &v->chain;\n+      v = chain;\n+    }\n+  *vp = NULL;\n+  n_vecs_collected += n_vecs;\n+\n+  tp = &trees, t = trees, n_trees = 0;\n+  while (t != NULL)\n+    {\n+      struct ggc_tree *chain = t->chain;\n+      if (!t->tree.common.gc_mark)\n+        {\n+\t  ggc_free_tree (t);\n+\t  *tp = chain;\n+\t  n_trees++;\n+        }\n+      else\n+\ttp = &t->chain;\n+      t = chain;\n+    }\n+  *tp = NULL;\n+  n_trees_collected += n_trees;\n+\n+  sp = &strings, s = strings, n_strings = 0;\n+  while (s != NULL)\n+    {\n+      struct ggc_string *chain = s->chain;\n+      if (!(s->magic_mark & 1))\n+        {\n+\t  ggc_free_string (s);\n+\t  *sp = chain;\n+\t  n_strings++;\n+        }\n+      else\n+\tsp = &s->chain;\n+      s = chain;\n+    }\n+  *sp = NULL;\n+  n_strings_collected += n_strings;\n+\n+  gc_time += time = get_run_time () - time;\n+\n+  if (!quiet_flag)\n+    {\n+      time = (time + 500) / 1000;\n+      fprintf (stderr, \"%d,%d,%d,%d %d.%03d}\", n_rtxs, n_vecs, n_trees,\n+\t       n_strings, time / 1000, time % 1000);\n+    }\n+}\n+\n+/* Manipulate global roots that are needed between calls to gc.  */\n+\n+void\n+ggc_add_root (base, nelt, size, cb)\n+     void *base;\n+     int nelt, size;\n+     void (*cb) PROTO ((void *));\n+{\n+  struct ggc_root *x = (struct ggc_root *) xmalloc (sizeof(*x));\n+\n+  x->next = roots;\n+  x->base = base;\n+  x->nelt = nelt;\n+  x->size = size;\n+  x->cb = cb;\n+\n+  roots = x;\n+}\n+\n+void\n+ggc_add_rtx_root (base, nelt)\n+     rtx *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof(rtx), ggc_mark_rtx_ptr);\n+}\n+\n+void\n+ggc_add_tree_root (base, nelt)\n+     tree *base;\n+     int nelt;\n+{\n+  ggc_add_root (base, nelt, sizeof(tree), ggc_mark_tree_ptr);\n+}\n+\n+void\n+ggc_del_root (base)\n+     void *base;\n+{\n+  struct ggc_root *x, **p;\n+\n+  p = &roots, x = roots;\n+  while (x)\n+    {\n+      if (x->base == base)\n+\t{\n+\t  *p = x->next;\n+\t  free (x);\n+\t  return;\n+\t}\n+      p = &x->next;\n+      x = x->next;\n+    }\n+\n+  abort();\n+}\n+\n+static void\n+ggc_mark_rtx_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_rtx (*(rtx *)elt);\n+}\n+\n+static void\n+ggc_mark_tree_ptr (elt)\n+     void *elt;\n+{\n+  ggc_mark_tree (*(tree *)elt);\n+}\n+\n+#ifdef GGC_DUMP\n+/* Don't enable this unless you want a really really lot of data.  */\n+static void __attribute__((constructor))\n+init(void)\n+{\n+  dump = fopen (\"zgcdump\", \"w\");\n+  setlinebuf (dump);\n+}\n+#endif\n+\n+#if 0\n+/* GDB really should have a memory search function.  Since this is just\n+   for initial debugging, I won't even pretend to get the __data_start\n+   to work on any but alpha-dec-linux-gnu.  */\n+static void **\n+search_data(void **start, void *target)\n+{\n+  extern void *__data_start[];\n+  void **_end = (void **)sbrk(0);\n+\n+  if (start == NULL)\n+    start = __data_start;\n+  while (start < _end)\n+    {\n+      if (*start == target)\n+        return start;\n+      start++;\n+    }\n+  return NULL;\n+}\n+#endif"}, {"sha": "bb0be13623e9c4a72cd8f8396924282b2347f811", "filename": "gcc/ggc.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -0,0 +1,72 @@\n+/* Garbage collection for the GNU compiler.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"gansidecl.h\"\n+\n+/* Symbols are marked with `ggc' for `gcc gc' so as not to interfere with\n+   an external gc library that might be linked in.  */\n+\n+/* Startup */\n+\n+extern void init_ggc PROTO ((void));\n+\n+/* Allocation.  */\n+\n+struct rtx_def *ggc_alloc_rtx PROTO ((int nslots));\n+struct rtvec_def *ggc_alloc_rtvec PROTO ((int nelt));\n+union tree_node *ggc_alloc_tree PROTO ((int length));\n+char *ggc_alloc_string PROTO ((const char *contents, int length));\n+\n+/* Invoke the collector.  This is really just a hint, but in the case of\n+   the simple collector, the only time it will happen.  */\n+\n+void ggc_collect PROTO ((void));\n+\n+/* Manipulate global roots that are needed between calls to gc.  */\n+void ggc_add_root PROTO ((void *base, int nelt, int size,\n+\t\t\t   void (*)(void *)));\n+void ggc_add_rtx_root PROTO ((struct rtx_def **, int nelt));\n+void ggc_add_tree_root PROTO ((union tree_node **, int nelt));\n+void ggc_del_root PROTO ((void *base));\n+\n+/* Mark nodes from the gc_add_root callback.  */\n+void ggc_mark_rtx PROTO ((struct rtx_def *));\n+void ggc_mark_rtvec PROTO ((struct rtvec_def *));\n+void ggc_mark_tree PROTO ((union tree_node *));\n+void ggc_mark_string PROTO ((char *));\n+\n+/* Callbacks to the languages.  */\n+\n+/* This is the language's opportunity to mark nodes held through\n+   the lang_specific hooks in the tree.  */\n+void lang_mark_tree PROTO ((union tree_node *));\n+\n+/* And similarly to free that data when the tree node is released.  */\n+void lang_cleanup_tree PROTO ((union tree_node *));\n+\n+/* Mark functions for various structs scattered about.  */\n+\n+void mark_temp_slot PROTO ((void *));\n+void mark_function_chain PROTO ((void *));\n+void mark_eh_state PROTO ((void *));\n+void mark_stmt_state PROTO ((void *));\n+void mark_emit_state PROTO ((void *));\n+void mark_varasm_state PROTO ((void *));\n+void mark_optab PROTO ((void *));"}, {"sha": "d680ed71059beb167fbfc66f1d9eaaf67c57d062", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -102,13 +102,13 @@ typedef struct rtx_def\n {\n #ifdef ONLY_INT_FIELDS\n #ifdef CODE_FIELD_BUG\n-  unsigned int code : 16;\n+  unsigned int code : 15;\n #else\n   unsigned short code;\n #endif\n #else\n   /* The kind of expression this is.  */\n-  enum rtx_code code : 16;\n+  enum rtx_code code : 15;\n #endif\n   /* The kind of value the expression has.  */\n #ifdef ONLY_INT_FIELDS\n@@ -171,6 +171,10 @@ typedef struct rtx_def\n      1 in a MEM if the MEM refers to a scalar, rather than a member of\n      an aggregate.  */\n   unsigned frame_related : 1;\n+\n+  /* Used by the garbage collector.  */\n+  unsigned gc_mark : 1;\n+\n   /* The first element of the operands of this rtx.\n      The number of operands and their types are controlled\n      by the `code' field, according to rtl.def.  */\n@@ -202,6 +206,7 @@ typedef struct rtx_def\n \n typedef struct rtvec_def{\n   int num_elem;\t\t/* number of elements */\n+  int gc_mark;\n   struct rtx_def *elem[1];\n } *rtvec;\n "}, {"sha": "266c64c4d7af639bdcbd08de29a8cf67524658b0", "filename": "gcc/toplev.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -54,6 +54,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"basic-block.h\"\n #include \"intl.h\"\n+#include \"ggc.h\"\n \n #ifdef DWARF_DEBUGGING_INFO\n #include \"dwarfout.h\"\n@@ -1350,6 +1351,8 @@ int stack_reg_time;\n int final_time;\n int symout_time;\n int dump_time;\n+int gc_time;\n+int all_time;\n \f\n /* Return time used so far, in microseconds.  */\n \n@@ -1429,8 +1432,9 @@ print_time (str, total)\n      int total;\n {\n   fprintf (stderr,\n-\t   \"time in %s: %d.%06d\\n\",\n-\t   str, total / 1000000, total % 1000000);\n+\t   \"time in %s: %d.%06d (%.0f%%)\\n\",\n+\t   str, total / 1000000, total % 1000000,\n+\t   (double)total / (double)all_time * 100.0);\n }\n \n /* Count an error or warning.  Return 1 if the message should be printed.  */\n@@ -3446,9 +3450,11 @@ compile_file (name)\n \n   if (! quiet_flag)\n     {\n+      all_time = get_run_time ();\n+\n       fprintf (stderr,\"\\n\");\n-      print_time (\"parse\", parse_time);\n \n+      print_time (\"parse\", parse_time);\n       print_time (\"integration\", integration_time);\n       print_time (\"jump\", jump_time);\n       print_time (\"cse\", cse_time);\n@@ -3473,6 +3479,7 @@ compile_file (name)\n       print_time (\"varconst\", varconst_time);\n       print_time (\"symout\", symout_time);\n       print_time (\"dump\", dump_time);\n+      print_time (\"gc\", gc_time);\n     }\n }\n \f\n@@ -3772,7 +3779,7 @@ rest_of_compilation (decl)\n   /* See if we have allocated stack slots that are not directly addressable.\n      If so, scan all the insns and create explicit address computation\n      for all references to such slots.  */\n-/*   fixup_stack_slots (); */\n+  /* fixup_stack_slots (); */\n \n   /* Find all the EH handlers.  */\n   find_exception_handler_labels ();"}, {"sha": "44d6f043b5d8da5fae995a16a7688ffc93dd2723", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a25f1f5e2a425425b7d09e24a530bb6e0247393/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0a25f1f5e2a425425b7d09e24a530bb6e0247393", "patch": "@@ -194,7 +194,10 @@ struct tree_common\n   unsigned lang_flag_4 : 1;\n   unsigned lang_flag_5 : 1;\n   unsigned lang_flag_6 : 1;\n-  /* There is room for three more flags.  */\n+\n+  unsigned gc_mark : 1;\n+\n+  /* There is room for two more flags.  */\n };\n \n /* The following table lists the uses of each of the above flags and"}]}