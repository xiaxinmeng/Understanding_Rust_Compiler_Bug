{"sha": "69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliMzMzMWUyYWUyMTIyYTYzOGUzNzNiYjg1OGMyZDliMWI5NGYzYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2007-12-03T13:12:51Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-12-03T13:12:51Z"}, "message": "unordered_map (operator==(const unordered_map&, const unordered_map&), [...]): Remove.\n\n2007-12-03  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/debug/unordered_map (operator==(const unordered_map&,\n\tconst unordered_map&), operator!=(const unordered_map&,\n\tconst unordered_map&), operator==(const unordered_multimap&,\n\tconst unordered_multimap&), operator!=(const unordered_multimap&,\n\tconst unordered_multimap&)): Remove.\n\t(unordered_map<>::unordered_map(unordered_map&&),\n\toperator=(unordered_map&&), clear, _M_invalidate_all,\n\tunordered_multimap<>::unordered_multimap(unordered_multimap&&),\n\toperator=(unordered_map&&), clear, _M_invalidate_all,\t\n\tswap(unordered_map<>&&, unordered_map<>&), swap(unordered_map<>&,\n\tunordered_map<>&&), swap(unordered_multimap<>&&,\n\tunordered_multimap<>&), swap(unordered_multimap<>&,\n\tunordered_multimap<>&&)): Add.\n\t* include/debug/unordered_set (operator==(const unordered_set&,\n\tconst unordered_set&), operator!=(const unordered_set&,\n\tconst unordered_set&), operator==(const unordered_multiset&,\n\tconst unordered_multiset&), operator!=(const unordered_multiset&,\n\tconst unordered_multiset&)): Remove.\n\t(unordered_set<>::unordered_set(unordered_set&&),\n\toperator=(unordered_set&&), clear, _M_invalidate_all,\n\tunordered_multiset<>::unordered_multiset(unordered_multiset&&),\n\toperator=(unordered_set&&), clear, _M_invalidate_all,\t\n\tswap(unordered_set<>&&, unordered_set<>&), swap(unordered_set<>&,\n\tunordered_set<>&&), swap(unordered_multiset<>&&,\n\tunordered_multiset<>&), swap(unordered_multiset<>&,\n\tunordered_multiset<>&&)): Add.\n\t* include/debug/safe_association.h (_Safe_association<>::\n\t_Safe_association(_Safe_association&&)): Add.\n\t(_Safe_association<>::clear, _M_invalidate_all): Remove.\n\nFrom-SVN: r130581", "tree": {"sha": "3a2bae84d01d7425c6f05e696ff2cc29e7aadd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2bae84d01d7425c6f05e696ff2cc29e7aadd8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/comments", "author": null, "committer": null, "parents": [{"sha": "aa1a4968d3c6b9889cd601cad404e97a7ad2b38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa1a4968d3c6b9889cd601cad404e97a7ad2b38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa1a4968d3c6b9889cd601cad404e97a7ad2b38a"}], "stats": {"total": 252, "additions": 191, "deletions": 61}, "files": [{"sha": "e76767bc65e05d3fa3e7b989f0fd4d752a6362ac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "patch": "@@ -1,3 +1,35 @@\n+2007-12-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/debug/unordered_map (operator==(const unordered_map&,\n+\tconst unordered_map&), operator!=(const unordered_map&,\n+\tconst unordered_map&), operator==(const unordered_multimap&,\n+\tconst unordered_multimap&), operator!=(const unordered_multimap&,\n+\tconst unordered_multimap&)): Remove.\n+\t(unordered_map<>::unordered_map(unordered_map&&),\n+\toperator=(unordered_map&&), clear, _M_invalidate_all,\n+\tunordered_multimap<>::unordered_multimap(unordered_multimap&&),\n+\toperator=(unordered_map&&), clear, _M_invalidate_all,\t\n+\tswap(unordered_map<>&&, unordered_map<>&), swap(unordered_map<>&,\n+\tunordered_map<>&&), swap(unordered_multimap<>&&,\n+\tunordered_multimap<>&), swap(unordered_multimap<>&,\n+\tunordered_multimap<>&&)): Add.\n+\t* include/debug/unordered_set (operator==(const unordered_set&,\n+\tconst unordered_set&), operator!=(const unordered_set&,\n+\tconst unordered_set&), operator==(const unordered_multiset&,\n+\tconst unordered_multiset&), operator!=(const unordered_multiset&,\n+\tconst unordered_multiset&)): Remove.\n+\t(unordered_set<>::unordered_set(unordered_set&&),\n+\toperator=(unordered_set&&), clear, _M_invalidate_all,\n+\tunordered_multiset<>::unordered_multiset(unordered_multiset&&),\n+\toperator=(unordered_set&&), clear, _M_invalidate_all,\t\n+\tswap(unordered_set<>&&, unordered_set<>&), swap(unordered_set<>&,\n+\tunordered_set<>&&), swap(unordered_multiset<>&&,\n+\tunordered_multiset<>&), swap(unordered_multiset<>&,\n+\tunordered_multiset<>&&)): Add.\n+\t* include/debug/safe_association.h (_Safe_association<>::\n+\t_Safe_association(_Safe_association&&)): Add.\n+\t(_Safe_association<>::clear, _M_invalidate_all): Remove.\n+\n 2007-12-01  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1_impl/hashtable_policy.h (struct _LessThan): Remove."}, {"sha": "42c050050b85a1eb9b0b476f8ed80f5168f85cc2", "filename": "libstdc++-v3/include/debug/safe_association.h", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_association.h?ref=69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "patch": "@@ -1,7 +1,6 @@\n // Safe associated container base class implementation  -*- C++ -*-\n \n-// Copyright (C) 2007\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -108,6 +107,9 @@ namespace __gnu_debug\n \n       _Safe_association(const _Base& __x) : _Base(__x) { }\n \n+      _Safe_association(_Safe_association&& __x)\n+      : _Base(std::forward<_Base>(__x)) { }\n+\n       using _Base::size;\n       using _Base::max_size;\n       using _Base::empty;\n@@ -197,27 +199,11 @@ namespace __gnu_debug\n \treturn iterator(_Base::erase(__first.base(), __last.base()));\n       }\n \n-      void\n-      clear()\n-      {\n-\t_Base::clear();\n-\tthis->_M_invalidate_all();\n-      }\n-\n       _Base&\n       _M_base() { return *this; }\n \n       const _Base&\n       _M_base() const { return *this; }\n-\n-    private:\n-      void\n-      _M_invalidate_all()\n-      {\n-\ttypedef typename _Base::const_iterator _Base_const_iterator;\n-\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n-\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n-      }\n     };\n } // namespace __gnu_debug\n "}, {"sha": "590d4a3478f03c772b306469710664b2bdde5ecd", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "patch": "@@ -1,6 +1,6 @@\n // Debugging unordered_map/unordered_multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2005, 2007\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -88,33 +88,61 @@ namespace __debug\n       unordered_map(const _Safe_assoc& __x) \n       : _Safe_assoc(__x), _Safe_base() { }\n \n+      unordered_map(unordered_map&& __x) \n+      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+\n+      unordered_map&\n+      operator=(unordered_map&& __x)\n+      {\n+        // NB: DR 675.\n+\tclear();\n+\tswap(__x);\n+\treturn *this;\n+      }\n+\n       void\n-      swap(unordered_map& __x)\n+      swap(unordered_map&& __x)\n       {\n \t_Safe_assoc::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+    private:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n-    inline bool\n-    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n-    inline bool\n-    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n+    inline void\n+    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n \n #undef _GLIBCXX_BASE\n@@ -160,36 +188,63 @@ namespace __debug\n       unordered_multimap(const _Safe_assoc& __x) \n       : _Safe_assoc(__x), _Safe_base() { }\n \n+      unordered_multimap(unordered_multimap&& __x) \n+      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+\n+      unordered_multimap&\n+      operator=(unordered_multimap&& __x)\n+      {\n+        // NB: DR 675.\n+\tclear();\n+\tswap(__x);\n+\treturn *this;\n+      }\n+\n       void\n-      swap(unordered_multimap& __x)\n+      swap(unordered_multimap&& __x)\n       {\n \t_Safe_assoc::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+    private:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+      }\n     };\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n-    inline bool\n-    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n-    inline bool\n-    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n+    inline void\n+    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Key, typename _Tp, typename _Hash,\n \t   typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n-\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n \n-\n } // namespace __debug\n } // namespace std\n "}, {"sha": "b4b9be8a140fc30690aa18deabaff9b709931c6b", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 78, "deletions": 21, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b3331e2ae2122a638e373bb858c2d9b1b94f3b/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=69b3331e2ae2122a638e373bb858c2d9b1b94f3b", "patch": "@@ -1,6 +1,6 @@\n // Debugging unordered_set/unordered_multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2005, 2007\n+// Copyright (C) 2003, 2004, 2005, 2006, 2007\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -89,30 +89,58 @@ namespace __debug\n       unordered_set(const _Safe_assoc& __x) \n       : _Safe_assoc(__x), _Safe_base() { }\n \n+      unordered_set(unordered_set&& __x) \n+      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+\n+      unordered_set&\n+      operator=(unordered_set&& __x)\n+      {\n+        // NB: DR 675.\n+\tclear();\n+\tswap(__x);\n+\treturn *this;\n+      }\n+\n       void\n-      swap(unordered_set& __x)\n+      swap(unordered_set&& __x)\n       {\n \t_Safe_assoc::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n+\n+      void\n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+    private:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n-    inline bool\n-    operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n-    inline bool\n-    operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n+    inline void\n+    swap(unordered_set<_Value, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_set<_Value, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n \n #undef _GLIBCXX_BASE\n@@ -158,31 +186,60 @@ namespace __debug\n       unordered_multiset(const _Safe_assoc& __x) \n       : _Safe_assoc(__x), _Safe_base() { }\n \n+      unordered_multiset(unordered_multiset&& __x) \n+      : _Safe_assoc(std::forward<_Safe_assoc>(__x)), _Safe_base() { }\n+\n+      unordered_multiset&\n+      operator=(unordered_multiset&& __x)\n+      {\n+        // NB: DR 675.\n+\tclear();\n+\tswap(__x);\n+\treturn *this;\n+      }\n+\n       void\n-      swap(unordered_multiset& __x)\n+      swap(unordered_multiset&& __x)\n       {\n \t_Safe_assoc::swap(__x);\n \t_Safe_base::_M_swap(__x);\n       }\n+\n+     void\n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+    private:\n+      void\n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(this->_M_base().end()));\n+      }\n     };\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n-    inline bool\n-    operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() == __y._M_base(); }\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n-    inline bool\n-    operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t       const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n-    { return __x._M_base() != __y._M_base(); }\n+    inline void\n+    swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>&& __x,\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+    { __x.swap(__y); }\n \n   template<typename _Value, typename _Hash, typename _Pred, typename _Alloc>\n     inline void\n     swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n-\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n+\t unordered_multiset<_Value, _Hash, _Pred, _Alloc>&& __y)\n     { __x.swap(__y); }\n+\n } // namespace __debug\n } // namespace std\n "}]}