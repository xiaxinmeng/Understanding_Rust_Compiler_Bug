{"sha": "316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE2ZDlkNGY5Zjg2YWNmOGZkMGU0YjIyYTgwZDAxMzRjODc2NTAyYQ==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2011-08-04T07:41:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T07:41:38Z"}, "message": "prj.adb, [...] (Complete_Mains, [...]): new subprogram.\n\n2011-08-04  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb, prj.ads, makeutl.adb, makeutl.ads (Complete_Mains,\n\tCompute_Compilation_Phases): new subprogram.\n\t(Builder_Data, Builder_Project_Tree_Data): new subprogram and type\n\tThe number of mains as well as the various compilation phases that\n\tneed to be run are now project tree specific, since various\n\taggregated trees might have different requirements. In particular,\n\tthey do not all require bind or link phases.\n\nFrom-SVN: r177317", "tree": {"sha": "90615aa381b47974f7c25d6c41437a8b2f3a956e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90615aa381b47974f7c25d6c41437a8b2f3a956e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8dd00781e17a65c4344681e13f763f8b41880c61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd00781e17a65c4344681e13f763f8b41880c61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd00781e17a65c4344681e13f763f8b41880c61"}], "stats": {"total": 692, "additions": 491, "deletions": 201}, "files": [{"sha": "40ffac4e36407c20ed9bcf5cd4a4be49f08791a6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "patch": "@@ -1,3 +1,13 @@\n+2011-08-04  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb, prj.ads, makeutl.adb, makeutl.ads (Complete_Mains,\n+\tCompute_Compilation_Phases): new subprogram.\n+\t(Builder_Data, Builder_Project_Tree_Data): new subprogram and type\n+\tThe number of mains as well as the various compilation phases that\n+\tneed to be run are now project tree specific, since various\n+\taggregated trees might have different requirements. In particular,\n+\tthey do not all require bind or link phases.\n+\n 2011-08-04  Emmanuel Briot  <briot@adacore.com>\n \n \t* prj.adb, prj.ads, makeutl.adb, makeutl.ads, prj-env.adb"}, {"sha": "2c821dc1c92196955e3557fbb81e1b31d27044ab", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 375, "deletions": 191, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Unchecked_Deallocation;\n with ALI;      use ALI;\n with Debug;\n with Err_Vars; use Err_Vars;\n@@ -1224,6 +1225,9 @@ package body Makeutl is\n       Current : Natural := 0;\n       --  The index of the last main retrieved from the table\n \n+      Count_Of_Mains_With_No_Tree : Natural := 0;\n+      --  Number of main units for which we do not know the project tree\n+\n       --------------\n       -- Add_Main --\n       --------------\n@@ -1236,13 +1240,27 @@ package body Makeutl is\n          Tree     : Project_Tree_Ref := null)\n       is\n       begin\n+         if Current_Verbosity = High then\n+            Debug_Output (\"Add_Main \"\"\" & Name & \"\"\" \" & Index'Img\n+                          & \" with_tree? \"\n+                          & Boolean'Image (Tree /= null));\n+         end if;\n+\n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (Name);\n          Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n \n          Names.Increment_Last;\n          Names.Table (Names.Last) :=\n            (Name_Find, Index, Location, No_Source, Project, Tree);\n+\n+         if Tree /= null then\n+            Builder_Data (Tree).Number_Of_Mains :=\n+              Builder_Data (Tree).Number_Of_Mains + 1;\n+         else\n+            Mains.Count_Of_Mains_With_No_Tree :=\n+              Mains.Count_Of_Mains_With_No_Tree + 1;\n+         end if;\n       end Add_Main;\n \n       --------------------------\n@@ -1281,6 +1299,162 @@ package body Makeutl is\n          Mains.Reset;\n       end Delete;\n \n+      --------------------\n+      -- Complete_Mains --\n+      --------------------\n+\n+      procedure Complete_Mains\n+        (Root_Project : Project_Id;\n+         Project_Tree : Project_Tree_Ref)\n+      is\n+         procedure Do_Complete (Project : Project_Id; Tree : Project_Tree_Ref);\n+         --  Check the mains for this specific project\n+\n+         procedure Complete_All is new For_Project_And_Aggregated\n+           (Do_Complete);\n+\n+         procedure Do_Complete\n+           (Project : Project_Id; Tree : Project_Tree_Ref) is\n+         begin\n+            if Mains.Number_Of_Mains (Tree) > 0\n+              or else Mains.Count_Of_Mains_With_No_Tree > 0\n+            then\n+               for J in Names.First .. Names.Last loop\n+                  declare\n+                     File       : Main_Info := Names.Table (J);\n+                     Main_Id    : File_Name_Type := File.File;\n+                     Main       : constant String := Get_Name_String (Main_Id);\n+                     Source     : Prj.Source_Id := No_Source;\n+                     Suffix     : File_Name_Type;\n+                     Iter       : Source_Iterator;\n+\n+                  begin\n+                     if Base_Name (Main) /= Main then\n+                        if Is_Absolute_Path (Main) then\n+                           Main_Id := Create_Name (Base_Name (Main));\n+                        else\n+                           Fail_Program\n+                             (Tree,\n+                              \"mains cannot include directory information (\"\"\"\n+                              & Main & \"\"\")\");\n+                        end if;\n+                     end if;\n+\n+                     --  If no project or tree was specified for the main, it\n+                     --  came from the command line. In this case, it needs to\n+                     --  belong to the root project.\n+                     --  Note that the assignments below will not modify inside\n+                     --  the table itself.\n+\n+                     if File.Project = null then\n+                        File.Project := Project;\n+                     end if;\n+\n+                     if File.Tree = null then\n+                        File.Tree := Project_Tree;\n+                     end if;\n+\n+                     if File.Source = null then\n+\n+                        --  First, look for the main as specified.\n+\n+                        Source := Find_Source\n+                          (In_Tree   => File.Tree,\n+                           Project   => File.Project,\n+                           Base_Name => File.File,\n+                           Index     => File.Index);\n+\n+                        if Source = No_Source then\n+                           --  Now look for the main with a body suffix\n+\n+                           declare\n+                              --  Main already has a canonical casing\n+                              Main : constant String :=\n+                                Get_Name_String (Main_Id);\n+                              Project : Project_Id;\n+                           begin\n+                              Project := File.Project;\n+                              while Source = No_Source\n+                                and then Project /= No_Project\n+                              loop\n+                                 Iter := For_Each_Source (File.Tree, Project);\n+                                 loop\n+                                    Source := Prj.Element (Iter);\n+                                    exit when Source = No_Source;\n+\n+                                    --  Only consider bodies\n+\n+                                    if Source.Kind = Impl then\n+                                       Get_Name_String (Source.File);\n+\n+                                       if Name_Len > Main'Length\n+                                         and then Name_Buffer\n+                                           (1 .. Main'Length) = Main\n+                                       then\n+                                          Suffix :=\n+                                            Source.Language\n+                                              .Config.Naming_Data.Body_Suffix;\n+\n+                                          exit when Suffix /= No_File and then\n+                                            Name_Buffer\n+                                              (Main'Length + 1 .. Name_Len) =\n+                                              Get_Name_String (Suffix);\n+                                       end if;\n+                                    end if;\n+\n+                                    Next (Iter);\n+                                 end loop;\n+\n+                                 Project := Project.Extends;\n+                              end loop;\n+                           end;\n+                        end if;\n+\n+                        if Source /= No_Source then\n+                           Debug_Output (\"Found main in project\",\n+                                         Name_Id (Source.File));\n+                           Names.Table (J).File    := Source.File;\n+                           Names.Table (J).Project := File.Project;\n+\n+                           if Names.Table (J).Tree = null then\n+                              Names.Table (J).Tree := File.Tree;\n+\n+                              Builder_Data (File.Tree).Number_Of_Mains :=\n+                                Builder_Data (File.Tree).Number_Of_Mains + 1;\n+                              Mains.Count_Of_Mains_With_No_Tree :=\n+                                Mains.Count_Of_Mains_With_No_Tree - 1;\n+                           end if;\n+\n+                           Names.Table (J).Source  := Source;\n+\n+                        elsif File.Location /= No_Location then\n+                           --  If the main is declared in package Builder of\n+                           --  the main project, report an error. If the main\n+                           --  is on the command line, it may be a main from\n+                           --  another project, so do nothing: if the main does\n+                           --  not exist in another project, an error will be\n+                           --  reported later.\n+\n+                           Error_Msg_File_1 := Main_Id;\n+                           Error_Msg_Name_1 := Root_Project.Name;\n+                           Errutil.Error_Msg\n+                             (\"{ is not a source of project %%\",\n+                              File.Location);\n+                        end if;\n+                     end if;\n+                  end;\n+               end loop;\n+            end if;\n+\n+            if Total_Errors_Detected > 0 then\n+               Fail_Program (Tree, \"problems with main sources\");\n+            end if;\n+         end Do_Complete;\n+\n+      begin\n+         Complete_All (Root_Project, Project_Tree);\n+      end Complete_Mains;\n+\n       -----------------------\n       -- FIll_From_Project --\n       -----------------------\n@@ -1291,168 +1465,56 @@ package body Makeutl is\n       is\n          procedure Add_Mains_From_Project\n            (Project : Project_Id; Tree    : Project_Tree_Ref);\n-         --  Add the main units from this project into Mains\n+         --  Add the main units from this project into Mains.\n+         --  This takes into account the aggregated projects\n \n          procedure Add_Mains_From_Project\n            (Project : Project_Id;\n             Tree    : Project_Tree_Ref)\n          is\n             List    : String_List_Id;\n             Element : String_Element;\n-            Agg     : Aggregated_Project_List;\n          begin\n-            Debug_Output (\"Add_Mains_From_Project\", Project.Name);\n-            case Project.Qualifier is\n-               when Aggregate =>\n-                  Agg := Project.Aggregated_Projects;\n-                  while Agg /= null loop\n-                     Add_Mains_From_Project (Agg.Project, Agg.Tree);\n-                     Agg := Agg.Next;\n-                  end loop;\n-\n-               when others =>\n-                  List := Project.Mains;\n-                  if List /= Prj.Nil_String then\n-                     --  The attribute Main is not an empty list.\n-                     --  Get the mains in the list\n-\n-                     while List /= Prj.Nil_String loop\n-                        Element := Tree.Shared.String_Elements.Table (List);\n-                        Debug_Output (\"Add_Main\", Element.Value);\n-                        Add_Main (Name     => Get_Name_String (Element.Value),\n-                                  Index    => Element.Index,\n-                                  Location => Element.Location,\n-                                  Project  => Project,\n-                                  Tree     => Tree);\n-                        List := Element.Next;\n-                     end loop;\n-                  end if;\n-            end case;\n-         end Add_Mains_From_Project;\n-\n-      begin\n-         if Number_Of_Mains = 0 then\n-            Add_Mains_From_Project (Root_Project, Project_Tree);\n-         end if;\n+            if Number_Of_Mains (Tree) = 0\n+              and then Mains.Count_Of_Mains_With_No_Tree = 0\n+            then\n+               Debug_Output (\"Add_Mains_From_Project\", Project.Name);\n+               List := Project.Mains;\n+               if List /= Prj.Nil_String then\n+                  --  The attribute Main is not an empty list.\n+                  --  Get the mains in the list\n \n-         --  If there are mains, check that they are sources of the main\n-         --  project\n-\n-         if Mains.Number_Of_Mains > 0 then\n-            for J in Names.First .. Names.Last loop\n-               declare\n-                  File       : Main_Info := Names.Table (J);\n-                  Main_Id    : File_Name_Type := File.File;\n-                  Main       : constant String := Get_Name_String (Main_Id);\n-                  Project    : Project_Id;\n-                  Source     : Prj.Source_Id := No_Source;\n-                  Suffix     : File_Name_Type;\n-                  Iter       : Source_Iterator;\n-\n-               begin\n-                  if Base_Name (Main) /= Main then\n-                     if Is_Absolute_Path (Main) then\n-                        Main_Id := Create_Name (Base_Name (Main));\n+                  while List /= Prj.Nil_String loop\n+                     Element := Tree.Shared.String_Elements.Table (List);\n+                     Debug_Output (\"Add_Main\", Element.Value);\n \n-                     else\n+                     if Project.Library then\n                         Fail_Program\n-                          (Project_Tree,\n-                           \"mains cannot include directory information (\"\"\" &\n-                           Main & \"\"\")\");\n+                          (Tree,\n+                           \"cannot specify a main program \" &\n+                           \"for a library project file\");\n                      end if;\n-                  end if;\n-\n-                  --  If no project or tree was specified for the main, it came\n-                  --  from the command line. In this case, it needs to belong\n-                  --  to the root project.\n-                  --  Note that the assignments below will not modify inside\n-                  --  the table itself.\n-\n-                  if File.Project = null then\n-                     File.Project := Root_Project;\n-                  end if;\n-\n-                  if File.Tree = null then\n-                     File.Tree := Project_Tree;\n-                  end if;\n-\n-                  --  First, look for the main as specified.\n-\n-                  Source := Find_Source\n-                    (In_Tree   => File.Tree,\n-                     Project   => File.Project,\n-                     Base_Name => File.File,\n-                     Index     => File.Index);\n-\n-                  if Source = No_Source then\n-                     --  Now look for the main with a body suffix\n \n-                     declare\n-                        --  Main already has a canonical casing\n-                        Main : constant String := Get_Name_String (Main_Id);\n-                     begin\n-                        Project := File.Project;\n-                        while Source = No_Source\n-                          and then Project /= No_Project\n-                        loop\n-                           Iter := For_Each_Source (File.Tree, Project);\n-                           loop\n-                              Source := Prj.Element (Iter);\n-                              exit when Source = No_Source;\n-\n-                              --  Only consider bodies\n-\n-                              if Source.Kind = Impl then\n-                                 Get_Name_String (Source.File);\n-\n-                                 if Name_Len > Main'Length\n-                                   and then\n-                                     Name_Buffer (1 .. Main'Length) = Main\n-                                 then\n-                                    Suffix :=\n-                                      Source.Language\n-                                        .Config.Naming_Data.Body_Suffix;\n-\n-                                    exit when Suffix /= No_File and then\n-                                      Name_Buffer (Main'Length + 1 .. Name_Len)\n-                                      = Get_Name_String (Suffix);\n-                                 end if;\n-                              end if;\n-\n-                              Next (Iter);\n-                           end loop;\n+                     Add_Main (Name     => Get_Name_String (Element.Value),\n+                               Index    => Element.Index,\n+                               Location => Element.Location,\n+                               Project  => Project,\n+                               Tree     => Tree);\n+                     List := Element.Next;\n+                  end loop;\n+               end if;\n+            end if;\n \n-                           Project := Project.Extends;\n-                        end loop;\n-                     end;\n-                  end if;\n+            if Total_Errors_Detected > 0 then\n+               Fail_Program (Tree, \"problems with main sources\");\n+            end if;\n+         end Add_Mains_From_Project;\n \n-                  if Source /= No_Source then\n-                     Names.Table (J).File    := Source.File;\n-                     Names.Table (J).Project := File.Project;\n-                     Names.Table (J).Tree    := File.Tree;\n-                     Names.Table (J).Source  := Source;\n-\n-                  elsif File.Location /= No_Location then\n-                     --  If the main is declared in package Builder of the\n-                     --  main project, report an error. If the main is on\n-                     --  the command line, it may be a main from another\n-                     --  project, so do nothing: if the main does not exist\n-                     --  in another project, an error will be reported\n-                     --  later.\n-\n-                     Error_Msg_File_1 := Main_Id;\n-                     Error_Msg_Name_1 := Root_Project.Name;\n-                     Errutil.Error_Msg (\"{ is not a source of project %%\",\n-                                        File.Location);\n-                  end if;\n-               end;\n-            end loop;\n-         end if;\n+         procedure Fill_All is new For_Project_And_Aggregated\n+           (Add_Mains_From_Project);\n \n-         if Total_Errors_Detected > 0 then\n-            Fail_Program (Project_Tree, \"problems with main sources\");\n-         end if;\n+      begin\n+         Fill_All (Root_Project, Project_Tree);\n       end Fill_From_Project;\n \n       ---------------\n@@ -1488,9 +1550,13 @@ package body Makeutl is\n       -- Number_Of_Mains --\n       ---------------------\n \n-      function Number_Of_Mains return Natural is\n+      function Number_Of_Mains (Tree : Project_Tree_Ref) return Natural is\n       begin\n-         return Names.Last;\n+         if Tree = null then\n+            return Names.Last;\n+         else\n+            return Builder_Data (Tree).Number_Of_Mains;\n+         end if;\n       end Number_Of_Mains;\n \n       -----------\n@@ -2017,7 +2083,7 @@ package body Makeutl is\n          if Current_Verbosity = High then\n             Write_Str (\"Adding \"\"\");\n             Debug_Display (Source);\n-            Write_Line (\" to the queue\");\n+            Write_Line (\"\"\" to the queue\");\n          end if;\n \n          Q.Append (New_Val => (Info => Source, Processed => False));\n@@ -2344,55 +2410,80 @@ package body Makeutl is\n       ----------------------------\n \n       procedure Insert_Project_Sources\n-        (Project      : Project_Id;\n-         Project_Tree : Project_Tree_Ref;\n-         All_Projects : Boolean;\n-         Unit_Based   : Boolean)\n+        (Project        : Project_Id;\n+         Project_Tree   : Project_Tree_Ref;\n+         All_Projects   : Boolean;\n+         Unique_Compile : Boolean)\n       is\n-         Iter   : Source_Iterator;\n-         Source : Prj.Source_Id;\n-      begin\n-         Iter := For_Each_Source (Project_Tree);\n-         loop\n-            Source := Prj.Element (Iter);\n-            exit when Source = No_Source;\n-\n-            if Is_Compilable (Source)\n-              and then\n-                (All_Projects\n-                 or else Is_Extending (Project, Source.Project))\n-              and then not Source.Locally_Removed\n-              and then Source.Replaced_By = No_Source\n-              and then\n-                (not Source.Project.Externally_Built\n-                 or else\n-                   (Is_Extending (Project, Source.Project)\n-                    and then not Project.Externally_Built))\n-              and then Source.Kind /= Sep\n-              and then Source.Path /= No_Path_Information\n+         procedure Do_Insert (Project : Project_Id; Tree : Project_Tree_Ref);\n+         procedure Do_Insert (Project : Project_Id; Tree : Project_Tree_Ref) is\n+            Unit_Based : constant Boolean :=\n+              Unique_Compile\n+              or else not Builder_Data (Tree).Closure_Needed;\n+            --  When Unit_Based is True, put in the queue all compilable\n+            --  sources including the unit based (Ada) one. When Unit_Based is\n+            --  False, put the Ada sources only when they are in a library\n+            --  project.\n+\n+            Iter   : Source_Iterator;\n+            Source : Prj.Source_Id;\n+         begin\n+            --  Nothing to do when \"-u\" was specified and some files were\n+            --  specified on the command line\n+\n+            if Unique_Compile\n+              and then Mains.Number_Of_Mains (Tree) > 0\n             then\n-               if Source.Kind = Impl\n-                 or else (Source.Unit /= No_Unit_Index\n-                          and then Source.Kind = Spec\n-                          and then (Other_Part (Source) = No_Source\n-                                    or else\n-                                      Other_Part (Source).Locally_Removed))\n+               return;\n+            end if;\n+\n+            Iter := For_Each_Source (Tree);\n+            loop\n+               Source := Prj.Element (Iter);\n+               exit when Source = No_Source;\n+\n+               if Is_Compilable (Source)\n+                 and then\n+                   (All_Projects\n+                    or else Is_Extending (Project, Source.Project))\n+                 and then not Source.Locally_Removed\n+                 and then Source.Replaced_By = No_Source\n+                 and then\n+                   (not Source.Project.Externally_Built\n+                    or else\n+                      (Is_Extending (Project, Source.Project)\n+                       and then not Project.Externally_Built))\n+                 and then Source.Kind /= Sep\n+                 and then Source.Path /= No_Path_Information\n                then\n-                  if (Unit_Based\n-                      or else Source.Unit = No_Unit_Index\n-                      or else Source.Project.Library)\n-                    and then not Is_Subunit (Source)\n+                  if Source.Kind = Impl\n+                    or else (Source.Unit /= No_Unit_Index\n+                             and then Source.Kind = Spec\n+                             and then (Other_Part (Source) = No_Source\n+                                       or else\n+                                         Other_Part (Source).Locally_Removed))\n                   then\n-                     Queue.Insert\n-                       (Source => (Format => Format_Gprbuild,\n-                                   Tree   => Project_Tree,\n-                                   Id     => Source));\n+                     if (Unit_Based\n+                         or else Source.Unit = No_Unit_Index\n+                         or else Source.Project.Library)\n+                       and then not Is_Subunit (Source)\n+                     then\n+                        Queue.Insert\n+                          (Source => (Format => Format_Gprbuild,\n+                                      Tree   => Tree,\n+                                      Id     => Source));\n+                     end if;\n                   end if;\n                end if;\n-            end if;\n \n-            Next (Iter);\n-         end loop;\n+               Next (Iter);\n+            end loop;\n+         end Do_Insert;\n+\n+         procedure Insert_All is new For_Project_And_Aggregated (Do_Insert);\n+\n+      begin\n+         Insert_All (Project, Project_Tree);\n       end Insert_Project_Sources;\n \n       -------------------------------\n@@ -2480,4 +2571,97 @@ package body Makeutl is\n       end Insert_Withed_Sources_For;\n    end Queue;\n \n+   ----------\n+   -- Free --\n+   ----------\n+\n+   procedure Free (Data : in out Builder_Project_Tree_Data) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Binding_Data_Record, Binding_Data);\n+\n+      TmpB, Binding : Binding_Data := Data.Binding;\n+   begin\n+      while Binding /= null loop\n+         TmpB := Binding.Next;\n+         Unchecked_Free (Binding);\n+         Binding := TmpB;\n+      end loop;\n+   end Free;\n+\n+   ------------------\n+   -- Builder_Data --\n+   ------------------\n+\n+   function Builder_Data\n+     (Tree : Project_Tree_Ref) return Builder_Data_Access\n+   is\n+   begin\n+      if Tree.Appdata = null then\n+         Tree.Appdata := new Builder_Project_Tree_Data;\n+      end if;\n+\n+      return Builder_Data_Access (Tree.Appdata);\n+   end Builder_Data;\n+\n+   --------------------------------\n+   -- Compute_Compilation_Phases --\n+   --------------------------------\n+\n+   procedure Compute_Compilation_Phases\n+     (Tree                  : Project_Tree_Ref;\n+      Root_Project          : Project_Id;\n+      Option_Unique_Compile : Boolean := False;   --  Was \"-u\" specified ?\n+      Option_Compile_Only   : Boolean := False;   --  Was \"-c\" specified ?\n+      Option_Bind_Only      : Boolean := False;\n+      Option_Link_Only      : Boolean := False)\n+   is\n+      procedure Do_Compute (Project : Project_Id; Tree : Project_Tree_Ref);\n+\n+      procedure Do_Compute (Project : Project_Id; Tree : Project_Tree_Ref) is\n+         Data       : constant Builder_Data_Access := Builder_Data (Tree);\n+         All_Phases : constant Boolean :=\n+           not Option_Compile_Only\n+           and then not Option_Bind_Only\n+           and then not Option_Link_Only;\n+         --  Whether the command line asked for all three phases. Depending on\n+         --  the project settings, we might still disable some of the phases.\n+\n+         Has_Mains : constant Boolean := Data.Number_Of_Mains > 0;\n+         --  Whether there are some main units defined for this project tree\n+         --  (either from one of the projects, or from the command line)\n+\n+      begin\n+         if Option_Unique_Compile then\n+            --  If -u or -U is specified on the command line, disregard any -c,\n+            --  -b or -l switch: only perform compilation.\n+\n+            Data.Closure_Needed   := False;\n+            Data.Need_Compilation := True;\n+            Data.Need_Binding     := False;\n+            Data.Need_Linking     := False;\n+\n+         else\n+            Data.Closure_Needed   := Has_Mains;\n+            Data.Need_Compilation := All_Phases or Option_Compile_Only;\n+            Data.Need_Binding     := All_Phases or Option_Bind_Only;\n+            Data.Need_Linking     := (All_Phases or Option_Link_Only)\n+              and then Has_Mains;\n+         end if;\n+\n+         if Current_Verbosity = High then\n+            Debug_Output (\"Compilation phases: \"\n+                          & \" compile=\" & Data.Need_Compilation'Img\n+                          & \" bind=\" & Data.Need_Binding'Img\n+                          & \" link=\" & Data.Need_Linking'Img\n+                          & \" closure=\" & Data.Closure_Needed'Img\n+                          & \" mains=\" & Data.Number_Of_Mains'Img,\n+                          Project.Name);\n+         end if;\n+      end Do_Compute;\n+\n+      procedure Compute_All is new For_Project_And_Aggregated (Do_Compute);\n+   begin\n+      Compute_All (Root_Project, Tree);\n+   end Compute_Compilation_Phases;\n+\n end Makeutl;"}, {"sha": "fa3ba0314466a968a731c0358222027a240cc016", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "patch": "@@ -233,6 +233,66 @@ package Makeutl is\n    --  according to Fatal.\n    --  This properly removes all temporary files\n \n+   -----------------------\n+   -- Project_Tree data --\n+   -----------------------\n+   --  The following types are specific to builders, and associated with each\n+   --  of the loaded project trees.\n+\n+   type Binding_Data_Record;\n+   type Binding_Data is access Binding_Data_Record;\n+   type Binding_Data_Record is record\n+      Language           : Language_Ptr;\n+      Language_Name      : Name_Id;\n+      Binder_Driver_Name : File_Name_Type;\n+      Binder_Driver_Path : String_Access;\n+      Binder_Prefix      : Name_Id;\n+      Next               : Binding_Data;\n+   end record;\n+   --  Data for a language that have a binder driver\n+\n+   type Builder_Project_Tree_Data is new Project_Tree_Appdata with record\n+      Binding : Binding_Data;\n+\n+      There_Are_Binder_Drivers : Boolean := False;\n+      --  True when there is a binder driver. Set by Get_Configuration when\n+      --  an attribute Language_Processing'Binder_Driver is declared.\n+      --  Reset to False if there are no sources of the languages with binder\n+      --  drivers.\n+\n+      Number_Of_Mains : Natural := 0;\n+      --  Number of main units in this project tree\n+\n+      Closure_Needed : Boolean := False;\n+      --  If True, we need to add the closure of the file we just compiled to\n+      --  the queue. If False, it is assumed that all files are already on the\n+      --  queue so we do not waste time computing the closure.\n+\n+      Need_Compilation : Boolean := True;\n+      Need_Binding     : Boolean := True;\n+      Need_Linking     : Boolean := True;\n+      --  Which of the compilation phases are needed for this project tree.\n+   end record;\n+   type Builder_Data_Access is access all Builder_Project_Tree_Data;\n+\n+   procedure Free (Data : in out Builder_Project_Tree_Data);\n+   --  Free all memory allocated for Data\n+\n+   function Builder_Data (Tree : Project_Tree_Ref) return Builder_Data_Access;\n+   --  Return (allocate if needed) tree-specific data\n+\n+   procedure Compute_Compilation_Phases\n+     (Tree                  : Project_Tree_Ref;\n+      Root_Project          : Project_Id;\n+      Option_Unique_Compile : Boolean := False;   --  Was \"-u\" specified ?\n+      Option_Compile_Only   : Boolean := False;   --  Was \"-c\" specified ?\n+      Option_Bind_Only      : Boolean := False;\n+      Option_Link_Only      : Boolean := False);\n+   --  Compute which compilation phases will be needed for Tree. This also\n+   --  does the computation for aggregated trees.\n+   --  This also check whether we'll need to check the closure of the files we\n+   --  have just compiled to add them to the queue.\n+\n    -----------\n    -- Mains --\n    -----------\n@@ -295,16 +355,20 @@ package Makeutl is\n       --  Moves the cursor forward and returns the new current entry.\n       --  Returns No_File_And_Loc if there are no more mains in the table.\n \n-      function Number_Of_Mains return Natural;\n-      --  Returns the number of mains in the table.\n+      function Number_Of_Mains (Tree : Project_Tree_Ref) return Natural;\n+      --  Returns the number of mains in this project tree (if Tree is null,\n+      --  it returns the total number of project trees)\n \n       procedure Fill_From_Project\n         (Root_Project : Project_Id;\n          Project_Tree : Project_Tree_Ref);\n       --  If no main was already added (presumably from the command line), add\n       --  the main units from root_project (or in the case of an aggregate\n       --  project from all the aggregated projects).\n-      --\n+\n+      procedure Complete_Mains\n+        (Root_Project : Project_Id;\n+         Project_Tree : Project_Tree_Ref);\n       --  If some main units were already added from the command line, check\n       --  that they all belong to the root project, and that they are full\n       --  full paths rather than (partial) base names (e.g. no body suffix was\n@@ -382,16 +446,19 @@ package Makeutl is\n       --  stored in the corresponding Source_Id for later reuse by the binder.\n \n       procedure Insert_Project_Sources\n-        (Project      : Project_Id;\n-         Project_Tree : Project_Tree_Ref;\n-         All_Projects : Boolean;\n-         Unit_Based   : Boolean);\n+        (Project        : Project_Id;\n+         Project_Tree   : Project_Tree_Ref;\n+         All_Projects   : Boolean;\n+         Unique_Compile : Boolean);\n       --  Insert all the compilable sources of the project in the queue. If\n       --  All_Project is true, then all sources from imported projects are also\n       --  inserted.\n-      --  When Unit_Based is True, put in the queue all compilable sources\n-      --  including the unit based (Ada) one. When Unit_Based is False, put the\n-      --  Ada sources only when they are in a library project.\n+      --  Unique_Compile should be true if \"-u\" was specified on the command\n+      --  line: if True and some files were given on the command line), only\n+      --  those files will be compiled (so Insert_Project_Sources will do\n+      --  nothing). If True and no file was specified on the command line, all\n+      --  files of the project(s) will be compiled.\n+      --  This procedure also processed aggregated projects.\n \n       procedure Insert_Withed_Sources_For\n         (The_ALI               : ALI.ALI_Id;"}, {"sha": "8129925d964a79dfbbbcebe65f33de01235891dd", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "patch": "@@ -1508,6 +1508,27 @@ package body Prj is\n       null;\n    end Free;\n \n+   --------------------------------\n+   -- For_Project_And_Aggregated --\n+   --------------------------------\n+\n+   procedure For_Project_And_Aggregated\n+     (Root_Project : Project_Id;\n+      Root_Tree    : Project_Tree_Ref)\n+   is\n+      Agg : Aggregated_Project_List;\n+   begin\n+      Action (Root_Project, Root_Tree);\n+\n+      if Root_Project.Qualifier = Aggregate then\n+         Agg := Root_Project.Aggregated_Projects;\n+         while Agg /= null loop\n+            For_Project_And_Aggregated (Agg.Project, Agg.Tree);\n+            Agg := Agg.Next;\n+         end loop;\n+      end if;\n+   end For_Project_And_Aggregated;\n+\n begin\n    --  Make sure that the standard config and user project file extensions are\n    --  compatible with canonical case file naming."}, {"sha": "dae62e73cc255f43db159d6f230251423a80a0f1", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316d9d4f9f86acf8fd0e4b22a80d0134c876502a/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=316d9d4f9f86acf8fd0e4b22a80d0134c876502a", "patch": "@@ -1523,6 +1523,14 @@ package Prj is\n    --  A table that associates a project to a boolean. This is used to detect\n    --  whether a project was already processed for instance.\n \n+   generic\n+      with procedure Action (Project : Project_Id; Tree    : Project_Tree_Ref);\n+   procedure For_Project_And_Aggregated\n+     (Root_Project : Project_Id;\n+      Root_Tree    : Project_Tree_Ref);\n+   --  Execute Action for Root_Project and all its aggregated projects\n+   --  recursively.\n+\n    generic\n       type State is limited private;\n       with procedure Action"}]}