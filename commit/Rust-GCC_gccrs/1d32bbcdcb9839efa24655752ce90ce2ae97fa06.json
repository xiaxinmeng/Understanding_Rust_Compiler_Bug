{"sha": "1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQzMmJiY2RjYjk4MzllZmEyNDY1NTc1MmNlOTBjZTJhZTk3ZmEwNg==", "commit": {"author": {"name": "Basile Starynkevitch", "email": "basile@starynkevitch.net", "date": "2010-10-18T06:05:28Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-10-18T06:05:28Z"}, "message": "gengtype.c (verbosity_level): Added variable.\n\n2010-10-18  Basile Starynkevitch  <basile@starynkevitch.net>\n\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\n\t* gengtype.c (verbosity_level): Added variable.\n\t(set_gc_used): Count variables for verbosity.\n\t(close_output_files): Backing up files, counting written ones\n\tverbosily.\n\t(write_types): Count emitted functions for verbosity. Added\n\tdebug messages.\n\t(write_enum_defn): Count structures for verbosity. Added debug\n\tmessages.\n\t(gengtype_long_options): Added \"verbose\" & \"backupdir\".\n\t(print_usage): Ditto.\n\t(main): Verbose display of parsed files.\n\n\t* gengtype.h (verbosity_level): Added declaration.\n\n\nCo-Authored-By: Jeremie Salvucci <jeremie.salvucci@free.fr>\n\nFrom-SVN: r165609", "tree": {"sha": "d85a460fd85c97e3d628d911811ed21f00a79509", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d85a460fd85c97e3d628d911811ed21f00a79509"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/comments", "author": {"login": "bstarynk", "id": 90412, "node_id": "MDQ6VXNlcjkwNDEy", "avatar_url": "https://avatars.githubusercontent.com/u/90412?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstarynk", "html_url": "https://github.com/bstarynk", "followers_url": "https://api.github.com/users/bstarynk/followers", "following_url": "https://api.github.com/users/bstarynk/following{/other_user}", "gists_url": "https://api.github.com/users/bstarynk/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstarynk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstarynk/subscriptions", "organizations_url": "https://api.github.com/users/bstarynk/orgs", "repos_url": "https://api.github.com/users/bstarynk/repos", "events_url": "https://api.github.com/users/bstarynk/events{/privacy}", "received_events_url": "https://api.github.com/users/bstarynk/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dad2226856d96ee6c0424ec4b908e39356a6e5b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad2226856d96ee6c0424ec4b908e39356a6e5b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad2226856d96ee6c0424ec4b908e39356a6e5b5"}], "stats": {"total": 148, "additions": 141, "deletions": 7}, "files": [{"sha": "ff092e721ef3181ef6b4bb5bce7f233174780830", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "patch": "@@ -1,3 +1,20 @@\n+2010-10-18  Basile Starynkevitch  <basile@starynkevitch.net>\n+\t    Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\n+\t* gengtype.c (verbosity_level): Added variable.\n+\t(set_gc_used): Count variables for verbosity.\n+\t(close_output_files): Backing up files, counting written ones\n+\tverbosily.\n+\t(write_types): Count emitted functions for verbosity. Added\n+\tdebug messages.\n+\t(write_enum_defn): Count structures for verbosity. Added debug\n+\tmessages.\n+\t(gengtype_long_options): Added \"verbose\" & \"backupdir\".\n+\t(print_usage): Ditto.\n+\t(main): Verbose display of parsed files.\n+\n+\t* gengtype.h (verbosity_level): Added declaration.\n+\n 2010-10-18  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* gengtype.c (parse_program_options): Added allocation of"}, {"sha": "38189ae194ce199d263f4d0d4ceed4e3c53e2913", "filename": "gcc/gengtype.c", "status": "modified", "additions": 121, "deletions": 7, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "patch": "@@ -163,6 +163,15 @@ const char *write_state_filename;\n int do_dump;\n int do_debug;\n \n+/* Level for verbose messages.  */\n+int verbosity_level;\n+\n+/* The backup directory should be in the same file system as the\n+   generated files, otherwise the rename(2) system call would fail.\n+   If NULL, no backup is made when overwriting a generated file.  */\n+static const char* backup_dir;\t/* (-B) program option.  */\n+\n+\n static outf_p create_file (const char *, const char *);\n \n static const char *get_file_basename (const char *);\n@@ -1515,9 +1524,15 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM])\n static void\n set_gc_used (pair_p variables)\n {\n+  int nbvars = 0;\n   pair_p p;\n   for (p = variables; p; p = p->next)\n-    set_gc_used_type (p->type, GC_USED, NULL);\n+    {\n+      set_gc_used_type (p->type, GC_USED, NULL);\n+      nbvars++;\n+    };\n+  if (verbosity_level >= 2)\n+    printf (\"%s used %d GTY-ed variables\\n\", progname, nbvars);\n }\n \f\n /* File mapping routines.  For each input file, there is one output .c file\n@@ -1907,25 +1922,54 @@ is_file_equal (outf_p of)\n static void\n close_output_files (void)\n {\n+  int nbwrittenfiles = 0;\n   outf_p of;\n \n   for (of = output_files; of; of = of->next)\n     {\n \n       if (!is_file_equal (of))\n \t{\n-\t  FILE *newfile = fopen (of->name, \"w\");\n+\t  FILE *newfile = NULL;\n+\t  char *backupname = NULL;\n+\t  /* Back up the old version of the output file gt-FOO.c as\n+\t     BACKUPDIR/gt-FOO.c~ if we have a backup directory.  */\n+\t  if (backup_dir)\n+\t    {\n+\t      backupname = concat (backup_dir, \"/\",\n+\t\t\t\t   lbasename (of->name), \"~\", NULL);\n+\t      if (!access (of->name, F_OK) && rename (of->name, backupname))\n+\t\tfatal (\"failed to back up %s as %s: %s\",\n+\t\t       of->name, backupname, xstrerror (errno));\n+\t    }\n+\n+\t  newfile = fopen (of->name, \"w\");\n \t  if (newfile == NULL)\n \t    fatal (\"opening output file %s: %s\", of->name, xstrerror (errno));\n \t  if (fwrite (of->buf, 1, of->bufused, newfile) != of->bufused)\n \t    fatal (\"writing output file %s: %s\", of->name, xstrerror (errno));\n \t  if (fclose (newfile) != 0)\n \t    fatal (\"closing output file %s: %s\", of->name, xstrerror (errno));\n+\t  nbwrittenfiles++;\n+\t  if (verbosity_level >= 2 && backupname)\n+\t    printf (\"%s wrote #%-3d %s backed-up in %s\\n\",\n+\t\t    progname, nbwrittenfiles, of->name, backupname);\n+\t  else if (verbosity_level >= 1)\n+\t    printf (\"%s write #%-3d %s\\n\", progname, nbwrittenfiles, of->name);\n+\t  free (backupname);\n+\t}\n+      else \n+\t{ \n+\t  /* output file remains unchanged. */\n+\t  if (verbosity_level >= 2)\n+\t    printf (\"%s keep %s\\n\", progname, of->name);\n \t}\n       free (of->buf);\n       of->buf = NULL;\n       of->bufused = of->buflength = 0;\n     }\n+  if (verbosity_level >= 1)\n+    printf (\"%s wrote %d files.\\n\", progname, nbwrittenfiles);\n }\n \f\n struct flist\n@@ -2801,6 +2845,7 @@ static void\n write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t     const struct write_types_data *wtd)\n {\n+  int nbfun = 0;\t\t/* Count the emitted functions.  */\n   type_p s;\n \n   oprintf (output_header, \"\\n/* %s*/\\n\", wtd->comment);\n@@ -2890,11 +2935,29 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t  {\n \t    type_p ss;\n \t    for (ss = s->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_func_for_structure (s, ss, NULL, wtd);\n+\t      {\n+\t\tnbfun++;\n+\t\tDBGPRINTF (\"writing func #%d lang_struct ss @ %p '%s'\",\n+\t\t\t   nbfun, (void*) ss, ss->u.s.tag);\n+\t\twrite_func_for_structure (s, ss, NULL, wtd);\n+\t      }\n \t  }\n \telse\n-\t  write_func_for_structure (s, s, NULL, wtd);\n+\t  {\n+\t    nbfun++;\n+\t    DBGPRINTF (\"writing func #%d struct s @ %p '%s'\",\n+\t\t       nbfun, (void*) s, s->u.s.tag);\n+\t    write_func_for_structure (s, s, NULL, wtd);\n+\t  }\n       }\n+    else\n+      {\n+\t/* Structure s is not possibly pointed to, so can be ignored.  */\n+\tDBGPRINTF (\"ignored s @ %p  '%s' gc_used#%d\",\n+\t\t   (void*)s,  s->u.s.tag,\n+\t\t   (int) s->gc_used);\n+      }\n+\n   for (s = param_structs; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO)\n       {\n@@ -2906,11 +2969,30 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n \t  {\n \t    type_p ss;\n \t    for (ss = stru->u.s.lang_struct; ss; ss = ss->next)\n-\t      write_func_for_structure (s, ss, param, wtd);\n+\t      {\n+\t\tnbfun++;\n+\t\tDBGPRINTF (\"writing func #%d param lang_struct ss @ %p '%s'\",\n+\t\t\t   nbfun, (void*) ss,  ss->u.s.tag);\n+\t\twrite_func_for_structure (s, ss, param, wtd);\n+\t      }\n \t  }\n \telse\n-\t  write_func_for_structure (s, stru, param, wtd);\n+\t  {\n+\t    nbfun++;\n+\t    DBGPRINTF (\"writing func #%d param struct s @ %p stru @ %p '%s'\",\n+\t\t       nbfun, (void*) s,\n+\t\t       (void*) stru,  stru->u.s.tag);\n+\t    write_func_for_structure (s, stru, param, wtd);\n+\t  }\n+      }\n+    else\n+      { \n+\t/* Param structure s is not pointed to, so should be ignored.  */\n+\tDBGPRINTF (\"ignored s @ %p\", (void*)s);\n       }\n+  if (verbosity_level >= 2)\n+    printf (\"%s emitted %d routines for %s\\n\",\n+\t    progname, nbfun, wtd->comment);\n }\n \n static const struct write_types_data ggc_wtd = {\n@@ -3100,6 +3182,8 @@ static void\n write_enum_defn (type_p structures, type_p param_structs)\n {\n   type_p s;\n+  int nbstruct = 0;\n+  int nbparamstruct = 0;\n \n   if (!header_file)\n     return;\n@@ -3108,19 +3192,32 @@ write_enum_defn (type_p structures, type_p param_structs)\n   for (s = structures; s; s = s->next)\n     if (USED_BY_TYPED_GC_P (s))\n       {\n+\tnbstruct++;\n+\tDBGPRINTF (\"write_enum_defn s @ %p nbstruct %d\",\n+\t\t   (void*) s, nbstruct);\n+\tif (UNION_OR_STRUCT_P (s))\n+\t  DBGPRINTF (\"write_enum_defn s %p #%d is unionorstruct tagged %s\",\n+\t\t     (void*) s, nbstruct, s->u.s.tag);\n \toprintf (header_file, \" gt_ggc_e_\");\n \toutput_mangled_typename (header_file, s);\n \toprintf (header_file, \",\\n\");\n       }\n   for (s = param_structs; s; s = s->next)\n     if (s->gc_used == GC_POINTED_TO)\n       {\n+\tnbparamstruct++;\n+\tDBGPRINTF (\"write_enum_defn s %p nbparamstruct %d\",\n+\t\t   (void*) s, nbparamstruct);\n \toprintf (header_file, \" gt_e_\");\n \toutput_mangled_typename (header_file, s);\n \toprintf (header_file, \",\\n\");\n       }\n   oprintf (header_file, \" gt_types_enum_last\\n\");\n   oprintf (header_file, \"};\\n\");\n+  if (verbosity_level >= 2)\n+    printf (\"%s handled %d GTY-ed structures & %d parameterized structures.\\n\",\n+\t    progname, nbstruct, nbparamstruct);\n+\n }\n \n /* Might T contain any non-pointer elements?  */\n@@ -4289,10 +4386,12 @@ dump_everything (void)\n static const struct option gengtype_long_options[] = {\n   {\"help\", no_argument, NULL, 'h'},\n   {\"version\", no_argument, NULL, 'V'},\n+  {\"verbose\", no_argument, NULL, 'v'},\n   {\"dump\", no_argument, NULL, 'd'},\n   {\"debug\", no_argument, NULL, 'D'},\n   {\"plugin\", required_argument, NULL, 'P'},\n   {\"srcdir\", required_argument, NULL, 'S'},\n+  {\"backupdir\", required_argument, NULL, 'B'},\n   {\"inputs\", required_argument, NULL, 'I'},\n   {\"read-state\", required_argument, NULL, 'r'},\n   {\"write-state\", required_argument, NULL, 'w'},\n@@ -4309,11 +4408,14 @@ print_usage (void)\n   printf (\"\\t -D | --debug \"\n \t  \" \\t# Give debug output to debug %s itself.\\n\", progname);\n   printf (\"\\t -V | --version \" \" \\t# Give version information.\\n\");\n+  printf (\"\\t -v | --verbose  \\t# Increase verbosity.  Can be given several times.\\n\");\n   printf (\"\\t -d | --dump \" \" \\t# Dump state for debugging.\\n\");\n   printf (\"\\t -P | --plugin <output-file> <plugin-src> ... \"\n \t  \" \\t# Generate for plugin.\\n\");\n   printf (\"\\t -S | --srcdir <GCC-directory> \"\n \t  \" \\t# Specify the GCC source directory.\\n\");\n+  printf (\"\\t -B | --backupdir <directory> \"\n+\t  \" \\t# Specify the backup directory for updated files.\\n\");\n   printf (\"\\t -I | --inputs <input-list> \"\n \t  \" \\t# Specify the file with source files list.\\n\");\n   printf (\"\\t -w | --write-state <state-file> \" \" \\t# Write a state file.\\n\");\n@@ -4332,7 +4434,7 @@ static void\n parse_program_options (int argc, char **argv)\n {\n   int opt = -1;\n-  while ((opt = getopt_long (argc, argv, \"hVdP:S:I:w:r:D\",\n+  while ((opt = getopt_long (argc, argv, \"hVvdP:S:B:I:w:r:D\",\n \t\t\t     gengtype_long_options, NULL)) >= 0)\n     {\n       switch (opt)\n@@ -4349,6 +4451,9 @@ parse_program_options (int argc, char **argv)\n \tcase 'D':\t\t/* --debug */\n \t  do_debug = 1;\n \t  break;\n+\tcase 'v':\t\t/* --verbose */\n+\t  verbosity_level++;\n+\t  break;\n \tcase 'P':\t\t/* --plugin */\n \t  if (optarg)\n \t    plugin_output_filename = optarg;\n@@ -4362,6 +4467,12 @@ parse_program_options (int argc, char **argv)\n \t    fatal (\"missing source directory\");\n \t  srcdir_len = strlen (srcdir);\n \t  break;\n+\tcase 'B':\t\t/* --backupdir */\n+\t  if (optarg)\n+\t    backup_dir = optarg;\n+\t  else\n+\t    fatal (\"missing backup directory\");\n+\t  break;\n \tcase 'I':\t\t/* --inputs */\n \t  if (optarg)\n \t    inputlist = optarg;\n@@ -4470,6 +4581,9 @@ main (int argc, char **argv)\n \t  parse_file (gt_files[i]);\n \t  DBGPRINTF (\"parsed file #%d %s\", (int) i, gt_files[i]);\n \t}\n+      if (verbosity_level >= 1)\n+\tprintf (\"%s parsed %d files\\n\", progname, (int) num_gt_files);\n+\n       DBGPRINT_COUNT_TYPE (\"structures after parsing\", structures);\n       DBGPRINT_COUNT_TYPE (\"param_structs after parsing\", param_structs);\n "}, {"sha": "968288d2ff8006c5135d6dbd706a990c22ba2f41", "filename": "gcc/gengtype.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d32bbcdcb9839efa24655752ce90ce2ae97fa06/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=1d32bbcdcb9839efa24655752ce90ce2ae97fa06", "patch": "@@ -160,6 +160,9 @@ enum\n   };\n \n \n+/* Level for verbose messages, e.g. output file generation...  */\n+extern int verbosity_level;\t/* (-v) program argument.  */\n+\n /* For debugging purposes we provide two flags.  */\n \n /* Dump everything to understand gengtype's state. Might be useful to"}]}