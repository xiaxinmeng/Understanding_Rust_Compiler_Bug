{"sha": "17663caca44a5be8fd9d9de7eab3190c40bc594a", "node_id": "C_kwDOANBUbNoAKDE3NjYzY2FjYTQ0YTViZThmZDlkOWRlN2VhYjMxOTBjNDBiYzU5NGE", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-28T16:06:53Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:25Z"}, "message": "gccrs constant folding port: ports over\n- more cases into constexpr_expression.\n- cxx_eval_condtional_expression.\n\nNote that COND_EXPR and IF_STMT are defined in cp-tree.def\n\nAlso renames constexpr_expression to eval_constant_expression.\n\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "44beb575e37f47aa2b5f0771fb1a6e7debc24a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44beb575e37f47aa2b5f0771fb1a6e7debc24a05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17663caca44a5be8fd9d9de7eab3190c40bc594a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17663caca44a5be8fd9d9de7eab3190c40bc594a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17663caca44a5be8fd9d9de7eab3190c40bc594a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17663caca44a5be8fd9d9de7eab3190c40bc594a/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4e80fd645a9b4cac48957283e820f23d6e18aab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e80fd645a9b4cac48957283e820f23d6e18aab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e80fd645a9b4cac48957283e820f23d6e18aab"}], "stats": {"total": 161, "additions": 125, "deletions": 36}, "files": [{"sha": "6c3fedffc518245aa08d81c00e8bfd19d712409b", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 125, "deletions": 36, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17663caca44a5be8fd9d9de7eab3190c40bc594a/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17663caca44a5be8fd9d9de7eab3190c40bc594a/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=17663caca44a5be8fd9d9de7eab3190c40bc594a", "patch": "@@ -332,8 +332,8 @@ uid_sensitive_constexpr_evaluation_checker::evaluation_restricted_p () const\n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree\n-cxx_eval_constant_expression (const constexpr_ctx *, tree, bool, bool *, bool *,\n-\t\t\t      tree * = NULL);\n+constexp_expression (const constexpr_ctx *, tree, bool, bool *, bool *,\n+\t\t     tree * = NULL);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n@@ -459,8 +459,8 @@ static void\n non_const_var_error (location_t loc, tree r);\n \n static tree\n-constexpr_expression (const constexpr_ctx *ctx, tree, bool, bool *, bool *,\n-\t\t      tree * = NULL);\n+eval_constant_expression (const constexpr_ctx *ctx, tree, bool, bool *, bool *,\n+\t\t\t  tree * = NULL);\n \n static tree\n constexpr_fn_retval (const constexpr_ctx *ctx, tree r);\n@@ -483,6 +483,11 @@ eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n static tree\n extract_string_elt (tree string, unsigned chars_per_elt, unsigned index);\n \n+static tree\n+eval_conditional_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t\t     bool *non_constant_p, bool *overflow_p,\n+\t\t\t     tree *jump_target);\n+\n /* Variables and functions to manage constexpr call expansion context.\n    These do not need to be marked for PCH or GC.  */\n \n@@ -543,8 +548,8 @@ fold_expr (tree expr)\n   bool non_constant_p = false;\n   bool overflow_p = false;\n \n-  tree folded\n-    = constexpr_expression (&ctx, expr, false, &non_constant_p, &overflow_p);\n+  tree folded = eval_constant_expression (&ctx, expr, false, &non_constant_p,\n+\t\t\t\t\t  &overflow_p);\n   rust_assert (folded != NULL_TREE);\n \n   // more logic here to possibly port\n@@ -553,9 +558,9 @@ fold_expr (tree expr)\n }\n \n static tree\n-constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n-\t\t      bool *non_constant_p, bool *overflow_p,\n-\t\t      tree *jump_target /* = NULL */)\n+eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t\t  bool *non_constant_p, bool *overflow_p,\n+\t\t\t  tree *jump_target /* = NULL */)\n {\n   location_t loc = EXPR_LOCATION (t);\n \n@@ -671,8 +676,8 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \n     case RETURN_EXPR:\n       rust_assert (TREE_OPERAND (t, 0) != NULL_TREE);\n-      r = constexpr_expression (ctx, TREE_OPERAND (t, 0), false, non_constant_p,\n-\t\t\t\toverflow_p);\n+      r = eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n+\t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n     case MODIFY_EXPR:\n@@ -686,8 +691,8 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t\t  jump_target);\n \n     case BIND_EXPR:\n-      return constexpr_expression (ctx, BIND_EXPR_BODY (t), lval,\n-\t\t\t\t   non_constant_p, overflow_p, jump_target);\n+      return eval_constant_expression (ctx, BIND_EXPR_BODY (t), lval,\n+\t\t\t\t       non_constant_p, overflow_p, jump_target);\n \n     case RESULT_DECL:\n       if (lval)\n@@ -711,8 +716,8 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \tr = *p;\n       else\n \t{\n-\t  r = constexpr_expression (ctx, TREE_OPERAND (t, 0), false,\n-\t\t\t\t    non_constant_p, overflow_p);\n+\t  r = eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n+\t\t\t\t\tnon_constant_p, overflow_p);\n \t  if (*non_constant_p)\n \t    break;\n \t  ctx->global->values.put (t, r);\n@@ -721,6 +726,45 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t}\n       break;\n \n+    case COND_EXPR:\n+    case IF_STMT:\n+      if (jump_target && *jump_target)\n+\t{\n+\t  tree orig_jump = *jump_target;\n+\t  tree arg = ((TREE_CODE (t) != IF_STMT || TREE_OPERAND (t, 1))\n+\t\t\t? TREE_OPERAND (t, 1)\n+\t\t\t: void_node);\n+\t  /* When jumping to a label, the label might be either in the\n+\t     then or else blocks, so process then block first in skipping\n+\t     mode first, and if we are still in the skipping mode at its end,\n+\t     process the else block too.  */\n+\t  r = eval_constant_expression (ctx, arg, lval, non_constant_p,\n+\t\t\t\t\toverflow_p, jump_target);\n+\t  /* It's possible that we found the label in the then block.  But\n+\t     it could have been followed by another jumping statement, e.g.\n+\t     say we're looking for case 1:\n+\t      if (cond)\n+\t\t{\n+\t\t  // skipped statements\n+\t\t  case 1:; // clears up *jump_target\n+\t\t  return 1; // and sets it to a RETURN_EXPR\n+\t\t}\n+\t      else { ... }\n+\t     in which case we need not go looking to the else block.\n+\t     (goto is not allowed in a constexpr function.)  */\n+\t  if (*jump_target == orig_jump)\n+\t    {\n+\t      arg = ((TREE_CODE (t) != IF_STMT || TREE_OPERAND (t, 2))\n+\t\t       ? TREE_OPERAND (t, 2)\n+\t\t       : void_node);\n+\t      r = eval_constant_expression (ctx, arg, lval, non_constant_p,\n+\t\t\t\t\t    overflow_p, jump_target);\n+\t    }\n+\t  break;\n+\t}\n+      r = eval_conditional_expression (ctx, t, lval, non_constant_p, overflow_p,\n+\t\t\t\t       jump_target);\n+      break;\n     default:\n       break;\n     }\n@@ -890,8 +934,8 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t stored in, so that any side-effects happen first.  */\n       if (!SCALAR_TYPE_P (type))\n \tnew_ctx.ctor = new_ctx.object = NULL_TREE;\n-      init = constexpr_expression (&new_ctx, init, false, non_constant_p,\n-\t\t\t\t   overflow_p);\n+      init = eval_constant_expression (&new_ctx, init, false, non_constant_p,\n+\t\t\t\t       overflow_p);\n       if (*non_constant_p)\n \treturn t;\n     }\n@@ -902,8 +946,8 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       /* If we want to return a reference to the target, we need to evaluate it\n \t as a whole; otherwise, only evaluate the innermost piece to avoid\n \t building up unnecessary *_REFs.  */\n-      target\n-\t= constexpr_expression (ctx, target, true, non_constant_p, overflow_p);\n+      target = eval_constant_expression (ctx, target, true, non_constant_p,\n+\t\t\t\t\t overflow_p);\n       evaluated = true;\n       if (*non_constant_p)\n \treturn t;\n@@ -955,8 +999,8 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t    object = probe;\n \t  else\n \t    {\n-\t      probe = constexpr_expression (ctx, probe, true, non_constant_p,\n-\t\t\t\t\t    overflow_p);\n+\t      probe = eval_constant_expression (ctx, probe, true,\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n \t      evaluated = true;\n \t      if (*non_constant_p)\n \t\treturn t;\n@@ -1146,8 +1190,8 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       if (TREE_CODE (init) == TARGET_EXPR)\n \tif (tree tinit = TARGET_EXPR_INITIAL (init))\n \t  init = tinit;\n-      init = constexpr_expression (&new_ctx, init, false, non_constant_p,\n-\t\t\t\t   overflow_p);\n+      init = eval_constant_expression (&new_ctx, init, false, non_constant_p,\n+\t\t\t\t       overflow_p);\n       /* The hash table might have moved since the get earlier, and the\n \t initializer might have mutated the underlying CONSTRUCTORs, so we must\n \t recompute VALP. */\n@@ -1250,8 +1294,10 @@ eval_binary_expression (const constexpr_ctx *ctx, tree t, bool lval,\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n \n-  lhs = constexpr_expression (ctx, orig_lhs, lval, non_constant_p, overflow_p);\n-  rhs = constexpr_expression (ctx, orig_rhs, lval, non_constant_p, overflow_p);\n+  lhs = eval_constant_expression (ctx, orig_lhs, lval, non_constant_p,\n+\t\t\t\t  overflow_p);\n+  rhs = eval_constant_expression (ctx, orig_rhs, lval, non_constant_p,\n+\t\t\t\t  overflow_p);\n \n   location_t loc = EXPR_LOCATION (t);\n   enum tree_code code = TREE_CODE (t);\n@@ -1333,8 +1379,8 @@ rs_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n       /* Normally we would strip a TARGET_EXPR in an initialization context\n \t such as this, but here we do the elision differently: we keep the\n \t TARGET_EXPR, and use its CONSTRUCTOR as the value of the parm.  */\n-      arg = constexpr_expression (ctx, x, /*lval=*/false, non_constant_p,\n-\t\t\t\t  overflow_p);\n+      arg = eval_constant_expression (ctx, x, /*lval=*/false, non_constant_p,\n+\t\t\t\t      overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && ctx->quiet)\n \tbreak;\n@@ -1604,8 +1650,8 @@ eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t  unsigned save_heap_dealloc_count = ctx->global->heap_dealloc_count;\n \n \t  tree jump_target = NULL_TREE;\n-\t  constexpr_expression (&ctx_with_save_exprs, body, lval,\n-\t\t\t\tnon_constant_p, overflow_p, &jump_target);\n+\t  eval_constant_expression (&ctx_with_save_exprs, body, lval,\n+\t\t\t\t    non_constant_p, overflow_p, &jump_target);\n \n \t  if (VOID_TYPE_P (TREE_TYPE (res)))\n \t    result = void_node;\n@@ -1712,8 +1758,8 @@ constexpr_fn_retval (const constexpr_ctx *ctx, tree body)\n       case RETURN_EXPR: {\n \tbool non_constant_p = false;\n \tbool overflow_p = false;\n-\treturn constexpr_expression (ctx, body, false, &non_constant_p,\n-\t\t\t\t     &overflow_p);\n+\treturn eval_constant_expression (ctx, body, false, &non_constant_p,\n+\t\t\t\t\t &overflow_p);\n       }\n       case DECL_EXPR: {\n \ttree decl = DECL_EXPR_DECL (body);\n@@ -2328,7 +2374,8 @@ get_array_or_vector_nelts (const constexpr_ctx *ctx, tree type,\n     gcc_unreachable ();\n \n   /* For VLAs, the number of elements won't be an integer constant.  */\n-  nelts = constexpr_expression (ctx, nelts, false, non_constant_p, overflow_p);\n+  nelts\n+    = eval_constant_expression (ctx, nelts, false, non_constant_p, overflow_p);\n   return nelts;\n }\n \n@@ -2345,8 +2392,8 @@ eval_and_check_array_index (const constexpr_ctx *ctx, tree t,\n   location_t loc = rs_expr_loc_or_input_loc (t);\n   tree ary = TREE_OPERAND (t, 0);\n   t = TREE_OPERAND (t, 1);\n-  tree index\n-    = constexpr_expression (ctx, t, allow_one_past, non_constant_p, overflow_p);\n+  tree index = eval_constant_expression (ctx, t, allow_one_past, non_constant_p,\n+\t\t\t\t\t overflow_p);\n   VERIFY_CONSTANT (index);\n \n   if (!tree_fits_shwi_p (index) || tree_int_cst_sgn (index) < 0)\n@@ -2561,8 +2608,8 @@ eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n       //   }\n       if (TREE_CODE (stmt) == DEBUG_BEGIN_STMT)\n \tcontinue;\n-      r = constexpr_expression (ctx, stmt, false, non_constant_p, overflow_p,\n-\t\t\t\tjump_target);\n+      r = eval_constant_expression (ctx, stmt, false, non_constant_p,\n+\t\t\t\t    overflow_p, jump_target);\n       if (*non_constant_p)\n \tbreak;\n       // FIXME\n@@ -2580,6 +2627,48 @@ eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n   return r;\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_eval_conditional_expression\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to evaluate condition expressions.  Dead branches are not\n+   looked into.  */\n+\n+static tree\n+eval_conditional_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t\t     bool *non_constant_p, bool *overflow_p,\n+\t\t\t     tree *jump_target)\n+{\n+  tree val\n+    = eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n+\t\t\t\t/*lval*/ false, non_constant_p, overflow_p);\n+  VERIFY_CONSTANT (val);\n+  if (TREE_CODE (t) == IF_STMT && IF_STMT_CONSTEVAL_P (t))\n+    {\n+      /* Evaluate the condition as if it was\n+\t if (__builtin_is_constant_evaluated ()), i.e. defer it if not\n+\t ctx->manifestly_const_eval (as sometimes we try to constant evaluate\n+\t without manifestly_const_eval even expressions or parts thereof which\n+\t will later be manifestly const_eval evaluated), otherwise fold it to\n+\t true.  */\n+      if (ctx->manifestly_const_eval)\n+\tval = boolean_true_node;\n+      else\n+\t{\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+    }\n+  /* Don't VERIFY_CONSTANT the other operands.  */\n+  if (integer_zerop (val))\n+    val = TREE_OPERAND (t, 2);\n+  else\n+    val = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == IF_STMT && !val)\n+    val = void_node;\n+  return eval_constant_expression (ctx, val, lval, non_constant_p, overflow_p,\n+\t\t\t\t   jump_target);\n+}\n+\n // #include \"gt-rust-rust-constexpr.h\"\n \n } // namespace Compile"}]}