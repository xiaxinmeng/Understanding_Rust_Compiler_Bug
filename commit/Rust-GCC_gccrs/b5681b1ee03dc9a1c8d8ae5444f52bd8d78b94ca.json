{"sha": "b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU2ODFiMWVlMDNkYzlhMWM4ZDhhZTU0NDRmNTJiZDhkNzhiOTRjYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T03:39:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T03:39:14Z"}, "message": "Initial revision\n\nFrom-SVN: r323", "tree": {"sha": "35880b086a62daaa8f0d130409b6cdb4a6e8fd03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35880b086a62daaa8f0d130409b6cdb4a6e8fd03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca/comments", "author": null, "committer": null, "parents": [{"sha": "4c0d89b59724bae04b42a5a0745288d9d1a79ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0d89b59724bae04b42a5a0745288d9d1a79ece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0d89b59724bae04b42a5a0745288d9d1a79ece"}], "stats": {"total": 602, "additions": 602, "deletions": 0}, "files": [{"sha": "762f5143fc6eed57b6797c82710f3538aa52b40b", "filename": "gcc/libgcc1.c", "status": "added", "additions": 602, "deletions": 0, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca/gcc%2Flibgcc1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca/gcc%2Flibgcc1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc1.c?ref=b5681b1ee03dc9a1c8d8ae5444f52bd8d78b94ca", "patch": "@@ -0,0 +1,602 @@\n+/* Subroutines needed by GCC output code on some machines.  */\n+/* Compile this file with the Unix C compiler!  */\n+/* Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"config.h\"\n+\n+/* Don't use `fancy_abort' here even if config.h says to use it.  */\n+#ifdef abort\n+#undef abort\n+#endif\n+\n+/* On some machines, cc is really GCC.  For these machines, we can't\n+   expect these functions to be properly compiled unless GCC open codes\n+   the operation (which is precisely when the function won't be used).\n+   So allow tm.h to specify ways of accomplishing the operations\n+   by defining the macros perform_*.\n+\n+   On a machine where cc is some other compiler, there is usually no\n+   reason to define perform_*.  The other compiler normally has other ways\n+   of implementing all of these operations.\n+\n+   In some cases a certain machine may come with GCC installed as cc\n+   or may have some other compiler.  Then it may make sense for tm.h\n+   to define perform_* only if __GNUC__ is defined.  */\n+\n+#ifndef perform_mulsi3\n+#define perform_mulsi3(a, b) return a * b\n+#endif\n+\n+#ifndef perform_divsi3\n+#define perform_divsi3(a, b) return a / b\n+#endif\n+\n+#ifndef perform_udivsi3\n+#define perform_udivsi3(a, b) return a / b\n+#endif\n+\n+#ifndef perform_modsi3\n+#define perform_modsi3(a, b) return a % b\n+#endif\n+\n+#ifndef perform_umodsi3\n+#define perform_umodsi3(a, b) return a % b\n+#endif\n+\n+#ifndef perform_lshrsi3\n+#define perform_lshrsi3(a, b) return a >> b\n+#endif\n+\n+#ifndef perform_lshlsi3\n+#define perform_lshlsi3(a, b) return a << b\n+#endif\n+\n+#ifndef perform_ashrsi3\n+#define perform_ashrsi3(a, b) return a >> b\n+#endif\n+\n+#ifndef perform_ashlsi3\n+#define perform_ashlsi3(a, b) return a << b\n+#endif\n+\n+#ifndef perform_adddf3\n+#define perform_adddf3(a, b) return a + b\n+#endif\n+\n+#ifndef perform_subdf3\n+#define perform_subdf3(a, b) return a - b\n+#endif\n+\n+#ifndef perform_muldf3\n+#define perform_muldf3(a, b) return a * b\n+#endif\n+\n+#ifndef perform_divdf3\n+#define perform_divdf3(a, b) return a / b\n+#endif\n+\n+#ifndef perform_addsf3\n+#define perform_addsf3(a, b) return INTIFY (a + b)\n+#endif\n+\n+#ifndef perform_subsf3\n+#define perform_subsf3(a, b) return INTIFY (a - b)\n+#endif\n+\n+#ifndef perform_mulsf3\n+#define perform_mulsf3(a, b) return INTIFY (a * b)\n+#endif\n+\n+#ifndef perform_divsf3\n+#define perform_divsf3(a, b) return INTIFY (a / b)\n+#endif\n+\n+#ifndef perform_negdf2\n+#define perform_negdf2(a) return -a\n+#endif\n+\n+#ifndef perform_negsf2\n+#define perform_negsf2(a) return INTIFY (-a)\n+#endif\n+\n+#ifndef perform_fixdfsi\n+#define perform_fixdfsi(a) return (SItype) a;\n+#endif\n+\n+#ifndef perform_fixsfsi\n+#define perform_fixsfsi(a) return (SItype) a\n+#endif\n+\n+#ifndef perform_floatsidf\n+#define perform_floatsidf(a) return (double) a\n+#endif\n+\n+#ifndef perform_floatsisf\n+#define perform_floatsisf(a)  return INTIFY ((float) a)\n+#endif\n+\n+#ifndef perform_extendsfdf2\n+#define perform_extendsfdf2(a)  return a\n+#endif\n+\n+#ifndef perform_truncdfsf2\n+#define perform_truncdfsf2(a)  return INTIFY (a)\n+#endif\n+\n+/* Note that eqdf2 returns a value for \"true\" that is == 0,\n+   nedf2 returns a value for \"true\" that is != 0,\n+   gtdf2 returns a value for \"true\" that is > 0,\n+   and so on.  */\n+\n+#ifndef perform_eqdf2\n+#define perform_eqdf2(a, b) return !(a == b)\n+#endif\n+\n+#ifndef perform_nedf2\n+#define perform_nedf2(a, b) return a != b\n+#endif\n+\n+#ifndef perform_gtdf2\n+#define perform_gtdf2(a, b) return a > b\n+#endif\n+\n+#ifndef perform_gedf2\n+#define perform_gedf2(a, b) return (a >= b) - 1\n+#endif\n+\n+#ifndef perform_ltdf2\n+#define perform_ltdf2(a, b) return -(a < b)\n+#endif\n+\n+#ifndef perform_ledf2\n+#define perform_ledf2(a, b) return 1 - (a <= b)\n+#endif\n+\n+#ifndef perform_eqsf2\n+#define perform_eqsf2(a, b) return !(a == b)\n+#endif\n+\n+#ifndef perform_nesf2\n+#define perform_nesf2(a, b) return a != b\n+#endif\n+\n+#ifndef perform_gtsf2\n+#define perform_gtsf2(a, b) return a > b\n+#endif\n+\n+#ifndef perform_gesf2\n+#define perform_gesf2(a, b) return (a >= b) - 1\n+#endif\n+\n+#ifndef perform_ltsf2\n+#define perform_ltsf2(a, b) return -(a < b)\n+#endif\n+\n+#ifndef perform_lesf2\n+#define perform_lesf2(a, b) return 1 - (a >= b);\n+#endif\n+\f\n+/* Define the C data type to use for an SImode value.  */\n+\n+#ifndef SItype\n+#define SItype long int\n+#endif\n+\n+/* Define the type to be used for returning an SF mode value\n+   and the method for turning a float into that type.\n+   These definitions work for machines where an SF value is\n+   returned in the same register as an int.  */\n+\n+#ifndef FLOAT_VALUE_TYPE  \n+#define FLOAT_VALUE_TYPE int\n+#endif\n+\n+#ifndef INTIFY\n+#define INTIFY(FLOATVAL)  (intify.f = (FLOATVAL), intify.i)\n+#endif\n+\n+#ifndef FLOATIFY\n+#define FLOATIFY(INTVAL)  ((INTVAL).f)\n+#endif\n+\n+#ifndef FLOAT_ARG_TYPE\n+#define FLOAT_ARG_TYPE union flt_or_int\n+#endif\n+\n+union flt_or_value { FLOAT_VALUE_TYPE i; float f; };\n+\n+union flt_or_int { int i; float f; };\n+\n+\n+#ifdef L_mulsi3\n+SItype\n+__mulsi3 (a, b)\n+     SItype a, b;\n+{\n+  perform_mulsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_udivsi3\n+SItype\n+__udivsi3 (a, b)\n+     unsigned SItype a, b;\n+{\n+  perform_udivsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_divsi3\n+SItype\n+__divsi3 (a, b)\n+     SItype a, b;\n+{\n+  perform_divsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_umodsi3\n+SItype\n+__umodsi3 (a, b)\n+     unsigned SItype a, b;\n+{\n+  perform_umodsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_modsi3\n+SItype\n+__modsi3 (a, b)\n+     SItype a, b;\n+{\n+  perform_modsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_lshrsi3\n+SItype\n+__lshrsi3 (a, b)\n+     unsigned SItype a, b;\n+{\n+  perform_lshrsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_lshlsi3\n+SItype\n+__lshlsi3 (a, b)\n+     unsigned SItype a, b;\n+{\n+  perform_lshlsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_ashrsi3\n+SItype\n+__ashrsi3 (a, b)\n+     SItype a, b;\n+{\n+  perform_ashrsi3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_ashlsi3\n+SItype\n+__ashlsi3 (a, b)\n+     SItype a, b;\n+{\n+  perform_ashlsi3 (a, b);\n+}\n+#endif\n+\f\n+#ifdef L_divdf3\n+double\n+__divdf3 (a, b)\n+     double a, b;\n+{\n+  perform_divdf3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_muldf3\n+double\n+__muldf3 (a, b)\n+     double a, b;\n+{\n+  perform_muldf3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_negdf2\n+double\n+__negdf2 (a)\n+     double a;\n+{\n+  perform_negdf2 (a);\n+}\n+#endif\n+\n+#ifdef L_adddf3\n+double\n+__adddf3 (a, b)\n+     double a, b;\n+{\n+  perform_adddf3 (a, b);\n+}\n+#endif\n+\n+#ifdef L_subdf3\n+double\n+__subdf3 (a, b)\n+     double a, b;\n+{\n+  perform_subdf3 (a, b);\n+}\n+#endif\n+\n+/* Note that eqdf2 returns a value for \"true\" that is == 0,\n+   nedf2 returns a value for \"true\" that is != 0,\n+   gtdf2 returns a value for \"true\" that is > 0,\n+   and so on.  */\n+\n+#ifdef L_eqdf2\n+SItype\n+__eqdf2 (a, b)\n+     double a, b;\n+{\n+  /* Value == 0 iff a == b.  */\n+  perform_eqdf2 (a, b);\n+}\n+#endif\n+\n+#ifdef L_nedf2\n+SItype\n+__nedf2 (a, b)\n+     double a, b;\n+{\n+  /* Value != 0 iff a != b.  */\n+  perform_nedf2 (a, b);\n+}\n+#endif\n+\n+#ifdef L_gtdf2\n+SItype\n+__gtdf2 (a, b)\n+     double a, b;\n+{\n+  /* Value > 0 iff a > b.  */\n+  perform_gtdf2 (a, b);\n+}\n+#endif\n+\n+#ifdef L_gedf2\n+SItype\n+__gedf2 (a, b)\n+     double a, b;\n+{\n+  /* Value >= 0 iff a >= b.  */\n+  perform_gedf2 (a, b);\n+}\n+#endif\n+\n+#ifdef L_ltdf2\n+SItype\n+__ltdf2 (a, b)\n+     double a, b;\n+{\n+  /* Value < 0 iff a < b.  */\n+  perform_ltdf2 (a, b);\n+}\n+#endif\n+\n+#ifdef L_ledf2\n+SItype\n+__ledf2 (a, b)\n+     double a, b;\n+{\n+  /* Value <= 0 iff a <= b.  */\n+  perform_ledf2 (a, b);\n+}\n+#endif\n+\f\n+#ifdef L_fixdfsi\n+SItype\n+__fixdfsi (a)\n+     double a;\n+{\n+  perform_fixdfsi (a);\n+}\n+#endif\n+\n+#ifdef L_fixsfsi\n+SItype\n+__fixsfsi (a)\n+     FLOAT_ARG_TYPE a;\n+{\n+  union flt_or_value intify;\n+  perform_fixsfsi (FLOATIFY (a));\n+}\n+#endif\n+\n+#ifdef L_floatsidf\n+double\n+__floatsidf (a)\n+     SItype a;\n+{\n+  perform_floatsidf (a);\n+}\n+#endif\n+\n+#ifdef L_floatsisf\n+FLOAT_VALUE_TYPE\n+__floatsisf (a)\n+     SItype a;\n+{\n+  union flt_or_value intify;\n+  perform_floatsisf (a);\n+}\n+#endif\n+\f\n+#ifdef L_addsf3\n+FLOAT_VALUE_TYPE\n+__addsf3 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_value intify;\n+  perform_addsf3 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_negsf2\n+FLOAT_VALUE_TYPE\n+__negsf2 (a)\n+     FLOAT_ARG_TYPE a;\n+{\n+  union flt_or_value intify;\n+  perform_negsf2 (FLOATIFY (a));\n+}\n+#endif\n+\n+#ifdef L_subsf3\n+FLOAT_VALUE_TYPE\n+__subsf3 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_value intify;\n+  perform_subsf3 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_eqsf2\n+SItype\n+__eqsf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value == 0 iff a == b.  */\n+  perform_eqsf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_nesf2\n+SItype\n+__nesf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value != 0 iff a != b.  */\n+  perform_nesf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_gtsf2\n+SItype\n+__gtsf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value > 0 iff a > b.  */\n+  perform_gtsf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_gesf2\n+SItype\n+__gesf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value >= 0 iff a >= b.  */\n+  perform_gesf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_ltsf2\n+SItype\n+__ltsf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value < 0 iff a < b.  */\n+  perform_ltsf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_lesf2\n+SItype\n+__lesf2 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_int intify;\n+  /* Value <= 0 iff a <= b.  */\n+  perform_lesf2 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_mulsf3\n+FLOAT_VALUE_TYPE\n+__mulsf3 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_value intify;\n+  perform_mulsf3 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_divsf3\n+FLOAT_VALUE_TYPE\n+__divsf3 (a, b)\n+     FLOAT_ARG_TYPE a, b;\n+{\n+  union flt_or_value intify;\n+  perform_divsf3 (FLOATIFY (a), FLOATIFY (b));\n+}\n+#endif\n+\n+#ifdef L_truncdfsf2\n+FLOAT_VALUE_TYPE\n+__truncdfsf2 (a)\n+     double a;\n+{\n+  union flt_or_value intify;\n+  perform_truncdfsf2 (a);\n+}\n+#endif\n+\n+#ifdef L_extendsfdf2\n+double\n+__extendsfdf2 (a)\n+     FLOAT_ARG_TYPE a;\n+{\n+  union flt_or_value intify;\n+  perform_extendsfdf2 (FLOATIFY (a));\n+}\n+#endif"}]}