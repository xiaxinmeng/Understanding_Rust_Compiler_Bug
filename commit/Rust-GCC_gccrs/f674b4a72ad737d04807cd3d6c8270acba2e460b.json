{"sha": "f674b4a72ad737d04807cd3d6c8270acba2e460b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3NGI0YTcyYWQ3MzdkMDQ4MDdjZDNkNmM4MjcwYWNiYTJlNDYwYg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2019-11-14T22:29:56Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2019-11-14T22:29:56Z"}, "message": "Change fold_range to return a boolean result.\n\n2019-11-14  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* range-op.h (range_operator::fold_range): Return a bool.\n\t* range-op.cc (range_operator::wi_fold): Assert supported type.\n\t(range_operator::fold_range): Assert supported type and return true.\n\t(operator_equal::fold_range): Return true.\n\t(operator_not_equal::fold_range): Same.\n\t(operator_lt::fold_range): Same.\n\t(operator_le::fold_range): Same.\n\t(operator_gt::fold_range): Same.\n\t(operator_ge::fold_range): Same.\n\t(operator_plus::op1_range): Adjust call to fold_range.\n\t(operator_plus::op2_range): Same.\n\t(operator_minus::op1_range): Same.\n\t(operator_minus::op2_range): Same.\n\t(operator_exact_divide::op1_range): Same.\n\t(operator_lshift::fold_range): Return true and adjust fold_range call.\n\t(operator_rshift::fold_range): Same.\n\t(operator_cast::fold_range): Return true.\n\t(operator_logical_and::fold_range): Same.\n\t(operator_logical_or::fold_range): Same.\n\t(operator_logical_not::fold_range): Same.\n\t(operator_bitwise_not::fold_range): Adjust call to fold_range.\n\t(operator_bitwise_not::op1_range): Same.\n\t(operator_cst::fold_range): Return true.\n\t(operator_identity::fold_range): Return true.\n\t(operator_negate::fold_range): Return true and adjust fold_range call.\n\t(operator_addr_expr::fold_range): Return true.\n\t(operator_addr_expr::op1_range): Adjust call to fold_range.\n\t(range_cast): Same.\n\t* tree-vrp.c (range_fold_binary_symbolics_p): Adjust call to fold_range.\n\t(range_fold_unary_symbolics_p): Same.\n\nFrom-SVN: r278266", "tree": {"sha": "8aa91338c0070dfad9ed2c62500209872f557f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aa91338c0070dfad9ed2c62500209872f557f02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f674b4a72ad737d04807cd3d6c8270acba2e460b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f674b4a72ad737d04807cd3d6c8270acba2e460b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f674b4a72ad737d04807cd3d6c8270acba2e460b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f674b4a72ad737d04807cd3d6c8270acba2e460b/comments", "author": null, "committer": null, "parents": [{"sha": "7c5890cc0a0ecea0e88cc39e9fba6385fb579e61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c5890cc0a0ecea0e88cc39e9fba6385fb579e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c5890cc0a0ecea0e88cc39e9fba6385fb579e61"}], "stats": {"total": 220, "additions": 130, "deletions": 90}, "files": [{"sha": "240bda5789ca3a21aa2a8a232675626cca065fd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f674b4a72ad737d04807cd3d6c8270acba2e460b", "patch": "@@ -1,3 +1,36 @@\n+2019-11-14  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* range-op.h (range_operator::fold_range): Return a bool.\n+\t* range-op.cc (range_operator::wi_fold): Assert supported type.\n+\t(range_operator::fold_range): Assert supported type and return true.\n+\t(operator_equal::fold_range): Return true.\n+\t(operator_not_equal::fold_range): Same.\n+\t(operator_lt::fold_range): Same.\n+\t(operator_le::fold_range): Same.\n+\t(operator_gt::fold_range): Same.\n+\t(operator_ge::fold_range): Same.\n+\t(operator_plus::op1_range): Adjust call to fold_range.\n+\t(operator_plus::op2_range): Same.\n+\t(operator_minus::op1_range): Same.\n+\t(operator_minus::op2_range): Same.\n+\t(operator_exact_divide::op1_range): Same.\n+\t(operator_lshift::fold_range): Return true and adjust fold_range call.\n+\t(operator_rshift::fold_range): Same.\n+\t(operator_cast::fold_range): Return true.\n+\t(operator_logical_and::fold_range): Same.\n+\t(operator_logical_or::fold_range): Same.\n+\t(operator_logical_not::fold_range): Same.\n+\t(operator_bitwise_not::fold_range): Adjust call to fold_range.\n+\t(operator_bitwise_not::op1_range): Same.\n+\t(operator_cst::fold_range): Return true.\n+\t(operator_identity::fold_range): Return true.\n+\t(operator_negate::fold_range): Return true and adjust fold_range call.\n+\t(operator_addr_expr::fold_range): Return true.\n+\t(operator_addr_expr::op1_range): Adjust call to fold_range.\n+\t(range_cast): Same.\n+\t* tree-vrp.c (range_fold_binary_symbolics_p): Adjust call to fold_range.\n+\t(range_fold_unary_symbolics_p): Same.\n+\n 2019-11-14  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR tree-optimization/92506"}, {"sha": "59d5d006d2e3cdec2be585783c03407c9378a849", "filename": "gcc/range-op.cc", "status": "modified", "additions": 93, "deletions": 84, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=f674b4a72ad737d04807cd3d6c8270acba2e460b", "patch": "@@ -131,19 +131,21 @@ range_operator::wi_fold (value_range &r, tree type,\n \t\t\t const wide_int &rh_lb ATTRIBUTE_UNUSED,\n \t\t\t const wide_int &rh_ub ATTRIBUTE_UNUSED) const\n {\n+  gcc_checking_assert (value_range::supports_type_p (type));\n   r = value_range (type);\n }\n \n // The default for fold is to break all ranges into sub-ranges and\n // invoke the wi_fold method on each sub-range pair.\n \n-void\n+bool\n range_operator::fold_range (value_range &r, tree type,\n \t\t\t    const value_range &lh,\n \t\t\t    const value_range &rh) const\n {\n+  gcc_checking_assert (value_range::supports_type_p (type));\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   value_range tmp;\n   r.set_undefined ();\n@@ -157,8 +159,9 @@ range_operator::fold_range (value_range &r, tree type,\n \twi_fold (tmp, type, lh_lb, lh_ub, rh_lb, rh_ub);\n \tr.union_ (tmp);\n \tif (r.varying_p ())\n-\t  return;\n+\t  return true;\n       }\n+  return true;\n }\n \n // The default for op1_range is to return false.\n@@ -364,7 +367,7 @@ get_bool_state (value_range &r, const value_range &lhs, tree val_type)\n class operator_equal : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -375,13 +378,13 @@ class operator_equal : public range_operator\n \t\t\t  const value_range &val) const;\n } op_equal;\n \n-void\n+bool\n operator_equal::fold_range (value_range &r, tree type,\n \t\t\t    const value_range &op1,\n \t\t\t    const value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n@@ -404,6 +407,7 @@ operator_equal::fold_range (value_range &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n+  return true;\n }\n \n bool\n@@ -448,7 +452,7 @@ operator_equal::op2_range (value_range &r, tree type,\n class operator_not_equal : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -459,13 +463,13 @@ class operator_not_equal : public range_operator\n \t\t\t  const value_range &op1) const;\n } op_not_equal;\n \n-void\n+bool\n operator_not_equal::fold_range (value_range &r, tree type,\n \t\t\t\tconst value_range &op1,\n \t\t\t\tconst value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   // We can be sure the values are always equal or not if both ranges\n   // consist of a single value, and then compare them.\n@@ -488,6 +492,7 @@ operator_not_equal::fold_range (value_range &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n+  return true;\n }\n \n bool\n@@ -578,7 +583,7 @@ build_ge (value_range &r, tree type, const wide_int &val)\n class operator_lt :  public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -589,13 +594,13 @@ class operator_lt :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_lt;\n \n-void\n+bool\n operator_lt::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -606,6 +611,7 @@ operator_lt::fold_range (value_range &r, tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n+  return true;\n }\n \n bool\n@@ -654,7 +660,7 @@ operator_lt::op2_range (value_range &r, tree type,\n class operator_le :  public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -665,13 +671,13 @@ class operator_le :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_le;\n \n-void\n+bool\n operator_le::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -682,6 +688,7 @@ operator_le::fold_range (value_range &r, tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n+  return true;\n }\n \n bool\n@@ -730,7 +737,7 @@ operator_le::op2_range (value_range &r, tree type,\n class operator_gt :  public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -741,12 +748,12 @@ class operator_gt :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_gt;\n \n-void\n+bool\n operator_gt::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1, const value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -757,6 +764,7 @@ operator_gt::fold_range (value_range &r, tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n+  return true;\n }\n \n bool\n@@ -804,7 +812,7 @@ operator_gt::op2_range (value_range &r, tree type,\n class operator_ge :  public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -815,13 +823,13 @@ class operator_ge :  public range_operator\n \t\t\t  const value_range &op1) const;\n } op_ge;\n \n-void\n+bool\n operator_ge::fold_range (value_range &r, tree type,\n \t\t\t const value_range &op1,\n \t\t\t const value_range &op2) const\n {\n   if (empty_range_check (r, op1, op2))\n-    return;\n+    return true;\n \n   signop sign = TYPE_SIGN (op1.type ());\n   gcc_checking_assert (sign == TYPE_SIGN (op2.type ()));\n@@ -832,6 +840,7 @@ operator_ge::fold_range (value_range &r, tree type,\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n+  return true;\n }\n \n bool\n@@ -910,17 +919,15 @@ operator_plus::op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const\n {\n-  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op2);\n-  return true;\n+  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op2);\n }\n \n bool\n operator_plus::op2_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op1) const\n {\n-  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op1);\n-  return true;\n+  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, lhs, op1);\n }\n \n \n@@ -957,17 +964,15 @@ operator_minus::op1_range (value_range &r, tree type,\n \t\t\t   const value_range &lhs,\n \t\t\t   const value_range &op2) const\n {\n-  range_op_handler (PLUS_EXPR, type)->fold_range (r, type, lhs, op2);\n-  return true;\n+  return range_op_handler (PLUS_EXPR, type)->fold_range (r, type, lhs, op2);\n }\n \n bool\n operator_minus::op2_range (value_range &r, tree type,\n \t\t\t   const value_range &lhs,\n \t\t\t   const value_range &op1) const\n {\n-  fold_range (r, type, op1, lhs);\n-  return true;\n+  return fold_range (r, type, op1, lhs);\n }\n \n \n@@ -1351,18 +1356,15 @@ operator_exact_divide::op1_range (value_range &r, tree type,\n   // If op2 is a multiple of 2, we would be able to set some non-zero bits.\n   if (op2.singleton_p (&offset)\n       && !integer_zerop (offset))\n-    {\n-      range_op_handler (MULT_EXPR, type)->fold_range (r, type, lhs, op2);\n-      return true;\n-    }\n+    return range_op_handler (MULT_EXPR, type)->fold_range (r, type, lhs, op2);\n   return false;\n }\n \n \n class operator_lshift : public cross_product_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n \n@@ -1375,13 +1377,13 @@ class operator_lshift : public cross_product_operator\n \t\t\t\tconst wide_int &) const;\n } op_lshift;\n \n-void\n+bool\n operator_lshift::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &op1,\n \t\t\t     const value_range &op2) const\n {\n   if (undefined_shift_range_check (r, type, op2))\n-    return;\n+    return true;\n \n   // Transform left shifts by constants into multiplies.\n   if (op2.singleton_p ())\n@@ -1395,14 +1397,15 @@ operator_lshift::fold_range (value_range &r, tree type,\n       bool saved_flag_wrapv_pointer = flag_wrapv_pointer;\n       flag_wrapv = 1;\n       flag_wrapv_pointer = 1;\n-      range_op_handler (MULT_EXPR, type)->fold_range (r, type, op1, mult);\n+      bool b = range_op_handler (MULT_EXPR, type)->fold_range (r, type, op1,\n+\t\t\t\t\t\t\t       mult);\n       flag_wrapv = saved_flag_wrapv;\n       flag_wrapv_pointer = saved_flag_wrapv_pointer;\n-      return;\n+      return b;\n     }\n-\n-  // Otherwise, invoke the generic fold routine.\n-  range_operator::fold_range (r, type, op1, op2);\n+  else\n+    // Otherwise, invoke the generic fold routine.\n+    return range_operator::fold_range (r, type, op1, op2);\n }\n \n void\n@@ -1486,7 +1489,7 @@ operator_lshift::wi_op_overflows (wide_int &res, tree type,\n class operator_rshift : public cross_product_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual void wi_fold (value_range &r, tree type,\n@@ -1519,16 +1522,16 @@ operator_rshift::wi_op_overflows (wide_int &res,\n   return false;\n }\n \n-void\n+bool\n operator_rshift::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &op1,\n \t\t\t     const value_range &op2) const\n {\n+  // Invoke the generic fold routine if not undefined..\n   if (undefined_shift_range_check (r, type, op2))\n-    return;\n+    return true;\n \n-  // Otherwise, invoke the generic fold routine.\n-  range_operator::fold_range (r, type, op1, op2);\n+  return range_operator::fold_range (r, type, op1, op2);\n }\n \n void\n@@ -1543,7 +1546,7 @@ operator_rshift::wi_fold (value_range &r, tree type,\n class operator_cast: public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -1552,13 +1555,13 @@ class operator_cast: public range_operator\n \n } op_convert;\n \n-void\n+bool\n operator_cast::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n   \n   tree inner = lh.type ();\n   tree outer = rh.type ();\n@@ -1598,8 +1601,9 @@ operator_cast::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t    }\n \t}\n       r = value_range (type);\n-      return;\n+      break;\n     }\n+  return true;\n }\n \n bool\n@@ -1682,7 +1686,7 @@ operator_cast::op1_range (value_range &r, tree type,\n class operator_logical_and : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -1694,13 +1698,13 @@ class operator_logical_and : public range_operator\n } op_logical_and;\n \n \n-void\n+bool\n operator_logical_and::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   // 0 && anything is 0.\n   if ((wi::eq_p (lh.lower_bound (), 0) && wi::eq_p (lh.upper_bound (), 0))\n@@ -1713,6 +1717,7 @@ operator_logical_and::fold_range (value_range &r, tree type,\n     r = range_true_and_false (type);\n   else\n     r = range_true (type);\n+  return true;\n }\n \n bool\n@@ -1964,7 +1969,7 @@ operator_bitwise_and::op2_range (value_range &r, tree type,\n class operator_logical_or : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -1975,16 +1980,17 @@ class operator_logical_or : public range_operator\n \t\t\t  const value_range &op1) const;\n } op_logical_or;\n \n-void\n+bool\n operator_logical_or::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t\t const value_range &lh,\n \t\t\t\t const value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   r = lh;\n   r.union_ (rh);\n+  return true;\n }\n \n bool\n@@ -2198,7 +2204,7 @@ operator_trunc_mod::wi_fold (value_range &r, tree type,\n class operator_logical_not : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n@@ -2220,13 +2226,13 @@ class operator_logical_not : public range_operator\n // \t b_2 = x_1 < 20\t\t[0,0] = x_1 < 20,   false, so x_1 == [20, 255]\n //   which is the result we are looking for.. so.. pass it through.\n \n-void\n+bool\n operator_logical_not::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   if (lh.varying_p () || lh.undefined_p ())\n     r = lh;\n@@ -2236,7 +2242,7 @@ operator_logical_not::fold_range (value_range &r, tree type,\n       r.invert ();\n     }\n   gcc_checking_assert (lh.type() == type);\n-  return;\n+  return true;\n }\n \n bool\n@@ -2255,27 +2261,27 @@ operator_logical_not::op1_range (value_range &r,\n class operator_bitwise_not : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_bitwise_not;\n \n-void\n+bool\n operator_bitwise_not::fold_range (value_range &r, tree type,\n \t\t\t\t  const value_range &lh,\n \t\t\t\t  const value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   // ~X is simply -1 - X.\n   value_range minusone (type, wi::minus_one (TYPE_PRECISION (type)),\n \t\t\twi::minus_one (TYPE_PRECISION (type)));\n-  range_op_handler (MINUS_EXPR, type)->fold_range (r, type, minusone, lh);\n-  return;\n+  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type, minusone,\n+\t\t\t\t\t\t\t  lh);\n }\n \n bool\n@@ -2284,45 +2290,46 @@ operator_bitwise_not::op1_range (value_range &r, tree type,\n \t\t\t\t const value_range &op2) const\n {\n   // ~X is -1 - X and since bitwise NOT is involutary...do it again.\n-  fold_range (r, type, lhs, op2);\n-  return true;\n+  return fold_range (r, type, lhs, op2);\n }\n \n \n class operator_cst : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n } op_integer_cst;\n \n-void\n+bool\n operator_cst::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t  const value_range &lh,\n \t\t\t  const value_range &rh ATTRIBUTE_UNUSED) const\n {\n   r = lh;\n+  return true;\n }\n \n \n class operator_identity : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_identity;\n \n-void\n+bool\n operator_identity::fold_range (value_range &r, tree type ATTRIBUTE_UNUSED,\n \t\t\t       const value_range &lh,\n \t\t\t       const value_range &rh ATTRIBUTE_UNUSED) const\n {\n   r = lh;\n+  return true;\n }\n \n bool\n@@ -2485,24 +2492,25 @@ operator_absu::wi_fold (value_range &r, tree type,\n class operator_negate : public range_operator\n {\n  public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_negate;\n \n-void\n+bool\n operator_negate::fold_range (value_range &r, tree type,\n \t\t\t     const value_range &lh,\n \t\t\t     const value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n   // -X is simply 0 - X.\n-  range_op_handler (MINUS_EXPR, type)->fold_range (r, type,\n-\t\t\t\t\t\t   range_zero (type), lh);\n+  return range_op_handler (MINUS_EXPR, type)->fold_range (r, type,\n+\t\t\t\t\t\t\t  range_zero (type),\n+\t\t\t\t\t\t\t  lh);\n }\n \n bool\n@@ -2511,29 +2519,28 @@ operator_negate::op1_range (value_range &r, tree type,\n \t\t\t    const value_range &op2) const\n {\n   // NEGATE is involutory.\n-  fold_range (r, type, lhs, op2);\n-  return true;\n+  return fold_range (r, type, lhs, op2);\n }\n \n \n class operator_addr_expr : public range_operator\n {\n public:\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &op1,\n \t\t\t   const value_range &op2) const;\n   virtual bool op1_range (value_range &r, tree type,\n \t\t\t  const value_range &lhs,\n \t\t\t  const value_range &op2) const;\n } op_addr;\n \n-void\n+bool\n operator_addr_expr::fold_range (value_range &r, tree type,\n \t\t\t\tconst value_range &lh,\n \t\t\t\tconst value_range &rh) const\n {\n   if (empty_range_check (r, lh, rh))\n-    return;\n+    return true;\n \n   // Return a non-null pointer of the LHS type (passed in op2).\n   if (lh.zero_p ())\n@@ -2542,15 +2549,15 @@ operator_addr_expr::fold_range (value_range &r, tree type,\n     r = range_nonzero (type);\n   else\n     r = value_range (type);\n+  return true;\n }\n \n bool\n operator_addr_expr::op1_range (value_range &r, tree type,\n \t\t\t       const value_range &lhs,\n \t\t\t       const value_range &op2) const\n {\n-  operator_addr_expr::fold_range (r, type, lhs, op2);\n-  return true;\n+  return operator_addr_expr::fold_range (r, type, lhs, op2);\n }\n \n \n@@ -2808,7 +2815,9 @@ range_cast (value_range &r, tree type)\n {\n   value_range tmp = r;\n   range_operator *op = range_op_handler (CONVERT_EXPR, type);\n-  op->fold_range (r, type, tmp, value_range (type));\n+  // Call op_convert, if it fails, the result is varying.\n+  if (!op->fold_range (r, type, tmp, value_range (type)))\n+    r = value_range (type);\n }\n \n #if CHECKING_P"}, {"sha": "458b42ffe7f41ad3cb4702dbf70356923526f42c", "filename": "gcc/range-op.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=f674b4a72ad737d04807cd3d6c8270acba2e460b", "patch": "@@ -50,7 +50,7 @@ class range_operator\n {\n public:\n   // Perform an operation between 2 ranges and return it.\n-  virtual void fold_range (value_range &r, tree type,\n+  virtual bool fold_range (value_range &r, tree type,\n \t\t\t   const value_range &lh,\n \t\t\t   const value_range &rh) const;\n \n@@ -73,7 +73,7 @@ class range_operator\n \t\t\t  const value_range &op1) const;\n \n protected:\n-  // Perform an operation between 2 sub-ranges and return it.\n+  // Perform an integral operation between 2 sub-ranges and return it.\n   virtual void wi_fold (value_range &r, tree type,\n \t\t        const wide_int &lh_lb,\n \t\t        const wide_int &lh_ub,"}, {"sha": "bbcf237a925aa186c4df13e736b63bfad992390c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f674b4a72ad737d04807cd3d6c8270acba2e460b/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f674b4a72ad737d04807cd3d6c8270acba2e460b", "patch": "@@ -1185,8 +1185,7 @@ range_fold_binary_symbolics_p (value_range *vr,\n       value_range vr0_cst (*vr0), vr1_cst (*vr1);\n       vr0_cst.normalize_symbolics ();\n       vr1_cst.normalize_symbolics ();\n-      op->fold_range (*vr, expr_type, vr0_cst, vr1_cst);\n-      return true;\n+      return op->fold_range (*vr, expr_type, vr0_cst, vr1_cst);\n     }\n   return false;\n }\n@@ -1221,8 +1220,7 @@ range_fold_unary_symbolics_p (value_range *vr,\n       const range_operator *op = get_range_op_handler (vr, code, expr_type);\n       value_range vr0_cst (*vr0);\n       vr0_cst.normalize_symbolics ();\n-      op->fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n-      return true;\n+      return op->fold_range (*vr, expr_type, vr0_cst, value_range (expr_type));\n     }\n   return false;\n }"}]}