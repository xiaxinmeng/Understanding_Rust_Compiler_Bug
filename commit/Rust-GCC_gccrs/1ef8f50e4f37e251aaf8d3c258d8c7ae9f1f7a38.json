{"sha": "1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmOGY1MGU0ZjM3ZTI1MWFhZjhkM2MyNThkOGM3YWU5ZjFmN2EzOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-06-07T22:18:24Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-06-07T22:18:24Z"}, "message": "Split up value_range::intersect into base (value_range_base) and\nderived versions (value_range).\n\nFrom-SVN: r272058", "tree": {"sha": "740fe04d5cffd31dadb65f99b1e591bd49569e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/740fe04d5cffd31dadb65f99b1e591bd49569e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f32ee8a25ee82ae4139eaf6357366683352c7068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32ee8a25ee82ae4139eaf6357366683352c7068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32ee8a25ee82ae4139eaf6357366683352c7068"}], "stats": {"total": 128, "additions": 89, "deletions": 39}, "files": [{"sha": "7e84da73316a488d904aa25c2275b6e2e000a494", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -1,3 +1,19 @@\n+2019-06-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.h (value_range_base::intersect): New.\n+\t(value_range::intersect_helper): Move from here...\n+\t(value_range_base::intersect_helper): ...to here.\n+\t* tree-vrp.c (value_range::intersect_helper): Rename to...\n+\t(value_range_base::intersect_helper): ...this, and rewrite to\n+\treturn a value instead of modifying THIS in place.\n+\tAlso, move equivalence handling...\n+\t(value_range::intersect): ...here, while calling intersect_helper.\n+\t* gimple-fold.c (size_must_be_zero_p): Use value_range_base when\n+\tcalling intersect.\n+\t* gimple-ssa-evrp-analyze.c (ecord_ranges_from_incoming_edge):\n+\tSame.\n+\t* vr-values.c (vrp_evaluate_conditional_warnv_with_ops): Same.\n+\n 2019-06-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Makefile.in (genprogerr): Add condmd."}, {"sha": "8b8331eb5556da42127231b1e5780798ee19469c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -684,10 +684,10 @@ size_must_be_zero_p (tree size)\n   /* Compute the value of SSIZE_MAX, the largest positive value that\n      can be stored in ssize_t, the signed counterpart of size_t.  */\n   wide_int ssize_max = wi::lshift (wi::one (prec), prec - 1) - 1;\n-  value_range valid_range (VR_RANGE,\n-\t\t\t   build_int_cst (type, 0),\n-\t\t\t   wide_int_to_tree (type, ssize_max));\n-  value_range vr;\n+  value_range_base valid_range (VR_RANGE,\n+\t\t\t\tbuild_int_cst (type, 0),\n+\t\t\t\twide_int_to_tree (type, ssize_max));\n+  value_range_base vr;\n   get_range_info (size, vr);\n   vr.intersect (&valid_range);\n   return vr.zero_p ();"}, {"sha": "4c68af847e140c1f95921fa7b02af6b20d37ed3a", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -210,9 +210,10 @@ evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)\n \t         getting first [64, +INF] and then ~[0, 0] from\n \t\t conditions like (s & 0x3cc0) == 0).  */\n \t      value_range *old_vr = get_value_range (vrs[i].first);\n-\t      value_range tem (old_vr->kind (), old_vr->min (), old_vr->max ());\n+\t      value_range_base tem (old_vr->kind (), old_vr->min (),\n+\t\t\t\t    old_vr->max ());\n \t      tem.intersect (vrs[i].second);\n-\t      if (tem.equal_p (*old_vr, /*ignore_equivs=*/true))\n+\t      if (tem.equal_p (*old_vr))\n \t\tcontinue;\n \t      push_value_range (vrs[i].first, vrs[i].second);\n \t      if (is_fallthru"}, {"sha": "d94de2b22eeac4f76f701561b3b321d940eacf9f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -6020,30 +6020,26 @@ intersect_ranges (enum value_range_kind *vr0type,\n }\n \n \n-/* Intersect the two value-ranges *VR0 and *VR1 and store the result\n-   in *VR0.  This may not be the smallest possible such range.  */\n+/* Helper for the intersection operation for value ranges.  Given two\n+   value ranges VR0 and VR1, return the intersection of the two\n+   ranges.  This may not be the smallest possible such range.  */\n \n-void\n-value_range::intersect_helper (value_range *vr0, const value_range *vr1)\n+value_range_base\n+value_range_base::intersect_helper (const value_range_base *vr0,\n+\t\t\t\t    const value_range_base *vr1)\n {\n   /* If either range is VR_VARYING the other one wins.  */\n   if (vr1->varying_p ())\n-    return;\n+    return *vr0;\n   if (vr0->varying_p ())\n-    {\n-      vr0->deep_copy (vr1);\n-      return;\n-    }\n+    return *vr1;\n \n   /* When either range is VR_UNDEFINED the resulting range is\n      VR_UNDEFINED, too.  */\n   if (vr0->undefined_p ())\n-    return;\n+    return *vr0;\n   if (vr1->undefined_p ())\n-    {\n-      vr0->set_undefined ();\n-      return;\n-    }\n+    return *vr1;\n \n   value_range_kind vr0type = vr0->kind ();\n   tree vr0min = vr0->min ();\n@@ -6053,28 +6049,34 @@ value_range::intersect_helper (value_range *vr0, const value_range *vr1)\n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n      fall back to vr0 when this turns things to varying.  */\n-  value_range tem;\n+  value_range_base tem;\n   tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n   /* If that failed, use the saved original VR0.  */\n   if (tem.varying_p ())\n-    return;\n-  vr0->update (tem.kind (), tem.min (), tem.max ());\n+    return *vr0;\n \n-  /* If the result is VR_UNDEFINED there is no need to mess with\n-     the equivalencies.  */\n-  if (vr0->undefined_p ())\n-    return;\n+  return tem;\n+}\n \n-  /* The resulting set of equivalences for range intersection is the union of\n-     the two sets.  */\n-  if (vr0->m_equiv && vr1->m_equiv && vr0->m_equiv != vr1->m_equiv)\n-    bitmap_ior_into (vr0->m_equiv, vr1->m_equiv);\n-  else if (vr1->m_equiv && !vr0->m_equiv)\n+void\n+value_range_base::intersect (const value_range_base *other)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      /* All equivalence bitmaps are allocated from the same obstack.  So\n-\t we can use the obstack associated with VR to allocate vr0->equiv.  */\n-      vr0->m_equiv = BITMAP_ALLOC (vr1->m_equiv->obstack);\n-      bitmap_copy (m_equiv, vr1->m_equiv);\n+      fprintf (dump_file, \"Intersecting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  *this = intersect_helper (this, other);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n     }\n }\n \n@@ -6089,7 +6091,36 @@ value_range::intersect (const value_range *other)\n       dump_value_range (dump_file, other);\n       fprintf (dump_file, \"\\n\");\n     }\n-  intersect_helper (this, other);\n+\n+  /* If THIS is varying we want to pick up equivalences from OTHER.\n+     Just special-case this here rather than trying to fixup after the\n+     fact.  */\n+  if (this->varying_p ())\n+    this->deep_copy (other);\n+  else\n+    {\n+      value_range_base tem = intersect_helper (this, other);\n+      this->update (tem.kind (), tem.min (), tem.max ());\n+\n+      /* If the result is VR_UNDEFINED there is no need to mess with\n+\t equivalencies.  */\n+      if (!undefined_p ())\n+\t{\n+\t  /* The resulting set of equivalences for range intersection\n+\t     is the union of the two sets.  */\n+\t  if (m_equiv && other->m_equiv && m_equiv != other->m_equiv)\n+\t    bitmap_ior_into (m_equiv, other->m_equiv);\n+\t  else if (other->m_equiv && !m_equiv)\n+\t    {\n+\t      /* All equivalence bitmaps are allocated from the same\n+\t\t obstack.  So we can use the obstack associated with\n+\t\t VR to allocate this->m_equiv.  */\n+\t      m_equiv = BITMAP_ALLOC (other->m_equiv->obstack);\n+\t      bitmap_copy (m_equiv, other->m_equiv);\n+\t    }\n+\t}\n+    }\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"to\\n  \");"}, {"sha": "c0801ff8041e6127c5fa4b3bb1d81538486e9b6b", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -62,6 +62,7 @@ class GTY((for_user)) value_range_base\n   void set_undefined ();\n \n   void union_ (const value_range_base *);\n+  void intersect (const value_range_base *);\n \n   bool operator== (const value_range_base &) const /* = delete */;\n   bool operator!= (const value_range_base &) const /* = delete */;\n@@ -80,6 +81,8 @@ class GTY((for_user)) value_range_base\n   void check ();\n   static value_range_base union_helper (const value_range_base *,\n \t\t\t\t\tconst value_range_base *);\n+  static value_range_base intersect_helper (const value_range_base *,\n+\t\t\t\t\t    const value_range_base *);\n \n   enum value_range_kind m_kind;\n \n@@ -144,7 +147,6 @@ class GTY((user)) value_range : public value_range_base\n   /* Deep-copies bitmap argument.  */\n   void set_equiv (bitmap);\n   void check ();\n-  void intersect_helper (value_range *, const value_range *);\n \n   /* Set of SSA names whose value ranges are equivalent to this one.\n      This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */"}, {"sha": "d3653e80789d726e84228571ba413e5f56026873", "filename": "gcc/vr-values.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=1ef8f50e4f37e251aaf8d3c258d8c7ae9f1f7a38", "patch": "@@ -2357,7 +2357,7 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t}\n       else\n \t{\n-\t  value_range vro, vri;\n+\t  value_range_base vro, vri;\n \t  if (code == GT_EXPR || code == GE_EXPR)\n \t    {\n \t      vro.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);"}]}