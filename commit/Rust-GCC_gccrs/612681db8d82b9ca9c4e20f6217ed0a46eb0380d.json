{"sha": "612681db8d82b9ca9c4e20f6217ed0a46eb0380d", "node_id": "C_kwDOANBUbNoAKDYxMjY4MWRiOGQ4MmI5Y2E5YzRlMjBmNjIxN2VkMGE0NmViMDM4MGQ", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2022-01-05T15:59:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-11T13:24:49Z"}, "message": "[Ada] Reduce scope of declare block in analysis of allocators\n\ngcc/ada/\n\n\t* sem_ch4.adb (Analyze_Allocator): Move DECLARE block inside IF\n\tstatement; refill code and comments.", "tree": {"sha": "d8c319e780c905af756c2411f8c235cc431a3f26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c319e780c905af756c2411f8c235cc431a3f26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/612681db8d82b9ca9c4e20f6217ed0a46eb0380d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612681db8d82b9ca9c4e20f6217ed0a46eb0380d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/612681db8d82b9ca9c4e20f6217ed0a46eb0380d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/612681db8d82b9ca9c4e20f6217ed0a46eb0380d/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13c0bf611a0f8dc73ac5ac463fcc6974eb55ae28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c0bf611a0f8dc73ac5ac463fcc6974eb55ae28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c0bf611a0f8dc73ac5ac463fcc6974eb55ae28"}], "stats": {"total": 321, "additions": 160, "deletions": 161}, "files": [{"sha": "918f3b84dccdafb05d0264f5b4cae3480d0cc9ab", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 160, "deletions": 161, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/612681db8d82b9ca9c4e20f6217ed0a46eb0380d/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/612681db8d82b9ca9c4e20f6217ed0a46eb0380d/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=612681db8d82b9ca9c4e20f6217ed0a46eb0380d", "patch": "@@ -588,59 +588,58 @@ package body Sem_Ch4 is\n       --  Case where allocator has a subtype indication\n \n       else\n-         declare\n-            Def_Id   : Entity_Id;\n-            Base_Typ : Entity_Id;\n-\n-         begin\n-            --  If the allocator includes a N_Subtype_Indication then a\n-            --  constraint is present, otherwise the node is a subtype mark.\n-            --  Introduce an explicit subtype declaration into the tree\n-            --  defining some anonymous subtype and rewrite the allocator to\n-            --  use this subtype rather than the subtype indication.\n-\n-            --  It is important to introduce the explicit subtype declaration\n-            --  so that the bounds of the subtype indication are attached to\n-            --  the tree in case the allocator is inside a generic unit.\n-\n-            --  Finally, if there is no subtype indication and the type is\n-            --  a tagged unconstrained type with discriminants, the designated\n-            --  object is constrained by their default values, and it is\n-            --  simplest to introduce an explicit constraint now. In some cases\n-            --  this is done during expansion, but freeze actions are certain\n-            --  to be emitted in the proper order if constraint is explicit.\n-\n-            if Is_Entity_Name (E) and then Expander_Active then\n-               Find_Type (E);\n-               Type_Id := Entity (E);\n-\n-               if Is_Tagged_Type (Type_Id)\n-                 and then Has_Defaulted_Discriminants (Type_Id)\n-                 and then not Is_Constrained (Type_Id)\n-               then\n-                  declare\n-                     Constr : constant List_Id    := New_List;\n-                     Loc    : constant Source_Ptr := Sloc (E);\n-                     Discr  : Entity_Id := First_Discriminant (Type_Id);\n+         --  If the allocator includes a N_Subtype_Indication then a\n+         --  constraint is present, otherwise the node is a subtype mark.\n+         --  Introduce an explicit subtype declaration into the tree\n+         --  defining some anonymous subtype and rewrite the allocator to\n+         --  use this subtype rather than the subtype indication.\n+\n+         --  It is important to introduce the explicit subtype declaration\n+         --  so that the bounds of the subtype indication are attached to\n+         --  the tree in case the allocator is inside a generic unit.\n+\n+         --  Finally, if there is no subtype indication and the type is\n+         --  a tagged unconstrained type with discriminants, the designated\n+         --  object is constrained by their default values, and it is\n+         --  simplest to introduce an explicit constraint now. In some cases\n+         --  this is done during expansion, but freeze actions are certain\n+         --  to be emitted in the proper order if constraint is explicit.\n+\n+         if Is_Entity_Name (E) and then Expander_Active then\n+            Find_Type (E);\n+            Type_Id := Entity (E);\n+\n+            if Is_Tagged_Type (Type_Id)\n+              and then Has_Defaulted_Discriminants (Type_Id)\n+              and then not Is_Constrained (Type_Id)\n+            then\n+               declare\n+                  Constr : constant List_Id    := New_List;\n+                  Loc    : constant Source_Ptr := Sloc (E);\n+                  Discr  : Entity_Id := First_Discriminant (Type_Id);\n \n-                  begin\n-                     while Present (Discr) loop\n-                        Append (Discriminant_Default_Value (Discr), Constr);\n-                        Next_Discriminant (Discr);\n-                     end loop;\n+               begin\n+                  while Present (Discr) loop\n+                     Append (Discriminant_Default_Value (Discr), Constr);\n+                     Next_Discriminant (Discr);\n+                  end loop;\n \n-                     Rewrite (E,\n-                       Make_Subtype_Indication (Loc,\n-                         Subtype_Mark => New_Occurrence_Of (Type_Id, Loc),\n-                         Constraint   =>\n-                           Make_Index_Or_Discriminant_Constraint (Loc,\n-                             Constraints => Constr)));\n-                  end;\n-               end if;\n+                  Rewrite (E,\n+                    Make_Subtype_Indication (Loc,\n+                      Subtype_Mark => New_Occurrence_Of (Type_Id, Loc),\n+                      Constraint   =>\n+                        Make_Index_Or_Discriminant_Constraint (Loc,\n+                          Constraints => Constr)));\n+               end;\n             end if;\n+         end if;\n \n-            if Nkind (E) = N_Subtype_Indication then\n+         if Nkind (E) = N_Subtype_Indication then\n+            declare\n+               Def_Id   : Entity_Id;\n+               Base_Typ : Entity_Id;\n \n+            begin\n                --  A constraint is only allowed for a composite type in Ada\n                --  95. In Ada 83, a constraint is also allowed for an\n                --  access-to-composite type, but the constraint is ignored.\n@@ -693,151 +692,151 @@ package body Sem_Ch4 is\n                                N_Index_Or_Discriminant_Constraint\n                   then\n                      Error_Msg_N -- CODEFIX\n-                       (\"if qualified expression was meant, \"\n-                        & \"use apostrophe!\", Constraint (E));\n+                       (\"if qualified expression was meant, use apostrophe!\",\n+                        Constraint (E));\n                   end if;\n \n                   E := New_Occurrence_Of (Def_Id, Loc);\n                   Rewrite (Expression (N), E);\n                end if;\n-            end if;\n+            end;\n+         end if;\n \n-            Type_Id := Process_Subtype (E, N);\n-            Acc_Type := Create_Itype (E_Allocator_Type, N);\n-            Set_Etype (Acc_Type, Acc_Type);\n-            Set_Directly_Designated_Type (Acc_Type, Type_Id);\n-            Check_Fully_Declared (Type_Id, N);\n+         Type_Id := Process_Subtype (E, N);\n+         Acc_Type := Create_Itype (E_Allocator_Type, N);\n+         Set_Etype (Acc_Type, Acc_Type);\n+         Set_Directly_Designated_Type (Acc_Type, Type_Id);\n+         Check_Fully_Declared (Type_Id, N);\n \n-            --  Ada 2005 (AI-231): If the designated type is itself an access\n-            --  type that excludes null, its default initialization will\n-            --  be a null object, and we can insert an unconditional raise\n-            --  before the allocator.\n+         --  Ada 2005 (AI-231): If the designated type is itself an access\n+         --  type that excludes null, its default initialization will\n+         --  be a null object, and we can insert an unconditional raise\n+         --  before the allocator.\n \n-            --  Ada 2012 (AI-104): A not null indication here is altogether\n-            --  illegal.\n+         --  Ada 2012 (AI-104): A not null indication here is altogether\n+         --  illegal.\n \n-            if Can_Never_Be_Null (Type_Id) then\n-               declare\n-                  Not_Null_Check : constant Node_Id :=\n-                                     Make_Raise_Constraint_Error (Sloc (E),\n-                                       Reason => CE_Null_Not_Allowed);\n+         if Can_Never_Be_Null (Type_Id) then\n+            declare\n+               Not_Null_Check : constant Node_Id :=\n+                                  Make_Raise_Constraint_Error (Sloc (E),\n+                                    Reason => CE_Null_Not_Allowed);\n \n-               begin\n-                  if Expander_Active then\n-                     Insert_Action (N, Not_Null_Check);\n-                     Analyze (Not_Null_Check);\n+            begin\n+               if Expander_Active then\n+                  Insert_Action (N, Not_Null_Check);\n+                  Analyze (Not_Null_Check);\n \n-                  elsif Warn_On_Ada_2012_Compatibility then\n-                     Error_Msg_N\n-                       (\"null value not allowed here in Ada 2012?y?\", E);\n-                  end if;\n-               end;\n-            end if;\n+               elsif Warn_On_Ada_2012_Compatibility then\n+                  Error_Msg_N\n+                    (\"null value not allowed here in Ada 2012?y?\", E);\n+               end if;\n+            end;\n+         end if;\n \n-            --  Check for missing initialization. Skip this check if we already\n-            --  had errors on analyzing the allocator, since in that case these\n-            --  are probably cascaded errors.\n+         --  Check for missing initialization. Skip this check if we already\n+         --  had errors on analyzing the allocator, since in that case these\n+         --  are probably cascaded errors.\n \n-            if not Is_Definite_Subtype (Type_Id)\n-              and then Serious_Errors_Detected = Sav_Errs\n+         if not Is_Definite_Subtype (Type_Id)\n+           and then Serious_Errors_Detected = Sav_Errs\n+         then\n+            --  The build-in-place machinery may produce an allocator when\n+            --  the designated type is indefinite but the underlying type is\n+            --  not. In this case the unknown discriminants are meaningless\n+            --  and should not trigger error messages. Check the parent node\n+            --  because the allocator is marked as coming from source.\n+\n+            if Present (Underlying_Type (Type_Id))\n+              and then Is_Definite_Subtype (Underlying_Type (Type_Id))\n+              and then not Comes_From_Source (Parent (N))\n             then\n-               --  The build-in-place machinery may produce an allocator when\n-               --  the designated type is indefinite but the underlying type is\n-               --  not. In this case the unknown discriminants are meaningless\n-               --  and should not trigger error messages. Check the parent node\n-               --  because the allocator is marked as coming from source.\n-\n-               if Present (Underlying_Type (Type_Id))\n-                 and then Is_Definite_Subtype (Underlying_Type (Type_Id))\n-                 and then not Comes_From_Source (Parent (N))\n-               then\n-                  null;\n+               null;\n \n-               --  An unusual case arises when the parent of a derived type is\n-               --  a limited record extension  with unknown discriminants, and\n-               --  its full view has no discriminants.\n-               --\n-               --  A more general fix might be to create the proper underlying\n-               --  type for such a derived type, but it is a record type with\n-               --  no private attributes, so this required extending the\n-               --  meaning of this attribute. ???\n-\n-               elsif Ekind (Etype (Type_Id)) = E_Record_Type_With_Private\n-                 and then Present (Underlying_Type (Etype (Type_Id)))\n-                 and then\n-                   not Has_Discriminants (Underlying_Type (Etype (Type_Id)))\n-                 and then not Comes_From_Source (Parent (N))\n+            --  An unusual case arises when the parent of a derived type is\n+            --  a limited record extension  with unknown discriminants, and\n+            --  its full view has no discriminants.\n+            --\n+            --  A more general fix might be to create the proper underlying\n+            --  type for such a derived type, but it is a record type with\n+            --  no private attributes, so this required extending the\n+            --  meaning of this attribute. ???\n+\n+            elsif Ekind (Etype (Type_Id)) = E_Record_Type_With_Private\n+              and then Present (Underlying_Type (Etype (Type_Id)))\n+              and then\n+                not Has_Discriminants (Underlying_Type (Etype (Type_Id)))\n+              and then not Comes_From_Source (Parent (N))\n+            then\n+               null;\n+\n+            elsif Is_Class_Wide_Type (Type_Id) then\n+               Error_Msg_N\n+                 (\"initialization required in class-wide allocation\", N);\n+\n+            else\n+               if Ada_Version < Ada_2005\n+                 and then Is_Limited_Type (Type_Id)\n                then\n-                  null;\n+                  Error_Msg_N (\"unconstrained allocation not allowed\", N);\n \n-               elsif Is_Class_Wide_Type (Type_Id) then\n-                  Error_Msg_N\n-                    (\"initialization required in class-wide allocation\", N);\n+                  if Is_Array_Type (Type_Id) then\n+                     Error_Msg_N\n+                       (\"\\constraint with array bounds required\", N);\n+\n+                  elsif Has_Unknown_Discriminants (Type_Id) then\n+                     null;\n+\n+                  else pragma Assert (Has_Discriminants (Type_Id));\n+                     Error_Msg_N\n+                       (\"\\constraint with discriminant values required\", N);\n+                  end if;\n+\n+               --  Limited Ada 2005 and general nonlimited case.\n+               --  This is an error, except in the case of an\n+               --  uninitialized allocator that is generated\n+               --  for a build-in-place function return of a\n+               --  discriminated but compile-time-known-size\n+               --  type.\n \n                else\n-                  if Ada_Version < Ada_2005\n-                    and then Is_Limited_Type (Type_Id)\n+                  if Original_Node (N) /= N\n+                    and then Nkind (Original_Node (N)) = N_Allocator\n                   then\n-                     Error_Msg_N (\"unconstrained allocation not allowed\", N);\n+                     declare\n+                        Qual : constant Node_Id :=\n+                          Expression (Original_Node (N));\n+                        pragma Assert\n+                          (Nkind (Qual) = N_Qualified_Expression);\n+                        Call : constant Node_Id := Expression (Qual);\n+                        pragma Assert\n+                          (Is_Expanded_Build_In_Place_Call (Call));\n+                     begin\n+                        null;\n+                     end;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"uninitialized unconstrained allocation not \"\n+                        & \"allowed\", N);\n \n                      if Is_Array_Type (Type_Id) then\n                         Error_Msg_N\n-                          (\"\\constraint with array bounds required\", N);\n+                          (\"\\qualified expression or constraint with \"\n+                           & \"array bounds required\", N);\n \n                      elsif Has_Unknown_Discriminants (Type_Id) then\n-                        null;\n+                        Error_Msg_N (\"\\qualified expression required\", N);\n \n                      else pragma Assert (Has_Discriminants (Type_Id));\n                         Error_Msg_N\n-                          (\"\\constraint with discriminant values required\", N);\n-                     end if;\n-\n-                  --  Limited Ada 2005 and general nonlimited case.\n-                  --  This is an error, except in the case of an\n-                  --  uninitialized allocator that is generated\n-                  --  for a build-in-place function return of a\n-                  --  discriminated but compile-time-known-size\n-                  --  type.\n-\n-                  else\n-                     if Original_Node (N) /= N\n-                       and then Nkind (Original_Node (N)) = N_Allocator\n-                     then\n-                        declare\n-                           Qual : constant Node_Id :=\n-                             Expression (Original_Node (N));\n-                           pragma Assert\n-                             (Nkind (Qual) = N_Qualified_Expression);\n-                           Call : constant Node_Id := Expression (Qual);\n-                           pragma Assert\n-                             (Is_Expanded_Build_In_Place_Call (Call));\n-                        begin\n-                           null;\n-                        end;\n-\n-                     else\n-                        Error_Msg_N\n-                          (\"uninitialized unconstrained allocation not \"\n-                           & \"allowed\", N);\n-\n-                        if Is_Array_Type (Type_Id) then\n-                           Error_Msg_N\n-                             (\"\\qualified expression or constraint with \"\n-                              & \"array bounds required\", N);\n-\n-                        elsif Has_Unknown_Discriminants (Type_Id) then\n-                           Error_Msg_N (\"\\qualified expression required\", N);\n-\n-                        else pragma Assert (Has_Discriminants (Type_Id));\n-                           Error_Msg_N\n-                             (\"\\qualified expression or constraint with \"\n-                              & \"discriminant values required\", N);\n-                        end if;\n+                          (\"\\qualified expression or constraint with \"\n+                           & \"discriminant values required\", N);\n                      end if;\n                   end if;\n                end if;\n             end if;\n-         end;\n+         end if;\n       end if;\n \n       if Is_Abstract_Type (Type_Id) then"}]}