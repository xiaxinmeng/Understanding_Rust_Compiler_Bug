{"sha": "f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUwZWM2MzVmYzdiNjBkNGM5NWIxMzc1MDk5MWMzYmE4Yjc3YmMwNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-19T22:25:21Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-19T22:25:21Z"}, "message": "i370-protos.h: New file.\n\n        * i370-protos.h: New file.\n\n        * i370.c: Include tm_p.h.  Fix compile time warnings.\n\n        * i370.h: Move prototypes to i370-protos.h.  Fix compile time\n        warnings.\n\n        * i370.md: Likewise.\n\nFrom-SVN: r31519", "tree": {"sha": "504e29b9292efd68df7f81dac2c5c62ed67bb73e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/504e29b9292efd68df7f81dac2c5c62ed67bb73e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/comments", "author": null, "committer": null, "parents": [{"sha": "b42b4d2c33342e5195764a06b9c505a263da734d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b42b4d2c33342e5195764a06b9c505a263da734d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b42b4d2c33342e5195764a06b9c505a263da734d"}], "stats": {"total": 169, "additions": 113, "deletions": 56}, "files": [{"sha": "1e8acd87049ab817f2dab36a042e5dec550473bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "patch": "@@ -1,3 +1,14 @@\n+2000-01-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* i370-protos.h: New file.\n+\n+\t* i370.c: Include tm_p.h.  Fix compile time warnings.\n+\t\n+\t* i370.h: Move prototypes to i370-protos.h.  Fix compile time\n+\twarnings.\n+\t\n+\t* i370.md: Likewise.\n+\n 2000-01-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* real.c (enan, einan, eiisnan, eiisneg, make_nan): Wrap in NANS."}, {"sha": "7e64acd8ed205a95138390d867b58e71ff1b7f4d", "filename": "gcc/config/i370/i370-protos.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "patch": "@@ -0,0 +1,48 @@\n+/* Definitions of target machine for GNU compiler.  System/370 version.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n+   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef RTX_CODE\n+extern int i370_branch_dest PARAMS ((rtx));\n+extern int i370_branch_length PARAMS ((rtx));\n+extern int i370_short_branch PARAMS ((rtx));\n+extern int s_operand PARAMS ((rtx, enum machine_mode));\n+extern int r_or_s_operand PARAMS ((rtx, enum machine_mode));\n+extern int unsigned_jump_follows_p PARAMS ((rtx));\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern int handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n+#endif /* TREE_CODE */\n+\n+extern char mvs_map_char PARAMS ((int));\n+extern void mvs_add_label PARAMS ((int));\n+extern int mvs_check_label PARAMS ((int));\n+extern int mvs_check_page PARAMS ((FILE *, int, int));\n+extern int mvs_function_check PARAMS ((const char *));\n+extern void mvs_add_alias PARAMS ((const char *, const char *, int));\n+extern int mvs_need_alias PARAMS ((const char *));\n+extern int mvs_get_alias PARAMS ((const char *, char *));\n+extern int mvs_check_alias PARAMS ((const char *, char *));\n+extern void i370_function_prolog PARAMS ((FILE *, int));\n+extern void check_label_emit PARAMS ((void));\n+extern void mvs_free_label_list PARAMS ((void));"}, {"sha": "9d4eb3d4e17544005159388a4549c6bd69716afa", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for System/370.\n-   Copyright (C) 1989, 93, 95, 97, 98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 95, 97-99, 2000 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"tm_p.h\"\n \n extern FILE *asm_out_file;\n \n@@ -92,7 +93,8 @@ static label_node_t *free_anchor = 0;\n /* Assembler source file descriptor.  */\n static FILE *assembler_source = 0;\n \n-label_node_t * mvs_get_label ();\n+static label_node_t * mvs_get_label PARAMS ((int));\n+static void i370_label_scan PARAMS ((void));\n \n /* ===================================================== */\n /* defines and functions specific to the HLASM assembler */\n@@ -121,14 +123,16 @@ alias_node_t;\n static alias_node_t *alias_anchor = 0;\n \n /* Alias number */\n-static alias_number = 0;\n+#ifdef LONGEXTERNAL\n+static int alias_number = 0;\n+#endif\n \n /* Define the length of the internal MVS function table.  */\n #define MVS_FUNCTION_TABLE_LENGTH 32\n \n /* C/370 internal function table.  These functions use non-standard linkage\n    and must handled in a special manner.  */\n-static char *mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n+static const char *const mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n {\n #if defined(HOST_EBCDIC) /* Changed for EBCDIC collating sequence */\n    \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_atan\", \"edc_ata2\", \"edc_cos\",\n@@ -151,7 +155,7 @@ static char *mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n /* ===================================================== */\n \n /* ASCII to EBCDIC conversion table.  */\n-static unsigned char ascebc[256] =\n+static const unsigned char ascebc[256] =\n {\n  /*00  NL    SH    SX    EX    ET    NQ    AK    BL */\n      0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,\n@@ -204,7 +208,7 @@ static unsigned char ascebc[256] =\n };\n \n /* EBCDIC to ASCII conversion table.  */\n-unsigned char ebcasc[256] =\n+static const unsigned char ebcasc[256] =\n {\n  /*00  NU    SH    SX    EX    PF    HT    LC    DL */\n      0x00, 0x01, 0x02, 0x03, 0x00, 0x09, 0x00, 0x7F,\n@@ -277,7 +281,7 @@ unsigned char ebcasc[256] =\n \n char\n mvs_map_char (c)\n-     char c;\n+     int c;\n {\n #if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)\n   fprintf (stderr, \"mvs_map_char: TE & !HE: c = %02x\\n\", c);\n@@ -389,7 +393,7 @@ i370_short_branch (insn)\n }\n \n void \n-i370_label_scan (void) \n+i370_label_scan () \n {\n    rtx insn;\n    label_node_t *lp;\n@@ -429,7 +433,6 @@ i370_label_scan (void)\n        if (JUMP_INSN == code)\n          {\n            rtx label = JUMP_LABEL (insn);\n-           int labelno;\n \n            /* If there is no label for this jump, then this\n               had better be a ADDR_VEC or an ADDR_DIFF_VEC\n@@ -442,7 +445,6 @@ i370_label_scan (void)\n                  {\n                     for (j=0; j < XVECLEN (body, 0); j++)\n                       {\n-                         int labelno;\n                          rtx lref = XVECEXP (body, 0, j);\n                          if (LABEL_REF != GET_CODE (lref)) abort ();\n                          label = XEXP (lref,0);\n@@ -476,7 +478,6 @@ i370_label_scan (void)\n                     debug_rtx (insn);\n                     for (j=0; j < XVECLEN (body, 0); j++)\n                       {\n-                         int labelno;\n                       }\n                     /* finished with the vector go do next insn */\n                     continue;\n@@ -551,8 +552,8 @@ i370_label_scan (void)\n   code, this shouldn't be a problem ...\n  */\n \n-int\n-check_label_emit (void)\n+void\n+check_label_emit ()\n {\n   if (mvs_need_base_reload)\n     {\n@@ -699,7 +700,7 @@ mvs_get_label_page(int id)\n    label element chain.  */\n \n void\n-mvs_free_label_list (void)\n+mvs_free_label_list ()\n {\n \n   if (label_anchor)\n@@ -806,7 +807,7 @@ mvs_check_page (file, code, lit)\n \n int\n mvs_function_check (name)\n-     char *name;\n+     const char *name;\n {\n   int lower, middle, upper;\n   int i;\n@@ -830,11 +831,11 @@ mvs_function_check (name)\n \n /* Add the alias to the current alias list.  */\n \n-int\n+void\n mvs_add_alias (realname, aliasname, emitted)\n-     char *realname;\n-     char *aliasname;\n-     int   emitted;\n+     const char *realname;\n+     const char *aliasname;\n+     int emitted;\n {\n   alias_node_t *ap;\n \n@@ -850,7 +851,7 @@ mvs_add_alias (realname, aliasname, emitted)\n \n int\n mvs_need_alias (realname)\n-      char *realname;\n+      const char *realname;\n {\n    if (mvs_function_check (realname))\n      return 0;\n@@ -866,7 +867,7 @@ mvs_need_alias (realname)\n \n int\n mvs_get_alias (realname, aliasname)\n-     char *realname;\n+     const char *realname;\n      char *aliasname;\n {\n #ifdef LONGEXTERNAL\n@@ -902,7 +903,7 @@ mvs_get_alias (realname, aliasname)\n \n int\n mvs_check_alias (realname, aliasname)\n-     char *realname;\n+     const char *realname;\n      char *aliasname;\n {\n #ifdef LONGEXTERNAL\n@@ -942,18 +943,13 @@ mvs_check_alias (realname, aliasname)\n    The result is 1 if the pragma was handled.  */\n \n int\n-handle_pragma (finput, node)\n-     FILE *finput;\n-     tree node;\n+handle_pragma (p_getc, p_ungetc, pname)\n+     int (* p_getc) PARAMS ((void));\n+     void (* p_ungetc) PARAMS ((int));\n+     const char *pname;\n {\n   int retval = 0;\n   register int c;\n-  register char *pname;\n-\n-  if (TREE_CODE (node) != IDENTIFIER_NODE)\n-    return 0;\n-\n-  pname = IDENTIFIER_POINTER (node);\n \n   if (strcmp (pname, \"map\") == 0)\n     {\n@@ -962,49 +958,49 @@ handle_pragma (finput, node)\n       char *s;\n \n       do {\n-\tc = getc (finput);\n+\tc = p_getc ();\n       } while (c == ' ' || c == '\\t');\n \n       if (c == '(')\n         {\n \t  s = realname;\n \t  do {\n-\t    c = getc (finput);\n+\t    c = p_getc ();\n \t  } while (c == ' ' || c == '\\t');\n \t  if (c == '\\n')\n \t    goto PRAGMA_WARNING;\n \t  do {\n \t    *s++ = c;\n-\t    c = getc (finput);\n+\t    c = p_getc ();\n \t  } while (ISALNUM(c) || c == '_');\n \t  if (c == '\\n')\n \t    goto PRAGMA_WARNING;\n \t  *s = 0;\n \n \t  if (c == ' ' || c == '\\t')\n \t    do {\n-\t      c = getc (finput);\n+\t      c = p_getc ();\n \t    } while (c == ' ' || c == '\\t');\n \t  \n \t  if (c == ',')\n \t    {\n \t      do {\n-\t        c = getc (finput);\n+\t        c = p_getc ();\n \t      } while (c == ' ' || c == '\\t');\n \t      if (c == '\"')\n \t        {\n \t          s = aliasname;\n-\t          c = getc(finput);\n+\t          c = p_getc ();\n \t          do {\n \t            if (c == '\\\\')\n \t              {\n \t                int d = 0;\n \t                do {\n-\t                  c = getc(finput);\n+\t                  c = p_getc ();\n \t                  if (c >= '0' && c <= '7')\n-\t                      d = (d << 3) | c - '0';\n+\t                      d = (d << 3) | (c - '0');\n \t                } while (c >= '0' && c <= '7');\n-\t                ungetc (c, finput);\n+\t                p_ungetc (c);\n \t                c = d;\n \t                if (d < 1 || d > 255)\n \t\t\t  warning (\"Escape value out of range\");\n@@ -1013,7 +1009,7 @@ handle_pragma (finput, node)\n #endif\n \t              }\n \t            *s++ = c;\n-\t            c = getc (finput);\n+\t            c = p_getc ();\n \t            if (ISSPACE(c) || c == ')')\n \t              goto PRAGMA_WARNING;\n \t          } while (c != '\"');\n@@ -1024,7 +1020,7 @@ handle_pragma (finput, node)\n \t\t      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n \t\t    }\n \t\t  do {\n-\t\t    c = getc (finput);\n+\t\t    c = p_getc ();\n \t\t  } while (c == ' ' || c == '\\t');\n \t\t  if (c == ')')\n \t\t    {\n@@ -1066,7 +1062,7 @@ handle_pragma (finput, node)\n \n int\n mvs_function_check (name)\n-     char *name;\n+     const char *name ATTRIBUTE_UNUSED;\n {\n    return 0;\n }\n@@ -1165,6 +1161,7 @@ r_or_s_operand (op, mode)\n    The unsigned_jump_follows_p() routine  returns a 1 if the next jump \n    is unsigned.  INSN is the current instruction.  */\n \n+int\n unsigned_jump_follows_p (insn)\n      register rtx insn;\n {\n@@ -1213,7 +1210,6 @@ i370_function_prolog (f, l)\n   static int function_first = 0;\n   static int function_year, function_month, function_day;\n   static int function_hour, function_minute, function_second;\n-  int i;\n #if defined(LE370)\n   if (!function_first)\n     {\n@@ -1260,7 +1256,7 @@ i370_function_prolog (f, l)\n   fprintf (f, \"FTIM%03d\\tDS\\t0F\\n\", function_label_index);\n   fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n   \t\t function_year, function_month, function_day,\n-    \t\t function_hour, function_minute, function_second);\n+    \t\t function_hour, function_minute);\n   fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n   fprintf (f, \"FENT%03d\\tDS\\t0H\\n\", function_label_index);\n   fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n@@ -1396,8 +1392,7 @@ i370_function_prolog (f, frame_size)\n {\n   static int function_label_index = 1;\n   static int function_first = 0;\n-  int i;\n-  int stackframe_size, soffset, aligned_size;\n+  int stackframe_size, aligned_size;\n \n   fprintf (f, \"# Function prologue\\n\");\n   /* define the stack, put it into its own data segment"}, {"sha": "42b00d0afcbec54a83cbc8e106605d844973a87e", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 93, 95, 96, 97, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 93, 95-99, 2000 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n    Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n@@ -61,7 +61,7 @@ extern int mvs_function_name_length;\n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n { { \"char-instructions\", 1, \"Generate char instructions\"},            \\\n   { \"no-char-instructions\", -1, \"Do not generate char instructions\"}, \\\n-  { \"\", TARGET_DEFAULT} }\n+  { \"\", TARGET_DEFAULT, 0} }\n \n /* To use IBM supplied macro function prologue and epilogue, define the\n    following to 1.  Should only be needed if IBM changes the definition\n@@ -152,8 +152,8 @@ extern int mvs_function_name_length;\n    text can be read.  CH is the first character after the #pragma.  The\n    result of the expression is the terminating character found\n    (newline or EOF).  */\n-#define HANDLE_PRAGMA(FILE, ungetc_unused, NODE) \\\n-  handle_pragma ((FILE), (NODE))\n+#define HANDLE_PRAGMA(GETC, UNGETC, NAME) \\\n+  handle_pragma ((GETC), (UNGETC), (NAME))\n #endif /* TARGET_HLASM */\n \n /* Define maximum length of page minus page escape overhead.  */\n@@ -392,7 +392,7 @@ enum reg_class\n /* Define which registers fit in which classes.  This is an initializer for\n    a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS {0, 0x0fffe, 0x0ffff, 0xf0000, 0xfffff}\n+#define REG_CLASS_CONTENTS {{0}, {0x0fffe}, {0x0ffff}, {0xf0000}, {0xfffff}}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -1016,6 +1016,8 @@ enum reg_class\n               /* some shifts set the CC some don't. */\t\t\t\\\n               case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n                  do {} while (0);\t\t\t\t\t\\\n+              default:\t\t\t\t\t\t\t\\\n+                break;\t\t\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}, {"sha": "20452ac12cc83a440bd8be2a2a3e55dc167e39dc", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f50ec635fc7b60d4c95b13750991c3ba8b77bc04/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=f50ec635fc7b60d4c95b13750991c3ba8b77bc04", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler -- System/370 version.\n-;;  Copyright (C) 1989, 93, 94, 95, 1997 Free Software Foundation, Inc.\n+;;  Copyright (C) 1989, 93, 94, 95, 97-99, 2000 Free Software Foundation, Inc.\n ;;  Contributed by Jan Stein (jan@cd.chalmers.se).\n ;;  Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n ;;  Lots of Bug Fixes & Enhancements by Linas Vepstas (linas@linas.org)\n@@ -1591,13 +1591,15 @@ check_label_emit ();\n   if (REG_P (operands[0]))\n     {\n       if (REG_P (operands[1]))\n+      {\n         if (REGNO (operands[0]) != REGNO (operands[1]))\n \t  {\n \t    mvs_check_page (0, 10, 0);\n             return \\\"LR\t%0,%1\\;SLL\t%0,16\\;SRA\t%0,16\\\";\n \t  }\n         else\n           return \\\"\\\"; /* Should be empty.  16-bits regs are always 32-bits.  */\n+      }\n       if (operands[1] == const0_rtx)\n \t{\n \t  CC_STATUS_INIT;\n@@ -1641,7 +1643,7 @@ check_label_emit ();\n       mvs_check_page (0, 8, 0);\n       return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n     }\n-  if (s_operand (operands[1]))\n+  if (s_operand (operands[1], GET_MODE (operands[1])))\n     {\n       mvs_check_page (0, 8, 0);\n       return \\\"ICM\t%0,8,%1\\;SRA\t%0,24\\\";\n@@ -1669,7 +1671,7 @@ check_label_emit ();\n       mvs_check_page (0, 8, 0);\n       return \\\"SLL\t%0,24\\;SRA\t%0,24\\\";\n     }\n-  if (s_operand (operands[1]))\n+  if (s_operand (operands[1], GET_MODE (operands[1])))\n     {\n       mvs_check_page (0, 8, 0);\n       return \\\"ICM\t%0,8,%1\\;SRA\t%0,24\\\";\n@@ -2718,7 +2720,6 @@ check_label_emit ();\n {\n   rtx dr = gen_reg_rtx (DImode);\n   rtx dr_0 = gen_rtx_SUBREG (SImode, dr, 0);\n-  rtx dr_1 = gen_rtx_SUBREG (SImode, dr, 1);\n \n   emit_insn (gen_rtx_SET (VOIDmode, dr_0, operands[1]));\n "}]}