{"sha": "8410737add10f9f2b70616986a6a173c312b732e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxMDczN2FkZDEwZjlmMmI3MDYxNjk4NmE2YTE3M2MzMTJiNzMyZQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-11-13T18:33:37Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-11-13T18:33:37Z"}, "message": "re PR target/41900 (call *%esp shouldn't be generated because of CPU errata)\n\n2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n\n\tPR target/41900\n\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1): Use \"lsm\"\n\tas operand 1 constraint.\n\t* config/i386/predicates.md (call_insn_operand): Depend on\n\tindex_register_operand to avoid %esp register.\n\n2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n\n\tRevert:\n\t2009-11-03  Uros Bizjak  <ubizjak@gmail.com>\n\n\tPR target/41900\n\t* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.\n\t(TARGET_CALL_ESP): New define.\n\t* config/i386/i386.c (initial_ix86_tune_features): Initialize\n\tX86_ARCH_CALL_ESP.\n\t* config/i386/i386.md (*call_pop_1_esp, *call_1_esp,\n\t*call_value_pop_1_esp, *call_value_1_esp): Rename from *call_pop_1,\n\t*call_1, *call_value_pop_1 and *call_value_1.  Depend on\n\tTARGET_CALL_ESP.\n\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):\n\tNew patterns, use \"lsm\" as operand 1 constraint.\n\t* config/i386/predicates.md (call_insn_operand): Depend on\n\tindex_register_operand for !TARGET_CALL_ESP to avoid %esp register.\n\nFrom-SVN: r154160", "tree": {"sha": "6774cedb6b67eef95d2a8c93ae8a48c63ea925c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6774cedb6b67eef95d2a8c93ae8a48c63ea925c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8410737add10f9f2b70616986a6a173c312b732e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8410737add10f9f2b70616986a6a173c312b732e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8410737add10f9f2b70616986a6a173c312b732e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8410737add10f9f2b70616986a6a173c312b732e/comments", "author": null, "committer": null, "parents": [{"sha": "0761b46229e1ccc5b573eaf972ff2a0d64477493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0761b46229e1ccc5b573eaf972ff2a0d64477493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0761b46229e1ccc5b573eaf972ff2a0d64477493"}], "stats": {"total": 128, "additions": 51, "deletions": 77}, "files": [{"sha": "bb92e10b867cf2c6392ac056d65da237d2de9119", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410737add10f9f2b70616986a6a173c312b732e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410737add10f9f2b70616986a6a173c312b732e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8410737add10f9f2b70616986a6a173c312b732e", "patch": "@@ -1,3 +1,30 @@\n+2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/41900\n+\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1): Use \"lsm\"\n+\tas operand 1 constraint.\n+\t* config/i386/predicates.md (call_insn_operand): Depend on\n+\tindex_register_operand to avoid %esp register.\n+\n+2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tRevert:\n+\t2009-11-03  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/41900\n+\t* config/i386/i386.h (ix86_arch_indices) <X86_ARCH_CALL_ESP>: New.\n+\t(TARGET_CALL_ESP): New define.\n+\t* config/i386/i386.c (initial_ix86_tune_features): Initialize\n+\tX86_ARCH_CALL_ESP.\n+\t* config/i386/i386.md (*call_pop_1_esp, *call_1_esp,\n+\t*call_value_pop_1_esp, *call_value_1_esp): Rename from *call_pop_1,\n+\t*call_1, *call_value_pop_1 and *call_value_1.  Depend on\n+\tTARGET_CALL_ESP.\n+\t(*call_pop_1, *call_1, *call_value_pop_1, *call_value_1):\n+\tNew patterns, use \"lsm\" as operand 1 constraint.\n+\t* config/i386/predicates.md (call_insn_operand): Depend on\n+\tindex_register_operand for !TARGET_CALL_ESP to avoid %esp register.\n+\n 2009-11-13  Jason Merrill  <jason@redhat.com>\n \n \tPR debug/26965\n@@ -6,9 +33,9 @@\n \n 2009-11-13  Andrey Belevantsev  <abel@ispras.ru>\n \n-        PR rtl-optimization/41697\n-\t* sel-sched-ir.c (fallthru_bb_of_jump): Bail out when a block with \n-\ta conditional jump has a single successor. \n+\tPR rtl-optimization/41697\n+\t* sel-sched-ir.c (fallthru_bb_of_jump): Bail out when a block with\n+\ta conditional jump has a single successor.\n \n 2009-11-13  Andrey Belevantsev  <abel@ispras.ru>\n \n@@ -31,8 +58,8 @@\n \tper-insn data in smaller chunks.\n \t* sel-sched-ir.h (free_data_for_scheduled_insn): Export.\n \t* sel-sched.c (update_seqnos_and_stage): Free INSN_DEPS_CONTEXT\n-\tin scheduled insn. \n-\t\n+\tin scheduled insn.\n+\n 2009-11-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (call_value): Fix comment.\n@@ -101,7 +128,7 @@\n \tPR middle-end/41440\n \t* cfgexpand.c (expand_gimple_basic_block): Append NOP to a fallthru,\n \tsingle successor block, ending with jump created by RTL expander.\n-\t\n+\n 2009-11-11  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/41729"}, {"sha": "69e4e61b1b9f76a1f2e9533c1c294362d3f661ed", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8410737add10f9f2b70616986a6a173c312b732e", "patch": "@@ -1553,11 +1553,6 @@ static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {\n \n   /* X86_ARCH_BSWAP: Byteswap was added for 80486.  */\n   ~m_386,\n-\n-  /* X86_ARCH_CALL_ESP: P6 processors will jump to the address after\n-     the decrement (so they will execute return address as code).  See\n-     Pentium Pro errata 70, Pentium 2 errata A33, Pentium 3 errata E17.  */\n-  ~(m_386 | m_486 | m_PENT | m_PPRO),\n };\n \n static const unsigned int x86_accumulate_outgoing_args"}, {"sha": "eb1c86fa2a894bb787fcaf35db471512ddf1d983", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8410737add10f9f2b70616986a6a173c312b732e", "patch": "@@ -402,7 +402,6 @@ enum ix86_arch_indices {\n   X86_ARCH_CMPXCHG8B,\n   X86_ARCH_XADD,\n   X86_ARCH_BSWAP,\n-  X86_ARCH_CALL_ESP,\n \n   X86_ARCH_LAST\n };\n@@ -414,7 +413,6 @@ extern unsigned char ix86_arch_features[X86_ARCH_LAST];\n #define TARGET_CMPXCHG8B\tix86_arch_features[X86_ARCH_CMPXCHG8B]\n #define TARGET_XADD\t\tix86_arch_features[X86_ARCH_XADD]\n #define TARGET_BSWAP\t\tix86_arch_features[X86_ARCH_BSWAP]\n-#define TARGET_CALL_ESP\t\tix86_arch_features[X86_ARCH_CALL_ESP]\n \n #define TARGET_FISTTP\t\t(TARGET_SSE3 && TARGET_80387)\n "}, {"sha": "d896205530f95a3131b5e3bd6a82b9b9b32a5cb4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 17, "deletions": 61, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8410737add10f9f2b70616986a6a173c312b732e", "patch": "@@ -14562,6 +14562,10 @@\n ;; checked for calls.  This is a bug in the generic code, but it isn't that\n ;; easy to fix.  Ignore it for now and be prepared to fix things up.\n \n+;; P6 processors will jump to the address after the decrement when %esp\n+;; is used as a call operand, so they will execute return address as a code.\n+;; See Pentium Pro errata 70, Pentium 2 errata A33 and Pentium 3 errata E17.\n+ \n ;; Call subroutine returning no value.\n \n (define_expand \"call_pop\"\n@@ -14592,27 +14596,13 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_pop_1_esp\"\n-  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"rsm\"))\n-\t (match_operand:SI 1 \"\" \"\"))\n-   (set (reg:SI SP_REG)\n-\t(plus:SI (reg:SI SP_REG)\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"call\\t%P0\";\n-  return \"call\\t%A0\";\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*call_pop_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n \t (match_operand:SI 1 \"\" \"\"))\n    (set (reg:SI SP_REG)\n \t(plus:SI (reg:SI SP_REG)\n \t\t (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+  \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n@@ -14664,21 +14654,10 @@\n }\n   [(set_attr \"type\" \"call\")])\n \n-(define_insn \"*call_1_esp\"\n-  [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"rsm\"))\n-\t (match_operand 1 \"\" \"\"))]\n-  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[0], Pmode))\n-    return \"call\\t%P0\";\n-  return \"call\\t%A0\";\n-}\n-  [(set_attr \"type\" \"call\")])\n-\n (define_insn \"*call_1\"\n   [(call (mem:QI (match_operand:SI 0 \"call_insn_operand\" \"lsm\"))\n \t (match_operand 1 \"\" \"\"))]\n-  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+  \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[0], Pmode))\n     return \"call\\t%P0\";\n@@ -21158,8 +21137,9 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"constant_call_address_operand\" \"\"))\n \t      (match_operand:SI 2 \"\" \"\")))\n-   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n   \"!TARGET_64BIT\"\n {\n   if (SIBLING_CALL_P (insn))\n@@ -21169,27 +21149,14 @@\n }\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn \"*call_value_pop_1_esp\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"rsm\"))\n-\t      (match_operand:SI 2 \"\" \"\")))\n-   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value_pop_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))\n-   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n     return \"call\\t%P1\";\n@@ -21201,8 +21168,9 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"sibcall_insn_operand\" \"s,U\"))\n \t      (match_operand:SI 2 \"\" \"\")))\n-   (set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG)\n-\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i,i\")))]\n+   (set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 3 \"immediate_operand\" \"i,i\")))]\n   \"!TARGET_64BIT && SIBLING_CALL_P (insn)\"\n   \"@\n    jmp\\t%P1\n@@ -21261,23 +21229,11 @@\n }\n   [(set_attr \"type\" \"callv\")])\n \n-(define_insn \"*call_value_1_esp\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"rsm\"))\n-\t      (match_operand:SI 2 \"\" \"\")))]\n-  \"!TARGET_64BIT && TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n-{\n-  if (constant_call_address_operand (operands[1], Pmode))\n-    return \"call\\t%P1\";\n-  return \"call\\t%A1\";\n-}\n-  [(set_attr \"type\" \"callv\")])\n-\n (define_insn \"*call_value_1\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:QI (match_operand:SI 1 \"call_insn_operand\" \"lsm\"))\n \t      (match_operand:SI 2 \"\" \"\")))]\n-  \"!TARGET_64BIT && !TARGET_CALL_ESP && !SIBLING_CALL_P (insn)\"\n+  \"!TARGET_64BIT && !SIBLING_CALL_P (insn)\"\n {\n   if (constant_call_address_operand (operands[1], Pmode))\n     return \"call\\t%P1\";"}, {"sha": "b21e895be782903e1f7e3b21d18f5011e3c46156", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8410737add10f9f2b70616986a6a173c312b732e/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=8410737add10f9f2b70616986a6a173c312b732e", "patch": "@@ -561,9 +561,7 @@\n ;; Test for a valid operand for a call instruction.\n (define_predicate \"call_insn_operand\"\n   (ior (match_operand 0 \"constant_call_address_operand\")\n-       (ior (and (match_operand 0 \"register_no_elim_operand\")\n-\t\t (ior (match_test \"TARGET_CALL_ESP\")\n-\t\t      (match_operand 0 \"index_register_operand\")))\n+       (ior (match_operand 0 \"index_register_operand\")\n \t    (match_operand 0 \"memory_operand\"))))\n \n ;; Similarly, but for tail calls, in which we cannot allow memory references."}]}