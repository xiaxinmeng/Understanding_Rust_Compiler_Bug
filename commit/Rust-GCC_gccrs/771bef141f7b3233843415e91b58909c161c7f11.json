{"sha": "771bef141f7b3233843415e91b58909c161c7f11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcxYmVmMTQxZjdiMzIzMzg0MzQxNWU5MWI1ODkwOWMxNjFjN2YxMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2015-02-04T16:39:16Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2015-02-04T16:39:16Z"}, "message": "fpmath-sf.S (__rl78_int_pack_a_r8): Fix edge case rounding up the fraction.\n\n\t* config/rl78/fpmath-sf.S (__rl78_int_pack_a_r8): Fix edge case\n\trounding up the fraction.\n\n\t* config/rl78/rl78.c (rl78_note_reg_set): Note the use of REGs\n\tinside a MEM.\n\nFrom-SVN: r220410", "tree": {"sha": "f38afb1a2745b90f21c2060a666dd6bc4ce1c643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f38afb1a2745b90f21c2060a666dd6bc4ce1c643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/771bef141f7b3233843415e91b58909c161c7f11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771bef141f7b3233843415e91b58909c161c7f11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/771bef141f7b3233843415e91b58909c161c7f11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/771bef141f7b3233843415e91b58909c161c7f11/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f435bff380b38ad9ecd5b67a54de88c1ee5b1d22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f435bff380b38ad9ecd5b67a54de88c1ee5b1d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f435bff380b38ad9ecd5b67a54de88c1ee5b1d22"}], "stats": {"total": 392, "additions": 254, "deletions": 138}, "files": [{"sha": "74728f83d16b9f2da6a41520738f62e1badfee17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771bef141f7b3233843415e91b58909c161c7f11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771bef141f7b3233843415e91b58909c161c7f11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=771bef141f7b3233843415e91b58909c161c7f11", "patch": "@@ -1,3 +1,8 @@\n+2015-02-04  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/rl78.c (rl78_note_reg_set): Note the use of REGs\n+\tinside a MEM.\n+\n 2015-02-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* builtins.def (DEF_BUILTIN_CHKP): Define if not defined."}, {"sha": "1ab483e01a30a9a341520b7c8a7721ddbe4bc676", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 234, "deletions": 134, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771bef141f7b3233843415e91b58909c161c7f11/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771bef141f7b3233843415e91b58909c161c7f11/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=771bef141f7b3233843415e91b58909c161c7f11", "patch": "@@ -1003,7 +1003,6 @@ rl78_valid_pointer_mode (machine_mode m)\n   return (m == HImode || m == SImode);\n }\n \n-\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P\t\trl78_is_legitimate_constant\n \n@@ -2723,7 +2722,7 @@ transcode_memory_rtx (rtx m, rtx newbase, rtx before)\n \n   if (REGNO (base) == SP_REG)\n     {\n-      if (addend >= 0 && addend  <= limit)\n+      if (addend >= 0 && addend <= limit)\n \treturn m;\n     }\n \n@@ -2933,8 +2932,8 @@ rl78_alloc_physical_registers_op1 (rtx_insn * insn)\n \t It is tempting to perform this optimization when OP(0) does\n \t not hold a MEM, but this leads to bigger code in general.\n \t The problem is that if OP(1) holds a MEM then swapping it\n-\t into BC means a BC-relative load is used and these 3 bytes\n-\t long vs 1 byte for an HL load.  */\n+\t into BC means a BC-relative load is used and these are 3\n+\t bytes long vs 1 byte for an HL load.  */\n       if (MEM_P (OP (0))\n \t  && already_contains (HL, XEXP (OP (0), 0)))\n \t{\n@@ -3379,6 +3378,12 @@ rl78_alloc_address_registers_macax (rtx_insn * insn)\n   MUST_BE_OK (insn);\n }\n \n+static void\n+rl78_alloc_address_registers_div (rtx_insn * insn)\n+{\n+  MUST_BE_OK (insn);\n+}\n+\n /* Scan all insns and devirtualize them.  */\n static void\n rl78_alloc_physical_registers (void)\n@@ -3457,6 +3462,18 @@ rl78_alloc_physical_registers (void)\n \t  record_content (BC, NULL_RTX);\n \t  record_content (DE, NULL_RTX);\n \t}\n+      else if (valloc_method == VALLOC_DIVHI)\n+\t{\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t}\n+      else if (valloc_method == VALLOC_DIVSI)\n+\t{\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n+\t  record_content (HL, NULL_RTX);\n+\t}\n \n       if (insn_ok_now (insn))\n \tcontinue;\n@@ -3492,6 +3509,20 @@ rl78_alloc_physical_registers (void)\n \t  record_content (BC, NULL_RTX);\n \t  record_content (DE, NULL_RTX);\n \t  break;\n+\tcase VALLOC_DIVSI:\n+\t  rl78_alloc_address_registers_div (insn);\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  record_content (DE, NULL_RTX);\n+\t  record_content (HL, NULL_RTX);\n+\t  break;\n+\tcase VALLOC_DIVHI:\n+\t  rl78_alloc_address_registers_div (insn);\n+\t  record_content (AX, NULL_RTX);\n+\t  record_content (BC, NULL_RTX);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n       if (JUMP_P (insn) || CALL_P (insn) || GET_CODE (pattern) == CALL)\n@@ -3577,6 +3608,9 @@ rl78_note_reg_set (char *dead, rtx d, rtx insn)\n {\n   int r, i;\n \n+  if (GET_CODE (d) == MEM)\n+    rl78_note_reg_uses (dead, XEXP (d, 0), insn);\n+\n   if (GET_CODE (d) != REG)\n     return;\n \n@@ -3620,7 +3654,21 @@ rl78_calculate_death_notes (void)\n \tcase INSN:\n \t  p = PATTERN (insn);\n \t  if (GET_CODE (p) == PARALLEL)\n-\t    p = XVECEXP (p, 0, 0);\n+\t    {\n+\t      rtx q = XVECEXP (p, 0 ,1);\n+\n+\t      /* This happens with the DIV patterns.  */\n+\t      if (GET_CODE (q) == SET)\n+\t\t{\n+\t\t  s = SET_SRC (q);\n+\t\t  d = SET_DEST (q);\n+\t\t  rl78_note_reg_set (dead, d, insn);\n+\t\t  rl78_note_reg_uses (dead, s, insn);\n+\n+\t\t}\n+\t      p = XVECEXP (p, 0, 0);\n+\t    }\n+\n \t  switch (GET_CODE (p))\n \t    {\n \t    case SET:\n@@ -3674,6 +3722,175 @@ reset_origins (int *rp, int *age)\n     }\n }\n \n+static void\n+set_origin (rtx pat, rtx_insn * insn, int * origins, int * age)\n+{\n+  rtx src = SET_SRC (pat);\n+  rtx dest = SET_DEST (pat);\n+  int mb = GET_MODE_SIZE (GET_MODE (dest));\n+  int i;\n+\n+  if (GET_CODE (dest) == REG)\n+    {\n+      int dr = REGNO (dest);\n+\n+      if (GET_CODE (src) == REG)\n+\t{\n+\t  int sr = REGNO (src);\n+\t  bool same = true;\n+\t  int best_age, best_reg;\n+\n+\t  /* See if the copy is not needed.  */\n+\t  for (i = 0; i < mb; i ++)\n+\t    if (origins[dr + i] != origins[sr + i])\n+\t      same = false;\n+\n+\t  if (same)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"deleting because dest already has correct value\\n\");\n+\t      delete_insn (insn);\n+\t      return;\n+\t    }\n+\n+\t  if (dr < 8 || sr >= 8)\n+\t    {\n+\t      int ar;\n+\n+\t      best_age = -1;\n+\t      best_reg = -1;\n+\n+\t      /* See if the copy can be made from another\n+\t\t bank 0 register instead, instead of the\n+\t\t virtual src register.  */\n+\t      for (ar = 0; ar < 8; ar += mb)\n+\t\t{\n+\t\t  same = true;\n+\n+\t\t  for (i = 0; i < mb; i ++)\n+\t\t    if (origins[ar + i] != origins[sr + i])\n+\t\t      same = false;\n+\n+\t\t  /* The chip has some reg-reg move limitations.  */\n+\t\t  if (mb == 1 && dr > 3)\n+\t\t    same = false;\n+\n+\t\t  if (same)\n+\t\t    {\n+\t\t      if (best_age == -1 || best_age > age[sr + i])\n+\t\t\t{\n+\t\t\t  best_age = age[sr + i];\n+\t\t\t  best_reg = sr;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      if (best_reg != -1)\n+\t\t{\n+\t\t  /* FIXME: copy debug info too.  */\n+\t\t  SET_SRC (pat) = gen_rtx_REG (GET_MODE (src), best_reg);\n+\t\t  sr = best_reg;\n+\t\t}\n+\t    }\n+\n+\t  for (i = 0; i < mb; i++)\n+\t    {\n+\t      origins[dr + i] = origins[sr + i];\n+\t      age[dr + i] = age[sr + i] + 1;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* The destination is computed, its origin is itself.  */\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"resetting origin of r%d for %d byte%s\\n\",\n+\t\t     dr, mb, mb == 1 ? \"\" : \"s\");\n+\n+\t  for (i = 0; i < mb; i ++)\n+\t    {\n+\t      origins[dr + i] = dr + i;\n+\t      age[dr + i] = 0;\n+\t    }\n+\t}\n+\n+      /* Any registers marked with that reg as an origin are reset.  */\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (origins[i] >= dr && origins[i] < dr + mb)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n+\n+  /* Special case - our MUL patterns uses AX and sometimes BC.  */\n+  if (get_attr_valloc (insn) == VALLOC_MACAX)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Resetting origin of AX/BC for MUL pattern.\\n\");\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (i <= 3 || origins[i] <= 3)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n+  else if (get_attr_valloc (insn) == VALLOC_DIVHI)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Resetting origin of AX/DE for DIVHI pattern.\\n\");\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (i == A_REG\n+\t    || i == X_REG\n+\t    || i == D_REG\n+\t    || i == E_REG\n+\t    || origins[i] == A_REG\n+\t    || origins[i] == X_REG\n+\t    || origins[i] == D_REG\n+\t    || origins[i] == E_REG)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n+  else if (get_attr_valloc (insn) == VALLOC_DIVSI)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Resetting origin of AX/BC/DE/HL for DIVSI pattern.\\n\");\n+\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (i <= 7 || origins[i] <= 7)\n+\t  {\n+\t    origins[i] = i;\n+\t    age[i] = 0;\n+\t  }\n+    }\n+\n+  if (GET_CODE (src) == ASHIFT\n+      || GET_CODE (src) == ASHIFTRT\n+      || GET_CODE (src) == LSHIFTRT)\n+    {\n+      rtx count = XEXP (src, 1);\n+\n+      if (GET_CODE (count) == REG)\n+\t{\n+\t  /* Special case - our pattern clobbers the count register.  */\n+\t  int r = REGNO (count);\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Resetting origin of r%d for shift.\\n\", r);\n+\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (i == r || origins[i] == r)\n+\t      {\n+\t\torigins[i] = i;\n+\t\tage[i] = 0;\n+\t      }\n+\t}\n+    }\n+}\n+\n /* The idea behind this optimization is to look for cases where we\n    move data from A to B to C, and instead move from A to B, and A to\n    C.  If B is a virtual register or memory, this is a big win on its\n@@ -3740,136 +3957,18 @@ rl78_propogate_register_origins (void)\n \t\t      age[cr + i] = 0;\n \t\t    }\n \t\t}\n+\t      /* This happens with the DIV patterns.  */\n+\t      else if (GET_CODE (clobber) == SET)\n+\t\t{\n+\t\t  set_origin (clobber, insn, origins, age);\n+\t\t}\n \t      else\n \t\tbreak;\n \t    }\n \n \t  if (GET_CODE (pat) == SET)\n \t    {\n-\t      rtx src = SET_SRC (pat);\n-\t      rtx dest = SET_DEST (pat);\n-\t      int mb = GET_MODE_SIZE (GET_MODE (dest));\n-\n-\t      if (GET_CODE (dest) == REG)\n-\t\t{\n-\t\t  int dr = REGNO (dest);\n-\n-\t\t  if (GET_CODE (src) == REG)\n-\t\t    {\n-\t\t      int sr = REGNO (src);\n-\t\t      int same = 1;\n-\t\t      int best_age, best_reg;\n-\n-\t\t      /* See if the copy is not needed.  */\n-\t\t      for (i = 0; i < mb; i ++)\n-\t\t\tif (origins[dr + i] != origins[sr + i])\n-\t\t\t  same = 0;\n-\t\t      if (same)\n-\t\t\t{\n-\t\t\t  if (dump_file)\n-\t\t\t    fprintf (dump_file, \"deleting because dest already has correct value\\n\");\n-\t\t\t  delete_insn (insn);\n-\t\t\t  break;\n-\t\t\t}\n-\n-\t\t      if (dr < 8 || sr >= 8)\n-\t\t\t{\n-\t\t\t  int ar;\n-\n-\t\t\t  best_age = -1;\n-\t\t\t  best_reg = -1;\n-\t\t\t  /* See if the copy can be made from another\n-\t\t\t     bank 0 register instead, instead of the\n-\t\t\t     virtual src register.  */\n-\t\t\t  for (ar = 0; ar < 8; ar += mb)\n-\t\t\t    {\n-\t\t\t      same = 1;\n-\t\t\t      for (i = 0; i < mb; i ++)\n-\t\t\t\tif (origins[ar + i] != origins[sr + i])\n-\t\t\t\t  same = 0;\n-\n-\t\t\t      /* The chip has some reg-reg move limitations.  */\n-\t\t\t      if (mb == 1 && dr > 3)\n-\t\t\t\tsame = 0;\n-\n-\t\t\t      if (same)\n-\t\t\t\t{\n-\t\t\t\t  if (best_age == -1 || best_age > age[sr + i])\n-\t\t\t\t    {\n-\t\t\t\t      best_age = age[sr + i];\n-\t\t\t\t      best_reg = sr;\n-\t\t\t\t    }\n-\t\t\t\t}\n-\t\t\t    }\n-\n-\t\t\t  if (best_reg != -1)\n-\t\t\t    {\n-\t\t\t      /* FIXME: copy debug info too.  */\n-\t\t\t      SET_SRC (pat) = gen_rtx_REG (GET_MODE (src), best_reg);\n-\t\t\t      sr = best_reg;\n-\t\t\t    }\n-\t\t\t}\n-\n-\t\t      for (i = 0; i < mb; i++)\n-\t\t\t{\n-\t\t\t  origins[dr + i] = origins[sr + i];\n-\t\t\t  age[dr + i] = age[sr + i] + 1;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The destination is computed, its origin is itself.  */\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"resetting origin of r%d for %d byte%s\\n\",\n-\t\t\t\t dr, mb, mb == 1 ? \"\" : \"s\");\n-\t\t      for (i = 0; i < mb; i ++)\n-\t\t\t{\n-\t\t\t  origins[dr + i] = dr + i;\n-\t\t\t  age[dr + i] = 0;\n-\t\t\t}\n-\t\t    }\n-\n-\t\t  /* Any registers marked with that reg as an origin are reset.  */\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (origins[i] >= dr && origins[i] < dr + mb)\n-\t\t      {\n-\t\t\torigins[i] = i;\n-\t\t\tage[i] = 0;\n-\t\t      }\n-\t\t}\n-\n-\t      /* Special case - our ADDSI3 macro uses AX and sometimes BC.  */\n-\t      if (get_attr_valloc (insn) == VALLOC_MACAX)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file, \"Resetting origin of AX/BC for macro.\\n\");\n-\t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t    if (i <= 3 || origins[i] <= 3)\n-\t\t      {\n-\t\t\torigins[i] = i;\n-\t\t\tage[i] = 0;\n-\t\t      }\n-\t\t}\n-\n-\t      if (GET_CODE (src) == ASHIFT\n-\t\t  || GET_CODE (src) == ASHIFTRT\n-\t\t  || GET_CODE (src) == LSHIFTRT)\n-\t\t{\n-\t\t  rtx count = XEXP (src, 1);\n-\t\t  if (GET_CODE (count) == REG)\n-\t\t    {\n-\t\t      /* Special case - our pattern clobbers the count register.  */\n-\t\t      int r = REGNO (count);\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"Resetting origin of r%d for shift.\\n\", r);\n-\t\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\t\tif (i == r || origins[i] == r)\n-\t\t\t  {\n-\t\t\t    origins[i] = i;\n-\t\t\t    age[i] = 0;\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n+\t      set_origin (pat, insn, origins, age);\n \t    }\n \t  else if (GET_CODE (pat) == CLOBBER\n \t\t   && GET_CODE (XEXP (pat, 0)) == REG)\n@@ -3907,7 +4006,11 @@ rl78_remove_unused_sets (void)\n \tcontinue;\n \n       if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n-\tdelete_insn (insn);\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"deleting because the set register is never used.\\n\");\n+\t  delete_insn (insn);\n+\t}\n     }\n }\n \n@@ -4023,8 +4126,6 @@ static bool rl78_rtx_costs (rtx   x,\n }\n \f\n \n-\f\n-\n static GTY(()) section * saddr_section;\n static GTY(()) section * frodata_section;\n \n@@ -4326,7 +4427,6 @@ rl78_asm_out_integer (rtx x, unsigned int size, int aligned_p)\n \n   return false;\n }\n- \n \f\n #undef  TARGET_UNWIND_WORD_MODE\n #define TARGET_UNWIND_WORD_MODE rl78_unwind_word_mode\n@@ -4441,7 +4541,7 @@ rl78_flags_already_set (rtx op, rtx operand)\n \n   return res;\n }\n- \f\n+\f\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rl78.h\""}, {"sha": "d5540b0ab3825fc1af0f68e348f71007a8156657", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771bef141f7b3233843415e91b58909c161c7f11/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771bef141f7b3233843415e91b58909c161c7f11/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=771bef141f7b3233843415e91b58909c161c7f11", "patch": "@@ -1,3 +1,8 @@\n+2015-02-02  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rl78/fpmath-sf.S (__rl78_int_pack_a_r8): Fix edge case\n+\trounding up the fraction.\n+\n 2015-01-31  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/linux-atomic.c (__kernel_cmpxchg2): Change declaration of"}, {"sha": "6d4d4bd897fd2f395953d72d463531c3761b3f62", "filename": "libgcc/config/rl78/fpmath-sf.S", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/771bef141f7b3233843415e91b58909c161c7f11/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/771bef141f7b3233843415e91b58909c161c7f11/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frl78%2Ffpmath-sf.S?ref=771bef141f7b3233843415e91b58909c161c7f11", "patch": "@@ -49,9 +49,6 @@ START_FUNC\t__int_isinf\n \n END_FUNC\t__int_isinf\n \n-START_FUNC\t_int_unpack_sf\n-\t;; convert 32-bit SFmode [DE] to 6-byte struct [HL] (\"A\")\n-\n #define A_SIGN\t\t[hl+0]\t/* byte */\n #define A_EXP\t\t[hl+2]\t/* word */\n #define A_FRAC_L\t[hl+4]\t/* word */\n@@ -66,6 +63,9 @@ START_FUNC\t_int_unpack_sf\n #define B_FRAC_H\t[hl+14]\n #define B_FRAC_HH\t[hl+15]\n \n+START_FUNC\t_int_unpack_sf\n+\t;; convert 32-bit SFmode [DE] to 6-byte struct [HL] (\"A\")\n+\n \tmov\ta, [de+3]\n \tsar\ta, 7\n \tmov\tA_SIGN, a\n@@ -517,8 +517,14 @@ START_FUNC\t__rl78_int_pack_a_r8\n \tmovw\tax, A_FRAC_L\n \taddw\tax, #1\n \tmovw\tA_FRAC_L, ax\n-\tsknc\n+\tbnc\t$1f\n \tincw\tA_FRAC_H\n+\n+\t;; If the rounding set the bit beyond the end of the fraction, increment the exponent.\n+\tmov\ta, A_FRAC_HH\n+\tbf\ta.1, $1f\n+\tincw\tA_EXP\n+\t\n 1:\t\n \tmovw\tax, A_FRAC_H\n \tshrw\tax, 1"}]}