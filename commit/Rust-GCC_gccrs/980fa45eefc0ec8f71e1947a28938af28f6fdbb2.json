{"sha": "980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwZmE0NWVlZmMwZWM4ZjcxZTE5NDdhMjg5MzhhZjI4ZjZmZGJiMg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-06-10T15:31:42Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-06-10T15:31:42Z"}, "message": "gfortran.h (gfc_expr): Add no_bounds_check field.\n\n2018-06-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.h (gfc_expr): Add no_bounds_check field.\n\t* frontend-passes.c (get_array_inq_function): Set no_bounds_check\n\ton function and function argument.\n\t(inline_matmul_assign): Set no_bounds_check on zero expression\n\tand on lhs of zero expression.\n\tAlso handle A1B2 case if realloc on assigment is active.\n\t* trans-array.c (gfc_conv_array_ref): Don't do range checking\n\tif expr has no_bounds_check set.\n\t(gfc_conv_expr_descriptor): Set no_bounds_check on ss if expr\n\thas it set.\n\t* trans-expr.c (gfc_trans_assignment_1): Set no_bounds_check\n\ton lss and lss if the corresponding expressions have it set.\n\n2018-06-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* gfortran.dg/inline_matmul_23.f90: New test.\n\nFrom-SVN: r261388", "tree": {"sha": "6beac9da84a5344f39428891e904a85f281417f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6beac9da84a5344f39428891e904a85f281417f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/comments", "author": null, "committer": null, "parents": [{"sha": "dcdae924d27a737dcda16bac7d9dfad5fbdfba6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcdae924d27a737dcda16bac7d9dfad5fbdfba6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcdae924d27a737dcda16bac7d9dfad5fbdfba6a"}], "stats": {"total": 91, "additions": 78, "deletions": 13}, "files": [{"sha": "2fea88d42193ef04001cd87218414e9c36f80702", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -1,3 +1,18 @@\n+2018-06-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_expr): Add no_bounds_check field.\n+\t* frontend-passes.c (get_array_inq_function): Set no_bounds_check\n+\ton function and function argument.\n+\t(inline_matmul_assign): Set no_bounds_check on zero expression\n+\tand on lhs of zero expression.\n+\tAlso handle A1B2 case if realloc on assigment is active.\n+\t* trans-array.c (gfc_conv_array_ref): Don't do range checking\n+\tif expr has no_bounds_check set.\n+\t(gfc_conv_expr_descriptor): Set no_bounds_check on ss if expr\n+\thas it set.\n+\t* trans-expr.c (gfc_trans_assignment_1): Set no_bounds_check\n+\ton lss and lss if the corresponding expressions have it set.\n+\n 2018-06-10  Dominique d'Humieres  <dominiq@gcc.gnu.org>\n \n \tPR fortran/79854\n@@ -13,7 +28,7 @@\n \t* gfortran.h: Add a comment to sym_intent.\n \n 2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>\n- \n+\n \tPR fortran/38351\n \t* resolve.c (resolve_operator): Provide better error message for\n \tderived type entity used in an binary intrinsic numeric operator."}, {"sha": "6d3a12ac5704215e8ec68d14fa4992fc9992a78f", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -2938,9 +2938,14 @@ get_array_inq_function (gfc_isym_id id, gfc_expr *e, int dim)\n \t\t\t   gfc_index_integer_kind);\n \n   ec = gfc_copy_expr (e);\n+\n+  /* No bounds checking, this will be done before the loops if -fcheck=bounds\n+     is in effect.  */\n+  ec->no_bounds_check = 1;\n   fcn = gfc_build_intrinsic_call (current_ns, id, name, e->where, 3,\n \t\t\t\t  ec, dim_arg,  kind);\n   gfc_simplify_expr (fcn, 0);\n+  fcn->no_bounds_check = 1;\n   return fcn;\n }\n \n@@ -3645,6 +3650,9 @@ scalarized_expr (gfc_expr *e_in, gfc_expr **index, int count_index)\n \t}\n     }\n \n+  /* Bounds checking will be done before the loops if -fcheck=bounds\n+     is in effect. */\n+  e->no_bounds_check = 1;\n   return e;\n }\n \n@@ -3832,7 +3840,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \t    m_case = A1B2;\n \t}\n     }\n-    \n+\n   if (m_case == none)\n     return 0;\n \n@@ -3911,10 +3919,13 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n       next_code_point = &if_limit->block->next;\n     }\n \n+  zero_e->no_bounds_check = 1;\n+\n   assign_zero = XCNEW (gfc_code);\n   assign_zero->op = EXEC_ASSIGN;\n   assign_zero->loc = co->loc;\n   assign_zero->expr1 = gfc_copy_expr (expr1);\n+  assign_zero->expr1->no_bounds_check = 1;\n   assign_zero->expr2 = zero_e;\n \n   /* Handle the reallocation, if needed.  */\n@@ -3926,20 +3937,33 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \t bounds checking, the rest will be allocated.  Also check this\n \t for A2B1.   */\n \n-      if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS) && (m_case == A2B2 || m_case == A2B1))\n+      if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n \t{\n \t  gfc_code *test;\n-\t  gfc_expr *a2, *b1;\n-\n-\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n-\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n-\t  test = runtime_error_ne (b1, a2, \"Dimension of array B incorrect \"\n-\t\t\t\t   \"in MATMUL intrinsic: Is %ld, should be %ld\");\n-\t  *next_code_point = test;\n-\t  next_code_point = &test->next;\n+\t  if (m_case == A2B2 || m_case == A2B1)\n+\t    {\n+\t      gfc_expr *a2, *b1;\n+\n+\t      a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\t      b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t      test = runtime_error_ne (b1, a2, \"Dimension of array B incorrect \"\n+\t\t\t\t       \"in MATMUL intrinsic: Is %ld, should be %ld\");\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n+\t  else if (m_case == A1B2)\n+\t    {\n+\t      gfc_expr *a1, *b1;\n+\n+\t      a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t      b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\t      test = runtime_error_ne (b1, a1, \"Dimension of array B incorrect \"\n+\t\t\t\t       \"in MATMUL intrinsic: Is %ld, should be %ld\");\n+\t      *next_code_point = test;\n+\t      next_code_point = &test->next;\n+\t    }\n \t}\n \n-\n       lhs_alloc = matmul_lhs_realloc (expr1, matrix_a, matrix_b, m_case);\n \n       *next_code_point = lhs_alloc;"}, {"sha": "1d98d2554c739b09b67fffb0b4656fb4a818344c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -2145,6 +2145,10 @@ typedef struct gfc_expr\n   /* Will require finalization after use.  */\n   unsigned int must_finalize : 1;\n \n+  /* Set this if no range check should be performed on this expression.  */\n+\n+  unsigned int no_bounds_check : 1;\n+\n   /* If an expression comes from a Hollerith constant or compile-time\n      evaluation of a transfer statement, it may have a prescribed target-\n      memory representation, and these cannot always be backformed from"}, {"sha": "193411c2674c827291887c9dddc3155123a35d58", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -3583,7 +3583,7 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n       gfc_conv_expr_type (&indexse, ar->start[n], gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &indexse.pre);\n \n-      if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+      if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS) && ! expr->no_bounds_check)\n \t{\n \t  /* Check array bounds.  */\n \t  tree cond;\n@@ -7181,6 +7181,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n     /* The right-hand side of a pointer assignment mustn't use a temporary.  */\n     gcc_assert (!se->direct_byref);\n \n+  /* Do we need bounds checking or not?  */\n+  ss->no_bounds_check = expr->no_bounds_check;\n+\n   /* Setup the scalarizing loops and bounds.  */\n   gfc_conv_ss_startstride (&loop);\n "}, {"sha": "b2a645beba48bcfea0047dee1fc3a1fce2775bad", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -9991,6 +9991,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t || expr2->value.function.isym->conversion)))\n \tlss->is_alloc_lhs = 1;\n     }\n+  else\n+    lss->no_bounds_check = expr1->no_bounds_check;\n \n   rss = NULL;\n \n@@ -10045,6 +10047,7 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n       if (is_poly_assign && expr2->rank == 0 && !UNLIMITED_POLY (expr2))\n \trss->info->type = GFC_SS_REFERENCE;\n \n+      rss->no_bounds_check = expr2->no_bounds_check;\n       /* Associate the SS with the loop.  */\n       gfc_add_ss_to_loop (&loop, lss);\n       gfc_add_ss_to_loop (&loop, rss);"}, {"sha": "34f298fdd6a2dfc92ab94df2796e9cb9a98a35c6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -1,3 +1,6 @@\n+2018-06-10  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* gfortran.dg/inline_matmul_23.f90: New test.\n \n 2018-06-10  Janus Weil  <janus@gcc.gnu.org>\n "}, {"sha": "05633bc4d0ba9cae26c7b2f4eea4508cf2a0e9f1", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_23.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_23.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980fa45eefc0ec8f71e1947a28938af28f6fdbb2/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_23.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_23.f90?ref=980fa45eefc0ec8f71e1947a28938af28f6fdbb2", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-options \"-Og -fcheck=bounds -fdump-tree-optimized\" }\n+! Check that bounds checking is done only before the matrix\n+! multiplication.\n+\n+module y\n+contains\n+  subroutine x(a,b,c)\n+    real, dimension(:,:) :: a, b, c\n+    c = matmul(a,b)\n+  end subroutine x\n+end module y\n+! { dg-final { scan-tree-dump-times \"_runtime_error\" 3 \"optimized\" } }"}]}