{"sha": "bb24f34350078f92e8740713a4d241cb4c2fc9a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIyNGYzNDM1MDA3OGY5MmU4NzQwNzEzYTRkMjQxY2I0YzJmYzlhNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-03-09T17:20:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-19T08:17:30Z"}, "message": "[Ada] Consolidate handling of implicit dereferences\n\n2020-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/trans.c (adjust_for_implicit_deref): Delete.\n\t(maybe_implicit_deref): Likewise.\n\t(Attribute_to_gnu): Replace calls to maybe_implicit_deref by calls\n\tto maybe_padded_object.\n\t(Call_to_gnu): Likewise.\n\t(gnat_to_gnu) <N_Indexed_Component>: Likewise.\n\t<N_Slice>: Likewise.\n\t<N_Selected_Component>: Likewise.\n\t<N_Free_Statement>: Remove call to adjust_for_implicit_deref and\n\tmanually make sure that the designated type is complete.\n\t* gcc-interface/utils2.c (build_simple_component_ref): Add comment.", "tree": {"sha": "6e4e3bffd31b3e3527869692a45623cf56e4a5b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e4e3bffd31b3e3527869692a45623cf56e4a5b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb24f34350078f92e8740713a4d241cb4c2fc9a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb24f34350078f92e8740713a4d241cb4c2fc9a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb24f34350078f92e8740713a4d241cb4c2fc9a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb24f34350078f92e8740713a4d241cb4c2fc9a7/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c95f808ddd5046573423c9d1ee148645e5340738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c95f808ddd5046573423c9d1ee148645e5340738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c95f808ddd5046573423c9d1ee148645e5340738"}], "stats": {"total": 82, "additions": 27, "deletions": 55}, "files": [{"sha": "3a6aa75b4d5559611a8b8c8ab16ff9316dc83956", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 25, "deletions": 55, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb24f34350078f92e8740713a4d241cb4c2fc9a7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb24f34350078f92e8740713a4d241cb4c2fc9a7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=bb24f34350078f92e8740713a4d241cb4c2fc9a7", "patch": "@@ -242,8 +242,6 @@ static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree pos_to_constructor (Node_Id, tree);\n static void validate_unchecked_conversion (Node_Id);\n-static Node_Id adjust_for_implicit_deref (Node_Id);\n-static tree maybe_implicit_deref (tree);\n static void set_expr_location_from_node (tree, Node_Id, bool = false);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n static bool set_end_locus_from_node (tree, Node_Id);\n@@ -2089,8 +2087,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tEntity_Id gnat_param = Empty;\n \tbool unconstrained_ptr_deref = false;\n \n-\t/* Make sure any implicit dereference gets done.  */\n-\tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n+\tgnu_prefix = maybe_padded_object (gnu_prefix);\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n \n \t/* We treat unconstrained array In parameters specially.  We also note\n@@ -2455,7 +2452,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       break;\n \n     case Attr_Component_Size:\n-      gnu_prefix = maybe_implicit_deref (gnu_prefix);\n+      gnu_prefix = maybe_padded_object (gnu_prefix);\n       gnu_type = TREE_TYPE (gnu_prefix);\n \n       if (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE)\n@@ -4853,7 +4850,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t subprogram.  */\n       else if (is_true_formal_parm && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n \t{\n-\t  gnu_actual = maybe_implicit_deref (gnu_actual);\n+\t  gnu_actual = maybe_padded_object (gnu_actual);\n \t  gnu_actual = maybe_unconstrained_array (gnu_actual);\n \n \t  /* Take the address of the object and convert to the proper pointer\n@@ -4901,7 +4898,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  /* Arrays are passed as pointers to element type.  */\n \t  if (mech != By_Copy && TREE_CODE (gnu_formal_type) == ARRAY_TYPE)\n \t    {\n-\t      gnu_actual = maybe_implicit_deref (gnu_actual);\n+\t      gnu_actual = maybe_padded_object (gnu_actual);\n \t      gnu_actual = maybe_unconstrained_array (gnu_actual);\n \n \t      /* Strip off any multi-dimensional entries, then strip\n@@ -6644,14 +6641,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Indexed_Component:\n       {\n-\ttree gnu_array_object\n-\t  = gnat_to_gnu (adjust_for_implicit_deref (Prefix (gnat_node)));\n+\ttree gnu_array_object = gnat_to_gnu ((Prefix (gnat_node)));\n \ttree gnu_type;\n-\tint ndim;\n-\tint i;\n+\tint ndim, i;\n \tNode_Id *gnat_expr_array;\n \n-\tgnu_array_object = maybe_implicit_deref (gnu_array_object);\n+\tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n \t/* Convert vector inputs to their representative array type, to fit\n@@ -6715,12 +6710,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Slice:\n       {\n-\ttree gnu_array_object\n-\t  = gnat_to_gnu (adjust_for_implicit_deref (Prefix (gnat_node)));\n+\ttree gnu_array_object = gnat_to_gnu (Prefix (gnat_node));\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\tgnu_array_object = maybe_implicit_deref (gnu_array_object);\n+\tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n \tgnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n@@ -6740,12 +6734,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Selected_Component:\n       {\n-\tEntity_Id gnat_prefix\n-\t  = adjust_for_implicit_deref (Prefix (gnat_node));\n+\tconst Entity_Id gnat_prefix = Prefix (gnat_node);\n \tEntity_Id gnat_field = Entity (Selector_Name (gnat_node));\n \ttree gnu_prefix = gnat_to_gnu (gnat_prefix);\n \n-\tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n+\tgnu_prefix = maybe_padded_object (gnu_prefix);\n \n \t/* gnat_to_gnu_entity does not save the GNU tree made for renamed\n \t   discriminants so avoid making recursive calls on each reference\n@@ -7209,7 +7202,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_type = gnat_to_gnu_type (Entity (gnat_temp));\n \telse if (Nkind (gnat_temp) == N_Qualified_Expression)\n \t  {\n-\t    Entity_Id gnat_desig_type\n+\t    const Entity_Id gnat_desig_type\n \t      = Designated_Type (Underlying_Type (Etype (gnat_node)));\n \n \t    ignore_init_type = Has_Constrained_Partial_View (gnat_desig_type);\n@@ -8063,12 +8056,21 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Free_Statement:\n+      gnat_temp = Expression (gnat_node);\n+\n       if (!type_annotate_only)\n \t{\n-\t  tree gnu_ptr\n-\t    = gnat_to_gnu (adjust_for_implicit_deref (Expression (gnat_node)));\n-\t  tree gnu_ptr_type = TREE_TYPE (gnu_ptr);\n-\t  tree gnu_obj_type, gnu_actual_obj_type;\n+\t  tree gnu_ptr, gnu_ptr_type, gnu_obj_type, gnu_actual_obj_type;\n+\n+\t  const Entity_Id gnat_desig_type\n+\t    = Designated_Type (Underlying_Type (Etype (gnat_temp)));\n+\n+\t  /* Make sure the designated type is complete before dereferencing,\n+\t     in case it is a Taft Amendment type.  */\n+\t  (void) gnat_to_gnu_entity (gnat_desig_type, NULL_TREE, false);\n+\n+\t  gnu_ptr = gnat_to_gnu (gnat_temp);\n+\t  gnu_ptr_type = TREE_TYPE (gnu_ptr);\n \n \t  /* If this is a thin pointer, we must first dereference it to create\n \t     a fat pointer, then go back below to a thin pointer.  The reason\n@@ -10235,38 +10237,6 @@ validate_unchecked_conversion (Node_Id gnat_node)\n     }\n }\n \f\n-/* EXP is to be used in a context where access objects are implicitly\n-   dereferenced.  Handle the cases when it is an access object.  */\n-\n-static Node_Id\n-adjust_for_implicit_deref (Node_Id exp)\n-{\n-  Entity_Id type = Underlying_Type (Etype (exp));\n-\n-  /* Make sure the designated type is complete before dereferencing.  */\n-  if (Is_Access_Type (type))\n-    gnat_to_gnu_entity (Designated_Type (type), NULL_TREE, false);\n-\n-  return exp;\n-}\n-\n-/* EXP is to be treated as an array or record.  Handle the cases when it is\n-   an access object and perform the required dereferences.  */\n-\n-static tree\n-maybe_implicit_deref (tree exp)\n-{\n-  /* If the object is a pointer, dereference it.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (exp))\n-      || TYPE_IS_FAT_POINTER_P (TREE_TYPE (exp)))\n-    exp = build_unary_op (INDIRECT_REF, NULL_TREE, exp);\n-\n-  /* If the object is padded, remove the padding.  */\n-  exp = maybe_padded_object (exp);\n-\n-  return exp;\n-}\n-\f\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a\n    source code location and false if it doesn't.  If CLEAR_COLUMN is\n    true, set the column information to 0.  If DECL is given and SLOC"}, {"sha": "364440b2c57f4119da3862229c45c26f01bc22a5", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb24f34350078f92e8740713a4d241cb4c2fc9a7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb24f34350078f92e8740713a4d241cb4c2fc9a7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=bb24f34350078f92e8740713a4d241cb4c2fc9a7", "patch": "@@ -1997,6 +1997,8 @@ build_simple_component_ref (tree record, tree field, bool no_fold)\n   tree type = TYPE_MAIN_VARIANT (TREE_TYPE (record));\n   tree ref;\n \n+  /* The failure of this assertion will very likely come from a missing\n+     insertion of an explicit dereference.  */\n   gcc_assert (RECORD_OR_UNION_TYPE_P (type) && COMPLETE_TYPE_P (type));\n \n   /* Try to fold a conversion from another record or union type unless the type"}]}