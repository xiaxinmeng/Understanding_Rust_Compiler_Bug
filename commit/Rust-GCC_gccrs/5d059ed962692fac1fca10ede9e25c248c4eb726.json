{"sha": "5d059ed962692fac1fca10ede9e25c248c4eb726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwNTllZDk2MjY5MmZhYzFmY2ExMGVkZTllMjVjMjQ4YzRlYjcyNg==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-11-26T10:25:38Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-11-26T10:25:38Z"}, "message": "calls.c (expand_call): Pass to REG_PARM_STACK_SPACE the type of the function...\n\n2008-11-26  Kai Tietz  <kai.tietz@onevision.com>\n\n        PR/38227\n        * calls.c (expand_call): Pass to REG_PARM_STACK_SPACE\n        the type of the function, when there is no FUNCTION_DECL available.\n        OUTGOING_REG_PARM_STACK_SPACE pass fntype, when no fndecl is available.\n        (compute_argument_block_size): Add fntype argument.\n        OUTGOING_REG_PARM_STACK_SPACE pass fntype, when no fndecl is available.\n        (emit_library_call_value_1): Likewise.\n        OUTGOING_REG_PARM_STACK_SPACE pass fntype, when no fndecl is available.\n        * config/i386/i386.c (ix86_reg_parm_stack_space): Handle function types.\n        * doc/tm.texi (REG_PARM_STACK_SPACE): Adjust documentation.\n\nFrom-SVN: r142215", "tree": {"sha": "621ef40c81da803e778b7b7894a67ca0ec7220d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/621ef40c81da803e778b7b7894a67ca0ec7220d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d059ed962692fac1fca10ede9e25c248c4eb726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d059ed962692fac1fca10ede9e25c248c4eb726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d059ed962692fac1fca10ede9e25c248c4eb726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d059ed962692fac1fca10ede9e25c248c4eb726/comments", "author": null, "committer": null, "parents": [{"sha": "89d926785d4e8a8f28318d6d3ea90d634d983e55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d926785d4e8a8f28318d6d3ea90d634d983e55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d926785d4e8a8f28318d6d3ea90d634d983e55"}], "stats": {"total": 32, "additions": 19, "deletions": 13}, "files": [{"sha": "e2c4fcb8a651fbb1a039022d14d197490787954e", "filename": "gcc/calls.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5d059ed962692fac1fca10ede9e25c248c4eb726", "patch": "@@ -132,7 +132,7 @@ static void store_unaligned_arguments_into_pseudos (struct arg_data *, int);\n static int finalize_must_preallocate (int, int, struct arg_data *,\n \t\t\t\t      struct args_size *);\n static void precompute_arguments (int, struct arg_data *);\n-static int compute_argument_block_size (int, struct args_size *, tree, int);\n+static int compute_argument_block_size (int, struct args_size *, tree, tree, int);\n static void initialize_argument_information (int, struct arg_data *,\n \t\t\t\t\t     struct args_size *, int,\n \t\t\t\t\t     tree, tree,\n@@ -1205,6 +1205,7 @@ static int\n compute_argument_block_size (int reg_parm_stack_space,\n \t\t\t     struct args_size *args_size,\n \t\t\t     tree fndecl ATTRIBUTE_UNUSED,\n+\t\t\t     tree fntype ATTRIBUTE_UNUSED,\n \t\t\t     int preferred_stack_boundary ATTRIBUTE_UNUSED)\n {\n   int unadjusted_args_size = args_size->constant;\n@@ -1242,7 +1243,7 @@ compute_argument_block_size (int reg_parm_stack_space,\n \n \t  /* The area corresponding to register parameters is not to count in\n \t     the size of the block we need.  So make the adjustment.  */\n-\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl))))\n+\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \t    args_size->var\n \t      = size_binop (MINUS_EXPR, args_size->var,\n \t\t\t    ssize_int (reg_parm_stack_space));\n@@ -1263,7 +1264,7 @@ compute_argument_block_size (int reg_parm_stack_space,\n       args_size->constant = MAX (args_size->constant,\n \t\t\t\t reg_parm_stack_space);\n \n-      if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl))))\n+      if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \targs_size->constant -= reg_parm_stack_space;\n     }\n   return unadjusted_args_size;\n@@ -2077,10 +2078,10 @@ expand_call (tree exp, rtx target, int ignore)\n     }\n \n #ifdef REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (!fndecl ? fntype : fndecl);\n #endif\n \n-  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl)))\n+  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl)))\n       && reg_parm_stack_space > 0 && PUSH_ARGS)\n     must_preallocate = 1;\n \n@@ -2404,7 +2405,7 @@ expand_call (tree exp, rtx target, int ignore)\n       unadjusted_args_size\n \t= compute_argument_block_size (reg_parm_stack_space,\n \t\t\t\t       &adjusted_args_size,\n-\t\t\t\t       fndecl,\n+\t\t\t\t       fndecl, fntype,\n \t\t\t\t       (pass == 0 ? 0\n \t\t\t\t\t: preferred_stack_boundary));\n \n@@ -2480,7 +2481,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t  /* Since we will be writing into the entire argument area,\n \t\t     the map must be allocated for its entire size, not just\n \t\t     the part that is the responsibility of the caller.  */\n-\t\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl))))\n+\t\t  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \t\t    needed += reg_parm_stack_space;\n \n #ifdef ARGS_GROW_DOWNWARD\n@@ -2579,7 +2580,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    {\n \t      rtx push_size\n \t\t= GEN_INT (adjusted_args_size.constant\n-\t\t\t   + (OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL\n+\t\t\t   + (OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype\n \t\t\t   \t\t\t\t\t      : TREE_TYPE (fndecl))) ? 0\n \t\t\t      : reg_parm_stack_space));\n \t      if (old_stack_level == 0)\n@@ -2750,7 +2751,7 @@ expand_call (tree exp, rtx target, int ignore)\n       /* If register arguments require space on the stack and stack space\n \t was not preallocated, allocate stack space here for arguments\n \t passed in registers.  */\n-      if (OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl)))\n+      if (OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl)))\n           && !ACCUMULATE_OUTGOING_ARGS\n \t  && must_preallocate == 0 && reg_parm_stack_space > 0)\n \tanti_adjust_stack (GEN_INT (reg_parm_stack_space));\n@@ -3230,6 +3231,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   /* Todo, choose the correct decl type of orgfun. Sadly this information\n      isn't present here, so we default to native calling abi here.  */\n   tree fndecl ATTRIBUTE_UNUSED = NULL_TREE; /* library calls default to host calling abi ? */\n+  tree fntype ATTRIBUTE_UNUSED = NULL_TREE; /* library calls default to host calling abi ? */\n   int inc;\n   int count;\n   rtx argblock = 0;\n@@ -3487,7 +3489,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   args_size.constant = MAX (args_size.constant,\n \t\t\t    reg_parm_stack_space);\n \n-  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl))))\n+  if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n     args_size.constant -= reg_parm_stack_space;\n \n   if (args_size.constant > crtl->outgoing_args_size)\n@@ -3512,7 +3514,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       /* Since we will be writing into the entire argument area, the\n \t map must be allocated for its entire size, not just the part that\n \t is the responsibility of the caller.  */\n-      if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? NULL_TREE : TREE_TYPE (fndecl))))\n+      if (! OUTGOING_REG_PARM_STACK_SPACE ((!fndecl ? fntype : TREE_TYPE (fndecl))))\n \tneeded += reg_parm_stack_space;\n \n #ifdef ARGS_GROW_DOWNWARD"}, {"sha": "7f806d4dcc64484ed3a51fe16c88499d9f20bed6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5d059ed962692fac1fca10ede9e25c248c4eb726", "patch": "@@ -4552,9 +4552,11 @@ ix86_reg_parm_stack_space (const_tree fndecl)\n   /* For libcalls it is possible that there is no fndecl at hand.\n      Therefore assume for this case the default abi of the target.  */\n   if (!fndecl)\n-    call_abi = DEFAULT_ABI;\n-  else\n+    call_abi = (cfun ? cfun->machine->call_abi : DEFAULT_ABI);\n+  else if (TREE_CODE (fndecl) == FUNCTION_DECL)\n     call_abi = ix86_function_abi (fndecl);\n+  else\n+    call_abi = ix86_function_type_abi (fndecl);\n   if (call_abi == 1)\n     return 32;\n   return 0;"}, {"sha": "7dfb46b3a0def54f2c2a4f25b039321d6d650fcf", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d059ed962692fac1fca10ede9e25c248c4eb726/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5d059ed962692fac1fca10ede9e25c248c4eb726", "patch": "@@ -3817,6 +3817,8 @@ registers.\n The value of this macro is the size, in bytes, of the area reserved for\n arguments passed in registers for the function represented by @var{fndecl},\n which can be zero if GCC is calling a library function.\n+The argument @var{fndecl} can be the FUNCTION_DECL, or the type itself\n+of the function.\n \n This space can be allocated by the caller, or be a part of the\n machine-dependent stack frame: @code{OUTGOING_REG_PARM_STACK_SPACE} says"}]}