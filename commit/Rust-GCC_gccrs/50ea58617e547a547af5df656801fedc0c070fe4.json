{"sha": "50ea58617e547a547af5df656801fedc0c070fe4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlYTU4NjE3ZTU0N2E1NDdhZjVkZjY1NjgwMWZlZGMwYzA3MGZlNA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-22T08:41:27Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-22T08:41:27Z"}, "message": "objc-act.c (get_objc_string_decl): Use a switch instead of a chain of ifs.\n\n2010-10-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (get_objc_string_decl): Use a switch instead of a\n        chain of ifs.  Use gcc_unreachable instead of abort.\n        (add_objc_string): Same change.\n        (generate_protocol_list): Same change - twice.\n        (synth_id_with_class_suffix): Same change.\n        (build_keyword_selector): Same change - twice.\n        (objc_build_message_expr): Same change.\n        (objc_build_selector_expr): Same change.\n        (check_methods): Same change - and added missing gcc_unreachable\n        for default case.\n        (check_methods_accessible): Same change - twice, and added missing\n        gcc_unreachable for default case in one of them.\n        (start_class): Same change - and added missing gcc_unreachable for\n        default case.\n        (continue_class): Same change.\n        (objc_gen_property_data): Same change.\n        (finish_class): Same change.\n        (encode_type_qualifiers): Added missing gcc_unreachable.\n        (encode_type): Small code tidy up to reduce duplicated code.  Use\n        gcc_unreachable instead of abort - twice.\n        (encode_gnu_bitfield): Use a switch instead of a chain of ifs -\n        twice.  Added missing gcc_unreachable for default case - twice.\n        (dump_interface): Use a switch instead of a chain of ifs.\n        (handle_impent): Same change.\n\nFrom-SVN: r165803", "tree": {"sha": "a5f3c266a210854d5b7be125869a14ee7249c748", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f3c266a210854d5b7be125869a14ee7249c748"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ea58617e547a547af5df656801fedc0c070fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ea58617e547a547af5df656801fedc0c070fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ea58617e547a547af5df656801fedc0c070fe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ea58617e547a547af5df656801fedc0c070fe4/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "05b7a48a2b4e50f4ced4cf908984a59743b320d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05b7a48a2b4e50f4ced4cf908984a59743b320d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05b7a48a2b4e50f4ced4cf908984a59743b320d1"}], "stats": {"total": 853, "additions": 474, "deletions": 379}, "files": [{"sha": "7f00238f3b93de4349b80ab05a17de662b92b301", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ea58617e547a547af5df656801fedc0c070fe4/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ea58617e547a547af5df656801fedc0c070fe4/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=50ea58617e547a547af5df656801fedc0c070fe4", "patch": "@@ -1,3 +1,30 @@\n+2010-10-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (get_objc_string_decl): Use a switch instead of a\n+\tchain of ifs.  Use gcc_unreachable instead of abort.\n+\t(add_objc_string): Same change.\n+\t(generate_protocol_list): Same change - twice.\n+\t(synth_id_with_class_suffix): Same change.\n+\t(build_keyword_selector): Same change - twice.\n+\t(objc_build_message_expr): Same change.\n+\t(objc_build_selector_expr): Same change.\n+\t(check_methods): Same change - and added missing gcc_unreachable\n+\tfor default case.\n+\t(check_methods_accessible): Same change - twice, and added missing\n+\tgcc_unreachable for default case in one of them.\n+\t(start_class): Same change - and added missing gcc_unreachable for\n+\tdefault case.\n+\t(continue_class): Same change.\n+\t(objc_gen_property_data): Same change.\n+\t(finish_class): Same change.\n+\t(encode_type_qualifiers): Added missing gcc_unreachable.\n+\t(encode_type): Small code tidy up to reduce duplicated code.  Use\n+\tgcc_unreachable instead of abort - twice.\n+\t(encode_gnu_bitfield): Use a switch instead of a chain of ifs -\n+\ttwice.  Added missing gcc_unreachable for default case - twice.\n+\t(dump_interface): Use a switch instead of a chain of ifs.\n+\t(handle_impent): Same change.\n+\t\n 2010-10-20  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.h (objc_inherit_code): Removed."}, {"sha": "f2ec8952d0bc2776dfc0149f8c21df70d8941d38", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 447, "deletions": 379, "changes": 826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ea58617e547a547af5df656801fedc0c070fe4/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ea58617e547a547af5df656801fedc0c070fe4/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=50ea58617e547a547af5df656801fedc0c070fe4", "patch": "@@ -3089,20 +3089,26 @@ get_objc_string_decl (tree ident, enum string_section section)\n {\n   tree chain;\n \n-  if (section == class_names)\n-    chain = class_names_chain;\n-  else if (section == meth_var_names)\n-    chain = meth_var_names_chain;\n-  else if (section == meth_var_types)\n-    chain = meth_var_types_chain;\n-  else\n-    abort ();\n+  switch (section)\n+    {\n+    case class_names:\n+      chain = class_names_chain;\n+      break;\n+    case meth_var_names:\n+      chain = meth_var_names_chain;\n+      break;\n+    case meth_var_types:\n+      chain = meth_var_types_chain;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   for (; chain != 0; chain = TREE_CHAIN (chain))\n     if (TREE_VALUE (chain) == ident)\n       return (TREE_PURPOSE (chain));\n \n-  abort ();\n+  gcc_unreachable ();\n   return NULL_TREE;\n }\n \n@@ -3519,23 +3525,23 @@ add_objc_string (tree ident, enum string_section section)\n   char buf[256];\n   \n   buf[0] = 0;\n-  if (section == class_names)\n+  switch (section)\n     {\n+    case class_names:\n       chain = &class_names_chain;\n       sprintf (buf, \"_OBJC_CLASS_NAME_%d\", class_names_idx++);\n-    }\n-  else if (section == meth_var_names)\n-    {\n+      break;\n+    case meth_var_names:\n       chain = &meth_var_names_chain;\n       sprintf (buf, \"_OBJC_METH_VAR_NAME_%d\", meth_var_names_idx++);\n-    }\n-  else if (section == meth_var_types)\n-    {\n+      break;\n+    case meth_var_types:\n       chain = &meth_var_types_chain;\n       sprintf (buf, \"_OBJC_METH_VAR_TYPE_%d\", meth_var_types_idx++);\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    gcc_unreachable ();\n \n   while (*chain)\n     {\n@@ -6100,13 +6106,18 @@ generate_protocol_list (tree i_or_p)\n   const char *ref_name;\n   VEC(constructor_elt,gc) *v = NULL;\n \n-  if (TREE_CODE (i_or_p) == CLASS_INTERFACE_TYPE\n-      || TREE_CODE (i_or_p) == CATEGORY_INTERFACE_TYPE)\n-    plist = CLASS_PROTOCOL_LIST (i_or_p);\n-  else if (TREE_CODE (i_or_p) == PROTOCOL_INTERFACE_TYPE)\n-    plist = PROTOCOL_LIST (i_or_p);\n-  else\n-    abort ();\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case CLASS_INTERFACE_TYPE:\n+    case CATEGORY_INTERFACE_TYPE:\n+      plist = CLASS_PROTOCOL_LIST (i_or_p);\n+      break;\n+    case PROTOCOL_INTERFACE_TYPE:\n+      plist = PROTOCOL_LIST (i_or_p);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   /* Compute size.  */\n   for (lproto = plist; lproto; lproto = TREE_CHAIN (lproto))\n@@ -6134,14 +6145,20 @@ generate_protocol_list (tree i_or_p)\n \n   /* static struct objc_protocol *refs[n]; */\n \n-  if (TREE_CODE (i_or_p) == PROTOCOL_INTERFACE_TYPE)\n-    ref_name = synth_id_with_class_suffix (\"_OBJC_PROTOCOL_REFS\", i_or_p);\n-  else if (TREE_CODE (i_or_p) == CLASS_INTERFACE_TYPE)\n-    ref_name = synth_id_with_class_suffix (\"_OBJC_CLASS_PROTOCOLS\", i_or_p);\n-  else if (TREE_CODE (i_or_p) == CATEGORY_INTERFACE_TYPE)\n-    ref_name = synth_id_with_class_suffix (\"_OBJC_CATEGORY_PROTOCOLS\", i_or_p);\n-  else\n-    abort ();\n+  switch (TREE_CODE (i_or_p))\n+    {\n+    case PROTOCOL_INTERFACE_TYPE:\n+      ref_name = synth_id_with_class_suffix (\"_OBJC_PROTOCOL_REFS\", i_or_p);\n+      break;\n+    case CLASS_INTERFACE_TYPE:\n+      ref_name = synth_id_with_class_suffix (\"_OBJC_CLASS_PROTOCOLS\", i_or_p);\n+      break;\n+    case CATEGORY_INTERFACE_TYPE:\n+      ref_name = synth_id_with_class_suffix (\"_OBJC_CATEGORY_PROTOCOLS\", i_or_p);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   ptype = build_pointer_type (objc_protocol_template);\n   array_type = build_sized_array_type (ptype, size + 3);\n@@ -6465,29 +6482,33 @@ synth_id_with_class_suffix (const char *preamble, tree ctxt)\n {\n   static char string[BUFSIZE];\n \n-  if (TREE_CODE (ctxt) == CLASS_IMPLEMENTATION_TYPE\n-      || TREE_CODE (ctxt) == CLASS_INTERFACE_TYPE)\n+  switch (TREE_CODE (ctxt))\n     {\n+    case CLASS_IMPLEMENTATION_TYPE:\n+    case CLASS_INTERFACE_TYPE:\n       sprintf (string, \"%s_%s\", preamble,\n \t       IDENTIFIER_POINTER (CLASS_NAME (ctxt)));\n+      break;\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+    case CATEGORY_INTERFACE_TYPE:\n+      {\n+\t/* We have a category.  */\n+\tconst char *const class_name\n+\t  = IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));\n+\tconst char *const class_super_name\n+\t  = IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context));\n+\tsprintf (string, \"%s_%s_%s\", preamble, class_name, class_super_name);\n+\tbreak;\n     }\n-  else if (TREE_CODE (ctxt) == CATEGORY_IMPLEMENTATION_TYPE\n-\t   || TREE_CODE (ctxt) == CATEGORY_INTERFACE_TYPE)\n-    {\n-      /* We have a category.  */\n-      const char *const class_name\n-\t= IDENTIFIER_POINTER (CLASS_NAME (objc_implementation_context));\n-      const char *const class_super_name\n-\t= IDENTIFIER_POINTER (CLASS_SUPER_NAME (objc_implementation_context));\n-      sprintf (string, \"%s_%s_%s\", preamble, class_name, class_super_name);\n-    }\n-  else if (TREE_CODE (ctxt) == PROTOCOL_INTERFACE_TYPE)\n-    {\n-      const char *protocol_name = IDENTIFIER_POINTER (PROTOCOL_NAME (ctxt));\n-      sprintf (string, \"%s_%s\", preamble, protocol_name);\n+    case PROTOCOL_INTERFACE_TYPE:\n+      {\n+\tconst char *protocol_name = IDENTIFIER_POINTER (PROTOCOL_NAME (ctxt));\n+\tsprintf (string, \"%s_%s\", preamble, protocol_name);\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n \n   return string;\n }\n@@ -6562,12 +6583,17 @@ build_keyword_selector (tree selector)\n   /* Scan the selector to see how much space we'll need.  */\n   for (key_chain = selector; key_chain; key_chain = TREE_CHAIN (key_chain))\n     {\n-      if (TREE_CODE (selector) == KEYWORD_DECL)\n-\tkey_name = KEYWORD_KEY_NAME (key_chain);\n-      else if (TREE_CODE (selector) == TREE_LIST)\n-\tkey_name = TREE_PURPOSE (key_chain);\n-      else\n-\tabort ();\n+      switch (TREE_CODE (selector))\n+\t{\n+\tcase KEYWORD_DECL:\n+\t  key_name = KEYWORD_KEY_NAME (key_chain);\n+\t  break;\n+\tcase TREE_LIST:\n+\t  key_name = TREE_PURPOSE (key_chain);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n       if (key_name)\n \tlen += IDENTIFIER_LENGTH (key_name) + 1;\n@@ -6582,18 +6608,21 @@ build_keyword_selector (tree selector)\n \n   for (key_chain = selector; key_chain; key_chain = TREE_CHAIN (key_chain))\n     {\n-      if (TREE_CODE (selector) == KEYWORD_DECL)\n-\tkey_name = KEYWORD_KEY_NAME (key_chain);\n-      else if (TREE_CODE (selector) == TREE_LIST)\n+      switch (TREE_CODE (selector))\n \t{\n+\tcase KEYWORD_DECL:\n+\t  key_name = KEYWORD_KEY_NAME (key_chain);\n+\t  break;\n+\tcase TREE_LIST:\n \t  key_name = TREE_PURPOSE (key_chain);\n-\t  /* The keyword decl chain will later be used as a function argument\n-\t     chain.  Unhook the selector itself so as to not confuse other\n-\t     parts of the compiler.  */\n+\t  /* The keyword decl chain will later be used as a function\n+\t     argument chain.  Unhook the selector itself so as to not\n+\t     confuse other parts of the compiler.  */\n \t  TREE_PURPOSE (key_chain) = NULL_TREE;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n \n       if (key_name)\n \tstrcat (buf, IDENTIFIER_POINTER (key_name));\n@@ -6885,13 +6914,18 @@ objc_build_message_expr (tree mess)\n     return error_mark_node;\n \n   /* Obtain the full selector name.  */\n-  if (TREE_CODE (args) == IDENTIFIER_NODE)\n-    /* A unary selector.  */\n-    sel_name = args;\n-  else if (TREE_CODE (args) == TREE_LIST)\n-    sel_name = build_keyword_selector (args);\n-  else\n-    abort ();\n+  switch (TREE_CODE (args))\n+    {\n+    case IDENTIFIER_NODE:\n+      /* A unary selector.  */\n+      sel_name = args;\n+      break;\n+    case TREE_LIST:\n+      sel_name = build_keyword_selector (args);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   /* Build the parameter list to give to the method.  */\n   if (TREE_CODE (args) == TREE_LIST)\n@@ -7382,13 +7416,18 @@ objc_build_selector_expr (location_t loc, tree selnamelist)\n   tree selname;\n \n   /* Obtain the full selector name.  */\n-  if (TREE_CODE (selnamelist) == IDENTIFIER_NODE)\n-    /* A unary selector.  */\n-    selname = selnamelist;\n-  else if (TREE_CODE (selnamelist) == TREE_LIST)\n-    selname = build_keyword_selector (selnamelist);\n-  else\n-    abort ();\n+  switch (TREE_CODE (selnamelist))\n+    {\n+    case IDENTIFIER_NODE:\n+      /* A unary selector.  */\n+      selname = selnamelist;\n+      break;\n+    case TREE_LIST:\n+      selname = build_keyword_selector (selnamelist);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   /* If we are required to check @selector() expressions as they\n      are found, check that the selector has been declared.  */\n@@ -8069,14 +8108,19 @@ check_methods (tree chain, tree list, int mtype)\n \t{\n \t  if (first)\n \t    {\n-\t      if (TREE_CODE (objc_implementation_context)\n-\t\t  == CLASS_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of class %qE\",\n-\t\t\t CLASS_NAME (objc_implementation_context));\n-\t      else if (TREE_CODE (objc_implementation_context)\n-\t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of category %qE\",\n-\t\t\t CLASS_SUPER_NAME (objc_implementation_context));\n+\t      switch (TREE_CODE (objc_implementation_context))\n+\t\t{\n+\t\tcase CLASS_IMPLEMENTATION_TYPE:\n+\t\t  warning (0, \"incomplete implementation of class %qE\",\n+\t\t\t   CLASS_NAME (objc_implementation_context));\n+\t\t  break;\n+\t\tcase CATEGORY_IMPLEMENTATION_TYPE:\n+\t\t  warning (0, \"incomplete implementation of category %qE\",\n+\t\t\t   CLASS_SUPER_NAME (objc_implementation_context));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t      first = 0;\n \t    }\n \n@@ -8138,33 +8182,42 @@ check_methods_accessible (tree chain, tree context, int mtype)\n \t  if (lookup_method (list, chain))\n \t      break;\n \n-\t  else if (TREE_CODE (context) == CLASS_IMPLEMENTATION_TYPE\n-\t\t   || TREE_CODE (context) == CLASS_INTERFACE_TYPE)\n-\t    context = (CLASS_SUPER_NAME (context)\n-\t\t       ? lookup_interface (CLASS_SUPER_NAME (context))\n-\t\t       : NULL_TREE);\n-\n-\t  else if (TREE_CODE (context) == CATEGORY_IMPLEMENTATION_TYPE\n-\t\t   || TREE_CODE (context) == CATEGORY_INTERFACE_TYPE)\n-\t    context = (CLASS_NAME (context)\n-\t\t       ? lookup_interface (CLASS_NAME (context))\n-\t\t       : NULL_TREE);\n-\t  else\n-\t    abort ();\n+\t  switch (TREE_CODE (context))\n+\t    {\n+\t    case CLASS_IMPLEMENTATION_TYPE:\n+\t    case CLASS_INTERFACE_TYPE:\n+\t      context = (CLASS_SUPER_NAME (context)\n+\t\t\t ? lookup_interface (CLASS_SUPER_NAME (context))\n+\t\t\t : NULL_TREE);\n+\t      break;\n+\t    case CATEGORY_IMPLEMENTATION_TYPE:\n+\t    case CATEGORY_INTERFACE_TYPE:\n+\t      context = (CLASS_NAME (context)\n+\t\t\t ? lookup_interface (CLASS_NAME (context))\n+\t\t\t : NULL_TREE);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n \t}\n \n       if (context == NULL_TREE)\n \t{\n \t  if (first)\n \t    {\n-\t      if (TREE_CODE (objc_implementation_context)\n-\t\t  == CLASS_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of class %qE\",\n-\t\t\t CLASS_NAME (objc_implementation_context));\n-\t      else if (TREE_CODE (objc_implementation_context)\n-\t\t       == CATEGORY_IMPLEMENTATION_TYPE)\n-\t\twarning (0, \"incomplete implementation of category %qE\",\n-\t\t\t CLASS_SUPER_NAME (objc_implementation_context));\n+\t      switch (TREE_CODE (objc_implementation_context))\n+\t\t{\n+\t\tcase CLASS_IMPLEMENTATION_TYPE:\n+\t\t  warning (0, \"incomplete implementation of class %qE\",\n+\t\t\t   CLASS_NAME (objc_implementation_context));\n+\t\t  break;\n+\t\tcase CATEGORY_IMPLEMENTATION_TYPE:\n+\t\t  warning (0, \"incomplete implementation of category %qE\",\n+\t\t\t   CLASS_SUPER_NAME (objc_implementation_context));\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t      first = 0;\n \t    }\n \t  warning (0, \"method definition for %<%c%E%> not found\",\n@@ -8307,19 +8360,20 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t     decl);\n     }\n \n-  if (code == CLASS_IMPLEMENTATION_TYPE)\n+  switch (code)\n     {\n+    case CLASS_IMPLEMENTATION_TYPE:\n       {\n-        tree chain;\n-\n-        for (chain = implemented_classes; chain; chain = TREE_CHAIN (chain))\n-           if (TREE_VALUE (chain) == class_name)\n-\t     {\n-\t       error (\"reimplementation of class %qE\",\n-\t\t      class_name);\n-\t       return error_mark_node;\n-\t     }\n-        implemented_classes = tree_cons (NULL_TREE, class_name,\n+\ttree chain;\n+\t\n+\tfor (chain = implemented_classes; chain; chain = TREE_CHAIN (chain))\n+\t  if (TREE_VALUE (chain) == class_name)\n+\t    {\n+\t      error (\"reimplementation of class %qE\",\n+\t\t     class_name);\n+\t      return error_mark_node;\n+\t    }\n+\timplemented_classes = tree_cons (NULL_TREE, class_name,\n \t\t\t\t\t implemented_classes);\n       }\n \n@@ -8343,64 +8397,61 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (super_name\n \t  && (super_name != CLASS_SUPER_NAME (implementation_template)))\n-        {\n+\t{\n \t  tree previous_name = CLASS_SUPER_NAME (implementation_template);\n \t  error (\"conflicting super class name %qE\",\n \t\t super_name);\n \t  if (previous_name)\n \t    error (\"previous declaration of %qE\", previous_name);\n \t  else\n \t    error (\"previous declaration\");\n-        }\n+\t}\n \n       else if (! super_name)\n \t{\n \t  CLASS_SUPER_NAME (objc_implementation_context)\n \t    = CLASS_SUPER_NAME (implementation_template);\n \t}\n-    }\n+      break;\n \n-  else if (code == CLASS_INTERFACE_TYPE)\n-    {\n+    case CLASS_INTERFACE_TYPE:\n       if (lookup_interface (class_name))\n #ifdef OBJCPLUS\n-\terror (\"duplicate interface declaration for class %qE\",\n+\terror (\"duplicate interface declaration for class %qE\", class_name);\n #else\n-\twarning (0, \"duplicate interface declaration for class %qE\",\n+        warning (0, \"duplicate interface declaration for class %qE\", class_name);\n #endif\n-        class_name);\n       else\n-        add_class (klass, class_name);\n-\n+\tadd_class (klass, class_name);\n+       \n       if (protocol_list)\n \tCLASS_PROTOCOL_LIST (klass)\n \t  = lookup_and_install_protocols (protocol_list);\n-    }\n+      break;     \n \n-  else if (code == CATEGORY_INTERFACE_TYPE)\n-    {\n-      tree class_category_is_assoc_with;\n-\n-      /* For a category, class_name is really the name of the class that\n-\t the following set of methods will be associated with. We must\n-\t find the interface so that can derive the objects template.  */\n-\n-      if (!(class_category_is_assoc_with = lookup_interface (class_name)))\n-\t{\n-\t  error (\"cannot find interface declaration for %qE\",\n-\t\t class_name);\n-\t  exit (FATAL_EXIT_CODE);\n-\t}\n-      else\n-        add_category (class_category_is_assoc_with, klass);\n-\n-      if (protocol_list)\n-\tCLASS_PROTOCOL_LIST (klass)\n-\t  = lookup_and_install_protocols (protocol_list);\n-    }\n+    case CATEGORY_INTERFACE_TYPE:\n+      {\n+\ttree class_category_is_assoc_with;\n+\t\n+\t/* For a category, class_name is really the name of the class that\n+\t   the following set of methods will be associated with. We must\n+\t   find the interface so that can derive the objects template.  */\n+\tif (!(class_category_is_assoc_with = lookup_interface (class_name)))\n+\t  {\n+\t    error (\"cannot find interface declaration for %qE\",\n+\t\t   class_name);\n+\t    exit (FATAL_EXIT_CODE);\n+\t  }\n+\telse\n+\t  add_category (class_category_is_assoc_with, klass);\n+\t\n+\tif (protocol_list)\n+\t  CLASS_PROTOCOL_LIST (klass)\n+\t    = lookup_and_install_protocols (protocol_list);\n+      }\n+      break;\n \n-  else if (code == CATEGORY_IMPLEMENTATION_TYPE)\n-    {\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n \n@@ -8416,77 +8467,77 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t\t class_name);\n \t  exit (FATAL_EXIT_CODE);\n         }\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n   return klass;\n }\n \n static tree\n continue_class (tree klass)\n {\n-  if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE\n-      || TREE_CODE (klass) == CATEGORY_IMPLEMENTATION_TYPE)\n+  switch (TREE_CODE (klass))\n     {\n-      struct imp_entry *imp_entry;\n-\n-      /* Check consistency of the instance variables.  */\n-\n-      if (CLASS_RAW_IVARS (klass))\n-\tcheck_ivars (implementation_template, klass);\n+    case CLASS_IMPLEMENTATION_TYPE:\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+      {\n+\tstruct imp_entry *imp_entry;\n \n-      /* code generation */\n+        /* Check consistency of the instance variables.  */\n \n+\tif (CLASS_RAW_IVARS (klass))\n+\t  check_ivars (implementation_template, klass);\n+\t\n+\t/* code generation */\n #ifdef OBJCPLUS\n-      push_lang_context (lang_name_c);\n+\tpush_lang_context (lang_name_c);\n #endif\n+        build_private_template (implementation_template);\n+        uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);\n+        objc_instance_type = build_pointer_type (uprivate_record);\n \n-      build_private_template (implementation_template);\n-      uprivate_record = CLASS_STATIC_TEMPLATE (implementation_template);\n-      objc_instance_type = build_pointer_type (uprivate_record);\n+        imp_entry = ggc_alloc_imp_entry ();\n \n-      imp_entry = ggc_alloc_imp_entry ();\n+        imp_entry->next = imp_list;\n+        imp_entry->imp_context = klass;\n+        imp_entry->imp_template = implementation_template;\n \n-      imp_entry->next = imp_list;\n-      imp_entry->imp_context = klass;\n-      imp_entry->imp_template = implementation_template;\n-\n-      synth_forward_declarations ();\n-      imp_entry->class_decl = UOBJC_CLASS_decl;\n-      imp_entry->meta_decl = UOBJC_METACLASS_decl;\n-      imp_entry->has_cxx_cdtors = 0;\n-\n-      /* Append to front and increment count.  */\n-      imp_list = imp_entry;\n-      if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE)\n-\timp_count++;\n-      else\n-\tcat_count++;\n+        synth_forward_declarations ();\n+        imp_entry->class_decl = UOBJC_CLASS_decl;\n+        imp_entry->meta_decl = UOBJC_METACLASS_decl;\n+\timp_entry->has_cxx_cdtors = 0;\n \n+        /* Append to front and increment count.  */\n+        imp_list = imp_entry;\n+        if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE)\n+          imp_count++;\n+\telse\n+\t  cat_count++;\n #ifdef OBJCPLUS\n-      pop_lang_context ();\n+\tpop_lang_context ();\n #endif /* OBJCPLUS */\n-\n-      return get_class_ivars (implementation_template, true);\n-    }\n-\n-  else if (TREE_CODE (klass) == CLASS_INTERFACE_TYPE)\n-    {\n+\t\n+\treturn get_class_ivars (implementation_template, true);\n+\tbreak;\n+      }\n+    case CLASS_INTERFACE_TYPE:\n+      {\n #ifdef OBJCPLUS\n-      push_lang_context (lang_name_c);\n+\tpush_lang_context (lang_name_c);\n #endif /* OBJCPLUS */\n-\n-      objc_collecting_ivars = 1;\n-      build_private_template (klass);\n-      objc_collecting_ivars = 0;\n-\n+\tobjc_collecting_ivars = 1;\n+\tbuild_private_template (klass);\n+\tobjc_collecting_ivars = 0;\n #ifdef OBJCPLUS\n-      pop_lang_context ();\n+\tpop_lang_context ();\n #endif /* OBJCPLUS */\n-\n-      return NULL_TREE;\n+\treturn NULL_TREE;\n+\tbreak;\n+      }\n+    default:\n+      return error_mark_node;\n     }\n-\n-  else\n-    return error_mark_node;\n }\n \n /* This routine builds a property ivar name. */\n@@ -8844,102 +8895,106 @@ objc_gen_property_data (tree klass, tree class_methods)\n static void\n finish_class (tree klass)\n {\n-  if (TREE_CODE (klass) == CLASS_IMPLEMENTATION_TYPE)\n-    {\n-      /* All code generation is done in finish_objc.  */\n-\n-      /* Generate what needed for property; setters, getters, etc. */\n-      objc_gen_property_data (implementation_template, implementation_template);\n-\n-      if (implementation_template != objc_implementation_context)\n-\t{\n-\t  /* Ensure that all method listed in the interface contain bodies.  */\n-\t  check_methods (CLASS_CLS_METHODS (implementation_template),\n-\t\t\t CLASS_CLS_METHODS (objc_implementation_context), '+');\n-\t  check_methods (CLASS_NST_METHODS (implementation_template),\n-\t\t\t CLASS_NST_METHODS (objc_implementation_context), '-');\n-\n-\t  if (CLASS_PROTOCOL_LIST (implementation_template))\n-\t    check_protocols (CLASS_PROTOCOL_LIST (implementation_template),\n-\t\t\t     \"class\",\n-\t\t\t     CLASS_NAME (objc_implementation_context));\n-\t}\n-    }\n-\n-  else if (TREE_CODE (klass) == CATEGORY_IMPLEMENTATION_TYPE)\n+  switch (TREE_CODE (klass))\n     {\n-      tree category = lookup_category (implementation_template, CLASS_SUPER_NAME (klass));\n-\n-      if (category)\n-\t{\n-          /* Generate what needed for property; setters, getters, etc. */\n-          objc_gen_property_data (implementation_template, category);\n-\n-\t  /* Ensure all method listed in the interface contain bodies.  */\n-\t  check_methods (CLASS_CLS_METHODS (category),\n-\t\t\t CLASS_CLS_METHODS (objc_implementation_context), '+');\n-\t  check_methods (CLASS_NST_METHODS (category),\n-\t\t\t CLASS_NST_METHODS (objc_implementation_context), '-');\n-\n-\t  if (CLASS_PROTOCOL_LIST (category))\n-\t    check_protocols (CLASS_PROTOCOL_LIST (category),\n-\t\t\t     \"category\",\n-\t\t\t     CLASS_SUPER_NAME (objc_implementation_context));\n-\t}\n-    }\n-  else \n-    {\n-      /* Process properties of the class. */\n-      tree x;\n-      for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n-\t{\n-\t  tree type = TREE_TYPE (x);\n-\t  tree prop_name = PROPERTY_NAME (x);\n-\t  /* Build an instance method declaration: - (type) prop_name; */\n-\t  if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n-\t    {\n-\t      /* No getter attribute specified. Generate an instance method for the \n-\t\t getter. */\n-\t      tree rettype = build_tree_list (NULL_TREE, type);\n-\t      tree getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t    rettype, prop_name, \n-\t\t\t\t\t\t    NULL_TREE, false);\n-\t      objc_add_method (objc_interface_context, getter_decl, false, false);\n-\t      METHOD_PROPERTY_CONTEXT (getter_decl) = x;\n-\t    }\n-\t  else\n-\t    warning (0, \"getter = %qs may not be specified in an interface\", \n-\t\t     IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (x)));\n+    case CLASS_IMPLEMENTATION_TYPE:\n+      {\n+\t/* All code generation is done in finish_objc.  */\n+\t\n+\t/* Generate what needed for property; setters, getters, etc. */\n+\tobjc_gen_property_data (implementation_template, implementation_template);\n \n-\t  /* Build an instance method declaration: - (void) setName: (type)value; */\n-\t  if (PROPERTY_SETTER_NAME (x) == NULL_TREE \n-\t      && PROPERTY_READONLY (x) == boolean_false_node)\n-\t    {\n-\t      /* Declare a setter instance method in the interface. */\n-\t      tree key_name, arg_type, arg_name;\n-\t      tree setter_decl, selector;\n-\t      tree ret_type = build_tree_list (NULL_TREE, void_type_node);\n-\t      /* setter name. */\n-\t      key_name = get_identifier (objc_build_property_setter_name (\n-\t\t\t\t\t  PROPERTY_NAME (x), false));\n-\t      arg_type = build_tree_list (NULL_TREE, type);\n-\t      arg_name = get_identifier (\"_value\");\n-\t      /* For now, no attributes.  */\n-\t      selector = objc_build_keyword_decl (key_name, arg_type, arg_name, NULL);\n-\t      setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t       ret_type, selector, \n-\t\t\t\t\t       build_tree_list (NULL_TREE, NULL_TREE),\n-\t\t\t\t\t       false);\n-\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n-\t      METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n-\t    }\n-\t  else if (PROPERTY_SETTER_NAME (x))\n-\t    warning (0, \"setter = %qs may not be specified in an interface\", \n-\t\t     IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x)));\n-\t  if (PROPERTY_IVAR_NAME (x))\n-\t    warning (0, \"ivar  = %qs attribute may not be specified in an interface\",\n-\t\t     IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (x)));\n-\t}\n+\tif (implementation_template != objc_implementation_context)\n+\t  {\n+\t    /* Ensure that all method listed in the interface contain bodies.  */\n+\t    check_methods (CLASS_CLS_METHODS (implementation_template),\n+\t\t\t   CLASS_CLS_METHODS (objc_implementation_context), '+');\n+\t    check_methods (CLASS_NST_METHODS (implementation_template),\n+\t\t\t   CLASS_NST_METHODS (objc_implementation_context), '-');\n+\n+\t    if (CLASS_PROTOCOL_LIST (implementation_template))\n+\t      check_protocols (CLASS_PROTOCOL_LIST (implementation_template),\n+\t\t\t       \"class\",\n+\t\t\t       CLASS_NAME (objc_implementation_context));\n+\t  }\n+\tbreak;\n+      }\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+      {\n+\ttree category = lookup_category (implementation_template, CLASS_SUPER_NAME (klass));\n+\t\n+\tif (category)\n+\t  {\n+\t    /* Generate what needed for property; setters, getters, etc. */\n+\t    objc_gen_property_data (implementation_template, category);\n+\t    \n+\t    /* Ensure all method listed in the interface contain bodies.  */\n+\t    check_methods (CLASS_CLS_METHODS (category),\n+\t\t\t   CLASS_CLS_METHODS (objc_implementation_context), '+');\n+\t    check_methods (CLASS_NST_METHODS (category),\n+\t\t\t   CLASS_NST_METHODS (objc_implementation_context), '-');\n+\t    \n+\t    if (CLASS_PROTOCOL_LIST (category))\n+\t      check_protocols (CLASS_PROTOCOL_LIST (category),\n+\t\t\t       \"category\",\n+\t\t\t       CLASS_SUPER_NAME (objc_implementation_context));\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      {\n+\t/* Process properties of the class. */\n+\ttree x;\n+\tfor (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n+\t  {\n+\t    tree type = TREE_TYPE (x);\n+\t    tree prop_name = PROPERTY_NAME (x);\n+\t    /* Build an instance method declaration: - (type) prop_name; */\n+\t    if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n+\t      {\n+\t\t/* No getter attribute specified. Generate an instance method for the \n+\t\t   getter. */\n+\t\ttree rettype = build_tree_list (NULL_TREE, type);\n+\t\ttree getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t      rettype, prop_name, \n+\t\t\t\t\t\t      NULL_TREE, false);\n+\t\tobjc_add_method (objc_interface_context, getter_decl, false, false);\n+\t\tMETHOD_PROPERTY_CONTEXT (getter_decl) = x;\n+\t      }\n+\t    else\n+\t      warning (0, \"getter = %qs may not be specified in an interface\", \n+\t\t       IDENTIFIER_POINTER (PROPERTY_GETTER_NAME (x)));\n+\t    \n+\t    /* Build an instance method declaration: - (void) setName: (type)value; */\n+\t    if (PROPERTY_SETTER_NAME (x) == NULL_TREE \n+\t\t&& PROPERTY_READONLY (x) == boolean_false_node)\n+\t      {\n+\t\t/* Declare a setter instance method in the interface. */\n+\t\ttree key_name, arg_type, arg_name;\n+\t\ttree setter_decl, selector;\n+\t\ttree ret_type = build_tree_list (NULL_TREE, void_type_node);\n+\t\t/* setter name. */\n+\t\tkey_name = get_identifier (objc_build_property_setter_name \n+\t\t\t\t\t   (PROPERTY_NAME (x), false));\n+\t\targ_type = build_tree_list (NULL_TREE, type);\n+\t\targ_name = get_identifier (\"_value\");\n+\t\t/* For now, no attributes.  */\n+\t\tselector = objc_build_keyword_decl (key_name, arg_type, arg_name, NULL);\n+\t\tsetter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t ret_type, selector, \n+\t\t\t\t\t\t build_tree_list (NULL_TREE, NULL_TREE),\n+\t\t\t\t\t\t false);\n+\t\tobjc_add_method (objc_interface_context, setter_decl, false, false);\n+\t\tMETHOD_PROPERTY_CONTEXT (setter_decl) = x;\n+\t      }\n+\t    else if (PROPERTY_SETTER_NAME (x))\n+\t      warning (0, \"setter = %qs may not be specified in an interface\", \n+\t\t       IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x)));\n+\t    if (PROPERTY_IVAR_NAME (x))\n+\t      warning (0, \"ivar  = %qs attribute may not be specified in an interface\",\n+\t\t       IDENTIFIER_POINTER (PROPERTY_IVAR_NAME (x)));\n+\t  }\n+      }\n     }\n }\n \n@@ -9089,6 +9144,8 @@ encode_type_qualifiers (tree declspecs)\n         obstack_1grow (&util_obstack, 'R');\n       else if (ridpointers[(int) RID_ONEWAY] == TREE_VALUE (spec))\n \tobstack_1grow (&util_obstack, 'V');\n+      else\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -9492,38 +9549,31 @@ encode_type (tree type, int curtype, int format)\n \t  case 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n \t  case 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n \t  case 32:\n-\t    if (flag_next_runtime)\n-\t      {\n-\t\ttree int_type;\n-\t\t/* Another legacy kludge for compatiblity with\n-\t\t   gcc-3.3: 32-bit longs are encoded as 'l' or 'L',\n-\t\t   but not always.  For typedefs, we need to use 'i'\n-\t\t   or 'I' instead if encoding a struct field, or a\n-\t\t   pointer!  */\n-\t\tint_type =  ((!generating_instance_variables\n-\t\t\t      && (obstack_object_size (&util_obstack)\n-\t\t\t\t  == (unsigned) curtype))\n-\t\t\t     ? TYPE_MAIN_VARIANT (type)\n-\t\t\t     : type);\n-\t\t\n-\t\tif (int_type == long_unsigned_type_node\n-\t\t    || int_type == long_integer_type_node)\n-\t\t  c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n-\t\telse\n-\t\t  c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (type == long_unsigned_type_node\n-\t\t    || type == long_integer_type_node)\n-\t\t  c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n-\t\telse\n-\t\t  c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n-\t      }\n+\t    {\n+\t      tree int_type = type;\n+\t      if (flag_next_runtime)\n+\t\t{\n+\t\t  /* Another legacy kludge for compatiblity with\n+\t\t     gcc-3.3: 32-bit longs are encoded as 'l' or 'L',\n+\t\t     but not always.  For typedefs, we need to use 'i'\n+\t\t     or 'I' instead if encoding a struct field, or a\n+\t\t     pointer!  */\n+\t\t  int_type =  ((!generating_instance_variables\n+\t\t\t\t&& (obstack_object_size (&util_obstack)\n+\t\t\t\t    == (unsigned) curtype))\n+\t\t\t       ? TYPE_MAIN_VARIANT (type)\n+\t\t\t       : type);\n+\t\t}\n+\t      if (int_type == long_unsigned_type_node\n+\t\t  || int_type == long_integer_type_node)\n+\t\tc = TYPE_UNSIGNED (type) ? 'L' : 'l';\n+\t      else\n+\t\tc = TYPE_UNSIGNED (type) ? 'I' : 'i';\n+\t    }\n \t    break;\n \t  case 64:  c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n \t  case 128: c = TYPE_UNSIGNED (type) ? 'T' : 't'; break;\n-\t  default: abort ();\n+\t  default: gcc_unreachable ();\n \t  }\n \tobstack_1grow (&util_obstack, c);\n \tbreak;\n@@ -9538,7 +9588,7 @@ encode_type (tree type, int curtype, int format)\n \t  case 64:  c = 'd'; break;\n \t  case 96:\n \t  case 128: c = 'D'; break;\n-\t  default: abort ();\n+\t  default: gcc_unreachable ();\n \t  }\n \tobstack_1grow (&util_obstack, c);\n \tbreak;\n@@ -9622,37 +9672,48 @@ encode_gnu_bitfield (int position, tree type, int size)\n       if (integer_zerop (TYPE_MIN_VALUE (type)))\n \t/* Unsigned integer types.  */\n \t{\n-\t  if (TYPE_MODE (type) == QImode)\n-\t    charType = 'C';\n-\t  else if (TYPE_MODE (type) == HImode)\n-\t    charType = 'S';\n-\t  else if (TYPE_MODE (type) == SImode)\n+\t  switch (TYPE_MODE (type))\n \t    {\n-\t      if (type == long_unsigned_type_node)\n-\t\tcharType = 'L';\n-\t      else\n-\t\tcharType = 'I';\n+\t    case QImode:\n+\t      charType = 'C'; break;\n+\t    case HImode:\n+\t      charType = 'S'; break;\n+\t    case SImode:\n+\t      {\n+\t\tif (type == long_unsigned_type_node)\n+\t\t  charType = 'L';\n+\t\telse\n+\t\t  charType = 'I';\n+\t\tbreak;\n+\t      }\n+\t    case DImode:\n+\t      charType = 'Q'; break;\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\t  else if (TYPE_MODE (type) == DImode)\n-\t    charType = 'Q';\n \t}\n       else\n \t/* Signed integer types.  */\n \t{\n-\t  if (TYPE_MODE (type) == QImode)\n-\t    charType = 'c';\n-\t  else if (TYPE_MODE (type) == HImode)\n-\t    charType = 's';\n-\t  else if (TYPE_MODE (type) == SImode)\n+\t  switch (TYPE_MODE (type))\n \t    {\n-\t      if (type == long_integer_type_node)\n-\t\tcharType = 'l';\n-\t      else\n-\t\tcharType = 'i';\n+\t    case QImode:\n+\t      charType = 'c'; break;\n+\t    case HImode:\n+\t      charType = 's'; break;\n+\t    case SImode:\n+\t      {\n+\t\tif (type == long_integer_type_node)\n+\t\t  charType = 'l';\n+\t\telse\n+\t\t  charType = 'i';\n+\t\tbreak;\n+\t      }\n+\t    case DImode:\n+\t      charType = 'q'; break;\n+\t    default:\n+\t      gcc_unreachable ();\n \t    }\n-\n-\t  else if (TYPE_MODE (type) == DImode)\n-\t    charType = 'q';\n \t}\n     }\n   else\n@@ -10501,14 +10562,15 @@ dump_interface (FILE *fp, tree chain)\n     {\n       const char *name = IDENTIFIER_POINTER (CLASS_SUPER_NAME (chain));\n \n-      if (TREE_CODE (chain) == CATEGORY_IMPLEMENTATION_TYPE\n-\t  || TREE_CODE (chain) == CATEGORY_INTERFACE_TYPE)\n+      switch (TREE_CODE (chain))\n \t{\n+\tcase CATEGORY_IMPLEMENTATION_TYPE:\n+\tcase CATEGORY_INTERFACE_TYPE:\n \t  fprintf (fp, \" (%s)\\n\", name);\n-\t}\n-      else\n-\t{\n+\t  break;\n+\tdefault:\n \t  fprintf (fp, \" : %s\\n\", name);\n+\t  break;\n \t}\n     }\n   else\n@@ -10815,34 +10877,40 @@ handle_impent (struct imp_entry *impent)\n   objc_implementation_context = impent->imp_context;\n   implementation_template = impent->imp_template;\n \n-  if (TREE_CODE (impent->imp_context) == CLASS_IMPLEMENTATION_TYPE)\n+  switch (TREE_CODE (impent->imp_context))\n     {\n-      const char *const class_name =\n-\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n-\n-      string = (char *) alloca (strlen (class_name) + 30);\n-\n-      sprintf (string, \"%sobjc_class_name_%s\",\n-               (flag_next_runtime ? \".\" : \"__\"), class_name);\n-    }\n-  else if (TREE_CODE (impent->imp_context) == CATEGORY_IMPLEMENTATION_TYPE)\n-    {\n-      const char *const class_name =\n-\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n-      const char *const class_super_name =\n-        IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n-\n-      string = (char *) alloca (strlen (class_name)\n-\t\t\t\t+ strlen (class_super_name) + 30);\n-\n-      /* Do the same for categories.  Even though no references to\n-         these symbols are generated automatically by the compiler, it\n-         gives you a handle to pull them into an archive by hand.  */\n-      sprintf (string, \"*%sobjc_category_name_%s_%s\",\n-               (flag_next_runtime ? \".\" : \"__\"), class_name, class_super_name);\n+    case CLASS_IMPLEMENTATION_TYPE:\n+      {\n+\tconst char *const class_name =\n+\t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+\t\n+\tstring = (char *) alloca (strlen (class_name) + 30);\n+\t\n+\tsprintf (string, \"%sobjc_class_name_%s\",\n+\t\t (flag_next_runtime ? \".\" : \"__\"), class_name);\n+\tbreak;\n+      }\n+    case CATEGORY_IMPLEMENTATION_TYPE:\n+      {\n+\tconst char *const class_name =\n+\t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n+\tconst char *const class_super_name =\n+\t  IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n+\t\n+\tstring = (char *) alloca (strlen (class_name)\n+\t\t\t\t  + strlen (class_super_name) + 30);\n+\t\n+\t/* Do the same for categories.  Even though no references to\n+\t   these symbols are generated automatically by the compiler,\n+\t   it gives you a handle to pull them into an archive by\n+\t   hand.  */\n+\tsprintf (string, \"*%sobjc_category_name_%s_%s\",\n+\t\t (flag_next_runtime ? \".\" : \"__\"), class_name, class_super_name);\n+\tbreak;\n+      }\n+    default:\n+      return;\n     }\n-  else\n-    return;\n \n #ifdef ASM_DECLARE_CLASS_REFERENCE\n   if (flag_next_runtime)"}]}