{"sha": "b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhZjBjYTVjNzJhODY2M2IzZWE3YjBkNzA2Y2I3MDU1ZDgyN2FlZA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-26T17:52:50Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-26T17:52:50Z"}, "message": "cpphash.h (struct _cpp_buff, [...]): New.\n\n\t* cpphash.h (struct _cpp_buff, _cpp_get_buff, _cpp_release_buff,\n\t_cpp_extend_buff, _cpp_free_buff): New.\n\t(struct cpp_reader): New member free_buffs.\n\t* cppinit.c (cpp_destroy): Free buffers.\n\t* cpplex.c (new_buff, _cpp_release_buff, _cpp_get_buff,\n\t_cpp_extend_buff, _cpp_free_buff): New.\n\t* cpplib.h (struct cpp_options): Remove unused member.\n\t* cppmacro.c (collect_args): New.  Combines the old parse_arg\n\tand parse_args.  Use _cpp_buff for memory allocation.\n\t(funlike_invocation_p, replace_args): Update.\n\nFrom-SVN: r45827", "tree": {"sha": "c6066a336fb26cdd94d5e883ad2dbefc8c99c02d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6066a336fb26cdd94d5e883ad2dbefc8c99c02d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/comments", "author": null, "committer": null, "parents": [{"sha": "9c383523a3f308e683dea3fb80e5774bfb2a040f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c383523a3f308e683dea3fb80e5774bfb2a040f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c383523a3f308e683dea3fb80e5774bfb2a040f"}], "stats": {"total": 364, "additions": 247, "deletions": 117}, "files": [{"sha": "891bfef195b61965cd86b7835dade8cd93c2851e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -1,3 +1,16 @@\n+2001-09-26  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpphash.h (struct _cpp_buff, _cpp_get_buff, _cpp_release_buff,\n+\t_cpp_extend_buff, _cpp_free_buff): New.\n+\t(struct cpp_reader): New member free_buffs.\n+\t* cppinit.c (cpp_destroy): Free buffers.\n+\t* cpplex.c (new_buff, _cpp_release_buff, _cpp_get_buff,\n+\t_cpp_extend_buff, _cpp_free_buff): New.\n+\t* cpplib.h (struct cpp_options): Remove unused member.\n+\t* cppmacro.c (collect_args): New.  Combines the old parse_arg\n+\tand parse_args.  Use _cpp_buff for memory allocation.\n+\t(funlike_invocation_p, replace_args): Update.\n+\n Wed Sep 26 13:20:51 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* final.c (final_scan_insn): Use delete_insn instead of delete_note."}, {"sha": "ee5b03e624a8e3172213c2b42be2719304af04cc", "filename": "gcc/cpphash.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -72,6 +72,21 @@ struct cpp_pool\n   unsigned int locks;\n };\n \n+/* A generic memory buffer.  */\n+\n+typedef struct _cpp_buff _cpp_buff;\n+struct _cpp_buff\n+{\n+  struct _cpp_buff *next;\n+  char *base, *cur, *limit;\n+};\n+\n+extern _cpp_buff *_cpp_get_buff PARAMS ((cpp_reader *, unsigned int));\n+extern void _cpp_release_buff PARAMS ((cpp_reader *, _cpp_buff *));\n+extern _cpp_buff *_cpp_extend_buff PARAMS ((cpp_reader *, _cpp_buff *,\n+\t\t\t\t\t    unsigned int));\n+extern void _cpp_free_buff PARAMS ((_cpp_buff *));\n+\n /* List of directories to look for include files in.  */\n struct search_path\n {\n@@ -254,6 +269,9 @@ struct cpp_reader\n   cpp_pool macro_pool;\t\t/* For macro definitions.  Permanent.  */\n   cpp_pool argument_pool;\t/* For macro arguments.  Temporary.   */\n \n+  /* Memory buffers.  */\n+  _cpp_buff *free_buffs;\n+\n   /* Context stack.  */\n   struct cpp_context base_context;\n   struct cpp_context *context;"}, {"sha": "53e1c68b8a60eebd9332466fbeee11fd2de13210", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -591,6 +591,7 @@ cpp_destroy (pfile)\n   _cpp_free_pool (&pfile->ident_pool);\n   _cpp_free_pool (&pfile->macro_pool);\n   _cpp_free_pool (&pfile->argument_pool);\n+  _cpp_free_buff (pfile->free_buffs);\n \n   for (run = &pfile->base_run; run; run = runn)\n     {"}, {"sha": "1ad608de5b21a5ec5c1185d774bf0c92d74ae631", "filename": "gcc/cpplex.c", "status": "modified", "additions": 91, "deletions": 1, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -107,6 +107,7 @@ static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n static cpp_chunk *new_chunk PARAMS ((unsigned int));\n static int chunk_suitable PARAMS ((cpp_pool *, cpp_chunk *, unsigned int));\n static unsigned int hex_digit_value PARAMS ((unsigned int));\n+static _cpp_buff *new_buff PARAMS ((unsigned int));\n \n /* Utility routine:\n \n@@ -2114,7 +2115,7 @@ cpp_interpret_charconst (pfile, token, warn_multi, traditional, pchars_seen)\n   return result;\n }\n \n-/* Memory pools.  */\n+/* Memory buffers.  */\n \n struct dummy\n {\n@@ -2127,6 +2128,95 @@ struct dummy\n };\n \n #define DEFAULT_ALIGNMENT (offsetof (struct dummy, u))\n+#define CPP_ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n+\n+/* Create a new allocation buffer.  */\n+static _cpp_buff *\n+new_buff (len)\n+     unsigned int len;\n+{\n+  _cpp_buff *result;\n+  char *base;\n+\n+  if (len < 4000)\n+    len = 4000;\n+  len = CPP_ALIGN (len, DEFAULT_ALIGNMENT);\n+\n+  base = xmalloc (len + sizeof (_cpp_buff));\n+  result = (_cpp_buff *) (base + len);\n+  result->base = base;\n+  result->cur = base;\n+  result->limit = base + len;\n+  result->next = NULL;\n+  return result;\n+}\n+\n+/* Place a chain of unwanted allocation buffers on the free list.  */\n+void\n+_cpp_release_buff (pfile, buff)\n+     cpp_reader *pfile;\n+     _cpp_buff *buff;\n+{\n+  _cpp_buff *end = buff;\n+\n+  while (end->next)\n+    end = end->next;\n+  end->next = pfile->free_buffs;\n+  pfile->free_buffs = buff;\n+}\n+\n+/* Return a free buffer of size at least MIN_SIZE.  */\n+_cpp_buff *\n+_cpp_get_buff (pfile, min_size)\n+     cpp_reader *pfile;\n+     unsigned int min_size;\n+{\n+  _cpp_buff *result, **p;\n+\n+  for (p = &pfile->free_buffs;; p = &(*p)->next)\n+    {\n+      if (*p == NULL || (*p)->next == NULL)\n+\treturn new_buff (min_size);\n+      result = (*p)->next;\n+      if ((unsigned int) (result->limit - result->base) > min_size)\n+\tbreak;\n+    }\n+\n+  *p = result->next;\n+  result->next = NULL;\n+  result->cur = result->base;\n+  return result;\n+}\n+\n+/* Return a buffer chained on the end of BUFF.  Copy to it the\n+   uncommitted remaining bytes of BUFF, with at least MIN_EXTRA more\n+   bytes.  */\n+_cpp_buff *\n+_cpp_extend_buff (pfile, buff, min_extra)\n+     cpp_reader *pfile;\n+     _cpp_buff *buff;\n+     unsigned int min_extra;\n+{\n+  unsigned int size = min_extra + (buff->limit - buff->cur) * 2;\n+\n+  buff->next = _cpp_get_buff (pfile, size);\n+  memcpy (buff->next->base, buff->cur, buff->limit - buff->cur);\n+  return buff->next;\n+}\n+\n+/* Free a chain of buffers starting at BUFF.  */\n+void\n+_cpp_free_buff (buff)\n+     _cpp_buff *buff;\n+{\n+  _cpp_buff *next;\n+\n+  for (; buff; buff = next)\n+    {\n+      next = buff->next;\n+      free (buff->base);\n+    }\n+}\n \n static int\n chunk_suitable (pool, chunk, size)"}, {"sha": "5dc6828bf6a2c2d66f94c787f53b0c0e265840c8", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -236,9 +236,6 @@ struct cpp_options\n   /* The language we're preprocessing.  */\n   enum c_lang lang;\n \n-  /* Nonzero means to return spacing characters for stand-alone CPP.  */\n-  unsigned char spacing;\n-\n   /* Non-0 means -v, so print the full set of include dirs.  */\n   unsigned char verbose;\n "}, {"sha": "fd38c08c9ae3bfb5e6d2602585a00de0436c1a98", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 124, "deletions": 113, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8af0ca5c72a8663b3ea7b0d706cb7055d827aed/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=b8af0ca5c72a8663b3ea7b0d706cb7055d827aed", "patch": "@@ -62,8 +62,7 @@ static void push_token_context\n   PARAMS ((cpp_reader *, cpp_macro *, const cpp_token *, unsigned int));\n static void push_ptoken_context\n   PARAMS ((cpp_reader *, cpp_macro *, const cpp_token **, unsigned int));\n-static enum cpp_ttype parse_arg PARAMS ((cpp_reader *, macro_arg *, int));\n-static macro_arg *parse_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n+static _cpp_buff *collect_args PARAMS ((cpp_reader *, const cpp_hashnode *));\n static cpp_context *next_context PARAMS ((cpp_reader *));\n static const cpp_token *padding_token\n   PARAMS ((cpp_reader *, const cpp_token *));\n@@ -461,116 +460,131 @@ paste_all_tokens (pfile, lhs)\n   push_token_context (pfile, NULL, pasted, 1);\n }\n \n-/* Reads the unexpanded tokens of a macro argument into ARG.  VAR_ARGS\n-   is non-zero if this is a variadic macro.  Returns the type of the\n-   token that caused reading to finish.  */\n-static enum cpp_ttype\n-parse_arg (pfile, arg, variadic)\n+/* Reads and returns the arguments to a function-like macro invocation.\n+   Assumes the opening parenthesis has been processed.  If there is an\n+   error, emits an appropriate diagnostic and returns NULL.  */\n+static _cpp_buff *\n+collect_args (pfile, node)\n      cpp_reader *pfile;\n-     struct macro_arg *arg;\n-     int variadic;\n+     const cpp_hashnode *node;\n {\n-  enum cpp_ttype result;\n-  unsigned int paren = 0;\n-\n-  arg->first = (const cpp_token **) POOL_FRONT (&pfile->argument_pool);\n-  for (;; arg->count++)\n+  _cpp_buff *buff, *base_buff;\n+  cpp_macro *macro;\n+  macro_arg *args, *arg;\n+  const cpp_token *token;\n+  unsigned int argc;\n+  bool error = false;\n+\n+  macro = node->value.macro;\n+  if (macro->paramc)\n+    argc = macro->paramc;\n+  else\n+    argc = 1;\n+  buff = _cpp_get_buff (pfile, argc * (50 * sizeof (cpp_token *)\n+\t\t\t\t       + sizeof (macro_arg)));\n+  base_buff = buff;\n+  args = (macro_arg *) buff->base;\n+  memset (args, 0, argc * sizeof (macro_arg));\n+  buff->cur = (char *) &args[argc];\n+  arg = args, argc = 0;\n+\n+  /* Collect the tokens making up each argument.  We don't yet know\n+     how many arguments have been supplied, whether too many or too\n+     few.  Hence the slightly bizarre usage of \"argc\" and \"arg\".  */\n+  do\n     {\n-      const cpp_token *token;\n-      const cpp_token **ptoken = &arg->first[arg->count];\n-      if ((unsigned char *) (ptoken + 2) >= POOL_LIMIT (&pfile->argument_pool))\n-\t{\n-\t  _cpp_next_chunk (&pfile->argument_pool, 2 * sizeof (cpp_token *),\n-\t\t\t   (unsigned char **) &arg->first);\n-\t  ptoken = &arg->first[arg->count];\n-\t}\n+      unsigned int paren_depth = 0;\n+      unsigned int ntokens = 0;\n \n-      /* Drop leading padding.  */\n-      do\n-\ttoken = cpp_get_token (pfile);\n-      while (arg->count == 0 && token->type == CPP_PADDING);\n-      *ptoken++ = token;\n-      result = token->type;\n+      argc++;\n+      arg->first = (const cpp_token **) buff->cur;\n \n-      if (result == CPP_OPEN_PAREN)\n-\tparen++;\n-      else if (result == CPP_CLOSE_PAREN && paren-- == 0)\n-\tbreak;\n-      /* Commas are not terminators within parantheses or variadic.  */\n-      else if (result == CPP_COMMA && paren == 0 && !variadic)\n-\tbreak;\n-      else if (result == CPP_EOF)\n-\t{\n-\t  /* We still need the EOF (added below) to end pre-expansion\n-\t     and directives.  */\n-\t  if (pfile->context->prev || pfile->state.in_directive)\n-\t    _cpp_backup_tokens (pfile, 1);\n-\t  /* Error reported by caller.  */\n-\t  break;\n-\t}\n-      else if (result == CPP_HASH && token->flags & BOL)\n+      for (;;)\n \t{\n-\t  /* 6.10.3 paragraph 11: If there are sequences of\n-\t     preprocessing tokens within the list of arguments that\n-\t     would otherwise act as preprocessing directives, the\n-\t     behavior is undefined.\n-\n-\t     This implementation will report a hard error, terminate\n-\t     the macro invocation, and proceed to process the\n-\t     directive.  */\n-\t  cpp_error (pfile,\n-\t\t     \"directives may not be used inside a macro argument\");\n-\t  _cpp_backup_tokens (pfile, 1);\n-\t  result = CPP_EOF;\n-\t  break;\n-\t}\n-    }\n-\n-  /* Drop trailing padding.  */\n-  while (arg->count > 0 && arg->first[arg->count - 1]->type == CPP_PADDING)\n-    arg->count--;\n+\t  /* Require space for 2 new tokens (including a CPP_EOF).  */\n+\t  if ((char *) &arg->first[ntokens + 2] > buff->limit)\n+\t    {\n+\t      buff = _cpp_extend_buff (pfile, buff,\n+\t\t\t\t       1000 * sizeof (cpp_token *));\n+\t      arg->first = (const cpp_token **) buff->cur;\n+\t    }\n \n-  /* Commit the memory used to store the arguments.  We make the last\n-     argument a CPP_EOF, so that it terminates macro pre-expansion,\n-     but it is not included in arg->count.  */\n-  arg->first[arg->count] = &pfile->eof;  \n-  POOL_COMMIT (&pfile->argument_pool, (arg->count + 1) * sizeof (cpp_token *));\n-  return result;\n-}\n+\t  token = cpp_get_token (pfile);\n \n-/* Parse the arguments making up a macro invocation.  */\n-static macro_arg *\n-parse_args (pfile, node)\n-     cpp_reader *pfile;\n-     const cpp_hashnode *node;\n-{\n-  cpp_macro *macro = node->value.macro;\n-  macro_arg *args, *cur;\n-  enum cpp_ttype type;\n-  int argc, error = 0;\n+\t  if (token->type == CPP_PADDING)\n+\t    {\n+\t      /* Drop leading padding.  */\n+\t      if (ntokens == 0)\n+\t\tcontinue;\n+\t    }\n+\t  else if (token->type == CPP_OPEN_PAREN)\n+\t    paren_depth++;\n+\t  else if (token->type == CPP_CLOSE_PAREN)\n+\t    {\n+\t      if (paren_depth-- == 0)\n+\t\tbreak;\n+\t    }\n+\t  else if (token->type == CPP_COMMA)\n+\t    {\n+\t      /* A comma does not terminate an argument within\n+\t\t parentheses or as part of a variable argument.  */\n+\t      if (paren_depth == 0\n+\t\t  && ! (macro->variadic && argc == macro->paramc))\n+\t\tbreak;\n+\t    }\n+\t  else if (token->type == CPP_EOF\n+\t\t   || (token->type == CPP_HASH && token->flags & BOL))\n+\t    break;\n \n-  /* Allocate room for at least one argument, and zero it out.  */\n-  argc = macro->paramc ? macro->paramc: 1;\n-  args = xcnewvec (macro_arg, argc);\n+\t  arg->first[ntokens++] = token;\n+\t}\n \n-  for (cur = args, argc = 0; ;)\n-    {\n-      argc++;\n+      /* Drop trailing padding.  */\n+      while (ntokens > 0 && arg->first[ntokens - 1]->type == CPP_PADDING)\n+\tntokens--;\n \n-      type = parse_arg (pfile, cur, argc == macro->paramc && macro->variadic);\n-      if (type == CPP_CLOSE_PAREN || type == CPP_EOF)\n-\tbreak;\n+      arg->count = ntokens;\n+      arg->first[ntokens] = &pfile->eof;\n \n-      /* Re-use the last argument for excess arguments.  */\n-      if (argc < macro->paramc)\n-\tcur++;\n+      /* Terminate the argument.  Excess arguments loop back and\n+\t overwrite the final legitimate argument, before failing.  */\n+      if (argc <= macro->paramc)\n+\t{\n+\t  buff->cur = (char *) &arg->first[ntokens + 1];\n+\t  if (argc != macro->paramc)\n+\t    arg++;\n+\t}\n     }\n+  while (token->type != CPP_CLOSE_PAREN\n+\t && token->type != CPP_EOF\n+\t && token->type != CPP_HASH);\n \n-  if (type == CPP_EOF)\n+  if (token->type == CPP_EOF || token->type == CPP_HASH)\n     {\n+      bool step_back = false;\n+\n+      /* 6.10.3 paragraph 11: If there are sequences of preprocessing\n+\t tokens within the list of arguments that would otherwise act\n+\t as preprocessing directives, the behavior is undefined.\n+\n+\t This implementation will report a hard error, terminate the\n+\t macro invocation, and proceed to process the directive.  */\n+      if (token->type == CPP_HASH)\n+\t{\n+\t  cpp_error (pfile,\n+\t\t     \"directives may not be used inside a macro argument\");\n+\t  step_back = true;\n+\t}\n+      else\n+\t/* We still need the CPP_EOF to end directives, and to end\n+           pre-expansion of a macro argument.  */\n+\tstep_back = (pfile->context->prev || pfile->state.in_directive);\n+\n+      if (step_back)\n+\t_cpp_backup_tokens (pfile, 1);\n       cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n-      error = 1;\n+      error = true;\n     }\n   else if (argc < macro->paramc)\n     {\n@@ -592,28 +606,26 @@ parse_args (pfile, node)\n \t  cpp_error (pfile,\n \t\t     \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n \t\t     NODE_NAME (node), macro->paramc, argc);\n-\t  error = 1;\n+\t  error = true;\n \t}\n     }\n   else if (argc > macro->paramc)\n     {\n       /* Empty argument to a macro taking no arguments is OK.  */\n-      if (argc != 1 || cur->count)\n+      if (argc != 1 || arg->count)\n \t{\n \t  cpp_error (pfile,\n \t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n \t\t     NODE_NAME (node), argc, macro->paramc);\n-\t  error = 1;\n+\t  error = true;\n \t}\n     }\n \n-  if (error)\n-    {\n-      free (args);\n-      args = 0;\n-    }\n+  if (!error)\n+    return base_buff;\n \n-  return args;\n+  _cpp_release_buff (pfile, base_buff);\n+  return NULL;\n }\n \n static int\n@@ -622,7 +634,7 @@ funlike_invocation_p (pfile, node)\n      const cpp_hashnode *node;\n {\n   const cpp_token *maybe_paren;\n-  macro_arg *args = 0;\n+  _cpp_buff *buff = NULL;\n \n   pfile->state.prevent_expansion++;\n   pfile->keep_tokens++;\n@@ -634,7 +646,7 @@ funlike_invocation_p (pfile, node)\n   pfile->state.parsing_args = 2;\n \n   if (maybe_paren->type == CPP_OPEN_PAREN)\n-    args = parse_args (pfile, node);\n+    buff = collect_args (pfile, node);\n   else\n     {\n       _cpp_backup_tokens (pfile, 1);\n@@ -648,14 +660,14 @@ funlike_invocation_p (pfile, node)\n   pfile->keep_tokens--;\n   pfile->state.prevent_expansion--;\n \n-  if (args)\n+  if (buff)\n     {\n       if (node->value.macro->paramc > 0)\n-\treplace_args (pfile, node->value.macro, args);\n-      free (args);\n+\treplace_args (pfile, node->value.macro, (macro_arg *) buff->base);\n+      _cpp_release_buff (pfile, buff);\n     }\n \n-  return args != 0;\n+  return buff != 0;\n }\n \n /* Push the context of a macro onto the context stack.  TOKEN is the\n@@ -694,8 +706,8 @@ enter_macro_context (pfile, node)\n }\n \n /* Take the expansion of a function-like MACRO, replacing parameters\n-   with the actual arguments.  Each instance is first macro-expanded,\n-   unless that paramter is operated upon by the # or ## operators.  */\n+   with the actual arguments.  Each argument is macro-expanded before\n+   replacement, unless operated upon by the # or ## operators.  */\n static void\n replace_args (pfile, macro, args)\n      cpp_reader *pfile;\n@@ -904,7 +916,6 @@ expand_arg (pfile, arg)\n {\n   unsigned int capacity;\n \n-  arg->expanded_count = 0;\n   if (arg->count == 0)\n     return;\n "}]}