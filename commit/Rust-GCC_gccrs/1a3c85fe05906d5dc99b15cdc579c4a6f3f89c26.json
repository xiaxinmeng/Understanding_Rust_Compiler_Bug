{"sha": "1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWEzYzg1ZmUwNTkwNmQ1ZGM5OWIxNWNkYzU3OWM0YTZmM2Y4OWMyNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-08-03T12:43:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-08-03T12:43:11Z"}, "message": "Add branch_changer.py script to maintainer-scripts\n\n\t* branch_changer.py: New file.\n\nFrom-SVN: r239066", "tree": {"sha": "fdcfe823dbce7a06c06a93705c3a2f624cbda757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdcfe823dbce7a06c06a93705c3a2f624cbda757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30e8d8754d68eeadb7c27e84edd61a78eb6c1801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30e8d8754d68eeadb7c27e84edd61a78eb6c1801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30e8d8754d68eeadb7c27e84edd61a78eb6c1801"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "84894d0415e781537de403a01ce62ef1bf755929", "filename": "maintainer-scripts/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26/maintainer-scripts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26/maintainer-scripts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2FChangeLog?ref=1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "patch": "@@ -1,3 +1,7 @@\n+2016-08-03  Martin Liska  <mliska@suse.cz>\n+\n+\t* branch_changer.py: New file.\n+\n 2016-07-26  Richard Biener  <rguenther@suse.de>\n \n \t* update_version_svn: Ignore the GCC 4.9 branch."}, {"sha": "5e1681b2fda17ecd5145776db3f015afbea3240b", "filename": "maintainer-scripts/branch_changer.py", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26/maintainer-scripts%2Fbranch_changer.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26/maintainer-scripts%2Fbranch_changer.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2Fbranch_changer.py?ref=1a3c85fe05906d5dc99b15cdc579c4a6f3f89c26", "patch": "@@ -0,0 +1,195 @@\n+#!/usr/bin/env python3\n+\n+# The script requires simplejson, requests, semantic_version packages, in case\n+# of openSUSE:\n+# zypper in python3-simplejson python3-requests\n+# pip3 install semantic_version\n+\n+import requests\n+import json\n+import argparse\n+import re\n+\n+from semantic_version import Version\n+\n+base_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/'\n+statuses = ['UNCONFIRMED', 'ASSIGNED', 'SUSPENDED', 'NEW', 'WAITING', 'REOPENED']\n+search_summary = ' Regression]'\n+regex = '(.*\\[)([0-9\\./]*)( [rR]egression])(.*)'\n+\n+class Bug:\n+    def __init__(self, data):\n+        self.data = data\n+        self.versions = None\n+        self.fail_versions = []\n+        self.is_regression = False\n+\n+        self.parse_summary()\n+        self.parse_known_to_fail()\n+\n+    def parse_summary(self):\n+        m = re.match(regex, self.data['summary'])\n+        if m != None:\n+            self.versions = m.group(2).split('/')\n+            self.is_regression = True\n+            self.regex_match = m\n+\n+    def parse_known_to_fail(self):\n+        v = self.data['cf_known_to_fail'].strip()\n+        if v != '':\n+            self.fail_versions = [x for x in re.split(' |,', v) if x != '']\n+\n+    def name(self):\n+        return 'PR%d (%s)' % (self.data['id'], self.data['summary'])\n+\n+    def remove_release(self, release):\n+        # Do not remove last value of [x Regression]\n+        if len(self.versions) == 1:\n+            return\n+        self.versions = list(filter(lambda x: x != release, self.versions))\n+\n+    def add_release(self, releases):\n+        parts = releases.split(':')\n+        assert len(parts) == 2\n+        for i, v in enumerate(self.versions):\n+            if v == parts[0]:\n+                self.versions.insert(i + 1, parts[1])\n+                break\n+\n+    def add_known_to_fail(self, release):\n+        if release in self.fail_versions:\n+            return False\n+        else:\n+            self.fail_versions.append(release)\n+            return True\n+\n+    def update_summary(self, api_key, doit):\n+        summary = self.data['summary']\n+        new_summary = self.serialize_summary()\n+        if new_summary != summary:\n+            print(self.name())\n+            print('  changing summary: \"%s\" to \"%s\"' % (summary, new_summary))\n+            self.modify_bug(api_key, {'summary': new_summary}, doit)\n+\n+            return True\n+\n+        return False\n+\n+    def change_milestone(self, api_key, old_milestone, new_milestone, comment, new_fail_version, doit):\n+        old_major = Bug.get_major_version(old_milestone)\n+        new_major = Bug.get_major_version(new_milestone)\n+\n+        print(self.name())\n+        args = {}\n+        if old_major == new_major:\n+            args['target_milestone'] = new_milestone\n+            print('  changing target milestone: \"%s\" to \"%s\" (same branch)' % (old_milestone, new_milestone))\n+        elif self.is_regression and new_major in self.versions:\n+            args['target_milestone'] = new_milestone\n+            print('  changing target milestone: \"%s\" to \"%s\" (regresses with the new milestone)' % (old_milestone, new_milestone))\n+        else:\n+            print('  not changing target milestone: not a regression or does not regress with the new milestone')\n+\n+        if 'target_milestone' in args and comment != None:\n+            print('  adding comment: \"%s\"' % comment)\n+            args['comment'] = {'comment': comment }\n+\n+        if new_fail_version != None:\n+            if self.add_known_to_fail(new_fail_version):\n+                s = self.serialize_known_to_fail()\n+                print('  changing known_to_fail: \"%s\" to \"%s\"' % (self.data['cf_known_to_fail'], s))\n+                args['cf_known_to_fail'] = s\n+\n+        if len(args.keys()) != 0:\n+            self.modify_bug(api_key, args, doit)\n+            return True\n+        else:\n+            return False\n+\n+    def serialize_summary(self):\n+        assert self.versions != None\n+        assert self.is_regression == True\n+\n+        new_version = '/'.join(self.versions)\n+        new_summary = self.regex_match.group(1) + new_version + self.regex_match.group(3) + self.regex_match.group(4)\n+        return new_summary\n+\n+    def serialize_known_to_fail(self):\n+        assert type(self.fail_versions) is list\n+        return ', '.join(sorted(self.fail_versions, key = lambda x: Version(x, partial = True)))\n+\n+    def modify_bug(self, api_key, params, doit):\n+        u = base_url + 'bug/' + str(self.data['id'])\n+\n+        data = {\n+            'ids': [self.data['id']],\n+            'api_key': api_key }\n+\n+        data.update(params)\n+\n+        if doit:\n+            r = requests.put(u, data = json.dumps(data), headers = {\"content-type\": \"text/javascript\"})\n+            print(r)\n+\n+    @staticmethod\n+    def get_major_version(release):\n+        parts = release.split('.')\n+        assert len(parts) == 2 or len(parts) == 3\n+        return '.'.join(parts[:-1])\n+\n+    @staticmethod\n+    def get_bugs(api_key, query):\n+        u = base_url + 'bug'\n+        r = requests.get(u, params = query)\n+        return [Bug(x) for x in r.json()['bugs']]\n+\n+def search(api_key, remove, add, limit, doit):\n+    bugs = Bug.get_bugs(api_key, {'api_key': api_key, 'summary': search_summary, 'bug_status': statuses})\n+    bugs = list(filter(lambda x: x.is_regression, bugs))\n+\n+    modified = 0\n+    for bug in bugs:\n+        if remove != None:\n+            bug.remove_release(remove)\n+        if add != None:\n+            bug.add_release(add)\n+\n+        if bug.update_summary(api_key, doit):\n+            modified += 1\n+            if modified == limit:\n+                break\n+\n+    print('\\nModified PRs: %d' % modified)\n+\n+def replace_milestone(api_key, limit, old_milestone, new_milestone, comment, add_known_to_fail, doit):\n+    bugs = Bug.get_bugs(api_key, {'api_key': api_key, 'bug_status': statuses, 'target_milestone': old_milestone})\n+\n+    modified = 0\n+    for bug in bugs:\n+        if bug.change_milestone(api_key, old_milestone, new_milestone, comment, add_known_to_fail, doit):\n+            modified += 1\n+            if modified == limit:\n+                break\n+\n+    print('\\nModified PRs: %d' % modified)\n+\n+parser = argparse.ArgumentParser(description='')\n+parser.add_argument('api_key', help = 'API key')\n+parser.add_argument('--remove', nargs = '?', help = 'Remove a release from summary')\n+parser.add_argument('--add', nargs = '?', help = 'Add a new release to summary, e.g. 6:7 will add 7 where 6 is included')\n+parser.add_argument('--limit', nargs = '?', help = 'Limit number of bugs affected by the script')\n+parser.add_argument('--doit', action = 'store_true', help = 'Really modify BUGs in the bugzilla')\n+parser.add_argument('--new-target-milestone', help = 'Set a new target milestone, e.g. 4.9.3:4.9.4 will set milestone to 4.9.4 for all PRs having milestone set to 4.9.3')\n+parser.add_argument('--add-known-to-fail', help = 'Set a new known to fail for all PRs affected by --new-target-milestone')\n+parser.add_argument('--comment', help = 'Comment a PR for which we set a new target milestore')\n+\n+args = parser.parse_args()\n+# Python3 does not have sys.maxint\n+args.limit = int(args.limit) if args.limit != None else 10**10\n+\n+if args.remove != None or args.add != None:\n+    search(args.api_key, args.remove, args.add, args.limit, args.doit)\n+if args.new_target_milestone != None:\n+    t = args.new_target_milestone.split(':')\n+    assert len(t) == 2\n+    replace_milestone(args.api_key, args.limit, t[0], t[1], args.comment, args.add_known_to_fail, args.doit)"}]}