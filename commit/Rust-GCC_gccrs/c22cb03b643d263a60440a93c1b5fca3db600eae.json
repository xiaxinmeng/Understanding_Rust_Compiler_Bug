{"sha": "c22cb03b643d263a60440a93c1b5fca3db600eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyY2IwM2I2NDNkMjYzYTYwNDQwYTkzYzFiNWZjYTNkYjYwMGVhZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-05-16T20:52:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-05-16T20:52:18Z"}, "message": "re PR c++/48969 (ICE with -std=c++0x)\n\n\tPR c++/48969\n\t* pt.c (deduction_tsubst_fntype): Use a VEC initially.\n\nFrom-SVN: r173805", "tree": {"sha": "71f14de6900af68e64168c3ba9cf1e6f9758cc37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71f14de6900af68e64168c3ba9cf1e6f9758cc37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c22cb03b643d263a60440a93c1b5fca3db600eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22cb03b643d263a60440a93c1b5fca3db600eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c22cb03b643d263a60440a93c1b5fca3db600eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22cb03b643d263a60440a93c1b5fca3db600eae/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20c97ec9baa279470107a024fe57b1eb66a85d5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c97ec9baa279470107a024fe57b1eb66a85d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c97ec9baa279470107a024fe57b1eb66a85d5c"}], "stats": {"total": 117, "additions": 93, "deletions": 24}, "files": [{"sha": "6260a3b085d33ef98e3c14fde134b089b75212e4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cb03b643d263a60440a93c1b5fca3db600eae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cb03b643d263a60440a93c1b5fca3db600eae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c22cb03b643d263a60440a93c1b5fca3db600eae", "patch": "@@ -1,3 +1,8 @@\n+2011-05-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/48969\n+\t* pt.c (deduction_tsubst_fntype): Use a VEC initially.\n+\n 2011-05-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* cxx-pretty-print.c: Update comment."}, {"sha": "cc14f0275bce1e9aadd0b5e8988f8455703e51c8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cb03b643d263a60440a93c1b5fca3db600eae/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cb03b643d263a60440a93c1b5fca3db600eae/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c22cb03b643d263a60440a93c1b5fca3db600eae", "patch": "@@ -13526,17 +13526,30 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n   return result;\n }\n \n-static GTY((param_is (spec_entry))) htab_t current_deduction_substs;\n+DEF_VEC_O (spec_entry);\n+DEF_VEC_ALLOC_O (spec_entry,gc);\n+static GTY(()) VEC(spec_entry,gc) *current_deduction_vec;\n+static GTY((param_is (spec_entry))) htab_t current_deduction_htab;\n \n /* In C++0x, it's possible to have a function template whose type depends\n    on itself recursively.  This is most obvious with decltype, but can also\n    occur with enumeration scope (c++/48969).  So we need to catch infinite\n-   recursion and reject the substitution at deduction time.  */\n+   recursion and reject the substitution at deduction time.\n+\n+   Use of a VEC here is O(n^2) in the depth of function template argument\n+   deduction substitution, but using a hash table creates a lot of constant\n+   overhead for the typical case of very low depth.  So to make the typical\n+   case fast we start out with a VEC and switch to a hash table only if\n+   depth gets to be significant; in one metaprogramming testcase, even at\n+   depth 80 the overhead of the VEC relative to a hash table was only about\n+   0.5% of compile time.  */\n \n static tree\n deduction_tsubst_fntype (tree fn, tree targs)\n {\n+  unsigned i;\n   spec_entry **slot;\n+  spec_entry *p;\n   spec_entry elt;\n   tree r;\n   hashval_t hash;\n@@ -13547,29 +13560,83 @@ deduction_tsubst_fntype (tree fn, tree targs)\n   if (cxx_dialect < cxx0x)\n     return tsubst (fntype, targs, tf_none, NULL_TREE);\n \n+  /* If we're seeing a lot of recursion, switch over to a hash table.  The\n+     constant 40 is fairly arbitrary.  */\n+  if (!current_deduction_htab\n+      && VEC_length (spec_entry, current_deduction_vec) > 40)\n+    {\n+      current_deduction_htab = htab_create_ggc (40*2, hash_specialization,\n+\t\t\t\t\t\teq_specializations, ggc_free);\n+      FOR_EACH_VEC_ELT (spec_entry, current_deduction_vec, i, p)\n+\t{\n+\t  slot = (spec_entry **) htab_find_slot (current_deduction_htab,\n+\t\t\t\t\t\t p, INSERT);\n+\t  *slot = ggc_alloc_spec_entry ();\n+\t  **slot = *p;\n+\t}\n+      VEC_free (spec_entry, gc, current_deduction_vec);\n+    }\n+\n+  /* Now check everything in the vector, if any.  */\n+  FOR_EACH_VEC_ELT (spec_entry, current_deduction_vec, i, p)\n+    if (p->tmpl == fn && comp_template_args (p->args, targs))\n+      {\n+\tp->spec = error_mark_node;\n+\treturn error_mark_node;\n+      }\n+\n   elt.tmpl = fn;\n   elt.args = targs;\n   elt.spec = NULL_TREE;\n-  hash = hash_specialization (&elt);\n \n-  slot = (spec_entry **)\n-    htab_find_slot_with_hash (current_deduction_substs, &elt, hash, INSERT);\n-  if (*slot)\n-    /* We already have an entry for this.  */\n-    (*slot)->spec = r = error_mark_node;\n+  /* If we've created a hash table, look there.  */\n+  if (current_deduction_htab)\n+    {\n+      hash = hash_specialization (&elt);\n+      slot = (spec_entry **)\n+\thtab_find_slot_with_hash (current_deduction_htab, &elt, hash, INSERT);\n+      if (*slot)\n+\t{\n+\t  /* We already have an entry for this.  */\n+\t  (*slot)->spec = error_mark_node;\n+\t  return error_mark_node;\n+\t}\n+      else\n+\t{\n+\t  /* Create a new entry.  */\n+\t  *slot = ggc_alloc_spec_entry ();\n+\t  **slot = elt;\n+\t}\n+    }\n   else\n     {\n-      /* Create a new entry.  */\n-      spec_entry *p = *slot = ggc_alloc_spec_entry ();\n-      *p = elt;\n+      /* No hash table, so add it to the VEC.  */\n+      hash = 0;\n+      VEC_safe_push (spec_entry, gc, current_deduction_vec, &elt);\n+    }\n \n-      r = tsubst (fntype, targs, tf_none, NULL_TREE);\n-      if (p->spec == error_mark_node)\n-\tr = error_mark_node;\n+  r = tsubst (fntype, targs, tf_none, NULL_TREE);\n \n-      htab_remove_elt_with_hash (current_deduction_substs, p, hash);\n+  /* After doing the substitution, make sure we didn't hit it again.  Note\n+     that we might have switched to a hash table during tsubst.  */\n+  if (current_deduction_htab)\n+    {\n+      if (hash == 0)\n+\thash = hash_specialization (&elt);\n+      slot = (spec_entry **)\n+\thtab_find_slot_with_hash (current_deduction_htab, &elt, hash,\n+\t\t\t\t  NO_INSERT);\n+      if ((*slot)->spec == error_mark_node)\n+\tr = error_mark_node;\n+      htab_clear_slot (current_deduction_htab, (void**)slot);\n+    }\n+  else\n+    {\n+      if (VEC_last (spec_entry, current_deduction_vec)->spec\n+\t  == error_mark_node)\n+\tr = error_mark_node;\n+      VEC_pop (spec_entry, current_deduction_vec);\n     }\n-\n   return r;\n }\n \n@@ -19331,10 +19398,6 @@ init_template_processing (void)\n \t\t\t\t\t  hash_specialization,\n \t\t\t\t\t  eq_specializations,\n \t\t\t\t\t  ggc_free);\n-  if (cxx_dialect >= cxx0x)\n-    current_deduction_substs = htab_create_ggc (37, hash_specialization,\n-\t\t\t\t\t\teq_specializations,\n-\t\t\t\t\t\tggc_free);\n }\n \n /* Print stats about the template hash tables for -fstats.  */\n@@ -19350,10 +19413,11 @@ print_template_statistics (void)\n \t   \"%f collisions\\n\", (long) htab_size (type_specializations),\n \t   (long) htab_elements (type_specializations),\n \t   htab_collisions (type_specializations));\n-  fprintf (stderr, \"current_deduction_substs: size %ld, %ld elements, \"\n-\t   \"%f collisions\\n\", (long) htab_size (current_deduction_substs),\n-\t   (long) htab_elements (current_deduction_substs),\n-\t   htab_collisions (current_deduction_substs));\n+  if (current_deduction_htab)\n+    fprintf (stderr, \"current_deduction_htab: size %ld, %ld elements, \"\n+\t     \"%f collisions\\n\", (long) htab_size (current_deduction_htab),\n+\t     (long) htab_elements (current_deduction_htab),\n+\t     htab_collisions (current_deduction_htab));\n }\n \n #include \"gt-cp-pt.h\""}]}