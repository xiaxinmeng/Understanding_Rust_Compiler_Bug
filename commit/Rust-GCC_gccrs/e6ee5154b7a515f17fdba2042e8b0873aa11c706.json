{"sha": "e6ee5154b7a515f17fdba2042e8b0873aa11c706", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlZTUxNTRiN2E1MTVmMTdmZGJhMjA0MmU4YjA4NzNhYTExYzcwNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-03T02:35:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-03T02:35:26Z"}, "message": "Initial revision\n\nFrom-SVN: r154", "tree": {"sha": "8675f8ae284752d298652a00580ed9dc2e3f1ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8675f8ae284752d298652a00580ed9dc2e3f1ab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6ee5154b7a515f17fdba2042e8b0873aa11c706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ee5154b7a515f17fdba2042e8b0873aa11c706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ee5154b7a515f17fdba2042e8b0873aa11c706", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ee5154b7a515f17fdba2042e8b0873aa11c706/comments", "author": null, "committer": null, "parents": [{"sha": "9f682aa750be6502cf322245d9a0cb05470d302d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f682aa750be6502cf322245d9a0cb05470d302d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f682aa750be6502cf322245d9a0cb05470d302d"}], "stats": {"total": 1898, "additions": 1898, "deletions": 0}, "files": [{"sha": "8b72b57c4ecedb3b5ae455eac2fca34422e1c1a0", "filename": "gcc/config/romp/romp.c", "status": "added", "additions": 1898, "deletions": 0, "changes": 1898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ee5154b7a515f17fdba2042e8b0873aa11c706/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ee5154b7a515f17fdba2042e8b0873aa11c706/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=e6ee5154b7a515f17fdba2042e8b0873aa11c706", "patch": "@@ -0,0 +1,1898 @@\n+/* Subroutines used for code generation on ROMP.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Contributed by Richard Kenner (kenner@nyu.edu)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"recog.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+#include \"tree.h\"\n+\n+#define min(A,B)\t((A) < (B) ? (A) : (B))\n+#define max(A,B)\t((A) > (B) ? (A) : (B))\n+\n+static int unsigned_comparisons_p ();\n+static void output_loadsave_fpregs ();\n+static void output_fpops ();\n+static void init_fpops ();\n+\f\n+/* Return 1 if the insn using CC0 set by INSN does not contain\n+   any unsigned tests applied to the condition codes.\n+\n+   Based on `next_insn_tests_no_inequality' in recog.c.  */\n+\n+int\n+next_insn_tests_no_unsigned (insn)\n+     rtx insn;\n+{\n+  register rtx next = next_cc0_user (insn);\n+\n+  if (next == 0)\n+    {\n+      if (find_reg_note (insn, REG_UNUSED, cc0_rtx))\n+\treturn 1;\n+      else\n+\tabort ();\n+    }\n+\n+  return ((GET_CODE (next) == JUMP_INSN\n+\t   || GET_CODE (next) == INSN\n+\t   || GET_CODE (next) == CALL_INSN)\n+\t  && ! unsigned_comparisons_p (PATTERN (next)));\n+}\n+\n+static int\n+unsigned_comparisons_p (x)\n+     rtx x;\n+{\n+  register char *fmt;\n+  register int len, i;\n+  register enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case REG:\n+    case PC:\n+    case CC0:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return 0;\n+\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+      return (XEXP (x, 0) == cc0_rtx || XEXP (x, 1) == cc0_rtx);\n+    }\n+\n+  len = GET_RTX_LENGTH (code);\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (unsigned_comparisons_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (unsigned_comparisons_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\t    \n+  return 0;\n+}\n+\f\n+/* Update the condition code from the insn.  Look mostly at the first\n+   byte of the machine-specific insn description information.\n+\n+   cc_state.value[12] refer to two possible values that might correspond\n+   to the CC.  We only store register values.  */\n+\n+update_cc (body, insn)\n+    rtx body;\n+    rtx insn;\n+{\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect the CC at all.  */\n+      break;\n+\n+    case CC_CHANGE0:\n+      /* Insn doesn't affect the CC but does modify operand[0], known to be\n+\t a register.  */\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+\n+      if (cc_status.value2 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n+\tcc_status.value2 = 0;\n+\n+      break;\n+\n+    case CC_COPY1TO0:\n+      /* Insn copies operand[1] to operand[0], both registers, but doesn't\n+         affect the CC.  */\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+\n+      if (cc_status.value2 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n+\tcc_status.value2 = 0;\n+\n+      if (cc_status.value1 != 0\n+\t  && rtx_equal_p (cc_status.value1, recog_operand[1]))\n+\tcc_status.value2 = recog_operand[0];\n+\n+      if (cc_status.value2 != 0\n+\t  && rtx_equal_p (cc_status.value2, recog_operand[1]))\n+\tcc_status.value1 = recog_operand[0];\n+\n+      break;\n+\n+    case CC_CLOBBER:\n+      /* Insn clobbers CC. */\n+      CC_STATUS_INIT;\n+      break;\n+\n+    case CC_SETS:\n+      /* Insn sets CC to recog_operand[0], but overflow is impossible.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_OVERFLOW;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+   case CC_COMPARE:\n+      /* Insn is a compare which sets the CC fully.  Update CC_STATUS for this\n+\t compare and mark whether the test will be signed or unsigned.  */\n+      {\n+\tregister rtx p = PATTERN (insn);\n+\n+\tCC_STATUS_INIT;\n+\n+\tif (GET_CODE (p) == PARALLEL)\n+\t  p = XVECEXP (p, 0, 0);\n+\tcc_status.value1 = SET_SRC (p);\n+\n+\tif (GET_CODE (SET_SRC (p)) == REG)\n+\t  cc_status.flags |= CC_NO_OVERFLOW;\n+\tif (! next_insn_tests_no_unsigned (insn))\n+\t  cc_status.flags |= CC_UNSIGNED;\n+      }\n+      break;\n+\n+    case CC_TBIT:\n+      /* Insn sets T bit if result is non-zero.  Next insn must be branch. */\n+      CC_STATUS_INIT;\n+      cc_status.flags = CC_IN_TB | CC_NOT_NEGATIVE;\n+      break;\n+\n+    default:\n+      abort ();\n+   }\n+}\n+\n+/* Return 1 if a previous compare needs to be re-issued.  This will happen\n+   if two compares tested the same objects, but one was signed and the\n+   other unsigned.  OP is the comparison operation being performed.  */\n+\n+int\n+restore_compare_p (op)\n+     rtx op;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  return (((code == GEU || code == LEU || code == GTU || code == LTU)\n+\t   && ! (cc_status.flags & CC_UNSIGNED))\n+\t  || ((code == GE || code == LE || code == GT || code == LT)\n+\t      && (cc_status.flags & CC_UNSIGNED)));\n+}\n+\f\n+/*  Generate the (long) string corresponding to an inline multiply insn.\n+    Note that `r10' does not refer to the register r10, but rather to the\n+    SCR used as the MQ.  */\n+char *\n+output_in_line_mul ()\n+{\n+  static char insns[200];\n+  int i;\n+\n+  strcpy (insns, \"s %0,%0\\n\");\n+  strcat (insns, \"\\tmts r10,%1\\n\");\n+  for (i = 0; i < 16; i++)\n+    strcat (insns, \"\\tm %0,%2\\n\");\n+  strcat (insns, \"\\tmfs r10,%0\");\n+\n+  return insns;\n+}\n+\f\n+/* Returns 1 if OP is a memory reference with an offset from a register within\n+   the range specified.  The offset must also be a multiple of the size of the\n+   mode.  */\n+\n+static int\n+memory_offset_in_range_p (op, mode, low, high)\n+     register rtx op;\n+     enum machine_mode mode;\n+     int low, high;\n+{\n+  int offset = 0;\n+\n+  if (! memory_operand (op, mode))\n+    return 0;\n+\n+  while (GET_CODE (op) == SUBREG)\n+    {\n+      offset += SUBREG_WORD (op) * UNITS_PER_WORD;\n+#if BYTES_BIG_ENDIAN\n+      offset -= (min (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (op)))\n+\t\t - min (UNITS_PER_WORD,\n+\t\t\tGET_MODE_SIZE (GET_MODE (SUBREG_REG (op)))));\n+#endif\n+      op = SUBREG_REG (op);\n+    }\n+\n+  /* We must now have either (mem (reg (x)), (mem (plus (reg (x)) (c))),\n+     or a constant pool address.  */\n+  if (GET_CODE (op) != MEM)\n+    abort ();\n+\n+  /* Now use the actual mode and get the address.  */\n+  mode = GET_MODE (op);\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (op))\n+    offset = get_pool_offset (op) + 12;\n+  else if (GET_CODE (op) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t  || ! register_operand (XEXP (op, 0), Pmode))\n+\treturn 0;\n+\n+      offset += INTVAL (XEXP (op, 1));\n+    }\n+\n+  else if (! register_operand (op, Pmode))\n+    return 0;\n+\n+  return (offset >= low && offset <= high\n+\t  && (offset % GET_MODE_SIZE (mode) == 0));\n+}\n+\n+/* Return 1 if OP is a valid operand for a memory reference insn that can\n+   only reference indirect through a register.   */\n+\n+int\n+zero_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return memory_offset_in_range_p (op, mode, 0, 0);\n+}\n+\n+/* Return 1 if OP is a valid operand for a `short' memory reference insn. */\n+\n+int\n+short_memory_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  return memory_offset_in_range_p (op, mode, 0,\n+\t\t\t\t   15 * min (UNITS_PER_WORD,\n+\t\t\t\t\t     GET_MODE_SIZE (mode)));\n+}\n+\n+/* Returns 1 if OP is a memory reference involving a symbolic constant\n+   that is not in the constant pool. */\n+\n+int\n+symbolic_memory_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (! memory_operand (op, mode))\n+    return 0;\n+\n+  while (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) != MEM)\n+    abort ();\n+\n+  op = XEXP (op, 0);\n+  if (constant_pool_address_operand (op, VOIDmode))\n+    return 0;\n+  else\n+    return romp_symbolic_operand (op, Pmode)\n+      || (GET_CODE (op) == PLUS && register_operand (XEXP (op, 0), Pmode)\n+\t  && romp_symbolic_operand (XEXP (op, 1), Pmode));\n+}\n+\n+\n+/* Returns 1 if OP is a constant pool reference to the current function.  */\n+\n+int\n+current_function_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+      ||  ! CONSTANT_POOL_ADDRESS_P (XEXP (op, 0)))\n+    return 0;\n+\n+  op = get_pool_constant (XEXP (op, 0));\n+  return (GET_CODE (op) == SYMBOL_REF\n+\t  && ! strcmp (current_function_name, XSTR (op, 0)));\n+}\n+\n+/* Return non-zero if this function is known to have a null epilogue.  */\n+\n+int\n+null_epilogue ()\n+{\n+  return (reload_completed\n+\t  && first_reg_to_save () == 16\n+\t  && ! romp_pushes_stack ());\n+}\n+\f\n+/* Returns 1 if OP is the address of a location in the constant pool.  */\n+\n+int\n+constant_pool_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (op))\n+\t  || (GET_CODE (op) == CONST && GET_CODE (XEXP (op, 0)) == PLUS\n+\t      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t      && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (op, 0), 0))));\n+}\n+\n+/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+romp_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return ! op->integrated;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t      || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t     && GET_CODE (XEXP (op, 1)) == CONST_INT;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Returns 1 if OP is a valid constant for the ROMP.  */\n+\n+int\n+constant_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case PLUS:\n+    case CONST:\n+      return romp_symbolic_operand (op,mode);\n+\n+    case CONST_INT:\n+      return (unsigned int) (INTVAL (op) + 0x8000) < 0x10000\n+\t     || (INTVAL (op) & 0xffff) == 0 || (INTVAL (op) & 0xffff0000) == 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Returns 1 if OP is either a constant integer valid for the ROMP or a\n+   register.  If a register, it must be in the proper mode unless MODE is\n+   VOIDmode.  */\n+\n+int\n+reg_or_cint_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return constant_operand (op, mode);\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 is the operand is either a register or ANY constant integer.  */\n+\n+int\n+reg_or_any_cint_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+     return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is either a register or a valid D-type operand. */\n+\n+int\n+reg_or_D_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return (unsigned) (INTVAL (op) + 0x8000) < 0x10000;\n+\n+  return register_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is either a register or an item that can be\n+   used as the operand of an SI add insn.  */\n+\n+int\n+reg_or_add_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return reg_or_D_operand (op, mode) || romp_symbolic_operand (op, mode)\n+\t || (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff) == 0);\n+}\n+\n+/* Return 1 if the operand is either a register or an item that can be\n+   used as the operand of a ROMP logical AND insn.  */\n+\n+int\n+reg_or_and_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (reg_or_cint_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  return (INTVAL (op) & 0xffff) == 0xffff\n+\t || (INTVAL (op) & 0xffff0000) == 0xffff0000;\n+}\n+\n+/* Return 1 if the operand is a register or memory operand.  */\n+\n+int\n+reg_or_mem_operand (op, mode)\n+     register rtx op;\n+     register enum machine_mode mode;\n+{\n+  return register_operand (op, mode) || memory_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is either a register or a memory operand that is\n+   not symbolic.  */\n+\n+int\n+reg_or_nonsymb_mem_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+\n+  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return 1 if this operand is valid for the ROMP.  This is any operand except\n+   certain constant integers.  */\n+\n+int\n+romp_operand (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return constant_operand (op, mode);\n+\n+  return general_operand (op, mode);\n+}\n+\n+/* Return 1 if the operand is (reg:mode 0).  */\n+\n+int\n+reg_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && GET_CODE (op) == REG && REGNO (op) == 0);\n+}\n+\n+/* Return 1 if the operand is (reg:mode 15).  */\n+\n+int\n+reg_15_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || mode == GET_MODE (op))\n+\t  && GET_CODE (op) == REG && REGNO (op) == 15);\n+}\n+\f\n+/* Return 1 if this is a binary floating-point operation.  */\n+\n+int\n+float_binary (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_MODE (op) != SFmode && GET_MODE (op) != DFmode)\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      return GET_MODE (XEXP (op, 0)) == GET_MODE (op)\n+\t     && GET_MODE (XEXP (op, 1)) == GET_MODE (op);\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if this is a unary floating-point operation.  */\n+\n+int\n+float_unary (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  if (GET_MODE (op) != SFmode && GET_MODE (op) != DFmode)\n+    return 0;\n+\n+  return (GET_CODE (op) == NEG || GET_CODE (op) == ABS)\n+\t && GET_MODE (XEXP (op, 0)) == GET_MODE (op);\n+}\n+\n+/* Return 1 if this is a valid floating-point converstion that can be done\n+   as part of an operation by the RT floating-point routines.  */\n+\n+int\n+float_conversion (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case FLOAT_TRUNCATE:\n+      return GET_MODE (op) == SFmode && GET_MODE (XEXP (op, 0)) == DFmode;\n+\n+    case FLOAT_EXTEND:\n+      return GET_MODE (op) == DFmode && GET_MODE (XEXP (op, 0)) == SFmode;\n+\n+    case FLOAT:\n+      return ((GET_MODE (XEXP (op, 0)) == SImode\n+\t       || GET_CODE (XEXP (op, 0)) == CONST_INT)\n+\t      && (GET_MODE (op) == SFmode || GET_MODE (op) == DFmode));\n+\n+    case FIX:\n+      return ((GET_MODE (op) == SImode\n+\t       || GET_CODE (XEXP (op, 0)) == CONST_INT)\n+\t      && (GET_MODE (XEXP (op, 0)) == SFmode\n+\t\t  || GET_MODE (XEXP (op, 0)) == DFmode));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Print an operand.  Recognize special options, documented below.  */\n+\n+void\n+print_operand (file, x, code)\n+    FILE *file;\n+    rtx x;\n+    char code;\n+{\n+  int i;\n+\n+  switch (code)\n+    {\n+    case 'B':\n+      /* Byte number (const/8) */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%B value\");\n+\n+      fprintf (file, \"%d\", INTVAL (x) / 8);\n+      break;\n+\n+    case 'L':\n+      /* Low order 16 bits of constant.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%L value\");\n+\n+      fprintf (file, \"%d\", INTVAL (x) & 0xffff);\n+      break;\n+\n+    case 's':\n+      /* Null or \"16\" depending on whether the constant is greater than 16. */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%s value\");\n+\n+      if (INTVAL (x) >= 16)\n+\tfprintf (file, \"16\");\n+\n+      break;\n+\n+    case 'S':\n+      /* For shifts: 's' will have given the half.  Just give the amount\n+\t within 16.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%S value\");\n+\n+      fprintf (file, \"%d\", INTVAL (x) & 15);\n+      break;\n+\n+    case 'b':\n+      /* The number of a single bit set or cleared, mod 16.  Note that the ROMP\n+\t numbers bits with the high-order bit 31.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%b value\");\n+\n+      if ((i = exact_log2 (INTVAL (x))) >= 0)\n+\tfprintf (file, \"%d\", (31 - i) % 16);\n+      else if ((i = exact_log2 (~ INTVAL (x))) >= 0)\n+\tfprintf (file, \"%d\", (31 - i) % 16);\n+      else\n+\toutput_operand_lossage (\"invalid %%b value\");\n+\n+      break;\n+\n+    case 'h':\n+      /* \"l\" or \"u\" depending on which half of the constant is zero.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%h value\");\n+\n+      if ((INTVAL (x) & 0xffff0000) == 0)\n+\tfprintf (file, \"l\");\n+      else if ((INTVAL (x) & 0xffff) == 0)\n+\tfprintf (file, \"u\");\n+      else\n+\toutput_operand_lossage (\"invalid %%h value\");\n+\n+      break;\n+\n+    case 'H':\n+      /* Upper or lower half, depending on which half is zero.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%H value\");\n+\n+      if ((INTVAL (x) & 0xffff0000) == 0)\n+\tfprintf (file, \"%d\", INTVAL (x) & 0xffff);\n+      else if ((INTVAL (x) & 0xffff) == 0)\n+\tfprintf (file, \"%d\", (INTVAL (x) >> 16) & 0xffff);\n+      else\n+\toutput_operand_lossage (\"invalid %%H value\");\n+\n+      break;\n+\n+    case 'z':\n+      /* Write two characters:\n+\t\t'lo'\tif the high order part is all ones\n+\t\t'lz'\tif the high order part is all zeros\n+\t\t'uo'\tif the low order part is all ones\n+\t\t'uz'\tif the low order part is all zeros \n+       */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%z value\");\n+\n+      if ((INTVAL (x) & 0xffff0000) == 0)\n+\tfprintf (file, \"lz\");\n+      else if ((INTVAL (x) & 0xffff0000) == 0xffff0000)\n+\tfprintf (file, \"lo\");\n+      else if ((INTVAL (x) & 0xffff) == 0)\n+\tfprintf (file, \"uz\");\n+      else if ((INTVAL (x) & 0xffff) == 0xffff)\n+\tfprintf (file, \"uo\");\n+      else\n+\toutput_operand_lossage (\"invalid %%z value\");\n+\n+      break;\n+\n+    case 'Z':\n+      /* Upper or lower half, depending on which is non-zero or not\n+\t all ones.  Must be consistent with 'z' above.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%Z value\");\n+\n+      if ((INTVAL (x) & 0xffff0000) == 0\n+\t  || (INTVAL (x) & 0xffff0000) == 0xffff0000)\n+\tfprintf (file, \"%d\", INTVAL (x) & 0xffff);\n+      else if ((INTVAL (x) & 0xffff) == 0 || (INTVAL (x) & 0xffff) == 0xffff)\n+\tfprintf (file, \"%d\", (INTVAL (x) >> 16) & 0xffff);\n+      else\n+\toutput_operand_lossage (\"invalid %%Z value\");\n+\n+      break;\n+\n+    case 'k':\n+      /* Same as 'z', except the trailing 'o' or 'z' is not written.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%k value\");\n+\n+      if ((INTVAL (x) & 0xffff0000) == 0\n+\t  || (INTVAL (x) & 0xffff0000) == 0xffff0000)\n+\tfprintf (file, \"l\");\n+      else if ((INTVAL (x) & 0xffff) == 0\n+\t       || (INTVAL (x) & 0xffff) == 0xffff)\n+\tfprintf (file, \"u\");\n+      else\n+\toutput_operand_lossage (\"invalid %%k value\");\n+\n+      break;\n+\n+    case 't':\n+      /* Similar to 's', except that we write 'h' or 'u'.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\toutput_operand_lossage (\"invalid %%k value\");\n+\n+      if (INTVAL (x) < 16)\n+\tfprintf (file, \"u\");\n+      else\n+\tfprintf (file, \"l\");\n+      break;\n+\n+    case 'M':\n+      /* For memory operations, write 's' if the operand is a short\n+\t memory operand.  */\n+      if (short_memory_operand (x, VOIDmode))\n+\tfprintf (file, \"s\");\n+      break;\n+\n+    case 'N':\n+      /* Like 'M', but check for zero memory offset.  */\n+      if (zero_memory_operand (x, VOIDmode))\n+\tfprintf (file, \"s\");\n+      break;\n+\n+    case 'O':\n+      /* Write low-order part of DImode or DFmode.  Supported for MEM\n+\t and REG only.  */\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n+      else if (GET_CODE (x) == MEM)\n+\tprint_operand (file, gen_rtx (MEM, GET_MODE (x),\n+\t\t\t\t      plus_constant (XEXP (x, 0), 4)), 0);\n+      else\n+\tabort ();\n+      break;\n+\n+    case 'C':\n+      /* Offset in constant pool for constant pool address.  */\n+      if (! constant_pool_address_operand (x, VOIDmode))\n+\tabort ();\n+      if (GET_CODE (x) == SYMBOL_REF)\n+\tfprintf (file, \"%d\", get_pool_offset (x) + 12);\n+      else \n+\t/* Must be (const (plus (symbol_ref) (const_int))) */\n+\tfprintf (file, \"%d\",\n+\t\t (get_pool_offset (XEXP (XEXP (x, 0), 0)) + 12\n+\t\t  + INTVAL (XEXP (XEXP (x, 0), 1))));\n+      break;\n+\n+    case 'j':\n+      /* Branch opcode.  Check for condition in test bit for eq/ne.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:\n+\t  if (cc_status.flags & CC_IN_TB)\n+\t    fprintf (file, \"ntb\");\n+\t  else\n+\t    fprintf (file, \"eq\");\n+\t  break;\n+\n+\tcase NE:\n+\t  if (cc_status.flags & CC_IN_TB)\n+\t    fprintf (file, \"tb\");\n+\t  else\n+\t    fprintf (file, \"ne\");\n+\t  break;\n+\n+\tcase GT:\n+\tcase GTU:\n+\t  fprintf (file, \"h\");\n+\t  break;\n+\n+\tcase LT:\n+\tcase LTU:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\n+\tcase GE:\n+\tcase GEU:\n+\t  fprintf (file, \"he\");\n+\t  break;\n+\n+\tcase LE:\n+\tcase LEU:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%j value\");\n+\t}\n+      break;\n+\n+    case 'J':\n+      /* Reversed branch opcode.  */\n+      switch (GET_CODE (x))\n+\t{\n+\tcase EQ:\n+\t  if (cc_status.flags & CC_IN_TB)\n+\t    fprintf (file, \"tb\");\n+\t  else\n+\t    fprintf (file, \"ne\");\n+\t  break;\n+\n+\tcase NE:\n+\t  if (cc_status.flags & CC_IN_TB)\n+\t    fprintf (file, \"ntb\");\n+\t  else\n+\t    fprintf (file, \"eq\");\n+\t  break;\n+\n+\tcase GT:\n+\tcase GTU:\n+\t  fprintf (file, \"le\");\n+\t  break;\n+\n+\tcase LT:\n+\tcase LTU:\n+\t  fprintf (file, \"he\");\n+\t  break;\n+\n+\tcase GE:\n+\tcase GEU:\n+\t  fprintf (file, \"l\");\n+\t  break;\n+\n+\tcase LE:\n+\tcase LEU:\n+\t  fprintf (file, \"h\");\n+\t  break;\n+\n+\tdefault:\n+\t  output_operand_lossage (\"invalid %%j value\");\n+\t}\n+      break;\n+\n+    case '.':\n+      /* Output nothing.  Used as delimeter in, e.g., \"mc%B1%.3 \" */\n+      break;\n+\n+    case '#':\n+      /* Output 'x' if this insn has a delay slot, else nothing.  */\n+      if (dbr_sequence_length ())\n+\tfprintf (file, \"x\");\n+      break;\n+\n+    case 0:\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n+      else if (GET_CODE (x) == MEM)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t      && current_function_operand (x, Pmode))\n+\t    fprintf (file, \"r14\");\n+\t  else\n+\t    output_address (XEXP (x, 0));\n+\t}\n+      else\n+\toutput_addr_const (file, x);\n+      break;\n+\n+    default:\n+      output_operand_lossage (\"invalid %%xn code\");\n+    }\n+}\n+\f\n+/* This page contains routines that are used to determine what the function\n+   prologue and epilogue code will do and write them out.  */\n+\n+/*  Return the first register that is required to be saved. 16 if none.  */\n+\n+int\n+first_reg_to_save()\n+{\n+  int first_reg;\n+\n+  /* Find lowest numbered live register.  */\n+  for (first_reg = 6; first_reg <= 15; first_reg++)\n+    if (regs_ever_live[first_reg])\n+      break;\n+\n+  /* If we think that we do not have to save r14, see if it will be used\n+     to be sure.  */\n+  if (first_reg > 14 && romp_using_r14 ())\n+    first_reg = 14;\n+\n+  return first_reg;\n+}\n+\n+/* Compute the size of the save area in the stack, including the space for\n+   the first four incoming arguments.  */\n+\n+int\n+romp_sa_size ()\n+{\n+  int size;\n+  int i;\n+\n+  /* We have the 4 words corresponding to the arguments passed in registers,\n+     4 reserved words, space for static chain, general register save area,\n+     and floating-point save area.  */\n+  size = 4 + 4 + 1 + (16 - first_reg_to_save ());\n+\n+  /* The documentation says we have to leave 18 words in the save area if\n+     any floating-point registers at all are saved, not the three words\n+     per register you might otherwise expect.  */\n+  for (i = 2 + (TARGET_FP_REGS != 0); i <= 7; i++)\n+    if (regs_ever_live[i + 17])\n+      {\n+\tsize += 18;\n+\tbreak;\n+      }\n+\n+  return size * 4;\n+}\n+\n+/* Return non-zero if this function makes calls or has fp operations\n+   (which are really calls).  */\n+\n+int\n+romp_makes_calls ()\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = next_insn (insn))\n+    {\n+      if (GET_CODE (insn) == CALL_INSN)\n+\treturn 1;\n+      else if (GET_CODE (insn) == INSN)\n+\t{\n+\t  rtx body = PATTERN (insn);\n+\n+\t  if (GET_CODE (body) != USE && GET_CODE (body) != CLOBBER\n+\t      && GET_CODE (body) != ADDR_VEC\n+\t      && GET_CODE (body) != ADDR_DIFF_VEC\n+\t      && get_attr_type (insn) == TYPE_FP)\n+\t    return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this function will use r14 as a pointer to its\n+   constant pool.  */\n+\n+int\n+romp_using_r14 ()\n+{\n+  /* If we are debugging, profiling, have a non-empty constant pool, or\n+     call a function, we need r14.  */\n+  return (write_symbols != NO_DEBUG || profile_flag || get_pool_size () != 0\n+\t  || romp_makes_calls ());\n+}\n+\n+/* Return non-zero if this function needs to push space on the stack.  */\n+\n+int\n+romp_pushes_stack ()\n+{\n+  /* We need to push the stack if a frame pointer is needed (because the\n+     stack might be dynamically adjusted), if we are debugging, if the\n+     total required size is more than 100 bytes, or if we make calls.  */\n+\n+  return (frame_pointer_needed || write_symbols != NO_DEBUG\n+\t  || (romp_sa_size () + get_frame_size ()) > 100\n+\t  || romp_makes_calls ());\n+}\n+\n+/* Write function prologue.\n+\n+   We compute the size of the fixed area required as follows:\n+\n+   We always allocate 4 words for incoming arguments, 4 word reserved, 1\n+   word for static link, as many words as required for general register\n+   save area, plus 2 words for each FP reg 2-7 that must be saved.  */\n+\n+void\n+output_prolog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int first_reg;\n+  int reg_save_offset;\n+  rtx insn;\n+  int fp_save = size + current_function_outgoing_args_size;\n+\n+  init_fpops ();\n+\n+  /* Add in fixed size plus output argument area.  */\n+  size += romp_sa_size () + current_function_outgoing_args_size;\n+\n+  /* Compute first register to save and perform the save operation if anything\n+     needs to be saved.  */\n+  first_reg = first_reg_to_save();\n+  reg_save_offset = - (4 + 4 + 1 + (16 - first_reg)) * 4;\n+  if (first_reg == 15)\n+    fprintf (file, \"\\tst r15,%d(r1)\\n\", reg_save_offset);\n+  else if (first_reg < 16)\n+    fprintf (file, \"\\tstm r%d,%d(r1)\\n\", first_reg, reg_save_offset);\n+\n+  /* Set up pointer to data area if it is needed.  */\n+  if (romp_using_r14 ())\n+    fprintf (file, \"\\tcas r14,r0,r0\\n\");\n+\n+  /* Set up frame pointer if needed.  */\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\tcal r13,-%d(r1)\\n\", romp_sa_size () + 64);\n+\n+  /* Push stack if neeeded.  There are a couple of ways of doing this.  */\n+  if (romp_pushes_stack ())\n+    {\n+      if (size >= 32768)\n+\t{\n+\t  if (size >= 65536)\n+\t    {\n+\t      fprintf (file, \"\\tcau r0,%d(r0)\\n\", size >> 16);\n+\t      fprintf (file, \"\\toil r0,r0,%d\\n\", size & 0xffff);\n+\t    }\n+\t  else\n+\t    fprintf (file, \"\\tcal16 r0,%d(r0)\\n\", size);\n+\t  fprintf (file, \"\\ts r1,r0\\n\");\n+\t}\n+      else\n+\tfprintf (file, \"\\tcal r1,-%d(r1)\\n\", size);\n+    }\n+\n+  /* Save floating-point registers.  */\n+  output_loadsave_fpregs (file, USE,\n+\t\t\t  plus_constant (stack_pointer_rtx, fp_save));\n+}\n+\n+/* Write function epilogue.  */\n+\n+void\n+output_epilog (file, size)\n+     FILE *file;\n+     int size;\n+{\n+  int first_reg = first_reg_to_save();\n+  int pushes_stack = romp_pushes_stack ();\n+  int reg_save_offset = - ((16 - first_reg) + 1 + 4 + 4) * 4;\n+  int total_size = (size + romp_sa_size ()\n+\t\t    + current_function_outgoing_args_size);\n+  int fp_save = size + current_function_outgoing_args_size;\n+  int long_frame = total_size >= 32768;\n+  rtx insn = get_last_insn ();\n+  int write_code = 1;\n+\n+  int nargs = 0;\t\t/* words of arguments */\n+  tree argptr;\n+\n+  for (argptr = DECL_ARGUMENTS (current_function_decl);\n+       argptr; argptr = TREE_CHAIN (argptr))\n+    nargs += ((TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (argptr)))\n+\t       + BITS_PER_WORD - 1) / BITS_PER_WORD);\n+  \n+  /* If the last insn was a BARRIER, we don't have to write anything except\n+     the trace table.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    write_code = 0;\n+\n+  /* Restore floating-point registers.  */\n+  if (write_code)\n+    output_loadsave_fpregs (file, CLOBBER,\n+\t\t\t    gen_rtx (PLUS, Pmode, gen_rtx (REG, Pmode, 1),\n+\t\t\t\t     gen_rtx (CONST_INT, VOIDmode, fp_save)));\n+\n+  /* If we push the stack and do not have size > 32K, adjust the register\n+     save location to the current position of sp.  Otherwise, if long frame,\n+     restore sp from fp.  */\n+  if (pushes_stack && ! long_frame)\n+    reg_save_offset += total_size;\n+  else if (long_frame && write_code)\n+    fprintf (file, \"\\tcal r1,%d(r13)\\n\", romp_sa_size () + 64);\n+\n+  /* Restore registers.  */\n+  if (first_reg == 15 && write_code)\n+    fprintf (file, \"\\tl r15,%d(r1)\\n\", reg_save_offset);\n+  else if (first_reg < 16 && write_code)\n+    fprintf (file, \"\\tlm r%d,%d(r1)\\n\", first_reg, reg_save_offset);\n+  if (first_reg == 16) first_reg = 0;\n+\n+  /* Handle popping stack, if needed and write debug table entry.  */\n+  if (pushes_stack)\n+    {\n+      if (write_code)\n+\t{\n+\t  if (long_frame)\n+\t    fprintf (file, \"\\tbr r15\\n\");\n+\t  else\n+\t    fprintf (file, \"\\tbrx r15\\n\\tcal r1,%d(r1)\\n\", total_size);\n+\t}\n+      fprintf (file, \"\\t.long 0x%x\\n\", 0xdf07df08 + first_reg * 0x10);\n+\n+      if (nargs > 15) nargs = 15;\n+      if (frame_pointer_needed)\n+\tfprintf (file, \"\\t.byte 0x%xd, 53\\n\", nargs);\n+      else\n+\tfprintf (file, \"\\t.short 0x%x100\\n\", nargs);\n+    }\n+  else\n+    {\n+      if (write_code)\n+\tfprintf (file, \"\\tbr r15\\n\");\n+      fprintf (file, \"\\t.long 0xdf02df00\\n\");\n+    }\n+\n+  /* Output any pending floating-point operations.  */\n+  if (write_code)\n+    output_fpops (file);\n+}\n+\f\n+/* For the ROMP we need to make new SYMBOL_REFs for the actual name of a\n+   called routine.  To keep them unique we maintain a hash table of all\n+   that have been created so far.  */\n+\n+struct symref_hashent {\n+  rtx symref;\t\t\t/* Created SYMBOL_REF rtx.  */\n+  struct symref_hashent *next;\t/* Next with same hash code.  */\n+};\n+\n+#define SYMHASHSIZE 151\n+#define HASHBITS 65535\n+\n+/* Define the hash table itself.  */\n+\n+static struct symref_hashent *symref_hash_table[SYMHASHSIZE];\n+\n+/* Given a name (allocatable in temporary storage), return a SYMBOL_REF\n+   for the name.  The rtx is allocated from the current rtl_obstack, while\n+   the name string is allocated from the permanent obstack.  */\n+rtx\n+get_symref (name)\n+     register char *name;\n+{\n+  extern struct obstack permanent_obstack;\n+  register char *sp = name;\n+  unsigned int hash = 0;\n+  struct symref_hashent *p, **last_p;\n+\n+  /* Compute the hash code for the string.  */\n+  while (*sp)\n+    hash = (hash << 4) + *sp++;\n+\n+  /* Search for a matching entry in the hash table, keeping track of the\n+     insertion location as we do so.  */\n+  hash = (hash & HASHBITS) % SYMHASHSIZE;\n+  for (last_p = &symref_hash_table[hash], p = *last_p;\n+       p; last_p = &p->next, p = *last_p)\n+    if (strcmp (name, XSTR (p->symref, 0)) == 0)\n+      break;\n+\n+  /* If couldn't find matching SYMBOL_REF, make a new one.  */\n+  if (p == 0)\n+    {\n+      /* Ensure SYMBOL_REF will stay around.  */\n+      end_temporary_allocation ();\n+      p = *last_p = (struct symref_hashent *)\n+\t\t\tpermalloc (sizeof (struct symref_hashent));\n+      p->symref = gen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t   obstack_copy0 (&permanent_obstack,\n+\t\t\t\t\t  name, strlen (name)));\n+      p->next = 0;\n+      resume_temporary_allocation ();\n+    }\n+\n+  return p->symref;\n+}\n+\f\n+/* Validate the precision of a floating-point operation.\n+\n+   We merge conversions from integers and between floating-point modes into\n+   the insn.  However, this must not effect the desired precision of the\n+   insn.  The RT floating-point system uses the widest of the operand modes.\n+   If this should be a double-precision insn, ensure that one operand\n+   passed to the floating-point processor has double mode.\n+\n+   Note that since we don't check anything if the mode is single precision,\n+   it, strictly speaking, isn't necessary to call this for those insns.\n+   However, we do so in case something else needs to be checked in the\n+   future.\n+\n+   This routine returns 1 if the operation is OK.  */\n+\n+int\n+check_precision (opmode, op1, op2)\n+     enum machine_mode opmode;\n+     rtx op1, op2;\n+{\n+  if (opmode == SFmode)\n+    return 1;\n+\n+  /* If operand is not a conversion from an integer mode or an extension from\n+     single-precision, it must be a double-precision value.  */\n+  if (GET_CODE (op1) != FLOAT && GET_CODE (op1) != FLOAT_EXTEND)\n+    return 1;\n+\n+  if (op2 && GET_CODE (op2) != FLOAT && GET_CODE (op2) != FLOAT_EXTEND)\n+    return 1;\n+\n+  return 0;\n+}\n+\f\n+/* Floating-point on the RT is done by creating an operation block in the data\n+   area that describes the operation.  If two floating-point operations are the\n+   same in a single function, they can use the same block.\n+\n+   These routines are responsible for managing these blocks.  */\n+\n+/* Structure to describe a floating-point operation.  */\n+\n+struct fp_op {\n+  struct fp_op *next_same_hash;\t\t/* Next op with same hash code. */\n+  struct fp_op *next_in_mem;\t\t/* Next op in memory. */\n+  int mem_offset;\t\t\t/* Offset from data area.  */\n+  short size;\t\t\t\t/* Size of block in bytes.  */\n+  short noperands;\t\t\t/* Number of operands in block.  */\n+  rtx ops[3];\t\t\t\t/* RTL for operands. */\n+  enum rtx_code opcode;\t\t\t/* Operation being performed.  */\n+};\n+\n+/* Size of hash table.  */\n+#define FP_HASH_SIZE 101\n+\n+/* Hash table of floating-point operation blocks.  */\n+static struct fp_op *fp_hash_table[FP_HASH_SIZE];\n+\n+/* First floating-point block in data area.  */\n+static struct fp_op *first_fpop;\n+\n+/* Last block in data area so far.  */\n+static struct fp_op *last_fpop_in_mem;\n+\n+/* Subroutine number in file, to get unique \"LF\" labels.  */\n+static int subr_number = 0;\n+\n+/* Current word offset in data area (includes header and any constant pool). */\n+int data_offset;\n+\n+/* Compute hash code for an RTX used in floating-point.  */\n+\n+static unsigned int\n+hash_rtx (x)\n+     register rtx x;\n+{\n+  register unsigned int hash = (((int) GET_CODE (x) << 10)\n+\t\t\t\t+ ((int) GET_MODE (x) << 20));\n+  register int i;\n+  register char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n+\n+  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n+    if (fmt[i] == 'e')\n+      hash += hash_rtx (XEXP (x, i));\n+    else if (fmt[i] == 'u')\n+      hash += (int) XEXP (x, i);\n+    else if (fmt[i] == 'i')\n+      hash += XINT (x, i);\n+    else if (fmt[i] == 's')\n+      hash += (int) XSTR (x, i);\n+\n+  return hash;\n+}\n+\f\n+/* Given an operation code and up to three operands, return a character string\n+   corresponding to the code to emit to branch to a floating-point operation\n+   block.  INSN is provided to see if the delay slot has been filled or not.\n+\n+   A new floating-point operation block is created if this operation has not\n+   been seen before.  */\n+\n+char *\n+output_fpop (code, op0, op1, op2, insn)\n+     enum rtx_code code;\n+     rtx op0, op1, op2;\n+     rtx insn;\n+{\n+  static char outbuf[40];\n+  unsigned int hash, hash0, hash1, hash2;\n+  int size, i;\n+  register struct fp_op *fpop, *last_fpop;\n+  int dyadic = (op2 != 0);\n+  enum machine_mode opmode;\n+  int noperands;\n+  rtx tem;\n+  unsigned int tem_hash;\n+  int fr0_avail = 0;\n+\n+  /* Compute hash code for each operand.  If the operation is commutative,\n+     put the one with the smaller hash code first.  This will make us see\n+     more operations as identical.  */\n+  hash0 = op0 ? hash_rtx (op0) : 0;\n+  hash1 = op1 ? hash_rtx (op1) : 0;\n+  hash2 = op2 ? hash_rtx (op2) : 0;\n+\n+  if (hash0 > hash1 && code == EQ)\n+    {\n+      tem = op0; op0 = op1; op1 = tem;\n+      tem_hash = hash0; hash0 = hash1; hash1 = tem_hash;\n+    }\n+  else if (hash1 > hash2 && (code == PLUS || code == MULT))\n+    {\n+      tem = op1; op1 = op2; op2 = tem;\n+      tem_hash = hash1; hash1 = hash2; hash2 = tem_hash;\n+    }\n+\n+  /* If operation is commutative and the first and third operands are equal,\n+     swap the second and third operands.  Note that we must consider two\n+     operands equal if they are the same register even if different modes.  */\n+  if (op2 && (code == PLUS || code == MULT)\n+      && (rtx_equal_p (op0, op2)\n+\t  || (GET_CODE (op0) == REG && GET_CODE (op2) == REG\n+\t      && REGNO (op0) == REGNO (op2))))\n+    {\n+      tem = op1; op1 = op2; op2 = tem;\n+      tem_hash = hash1; hash1 = hash2; hash2 = tem_hash;\n+    }\n+\n+  /* If the first and second operands are the same, merge them.  Don't do this\n+     for SFmode in general registers because this triggers a bug in the RT fp\n+     code.  */\n+  if (op1 && rtx_equal_p (op0, op1)\n+      && code != EQ && code != GE && code != SET\n+      && (GET_MODE (op1) != SFmode || GET_CODE (op0) != REG\n+\t  || FP_REGNO_P (REGNO (op0))))\n+    {\n+      op1 = op2;\n+      op2 = 0;\n+    }\n+\n+  noperands = 1 + (op1 != 0) + (op2 != 0);\n+\n+  /* Compute hash code for entire expression and see if operation block\n+     already exists.  */\n+  hash = ((int) code << 13) + (hash0 << 2) + (hash1 << 1) + hash2;\n+\n+  hash %= FP_HASH_SIZE;\n+  for (fpop = fp_hash_table[hash], last_fpop = 0;\n+       fpop;\n+       last_fpop = fpop, fpop = fpop->next_same_hash)\n+    if (fpop->opcode == code && noperands == fpop->noperands\n+\t&& (op0 == 0 || rtx_equal_p (op0, fpop->ops[0]))\n+\t&& (op1 == 0 || rtx_equal_p (op1, fpop->ops[1]))\n+\t&& (op2 == 0 || rtx_equal_p (op2, fpop->ops[2])))\n+      goto win;\n+\n+  /* We have never seen this operation before.  */\n+  fpop = (struct fp_op *) oballoc (sizeof (struct fp_op));\n+  fpop->mem_offset = data_offset;\n+  fpop->opcode = code;\n+  fpop->noperands = noperands;\n+  fpop->ops[0] = op0;\n+  fpop->ops[1] = op1;\n+  fpop->ops[2] = op2;\n+\n+  /* Compute the size using the rules in Appendix A of the RT Linkage\n+     Convention (4.3/RT-PSD:5) manual.  These rules are a bit ambiguous,\n+     but if we guess wrong, it will effect only efficiency, not correctness. */\n+\n+  /* Size = 24 + 32 for each non-fp (or fr7) */\n+  size = 24;\n+  if (op0 && (GET_CODE (op0) != REG\n+\t      || ! FP_REGNO_P (REGNO (op0)) || REGNO (op0) == 23))\n+    size += 32;\n+\n+  if (op1 && (GET_CODE (op1) != REG\n+\t      || ! FP_REGNO_P (REGNO (op1)) || REGNO (op1) == 23))\n+    size += 32;\n+\n+  if (op2 && (GET_CODE (op2) != REG\n+\t      || ! FP_REGNO_P (REGNO (op2)) || REGNO (op2) == 23))\n+    size += 32;\n+\n+  /* Size + 12 for each conversion.  First get operation mode.  */\n+  if ((op0 && GET_MODE (op0) == DFmode)\n+      || (op1 && GET_MODE (op1) == DFmode)\n+      || (op2 && GET_MODE (op2) == DFmode))\n+    opmode = DFmode;\n+  else\n+    opmode = SFmode;\n+\n+  if (op0 && GET_MODE (op0) != opmode)\n+    size += 12;\n+  if (op1 && GET_MODE (op1) != opmode)\n+    size += 12;\n+  if (op2 && GET_MODE (op2) != opmode)\n+    size += 12;\n+\n+  /* 12 more if first and third operand types not the same. */\n+  if (op2 && GET_MODE (op0) != GET_MODE (op2))\n+    size += 12;\n+\n+  /* CMP and CMPT need additional.  Also, compute size of save/restore here. */\n+  if (code == EQ)\n+    size += 32;\n+  else if (code == GE)\n+    size += 64;\n+  else if (code == USE || code == CLOBBER)\n+    {\n+      /* 34 + 24 for each additional register plus 8 if fr7 saved.  (We\n+         call it 36 because we need to keep the block length a multiple\n+\t of four.  */\n+      size = 36 - 24;\n+      for (i = 0; i <= 7; i++)\n+\tif (INTVAL (op0) & (1 << (7-i)))\n+\t  size += 24 + 8 * (i == 7);\n+    }\n+\n+  /* We provide no general-purpose scratch registers.  */\n+  size +=16;\n+\n+  /* No floating-point scratch registers are provided.  Compute extra\n+     length due to this.  This logic is that shown in the referenced\n+     appendix.  */\n+\n+  i = 0;\n+  if (op0 && GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0)))\n+    i++;\n+  if (op1 && GET_CODE (op1) == REG && FP_REGNO_P (REGNO (op1)))\n+    i++;\n+  if (op2 && GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n+    i++;\n+\n+  if ((op0 == 0 || GET_CODE (op0) != REG || REGNO(op0) != 17)\n+      && (op1 == 0 || GET_CODE (op1) != REG || REGNO(op1) != 17)\n+      && (op2 == 0 || GET_CODE (op2) != REG || REGNO(op2) != 17))\n+    fr0_avail = 1;\n+\n+  if (dyadic)\n+    {\n+      if (i == 0)\n+\tsize += fr0_avail ? 64 : 112;\n+      else if (fpop->noperands == 2 && i == 1)\n+\tsize += fr0_avail ? 0 : 64;\n+      else if (fpop->noperands == 3)\n+\t{\n+\t  if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0))\n+\t      && GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n+\t    {\n+\t      if (REGNO (op0) == REGNO (op2))\n+#if 1\n+\t\t/* This triggers a bug on the RT. */\n+\t\tabort ();\n+#else\n+\t\tsize += fr0_avail ? 0 : 64;\n+#endif\n+\t    }\n+\t  else\n+\t    {\n+\t      i = 0;\n+\t      if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0)))\n+\t\ti++;\n+\t      if (GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n+\t\ti++;\n+\t      if (i == 0)\n+\t\tsize += fr0_avail ? 64 : 112;\n+\t      else if (i == 1)\n+\t\tsize += fr0_avail ? 0 : 64;\n+\t    }\n+\t}\n+    }\n+  else if (code != USE && code != CLOBBER\n+\t   && (GET_CODE (op0) != REG || ! FP_REGNO_P (REGNO (op0))))\n+    size += 64;\n+    \n+  if (! TARGET_FULL_FP_BLOCKS)\n+    {\n+      /* If we are not to pad the blocks, just compute its actual length.  */\n+      size = 12;\t/* Header + opcode */\n+      if (code == USE || code == CLOBBER)\n+        size += 2;\n+      else\n+        {\n+\t  if (op0) size += 2;\n+\t  if (op1) size += 2;\n+\t  if (op2) size += 2;\n+\t}\n+\n+      /* If in the middle of a word, round.  */\n+      if (size % UNITS_PER_WORD)\n+\tsize += 2;\n+\t\n+      /* Handle any immediates.  */\n+      if (code != USE && code != CLOBBER && op0 && GET_CODE (op0) != REG)\n+        size += 4;\n+      if (op1 && GET_CODE (op1) != REG)\n+        size += 4;\n+      if (op2 && GET_CODE (op2) != REG)\n+        size += 4;\n+\n+      if (code != USE && code != CLOBBER && \n+\t  op0 && GET_CODE (op0) == CONST_DOUBLE && GET_MODE (op0) == DFmode)\n+        size += 4;\n+      if (op1 && GET_CODE (op1) == CONST_DOUBLE && GET_MODE (op1) == DFmode)\n+        size += 4;\n+      if (op2 && GET_CODE (op2) == CONST_DOUBLE && GET_MODE (op2) == DFmode)\n+        size += 4;\n+    }\n+\n+  /* Done with size computation!  Chain this in. */\n+  fpop->size = size;\n+  data_offset += size / UNITS_PER_WORD;\n+  fpop->next_in_mem = 0;\n+  fpop->next_same_hash = 0;\n+\n+  if (last_fpop_in_mem)\n+    last_fpop_in_mem->next_in_mem = fpop;\n+  else\n+    first_fpop = fpop;\n+  last_fpop_in_mem = fpop;\n+\n+  if (last_fpop)\n+    last_fpop->next_same_hash = fpop;\n+  else\n+    fp_hash_table[hash] = fpop;\n+\n+win:\n+  /* FPOP describes the operation to be performed.  Return a string to branch\n+     to it.  */\n+  if (fpop->mem_offset < 32768 / UNITS_PER_WORD)\n+    sprintf (outbuf, \"cal r15,%d(r14)\\n\\tbalr%s r15,r15\",\n+\t     fpop->mem_offset * UNITS_PER_WORD,\n+\t     dbr_sequence_length () ? \"x\" : \"\");\n+  else\n+    sprintf (outbuf, \"get r15,$L%dF%d\\n\\tbalr%s r15,r15\",\n+\t     subr_number, fpop->mem_offset * UNITS_PER_WORD,\n+\t     dbr_sequence_length () ? \"x\" : \"\");\n+  return outbuf;\n+}\n+\f\n+/* If necessary, output a floating-point operation to save or restore all\n+   floating-point registers.\n+\n+   file is the file to write the operation to, CODE is USE for save, CLOBBER\n+   for restore, and ADDR is the address of the same area, as RTL.  */\n+\n+static void\n+output_loadsave_fpregs (file, code, addr)\n+     FILE *file;\n+     enum rtx_code code;\n+     rtx addr;\n+{\n+  register int i;\n+  register int mask = 0;\n+\n+  for (i = 2 + (TARGET_FP_REGS != 0); i <= 7; i++)\n+    if (regs_ever_live[i + 17])\n+      mask |= 1 << (7 - i);\n+\n+  if (mask)\n+    fprintf (file, \"\\t%s\\n\",\n+\t     output_fpop (code, gen_rtx (CONST_INT, VOIDmode, mask),\n+\t\t\t\tgen_rtx (MEM, Pmode, addr),\n+\t\t\t\t0, const0_rtx));\n+\n+}\n+\f\n+/* Output any floating-point operations at the end of the routine.  */\n+\n+static void\n+output_fpops (file)\n+     FILE *file;\n+{\n+  register struct fp_op *fpop;\n+  register int size_so_far;\n+  register int i;\n+  rtx immed[3];\n+\n+  if (first_fpop == 0)\n+    return;\n+\n+  data_section ();\n+\n+  ASM_OUTPUT_ALIGN (file, 2);\n+\n+  for (fpop = first_fpop; fpop; fpop = fpop->next_in_mem)\n+    {\n+      if (fpop->mem_offset < 32768 / UNITS_PER_WORD)\n+\tfprintf (file, \"# data area offset = %d\\n\",\n+\t\t fpop->mem_offset * UNITS_PER_WORD);\n+      else\n+\tfprintf (file, \"L%dF%d:\\n\",\n+\t\t subr_number, fpop->mem_offset * UNITS_PER_WORD);\n+\n+      fprintf (file, \"\\tcas r0,r15,r0\\n\");\n+      fprintf (file, \"\\t.long FPGLUE\\n\");\n+      switch (fpop->opcode)\n+\t{\n+\tcase USE:\n+\t  fprintf (file, \"\\t.byte 0x1d\\t# STOREM\\n\");\n+\t  break;\n+\tcase CLOBBER:\n+\t  fprintf (file, \"\\t.byte 0x0f\\t# LOADM\\n\");\n+\t  break;\n+\tcase ABS:\n+\t  fprintf (file, \"\\t.byte 0x00\\t# ABS\\n\");\n+\t  break;\n+\tcase PLUS:\n+\t  fprintf (file, \"\\t.byte 0x02\\t# ADD\\n\");\n+\t  break;\n+\tcase EQ:\n+\t  fprintf (file, \"\\t.byte 0x07\\t# CMP\\n\");\n+\t  break;\n+\tcase GE:\n+\t  fprintf (file, \"\\t.byte 0x08\\t# CMPT\\n\");\n+\t  break;\n+\tcase DIV:\n+\t  fprintf (file, \"\\t.byte 0x0c\\t# DIV\\n\");\n+\t  break;\n+\tcase SET:\n+\t  fprintf (file, \"\\t.byte 0x14\\t# MOVE\\n\");\n+\t  break;\n+\tcase MULT:\n+\t  fprintf (file, \"\\t.byte 0x15\\t# MUL\\n\");\n+\t  break;\n+\tcase NEG:\n+\t  fprintf (file, \"\\t.byte 0x16\\t# NEG\\n\");\n+\t  break;\n+\tcase SQRT:\n+\t  fprintf (file, \"\\t.byte 0x1c\\t# SQRT\\n\");\n+\t  break;\n+\tcase MINUS:\n+\t  fprintf (file, \"\\t.byte 0x1e\\t# SUB\\n\");\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      fprintf (file, \"\\t.byte %d\\n\", fpop->noperands);\n+      fprintf (file, \"\\t.short 0x8001\\n\");\n+      \n+      if ((fpop->ops[0] == 0\n+\t   || GET_CODE (fpop->ops[0]) != REG || REGNO(fpop->ops[0]) != 17)\n+\t  && (fpop->ops[1] == 0 || GET_CODE (fpop->ops[1]) != REG\n+\t      || REGNO(fpop->ops[1]) != 17)\n+\t  && (fpop->ops[2] == 0 || GET_CODE (fpop->ops[2]) != REG\n+\t      || REGNO(fpop->ops[2]) != 17))\n+\tfprintf (file, \"\\t.byte %d, 0x80\\n\", fpop->size);\n+      else\n+\tfprintf (file, \"\\t.byte %d, 0\\n\", fpop->size);\n+      size_so_far = 12;\n+      for (i = 0; i < fpop->noperands; i++)\n+\t{\n+\t  register int type;\n+\t  register int opbyte;\n+\t  register char *desc0;\n+\t  char desc1[50];\n+\n+\t  immed[i] = 0;\n+\t  switch (GET_MODE (fpop->ops[i]))\n+\t    {\n+\t    case SImode:\n+\t    case VOIDmode:\n+\t      desc0 = \"int\";\n+\t      type = 0;\n+\t      break;\n+\t    case SFmode:\n+\t      desc0 = \"float\";\n+\t      type = 2;\n+\t      break;\n+\t    case DFmode:\n+\t      desc0 = \"double\";\n+\t      type = 3;\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  switch (GET_CODE (fpop->ops[i]))\n+\t    {\n+\t    case REG:\n+\t      strcpy(desc1, reg_names[REGNO (fpop->ops[i])]);\n+\t      if (FP_REGNO_P (REGNO (fpop->ops[i])))\n+\t\t{\n+\t\t  type += 0x10;\n+\t\t  opbyte = REGNO (fpop->ops[i]) - 17;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  type += 0x00;\n+\t\t  opbyte = REGNO (fpop->ops[i]);\n+\t\t  if (type == 3)\n+\t\t    opbyte = (opbyte << 4) + opbyte + 1;\n+\t\t}\n+\t      break;\n+\n+\t    case MEM:\n+\t      type += 0x30;\n+\t      if (GET_CODE (XEXP (fpop->ops[i], 0)) == PLUS)\n+\t\t{\n+\t\t  immed[i] = XEXP (XEXP (fpop->ops[i], 0), 1);\n+\t\t  opbyte = REGNO (XEXP (XEXP (fpop->ops[i], 0), 0));\n+\t\t  if (GET_CODE (immed[i]) == CONST_INT)\n+\t\t    sprintf (desc1, \"%d(%s)\", INTVAL (immed[i]),\n+\t\t\t     reg_names[opbyte]);\n+\t\t  else\n+\t\t    sprintf (desc1, \"<memory> (%s)\", reg_names[opbyte]);\n+\t\t}\n+\t      else if (GET_CODE (XEXP (fpop->ops[i], 0)) == REG)\n+\t\t{\n+\t\t  opbyte = REGNO (XEXP (fpop->ops[i], 0));\n+\t\t  immed[i] = const0_rtx;\n+ \t\t  sprintf (desc1, \"(%s)\", reg_names[opbyte]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  immed[i] = XEXP (fpop->ops[i], 0);\n+\t\t  opbyte = 0;\n+\t\t  sprintf(desc1, \"<memory>\");\n+\t\t}\n+\t      break;\n+\n+\t    case CONST_INT:\n+\t    case CONST_DOUBLE:\n+\t    case CONST:\n+\t      type += 0x20;\n+\t      opbyte = 0;\n+\t      immed[i] = fpop->ops[i];\n+\t      desc1[0] = '$';\n+\t      desc1[1] = '\\0';\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  /* Save/restore is special.  */\n+\t  if (i == 0 && (fpop->opcode == USE || fpop->opcode == CLOBBER))\n+\t    type = 0xff, opbyte = INTVAL (fpop->ops[0]), immed[i] = 0;\n+\n+\t  fprintf (file, \"\\t.byte 0x%x,0x%x # (%s) %s\\n\",\n+\t\t   type, opbyte, desc0, desc1);\n+\n+\t  size_so_far += 2;\n+\t}\n+\n+      /* If in the middle of a word, round.  */\n+      if (size_so_far % UNITS_PER_WORD)\n+\t{\n+\t  fprintf (file, \"\\t.space 2\\n\");\n+\t  size_so_far += 2;\n+\t}\n+\n+      for (i = 0; i < fpop->noperands; i++)\n+\tif (immed[i])\n+\t  switch (GET_MODE (immed[i]))\n+\t    {\n+\t    case SImode:\n+\t    case VOIDmode:\n+\t      size_so_far += 4;\n+\t      fprintf (file, \"\\t.long \");\n+\t      output_addr_const (file, immed[i]);\n+\t      fprintf (file, \"\\n\");\n+\t      break;\n+\n+\t    case DFmode:\n+\t      size_so_far += 4;\n+\t    case SFmode:\n+\t      size_so_far += 4;\n+\t      if (GET_CODE (immed[i]) == CONST_DOUBLE)\n+\t\t{\n+\t\t  union real_extract u;\n+\n+\t\t  bcopy (&CONST_DOUBLE_LOW (immed[i]), &u, sizeof u);\n+\t\t  if (GET_MODE (immed[i]) == DFmode)\n+\t\t    ASM_OUTPUT_DOUBLE (file, u.d);\n+\t\t  else\n+\t\t    ASM_OUTPUT_FLOAT (file, u.d);\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t\n+      if (size_so_far != fpop->size)\n+        {\n+          if (TARGET_FULL_FP_BLOCKS)\n+\t    fprintf (file, \"\\t.space %d\\n\", fpop->size - size_so_far);\n+\t  else\n+\t    abort ();\n+\t}\n+    }\n+\n+  /* Update for next subroutine.  */\n+  subr_number++;\n+  text_section ();\n+}\n+\n+ /* Initialize floating-point operation table.  */\n+\n+static void\n+init_fpops()\n+{\n+  register int i;\n+\n+  first_fpop = last_fpop_in_mem = 0;\n+  for (i = 0; i < FP_HASH_SIZE; i++)\n+    fp_hash_table[i] = 0;\n+}"}]}