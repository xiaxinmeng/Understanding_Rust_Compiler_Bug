{"sha": "f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiODZjMmQ4MDhkYWRiYjkxNDNhZGFjYzFiMGMxNjJkYmY1OGUxYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T08:49:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-20T08:49:02Z"}, "message": "[multiple changes]\n\n2009-04-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb (Add_Inlined_Subprogram): Do not place on the back-end\n\tlist a caller of an inlined subprogram, if the caller itself is not\n\tcalled.\n\n2009-04-20  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.c: Disable use of ACL on network drives.\n\n2009-04-20  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_ugn.texi: Add examples.\n\nFrom-SVN: r146374", "tree": {"sha": "dbcafab193762e8e73114d4041c4d06e4f2c1f96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbcafab193762e8e73114d4041c4d06e4f2c1f96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/comments", "author": null, "committer": null, "parents": [{"sha": "efec4f2a560b7b903f74ae8dbe98716f8e39587d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efec4f2a560b7b903f74ae8dbe98716f8e39587d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efec4f2a560b7b903f74ae8dbe98716f8e39587d"}], "stats": {"total": 227, "additions": 204, "deletions": 23}, "files": [{"sha": "44f54ee4d21902d44653e35fde8b2bebdba1553d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "patch": "@@ -1,3 +1,17 @@\n+2009-04-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.adb (Add_Inlined_Subprogram): Do not place on the back-end\n+\tlist a caller of an inlined subprogram, if the caller itself is not\n+\tcalled.\n+\n+2009-04-20  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c: Disable use of ACL on network drives.\n+\n+2009-04-20  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_ugn.texi: Add examples.\n+\n 2009-04-20  Thomas Quinot  <quinot@adacore.com>\n \n \t* g-socket.ads (Abort_Selector): Clarify documentation."}, {"sha": "e49e0f05cc443753398446fb7b971a0670e0123e", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 88, "deletions": 22, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "patch": "@@ -1746,6 +1746,65 @@ __gnat_is_directory (char *name)\n }\n \n #if defined (_WIN32) && !defined (RTX)\n+\n+/* Returns the same constant as GetDriveType but takes a pathname as\n+   argument. */\n+\n+static UINT\n+GetDriveTypeFromPath (TCHAR *wfullpath)\n+{\n+  TCHAR wdrv[MAX_PATH];\n+  TCHAR wpath[MAX_PATH];\n+  TCHAR wfilename[MAX_PATH];\n+  TCHAR wext[MAX_PATH];\n+\n+  _tsplitpath (wfullpath, wdrv, wpath, wfilename, wext);\n+\n+  if (_tcslen (wdrv) != 0)\n+    {\n+      /* we have a drive specified. */\n+      _tcscat (wdrv, _T(\"\\\\\"));\n+      return GetDriveType (wdrv);\n+    }\n+  else\n+    {\n+      /* No drive specified. */\n+\n+      /* Is this a relative path, if so get current drive type. */\n+      if (wpath[0] != _T('\\\\') ||\n+\t  (_tcslen (wpath) > 2 && wpath[0] == _T('\\\\') && wpath[1] != _T('\\\\')))\n+\treturn GetDriveType (NULL);\n+\n+      UINT result = GetDriveType (wpath);\n+\n+      /* Cannot guess the drive type, is this \\\\.\\ ? */\n+\n+      if (result == DRIVE_NO_ROOT_DIR &&\n+\t _tcslen (wpath) >= 4 && wpath[0] == _T('\\\\') && wpath[1] == _T('\\\\')\n+\t  && wpath[2] == _T('.') && wpath[3] == _T('\\\\'))\n+\t{\n+\t  if (_tcslen (wpath) == 4)\n+\t    _tcscat (wpath, wfilename);\n+\n+\t  LPTSTR p = &wpath[4];\n+\t  LPTSTR b = _tcschr (p, _T('\\\\'));\n+\n+\t  if (b != NULL)\n+\t    { /* logical drive \\\\.\\c\\dir\\file */\n+\t      *b++ = _T(':');\n+\t      *b++ = _T('\\\\');\n+\t      *b = _T('\\0');\n+\t    }\n+\t  else\n+\t    _tcscat (p, _T(\":\\\\\"));\n+\n+\t  return GetDriveType (p);\n+\t}\n+\n+      return result;\n+    }\n+}\n+\n /*  This MingW section contains code to work with ACL. */\n static int\n __gnat_check_OWNER_ACL\n@@ -1856,6 +1915,16 @@ __gnat_set_OWNER_ACL\n   LocalFree (pSD);\n   LocalFree (pNewDACL);\n }\n+\n+/* Check if it is possible to use ACL for wname, the file must not be on a\n+   network drive. */\n+\n+static int\n+__gnat_can_use_acl (TCHAR *wname)\n+{\n+  return __gnat_use_acl && GetDriveTypeFromPath (wname) != DRIVE_REMOTE;\n+}\n+\n #endif /* defined (_WIN32) && !defined (RTX) */\n \n int\n@@ -1865,10 +1934,10 @@ __gnat_is_readable_file (char *name)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n   GENERIC_MAPPING GenericMapping;\n \n-  if (__gnat_use_acl)\n-    {\n-      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n+  if (__gnat_can_use_acl (wname))\n+    {\n       ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n       GenericMapping.GenericRead = GENERIC_READ;\n \n@@ -1897,7 +1966,7 @@ __gnat_is_writable_file (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_use_acl)\n+  if (__gnat_can_use_acl (wname))\n     {\n       ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n       GenericMapping.GenericWrite = GENERIC_WRITE;\n@@ -1929,7 +1998,7 @@ __gnat_is_executable_file (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_use_acl)\n+  if (__gnat_can_use_acl (wname))\n     {\n       ZeroMemory (&GenericMapping, sizeof (GENERIC_MAPPING));\n       GenericMapping.GenericExecute = GENERIC_EXECUTE;\n@@ -1959,7 +2028,7 @@ __gnat_set_writable (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_use_acl)\n+  if (__gnat_can_use_acl (wname))\n     __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_WRITE);\n \n   SetFileAttributes\n@@ -1981,12 +2050,11 @@ __gnat_set_executable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  if (__gnat_use_acl)\n-    {\n-      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+\n+  if (__gnat_can_use_acl (wname))\n+    __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n \n-      __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_EXECUTE);\n-    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n@@ -2006,7 +2074,7 @@ __gnat_set_non_writable (char *name)\n \n   S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n \n-  if (__gnat_use_acl)\n+  if (__gnat_can_use_acl (wname))\n     __gnat_set_OWNER_ACL\n       (wname, DENY_ACCESS,\n        FILE_WRITE_DATA | FILE_APPEND_DATA |\n@@ -2031,12 +2099,11 @@ __gnat_set_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  if (__gnat_use_acl)\n-    {\n-      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+\n+  if (__gnat_can_use_acl (wname))\n+    __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n \n-      __gnat_set_OWNER_ACL (wname, GRANT_ACCESS, FILE_GENERIC_READ);\n-    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n \n@@ -2053,12 +2120,11 @@ __gnat_set_non_readable (char *name)\n #if defined (_WIN32) && !defined (RTX)\n   TCHAR wname [GNAT_MAX_PATH_LEN + 2];\n \n-  if (__gnat_use_acl)\n-    {\n-      S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+  S2WSC (wname, name, GNAT_MAX_PATH_LEN + 2);\n+\n+  if (__gnat_can_use_acl (wname))\n+    __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n \n-      __gnat_set_OWNER_ACL (wname, DENY_ACCESS, FILE_GENERIC_READ);\n-    }\n #elif ! defined (__vxworks) && ! defined(__nucleus__)\n   struct stat statbuf;\n "}, {"sha": "14ef44656289e837bcc1e570463223d8b9e1f34c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "patch": "@@ -22375,6 +22375,98 @@ multiple inheritance of abstract classes will be mapped to Ada interfaces\n (@xref{Interfacing to C++,,,gnat_rm, GNAT Reference Manual}, for additional\n information on interfacing to C++).\n \n+For example, given the following C++ header file:\n+\n+@smallexample\n+@group\n+@cartouche\n+class Carnivore @{\n+public:\n+   virtual int Number_Of_Teeth () = 0;\n+@};\n+\n+class Domestic @{\n+public:\n+   virtual void Set_Owner (char* Name) = 0;\n+@};\n+\n+class Animal @{\n+public:\n+  int Age_Count;\n+  virtual void Set_Age (int New_Age);\n+@};\n+\n+class Dog : Animal, Carnivore, Domestic @{\n+ public:\n+  int  Tooth_Count;\n+  char *Owner;\n+\n+  virtual int  Number_Of_Teeth ();\n+  virtual void Set_Owner (char* Name);\n+\n+  Dog();\n+@};\n+@end cartouche\n+@end group\n+@end smallexample\n+\n+The corresponding Ada code is generated:\n+\n+@smallexample @c ada\n+@group\n+@cartouche\n+  package Class_Carnivore is\n+    type Carnivore is limited interface;\n+    pragma Import (CPP, Carnivore);\n+\n+    function Number_Of_Teeth (this : access Carnivore) return int is abstract;\n+  end;\n+  use Class_Carnivore;\n+\n+  package Class_Domestic is\n+    type Domestic is limited interface;\n+    pragma Import (CPP, Domestic);\n+\n+    procedure Set_Owner\n+      (this : access Domestic;\n+       Name : Interfaces.C.Strings.chars_ptr) is abstract;\n+  end;\n+  use Class_Domestic;\n+\n+  package Class_Animal is\n+    type Animal is tagged limited record\n+      Age_Count : aliased int;\n+    end record;\n+    pragma Import (CPP, Animal);\n+\n+    procedure Set_Age (this : access Animal; New_Age : int);\n+    pragma Import (CPP, Set_Age, \"_ZN6Animal7Set_AgeEi\");\n+  end;\n+  use Class_Animal;\n+\n+  package Class_Dog is\n+    type Dog is new Animal and Carnivore and Domestic with record\n+      Tooth_Count : aliased int;\n+      Owner : Interfaces.C.Strings.chars_ptr;\n+    end record;\n+    pragma Import (CPP, Dog);\n+\n+    function Number_Of_Teeth (this : access Dog) return int;\n+    pragma Import (CPP, Number_Of_Teeth, \"_ZN3Dog15Number_Of_TeethEv\");\n+\n+    procedure Set_Owner\n+      (this : access Dog; Name : Interfaces.C.Strings.chars_ptr);\n+    pragma Import (CPP, Set_Owner, \"_ZN3Dog9Set_OwnerEPc\");\n+\n+    function New_Dog return Dog'Class;\n+    pragma CPP_Constructor (New_Dog);\n+    pragma Import (CPP, New_Dog, \"_ZN3DogC1Ev\");\n+  end;\n+  use Class_Dog;\n+@end cartouche\n+@end group\n+@end smallexample\n+\n @node Switches\n @section Switches\n "}, {"sha": "6fe50fd37d43f65924a7b13cfa4a7ea2233c8c21", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8b86c2d808dadbb9143adacc1b0c162dbf58e1a/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=f8b86c2d808dadbb9143adacc1b0c162dbf58e1a", "patch": "@@ -500,12 +500,21 @@ package body Inline is\n \n       Inlined.Table (Index).Listed := True;\n \n+      --  Now add to the list those callers of the current subprogram that\n+      --  are themselves called. They may appear on the graph as callers\n+      --  of the current one, even if they are themselves not called, and\n+      --  there is no point in including them in the list for the backend.\n+      --  Furthermore, they might not even be public, in which case the\n+      --  back-end cannot handle them at all.\n+\n       Succ := Inlined.Table (Index).First_Succ;\n       while Succ /= No_Succ loop\n          Subp := Successors.Table (Succ).Subp;\n          Inlined.Table (Subp).Count := Inlined.Table (Subp).Count - 1;\n \n-         if Inlined.Table (Subp).Count = 0 then\n+         if Inlined.Table (Subp).Count = 0\n+           and then Is_Called (Inlined.Table (Subp).Name)\n+         then\n             Add_Inlined_Subprogram (Subp);\n          end if;\n "}]}