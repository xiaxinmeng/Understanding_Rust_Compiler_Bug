{"sha": "538d56bb75ad00b1841398e10e6563035bfde442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM4ZDU2YmI3NWFkMDBiMTg0MTM5OGUxMGU2NTYzMDM1YmZkZTQ0Mg==", "commit": {"author": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-22T15:48:59Z"}, "committer": {"name": "Jan Brittenson", "email": "bson@gnu.org", "date": "1993-09-22T15:48:59Z"}, "message": "Initial revision\n\nFrom-SVN: r5389", "tree": {"sha": "19a5cbd87ccf3dada3dd12d0749afbc85674ab25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19a5cbd87ccf3dada3dd12d0749afbc85674ab25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/538d56bb75ad00b1841398e10e6563035bfde442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538d56bb75ad00b1841398e10e6563035bfde442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/538d56bb75ad00b1841398e10e6563035bfde442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538d56bb75ad00b1841398e10e6563035bfde442/comments", "author": null, "committer": null, "parents": [{"sha": "1b0211eb002d20c9f67fc1d74c8c84aba82c5959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b0211eb002d20c9f67fc1d74c8c84aba82c5959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b0211eb002d20c9f67fc1d74c8c84aba82c5959"}], "stats": {"total": 465, "additions": 465, "deletions": 0}, "files": [{"sha": "dbf32b8137f238c7de28be1e81378e8abc4f4f85", "filename": "gcc/bi-defs.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-defs.h?ref=538d56bb75ad00b1841398e10e6563035bfde442", "patch": "@@ -0,0 +1,47 @@\n+/* Definitions for Bytecode Interpreter.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+struct node\n+{\n+  char *text;\n+  struct node *next;\n+};\n+\n+struct variation\n+{\n+  char *name;\n+  int code;\n+  struct node *inputs;\n+  struct node *outputs;\n+  struct node *literals;\n+  struct variation *next;\n+};\n+\n+struct def\n+{\n+  char *basename;\n+  char *template;\n+  struct variation *variations;\n+  struct def *next;\n+};\n+\n+extern struct def *defs;\n+extern int ndefs;\n+extern void reverse();"}, {"sha": "ac2d84a52353b8eaee1526ecfbe9631e2a6f8819", "filename": "gcc/bi-opname.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-opname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-opname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-opname.c?ref=538d56bb75ad00b1841398e10e6563035bfde442", "patch": "@@ -0,0 +1,35 @@\n+/* Utility to generate opcode name list from bytecode definition file.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"bi-defs.h\"\n+\n+int\n+main()\n+{\n+  struct def *d;\n+  struct variation *v;\n+\n+  yyparse();\n+  reverse();\n+\n+  for (d = defs; d; d = d->next)\n+    for (v = d->variations; v; v = v->next)\n+      printf(\"\\\"%s%s\\\",\\n\", d->basename, v->name);\n+  return 0;\n+}"}, {"sha": "30eecba91b48f5b31abb002f9814ec8daa18dbd8", "filename": "gcc/bi-reverse.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-reverse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbi-reverse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-reverse.c?ref=538d56bb75ad00b1841398e10e6563035bfde442", "patch": "@@ -0,0 +1,61 @@\n+/* Reverse order of definitions obtained from bytecode definition file.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include \"bi-defs.h\"\n+\n+#define NULL 0\n+\n+void\n+reverse()\n+{\n+  struct def *dp, *d, *dn;\n+  struct variation *vp, *v, *vn;\n+\n+  dp = defs;\n+  if (dp)\n+    {\n+      vp = dp->variations;\n+      if (vp)\n+\t{\n+\t  for (v = vp->next, vp->next = NULL; v; vp = v, v = vn)\n+\t    {\n+\t      vn = v->next;\n+\t      v->next = vp;\n+\t    }\n+\t  dp->variations = vp;\n+\t}\n+      for (d = dp->next, dp->next = NULL; d; dp = d, d = dn)\n+\t{\n+\t  vp = d->variations;\n+\t  if (vp)\n+\t    {\n+\t      for (v = vp->next, vp->next = NULL; v; vp = v, v = vn)\n+\t\t{\n+\t\t  vn = v->next;\n+\t\t  v->next = vp;\n+\t\t}\n+\t      d->variations = vp;\n+\t    }\n+\t  dn = d->next;\n+\t  d->next = dp;\n+\t}\n+      defs = dp;\n+    }\n+}"}, {"sha": "5ac72842e3a342c8987479b0f29e84a03be86bef", "filename": "gcc/bytecode.def", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbytecode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/538d56bb75ad00b1841398e10e6563035bfde442/gcc%2Fbytecode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbytecode.def?ref=538d56bb75ad00b1841398e10e6563035bfde442", "patch": "@@ -0,0 +1,322 @@\n+# -*- C -*-\n+# bytecode.def - definitions of bytecodes for the stack machine.\n+\n+# The production of the bytecode interpreter and compiler is\n+# heavily automated by using this file creatively.\n+\n+# Various elementary data types are understood by the bytecode interpreter.\n+# Q[IU] - quarter word (byte) signed and unsigned integers (char).\n+# H[IU] - half word signed and unsigned integers (short int, maybe int).\n+# S[IU] - single word signed and unsigned integers (maybe int, long int).\n+# D[IU] - double word signed and unsigned integers (long long int).\n+# SF - single precision floating point (float).\n+# DF - double precision floating point (double).\n+# XF - extended precision floating point (long double).\n+# P - pointer type for address arithmetic and other purposes.\n+\n+# The bytecode specification consists of a series of define_operator\n+# forms, that are parsed by preprocessors to automatically build\n+# various switch statements.\n+#\tdefine_operator(name,\n+#\t\t\t<C prototype code for implementing the operator>,\n+#\t\t\t<list of variations>)\n+# The <C prototype> is self explanatory.\n+# The <list of variations> consists of a (parenthesized list) of\n+# variation items, each of which is in itself a list.  A variation\n+# item consists of a name suffix, the types of the input arguments\n+# expected on the stack (shallowest item first) and (optionally) the\n+# types of the output arguments (similarly ordered).  Finally, the\n+# types of the literal arguments (if any) may appear.\n+\n+# Substitution in the C prototype code is as follows:\n+# Substitution happens only after a dollar sign.  To get a literal\n+# dollar sign (why would you ever want one anyway?) use $$.\n+# $R1 means \"result 1\" $TR1 means \"type name of result one\"\n+# $S1 means \"source 1\" and similarly with $TS1.\n+# $L1 means \"literal (inline) argument 1\" and $TL1 means type thereof.\n+#\n+\n+# Notice that the number following $R doesn't affect the push order;\n+# it's used only for clarity and orthogonality, although it's checked\n+# to make sure it doesn't exceed the number of outputs. A $R reference\n+# results in a push, and represents the result lvalue. E.g.\n+\n+#\t$R1 = 2\\, $R2 = 17\n+# will expand to:\n+#\tINTERP_PUSH($TR1) = 2, INTERP_PUSH($TR2) = 17\n+#\n+\n+# Opcode 0 should never happen.\n+define_operator(neverneverland, abort\\(\\), (()))\n+\n+# Stack manipulations.\n+define_operator(drop, 0, ((, (SI))))\n+define_operator(dup, 0, ((, (SI), (SI, SI))))\n+define_operator(over, 0, ((, (SI), (SI, SI))))\n+\n+# Adjust stack pointer\n+\n+define_operator(setstack, 0, ((SI,,,(SI))))\n+define_operator(adjstack, 0, ((SI,,,(SI))))\n+\n+# Constants, loads, and stores.\n+define_operator(const,\n+\t\t$R1 = $L1,\n+\t\t((QI,, (QI), (QI)), (HI,, (HI), (HI)),\n+\t\t (SI,, (SI), (SI)), (DI,, (DI), (DI)),\n+\t\t (SF,, (SF), (SF)), (DF,, (DF), (DF)),\n+\t\t (XF,, (XF), (XF)), (P,, (P), (P))))\n+define_operator(load,\n+\t\t$R1 = *\\($TR1 *\\) $S1,\n+\t\t((QI, (P), (QI)), (HI, (P), (HI)),\n+\t\t (SI, (P), (SI)), (DI, (P), (DI)),\n+\t\t (SF, (P), (SF)), (DF, (P), (DF)),\n+\t\t (XF, (P), (XF)), (P, (P), (P))))\n+define_operator(store,\n+\t\t*\\($TS2 *\\) $S1 = $S2,\n+\t\t((QI, (P, QI)), (HI, (P, HI)),\n+\t\t (SI, (P, SI)), (DI, (P, DI)),\n+\t\t (SF, (P, SF)), (DF, (P, DF)),\n+\t\t (XF, (P, XF)), (P, (P, P)),\n+\t\t (BLK, (SI, BLK, BLK))))\n+\n+# Clear memory block\n+\n+define_operator(clear, $S1 + $S2, ((BLK, (SI, BLK))))\n+\n+\n+# Advance pointer by SI constant\n+\n+define_operator(addconst, $R1 = $S1, ((PSI, (P), (P), (SI))))\n+\n+\n+# newlocalSI is used for creating variable-sized storage during function\n+# initialization.\n+\n+# Create local space, return pointer to block\n+\n+define_operator(newlocal, $R1 = $S1, ((SI, (SI), (P))))\n+\n+\n+# Push the address of a local variable.\n+define_operator(local, $R1 = locals + $L1, ((P,, (P), (SI))))\n+\n+# Push the address of an argument variable.\n+define_operator(arg, $R1 = args + $L1, ((P,, (P), (SI))))\n+\n+# Arithmetic conversions.\n+define_operator(convert,\n+\t\t$R1 = \\($TR1\\) $S1,\n+\t\t(# Signed integral promotions (sign extensions).\n+\t\t (QIHI, (QI), (HI)), (HISI, (HI), (SI)), (SIDI, (SI), (DI)),\n+\t\t (QISI, (QI), (SI)),\n+\t\t # Unsigned integral promotions (zero extensions).\n+\t\t (QUHU, (QU), (HU)), (HUSU, (HU), (SU)), (SUDU, (SU), (DU)),\n+\t\t (QUSU, (QU), (SU)),\n+\t\t # Floating promotions.\n+\t\t (SFDF, (SF), (DF)), (DFXF, (DF), (XF)),\n+\t\t # Integral truncation.\n+\t\t (HIQI, (HI), (QI)), (SIHI, (SI), (HI)), (DISI, (DI), (SI)),\n+\t\t (SIQI, (SI), (QI)),\n+                 # Unsigned truncation.\n+\t\t (SUQU, (SU), (QU)),\n+\t\t # Floating truncation.\n+\t\t (DFSF, (DF), (SF)), (XFDF, (XF), (DF)),\n+\t\t # Integral conversions to floating types.\n+\t\t (SISF, (SI), (SF)), (SIDF, (SI), (DF)), (SIXF, (SI), (XF)),\n+\t\t (SUSF, (SU), (SF)), (SUDF, (SU), (DF)), (SUXF, (SU), (XF)),\n+\t\t (DISF, (DI), (SF)), (DIDF, (DI), (DF)), (DIXF, (DI), (XF)),\n+\t\t (DUSF, (DU), (SF)), (DUDF, (DU), (DF)), (DUXF, (DU), (XF)),\n+\t\t # Floating conversions to integral types.\n+\t\t (SFSI, (SF), (SI)), (DFSI, (DF), (SI)), (XFSI, (XF), (SI)),\n+\t\t (SFSU, (SF), (SU)), (DFSU, (DF), (SU)), (XFSU, (XF), (SU)),\n+\t\t (SFDI, (SF), (DI)), (DFDI, (DF), (DI)), (XFDI, (XF), (DI)),\n+\t\t (SFDU, (SF), (DU)), (DFDU, (DF), (DU)), (XFDU, (XF), (DU)),\n+\t\t # Pointer/integer conversions.\n+\t\t (PSI, (P), (SI)), (SIP, (SI), (P))))\n+\n+# Truth value conversion.  These are necessary because conversions of, e.g.,\n+# floating types to integers may not function correctly for large values.\n+define_operator(convert,\n+\t\t$R1 = !!$S1,\n+\t\t((SIT, (SI), (T)), (DIT, (DI), (T)),\n+\t\t (SFT, (SF), (T)), (DFT, (DF), (T)),\n+\t\t (XFT, (XF), (T)), (PT, (P), (T))))\n+\n+# Bit field load/store.\n+\n+# Load and zero-extend bitfield\n+\n+define_operator(zxload, $R1 = $S1, ((BI, (SU, SU, P), (SU))))\n+\n+# Load and sign-extend bitfield\n+\n+define_operator(sxload, $R1 = $S1, ((BI, (SU, SU, P), (SI))))\n+\n+# Store integer in bitfield\n+\n+define_operator(sstore, $R1 = $S1, ((BI, (SU, SU, P, SI))))\n+\n+\n+# Binary operations.\n+define_operator(add,\n+\t\t$R1 = $S1 + $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n+\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n+\t\t (XF, (XF, XF), (XF)),\n+\t\t (PSI, (P, SI), (P))))\n+define_operator(sub,\n+\t\t$R1 = $S1 - $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n+\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n+\t\t (XF, (XF, XF), (XF)),\n+\t\t (PP, (P, P), (SI))))\n+define_operator(mul,\n+\t\t$R1 = $S1 * $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n+\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU)),\n+\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n+\t\t (XF, (XF, XF), (XF))))\n+define_operator(div,\n+\t\t$R1 = $S1 / $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n+\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU)),\n+\t\t (SF, (SF, SF), (SF)), (DF, (DF, DF), (DF)),\n+\t\t (XF, (XF, XF), (XF))))\n+define_operator(mod,\n+\t\t$R1 = $S1 % $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI)),\n+\t\t (SU, (SU, SU), (SU)), (DU, (DU, DU), (DU))))\n+define_operator(and,\n+\t\t$R1 = $S1 & $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n+define_operator(ior,\n+\t\t$R1 = $S1 | $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n+define_operator(xor,\n+\t\t$R1 = $S1 ^ $S2,\n+\t\t((SI, (SI, SI), (SI)), (DI, (DI, DI), (DI))))\n+define_operator(lshift,\n+\t\t$R1 = $S1 << $S2,\n+\t\t((SI, (SI, SI), (SI)), (SU, (SU, SI), (SU)),\n+\t\t (DI, (DI, SI), (DI)), (DU, (DU, SI), (DU))))\n+define_operator(rshift,\n+\t\t$R1 = $S1 >> $S2,\n+\t\t((SI, (SI, SI), (SI)), (SU, (SU, SI), (SU)),\n+\t\t (DI, (DI, SI), (DI)), (DU, (DU, SI), (DU))))\n+define_operator(lt,\n+\t\t$R1 = $S1 < $S2,\n+\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n+\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+define_operator(le,\n+\t\t$R1 = $S1 <= $S2,\n+\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n+\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+define_operator(ge,\n+\t\t$R1 = $S1 >= $S2,\n+\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n+\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+define_operator(gt,\n+\t\t$R1 = $S1 > $S2,\n+\t\t((SI, (SI, SI), (T)), (SU, (SU, SU), (T)),\n+\t\t (DI, (DI, DI), (T)), (DU, (DU, DU), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+define_operator(eq,\n+\t\t$R1 = $S1 == $S2,\n+\t\t((SI, (SI, SI), (T)), (DI, (DI, DI), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+define_operator(ne,\n+\t\t$R1 = $S1 != $S2,\n+\t\t((SI, (SI, SI), (T)), (DI, (DI, DI), (T)),\n+\t\t (SF, (SF, SF), (T)), (DF, (DF, DF), (T)),\n+\t\t (XF, (XF, XF), (T)), (P, (P, P), (T))))\n+\n+# Unary operations.\n+define_operator(neg,\n+\t\t$R1 = -$S1,\n+\t\t((SI, (SI), (SI)), (DI, (DI), (DI)),\n+\t\t (SF, (SF), (SF)), (DF, (DF), (DF)),\n+\t\t (XF, (XF), (XF))))\n+define_operator(not,\n+\t\t$R1 = ~$S1,\n+\t\t((SI, (SI), (SI)), (DI, (DI), (DI))))\n+define_operator(not,\n+\t\t$R1 = !$S1,\n+\t\t((T, (SI), (SI))))\n+\n+# Increment operations.\n+define_operator(predec,\n+\t\t$R1 = *\\($TR1 *\\) $S1 -= $S2,\n+\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n+\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n+\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n+\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n+\t\t (BI, (SU, SU, P, SI), (SI))))\n+\n+define_operator(preinc,\n+\t\t$R1 = *\\($TR1 *\\) $S1 += $S2,\n+\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n+\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n+\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n+\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n+\t\t (BI, (SU, SU, P, SI), (SI))))\n+\n+define_operator(postdec,\n+\t\t$R1 = *\\($TR1 *\\) $S1\\, *\\($TR1 *\\) $S1 -= $S2,\n+\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n+\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n+\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n+\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n+\t\t (BI, (SU, SU, P, SI), (SI))))\n+\n+define_operator(postinc,\n+\t\t$R1 = *\\($TR1 *\\) $S1\\, *\\($TR1 *\\) $S1 += $S2,\n+\t\t((QI, (P, QI), (QI)), (HI, (P, HI), (HI)),\n+\t\t (SI, (P, SI), (SI)), (DI, (P, DI), (DI)),\n+\t\t (P, (P, SI), (P)), (SF, (P, SF), (SF)),\n+\t\t (DF, (P, DF), (DF)), (XF, (P, XF), (XF)),\n+\t\t (BI, (SU, SU, P, SI), (SI))))\n+\n+# Jumps.\n+define_operator(jumpif, if \\($S1\\) pc = code->pc0 + $L1, ((, (T),, (SI))))\n+define_operator(jumpifnot, if \\(! $S1\\) pc = code->pc0 + $L1, ((, (T),, (SI))))\n+define_operator(jump, pc = code->pc0 + $L1, ((,,,(SI))))\n+\n+# This is for GCC2. It jumps to the address on the stack.\n+define_operator(jump, pc = \\(void *\\) $S1, ((P,,)))\n+\n+# Switches.  In order to (eventually) support ranges we provide four different\n+# varieties of switches.  Arguments are the switch index from the stack, the\n+# bytecode offset of the switch table, the size of the switch table, and \n+# the default label.\n+define_operator(caseSI, CASESI\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (SI),, (SI, SI, SI))))\n+define_operator(caseSU, CASESU\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (SU),, (SI, SI, SI))))\n+define_operator(caseDI, CASEDI\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (DI),, (SI, SI, SI))))\n+define_operator(caseDU, CASEDU\\($S1\\, $L1\\, $L2\\, $L3\\), ((, (DU),, (SI, SI, SI))))\n+\n+# Procedure call.\n+# Stack arguments are (deepest first):\n+#\tprocedure arguments in reverse order.\n+#\tpointer to the place to hold the return value.\n+#\taddress of the call description vector.\n+#\tpointer to the procedure to be called.\n+define_operator(call, CALL\\($S1\\, $S2\\, $S3\\, sp\\), ((, (P, P, P))))\n+\n+# Procedure return.\n+# Pushes on interpreter stack:\n+#       value of retptr (pointer to return value storage slot)\n+define_operator(return, $R1 = retptr, ((P,,(P))))\n+\n+# Really return.\n+define_operator(ret, return, (()))\n+\n+# Print an obnoxious line number.\n+define_operator(linenote, fprintf\\(stderr\\, \"%d\\\\n\"\\, $L1\\), ((,,,(SI))))"}]}