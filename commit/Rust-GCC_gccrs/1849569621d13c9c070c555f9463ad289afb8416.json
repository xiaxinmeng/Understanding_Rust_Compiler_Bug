{"sha": "1849569621d13c9c070c555f9463ad289afb8416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg0OTU2OTYyMWQxM2M5YzA3MGM1NTVmOTQ2M2FkMjg5YWZiODQxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:20:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:20:37Z"}, "message": "Remove global call sets: early-remat.c\n\nThis pass previously excluded rematerialisation candidates if they\nclobbered a call-preserved register, on the basis that it then\nwouldn't be safe to add new instances of the candidate instruction\nafter a call.  This patch instead makes the decision on a call-by-call\nbasis.\n\nThe second emit_remat_insns_for_block hunk probably isn't needed,\nbut it seems safer and more consistent to have it, so that every call\nto emit_remat_insns is preceded by a check for invalid clobbers.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* early-remat.c: Include regs.h and function-abi.h.\n\t(early_remat::maybe_add_candidate): Don't check for call-clobbered\n\tregisters here.\n\t(early_remat::restrict_remat_for_unavail_regs): New function.\n\t(early_remat::restrict_remat_for_call): Likewise.\n\t(early_remat::process_block): Before calling emit_remat_insns\n\tfor a previous call in the block, invalidate any candidates\n\tthat would clobber call-preserved registers.\n\t(early_remat::emit_remat_insns_for_block): Likewise for the\n\tfinal call in a block.  Do the same thing for live-in registers\n\twhen calling emit_remat_insns at the head of a block.\n\nFrom-SVN: r276321", "tree": {"sha": "5d1f7bacf357435319a43803e2c16d274ce6ac77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d1f7bacf357435319a43803e2c16d274ce6ac77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1849569621d13c9c070c555f9463ad289afb8416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1849569621d13c9c070c555f9463ad289afb8416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1849569621d13c9c070c555f9463ad289afb8416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1849569621d13c9c070c555f9463ad289afb8416/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "559c1ae100489da76a0283750361ace146fdeb77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/559c1ae100489da76a0283750361ace146fdeb77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/559c1ae100489da76a0283750361ace146fdeb77"}], "stats": {"total": 88, "additions": 66, "deletions": 22}, "files": [{"sha": "138f3f0c0bc9684c440c6f957cf36fe505cb0f05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1849569621d13c9c070c555f9463ad289afb8416/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1849569621d13c9c070c555f9463ad289afb8416/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1849569621d13c9c070c555f9463ad289afb8416", "patch": "@@ -1,3 +1,17 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* early-remat.c: Include regs.h and function-abi.h.\n+\t(early_remat::maybe_add_candidate): Don't check for call-clobbered\n+\tregisters here.\n+\t(early_remat::restrict_remat_for_unavail_regs): New function.\n+\t(early_remat::restrict_remat_for_call): Likewise.\n+\t(early_remat::process_block): Before calling emit_remat_insns\n+\tfor a previous call in the block, invalidate any candidates\n+\tthat would clobber call-preserved registers.\n+\t(early_remat::emit_remat_insns_for_block): Likewise for the\n+\tfinal call in a block.  Do the same thing for live-in registers\n+\twhen calling emit_remat_insns at the head of a block.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* df-scan.c (df_get_entry_block_def_set): Use crtl->abi to test"}, {"sha": "bb2d433373b9bb65ca82f04757e7f702b2f5cf7d", "filename": "gcc/early-remat.c", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1849569621d13c9c070c555f9463ad289afb8416/gcc%2Fearly-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1849569621d13c9c070c555f9463ad289afb8416/gcc%2Fearly-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fearly-remat.c?ref=1849569621d13c9c070c555f9463ad289afb8416", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtlhash.h\"\n #include \"print-rtl.h\"\n #include \"rtl-iter.h\"\n+#include \"regs.h\"\n+#include \"function-abi.h\"\n \n /* This pass runs before register allocation and implements an aggressive\n    form of rematerialization.  It looks for pseudo registers R of mode M\n@@ -435,6 +437,8 @@ class early_remat {\n   void compute_clobbers (unsigned int);\n   void assign_value_number (unsigned int);\n   void decide_candidate_validity (void);\n+  void restrict_remat_for_unavail_regs (bitmap, const_bitmap);\n+  void restrict_remat_for_call (bitmap, rtx_insn *);\n   bool stable_use_p (unsigned int);\n   void emit_copy_before (unsigned int, rtx, rtx);\n   void stabilize_pattern (unsigned int);\n@@ -889,29 +893,15 @@ early_remat::maybe_add_candidate (rtx_insn *insn, unsigned int regno)\n       else\n \t{\n \t  /* The instruction can set additional registers, provided that\n-\t     they're call-clobbered hard registers.  This is useful for\n-\t     instructions that alter the condition codes.  */\n+\t     they're hard registers.  This is useful for instructions\n+\t     that alter the condition codes.  */\n \t  if (!HARD_REGISTER_NUM_P (def_regno))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n \t\t\t \" pseudo reg %d\\n\", FAILURE_ARGS, def_regno);\n \t      return false;\n \t    }\n-\t  if (global_regs[def_regno])\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n-\t\t\t \" global reg %d\\n\", FAILURE_ARGS, def_regno);\n-\t      return false;\n-\t    }\n-\t  if (!TEST_HARD_REG_BIT (regs_invalidated_by_call, def_regno))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n-\t\t\t \" call-preserved reg %d\\n\", FAILURE_ARGS, def_regno);\n-\t      return false;\n-\t    }\n \t}\n     }\n \n@@ -1532,6 +1522,39 @@ early_remat::decide_candidate_validity (void)\n       }\n }\n \n+/* Remove any candidates in CANDIDATES that would clobber a register in\n+   UNAVAIL_REGS.  */\n+\n+void\n+early_remat::restrict_remat_for_unavail_regs (bitmap candidates,\n+\t\t\t\t\t      const_bitmap unavail_regs)\n+{\n+  bitmap_clear (&m_tmp_bitmap);\n+  unsigned int cand_index;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (candidates, 0, cand_index, bi)\n+    {\n+      remat_candidate *cand = &m_candidates[cand_index];\n+      if (cand->clobbers\n+\t  && bitmap_intersect_p (cand->clobbers, unavail_regs))\n+\tbitmap_set_bit (&m_tmp_bitmap, cand_index);\n+    }\n+  bitmap_and_compl_into (candidates, &m_tmp_bitmap);\n+}\n+\n+/* Remove any candidates in CANDIDATES that would clobber a register\n+   that is potentially live across CALL.  */\n+\n+void\n+early_remat::restrict_remat_for_call (bitmap candidates, rtx_insn *call)\n+{\n+  /* We don't know whether partially-clobbered registers are live\n+     across the call or not, so assume that they are.  */\n+  bitmap_view<HARD_REG_SET> call_preserved_regs\n+    (~insn_callee_abi (call).full_reg_clobbers ());\n+  restrict_remat_for_unavail_regs (candidates, call_preserved_regs);\n+}\n+\n /* Assuming that every path reaching a point P contains a copy of a\n    use U of REGNO, return true if another copy of U at P would have\n    access to the same value of REGNO.  */\n@@ -1984,10 +2007,13 @@ early_remat::process_block (basic_block bb)\n \t      init_temp_bitmap (&m_required);\n \t    }\n \t  else\n-\t    /* The fully-local case: candidates that need to be\n-\t       rematerialized after a previous call in the block.  */\n-\t    emit_remat_insns (m_required, NULL, info->rd_after_call,\n-\t\t\t      last_call);\n+\t    {\n+\t      /* The fully-local case: candidates that need to be\n+\t\t rematerialized after a previous call in the block.  */\n+\t      restrict_remat_for_call (m_required, last_call);\n+\t      emit_remat_insns (m_required, NULL, info->rd_after_call,\n+\t\t\t\tlast_call);\n+\t    }\n \t  last_call = insn;\n \t  bitmap_clear (m_available);\n \t  gcc_checking_assert (empty_p (m_required));\n@@ -2480,15 +2506,19 @@ early_remat::emit_remat_insns_for_block (basic_block bb)\n   remat_block_info *info = &m_block_info[bb->index];\n \n   if (info->last_call && !empty_p (info->required_after_call))\n-    emit_remat_insns (info->required_after_call, NULL,\n-\t\t      info->rd_after_call, info->last_call);\n+    {\n+      restrict_remat_for_call (info->required_after_call, info->last_call);\n+      emit_remat_insns (info->required_after_call, NULL,\n+\t\t\tinfo->rd_after_call, info->last_call);\n+    }\n \n   if (!empty_p (info->required_in))\n     {\n       rtx_insn *insn = BB_HEAD (bb);\n       while (insn != BB_END (bb)\n \t     && !INSN_P (NEXT_INSN (insn)))\n \tinsn = NEXT_INSN (insn);\n+      restrict_remat_for_unavail_regs (info->required_in, DF_LR_IN (bb));\n       emit_remat_insns (info->required_in, info->available_in,\n \t\t\tinfo->rd_in, insn);\n     }"}]}