{"sha": "9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "node_id": "C_kwDOANBUbNoAKDlmMzUzYjBjMWRjOTM4NWJhOGI4YTY0YjY1ZDY2ZDU0NTIzODNjMTE", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-11-11T22:59:30Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2023-01-26T15:06:20Z"}, "message": "c++: Reject UDLs in certain contexts [PR105300]\n\nIn this PR, we are crashing because we've encountered a UDL where a\nstring-literal is expected.  This patch makes the parser reject string\nand character UDLs in all places where the grammar requires a\nstring-literal and not a user-defined-string-literal.\n\nI've introduced two new wrappers; the existing cp_parser_string_literal\nwas renamed to cp_parser_string_literal_common and should not be called\ndirectly.  finish_userdef_string_literal is renamed from\ncp_parser_userdef_string_literal.\n\n\tPR c++/105300\n\ngcc/c-family/ChangeLog:\n\n\t* c-pragma.cc (handle_pragma_message): Warn for CPP_STRING_USERDEF.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc: Remove unnecessary forward declarations.\n\t(cp_parser_string_literal): New wrapper.\n\t(cp_parser_string_literal_common): Renamed from\n\tcp_parser_string_literal.  Add a bool parameter.  Give an error when\n\tUDLs are not permitted.\n\t(cp_parser_userdef_string_literal): New wrapper.\n\t(finish_userdef_string_literal): Renamed from\n\tcp_parser_userdef_string_literal.\n\t(cp_parser_primary_expression): Call cp_parser_userdef_string_literal\n\tinstead of cp_parser_string_literal.\n\t(cp_parser_linkage_specification): Move a variable declaration closer\n\tto its first use.\n\t(cp_parser_static_assert): Likewise.\n\t(cp_parser_operator): Call cp_parser_userdef_string_literal instead of\n\tcp_parser_string_literal.\n\t(cp_parser_asm_definition): Move a variable declaration closer to its\n\tfirst use.\n\t(cp_parser_asm_specification_opt): Move variable declarations closer to\n\ttheir first use.\n\t(cp_parser_asm_operand_list): Likewise.\n\t(cp_parser_asm_clobber_list): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/udlit-error1.C: New test.", "tree": {"sha": "46eb0c0e167e6da608f961bd74cf4212d62f112f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46eb0c0e167e6da608f961bd74cf4212d62f112f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1eab269288ffa80ba924ddb4c4b36f8f781d613", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eab269288ffa80ba924ddb4c4b36f8f781d613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1eab269288ffa80ba924ddb4c4b36f8f781d613"}], "stats": {"total": 157, "additions": 113, "deletions": 44}, "files": [{"sha": "0d2b333cebbed32423d5dc6fd2a3ac0ce0bf8b94", "filename": "gcc/c-family/c-pragma.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Fc-family%2Fc-pragma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Fc-family%2Fc-pragma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.cc?ref=9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "patch": "@@ -1390,6 +1390,9 @@ handle_pragma_message (cpp_reader *)\n     }\n   else if (token == CPP_STRING)\n     message = x;\n+  else if (token == CPP_STRING_USERDEF)\n+    GCC_BAD (\"string literal with user-defined suffix is invalid in this \"\n+\t     \"context\");\n   else\n     GCC_BAD (\"expected a string after %<#pragma message%>\");\n "}, {"sha": "4cdc1cd472f33689aea93d0b3e58f8763e334542", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 89, "deletions": 44, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "patch": "@@ -2227,16 +2227,8 @@ pop_unparsed_function_queues (cp_parser *parser)\n \n /* Lexical conventions [gram.lex]  */\n \n-static cp_expr cp_parser_identifier\n-  (cp_parser *);\n-static cp_expr cp_parser_string_literal\n-  (cp_parser *, bool, bool, bool);\n-static cp_expr cp_parser_userdef_char_literal\n-  (cp_parser *);\n-static tree cp_parser_userdef_string_literal\n+static tree finish_userdef_string_literal\n   (tree);\n-static cp_expr cp_parser_userdef_numeric_literal\n-  (cp_parser *);\n \n /* Basic concepts [gram.basic]  */\n \n@@ -4408,11 +4400,15 @@ cp_parser_identifier (cp_parser* parser)\n     return error_mark_node;\n }\n \n-/* Parse a sequence of adjacent string constants.  Returns a\n+/* Worker for cp_parser_string_literal and cp_parser_userdef_string_literal.\n+   Do not call this directly; use either of the above.\n+\n+   Parse a sequence of adjacent string constants.  Return a\n    TREE_STRING representing the combined, nul-terminated string\n    constant.  If TRANSLATE is true, translate the string to the\n    execution character set.  If WIDE_OK is true, a wide string is\n-   invalid here.\n+   valid here.  If UDL_OK is true, a string literal with user-defined\n+   suffix can be used in this context.\n \n    C++98 [lex.string] says that if a narrow string literal token is\n    adjacent to a wide string literal token, the behavior is undefined.\n@@ -4422,9 +4418,11 @@ cp_parser_identifier (cp_parser* parser)\n    This code is largely lifted from lex_string() in c-lex.cc.\n \n    FUTURE: ObjC++ will need to handle @-strings here.  */\n+\n static cp_expr\n-cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n-\t\t\t  bool lookup_udlit = true)\n+cp_parser_string_literal_common (cp_parser *parser, bool translate,\n+\t\t\t\t bool wide_ok, bool udl_ok,\n+\t\t\t\t bool lookup_udlit)\n {\n   tree value;\n   size_t count;\n@@ -4449,6 +4447,12 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \n   if (cpp_userdef_string_p (tok->type))\n     {\n+      if (!udl_ok)\n+\t{\n+\t  error_at (loc, \"string literal with user-defined suffix \"\n+\t\t    \"is invalid in this context\");\n+\t  return error_mark_node;\n+\t}\n       string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n       curr_type = cpp_userdef_string_remove_type (tok->type);\n       curr_tok_is_userdef_p = true;\n@@ -4539,6 +4543,12 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t  tok = cp_lexer_peek_token (parser->lexer);\n \t  if (cpp_userdef_string_p (tok->type))\n \t    {\n+\t      if (!udl_ok)\n+\t\t{\n+\t\t  error_at (loc, \"string literal with user-defined suffix \"\n+\t\t\t    \"is invalid in this context\");\n+\t\t  return error_mark_node;\n+\t\t}\n \t      string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n \t      curr_type = cpp_userdef_string_remove_type (tok->type);\n \t      curr_tok_is_userdef_p = true;\n@@ -4608,7 +4618,7 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t  tree literal = build_userdef_literal (suffix_id, value,\n \t\t\t\t\t\tOT_NONE, NULL_TREE);\n \t  if (lookup_udlit)\n-\t    value = cp_parser_userdef_string_literal (literal);\n+\t    value = finish_userdef_string_literal (literal);\n \t  else\n \t    value = literal;\n \t}\n@@ -4626,6 +4636,37 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n   return cp_expr (value, loc);\n }\n \n+/* Parse a sequence of adjacent string constants.  Return a TREE_STRING\n+   representing the combined, nul-terminated string constant.  If\n+   TRANSLATE is true, translate the string to the execution character set.\n+   If WIDE_OK is true, a wide string is valid here.\n+\n+   This function issues an error if a user defined string literal is\n+   encountered; use cp_parser_userdef_string_literal if UDLs are allowed.  */\n+\n+static inline cp_expr\n+cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n+{\n+  return cp_parser_string_literal_common (parser, translate, wide_ok,\n+\t\t\t\t\t  /*udl_ok=*/false,\n+\t\t\t\t\t  /*lookup_udlit=*/false);\n+}\n+\n+/* Parse a string literal or user defined string literal.\n+\n+   user-defined-string-literal :\n+     string-literal ud-suffix\n+\n+   If LOOKUP_UDLIT, perform a lookup for a suitable template function.  */\n+\n+static inline cp_expr\n+cp_parser_userdef_string_literal (cp_parser *parser, bool lookup_udlit)\n+{\n+  return cp_parser_string_literal_common (parser, /*translate=*/true,\n+\t\t\t\t\t  /*wide_ok=*/true, /*udl_ok=*/true,\n+\t\t\t\t\t  lookup_udlit);\n+}\n+\n /* Look up a literal operator with the name and the exact arguments.  */\n \n static tree\n@@ -4923,7 +4964,7 @@ cp_parser_userdef_numeric_literal (cp_parser *parser)\n    as arguments.  */\n \n static tree\n-cp_parser_userdef_string_literal (tree literal)\n+finish_userdef_string_literal (tree literal)\n {\n   tree suffix_id = USERDEF_LITERAL_SUFFIX_ID (literal);\n   tree name = cp_literal_operator_id (IDENTIFIER_POINTER (suffix_id));\n@@ -5663,10 +5704,15 @@ cp_parser_primary_expression (cp_parser *parser,\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */\n-      return (cp_parser_string_literal (parser,\n-\t\t\t\t\tparser->translate_strings_p,\n-\t\t\t\t\ttrue)\n-\t      .maybe_add_location_wrapper ());\n+      if (parser->translate_strings_p)\n+\treturn (cp_parser_userdef_string_literal (parser,\n+\t\t\t\t\t\t  /*lookup_udlit=*/true)\n+\t\t.maybe_add_location_wrapper ());\n+      else\n+\treturn (cp_parser_string_literal (parser,\n+\t\t\t\t\t  /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/true)\n+\t\t.maybe_add_location_wrapper ());\n \n     case CPP_OPEN_PAREN:\n       /* If we see `( { ' then we are looking at the beginning of\n@@ -16222,15 +16268,14 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n static void\n cp_parser_linkage_specification (cp_parser* parser, tree prefix_attr)\n {\n-  tree linkage;\n-\n   /* Look for the `extern' keyword.  */\n   cp_token *extern_token\n     = cp_parser_require_keyword (parser, RID_EXTERN, RT_EXTERN);\n \n   /* Look for the string-literal.  */\n   cp_token *string_token = cp_lexer_peek_token (parser->lexer);\n-  linkage = cp_parser_string_literal (parser, false, false);\n+  tree linkage = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t   /*wide_ok=*/false);\n \n   /* Transform the literal into an identifier.  If the literal is a\n      wide-character string, or contains embedded NULs, then we can't\n@@ -16360,9 +16405,8 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n       cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \n       /* Parse the string-literal message.  */\n-      message = cp_parser_string_literal (parser,\n-                                \t  /*translate=*/false,\n-                                \t  /*wide_ok=*/true);\n+      message = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/true);\n \n       /* A `)' completes the static assertion.  */\n       if (!parens.require_close (parser))\n@@ -17410,16 +17454,15 @@ cp_parser_operator (cp_parser* parser, location_t start_loc)\n     case CPP_STRING16_USERDEF:\n     case CPP_STRING32_USERDEF:\n       {\n-\tcp_expr str;\n \ttree string_tree;\n \tint sz, len;\n \n \tif (cxx_dialect == cxx98)\n \t  maybe_warn_cpp0x (CPP0X_USER_DEFINED_LITERALS);\n \n \t/* Consume the string.  */\n-\tstr = cp_parser_string_literal (parser, /*translate=*/true,\n-\t\t\t\t      /*wide_ok=*/true, /*lookup_udlit=*/false);\n+\tcp_expr str = cp_parser_userdef_string_literal (parser,\n+\t\t\t\t\t\t\t/*lookup_udlit=*/false);\n \tif (str == error_mark_node)\n \t  return error_mark_node;\n \telse if (TREE_CODE (str) == USERDEF_LITERAL)\n@@ -22072,7 +22115,6 @@ cp_parser_using_directive (cp_parser* parser)\n static void\n cp_parser_asm_definition (cp_parser* parser)\n {\n-  tree string;\n   tree outputs = NULL_TREE;\n   tree inputs = NULL_TREE;\n   tree clobbers = NULL_TREE;\n@@ -22180,7 +22222,8 @@ cp_parser_asm_definition (cp_parser* parser)\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return;\n   /* Look for the string.  */\n-  string = cp_parser_string_literal (parser, false, false);\n+  tree string = cp_parser_string_literal (parser, /*translate=*/false,\n+\t\t\t\t\t  /*wide_ok=*/false);\n   if (string == error_mark_node)\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, true, false,\n@@ -28655,11 +28698,8 @@ cp_parser_yield_expression (cp_parser* parser)\n static tree\n cp_parser_asm_specification_opt (cp_parser* parser)\n {\n-  cp_token *token;\n-  tree asm_specification;\n-\n   /* Peek at the next token.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n   /* If the next token isn't the `asm' keyword, then there's no\n      asm-specification.  */\n   if (!cp_parser_is_keyword (token, RID_ASM))\n@@ -28672,7 +28712,9 @@ cp_parser_asm_specification_opt (cp_parser* parser)\n   parens.require_open (parser);\n \n   /* Look for the string-literal.  */\n-  asm_specification = cp_parser_string_literal (parser, false, false);\n+  tree asm_specification = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t     /*translate=*/false,\n+\t\t\t\t\t\t     /*wide_ok=*/false);\n \n   /* Look for the `)'.  */\n   parens.require_close (parser);\n@@ -28705,8 +28747,6 @@ cp_parser_asm_operand_list (cp_parser* parser)\n \n   while (true)\n     {\n-      tree string_literal;\n-      tree expression;\n       tree name;\n \n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n@@ -28724,13 +28764,15 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       else\n \tname = NULL_TREE;\n       /* Look for the string-literal.  */\n-      string_literal = cp_parser_string_literal (parser, false, false);\n+      tree string_literal = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n \n       /* Look for the `('.  */\n       matching_parens parens;\n       parens.require_open (parser);\n       /* Parse the expression.  */\n-      expression = cp_parser_expression (parser);\n+      tree expression = cp_parser_expression (parser);\n       /* Look for the `)'.  */\n       parens.require_close (parser);\n \n@@ -28770,10 +28812,10 @@ cp_parser_asm_clobber_list (cp_parser* parser)\n \n   while (true)\n     {\n-      tree string_literal;\n-\n       /* Look for the string literal.  */\n-      string_literal = cp_parser_string_literal (parser, false, false);\n+      tree string_literal = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n       /* Add it to the list.  */\n       clobbers = tree_cons (NULL_TREE, string_literal, clobbers);\n       /* If the next token is not a `,', then the list is\n@@ -46372,7 +46414,9 @@ cp_parser_omp_context_selector (cp_parser *parser, tree set, bool has_parms_p)\n \t\t      cp_lexer_consume_token (parser->lexer);\n \t\t    }\n \t\t  else if (cp_lexer_next_token_is (parser->lexer, CPP_STRING))\n-\t\t    value = cp_parser_string_literal (parser, false, false);\n+\t\t    value = cp_parser_string_literal (parser,\n+\t\t\t\t\t\t      /*translate=*/false,\n+\t\t\t\t\t\t      /*wide_ok=*/false);\n \t\t  else\n \t\t    {\n \t\t      cp_parser_error (parser, \"expected identifier or \"\n@@ -49394,7 +49438,8 @@ pragma_lex (tree *value, location_t *loc)\n   if (ret == CPP_PRAGMA_EOL)\n     ret = CPP_EOF;\n   else if (ret == CPP_STRING)\n-    *value = cp_parser_string_literal (the_parser, false, false);\n+    *value = cp_parser_string_literal (the_parser, /*translate=*/false,\n+\t\t\t\t       /*wide_ok=*/false);\n   else\n     {\n       if (ret == CPP_KEYWORD)"}, {"sha": "66e300e350f11cb154cf9db83c319415d30c7954", "filename": "gcc/testsuite/g++.dg/cpp0x/udlit-error1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-error1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f353b0c1dc9385ba8b8a64b65d66d5452383c11/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-error1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fudlit-error1.C?ref=9f353b0c1dc9385ba8b8a64b65d66d5452383c11", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/105300\n+// { dg-do compile { target c++11 } }\n+\n+void operator\"\"_x(const char *, decltype(sizeof(0)));\n+\n+#include \"\"_x\t\t  // { dg-error \"include expects\" }\n+#line \"\"_x\t\t  // { dg-error \"not a positive integer\" }\n+#if __has_include(\"\"_x)\t  // { dg-error \"requires a header-name\" }\n+#endif\n+\n+#pragma message \"hi\"_x\t  // { dg-warning \"string literal with user-defined suffix is invalid in this context\" }\n+\n+extern \"C\"_x { void g(); } // { dg-error \"before user-defined string literal\" }\n+static_assert(true, \"foo\"_x); // { dg-error \"string literal with user-defined suffix is invalid in this context|expected\" }\n+\n+[[deprecated(\"oof\"_x)]]\n+void\n+lol () // { dg-error \"not a string\" }\n+{\n+  asm (\"\"_x); // { dg-error \"string literal with user-defined suffix is invalid in this context\" }\n+}"}]}