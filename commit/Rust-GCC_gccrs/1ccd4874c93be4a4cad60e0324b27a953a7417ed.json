{"sha": "1ccd4874c93be4a4cad60e0324b27a953a7417ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjZDQ4NzRjOTNiZTRhNGNhZDYwZTAzMjRiMjdhOTUzYTc0MTdlZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-05-24T15:30:47Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-05-24T15:30:47Z"}, "message": "lra-constraints.c (emit_spill_move): Use smaller mode for mem-mem moves.\n\n2013-05-24  Vladimir Makarov  <vmakarov@redhat.com>\n\n        * lra-constraints.c (emit_spill_move): Use smaller mode for\n\tmem-mem moves.\n        (check_and_process_move): Consider mem-reg moves for secondary\n\ttoo.\n        (curr_insn_transform): Don't lose insns emitted before for\n\tsecondary memory moves.\n\t(inherit_in_ebb): Mark defined reg.  Add usage only if it is not a\n\treg set up in the current insn.\n\nFrom-SVN: r199298", "tree": {"sha": "54fd0ee909dc935aaf58324287473b79b8204cb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54fd0ee909dc935aaf58324287473b79b8204cb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ccd4874c93be4a4cad60e0324b27a953a7417ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccd4874c93be4a4cad60e0324b27a953a7417ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccd4874c93be4a4cad60e0324b27a953a7417ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccd4874c93be4a4cad60e0324b27a953a7417ed/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8db59905a61b406c9558ccb91867a60aec56b1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8db59905a61b406c9558ccb91867a60aec56b1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8db59905a61b406c9558ccb91867a60aec56b1b"}], "stats": {"total": 89, "additions": 67, "deletions": 22}, "files": [{"sha": "1d9d2dcd11e53ba6913f283fb99785ee30b2025e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccd4874c93be4a4cad60e0324b27a953a7417ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccd4874c93be4a4cad60e0324b27a953a7417ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ccd4874c93be4a4cad60e0324b27a953a7417ed", "patch": "@@ -1,3 +1,14 @@\n+2013-05-24  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+        * lra-constraints.c (emit_spill_move): Use smaller mode for\n+\tmem-mem moves.\n+        (check_and_process_move): Consider mem-reg moves for secondary\n+\ttoo.\n+        (curr_insn_transform): Don't lose insns emitted before for\n+\tsecondary memory moves.\n+\t(inherit_in_ebb): Mark defined reg.  Add usage only if it is not a\n+\treg set up in the current insn.\n+\n 2013-05-24  Dehao Chen  <dehao@google.com>\n \n \t* gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c: New Testcase."}, {"sha": "ef6e07e10c171f36af948874a69ee0cb2df5c7e1", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 56, "deletions": 22, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccd4874c93be4a4cad60e0324b27a953a7417ed/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccd4874c93be4a4cad60e0324b27a953a7417ed/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=1ccd4874c93be4a4cad60e0324b27a953a7417ed", "patch": "@@ -859,10 +859,20 @@ emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n {\n   if (GET_MODE (mem_pseudo) != GET_MODE (val))\n     {\n-      val = gen_rtx_SUBREG (GET_MODE (mem_pseudo),\n-\t\t\t    GET_CODE (val) == SUBREG ? SUBREG_REG (val) : val,\n-\t\t\t    0);\n-      LRA_SUBREG_P (val) = 1;\n+      lra_assert (GET_MODE_SIZE (GET_MODE (mem_pseudo))\n+\t\t  >= GET_MODE_SIZE (GET_MODE (val)));\n+      if (! MEM_P (val))\n+\t{\n+\t  val = gen_rtx_SUBREG (GET_MODE (mem_pseudo),\n+\t\t\t\tGET_CODE (val) == SUBREG ? SUBREG_REG (val) : val,\n+\t\t\t\t0);\n+\t  LRA_SUBREG_P (val) = 1;\n+\t}\n+      else\n+\t{\n+\t  mem_pseudo = gen_lowpart_SUBREG (GET_MODE (val), mem_pseudo);\n+\t  LRA_SUBREG_P (mem_pseudo) = 1;\n+\t}\n     }\n   return (to_p\n \t  ? gen_move_insn (mem_pseudo, val)\n@@ -890,7 +900,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n     dreg = SUBREG_REG (dest);\n   if (GET_CODE (src) == SUBREG)\n     sreg = SUBREG_REG (src);\n-  if (! REG_P (dreg) || ! REG_P (sreg))\n+  if (! (REG_P (dreg) || MEM_P (dreg)) || ! (REG_P (sreg) || MEM_P (sreg)))\n     return false;\n   sclass = dclass = NO_REGS;\n   if (REG_P (dreg))\n@@ -911,14 +921,22 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n   if (sclass == ALL_REGS)\n     /* See comments above.  */\n     return false;\n+  if (sclass == NO_REGS && dclass == NO_REGS)\n+    return false;\n #ifdef SECONDARY_MEMORY_NEEDED\n-  if (dclass != NO_REGS && sclass != NO_REGS\n-      && SECONDARY_MEMORY_NEEDED (sclass, dclass, GET_MODE (src)))\n+  if (SECONDARY_MEMORY_NEEDED (sclass, dclass, GET_MODE (src))\n+#ifdef SECONDARY_MEMORY_NEEDED_MODE\n+      && ((sclass != NO_REGS && dclass != NO_REGS)\n+\t  || GET_MODE (src) != SECONDARY_MEMORY_NEEDED_MODE (GET_MODE (src)))\n+#endif\n+      )\n     {\n       *sec_mem_p = true;\n       return false;\n     }\n #endif\n+  if (! REG_P (dreg) || ! REG_P (sreg))\n+    return false;\n   sri.prev_sri = NULL;\n   sri.icode = CODE_FOR_nothing;\n   sri.extra_cost = 0;\n@@ -3006,24 +3024,35 @@ curr_insn_transform (void)\n \t  /* If the target says specifically to use another mode for\n \t     secondary memory moves we can not reuse the original\n \t     insn.  */\n-         after = emit_spill_move (false, new_reg, dest);\n-         lra_process_new_insns (curr_insn, NULL_RTX, after,\n-                                \"Inserting the sec. move\");\n-         before = emit_spill_move (true, new_reg, src);\n-         lra_process_new_insns (curr_insn, before, NULL_RTX, \"Changing on\");\n-         lra_set_insn_deleted (curr_insn);\n-       }\n+\t  after = emit_spill_move (false, new_reg, dest);\n+\t  lra_process_new_insns (curr_insn, NULL_RTX, after,\n+\t\t\t\t \"Inserting the sec. move\");\n+\t  /* We may have non null BEFORE here (e.g. after address\n+\t     processing.  */\n+\t  push_to_sequence (before);\n+\t  before = emit_spill_move (true, new_reg, src);\n+\t  emit_insn (before);\n+\t  before = get_insns ();\n+\t  end_sequence ();\n+\t  lra_process_new_insns (curr_insn, before, NULL_RTX, \"Changing on\");\n+\t  lra_set_insn_deleted (curr_insn);\n+\t}\n       else if (dest == rld)\n-       {\n-         *curr_id->operand_loc[0] = new_reg;\n+        {\n+\t  *curr_id->operand_loc[0] = new_reg;\n \t  after = emit_spill_move (false, new_reg, dest);\n \t  lra_process_new_insns (curr_insn, NULL_RTX, after,\n \t\t\t\t \"Inserting the sec. move\");\n \t}\n       else\n \t{\n \t  *curr_id->operand_loc[1] = new_reg;\n+\t  /* See comments above.  */\n+\t  push_to_sequence (before);\n \t  before = emit_spill_move (true, new_reg, src);\n+\t  emit_insn (before);\n+\t  before = get_insns ();\n+\t  end_sequence ();\n \t  lra_process_new_insns (curr_insn, before, NULL_RTX,\n \t\t\t\t \"Inserting the sec. move\");\n \t}\n@@ -3823,7 +3852,9 @@ struct usage_insns\n {\n   /* If the value is equal to CURR_USAGE_INSNS_CHECK, then the member\n      value INSNS is valid.  The insns is chain of optional debug insns\n-     and a finishing non-debug insn using the corresponding reg.  */\n+     and a finishing non-debug insn using the corresponding reg.  The\n+     value is also used to mark the registers which are set up in the\n+     current insn.  The negated insn uid is used for this.  */\n   int check;\n   /* Value of global reloads_num at the last insn in INSNS.  */\n   int reloads_num;\n@@ -4796,14 +4827,15 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t\t&& (dst_regno < FIRST_PSEUDO_REGISTER\n \t\t\t    || reg_renumber[dst_regno] >= 0)))\n \t\t  {\n-\t\t    /* Invalidate.  */\n+\t\t    /* Invalidate and mark definitions.  */\n \t\t    if (dst_regno >= FIRST_PSEUDO_REGISTER)\n-\t\t      usage_insns[dst_regno].check = 0;\n+\t\t      usage_insns[dst_regno].check = -(int) INSN_UID (curr_insn);\n \t\t    else\n \t\t      {\n \t\t\tnregs = hard_regno_nregs[dst_regno][reg->biggest_mode];\n \t\t\tfor (i = 0; i < nregs; i++)\n-\t\t\t  usage_insns[dst_regno + i].check = 0;\n+\t\t\t  usage_insns[dst_regno + i].check\n+\t\t\t    = -(int) INSN_UID (curr_insn);\n \t\t      }\n \t\t  }\n \t      }\n@@ -4864,8 +4896,10 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t\t    = usage_insns[src_regno].insns) != NULL_RTX\n \t\t\t&& NONDEBUG_INSN_P (curr_insn))\n \t\t      add_to_inherit (src_regno, next_usage_insns);\n-\t\t    else\n-\t\t      /* Add usages.  */\n+\t\t    else if (usage_insns[src_regno].check\n+\t\t\t     != -(int) INSN_UID (curr_insn))\n+                      /* Add usages but only if the reg is not set up\n+                         in the same insn.  */\n \t\t      add_next_usage_insn (src_regno, curr_insn, reloads_num);\n \t\t  }\n \t\telse if (src_regno < FIRST_PSEUDO_REGISTER"}]}