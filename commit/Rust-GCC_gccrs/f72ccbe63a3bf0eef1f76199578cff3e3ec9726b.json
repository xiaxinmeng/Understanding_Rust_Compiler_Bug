{"sha": "f72ccbe63a3bf0eef1f76199578cff3e3ec9726b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyY2NiZTYzYTNiZjBlZWYxZjc2MTk5NTc4Y2ZmM2UzZWM5NzI2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-05T23:17:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-05T23:17:30Z"}, "message": "(push_reload, find_reloads): Refine when we reload inside a SUBREG by respecting BYTE_LOADS_*_EXTEND...\n\n(push_reload, find_reloads): Refine when we reload inside a SUBREG by\nrespecting BYTE_LOADS_*_EXTEND; see comments in push_reload.\n\nFrom-SVN: r5076", "tree": {"sha": "74e30d96047d18c282a24e8863f53c673d509f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74e30d96047d18c282a24e8863f53c673d509f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b/comments", "author": null, "committer": null, "parents": [{"sha": "ebe6d7a7cc236f5b9fad716346f858ba44d48c4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe6d7a7cc236f5b9fad716346f858ba44d48c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe6d7a7cc236f5b9fad716346f858ba44d48c4d"}], "stats": {"total": 92, "additions": 55, "deletions": 37}, "files": [{"sha": "8b7b244a5bb50d967a2f9afd206e56e21f569f47", "filename": "gcc/reload.c", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f72ccbe63a3bf0eef1f76199578cff3e3ec9726b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f72ccbe63a3bf0eef1f76199578cff3e3ec9726b", "patch": "@@ -616,6 +616,8 @@ push_reload (in, out, inloc, outloc, class,\n      really reload just the inside expression in its own mode.\n      If we have (SUBREG:M1 (REG:M2 ...) ...) with M1 wider than M2 and the\n      register is a pseudo, this will become the same as the above case.\n+     For machines that extend byte loads, do this for any SUBREG of a pseudo\n+     where both M1 and M2 are a word or smaller.\n      Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n      either M1 is not valid for R or M2 is wider than a word but we only\n      need one word to store an M2-sized quantity in R.\n@@ -636,20 +638,28 @@ push_reload (in, out, inloc, outloc, class,\n \t  || strict_low\n \t  || (GET_CODE (SUBREG_REG (in)) == REG\n \t      && REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER\n+#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n+\t      && GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n+\t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) <= UNITS_PER_WORD\n+#else\n \t      && (GET_MODE_SIZE (inmode)\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))))\n+\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n+#endif\n+\t      )\n \t  || (REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n \t      && (out == 0 || SUBREG_WORD (in) == 0)\n-\t      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (in)), inmode)\n-\t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t  > UNITS_PER_WORD)\n-\t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t   / UNITS_PER_WORD)\n-\t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))))))\n+\t      && ((GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n+\t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t       > UNITS_PER_WORD)\n+\t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n+\t\t\t/ UNITS_PER_WORD)\n+\t\t       != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n+\t\t\t\t\t    GET_MODE (SUBREG_REG (in)))))\n+\t\t  || ! HARD_REGNO_MODE_OK ((REGNO (SUBREG_REG (in))\n+\t\t\t\t\t    + SUBREG_WORD (in)),\n+\t\t\t\t\t   inmode)))\n #ifdef SECONDARY_INPUT_RELOAD_CLASS\n \t  || (SECONDARY_INPUT_RELOAD_CLASS (class, inmode, in) != NO_REGS\n \t      && (SECONDARY_INPUT_RELOAD_CLASS (class,\n@@ -707,18 +717,26 @@ push_reload (in, out, inloc, outloc, class,\n \t  || strict_low\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER\n+#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n+\t      && GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n+\t      && GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) <= UNITS_PER_WORD\n+#else\n \t      && (GET_MODE_SIZE (outmode)\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))))\n+\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+#endif\n+\t      )\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n-\t      && (! HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (out)), outmode)\n-\t\t  || (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n-\t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t\t  > UNITS_PER_WORD)\n-\t\t      && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t\t   / UNITS_PER_WORD)\n-\t\t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n-\t\t\t\t\t       GET_MODE (SUBREG_REG (out)))))))\n+\t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n+\t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n+\t\t       > UNITS_PER_WORD)\n+\t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n+\t\t\t/ UNITS_PER_WORD)\n+\t\t       != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n+\t\t\t\t\t    GET_MODE (SUBREG_REG (out)))))\n+\t\t  || ! HARD_REGNO_MODE_OK ((REGNO (SUBREG_REG (out))\n+\t\t\t\t\t    + SUBREG_WORD (out)),\n+\t\t\t\t\t   outmode)))\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  || (SECONDARY_OUTPUT_RELOAD_CLASS (class, outmode, out) != NO_REGS\n \t      && (SECONDARY_OUTPUT_RELOAD_CLASS (class,\n@@ -2526,30 +2544,30 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t be a problem accessing the register in the outer mode.  */\n \t      if (GET_CODE (operand) != REG\n #if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n-\t\t  /* ??? The comment below clearly does not match the code.\n-\t\t     What the code below actually does is set force_reload\n-\t\t     for a paradoxical subreg of a pseudo.  rms and kenner\n-\t\t     can't see the point of doing this.  */\n-\t\t  /* Nonparadoxical subreg of a pseudoreg.\n-\t\t     Don't to load the full width if on this machine\n-\t\t     we expected the fetch to extend.  */\n-\t\t  || ((GET_MODE_SIZE (operand_mode[i])\n-\t\t       > GET_MODE_SIZE (GET_MODE (operand)))\n-\t\t      && REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n+\t\t  /* If we have a SUBREG where both the inner and outer\n+\t\t     modes are different but no wider than a word, combine.c\n+\t\t     has made assumptions about the behavior of the machine\n+\t\t     in such register access.  If the data is, in fact, in\n+\t\t     memory we must always load using the size assumed to\n+\t\t     be in the register and let the insn do the different-sized\n+\t\t     accesses.  */\n+\t\t  || (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t      && GET_MODE_SIZE (GET_MODE (operand)) <= UNITS_PER_WORD)\n #endif\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n \t\t     or which would handle that mode in the wrong number of\n \t\t     registers for subregging to work.  */\n \t\t  || (REGNO (operand) < FIRST_PSEUDO_REGISTER\n-\t\t      && (! HARD_REGNO_MODE_OK (REGNO (operand),\n-\t\t\t\t\t\toperand_mode[i])\n-\t\t\t  || (GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t\t\t      && (GET_MODE_SIZE (GET_MODE (operand))\n-\t\t\t\t  > UNITS_PER_WORD)\n-\t\t\t      && ((GET_MODE_SIZE (GET_MODE (operand))\n-\t\t\t\t   / UNITS_PER_WORD)\n-\t\t\t\t  != HARD_REGNO_NREGS (REGNO (operand),\n-\t\t\t\t\t\t       GET_MODE (operand)))))))\n+\t\t      && ((GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t\t   && (GET_MODE_SIZE (GET_MODE (operand))\n+\t\t\t       > UNITS_PER_WORD)\n+\t\t\t   && ((GET_MODE_SIZE (GET_MODE (operand))\n+\t\t\t\t/ UNITS_PER_WORD)\n+\t\t\t       != HARD_REGNO_NREGS (REGNO (operand),\n+\t\t\t\t\t\t    GET_MODE (operand))))\n+\t\t\t  || ! HARD_REGNO_MODE_OK (REGNO (operand) + offset,\n+\t\t\t\t\t\t   operand_mode[i]))))\n \t\tforce_reload = 1;\n \t    }\n "}]}