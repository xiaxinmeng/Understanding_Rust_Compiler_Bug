{"sha": "214c63949d6da60041242a3d2507eb8a2fe41b7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE0YzYzOTQ5ZDZkYTYwMDQxMjQyYTNkMjUwN2ViOGEyZmU0MWI3ZQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-05-05T07:55:21Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-05-05T07:55:21Z"}, "message": "sparc.c (sparc_rtx_costs): Describe costs of more RTX codes.\n\n2002-05-04  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/sparc.c (sparc_rtx_costs): Describe costs of\n\tmore RTX codes.\n\t* config/sparc/sparc.h (RTX_COSTS_CASES): List those new codes.\n\nFrom-SVN: r53178", "tree": {"sha": "5518add6966a4a80e76ca808e35b854971317eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5518add6966a4a80e76ca808e35b854971317eed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/214c63949d6da60041242a3d2507eb8a2fe41b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214c63949d6da60041242a3d2507eb8a2fe41b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214c63949d6da60041242a3d2507eb8a2fe41b7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214c63949d6da60041242a3d2507eb8a2fe41b7e/comments", "author": null, "committer": null, "parents": [{"sha": "091fb516144007611bcbd318e8eff9300488353c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/091fb516144007611bcbd318e8eff9300488353c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/091fb516144007611bcbd318e8eff9300488353c"}], "stats": {"total": 276, "additions": 270, "deletions": 6}, "files": [{"sha": "7a222873d8ab02b44494fd886c6da33459b4ac99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=214c63949d6da60041242a3d2507eb8a2fe41b7e", "patch": "@@ -1,5 +1,9 @@\n 2002-05-04  David S. Miller  <davem@redhat.com>\n \n+\t* config/sparc/sparc.c (sparc_rtx_costs): Describe costs of\n+\tmore RTX codes.\n+\t* config/sparc/sparc.h (RTX_COSTS_CASES): List those new codes.\n+\n \t* recog.c (store_data_bypass_p): Handle out_insn being a PARALLEL\n \tof SETs.\n "}, {"sha": "57083801688bf599684a6f3e12b6fcbcd0086bce", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 259, "deletions": 5, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=214c63949d6da60041242a3d2507eb8a2fe41b7e", "patch": "@@ -8086,21 +8086,169 @@ sparc_extra_constraint_check (op, c, strict)\n   return reload_ok_mem;\n }\n \n+/* ??? This duplicates information provided to the compiler by the\n+   ??? scheduler description.  Some day, teach genautomata to output\n+   ??? the latencies and then CSE will just use that.  */\n+\n int\n sparc_rtx_costs (x, code, outer_code)\n      rtx x;\n      enum rtx_code code, outer_code;\n {\n   switch (code)\n     {\n+    case PLUS: case MINUS: case ABS: case NEG:\n+    case FLOAT: case UNSIGNED_FLOAT:\n+    case FIX: case UNSIGNED_FIX:\n+    case FLOAT_EXTEND: case FLOAT_TRUNCATE:\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\t{\n+\t  switch (sparc_cpu)\n+\t    {\n+\t    case PROCESSOR_ULTRASPARC:\n+\t    case PROCESSOR_ULTRASPARC3:\n+\t      return COSTS_N_INSNS (4);\n+\n+\t    case PROCESSOR_SUPERSPARC:\n+\t      return COSTS_N_INSNS (3);\n+\n+\t    case PROCESSOR_CYPRESS:\n+\t      return COSTS_N_INSNS (5);\n+\n+\t    case PROCESSOR_HYPERSPARC:\n+\t    case PROCESSOR_SPARCLITE86X:\n+\t    default:\n+\t      return COSTS_N_INSNS (1);\n+\t    }\n+\t}\n+\n+      return COSTS_N_INSNS (1);\n+\n+    case SQRT:\n+      switch (sparc_cpu)\n+\t{\n+\tcase PROCESSOR_ULTRASPARC:\n+\t  if (GET_MODE (x) == SFmode)\n+\t    return COSTS_N_INSNS (13);\n+\t  else\n+\t    return COSTS_N_INSNS (23);\n+\n+\tcase PROCESSOR_ULTRASPARC3:\n+\t  if (GET_MODE (x) == SFmode)\n+\t    return COSTS_N_INSNS (20);\n+\t  else\n+\t    return COSTS_N_INSNS (29);\n+\n+\tcase PROCESSOR_SUPERSPARC:\n+\t  return COSTS_N_INSNS (12);\n+\n+\tcase PROCESSOR_CYPRESS:\n+\t  return COSTS_N_INSNS (63);\n+\n+\tcase PROCESSOR_HYPERSPARC:\n+\tcase PROCESSOR_SPARCLITE86X:\n+\t  return COSTS_N_INSNS (17);\n+\n+\tdefault:\n+\t  return COSTS_N_INSNS (30);\n+\t}\n+\n+    case COMPARE:\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\t{\n+\t  switch (sparc_cpu)\n+\t    {\n+\t    case PROCESSOR_ULTRASPARC:\n+\t    case PROCESSOR_ULTRASPARC3:\n+\t      return COSTS_N_INSNS (1);\n+\n+\t    case PROCESSOR_SUPERSPARC:\n+\t      return COSTS_N_INSNS (3);\n+\n+\t    case PROCESSOR_CYPRESS:\n+\t      return COSTS_N_INSNS (5);\n+\n+\t    case PROCESSOR_HYPERSPARC:\n+\t    case PROCESSOR_SPARCLITE86X:\n+\t    default:\n+\t      return COSTS_N_INSNS (1);\n+\t    }\n+\t}\n+\n+      /* ??? Maybe mark integer compares as zero cost on\n+\t ??? all UltraSPARC processors because the result\n+\t ??? can be bypassed to a branch in the same group.  */\n+\n+      return COSTS_N_INSNS (1);\n+\n     case MULT:\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\t{\n+\t  switch (sparc_cpu)\n+\t    {\n+\t    case PROCESSOR_ULTRASPARC:\n+\t    case PROCESSOR_ULTRASPARC3:\n+\t      return COSTS_N_INSNS (4);\n+\n+\t    case PROCESSOR_SUPERSPARC:\n+\t      return COSTS_N_INSNS (3);\n+\n+\t    case PROCESSOR_CYPRESS:\n+\t      return COSTS_N_INSNS (7);\n+\n+\t    case PROCESSOR_HYPERSPARC:\n+\t    case PROCESSOR_SPARCLITE86X:\n+\t      return COSTS_N_INSNS (1);\n+\n+\t    default:\n+\t      return COSTS_N_INSNS (5);\n+\t    }\n+\t}\n+\n+      /* The latency is actually variable for Ultra-I/II\n+\t And if one of the inputs have a known constant\n+\t value, we could calculate this precisely.\n+\n+\t However, for that to be useful we would need to\n+\t add some machine description changes which would\n+\t make sure small constants ended up in rs1 of the\n+\t multiply instruction.  This is because the multiply\n+\t latency is determined by the number of clear (or\n+\t set if the value is negative) bits starting from\n+\t the most significant bit of the first input.\n+\n+\t The algorithm for computing num_cycles of a multiply\n+\t on Ultra-I/II is:\n+\n+\t \tif (rs1 < 0)\n+\t\t\thighest_bit = highest_clear_bit(rs1);\n+\t\telse\n+\t\t\thighest_bit = highest_set_bit(rs1);\n+\t\tif (num_bits < 3)\n+\t\t\thighest_bit = 3;\n+\t\tnum_cycles = 4 + ((highest_bit - 3) / 2);\n+\n+\t If we did that we would have to also consider register\n+\t allocation issues that would result from forcing such\n+\t a value into a register.\n+\n+\t There are other similar tricks we could play if we\n+\t knew, for example, that one input was an array index.\n+\n+\t Since we do not play any such tricks currently the\n+\t safest thing to do is report the worst case latency.  */\n       if (sparc_cpu == PROCESSOR_ULTRASPARC)\n \treturn (GET_MODE (x) == DImode ?\n \t\tCOSTS_N_INSNS (34) : COSTS_N_INSNS (19));\n \n+      /* Multiply latency on Ultra-III, fortunately, is constant.  */\n       if (sparc_cpu == PROCESSOR_ULTRASPARC3)\n \treturn COSTS_N_INSNS (6);\n \n+      if (sparc_cpu == PROCESSOR_HYPERSPARC\n+\t  || sparc_cpu == PROCESSOR_SPARCLITE86X)\n+\treturn COSTS_N_INSNS (17);\n+\n       return (TARGET_HARD_MUL\n \t      ? COSTS_N_INSNS (5)\n \t      : COSTS_N_INSNS (25));\n@@ -8109,6 +8257,40 @@ sparc_rtx_costs (x, code, outer_code)\n     case UDIV:\n     case MOD:\n     case UMOD:\n+      if (FLOAT_MODE_P (GET_MODE (x)))\n+\t{\n+\t  switch (sparc_cpu)\n+\t    {\n+\t    case PROCESSOR_ULTRASPARC:\n+\t      if (GET_MODE (x) == SFmode)\n+\t\treturn COSTS_N_INSNS (13);\n+\t      else\n+\t\treturn COSTS_N_INSNS (23);\n+\n+\t    case PROCESSOR_ULTRASPARC3:\n+\t      if (GET_MODE (x) == SFmode)\n+\t\treturn COSTS_N_INSNS (17);\n+\t      else\n+\t\treturn COSTS_N_INSNS (20);\n+\n+\t    case PROCESSOR_SUPERSPARC:\n+\t      if (GET_MODE (x) == SFmode)\n+\t\treturn COSTS_N_INSNS (6);\n+\t      else\n+\t\treturn COSTS_N_INSNS (9);\n+\n+\t    case PROCESSOR_HYPERSPARC:\n+\t    case PROCESSOR_SPARCLITE86X:\n+\t      if (GET_MODE (x) == SFmode)\n+\t\treturn COSTS_N_INSNS (8);\n+\t      else\n+\t\treturn COSTS_N_INSNS (12);\n+\n+\t    default:\n+\t      return COSTS_N_INSNS (7);\n+\t    }\n+\t}\n+\n       if (sparc_cpu == PROCESSOR_ULTRASPARC)\n \treturn (GET_MODE (x) == DImode ?\n \t\tCOSTS_N_INSNS (68) : COSTS_N_INSNS (37));\n@@ -8117,11 +8299,83 @@ sparc_rtx_costs (x, code, outer_code)\n \t\tCOSTS_N_INSNS (71) : COSTS_N_INSNS (40));\n       return COSTS_N_INSNS (25);\n \n-      /* Make FLOAT and FIX more expensive than CONST_DOUBLE,\n-\t so that cse will favor the latter.  */\n-    case FLOAT:\n-    case FIX:\n-      return 19;\n+    case IF_THEN_ELSE:\n+      /* Conditional moves. */\n+      switch (sparc_cpu)\n+\t{\n+\tcase PROCESSOR_ULTRASPARC:\n+\t  return COSTS_N_INSNS (2);\n+\n+\tcase PROCESSOR_ULTRASPARC3:\n+\t  if (FLOAT_MODE_P (GET_MODE (x)))\n+\t    return COSTS_N_INSNS (3);\n+\t  else\n+\t    return COSTS_N_INSNS (2);\n+\n+\tdefault:\n+\t  return COSTS_N_INSNS (1);\n+\t}\n+\n+    case MEM:\n+      /* If outer-code is SIGN/ZERO extension we have to subtract\n+\t out COSTS_N_INSNS (1) from whatever we return in determining\n+\t the cost.  */\n+      switch (sparc_cpu)\n+\t{\n+\tcase PROCESSOR_ULTRASPARC:\n+\t  if (outer_code == ZERO_EXTEND)\n+\t    return COSTS_N_INSNS (1);\n+\t  else\n+\t    return COSTS_N_INSNS (2);\n+\n+\tcase PROCESSOR_ULTRASPARC3:\n+\t  if (outer_code == ZERO_EXTEND)\n+\t    {\n+\t      if (GET_MODE (x) == QImode\n+\t\t  || GET_MODE (x) == HImode\n+\t\t  || outer_code == SIGN_EXTEND)\n+\t\treturn COSTS_N_INSNS (2);\n+\t      else\n+\t\treturn COSTS_N_INSNS (1);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This handles sign extension (3 cycles)\n+\t\t and everything else (2 cycles).  */\n+\t      return COSTS_N_INSNS (2);\n+\t    }\n+\n+\tcase PROCESSOR_SUPERSPARC:\n+\t  if (FLOAT_MODE_P (GET_MODE (x))\n+\t      || outer_code == ZERO_EXTEND\n+\t      || outer_code == SIGN_EXTEND)\n+\t    return COSTS_N_INSNS (0);\n+\t  else\n+\t    return COSTS_N_INSNS (1);\n+\n+\tcase PROCESSOR_TSC701:\n+\t  if (outer_code == ZERO_EXTEND\n+\t      || outer_code == SIGN_EXTEND)\n+\t    return COSTS_N_INSNS (2);\n+\t  else\n+\t    return COSTS_N_INSNS (3);\n+\t  \n+\tcase PROCESSOR_CYPRESS:\n+\t  if (outer_code == ZERO_EXTEND\n+\t      || outer_code == SIGN_EXTEND)\n+\t    return COSTS_N_INSNS (1);\n+\t  else\n+\t    return COSTS_N_INSNS (2);\n+\t  \n+\tcase PROCESSOR_HYPERSPARC:\n+\tcase PROCESSOR_SPARCLITE86X:\n+\tdefault:\n+\t  if (outer_code == ZERO_EXTEND\n+\t      || outer_code == SIGN_EXTEND)\n+\t    return COSTS_N_INSNS (0);\n+\t  else\n+\t    return COSTS_N_INSNS (1);\n+\t}\n \n     case CONST_INT:\n       if (INTVAL (x) < 0x1000 && INTVAL (x) >= -0x1000)"}, {"sha": "fa1e792b9c1da0f80044b5f9ea17c6d5a3bebedb", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214c63949d6da60041242a3d2507eb8a2fe41b7e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=214c63949d6da60041242a3d2507eb8a2fe41b7e", "patch": "@@ -2675,8 +2675,14 @@ do {                                                                    \\\n /* The cases that RTX_COSTS handles.  */\n \n #define RTX_COSTS_CASES\t\\\n+case PLUS: case MINUS: case ABS: case NEG: \\\n+case FLOAT: case UNSIGNED_FLOAT: \\\n+case FIX: case UNSIGNED_FIX: \\\n+case FLOAT_EXTEND: case FLOAT_TRUNCATE: \\\n+case SQRT: \\\n+case COMPARE: case IF_THEN_ELSE: \\\n+case MEM: \\\n case MULT: case DIV: case UDIV: case MOD: case UMOD: \\\n-case FLOAT: case FIX: \\\n case CONST_INT: case HIGH: case CONST: \\\n case LABEL_REF: case SYMBOL_REF: case CONST_DOUBLE:\n "}]}