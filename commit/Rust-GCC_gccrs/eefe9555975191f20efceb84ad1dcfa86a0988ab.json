{"sha": "eefe9555975191f20efceb84ad1dcfa86a0988ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmZTk1NTU5NzUxOTFmMjBlZmNlYjg0YWQxZGNmYTg2YTA5ODhhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:20:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-04T13:20:30Z"}, "message": "[multiple changes]\n\n2014-08-04  Claire Dross  <dross@adacore.com>\n\n\t* exp_util.adb (Get_First_Parent_With_Ext_Axioms_For_Entity):\n\tFor an instance, look at the scope before the generic parent.\n\n2014-08-04  Yannick Moy  <moy@adacore.com>\n\n\t* lib-writ.ads: Update comments.\n\t* sem_disp.ads, sem_disp.adb (Inherited_Subprograms): Add\n\tparameters to filter inherited subprograms.\n\nFrom-SVN: r213590", "tree": {"sha": "b30c95833e265d7af642325f6743b3cf861b206b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b30c95833e265d7af642325f6743b3cf861b206b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eefe9555975191f20efceb84ad1dcfa86a0988ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eefe9555975191f20efceb84ad1dcfa86a0988ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eefe9555975191f20efceb84ad1dcfa86a0988ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eefe9555975191f20efceb84ad1dcfa86a0988ab/comments", "author": null, "committer": null, "parents": [{"sha": "9a9d35ffaa1445248ca6449bfedae640659def22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9d35ffaa1445248ca6449bfedae640659def22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9d35ffaa1445248ca6449bfedae640659def22"}], "stats": {"total": 179, "additions": 112, "deletions": 67}, "files": [{"sha": "70db1c1f456686b790af567992370567a62a2fe4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=eefe9555975191f20efceb84ad1dcfa86a0988ab", "patch": "@@ -1,3 +1,14 @@\n+2014-08-04  Claire Dross  <dross@adacore.com>\n+\n+\t* exp_util.adb (Get_First_Parent_With_Ext_Axioms_For_Entity):\n+\tFor an instance, look at the scope before the generic parent.\n+\n+2014-08-04  Yannick Moy  <moy@adacore.com>\n+\n+\t* lib-writ.ads: Update comments.\n+\t* sem_disp.ads, sem_disp.adb (Inherited_Subprograms): Add\n+\tparameters to filter inherited subprograms.\n+\n 2014-08-04  Robert Dewar  <dewar@adacore.com>\n \n \t* gnat_rm.texi: Add section on use of address clause for memory"}, {"sha": "d5d269c28ca98c7f376ddf00abf986d0805baa90", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=eefe9555975191f20efceb84ad1dcfa86a0988ab", "patch": "@@ -3319,27 +3319,36 @@ package body Exp_Util is\n         and then Has_Annotate_Pragma_For_External_Axiomatization (E)\n       then\n          return E;\n+      end if;\n \n-         --  E is a package instance, in which case it is axiomatized iff the\n-         --  corresponding generic package is Axiomatized.\n+      --  If E's scope is axiomatized, E is axiomatized.\n \n-      elsif Ekind (E) = E_Package\n-        and then Present (Generic_Parent (Decl))\n-      then\n-         return\n-           Get_First_Parent_With_Ext_Axioms_For_Entity (Generic_Parent (Decl));\n+      declare\n+         First_Ax_Parent_Scope : Entity_Id := Empty;\n \n-         --  Otherwise, look at E's scope instead if present\n+      begin\n+         if Present (Scope (E)) then\n+            First_Ax_Parent_Scope :=\n+              Get_First_Parent_With_Ext_Axioms_For_Entity (Scope (E));\n+         end if;\n \n-      elsif Present (Scope (E)) then\n-         return\n-           Get_First_Parent_With_Ext_Axioms_For_Entity (Scope (E));\n+         if Present (First_Ax_Parent_Scope) then\n+            return First_Ax_Parent_Scope;\n+         end if;\n \n-         --  Else there is no such axiomatized package\n+         --  otherwise, if E is a package instance, it is axiomatized if the\n+         --  corresponding generic package is axiomatized.\n \n-      else\n-         return Empty;\n-      end if;\n+         if Ekind (E) = E_Package\n+           and then Present (Generic_Parent (Decl))\n+         then\n+            return\n+              Get_First_Parent_With_Ext_Axioms_For_Entity\n+                (Generic_Parent (Decl));\n+         else\n+            return Empty;\n+         end if;\n+      end;\n    end Get_First_Parent_With_Ext_Axioms_For_Entity;\n \n    ---------------------"}, {"sha": "5a061e49e4d8d51f4820ab52d8454c9ea34419f2", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=eefe9555975191f20efceb84ad1dcfa86a0988ab", "patch": "@@ -917,7 +917,8 @@ package Lib.Writ is\n    procedure Write_ALI (Object : Boolean);\n    --  This procedure writes the library information for the current main unit\n    --  The Object parameter is true if an object file is created, and false\n-   --  otherwise.\n+   --  otherwise. Note that the pseudo-object file generated in GNATProve mode\n+   --  does count as an object file from this point of view.\n    --\n    --  Note: in the case where we are not generating code (-gnatc mode), this\n    --  routine only writes an ALI file if it cannot find an existing up to"}, {"sha": "6d6078dc9f50cb1d697c8caac535462372f6622d", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=eefe9555975191f20efceb84ad1dcfa86a0988ab", "patch": "@@ -2044,7 +2044,11 @@ package body Sem_Disp is\n    -- Inherited_Subprograms --\n    ---------------------------\n \n-   function Inherited_Subprograms (S : Entity_Id) return Subprogram_List is\n+   function Inherited_Subprograms\n+     (S               : Entity_Id;\n+      No_Interfaces   : Boolean := False;\n+      Interfaces_Only : Boolean := False) return Subprogram_List\n+   is\n       Result : Subprogram_List (1 .. 6000);\n       --  6000 here is intended to be infinity. We could use an expandable\n       --  table, but it would be awfully heavy, and there is no way that we\n@@ -2078,68 +2082,79 @@ package body Sem_Disp is\n    --  Start of processing for Inherited_Subprograms\n \n    begin\n+      pragma Assert (not (No_Interfaces and Interfaces_Only));\n+\n       if Present (S) and then Is_Dispatching_Operation (S) then\n \n          --  Deal with direct inheritance\n \n-         Parent_Op := S;\n-         loop\n-            Parent_Op := Overridden_Operation (Parent_Op);\n-            exit when No (Parent_Op);\n-\n-            if Is_Subprogram (Parent_Op)\n-              or else Is_Generic_Subprogram (Parent_Op)\n-            then\n-               Store_IS (Parent_Op);\n-            end if;\n-         end loop;\n+         if not Interfaces_Only then\n+            Parent_Op := S;\n+            loop\n+               Parent_Op := Overridden_Operation (Parent_Op);\n+               exit when No (Parent_Op)\n+                 or else\n+                   (No_Interfaces\n+                     and then\n+                       Is_Interface (Find_Dispatching_Type (Parent_Op)));\n+\n+               if Is_Subprogram         (Parent_Op)\n+                    or else\n+                  Is_Generic_Subprogram (Parent_Op)\n+               then\n+                  Store_IS (Parent_Op);\n+               end if;\n+            end loop;\n+         end if;\n \n          --  Now deal with interfaces\n \n-         declare\n-            Tag_Typ : Entity_Id;\n-            Prim    : Entity_Id;\n-            Elmt    : Elmt_Id;\n+         if not No_Interfaces then\n+            declare\n+               Tag_Typ : Entity_Id;\n+               Prim    : Entity_Id;\n+               Elmt    : Elmt_Id;\n \n-         begin\n-            Tag_Typ := Find_Dispatching_Type (S);\n+            begin\n+               Tag_Typ := Find_Dispatching_Type (S);\n \n-            if Is_Concurrent_Type (Tag_Typ) then\n-               Tag_Typ := Corresponding_Record_Type (Tag_Typ);\n-            end if;\n+               if Is_Concurrent_Type (Tag_Typ) then\n+                  Tag_Typ := Corresponding_Record_Type (Tag_Typ);\n+               end if;\n \n-            --  Search primitive operations of dispatching type\n+               --  Search primitive operations of dispatching type\n \n-            if Present (Tag_Typ)\n-              and then Present (Primitive_Operations (Tag_Typ))\n-            then\n-               Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n-               while Present (Elmt) loop\n-                  Prim := Node (Elmt);\n+               if Present (Tag_Typ)\n+                 and then Present (Primitive_Operations (Tag_Typ))\n+               then\n+                  Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+                  while Present (Elmt) loop\n+                     Prim := Node (Elmt);\n \n-                  --  The following test eliminates some odd cases in which\n-                  --  Ekind (Prim) is Void, to be investigated further ???\n+                     --  The following test eliminates some odd cases in which\n+                     --  Ekind (Prim) is Void, to be investigated further ???\n \n-                  if not (Is_Subprogram (Prim)\n-                            or else\n-                          Is_Generic_Subprogram (Prim))\n-                  then\n-                     null;\n+                     if not (Is_Subprogram         (Prim)\n+                                or else\n+                             Is_Generic_Subprogram (Prim))\n+                     then\n+                        null;\n \n                      --  For [generic] subprogram, look at interface alias\n \n-                  elsif Present (Interface_Alias (Prim))\n-                    and then Alias (Prim) = S\n-                  then\n-                     --  We have found a primitive covered by S\n+                     elsif Present (Interface_Alias (Prim))\n+                       and then Alias (Prim) = S\n+                     then\n+                        --  We have found a primitive covered by S\n \n-                     Store_IS (Interface_Alias (Prim));\n-                  end if;\n+                        Store_IS (Interface_Alias (Prim));\n+                     end if;\n \n-                  Next_Elmt (Elmt);\n-               end loop;\n-            end if;\n-         end;\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end if;\n+            end;\n+         end if;\n       end if;\n \n       return Result (1 .. N);"}, {"sha": "7dbec1b1c9121c597b79472cd7a00a01d097b19a", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eefe9555975191f20efceb84ad1dcfa86a0988ab/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=eefe9555975191f20efceb84ad1dcfa86a0988ab", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,13 +97,22 @@ package Sem_Disp is\n    type Subprogram_List is array (Nat range <>) of Entity_Id;\n    --  Type returned by Inherited_Subprograms function\n \n-   function Inherited_Subprograms (S : Entity_Id) return Subprogram_List;\n+   function Inherited_Subprograms\n+     (S               : Entity_Id;\n+      No_Interfaces   : Boolean := False;\n+      Interfaces_Only : Boolean := False) return Subprogram_List;\n    --  Given the spec of a subprogram, this function gathers any inherited\n-   --  subprograms from direct inheritance or via interfaces. The list is\n-   --  a list of entity id's of the specs of inherited subprograms. Returns\n-   --  a null array if passed an Empty spec id. Note that the returned array\n+   --  subprograms from direct inheritance or via interfaces. The list is a\n+   --  list of entity id's of the specs of inherited subprograms. Returns a\n+   --  null array if passed an Empty spec id. Note that the returned array\n    --  only includes subprograms and generic subprograms (and excludes any\n-   --  other inherited entities, in particular enumeration literals).\n+   --  other inherited entities, in particular enumeration literals). If\n+   --  No_Interfaces is True, only return inherited subprograms not coming\n+   --  from an interface. If Interfaces_Only is True, only return inherited\n+   --  subprograms from interfaces. Otherwise, subprograms inherited directly\n+   --  come first, starting with the closest ancestors, and are followed by\n+   --  subprograms inherited from interfaces. At most one of No_Interfaces\n+   --  and Interfaces_Only should be True.\n \n    function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n    --  Used to determine whether a call is dispatching, i.e. if is an"}]}