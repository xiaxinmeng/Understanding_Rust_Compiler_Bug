{"sha": "92456a4e5658e138e2cea79e390e3306b07685b0", "node_id": "C_kwDOANBUbNoAKDkyNDU2YTRlNTY1OGUxMzhlMmNlYTc5ZTM5MGUzMzA2YjA3Njg1YjA", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-08-31T14:14:47Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-10-20T12:35:52Z"}, "message": "libffi: Sync with libffi 3.4.2\n\nMerged commit: f9ea41683444ebe11cfa45b05223899764df28fb", "tree": {"sha": "6ef878e933b504a902035f1ae89510fde96a976d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ef878e933b504a902035f1ae89510fde96a976d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92456a4e5658e138e2cea79e390e3306b07685b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92456a4e5658e138e2cea79e390e3306b07685b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92456a4e5658e138e2cea79e390e3306b07685b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92456a4e5658e138e2cea79e390e3306b07685b0/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d738405e7fe62cc8eb9580948a6ea39005cd7170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d738405e7fe62cc8eb9580948a6ea39005cd7170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d738405e7fe62cc8eb9580948a6ea39005cd7170"}], "stats": {"total": 47198, "additions": 17051, "deletions": 30147}, "files": [{"sha": "f7d3833e78677816b69113970f13020e4507aa1b", "filename": "libffi/.gitattributes", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2F.gitattributes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2F.gitattributes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2F.gitattributes?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,4 @@\n+*\ttext=auto\n+\n+*.sln\ttext eol=crlf\n+*.vcxproj*\ttext eol=crlf"}, {"sha": "e4034b09af090e5d0fc55cc6500567672ceadb6c", "filename": "libffi/LICENSE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FLICENSE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FLICENSE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FLICENSE?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,4 +1,4 @@\n-libffi - Copyright (c) 1996-2014  Anthony Green, Red Hat, Inc and others.\n+libffi - Copyright (c) 1996-2021  Anthony Green, Red Hat, Inc and others.\n See source files for details.\n \n Permission is hereby granted, free of charge, to any person obtaining"}, {"sha": "d1d626e00859030061ed7b071e84f8f893d84d93", "filename": "libffi/LICENSE-BUILDTOOLS", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FLICENSE-BUILDTOOLS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FLICENSE-BUILDTOOLS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FLICENSE-BUILDTOOLS?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,353 @@\n+The libffi source distribution contains certain code that is not part\n+of libffi, and is only used as tooling to assist with the building and\n+testing of libffi.  This includes the msvcc.sh script used to wrap the\n+Microsoft compiler with GNU compatible command-line options,\n+make_sunver.pl, and the libffi test code distributed in the\n+testsuite/libffi.bhaible directory.  This code is distributed with\n+libffi for the purpose of convenience only, and libffi is in no way\n+derived from this code.\n+\n+msvcc.sh an testsuite/libffi.bhaible are both distributed under the\n+terms of the GNU GPL version 2, as below.\n+\n+\n+\n+                    GNU GENERAL PUBLIC LICENSE\n+                       Version 2, June 1991\n+\n+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n+ Everyone is permitted to copy and distribute verbatim copies\n+ of this license document, but changing it is not allowed.\n+\n+                            Preamble\n+\n+  The licenses for most software are designed to take away your\n+freedom to share and change it.  By contrast, the GNU General Public\n+License is intended to guarantee your freedom to share and change free\n+software--to make sure the software is free for all its users.  This\n+General Public License applies to most of the Free Software\n+Foundation's software and to any other program whose authors commit to\n+using it.  (Some other Free Software Foundation software is covered by\n+the GNU Lesser General Public License instead.)  You can apply it to\n+your programs, too.\n+\n+  When we speak of free software, we are referring to freedom, not\n+price.  Our General Public Licenses are designed to make sure that you\n+have the freedom to distribute copies of free software (and charge for\n+this service if you wish), that you receive source code or can get it\n+if you want it, that you can change the software or use pieces of it\n+in new free programs; and that you know you can do these things.\n+\n+  To protect your rights, we need to make restrictions that forbid\n+anyone to deny you these rights or to ask you to surrender the rights.\n+These restrictions translate to certain responsibilities for you if you\n+distribute copies of the software, or if you modify it.\n+\n+  For example, if you distribute copies of such a program, whether\n+gratis or for a fee, you must give the recipients all the rights that\n+you have.  You must make sure that they, too, receive or can get the\n+source code.  And you must show them these terms so they know their\n+rights.\n+\n+  We protect your rights with two steps: (1) copyright the software, and\n+(2) offer you this license which gives you legal permission to copy,\n+distribute and/or modify the software.\n+\n+  Also, for each author's protection and ours, we want to make certain\n+that everyone understands that there is no warranty for this free\n+software.  If the software is modified by someone else and passed on, we\n+want its recipients to know that what they have is not the original, so\n+that any problems introduced by others will not reflect on the original\n+authors' reputations.\n+\n+  Finally, any free program is threatened constantly by software\n+patents.  We wish to avoid the danger that redistributors of a free\n+program will individually obtain patent licenses, in effect making the\n+program proprietary.  To prevent this, we have made it clear that any\n+patent must be licensed for everyone's free use or not licensed at all.\n+\n+  The precise terms and conditions for copying, distribution and\n+modification follow.\n+\n+                    GNU GENERAL PUBLIC LICENSE\n+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n+\n+  0. This License applies to any program or other work which contains\n+a notice placed by the copyright holder saying it may be distributed\n+under the terms of this General Public License.  The \"Program\", below,\n+refers to any such program or work, and a \"work based on the Program\"\n+means either the Program or any derivative work under copyright law:\n+that is to say, a work containing the Program or a portion of it,\n+either verbatim or with modifications and/or translated into another\n+language.  (Hereinafter, translation is included without limitation in\n+the term \"modification\".)  Each licensee is addressed as \"you\".\n+\n+Activities other than copying, distribution and modification are not\n+covered by this License; they are outside its scope.  The act of\n+running the Program is not restricted, and the output from the Program\n+is covered only if its contents constitute a work based on the\n+Program (independent of having been made by running the Program).\n+Whether that is true depends on what the Program does.\n+\n+  1. You may copy and distribute verbatim copies of the Program's\n+source code as you receive it, in any medium, provided that you\n+conspicuously and appropriately publish on each copy an appropriate\n+copyright notice and disclaimer of warranty; keep intact all the\n+notices that refer to this License and to the absence of any warranty;\n+and give any other recipients of the Program a copy of this License\n+along with the Program.\n+\n+You may charge a fee for the physical act of transferring a copy, and\n+you may at your option offer warranty protection in exchange for a fee.\n+\n+  2. You may modify your copy or copies of the Program or any portion\n+of it, thus forming a work based on the Program, and copy and\n+distribute such modifications or work under the terms of Section 1\n+above, provided that you also meet all of these conditions:\n+\n+    a) You must cause the modified files to carry prominent notices\n+    stating that you changed the files and the date of any change.\n+\n+    b) You must cause any work that you distribute or publish, that in\n+    whole or in part contains or is derived from the Program or any\n+    part thereof, to be licensed as a whole at no charge to all third\n+    parties under the terms of this License.\n+\n+    c) If the modified program normally reads commands interactively\n+    when run, you must cause it, when started running for such\n+    interactive use in the most ordinary way, to print or display an\n+    announcement including an appropriate copyright notice and a\n+    notice that there is no warranty (or else, saying that you provide\n+    a warranty) and that users may redistribute the program under\n+    these conditions, and telling the user how to view a copy of this\n+    License.  (Exception: if the Program itself is interactive but\n+    does not normally print such an announcement, your work based on\n+    the Program is not required to print an announcement.)\n+\n+These requirements apply to the modified work as a whole.  If\n+identifiable sections of that work are not derived from the Program,\n+and can be reasonably considered independent and separate works in\n+themselves, then this License, and its terms, do not apply to those\n+sections when you distribute them as separate works.  But when you\n+distribute the same sections as part of a whole which is a work based\n+on the Program, the distribution of the whole must be on the terms of\n+this License, whose permissions for other licensees extend to the\n+entire whole, and thus to each and every part regardless of who wrote it.\n+\n+Thus, it is not the intent of this section to claim rights or contest\n+your rights to work written entirely by you; rather, the intent is to\n+exercise the right to control the distribution of derivative or\n+collective works based on the Program.\n+\n+In addition, mere aggregation of another work not based on the Program\n+with the Program (or with a work based on the Program) on a volume of\n+a storage or distribution medium does not bring the other work under\n+the scope of this License.\n+\n+  3. You may copy and distribute the Program (or a work based on it,\n+under Section 2) in object code or executable form under the terms of\n+Sections 1 and 2 above provided that you also do one of the following:\n+\n+    a) Accompany it with the complete corresponding machine-readable\n+    source code, which must be distributed under the terms of Sections\n+    1 and 2 above on a medium customarily used for software interchange; or,\n+\n+    b) Accompany it with a written offer, valid for at least three\n+    years, to give any third party, for a charge no more than your\n+    cost of physically performing source distribution, a complete\n+    machine-readable copy of the corresponding source code, to be\n+    distributed under the terms of Sections 1 and 2 above on a medium\n+    customarily used for software interchange; or,\n+\n+    c) Accompany it with the information you received as to the offer\n+    to distribute corresponding source code.  (This alternative is\n+    allowed only for noncommercial distribution and only if you\n+    received the program in object code or executable form with such\n+    an offer, in accord with Subsection b above.)\n+\n+The source code for a work means the preferred form of the work for\n+making modifications to it.  For an executable work, complete source\n+code means all the source code for all modules it contains, plus any\n+associated interface definition files, plus the scripts used to\n+control compilation and installation of the executable.  However, as a\n+special exception, the source code distributed need not include\n+anything that is normally distributed (in either source or binary\n+form) with the major components (compiler, kernel, and so on) of the\n+operating system on which the executable runs, unless that component\n+itself accompanies the executable.\n+\n+If distribution of executable or object code is made by offering\n+access to copy from a designated place, then offering equivalent\n+access to copy the source code from the same place counts as\n+distribution of the source code, even though third parties are not\n+compelled to copy the source along with the object code.\n+\n+  4. You may not copy, modify, sublicense, or distribute the Program\n+except as expressly provided under this License.  Any attempt\n+otherwise to copy, modify, sublicense or distribute the Program is\n+void, and will automatically terminate your rights under this License.\n+However, parties who have received copies, or rights, from you under\n+this License will not have their licenses terminated so long as such\n+parties remain in full compliance.\n+\n+  5. You are not required to accept this License, since you have not\n+signed it.  However, nothing else grants you permission to modify or\n+distribute the Program or its derivative works.  These actions are\n+prohibited by law if you do not accept this License.  Therefore, by\n+modifying or distributing the Program (or any work based on the\n+Program), you indicate your acceptance of this License to do so, and\n+all its terms and conditions for copying, distributing or modifying\n+the Program or works based on it.\n+\n+  6. Each time you redistribute the Program (or any work based on the\n+Program), the recipient automatically receives a license from the\n+original licensor to copy, distribute or modify the Program subject to\n+these terms and conditions.  You may not impose any further\n+restrictions on the recipients' exercise of the rights granted herein.\n+You are not responsible for enforcing compliance by third parties to\n+this License.\n+\n+  7. If, as a consequence of a court judgment or allegation of patent\n+infringement or for any other reason (not limited to patent issues),\n+conditions are imposed on you (whether by court order, agreement or\n+otherwise) that contradict the conditions of this License, they do not\n+excuse you from the conditions of this License.  If you cannot\n+distribute so as to satisfy simultaneously your obligations under this\n+License and any other pertinent obligations, then as a consequence you\n+may not distribute the Program at all.  For example, if a patent\n+license would not permit royalty-free redistribution of the Program by\n+all those who receive copies directly or indirectly through you, then\n+the only way you could satisfy both it and this License would be to\n+refrain entirely from distribution of the Program.\n+\n+If any portion of this section is held invalid or unenforceable under\n+any particular circumstance, the balance of the section is intended to\n+apply and the section as a whole is intended to apply in other\n+circumstances.\n+\n+It is not the purpose of this section to induce you to infringe any\n+patents or other property right claims or to contest validity of any\n+such claims; this section has the sole purpose of protecting the\n+integrity of the free software distribution system, which is\n+implemented by public license practices.  Many people have made\n+generous contributions to the wide range of software distributed\n+through that system in reliance on consistent application of that\n+system; it is up to the author/donor to decide if he or she is willing\n+to distribute software through any other system and a licensee cannot\n+impose that choice.\n+\n+This section is intended to make thoroughly clear what is believed to\n+be a consequence of the rest of this License.\n+\n+  8. If the distribution and/or use of the Program is restricted in\n+certain countries either by patents or by copyrighted interfaces, the\n+original copyright holder who places the Program under this License\n+may add an explicit geographical distribution limitation excluding\n+those countries, so that distribution is permitted only in or among\n+countries not thus excluded.  In such case, this License incorporates\n+the limitation as if written in the body of this License.\n+\n+  9. The Free Software Foundation may publish revised and/or new versions\n+of the General Public License from time to time.  Such new versions will\n+be similar in spirit to the present version, but may differ in detail to\n+address new problems or concerns.\n+\n+Each version is given a distinguishing version number.  If the Program\n+specifies a version number of this License which applies to it and \"any\n+later version\", you have the option of following the terms and conditions\n+either of that version or of any later version published by the Free\n+Software Foundation.  If the Program does not specify a version number of\n+this License, you may choose any version ever published by the Free Software\n+Foundation.\n+\n+  10. If you wish to incorporate parts of the Program into other free\n+programs whose distribution conditions are different, write to the author\n+to ask for permission.  For software which is copyrighted by the Free\n+Software Foundation, write to the Free Software Foundation; we sometimes\n+make exceptions for this.  Our decision will be guided by the two goals\n+of preserving the free status of all derivatives of our free software and\n+of promoting the sharing and reuse of software generally.\n+\n+                            NO WARRANTY\n+\n+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\n+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\n+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\n+PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\n+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\n+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\n+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\n+REPAIR OR CORRECTION.\n+\n+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\n+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\n+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\n+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\n+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\n+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\n+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGES.\n+\n+                     END OF TERMS AND CONDITIONS\n+\n+            How to Apply These Terms to Your New Programs\n+\n+  If you develop a new program, and you want it to be of the greatest\n+possible use to the public, the best way to achieve this is to make it\n+free software which everyone can redistribute and change under these terms.\n+\n+  To do so, attach the following notices to the program.  It is safest\n+to attach them to the start of each source file to most effectively\n+convey the exclusion of warranty; and each file should have at least\n+the \"copyright\" line and a pointer to where the full notice is found.\n+\n+    <one line to give the program's name and a brief idea of what it does.>\n+    Copyright (C) <year>  <name of author>\n+\n+    This program is free software; you can redistribute it and/or modify\n+    it under the terms of the GNU General Public License as published by\n+    the Free Software Foundation; either version 2 of the License, or\n+    (at your option) any later version.\n+\n+    This program is distributed in the hope that it will be useful,\n+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+    GNU General Public License for more details.\n+\n+    You should have received a copy of the GNU General Public License along\n+    with this program; if not, write to the Free Software Foundation, Inc.,\n+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Also add information on how to contact you by electronic and paper mail.\n+\n+If the program is interactive, make it output a short notice like this\n+when it starts in an interactive mode:\n+\n+    Gnomovision version 69, Copyright (C) year name of author\n+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n+    This is free software, and you are welcome to redistribute it\n+    under certain conditions; type `show c' for details.\n+\n+The hypothetical commands `show w' and `show c' should show the appropriate\n+parts of the General Public License.  Of course, the commands you use may\n+be called something other than `show w' and `show c'; they could even be\n+mouse-clicks or menu items--whatever suits your program.\n+\n+You should also get your employer (if you work as a programmer) or your\n+school, if any, to sign a \"copyright disclaimer\" for the program, if\n+necessary.  Here is a sample; alter the names:\n+\n+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n+  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n+\n+  <signature of Ty Coon>, 1 April 1989\n+  Ty Coon, President of Vice\n+\n+This General Public License does not permit incorporating your program into\n+proprietary programs.  If your program is a subroutine library, you may\n+consider it more useful to permit linking proprietary applications with the\n+library.  If this is what you want to do, use the GNU Lesser General\n+Public License instead of this License."}, {"sha": "fd0076e6509c950bfb4dab2ef9590348228df55b", "filename": "libffi/MERGE", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMERGE?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,4 @@\n+f9ea41683444ebe11cfa45b05223899764df28fb\n+\n+The first line of this file holds the git revision number of the\n+last merge done from the master library sources."}, {"sha": "1b18198ad18c789ae4b3e0d801ec0c43fc57e0a7", "filename": "libffi/Makefile.am", "status": "modified", "additions": 75, "deletions": 174, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,107 +1,31 @@\n ## Process this with automake to create Makefile.in\n \n-AUTOMAKE_OPTIONS = foreign subdir-objects info-in-builddir\n+AUTOMAKE_OPTIONS = foreign subdir-objects\n \n-ACLOCAL_AMFLAGS = -I .. -I ../config\n+ACLOCAL_AMFLAGS = -I m4\n \n SUBDIRS = include testsuite man\n+if BUILD_DOCS\n+## This hack is needed because it doesn't seem possible to make a\n+## conditional info_TEXINFOS in Automake.  At least Automake 1.14\n+## either gives errors -- if this attempted in the most\n+## straightforward way -- or simply unconditionally tries to build the\n+## info file.\n+SUBDIRS += doc\n+endif\n \n-EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj\t\t\t\\\n-\tChangeLog.libffi ChangeLog.libffi-3.1\t\t\t\t\\\n+EXTRA_DIST = LICENSE ChangeLog.old\t\t\t\t\t\\\n \tm4/libtool.m4 m4/lt~obsolete.m4\t\t\t\t\t\\\n \t m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4\t\t\t\\\n \t m4/ltversion.m4 src/debug.c msvcc.sh\t\t\t\t\\\n \tgenerate-darwin-source-and-headers.py\t\t\t\t\\\n \tlibffi.xcodeproj/project.pbxproj\t\t\t\t\\\n-\tlibtool-ldflags\n+\tlibtool-ldflags libtool-version configure.host README.md        \\\n+\tlibffi.map.in LICENSE-BUILDTOOLS msvc_build make_sunver.pl\t\n \n # local.exp is generated by configure\n DISTCLEANFILES = local.exp\n \n-# Automake Documentation:\n-# If your package has Texinfo files in many directories, you can use the\n-# variable TEXINFO_TEX to tell Automake where to find the canonical\n-# `texinfo.tex' for your package. The value of this variable should be\n-# the relative path from the current `Makefile.am' to `texinfo.tex'.\n-TEXINFO_TEX   = ../gcc/doc/include/texinfo.tex\n-\n-# Defines info, dvi, pdf and html targets\n-MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n-info_TEXINFOS = doc/libffi.texi\n-\n-# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n-if GENINSRC\n-STAMP_GENINSRC = stamp-geninsrc\n-else\n-STAMP_GENINSRC =\n-endif\n-\n-# AM_CONDITIONAL on configure check ACX_CHECK_PROG_VER([MAKEINFO])\n-if BUILD_INFO\n-STAMP_BUILD_INFO = stamp-build-info\n-else\n-STAMP_BUILD_INFO =\n-endif\n-\n-all-local: $(STAMP_GENINSRC)\n-\n-stamp-geninsrc: doc/libffi.info\n-\tcp -p $(top_builddir)/doc/libffi.info $(srcdir)/doc/libffi.info\n-\t@touch $@\n-\n-doc/libffi.info: $(STAMP_BUILD_INFO)\n-\n-stamp-build-info: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\t$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)/doc -o doc/libffi.info $(srcdir)/doc/libffi.texi\n-\t@touch $@\n-\n-CLEANFILES = $(STAMP_GENINSRC) $(STAMP_BUILD_INFO)\n-MAINTAINERCLEANFILES = $(srcdir)/doc/libffi.info\n-\n-## ################################################################\n-\n-##\n-## This section is for make and multilib madness.\n-##\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"mandir=$(mandir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n # Subdir rules rely on $(FLAGS_TO_PASS)\n FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n \n@@ -114,82 +38,62 @@ toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n \n libffi_la_SOURCES = src/prep_cif.c src/types.c \\\n-\t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n+\t\tsrc/raw_api.c src/java_raw_api.c src/closures.c \\\n+\t\tsrc/tramp.c\n \n if FFI_DEBUG\n libffi_la_SOURCES += src/debug.c\n endif\n \n-noinst_HEADERS = \\\n-\tsrc/aarch64/ffitarget.h src/aarch64/internal.h\t\t\t\\\n+noinst_HEADERS = src/aarch64/ffitarget.h src/aarch64/internal.h\t\t\\\n \tsrc/alpha/ffitarget.h src/alpha/internal.h\t\t\t\\\n-\tsrc/arc/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/arm/ffitarget.h src/arm/internal.h\t\t\t\t\\\n-\tsrc/avr32/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/bfin/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/cris/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/frv/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/arc/ffitarget.h src/arm/ffitarget.h src/arm/internal.h\t\\\n+\tsrc/avr32/ffitarget.h src/bfin/ffitarget.h\t\t\t\\\n+\tsrc/cris/ffitarget.h src/csky/ffitarget.h src/frv/ffitarget.h\t\\\n \tsrc/ia64/ffitarget.h src/ia64/ia64_flags.h\t\t\t\\\n-\tsrc/m32r/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/m68k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/m88k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/metag/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/microblaze/ffitarget.h\t\t\t\t\t\\\n-\tsrc/mips/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/moxie/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/nios2/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n-\tsrc/riscv/ffitarget.h\t\t\t  \t\t\t\\\n-\tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sparc/ffitarget.h src/sparc/internal.h\t\t\t\\\n-\tsrc/tile/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/vax/ffitarget.h\t\t\t\t\t\t\\\n+\tsrc/m32r/ffitarget.h src/m68k/ffitarget.h\t\t\t\\\n+\tsrc/m88k/ffitarget.h src/metag/ffitarget.h\t\t\t\\\n+\tsrc/microblaze/ffitarget.h src/mips/ffitarget.h\t\t\t\\\n+\tsrc/moxie/ffitarget.h src/nios2/ffitarget.h\t\t\t\\\n+\tsrc/or1k/ffitarget.h src/pa/ffitarget.h\t\t\t\t\\\n+\tsrc/powerpc/ffitarget.h src/powerpc/asm.h\t\t\t\\\n+\tsrc/powerpc/ffi_powerpc.h src/riscv/ffitarget.h\t\t\t\\\n+\tsrc/s390/ffitarget.h src/s390/internal.h src/sh/ffitarget.h\t\\\n+\tsrc/sh64/ffitarget.h src/sparc/ffitarget.h\t\t\t\\\n+\tsrc/sparc/internal.h src/tile/ffitarget.h src/vax/ffitarget.h\t\\\n \tsrc/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h\t\\\n-\tsrc/xtensa/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/dlmalloc.c\n-\n-EXTRA_libffi_la_SOURCES = \\\n-\tsrc/aarch64/ffi.c src/aarch64/sysv.S\t\t\t\t\\\n-\tsrc/alpha/ffi.c src/alpha/osf.S\t\t\t\t\t\\\n-\tsrc/arc/ffi.c src/arc/arcompact.S\t\t\t\t\\\n-\tsrc/arm/ffi.c src/arm/sysv.S\t\t\t\t\t\\\n-\tsrc/avr32/ffi.c src/avr32/sysv.S\t\t\t\t\\\n-\tsrc/bfin/ffi.c src/bfin/sysv.S\t\t\t\t\t\\\n-\tsrc/cris/ffi.c src/cris/sysv.S\t\t\t\t\t\\\n-\tsrc/frv/ffi.c src/frv/eabi.S\t\t\t\t\t\\\n-\tsrc/ia64/ffi.c src/ia64/unix.S\t\t\t\t\t\\\n-\tsrc/m32r/ffi.c src/m32r/sysv.S\t\t\t\t\t\\\n-\tsrc/m68k/ffi.c src/m68k/sysv.S\t\t\t\t\t\\\n-\tsrc/m88k/ffi.c src/m88k/obsd.S\t\t\t\t\t\\\n-\tsrc/metag/ffi.c src/metag/sysv.S\t\t\t\t\\\n-\tsrc/microblaze/ffi.c src/microblaze/sysv.S\t\t\t\\\n-\tsrc/mips/ffi.c src/mips/o32.S src/mips/n32.S\t\t\t\\\n-\tsrc/moxie/ffi.c src/moxie/eabi.S\t\t\t\t\\\n-\tsrc/nios2/ffi.c src/nios2/sysv.S\t\t\t\t\\\n-\tsrc/or1k/ffi.c src/or1k/sysv.S\t\t\t\t\t\\\n-\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S\t\t\t\\\n-\tsrc/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c \\\n-\t src/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n-\t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n-\t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n-\t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n-\tsrc/riscv/ffi.c src/riscv/sysv.S\t\t\t\t\\\n-\tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n-\tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n-\tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\\n-\tsrc/sparc/ffi.c src/sparc/ffi64.c src/sparc/v8.S src/sparc/v9.S\t\\\n-\tsrc/tile/ffi.c src/tile/tile.S\t\t\t\t\t\\\n-\tsrc/vax/ffi.c src/vax/elfbsd.S\t\t\t\t\t\\\n-\tsrc/x86/ffi.c src/x86/sysv.S\t\t\t\t\t\\\n-\t src/x86/ffiw64.c src/x86/win64.S \t\t\t\t\\\n-\t src/x86/ffi64.c src/x86/unix64.S\t\t\t\t\\\n-\t src/x86/darwin64.S src/x86/darwin.S\t\t\t\t\\\n-\t src/x86/darwin64_c.c src/x86/darwin_c.c\t\t\t\\\n-\tsrc/xtensa/ffi.c src/xtensa/sysv.S\n+\tsrc/x86/asmnames.h src/xtensa/ffitarget.h src/dlmalloc.c\t\\\n+\tsrc/kvx/ffitarget.h\n+\n+EXTRA_libffi_la_SOURCES = src/aarch64/ffi.c src/aarch64/sysv.S\t\t\\\n+\tsrc/aarch64/win64_armasm.S src/alpha/ffi.c src/alpha/osf.S\t\\\n+\tsrc/arc/ffi.c src/arc/arcompact.S src/arm/ffi.c\t\t\t\\\n+\tsrc/arm/sysv.S src/arm/ffi.c src/arm/sysv_msvc_arm32.S\t\t\\\n+\tsrc/avr32/ffi.c src/avr32/sysv.S src/bfin/ffi.c\t\t\t\\\n+\tsrc/bfin/sysv.S src/cris/ffi.c src/cris/sysv.S src/frv/ffi.c\t\\\n+\tsrc/csky/ffi.c src/csky/sysv.S src/frv/eabi.S src/ia64/ffi.c\t\\\n+\tsrc/ia64/unix.S src/m32r/ffi.c src/m32r/sysv.S src/m68k/ffi.c\t\\\n+\tsrc/m68k/sysv.S src/m88k/ffi.c src/m88k/obsd.S\t\t\t\\\n+\tsrc/metag/ffi.c src/metag/sysv.S src/microblaze/ffi.c\t\t\\\n+\tsrc/microblaze/sysv.S src/mips/ffi.c src/mips/o32.S\t\t\\\n+\tsrc/mips/n32.S src/moxie/ffi.c src/moxie/eabi.S\t\t\t\\\n+\tsrc/nios2/ffi.c src/nios2/sysv.S src/or1k/ffi.c\t\t\t\\\n+\tsrc/or1k/sysv.S src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S\t\\\n+\tsrc/powerpc/ffi.c src/powerpc/ffi_sysv.c\t\t\t\\\n+\tsrc/powerpc/ffi_linux64.c src/powerpc/sysv.S\t\t\t\\\n+\tsrc/powerpc/linux64.S src/powerpc/linux64_closure.S\t\t\\\n+\tsrc/powerpc/ppc_closure.S src/powerpc/aix.S\t\t\t\\\n+\tsrc/powerpc/darwin.S src/powerpc/aix_closure.S\t\t\t\\\n+\tsrc/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n+\tsrc/riscv/ffi.c src/riscv/sysv.S src/s390/ffi.c\t\t\t\\\n+\tsrc/s390/sysv.S src/sh/ffi.c src/sh/sysv.S src/sh64/ffi.c\t\\\n+\tsrc/sh64/sysv.S src/sparc/ffi.c src/sparc/ffi64.c\t\t\\\n+\tsrc/sparc/v8.S src/sparc/v9.S src/tile/ffi.c src/tile/tile.S\t\\\n+\tsrc/vax/ffi.c src/vax/elfbsd.S src/x86/ffi.c src/x86/sysv.S\t\\\n+\tsrc/x86/ffiw64.c src/x86/win64.S src/x86/ffi64.c\t\t\\\n+\tsrc/x86/unix64.S src/x86/sysv_intel.S src/x86/win64_intel.S\t\\\n+\tsrc/xtensa/ffi.c src/xtensa/sysv.S src/kvx/ffi.c\t\t\\\n+\tsrc/kvx/sysv.S\n \n TARGET_OBJ = @TARGET_OBJ@\n libffi_la_LIBADD = $(TARGET_OBJ)\n@@ -200,26 +104,26 @@ libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)\n libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n \n-LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/libtool-ldflags $(LDFLAGS))\n \n-AM_CFLAGS = -Wall -g -fexceptions\n+AM_CFLAGS =\n if FFI_DEBUG\n # Build debug. Define FFI_DEBUG on the commandline so that, when building with\n # MSVC, it can link against the debug CRT.\n AM_CFLAGS += -DFFI_DEBUG\n endif\n \n-if LIBAT_BUILD_VERSIONED_SHLIB\n-if LIBAT_BUILD_VERSIONED_SHLIB_GNU\n+if LIBFFI_BUILD_VERSIONED_SHLIB\n+if LIBFFI_BUILD_VERSIONED_SHLIB_GNU\n libffi_version_script = -Wl,--version-script,libffi.map\n libffi_version_dep = libffi.map\n endif\n-if LIBAT_BUILD_VERSIONED_SHLIB_SUN\n+if LIBFFI_BUILD_VERSIONED_SHLIB_SUN\n libffi_version_script = -Wl,-M,libffi.map-sun\n libffi_version_dep = libffi.map-sun\n-libffi.map-sun : libffi.map $(top_srcdir)/../contrib/make_sunver.pl \\\n-                $(libffi_la_OBJECTS) $(libffi_la_LIBADD)\n-\tperl $(top_srcdir)/../contrib/make_sunver.pl libffi.map \\\n+libffi.map-sun : libffi.map $(top_srcdir)/make_sunver.pl \\\n+\t\t $(libffi_la_OBJECTS) $(libffi_la_LIBADD)\n+\tperl $(top_srcdir)/make_sunver.pl libffi.map \\\n \t `echo $(libffi_la_OBJECTS) $(libffi_la_LIBADD) | \\\n \t    sed 's,\\([^/        ]*\\)\\.l\\([ao]\\),.libs/\\1.\\2,g'` \\\n \t > $@ || (rm -f $@ ; exit 1)\n@@ -231,20 +135,17 @@ endif\n libffi_version_info = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n \n libffi.map: $(top_srcdir)/libffi.map.in\n-\t$(COMPILE) -D$(TARGET) -E -x assembler-with-cpp -o $@ $<\n+\t$(COMPILE) -D$(TARGET) -DGENERATE_LIBFFI_MAP \\\n+\t -E -x assembler-with-cpp -o $@ $(top_srcdir)/libffi.map.in\n \n libffi_la_LDFLAGS = -no-undefined $(libffi_version_info) $(libffi_version_script) $(LTLDFLAGS) $(AM_LTLDFLAGS)\n libffi_la_DEPENDENCIES = $(libffi_la_LIBADD) $(libffi_version_dep)\n \n AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src\n AM_CCASFLAGS = $(AM_CPPFLAGS)\n \n-# Multilib support.  Automake should provide these on its own.\n-all-recursive: all-multi\n-install-recursive: install-multi\n-mostlyclean-recursive: mostlyclean-multi\n-clean-recursive: clean-multi\n-distclean-recursive: distclean-multi\n-maintainer-clean-recursive: maintainer-clean-multi\n+dist-hook:\n+\td=`(cd $(distdir); pwd)`; (cd doc; make pdf; cp *.pdf $$d/doc)\n+\tif [ -d $(top_srcdir)/.git ] ; then (cd $(top_srcdir); git log --no-decorate) ; else echo 'See git log for history.' ; fi > $(distdir)/ChangeLog\n+\ts=`awk '/was released on/{ print NR; exit}' $(top_srcdir)/README.md`; tail -n +$$(($$s-1)) $(top_srcdir)/README.md > $(distdir)/README.md\n \n-include $(top_srcdir)/../multilib.am"}, {"sha": "745bdd80777b4f6ca08c18ed698b6466200a4b08", "filename": "libffi/Makefile.in", "status": "removed", "additions": 0, "deletions": 1944, "changes": 1944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,1944 +0,0 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n-\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-\n-\n-VPATH = @srcdir@\n-am__is_gnu_make = { \\\n-  if test -z '$(MAKELEVEL)'; then \\\n-    false; \\\n-  elif test -n '$(MAKE_HOST)'; then \\\n-    true; \\\n-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n-    true; \\\n-  else \\\n-    false; \\\n-  fi; \\\n-}\n-am__make_running_with_option = \\\n-  case $${target_option-} in \\\n-      ?) ;; \\\n-      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n-              \"target option '$${target_option-}' specified\" >&2; \\\n-         exit 1;; \\\n-  esac; \\\n-  has_opt=no; \\\n-  sane_makeflags=$$MAKEFLAGS; \\\n-  if $(am__is_gnu_make); then \\\n-    sane_makeflags=$$MFLAGS; \\\n-  else \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        bs=\\\\; \\\n-        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n-          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n-    esac; \\\n-  fi; \\\n-  skip_next=no; \\\n-  strip_trailopt () \\\n-  { \\\n-    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n-  }; \\\n-  for flg in $$sane_makeflags; do \\\n-    test $$skip_next = yes && { skip_next=no; continue; }; \\\n-    case $$flg in \\\n-      *=*|--*) continue;; \\\n-        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n-      -*I?*) strip_trailopt 'I';; \\\n-        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n-      -*O?*) strip_trailopt 'O';; \\\n-        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n-      -*l?*) strip_trailopt 'l';; \\\n-      -[dEDm]) skip_next=yes;; \\\n-      -[JT]) skip_next=yes;; \\\n-    esac; \\\n-    case $$flg in \\\n-      *$$target_option*) has_opt=yes; break;; \\\n-    esac; \\\n-  done; \\\n-  test $$has_opt = yes\n-am__make_dryrun = (target_option=n; $(am__make_running_with_option))\n-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-@FFI_DEBUG_TRUE@am__append_1 = src/debug.c\n-# Build debug. Define FFI_DEBUG on the commandline so that, when building with\n-# MSVC, it can link against the debug CRT.\n-@FFI_DEBUG_TRUE@am__append_2 = -DFFI_DEBUG\n-subdir = .\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/asmcfi.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/toolexeclibdir.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps) $(srcdir)/doc/version.texi \\\n-\t$(srcdir)/doc/stamp-vti $(noinst_HEADERS)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = fficonfig.h\n-CONFIG_CLEAN_FILES = libffi.pc\n-CONFIG_CLEAN_VPATH_FILES =\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n-\t\"$(DESTDIR)$(pkgconfigdir)\"\n-LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n-am__DEPENDENCIES_1 =\n-am__dirstamp = $(am__leading_dot)dirstamp\n-@FFI_DEBUG_TRUE@am__objects_1 = src/debug.lo\n-am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-\tsrc/java_raw_api.lo src/closures.lo $(am__objects_1)\n-libffi_la_OBJECTS = $(am_libffi_la_OBJECTS)\n-AM_V_lt = $(am__v_lt_@AM_V@)\n-am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\n-am__v_lt_0 = --silent\n-am__v_lt_1 = \n-libffi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(libffi_la_LDFLAGS) $(LDFLAGS) -o $@\n-am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)\n-am__objects_2 = src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-\tsrc/java_raw_api.lo src/closures.lo $(am__objects_1)\n-am_libffi_convenience_la_OBJECTS = $(am__objects_2)\n-nodist_libffi_convenience_la_OBJECTS =\n-libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \\\n-\t$(nodist_libffi_convenience_la_OBJECTS)\n-AM_V_P = $(am__v_P_@AM_V@)\n-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n-am__v_P_0 = false\n-am__v_P_1 = :\n-AM_V_GEN = $(am__v_GEN_@AM_V@)\n-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\n-am__v_GEN_0 = @echo \"  GEN     \" $@;\n-am__v_GEN_1 = \n-AM_V_at = $(am__v_at_@AM_V@)\n-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\n-am__v_at_0 = @\n-am__v_at_1 = \n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n-LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CCASFLAGS) $(CCASFLAGS)\n-AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)\n-am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)\n-am__v_CPPAS_0 = @echo \"  CPPAS   \" $@;\n-am__v_CPPAS_1 = \n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CFLAGS) $(CFLAGS)\n-AM_V_CC = $(am__v_CC_@AM_V@)\n-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\n-am__v_CC_0 = @echo \"  CC      \" $@;\n-am__v_CC_1 = \n-CCLD = $(CC)\n-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-AM_V_CCLD = $(am__v_CCLD_@AM_V@)\n-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\n-am__v_CCLD_0 = @echo \"  CCLD    \" $@;\n-am__v_CCLD_1 = \n-SOURCES = $(libffi_la_SOURCES) $(EXTRA_libffi_la_SOURCES) \\\n-\t$(libffi_convenience_la_SOURCES) \\\n-\t$(EXTRA_libffi_convenience_la_SOURCES) \\\n-\t$(nodist_libffi_convenience_la_SOURCES)\n-AM_V_DVIPS = $(am__v_DVIPS_@AM_V@)\n-am__v_DVIPS_ = $(am__v_DVIPS_@AM_DEFAULT_V@)\n-am__v_DVIPS_0 = @echo \"  DVIPS   \" $@;\n-am__v_DVIPS_1 = \n-AM_V_MAKEINFO = $(am__v_MAKEINFO_@AM_V@)\n-am__v_MAKEINFO_ = $(am__v_MAKEINFO_@AM_DEFAULT_V@)\n-am__v_MAKEINFO_0 = @echo \"  MAKEINFO\" $@;\n-am__v_MAKEINFO_1 = \n-AM_V_INFOHTML = $(am__v_INFOHTML_@AM_V@)\n-am__v_INFOHTML_ = $(am__v_INFOHTML_@AM_DEFAULT_V@)\n-am__v_INFOHTML_0 = @echo \"  INFOHTML\" $@;\n-am__v_INFOHTML_1 = \n-AM_V_TEXI2DVI = $(am__v_TEXI2DVI_@AM_V@)\n-am__v_TEXI2DVI_ = $(am__v_TEXI2DVI_@AM_DEFAULT_V@)\n-am__v_TEXI2DVI_0 = @echo \"  TEXI2DVI\" $@;\n-am__v_TEXI2DVI_1 = \n-AM_V_TEXI2PDF = $(am__v_TEXI2PDF_@AM_V@)\n-am__v_TEXI2PDF_ = $(am__v_TEXI2PDF_@AM_DEFAULT_V@)\n-am__v_TEXI2PDF_0 = @echo \"  TEXI2PDF\" $@;\n-am__v_TEXI2PDF_1 = \n-AM_V_texinfo = $(am__v_texinfo_@AM_V@)\n-am__v_texinfo_ = $(am__v_texinfo_@AM_DEFAULT_V@)\n-am__v_texinfo_0 = -q\n-am__v_texinfo_1 = \n-AM_V_texidevnull = $(am__v_texidevnull_@AM_V@)\n-am__v_texidevnull_ = $(am__v_texidevnull_@AM_DEFAULT_V@)\n-am__v_texidevnull_0 = > /dev/null\n-am__v_texidevnull_1 = \n-INFO_DEPS = doc/libffi.info\n-am__TEXINFO_TEX_DIR = $(srcdir)/../gcc/doc/include\n-DVIS = doc/libffi.dvi\n-PDFS = doc/libffi.pdf\n-PSS = doc/libffi.ps\n-HTMLS = doc/libffi.html\n-TEXINFOS = doc/libffi.texi\n-TEXI2DVI = texi2dvi\n-TEXI2PDF = $(TEXI2DVI) --pdf --batch\n-MAKEINFOHTML = $(MAKEINFO) --html\n-AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)\n-DVIPS = dvips\n-RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \\\n-\tctags-recursive dvi-recursive html-recursive info-recursive \\\n-\tinstall-data-recursive install-dvi-recursive \\\n-\tinstall-exec-recursive install-html-recursive \\\n-\tinstall-info-recursive install-pdf-recursive \\\n-\tinstall-ps-recursive install-recursive installcheck-recursive \\\n-\tinstalldirs-recursive pdf-recursive ps-recursive \\\n-\ttags-recursive uninstall-recursive\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-DATA = $(pkgconfig_DATA)\n-HEADERS = $(noinst_HEADERS)\n-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n-  distclean-recursive maintainer-clean-recursive\n-am__recursive_targets = \\\n-  $(RECURSIVE_TARGETS) \\\n-  $(RECURSIVE_CLEAN_TARGETS) \\\n-  $(am__extra_recursive_targets)\n-AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \\\n-\tcscope\n-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \\\n-\t$(LISP)fficonfig.h.in\n-# Read a list of newline-separated strings from the standard input,\n-# and print each of them once, without duplicates.  Input order is\n-# *not* preserved.\n-am__uniquify_input = $(AWK) '\\\n-  BEGIN { nonempty = 0; } \\\n-  { items[$$0] = 1; nonempty = 1; } \\\n-  END { if (nonempty) { for (i in items) print i; }; } \\\n-'\n-# Make sure the list of sources is unique.  This is necessary because,\n-# e.g., the same source file might be shared among _SOURCES variables\n-# for different programs/libraries.\n-am__define_uniq_tagged_files = \\\n-  list='$(am__tagged_files)'; \\\n-  unique=`for i in $$list; do \\\n-    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-  done | $(am__uniquify_input)`\n-ETAGS = etags\n-CTAGS = ctags\n-CSCOPE = cscope\n-DIST_SUBDIRS = $(SUBDIRS)\n-ACLOCAL = @ACLOCAL@\n-ALLOCA = @ALLOCA@\n-AMTAR = @AMTAR@\n-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\n-AM_LTLDFLAGS = @AM_LTLDFLAGS@\n-AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCAS = @CCAS@\n-CCASDEPMODE = @CCASDEPMODE@\n-CCASFLAGS = @CCASFLAGS@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n-HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OPT_LDFLAGS = @OPT_LDFLAGS@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SECTION_LDFLAGS = @SECTION_LDFLAGS@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-TARGET = @TARGET@\n-TARGETDIR = @TARGETDIR@\n-TARGET_OBJ = @TARGET_OBJ@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-get_gcc_base_ver = @get_gcc_base_ver@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign subdir-objects info-in-builddir\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-SUBDIRS = include testsuite man\n-EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj\t\t\t\\\n-\tChangeLog.libffi ChangeLog.libffi-3.1\t\t\t\t\\\n-\tm4/libtool.m4 m4/lt~obsolete.m4\t\t\t\t\t\\\n-\t m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4\t\t\t\\\n-\t m4/ltversion.m4 src/debug.c msvcc.sh\t\t\t\t\\\n-\tgenerate-darwin-source-and-headers.py\t\t\t\t\\\n-\tlibffi.xcodeproj/project.pbxproj\t\t\t\t\\\n-\tlibtool-ldflags\n-\n-\n-# local.exp is generated by configure\n-DISTCLEANFILES = local.exp\n-\n-# Automake Documentation:\n-# If your package has Texinfo files in many directories, you can use the\n-# variable TEXINFO_TEX to tell Automake where to find the canonical\n-# `texinfo.tex' for your package. The value of this variable should be\n-# the relative path from the current `Makefile.am' to `texinfo.tex'.\n-TEXINFO_TEX = ../gcc/doc/include/texinfo.tex\n-\n-# Defines info, dvi, pdf and html targets\n-MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n-info_TEXINFOS = doc/libffi.texi\n-@GENINSRC_FALSE@STAMP_GENINSRC = \n-\n-# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n-@GENINSRC_TRUE@STAMP_GENINSRC = stamp-geninsrc\n-@BUILD_INFO_FALSE@STAMP_BUILD_INFO = \n-\n-# AM_CONDITIONAL on configure check ACX_CHECK_PROG_VER([MAKEINFO])\n-@BUILD_INFO_TRUE@STAMP_BUILD_INFO = stamp-build-info\n-CLEANFILES = $(STAMP_GENINSRC) $(STAMP_BUILD_INFO)\n-MAINTAINERCLEANFILES = $(srcdir)/doc/libffi.info\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"mandir=$(mandir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-\n-# Subdir rules rely on $(FLAGS_TO_PASS)\n-FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n-MAKEOVERRIDES = \n-pkgconfigdir = $(libdir)/pkgconfig\n-pkgconfig_DATA = libffi.pc\n-toolexeclib_LTLIBRARIES = libffi.la\n-noinst_LTLIBRARIES = libffi_convenience.la\n-libffi_la_SOURCES = src/prep_cif.c src/types.c src/raw_api.c \\\n-\tsrc/java_raw_api.c src/closures.c $(am__append_1)\n-noinst_HEADERS = \\\n-\tsrc/aarch64/ffitarget.h src/aarch64/internal.h\t\t\t\\\n-\tsrc/alpha/ffitarget.h src/alpha/internal.h\t\t\t\\\n-\tsrc/arc/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/arm/ffitarget.h src/arm/internal.h\t\t\t\t\\\n-\tsrc/avr32/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/bfin/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/cris/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/frv/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/ia64/ffitarget.h src/ia64/ia64_flags.h\t\t\t\\\n-\tsrc/m32r/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/m68k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/m88k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/metag/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/microblaze/ffitarget.h\t\t\t\t\t\\\n-\tsrc/mips/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/moxie/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/nios2/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/or1k/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/pa/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/powerpc/ffitarget.h src/powerpc/asm.h src/powerpc/ffi_powerpc.h \\\n-\tsrc/riscv/ffitarget.h\t\t\t  \t\t\t\\\n-\tsrc/s390/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sh/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sh64/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/sparc/ffitarget.h src/sparc/internal.h\t\t\t\\\n-\tsrc/tile/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/vax/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h\t\\\n-\tsrc/xtensa/ffitarget.h\t\t\t\t\t\t\\\n-\tsrc/dlmalloc.c\n-\n-EXTRA_libffi_la_SOURCES = \\\n-\tsrc/aarch64/ffi.c src/aarch64/sysv.S\t\t\t\t\\\n-\tsrc/alpha/ffi.c src/alpha/osf.S\t\t\t\t\t\\\n-\tsrc/arc/ffi.c src/arc/arcompact.S\t\t\t\t\\\n-\tsrc/arm/ffi.c src/arm/sysv.S\t\t\t\t\t\\\n-\tsrc/avr32/ffi.c src/avr32/sysv.S\t\t\t\t\\\n-\tsrc/bfin/ffi.c src/bfin/sysv.S\t\t\t\t\t\\\n-\tsrc/cris/ffi.c src/cris/sysv.S\t\t\t\t\t\\\n-\tsrc/frv/ffi.c src/frv/eabi.S\t\t\t\t\t\\\n-\tsrc/ia64/ffi.c src/ia64/unix.S\t\t\t\t\t\\\n-\tsrc/m32r/ffi.c src/m32r/sysv.S\t\t\t\t\t\\\n-\tsrc/m68k/ffi.c src/m68k/sysv.S\t\t\t\t\t\\\n-\tsrc/m88k/ffi.c src/m88k/obsd.S\t\t\t\t\t\\\n-\tsrc/metag/ffi.c src/metag/sysv.S\t\t\t\t\\\n-\tsrc/microblaze/ffi.c src/microblaze/sysv.S\t\t\t\\\n-\tsrc/mips/ffi.c src/mips/o32.S src/mips/n32.S\t\t\t\\\n-\tsrc/moxie/ffi.c src/moxie/eabi.S\t\t\t\t\\\n-\tsrc/nios2/ffi.c src/nios2/sysv.S\t\t\t\t\\\n-\tsrc/or1k/ffi.c src/or1k/sysv.S\t\t\t\t\t\\\n-\tsrc/pa/ffi.c src/pa/linux.S src/pa/hpux32.S\t\t\t\\\n-\tsrc/powerpc/ffi.c src/powerpc/ffi_sysv.c src/powerpc/ffi_linux64.c \\\n-\t src/powerpc/sysv.S src/powerpc/linux64.S\t\t\t\\\n-\t src/powerpc/linux64_closure.S src/powerpc/ppc_closure.S\t\\\n-\t src/powerpc/aix.S src/powerpc/darwin.S src/powerpc/aix_closure.S \\\n-\t src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c\t\t\\\n-\tsrc/riscv/ffi.c src/riscv/sysv.S\t\t\t\t\\\n-\tsrc/s390/ffi.c src/s390/sysv.S\t\t\t\t\t\\\n-\tsrc/sh/ffi.c src/sh/sysv.S\t\t\t\t\t\\\n-\tsrc/sh64/ffi.c src/sh64/sysv.S\t\t\t\t\t\\\n-\tsrc/sparc/ffi.c src/sparc/ffi64.c src/sparc/v8.S src/sparc/v9.S\t\\\n-\tsrc/tile/ffi.c src/tile/tile.S\t\t\t\t\t\\\n-\tsrc/vax/ffi.c src/vax/elfbsd.S\t\t\t\t\t\\\n-\tsrc/x86/ffi.c src/x86/sysv.S\t\t\t\t\t\\\n-\t src/x86/ffiw64.c src/x86/win64.S \t\t\t\t\\\n-\t src/x86/ffi64.c src/x86/unix64.S\t\t\t\t\\\n-\t src/x86/darwin64.S src/x86/darwin.S\t\t\t\t\\\n-\t src/x86/darwin64_c.c src/x86/darwin_c.c\t\t\t\\\n-\tsrc/xtensa/ffi.c src/xtensa/sysv.S\n-\n-libffi_la_LIBADD = $(TARGET_OBJ)\n-libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n-EXTRA_libffi_convenience_la_SOURCES = $(EXTRA_libffi_la_SOURCES)\n-libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)\n-libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)\n-nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)\n-LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n-AM_CFLAGS = -Wall -g -fexceptions $(am__append_2)\n-@LIBAT_BUILD_VERSIONED_SHLIB_FALSE@libffi_version_script = \n-@LIBAT_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_script = -Wl,--version-script,libffi.map\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_script = -Wl,-M,libffi.map-sun\n-@LIBAT_BUILD_VERSIONED_SHLIB_FALSE@libffi_version_dep = \n-@LIBAT_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_dep = libffi.map\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_dep = libffi.map-sun\n-libffi_version_info = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n-libffi_la_LDFLAGS = -no-undefined $(libffi_version_info) $(libffi_version_script) $(LTLDFLAGS) $(AM_LTLDFLAGS)\n-libffi_la_DEPENDENCIES = $(libffi_la_LIBADD) $(libffi_version_dep)\n-AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src\n-AM_CCASFLAGS = $(AM_CPPFLAGS)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-all: fficonfig.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n-\n-.SUFFIXES:\n-.SUFFIXES: .S .c .dvi .lo .o .obj .ps\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/../multilib.am $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-$(top_srcdir)/../multilib.am $(am__empty):\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-fficonfig.h: stamp-h1\n-\t@test -f $@ || rm -f stamp-h1\n-\t@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1\n-\n-stamp-h1: $(srcdir)/fficonfig.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status fficonfig.h\n-$(srcdir)/fficonfig.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f fficonfig.h stamp-h1\n-libffi.pc: $(top_builddir)/config.status $(srcdir)/libffi.pc.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-\n-clean-noinstLTLIBRARIES:\n-\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n-\t@list='$(noinst_LTLIBRARIES)'; \\\n-\tlocs=`for p in $$list; do echo $$p; done | \\\n-\t      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \\\n-\t      sort -u`; \\\n-\ttest -z \"$$locs\" || { \\\n-\t  echo rm -f $${locs}; \\\n-\t  rm -f $${locs}; \\\n-\t}\n-\n-install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tlist2=; for p in $$list; do \\\n-\t  if test -f $$p; then \\\n-\t    list2=\"$$list2 $$p\"; \\\n-\t  else :; fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n-\t}\n-\n-uninstall-toolexeclibLTLIBRARIES:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n-\tdone\n-\n-clean-toolexeclibLTLIBRARIES:\n-\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; \\\n-\tlocs=`for p in $$list; do echo $$p; done | \\\n-\t      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \\\n-\t      sort -u`; \\\n-\ttest -z \"$$locs\" || { \\\n-\t  echo rm -f $${locs}; \\\n-\t  rm -f $${locs}; \\\n-\t}\n-src/$(am__dirstamp):\n-\t@$(MKDIR_P) src\n-\t@: > src/$(am__dirstamp)\n-src/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/$(DEPDIR)\n-\t@: > src/$(DEPDIR)/$(am__dirstamp)\n-src/prep_cif.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/types.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/java_raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/closures.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/debug.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/$(am__dirstamp):\n-\t@$(MKDIR_P) src/aarch64\n-\t@: > src/aarch64/$(am__dirstamp)\n-src/aarch64/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/aarch64/$(DEPDIR)\n-\t@: > src/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/ffi.lo: src/aarch64/$(am__dirstamp) \\\n-\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/aarch64/sysv.lo: src/aarch64/$(am__dirstamp) \\\n-\tsrc/aarch64/$(DEPDIR)/$(am__dirstamp)\n-src/alpha/$(am__dirstamp):\n-\t@$(MKDIR_P) src/alpha\n-\t@: > src/alpha/$(am__dirstamp)\n-src/alpha/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/alpha/$(DEPDIR)\n-\t@: > src/alpha/$(DEPDIR)/$(am__dirstamp)\n-src/alpha/ffi.lo: src/alpha/$(am__dirstamp) \\\n-\tsrc/alpha/$(DEPDIR)/$(am__dirstamp)\n-src/alpha/osf.lo: src/alpha/$(am__dirstamp) \\\n-\tsrc/alpha/$(DEPDIR)/$(am__dirstamp)\n-src/arc/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arc\n-\t@: > src/arc/$(am__dirstamp)\n-src/arc/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arc/$(DEPDIR)\n-\t@: > src/arc/$(DEPDIR)/$(am__dirstamp)\n-src/arc/ffi.lo: src/arc/$(am__dirstamp) \\\n-\tsrc/arc/$(DEPDIR)/$(am__dirstamp)\n-src/arc/arcompact.lo: src/arc/$(am__dirstamp) \\\n-\tsrc/arc/$(DEPDIR)/$(am__dirstamp)\n-src/arm/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arm\n-\t@: > src/arm/$(am__dirstamp)\n-src/arm/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/arm/$(DEPDIR)\n-\t@: > src/arm/$(DEPDIR)/$(am__dirstamp)\n-src/arm/ffi.lo: src/arm/$(am__dirstamp) \\\n-\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n-src/arm/sysv.lo: src/arm/$(am__dirstamp) \\\n-\tsrc/arm/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/$(am__dirstamp):\n-\t@$(MKDIR_P) src/avr32\n-\t@: > src/avr32/$(am__dirstamp)\n-src/avr32/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/avr32/$(DEPDIR)\n-\t@: > src/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/ffi.lo: src/avr32/$(am__dirstamp) \\\n-\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/avr32/sysv.lo: src/avr32/$(am__dirstamp) \\\n-\tsrc/avr32/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/$(am__dirstamp):\n-\t@$(MKDIR_P) src/bfin\n-\t@: > src/bfin/$(am__dirstamp)\n-src/bfin/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/bfin/$(DEPDIR)\n-\t@: > src/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/ffi.lo: src/bfin/$(am__dirstamp) \\\n-\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/bfin/sysv.lo: src/bfin/$(am__dirstamp) \\\n-\tsrc/bfin/$(DEPDIR)/$(am__dirstamp)\n-src/cris/$(am__dirstamp):\n-\t@$(MKDIR_P) src/cris\n-\t@: > src/cris/$(am__dirstamp)\n-src/cris/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/cris/$(DEPDIR)\n-\t@: > src/cris/$(DEPDIR)/$(am__dirstamp)\n-src/cris/ffi.lo: src/cris/$(am__dirstamp) \\\n-\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n-src/cris/sysv.lo: src/cris/$(am__dirstamp) \\\n-\tsrc/cris/$(DEPDIR)/$(am__dirstamp)\n-src/frv/$(am__dirstamp):\n-\t@$(MKDIR_P) src/frv\n-\t@: > src/frv/$(am__dirstamp)\n-src/frv/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/frv/$(DEPDIR)\n-\t@: > src/frv/$(DEPDIR)/$(am__dirstamp)\n-src/frv/ffi.lo: src/frv/$(am__dirstamp) \\\n-\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n-src/frv/eabi.lo: src/frv/$(am__dirstamp) \\\n-\tsrc/frv/$(DEPDIR)/$(am__dirstamp)\n-src/ia64/$(am__dirstamp):\n-\t@$(MKDIR_P) src/ia64\n-\t@: > src/ia64/$(am__dirstamp)\n-src/ia64/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/ia64/$(DEPDIR)\n-\t@: > src/ia64/$(DEPDIR)/$(am__dirstamp)\n-src/ia64/ffi.lo: src/ia64/$(am__dirstamp) \\\n-\tsrc/ia64/$(DEPDIR)/$(am__dirstamp)\n-src/ia64/unix.lo: src/ia64/$(am__dirstamp) \\\n-\tsrc/ia64/$(DEPDIR)/$(am__dirstamp)\n-src/m32r/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m32r\n-\t@: > src/m32r/$(am__dirstamp)\n-src/m32r/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m32r/$(DEPDIR)\n-\t@: > src/m32r/$(DEPDIR)/$(am__dirstamp)\n-src/m32r/ffi.lo: src/m32r/$(am__dirstamp) \\\n-\tsrc/m32r/$(DEPDIR)/$(am__dirstamp)\n-src/m32r/sysv.lo: src/m32r/$(am__dirstamp) \\\n-\tsrc/m32r/$(DEPDIR)/$(am__dirstamp)\n-src/m68k/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m68k\n-\t@: > src/m68k/$(am__dirstamp)\n-src/m68k/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m68k/$(DEPDIR)\n-\t@: > src/m68k/$(DEPDIR)/$(am__dirstamp)\n-src/m68k/ffi.lo: src/m68k/$(am__dirstamp) \\\n-\tsrc/m68k/$(DEPDIR)/$(am__dirstamp)\n-src/m68k/sysv.lo: src/m68k/$(am__dirstamp) \\\n-\tsrc/m68k/$(DEPDIR)/$(am__dirstamp)\n-src/m88k/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m88k\n-\t@: > src/m88k/$(am__dirstamp)\n-src/m88k/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/m88k/$(DEPDIR)\n-\t@: > src/m88k/$(DEPDIR)/$(am__dirstamp)\n-src/m88k/ffi.lo: src/m88k/$(am__dirstamp) \\\n-\tsrc/m88k/$(DEPDIR)/$(am__dirstamp)\n-src/m88k/obsd.lo: src/m88k/$(am__dirstamp) \\\n-\tsrc/m88k/$(DEPDIR)/$(am__dirstamp)\n-src/metag/$(am__dirstamp):\n-\t@$(MKDIR_P) src/metag\n-\t@: > src/metag/$(am__dirstamp)\n-src/metag/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/metag/$(DEPDIR)\n-\t@: > src/metag/$(DEPDIR)/$(am__dirstamp)\n-src/metag/ffi.lo: src/metag/$(am__dirstamp) \\\n-\tsrc/metag/$(DEPDIR)/$(am__dirstamp)\n-src/metag/sysv.lo: src/metag/$(am__dirstamp) \\\n-\tsrc/metag/$(DEPDIR)/$(am__dirstamp)\n-src/microblaze/$(am__dirstamp):\n-\t@$(MKDIR_P) src/microblaze\n-\t@: > src/microblaze/$(am__dirstamp)\n-src/microblaze/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/microblaze/$(DEPDIR)\n-\t@: > src/microblaze/$(DEPDIR)/$(am__dirstamp)\n-src/microblaze/ffi.lo: src/microblaze/$(am__dirstamp) \\\n-\tsrc/microblaze/$(DEPDIR)/$(am__dirstamp)\n-src/microblaze/sysv.lo: src/microblaze/$(am__dirstamp) \\\n-\tsrc/microblaze/$(DEPDIR)/$(am__dirstamp)\n-src/mips/$(am__dirstamp):\n-\t@$(MKDIR_P) src/mips\n-\t@: > src/mips/$(am__dirstamp)\n-src/mips/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/mips/$(DEPDIR)\n-\t@: > src/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/ffi.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/o32.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/mips/n32.lo: src/mips/$(am__dirstamp) \\\n-\tsrc/mips/$(DEPDIR)/$(am__dirstamp)\n-src/moxie/$(am__dirstamp):\n-\t@$(MKDIR_P) src/moxie\n-\t@: > src/moxie/$(am__dirstamp)\n-src/moxie/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/moxie/$(DEPDIR)\n-\t@: > src/moxie/$(DEPDIR)/$(am__dirstamp)\n-src/moxie/ffi.lo: src/moxie/$(am__dirstamp) \\\n-\tsrc/moxie/$(DEPDIR)/$(am__dirstamp)\n-src/moxie/eabi.lo: src/moxie/$(am__dirstamp) \\\n-\tsrc/moxie/$(DEPDIR)/$(am__dirstamp)\n-src/nios2/$(am__dirstamp):\n-\t@$(MKDIR_P) src/nios2\n-\t@: > src/nios2/$(am__dirstamp)\n-src/nios2/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/nios2/$(DEPDIR)\n-\t@: > src/nios2/$(DEPDIR)/$(am__dirstamp)\n-src/nios2/ffi.lo: src/nios2/$(am__dirstamp) \\\n-\tsrc/nios2/$(DEPDIR)/$(am__dirstamp)\n-src/nios2/sysv.lo: src/nios2/$(am__dirstamp) \\\n-\tsrc/nios2/$(DEPDIR)/$(am__dirstamp)\n-src/or1k/$(am__dirstamp):\n-\t@$(MKDIR_P) src/or1k\n-\t@: > src/or1k/$(am__dirstamp)\n-src/or1k/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/or1k/$(DEPDIR)\n-\t@: > src/or1k/$(DEPDIR)/$(am__dirstamp)\n-src/or1k/ffi.lo: src/or1k/$(am__dirstamp) \\\n-\tsrc/or1k/$(DEPDIR)/$(am__dirstamp)\n-src/or1k/sysv.lo: src/or1k/$(am__dirstamp) \\\n-\tsrc/or1k/$(DEPDIR)/$(am__dirstamp)\n-src/pa/$(am__dirstamp):\n-\t@$(MKDIR_P) src/pa\n-\t@: > src/pa/$(am__dirstamp)\n-src/pa/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/pa/$(DEPDIR)\n-\t@: > src/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/linux.lo: src/pa/$(am__dirstamp) \\\n-\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n-src/pa/hpux32.lo: src/pa/$(am__dirstamp) \\\n-\tsrc/pa/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/$(am__dirstamp):\n-\t@$(MKDIR_P) src/powerpc\n-\t@: > src/powerpc/$(am__dirstamp)\n-src/powerpc/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/powerpc/$(DEPDIR)\n-\t@: > src/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ffi.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ffi_sysv.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ffi_linux64.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/sysv.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/linux64.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/linux64_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ppc_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/aix.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/darwin.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/aix_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/darwin_closure.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/powerpc/ffi_darwin.lo: src/powerpc/$(am__dirstamp) \\\n-\tsrc/powerpc/$(DEPDIR)/$(am__dirstamp)\n-src/riscv/$(am__dirstamp):\n-\t@$(MKDIR_P) src/riscv\n-\t@: > src/riscv/$(am__dirstamp)\n-src/riscv/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/riscv/$(DEPDIR)\n-\t@: > src/riscv/$(DEPDIR)/$(am__dirstamp)\n-src/riscv/ffi.lo: src/riscv/$(am__dirstamp) \\\n-\tsrc/riscv/$(DEPDIR)/$(am__dirstamp)\n-src/riscv/sysv.lo: src/riscv/$(am__dirstamp) \\\n-\tsrc/riscv/$(DEPDIR)/$(am__dirstamp)\n-src/s390/$(am__dirstamp):\n-\t@$(MKDIR_P) src/s390\n-\t@: > src/s390/$(am__dirstamp)\n-src/s390/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/s390/$(DEPDIR)\n-\t@: > src/s390/$(DEPDIR)/$(am__dirstamp)\n-src/s390/ffi.lo: src/s390/$(am__dirstamp) \\\n-\tsrc/s390/$(DEPDIR)/$(am__dirstamp)\n-src/s390/sysv.lo: src/s390/$(am__dirstamp) \\\n-\tsrc/s390/$(DEPDIR)/$(am__dirstamp)\n-src/sh/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sh\n-\t@: > src/sh/$(am__dirstamp)\n-src/sh/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sh/$(DEPDIR)\n-\t@: > src/sh/$(DEPDIR)/$(am__dirstamp)\n-src/sh/ffi.lo: src/sh/$(am__dirstamp) src/sh/$(DEPDIR)/$(am__dirstamp)\n-src/sh/sysv.lo: src/sh/$(am__dirstamp) \\\n-\tsrc/sh/$(DEPDIR)/$(am__dirstamp)\n-src/sh64/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sh64\n-\t@: > src/sh64/$(am__dirstamp)\n-src/sh64/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sh64/$(DEPDIR)\n-\t@: > src/sh64/$(DEPDIR)/$(am__dirstamp)\n-src/sh64/ffi.lo: src/sh64/$(am__dirstamp) \\\n-\tsrc/sh64/$(DEPDIR)/$(am__dirstamp)\n-src/sh64/sysv.lo: src/sh64/$(am__dirstamp) \\\n-\tsrc/sh64/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sparc\n-\t@: > src/sparc/$(am__dirstamp)\n-src/sparc/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/sparc/$(DEPDIR)\n-\t@: > src/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/ffi.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/ffi64.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/v8.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/sparc/v9.lo: src/sparc/$(am__dirstamp) \\\n-\tsrc/sparc/$(DEPDIR)/$(am__dirstamp)\n-src/tile/$(am__dirstamp):\n-\t@$(MKDIR_P) src/tile\n-\t@: > src/tile/$(am__dirstamp)\n-src/tile/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/tile/$(DEPDIR)\n-\t@: > src/tile/$(DEPDIR)/$(am__dirstamp)\n-src/tile/ffi.lo: src/tile/$(am__dirstamp) \\\n-\tsrc/tile/$(DEPDIR)/$(am__dirstamp)\n-src/tile/tile.lo: src/tile/$(am__dirstamp) \\\n-\tsrc/tile/$(DEPDIR)/$(am__dirstamp)\n-src/vax/$(am__dirstamp):\n-\t@$(MKDIR_P) src/vax\n-\t@: > src/vax/$(am__dirstamp)\n-src/vax/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/vax/$(DEPDIR)\n-\t@: > src/vax/$(DEPDIR)/$(am__dirstamp)\n-src/vax/ffi.lo: src/vax/$(am__dirstamp) \\\n-\tsrc/vax/$(DEPDIR)/$(am__dirstamp)\n-src/vax/elfbsd.lo: src/vax/$(am__dirstamp) \\\n-\tsrc/vax/$(DEPDIR)/$(am__dirstamp)\n-src/x86/$(am__dirstamp):\n-\t@$(MKDIR_P) src/x86\n-\t@: > src/x86/$(am__dirstamp)\n-src/x86/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/x86/$(DEPDIR)\n-\t@: > src/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/ffi.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/sysv.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/ffiw64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/win64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/ffi64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/unix64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin64.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin64_c.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/x86/darwin_c.lo: src/x86/$(am__dirstamp) \\\n-\tsrc/x86/$(DEPDIR)/$(am__dirstamp)\n-src/xtensa/$(am__dirstamp):\n-\t@$(MKDIR_P) src/xtensa\n-\t@: > src/xtensa/$(am__dirstamp)\n-src/xtensa/$(DEPDIR)/$(am__dirstamp):\n-\t@$(MKDIR_P) src/xtensa/$(DEPDIR)\n-\t@: > src/xtensa/$(DEPDIR)/$(am__dirstamp)\n-src/xtensa/ffi.lo: src/xtensa/$(am__dirstamp) \\\n-\tsrc/xtensa/$(DEPDIR)/$(am__dirstamp)\n-src/xtensa/sysv.lo: src/xtensa/$(am__dirstamp) \\\n-\tsrc/xtensa/$(DEPDIR)/$(am__dirstamp)\n-\n-libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) $(EXTRA_libffi_la_DEPENDENCIES) \n-\t$(AM_V_CCLD)$(libffi_la_LINK) -rpath $(toolexeclibdir) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)\n-\n-libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) $(EXTRA_libffi_convenience_la_DEPENDENCIES) \n-\t$(AM_V_CCLD)$(LINK)  $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\t-rm -f src/*.$(OBJEXT)\n-\t-rm -f src/*.lo\n-\t-rm -f src/aarch64/*.$(OBJEXT)\n-\t-rm -f src/aarch64/*.lo\n-\t-rm -f src/alpha/*.$(OBJEXT)\n-\t-rm -f src/alpha/*.lo\n-\t-rm -f src/arc/*.$(OBJEXT)\n-\t-rm -f src/arc/*.lo\n-\t-rm -f src/arm/*.$(OBJEXT)\n-\t-rm -f src/arm/*.lo\n-\t-rm -f src/avr32/*.$(OBJEXT)\n-\t-rm -f src/avr32/*.lo\n-\t-rm -f src/bfin/*.$(OBJEXT)\n-\t-rm -f src/bfin/*.lo\n-\t-rm -f src/cris/*.$(OBJEXT)\n-\t-rm -f src/cris/*.lo\n-\t-rm -f src/frv/*.$(OBJEXT)\n-\t-rm -f src/frv/*.lo\n-\t-rm -f src/ia64/*.$(OBJEXT)\n-\t-rm -f src/ia64/*.lo\n-\t-rm -f src/m32r/*.$(OBJEXT)\n-\t-rm -f src/m32r/*.lo\n-\t-rm -f src/m68k/*.$(OBJEXT)\n-\t-rm -f src/m68k/*.lo\n-\t-rm -f src/m88k/*.$(OBJEXT)\n-\t-rm -f src/m88k/*.lo\n-\t-rm -f src/metag/*.$(OBJEXT)\n-\t-rm -f src/metag/*.lo\n-\t-rm -f src/microblaze/*.$(OBJEXT)\n-\t-rm -f src/microblaze/*.lo\n-\t-rm -f src/mips/*.$(OBJEXT)\n-\t-rm -f src/mips/*.lo\n-\t-rm -f src/moxie/*.$(OBJEXT)\n-\t-rm -f src/moxie/*.lo\n-\t-rm -f src/nios2/*.$(OBJEXT)\n-\t-rm -f src/nios2/*.lo\n-\t-rm -f src/or1k/*.$(OBJEXT)\n-\t-rm -f src/or1k/*.lo\n-\t-rm -f src/pa/*.$(OBJEXT)\n-\t-rm -f src/pa/*.lo\n-\t-rm -f src/powerpc/*.$(OBJEXT)\n-\t-rm -f src/powerpc/*.lo\n-\t-rm -f src/riscv/*.$(OBJEXT)\n-\t-rm -f src/riscv/*.lo\n-\t-rm -f src/s390/*.$(OBJEXT)\n-\t-rm -f src/s390/*.lo\n-\t-rm -f src/sh/*.$(OBJEXT)\n-\t-rm -f src/sh/*.lo\n-\t-rm -f src/sh64/*.$(OBJEXT)\n-\t-rm -f src/sh64/*.lo\n-\t-rm -f src/sparc/*.$(OBJEXT)\n-\t-rm -f src/sparc/*.lo\n-\t-rm -f src/tile/*.$(OBJEXT)\n-\t-rm -f src/tile/*.lo\n-\t-rm -f src/vax/*.$(OBJEXT)\n-\t-rm -f src/vax/*.lo\n-\t-rm -f src/x86/*.$(OBJEXT)\n-\t-rm -f src/x86/*.lo\n-\t-rm -f src/xtensa/*.$(OBJEXT)\n-\t-rm -f src/xtensa/*.lo\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/closures.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/debug.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/java_raw_api.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/prep_cif.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/raw_api.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/types.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/osf.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/arcompact.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/bfin/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/bfin/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/frv/$(DEPDIR)/eabi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/frv/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/ia64/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/ia64/$(DEPDIR)/unix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m32r/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m32r/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/obsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/n32.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/o32.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/eabi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/hpux32.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/aix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/aix_closure.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/darwin.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/darwin_closure.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_darwin.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_linux64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64_closure.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ppc_closure.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sh/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sh/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v8.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v9.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/tile.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/elfbsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin64_c.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/darwin_c.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffiw64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/sysv.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/unix64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/ffi.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/sysv.Plo@am__quote@\n-\n-.S.o:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n-@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCCAS_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<\n-\n-.S.obj:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.obj$$||'`;\\\n-@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\\\n-@am__fastdepCCAS_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.S.lo:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.lo$$||'`;\\\n-@am__fastdepCCAS_TRUE@\t$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCCAS_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Plo\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.o$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.obj$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\t$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\\.lo$$||'`;\\\n-@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\\\n-@am__fastdepCC_TRUE@\t$(am__mv) $$depbase.Tpo $$depbase.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\t-rm -rf src/.libs src/_libs\n-\t-rm -rf src/aarch64/.libs src/aarch64/_libs\n-\t-rm -rf src/alpha/.libs src/alpha/_libs\n-\t-rm -rf src/arc/.libs src/arc/_libs\n-\t-rm -rf src/arm/.libs src/arm/_libs\n-\t-rm -rf src/avr32/.libs src/avr32/_libs\n-\t-rm -rf src/bfin/.libs src/bfin/_libs\n-\t-rm -rf src/cris/.libs src/cris/_libs\n-\t-rm -rf src/frv/.libs src/frv/_libs\n-\t-rm -rf src/ia64/.libs src/ia64/_libs\n-\t-rm -rf src/m32r/.libs src/m32r/_libs\n-\t-rm -rf src/m68k/.libs src/m68k/_libs\n-\t-rm -rf src/m88k/.libs src/m88k/_libs\n-\t-rm -rf src/metag/.libs src/metag/_libs\n-\t-rm -rf src/microblaze/.libs src/microblaze/_libs\n-\t-rm -rf src/mips/.libs src/mips/_libs\n-\t-rm -rf src/moxie/.libs src/moxie/_libs\n-\t-rm -rf src/nios2/.libs src/nios2/_libs\n-\t-rm -rf src/or1k/.libs src/or1k/_libs\n-\t-rm -rf src/pa/.libs src/pa/_libs\n-\t-rm -rf src/powerpc/.libs src/powerpc/_libs\n-\t-rm -rf src/riscv/.libs src/riscv/_libs\n-\t-rm -rf src/s390/.libs src/s390/_libs\n-\t-rm -rf src/sh/.libs src/sh/_libs\n-\t-rm -rf src/sh64/.libs src/sh64/_libs\n-\t-rm -rf src/sparc/.libs src/sparc/_libs\n-\t-rm -rf src/tile/.libs src/tile/_libs\n-\t-rm -rf src/vax/.libs src/vax/_libs\n-\t-rm -rf src/x86/.libs src/x86/_libs\n-\t-rm -rf src/xtensa/.libs src/xtensa/_libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-doc/$(am__dirstamp):\n-\t@$(MKDIR_P) doc\n-\t@: > doc/$(am__dirstamp)\n-\n-doc/libffi.dvi: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\t$(AM_V_TEXI2DVI)TEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc' \\\n-\t$(TEXI2DVI) $(AM_V_texinfo) --build-dir=$(@:.dvi=.t2d) -o $@ $(AM_V_texidevnull) \\\n-\t`test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi\n-\n-doc/libffi.pdf: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\t$(AM_V_TEXI2PDF)TEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc' \\\n-\t$(TEXI2PDF) $(AM_V_texinfo) --build-dir=$(@:.pdf=.t2p) -o $@ $(AM_V_texidevnull) \\\n-\t`test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi\n-\n-doc/libffi.html: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\t$(AM_V_MAKEINFO)rm -rf $(@:.html=.htp)\n-\t$(AM_V_at)if $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I doc -I $(srcdir)/doc \\\n-\t -o $(@:.html=.htp) `test -f 'doc/libffi.texi' || echo '$(srcdir)/'`doc/libffi.texi; \\\n-\tthen \\\n-\t  rm -rf $@ && mv $(@:.html=.htp) $@; \\\n-\telse \\\n-\t  rm -rf $(@:.html=.htp); exit 1; \\\n-\tfi\n-$(srcdir)/doc/version.texi: @MAINTAINER_MODE_TRUE@ $(srcdir)/doc/stamp-vti\n-$(srcdir)/doc/stamp-vti: doc/libffi.texi $(top_srcdir)/configure\n-\t@test -f doc/$(am__dirstamp) || $(MAKE) $(AM_MAKEFLAGS) doc/$(am__dirstamp)\n-\t@(dir=.; test -f ./doc/libffi.texi || dir=$(srcdir); \\\n-\tset `$(SHELL) $(srcdir)/mdate-sh $$dir/doc/libffi.texi`; \\\n-\techo \"@set UPDATED $$1 $$2 $$3\"; \\\n-\techo \"@set UPDATED-MONTH $$2 $$3\"; \\\n-\techo \"@set EDITION $(VERSION)\"; \\\n-\techo \"@set VERSION $(VERSION)\") > vti.tmp$$$$ && \\\n-\t(cmp -s vti.tmp$$$$ $(srcdir)/doc/version.texi \\\n-\t  || (echo \"Updating $(srcdir)/doc/version.texi\" && \\\n-\t      cp vti.tmp$$$$ $(srcdir)/doc/version.texi.tmp$$$$ && \\\n-\t      mv $(srcdir)/doc/version.texi.tmp$$$$ $(srcdir)/doc/version.texi)) && \\\n-\trm -f vti.tmp$$$$ $(srcdir)/doc/version.texi.$$$$\n-\t@cp $(srcdir)/doc/version.texi $@\n-\n-mostlyclean-vti:\n-\t-rm -f vti.tmp* $(srcdir)/doc/version.texi.tmp*\n-\n-maintainer-clean-vti:\n-@MAINTAINER_MODE_TRUE@\t-rm -f $(srcdir)/doc/stamp-vti $(srcdir)/doc/version.texi\n-.dvi.ps:\n-\t$(AM_V_DVIPS)TEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n-\t$(DVIPS) $(AM_V_texinfo) -o $@ $<\n-\n-uninstall-dvi-am:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(DVIS)'; test -n \"$(dvidir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" rm -f '$(DESTDIR)$(dvidir)/$$f'\"; \\\n-\t  rm -f \"$(DESTDIR)$(dvidir)/$$f\"; \\\n-\tdone\n-\n-uninstall-html-am:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(HTMLS)'; test -n \"$(htmldir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" rm -rf '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t  rm -rf \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-\tdone\n-\n-uninstall-info-am:\n-\t@$(PRE_UNINSTALL)\n-\t@if test -d '$(DESTDIR)$(infodir)' && $(am__can_run_installinfo); then \\\n-\t  list='$(INFO_DEPS)'; \\\n-\t  for file in $$list; do \\\n-\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n-\t    if install-info --info-dir=\"$(DESTDIR)$(infodir)\" --remove \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n-\t    then :; else test ! -f \"$(DESTDIR)$(infodir)/$$relfile\" || exit 1; fi; \\\n-\t  done; \\\n-\telse :; fi\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(INFO_DEPS)'; \\\n-\tfor file in $$list; do \\\n-\t  relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t  relfile_i=`echo \"$$relfile\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  (if test -d \"$(DESTDIR)$(infodir)\" && cd \"$(DESTDIR)$(infodir)\"; then \\\n-\t     echo \" cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]\"; \\\n-\t     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \\\n-\t   else :; fi); \\\n-\tdone\n-\n-uninstall-pdf-am:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(PDFS)'; test -n \"$(pdfdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" rm -f '$(DESTDIR)$(pdfdir)/$$f'\"; \\\n-\t  rm -f \"$(DESTDIR)$(pdfdir)/$$f\"; \\\n-\tdone\n-\n-uninstall-ps-am:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(PSS)'; test -n \"$(psdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" rm -f '$(DESTDIR)$(psdir)/$$f'\"; \\\n-\t  rm -f \"$(DESTDIR)$(psdir)/$$f\"; \\\n-\tdone\n-\n-dist-info: $(INFO_DEPS)\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(INFO_DEPS)'; \\\n-\tfor base in $$list; do \\\n-\t  case $$base in \\\n-\t    $(srcdir)/*) base=`echo \"$$base\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$base; then d=.; else d=$(srcdir); fi; \\\n-\t  base_i=`echo \"$$base\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  for file in $$d/$$base $$d/$$base-[0-9] $$d/$$base-[0-9][0-9] $$d/$$base_i[0-9] $$d/$$base_i[0-9][0-9]; do \\\n-\t    if test -f $$file; then \\\n-\t      relfile=`expr \"$$file\" : \"$$d/\\(.*\\)\"`; \\\n-\t      test -f \"$(distdir)/$$relfile\" || \\\n-\t\tcp -p $$file \"$(distdir)/$$relfile\"; \\\n-\t    else :; fi; \\\n-\t  done; \\\n-\tdone\n-\n-mostlyclean-aminfo:\n-\t-rm -rf doc/libffi.t2d doc/libffi.t2p\n-\n-clean-aminfo:\n-\t-test -z \"doc/libffi.dvi doc/libffi.pdf doc/libffi.ps doc/libffi.html\" \\\n-\t|| rm -rf doc/libffi.dvi doc/libffi.pdf doc/libffi.ps doc/libffi.html\n-\n-maintainer-clean-aminfo:\n-\t@list='$(INFO_DEPS)'; for i in $$list; do \\\n-\t  i_i=`echo \"$$i\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  echo \" rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]\"; \\\n-\t  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \\\n-\tdone\n-install-pkgconfigDATA: $(pkgconfig_DATA)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(pkgconfig_DATA)'; test -n \"$(pkgconfigdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(pkgconfigdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(pkgconfigdir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(pkgconfigdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(pkgconfigdir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-pkgconfigDATA:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(pkgconfig_DATA)'; test -n \"$(pkgconfigdir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(pkgconfigdir)'; $(am__uninstall_files_from_dir)\n-\n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run 'make' without going through this Makefile.\n-# To change the values of 'make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in 'config.status', edit 'config.status'\n-#     (which will cause the Makefiles to be regenerated when you run 'make');\n-# (2) otherwise, pass the desired values on the 'make' command line.\n-$(am__recursive_targets):\n-\t@fail=; \\\n-\tif $(am__make_keepgoing); then \\\n-\t  failcom='fail=yes'; \\\n-\telse \\\n-\t  failcom='exit 1'; \\\n-\tfi; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tcase \"$@\" in \\\n-\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n-\t  *) list='$(SUBDIRS)' ;; \\\n-\tesac; \\\n-\tfor subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-ID: $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); mkid -fID $$unique\n-tags: tags-recursive\n-TAGS: tags\n-\n-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n-\t  include_option=--etags-include; \\\n-\t  empty_fix=.; \\\n-\telse \\\n-\t  include_option=--include; \\\n-\t  empty_fix=; \\\n-\tfi; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test ! -f $$subdir/TAGS || \\\n-\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\t$(am__define_uniq_tagged_files); \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: ctags-recursive\n-\n-CTAGS: ctags\n-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-cscope: cscope.files\n-\ttest ! -s cscope.files \\\n-\t  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)\n-clean-cscope:\n-\t-rm -f cscope.files\n-cscope.files: clean-cscope cscopelist\n-cscopelist: cscopelist-recursive\n-\n-cscopelist-am: $(am__tagged_files)\n-\tlist='$(am__tagged_files)'; \\\n-\tcase \"$(srcdir)\" in \\\n-\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n-\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n-\tesac; \\\n-\tfor i in $$list; do \\\n-\t  if test -f \"$$i\"; then \\\n-\t    echo \"$(subdir)/$$i\"; \\\n-\t  else \\\n-\t    echo \"$$sdir/$$i\"; \\\n-\t  fi; \\\n-\tdone >> $(top_builddir)/cscope.files\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\t-rm -f cscope.out cscope.in.out cscope.po.out cscope.files\n-check-am: all-am\n-check: check-recursive\n-all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) $(DATA) $(HEADERS) \\\n-\t\tfficonfig.h all-local\n-installdirs: installdirs-recursive\n-installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(pkgconfigdir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-recursive\n-install-exec: install-exec-recursive\n-install-data: install-data-recursive\n-uninstall: uninstall-recursive\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-recursive\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\t-rm -f doc/$(am__dirstamp)\n-\t-rm -f src/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/$(am__dirstamp)\n-\t-rm -f src/aarch64/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/aarch64/$(am__dirstamp)\n-\t-rm -f src/alpha/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/alpha/$(am__dirstamp)\n-\t-rm -f src/arc/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/arc/$(am__dirstamp)\n-\t-rm -f src/arm/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/arm/$(am__dirstamp)\n-\t-rm -f src/avr32/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/avr32/$(am__dirstamp)\n-\t-rm -f src/bfin/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/bfin/$(am__dirstamp)\n-\t-rm -f src/cris/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/cris/$(am__dirstamp)\n-\t-rm -f src/frv/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/frv/$(am__dirstamp)\n-\t-rm -f src/ia64/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/ia64/$(am__dirstamp)\n-\t-rm -f src/m32r/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/m32r/$(am__dirstamp)\n-\t-rm -f src/m68k/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/m68k/$(am__dirstamp)\n-\t-rm -f src/m88k/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/m88k/$(am__dirstamp)\n-\t-rm -f src/metag/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/metag/$(am__dirstamp)\n-\t-rm -f src/microblaze/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/microblaze/$(am__dirstamp)\n-\t-rm -f src/mips/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/mips/$(am__dirstamp)\n-\t-rm -f src/moxie/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/moxie/$(am__dirstamp)\n-\t-rm -f src/nios2/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/nios2/$(am__dirstamp)\n-\t-rm -f src/or1k/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/or1k/$(am__dirstamp)\n-\t-rm -f src/pa/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/pa/$(am__dirstamp)\n-\t-rm -f src/powerpc/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/powerpc/$(am__dirstamp)\n-\t-rm -f src/riscv/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/riscv/$(am__dirstamp)\n-\t-rm -f src/s390/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/s390/$(am__dirstamp)\n-\t-rm -f src/sh/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/sh/$(am__dirstamp)\n-\t-rm -f src/sh64/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/sh64/$(am__dirstamp)\n-\t-rm -f src/sparc/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/sparc/$(am__dirstamp)\n-\t-rm -f src/tile/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/tile/$(am__dirstamp)\n-\t-rm -f src/vax/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/vax/$(am__dirstamp)\n-\t-rm -f src/x86/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/x86/$(am__dirstamp)\n-\t-rm -f src/xtensa/$(DEPDIR)/$(am__dirstamp)\n-\t-rm -f src/xtensa/$(am__dirstamp)\n-\t-test -z \"$(DISTCLEANFILES)\" || rm -f $(DISTCLEANFILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-\t-test -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n-clean: clean-recursive\n-\n-clean-am: clean-aminfo clean-generic clean-libtool clean-local \\\n-\tclean-noinstLTLIBRARIES clean-toolexeclibLTLIBRARIES \\\n-\tmostlyclean-am\n-\n-distclean: distclean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/riscv/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-local distclean-tags\n-\n-dvi: dvi-recursive\n-\n-dvi-am: $(DVIS)\n-\n-html: html-recursive\n-\n-html-am: $(HTMLS)\n-\n-info: info-recursive\n-\n-info-am: $(INFO_DEPS)\n-\n-install-data-am: install-info-am install-pkgconfigDATA\n-\n-install-dvi: install-dvi-recursive\n-\n-install-dvi-am: $(DVIS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(DVIS)'; test -n \"$(dvidir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(dvidir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(dvidir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(dvidir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(dvidir)\" || exit $$?; \\\n-\tdone\n-install-exec-am: install-exec-local install-toolexeclibLTLIBRARIES\n-\n-install-html: install-html-recursive\n-\n-install-html-am: $(HTMLS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(HTMLS)'; list2=; test -n \"$(htmldir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(htmldir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(htmldir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\" || test -d \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  $(am__strip_dir) \\\n-\t  d2=$$d$$p; \\\n-\t  if test -d \"$$d2\"; then \\\n-\t    echo \" $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(MKDIR_P) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-\t    echo \" $(INSTALL_DATA) '$$d2'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-\t    $(INSTALL_DATA) \"$$d2\"/* \"$(DESTDIR)$(htmldir)/$$f\" || exit $$?; \\\n-\t  else \\\n-\t    list2=\"$$list2 $$d2\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { echo \"$$list2\" | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(htmldir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(htmldir)\" || exit $$?; \\\n-\tdone; }\n-install-info: install-info-recursive\n-\n-install-info-am: $(INFO_DEPS)\n-\t@$(NORMAL_INSTALL)\n-\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n-\tlist='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(infodir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(infodir)\" || exit 1; \\\n-\tfi; \\\n-\tfor file in $$list; do \\\n-\t  case $$file in \\\n-\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-\t  esac; \\\n-\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  file_i=`echo \"$$file\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n-\t  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \\\n-\t               $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \\\n-\t    if test -f $$ifile; then \\\n-\t      echo \"$$ifile\"; \\\n-\t    else : ; fi; \\\n-\t  done; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(infodir)\" || exit $$?; done\n-\t@$(POST_INSTALL)\n-\t@if $(am__can_run_installinfo); then \\\n-\t  list='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n-\t  for file in $$list; do \\\n-\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n-\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'\";\\\n-\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(infodir)/$$relfile\" || :;\\\n-\t  done; \\\n-\telse : ; fi\n-install-man:\n-\n-install-pdf: install-pdf-recursive\n-\n-install-pdf-am: $(PDFS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(PDFS)'; test -n \"$(pdfdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(pdfdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(pdfdir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(pdfdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(pdfdir)\" || exit $$?; done\n-install-ps: install-ps-recursive\n-\n-install-ps-am: $(PSS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(PSS)'; test -n \"$(psdir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(psdir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(psdir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(psdir)'\"; \\\n-\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(psdir)\" || exit $$?; done\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf src/$(DEPDIR) src/aarch64/$(DEPDIR) src/alpha/$(DEPDIR) src/arc/$(DEPDIR) src/arm/$(DEPDIR) src/avr32/$(DEPDIR) src/bfin/$(DEPDIR) src/cris/$(DEPDIR) src/frv/$(DEPDIR) src/ia64/$(DEPDIR) src/m32r/$(DEPDIR) src/m68k/$(DEPDIR) src/m88k/$(DEPDIR) src/metag/$(DEPDIR) src/microblaze/$(DEPDIR) src/mips/$(DEPDIR) src/moxie/$(DEPDIR) src/nios2/$(DEPDIR) src/or1k/$(DEPDIR) src/pa/$(DEPDIR) src/powerpc/$(DEPDIR) src/riscv/$(DEPDIR) src/s390/$(DEPDIR) src/sh/$(DEPDIR) src/sh64/$(DEPDIR) src/sparc/$(DEPDIR) src/tile/$(DEPDIR) src/vax/$(DEPDIR) src/x86/$(DEPDIR) src/xtensa/$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n-\tmaintainer-clean-generic maintainer-clean-local \\\n-\tmaintainer-clean-vti\n-\n-mostlyclean: mostlyclean-recursive\n-\n-mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool mostlyclean-local \\\n-\tmostlyclean-vti\n-\n-pdf: pdf-recursive\n-\n-pdf-am: $(PDFS)\n-\n-ps: ps-recursive\n-\n-ps-am: $(PSS)\n-\n-uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n-\tuninstall-pdf-am uninstall-pkgconfigDATA uninstall-ps-am \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.MAKE: $(am__recursive_targets) all install-am install-strip\n-\n-.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am all-local \\\n-\tam--refresh check check-am clean clean-aminfo clean-cscope \\\n-\tclean-generic clean-libtool clean-local \\\n-\tclean-noinstLTLIBRARIES clean-toolexeclibLTLIBRARIES cscope \\\n-\tcscopelist-am ctags ctags-am dist-info distclean \\\n-\tdistclean-compile distclean-generic distclean-hdr \\\n-\tdistclean-libtool distclean-local distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-exec-local install-html \\\n-\tinstall-html-am install-info install-info-am install-man \\\n-\tinstall-pdf install-pdf-am install-pkgconfigDATA install-ps \\\n-\tinstall-ps-am install-strip install-toolexeclibLTLIBRARIES \\\n-\tinstallcheck installcheck-am installdirs installdirs-am \\\n-\tmaintainer-clean maintainer-clean-aminfo \\\n-\tmaintainer-clean-generic maintainer-clean-local \\\n-\tmaintainer-clean-vti mostlyclean mostlyclean-aminfo \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-local mostlyclean-vti pdf pdf-am ps ps-am tags \\\n-\ttags-am uninstall uninstall-am uninstall-dvi-am \\\n-\tuninstall-html-am uninstall-info-am uninstall-pdf-am \\\n-\tuninstall-pkgconfigDATA uninstall-ps-am \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.PRECIOUS: Makefile\n-\n-\n-all-local: $(STAMP_GENINSRC)\n-\n-stamp-geninsrc: doc/libffi.info\n-\tcp -p $(top_builddir)/doc/libffi.info $(srcdir)/doc/libffi.info\n-\t@touch $@\n-\n-doc/libffi.info: $(STAMP_BUILD_INFO)\n-\n-stamp-build-info: doc/libffi.texi $(srcdir)/doc/version.texi doc/$(am__dirstamp)\n-\t$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)/doc -o doc/libffi.info $(srcdir)/doc/libffi.texi\n-\t@touch $@\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libffi.map-sun : libffi.map $(top_srcdir)/../contrib/make_sunver.pl \\\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@                $(libffi_la_OBJECTS) $(libffi_la_LIBADD)\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\tperl $(top_srcdir)/../contrib/make_sunver.pl libffi.map \\\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t `echo $(libffi_la_OBJECTS) $(libffi_la_LIBADD) | \\\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t    sed 's,\\([^/        ]*\\)\\.l\\([ao]\\),.libs/\\1.\\2,g'` \\\n-@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t > $@ || (rm -f $@ ; exit 1)\n-\n-libffi.map: $(top_srcdir)/libffi.map.in\n-\t$(COMPILE) -D$(TARGET) -E -x assembler-with-cpp -o $@ $<\n-\n-# Multilib support.  Automake should provide these on its own.\n-all-recursive: all-multi\n-install-recursive: install-multi\n-mostlyclean-recursive: mostlyclean-multi\n-clean-recursive: clean-multi\n-distclean-recursive: distclean-multi\n-maintainer-clean-recursive: maintainer-clean-multi\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-.MAKE .PHONY: all-multi clean-multi distclean-multi install-am \\\n-\t      install-multi maintainer-clean-multi mostlyclean-multi\n-\n-install-exec-local: install-multi\n-\n-all-local: all-multi\n-mostlyclean-local: mostlyclean-multi\n-clean-local: clean-multi\n-distclean-local: distclean-multi\n-maintainer-clean-local: maintainer-clean-multi\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "c072101789172f89c84ed9a7fc24fc1607fc0634", "filename": "libffi/README", "status": "removed", "additions": 0, "deletions": 450, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,450 +0,0 @@\n-Status\n-======\n-\n-libffi-4?? was released on TBD.  Check the libffi web\n-page for updates: <URL:http://sourceware.org/libffi/>.\n-\n-\n-What is libffi?\n-===============\n-\n-Compilers for high level languages generate code that follow certain\n-conventions. These conventions are necessary, in part, for separate\n-compilation to work. One such convention is the \"calling\n-convention\". The \"calling convention\" is essentially a set of\n-assumptions made by the compiler about where function arguments will\n-be found on entry to a function. A \"calling convention\" also specifies\n-where the return value for a function is found.\n-\n-Some programs may not know at the time of compilation what arguments\n-are to be passed to a function. For instance, an interpreter may be\n-told at run-time about the number and types of arguments used to call\n-a given function. Libffi can be used in such programs to provide a\n-bridge from the interpreter program to compiled code.\n-\n-The libffi library provides a portable, high level programming\n-interface to various calling conventions. This allows a programmer to\n-call any function specified by a call interface description at run\n-time.  \n-\n-FFI stands for Foreign Function Interface.  A foreign function\n-interface is the popular name for the interface that allows code\n-written in one language to call code written in another language. The\n-libffi library really only provides the lowest, machine dependent\n-layer of a fully featured foreign function interface. A layer must\n-exist above libffi that handles type conversions for values passed\n-between the two languages.\n-\n-\n-Supported Platforms\n-===================\n-\n-Libffi has been ported to many different platforms.\n-For specific configuration details and testing status, please\n-refer to the wiki page here:\n-\n- http://www.moxielogic.org/wiki/index.php?title=Libffi_3.2\n-\n-At the time of release, the following basic configurations have been\n-tested:\n-\n-|-----------------+------------------+-------------------------|\n-| Architecture    | Operating System | Compiler                |\n-|-----------------+------------------+-------------------------|\n-| AArch64 (ARM64) | iOS              | Clang                   |\n-| AArch64         | Linux            | GCC                     |\n-| Alpha           | Linux            | GCC                     |\n-| Alpha           | Tru64            | GCC                     |\n-| ARC             | Linux            | GCC                     |\n-| ARM             | Linux            | GCC                     |\n-| ARM             | iOS              | GCC                     |\n-| AVR32           | Linux            | GCC                     |\n-| Blackfin        | uClinux          | GCC                     |\n-| HPPA            | HPUX             | GCC                     |\n-| IA-64           | Linux            | GCC                     |\n-| M68K            | FreeMiNT         | GCC                     |\n-| M68K            | Linux            | GCC                     |\n-| M68K            | RTEMS            | GCC                     |\n-| M88K            | OpenBSD/mvme88k  | GCC                     |\n-| Meta            | Linux            | GCC                     |\n-| MicroBlaze      | Linux            | GCC                     |\n-| MIPS            | IRIX             | GCC                     |\n-| MIPS            | Linux            | GCC                     |\n-| MIPS            | RTEMS            | GCC                     |\n-| MIPS64          | Linux            | GCC                     |\n-| Moxie           | Bare metal       | GCC                     |\n-| Nios II         | Linux            | GCC                     |\n-| OpenRISC        | Linux            | GCC                     |\n-| PowerPC 32-bit  | AIX              | IBM XL C                |\n-| PowerPC 64-bit  | AIX              | IBM XL C                |\n-| PowerPC         | AMIGA            | GCC                     |\n-| PowerPC         | Linux            | GCC                     |\n-| PowerPC         | Mac OSX          | GCC                     |\n-| PowerPC         | FreeBSD          | GCC                     |\n-| PowerPC 64-bit  | FreeBSD          | GCC                     |\n-| PowerPC 64-bit  | Linux ELFv1      | GCC                     |\n-| PowerPC 64-bit  | Linux ELFv2      | GCC                     |\n-| S390            | Linux            | GCC                     |\n-| S390X           | Linux            | GCC                     |\n-| SPARC           | Linux            | GCC                     |\n-| SPARC           | Solaris          | GCC                     |\n-| SPARC           | Solaris          | Oracle Solaris Studio C |\n-| SPARC64         | Linux            | GCC                     |\n-| SPARC64         | FreeBSD          | GCC                     |\n-| SPARC64         | Solaris          | Oracle Solaris Studio C |\n-| TILE-Gx/TILEPro | Linux            | GCC                     |\n-| VAX             | OpenBSD/vax      | GCC                     |\n-| X86             | FreeBSD          | GCC                     |\n-| X86             | GNU HURD         | GCC                     |\n-| X86             | Interix          | GCC                     |\n-| X86             | kFreeBSD         | GCC                     |\n-| X86             | Linux            | GCC                     |\n-| X86             | Mac OSX          | GCC                     |\n-| X86             | OpenBSD          | GCC                     |\n-| X86             | OS/2             | GCC                     |\n-| X86             | Solaris          | GCC                     |\n-| X86             | Solaris          | Oracle Solaris Studio C |\n-| X86             | Windows/Cygwin   | GCC                     |\n-| X86             | Windows/MingW    | GCC                     |\n-| X86-64          | FreeBSD          | GCC                     |\n-| X86-64          | Linux            | GCC                     |\n-| X86-64          | Linux/x32        | GCC                     |\n-| X86-64          | OpenBSD          | GCC                     |\n-| X86-64          | Solaris          | Oracle Solaris Studio C |\n-| X86-64          | Windows/Cygwin   | GCC                     |\n-| X86-64          | Windows/MingW    | GCC                     |\n-| Xtensa          | Linux            | GCC                     |\n-|-----------------+------------------+-------------------------|\n-\n-Please send additional platform test results to\n-libffi-discuss@sourceware.org and feel free to update the wiki page\n-above.\n-\n-Installing libffi\n-=================\n-\n-First you must configure the distribution for your particular\n-system. Go to the directory you wish to build libffi in and run the\n-\"configure\" program found in the root directory of the libffi source\n-distribution.\n-\n-If you're building libffi directly from version control, configure won't\n-exist yet; run ./autogen.sh first.\n-\n-You may want to tell configure where to install the libffi library and\n-header files. To do that, use the --prefix configure switch.  Libffi\n-will install under /usr/local by default. \n-\n-If you want to enable extra run-time debugging checks use the the\n---enable-debug configure switch. This is useful when your program dies\n-mysteriously while using libffi. \n-\n-Another useful configure switch is --enable-purify-safety. Using this\n-will add some extra code which will suppress certain warnings when you\n-are using Purify with libffi. Only use this switch when using \n-Purify, as it will slow down the library.\n-\n-It's also possible to build libffi on Windows platforms with\n-Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh\n-wrapper script during configuration like so:\n-\n-path/to/configure CC=path/to/msvcc.sh CXX=path/to/msvcc.sh LD=link CPP=\"cl -nologo -EP\"\n-\n-For 64-bit Windows builds, use CC=\"path/to/msvcc.sh -m64\" and\n-CXX=\"path/to/msvcc.sh -m64\".  You may also need to specify --build\n-appropriately.\n-\n-It is also possible to build libffi on Windows platforms with the LLVM\n-project's clang-cl compiler, like below:\n-\n-path/to/configure CC=\"path/to/msvcc.sh -clang-cl\" CXX=\"path/to/msvcc.sh -clang-cl\" LD=link CPP=\"clang-cl -EP\"\n-\n-When building with MSVC under a MingW environment, you may need to\n-remove the line in configure that sets 'fix_srcfile_path' to a 'cygpath'\n-command.  ('cygpath' is not present in MingW, and is not required when\n-using MingW-style paths.)\n-\n-For iOS builds, the 'libffi.xcodeproj' Xcode project is available.\n-\n-Configure has many other options. Use \"configure --help\" to see them all.\n-\n-Once configure has finished, type \"make\". Note that you must be using\n-GNU make.  You can ftp GNU make from ftp.gnu.org:/pub/gnu/make .\n-\n-To ensure that libffi is working as advertised, type \"make check\".\n-This will require that you have DejaGNU installed.\n-\n-To install the library and header files, type \"make install\".\n-\n-\n-History\n-=======\n-\n-See the git log for details at http://github.com/atgreen/libffi.\n-\n-4.0 TBD\n-        New API in support of GO closures.\n-\n-3.2.1 Nov-12-14\n-        Build fix for non-iOS AArch64 targets.\n-\n-3.2 Nov-11-14\n-        Add C99 Complex Type support (currently only supported on\n-          s390).\n-\tAdd support for PASCAL and REGISTER calling conventions on x86\n-\t  Windows/Linux.\n-\tAdd OpenRISC and Cygwin-64 support.\n-        Bug fixes.\n-\n-3.1 May-19-14\n-        Add AArch64 (ARM64) iOS support.\n-        Add Nios II support.\n-        Add m88k and DEC VAX support.\n-\tAdd support for stdcall, thiscall, and fastcall on non-Windows\n-\t  32-bit x86 targets such as Linux.\n-\tVarious Android, MIPS N32, x86, FreeBSD and UltraSPARC IIi\n-\t  fixes.\n-\tMake the testsuite more robust: eliminate several spurious\n-\t  failures, and respect the $CC and $CXX environment variables.\n-\tArchive off the manually maintained ChangeLog in favor of git\n-\t  log.\n-\n-3.0.13 Mar-17-13\n-\tAdd Meta support.\n-\tAdd missing Moxie bits.\n-\tFix stack alignment bug on 32-bit x86.\n-\tBuild fix for m68000 targets.\n-\tBuild fix for soft-float Power targets.\n-\tFix the install dir location for some platforms when building\n-\t  with GCC (OS X, Solaris).\n-\tFix Cygwin regression.\n-\n-3.0.12 Feb-11-13\n-        Add Moxie support.\n-\tAdd AArch64 support.\n-\tAdd Blackfin support.\n-\tAdd TILE-Gx/TILEPro support.\n-\tAdd MicroBlaze support.\n-\tAdd Xtensa support.\n-\tAdd support for PaX enabled kernels with MPROTECT.\n-\tAdd support for native vendor compilers on\n-\t  Solaris and AIX.\n-\tWork around LLVM/GCC interoperability issue on x86_64.\n-\n-3.0.11 Apr-11-12\n-        Lots of build fixes.\n-\tAdd support for variadic functions (ffi_prep_cif_var).\n-\tAdd Linux/x32 support.\n-\tAdd thiscall, fastcall and MSVC cdecl support on Windows.\n-\tAdd Amiga and newer MacOS support.\n-\tAdd m68k FreeMiNT support.\n-\tIntegration with iOS' xcode build tools.\n-\tFix Octeon and MC68881 support.\n-\tFix code pessimizations.\n-\n-3.0.10 Aug-23-11\n-        Add support for Apple's iOS.\n-\tAdd support for ARM VFP ABI.\n-        Add RTEMS support for MIPS and M68K.\n-\tFix instruction cache clearing problems on\n-\t  ARM and SPARC.\n-\tFix the N64 build on mips-sgi-irix6.5.\n-\tEnable builds with Microsoft's compiler.\n-\tEnable x86 builds with Oracle's Solaris compiler.\n-\tFix support for calling code compiled with Oracle's Sparc\n-\t  Solaris compiler.\n-\tTestsuite fixes for Tru64 Unix.\n-\tAdditional platform support.\n-\n-3.0.9 Dec-31-09\n-        Add AVR32 and win64 ports.  Add ARM softfp support.\n-\tMany fixes for AIX, Solaris, HP-UX, *BSD.\n-\tSeveral PowerPC and x86-64 bug fixes.\n-\tBuild DLL for windows.\n-\n-3.0.8 Dec-19-08\n-        Add *BSD, BeOS, and PA-Linux support.\n-\n-3.0.7 Nov-11-08\n-        Fix for ppc FreeBSD.\n-\t(thanks to Andreas Tobler)\n-\n-3.0.6 Jul-17-08\n-        Fix for closures on sh.\n-\tMark the sh/sh64 stack as non-executable.\n-\t(both thanks to Kaz Kojima)\n-\n-3.0.5 Apr-3-08\n-        Fix libffi.pc file.\n-\tFix #define ARM for IcedTea users.\n-\tFix x86 closure bug.\n-\n-3.0.4 Feb-24-08\n-        Fix x86 OpenBSD configury.\n-\n-3.0.3 Feb-22-08\n-        Enable x86 OpenBSD thanks to Thomas Heller, and\n-\tx86-64 FreeBSD thanks to Bj\u00f6rn K\u00f6nig and Andreas Tobler.\n-\tClean up test instruction in README.\n-\n-3.0.2 Feb-21-08\n-        Improved x86 FreeBSD support.\n-\tThanks to Bj\u00f6rn K\u00f6nig.\n-\n-3.0.1 Feb-15-08\n-        Fix instruction cache flushing bug on MIPS.\n-\tThanks to David Daney.\n-\n-3.0.0 Feb-15-08\n-        Many changes, mostly thanks to the GCC project.\n-\tCygnus Solutions is now Red Hat.\n-\n-  [10 years go by...]\n-\n-1.20 Oct-5-98\n-\tRaffaele Sena produces ARM port.\n-\n-1.19 Oct-5-98\n-\tFixed x86 long double and long long return support.\n-\tm68k bug fixes from Andreas Schwab.\n-\tPatch for DU assembler compatibility for the Alpha from Richard\n-\tHenderson.\n-\n-1.18 Apr-17-98\n-\tBug fixes and MIPS configuration changes.\n-\n-1.17 Feb-24-98\n-\tBug fixes and m68k port from Andreas Schwab. PowerPC port from\n-\tGeoffrey Keating. Various bug x86, Sparc and MIPS bug fixes.\n-\n-1.16 Feb-11-98\n-\tRichard Henderson produces Alpha port.\n-\n-1.15 Dec-4-97\n-\tFixed an n32 ABI bug. New libtool, auto* support.\n-\n-1.14 May-13-97\n-\tlibtool is now used to generate shared and static libraries.\n-\tFixed a minor portability problem reported by Russ McManus\n-\t<mcmanr@eq.gs.com>.\n-\n-1.13 Dec-2-96\n-\tAdded --enable-purify-safety to keep Purify from complaining\n-\tabout certain low level code.\n-\tSparc fix for calling functions with < 6 args.\n-\tLinux x86 a.out fix.\n-\n-1.12 Nov-22-96\n-\tAdded missing ffi_type_void, needed for supporting void return \n-\ttypes. Fixed test case for non MIPS machines. Cygnus Support \n-\tis now Cygnus Solutions. \n-\n-1.11 Oct-30-96\n-\tAdded notes about GNU make.\n-\n-1.10 Oct-29-96\n-\tAdded configuration fix for non GNU compilers.\n-\n-1.09 Oct-29-96\n-\tAdded --enable-debug configure switch. Clean-ups based on LCLint \n-\tfeedback. ffi_mips.h is always installed. Many configuration \n-\tfixes. Fixed ffitest.c for sparc builds.\n-\n-1.08 Oct-15-96\n-\tFixed n32 problem. Many clean-ups.\n-\n-1.07 Oct-14-96\n-\tGordon Irlam rewrites v8.S again. Bug fixes.\n-\n-1.06 Oct-14-96\n-\tGordon Irlam improved the sparc port. \n-\n-1.05 Oct-14-96\n-\tInterface changes based on feedback.\n-\n-1.04 Oct-11-96\n-\tSparc port complete (modulo struct passing bug).\n-\n-1.03 Oct-10-96\n-\tPassing struct args, and returning struct values works for\n-\tall architectures/calling conventions. Expanded tests.\n-\n-1.02 Oct-9-96\n-\tAdded SGI n32 support. Fixed bugs in both o32 and Linux support.\n-\tAdded \"make test\".\n-\n-1.01 Oct-8-96\n-\tFixed float passing bug in mips version. Restructured some\n-\tof the code. Builds cleanly with SGI tools.\n-\n-1.00 Oct-7-96\n-\tFirst release. No public announcement.\n-\n-\n-Authors & Credits\n-=================\n-\n-libffi was originally written by Anthony Green <green@moxielogic.com>.\n-\n-The developers of the GNU Compiler Collection project have made\n-innumerable valuable contributions.  See the ChangeLog file for\n-details.\n-\n-Some of the ideas behind libffi were inspired by Gianni Mariani's free\n-gencall library for Silicon Graphics machines.\n-\n-The closure mechanism was designed and implemented by Kresten Krab\n-Thorup.\n-\n-Major processor architecture ports were contributed by the following\n-developers:\n-\n-aarch64\t\tMarcus Shawcroft, James Greenhalgh\n-alpha\t\tRichard Henderson\n-arm\t\tRaffaele Sena\n-blackfin        Alexandre Keunecke I. de Mendonca\n-cris\t\tSimon Posnjak, Hans-Peter Nilsson\n-frv\t\tAnthony Green\n-ia64\t\tHans Boehm\n-m32r\t\tKazuhiro Inaoka\n-m68k\t\tAndreas Schwab\n-m88k\t\tMiod Vallat\n-microblaze\tNathan Rossi\n-mips\t\tAnthony Green, Casey Marshall\n-mips64\t\tDavid Daney\n-moxie\t\tAnthony Green\n-nios ii\t\tSandra Loosemore\n-openrisc        Sebastian Macke\n-pa\t\tRandolph Chung, Dave Anglin, Andreas Tobler\n-powerpc\t\tGeoffrey Keating, Andreas Tobler, \n-\t\t\t David Edelsohn, John Hornkvist\n-powerpc64\tJakub Jelinek\n-s390\t\tGerhard Tonn, Ulrich Weigand\n-sh\t\tKaz Kojima\n-sh64\t\tKaz Kojima\n-sparc\t\tAnthony Green, Gordon Irlam\n-tile-gx/tilepro Walter Lee\n-vax\t\tMiod Vallat\n-x86\t\tAnthony Green, Jon Beniston\n-x86-64\t\tBo Thorsen\n-xtensa\t\tChris Zankel\n-\n-Jesper Skov and Andrew Haley both did more than their fair share of\n-stepping through the code and tracking down bugs.\n-\n-Thanks also to Tom Tromey for bug fixes, documentation and\n-configuration help.\n-\n-Thanks to Jim Blandy, who provided some useful feedback on the libffi\n-interface.\n-\n-Andreas Tobler has done a tremendous amount of work on the testsuite.\n-\n-Alex Oliva solved the executable page problem for SElinux.\n-\n-The list above is almost certainly incomplete and inaccurate.  I'm\n-happy to make corrections or additions upon request.\n-\n-If you have a problem, or have found a bug, please send a note to the\n-author at green@moxielogic.com, or the project mailing list at\n-libffi-discuss@sourceware.org."}, {"sha": "b95bd74d8ba48f217cbedc74aeda3239c7b224ea", "filename": "libffi/README.md", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME.md?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,495 @@\n+Status\n+======\n+\n+libffi-3.4.1 was released on June 28, 2021.  Check the libffi web page\n+for updates: <URL:http://sourceware.org/libffi/>.\n+\n+\n+What is libffi?\n+===============\n+\n+Compilers for high level languages generate code that follow certain\n+conventions. These conventions are necessary, in part, for separate\n+compilation to work. One such convention is the \"calling\n+convention\". The \"calling convention\" is essentially a set of\n+assumptions made by the compiler about where function arguments will\n+be found on entry to a function. A \"calling convention\" also specifies\n+where the return value for a function is found.\n+\n+Some programs may not know at the time of compilation what arguments\n+are to be passed to a function. For instance, an interpreter may be\n+told at run-time about the number and types of arguments used to call\n+a given function. Libffi can be used in such programs to provide a\n+bridge from the interpreter program to compiled code.\n+\n+The libffi library provides a portable, high level programming\n+interface to various calling conventions. This allows a programmer to\n+call any function specified by a call interface description at run\n+time.\n+\n+FFI stands for Foreign Function Interface.  A foreign function\n+interface is the popular name for the interface that allows code\n+written in one language to call code written in another language. The\n+libffi library really only provides the lowest, machine dependent\n+layer of a fully featured foreign function interface. A layer must\n+exist above libffi that handles type conversions for values passed\n+between the two languages.\n+\n+\n+Supported Platforms\n+===================\n+\n+Libffi has been ported to many different platforms.\n+\n+At the time of release, the following basic configurations have been\n+tested:\n+\n+| Architecture    | Operating System | Compiler                |\n+| --------------- | ---------------- | ----------------------- |\n+| AArch64 (ARM64) | iOS              | Clang                   |\n+| AArch64         | Linux            | GCC                     |\n+| AArch64         | Windows          | MSVC                    |\n+| Alpha           | Linux            | GCC                     |\n+| Alpha           | Tru64            | GCC                     |\n+| ARC             | Linux            | GCC                     |\n+| ARM             | Linux            | GCC                     |\n+| ARM             | iOS              | GCC                     |\n+| ARM             | Windows          | MSVC                    |\n+| AVR32           | Linux            | GCC                     |\n+| Blackfin        | uClinux          | GCC                     |\n+| CSKY            | Linux            | GCC                     |\n+| HPPA            | HPUX             | GCC                     |\n+| KVX             | Linux            | GCC                     |\n+| IA-64           | Linux            | GCC                     |\n+| M68K            | FreeMiNT         | GCC                     |\n+| M68K            | Linux            | GCC                     |\n+| M68K            | RTEMS            | GCC                     |\n+| M88K            | OpenBSD/mvme88k  | GCC                     |\n+| Meta            | Linux            | GCC                     |\n+| MicroBlaze      | Linux            | GCC                     |\n+| MIPS            | IRIX             | GCC                     |\n+| MIPS            | Linux            | GCC                     |\n+| MIPS            | RTEMS            | GCC                     |\n+| MIPS64          | Linux            | GCC                     |\n+| Moxie           | Bare metal       | GCC                     |\n+| Nios II         | Linux            | GCC                     |\n+| OpenRISC        | Linux            | GCC                     |\n+| PowerPC 32-bit  | AIX              | IBM XL C                |\n+| PowerPC 64-bit  | AIX              | IBM XL C                |\n+| PowerPC         | AMIGA            | GCC                     |\n+| PowerPC         | Linux            | GCC                     |\n+| PowerPC         | Mac OSX          | GCC                     |\n+| PowerPC         | FreeBSD          | GCC                     |\n+| PowerPC 64-bit  | FreeBSD          | GCC                     |\n+| PowerPC 64-bit  | Linux ELFv1      | GCC                     |\n+| PowerPC 64-bit  | Linux ELFv2      | GCC                     |\n+| RISC-V 32-bit   | Linux            | GCC                     |\n+| RISC-V 64-bit   | Linux            | GCC                     |\n+| S390            | Linux            | GCC                     |\n+| S390X           | Linux            | GCC                     |\n+| SPARC           | Linux            | GCC                     |\n+| SPARC           | Solaris          | GCC                     |\n+| SPARC           | Solaris          | Oracle Solaris Studio C |\n+| SPARC64         | Linux            | GCC                     |\n+| SPARC64         | FreeBSD          | GCC                     |\n+| SPARC64         | Solaris          | Oracle Solaris Studio C |\n+| TILE-Gx/TILEPro | Linux            | GCC                     |\n+| VAX             | OpenBSD/vax      | GCC                     |\n+| X86             | FreeBSD          | GCC                     |\n+| X86             | GNU HURD         | GCC                     |\n+| X86             | Interix          | GCC                     |\n+| X86             | kFreeBSD         | GCC                     |\n+| X86             | Linux            | GCC                     |\n+| X86             | OpenBSD          | GCC                     |\n+| X86             | OS/2             | GCC                     |\n+| X86             | Solaris          | GCC                     |\n+| X86             | Solaris          | Oracle Solaris Studio C |\n+| X86             | Windows/Cygwin   | GCC                     |\n+| X86             | Windows/MingW    | GCC                     |\n+| X86-64          | FreeBSD          | GCC                     |\n+| X86-64          | Linux            | GCC                     |\n+| X86-64          | Linux/x32        | GCC                     |\n+| X86-64          | OpenBSD          | GCC                     |\n+| X86-64          | Solaris          | Oracle Solaris Studio C |\n+| X86-64          | Windows/Cygwin   | GCC                     |\n+| X86-64          | Windows/MingW    | GCC                     |\n+| X86-64          | Mac OSX          | GCC                     |\n+| Xtensa          | Linux            | GCC                     |\n+\n+Please send additional platform test results to\n+libffi-discuss@sourceware.org.\n+\n+Installing libffi\n+=================\n+\n+First you must configure the distribution for your particular\n+system. Go to the directory you wish to build libffi in and run the\n+\"configure\" program found in the root directory of the libffi source\n+distribution.  Note that building libffi requires a C99 compatible\n+compiler.\n+\n+If you're building libffi directly from git hosted sources, configure\n+won't exist yet; run ./autogen.sh first.  This will require that you\n+install autoconf, automake and libtool.\n+\n+You may want to tell configure where to install the libffi library and\n+header files. To do that, use the ``--prefix`` configure switch.  Libffi\n+will install under /usr/local by default.\n+\n+If you want to enable extra run-time debugging checks use the the\n+``--enable-debug`` configure switch. This is useful when your program dies\n+mysteriously while using libffi.\n+\n+Another useful configure switch is ``--enable-purify-safety``. Using this\n+will add some extra code which will suppress certain warnings when you\n+are using Purify with libffi. Only use this switch when using\n+Purify, as it will slow down the library.\n+\n+If you don't want to build documentation, use the ``--disable-docs``\n+configure switch.\n+\n+It's also possible to build libffi on Windows platforms with\n+Microsoft's Visual C++ compiler.  In this case, use the msvcc.sh\n+wrapper script during configuration like so:\n+\n+    path/to/configure CC=path/to/msvcc.sh CXX=path/to/msvcc.sh LD=link CPP=\"cl -nologo -EP\" CPPFLAGS=\"-DFFI_BUILDING_DLL\"\n+\n+For 64-bit Windows builds, use ``CC=\"path/to/msvcc.sh -m64\"`` and\n+``CXX=\"path/to/msvcc.sh -m64\"``.  You may also need to specify\n+``--build`` appropriately.\n+\n+It is also possible to build libffi on Windows platforms with the LLVM\n+project's clang-cl compiler, like below:\n+\n+    path/to/configure CC=\"path/to/msvcc.sh -clang-cl\" CXX=\"path/to/msvcc.sh -clang-cl\" LD=link CPP=\"clang-cl -EP\"\n+\n+When building with MSVC under a MingW environment, you may need to\n+remove the line in configure that sets 'fix_srcfile_path' to a 'cygpath'\n+command.  ('cygpath' is not present in MingW, and is not required when\n+using MingW-style paths.)\n+\n+To build static library for ARM64 with MSVC using visual studio solution, msvc_build folder have\n+   aarch64/Ffi_staticLib.sln\n+   required header files in aarch64/aarch64_include/\n+\n+\n+SPARC Solaris builds require the use of the GNU assembler and linker.\n+Point ``AS`` and ``LD`` environment variables at those tool prior to\n+configuration.\n+\n+For iOS builds, the ``libffi.xcodeproj`` Xcode project is available.\n+\n+Configure has many other options. Use ``configure --help`` to see them all.\n+\n+Once configure has finished, type \"make\". Note that you must be using\n+GNU make.  You can ftp GNU make from ftp.gnu.org:/pub/gnu/make .\n+\n+To ensure that libffi is working as advertised, type \"make check\".\n+This will require that you have DejaGNU installed.\n+\n+To install the library and header files, type ``make install``.\n+\n+\n+History\n+=======\n+\n+See the git log for details at http://github.com/libffi/libffi.\n+\n+    3.4.2 Jun-28-21\n+        Add static trampoline support for Linux on x86_64 and ARM64.\n+        Add support for Alibaba's CSKY architecture.\n+        Add support for Kalray's KVX architecture.\n+        Add support for Intel Control-flow Enforcement Technology (CET).\n+        Add support for ARM Pointer Authentication (PA).\n+        Fix 32-bit PPC regression.\n+        Fix MIPS soft-float problem.\n+        Enable tmpdir override with the $LIBFFI_TMPDIR environment variable.\n+        Enable compatibility with MSVC runtime stack checking.\n+        Reject float and small integer argument in ffi_prep_cif_var().\n+          Callers must promote these types themselves.\n+\n+    3.3 Nov-23-19\n+        Add RISC-V support.\n+        New API in support of GO closures.\n+        Add IEEE754 binary128 long double support for 64-bit Power\n+        Default to Microsoft's 64 bit long double ABI with Visual C++.\n+        GNU compiler uses 80 bits (128 in memory) FFI_GNUW64 ABI.\n+        Add Windows on ARM64 (WOA) support.\n+        Add Windows 32-bit ARM support.\n+        Raw java (gcj) API deprecated.\n+        Add pre-built PDF documentation to source distribution.\n+        Many new test cases and bug fixes.\n+\n+    3.2.1 Nov-12-14\n+        Build fix for non-iOS AArch64 targets.\n+\n+    3.2 Nov-11-14\n+        Add C99 Complex Type support (currently only supported on\n+          s390).\n+        Add support for PASCAL and REGISTER calling conventions on x86\n+          Windows/Linux.\n+        Add OpenRISC and Cygwin-64 support.\n+        Bug fixes.\n+\n+    3.1 May-19-14\n+        Add AArch64 (ARM64) iOS support.\n+        Add Nios II support.\n+        Add m88k and DEC VAX support.\n+        Add support for stdcall, thiscall, and fastcall on non-Windows\n+          32-bit x86 targets such as Linux.\n+        Various Android, MIPS N32, x86, FreeBSD and UltraSPARC IIi\n+          fixes.\n+        Make the testsuite more robust: eliminate several spurious\n+          failures, and respect the $CC and $CXX environment variables.\n+        Archive off the manually maintained ChangeLog in favor of git\n+          log.\n+\n+    3.0.13 Mar-17-13\n+        Add Meta support.\n+        Add missing Moxie bits.\n+        Fix stack alignment bug on 32-bit x86.\n+        Build fix for m68000 targets.\n+        Build fix for soft-float Power targets.\n+        Fix the install dir location for some platforms when building\n+          with GCC (OS X, Solaris).\n+        Fix Cygwin regression.\n+\n+    3.0.12 Feb-11-13\n+        Add Moxie support.\n+        Add AArch64 support.\n+        Add Blackfin support.\n+        Add TILE-Gx/TILEPro support.\n+        Add MicroBlaze support.\n+        Add Xtensa support.\n+        Add support for PaX enabled kernels with MPROTECT.\n+        Add support for native vendor compilers on\n+          Solaris and AIX.\n+        Work around LLVM/GCC interoperability issue on x86_64.\n+\n+    3.0.11 Apr-11-12\n+        Lots of build fixes.\n+        Add support for variadic functions (ffi_prep_cif_var).\n+        Add Linux/x32 support.\n+        Add thiscall, fastcall and MSVC cdecl support on Windows.\n+        Add Amiga and newer MacOS support.\n+        Add m68k FreeMiNT support.\n+        Integration with iOS' xcode build tools.\n+        Fix Octeon and MC68881 support.\n+        Fix code pessimizations.\n+\n+    3.0.10 Aug-23-11\n+        Add support for Apple's iOS.\n+        Add support for ARM VFP ABI.\n+        Add RTEMS support for MIPS and M68K.\n+        Fix instruction cache clearing problems on\n+          ARM and SPARC.\n+        Fix the N64 build on mips-sgi-irix6.5.\n+        Enable builds with Microsoft's compiler.\n+        Enable x86 builds with Oracle's Solaris compiler.\n+        Fix support for calling code compiled with Oracle's Sparc\n+          Solaris compiler.\n+        Testsuite fixes for Tru64 Unix.\n+        Additional platform support.\n+\n+    3.0.9 Dec-31-09\n+        Add AVR32 and win64 ports.  Add ARM softfp support.\n+        Many fixes for AIX, Solaris, HP-UX, *BSD.\n+        Several PowerPC and x86-64 bug fixes.\n+        Build DLL for windows.\n+\n+    3.0.8 Dec-19-08\n+        Add *BSD, BeOS, and PA-Linux support.\n+\n+    3.0.7 Nov-11-08\n+        Fix for ppc FreeBSD.\n+        (thanks to Andreas Tobler)\n+\n+    3.0.6 Jul-17-08\n+        Fix for closures on sh.\n+        Mark the sh/sh64 stack as non-executable.\n+        (both thanks to Kaz Kojima)\n+\n+    3.0.5 Apr-3-08\n+        Fix libffi.pc file.\n+        Fix #define ARM for IcedTea users.\n+        Fix x86 closure bug.\n+\n+    3.0.4 Feb-24-08\n+        Fix x86 OpenBSD configury.\n+\n+    3.0.3 Feb-22-08\n+        Enable x86 OpenBSD thanks to Thomas Heller, and\n+          x86-64 FreeBSD thanks to Bj\u00f6rn K\u00f6nig and Andreas Tobler.\n+        Clean up test instruction in README.\n+\n+    3.0.2 Feb-21-08\n+        Improved x86 FreeBSD support.\n+        Thanks to Bj\u00f6rn K\u00f6nig.\n+\n+    3.0.1 Feb-15-08\n+        Fix instruction cache flushing bug on MIPS.\n+        Thanks to David Daney.\n+\n+    3.0.0 Feb-15-08\n+        Many changes, mostly thanks to the GCC project.\n+        Cygnus Solutions is now Red Hat.\n+\n+      [10 years go by...]\n+\n+    1.20 Oct-5-98\n+        Raffaele Sena produces ARM port.\n+\n+    1.19 Oct-5-98\n+        Fixed x86 long double and long long return support.\n+        m68k bug fixes from Andreas Schwab.\n+        Patch for DU assembler compatibility for the Alpha from Richard\n+          Henderson.\n+\n+    1.18 Apr-17-98\n+        Bug fixes and MIPS configuration changes.\n+\n+    1.17 Feb-24-98\n+        Bug fixes and m68k port from Andreas Schwab. PowerPC port from\n+        Geoffrey Keating. Various bug x86, Sparc and MIPS bug fixes.\n+\n+    1.16 Feb-11-98\n+        Richard Henderson produces Alpha port.\n+\n+    1.15 Dec-4-97\n+        Fixed an n32 ABI bug. New libtool, auto* support.\n+\n+    1.14 May-13-97\n+        libtool is now used to generate shared and static libraries.\n+        Fixed a minor portability problem reported by Russ McManus\n+        <mcmanr@eq.gs.com>.\n+\n+    1.13 Dec-2-96\n+        Added --enable-purify-safety to keep Purify from complaining\n+          about certain low level code.\n+        Sparc fix for calling functions with < 6 args.\n+        Linux x86 a.out fix.\n+\n+    1.12 Nov-22-96\n+        Added missing ffi_type_void, needed for supporting void return\n+          types. Fixed test case for non MIPS machines. Cygnus Support\n+          is now Cygnus Solutions.\n+\n+    1.11 Oct-30-96\n+        Added notes about GNU make.\n+\n+    1.10 Oct-29-96\n+        Added configuration fix for non GNU compilers.\n+\n+    1.09 Oct-29-96\n+        Added --enable-debug configure switch. Clean-ups based on LCLint\n+        feedback. ffi_mips.h is always installed. Many configuration\n+        fixes. Fixed ffitest.c for sparc builds.\n+\n+    1.08 Oct-15-96\n+        Fixed n32 problem. Many clean-ups.\n+\n+    1.07 Oct-14-96\n+        Gordon Irlam rewrites v8.S again. Bug fixes.\n+\n+    1.06 Oct-14-96\n+        Gordon Irlam improved the sparc port.\n+\n+    1.05 Oct-14-96\n+        Interface changes based on feedback.\n+\n+    1.04 Oct-11-96\n+        Sparc port complete (modulo struct passing bug).\n+\n+    1.03 Oct-10-96\n+        Passing struct args, and returning struct values works for\n+        all architectures/calling conventions. Expanded tests.\n+\n+    1.02 Oct-9-96\n+        Added SGI n32 support. Fixed bugs in both o32 and Linux support.\n+        Added \"make test\".\n+\n+    1.01 Oct-8-96\n+        Fixed float passing bug in mips version. Restructured some\n+        of the code. Builds cleanly with SGI tools.\n+\n+    1.00 Oct-7-96\n+        First release. No public announcement.\n+\n+Authors & Credits\n+=================\n+\n+libffi was originally written by Anthony Green <green@moxielogic.com>.\n+\n+The developers of the GNU Compiler Collection project have made\n+innumerable valuable contributions.  See the ChangeLog file for\n+details.\n+\n+Some of the ideas behind libffi were inspired by Gianni Mariani's free\n+gencall library for Silicon Graphics machines.\n+\n+The closure mechanism was designed and implemented by Kresten Krab\n+Thorup.\n+\n+Major processor architecture ports were contributed by the following\n+developers:\n+\n+    aarch64             Marcus Shawcroft, James Greenhalgh\n+    alpha               Richard Henderson\n+    arc                 Hackers at Synopsis\n+    arm                 Raffaele Sena\n+    avr32               Bradley Smith\n+    blackfin            Alexandre Keunecke I. de Mendonca\n+    cris                Simon Posnjak, Hans-Peter Nilsson\n+    csky                Ma Jun, Zhang Wenmeng\n+    frv                 Anthony Green\n+    ia64                Hans Boehm\n+    kvx                 Yann Sionneau\n+    m32r                Kazuhiro Inaoka\n+    m68k                Andreas Schwab\n+    m88k                Miod Vallat\n+    metag               Hackers at Imagination Technologies\n+    microblaze          Nathan Rossi\n+    mips                Anthony Green, Casey Marshall\n+    mips64              David Daney\n+    moxie               Anthony Green\n+    nios ii             Sandra Loosemore\n+    openrisc            Sebastian Macke\n+    pa                  Randolph Chung, Dave Anglin, Andreas Tobler\n+    powerpc             Geoffrey Keating, Andreas Tobler,\n+                        David Edelsohn, John Hornkvist\n+    powerpc64           Jakub Jelinek\n+    riscv               Michael Knyszek, Andrew Waterman, Stef O'Rear\n+    s390                Gerhard Tonn, Ulrich Weigand\n+    sh                  Kaz Kojima\n+    sh64                Kaz Kojima\n+    sparc               Anthony Green, Gordon Irlam\n+    tile-gx/tilepro     Walter Lee\n+    vax                 Miod Vallat\n+    x86                 Anthony Green, Jon Beniston\n+    x86-64              Bo Thorsen\n+    xtensa              Chris Zankel\n+\n+Jesper Skov and Andrew Haley both did more than their fair share of\n+stepping through the code and tracking down bugs.\n+\n+Thanks also to Tom Tromey for bug fixes, documentation and\n+configuration help.\n+\n+Thanks to Jim Blandy, who provided some useful feedback on the libffi\n+interface.\n+\n+Andreas Tobler has done a tremendous amount of work on the testsuite.\n+\n+Alex Oliva solved the executable page problem for SElinux.\n+\n+The list above is almost certainly incomplete and inaccurate.  I'm\n+happy to make corrections or additions upon request.\n+\n+If you have a problem, or have found a bug, please file an issue on\n+our issue tracker at https://github.com/libffi/libffi/issues.\n+\n+The author can be reached at green@moxielogic.com.\n+\n+To subscribe/unsubscribe to our mailing lists, visit:\n+https://sourceware.org/mailman/listinfo/libffi-announce\n+https://sourceware.org/mailman/listinfo/libffi-discuss"}, {"sha": "1a70efb010dc045bb4287ca1afcff76bfa0d74a1", "filename": "libffi/acinclude.m4", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Facinclude.m4?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -95,14 +95,14 @@ dnl ----------------------------------------------------------------------\n dnl This whole bit snagged from libstdc++-v3, via libatomic.\n \n dnl\n-dnl LIBAT_ENABLE\n+dnl LIBFFI_ENABLE\n dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING)\n dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, permit a|b|c)\n dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, SHELL-CODE-HANDLER)\n dnl\n dnl See docs/html/17_intro/configury.html#enable for documentation.\n dnl\n-m4_define([LIBAT_ENABLE],[dnl\n+m4_define([LIBFFI_ENABLE],[dnl\n m4_define([_g_switch],[--enable-$1])dnl\n m4_define([_g_help],[AC_HELP_STRING(_g_switch$3,[$4 @<:@default=$2@:>@])])dnl\n  AC_ARG_ENABLE($1,_g_help,\n@@ -146,7 +146,7 @@ dnl\n dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n dnl set libat_gnu_ld_version to 12345.  Zeros cause problems.\n dnl\n-AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n+AC_DEFUN([LIBFFI_CHECK_LINKER_FEATURES], [\n   # If we're not using GNU ld, then there's no point in even trying these\n   # tests.  Check for that first.  We should have already tested for gld\n   # by now (in libtool), but require it now just to be safe...\n@@ -178,7 +178,7 @@ AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n   fi\n   changequote(,)\n   ldver=`$LD --version 2>/dev/null |\n-         sed -e 's/[. ][0-9]\\{8\\}$//;s/.* \\([^ ]\\{1,\\}\\)$/\\1/; q'`\n+         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n   changequote([,])\n   libat_gnu_ld_version=`echo $ldver | \\\n          $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n@@ -248,7 +248,7 @@ dnl\n dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n dnl set libat_gnu_ld_version to 12345.  Zeros cause problems.\n dnl\n-AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n+AC_DEFUN([LIBFFI_CHECK_LINKER_FEATURES], [\n   # If we're not using GNU ld, then there's no point in even trying these\n   # tests.  Check for that first.  We should have already tested for gld\n   # by now (in libtool), but require it now just to be safe...\n@@ -278,9 +278,13 @@ AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n   if $LD --version 2>/dev/null | grep 'GNU gold'> /dev/null 2>&1; then\n     libat_ld_is_gold=yes\n   fi\n+  libat_ld_is_lld=no\n+  if $LD --version 2>/dev/null | grep 'LLD '> /dev/null 2>&1; then\n+    libat_ld_is_lld=yes\n+  fi\n   changequote(,)\n   ldver=`$LD --version 2>/dev/null |\n-         sed -e 's/[. ][0-9]\\{8\\}$//;s/.* \\([^ ]\\{1,\\}\\)$/\\1/; q'`\n+         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n   changequote([,])\n   libat_gnu_ld_version=`echo $ldver | \\\n          $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n@@ -341,20 +345,20 @@ dnl --enable-symvers=style adds a version script to the linker call when\n dnl       creating the shared library.  The choice of version script is\n dnl       controlled by 'style'.\n dnl --disable-symvers does not.\n-dnl  +  Usage:  LIBAT_ENABLE_SYMVERS[(DEFAULT)]\n+dnl  +  Usage:  LIBFFI_ENABLE_SYMVERS[(DEFAULT)]\n dnl       Where DEFAULT is either 'yes' or 'no'.  Passing `yes' tries to\n dnl       choose a default style based on linker characteristics.  Passing\n dnl       'no' disables versioning.\n dnl\n-AC_DEFUN([LIBAT_ENABLE_SYMVERS], [\n+AC_DEFUN([LIBFFI_ENABLE_SYMVERS], [\n \n-LIBAT_ENABLE(symvers,yes,[=STYLE],\n+LIBFFI_ENABLE(symvers,yes,[=STYLE],\n   [enables symbol versioning of the shared library],\n   [permit yes|no|gnu*|sun])\n \n-# If we never went through the LIBAT_CHECK_LINKER_FEATURES macro, then we\n+# If we never went through the LIBFFI_CHECK_LINKER_FEATURES macro, then we\n # don't know enough about $LD to do tricks...\n-AC_REQUIRE([LIBAT_CHECK_LINKER_FEATURES])\n+AC_REQUIRE([LIBFFI_CHECK_LINKER_FEATURES])\n \n # Turn a 'yes' into a suitable default.\n if test x$enable_symvers = xyes ; then\n@@ -420,7 +424,7 @@ changequote([,])dnl\n fi\n \n # For GNU ld, we need at least this version.  The format is described in\n-# LIBAT_CHECK_LINKER_FEATURES above.\n+# LIBFFI_CHECK_LINKER_FEATURES above.\n libat_min_gnu_ld_version=21400\n # XXXXXXXXXXX libat_gnu_ld_version=21390\n \n@@ -432,6 +436,8 @@ if test $enable_symvers != no && test $libat_shared_libgcc = yes; then\n       enable_symvers=gnu\n     elif test $libat_ld_is_gold = yes ; then\n       enable_symvers=gnu\n+    elif test $libat_ld_is_lld = yes ; then\n+      enable_symvers=gnu\n     else\n       # The right tools, the right setup, but too old.  Fallbacks?\n       AC_MSG_WARN(=== Linker version $libat_gnu_ld_version is too old for)\n@@ -462,12 +468,12 @@ if test $enable_symvers != no && test $libat_shared_libgcc = yes; then\n   fi\n fi\n if test $enable_symvers = gnu; then\n-  AC_DEFINE(LIBAT_GNU_SYMBOL_VERSIONING, 1,\n+  AC_DEFINE(LIBFFI_GNU_SYMBOL_VERSIONING, 1,\n \t    [Define to 1 if GNU symbol versioning is used for libatomic.])\n fi\n \n-AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)\n-AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB_GNU, test $enable_symvers = gnu)\n-AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB_SUN, test $enable_symvers = sun)\n+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)\n+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB_GNU, test $enable_symvers = gnu)\n+AM_CONDITIONAL(LIBFFI_BUILD_VERSIONED_SHLIB_SUN, test $enable_symvers = sun)\n AC_MSG_NOTICE(versioning on shared library symbols is $enable_symvers)\n ])"}, {"sha": "9c8c88f8ca643709f9f0c72293d40acf68e5c57e", "filename": "libffi/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1202, "changes": 1202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Faclocal.m4?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,1202 +0,0 @@\n-# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,\n-[m4_warning([this file was generated for autoconf 2.69.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n-\n-# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.15'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.15.1], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.15.1])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# Figure out how to run the assembler.                      -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_AS\n-# ----------\n-AC_DEFUN([AM_PROG_AS],\n-[# By default we simply use the C compiler to build assembly code.\n-AC_REQUIRE([AC_PROG_CC])\n-test \"${CCAS+set}\" = set || CCAS=$CC\n-test \"${CCASFLAGS+set}\" = set || CCASFLAGS=$CFLAGS\n-AC_ARG_VAR([CCAS],      [assembler compiler command (defaults to CC)])\n-AC_ARG_VAR([CCASFLAGS], [assembler compiler flags (defaults to CFLAGS)])\n-_AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl\n-])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to\n-# '$srcdir', '$srcdir/..', or '$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is '.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\n-# Expand $ac_aux_dir to an absolute path.\n-am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ([2.52])dnl\n- m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"OBJC\", \"OBJCXX\", \"UPC\", or \"GJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-m4_if([$1], [CC],   [depcc=\"$CC\"   am_compiler_list=],\n-      [$1], [CXX],  [depcc=\"$CXX\"  am_compiler_list=],\n-      [$1], [OBJC], [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-      [$1], [OBJCXX], [depcc=\"$OBJCXX\" am_compiler_list='gcc3 gcc'],\n-      [$1], [UPC],  [depcc=\"$UPC\"  am_compiler_list=],\n-      [$1], [GCJ],  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                    [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named 'D' -- because '-MD' means \"put the output\n-  # in D\".\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using \": > sub/conftst$i.h\" creates only sub/conftst1.h with\n-      # Solaris 10 /bin/sh.\n-      echo '/* dummy */' > sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with '-c' and '-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle '-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs.\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # After this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested.\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n-      # This compiler won't grok '-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES.\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE([dependency-tracking], [dnl\n-AS_HELP_STRING(\n-  [--enable-dependency-tracking],\n-  [do not reject slow dependency extractors])\n-AS_HELP_STRING(\n-  [--disable-dependency-tracking],\n-  [speeds up one-time build])])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-  am__nodep='_no'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-AC_SUBST([am__nodep])dnl\n-_AM_SUBST_NOTMAKE([am__nodep])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Older Autoconf quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each '.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.\n-m4_define([AC_PROG_CC],\n-m4_defn([AC_PROG_CC])\n-[_AM_PROG_CC_C_O\n-])\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.65])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[AC_DIAGNOSE([obsolete],\n-             [$0: two- and three-arguments forms are deprecated.])\n-m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(\n-  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),\n-  [ok:ok],,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED([PACKAGE], [\"$PACKAGE\"], [Name of package])\n- AC_DEFINE_UNQUOTED([VERSION], [\"$VERSION\"], [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])\n-AM_MISSING_PROG([AUTOCONF], [autoconf])\n-AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])\n-AM_MISSING_PROG([AUTOHEADER], [autoheader])\n-AM_MISSING_PROG([MAKEINFO], [makeinfo])\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-# For better backward compatibility.  To be removed once Automake 1.9.x\n-# dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n-AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n-# We need awk for the \"check\" target (and possibly the TAP driver).  The\n-# system \"awk\" is bad on some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES([CC])],\n-\t\t  [m4_define([AC_PROG_CC],\n-\t\t\t     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES([CXX])],\n-\t\t  [m4_define([AC_PROG_CXX],\n-\t\t\t     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES([OBJC])],\n-\t\t  [m4_define([AC_PROG_OBJC],\n-\t\t\t     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],\n-\t\t  [_AM_DEPENDENCIES([OBJCXX])],\n-\t\t  [m4_define([AC_PROG_OBJCXX],\n-\t\t\t     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl\n-])\n-AC_REQUIRE([AM_SILENT_RULES])dnl\n-dnl The testsuite driver may need to know about EXEEXT, so add the\n-dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This\n-dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-\n-# POSIX will say in a future version that running \"rm -f\" with no argument\n-# is OK; and we want to be able to make that assumption in our Makefile\n-# recipes.  So use an aggressive probe to check that the usage we want is\n-# actually supported \"in the wild\" to an acceptable degree.\n-# See automake bug#10828.\n-# To make any issue more visible, cause the running configure to be aborted\n-# by default if the 'rm' program in use doesn't match our expectations; the\n-# user can still override this though.\n-if rm -f && rm -fr && rm -rf; then : OK; else\n-  cat >&2 <<'END'\n-Oops!\n-\n-Your 'rm' program seems unable to run without file operands specified\n-on the command line, even when the '-f' option is present.  This is contrary\n-to the behaviour of most rm programs out there, and not conforming with\n-the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>\n-\n-Please tell bug-automake@gnu.org about your system, including the value\n-of your $PATH and any error possibly output before this message.  This\n-can help us improve future automake versions.\n-\n-END\n-  if test x\"$ACCEPT_INFERIOR_RM_PROGRAM\" = x\"yes\"; then\n-    echo 'Configuration will proceed anyway, since you have set the' >&2\n-    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to \"yes\"' >&2\n-    echo >&2\n-  else\n-    cat >&2 <<'END'\n-Aborting the configuration process, to ensure you take notice of the issue.\n-\n-You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n-\n-If you want to complete the configuration process using your problematic\n-'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n-to \"yes\", and re-run configure.\n-\n-END\n-    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])\n-  fi\n-fi\n-dnl The trailing newline in this macro's definition is deliberate, for\n-dnl backward compatibility and to allow trailing 'dnl'-style comments\n-dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.\n-])\n-\n-dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST([install_sh])])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless 'enable' is passed literally.\n-# For symmetry, 'disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n-      am_maintainer_other[ make rules and dependencies not useful\n-      (and sometimes confusing) to the casual installer])],\n-    [USE_MAINTAINER_MODE=$enableval],\n-    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it is modern enough.\n-# If it is, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --is-lightweight\"; then\n-  am_missing_run=\"$MISSING \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN(['missing' script is too old or missing])\n-fi\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), [1])])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_CC_C_O\n-# ---------------\n-# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC\n-# to automatically call this.\n-AC_DEFUN([_AM_PROG_CC_C_O],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([compile])dnl\n-AC_LANG_PUSH([C])dnl\n-AC_CACHE_CHECK(\n-  [whether $CC understands -c and -o together],\n-  [am_cv_prog_cc_c_o],\n-  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])\n-  # Make sure it works both with $CC and with simple cc.\n-  # Following AC_PROG_CC_C_O, we do the test twice because some\n-  # compilers refuse to overwrite an existing .o file with -o,\n-  # though they will create one.\n-  am_cv_prog_cc_c_o=yes\n-  for am_i in 1 2; do\n-    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \\\n-         && test -f conftest2.$ac_objext; then\n-      : OK\n-    else\n-      am_cv_prog_cc_c_o=no\n-      break\n-    fi\n-  done\n-  rm -f core conftest*\n-  unset am_i])\n-if test \"$am_cv_prog_cc_c_o\" != yes; then\n-   # Losing compiler, so override with the script.\n-   # FIXME: It is wrong to rewrite CC.\n-   # But if we don't then we get into trouble of one sort or another.\n-   # A longer-term fix would be to have automake use am__CC in this case,\n-   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n-   CC=\"$am_aux_dir/compile $CC\"\n-fi\n-AC_LANG_POP([C])])\n-\n-# For backward compatibility.\n-AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_RUN_LOG(COMMAND)\n-# -------------------\n-# Run COMMAND, save the exit status in ac_status, and log it.\n-# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)\n-AC_DEFUN([AM_RUN_LOG],\n-[{ echo \"$as_me:$LINENO: $1\" >&AS_MESSAGE_LOG_FD\n-   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD\n-   ac_status=$?\n-   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n-   (exit $ac_status); }])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;\n-esac\n-\n-# Do 'set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   am_has_slept=no\n-   for am_try in 1 2; do\n-     echo \"timestamp, slept: $am_has_slept\" > conftest.file\n-     set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-     if test \"$[*]\" = \"X\"; then\n-\t# -L didn't work.\n-\tset X `ls -t \"$srcdir/configure\" conftest.file`\n-     fi\n-     if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-\t&& test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-\t# If neither matched, then we have a broken ls.  This can happen\n-\t# if, for instance, CONFIG_SHELL is bash and it inherits a\n-\t# broken ls alias from the environment.  This has actually\n-\t# happened.  Such a system could not be considered \"sane\".\n-\tAC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-  alias in your environment])\n-     fi\n-     if test \"$[2]\" = conftest.file || test $am_try -eq 2; then\n-       break\n-     fi\n-     # Just in case.\n-     sleep 1\n-     am_has_slept=yes\n-   done\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT([yes])\n-# If we didn't sleep, we still need to ensure time stamps of config.status and\n-# generated files are strictly newer.\n-am_sleep_pid=\n-if grep 'slept: no' conftest.file >/dev/null 2>&1; then\n-  ( sleep 1 ) &\n-  am_sleep_pid=$!\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-  [AC_MSG_CHECKING([that generated files are newer than configure])\n-   if test -n \"$am_sleep_pid\"; then\n-     # Hide warnings about reused PIDs.\n-     wait $am_sleep_pid 2>/dev/null\n-   fi\n-   AC_MSG_RESULT([done])])\n-rm -f conftest.file\n-])\n-\n-# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_SILENT_RULES([DEFAULT])\n-# --------------------------\n-# Enable less verbose build rules; with the default set to DEFAULT\n-# (\"yes\" being less verbose, \"no\" or empty being verbose).\n-AC_DEFUN([AM_SILENT_RULES],\n-[AC_ARG_ENABLE([silent-rules], [dnl\n-AS_HELP_STRING(\n-  [--enable-silent-rules],\n-  [less verbose build output (undo: \"make V=1\")])\n-AS_HELP_STRING(\n-  [--disable-silent-rules],\n-  [verbose build output (undo: \"make V=0\")])dnl\n-])\n-case $enable_silent_rules in @%:@ (((\n-  yes) AM_DEFAULT_VERBOSITY=0;;\n-   no) AM_DEFAULT_VERBOSITY=1;;\n-    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;\n-esac\n-dnl\n-dnl A few 'make' implementations (e.g., NonStop OS and NextStep)\n-dnl do not support nested variable expansions.\n-dnl See automake bug#9928 and bug#10237.\n-am_make=${MAKE-make}\n-AC_CACHE_CHECK([whether $am_make supports nested variables],\n-   [am_cv_make_support_nested_variables],\n-   [if AS_ECHO([['TRUE=$(BAR$(V))\n-BAR0=false\n-BAR1=true\n-V=1\n-am__doit:\n-\t@$(TRUE)\n-.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then\n-  am_cv_make_support_nested_variables=yes\n-else\n-  am_cv_make_support_nested_variables=no\n-fi])\n-if test $am_cv_make_support_nested_variables = yes; then\n-  dnl Using '$V' instead of '$(V)' breaks IRIX make.\n-  AM_V='$(V)'\n-  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\n-else\n-  AM_V=$AM_DEFAULT_VERBOSITY\n-  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\n-fi\n-AC_SUBST([AM_V])dnl\n-AM_SUBST_NOTMAKE([AM_V])dnl\n-AC_SUBST([AM_DEFAULT_V])dnl\n-AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl\n-AC_SUBST([AM_DEFAULT_VERBOSITY])dnl\n-AM_BACKSLASH='\\'\n-AC_SUBST([AM_BACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n-])\n-\n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor 'install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in \"make install-strip\", and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using 'strip' when the user\n-# run \"make install-strip\".  However 'strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the 'STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of 'v7', 'ustar', or 'pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-#\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-\n-# We'll loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-\n-m4_if([$1], [v7],\n-  [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-\n-  [m4_case([$1],\n-    [ustar],\n-     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.\n-      # There is notably a 21 bits limit for the UID and the GID.  In fact,\n-      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343\n-      # and bug#13588).\n-      am_max_uid=2097151 # 2^21 - 1\n-      am_max_gid=$am_max_uid\n-      # The $UID and $GID variables are not portable, so we need to resort\n-      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls\n-      # below are definitely unexpected, so allow the users to see them\n-      # (that is, avoid stderr redirection).\n-      am_uid=`id -u || echo unknown`\n-      am_gid=`id -g || echo unknown`\n-      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])\n-      if test $am_uid -le $am_max_uid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-         AC_MSG_RESULT([no])\n-         _am_tools=none\n-      fi\n-      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])\n-      if test $am_gid -le $am_max_gid; then\n-         AC_MSG_RESULT([yes])\n-      else\n-        AC_MSG_RESULT([no])\n-        _am_tools=none\n-      fi],\n-\n-  [pax],\n-    [],\n-\n-  [m4_fatal([Unknown tar format])])\n-\n-  AC_MSG_CHECKING([how to create a $1 tar archive])\n-\n-  # Go ahead even if we have the value already cached.  We do so because we\n-  # need to set the values for the 'am__tar' and 'am__untar' variables.\n-  _am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-\n-  for _am_tool in $_am_tools; do\n-    case $_am_tool in\n-    gnutar)\n-      for _am_tar in tar gnutar gtar; do\n-        AM_RUN_LOG([$_am_tar --version]) && break\n-      done\n-      am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-      am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-      am__untar=\"$_am_tar -xf -\"\n-      ;;\n-    plaintar)\n-      # Must skip GNU tar: if it does not support --format= it doesn't create\n-      # ustar tarball either.\n-      (tar --version) >/dev/null 2>&1 && continue\n-      am__tar='tar chf - \"$$tardir\"'\n-      am__tar_='tar chf - \"$tardir\"'\n-      am__untar='tar xf -'\n-      ;;\n-    pax)\n-      am__tar='pax -L -x $1 -w \"$$tardir\"'\n-      am__tar_='pax -L -x $1 -w \"$tardir\"'\n-      am__untar='pax -r'\n-      ;;\n-    cpio)\n-      am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-      am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-      am__untar='cpio -i -H $1 -d'\n-      ;;\n-    none)\n-      am__tar=false\n-      am__tar_=false\n-      am__untar=false\n-      ;;\n-    esac\n-\n-    # If the value was cached, stop now.  We just wanted to have am__tar\n-    # and am__untar set.\n-    test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-    # tar/untar a dummy directory, and stop if the command works.\n-    rm -rf conftest.dir\n-    mkdir conftest.dir\n-    echo GrepMe > conftest.dir/file\n-    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-    rm -rf conftest.dir\n-    if test -s conftest.tar; then\n-      AM_RUN_LOG([$am__untar <conftest.tar])\n-      AM_RUN_LOG([cat conftest.dir/file])\n-      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-    fi\n-  done\n-  rm -rf conftest.dir\n-\n-  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-  AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/acx.m4])\n-m4_include([../config/asmcfi.m4])\n-m4_include([../config/depstand.m4])\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/override.m4])\n-m4_include([../config/toolexeclibdir.m4])\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])\n-m4_include([acinclude.m4])"}, {"sha": "8d52ec4f4952898ed31a4a5418236e721df28196", "filename": "libffi/configure", "status": "removed", "additions": 0, "deletions": 19411, "changes": 19411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "70f6d2c2ea44a5b9e8f9a9ea5d7252bf82a03921", "filename": "libffi/configure.ac", "status": "modified", "additions": 122, "deletions": 77, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,40 +1,22 @@\n dnl Process this with autoconf to create configure\n \n+AC_PREREQ(2.68)\n \n-AC_INIT([libffi], [3.99999], [http://github.com/atgreen/libffi/issues])\n+AC_INIT([libffi], [3.4.2], [http://github.com/libffi/libffi/issues])\n AC_CONFIG_HEADERS([fficonfig.h])\n \n-AM_ENABLE_MULTILIB(, ..)\n-\n AC_CANONICAL_SYSTEM\n target_alias=${target_alias-$host_alias}\n \n-AM_INIT_AUTOMAKE([no-dist])\n-\n-# See if makeinfo has been installed and is modern enough\n-# that we can use it.\n-ACX_CHECK_PROG_VER([MAKEINFO], [makeinfo], [--version],\n-                   [GNU texinfo.* \\([0-9][0-9.]*\\)],\n-                   [4.[4-9]*|4.[1-9][0-9]*|[5-9]*|[1-9][0-9]*])\n-AM_CONDITIONAL(BUILD_INFO, test $gcc_cv_prog_makeinfo_modern = \"yes\")\n-\n-# We would like our source tree to be readonly. However when releases or\n-# pre-releases are generated, the flex/bison generated files as well as the\n-# various formats of manuals need to be included along with the rest of the\n-# sources.  Therefore we have --enable-generated-files-in-srcdir to do\n-# just that.\n-AC_MSG_CHECKING(generated-files-in-srcdir)\n-AC_ARG_ENABLE(generated-files-in-srcdir,\n-AS_HELP_STRING([--enable-generated-files-in-srcdir],\n- [put copies of generated files in source dir intended for creating source tarballs for users without texinfo bison or flex]),\n-[case \"$enableval\" in\n- yes) enable_generated_files_in_srcdir=yes ;;\n- no)  enable_generated_files_in_srcdir=no ;;\n- *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n- esac],\n-[enable_generated_files_in_srcdir=no])\n-AC_MSG_RESULT($enable_generated_files_in_srcdir)\n-AM_CONDITIONAL(GENINSRC, test \"$enable_generated_files_in_srcdir\" = yes)\n+case \"${host}\" in\n+  frv*-elf)\n+    LDFLAGS=`echo $LDFLAGS | sed \"s/\\-B[^ ]*libgloss\\/frv\\///\"`\\ -B`pwd`/../libgloss/frv/\n+    ;;\n+esac\n+\n+AX_ENABLE_BUILDDIR\n+\n+AM_INIT_AUTOMAKE\n \n # The same as in boehm-gc and libstdc++. Have to borrow it from there.\n # We must force CC to /not/ be precious variables; otherwise\n@@ -57,19 +39,38 @@ AC_SUBST(CFLAGS)\n AM_PROG_AS\n AM_PROG_CC_C_O\n AC_PROG_LIBTOOL\n+AC_CONFIG_MACRO_DIR([m4])\n+\n+AC_CHECK_TOOL(READELF, readelf)\n \n # Test for 64-bit build.\n AC_CHECK_SIZEOF([size_t])\n \n+AX_COMPILER_VENDOR\n+AX_CC_MAXOPT\n+# The AX_CFLAGS_WARN_ALL macro doesn't currently work for sunpro\n+# compiler.\n+if test \"$ax_cv_c_compiler_vendor\" != \"sun\"; then\n+  AX_CFLAGS_WARN_ALL\n+fi\n+\n+if test \"x$GCC\" = \"xyes\"; then\n+  CFLAGS=\"$CFLAGS -fexceptions\"\n+fi\n+\n cat > local.exp <<EOF\n set CC_FOR_TARGET \"$CC\"\n set CXX_FOR_TARGET \"$CXX\"\n+set compiler_vendor \"$ax_cv_c_compiler_vendor\"\n EOF\n \n AM_MAINTAINER_MODE\n \n+AC_CHECK_HEADERS(sys/memfd.h)\n+AC_CHECK_FUNCS([memfd_create])\n+\n AC_CHECK_HEADERS(sys/mman.h)\n-AC_CHECK_FUNCS([mmap mkostemp])\n+AC_CHECK_FUNCS([mmap mkostemp mkstemp])\n AC_FUNC_MMAP_BLACKLIST\n \n dnl The -no-testsuite modules omit the test subdir.\n@@ -181,6 +182,28 @@ case \"$TARGET\" in\n     ;;\n esac\n \n+AC_CACHE_CHECK([whether compiler supports pointer authentication],\n+   libffi_cv_as_ptrauth, [\n+   libffi_cv_as_ptrauth=unknown\n+   AC_TRY_COMPILE(,[\n+#ifdef __clang__\n+# if __has_feature(ptrauth_calls)\n+#  define HAVE_PTRAUTH 1\n+# endif\n+#endif\n+\n+#ifndef HAVE_PTRAUTH\n+# error Pointer authentication not supported\n+#endif\n+\t\t   ],\n+\t\t   [libffi_cv_as_ptrauth=yes],\n+\t\t   [libffi_cv_as_ptrauth=no])\n+])\n+if test \"x$libffi_cv_as_ptrauth\" = xyes; then\n+    AC_DEFINE(HAVE_PTRAUTH, 1,\n+\t      [Define if your compiler supports pointer authentication.])\n+fi\n+\n # On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n AC_ARG_ENABLE(pax_emutramp,\n   [  --enable-pax_emutramp       enable pax emulated trampolines, for we can't use PROT_EXEC],\n@@ -189,15 +212,20 @@ AC_ARG_ENABLE(pax_emutramp,\n       [Define this if you want to enable pax emulated trampolines])\n   fi)\n \n+LT_SYS_SYMBOL_USCORE\n+if test \"x$sys_symbol_underscore\" = xyes; then\n+    AC_DEFINE(SYMBOL_UNDERSCORE, 1, [Define if symbols are underscored.])\n+fi\n+\n FFI_EXEC_TRAMPOLINE_TABLE=0\n case \"$target\" in\n-     *arm*-apple-darwin* | aarch64-apple-darwin*)\n+     *arm*-apple-* | aarch64-apple-*)\n        FFI_EXEC_TRAMPOLINE_TABLE=1\n        AC_DEFINE(FFI_EXEC_TRAMPOLINE_TABLE, 1,\n                  [Cannot use PROT_EXEC on this target, so, we revert to\n                    alternative means])\n      ;;\n-     *-apple-darwin1* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris*)\n+     *-apple-* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris* | *-linux-android*)\n        AC_DEFINE(FFI_MMAP_EXEC_WRIT, 1,\n                  [Cannot use malloc on this target, so, we revert to\n                    alternative means])\n@@ -238,19 +266,15 @@ EOF\n fi\n \n if test \"x$GCC\" = \"xyes\"; then\n+  AX_CHECK_COMPILE_FLAG(-fno-lto, libffi_cv_no_lto=-fno-lto)\n+\n   AC_CACHE_CHECK([whether .eh_frame section should be read-only],\n       libffi_cv_ro_eh_frame, [\n-  \tlibffi_cv_ro_eh_frame=no\n+  \tlibffi_cv_ro_eh_frame=yes\n   \techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n-  \tif $CC $CFLAGS -c -fpic -fexceptions -o conftest.o conftest.c > /dev/null 2>&1; then\n-\t    objdump -h conftest.o > conftest.dump 2>&1\n-\t    libffi_eh_frame_line=`grep -n eh_frame conftest.dump | cut -d: -f 1`\n-\t    if test \"x$libffi_eh_frame_line\" != \"x\"; then\n-\t        libffi_test_line=`expr $libffi_eh_frame_line + 1`p\n-\t        sed -n $libffi_test_line conftest.dump > conftest.line\n-\t        if grep READONLY conftest.line > /dev/null; then\n-\t            libffi_cv_ro_eh_frame=yes\n-\t        fi\n+  \tif $CC $CFLAGS -c -fpic -fexceptions $libffi_cv_no_lto -o conftest.o conftest.c > /dev/null 2>&1; then\n+\t    if $READELF -WS conftest.o | grep -q -n 'eh_frame .* WA'; then\n+\t        libffi_cv_ro_eh_frame=no\n \t    fi\n   \tfi\n   \trm -f conftest.*\n@@ -270,7 +294,7 @@ if test \"x$GCC\" = \"xyes\"; then\n   \techo 'int __attribute__ ((visibility (\"hidden\"))) foo (void) { return 1  ; }' > conftest.c\n   \tlibffi_cv_hidden_visibility_attribute=no\n   \tif AC_TRY_COMMAND(${CC-cc} -Werror -S conftest.c -o conftest.s 1>&AS_MESSAGE_LOG_FD); then\n-  \t    if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n+  \t    if egrep '(\\.hidden|\\.private_extern).*foo' conftest.s >/dev/null; then\n   \t\tlibffi_cv_hidden_visibility_attribute=yes\n   \t    fi\n   \tfi\n@@ -282,10 +306,21 @@ if test \"x$GCC\" = \"xyes\"; then\n   fi\n fi\n \n+AC_ARG_ENABLE(docs,\n+              AC_HELP_STRING([--disable-docs],\n+                             [Disable building of docs (default: no)]),\n+              [enable_docs=no],\n+              [enable_docs=yes])\n+AM_CONDITIONAL(BUILD_DOCS, [test x$enable_docs = xyes])\n+\n AH_BOTTOM([\n #ifdef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE\n #ifdef LIBFFI_ASM\n+#ifdef __APPLE__\n+#define FFI_HIDDEN(name) .private_extern name\n+#else\n #define FFI_HIDDEN(name) .hidden name\n+#endif\n #else\n #define FFI_HIDDEN __attribute__ ((visibility (\"hidden\")))\n #endif\n@@ -331,57 +366,67 @@ AC_ARG_ENABLE(raw-api,\n     AC_DEFINE(FFI_NO_RAW_API, 1, [Define this if you do not want support for the raw API.])\n   fi)\n \n+AC_ARG_ENABLE(exec-static-tramp,\n+[  --disable-exec-static-tramp  disable use of static exec trampolines (enabled by default)])\n+\n+if test \"$enable_exec_static_tramp\" != no; then\n+case \"$target\" in\n+     *-cygwin*)\n+     ;;\n+     *arm*-*-linux-* | aarch64*-*-linux-* | i*86-*-linux-* | x86_64-*-linux-*)\n+       AC_DEFINE(FFI_EXEC_STATIC_TRAMP, 1,\n+                 [Define this if you want statically defined trampolines])\n+     ;;\n+esac\n+fi\n+\n AC_ARG_ENABLE(purify-safety,\n [  --enable-purify-safety  purify-safe mode],\n   if test \"$enable_purify_safety\" = \"yes\"; then\n     AC_DEFINE(USING_PURIFY, 1, [Define this if you are using Purify and want to suppress spurious messages.])\n   fi)\n \n-GCC_WITH_TOOLEXECLIBDIR\n-\n-if test -n \"$with_cross_host\" &&\n-   test x\"$with_cross_host\" != x\"no\"; then\n-  toolexecdir='$(exec_prefix)/$(target_alias)'\n-  case ${with_toolexeclibdir} in\n-    no)\n-      toolexeclibdir='$(toolexecdir)/lib'\n-      ;;\n-    *)\n-      toolexeclibdir=${with_toolexeclibdir}\n-      ;;\n-  esac\n+AC_ARG_ENABLE(multi-os-directory,\n+[  --disable-multi-os-directory\n+                          disable use of gcc --print-multi-os-directory to change the library installation directory])\n+                          \n+# These variables are only ever used when we cross-build to X86_WIN32.\n+# And we only support this with GCC, so...\n+if test \"x$GCC\" = \"xyes\"; then\n+  if test -n \"$with_cross_host\" &&\n+     test x\"$with_cross_host\" != x\"no\"; then\n+    toolexecdir='${exec_prefix}'/'$(target_alias)'\n+    toolexeclibdir='${toolexecdir}'/lib\n+  else\n+    toolexecdir='${libdir}'/gcc-lib/'$(target_alias)'\n+    toolexeclibdir='${libdir}'\n+  fi\n+  if test x\"$enable_multi_os_directory\" != x\"no\"; then\n+    multi_os_directory=`$CC $CFLAGS -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      ../*) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+  fi\n+  AC_SUBST(toolexecdir)\n else\n-  toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n-  toolexeclibdir='$(libdir)'\n+  toolexeclibdir='${libdir}'\n fi\n-multi_os_directory=`$CC -print-multi-os-directory`\n-case $multi_os_directory in\n-  .) ;; # Avoid trailing /.\n-  *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n-esac\n-AC_SUBST(toolexecdir)\n AC_SUBST(toolexeclibdir)\n \n-if test \"${multilib}\" = \"yes\"; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n # Check linker support.\n-LIBAT_ENABLE_SYMVERS\n-\n-# Determine what GCC version number to use in filesystem paths.\n-GCC_BASE_VER\n+LIBFFI_ENABLE_SYMVERS\n \n AC_CONFIG_COMMANDS(include, [test -d include || mkdir include])\n AC_CONFIG_COMMANDS(src, [\n test -d src || mkdir src\n test -d src/$TARGETDIR || mkdir src/$TARGETDIR\n ], [TARGETDIR=\"$TARGETDIR\"])\n \n-AC_CONFIG_LINKS(include/ffitarget.h:src/$TARGETDIR/ffitarget.h)\n-\n-AC_CONFIG_FILES(include/Makefile include/ffi.h Makefile testsuite/Makefile man/Makefile libffi.pc)\n+AC_CONFIG_FILES(include/Makefile include/ffi.h Makefile testsuite/Makefile man/Makefile doc/Makefile libffi.pc)\n \n AC_OUTPUT\n+\n+# Copy this file instead of using AC_CONFIG_LINK in order to support\n+# compiling with MSVC, which won't understand cygwin style symlinks.\n+cp ${srcdir}/src/$TARGETDIR/ffitarget.h include/ffitarget.h"}, {"sha": "268267183a031c292a53d3ab11ec475f13c51392", "filename": "libffi/configure.host", "status": "modified", "additions": 76, "deletions": 21, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.host?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -6,6 +6,13 @@\n # THIS TABLE IS SORTED.  KEEP IT THAT WAY.\n # Most of the time we can define all the variables all at once...\n case \"${host}\" in\n+  aarch64*-*-cygwin* | aarch64*-*-mingw* | aarch64*-*-win* )\n+\tTARGET=ARM_WIN64; TARGETDIR=aarch64\n+\tif test \"${ax_cv_c_compiler_vendor}\" = \"microsoft\"; then\n+\t  MSVC=1\n+\tfi\n+\t;;\n+\n   aarch64*-*-*)\n \tTARGET=AARCH64; TARGETDIR=aarch64\n \tSOURCES=\"ffi.c sysv.S\"\n@@ -23,6 +30,13 @@ case \"${host}\" in\n \tSOURCES=\"ffi.c arcompact.S\"\n \t;;\n \n+  arm*-*-cygwin* | arm*-*-mingw* | arm*-*-win* )\n+\tTARGET=ARM_WIN32; TARGETDIR=arm\n+\tif test \"${ax_cv_c_compiler_vendor}\" = \"microsoft\"; then\n+\t  MSVC=1\n+\tfi\n+\t;;\n+\n   arm*-*-*)\n \tTARGET=ARM; TARGETDIR=arm\n \tSOURCES=\"ffi.c sysv.S\"\n@@ -43,6 +57,11 @@ case \"${host}\" in\n \tSOURCES=\"ffi.c sysv.S\"\n \t;;\n \n+  csky-*-*)\n+        TARGET=CSKY; TARGETDIR=csky\n+        SOURCES=\"ffi.c sysv.S\"\n+        ;;\n+\n   frv-*-*)\n \tTARGET=FRV; TARGETDIR=frv\n \tSOURCES=\"ffi.c eabi.S\"\n@@ -64,14 +83,17 @@ case \"${host}\" in\n \tTARGET=X86_FREEBSD; TARGETDIR=x86\n \t;;\n \n-  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2* | i?86-*-interix* \\\n-  | x86_64-*-cygwin* | x86_64-*-mingw*)\n+  i?86-*-cygwin* | i?86-*-mingw* | i?86-*-win* | i?86-*-os2* | i?86-*-interix* \\\n+  | x86_64-*-cygwin* | x86_64-*-mingw* | x86_64-*-win* )\n \tTARGETDIR=x86\n \tif test $ac_cv_sizeof_size_t = 4; then\n \t  TARGET=X86_WIN32\n \telse\n \t  TARGET=X86_WIN64\n \tfi\n+\tif test \"${ax_cv_c_compiler_vendor}\" = \"microsoft\"; then\n+\t  MSVC=1\n+\tfi\n \t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n \t# We must also check with_cross_host to decide if this is a native\n \t# or cross-build and select where to install dlls appropriately.\n@@ -83,12 +105,12 @@ case \"${host}\" in\n \tfi\n \t;;\n \n-  i?86-*-darwin* | x86_64-*-darwin*)\n+  i?86-*-darwin* | x86_64-*-darwin* | i?86-*-ios | x86_64-*-ios)\n \tTARGETDIR=x86\n \tif test $ac_cv_sizeof_size_t = 4; then\n \t  TARGET=X86_DARWIN\n \telse\n-\t  TARGET=X86_64_DARWIN\n+\t  TARGET=X86_64\n \tfi\n \t;;\n \n@@ -97,11 +119,12 @@ case \"${host}\" in\n \tif test $ac_cv_sizeof_size_t = 4; then\n \t  echo 'int foo (void) { return __x86_64__; }' > conftest.c\n \t  if $CC $CFLAGS -Werror -S conftest.c -o conftest.s > /dev/null 2>&1; then\n-\t    TARGET=X86_64;\n+\t    TARGET_X32=yes\n+\t    TARGET=X86_64\n \t  else\n \t    TARGET=X86;\n-\t   fi\n-\t   rm -f conftest.*\n+\t  fi\n+\t  rm -f conftest.*\n \telse\n \t  TARGET=X86_64;\n \tfi\n@@ -112,6 +135,11 @@ case \"${host}\" in\n \tSOURCES=\"ffi.c unix.S\"\n \t;;\n \n+  kvx-*-*)\n+\tTARGET=KVX; TARGETDIR=kvx\n+\tSOURCES=\"ffi.c sysv.S\"\n+\t;;\n+\n   m32r*-*-*)\n \tTARGET=M32R; TARGETDIR=m32r\n \tSOURCES=\"ffi.c sysv.S\"\n@@ -145,7 +173,7 @@ case \"${host}\" in\n   mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)\n \tTARGET=MIPS; TARGETDIR=mips\n \t;;\n-  mips*-*linux* | mips*-*-openbsd*)\n+  mips*-*linux* | mips*-*-openbsd* | mips*-*-freebsd*)\n \t# Support 128-bit long double for NewABI.\n \tHAVE_LONG_DOUBLE='defined(__mips64)'\n \tTARGET=MIPS; TARGETDIR=mips\n@@ -156,7 +184,7 @@ case \"${host}\" in\n \tSOURCES=\"ffi.c sysv.S\"\n \t;;\n \n-  or1k*-linux*)\n+  or1k*-*-*)\n \tTARGET=OR1K; TARGETDIR=or1k\n \tSOURCES=\"ffi.c sysv.S\"\n \t;;\n@@ -168,6 +196,9 @@ case \"${host}\" in\n   powerpc-*-amigaos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n+  powerpc-*-eabi*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n   powerpc-*-beos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n@@ -177,11 +208,15 @@ case \"${host}\" in\n   powerpc-*-aix* | rs6000-*-aix*)\n \tTARGET=POWERPC_AIX; TARGETDIR=powerpc\n \t;;\n-  powerpc-*-freebsd* | powerpc-*-openbsd*)\n+  powerpc-*-freebsd* | powerpc-*-openbsd* | powerpc-*-netbsd*)\n \tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n \tHAVE_LONG_DOUBLE_VARIANT=1\n \t;;\n-  powerpc64-*-freebsd*)\n+  powerpcspe-*-freebsd*)\n+\tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n+\tCFLAGS=\"$CFLAGS -D__NO_FPRS__\"\n+\t;;\n+  powerpc64-*-freebsd* | powerpc64le-*-freebsd*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n   powerpc*-*-rtems*)\n@@ -230,6 +265,20 @@ esac\n \n # ... but some of the cases above share configury.\n case \"${TARGET}\" in\n+  ARM_WIN32)\n+\tif test \"$MSVC\" = 1; then\n+\t\tSOURCES=\"ffi.c sysv_msvc_arm32.S\"\n+\telse\n+\t\tSOURCES=\"ffi.c sysv.S\"\n+\tfi\n+\t;;\n+  ARM_WIN64)\n+\tif test \"$MSVC\" = 1; then\n+\t\tSOURCES=\"ffi.c win64_armasm.S\"\n+\telse\n+\t\tSOURCES=\"ffi.c sysv.S\"\n+\tfi\n+\t;;\n   MIPS)\n \tSOURCES=\"ffi.c o32.S n32.S\"\n \t;;\n@@ -246,20 +295,26 @@ case \"${TARGET}\" in\n   POWERPC_FREEBSD)\n \tSOURCES=\"ffi.c ffi_sysv.c sysv.S ppc_closure.S\"\n \t;;\n-  X86 | X86_FREEBSD | X86_WIN32)\n-\tSOURCES=\"ffi.c sysv.S\"\n+  X86 | X86_DARWIN | X86_FREEBSD | X86_WIN32)\n+\tif test \"$MSVC\" = 1; then\n+\t\tSOURCES=\"ffi.c sysv_intel.S\"\n+\telse\n+\t\tSOURCES=\"ffi.c sysv.S\"\n+\tfi\n \t;;\n   X86_64)\n-\tSOURCES=\"ffi64.c unix64.S\"\n+\tif test x\"$TARGET_X32\" = xyes; then\n+\t\tSOURCES=\"ffi64.c unix64.S\"\n+\telse\n+\t\tSOURCES=\"ffi64.c unix64.S ffiw64.c win64.S\"\n+\tfi\n \t;;\n   X86_WIN64)\n-\tSOURCES=\"ffiw64.c win64.S\"\n-\t;;\n-  X86_DARWIN)\n-\tSOURCES=\"darwin_c.c darwin.S\"\n-\t;;\n-  X86_64_DARWIN)\n-\tSOURCES=\"darwin64_c.c darwin64.S\"\n+\tif test \"$MSVC\" = 1; then\n+\t\tSOURCES=\"ffiw64.c win64_intel.S\"\n+\telse\n+\t\tSOURCES=\"ffiw64.c win64.S\"\n+\tfi\n \t;;\n esac\n "}, {"sha": "43b650aea7a2dc6ecd7a75baba9624024994b248", "filename": "libffi/doc/Makefile.am", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2FMakefile.am?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,3 @@\n+## Process this with automake to create Makefile.in\n+\n+info_TEXINFOS = libffi.texi"}, {"sha": "7fd3625d992b50e713721f8bae60bb9b397e99dd", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 333, "deletions": 49, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,7 +1,8 @@\n \\input texinfo   @c -*-texinfo-*-\n @c %**start of header\n @setfilename libffi.info\n-@settitle libffi\n+@include version.texi\n+@settitle libffi: the portable foreign function interface library\n @setchapternewpage off\n @c %**end of header\n \n@@ -12,32 +13,43 @@\n @syncodeindex pg cp\n @syncodeindex tp cp\n \n-@include version.texi\n-\n @copying\n \n-This manual is for Libffi, a portable foreign-function interface\n+This manual is for libffi, a portable foreign function interface\n library.\n \n-Copyright @copyright{} 2008, 2010, 2011 Red Hat, Inc.\n+Copyright @copyright{} 2008--2019, 2021 Anthony Green and Red Hat, Inc.\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n \n-@quotation\n-Permission is granted to copy, distribute and/or modify this document\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.  A copy of the license is included in the\n-section entitled ``GNU General Public License''.\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n-@end quotation\n @end copying\n \n @dircategory Development\n @direntry\n-* libffi: (libffi).             Portable foreign-function interface library.\n+* libffi: (libffi).             Portable foreign function interface library.\n @end direntry\n \n @titlepage\n-@title Libffi\n+@title libffi: a foreign function interface library\n+@subtitle For Version @value{VERSION} of libffi\n+@author Anthony Green\n @page\n @vskip 0pt plus 1filll\n @insertcopying\n@@ -53,6 +65,7 @@ section entitled ``GNU General Public License''.\n @menu\n * Introduction::                What is libffi?\n * Using libffi::                How to use libffi.\n+* Memory Usage::                Where memory for closures comes from.\n * Missing Features::            Things libffi can't do.\n * Index::                       Index.\n @end menu\n@@ -107,6 +120,7 @@ values passed between the two languages.\n * Multiple ABIs::               Different passing styles on one platform.\n * The Closure API::             Writing a generic function.\n * Closure Example::             A closure example.\n+* Thread Safety::               Thread safety.\n @end menu\n \n \n@@ -152,16 +166,21 @@ If the function being called is variadic (varargs) then\n @code{ffi_prep_cif_var} must be used instead of @code{ffi_prep_cif}.\n \n @findex ffi_prep_cif_var\n-@defun ffi_status ffi_prep_cif_var (ffi_cif *@var{cif}, ffi_abi var{abi}, unsigned int @var{nfixedargs}, unsigned int var{ntotalargs}, ffi_type *@var{rtype}, ffi_type **@var{argtypes})\n+@defun ffi_status ffi_prep_cif_var (ffi_cif *@var{cif}, ffi_abi @var{abi}, unsigned int @var{nfixedargs}, unsigned int @var{ntotalargs}, ffi_type *@var{rtype}, ffi_type **@var{argtypes})\n This initializes @var{cif} according to the given parameters for\n-a call to a variadic function.  In general it's operation is the\n+a call to a variadic function.  In general its operation is the\n same as for @code{ffi_prep_cif} except that:\n \n @var{nfixedargs} is the number of fixed arguments, prior to any\n variadic arguments.  It must be greater than zero.\n \n @var{ntotalargs} the total number of arguments, including variadic\n-and fixed arguments.\n+and fixed arguments.  @var{argtypes} must have this many elements.\n+\n+@code{ffi_prep_cif_var} will return @code{FFI_BAD_ARGTYPE} if any of\n+the variable argument types are @code{ffi_type_float} (promote to\n+@code{ffi_type_double} first), or any integer type small than an int\n+(promote to an int-sized type first).\n \n Note that, different cif's must be prepped for calls to the same\n function when different numbers of arguments are passed.\n@@ -172,6 +191,10 @@ Also note that a call to @code{ffi_prep_cif_var} with\n \n @end defun\n \n+Note that the resulting @code{ffi_cif} holds pointers to all the\n+@code{ffi_type} objects that were used during initialization.  You\n+must ensure that these type objects have a lifetime at least as long\n+as that of the @code{ffi_cif}.\n \n To call a function using an initialized @code{ffi_cif}, use the\n @code{ffi_call} function:\n@@ -190,12 +213,29 @@ to ensure this.  If @var{cif} declares that the function returns\n @code{void} (using @code{ffi_type_void}), then @var{rvalue} is\n ignored.\n \n+In most situations, @samp{libffi} will handle promotion according to\n+the ABI.  However, for historical reasons, there is a special case\n+with return values that must be handled by your code.  In particular,\n+for integral (not @code{struct}) types that are narrower than the\n+system register size, the return value will be widened by\n+@samp{libffi}.  @samp{libffi} provides a type, @code{ffi_arg}, that\n+can be used as the return type.  For example, if the CIF was defined\n+with a return type of @code{char}, @samp{libffi} will try to store a\n+full @code{ffi_arg} into the return value.\n+\n @var{avalues} is a vector of @code{void *} pointers that point to the\n memory locations holding the argument values for a call.  If @var{cif}\n declares that the function has no arguments (i.e., @var{nargs} was 0),\n then @var{avalues} is ignored.  Note that argument values may be\n modified by the callee (for instance, structs passed by value); the\n burden of copying pass-by-value arguments is placed on the caller.\n+\n+Note that while the return value must be register-sized, arguments\n+should exactly match their declared type.  For example, if an argument\n+is a @code{short}, then the entry in @var{avalues} should point to an\n+object declared as @code{short}; but if the return type is\n+@code{short}, then @var{rvalue} should point to an object declared as\n+a larger type -- usually @code{ffi_arg}.\n @end defun\n \n \n@@ -215,26 +255,26 @@ int main()\n   void *values[1];\n   char *s;\n   ffi_arg rc;\n-  \n-  /* Initialize the argument info vectors */    \n+\n+  /* Initialize the argument info vectors */\n   args[0] = &ffi_type_pointer;\n   values[0] = &s;\n-  \n+\n   /* Initialize the cif */\n-  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n+  if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t       &ffi_type_sint, args) == FFI_OK)\n     @{\n       s = \"Hello World!\";\n       ffi_call(&cif, puts, &rc, values);\n       /* rc now holds the result of the call to puts */\n-      \n-      /* values holds a pointer to the function's arg, so to \n-         call puts() again all we need to do is change the \n+\n+      /* values holds a pointer to the function's arg, so to\n+         call puts() again all we need to do is change the\n          value of s */\n       s = \"This is cool!\";\n       ffi_call(&cif, puts, &rc, values);\n     @}\n-  \n+\n   return 0;\n @}\n @end example\n@@ -246,6 +286,8 @@ int main()\n @menu\n * Primitive Types::             Built-in types.\n * Structures::                  Structure types.\n+* Size and Alignment::          Size and alignment of types.\n+* Arrays Unions Enums::         Arrays, unions, and enumerations.\n * Type Example::                Structure type example.\n * Complex::                     Complex types.\n * Complex Type Example::        Complex type example.\n@@ -370,8 +412,7 @@ when passing to @code{ffi_prep_cif}.\n @node Structures\n @subsection Structures\n \n-Although @samp{libffi} has no special support for unions or\n-bit-fields, it is perfectly happy passing structures back and forth.\n+@samp{libffi} is perfectly happy passing structures back and forth.\n You must first describe the structure to @samp{libffi} by creating a\n new @code{ffi_type} object for it.\n \n@@ -391,9 +432,166 @@ For a structure, this should be set to @code{FFI_TYPE_STRUCT}.\n @item ffi_type **elements\n This is a @samp{NULL}-terminated array of pointers to @code{ffi_type}\n objects.  There is one element per field of the struct.\n+\n+Note that @samp{libffi} has no special support for bit-fields.  You\n+must manage these manually.\n @end table\n @end deftp\n \n+The @code{size} and @code{alignment} fields will be filled in by\n+@code{ffi_prep_cif} or @code{ffi_prep_cif_var}, as needed.\n+\n+@node Size and Alignment\n+@subsection Size and Alignment\n+\n+@code{libffi} will set the @code{size} and @code{alignment} fields of\n+an @code{ffi_type} object for you.  It does so using its knowledge of\n+the ABI.\n+\n+You might expect that you can simply read these fields for a type that\n+has been laid out by @code{libffi}.  However, there are some caveats.\n+\n+@itemize @bullet\n+@item\n+The size or alignment of some of the built-in types may vary depending\n+on the chosen ABI.\n+\n+@item\n+The size and alignment of a new structure type will not be set by\n+@code{libffi} until it has been passed to @code{ffi_prep_cif} or\n+@code{ffi_get_struct_offsets}.\n+\n+@item\n+A structure type cannot be shared across ABIs.  Instead each ABI needs\n+its own copy of the structure type.\n+@end itemize\n+\n+So, before examining these fields, it is safest to pass the\n+@code{ffi_type} object to @code{ffi_prep_cif} or\n+@code{ffi_get_struct_offsets} first.  This function will do all the\n+needed setup.\n+\n+@example\n+ffi_type *desired_type;\n+ffi_abi desired_abi;\n+@dots{}\n+ffi_cif cif;\n+if (ffi_prep_cif (&cif, desired_abi, 0, desired_type, NULL) == FFI_OK)\n+  @{\n+    size_t size = desired_type->size;\n+    unsigned short alignment = desired_type->alignment;\n+  @}\n+@end example\n+\n+@code{libffi} also provides a way to get the offsets of the members of\n+a structure.\n+\n+@findex ffi_get_struct_offsets\n+@defun ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type, size_t *offsets)\n+Compute the offset of each element of the given structure type.\n+@var{abi} is the ABI to use; this is needed because in some cases the\n+layout depends on the ABI.\n+\n+@var{offsets} is an out parameter.  The caller is responsible for\n+providing enough space for all the results to be written -- one\n+element per element type in @var{struct_type}.  If @var{offsets} is\n+@code{NULL}, then the type will be laid out but not otherwise\n+modified.  This can be useful for accessing the type's size or layout,\n+as mentioned above.\n+\n+This function returns @code{FFI_OK} on success; @code{FFI_BAD_ABI} if\n+@var{abi} is invalid; or @code{FFI_BAD_TYPEDEF} if @var{struct_type}\n+is invalid in some way.  Note that only @code{FFI_STRUCT} types are\n+valid here.\n+@end defun\n+\n+@node Arrays Unions Enums\n+@subsection Arrays, Unions, and Enumerations\n+\n+@subsubsection Arrays\n+\n+@samp{libffi} does not have direct support for arrays or unions.\n+However, they can be emulated using structures.\n+\n+To emulate an array, simply create an @code{ffi_type} using\n+@code{FFI_TYPE_STRUCT} with as many members as there are elements in\n+the array.\n+\n+@example\n+ffi_type array_type;\n+ffi_type **elements\n+int i;\n+\n+elements = malloc ((n + 1) * sizeof (ffi_type *));\n+for (i = 0; i < n; ++i)\n+  elements[i] = array_element_type;\n+elements[n] = NULL;\n+\n+array_type.size = array_type.alignment = 0;\n+array_type.type = FFI_TYPE_STRUCT;\n+array_type.elements = elements;\n+@end example\n+\n+Note that arrays cannot be passed or returned by value in C --\n+structure types created like this should only be used to refer to\n+members of real @code{FFI_TYPE_STRUCT} objects.\n+\n+However, a phony array type like this will not cause any errors from\n+@samp{libffi} if you use it as an argument or return type.  This may\n+be confusing.\n+\n+@subsubsection Unions\n+\n+A union can also be emulated using @code{FFI_TYPE_STRUCT}.  In this\n+case, however, you must make sure that the size and alignment match\n+the real requirements of the union.\n+\n+One simple way to do this is to ensue that each element type is laid\n+out.  Then, give the new structure type a single element; the size of\n+the largest element; and the largest alignment seen as well.\n+\n+This example uses the @code{ffi_prep_cif} trick to ensure that each\n+element type is laid out.\n+\n+@example\n+ffi_abi desired_abi;\n+ffi_type union_type;\n+ffi_type **union_elements;\n+\n+int i;\n+ffi_type element_types[2];\n+\n+element_types[1] = NULL;\n+\n+union_type.size = union_type.alignment = 0;\n+union_type.type = FFI_TYPE_STRUCT;\n+union_type.elements = element_types;\n+\n+for (i = 0; union_elements[i]; ++i)\n+  @{\n+    ffi_cif cif;\n+    if (ffi_prep_cif (&cif, desired_abi, 0, union_elements[i], NULL) == FFI_OK)\n+      @{\n+        if (union_elements[i]->size > union_type.size)\n+          @{\n+            union_type.size = union_elements[i];\n+            size = union_elements[i]->size;\n+          @}\n+        if (union_elements[i]->alignment > union_type.alignment)\n+          union_type.alignment = union_elements[i]->alignment;\n+      @}\n+  @}\n+@end example\n+\n+@subsubsection Enumerations\n+\n+@code{libffi} does not have any special support for C @code{enum}s.\n+Although any given @code{enum} is implemented using a specific\n+underlying integral type, exactly which type will be used cannot be\n+determined by @code{libffi} -- it may depend on the values in the\n+enumeration or on compiler flags such as @option{-fshort-enums}.\n+@xref{Structures unions enumerations and bit-fields implementation, , , gcc},\n+for more information about how GCC handles enumerations.\n \n @node Type Example\n @subsection Type Example\n@@ -432,7 +630,7 @@ Here is the corresponding code to describe this struct to\n       tm_type.size = tm_type.alignment = 0;\n       tm_type.type = FFI_TYPE_STRUCT;\n       tm_type.elements = &tm_type_elements;\n-    \n+\n       for (i = 0; i < 9; i++)\n           tm_type_elements[i] = &ffi_type_sint;\n \n@@ -630,30 +828,47 @@ the closure function:\n \n @findex ffi_prep_closure_loc\n @defun ffi_status ffi_prep_closure_loc (ffi_closure *@var{closure}, ffi_cif *@var{cif}, void (*@var{fun}) (ffi_cif *@var{cif}, void *@var{ret}, void **@var{args}, void *@var{user_data}), void *@var{user_data}, void *@var{codeloc})\n-Prepare a closure function.\n+Prepare a closure function.  The arguments to\n+@code{ffi_prep_closure_loc} are:\n \n-@var{closure} is the address of a @code{ffi_closure} object; this is\n-the writable address returned by @code{ffi_closure_alloc}.\n+@table @var\n+@item closure\n+The address of a @code{ffi_closure} object; this is the writable\n+address returned by @code{ffi_closure_alloc}.\n+\n+@item cif\n+The @code{ffi_cif} describing the function parameters.  Note that this\n+object, and the types to which it refers, must be kept alive until the\n+closure itself is freed.\n \n-@var{cif} is the @code{ffi_cif} describing the function parameters.\n+@item user_data\n+An arbitrary datum that is passed, uninterpreted, to your closure\n+function.\n \n-@var{user_data} is an arbitrary datum that is passed, uninterpreted,\n-to your closure function.\n+@item codeloc\n+The executable address returned by @code{ffi_closure_alloc}.\n \n-@var{codeloc} is the executable address returned by\n-@code{ffi_closure_alloc}.\n+@item fun\n+The function which will be called when the closure is invoked.  It is\n+called with the arguments:\n \n-@var{fun} is the function which will be called when the closure is\n-invoked.  It is called with the arguments:\n @table @var\n @item cif\n The @code{ffi_cif} passed to @code{ffi_prep_closure_loc}.\n \n @item ret\n A pointer to the memory used for the function's return value.\n-@var{fun} must fill this, unless the function is declared as returning\n-@code{void}.\n-@c FIXME: is this NULL for void-returning functions?\n+\n+If the function is declared as returning @code{void}, then this value\n+is garbage and should not be used.\n+\n+Otherwise, @var{fun} must fill the object to which this points,\n+following the same special promotion behavior as @code{ffi_call}.\n+That is, in most cases, @var{ret} points to an object of exactly the\n+size of the type specified when @var{cif} was constructed.  However,\n+integral types narrower than the system register size are widened.  In\n+these cases your program may assume that @var{ret} points to an\n+@code{ffi_arg} object.\n \n @item args\n A vector of pointers to memory holding the arguments to the function.\n@@ -662,10 +877,10 @@ A vector of pointers to memory holding the arguments to the function.\n The same @var{user_data} that was passed to\n @code{ffi_prep_closure_loc}.\n @end table\n+@end table\n \n @code{ffi_prep_closure_loc} will return @code{FFI_OK} if everything\n-went ok, and something else on error.\n-@c FIXME: what?\n+went ok, and one of the other @code{ffi_status} values on error.\n \n After calling @code{ffi_prep_closure_loc}, you can cast @var{codeloc}\n to the appropriate pointer-to-function type.\n@@ -678,7 +893,7 @@ writable and executable addresses.\n @node Closure Example\n @section Closure Example\n \n-A trivial example that creates a new @code{puts} by binding \n+A trivial example that creates a new @code{puts} by binding\n @code{fputs} with @code{stdout}.\n \n @example\n@@ -733,6 +948,77 @@ int main()\n \n @end example\n \n+@node Thread Safety\n+@section Thread Safety\n+\n+@code{libffi} is not completely thread-safe.  However, many parts are,\n+and if you follow some simple rules, you can use it safely in a\n+multi-threaded program.\n+\n+@itemize @bullet\n+@item\n+@code{ffi_prep_cif} may modify the @code{ffi_type} objects passed to\n+it.  It is best to ensure that only a single thread prepares a given\n+@code{ffi_cif} at a time.\n+\n+@item\n+On some platforms, @code{ffi_prep_cif} may modify the size and\n+alignment of some types, depending on the chosen ABI.  On these\n+platforms, if you switch between ABIs, you must ensure that there is\n+only one call to @code{ffi_prep_cif} at a time.\n+\n+Currently the only affected platform is PowerPC and the only affected\n+type is @code{long double}.\n+@end itemize\n+\n+@node Memory Usage\n+@chapter Memory Usage\n+\n+Note that memory allocated by @code{ffi_closure_alloc} and freed by\n+@code{ffi_closure_free} does not come from the same general pool of\n+memory that @code{malloc} and @code{free} use.  To accomodate security\n+settings, @samp{libffi} may aquire memory, for example, by mapping\n+temporary files into multiple places in the address space (once to\n+write out the closure, a second to execute it).  The search follows\n+this list, using the first that works:\n+\n+@itemize @bullet\n+\n+@item\n+A anonymous mapping (i.e. not file-backed)\n+\n+@item\n+@code{memfd_create()}, if the kernel supports it.\n+\n+@item\n+A file created in the directory referenced by the environment variable\n+@code{LIBFFI_TMPDIR}.\n+\n+@item\n+Likewise for the environment variable @code{TMPDIR}.\n+\n+@item\n+A file created in @code{/tmp}.\n+\n+@item\n+A file created in @code{/var/tmp}.\n+\n+@item\n+A file created in @code{/dev/shm}.\n+\n+@item\n+A file created in the user's home directory (@code{$HOME}).\n+\n+@item\n+A file created in any directory listed in @code{/etc/mtab}.\n+\n+@item\n+A file created in any directory listed in @code{/proc/mounts}.\n+\n+@end itemize\n+\n+If security settings prohibit using any of these for closures,\n+@code{ffi_closure_alloc} will fail.\n \n @node Missing Features\n @chapter Missing Features\n@@ -749,13 +1035,11 @@ There is no support for bit fields in structures.\n \n @item\n The ``raw'' API is undocumented.\n-@c argument promotion?\n-@c unions?\n @c anything else?\n-@end itemize\n \n-Note that variadic support is very new and tested on a relatively\n-small number of platforms.\n+@item\n+The Go API is undocumented.\n+@end itemize\n \n @node Index\n @unnumbered Index"}, {"sha": "f2b741e87e467458bbfbd8a0d59441c7d8027aa0", "filename": "libffi/doc/version.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2Fversion.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fdoc%2Fversion.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Fversion.texi?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,4 +1,4 @@\n-@set UPDATED 8 November 2014\n-@set UPDATED-MONTH November 2014\n-@set EDITION 3.2.1\n-@set VERSION 3.2.1\n+@set UPDATED 27 June 2021\n+@set UPDATED-MONTH June 2021\n+@set EDITION 3.4.2\n+@set VERSION 3.4.2"}, {"sha": "2cf8de930614e0d1a0c16d579f1ce3cb5112ca56", "filename": "libffi/fficonfig.h.in", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,208 +0,0 @@\n-/* fficonfig.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-#undef AC_APPLE_UNIVERSAL_BUILD\n-\n-/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP\n-   systems. This function is required for `alloca.c' support on those systems.\n-   */\n-#undef CRAY_STACKSEG_END\n-\n-/* Define to 1 if using `alloca.c'. */\n-#undef C_ALLOCA\n-\n-/* Define to the flags needed for the .section .eh_frame directive. */\n-#undef EH_FRAME_FLAGS\n-\n-/* Define this if you want extra debugging. */\n-#undef FFI_DEBUG\n-\n-/* Cannot use PROT_EXEC on this target, so, we revert to alternative means */\n-#undef FFI_EXEC_TRAMPOLINE_TABLE\n-\n-/* Define this if you want to enable pax emulated trampolines */\n-#undef FFI_MMAP_EXEC_EMUTRAMP_PAX\n-\n-/* Cannot use malloc on this target, so, we revert to alternative means */\n-#undef FFI_MMAP_EXEC_WRIT\n-\n-/* Define this if you do not want support for the raw API. */\n-#undef FFI_NO_RAW_API\n-\n-/* Define this if you do not want support for aggregate types. */\n-#undef FFI_NO_STRUCTS\n-\n-/* Define to 1 if you have `alloca', as a function or macro. */\n-#undef HAVE_ALLOCA\n-\n-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).\n-   */\n-#undef HAVE_ALLOCA_H\n-\n-/* Define if your assembler supports .cfi_* directives. */\n-#undef HAVE_AS_CFI_PSEUDO_OP\n-\n-/* Define if your assembler supports .register. */\n-#undef HAVE_AS_REGISTER_PSEUDO_OP\n-\n-/* Define if the compiler uses zarch features. */\n-#undef HAVE_AS_S390_ZARCH\n-\n-/* Define if your assembler and linker support unaligned PC relative relocs.\n-   */\n-#undef HAVE_AS_SPARC_UA_PCREL\n-\n-/* Define if your assembler supports unwind section type. */\n-#undef HAVE_AS_X86_64_UNWIND_SECTION_TYPE\n-\n-/* Define if your assembler supports PC relative relocs. */\n-#undef HAVE_AS_X86_PCREL\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#undef HAVE_DLFCN_H\n-\n-/* Define if __attribute__((visibility(\"hidden\"))) is supported. */\n-#undef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#undef HAVE_INTTYPES_H\n-\n-/* Define if you have the long double type and it is bigger than a double */\n-#undef HAVE_LONG_DOUBLE\n-\n-/* Define if you support more than one size of the long double type */\n-#undef HAVE_LONG_DOUBLE_VARIANT\n-\n-/* Define to 1 if you have the `memcpy' function. */\n-#undef HAVE_MEMCPY\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#undef HAVE_MEMORY_H\n-\n-/* Define to 1 if you have the `mkostemp' function. */\n-#undef HAVE_MKOSTEMP\n-\n-/* Define to 1 if you have the `mmap' function. */\n-#undef HAVE_MMAP\n-\n-/* Define if mmap with MAP_ANON(YMOUS) works. */\n-#undef HAVE_MMAP_ANON\n-\n-/* Define if mmap of /dev/zero works. */\n-#undef HAVE_MMAP_DEV_ZERO\n-\n-/* Define if read-only mmap of a plain file works. */\n-#undef HAVE_MMAP_FILE\n-\n-/* Define if .eh_frame sections should be read-only. */\n-#undef HAVE_RO_EH_FRAME\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#undef HAVE_STDINT_H\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#undef HAVE_STDLIB_H\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#undef HAVE_STRINGS_H\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#undef HAVE_STRING_H\n-\n-/* Define to 1 if you have the <sys/mman.h> header file. */\n-#undef HAVE_SYS_MMAN_H\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#undef HAVE_SYS_STAT_H\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#undef HAVE_SYS_TYPES_H\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#undef HAVE_UNISTD_H\n-\n-/* Define to 1 if GNU symbol versioning is used for libatomic. */\n-#undef LIBAT_GNU_SYMBOL_VERSIONING\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#undef LT_OBJDIR\n-\n-/* Name of package */\n-#undef PACKAGE\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#undef PACKAGE_BUGREPORT\n-\n-/* Define to the full name of this package. */\n-#undef PACKAGE_NAME\n-\n-/* Define to the full name and version of this package. */\n-#undef PACKAGE_STRING\n-\n-/* Define to the one symbol short name of this package. */\n-#undef PACKAGE_TARNAME\n-\n-/* Define to the home page for this package. */\n-#undef PACKAGE_URL\n-\n-/* Define to the version of this package. */\n-#undef PACKAGE_VERSION\n-\n-/* The size of `double', as computed by sizeof. */\n-#undef SIZEOF_DOUBLE\n-\n-/* The size of `long double', as computed by sizeof. */\n-#undef SIZEOF_LONG_DOUBLE\n-\n-/* The size of `size_t', as computed by sizeof. */\n-#undef SIZEOF_SIZE_T\n-\n-/* If using the C implementation of alloca, define if you know the\n-   direction of stack growth for your system; otherwise it will be\n-   automatically deduced at runtime.\n-\tSTACK_DIRECTION > 0 => grows toward higher addresses\n-\tSTACK_DIRECTION < 0 => grows toward lower addresses\n-\tSTACK_DIRECTION = 0 => direction of growth unknown */\n-#undef STACK_DIRECTION\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#undef STDC_HEADERS\n-\n-/* Define this if you are using Purify and want to suppress spurious messages.\n-   */\n-#undef USING_PURIFY\n-\n-/* Version number of package */\n-#undef VERSION\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-#  undef WORDS_BIGENDIAN\n-# endif\n-#endif\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-#undef size_t\n-\n-\n-#ifdef HAVE_HIDDEN_VISIBILITY_ATTRIBUTE\n-#ifdef LIBFFI_ASM\n-#define FFI_HIDDEN(name) .hidden name\n-#else\n-#define FFI_HIDDEN __attribute__ ((visibility (\"hidden\")))\n-#endif\n-#else\n-#ifdef LIBFFI_ASM\n-#define FFI_HIDDEN(name)\n-#else\n-#define FFI_HIDDEN\n-#endif\n-#endif\n-"}, {"sha": "9921b0d99d8c464e12be3cf5351f84282dc19544", "filename": "libffi/generate-darwin-source-and-headers.py", "status": "modified", "additions": 99, "deletions": 44, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fgenerate-darwin-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fgenerate-darwin-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-darwin-source-and-headers.py?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -6,59 +6,73 @@\n import glob\n import argparse\n \n+\n class Platform(object):\n     pass\n \n+\n class simulator_platform(Platform):\n-    directory = 'darwin_ios'\n-    sdk = 'iphonesimulator'\n     arch = 'i386'\n     triple = 'i386-apple-darwin11'\n-    version_min = '-miphoneos-version-min=7.0'\n \n     prefix = \"#ifdef __i386__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n     src_dir = 'x86'\n-    src_files = ['darwin.S', 'win32.S', 'ffi.c']\n+    src_files = ['sysv.S', 'ffi.c', 'internal.h']\n \n \n class simulator64_platform(Platform):\n-    directory = 'darwin_ios'\n-    sdk = 'iphonesimulator'\n     arch = 'x86_64'\n     triple = 'x86_64-apple-darwin13'\n-    version_min = '-miphoneos-version-min=7.0'\n \n     prefix = \"#ifdef __x86_64__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n     src_dir = 'x86'\n-    src_files = ['darwin64.S', 'ffi64.c']\n+    src_files = ['unix64.S', 'ffi64.c', 'ffiw64.c', 'win64.S', 'internal64.h', 'asmnames.h']\n \n \n class device_platform(Platform):\n-    directory = 'darwin_ios'\n-    sdk = 'iphoneos'\n     arch = 'armv7'\n     triple = 'arm-apple-darwin11'\n-    version_min = '-miphoneos-version-min=7.0'\n \n     prefix = \"#ifdef __arm__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n     src_dir = 'arm'\n-    src_files = ['sysv.S', 'trampoline.S', 'ffi.c']\n+    src_files = ['sysv.S', 'ffi.c', 'internal.h']\n \n \n class device64_platform(Platform):\n-    directory = 'darwin_ios'\n-    sdk = 'iphoneos'\n     arch = 'arm64'\n     triple = 'aarch64-apple-darwin13'\n-    version_min = '-miphoneos-version-min=7.0'\n \n     prefix = \"#ifdef __arm64__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n     src_dir = 'aarch64'\n-    src_files = ['sysv.S', 'ffi.c']\n+    src_files = ['sysv.S', 'ffi.c', 'internal.h']\n+\n+\n+class ios_simulator_platform(simulator_platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphonesimulator'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+\n+class ios_simulator64_platform(simulator64_platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphonesimulator'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+\n+class ios_device_platform(device_platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphoneos'\n+    version_min = '-miphoneos-version-min=7.0'\n+\n+\n+class ios_device64_platform(device64_platform):\n+    directory = 'darwin_ios'\n+    sdk = 'iphoneos'\n+    version_min = '-miphoneos-version-min=7.0'\n \n \n class desktop32_platform(Platform):\n@@ -68,7 +82,7 @@ class desktop32_platform(Platform):\n     triple = 'i386-apple-darwin10'\n     version_min = '-mmacosx-version-min=10.6'\n     src_dir = 'x86'\n-    src_files = ['darwin.S', 'win32.S', 'ffi.c']\n+    src_files = ['sysv.S', 'ffi.c', 'internal.h']\n \n     prefix = \"#ifdef __i386__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n@@ -84,16 +98,39 @@ class desktop64_platform(Platform):\n     prefix = \"#ifdef __x86_64__\\n\\n\"\n     suffix = \"\\n\\n#endif\"\n     src_dir = 'x86'\n-    src_files = ['darwin64.S', 'ffi64.c']\n+    src_files = ['unix64.S', 'ffi64.c', 'ffiw64.c', 'win64.S', 'internal64.h', 'asmnames.h']\n+\n+\n+class tvos_simulator64_platform(simulator64_platform):\n+    directory = 'darwin_tvos'\n+    sdk = 'appletvsimulator'\n+    version_min = '-mtvos-version-min=9.0'\n+\n+\n+class tvos_device64_platform(device64_platform):\n+    directory = 'darwin_tvos'\n+    sdk = 'appletvos'\n+    version_min = '-mtvos-version-min=9.0'\n+\n+\n+class watchos_simulator_platform(simulator_platform):\n+    directory = 'darwin_watchos'\n+    sdk = 'watchsimulator'\n+    version_min = '-mwatchos-version-min=4.0'\n+\n+\n+class watchos_device_platform(device_platform):\n+    directory = 'darwin_watchos'\n+    sdk = 'watchos'\n+    arch = 'armv7k'\n+    version_min = '-mwatchos-version-min=4.0'\n \n \n def mkdir_p(path):\n     try:\n         os.makedirs(path)\n     except OSError as exc:  # Python >2.5\n-        if exc.errno == errno.EEXIST:\n-            pass\n-        else:\n+        if exc.errno != errno.EEXIST:\n             raise\n \n \n@@ -102,8 +139,11 @@ def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''\n     out_filename = filename\n \n     if file_suffix:\n-        split_name = os.path.splitext(filename)\n-        out_filename = \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n+        if filename in ['internal64.h', 'asmnames.h', 'internal.h']:\n+            out_filename = filename\n+        else:\n+            split_name = os.path.splitext(filename)\n+            out_filename = \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n \n     with open(os.path.join(src_dir, filename)) as in_file:\n         with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n@@ -142,7 +182,7 @@ def xcrun_cmd(cmd):\n     mkdir_p(build_dir)\n     env = dict(CC=xcrun_cmd('clang'),\n                LD=xcrun_cmd('ld'),\n-               CFLAGS='%s' % (platform.version_min))\n+               CFLAGS='%s -fembed-bitcode' % (platform.version_min))\n     working_dir = os.getcwd()\n     try:\n         os.chdir(build_dir)\n@@ -162,39 +202,47 @@ def xcrun_cmd(cmd):\n             platform_headers[filename].add((platform.prefix, platform.arch, platform.suffix))\n \n \n-def make_tramp():\n-    with open('src/arm/trampoline.S', 'w') as tramp_out:\n-        p = subprocess.Popen(['bash', 'src/arm/gentramp.sh'], stdout=tramp_out)\n-        p.wait()\n-\n-\n-def generate_source_and_headers(generate_osx=True, generate_ios=True):\n+def generate_source_and_headers(\n+    generate_osx=True,\n+    generate_ios=True,\n+    generate_tvos=True,\n+    generate_watchos=True,\n+):\n     copy_files('src', 'darwin_common/src', pattern='*.c')\n     copy_files('include', 'darwin_common/include', pattern='*.h')\n \n     if generate_ios:\n-        make_tramp()\n-        copy_src_platform_files(simulator_platform)\n-        copy_src_platform_files(simulator64_platform)\n-        copy_src_platform_files(device_platform)\n-        copy_src_platform_files(device64_platform)\n+        copy_src_platform_files(ios_simulator_platform)\n+        copy_src_platform_files(ios_simulator64_platform)\n+        copy_src_platform_files(ios_device_platform)\n+        copy_src_platform_files(ios_device64_platform)\n     if generate_osx:\n-        copy_src_platform_files(desktop32_platform)\n         copy_src_platform_files(desktop64_platform)\n+    if generate_tvos:\n+        copy_src_platform_files(tvos_simulator64_platform)\n+        copy_src_platform_files(tvos_device64_platform)\n+    if generate_watchos:\n+        copy_src_platform_files(watchos_simulator_platform)\n+        copy_src_platform_files(watchos_device_platform)\n \n     platform_headers = collections.defaultdict(set)\n \n     if generate_ios:\n-        build_target(simulator_platform, platform_headers)\n-        build_target(simulator64_platform, platform_headers)\n-        build_target(device_platform, platform_headers)\n-        build_target(device64_platform, platform_headers)\n+        build_target(ios_simulator_platform, platform_headers)\n+        build_target(ios_simulator64_platform, platform_headers)\n+        build_target(ios_device_platform, platform_headers)\n+        build_target(ios_device64_platform, platform_headers)\n     if generate_osx:\n-        build_target(desktop32_platform, platform_headers)\n         build_target(desktop64_platform, platform_headers)\n+    if generate_tvos:\n+        build_target(tvos_simulator64_platform, platform_headers)\n+        build_target(tvos_device64_platform, platform_headers)\n+    if generate_watchos:\n+        build_target(watchos_simulator_platform, platform_headers)\n+        build_target(watchos_device_platform, platform_headers)\n \n     mkdir_p('darwin_common/include')\n-    for header_name, tag_tuples in platform_headers.iteritems():\n+    for header_name, tag_tuples in platform_headers.items():\n         basename, suffix = os.path.splitext(header_name)\n         with open(os.path.join('darwin_common/include', header_name), 'w') as header:\n             for tag_tuple in tag_tuples:\n@@ -204,6 +252,13 @@ def generate_source_and_headers(generate_osx=True, generate_ios=True):\n     parser = argparse.ArgumentParser()\n     parser.add_argument('--only-ios', action='store_true', default=False)\n     parser.add_argument('--only-osx', action='store_true', default=False)\n+    parser.add_argument('--only-tvos', action='store_true', default=False)\n+    parser.add_argument('--only-watchos', action='store_true', default=False)\n     args = parser.parse_args()\n \n-    generate_source_and_headers(generate_osx=not args.only_ios, generate_ios=not args.only_osx)\n+    generate_source_and_headers(\n+        generate_osx=not args.only_ios and not args.only_tvos and not args.only_watchos,\n+        generate_ios=not args.only_osx and not args.only_tvos and not args.only_watchos,\n+        generate_tvos=not args.only_ios and not args.only_osx and not args.only_watchos,\n+        generate_watchos=not args.only_ios and not args.only_osx and not args.only_tvos,\n+    )"}, {"sha": "5f0d4066f4a97a95fc67c2c866664d46bf2d128d", "filename": "libffi/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.am?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -3,11 +3,7 @@\n AUTOMAKE_OPTIONS=foreign\n \n DISTCLEANFILES=ffitarget.h\n-noinst_HEADERS=ffi_common.h ffi_cfi.h\n+noinst_HEADERS=ffi_common.h ffi_cfi.h tramp.h\n EXTRA_DIST=ffi.h.in\n \n-# Where generated headers like ffitarget.h get installed.\n-gcc_version   := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n-toollibffidir := $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n-\n-toollibffi_HEADERS = ffi.h ffitarget.h\n+nodist_include_HEADERS = ffi.h ffitarget.h"}, {"sha": "99da8410d8b64c7f27c1bdc75ad3643868ddb353", "filename": "libffi/include/Makefile.in", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2FMakefile.in?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,565 +0,0 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n-\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-VPATH = @srcdir@\n-am__is_gnu_make = { \\\n-  if test -z '$(MAKELEVEL)'; then \\\n-    false; \\\n-  elif test -n '$(MAKE_HOST)'; then \\\n-    true; \\\n-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n-    true; \\\n-  else \\\n-    false; \\\n-  fi; \\\n-}\n-am__make_running_with_option = \\\n-  case $${target_option-} in \\\n-      ?) ;; \\\n-      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n-              \"target option '$${target_option-}' specified\" >&2; \\\n-         exit 1;; \\\n-  esac; \\\n-  has_opt=no; \\\n-  sane_makeflags=$$MAKEFLAGS; \\\n-  if $(am__is_gnu_make); then \\\n-    sane_makeflags=$$MFLAGS; \\\n-  else \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        bs=\\\\; \\\n-        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n-          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n-    esac; \\\n-  fi; \\\n-  skip_next=no; \\\n-  strip_trailopt () \\\n-  { \\\n-    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n-  }; \\\n-  for flg in $$sane_makeflags; do \\\n-    test $$skip_next = yes && { skip_next=no; continue; }; \\\n-    case $$flg in \\\n-      *=*|--*) continue;; \\\n-        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n-      -*I?*) strip_trailopt 'I';; \\\n-        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n-      -*O?*) strip_trailopt 'O';; \\\n-        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n-      -*l?*) strip_trailopt 'l';; \\\n-      -[dEDm]) skip_next=yes;; \\\n-      -[JT]) skip_next=yes;; \\\n-    esac; \\\n-    case $$flg in \\\n-      *$$target_option*) has_opt=yes; break;; \\\n-    esac; \\\n-  done; \\\n-  test $$has_opt = yes\n-am__make_dryrun = (target_option=n; $(am__make_running_with_option))\n-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = include\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/asmcfi.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/toolexeclibdir.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-DIST_COMMON = $(srcdir)/Makefile.am $(noinst_HEADERS) \\\n-\t$(toollibffi_HEADERS)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = $(top_builddir)/fficonfig.h\n-CONFIG_CLEAN_FILES = ffi.h ffitarget.h\n-CONFIG_CLEAN_VPATH_FILES =\n-AM_V_P = $(am__v_P_@AM_V@)\n-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n-am__v_P_0 = false\n-am__v_P_1 = :\n-AM_V_GEN = $(am__v_GEN_@AM_V@)\n-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\n-am__v_GEN_0 = @echo \"  GEN     \" $@;\n-am__v_GEN_1 = \n-AM_V_at = $(am__v_at_@AM_V@)\n-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\n-am__v_at_0 = @\n-am__v_at_1 = \n-SOURCES =\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n-am__installdirs = \"$(DESTDIR)$(toollibffidir)\"\n-HEADERS = $(noinst_HEADERS) $(toollibffi_HEADERS)\n-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n-# Read a list of newline-separated strings from the standard input,\n-# and print each of them once, without duplicates.  Input order is\n-# *not* preserved.\n-am__uniquify_input = $(AWK) '\\\n-  BEGIN { nonempty = 0; } \\\n-  { items[$$0] = 1; nonempty = 1; } \\\n-  END { if (nonempty) { for (i in items) print i; }; } \\\n-'\n-# Make sure the list of sources is unique.  This is necessary because,\n-# e.g., the same source file might be shared among _SOURCES variables\n-# for different programs/libraries.\n-am__define_uniq_tagged_files = \\\n-  list='$(am__tagged_files)'; \\\n-  unique=`for i in $$list; do \\\n-    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-  done | $(am__uniquify_input)`\n-ETAGS = etags\n-CTAGS = ctags\n-ACLOCAL = @ACLOCAL@\n-ALLOCA = @ALLOCA@\n-AMTAR = @AMTAR@\n-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\n-AM_LTLDFLAGS = @AM_LTLDFLAGS@\n-AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCAS = @CCAS@\n-CCASDEPMODE = @CCASDEPMODE@\n-CCASFLAGS = @CCASFLAGS@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n-HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OPT_LDFLAGS = @OPT_LDFLAGS@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SECTION_LDFLAGS = @SECTION_LDFLAGS@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-TARGET = @TARGET@\n-TARGETDIR = @TARGETDIR@\n-TARGET_OBJ = @TARGET_OBJ@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-get_gcc_base_ver = @get_gcc_base_ver@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign\n-DISTCLEANFILES = ffitarget.h\n-noinst_HEADERS = ffi_common.h ffi_cfi.h\n-EXTRA_DIST = ffi.h.in\n-\n-# Where generated headers like ffitarget.h get installed.\n-gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)\n-toollibffidir := $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n-toollibffi_HEADERS = ffi.h ffitarget.h\n-all: all-am\n-\n-.SUFFIXES:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n-\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign include/Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign include/Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(am__aclocal_m4_deps):\n-ffi.h: $(top_builddir)/config.status $(srcdir)/ffi.h.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-install-toollibffiHEADERS: $(toollibffi_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\t@list='$(toollibffi_HEADERS)'; test -n \"$(toollibffidir)\" || list=; \\\n-\tif test -n \"$$list\"; then \\\n-\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toollibffidir)'\"; \\\n-\t  $(MKDIR_P) \"$(DESTDIR)$(toollibffidir)\" || exit 1; \\\n-\tfi; \\\n-\tfor p in $$list; do \\\n-\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; \\\n-\tdone | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(toollibffidir)'\"; \\\n-\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(toollibffidir)\" || exit $$?; \\\n-\tdone\n-\n-uninstall-toollibffiHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toollibffi_HEADERS)'; test -n \"$(toollibffidir)\" || list=; \\\n-\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n-\tdir='$(DESTDIR)$(toollibffidir)'; $(am__uninstall_files_from_dir)\n-\n-ID: $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); mkid -fID $$unique\n-tags: tags-am\n-TAGS: tags\n-\n-tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\tset x; \\\n-\there=`pwd`; \\\n-\t$(am__define_uniq_tagged_files); \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: ctags-am\n-\n-CTAGS: ctags\n-ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n-\t$(am__define_uniq_tagged_files); \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-cscopelist: cscopelist-am\n-\n-cscopelist-am: $(am__tagged_files)\n-\tlist='$(am__tagged_files)'; \\\n-\tcase \"$(srcdir)\" in \\\n-\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n-\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n-\tesac; \\\n-\tfor i in $$list; do \\\n-\t  if test -f \"$$i\"; then \\\n-\t    echo \"$(subdir)/$$i\"; \\\n-\t  else \\\n-\t    echo \"$$sdir/$$i\"; \\\n-\t  fi; \\\n-\tdone >> $(top_builddir)/cscope.files\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(HEADERS)\n-installdirs:\n-\tfor dir in \"$(DESTDIR)$(toollibffidir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\t-test -z \"$(DISTCLEANFILES)\" || rm -f $(DISTCLEANFILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libtool mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-generic distclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am: install-toollibffiHEADERS\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am:\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-toollibffiHEADERS\n-\n-.MAKE: install-am install-strip\n-\n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool cscopelist-am ctags ctags-am distclean \\\n-\tdistclean-generic distclean-libtool distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-html install-html-am install-info \\\n-\tinstall-info-am install-man install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip \\\n-\tinstall-toollibffiHEADERS installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \\\n-\tps ps-am tags tags-am uninstall uninstall-am \\\n-\tuninstall-toollibffiHEADERS\n-\n-.PRECIOUS: Makefile\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "d16f307e64bebd72558a094d5df649e3947dd94d", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 116, "deletions": 97, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------*-C-*-\n-   libffi @VERSION@ - Copyright (c) 2011, 2014 Anthony Green\n-                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n+   libffi @VERSION@\n+     - Copyright (c) 2011, 2014, 2019, 2021 Anthony Green\n+     - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n@@ -25,23 +26,14 @@\n    ----------------------------------------------------------------------- */\n \n /* -------------------------------------------------------------------\n-   The basic API is described in the README file.\n+   Most of the API is documented in doc/libffi.texi.\n \n-   The raw API is designed to bypass some of the argument packing\n-   and unpacking on architectures for which it can be avoided.\n+   The raw API is designed to bypass some of the argument packing and\n+   unpacking on architectures for which it can be avoided.  Routines\n+   are provided to emulate the raw API if the underlying platform\n+   doesn't allow faster implementation.\n \n-   The closure API allows interpreted functions to be packaged up\n-   inside a C function pointer, so that they can be called as C functions,\n-   with no understanding on the client side that they are interpreted.\n-   It can also be used in other cases in which it is necessary to package\n-   up a user specified parameter and a function pointer as a single\n-   function pointer.\n-\n-   The closure API must be implemented in order to get its functionality,\n-   e.g. for use by gij.  Routines are provided to emulate the raw API\n-   if the underlying platform doesn't allow faster implementation.\n-\n-   More details on the raw and cloure API can be found in:\n+   More details on the raw API can be found in:\n \n    http://gcc.gnu.org/ml/java/1999-q3/msg00138.html\n \n@@ -106,8 +98,8 @@ extern \"C\" {\n # endif\n #endif\n \n-/* The closure code assumes that this works on pointers, i.e. a size_t\t*/\n-/* can hold a pointer.\t\t\t\t\t\t\t*/\n+/* The closure code assumes that this works on pointers, i.e. a size_t\n+   can hold a pointer.  */\n \n typedef struct _ffi_type\n {\n@@ -117,6 +109,32 @@ typedef struct _ffi_type\n   struct _ffi_type **elements;\n } ffi_type;\n \n+/* Need minimal decorations for DLLs to work on Windows.  GCC has\n+   autoimport and autoexport.  Always mark externally visible symbols\n+   as dllimport for MSVC clients, even if it means an extra indirection\n+   when using the static version of the library.\n+   Besides, as a workaround, they can define FFI_BUILDING if they\n+   *know* they are going to link with the static library.  */\n+#if defined _MSC_VER\n+# if defined FFI_BUILDING_DLL /* Building libffi.DLL with msvcc.sh */\n+#  define FFI_API __declspec(dllexport)\n+# elif !defined FFI_BUILDING  /* Importing libffi.DLL */\n+#  define FFI_API __declspec(dllimport)\n+# else                        /* Building/linking static library */\n+#  define FFI_API\n+# endif\n+#else\n+# define FFI_API\n+#endif\n+\n+/* The externally visible type declarations also need the MSVC DLL\n+   decorations, or they will not be exported from the object file.  */\n+#if defined LIBFFI_HIDE_BASIC_TYPES\n+# define FFI_EXTERN FFI_API\n+#else\n+# define FFI_EXTERN extern FFI_API\n+#endif\n+\n #ifndef LIBFFI_HIDE_BASIC_TYPES\n #if SCHAR_MAX == 127\n # define ffi_type_uchar                ffi_type_uint8\n@@ -166,21 +184,7 @@ typedef struct _ffi_type\n  #error \"long size not supported\"\n #endif\n \n-/* Need minimal decorations for DLLs to works on Windows. */\n-/* GCC has autoimport and autoexport.  Rely on Libtool to */\n-/* help MSVC export from a DLL, but always declare data   */\n-/* to be imported for MSVC clients.  This costs an extra  */\n-/* indirection for MSVC clients using the static version  */\n-/* of the library, but don't worry about that.  Besides,  */\n-/* as a workaround, they can define FFI_BUILDING if they  */\n-/* *know* they are going to link with the static library. */\n-#if defined _MSC_VER && !defined FFI_BUILDING\n-#define FFI_EXTERN extern __declspec(dllimport)\n-#else\n-#define FFI_EXTERN extern\n-#endif\n-\n-/* These are defined in types.c */\n+/* These are defined in types.c.  */\n FFI_EXTERN ffi_type ffi_type_void;\n FFI_EXTERN ffi_type ffi_type_uint8;\n FFI_EXTERN ffi_type ffi_type_sint8;\n@@ -214,11 +218,10 @@ FFI_EXTERN ffi_type ffi_type_complex_longdouble;\n typedef enum {\n   FFI_OK = 0,\n   FFI_BAD_TYPEDEF,\n-  FFI_BAD_ABI\n+  FFI_BAD_ABI,\n+  FFI_BAD_ARGTYPE\n } ffi_status;\n \n-typedef unsigned FFI_TYPE;\n-\n typedef struct {\n   ffi_abi abi;\n   unsigned nargs;\n@@ -231,20 +234,6 @@ typedef struct {\n #endif\n } ffi_cif;\n \n-#if @HAVE_LONG_DOUBLE_VARIANT@\n-/* Used to adjust size/alignment of ffi types.  */\n-void ffi_prep_types (ffi_abi abi);\n-#endif\n-\n-/* Used internally, but overridden by some architectures */\n-ffi_status ffi_prep_cif_core(ffi_cif *cif,\n-\t\t\t     ffi_abi abi,\n-\t\t\t     unsigned int isvariadic,\n-\t\t\t     unsigned int nfixedargs,\n-\t\t\t     unsigned int ntotalargs,\n-\t\t\t     ffi_type *rtype,\n-\t\t\t     ffi_type **atypes);\n-\n /* ---- Definitions for the raw API -------------------------------------- */\n \n #ifndef FFI_SIZEOF_ARG\n@@ -282,27 +271,34 @@ typedef ffi_raw ffi_java_raw;\n #endif\n \n \n+FFI_API\n void ffi_raw_call (ffi_cif *cif,\n \t\t   void (*fn)(void),\n \t\t   void *rvalue,\n \t\t   ffi_raw *avalue);\n \n-void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);\n-void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);\n-size_t ffi_raw_size (ffi_cif *cif);\n+FFI_API void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);\n+FFI_API void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);\n+FFI_API size_t ffi_raw_size (ffi_cif *cif);\n \n-/* This is analogous to the raw API, except it uses Java parameter\t*/\n-/* packing, even on 64-bit machines.  I.e. on 64-bit machines\t\t*/\n-/* longs and doubles are followed by an empty 64-bit word.\t\t*/\n+/* This is analogous to the raw API, except it uses Java parameter\n+   packing, even on 64-bit machines.  I.e. on 64-bit machines longs\n+   and doubles are followed by an empty 64-bit word.  */\n \n+#if !FFI_NATIVE_RAW_API\n+FFI_API\n void ffi_java_raw_call (ffi_cif *cif,\n \t\t\tvoid (*fn)(void),\n \t\t\tvoid *rvalue,\n-\t\t\tffi_java_raw *avalue);\n+\t\t\tffi_java_raw *avalue) __attribute__((deprecated));\n+#endif\n \n-void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);\n-void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);\n-size_t ffi_java_raw_size (ffi_cif *cif);\n+FFI_API\n+void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw) __attribute__((deprecated));\n+FFI_API\n+void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args) __attribute__((deprecated));\n+FFI_API\n+size_t ffi_java_raw_size (ffi_cif *cif) __attribute__((deprecated));\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n@@ -316,30 +312,50 @@ typedef struct {\n   void *trampoline_table;\n   void *trampoline_table_entry;\n #else\n-  char tramp[FFI_TRAMPOLINE_SIZE];\n+  union {\n+    char tramp[FFI_TRAMPOLINE_SIZE];\n+    void *ftramp;\n+  };\n #endif\n   ffi_cif   *cif;\n   void     (*fun)(ffi_cif*,void*,void**,void*);\n   void      *user_data;\n+} ffi_closure\n #ifdef __GNUC__\n-} ffi_closure __attribute__((aligned (8)));\n-#else\n-} ffi_closure;\n+    __attribute__((aligned (8)))\n+#endif\n+    ;\n+\n+#ifndef __GNUC__\n # ifdef __sgi\n #  pragma pack 0\n # endif\n #endif\n \n-void *ffi_closure_alloc (size_t size, void **code);\n-void ffi_closure_free (void *);\n+FFI_API void *ffi_closure_alloc (size_t size, void **code);\n+FFI_API void ffi_closure_free (void *);\n+\n+#if defined(PA_LINUX) || defined(PA_HPUX)\n+#define FFI_CLOSURE_PTR(X) ((void *)((unsigned int)(X) | 2))\n+#define FFI_RESTORE_PTR(X) ((void *)((unsigned int)(X) & ~3))\n+#else\n+#define FFI_CLOSURE_PTR(X) (X)\n+#define FFI_RESTORE_PTR(X) (X)\n+#endif\n \n-ffi_status\n+FFI_API ffi_status\n ffi_prep_closure (ffi_closure*,\n \t\t  ffi_cif *,\n \t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t  void *user_data);\n+\t\t  void *user_data)\n+#if defined(__GNUC__) && (((__GNUC__ * 100) + __GNUC_MINOR__) >= 405)\n+  __attribute__((deprecated (\"use ffi_prep_closure_loc instead\")))\n+#elif defined(__GNUC__) && __GNUC__ >= 3\n+  __attribute__((deprecated))\n+#endif\n+  ;\n \n-ffi_status\n+FFI_API ffi_status\n ffi_prep_closure_loc (ffi_closure*,\n \t\t      ffi_cif *,\n \t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n@@ -360,9 +376,9 @@ typedef struct {\n \n #if !FFI_NATIVE_RAW_API\n \n-  /* if this is enabled, then a raw closure has the same layout \n-     as a regular closure.  We use this to install an intermediate \n-     handler to do the transaltion, void** -> ffi_raw*. */\n+  /* If this is enabled, then a raw closure has the same layout\n+     as a regular closure.  We use this to install an intermediate\n+     handler to do the transaltion, void** -> ffi_raw*.  */\n \n   void     (*translate_args)(ffi_cif*,void*,void**,void*);\n   void      *this_closure;\n@@ -386,9 +402,9 @@ typedef struct {\n \n #if !FFI_NATIVE_RAW_API\n \n-  /* if this is enabled, then a raw closure has the same layout \n-     as a regular closure.  We use this to install an intermediate \n-     handler to do the transaltion, void** -> ffi_raw*. */\n+  /* If this is enabled, then a raw closure has the same layout\n+     as a regular closure.  We use this to install an intermediate\n+     handler to do the translation, void** -> ffi_raw*.  */\n \n   void     (*translate_args)(ffi_cif*,void*,void**,void*);\n   void      *this_closure;\n@@ -400,31 +416,33 @@ typedef struct {\n \n } ffi_java_raw_closure;\n \n-ffi_status\n+FFI_API ffi_status\n ffi_prep_raw_closure (ffi_raw_closure*,\n \t\t      ffi_cif *cif,\n \t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n \t\t      void *user_data);\n \n-ffi_status\n+FFI_API ffi_status\n ffi_prep_raw_closure_loc (ffi_raw_closure*,\n \t\t\t  ffi_cif *cif,\n \t\t\t  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n \t\t\t  void *user_data,\n \t\t\t  void *codeloc);\n \n-ffi_status\n+#if !FFI_NATIVE_RAW_API\n+FFI_API ffi_status\n ffi_prep_java_raw_closure (ffi_java_raw_closure*,\n \t\t           ffi_cif *cif,\n \t\t           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n-\t\t           void *user_data);\n+\t\t           void *user_data) __attribute__((deprecated));\n \n-ffi_status\n+FFI_API ffi_status\n ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,\n \t\t\t       ffi_cif *cif,\n \t\t\t       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),\n \t\t\t       void *user_data,\n-\t\t\t       void *codeloc);\n+\t\t\t       void *codeloc) __attribute__((deprecated));\n+#endif\n \n #endif /* FFI_CLOSURES */\n \n@@ -436,54 +454,61 @@ typedef struct {\n   void     (*fun)(ffi_cif*,void*,void**,void*);\n } ffi_go_closure;\n \n-ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,\n+FFI_API ffi_status ffi_prep_go_closure (ffi_go_closure*, ffi_cif *,\n \t\t\t\tvoid (*fun)(ffi_cif*,void*,void**,void*));\n \n-void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+FFI_API void ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n \t\t  void **avalue, void *closure);\n \n #endif /* FFI_GO_CLOSURES */\n \n /* ---- Public interface definition -------------------------------------- */\n \n+FFI_API\n ffi_status ffi_prep_cif(ffi_cif *cif,\n \t\t\tffi_abi abi,\n \t\t\tunsigned int nargs,\n \t\t\tffi_type *rtype,\n \t\t\tffi_type **atypes);\n \n+FFI_API\n ffi_status ffi_prep_cif_var(ffi_cif *cif,\n \t\t\t    ffi_abi abi,\n \t\t\t    unsigned int nfixedargs,\n \t\t\t    unsigned int ntotalargs,\n \t\t\t    ffi_type *rtype,\n \t\t\t    ffi_type **atypes);\n \n+FFI_API\n void ffi_call(ffi_cif *cif,\n \t      void (*fn)(void),\n \t      void *rvalue,\n \t      void **avalue);\n \n-/* Useful for eliminating compiler warnings */\n+FFI_API\n+ffi_status ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type,\n+\t\t\t\t   size_t *offsets);\n+\n+/* Useful for eliminating compiler warnings.  */\n #define FFI_FN(f) ((void (*)(void))f)\n \n /* ---- Definitions shared with assembly code ---------------------------- */\n \n #endif\n \n /* If these change, update src/mips/ffitarget.h. */\n-#define FFI_TYPE_VOID       0    \n+#define FFI_TYPE_VOID       0\n #define FFI_TYPE_INT        1\n-#define FFI_TYPE_FLOAT      2    \n+#define FFI_TYPE_FLOAT      2\n #define FFI_TYPE_DOUBLE     3\n #if @HAVE_LONG_DOUBLE@\n #define FFI_TYPE_LONGDOUBLE 4\n #else\n #define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE\n #endif\n-#define FFI_TYPE_UINT8      5   \n+#define FFI_TYPE_UINT8      5\n #define FFI_TYPE_SINT8      6\n-#define FFI_TYPE_UINT16     7 \n+#define FFI_TYPE_UINT16     7\n #define FFI_TYPE_SINT16     8\n #define FFI_TYPE_UINT32     9\n #define FFI_TYPE_SINT32     10\n@@ -493,14 +518,8 @@ void ffi_call(ffi_cif *cif,\n #define FFI_TYPE_POINTER    14\n #define FFI_TYPE_COMPLEX    15\n \n-/* This should always refer to the last type code (for sanity checks) */\n-/* ??? Ideally, anyway.  There are assembly files that still depend\n-   on this not including COMPLEX.  */\n-#ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n-# define FFI_TYPE_LAST      FFI_TYPE_COMPLEX\n-#else\n-# define FFI_TYPE_LAST      FFI_TYPE_POINTER\n-#endif\n+/* This should always refer to the last type code (for sanity checks).  */\n+#define FFI_TYPE_LAST       FFI_TYPE_COMPLEX\n \n #ifdef __cplusplus\n }"}, {"sha": "f4c292d004049d031cbe4bd0ba16097da14b30a3", "filename": "libffi/include/ffi_cfi.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi_cfi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi_cfi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_cfi.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -2,6 +2,27 @@\n    ffi_cfi.h - Copyright (c) 2014  Red Hat, Inc.\n \n    Conditionally assemble cfi directives. Only necessary for building libffi.\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n    ----------------------------------------------------------------------- */\n \n #ifndef FFI_CFI_H"}, {"sha": "2bd31b03d0f9d1252d637c57d81185a3049174b4", "filename": "libffi/include/ffi_common.h", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Fffi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi_common.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -5,6 +5,27 @@\n                   \n    Common internal definitions and macros. Only necessary for building\n    libffi.\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n    ----------------------------------------------------------------------- */\n \n #ifndef FFI_COMMON_H\n@@ -74,14 +95,39 @@ void ffi_type_test(ffi_type *a, char *file, int line);\n #define FFI_ASSERT_VALID_TYPE(x)\n #endif\n \n-#define ALIGN(v, a)  (((((size_t) (v))-1) | ((a)-1))+1)\n-#define ALIGN_DOWN(v, a) (((size_t) (v)) & -a)\n+/* v cast to size_t and aligned up to a multiple of a */\n+#define FFI_ALIGN(v, a)  (((((size_t) (v))-1) | ((a)-1))+1)\n+/* v cast to size_t and aligned down to a multiple of a */\n+#define FFI_ALIGN_DOWN(v, a) (((size_t) (v)) & -a)\n \n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif);\n ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n \t unsigned int nfixedargs, unsigned int ntotalargs);\n \n+\n+#if HAVE_LONG_DOUBLE_VARIANT\n+/* Used to adjust size/alignment of ffi types.  */\n+void ffi_prep_types (ffi_abi abi);\n+#endif\n+\n+/* Used internally, but overridden by some architectures */\n+ffi_status ffi_prep_cif_core(ffi_cif *cif,\n+\t\t\t     ffi_abi abi,\n+\t\t\t     unsigned int isvariadic,\n+\t\t\t     unsigned int nfixedargs,\n+\t\t\t     unsigned int ntotalargs,\n+\t\t\t     ffi_type *rtype,\n+\t\t\t     ffi_type **atypes);\n+\n+/* Translate a data pointer to a code pointer.  Needed for closures on\n+   some targets.  */\n+void *ffi_data_to_code_pointer (void *data) FFI_HIDDEN;\n+\n+/* The arch code calls this to determine if a given closure has a\n+   static trampoline. */\n+int ffi_tramp_is_present (void *closure) FFI_HIDDEN;\n+\n /* Extended cif, used in callback from assembly routine */\n typedef struct\n {"}, {"sha": "e14e463e83a6e04c119bf6d9ba0ebe7b7c2b6b51", "filename": "libffi/include/tramp.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Ftramp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Finclude%2Ftramp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Ftramp.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,45 @@\n+/* -----------------------------------------------------------------------\n+   ffi_tramp.h - Copyright (C) 2021  Microsoft, Inc.\n+\n+   Static trampoline definitions.\n+\n+   Permission is hereby granted, free of charge, to any person\n+   obtaining a copy of this software and associated documentation\n+   files (the ``Software''), to deal in the Software without\n+   restriction, including without limitation the rights to use, copy,\n+   modify, merge, publish, distribute, sublicense, and/or sell copies\n+   of the Software, and to permit persons to whom the Software is\n+   furnished to do so, subject to the following conditions:\n+\n+   The above copyright notice and this permission notice shall be\n+   included in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef FFI_TRAMP_H\n+#define FFI_TRAMP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+int ffi_tramp_is_supported(void);\n+void *ffi_tramp_alloc (int flags);\n+void ffi_tramp_set_parms (void *tramp, void *data, void *code);\n+void *ffi_tramp_get_addr (void *tramp);\n+void ffi_tramp_free (void *tramp);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* FFI_TRAMP_H */"}, {"sha": "de8778ae40fb9c88398f1f96e978333699a8d141", "filename": "libffi/libffi.map.in", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.map.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.map.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.map.in?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -3,7 +3,10 @@\n #include <fficonfig.h>\n #include <ffitarget.h>\n \n-LIBFFI_BASE_7.0 {\n+/* These version numbers correspond to the libtool-version abi numbers,\n+   not to the libffi release numbers.  */\n+\n+LIBFFI_BASE_8.0 {\n   global:\n \t/* Exported data variables.  */\n \tffi_type_void;\n@@ -35,28 +38,23 @@ LIBFFI_BASE_7.0 {\n \tffi_java_raw_to_ptrarray;\n \tffi_java_raw_size;\n \n-\t/* Functions in the ffi.h header, but not exported.\n-\t   These are listed here for documentation purposes only.\n-\tffi_prep_types\n-\tffi_prep_cif_core\n-\t*/\n-\n+\tffi_get_struct_offsets;\n   local:\n \t*;\n };\n \n #ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n-LIBFFI_COMPLEX_7.0 {\n+LIBFFI_COMPLEX_8.0 {\n   global:\n \t/* Exported data variables.  */\n \tffi_type_complex_float;\n \tffi_type_complex_double;\n \tffi_type_complex_longdouble;\n-} LIBFFI_BASE_7.0;\n+} LIBFFI_BASE_8.0;\n #endif\n \n #if FFI_CLOSURES\n-LIBFFI_CLOSURE_7.0 {\n+LIBFFI_CLOSURE_8.0 {\n   global:\n \tffi_closure_alloc;\n \tffi_closure_free;\n@@ -66,13 +64,13 @@ LIBFFI_CLOSURE_7.0 {\n \tffi_prep_raw_closure_loc;\n \tffi_prep_java_raw_closure;\n \tffi_prep_java_raw_closure_loc;\n-} LIBFFI_BASE_7.0;\n+} LIBFFI_BASE_8.0;\n #endif\n \n #if FFI_GO_CLOSURES\n-LIBFFI_GO_CLOSURE_7.0 {\n+LIBFFI_GO_CLOSURE_8.0 {\n   global:\n \tffi_call_go;\n \tffi_prep_go_closure;\n-} LIBFFI_CLOSURE_7.0;\n+} LIBFFI_CLOSURE_8.0;\n #endif"}, {"sha": "6fad83b4951c86bd96012fb14cadce69320d5df4", "filename": "libffi/libffi.pc.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.pc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.pc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.pc.in?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -2,7 +2,7 @@ prefix=@prefix@\n exec_prefix=@exec_prefix@\n libdir=@libdir@\n toolexeclibdir=@toolexeclibdir@\n-includedir=${libdir}/@PACKAGE_NAME@-@PACKAGE_VERSION@/include\n+includedir=@includedir@\n \n Name: @PACKAGE_NAME@\n Description: Library supporting Foreign Function Interfaces"}, {"sha": "480c4a4e4456c54d427caabe27d4f0ee424dfb00", "filename": "libffi/libffi.xcodeproj/project.pbxproj", "status": "modified", "additions": 445, "deletions": 85, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -7,6 +7,9 @@\n \tobjects = {\n \n /* Begin PBXBuildFile section */\n+\t\t43B5D3F81D35473200D1E1FD /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */; };\n+\t\t43B5D3FA1D3547CE00D1E1FD /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */; };\n+\t\t43E9A5C81D352C1500926A8F /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43E9A5C61D352C1500926A8F /* unix64_x86_64.S */; };\n \t\tDBFA714A187F1D8600A76262 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };\n \t\tDBFA714B187F1D8600A76262 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA713F187F1D8600A76262 /* ffi_common.h */; };\n \t\tDBFA714C187F1D8600A76262 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7140187F1D8600A76262 /* fficonfig.h */; };\n@@ -23,36 +26,110 @@\n \t\tDBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716D187F1D9B00A76262 /* sysv_arm64.S */; };\n \t\tDBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716F187F1D9B00A76262 /* ffi_armv7.c */; };\n \t\tDBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7170187F1D9B00A76262 /* sysv_armv7.S */; };\n-\t\tDBFA717B187F1D9B00A76262 /* trampoline_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7171187F1D9B00A76262 /* trampoline_armv7.S */; };\n-\t\tDBFA717C187F1D9B00A76262 /* darwin64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */; };\n-\t\tDBFA717D187F1D9B00A76262 /* darwin_i386.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7174187F1D9B00A76262 /* darwin_i386.S */; };\n \t\tDBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */; };\n-\t\tDBFA717F187F1D9B00A76262 /* ffi_i386.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7176187F1D9B00A76262 /* ffi_i386.c */; };\n-\t\tDBFA718E187F1DA100A76262 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7182187F1DA100A76262 /* ffi_i386.h */; };\n \t\tDBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7183187F1DA100A76262 /* ffi_x86_64.h */; };\n-\t\tDBFA7190187F1DA100A76262 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7184187F1DA100A76262 /* fficonfig_i386.h */; };\n \t\tDBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */; };\n-\t\tDBFA7192187F1DA100A76262 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7186187F1DA100A76262 /* ffitarget_i386.h */; };\n \t\tDBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */; };\n-\t\tDBFA7194187F1DA100A76262 /* darwin64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* darwin64_x86_64.S */; };\n-\t\tDBFA7195187F1DA100A76262 /* darwin_i386.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718B187F1DA100A76262 /* darwin_i386.S */; };\n+\t\tDBFA7194187F1DA100A76262 /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* unix64_x86_64.S */; };\n \t\tDBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */; };\n-\t\tDBFA7197187F1DA100A76262 /* ffi_i386.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718D187F1DA100A76262 /* ffi_i386.c */; };\n+\t\tFDB52FB31F6144FA00AA92E6 /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43E9A5C61D352C1500926A8F /* unix64_x86_64.S */; };\n+\t\tFDB52FB51F6144FA00AA92E6 /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */; };\n+\t\tFDB52FB61F6144FA00AA92E6 /* ffi_armv7.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716F187F1D9B00A76262 /* ffi_armv7.c */; };\n+\t\tFDB52FB71F6144FA00AA92E6 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };\n+\t\tFDB52FB81F6144FA00AA92E6 /* sysv_armv7.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7170187F1D9B00A76262 /* sysv_armv7.S */; };\n+\t\tFDB52FB91F6144FA00AA92E6 /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */; };\n+\t\tFDB52FBA1F6144FA00AA92E6 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };\n+\t\tFDB52FBC1F6144FA00AA92E6 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };\n+\t\tFDB52FBD1F6144FA00AA92E6 /* sysv_arm64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716D187F1D9B00A76262 /* sysv_arm64.S */; };\n+\t\tFDB52FBE1F6144FA00AA92E6 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };\n+\t\tFDB52FBF1F6144FA00AA92E6 /* ffi_arm64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA716C187F1D9B00A76262 /* ffi_arm64.c */; };\n+\t\tFDB52FC01F6144FA00AA92E6 /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = 43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */; };\n+\t\tFDB52FD01F614A8B00AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };\n+\t\tFDB52FD11F614AA700AA92E6 /* ffi_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715E187F1D9B00A76262 /* ffi_arm64.h */; };\n+\t\tFDB52FD21F614AAB00AA92E6 /* ffi_armv7.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715F187F1D9B00A76262 /* ffi_armv7.h */; };\n+\t\tFDB52FD41F614AB500AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */; };\n+\t\tFDB52FD51F614AE200AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };\n+\t\tFDB52FD61F614AEA00AA92E6 /* ffi_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA715E187F1D9B00A76262 /* ffi_arm64.h */; };\n+\t\tFDB52FD71F614AED00AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7161187F1D9B00A76262 /* ffi_x86_64.h */; };\n+\t\tFDB52FD81F614B8700AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };\n+\t\tFDB52FD91F614B8E00AA92E6 /* ffitarget_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */; };\n+\t\tFDB52FDA1F614B9300AA92E6 /* ffitarget_armv7.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */; };\n+\t\tFDB52FDD1F614BA900AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */; };\n+\t\tFDB52FDE1F6155E300AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };\n+\t\tFDB52FDF1F6155EA00AA92E6 /* ffitarget_arm64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */; };\n+\t\tFDB52FE01F6155EF00AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */; };\n+\t\tFDB52FE21F6156FA00AA92E6 /* ffi.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA713E187F1D8600A76262 /* ffi.h */; };\n+\t\tFDB52FE31F61571A00AA92E6 /* ffi_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7183187F1DA100A76262 /* ffi_x86_64.h */; };\n+\t\tFDB52FE41F61571D00AA92E6 /* ffitarget.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7141187F1D8600A76262 /* ffitarget.h */; };\n+\t\tFDB52FE61F61573100AA92E6 /* ffitarget_x86_64.h in CopyFiles */ = {isa = PBXBuildFile; fileRef = DBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */; };\n+\t\tFDDB2F411F5D66E200EF414E /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */; };\n+\t\tFDDB2F461F5D691E00EF414E /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F441F5D68C900EF414E /* win64_x86_64.S */; };\n+\t\tFDDB2F4A1F5D846400EF414E /* ffi64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718C187F1DA100A76262 /* ffi64_x86_64.c */; };\n+\t\tFDDB2F4C1F5D846400EF414E /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7147187F1D8600A76262 /* prep_cif.c */; };\n+\t\tFDDB2F4E1F5D846400EF414E /* ffiw64_x86_64.c in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */; };\n+\t\tFDDB2F4F1F5D846400EF414E /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7149187F1D8600A76262 /* types.c */; };\n+\t\tFDDB2F501F5D846400EF414E /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7148187F1D8600A76262 /* raw_api.c */; };\n+\t\tFDDB2F511F5D846400EF414E /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = DBFA7143187F1D8600A76262 /* closures.c */; };\n+\t\tFDDB2F521F5D846400EF414E /* unix64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = DBFA718A187F1DA100A76262 /* unix64_x86_64.S */; };\n+\t\tFDDB2F531F5D846400EF414E /* win64_x86_64.S in Sources */ = {isa = PBXBuildFile; fileRef = FDDB2F441F5D68C900EF414E /* win64_x86_64.S */; };\n /* End PBXBuildFile section */\n \n /* Begin PBXCopyFilesBuildPhase section */\n \t\tDB13B1641849DF1E0010F42D /* CopyFiles */ = {\n \t\t\tisa = PBXCopyFilesBuildPhase;\n-\t\t\tbuildActionMask = 8;\n+\t\t\tbuildActionMask = 12;\n \t\t\tdstPath = \"include/$(PRODUCT_NAME)\";\n \t\t\tdstSubfolderSpec = 16;\n \t\t\tfiles = (\n+\t\t\t\tFDB52FD01F614A8B00AA92E6 /* ffi.h in CopyFiles */,\n+\t\t\t\tFDB52FD11F614AA700AA92E6 /* ffi_arm64.h in CopyFiles */,\n+\t\t\t\tFDB52FD21F614AAB00AA92E6 /* ffi_armv7.h in CopyFiles */,\n+\t\t\t\tFDB52FD41F614AB500AA92E6 /* ffi_x86_64.h in CopyFiles */,\n+\t\t\t\tFDB52FD81F614B8700AA92E6 /* ffitarget.h in CopyFiles */,\n+\t\t\t\tFDB52FD91F614B8E00AA92E6 /* ffitarget_arm64.h in CopyFiles */,\n+\t\t\t\tFDB52FDA1F614B9300AA92E6 /* ffitarget_armv7.h in CopyFiles */,\n+\t\t\t\tFDB52FDD1F614BA900AA92E6 /* ffitarget_x86_64.h in CopyFiles */,\n \t\t\t);\n-\t\t\trunOnlyForDeploymentPostprocessing = 1;\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tFDB52FC11F6144FA00AA92E6 /* CopyFiles */ = {\n+\t\t\tisa = PBXCopyFilesBuildPhase;\n+\t\t\tbuildActionMask = 12;\n+\t\t\tdstPath = \"include/$(PRODUCT_NAME)\";\n+\t\t\tdstSubfolderSpec = 16;\n+\t\t\tfiles = (\n+\t\t\t\tFDB52FD51F614AE200AA92E6 /* ffi.h in CopyFiles */,\n+\t\t\t\tFDB52FD61F614AEA00AA92E6 /* ffi_arm64.h in CopyFiles */,\n+\t\t\t\tFDB52FD71F614AED00AA92E6 /* ffi_x86_64.h in CopyFiles */,\n+\t\t\t\tFDB52FDE1F6155E300AA92E6 /* ffitarget.h in CopyFiles */,\n+\t\t\t\tFDB52FDF1F6155EA00AA92E6 /* ffitarget_arm64.h in CopyFiles */,\n+\t\t\t\tFDB52FE01F6155EF00AA92E6 /* ffitarget_x86_64.h in CopyFiles */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tFDB52FE11F6156E000AA92E6 /* CopyFiles */ = {\n+\t\t\tisa = PBXCopyFilesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tdstPath = \"include/$(PRODUCT_NAME)\";\n+\t\t\tdstSubfolderSpec = 16;\n+\t\t\tfiles = (\n+\t\t\t\tFDB52FE21F6156FA00AA92E6 /* ffi.h in CopyFiles */,\n+\t\t\t\tFDB52FE31F61571A00AA92E6 /* ffi_x86_64.h in CopyFiles */,\n+\t\t\t\tFDB52FE41F61571D00AA92E6 /* ffitarget.h in CopyFiles */,\n+\t\t\t\tFDB52FE61F61573100AA92E6 /* ffitarget_x86_64.h in CopyFiles */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n /* End PBXCopyFilesBuildPhase section */\n \n /* Begin PBXFileReference section */\n+\t\t43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffiw64_x86_64.c; sourceTree = \"<group>\"; };\n+\t\t43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = win64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\t43E9A5C61D352C1500926A8F /* unix64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = unix64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\t43E9A5DA1D35373600926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = \"<group>\"; };\n+\t\t43E9A5DB1D35374400926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = \"<group>\"; };\n+\t\t43E9A5DC1D35375400926A8F /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = \"<group>\"; };\n+\t\t43E9A5DD1D35375400926A8F /* internal64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal64.h; sourceTree = \"<group>\"; };\n \t\tDB13B1661849DF1E0010F42D /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n \t\tDB13B1911849DF510010F42D /* ffi.dylib */ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = ffi.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n \t\tDBFA713E187F1D8600A76262 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n@@ -66,35 +143,30 @@\n \t\tDBFA7149187F1D8600A76262 /* types.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = types.c; sourceTree = \"<group>\"; };\n \t\tDBFA715E187F1D9B00A76262 /* ffi_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_arm64.h; sourceTree = \"<group>\"; };\n \t\tDBFA715F187F1D9B00A76262 /* ffi_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_armv7.h; sourceTree = \"<group>\"; };\n-\t\tDBFA7160187F1D9B00A76262 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7161187F1D9B00A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n \t\tDBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_arm64.h; sourceTree = \"<group>\"; };\n \t\tDBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_armv7.h; sourceTree = \"<group>\"; };\n-\t\tDBFA7164187F1D9B00A76262 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n \t\tDBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_arm64.h; sourceTree = \"<group>\"; };\n \t\tDBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_armv7.h; sourceTree = \"<group>\"; };\n-\t\tDBFA7168187F1D9B00A76262 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n-\t\tDBFA716C187F1D9B00A76262 /* ffi_arm64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_arm64.c; sourceTree = \"<group>\"; };\n+\t\tDBFA716C187F1D9B00A76262 /* ffi_arm64.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi_arm64.c; sourceTree = \"<group>\"; };\n \t\tDBFA716D187F1D9B00A76262 /* sysv_arm64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_arm64.S; sourceTree = \"<group>\"; };\n-\t\tDBFA716F187F1D9B00A76262 /* ffi_armv7.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_armv7.c; sourceTree = \"<group>\"; };\n+\t\tDBFA716F187F1D9B00A76262 /* ffi_armv7.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi_armv7.c; sourceTree = \"<group>\"; };\n \t\tDBFA7170187F1D9B00A76262 /* sysv_armv7.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv_armv7.S; sourceTree = \"<group>\"; };\n-\t\tDBFA7171187F1D9B00A76262 /* trampoline_armv7.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = trampoline_armv7.S; sourceTree = \"<group>\"; };\n-\t\tDBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64_x86_64.S; sourceTree = \"<group>\"; };\n-\t\tDBFA7174187F1D9B00A76262 /* darwin_i386.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin_i386.S; sourceTree = \"<group>\"; };\n \t\tDBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = \"<group>\"; };\n-\t\tDBFA7176187F1D9B00A76262 /* ffi_i386.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_i386.c; sourceTree = \"<group>\"; };\n-\t\tDBFA7182187F1DA100A76262 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7183187F1DA100A76262 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n-\t\tDBFA7184187F1DA100A76262 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n-\t\tDBFA7186187F1DA100A76262 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n \t\tDBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n-\t\tDBFA718A187F1DA100A76262 /* darwin64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64_x86_64.S; sourceTree = \"<group>\"; };\n-\t\tDBFA718B187F1DA100A76262 /* darwin_i386.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin_i386.S; sourceTree = \"<group>\"; };\n-\t\tDBFA718C187F1DA100A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = \"<group>\"; };\n-\t\tDBFA718D187F1DA100A76262 /* ffi_i386.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi_i386.c; sourceTree = \"<group>\"; };\n+\t\tDBFA718A187F1DA100A76262 /* unix64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = unix64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\tDBFA718C187F1DA100A76262 /* ffi64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; indentWidth = 2; lastKnownFileType = sourcecode.c.c; path = ffi64_x86_64.c; sourceTree = \"<group>\"; };\n+\t\tFDB52FC51F6144FA00AA92E6 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n+\t\tFDDB2F3E1F5D61BC00EF414E /* asmnames.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = asmnames.h; sourceTree = \"<group>\"; };\n+\t\tFDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffiw64_x86_64.c; sourceTree = \"<group>\"; };\n+\t\tFDDB2F421F5D68C900EF414E /* internal64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal64.h; sourceTree = \"<group>\"; };\n+\t\tFDDB2F431F5D68C900EF414E /* internal.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = internal.h; sourceTree = \"<group>\"; };\n+\t\tFDDB2F441F5D68C900EF414E /* win64_x86_64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = win64_x86_64.S; sourceTree = \"<group>\"; };\n+\t\tFDDB2F621F5D846400EF414E /* libffi.a */ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n /* End PBXFileReference section */\n \n /* Begin PBXGroup section */\n@@ -113,6 +185,8 @@\n \t\t\tchildren = (\n \t\t\t\tDB13B1661849DF1E0010F42D /* libffi.a */,\n \t\t\t\tDB13B1911849DF510010F42D /* ffi.dylib */,\n+\t\t\t\tFDDB2F621F5D846400EF414E /* libffi.a */,\n+\t\t\t\tFDB52FC51F6144FA00AA92E6 /* libffi.a */,\n \t\t\t);\n \t\t\tname = Products;\n \t\t\tsourceTree = \"<group>\";\n@@ -123,7 +197,7 @@\n \t\t\t\tDBFA713D187F1D8600A76262 /* include */,\n \t\t\t\tDBFA7142187F1D8600A76262 /* src */,\n \t\t\t);\n-\t\t\tpath = \"darwin_common\";\n+\t\t\tpath = darwin_common;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n \t\tDBFA713D187F1D8600A76262 /* include */ = {\n@@ -155,23 +229,20 @@\n \t\t\t\tDBFA715D187F1D9B00A76262 /* include */,\n \t\t\t\tDBFA716A187F1D9B00A76262 /* src */,\n \t\t\t);\n-\t\t\tpath = \"darwin_ios\";\n+\t\t\tpath = darwin_ios;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n \t\tDBFA715D187F1D9B00A76262 /* include */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n \t\t\t\tDBFA715E187F1D9B00A76262 /* ffi_arm64.h */,\n \t\t\t\tDBFA715F187F1D9B00A76262 /* ffi_armv7.h */,\n-\t\t\t\tDBFA7160187F1D9B00A76262 /* ffi_i386.h */,\n \t\t\t\tDBFA7161187F1D9B00A76262 /* ffi_x86_64.h */,\n \t\t\t\tDBFA7162187F1D9B00A76262 /* fficonfig_arm64.h */,\n \t\t\t\tDBFA7163187F1D9B00A76262 /* fficonfig_armv7.h */,\n-\t\t\t\tDBFA7164187F1D9B00A76262 /* fficonfig_i386.h */,\n \t\t\t\tDBFA7165187F1D9B00A76262 /* fficonfig_x86_64.h */,\n \t\t\t\tDBFA7166187F1D9B00A76262 /* ffitarget_arm64.h */,\n \t\t\t\tDBFA7167187F1D9B00A76262 /* ffitarget_armv7.h */,\n-\t\t\t\tDBFA7168187F1D9B00A76262 /* ffitarget_i386.h */,\n \t\t\t\tDBFA7169187F1D9B00A76262 /* ffitarget_x86_64.h */,\n \t\t\t);\n \t\t\tpath = include;\n@@ -190,6 +261,7 @@\n \t\tDBFA716B187F1D9B00A76262 /* aarch64 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n+\t\t\t\t43E9A5DA1D35373600926A8F /* internal.h */,\n \t\t\t\tDBFA716C187F1D9B00A76262 /* ffi_arm64.c */,\n \t\t\t\tDBFA716D187F1D9B00A76262 /* sysv_arm64.S */,\n \t\t\t);\n@@ -199,20 +271,22 @@\n \t\tDBFA716E187F1D9B00A76262 /* arm */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n+\t\t\t\t43E9A5DB1D35374400926A8F /* internal.h */,\n \t\t\t\tDBFA716F187F1D9B00A76262 /* ffi_armv7.c */,\n \t\t\t\tDBFA7170187F1D9B00A76262 /* sysv_armv7.S */,\n-\t\t\t\tDBFA7171187F1D9B00A76262 /* trampoline_armv7.S */,\n \t\t\t);\n \t\t\tpath = arm;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n \t\tDBFA7172187F1D9B00A76262 /* x86 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\tDBFA7173187F1D9B00A76262 /* darwin64_x86_64.S */,\n-\t\t\t\tDBFA7174187F1D9B00A76262 /* darwin_i386.S */,\n+\t\t\t\t43E9A5DC1D35375400926A8F /* internal.h */,\n+\t\t\t\t43E9A5DD1D35375400926A8F /* internal64.h */,\n \t\t\t\tDBFA7175187F1D9B00A76262 /* ffi64_x86_64.c */,\n-\t\t\t\tDBFA7176187F1D9B00A76262 /* ffi_i386.c */,\n+\t\t\t\t43B5D3F71D35473200D1E1FD /* ffiw64_x86_64.c */,\n+\t\t\t\t43E9A5C61D352C1500926A8F /* unix64_x86_64.S */,\n+\t\t\t\t43B5D3F91D3547CE00D1E1FD /* win64_x86_64.S */,\n \t\t\t);\n \t\t\tpath = x86;\n \t\t\tsourceTree = \"<group>\";\n@@ -223,17 +297,14 @@\n \t\t\t\tDBFA7181187F1DA100A76262 /* include */,\n \t\t\t\tDBFA7188187F1DA100A76262 /* src */,\n \t\t\t);\n-\t\t\tpath = \"darwin_osx\";\n+\t\t\tpath = darwin_osx;\n \t\t\tsourceTree = \"<group>\";\n \t\t};\n \t\tDBFA7181187F1DA100A76262 /* include */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\tDBFA7182187F1DA100A76262 /* ffi_i386.h */,\n \t\t\t\tDBFA7183187F1DA100A76262 /* ffi_x86_64.h */,\n-\t\t\t\tDBFA7184187F1DA100A76262 /* fficonfig_i386.h */,\n \t\t\t\tDBFA7185187F1DA100A76262 /* fficonfig_x86_64.h */,\n-\t\t\t\tDBFA7186187F1DA100A76262 /* ffitarget_i386.h */,\n \t\t\t\tDBFA7187187F1DA100A76262 /* ffitarget_x86_64.h */,\n \t\t\t);\n \t\t\tpath = include;\n@@ -250,10 +321,13 @@\n \t\tDBFA7189187F1DA100A76262 /* x86 */ = {\n \t\t\tisa = PBXGroup;\n \t\t\tchildren = (\n-\t\t\t\tDBFA718A187F1DA100A76262 /* darwin64_x86_64.S */,\n-\t\t\t\tDBFA718B187F1DA100A76262 /* darwin_i386.S */,\n+\t\t\t\tFDDB2F431F5D68C900EF414E /* internal.h */,\n+\t\t\t\tFDDB2F421F5D68C900EF414E /* internal64.h */,\n+\t\t\t\tFDDB2F3E1F5D61BC00EF414E /* asmnames.h */,\n \t\t\t\tDBFA718C187F1DA100A76262 /* ffi64_x86_64.c */,\n-\t\t\t\tDBFA718D187F1DA100A76262 /* ffi_i386.c */,\n+\t\t\t\tFDDB2F3F1F5D666900EF414E /* ffiw64_x86_64.c */,\n+\t\t\t\tDBFA718A187F1DA100A76262 /* unix64_x86_64.S */,\n+\t\t\t\tFDDB2F441F5D68C900EF414E /* win64_x86_64.S */,\n \t\t\t);\n \t\t\tpath = x86;\n \t\t\tsourceTree = \"<group>\";\n@@ -270,11 +344,8 @@\n \t\t\t\tDBFA714A187F1D8600A76262 /* ffi.h in Headers */,\n \t\t\t\tDBFA718F187F1DA100A76262 /* ffi_x86_64.h in Headers */,\n \t\t\t\tDBFA7191187F1DA100A76262 /* fficonfig_x86_64.h in Headers */,\n-\t\t\t\tDBFA718E187F1DA100A76262 /* ffi_i386.h in Headers */,\n-\t\t\t\tDBFA7190187F1DA100A76262 /* fficonfig_i386.h in Headers */,\n \t\t\t\tDBFA714B187F1D8600A76262 /* ffi_common.h in Headers */,\n \t\t\t\tDBFA7193187F1DA100A76262 /* ffitarget_x86_64.h in Headers */,\n-\t\t\t\tDBFA7192187F1DA100A76262 /* ffitarget_i386.h in Headers */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n@@ -285,7 +356,7 @@\n \t\t\tisa = PBXNativeTarget;\n \t\t\tbuildConfigurationList = DB13B18B1849DF1E0010F42D /* Build configuration list for PBXNativeTarget \"libffi-iOS\" */;\n \t\t\tbuildPhases = (\n-\t\t\t\tDB13B3051849E01C0010F42D /* ShellScript */,\n+\t\t\t\t43B5D3FB1D35480D00D1E1FD /* Run Script */,\n \t\t\t\tDB13B1621849DF1E0010F42D /* Sources */,\n \t\t\t\tDB13B1641849DF1E0010F42D /* CopyFiles */,\n \t\t\t);\n@@ -315,13 +386,47 @@\n \t\t\tproductReference = DB13B1911849DF510010F42D /* ffi.dylib */;\n \t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n \t\t};\n+\t\tFDB52FB01F6144FA00AA92E6 /* libffi-tvOS */ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = FDB52FC21F6144FA00AA92E6 /* Build configuration list for PBXNativeTarget \"libffi-tvOS\" */;\n+\t\t\tbuildPhases = (\n+\t\t\t\tFDB52FB11F6144FA00AA92E6 /* Run Script */,\n+\t\t\t\tFDB52FB21F6144FA00AA92E6 /* Sources */,\n+\t\t\t\tFDB52FC11F6144FA00AA92E6 /* CopyFiles */,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = \"libffi-tvOS\";\n+\t\t\tproductName = ffi;\n+\t\t\tproductReference = FDB52FC51F6144FA00AA92E6 /* libffi.a */;\n+\t\t\tproductType = \"com.apple.product-type.library.static\";\n+\t\t};\n+\t\tFDDB2F471F5D846400EF414E /* libffi-static-Mac */ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = FDDB2F5F1F5D846400EF414E /* Build configuration list for PBXNativeTarget \"libffi-static-Mac\" */;\n+\t\t\tbuildPhases = (\n+\t\t\t\tFDDB2F481F5D846400EF414E /* ShellScript */,\n+\t\t\t\tFDDB2F491F5D846400EF414E /* Sources */,\n+\t\t\t\tFDB52FE11F6156E000AA92E6 /* CopyFiles */,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = \"libffi-static-Mac\";\n+\t\t\tproductName = ffi;\n+\t\t\tproductReference = FDDB2F621F5D846400EF414E /* libffi.a */;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n+\t\t};\n /* End PBXNativeTarget section */\n \n /* Begin PBXProject section */\n \t\tDB13B15C1849DEB70010F42D /* Project object */ = {\n \t\t\tisa = PBXProject;\n \t\t\tattributes = {\n-\t\t\t\tLastUpgradeCheck = 0510;\n+\t\t\t\tLastUpgradeCheck = 0830;\n \t\t\t};\n \t\t\tbuildConfigurationList = DB13B15F1849DEB70010F42D /* Build configuration list for PBXProject \"libffi\" */;\n \t\t\tcompatibilityVersion = \"Xcode 3.2\";\n@@ -336,24 +441,27 @@\n \t\t\tprojectRoot = \"\";\n \t\t\ttargets = (\n \t\t\t\tDB13B1651849DF1E0010F42D /* libffi-iOS */,\n+\t\t\t\tFDB52FB01F6144FA00AA92E6 /* libffi-tvOS */,\n \t\t\t\tDB13B1901849DF510010F42D /* libffi-Mac */,\n+\t\t\t\tFDDB2F471F5D846400EF414E /* libffi-static-Mac */,\n \t\t\t);\n \t\t};\n /* End PBXProject section */\n \n /* Begin PBXShellScriptBuildPhase section */\n-\t\tDB13B3051849E01C0010F42D /* ShellScript */ = {\n+\t\t43B5D3FB1D35480D00D1E1FD /* Run Script */ = {\n \t\t\tisa = PBXShellScriptBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t);\n \t\t\tinputPaths = (\n \t\t\t);\n+\t\t\tname = \"Run Script\";\n \t\t\toutputPaths = (\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t\tshellPath = /bin/sh;\n-\t\t\tshellScript = \"/usr/bin/python generate-darwin-source-and-headers.py --only-ios\";\n+\t\t\tshellScript = \"if [ ! -f \\\"./compile\\\" ]\\nthen\\nautoreconf -i -f -v\\nif [ -f \\\"../ltmain.sh\\\" ]\\nthen\\necho \\\"fixing ltmain.sh for some reason\\\"\\nmv ../ltmain.sh ./\\nautoreconf -i -f -v\\nfi\\n/usr/bin/python generate-darwin-source-and-headers.py --only-ios\\nfi\";\n \t\t};\n \t\tDB13B3061849E0490010F42D /* ShellScript */ = {\n \t\t\tisa = PBXShellScriptBuildPhase;\n@@ -366,7 +474,34 @@\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t\tshellPath = /bin/sh;\n-\t\t\tshellScript = \"/usr/bin/python generate-darwin-source-and-headers.py --only-osx\";\n+\t\t\tshellScript = \"if [ ! -f \\\"./compile\\\" ]\\nthen\\nautoreconf -i -f -v\\nif [ -f \\\"../ltmain.sh\\\" ]\\nthen\\necho \\\"fixing ltmain.sh for some reason\\\"\\nmv ../ltmain.sh ./\\nautoreconf -i -f -v\\nfi\\n/usr/bin/python generate-darwin-source-and-headers.py --only-osx\\nfi\";\n+\t\t};\n+\t\tFDB52FB11F6144FA00AA92E6 /* Run Script */ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run Script\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = /bin/sh;\n+\t\t\tshellScript = \"if [ ! -f \\\"./compile\\\" ]\\nthen\\nautoreconf -i -f -v\\nif [ -f \\\"../ltmain.sh\\\" ]\\nthen\\necho \\\"fixing ltmain.sh for some reason\\\"\\nmv ../ltmain.sh ./\\nautoreconf -i -f -v\\nfi\\n/usr/bin/python generate-darwin-source-and-headers.py --only-ios\\nfi\";\n+\t\t};\n+\t\tFDDB2F481F5D846400EF414E /* ShellScript */ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = /bin/sh;\n+\t\t\tshellScript = \"if [ ! -f \\\"./compile\\\" ]\\nthen\\nautoreconf -i -f -v\\nif [ -f \\\"../ltmain.sh\\\" ]\\nthen\\necho \\\"fixing ltmain.sh for some reason\\\"\\nmv ../ltmain.sh ./\\nautoreconf -i -f -v\\nfi\\n/usr/bin/python generate-darwin-source-and-headers.py --only-osx\\nfi\";\n \t\t};\n /* End PBXShellScriptBuildPhase section */\n \n@@ -375,19 +510,18 @@\n \t\t\tisa = PBXSourcesBuildPhase;\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n+\t\t\t\t43E9A5C81D352C1500926A8F /* unix64_x86_64.S in Sources */,\n \t\t\t\tDBFA717E187F1D9B00A76262 /* ffi64_x86_64.c in Sources */,\n \t\t\t\tDBFA7179187F1D9B00A76262 /* ffi_armv7.c in Sources */,\n-\t\t\t\tDBFA717B187F1D9B00A76262 /* trampoline_armv7.S in Sources */,\n \t\t\t\tDBFA714E187F1D8600A76262 /* closures.c in Sources */,\n \t\t\t\tDBFA717A187F1D9B00A76262 /* sysv_armv7.S in Sources */,\n-\t\t\t\tDBFA717D187F1D9B00A76262 /* darwin_i386.S in Sources */,\n+\t\t\t\t43B5D3F81D35473200D1E1FD /* ffiw64_x86_64.c in Sources */,\n \t\t\t\tDBFA7156187F1D8600A76262 /* prep_cif.c in Sources */,\n-\t\t\t\tDBFA717F187F1D9B00A76262 /* ffi_i386.c in Sources */,\n \t\t\t\tDBFA7158187F1D8600A76262 /* raw_api.c in Sources */,\n \t\t\t\tDBFA7178187F1D9B00A76262 /* sysv_arm64.S in Sources */,\n-\t\t\t\tDBFA717C187F1D9B00A76262 /* darwin64_x86_64.S in Sources */,\n \t\t\t\tDBFA715A187F1D8600A76262 /* types.c in Sources */,\n \t\t\t\tDBFA7177187F1D9B00A76262 /* ffi_arm64.c in Sources */,\n+\t\t\t\t43B5D3FA1D3547CE00D1E1FD /* win64_x86_64.S in Sources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n@@ -396,13 +530,47 @@\n \t\t\tbuildActionMask = 2147483647;\n \t\t\tfiles = (\n \t\t\t\tDBFA7196187F1DA100A76262 /* ffi64_x86_64.c in Sources */,\n-\t\t\t\tDBFA7195187F1DA100A76262 /* darwin_i386.S in Sources */,\n \t\t\t\tDBFA7157187F1D8600A76262 /* prep_cif.c in Sources */,\n-\t\t\t\tDBFA7197187F1DA100A76262 /* ffi_i386.c in Sources */,\n+\t\t\t\tFDDB2F411F5D66E200EF414E /* ffiw64_x86_64.c in Sources */,\n \t\t\t\tDBFA715B187F1D8600A76262 /* types.c in Sources */,\n \t\t\t\tDBFA7159187F1D8600A76262 /* raw_api.c in Sources */,\n \t\t\t\tDBFA714F187F1D8600A76262 /* closures.c in Sources */,\n-\t\t\t\tDBFA7194187F1DA100A76262 /* darwin64_x86_64.S in Sources */,\n+\t\t\t\tDBFA7194187F1DA100A76262 /* unix64_x86_64.S in Sources */,\n+\t\t\t\tFDDB2F461F5D691E00EF414E /* win64_x86_64.S in Sources */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tFDB52FB21F6144FA00AA92E6 /* Sources */ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\tFDB52FB31F6144FA00AA92E6 /* unix64_x86_64.S in Sources */,\n+\t\t\t\tFDB52FB51F6144FA00AA92E6 /* ffi64_x86_64.c in Sources */,\n+\t\t\t\tFDB52FB61F6144FA00AA92E6 /* ffi_armv7.c in Sources */,\n+\t\t\t\tFDB52FB71F6144FA00AA92E6 /* closures.c in Sources */,\n+\t\t\t\tFDB52FB81F6144FA00AA92E6 /* sysv_armv7.S in Sources */,\n+\t\t\t\tFDB52FB91F6144FA00AA92E6 /* ffiw64_x86_64.c in Sources */,\n+\t\t\t\tFDB52FBA1F6144FA00AA92E6 /* prep_cif.c in Sources */,\n+\t\t\t\tFDB52FBC1F6144FA00AA92E6 /* raw_api.c in Sources */,\n+\t\t\t\tFDB52FBD1F6144FA00AA92E6 /* sysv_arm64.S in Sources */,\n+\t\t\t\tFDB52FBE1F6144FA00AA92E6 /* types.c in Sources */,\n+\t\t\t\tFDB52FBF1F6144FA00AA92E6 /* ffi_arm64.c in Sources */,\n+\t\t\t\tFDB52FC01F6144FA00AA92E6 /* win64_x86_64.S in Sources */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tFDDB2F491F5D846400EF414E /* Sources */ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\tFDDB2F4A1F5D846400EF414E /* ffi64_x86_64.c in Sources */,\n+\t\t\t\tFDDB2F4C1F5D846400EF414E /* prep_cif.c in Sources */,\n+\t\t\t\tFDDB2F4E1F5D846400EF414E /* ffiw64_x86_64.c in Sources */,\n+\t\t\t\tFDDB2F4F1F5D846400EF414E /* types.c in Sources */,\n+\t\t\t\tFDDB2F501F5D846400EF414E /* raw_api.c in Sources */,\n+\t\t\t\tFDDB2F511F5D846400EF414E /* closures.c in Sources */,\n+\t\t\t\tFDDB2F521F5D846400EF414E /* unix64_x86_64.S in Sources */,\n+\t\t\t\tFDDB2F531F5D846400EF414E /* win64_x86_64.S in Sources */,\n \t\t\t);\n \t\t\trunOnlyForDeploymentPostprocessing = 0;\n \t\t};\n@@ -412,9 +580,27 @@\n \t\tDB13B1601849DEB70010F42D /* Debug */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INFINITE_RECURSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_SUSPICIOUS_MOVE = YES;\n+\t\t\t\tCLANG_WARN_UNREACHABLE_CODE = YES;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tENABLE_STRICT_OBJC_MSGSEND = YES;\n+\t\t\t\tENABLE_TESTABILITY = YES;\n+\t\t\t\tGCC_NO_COMMON_BLOCKS = YES;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_common/include\",\n+\t\t\t\t\tdarwin_common/include,\n \t\t\t\t);\n \t\t\t\tONLY_ACTIVE_ARCH = YES;\n \t\t\t};\n@@ -423,9 +609,26 @@\n \t\tDB13B1611849DEB70010F42D /* Release */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INFINITE_RECURSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_SUSPICIOUS_MOVE = YES;\n+\t\t\t\tCLANG_WARN_UNREACHABLE_CODE = YES;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tENABLE_STRICT_OBJC_MSGSEND = YES;\n+\t\t\t\tGCC_NO_COMMON_BLOCKS = YES;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_common/include\",\n+\t\t\t\t\tdarwin_common/include,\n \t\t\t\t);\n \t\t\t};\n \t\t\tname = Release;\n@@ -434,11 +637,6 @@\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n \t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_INCLUDING_64_BIT)\";\n-\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n-\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n-\t\t\t\tCLANG_ENABLE_MODULES = YES;\n-\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n \t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n@@ -449,14 +647,11 @@\n \t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n \t\t\t\tCOPY_PHASE_STRIP = NO;\n \t\t\t\tDSTROOT = /tmp/ffi.dst;\n-\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n-\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n \t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n \t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n \t\t\t\t\t\"DEBUG=1\",\n \t\t\t\t\t\"$(inherited)\",\n \t\t\t\t);\n-\t\t\t\tGCC_SYMBOLS_PRIVATE_EXTERN = NO;\n \t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n \t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n \t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n@@ -465,26 +660,20 @@\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_ios/include\",\n+\t\t\t\t\tdarwin_ios/include,\n \t\t\t\t);\n-\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 5.0;\n-\t\t\t\t\"IPHONEOS_DEPLOYMENT_TARGET[arch=arm64]\" = 7.0;\n-\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 8.0;\n \t\t\t\tPRODUCT_NAME = ffi;\n \t\t\t\tSDKROOT = iphoneos;\n \t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tVALID_ARCHS = \"arm64 armv7 armv7s x86_64\";\n \t\t\t};\n \t\t\tname = Debug;\n \t\t};\n \t\tDB13B1881849DF1E0010F42D /* Release */ = {\n \t\t\tisa = XCBuildConfiguration;\n \t\t\tbuildSettings = {\n \t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n-\t\t\t\tARCHS = \"$(ARCHS_STANDARD_INCLUDING_64_BIT)\";\n-\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n-\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n-\t\t\t\tCLANG_ENABLE_MODULES = YES;\n-\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n \t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n@@ -496,7 +685,6 @@\n \t\t\t\tCOPY_PHASE_STRIP = YES;\n \t\t\t\tDSTROOT = /tmp/ffi.dst;\n \t\t\t\tENABLE_NS_ASSERTIONS = NO;\n-\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n \t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n \t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n \t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n@@ -505,15 +693,14 @@\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_ios/include\",\n+\t\t\t\t\tdarwin_ios/include,\n \t\t\t\t);\n-\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 5.0;\n-\t\t\t\t\"IPHONEOS_DEPLOYMENT_TARGET[arch=arm64]\" = 7.0;\n-\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 8.0;\n \t\t\t\tPRODUCT_NAME = ffi;\n \t\t\t\tSDKROOT = iphoneos;\n \t\t\t\tSKIP_INSTALL = YES;\n \t\t\t\tVALIDATE_PRODUCT = YES;\n+\t\t\t\tVALID_ARCHS = \"arm64 armv7 armv7s x86_64\";\n \t\t\t};\n \t\t\tname = Release;\n \t\t};\n@@ -532,6 +719,7 @@\n \t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n \t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n \t\t\t\tCOPY_PHASE_STRIP = NO;\n \t\t\t\tDYLIB_COMPATIBILITY_VERSION = 1;\n \t\t\t\tDYLIB_CURRENT_VERSION = 1;\n@@ -552,7 +740,7 @@\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_osx/include\",\n+\t\t\t\t\tdarwin_osx/include,\n \t\t\t\t);\n \t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n \t\t\t\tONLY_ACTIVE_ARCH = YES;\n@@ -577,6 +765,7 @@\n \t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n \t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n \t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n \t\t\t\tCOPY_PHASE_STRIP = YES;\n \t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n \t\t\t\tDYLIB_COMPATIBILITY_VERSION = 1;\n@@ -592,7 +781,7 @@\n \t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n \t\t\t\tHEADER_SEARCH_PATHS = (\n \t\t\t\t\t\"$(inherited)\",\n-\t\t\t\t\t\"darwin_osx/include\",\n+\t\t\t\t\tdarwin_osx/include,\n \t\t\t\t);\n \t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n \t\t\t\tOTHER_LDFLAGS = \"-Wl,-no_compact_unwind\";\n@@ -601,6 +790,159 @@\n \t\t\t};\n \t\t\tname = Release;\n \t\t};\n+\t\tFDB52FC31F6144FA00AA92E6 /* Debug */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n+\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n+\t\t\t\t\t\"DEBUG=1\",\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t);\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\tdarwin_ios/include,\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = appletvos;\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tTVOS_DEPLOYMENT_TARGET = 9.0;\n+\t\t\t};\n+\t\t\tname = Debug;\n+\t\t};\n+\t\tFDB52FC41F6144FA00AA92E6 /* Release */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = YES;\n+\t\t\t\tENABLE_NS_ASSERTIONS = NO;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\tdarwin_ios/include,\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = appletvos;\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tTVOS_DEPLOYMENT_TARGET = 9.0;\n+\t\t\t\tVALIDATE_PRODUCT = YES;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tFDDB2F601F5D846400EF414E /* Debug */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tEXECUTABLE_EXTENSION = a;\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n+\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n+\t\t\t\t\t\"DEBUG=1\",\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t);\n+\t\t\t\tGCC_SYMBOLS_PRIVATE_EXTERN = NO;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\tdarwin_osx/include,\n+\t\t\t\t);\n+\t\t\t\tMACH_O_TYPE = staticlib;\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Debug;\n+\t\t};\n+\t\tFDDB2F611F5D846400EF414E /* Release */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n+\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n+\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n+\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n+\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n+\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n+\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n+\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n+\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n+\t\t\t\tCOPY_PHASE_STRIP = YES;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tENABLE_NS_ASSERTIONS = NO;\n+\t\t\t\tEXECUTABLE_EXTENSION = a;\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n+\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n+\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\tdarwin_osx/include,\n+\t\t\t\t);\n+\t\t\t\tMACH_O_TYPE = staticlib;\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n /* End XCBuildConfiguration section */\n \n /* Begin XCConfigurationList section */\n@@ -631,6 +973,24 @@\n \t\t\tdefaultConfigurationIsVisible = 0;\n \t\t\tdefaultConfigurationName = Release;\n \t\t};\n+\t\tFDB52FC21F6144FA00AA92E6 /* Build configuration list for PBXNativeTarget \"libffi-tvOS\" */ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tFDB52FC31F6144FA00AA92E6 /* Debug */,\n+\t\t\t\tFDB52FC41F6144FA00AA92E6 /* Release */,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tFDDB2F5F1F5D846400EF414E /* Build configuration list for PBXNativeTarget \"libffi-static-Mac\" */ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tFDDB2F601F5D846400EF414E /* Debug */,\n+\t\t\t\tFDDB2F611F5D846400EF414E /* Release */,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n /* End XCConfigurationList section */\n \t};\n \trootObject = DB13B15C1849DEB70010F42D /* Project object */;"}, {"sha": "607fee5585d9c7afec826675689a56abad43966d", "filename": "libffi/libtool-version", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibtool-version?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -2,5 +2,28 @@\n # the libtool manual to understand the meaning of the fields.  This is\n # a separate file so that version updates don't involve re-running\n # automake.\n+#\n+# Here are a set of rules to help you update your library version\n+# information:\n+# \n+# 1. Start with version information of `0:0:0' for each libtool library.\n+#\n+# 2. Update the version information only immediately before a public\n+#    release of your software. More frequent updates are unnecessary,\n+#    and only guarantee that the current interface number gets larger\n+#    faster.\n+#\n+# 3. If the library source code has changed at all since the last\n+#    update, then increment revision (`c:r:a' becomes `c:r+1:a').\n+#\n+# 4. If any interfaces have been added, removed, or changed since the\n+#    last update, increment current, and set revision to 0.\n+#\n+# 5. If any interfaces have been added since the last public release,\n+#    then increment age.\n+#\n+# 6. If any interfaces have been removed since the last public\n+#    release, then set age to 0.\n+#\n # CURRENT:REVISION:AGE\n-7:0:0\n+9:0:1"}, {"sha": "754691095f715cacba2bad7a991f9c5318e51e99", "filename": "libffi/man/Makefile.in", "status": "removed", "additions": 0, "deletions": 515, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fman%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fman%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.in?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,515 +0,0 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n-\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-VPATH = @srcdir@\n-am__is_gnu_make = { \\\n-  if test -z '$(MAKELEVEL)'; then \\\n-    false; \\\n-  elif test -n '$(MAKE_HOST)'; then \\\n-    true; \\\n-  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \\\n-    true; \\\n-  else \\\n-    false; \\\n-  fi; \\\n-}\n-am__make_running_with_option = \\\n-  case $${target_option-} in \\\n-      ?) ;; \\\n-      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n-              \"target option '$${target_option-}' specified\" >&2; \\\n-         exit 1;; \\\n-  esac; \\\n-  has_opt=no; \\\n-  sane_makeflags=$$MAKEFLAGS; \\\n-  if $(am__is_gnu_make); then \\\n-    sane_makeflags=$$MFLAGS; \\\n-  else \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        bs=\\\\; \\\n-        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n-          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n-    esac; \\\n-  fi; \\\n-  skip_next=no; \\\n-  strip_trailopt () \\\n-  { \\\n-    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n-  }; \\\n-  for flg in $$sane_makeflags; do \\\n-    test $$skip_next = yes && { skip_next=no; continue; }; \\\n-    case $$flg in \\\n-      *=*|--*) continue;; \\\n-        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n-      -*I?*) strip_trailopt 'I';; \\\n-        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n-      -*O?*) strip_trailopt 'O';; \\\n-        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n-      -*l?*) strip_trailopt 'l';; \\\n-      -[dEDm]) skip_next=yes;; \\\n-      -[JT]) skip_next=yes;; \\\n-    esac; \\\n-    case $$flg in \\\n-      *$$target_option*) has_opt=yes; break;; \\\n-    esac; \\\n-  done; \\\n-  test $$has_opt = yes\n-am__make_dryrun = (target_option=n; $(am__make_running_with_option))\n-am__make_keepgoing = (target_option=k; $(am__make_running_with_option))\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = man\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/asmcfi.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/toolexeclibdir.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-DIST_COMMON = $(srcdir)/Makefile.am\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = $(top_builddir)/fficonfig.h\n-CONFIG_CLEAN_FILES =\n-CONFIG_CLEAN_VPATH_FILES =\n-AM_V_P = $(am__v_P_@AM_V@)\n-am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n-am__v_P_0 = false\n-am__v_P_1 = :\n-AM_V_GEN = $(am__v_GEN_@AM_V@)\n-am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\n-am__v_GEN_0 = @echo \"  GEN     \" $@;\n-am__v_GEN_1 = \n-AM_V_at = $(am__v_at_@AM_V@)\n-am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\n-am__v_at_0 = @\n-am__v_at_1 = \n-SOURCES =\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__uninstall_files_from_dir = { \\\n-  test -z \"$$files\" \\\n-    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n-    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n-         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n-  }\n-man3dir = $(mandir)/man3\n-am__installdirs = \"$(DESTDIR)$(man3dir)\"\n-NROFF = nroff\n-MANS = $(man_MANS)\n-am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n-ACLOCAL = @ACLOCAL@\n-ALLOCA = @ALLOCA@\n-AMTAR = @AMTAR@\n-AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\n-AM_LTLDFLAGS = @AM_LTLDFLAGS@\n-AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCAS = @CCAS@\n-CCASDEPMODE = @CCASDEPMODE@\n-CCASFLAGS = @CCASFLAGS@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-CXXDEPMODE = @CXXDEPMODE@\n-CXXFLAGS = @CXXFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n-HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OPT_LDFLAGS = @OPT_LDFLAGS@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SECTION_LDFLAGS = @SECTION_LDFLAGS@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-TARGET = @TARGET@\n-TARGETDIR = @TARGETDIR@\n-TARGET_OBJ = @TARGET_OBJ@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_CXX = @ac_ct_CXX@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-get_gcc_base_ver = @get_gcc_base_ver@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign\n-EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n-man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n-all: all-am\n-\n-.SUFFIXES:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n-\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign man/Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign man/Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(am__aclocal_m4_deps):\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-install-man3: $(man_MANS)\n-\t@$(NORMAL_INSTALL)\n-\t@list1=''; \\\n-\tlist2='$(man_MANS)'; \\\n-\ttest -n \"$(man3dir)\" \\\n-\t  && test -n \"`echo $$list1$$list2`\" \\\n-\t  || exit 0; \\\n-\techo \" $(MKDIR_P) '$(DESTDIR)$(man3dir)'\"; \\\n-\t$(MKDIR_P) \"$(DESTDIR)$(man3dir)\" || exit 1; \\\n-\t{ for i in $$list1; do echo \"$$i\"; done;  \\\n-\tif test -n \"$$list2\"; then \\\n-\t  for i in $$list2; do echo \"$$i\"; done \\\n-\t    | sed -n '/\\.3[a-z]*$$/p'; \\\n-\tfi; \\\n-\t} | while read p; do \\\n-\t  if test -f $$p; then d=; else d=\"$(srcdir)/\"; fi; \\\n-\t  echo \"$$d$$p\"; echo \"$$p\"; \\\n-\tdone | \\\n-\tsed -e 'n;s,.*/,,;p;h;s,.*\\.,,;s,^[^3][0-9a-z]*$$,3,;x' \\\n-\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,' | \\\n-\tsed 'N;N;s,\\n, ,g' | { \\\n-\tlist=; while read file base inst; do \\\n-\t  if test \"$$base\" = \"$$inst\"; then list=\"$$list $$file\"; else \\\n-\t    echo \" $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man3dir)/$$inst'\"; \\\n-\t    $(INSTALL_DATA) \"$$file\" \"$(DESTDIR)$(man3dir)/$$inst\" || exit $$?; \\\n-\t  fi; \\\n-\tdone; \\\n-\tfor i in $$list; do echo \"$$i\"; done | $(am__base_list) | \\\n-\twhile read files; do \\\n-\t  test -z \"$$files\" || { \\\n-\t    echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(man3dir)'\"; \\\n-\t    $(INSTALL_DATA) $$files \"$(DESTDIR)$(man3dir)\" || exit $$?; }; \\\n-\tdone; }\n-\n-uninstall-man3:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list=''; test -n \"$(man3dir)\" || exit 0; \\\n-\tfiles=`{ for i in $$list; do echo \"$$i\"; done; \\\n-\tl2='$(man_MANS)'; for i in $$l2; do echo \"$$i\"; done | \\\n-\t  sed -n '/\\.3[a-z]*$$/p'; \\\n-\t} | sed -e 's,.*/,,;h;s,.*\\.,,;s,^[^3][0-9a-z]*$$,3,;x' \\\n-\t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,'`; \\\n-\tdir='$(DESTDIR)$(man3dir)'; $(am__uninstall_files_from_dir)\n-tags TAGS:\n-\n-ctags CTAGS:\n-\n-cscope cscopelist:\n-\n-check-am: all-am\n-check: check-am\n-all-am: Makefile $(MANS)\n-installdirs:\n-\tfor dir in \"$(DESTDIR)$(man3dir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libtool mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-generic\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am: install-man\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am:\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man: install-man3\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am: uninstall-man\n-\n-uninstall-man: uninstall-man3\n-\n-.MAKE: install-am install-strip\n-\n-.PHONY: all all-am check check-am clean clean-generic clean-libtool \\\n-\tcscopelist-am ctags-am distclean distclean-generic \\\n-\tdistclean-libtool dvi dvi-am html html-am info info-am install \\\n-\tinstall-am install-data install-data-am install-dvi \\\n-\tinstall-dvi-am install-exec install-exec-am install-html \\\n-\tinstall-html-am install-info install-info-am install-man \\\n-\tinstall-man3 install-pdf install-pdf-am install-ps \\\n-\tinstall-ps-am install-strip installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \\\n-\tps ps-am tags-am uninstall uninstall-am uninstall-man \\\n-\tuninstall-man3\n-\n-.PRECIOUS: Makefile\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "e631b2219a3cc2ccb992cb1a5f2f42e6b6d84765", "filename": "libffi/mdate-sh", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fmdate-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fmdate-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fmdate-sh?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,205 +0,0 @@\n-#!/bin/sh\n-# Get modification time of a file or directory and pretty-print it.\n-\n-scriptversion=2009-04-28.21; # UTC\n-\n-# Copyright (C) 1995, 1996, 1997, 2003, 2004, 2005, 2007, 2009 Free\n-# Software Foundation, Inc.\n-# written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, June 1995\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-# As a special exception to the GNU General Public License, if you\n-# distribute this file as part of a program that contains a\n-# configuration script generated by Autoconf, you may include it under\n-# the same distribution terms that you use for the rest of that program.\n-\n-# This file is maintained in Automake, please report\n-# bugs to <bug-automake@gnu.org> or send patches to\n-# <automake-patches@gnu.org>.\n-\n-case $1 in\n-  '')\n-     echo \"$0: No file.  Try \\`$0 --help' for more information.\" 1>&2\n-     exit 1;\n-     ;;\n-  -h | --h*)\n-    cat <<\\EOF\n-Usage: mdate-sh [--help] [--version] FILE\n-\n-Pretty-print the modification time of FILE.\n-\n-Report bugs to <bug-automake@gnu.org>.\n-EOF\n-    exit $?\n-    ;;\n-  -v | --v*)\n-    echo \"mdate-sh $scriptversion\"\n-    exit $?\n-    ;;\n-esac\n-\n-# Prevent date giving response in another language.\n-LANG=C\n-export LANG\n-LC_ALL=C\n-export LC_ALL\n-LC_TIME=C\n-export LC_TIME\n-\n-# GNU ls changes its time format in response to the TIME_STYLE\n-# variable.  Since we cannot assume `unset' works, revert this\n-# variable to its documented default.\n-if test \"${TIME_STYLE+set}\" = set; then\n-  TIME_STYLE=posix-long-iso\n-  export TIME_STYLE\n-fi\n-\n-save_arg1=$1\n-\n-# Find out how to get the extended ls output of a file or directory.\n-if ls -L /dev/null 1>/dev/null 2>&1; then\n-  ls_command='ls -L -l -d'\n-else\n-  ls_command='ls -l -d'\n-fi\n-# Avoid user/group names that might have spaces, when possible.\n-if ls -n /dev/null 1>/dev/null 2>&1; then\n-  ls_command=\"$ls_command -n\"\n-fi\n-\n-# A `ls -l' line looks as follows on OS/2.\n-#  drwxrwx---        0 Aug 11  2001 foo\n-# This differs from Unix, which adds ownership information.\n-#  drwxrwx---   2 root  root      4096 Aug 11  2001 foo\n-#\n-# To find the date, we split the line on spaces and iterate on words\n-# until we find a month.  This cannot work with files whose owner is a\n-# user named `Jan', or `Feb', etc.  However, it's unlikely that `/'\n-# will be owned by a user whose name is a month.  So we first look at\n-# the extended ls output of the root directory to decide how many\n-# words should be skipped to get the date.\n-\n-# On HPUX /bin/sh, \"set\" interprets \"-rw-r--r--\" as options, so the \"x\" below.\n-set x`$ls_command /`\n-\n-# Find which argument is the month.\n-month=\n-command=\n-until test $month\n-do\n-  shift\n-  # Add another shift to the command.\n-  command=\"$command shift;\"\n-  case $1 in\n-    Jan) month=January; nummonth=1;;\n-    Feb) month=February; nummonth=2;;\n-    Mar) month=March; nummonth=3;;\n-    Apr) month=April; nummonth=4;;\n-    May) month=May; nummonth=5;;\n-    Jun) month=June; nummonth=6;;\n-    Jul) month=July; nummonth=7;;\n-    Aug) month=August; nummonth=8;;\n-    Sep) month=September; nummonth=9;;\n-    Oct) month=October; nummonth=10;;\n-    Nov) month=November; nummonth=11;;\n-    Dec) month=December; nummonth=12;;\n-  esac\n-done\n-\n-# Get the extended ls output of the file or directory.\n-set dummy x`eval \"$ls_command \\\"\\$save_arg1\\\"\"`\n-\n-# Remove all preceding arguments\n-eval $command\n-\n-# Because of the dummy argument above, month is in $2.\n-#\n-# On a POSIX system, we should have\n-#\n-# $# = 5\n-# $1 = file size\n-# $2 = month\n-# $3 = day\n-# $4 = year or time\n-# $5 = filename\n-#\n-# On Darwin 7.7.0 and 7.6.0, we have\n-#\n-# $# = 4\n-# $1 = day\n-# $2 = month\n-# $3 = year or time\n-# $4 = filename\n-\n-# Get the month.\n-case $2 in\n-  Jan) month=January; nummonth=1;;\n-  Feb) month=February; nummonth=2;;\n-  Mar) month=March; nummonth=3;;\n-  Apr) month=April; nummonth=4;;\n-  May) month=May; nummonth=5;;\n-  Jun) month=June; nummonth=6;;\n-  Jul) month=July; nummonth=7;;\n-  Aug) month=August; nummonth=8;;\n-  Sep) month=September; nummonth=9;;\n-  Oct) month=October; nummonth=10;;\n-  Nov) month=November; nummonth=11;;\n-  Dec) month=December; nummonth=12;;\n-esac\n-\n-case $3 in\n-  ???*) day=$1;;\n-  *) day=$3; shift;;\n-esac\n-\n-# Here we have to deal with the problem that the ls output gives either\n-# the time of day or the year.\n-case $3 in\n-  *:*) set `date`; eval year=\\$$#\n-       case $2 in\n-\t Jan) nummonthtod=1;;\n-\t Feb) nummonthtod=2;;\n-\t Mar) nummonthtod=3;;\n-\t Apr) nummonthtod=4;;\n-\t May) nummonthtod=5;;\n-\t Jun) nummonthtod=6;;\n-\t Jul) nummonthtod=7;;\n-\t Aug) nummonthtod=8;;\n-\t Sep) nummonthtod=9;;\n-\t Oct) nummonthtod=10;;\n-\t Nov) nummonthtod=11;;\n-\t Dec) nummonthtod=12;;\n-       esac\n-       # For the first six month of the year the time notation can also\n-       # be used for files modified in the last year.\n-       if (expr $nummonth \\> $nummonthtod) > /dev/null;\n-       then\n-\t year=`expr $year - 1`\n-       fi;;\n-  *) year=$3;;\n-esac\n-\n-# The result.\n-echo $day $month $year\n-\n-# Local Variables:\n-# mode: shell-script\n-# sh-indentation: 2\n-# eval: (add-hook 'write-file-hooks 'time-stamp)\n-# time-stamp-start: \"scriptversion=\"\n-# time-stamp-format: \"%:y-%02m-%02d.%02H\"\n-# time-stamp-time-zone: \"UTC\"\n-# time-stamp-end: \"; # UTC\"\n-# End:"}, {"sha": "301e2fbd6840feae9944add823a829b1c89bda8f", "filename": "libffi/msvcc.sh", "status": "modified", "additions": 115, "deletions": 19, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fmsvcc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fmsvcc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fmsvcc.sh?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -44,17 +44,29 @@\n \n args_orig=$@\n args=\"-nologo -W3\"\n+linkargs=\n static_crt=\n debug_crt=\n cl=\"cl\"\n ml=\"ml\"\n safeseh=\"-safeseh\"\n output=\n+libpaths=\n+libversion=8\n+verbose=\n \n while [ $# -gt 0 ]\n do\n   case $1\n   in\n+    --verbose)\n+      verbose=1\n+      shift 1\n+    ;;\n+    --version)\n+      args=\"-help\"\n+      shift 1\n+    ;;\n     -fexceptions)\n       # Don't enable exceptions for now.\n       #args=\"$args -EHac\"\n@@ -68,9 +80,18 @@ do\n       safeseh=\n       shift 1\n     ;;\n+    -marm)\n+      ml='armasm'\n+      safeseh=\n+      shift 1\n+    ;;\n+    -marm64)\n+      ml='armasm64'\n+      safeseh=\n+      shift 1\n+    ;;\n     -clang-cl)\n       cl=\"clang-cl\"\n-      safeseh=\n       shift 1\n     ;;\n     -O0)\n@@ -144,13 +165,44 @@ do\n       shift 1\n     ;;\n     -I)\n-      args=\"$args -I$2\"\n-      includes=\"$includes -I$2\"\n+      p=$(cygpath -ma \"$2\")\n+      args=\"$args -I\\\"$p\\\"\"\n+      includes=\"$includes -I\\\"$p\\\"\"\n       shift 2\n     ;;\n     -I*)\n-      args=\"$args $1\"\n-      includes=\"$includes $1\"\n+      p=$(cygpath -ma \"${1#-I}\")\n+      args=\"$args -I\\\"$p\\\"\"\n+      includes=\"$includes -I\\\"$p\\\"\"\n+      shift 1\n+    ;;\n+    -L)\n+      p=$(cygpath -ma $2)\n+      linkargs=\"$linkargs -LIBPATH:$p\"\n+      shift 2\n+    ;;\n+    -L*)\n+      p=$(cygpath -ma ${1#-L})\n+      linkargs=\"$linkargs -LIBPATH:$p\"\n+      shift 1\n+    ;;\n+    -link)\n+      # add next argument verbatim to linker args\n+      linkargs=\"$linkargs $2\"\n+      shift 2\n+      ;;\n+    -l*)\n+      case $1\n+      in\n+        -lffi)\n+          linkargs=\"$linkargs lib${1#-l}-${libversion}.lib\"\n+          ;;\n+        *)\n+          # ignore other libraries like -lm, hope they are\n+          # covered by MSVCRT\n+          # linkargs=\"$linkargs ${1#-l}.lib\"\n+          ;;\n+      esac\n       shift 1\n     ;;\n     -W|-Wextra)\n@@ -166,6 +218,15 @@ do\n       # libffi tests -pedantic with -Wall, so drop it also.\n       shift 1\n     ;;\n+    -warn)\n+      # ignore -warn all from libtool as well.\n+      if test \"$2\" = \"all\"; then\n+        shift 2\n+      else\n+        args=\"$args -warn\"\n+        shift 1\n+      fi\n+    ;;\n     -Werror)\n       args=\"$args -WX\"\n       shift 1\n@@ -186,6 +247,7 @@ do\n       else\n         output=\"-Fe$2\"\n       fi\n+      armasm_output=\"-o $2\"\n       if [ -n \"$assembly\" ]; then\n         args=\"$args $output\"\n       else\n@@ -194,12 +256,12 @@ do\n       shift 2\n     ;;\n     *.S)\n-      src=$1\n+      src=\"$(cygpath -ma $1)\"\n       assembly=\"true\"\n       shift 1\n     ;;\n     *.c)\n-      args=\"$args $1\"\n+      args=\"$args $(cygpath -ma $1)\"\n       shift 1\n     ;;\n     *)\n@@ -210,11 +272,16 @@ do\n   esac\n done\n \n-# If -Zi is specified, certain optimizations are implicitly disabled\n-# by MSVC. Add back those optimizations if this is an optimized build.\n-# NOTE: These arguments must come after all others.\n-if [ -n \"$opt\" ]; then\n-    args=\"$args -link -OPT:REF -OPT:ICF -INCREMENTAL:NO\"\n+if [ -n \"$linkargs\" ]; then\n+\n+    # If -Zi is specified, certain optimizations are implicitly disabled\n+    # by MSVC. Add back those optimizations if this is an optimized build.\n+    # NOTE: These arguments must come after all others.\n+    if [ -n \"$opt\" ]; then\n+\tlinkargs=\"$linkargs -OPT:REF -OPT:ICF -INCREMENTAL:NO\"\n+    fi\n+\n+    args=\"$args -link $linkargs\"\n fi\n \n if [ -n \"$static_crt\" ]; then\n@@ -232,26 +299,55 @@ if [ -n \"$assembly\" ]; then\n       outdir=\".\"\n     fi\n     ppsrc=\"$outdir/$(basename $src|sed 's/.S$/.asm/g')\"\n-    echo \"$cl -nologo -EP $includes $defines $src > $ppsrc\"\n-    \"$cl\" -nologo -EP $includes $defines $src > $ppsrc || exit $?\n+\n+    if [ $ml = \"armasm\" ]; then\n+      defines=\"$defines -D_M_ARM\"\n+    fi\n+\n+    if [ $ml = \"armasm64\" ]; then\n+      defines=\"$defines -D_M_ARM64\"\n+    fi\n+\n+    if test -n \"$verbose\"; then\n+      echo \"$cl -nologo -EP $includes $defines $src > $ppsrc\"\n+    fi\n+\n+    eval \"\\\"$cl\\\" -nologo -EP $includes $defines $src\" > $ppsrc || exit $?\n     output=\"$(echo $output | sed 's%/F[dpa][^ ]*%%g')\"\n-    args=\"-nologo $safeseh $single $output $ppsrc\"\n+    if [ $ml = \"armasm\" ]; then\n+      args=\"-nologo -g -oldit $armasm_output $ppsrc -errorReport:prompt\"\n+    elif [ $ml = \"armasm64\" ]; then\n+      args=\"-nologo -g $armasm_output $ppsrc -errorReport:prompt\"\n+    else\n+      args=\"-nologo $safeseh $single $output $ppsrc\"\n+    fi\n+\n+    if test -n \"$verbose\"; then\n+      echo \"$ml $args\"\n+    fi\n \n-    echo \"$ml $args\"\n     eval \"\\\"$ml\\\" $args\"\n     result=$?\n \n     # required to fix ml64 broken output?\n     #mv *.obj $outdir\n else\n     args=\"$md $args\"\n-    echo \"$cl $args\"\n+\n+    if test -n \"$verbose\"; then\n+      echo \"$cl $args\"\n+    fi\n     # Return an error code of 1 if an invalid command line parameter is passed\n-    # instead of just ignoring it.\n+    # instead of just ignoring it. Any output that is not a warning or an\n+    # error is filtered so this command behaves more like gcc. cl.exe prints\n+    # the name of the compiled file otherwise, which breaks the dejagnu checks\n+    # for excess warnings and errors.\n     eval \"(\\\"$cl\\\" $args 2>&1 1>&3 | \\\n-          awk '{print \\$0} /D9002/ {error=1} END{exit error}' >&2) 3>&1\"\n+          awk '{print \\$0} /D9002/ {error=1} END{exit error}' >&2) 3>&1 | \\\n+          awk '/warning|error/'\"\n     result=$?\n fi\n \n exit $result\n \n+# vim: noai:ts=4:sw=4"}, {"sha": "5c85fcd0e9c9ba7dd77ebdc14b980c507776d451", "filename": "libffi/src/aarch64/ffi.c", "status": "modified", "additions": 224, "deletions": 312, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -19,12 +19,18 @@ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n \n+#if defined(__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)\n #include <stdio.h>\n #include <stdlib.h>\n #include <stdint.h>\n+#include <fficonfig.h>\n #include <ffi.h>\n #include <ffi_common.h>\n #include \"internal.h\"\n+#ifdef _WIN32\n+#include <windows.h> /* FlushInstructionCache */\n+#endif\n+#include <tramp.h>\n \n /* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;\n    all further uses in this file will refer to the 128-bit type.  */\n@@ -54,6 +60,17 @@ struct call_context\n   UINT64 x[N_X_ARG_REG];\n };\n \n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#ifdef __MACH__\n+#ifdef HAVE_PTRAUTH\n+#include <ptrauth.h>\n+#endif\n+#include <mach/vm_param.h>\n+#endif\n+\n+#else\n+\n #if defined (__clang__) && defined (__APPLE__)\n extern void sys_icache_invalidate (void *start, size_t len);\n #endif\n@@ -65,11 +82,15 @@ ffi_clear_cache (void *start, void *end)\n   sys_icache_invalidate (start, (char *)end - (char *)start);\n #elif defined (__GNUC__)\n   __builtin___clear_cache (start, end);\n+#elif defined (_WIN32)\n+  FlushInstructionCache(GetCurrentProcess(), start, (char*)end - (char*)start);\n #else\n #error \"Missing builtin to flush instruction cache\"\n #endif\n }\n \n+#endif\n+\n /* A subroutine of is_vfp_type.  Given a structure type, return the type code\n    of the first non-structure element.  Recurse for structure elements.\n    Return -1 if the structure is in fact empty, i.e. no nested elements.  */\n@@ -220,7 +241,7 @@ is_vfp_type (const ffi_type *ty)\n \n   /* All tests succeeded.  Encode the result.  */\n  done:\n-  return candidate * 4 + (4 - ele_count);\n+  return candidate * 4 + (4 - (int)ele_count);\n }\n \n /* Representation of the procedure call argument marshalling\n@@ -269,7 +290,7 @@ allocate_to_stack (struct arg_state *state, void *stack,\n     alignment = 8;\n #endif\n     \n-  nsaa = ALIGN (nsaa, alignment);\n+  nsaa = FFI_ALIGN (nsaa, alignment);\n   state->nsaa = nsaa + size;\n \n   return (char *)stack + nsaa;\n@@ -304,10 +325,13 @@ extend_integer_type (void *source, int type)\n     }\n }\n \n+#if defined(_MSC_VER)\n+void extend_hfa_type (void *dest, void *src, int h);\n+#else\n static void\n extend_hfa_type (void *dest, void *src, int h)\n {\n-  int f = h - AARCH64_RET_S4;\n+  ssize_t f = h - AARCH64_RET_S4;\n   void *x0;\n \n   asm volatile (\n@@ -339,10 +363,10 @@ extend_hfa_type (void *dest, void *src, int h)\n \"\tb\t1f\\n\"\n \"\tnop\\n\"\n \"\tldp\tq16, q17, [%3]\\n\"\t/* Q4 */\n-\"\tldp\tq18, q19, [%3, #16]\\n\"\n+\"\tldp\tq18, q19, [%3, #32]\\n\"\n \"\tb\t4f\\n\"\n \"\tldp\tq16, q17, [%3]\\n\"\t/* Q3 */\n-\"\tldr\tq18, [%3, #16]\\n\"\n+\"\tldr\tq18, [%3, #32]\\n\"\n \"\tb\t3f\\n\"\n \"\tldp\tq16, q17, [%3]\\n\"\t/* Q2 */\n \"\tb\t2f\\n\"\n@@ -357,7 +381,11 @@ extend_hfa_type (void *dest, void *src, int h)\n     : \"r\"(f * 12), \"r\"(dest), \"r\"(src)\n     : \"memory\", \"v16\", \"v17\", \"v18\", \"v19\");\n }\n+#endif\n \n+#if defined(_MSC_VER)\n+void* compress_hfa_type (void *dest, void *src, int h);\n+#else\n static void *\n compress_hfa_type (void *dest, void *reg, int h)\n {\n@@ -426,6 +454,7 @@ compress_hfa_type (void *dest, void *reg, int h)\n     }\n   return dest;\n }\n+#endif\n \n /* Either allocate an appropriate register for the argument type, or if\n    none are available, allocate a stack slot and return a pointer\n@@ -443,7 +472,7 @@ allocate_int_to_reg_or_stack (struct call_context *context,\n   return allocate_to_stack (state, stack, size, size);\n }\n \n-ffi_status\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep (ffi_cif *cif)\n {\n   ffi_type *rtype = cif->rtype;\n@@ -517,7 +546,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n       }\n \n   /* Round the stack up to a multiple of the stack alignment requirement. */\n-  cif->bytes = ALIGN(bytes, 16);\n+  cif->bytes = (unsigned) FFI_ALIGN(bytes, 16);\n   cif->flags = flags;\n #if defined (__APPLE__)\n   cif->aarch64_nfixedargs = 0;\n@@ -528,14 +557,22 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n #if defined (__APPLE__)\n /* Perform Apple-specific cif processing for variadic calls */\n-ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n-\t\t\t\t    unsigned int nfixedargs,\n-\t\t\t\t    unsigned int ntotalargs)\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,\n+\t\t\t unsigned int ntotalargs)\n {\n   ffi_status status = ffi_prep_cif_machdep (cif);\n   cif->aarch64_nfixedargs = nfixedargs;\n   return status;\n }\n+#else\n+ffi_status FFI_HIDDEN\n+ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs)\n+{\n+  ffi_status status = ffi_prep_cif_machdep (cif);\n+  cif->flags |= AARCH64_FLAG_VARARG;\n+  return status;\n+}\n #endif /* __APPLE__ */\n \n extern void ffi_call_SYSV (struct call_context *context, void *frame,\n@@ -552,14 +589,20 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n   void *stack, *frame, *rvalue;\n   struct arg_state state;\n   size_t stack_bytes, rtype_size, rsize;\n-  int i, nargs, flags;\n+  int i, nargs, flags, isvariadic = 0;\n   ffi_type *rtype;\n \n   flags = cif->flags;\n   rtype = cif->rtype;\n   rtype_size = rtype->size;\n   stack_bytes = cif->bytes;\n \n+  if (flags & AARCH64_FLAG_VARARG)\n+  {\n+    isvariadic = 1;\n+    flags &= ~AARCH64_FLAG_VARARG;\n+  }\n+\n   /* If the target function returns a structure via hidden pointer,\n      then we cannot allow a null rvalue.  Otherwise, mash a null\n      rvalue to void return type.  */\n@@ -574,11 +617,12 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n   else if (flags & AARCH64_RET_NEED_COPY)\n     rsize = 16;\n \n-  /* Allocate consectutive stack for everything we'll need.  */\n-  context = alloca (sizeof(struct call_context) + stack_bytes + 32 + rsize);\n+  /* Allocate consectutive stack for everything we'll need.\n+     The frame uses 40 bytes for: lr, fp, rvalue, flags, sp */\n+  context = alloca (sizeof(struct call_context) + stack_bytes + 40 + rsize);\n   stack = context + 1;\n-  frame = stack + stack_bytes;\n-  rvalue = (rsize ? frame + 32 : orig_rvalue);\n+  frame = (void*)((uintptr_t)stack + (uintptr_t)stack_bytes);\n+  rvalue = (rsize ? (void*)((uintptr_t)frame + 40) : orig_rvalue);\n \n   arg_init (&state);\n   for (i = 0, nargs = cif->nargs; i < nargs; i++)\n@@ -639,16 +683,31 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n \t    h = is_vfp_type (ty);\n \t    if (h)\n \t      {\n-\t\tint elems = 4 - (h & 3);\n-\t        if (state.nsrn + elems <= N_V_ARG_REG)\n-\t\t  {\n-\t\t    dest = &context->v[state.nsrn];\n-\t\t    state.nsrn += elems;\n-\t\t    extend_hfa_type (dest, a, h);\n-\t\t    break;\n-\t\t  }\n-\t\tstate.nsrn = N_V_ARG_REG;\n-\t\tdest = allocate_to_stack (&state, stack, ty->alignment, s);\n+              int elems = 4 - (h & 3);\n+              if (cif->abi == FFI_WIN64 && isvariadic)\n+              {\n+                if (state.ngrn + elems <= N_X_ARG_REG)\n+                {\n+                  dest = &context->x[state.ngrn];\n+                  state.ngrn += elems;\n+                  extend_hfa_type(dest, a, h);\n+                  break;\n+                }\n+                state.nsrn = N_X_ARG_REG;\n+                dest = allocate_to_stack(&state, stack, ty->alignment, s);\n+              }\n+              else\n+              {\n+                if (state.nsrn + elems <= N_V_ARG_REG)\n+                {\n+                  dest = &context->v[state.nsrn];\n+                  state.nsrn += elems;\n+                  extend_hfa_type (dest, a, h);\n+                  break;\n+                }\n+                state.nsrn = N_V_ARG_REG;\n+                dest = allocate_to_stack (&state, stack, ty->alignment, s);\n+              }\n \t      }\n \t    else if (s > 16)\n \t      {\n@@ -657,6 +716,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n \t\t   the argument is replaced by a pointer to the copy.  */\n \t\ta = &avalue[i];\n \t\tt = FFI_TYPE_POINTER;\n+\t\ts = sizeof (void *);\n \t\tgoto do_pointer;\n \t      }\n \t    else\n@@ -669,7 +729,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *orig_rvalue,\n \t\t       X registers, then the argument is copied into\n \t\t       consecutive X registers.  */\n \t\t    dest = &context->x[state.ngrn];\n-\t\t    state.ngrn += n;\n+                    state.ngrn += (unsigned int)n;\n \t\t  }\n \t\telse\n \t\t  {\n@@ -711,6 +771,8 @@ ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n   ffi_call_int (cif, fn, rvalue, avalue, NULL);\n }\n \n+#if FFI_CLOSURES\n+\n #ifdef FFI_GO_CLOSURES\n void\n ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n@@ -724,239 +786,9 @@ ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n \n extern void ffi_closure_SYSV (void) FFI_HIDDEN;\n extern void ffi_closure_SYSV_V (void) FFI_HIDDEN;\n-\n-#if FFI_EXEC_TRAMPOLINE_TABLE\n-\n-#include <mach/mach.h>\n-#include <pthread.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-extern void *ffi_closure_trampoline_table_page;\n-\n-typedef struct ffi_trampoline_table ffi_trampoline_table;\n-typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n-\n-struct ffi_trampoline_table\n-{\n-  /* contiguous writable and executable pages */\n-  vm_address_t config_page;\n-  vm_address_t trampoline_page;\n-\n-  /* free list tracking */\n-  uint16_t free_count;\n-  ffi_trampoline_table_entry *free_list;\n-  ffi_trampoline_table_entry *free_list_pool;\n-\n-  ffi_trampoline_table *prev;\n-  ffi_trampoline_table *next;\n-};\n-\n-struct ffi_trampoline_table_entry\n-{\n-  void *(*trampoline) ();\n-  ffi_trampoline_table_entry *next;\n-};\n-\n-/* The trampoline configuration is placed a page prior to the trampoline's entry point */\n-#define FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc) ((void **) (((uint8_t *) codeloc) - PAGE_SIZE));\n-\n-/* Total number of trampolines that fit in one trampoline table */\n-#define FFI_TRAMPOLINE_COUNT (PAGE_SIZE / FFI_TRAMPOLINE_SIZE)\n-\n-static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;\n-static ffi_trampoline_table *ffi_trampoline_tables = NULL;\n-\n-static ffi_trampoline_table *\n-ffi_trampoline_table_alloc ()\n-{\n-  ffi_trampoline_table *table = NULL;\n-\n-  /* Loop until we can allocate two contiguous pages */\n-  while (table == NULL)\n-    {\n-      vm_address_t config_page = 0x0;\n-      kern_return_t kt;\n-\n-      /* Try to allocate two pages */\n-      kt =\n-\tvm_allocate (mach_task_self (), &config_page, PAGE_SIZE * 2,\n-\t\t     VM_FLAGS_ANYWHERE);\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  fprintf (stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt,\n-\t\t   __FILE__, __LINE__);\n-\t  break;\n-\t}\n-\n-      /* Now drop the second half of the allocation to make room for the trampoline table */\n-      vm_address_t trampoline_page = config_page + PAGE_SIZE;\n-      kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  fprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t   __FILE__, __LINE__);\n-\t  break;\n-\t}\n-\n-      /* Remap the trampoline table to directly follow the config page */\n-      vm_prot_t cur_prot;\n-      vm_prot_t max_prot;\n-\n-      kt =\n-\tvm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE,\n-\t\t  mach_task_self (),\n-\t\t  (vm_address_t) & ffi_closure_trampoline_table_page, FALSE,\n-\t\t  &cur_prot, &max_prot, VM_INHERIT_SHARE);\n-\n-      /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  /* Log unexpected failures */\n-\t  if (kt != KERN_NO_SPACE)\n-\t    {\n-\t      fprintf (stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt,\n-\t\t       __FILE__, __LINE__);\n-\t    }\n-\n-\t  vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n-\t  continue;\n-\t}\n-\n-      /* We have valid trampoline and config pages */\n-      table = calloc (1, sizeof (ffi_trampoline_table));\n-      table->free_count = FFI_TRAMPOLINE_COUNT;\n-      table->config_page = config_page;\n-      table->trampoline_page = trampoline_page;\n-\n-      /* Create and initialize the free list */\n-      table->free_list_pool =\n-\tcalloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));\n-\n-      uint16_t i;\n-      for (i = 0; i < table->free_count; i++)\n-\t{\n-\t  ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n-\t  entry->trampoline =\n-\t    (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n-\n-\t  if (i < table->free_count - 1)\n-\t    entry->next = &table->free_list_pool[i + 1];\n-\t}\n-\n-      table->free_list = table->free_list_pool;\n-    }\n-\n-  return table;\n-}\n-\n-void *\n-ffi_closure_alloc (size_t size, void **code)\n-{\n-  /* Create the closure */\n-  ffi_closure *closure = malloc (size);\n-  if (closure == NULL)\n-    return NULL;\n-\n-  pthread_mutex_lock (&ffi_trampoline_lock);\n-\n-  /* Check for an active trampoline table with available entries. */\n-  ffi_trampoline_table *table = ffi_trampoline_tables;\n-  if (table == NULL || table->free_list == NULL)\n-    {\n-      table = ffi_trampoline_table_alloc ();\n-      if (table == NULL)\n-\t{\n-\t  free (closure);\n-\t  return NULL;\n-\t}\n-\n-      /* Insert the new table at the top of the list */\n-      table->next = ffi_trampoline_tables;\n-      if (table->next != NULL)\n-\ttable->next->prev = table;\n-\n-      ffi_trampoline_tables = table;\n-    }\n-\n-  /* Claim the free entry */\n-  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n-  ffi_trampoline_tables->free_list = entry->next;\n-  ffi_trampoline_tables->free_count--;\n-  entry->next = NULL;\n-\n-  pthread_mutex_unlock (&ffi_trampoline_lock);\n-\n-  /* Initialize the return values */\n-  *code = entry->trampoline;\n-  closure->trampoline_table = table;\n-  closure->trampoline_table_entry = entry;\n-\n-  return closure;\n-}\n-\n-void\n-ffi_closure_free (void *ptr)\n-{\n-  ffi_closure *closure = ptr;\n-\n-  pthread_mutex_lock (&ffi_trampoline_lock);\n-\n-  /* Fetch the table and entry references */\n-  ffi_trampoline_table *table = closure->trampoline_table;\n-  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;\n-\n-  /* Return the entry to the free list */\n-  entry->next = table->free_list;\n-  table->free_list = entry;\n-  table->free_count++;\n-\n-  /* If all trampolines within this table are free, and at least one other table exists, deallocate\n-   * the table */\n-  if (table->free_count == FFI_TRAMPOLINE_COUNT\n-      && ffi_trampoline_tables != table)\n-    {\n-      /* Remove from the list */\n-      if (table->prev != NULL)\n-\ttable->prev->next = table->next;\n-\n-      if (table->next != NULL)\n-\ttable->next->prev = table->prev;\n-\n-      /* Deallocate pages */\n-      kern_return_t kt;\n-      kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t __FILE__, __LINE__);\n-\n-      kt =\n-\tvm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t __FILE__, __LINE__);\n-\n-      /* Deallocate free list */\n-      free (table->free_list_pool);\n-      free (table);\n-    }\n-  else if (ffi_trampoline_tables != table)\n-    {\n-      /* Otherwise, bump this table to the top of the list */\n-      table->prev = NULL;\n-      table->next = ffi_trampoline_tables;\n-      if (ffi_trampoline_tables != NULL)\n-\tffi_trampoline_tables->prev = table;\n-\n-      ffi_trampoline_tables = table;\n-    }\n-\n-  pthread_mutex_unlock (&ffi_trampoline_lock);\n-\n-  /* Free the closure */\n-  free (closure);\n-}\n-\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+extern void ffi_closure_SYSV_alt (void) FFI_HIDDEN;\n+extern void ffi_closure_SYSV_V_alt (void) FFI_HIDDEN;\n #endif\n \n ffi_status\n@@ -966,7 +798,7 @@ ffi_prep_closure_loc (ffi_closure *closure,\n                       void *user_data,\n                       void *codeloc)\n {\n-  if (cif->abi != FFI_SYSV)\n+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)\n     return FFI_BAD_ABI;\n \n   void (*start)(void);\n@@ -977,22 +809,52 @@ ffi_prep_closure_loc (ffi_closure *closure,\n     start = ffi_closure_SYSV;\n \n #if FFI_EXEC_TRAMPOLINE_TABLE\n-  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG (codeloc);\n+#ifdef __MACH__\n+#ifdef HAVE_PTRAUTH\n+  codeloc = ptrauth_auth_data(codeloc, ptrauth_key_function_pointer, 0);\n+#endif\n+  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n   config[0] = closure;\n   config[1] = start;\n+#endif\n #else\n   static const unsigned char trampoline[16] = {\n     0x90, 0x00, 0x00, 0x58,\t/* ldr\tx16, tramp+16\t*/\n     0xf1, 0xff, 0xff, 0x10,\t/* adr\tx17, tramp+0\t*/\n     0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t\t*/\n   };\n   char *tramp = closure->tramp;\n-  \n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      /* Initialize the static trampoline's parameters. */\n+      if (start == ffi_closure_SYSV_V)\n+          start = ffi_closure_SYSV_V_alt;\n+      else\n+          start = ffi_closure_SYSV_alt;\n+      ffi_tramp_set_parms (closure->ftramp, start, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  /* Initialize the dynamic trampoline. */\n   memcpy (tramp, trampoline, sizeof(trampoline));\n   \n   *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n \n   ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n+\n+  /* Also flush the cache for code mapping.  */\n+#ifdef _WIN32\n+  // Not using dlmalloc.c for Windows ARM64 builds\n+  // so calling ffi_data_to_code_pointer() isn't necessary\n+  unsigned char *tramp_code = tramp;\n+  #else\n+  unsigned char *tramp_code = ffi_data_to_code_pointer (tramp);\n+  #endif\n+  ffi_clear_cache (tramp_code, tramp_code + FFI_TRAMPOLINE_SIZE);\n+out:\n #endif\n \n   closure->cif = cif;\n@@ -1012,7 +874,7 @@ ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif* cif,\n {\n   void (*start)(void);\n \n-  if (cif->abi != FFI_SYSV)\n+  if (cif->abi != FFI_SYSV && cif->abi != FFI_WIN64)\n     return FFI_BAD_ABI;\n \n   if (cif->flags & AARCH64_FLAG_ARG_V)\n@@ -1052,11 +914,18 @@ ffi_closure_SYSV_inner (ffi_cif *cif,\n \t\t\tvoid *stack, void *rvalue, void *struct_rvalue)\n {\n   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n-  int i, h, nargs, flags;\n+  int i, h, nargs, flags, isvariadic = 0;\n   struct arg_state state;\n \n   arg_init (&state);\n \n+  flags = cif->flags;\n+  if (flags & AARCH64_FLAG_VARARG)\n+  {\n+    isvariadic = 1;\n+    flags &= ~AARCH64_FLAG_VARARG;\n+  }\n+\n   for (i = 0, nargs = cif->nargs; i < nargs; i++)\n     {\n       ffi_type *ty = cif->arg_types[i];\n@@ -1091,62 +960,105 @@ ffi_closure_SYSV_inner (ffi_cif *cif,\n \t  if (h)\n \t    {\n \t      n = 4 - (h & 3);\n-\t      if (state.nsrn + n <= N_V_ARG_REG)\n-\t\t{\n-\t\t  void *reg = &context->v[state.nsrn];\n-\t\t  state.nsrn += n;\n-\n-\t\t  /* Eeek! We need a pointer to the structure, however the\n-\t\t     homogeneous float elements are being passed in individual\n-\t\t     registers, therefore for float and double the structure\n-\t\t     is not represented as a contiguous sequence of bytes in\n-\t\t     our saved register context.  We don't need the original\n-\t\t     contents of the register storage, so we reformat the\n-\t\t     structure into the same memory.  */\n-\t\t  avalue[i] = compress_hfa_type (reg, reg, h);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  state.nsrn = N_V_ARG_REG;\n-\t\t  avalue[i] = allocate_to_stack (&state, stack,\n-\t\t\t\t\t\t ty->alignment, s);\n-\t\t}\n-\t    }\n-\t  else if (s > 16)\n-\t    {\n-\t      /* Replace Composite type of size greater than 16 with a\n-\t\t pointer.  */\n-\t      avalue[i] = *(void **)\n-\t\tallocate_int_to_reg_or_stack (context, &state, stack,\n-\t\t\t\t\t      sizeof (void *));\n-\t    }\n-\t  else\n-\t    {\n-\t      n = (s + 7) / 8;\n-\t      if (state.ngrn + n <= N_X_ARG_REG)\n-\t\t{\n-\t\t  avalue[i] = &context->x[state.ngrn];\n-\t\t  state.ngrn += n;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  state.ngrn = N_X_ARG_REG;\n-\t\t  avalue[i] = allocate_to_stack (&state, stack,\n-\t\t\t\t\t\t ty->alignment, s);\n-\t\t}\n-\t    }\n-\t  break;\n+              if (cif->abi == FFI_WIN64 && isvariadic)\n+                {\n+                  if (state.ngrn + n <= N_X_ARG_REG)\n+                    {\n+                      void *reg = &context->x[state.ngrn];\n+                      state.ngrn += (unsigned int)n;\n+    \n+                      /* Eeek! We need a pointer to the structure, however the\n+                       homogeneous float elements are being passed in individual\n+                       registers, therefore for float and double the structure\n+                       is not represented as a contiguous sequence of bytes in\n+                       our saved register context.  We don't need the original\n+                       contents of the register storage, so we reformat the\n+                       structure into the same memory.  */\n+                      avalue[i] = compress_hfa_type(reg, reg, h);\n+                    }\n+                  else\n+                    {\n+                      state.ngrn = N_X_ARG_REG;\n+                      state.nsrn = N_V_ARG_REG;\n+                      avalue[i] = allocate_to_stack(&state, stack,\n+                             ty->alignment, s);\n+                    }\n+                }\n+              else\n+                {\n+                  if (state.nsrn + n <= N_V_ARG_REG)\n+                    {\n+                      void *reg = &context->v[state.nsrn];\n+                      state.nsrn += (unsigned int)n;\n+                      avalue[i] = compress_hfa_type(reg, reg, h);\n+                    }\n+                  else\n+                    {\n+                      state.nsrn = N_V_ARG_REG;\n+                      avalue[i] = allocate_to_stack(&state, stack,\n+                                                   ty->alignment, s);\n+                    }\n+                }\n+            }\n+          else if (s > 16)\n+            {\n+              /* Replace Composite type of size greater than 16 with a\n+                  pointer.  */\n+              avalue[i] = *(void **)\n+              allocate_int_to_reg_or_stack (context, &state, stack,\n+                                         sizeof (void *));\n+            }\n+          else\n+            {\n+              n = (s + 7) / 8;\n+              if (state.ngrn + n <= N_X_ARG_REG)\n+                {\n+                  avalue[i] = &context->x[state.ngrn];\n+                  state.ngrn += (unsigned int)n;\n+                }\n+              else\n+                {\n+                  state.ngrn = N_X_ARG_REG;\n+                  avalue[i] = allocate_to_stack(&state, stack,\n+                                           ty->alignment, s);\n+                }\n+            }\n+          break;\n+\n+        default:\n+          abort();\n+      }\n \n-\tdefault:\n-\t  abort();\n+#if defined (__APPLE__)\n+      if (i + 1 == cif->aarch64_nfixedargs)\n+\t{\n+\t  state.ngrn = N_X_ARG_REG;\n+\t  state.nsrn = N_V_ARG_REG;\n+\t  state.allocating_variadic = 1;\n \t}\n+#endif\n     }\n \n-  flags = cif->flags;\n   if (flags & AARCH64_RET_IN_MEM)\n     rvalue = struct_rvalue;\n \n   fun (cif, rvalue, avalue, user_data);\n \n   return flags;\n }\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void *\n+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)\n+{\n+  extern void *trampoline_code_table;\n+\n+  *tramp_size = AARCH64_TRAMP_SIZE;\n+  *map_size = AARCH64_TRAMP_MAP_SIZE;\n+  return &trampoline_code_table;\n+}\n+#endif\n+\n+#endif /* FFI_CLOSURES */\n+\n+#endif /* (__aarch64__) || defined(__arm64__)|| defined (_M_ARM64)*/"}, {"sha": "d5622e133625cac90c334476b41d7b6b1aee6f88", "filename": "libffi/src/aarch64/ffitarget.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -32,6 +32,10 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n #define FFI_SIZEOF_JAVA_RAW  4\n typedef unsigned long long ffi_arg;\n typedef signed long long ffi_sarg;\n+#elif defined(_WIN32)\n+#define FFI_SIZEOF_ARG 8\n+typedef unsigned long long ffi_arg;\n+typedef signed long long ffi_sarg;\n #else\n typedef unsigned long ffi_arg;\n typedef signed long ffi_sarg;\n@@ -41,34 +45,53 @@ typedef enum ffi_abi\n   {\n     FFI_FIRST_ABI = 0,\n     FFI_SYSV,\n+    FFI_WIN64,\n     FFI_LAST_ABI,\n+#if defined(_WIN32)\n+    FFI_DEFAULT_ABI = FFI_WIN64\n+#else\n     FFI_DEFAULT_ABI = FFI_SYSV\n+#endif\n   } ffi_abi;\n #endif\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n-#if defined (__APPLE__)\n-#define FFI_TRAMPOLINE_SIZE 20\n+#define FFI_NATIVE_RAW_API 0\n+\n+#if defined (FFI_EXEC_TRAMPOLINE_TABLE) && FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#ifdef __MACH__\n+#define FFI_TRAMPOLINE_SIZE 16\n #define FFI_TRAMPOLINE_CLOSURE_OFFSET 16\n+#else\n+#error \"No trampoline table implementation\"\n+#endif\n+\n #else\n #define FFI_TRAMPOLINE_SIZE 24\n #define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE\n #endif\n-#define FFI_NATIVE_RAW_API 0\n+\n+#ifdef _WIN32\n+#define FFI_EXTRA_CIF_FIELDS unsigned is_variadic\n+#endif\n+#define FFI_TARGET_SPECIFIC_VARIADIC\n \n /* ---- Internal ---- */\n \n #if defined (__APPLE__)\n-#define FFI_TARGET_SPECIFIC_VARIADIC\n #define FFI_EXTRA_CIF_FIELDS unsigned aarch64_nfixedargs\n-#else\n-/* iOS reserves x18 for the system.  Disable Go closures until\n+#elif !defined(_WIN32)\n+/* iOS and Windows reserve x18 for the system.  Disable Go closures until\n    a new static chain is chosen.  */\n #define FFI_GO_CLOSURES 1\n #endif\n \n+#ifndef _WIN32\n+/* No complex type on Windows */\n #define FFI_TARGET_HAS_COMPLEX_TYPE\n+#endif\n \n #endif"}, {"sha": "b5d102b4add2c5948a9309b23f79977e52458d8a", "filename": "libffi/src/aarch64/internal.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Finternal.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -61,7 +61,40 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n \n #define AARCH64_FLAG_ARG_V_BIT\t7\n #define AARCH64_FLAG_ARG_V\t(1 << AARCH64_FLAG_ARG_V_BIT)\n+#define AARCH64_FLAG_VARARG\t(1 << 8)\n \n #define N_X_ARG_REG\t\t8\n #define N_V_ARG_REG\t\t8\n #define CALL_CONTEXT_SIZE\t(N_V_ARG_REG * 16 + N_X_ARG_REG * 8)\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+/*\n+ * For the trampoline code table mapping, a mapping size of 16K is chosen to\n+ * cover the base page sizes of 4K and 16K.\n+ */\n+#define AARCH64_TRAMP_MAP_SHIFT\t14\n+#define AARCH64_TRAMP_MAP_SIZE\t(1 << AARCH64_TRAMP_MAP_SHIFT)\n+#define AARCH64_TRAMP_SIZE\t32\n+\n+#endif\n+\n+/* Helpers for writing assembly compatible with arm ptr auth */\n+#ifdef LIBFFI_ASM\n+\n+#ifdef HAVE_PTRAUTH\n+#define SIGN_LR pacibsp\n+#define SIGN_LR_WITH_REG(x) pacib lr, x\n+#define AUTH_LR_AND_RET retab\n+#define AUTH_LR_WITH_REG(x) autib lr, x\n+#define BRANCH_AND_LINK_TO_REG blraaz\n+#define BRANCH_TO_REG braaz\n+#else\n+#define SIGN_LR\n+#define SIGN_LR_WITH_REG(x)\n+#define AUTH_LR_AND_RET ret\n+#define AUTH_LR_WITH_REG(x)\n+#define BRANCH_AND_LINK_TO_REG blr\n+#define BRANCH_TO_REG br\n+#endif\n+\n+#endif"}, {"sha": "eeaf3f85140f4877e2c28d043c11491bdadb0782", "filename": "libffi/src/aarch64/sysv.S", "status": "modified", "additions": 146, "deletions": 43, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -19,6 +19,7 @@ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n \n+#if defined(__aarch64__) || defined(__arm64__)\n #define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n@@ -77,9 +78,22 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n \n \tcfi_startproc\n CNAME(ffi_call_SYSV):\n+\t/* Sign the lr with x1 since that is where it will be stored */\n+\tSIGN_LR_WITH_REG(x1)\n+\n \t/* Use a stack frame allocated by our caller.  */\n-\tcfi_def_cfa(x1, 32);\n+#if defined(HAVE_PTRAUTH) && defined(__APPLE__)\n+\t/* darwin's libunwind assumes that the cfa is the sp and that's the data\n+\t * used to sign the lr.  In order to allow unwinding through this\n+\t * function it is necessary to point the cfa at the signing register.\n+\t */\n+\tcfi_def_cfa(x1, 0);\n+#else\n+\tcfi_def_cfa(x1, 40);\n+#endif\n \tstp\tx29, x30, [x1]\n+\tmov\tx9, sp\n+\tstr\tx9, [x1, #32]\n \tmov\tx29, x1\n \tmov\tsp, x0\n \tcfi_def_cfa_register(x29)\n@@ -110,13 +124,15 @@ CNAME(ffi_call_SYSV):\n \t/* Deallocate the context, leaving the stacked arguments.  */\n \tadd\tsp, sp, #CALL_CONTEXT_SIZE\n \n-\tblr     x9\t\t\t/* call fn */\n+\tBRANCH_AND_LINK_TO_REG     x9\t\t\t/* call fn */\n \n \tldp\tx3, x4, [x29, #16]\t/* reload rvalue and flags */\n \n \t/* Partially deconstruct the stack frame.  */\n-\tmov     sp, x29\n+\tldr\tx9, [x29, #32]\n+\tmov\tsp, x9\n \tcfi_def_cfa_register (sp)\n+\tmov\tx2, x29\t\t\t/* Preserve for auth */\n \tldp     x29, x30, [x29]\n \n \t/* Save the return value as directed.  */\n@@ -130,80 +146,87 @@ CNAME(ffi_call_SYSV):\n \t   and therefore we want to extend to 64 bits; these types\n \t   have two consecutive entries allocated for them.  */\n \t.align\t4\n-0:\tret\t\t\t\t/* VOID */\n+0:\tb 99f\t\t\t\t/* VOID */\n \tnop\n 1:\tstr\tx0, [x3]\t\t/* INT64 */\n-\tret\n+\tb 99f\n 2:\tstp\tx0, x1, [x3]\t\t/* INT128 */\n-\tret\n+\tb 99f\n 3:\tbrk\t#1000\t\t\t/* UNUSED */\n-\tret\n+\tb 99f\n 4:\tbrk\t#1000\t\t\t/* UNUSED */\n-\tret\n+\tb 99f\n 5:\tbrk\t#1000\t\t\t/* UNUSED */\n-\tret\n+\tb 99f\n 6:\tbrk\t#1000\t\t\t/* UNUSED */\n-\tret\n+\tb 99f\n 7:\tbrk\t#1000\t\t\t/* UNUSED */\n-\tret\n+\tb 99f\n 8:\tst4\t{ v0.s, v1.s, v2.s, v3.s }[0], [x3]\t/* S4 */\n-\tret\n+\tb 99f\n 9:\tst3\t{ v0.s, v1.s, v2.s }[0], [x3]\t/* S3 */\n-\tret\n+\tb 99f\n 10:\tstp\ts0, s1, [x3]\t\t/* S2 */\n-\tret\n+\tb 99f\n 11:\tstr\ts0, [x3]\t\t/* S1 */\n-\tret\n+\tb 99f\n 12:\tst4\t{ v0.d, v1.d, v2.d, v3.d }[0], [x3]\t/* D4 */\n-\tret\n+\tb 99f\n 13:\tst3\t{ v0.d, v1.d, v2.d }[0], [x3]\t/* D3 */\n-\tret\n+\tb 99f\n 14:\tstp\td0, d1, [x3]\t\t/* D2 */\n-\tret\n+\tb 99f\n 15:\tstr\td0, [x3]\t\t/* D1 */\n-\tret\n+\tb 99f\n 16:\tstr\tq3, [x3, #48]\t\t/* Q4 */\n \tnop\n 17:\tstr\tq2, [x3, #32]\t\t/* Q3 */\n \tnop\n 18:\tstp\tq0, q1, [x3]\t\t/* Q2 */\n-\tret\n+\tb 99f\n 19:\tstr\tq0, [x3]\t\t/* Q1 */\n-\tret\n+\tb 99f\n 20:\tuxtb\tw0, w0\t\t\t/* UINT8 */\n \tstr\tx0, [x3]\n-21:\tret\t\t\t\t/* reserved */\n+21:\tb 99f\t\t\t\t/* reserved */\n \tnop\n 22:\tuxth\tw0, w0\t\t\t/* UINT16 */\n \tstr\tx0, [x3]\n-23:\tret\t\t\t\t/* reserved */\n+23:\tb 99f\t\t\t\t/* reserved */\n \tnop\n 24:\tmov\tw0, w0\t\t\t/* UINT32 */\n \tstr\tx0, [x3]\n-25:\tret\t\t\t\t/* reserved */\n+25:\tb 99f\t\t\t\t/* reserved */\n \tnop\n 26:\tsxtb\tx0, w0\t\t\t/* SINT8 */\n \tstr\tx0, [x3]\n-27:\tret\t\t\t\t/* reserved */\n+27:\tb 99f\t\t\t\t/* reserved */\n \tnop\n 28:\tsxth\tx0, w0\t\t\t/* SINT16 */\n \tstr\tx0, [x3]\n-29:\tret\t\t\t\t/* reserved */\n+29:\tb 99f\t\t\t\t/* reserved */\n \tnop\n 30:\tsxtw\tx0, w0\t\t\t/* SINT32 */\n \tstr\tx0, [x3]\n-31:\tret\t\t\t\t/* reserved */\n+31:\tb 99f\t\t\t\t/* reserved */\n \tnop\n \n+\t/* Return now that result has been populated. */\n+99:\n+\tAUTH_LR_WITH_REG(x2)\n+\tret\n+\n \tcfi_endproc\n \n \t.globl\tCNAME(ffi_call_SYSV)\n+\tFFI_HIDDEN(CNAME(ffi_call_SYSV))\n #ifdef __ELF__\n \t.type\tCNAME(ffi_call_SYSV), #function\n-\t.hidden\tCNAME(ffi_call_SYSV)\n \t.size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)\n #endif\n \n+#if FFI_CLOSURES\n+\n /* ffi_closure_SYSV\n \n    Closure invocation glue. This is the low level code invoked directly by\n@@ -223,6 +246,7 @@ CNAME(ffi_call_SYSV):\n \t.align 4\n CNAME(ffi_closure_SYSV_V):\n \tcfi_startproc\n+\tSIGN_LR\n \tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n \tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n \tcfi_rel_offset (x29, 0)\n@@ -237,15 +261,16 @@ CNAME(ffi_closure_SYSV_V):\n \tcfi_endproc\n \n \t.globl\tCNAME(ffi_closure_SYSV_V)\n+\tFFI_HIDDEN(CNAME(ffi_closure_SYSV_V))\n #ifdef __ELF__\n \t.type\tCNAME(ffi_closure_SYSV_V), #function\n-\t.hidden\tCNAME(ffi_closure_SYSV_V)\n \t.size\tCNAME(ffi_closure_SYSV_V), . - CNAME(ffi_closure_SYSV_V)\n #endif\n \n \t.align\t4\n \tcfi_startproc\n CNAME(ffi_closure_SYSV):\n+\tSIGN_LR\n \tstp     x29, x30, [sp, #-ffi_closure_SYSV_FS]!\n \tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n \tcfi_rel_offset (x29, 0)\n@@ -262,7 +287,9 @@ CNAME(ffi_closure_SYSV):\n \t/* Load ffi_closure_inner arguments.  */\n \tldp\tPTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t/* load cif, fn */\n \tldr\tPTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]\t/* load user_data */\n+#ifdef FFI_GO_CLOSURES\n .Ldo_closure:\n+#endif\n \tadd\tx3, sp, #16\t\t\t\t/* load context */\n \tadd\tx4, sp, #ffi_closure_SYSV_FS\t\t/* load stack */\n \tadd\tx5, sp, #16+CALL_CONTEXT_SIZE\t\t/* load rvalue */\n@@ -296,7 +323,7 @@ CNAME(ffi_closure_SYSV):\n \tnop\n 8:\tldr\ts3, [x3, #12]\t\t/* S4 */\n \tnop\n-9:\tldr\ts2, [x2, #8]\t\t/* S3 */\n+9:\tldr\ts2, [x3, #8]\t\t/* S3 */\n \tnop\n 10:\tldp\ts0, s1, [x3]\t\t/* S2 */\n \tb\t99f\n@@ -345,35 +372,109 @@ CNAME(ffi_closure_SYSV):\n \tcfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)\n \tcfi_restore (x29)\n \tcfi_restore (x30)\n-\tret\n+\tAUTH_LR_AND_RET\n \tcfi_endproc\n \n \t.globl\tCNAME(ffi_closure_SYSV)\n+\tFFI_HIDDEN(CNAME(ffi_closure_SYSV))\n #ifdef __ELF__\n \t.type\tCNAME(ffi_closure_SYSV), #function\n-\t.hidden\tCNAME(ffi_closure_SYSV)\n \t.size\tCNAME(ffi_closure_SYSV), . - CNAME(ffi_closure_SYSV)\n #endif\n \n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+\t.align 4\n+CNAME(ffi_closure_SYSV_V_alt):\n+\t/* See the comments above trampoline_code_table. */\n+\tldr\tx17, [sp, #8]\t\t\t/* Load closure in x17 */\n+\tadd\tsp, sp, #16\t\t\t/* Restore the stack */\n+\tb\tCNAME(ffi_closure_SYSV_V)\n+\n+\t.globl\tCNAME(ffi_closure_SYSV_V_alt)\n+\tFFI_HIDDEN(CNAME(ffi_closure_SYSV_V_alt))\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_closure_SYSV_V_alt), #function\n+\t.size\tCNAME(ffi_closure_SYSV_V_alt), . - CNAME(ffi_closure_SYSV_V_alt)\n+#endif\n+\n+\t.align 4\n+CNAME(ffi_closure_SYSV_alt):\n+\t/* See the comments above trampoline_code_table. */\n+\tldr\tx17, [sp, #8]\t\t\t/* Load closure in x17 */\n+\tadd\tsp, sp, #16\t\t\t/* Restore the stack */\n+\tb\tCNAME(ffi_closure_SYSV)\n+\n+\t.globl\tCNAME(ffi_closure_SYSV_alt)\n+\tFFI_HIDDEN(CNAME(ffi_closure_SYSV_alt))\n+#ifdef __ELF__\n+\t.type\tCNAME(ffi_closure_SYSV_alt), #function\n+\t.size\tCNAME(ffi_closure_SYSV_alt), . - CNAME(ffi_closure_SYSV_alt)\n+#endif\n+\n+/*\n+ * Below is the definition of the trampoline code table. Each element in\n+ * the code table is a trampoline.\n+ */\n+/*\n+ * The trampoline uses register x17. It saves the original value of x17 on\n+ * the stack.\n+ *\n+ * The trampoline has two parameters - target code to jump to and data for\n+ * the target code. The trampoline extracts the parameters from its parameter\n+ * block (see tramp_table_map()). The trampoline saves the data address on\n+ * the stack. Finally, it jumps to the target code.\n+ *\n+ * The target code can choose to:\n+ *\n+ * - restore the value of x17\n+ * - load the data address in a register\n+ * - restore the stack pointer to what it was when the trampoline was invoked.\n+ */\n+\t.align\tAARCH64_TRAMP_MAP_SHIFT\n+CNAME(trampoline_code_table):\n+\t.rept\tAARCH64_TRAMP_MAP_SIZE / AARCH64_TRAMP_SIZE\n+\tsub\tsp, sp, #16\t\t/* Make space on the stack */\n+\tstr\tx17, [sp]\t\t/* Save x17 on stack */\n+\tadr\tx17, #16376\t\t/* Get data address */\n+\tldr\tx17, [x17]\t\t/* Copy data into x17 */\n+\tstr\tx17, [sp, #8]\t\t/* Save data on stack */\n+\tadr\tx17, #16372\t\t/* Get code address */\n+\tldr\tx17, [x17]\t\t/* Load code address into x17 */\n+\tbr\tx17\t\t\t/* Jump to code */\n+\t.endr\n+\n+\t.globl CNAME(trampoline_code_table)\n+\tFFI_HIDDEN(CNAME(trampoline_code_table))\n+#ifdef __ELF__\n+\t.type\tCNAME(trampoline_code_table), #function\n+\t.size\tCNAME(trampoline_code_table), . - CNAME(trampoline_code_table)\n+#endif\n+\t.align\tAARCH64_TRAMP_MAP_SHIFT\n+#endif /* FFI_EXEC_STATIC_TRAMP */\n+\n #if FFI_EXEC_TRAMPOLINE_TABLE\n-    .align 12\n+\n+#ifdef __MACH__\n+#include <mach/machine/vm_param.h>\n+    .align PAGE_MAX_SHIFT\n CNAME(ffi_closure_trampoline_table_page):\n-    .rept 16384 / FFI_TRAMPOLINE_SIZE\n-    adr\tx17, -16384\n-    adr\tx16, -16380\n-    ldr x16, [x16]\n-    ldr x17, [x17]\n-    br\tx16\n+    .rept PAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE\n+    adr x16, -PAGE_MAX_SIZE\n+    ldp x17, x16, [x16]\n+    br x16\n+\tnop\t\t/* each entry in the trampoline config page is 2*sizeof(void*) so the trampoline itself cannot be smaller than 16 bytes */\n     .endr\n-    \n+\n     .globl CNAME(ffi_closure_trampoline_table_page)\n+    FFI_HIDDEN(CNAME(ffi_closure_trampoline_table_page))\n     #ifdef __ELF__\n     \t.type\tCNAME(ffi_closure_trampoline_table_page), #function\n-    \t.hidden\tCNAME(ffi_closure_trampoline_table_page)\n     \t.size\tCNAME(ffi_closure_trampoline_table_page), . - CNAME(ffi_closure_trampoline_table_page)\n     #endif\n #endif\n \n+#endif /* FFI_EXEC_TRAMPOLINE_TABLE */\n+\n #ifdef FFI_GO_CLOSURES\n \t.align 4\n CNAME(ffi_go_closure_SYSV_V):\n@@ -392,9 +493,9 @@ CNAME(ffi_go_closure_SYSV_V):\n \tcfi_endproc\n \n \t.globl\tCNAME(ffi_go_closure_SYSV_V)\n+\tFFI_HIDDEN(CNAME(ffi_go_closure_SYSV_V))\n #ifdef __ELF__\n \t.type\tCNAME(ffi_go_closure_SYSV_V), #function\n-\t.hidden\tCNAME(ffi_go_closure_SYSV_V)\n \t.size\tCNAME(ffi_go_closure_SYSV_V), . - CNAME(ffi_go_closure_SYSV_V)\n #endif\n \n@@ -421,12 +522,14 @@ CNAME(ffi_go_closure_SYSV):\n \tcfi_endproc\n \n \t.globl\tCNAME(ffi_go_closure_SYSV)\n+\tFFI_HIDDEN(CNAME(ffi_go_closure_SYSV))\n #ifdef __ELF__\n \t.type\tCNAME(ffi_go_closure_SYSV), #function\n-\t.hidden\tCNAME(ffi_go_closure_SYSV)\n \t.size\tCNAME(ffi_go_closure_SYSV), . - CNAME(ffi_go_closure_SYSV)\n #endif\n #endif /* FFI_GO_CLOSURES */\n+#endif /* FFI_CLOSURES */\n+#endif /* __arm64__ */\n \n #if defined __ELF__ && defined __linux__\n \t.section .note.GNU-stack,\"\",%progbits"}, {"sha": "7fc185b3d8baea96e5a0abee9298c8470150f33a", "filename": "libffi/src/aarch64/win64_armasm.S", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fwin64_armasm.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Faarch64%2Fwin64_armasm.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fwin64_armasm.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,506 @@\n+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#include <ffi_cfi.h>\n+#include \"internal.h\"\n+\n+\tOPT\t2 /*disable listing */\n+/* For some macros to add unwind information */\n+#include \"ksarm64.h\"\n+\tOPT\t1 /*re-enable listing */\n+\n+#define BE(X)\t0\n+#define PTR_REG(n)      x##n\n+#define PTR_SIZE\t8\n+\n+\tIMPORT ffi_closure_SYSV_inner\n+\tEXPORT\tffi_call_SYSV\n+\tEXPORT\tffi_closure_SYSV_V\n+\tEXPORT\tffi_closure_SYSV\n+\tEXPORT\textend_hfa_type\n+\tEXPORT\tcompress_hfa_type\n+#ifdef FFI_GO_CLOSURES\n+\tEXPORT\tffi_go_closure_SYSV_V\n+\tEXPORT\tffi_go_closure_SYSV\n+#endif\n+\n+\tTEXTAREA, ALIGN=8\n+\n+/* ffi_call_SYSV\n+   extern void ffi_call_SYSV (void *stack, void *frame,\n+\t\t\t      void (*fn)(void), void *rvalue,\n+\t\t\t      int flags, void *closure);\n+   Therefore on entry we have:\n+   x0 stack\n+   x1 frame\n+   x2 fn\n+   x3 rvalue\n+   x4 flags\n+   x5 closure\n+*/\n+\n+\tNESTED_ENTRY ffi_call_SYSV_fake\n+\n+\t/* For unwind information, Windows has to store fp and lr  */\n+\tPROLOG_SAVE_REG_PAIR\tx29, x30, #-32!\n+\n+\tALTERNATE_ENTRY ffi_call_SYSV\n+\t/* Use a stack frame allocated by our caller. */\n+\tstp\tx29, x30, [x1]\n+\tmov\tx29, x1\n+\tmov\tsp, x0\n+\n+\tmov\tx9, x2\t\t\t/* save fn */\n+\tmov\tx8, x3\t\t\t/* install structure return */\n+#ifdef FFI_GO_CLOSURES\n+\t/*mov\tx18, x5\t\t\tinstall static chain */\n+#endif\n+\tstp\tx3, x4, [x29, #16]\t/* save rvalue and flags */\n+\t\n+\t/* Load the vector argument passing registers, if necessary.  */\n+\ttbz\tx4, #AARCH64_FLAG_ARG_V_BIT, ffi_call_SYSV_L1\n+\tldp\tq0, q1, [sp, #0]\n+\tldp\tq2, q3, [sp, #32]\n+\tldp\tq4, q5, [sp, #64]\n+\tldp\tq6, q7, [sp, #96]\n+\n+ffi_call_SYSV_L1\n+\t/* Load the core argument passing registers, including\n+\t   the structure return pointer.  */\n+\tldp     x0, x1, [sp, #16*N_V_ARG_REG + 0]\n+\tldp     x2, x3, [sp, #16*N_V_ARG_REG + 16]\n+\tldp     x4, x5, [sp, #16*N_V_ARG_REG + 32]\n+\tldp     x6, x7, [sp, #16*N_V_ARG_REG + 48]\n+\n+\t/* Deallocate the context, leaving the stacked arguments.  */\n+\tadd\tsp, sp, #CALL_CONTEXT_SIZE\t\n+\n+\tblr     x9\t\t\t/* call fn */\n+\n+\tldp\tx3, x4, [x29, #16]\t/* reload rvalue and flags */\n+\n+\t/* Partially deconstruct the stack frame. */\n+\tmov     sp, x29 \n+\tldp     x29, x30, [x29]\n+\n+\t/* Save the return value as directed.  */\n+\tadr\tx5, ffi_call_SYSV_return\n+\tand\tw4, w4, #AARCH64_RET_MASK\n+\tadd\tx5, x5, x4, lsl #3\n+\tbr\tx5\n+\t\n+\t/* Note that each table entry is 2 insns, and thus 8 bytes.\n+\t   For integer data, note that we're storing into ffi_arg\n+\t   and therefore we want to extend to 64 bits; these types\n+\t   have two consecutive entries allocated for them.  */\n+\tALIGN 4\n+ffi_call_SYSV_return\n+\tret\t\t\t\t/* VOID */\n+\tnop\n+\tstr\tx0, [x3]\t\t/* INT64 */\n+\tret\n+\tstp\tx0, x1, [x3]\t\t/* INT128 */\n+\tret\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tret\n+\tst4\t{ v0.s, v1.s, v2.s, v3.s }[0], [x3]\t/* S4 */\n+\tret\n+\tst3\t{ v0.s, v1.s, v2.s }[0], [x3]\t/* S3 */\n+\tret\n+\tstp\ts0, s1, [x3]\t\t/* S2 */\n+\tret\n+\tstr\ts0, [x3]\t\t/* S1 */\n+\tret\n+\tst4\t{ v0.d, v1.d, v2.d, v3.d }[0], [x3]\t/* D4 */\n+\tret\n+\tst3\t{ v0.d, v1.d, v2.d }[0], [x3]\t/* D3 */\n+\tret\n+\tstp\td0, d1, [x3]\t\t/* D2 */\n+\tret\n+\tstr\td0, [x3]\t\t/* D1 */\n+\tret\n+\tstr\tq3, [x3, #48]\t\t/* Q4 */\n+\tnop\n+\tstr\tq2, [x3, #32]\t\t/* Q3 */\n+\tnop\n+\tstp\tq0, q1, [x3]\t\t/* Q2 */\n+\tret\n+\tstr\tq0, [x3]\t\t/* Q1 */\n+\tret\n+\tuxtb\tw0, w0\t\t\t/* UINT8 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\tuxth\tw0, w0\t\t\t/* UINT16 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\tmov\tw0, w0\t\t\t/* UINT32 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\tsxtb\tx0, w0\t\t\t/* SINT8 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\tsxth\tx0, w0\t\t\t/* SINT16 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\tsxtw\tx0, w0\t\t\t/* SINT32 */\n+\tstr\tx0, [x3]\n+\tret\t\t\t\t/* reserved */\n+\tnop\n+\t\n+\t\n+\tNESTED_END ffi_call_SYSV_fake\n+\t\n+\n+/* ffi_closure_SYSV\n+   Closure invocation glue. This is the low level code invoked directly by\n+   the closure trampoline to setup and call a closure.\n+   On entry x17 points to a struct ffi_closure, x16 has been clobbered\n+   all other registers are preserved.\n+   We allocate a call context and save the argument passing registers,\n+   then invoked the generic C ffi_closure_SYSV_inner() function to do all\n+   the real work, on return we load the result passing registers back from\n+   the call context.\n+*/\n+\n+#define ffi_closure_SYSV_FS (8*2 + CALL_CONTEXT_SIZE + 64)\n+\n+\tNESTED_ENTRY\tffi_closure_SYSV_V\n+\tPROLOG_SAVE_REG_PAIR\tx29, x30, #-ffi_closure_SYSV_FS!\n+\n+\t/* Save the argument passing vector registers.  */\n+\tstp\tq0, q1, [sp, #16 + 0]\n+\tstp\tq2, q3, [sp, #16 + 32]\n+\tstp\tq4, q5, [sp, #16 + 64]\n+\tstp\tq6, q7, [sp, #16 + 96]\n+\n+\tb\tffi_closure_SYSV_save_argument\n+\tNESTED_END\tffi_closure_SYSV_V\n+\n+\tNESTED_ENTRY\tffi_closure_SYSV\n+\tPROLOG_SAVE_REG_PAIR\tx29, x30, #-ffi_closure_SYSV_FS!\n+\n+ffi_closure_SYSV_save_argument\n+\t/* Save the argument passing core registers.  */\n+\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+\n+\t/* Load ffi_closure_inner arguments.  */\n+\tldp\tPTR_REG(0), PTR_REG(1), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t/* load cif, fn */\n+\tldr\tPTR_REG(2), [x17, #FFI_TRAMPOLINE_CLOSURE_OFFSET+PTR_SIZE*2]\t/* load user_data */\n+\n+do_closure\n+\tadd\tx3, sp, #16\t\t\t\t\t\t\t/* load context */\n+\tadd\tx4, sp, #ffi_closure_SYSV_FS\t\t/* load stack */\n+\tadd\tx5, sp, #16+CALL_CONTEXT_SIZE\t\t/* load rvalue */\n+\tmov\tx6, x8\t\t\t\t\t/* load struct_rval */\n+\n+\tbl\tffi_closure_SYSV_inner\n+\n+\t/* Load the return value as directed.  */\n+\tadr\tx1, ffi_closure_SYSV_return_base\n+\tand\tw0, w0, #AARCH64_RET_MASK\n+\tadd\tx1, x1, x0, lsl #3\n+\tadd\tx3, sp, #16+CALL_CONTEXT_SIZE\n+\tbr\tx1\n+\n+\t/* Note that each table entry is 2 insns, and thus 8 bytes.  */\n+\tALIGN\t8\n+ffi_closure_SYSV_return_base\n+\tb\tffi_closure_SYSV_epilog\t\t\t/* VOID */\n+\tnop\n+\tldr\tx0, [x3]\t\t/* INT64 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldp\tx0, x1, [x3]\t\t/* INT128 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+\tbrk\t#1000\t\t\t/* UNUSED */\n+\tnop\n+\tldr\ts3, [x3, #12]\t\t/* S4 */\n+\tnop\n+\tldr\ts2, [x3, #8]\t\t/* S3 */\n+\tnop\n+\tldp\ts0, s1, [x3]\t\t/* S2 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldr\ts0, [x3]\t\t/* S1 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldr\td3, [x3, #24]\t\t/* D4 */\n+\tnop\n+\tldr\td2, [x3, #16]\t\t/* D3 */\n+\tnop\n+\tldp\td0, d1, [x3]\t\t/* D2 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldr\td0, [x3]\t\t/* D1 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldr\tq3, [x3, #48]\t\t/* Q4 */\n+\tnop\n+\tldr\tq2, [x3, #32]\t\t/* Q3 */\n+\tnop\n+\tldp\tq0, q1, [x3]\t\t/* Q2 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldr\tq0, [x3]\t\t/* Q1 */\n+\tb\tffi_closure_SYSV_epilog\n+\tldrb\tw0, [x3, #BE(7)]\t/* UINT8 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+\tldrh\tw0, [x3, #BE(6)]\t/* UINT16 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+\tldr\tw0, [x3, #BE(4)]\t/* UINT32 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+\tldrsb\tx0, [x3, #BE(7)]\t/* SINT8 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+\tldrsh\tx0, [x3, #BE(6)]\t/* SINT16 */\n+\tb\tffi_closure_SYSV_epilog\n+\tbrk\t#1000\t\t\t/* reserved */\n+\tnop\n+\tldrsw\tx0, [x3, #BE(4)]\t/* SINT32 */\n+\tnop\n+\t\t\t\t\t/* reserved */\n+\n+ffi_closure_SYSV_epilog\n+\tEPILOG_RESTORE_REG_PAIR\tx29, x30, #ffi_closure_SYSV_FS!\n+\tEPILOG_RETURN\n+\tNESTED_END\tffi_closure_SYSV\n+\n+\n+#ifdef FFI_GO_CLOSURES\n+\tNESTED_ENTRY\tffi_go_closure_SYSV_V\n+\tPROLOG_SAVE_REG_PAIR\tx29, x30, #-ffi_closure_SYSV_FS!\n+\n+\t/* Save the argument passing vector registers.  */\n+\tstp\tq0, q1, [sp, #16 + 0]\n+\tstp\tq2, q3, [sp, #16 + 32]\n+\tstp\tq4, q5, [sp, #16 + 64]\n+\tstp\tq6, q7, [sp, #16 + 96]\n+\tb\tffi_go_closure_SYSV_save_argument\n+\tNESTED_END\tffi_go_closure_SYSV_V\n+\n+\tNESTED_ENTRY\tffi_go_closure_SYSV\n+\tPROLOG_SAVE_REG_PAIR\tx29, x30, #-ffi_closure_SYSV_FS!\n+\n+ffi_go_closure_SYSV_save_argument\n+\t/* Save the argument passing core registers.  */\n+\tstp     x0, x1, [sp, #16 + 16*N_V_ARG_REG + 0]\n+\tstp     x2, x3, [sp, #16 + 16*N_V_ARG_REG + 16]\n+\tstp     x4, x5, [sp, #16 + 16*N_V_ARG_REG + 32]\n+\tstp     x6, x7, [sp, #16 + 16*N_V_ARG_REG + 48]\n+\n+\t/* Load ffi_closure_inner arguments.  */\n+\tldp\tPTR_REG(0), PTR_REG(1), [x18, #PTR_SIZE]/* load cif, fn */\n+\tmov\tx2, x18\t\t\t\t\t/* load user_data */\n+\tb\tdo_closure\n+\tNESTED_END\tffi_go_closure_SYSV\n+\n+#endif /* FFI_GO_CLOSURES */\n+\n+\n+/* void extend_hfa_type (void *dest, void *src, int h) */\n+\n+\tLEAF_ENTRY\textend_hfa_type\n+\n+\tadr\tx3, extend_hfa_type_jump_base\n+\tand\tw2, w2, #AARCH64_RET_MASK\n+\tsub\tx2, x2, #AARCH64_RET_S4\n+\tadd\tx3, x3, x2, lsl #4\n+\tbr\tx3\n+\n+\tALIGN\t4\n+extend_hfa_type_jump_base\n+\tldp\ts16, s17, [x1]\t\t/* S4 */\n+\tldp\ts18, s19, [x1, #8]\n+\tb\textend_hfa_type_store_4\n+\tnop\n+\n+\tldp\ts16, s17, [x1]\t\t/* S3 */\n+\tldr\ts18, [x1, #8]\n+\tb\textend_hfa_type_store_3\n+\tnop\n+\n+\tldp\ts16, s17, [x1]\t\t/* S2 */\n+\tb\textend_hfa_type_store_2\n+\tnop\n+\tnop\n+\n+\tldr\ts16, [x1]\t\t/* S1 */\n+\tb\textend_hfa_type_store_1\n+\tnop\n+\tnop\n+\n+\tldp\td16, d17, [x1]\t\t/* D4 */\n+\tldp\td18, d19, [x1, #16]\n+\tb       extend_hfa_type_store_4\n+\tnop\n+\n+\tldp     d16, d17, [x1]\t\t/* D3 */\n+\tldr     d18, [x1, #16]\n+\tb\textend_hfa_type_store_3\n+\tnop\n+\n+\tldp\td16, d17, [x1]\t\t/* D2 */\n+\tb\textend_hfa_type_store_2\n+\tnop\n+\tnop\n+\n+\tldr\td16, [x1]\t\t/* D1 */\n+\tb\textend_hfa_type_store_1\n+\tnop\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q4 */\n+\tldp\tq18, q19, [x1, #16]\n+\tb\textend_hfa_type_store_4\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q3 */\n+\tldr\tq18, [x1, #16]\n+\tb\textend_hfa_type_store_3\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q2 */\n+\tb\textend_hfa_type_store_2\n+\tnop\n+\tnop\n+\n+\tldr\tq16, [x1]\t\t/* Q1 */\n+\tb\textend_hfa_type_store_1\n+\n+extend_hfa_type_store_4\n+\tstr\tq19, [x0, #48]\n+extend_hfa_type_store_3\n+\tstr\tq18, [x0, #32]\n+extend_hfa_type_store_2\n+\tstr\tq17, [x0, #16]\n+extend_hfa_type_store_1\n+\tstr\tq16, [x0]\n+\tret\n+\n+\tLEAF_END\textend_hfa_type\n+\n+\n+/* void compress_hfa_type (void *dest, void *reg, int h) */\n+\n+\tLEAF_ENTRY\tcompress_hfa_type\n+\n+\tadr\tx3, compress_hfa_type_jump_base\n+\tand\tw2, w2, #AARCH64_RET_MASK\n+\tsub\tx2, x2, #AARCH64_RET_S4\n+\tadd\tx3, x3, x2, lsl #4\n+\tbr\tx3\n+\n+\tALIGN\t4\n+compress_hfa_type_jump_base\n+\tldp\tq16, q17, [x1]\t\t/* S4 */\n+\tldp\tq18, q19, [x1, #32]\n+\tst4\t{ v16.s, v17.s, v18.s, v19.s }[0], [x0]\n+\tret\n+\n+\tldp\tq16, q17, [x1]\t\t/* S3 */\n+\tldr\tq18, [x1, #32]\n+\tst3\t{ v16.s, v17.s, v18.s }[0], [x0]\n+\tret\n+\n+\tldp\tq16, q17, [x1]\t\t/* S2 */\n+\tst2\t{ v16.s, v17.s }[0], [x0]\n+\tret\n+\tnop\n+\n+\tldr\tq16, [x1]\t\t/* S1 */\n+\tst1\t{ v16.s }[0], [x0]\n+\tret\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* D4 */\n+\tldp\tq18, q19, [x1, #32]\n+\tst4\t{ v16.d, v17.d, v18.d, v19.d }[0], [x0]\n+\tret\n+\n+\tldp\tq16, q17, [x1]\t\t/* D3 */\n+\tldr\tq18, [x1, #32]\n+\tst3\t{ v16.d, v17.d, v18.d }[0], [x0]\n+\tret\n+\n+\tldp\tq16, q17, [x1]\t\t/* D2 */\n+\tst2\t{ v16.d, v17.d }[0], [x0]\n+\tret\n+\tnop\n+\n+\tldr\tq16, [x1]\t\t/* D1 */\n+\tst1\t{ v16.d }[0], [x0]\n+\tret\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q4 */\n+\tldp\tq18, q19, [x1, #32]\n+\tb\tcompress_hfa_type_store_q4\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q3 */\n+\tldr\tq18, [x1, #32]\n+\tb\tcompress_hfa_type_store_q3\n+\tnop\n+\n+\tldp\tq16, q17, [x1]\t\t/* Q2 */\n+\tstp\tq16, q17, [x0]\n+\tret\n+\tnop\n+\n+\tldr\tq16, [x1]\t\t/* Q1 */\n+\tstr\tq16, [x0]\n+\tret\n+\n+compress_hfa_type_store_q4\n+\tstr\tq19, [x0, #48]\n+compress_hfa_type_store_q3\n+\tstr\tq18, [x0, #32]\n+\tstp\tq16, q17, [x0]\n+\tret\n+\n+\tLEAF_END\tcompress_hfa_type\n+\n+\tEND\n\\ No newline at end of file"}, {"sha": "7a95e9707c3a0f6e1b175a43cdb1499d16d65e3a", "filename": "libffi/src/alpha/ffi.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Falpha%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Falpha%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -98,7 +98,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \tcase FFI_TYPE_VOID:\n \tcase FFI_TYPE_STRUCT:\n \t  /* Passed by value in N slots.  */\n-\t  bytes += ALIGN(itype->size, FFI_SIZEOF_ARG);\n+\t  bytes += FFI_ALIGN(itype->size, FFI_SIZEOF_ARG);\n \t  break;\n \n \tcase FFI_TYPE_COMPLEX:\n@@ -285,7 +285,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,\n \tcase FFI_TYPE_STRUCT:\n \t  size = ty->size;\n \t  memcpy(argp + argn, valp, size);\n-\t  argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  argn += FFI_ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t  break;\n \n \tcase FFI_TYPE_COMPLEX:\n@@ -421,7 +421,7 @@ ffi_closure_osf_inner (ffi_cif *cif,\n \tcase FFI_TYPE_VOID:\n \tcase FFI_TYPE_STRUCT:\n \t  size = ty->size;\n-\t  argn += ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  argn += FFI_ALIGN(size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:"}, {"sha": "4d10b21a5d95d9a7a4ec1fa2991d2dd2680d8b97", "filename": "libffi/src/arc/ffi.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farc%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -46,12 +46,10 @@ void\n ffi_prep_args (char *stack, extended_cif * ecif)\n {\n   unsigned int i;\n-  int tmp;\n   void **p_argv;\n   char *argp;\n   ffi_type **p_arg;\n \n-  tmp = 0;\n   argp = stack;\n \n   if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)\n@@ -73,7 +71,7 @@ ffi_prep_args (char *stack, extended_cif * ecif)\n \n       /* Align if necessary.  */\n       if ((alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, alignment);\n+\targp = (char *) FFI_ALIGN (argp, alignment);\n \n       z = (*p_arg)->size;\n       if (z < sizeof (int))\n@@ -225,7 +223,7 @@ ffi_closure_inner_ARCompact (ffi_closure * closure, void *rvalue,\n \n       /* Align if necessary.  */\n       if ((alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, alignment);\n+\targp = (char *) FFI_ALIGN (argp, alignment);\n \n       z = (*p_argt)->size;\n       *p_argv = (void *) argp;"}, {"sha": "593ab4d48b8b003f606b1f795284823420656d35", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 126, "deletions": 254, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -28,11 +28,42 @@\n    DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n+#if defined(__arm__) || defined(_M_ARM)\n+#include <fficonfig.h>\n #include <ffi.h>\n #include <ffi_common.h>\n+#include <stdint.h>\n #include <stdlib.h>\n+#include <tramp.h>\n #include \"internal.h\"\n \n+#if defined(_WIN32)\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+#endif\n+\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#ifdef __MACH__\n+#include <mach/machine/vm_param.h>\n+#endif\n+\n+#else\n+#ifndef _WIN32\n+extern unsigned int ffi_arm_trampoline[2] FFI_HIDDEN;\n+#else\n+// Declare this as an array of char, instead of array of int,\n+// otherwise Clang optimizes out the \"& 0xFFFFFFFE\" for clearing\n+// the thumb bit.\n+extern unsigned char ffi_arm_trampoline[12] FFI_HIDDEN;\n+#endif\n+#endif\n+\n+#if defined(__FreeBSD__) && defined(__arm__)\n+#include <sys/types.h>\n+#include <machine/sysarch.h>\n+#endif\n+\n /* Forward declares. */\n static int vfp_type_p (const ffi_type *);\n static void layout_vfp_args (ffi_cif *);\n@@ -49,7 +80,7 @@ ffi_align (ffi_type *ty, void *p)\n   if (alignment < 4)\n     alignment = 4;\n #endif\n-  return (void *) ALIGN (p, alignment);\n+  return (void *) FFI_ALIGN (p, alignment);\n }\n \n static size_t\n@@ -76,10 +107,20 @@ ffi_put_arg (ffi_type *ty, void *src, void *dst)\n     case FFI_TYPE_SINT32:\n     case FFI_TYPE_UINT32:\n     case FFI_TYPE_POINTER:\n+#ifndef _WIN32\n     case FFI_TYPE_FLOAT:\n+#endif\n       *(UINT32 *)dst = *(UINT32 *)src;\n       break;\n \n+#ifdef _WIN32\n+    // casting a float* to a UINT32* doesn't work on Windows\n+    case FFI_TYPE_FLOAT:\n+        *(uintptr_t *)dst = 0;\n+        *(float *)dst = *(float *)src;\n+        break;\n+#endif\n+\n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_UINT64:\n     case FFI_TYPE_DOUBLE:\n@@ -95,7 +136,7 @@ ffi_put_arg (ffi_type *ty, void *src, void *dst)\n       abort();\n     }\n \n-  return ALIGN (z, 4);\n+  return FFI_ALIGN (z, 4);\n }\n \n /* ffi_prep_args is called once stack space has been allocated\n@@ -198,7 +239,7 @@ ffi_prep_args_VFP (ffi_cif *cif, int flags, void *rvalue,\n }\n \n /* Perform machine dependent cif processing */\n-ffi_status\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep (ffi_cif *cif)\n {\n   int flags = 0, cabi = cif->abi;\n@@ -276,7 +317,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   /* Round the stack up to a multiple of 8 bytes.  This isn't needed\n      everywhere, but it is on some platforms, and it doesn't harm anything\n      when it isn't needed.  */\n-  bytes = ALIGN (bytes, 8);\n+  bytes = FFI_ALIGN (bytes, 8);\n \n   /* Minimum stack space is the 4 register arguments that we pop.  */\n   if (bytes < 4*4)\n@@ -289,7 +330,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n }\n \n /* Perform machine dependent cif processing for variadic calls */\n-ffi_status\n+ffi_status FFI_HIDDEN\n ffi_prep_cif_machdep_var (ffi_cif * cif,\n \t\t\t  unsigned int nfixedargs, unsigned int ntotalargs)\n {\n@@ -389,12 +430,14 @@ ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)\n   ffi_call_int (cif, fn, rvalue, avalue, NULL);\n }\n \n+#ifdef FFI_GO_CLOSURES\n void\n ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,\n \t     void **avalue, void *closure)\n {\n   ffi_call_int (cif, fn, rvalue, avalue, closure);\n }\n+#endif\n \n static void *\n ffi_prep_incoming_args_SYSV (ffi_cif *cif, void *rvalue,\n@@ -408,6 +451,11 @@ ffi_prep_incoming_args_SYSV (ffi_cif *cif, void *rvalue,\n       rvalue = *(void **) argp;\n       argp += 4;\n     }\n+  else\n+    {\n+      if (cif->rtype->size && cif->rtype->size < 4)\n+        *(uint32_t *) rvalue = 0;\n+    }\n \n   for (i = 0, n = cif->nargs; i < n; i++)\n     {\n@@ -492,6 +540,8 @@ ffi_prep_incoming_args_VFP (ffi_cif *cif, void *rvalue, char *stack,\n   return rvalue;\n }\n \n+#if FFI_CLOSURES\n+\n struct closure_frame\n {\n   char vfp_space[8*8] __attribute__((aligned(8)));\n@@ -527,257 +577,28 @@ ffi_closure_inner_VFP (ffi_cif *cif,\n \n void ffi_closure_SYSV (void) FFI_HIDDEN;\n void ffi_closure_VFP (void) FFI_HIDDEN;\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void ffi_closure_SYSV_alt (void) FFI_HIDDEN;\n+void ffi_closure_VFP_alt (void) FFI_HIDDEN;\n+#endif\n+\n+#ifdef FFI_GO_CLOSURES\n void ffi_go_closure_SYSV (void) FFI_HIDDEN;\n void ffi_go_closure_VFP (void) FFI_HIDDEN;\n-\n-#if FFI_EXEC_TRAMPOLINE_TABLE\n-\n-#include <mach/mach.h>\n-#include <pthread.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-extern void *ffi_closure_trampoline_table_page;\n-\n-typedef struct ffi_trampoline_table ffi_trampoline_table;\n-typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n-\n-struct ffi_trampoline_table\n-{\n-  /* contiguous writable and executable pages */\n-  vm_address_t config_page;\n-  vm_address_t trampoline_page;\n-\n-  /* free list tracking */\n-  uint16_t free_count;\n-  ffi_trampoline_table_entry *free_list;\n-  ffi_trampoline_table_entry *free_list_pool;\n-\n-  ffi_trampoline_table *prev;\n-  ffi_trampoline_table *next;\n-};\n-\n-struct ffi_trampoline_table_entry\n-{\n-  void *(*trampoline) ();\n-  ffi_trampoline_table_entry *next;\n-};\n-\n-/* Override the standard architecture trampoline size */\n-// XXX TODO - Fix\n-#undef FFI_TRAMPOLINE_SIZE\n-#define FFI_TRAMPOLINE_SIZE 12\n-\n-/* The trampoline configuration is placed at 4080 bytes prior to the trampoline's entry point */\n-#define FFI_TRAMPOLINE_CODELOC_CONFIG(codeloc) ((void **) (((uint8_t *) codeloc) - 4080));\n-\n-/* The first 16 bytes of the config page are unused, as they are unaddressable from the trampoline page. */\n-#define FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET 16\n-\n-/* Total number of trampolines that fit in one trampoline table */\n-#define FFI_TRAMPOLINE_COUNT ((PAGE_SIZE - FFI_TRAMPOLINE_CONFIG_PAGE_OFFSET) / FFI_TRAMPOLINE_SIZE)\n-\n-static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;\n-static ffi_trampoline_table *ffi_trampoline_tables = NULL;\n-\n-static ffi_trampoline_table *\n-ffi_trampoline_table_alloc ()\n-{\n-  ffi_trampoline_table *table = NULL;\n-\n-  /* Loop until we can allocate two contiguous pages */\n-  while (table == NULL)\n-    {\n-      vm_address_t config_page = 0x0;\n-      kern_return_t kt;\n-\n-      /* Try to allocate two pages */\n-      kt =\n-\tvm_allocate (mach_task_self (), &config_page, PAGE_SIZE * 2,\n-\t\t     VM_FLAGS_ANYWHERE);\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  fprintf (stderr, \"vm_allocate() failure: %d at %s:%d\\n\", kt,\n-\t\t   __FILE__, __LINE__);\n-\t  break;\n-\t}\n-\n-      /* Now drop the second half of the allocation to make room for the trampoline table */\n-      vm_address_t trampoline_page = config_page + PAGE_SIZE;\n-      kt = vm_deallocate (mach_task_self (), trampoline_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  fprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t   __FILE__, __LINE__);\n-\t  break;\n-\t}\n-\n-      /* Remap the trampoline table to directly follow the config page */\n-      vm_prot_t cur_prot;\n-      vm_prot_t max_prot;\n-\n-      kt =\n-\tvm_remap (mach_task_self (), &trampoline_page, PAGE_SIZE, 0x0, FALSE,\n-\t\t  mach_task_self (),\n-\t\t  (vm_address_t) & ffi_closure_trampoline_table_page, FALSE,\n-\t\t  &cur_prot, &max_prot, VM_INHERIT_SHARE);\n-\n-      /* If we lost access to the destination trampoline page, drop our config allocation mapping and retry */\n-      if (kt != KERN_SUCCESS)\n-\t{\n-\t  /* Log unexpected failures */\n-\t  if (kt != KERN_NO_SPACE)\n-\t    {\n-\t      fprintf (stderr, \"vm_remap() failure: %d at %s:%d\\n\", kt,\n-\t\t       __FILE__, __LINE__);\n-\t    }\n-\n-\t  vm_deallocate (mach_task_self (), config_page, PAGE_SIZE);\n-\t  continue;\n-\t}\n-\n-      /* We have valid trampoline and config pages */\n-      table = calloc (1, sizeof (ffi_trampoline_table));\n-      table->free_count = FFI_TRAMPOLINE_COUNT;\n-      table->config_page = config_page;\n-      table->trampoline_page = trampoline_page;\n-\n-      /* Create and initialize the free list */\n-      table->free_list_pool =\n-\tcalloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));\n-\n-      uint16_t i;\n-      for (i = 0; i < table->free_count; i++)\n-\t{\n-\t  ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n-\t  entry->trampoline =\n-\t    (void *) (table->trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n-\n-\t  if (i < table->free_count - 1)\n-\t    entry->next = &table->free_list_pool[i + 1];\n-\t}\n-\n-      table->free_list = table->free_list_pool;\n-    }\n-\n-  return table;\n-}\n-\n-void *\n-ffi_closure_alloc (size_t size, void **code)\n-{\n-  /* Create the closure */\n-  ffi_closure *closure = malloc (size);\n-  if (closure == NULL)\n-    return NULL;\n-\n-  pthread_mutex_lock (&ffi_trampoline_lock);\n-\n-  /* Check for an active trampoline table with available entries. */\n-  ffi_trampoline_table *table = ffi_trampoline_tables;\n-  if (table == NULL || table->free_list == NULL)\n-    {\n-      table = ffi_trampoline_table_alloc ();\n-      if (table == NULL)\n-\t{\n-\t  free (closure);\n-\t  return NULL;\n-\t}\n-\n-      /* Insert the new table at the top of the list */\n-      table->next = ffi_trampoline_tables;\n-      if (table->next != NULL)\n-\ttable->next->prev = table;\n-\n-      ffi_trampoline_tables = table;\n-    }\n-\n-  /* Claim the free entry */\n-  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n-  ffi_trampoline_tables->free_list = entry->next;\n-  ffi_trampoline_tables->free_count--;\n-  entry->next = NULL;\n-\n-  pthread_mutex_unlock (&ffi_trampoline_lock);\n-\n-  /* Initialize the return values */\n-  *code = entry->trampoline;\n-  closure->trampoline_table = table;\n-  closure->trampoline_table_entry = entry;\n-\n-  return closure;\n-}\n-\n-void\n-ffi_closure_free (void *ptr)\n-{\n-  ffi_closure *closure = ptr;\n-\n-  pthread_mutex_lock (&ffi_trampoline_lock);\n-\n-  /* Fetch the table and entry references */\n-  ffi_trampoline_table *table = closure->trampoline_table;\n-  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;\n-\n-  /* Return the entry to the free list */\n-  entry->next = table->free_list;\n-  table->free_list = entry;\n-  table->free_count++;\n-\n-  /* If all trampolines within this table are free, and at least one other table exists, deallocate\n-   * the table */\n-  if (table->free_count == FFI_TRAMPOLINE_COUNT\n-      && ffi_trampoline_tables != table)\n-    {\n-      /* Remove from the list */\n-      if (table->prev != NULL)\n-\ttable->prev->next = table->next;\n-\n-      if (table->next != NULL)\n-\ttable->next->prev = table->prev;\n-\n-      /* Deallocate pages */\n-      kern_return_t kt;\n-      kt = vm_deallocate (mach_task_self (), table->config_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t __FILE__, __LINE__);\n-\n-      kt =\n-\tvm_deallocate (mach_task_self (), table->trampoline_page, PAGE_SIZE);\n-      if (kt != KERN_SUCCESS)\n-\tfprintf (stderr, \"vm_deallocate() failure: %d at %s:%d\\n\", kt,\n-\t\t __FILE__, __LINE__);\n-\n-      /* Deallocate free list */\n-      free (table->free_list_pool);\n-      free (table);\n-    }\n-  else if (ffi_trampoline_tables != table)\n-    {\n-      /* Otherwise, bump this table to the top of the list */\n-      table->prev = NULL;\n-      table->next = ffi_trampoline_tables;\n-      if (ffi_trampoline_tables != NULL)\n-\tffi_trampoline_tables->prev = table;\n-\n-      ffi_trampoline_tables = table;\n-    }\n-\n-  pthread_mutex_unlock (&ffi_trampoline_lock);\n-\n-  /* Free the closure */\n-  free (closure);\n-}\n-\n-#else\n-\n-extern unsigned int ffi_arm_trampoline[2] FFI_HIDDEN;\n-\n #endif\n \n /* the cif must already be prep'ed */\n \n+#if defined(__FreeBSD__) && defined(__arm__)\n+#define __clear_cache(start, end) do { \\\n+\t\tstruct arm_sync_icache_args ua; \t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t\tua.addr = (uintptr_t)(start);\t\t\t\\\n+\t\tua.len = (char *)(end) - (char *)start;\t\t\\\n+\t\tsysarch(ARM_SYNC_ICACHE, &ua);\t\t\t\\\n+\t} while (0);\n+#endif\n+\n ffi_status\n ffi_prep_closure_loc (ffi_closure * closure,\n \t\t      ffi_cif * cif,\n@@ -796,14 +617,47 @@ ffi_prep_closure_loc (ffi_closure * closure,\n     return FFI_BAD_ABI;\n \n #if FFI_EXEC_TRAMPOLINE_TABLE\n-  void **config = FFI_TRAMPOLINE_CODELOC_CONFIG (codeloc);\n+  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n   config[0] = closure;\n   config[1] = closure_func;\n #else\n-  memcpy (closure->tramp, ffi_arm_trampoline, 8);\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+  if (ffi_tramp_is_present(closure))\n+    {\n+      /* Initialize the static trampoline's parameters. */\n+      if (closure_func == ffi_closure_SYSV)\n+        closure_func = ffi_closure_SYSV_alt;\n+      else\n+        closure_func = ffi_closure_VFP_alt;\n+      ffi_tramp_set_parms (closure->ftramp, closure_func, closure);\n+      goto out;\n+    }\n+#endif\n+\n+  /* Initialize the dynamic trampoline. */\n+#ifndef _WIN32\n+  memcpy(closure->tramp, ffi_arm_trampoline, 8);\n+#else\n+  // cast away function type so MSVC doesn't set the lower bit of the function pointer\n+  memcpy(closure->tramp, (void*)((uintptr_t)ffi_arm_trampoline & 0xFFFFFFFE), FFI_TRAMPOLINE_CLOSURE_OFFSET);\n+#endif\n+\n+#if defined (__QNX__)\n+  msync(closure->tramp, 8, 0x1000000);\t/* clear data map */\n+  msync(codeloc, 8, 0x1000000);\t/* clear insn map */\n+#elif defined(_WIN32)\n+  FlushInstructionCache(GetCurrentProcess(), closure->tramp, FFI_TRAMPOLINE_SIZE);\n+#else\n   __clear_cache(closure->tramp, closure->tramp + 8);\t/* clear data map */\n   __clear_cache(codeloc, codeloc + 8);\t\t\t/* clear insn map */\n+#endif\n+#ifdef _WIN32\n+  *(void(**)(void))(closure->tramp + FFI_TRAMPOLINE_CLOSURE_FUNCTION) = closure_func;\n+#else\n   *(void (**)(void))(closure->tramp + 8) = closure_func;\n+#endif\n+out:\n #endif\n \n   closure->cif = cif;\n@@ -813,6 +667,7 @@ ffi_prep_closure_loc (ffi_closure * closure,\n   return FFI_OK;\n }\n \n+#ifdef FFI_GO_CLOSURES\n ffi_status\n ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,\n \t\t     void (*fun) (ffi_cif *, void *, void **, void *))\n@@ -834,6 +689,9 @@ ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,\n \n   return FFI_OK;\n }\n+#endif\n+\n+#endif /* FFI_CLOSURES */\n \n /* Below are routines for VFP hard-float support. */\n \n@@ -1005,7 +863,7 @@ place_vfp_arg (ffi_cif *cif, int h)\n \t}\n       /* Found regs to allocate. */\n       cif->vfp_used |= new_used;\n-      cif->vfp_args[cif->vfp_nargs++] = reg;\n+      cif->vfp_args[cif->vfp_nargs++] = (signed char)reg;\n \n       /* Update vfp_reg_free. */\n       if (cif->vfp_used & (1 << cif->vfp_reg_free))\n@@ -1027,7 +885,7 @@ place_vfp_arg (ffi_cif *cif, int h)\n static void\n layout_vfp_args (ffi_cif * cif)\n {\n-  int i;\n+  unsigned int i;\n   /* Init VFP fields */\n   cif->vfp_used = 0;\n   cif->vfp_nargs = 0;\n@@ -1041,3 +899,17 @@ layout_vfp_args (ffi_cif * cif)\n \tbreak;\n     }\n }\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+void *\n+ffi_tramp_arch (size_t *tramp_size, size_t *map_size)\n+{\n+  extern void *trampoline_code_table;\n+\n+  *tramp_size = ARM_TRAMP_SIZE;\n+  *map_size = ARM_TRAMP_MAP_SIZE;\n+  return &trampoline_code_table;\n+}\n+#endif\n+\n+#endif /* __arm__ or _M_ARM */"}, {"sha": "12d5d206953490121548df9e4f03ed30c03494a9", "filename": "libffi/src/arm/ffitarget.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -43,7 +43,7 @@ typedef enum ffi_abi {\n   FFI_SYSV,\n   FFI_VFP,\n   FFI_LAST_ABI,\n-#ifdef __ARM_PCS_VFP\n+#if defined(__ARM_PCS_VFP) || defined(_WIN32)\n   FFI_DEFAULT_ABI = FFI_VFP,\n #else\n   FFI_DEFAULT_ABI = FFI_SYSV,\n@@ -57,13 +57,33 @@ typedef enum ffi_abi {\n   signed char vfp_args[16]\t\t\t\\\n \n #define FFI_TARGET_SPECIFIC_VARIADIC\n+#ifndef _WIN32\n #define FFI_TARGET_HAS_COMPLEX_TYPE\n+#endif\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n #define FFI_GO_CLOSURES 1\n-#define FFI_TRAMPOLINE_SIZE 12\n #define FFI_NATIVE_RAW_API 0\n \n+#if defined (FFI_EXEC_TRAMPOLINE_TABLE) && FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#ifdef __MACH__\n+#define FFI_TRAMPOLINE_SIZE 12\n+#define FFI_TRAMPOLINE_CLOSURE_OFFSET 8\n+#else\n+#error \"No trampoline table implementation\"\n+#endif\n+\n+#else\n+#ifdef _WIN32\n+#define FFI_TRAMPOLINE_SIZE 16\n+#define FFI_TRAMPOLINE_CLOSURE_FUNCTION 12\n+#else\n+#define FFI_TRAMPOLINE_SIZE 12\n+#endif\n+#define FFI_TRAMPOLINE_CLOSURE_OFFSET FFI_TRAMPOLINE_SIZE\n+#endif\n+\n #endif"}, {"sha": "fa8ab0b6ebcd70b71e7269c02e11eb8e272e2103", "filename": "libffi/src/arm/internal.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Finternal.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -5,3 +5,13 @@\n #define ARM_TYPE_INT\t4\n #define ARM_TYPE_VOID\t5\n #define ARM_TYPE_STRUCT\t6\n+\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+/*\n+ * For the trampoline table mapping, a mapping size of 4K (base page size)\n+ * is chosen.\n+ */\n+#define ARM_TRAMP_MAP_SHIFT\t12\n+#define ARM_TRAMP_MAP_SIZE\t(1 << ARM_TRAMP_MAP_SHIFT)\n+#define ARM_TRAMP_SIZE\t\t20\n+#endif"}, {"sha": "fb36213c6805fa5017154328e094daeaf902a0c5", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 229, "deletions": 75, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -25,7 +25,8 @@\n    DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#define LIBFFI_ASM\t\n+#ifdef __arm__\n+#define LIBFFI_ASM\n #include <fficonfig.h>\n #include <ffi.h>\n #include <ffi_cfi.h>\n@@ -52,11 +53,12 @@\n #endif\n \n /* Conditionally compile unwinder directives.  */\n-.macro UNWIND text:vararg\n #ifdef __ARM_EABI__\n-\t\\text\n-#endif\t\n-.endm\n+# define UNWIND(...)\t__VA_ARGS__\n+#else\n+# define UNWIND(...)\n+#endif\n+\n #if defined(HAVE_AS_CFI_PSEUDO_OP) && defined(__ARM_EABI__)\n \t.cfi_sections\t.debug_frame\n #endif\n@@ -77,29 +79,52 @@\n # define TYPE(X, Y)\n #endif\n \n-#define ARM_FUNC_START(name, gl) \\\n-\t.align\t3; \\\n-\t.ifne gl; .globl CNAME(name); FFI_HIDDEN(CNAME(name)); .endif; \\\n-\tTYPE(name, %function); \\\n+#define ARM_FUNC_START_LOCAL(name)\t\\\n+\t.align\t3;\t\t\t\\\n+\tTYPE(CNAME(name), %function);\t\\\n \tCNAME(name):\n \n+#define ARM_FUNC_START(name)\t\t\\\n+\t.globl CNAME(name);\t\t\\\n+\tFFI_HIDDEN(CNAME(name));\t\\\n+\tARM_FUNC_START_LOCAL(name)\n+\n #define ARM_FUNC_END(name) \\\n \tSIZE(name)\n \n-/* Aid in defining a jump table with 8 bytes between entries.  */\n-.macro E index\n-\t.if . - 0b - 8*\\index\n-\t.error \"type table out of sync\"\n-\t.endif\n-.endm\n-\n \t.text\n \t.syntax unified\n+#if defined(_WIN32)\n+\t/* Windows on ARM is thumb-only */\n+\t.thumb\n+#else\n+\t/* Keep the assembly in ARM mode in other cases, for simplicity\n+\t * (to avoid interworking issues). */\n+#undef __thumb__\n \t.arm\n+#endif\n \n+/* Aid in defining a jump table with 8 bytes between entries.  */\n+#ifdef __thumb__\n+/* In thumb mode, instructions can be shorter than expected in arm mode, so\n+ * we need to align the start of each case. */\n+# define E(index) .align 3\n+#elif defined(__clang__)\n+/* ??? The clang assembler doesn't handle .if with symbolic expressions.  */\n+# define E(index)\n+#else\n+# define E(index)\t\t\t\t\\\n+\t.if . - 0b - 8*index;\t\t\t\\\n+\t.error \"type table out of sync\";\t\\\n+\t.endif\n+#endif\n+\n+\n+#ifndef __clang__\n \t/* We require interworking on LDM, which implies ARMv5T,\n \t   which implies the existance of BLX.  */\n-\t.arch\tarmv5t\n+ \t.arch\tarmv5t\n+#endif\n \n \t/* Note that we use STC and LDC to encode VFP instructions,\n \t   so that we do not need \".fpu vfp\", nor get that added to\n@@ -111,25 +136,31 @@\n \t@ r2:   fn\n \t@ r3:\tvfp_used\n \n-ARM_FUNC_START(ffi_call_VFP, 1)\n-\tUNWIND\t.fnstart\n+ARM_FUNC_START(ffi_call_VFP)\n+\tUNWIND(.fnstart)\n \tcfi_startproc\n \n \tcmp\tr3, #3\t\t\t@ load only d0 if possible\n-\tldcle\tp11, cr0, [r0]\t\t@ vldrle d0, [sp]\n-\tldcgt\tp11, cr0, [r0], {16}\t@ vldmgt sp, {d0-d7}\n+\tite\tle\n+#ifdef __clang__\n+\tvldrle d0, [r0]\n+\tvldmgt r0, {d0-d7}\n+#else\n+\tldcle\tp11, cr0, [r0]\t\t@ vldrle d0, [r0]\n+\tldcgt\tp11, cr0, [r0], {16}\t@ vldmgt r0, {d0-d7}\n+#endif\n \tadd\tr0, r0, #64\t\t@ discard the vfp register args\n \t/* FALLTHRU */\n ARM_FUNC_END(ffi_call_VFP)\n \n-ARM_FUNC_START(ffi_call_SYSV, 1)\n+ARM_FUNC_START(ffi_call_SYSV)\n \tstm\tr1, {fp, lr}\n \tmov\tfp, r1\n \n \t@ This is a bit of a lie wrt the origin of the unwind info, but\n \t@ now we've got the usual frame pointer and two saved registers.\n-\tUNWIND\t.save {fp,lr}\n-\tUNWIND\t.setfp fp, sp\n+\tUNWIND(.save {fp,lr})\n+\tUNWIND(.setfp fp, sp)\n \tcfi_def_cfa(fp, 8)\n \tcfi_rel_offset(fp, 0)\n \tcfi_rel_offset(lr, 4)\n@@ -150,41 +181,61 @@ ARM_FUNC_START(ffi_call_SYSV, 1)\n \tcfi_def_cfa_register(sp)\n \n \t@ Store values stored in registers.\n+#ifndef __thumb__\n \t.align\t3\n \tadd\tpc, pc, r3, lsl #3\n \tnop\n+#else\n+\tadr\tip, 0f\n+\tadd\tip, ip, r3, lsl #3\n+\tmov\tpc, ip\n+\t.align\t3\n+#endif\n 0:\n-E ARM_TYPE_VFP_S\n+E(ARM_TYPE_VFP_S)\n+#ifdef __clang__\n+\tvstr s0, [r2]\n+#else\n \tstc\tp10, cr0, [r2]\t\t@ vstr s0, [r2]\n+#endif\n \tpop\t{fp,pc}\n-E ARM_TYPE_VFP_D\n+E(ARM_TYPE_VFP_D)\n+#ifdef __clang__\n+\tvstr d0, [r2]\n+#else\n \tstc\tp11, cr0, [r2]\t\t@ vstr d0, [r2]\n+#endif\n \tpop\t{fp,pc}\n-E ARM_TYPE_VFP_N\n+E(ARM_TYPE_VFP_N)\n+#ifdef __clang__\n+\tvstm r2, {d0-d3}\n+#else\n \tstc\tp11, cr0, [r2], {8}\t@ vstm r2, {d0-d3}\n+#endif\n \tpop\t{fp,pc}\n-E ARM_TYPE_INT64\n+E(ARM_TYPE_INT64)\n \tstr\tr1, [r2, #4]\n \tnop\n-E ARM_TYPE_INT\n+E(ARM_TYPE_INT)\n \tstr\tr0, [r2]\n \tpop\t{fp,pc}\n-E ARM_TYPE_VOID\n+E(ARM_TYPE_VOID)\n \tpop\t{fp,pc}\n \tnop\n-E ARM_TYPE_STRUCT\n+E(ARM_TYPE_STRUCT)\n \tpop\t{fp,pc}\n \n \tcfi_endproc\n-\tUNWIND\t.fnend\n+\tUNWIND(.fnend)\n ARM_FUNC_END(ffi_call_SYSV)\n \n+#if FFI_CLOSURES\n \n /*\n \tint ffi_closure_inner_* (cif, fun, user_data, frame)\n */\n \n-ARM_FUNC_START(ffi_go_closure_SYSV, 1)\n+ARM_FUNC_START(ffi_go_closure_SYSV)\n \tcfi_startproc\n \tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n \tcfi_adjust_cfa_offset(16)\n@@ -195,14 +246,21 @@ ARM_FUNC_START(ffi_go_closure_SYSV, 1)\n \tcfi_endproc\n ARM_FUNC_END(ffi_go_closure_SYSV)\n \n-ARM_FUNC_START(ffi_closure_SYSV, 1)\n-\tUNWIND\t.fnstart\n+ARM_FUNC_START(ffi_closure_SYSV)\n+\tUNWIND(.fnstart)\n \tcfi_startproc\n+#ifdef _WIN32\n+\tldmfd\tsp!, {r0, ip}\t\t\t@ restore fp (r0 is used for stack alignment)\n+#endif\n \tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n \tcfi_adjust_cfa_offset(16)\n-\tldr\tr0, [ip, #FFI_TRAMPOLINE_SIZE]\t  @ load cif\n-\tldr\tr1, [ip, #FFI_TRAMPOLINE_SIZE+4]  @ load fun\n-\tldr\tr2, [ip, #FFI_TRAMPOLINE_SIZE+8]  @ load user_data\n+\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\tldr ip, [ip]\t\t\t\t@ ip points to the config page, dereference to get the ffi_closure*\n+#endif\n+\tldr\tr0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t@ load cif\n+\tldr\tr1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  @ load fun\n+\tldr\tr2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  @ load user_data\n 0:\n \tadd\tip, sp, #16\t\t\t@ compute entry sp\n \tsub\tsp, sp, #64+32\t\t\t@ allocate frame\n@@ -212,7 +270,7 @@ ARM_FUNC_START(ffi_closure_SYSV, 1)\n \t/* Remember that EABI unwind info only applies at call sites.\n \t   We need do nothing except note the save of the stack pointer\n \t   and the link registers.  */\n-\tUNWIND\t.save {sp,lr}\n+\tUNWIND(.save {sp,lr})\n \tcfi_adjust_cfa_offset(8)\n \tcfi_rel_offset(lr, 4)\n \n@@ -222,12 +280,17 @@ ARM_FUNC_START(ffi_closure_SYSV, 1)\n \t@ Load values returned in registers.\n \tadd\tr2, sp, #8+64\t\t\t@ load result\n \tadr\tr3, CNAME(ffi_closure_ret)\n+#ifndef __thumb__\n \tadd\tpc, r3, r0, lsl #3\n+#else\n+\tadd\tr3, r3, r0, lsl #3\n+\tmov\tpc, r3\n+#endif\n \tcfi_endproc\n-\tUNWIND\t.fnend\n+\tUNWIND(.fnend)\n ARM_FUNC_END(ffi_closure_SYSV)\n \n-ARM_FUNC_START(ffi_go_closure_VFP, 1)\n+ARM_FUNC_START(ffi_go_closure_VFP)\n \tcfi_startproc\n \tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n \tcfi_adjust_cfa_offset(16)\n@@ -238,23 +301,34 @@ ARM_FUNC_START(ffi_go_closure_VFP, 1)\n \tcfi_endproc\n ARM_FUNC_END(ffi_go_closure_VFP)\n \n-ARM_FUNC_START(ffi_closure_VFP, 1)\n-\tUNWIND\t.fnstart\n+ARM_FUNC_START(ffi_closure_VFP)\n+\tUNWIND(.fnstart)\n \tcfi_startproc\n+#ifdef _WIN32\n+\tldmfd\tsp!, {r0, ip}\t\t\t@ restore fp (r0 is used for stack alignment)\n+#endif\n \tstmdb\tsp!, {r0-r3}\t\t\t@ save argument regs\n \tcfi_adjust_cfa_offset(16)\n-\tldr\tr0, [ip, #FFI_TRAMPOLINE_SIZE]\t  @ load cif\n-\tldr\tr1, [ip, #FFI_TRAMPOLINE_SIZE+4]  @ load fun\n-\tldr\tr2, [ip, #FFI_TRAMPOLINE_SIZE+8]  @ load user_data\n+\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\tldr ip, [ip]\t\t\t\t@ ip points to the config page, dereference to get the ffi_closure*\n+#endif\n+\tldr\tr0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]\t@ load cif\n+\tldr\tr1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  @ load fun\n+\tldr\tr2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  @ load user_data\n 0:\n \tadd\tip, sp, #16\n \tsub\tsp, sp, #64+32\t\t\t@ allocate frame\n \tcfi_adjust_cfa_offset(64+32)\n+#ifdef __clang__\n+\tvstm sp, {d0-d7}\n+#else\n \tstc\tp11, cr0, [sp], {16}\t\t@ vstm sp, {d0-d7}\n+#endif\n \tstmdb\tsp!, {ip,lr}\n \n \t/* See above.  */\n-\tUNWIND\t.save {sp,lr}\n+\tUNWIND(.save {sp,lr})\n \tcfi_adjust_cfa_offset(8)\n \tcfi_rel_offset(lr, 4)\n \n@@ -264,71 +338,151 @@ ARM_FUNC_START(ffi_closure_VFP, 1)\n \t@ Load values returned in registers.\n \tadd\tr2, sp, #8+64\t\t\t@ load result\n \tadr\tr3, CNAME(ffi_closure_ret)\n+#ifndef __thumb__\n \tadd\tpc, r3, r0, lsl #3\n+#else\n+\tadd\tr3, r3, r0, lsl #3\n+\tmov\tpc, r3\n+#endif\n \tcfi_endproc\n-\tUNWIND\t.fnend\n+\tUNWIND(.fnend)\n ARM_FUNC_END(ffi_closure_VFP)\n \n /* Load values returned in registers for both closure entry points.\n    Note that we use LDM with SP in the register set.  This is deprecated\n    by ARM, but not yet unpredictable.  */\n \n-ARM_FUNC_START(ffi_closure_ret, 0)\n+ARM_FUNC_START_LOCAL(ffi_closure_ret)\n \tcfi_startproc\n \tcfi_rel_offset(sp, 0)\n \tcfi_rel_offset(lr, 4)\n 0:\n-E ARM_TYPE_VFP_S\n+E(ARM_TYPE_VFP_S)\n+#ifdef __clang__\n+\tvldr s0, [r2]\n+#else\n \tldc\tp10, cr0, [r2]\t\t\t@ vldr s0, [r2]\n-\tldm\tsp, {sp,pc}\n-E ARM_TYPE_VFP_D\n+#endif\n+\tb\tcall_epilogue\n+E(ARM_TYPE_VFP_D)\n+#ifdef __clang__\n+\tvldr d0, [r2]\n+#else\n \tldc\tp11, cr0, [r2]\t\t\t@ vldr d0, [r2]\n-\tldm\tsp, {sp,pc}\n-E ARM_TYPE_VFP_N\n+#endif\n+\tb\tcall_epilogue\n+E(ARM_TYPE_VFP_N)\n+#ifdef __clang__\n+\tvldm r2, {d0-d3}\n+#else\n \tldc\tp11, cr0, [r2], {8}\t\t@ vldm r2, {d0-d3}\n-\tldm\tsp, {sp,pc}\n-E ARM_TYPE_INT64\n+#endif\n+\tb\tcall_epilogue\n+E(ARM_TYPE_INT64)\n \tldr\tr1, [r2, #4]\n \tnop\n-E ARM_TYPE_INT\n+E(ARM_TYPE_INT)\n \tldr\tr0, [r2]\n-\tldm\tsp, {sp,pc}\n-E ARM_TYPE_VOID\n-\tldm\tsp, {sp,pc}\n+\tb\tcall_epilogue\n+E(ARM_TYPE_VOID)\n+\tb\tcall_epilogue\n \tnop\n-E ARM_TYPE_STRUCT\n+E(ARM_TYPE_STRUCT)\n+\tb\tcall_epilogue\n+call_epilogue:\n+#ifndef __thumb__\n \tldm\tsp, {sp,pc}\n+#else\n+\tldm\tsp, {ip,lr}\n+\tmov\tsp, ip\n+\tbx\tlr\n+#endif\n \tcfi_endproc\n ARM_FUNC_END(ffi_closure_ret)\n \n-#if FFI_EXEC_TRAMPOLINE_TABLE\n+#if defined(FFI_EXEC_STATIC_TRAMP)\n+ARM_FUNC_START(ffi_closure_SYSV_alt)\n+\t/* See the comments above trampoline_code_table. */\n+\tldr\tip, [sp, #4]\t\t\t/* Load closure in ip */\n+\tadd\tsp, sp, 8\t\t\t/* Restore the stack */\n+\tb\tCNAME(ffi_closure_SYSV)\n+ARM_FUNC_END(ffi_closure_SYSV_alt)\n+\n+ARM_FUNC_START(ffi_closure_VFP_alt)\n+\t/* See the comments above trampoline_code_table. */\n+\tldr\tip, [sp, #4]\t\t\t/* Load closure in ip */\n+\tadd\tsp, sp, 8\t\t\t/* Restore the stack */\n+\tb\tCNAME(ffi_closure_VFP)\n+ARM_FUNC_END(ffi_closure_VFP_alt)\n \n-/* ??? The iOS support should be updated.  The first insn used to\n-   be STMFD, but that's been moved into ffi_closure_SYSV.  If the\n-   writable page is put after this one we can make use of the\n-   pc+8 feature of the architecture.  We can also reduce the size\n-   of the thunk to 8 and pack more of these into the page.\n+/*\n+ * Below is the definition of the trampoline code table. Each element in\n+ * the code table is a trampoline.\n+ */\n+/*\n+ * The trampoline uses register ip (r12). It saves the original value of ip\n+ * on the stack.\n+ *\n+ * The trampoline has two parameters - target code to jump to and data for\n+ * the target code. The trampoline extracts the parameters from its parameter\n+ * block (see tramp_table_map()). The trampoline saves the data address on\n+ * the stack. Finally, it jumps to the target code.\n+ *\n+ * The target code can choose to:\n+ *\n+ * - restore the value of ip\n+ * - load the data address in a register\n+ * - restore the stack pointer to what it was when the trampoline was invoked.\n+ */\n+\t.align\tARM_TRAMP_MAP_SHIFT\n+ARM_FUNC_START(trampoline_code_table)\n+\t.rept\tARM_TRAMP_MAP_SIZE / ARM_TRAMP_SIZE\n+\tsub\tsp, sp, #8\t\t/* Make space on the stack */\n+\tstr\tip, [sp]\t\t/* Save ip on stack */\n+\tldr\tip, [pc, #4080]\t\t/* Copy data into ip */\n+\tstr\tip, [sp, #4]\t\t/* Save data on stack */\n+\tldr\tpc, [pc, #4076]\t\t/* Copy code into PC */\n+\t.endr\n+ARM_FUNC_END(trampoline_code_table)\n+\t.align\tARM_TRAMP_MAP_SHIFT\n+#endif /* FFI_EXEC_STATIC_TRAMP */\n+\n+#endif /* FFI_CLOSURES */\n+\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n \n-   In the meantime, simply replace the STMFD with a NOP so as to\n-   keep all the magic numbers the same within ffi.c.  */\n+#ifdef __MACH__\n+#include <mach/machine/vm_param.h>\n \n-\t.align\t12\n+.align\tPAGE_MAX_SHIFT\n ARM_FUNC_START(ffi_closure_trampoline_table_page)\n-.rept\t4096 / 12\n-\tnop\n-\tldr\tip, [pc, #-4092]\n-\tldr\tpc, [pc, #-4092]\n+.rept\tPAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE\n+\tadr ip, #-PAGE_MAX_SIZE   @ the config page is PAGE_MAX_SIZE behind the trampoline page\n+\tsub ip, #8\t\t\t\t  @ account for pc bias\n+\tldr\tpc, [ip, #4]\t\t  @ jump to ffi_closure_SYSV or ffi_closure_VFP\n .endr\n+ARM_FUNC_END(ffi_closure_trampoline_table_page)\n+#endif\n+\n+#elif defined(_WIN32)\n+\n+ARM_FUNC_START(ffi_arm_trampoline)\n+0:\tadr\tip, 0b\n+\tstmdb\tsp!, {r0, ip}\n+\tldr\tpc, 1f\n+1:\t.long\t0\n+ARM_FUNC_END(ffi_arm_trampoline)\n \n #else\n \n-ARM_FUNC_START(ffi_arm_trampoline, 1)\n+ARM_FUNC_START(ffi_arm_trampoline)\n 0:\tadr\tip, 0b\n \tldr\tpc, 1f\n 1:\t.long\t0\n ARM_FUNC_END(ffi_arm_trampoline)\n \n #endif /* FFI_EXEC_TRAMPOLINE_TABLE */\n+#endif /* __arm__ */\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",%progbits"}, {"sha": "5c99d0207af3174e8953527d9988a9d0406d434b", "filename": "libffi/src/arm/sysv_msvc_arm32.S", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fsysv_msvc_arm32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Farm%2Fsysv_msvc_arm32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv_msvc_arm32.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,311 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 1998, 2008, 2011 Red Hat, Inc.\n+        Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n+        Copyright (c) 2019 Microsoft Corporation.\n+\n+   ARM Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#include <ffi_cfi.h>\n+#include \"internal.h\"\n+#include \"ksarm.h\"\n+\n+\n+        ; 8 byte aligned AREA to support 8 byte aligned jump tables\n+        MACRO\n+        NESTED_ENTRY_FFI $FuncName, $AreaName, $ExceptHandler\n+\n+        ; compute the function's labels\n+        __DeriveFunctionLabels $FuncName\n+\n+        ; determine the area we will put the function into\n+__FuncArea   SETS    \"|.text|\"\n+        IF \"$AreaName\" != \"\"\n+__FuncArea   SETS    \"$AreaName\"\n+        ENDIF\n+\n+        ; set up the exception handler itself\n+__FuncExceptionHandler SETS \"\"\n+        IF \"$ExceptHandler\" != \"\"\n+__FuncExceptionHandler SETS    \"|$ExceptHandler|\"\n+        ENDIF\n+\n+        ; switch to the specified area, jump tables require 8 byte alignment\n+        AREA    $__FuncArea,CODE,CODEALIGN,ALIGN=3,READONLY\n+\n+        ; export the function name\n+        __ExportProc $FuncName\n+\n+        ; flush any pending literal pool stuff\n+        ROUT\n+\n+        ; reset the state of the unwind code tracking\n+        __ResetUnwindState\n+\n+        MEND\n+\n+;        MACRO\n+;        TABLE_ENTRY $Type, $Table\n+;$Type_$Table\n+;        MEND\n+\n+#define E(index,table) return_##index##_##table\n+\n+    ; r0:   stack\n+    ; r1:   frame\n+    ; r2:   fn\n+    ; r3:   vfp_used\n+\n+    ; fake entry point exists only to generate exists only to \n+    ; generate .pdata for exception unwinding\n+    NESTED_ENTRY_FFI ffi_call_VFP_fake\n+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind\n+\n+    ALTERNATE_ENTRY ffi_call_VFP\n+    cmp    r3, #3                   ; load only d0 if possible\n+    vldrle d0, [r0]\n+    vldmgt r0, {d0-d7}\n+    add    r0, r0, #64              ; discard the vfp register args\n+    b ffi_call_SYSV\n+    NESTED_END ffi_call_VFP_fake\n+\n+    ; fake entry point exists only to generate exists only to \n+    ; generate .pdata for exception unwinding\n+    NESTED_ENTRY_FFI ffi_call_SYSV_fake\n+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind\n+\n+    ALTERNATE_ENTRY ffi_call_SYSV\n+    stm    r1, {fp, lr}\n+    mov    fp, r1\n+\n+    mov    sp, r0                   ; install the stack pointer\n+    mov    lr, r2                   ; move the fn pointer out of the way\n+    ldr    ip, [fp, #16]            ; install the static chain\n+    ldmia  sp!, {r0-r3}             ; move first 4 parameters in registers.\n+    blx    lr                       ; call fn\n+\n+    ; Load r2 with the pointer to storage for the return value\n+    ; Load r3 with the return type code\n+    ldr    r2, [fp, #8]\n+    ldr    r3, [fp, #12]\n+\n+    ; Deallocate the stack with the arguments.\n+    mov    sp, fp\n+\n+    ; Store values stored in registers.\n+    ALIGN 8\n+    lsl     r3, #3\n+    add     r3, r3, pc\n+    add     r3, #8\n+    mov     pc, r3\n+\n+\n+E(ARM_TYPE_VFP_S, ffi_call)\n+    ALIGN 8\n+    vstr s0, [r2]\n+    pop    {fp,pc}\n+E(ARM_TYPE_VFP_D, ffi_call)\n+    ALIGN 8\n+    vstr d0, [r2]\n+    pop    {fp,pc}\n+E(ARM_TYPE_VFP_N, ffi_call)\n+    ALIGN 8\n+    vstm r2, {d0-d3}\n+    pop    {fp,pc}\n+E(ARM_TYPE_INT64, ffi_call)\n+    ALIGN 8\n+    str    r1, [r2, #4]\n+    nop\n+E(ARM_TYPE_INT, ffi_call)\n+    ALIGN 8\n+    str    r0, [r2]\n+    pop    {fp,pc}\n+E(ARM_TYPE_VOID, ffi_call)\n+    ALIGN 8\n+    pop    {fp,pc}\n+    nop\n+E(ARM_TYPE_STRUCT, ffi_call)\n+    ALIGN 8\n+    cmp r3, #ARM_TYPE_STRUCT\n+    pop    {fp,pc}\n+    NESTED_END ffi_call_SYSV_fake\n+\n+    IMPORT |ffi_closure_inner_SYSV|\n+    /*\n+    int ffi_closure_inner_SYSV\n+    (\n+        cif,        ; r0\n+        fun,        ; r1\n+        user_data,  ; r2\n+        frame       ; r3\n+    )\n+    */\n+\n+    NESTED_ENTRY_FFI ffi_go_closure_SYSV\n+    stmdb   sp!, {r0-r3}            ; save argument regs\n+    ldr     r0, [ip, #4]            ; load cif\n+    ldr     r1, [ip, #8]            ; load fun\n+    mov     r2, ip                  ; load user_data\n+    b       ffi_go_closure_SYSV_0\n+    NESTED_END ffi_go_closure_SYSV\n+\n+    ; r3:    ffi_closure\n+\n+    ; fake entry point exists only to generate exists only to \n+    ; generate .pdata for exception unwinding\n+    NESTED_ENTRY_FFI ffi_closure_SYSV_fake  \n+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind\n+    ALTERNATE_ENTRY ffi_closure_SYSV\n+    ldmfd   sp!, {ip,r0}            ; restore fp (r0 is used for stack alignment)\n+    stmdb   sp!, {r0-r3}            ; save argument regs\n+\n+    ldr     r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]    ; ffi_closure->cif\n+    ldr     r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  ; ffi_closure->fun\n+    ldr     r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  ; ffi_closure->user_data\n+\n+    ALTERNATE_ENTRY ffi_go_closure_SYSV_0\n+    add     ip, sp, #16             ; compute entry sp\n+\n+    sub     sp, sp, #64+32          ; allocate frame parameter (sizeof(vfp_space) = 64, sizeof(result) = 32)\n+    mov     r3, sp                  ; set frame parameter\n+    stmdb   sp!, {ip,lr}\n+\n+    bl      ffi_closure_inner_SYSV  ; call the Python closure\n+\n+                                    ; Load values returned in registers.\n+    add     r2, sp, #64+8           ; address of closure_frame->result\n+    bl      ffi_closure_ret         ; move result to correct register or memory for type\n+\n+    ldmfd   sp!, {ip,lr}\n+    mov     sp, ip                  ; restore stack pointer\n+    mov     pc, lr\n+    NESTED_END ffi_closure_SYSV_fake\n+\n+    IMPORT |ffi_closure_inner_VFP|\n+    /*\n+    int ffi_closure_inner_VFP\n+    (\n+        cif,        ; r0\n+        fun,        ; r1\n+        user_data,  ; r2\n+        frame       ; r3\n+    )\n+    */\n+\n+    NESTED_ENTRY_FFI ffi_go_closure_VFP\n+    stmdb   sp!, {r0-r3}\t\t\t; save argument regs\n+    ldr\tr0, [ip, #4]\t\t\t; load cif\n+    ldr\tr1, [ip, #8]\t\t\t; load fun\n+    mov\tr2, ip\t\t\t\t; load user_data\n+    b\tffi_go_closure_VFP_0\n+    NESTED_END ffi_go_closure_VFP\n+\n+    ; fake entry point exists only to generate exists only to \n+    ; generate .pdata for exception unwinding\n+    ; r3:    closure\n+    NESTED_ENTRY_FFI ffi_closure_VFP_fake\n+    PROLOG_PUSH  {r11, lr}          ; save fp and lr for unwind\n+\n+    ALTERNATE_ENTRY ffi_closure_VFP\n+    ldmfd   sp!, {ip,r0}            ; restore fp (r0 is used for stack alignment)\n+    stmdb   sp!, {r0-r3}            ; save argument regs\n+\n+    ldr     r0, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET]    ; load cif\n+    ldr     r1, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+4]  ; load fun\n+    ldr     r2, [ip, #FFI_TRAMPOLINE_CLOSURE_OFFSET+8]  ; load user_data\n+\n+    ALTERNATE_ENTRY ffi_go_closure_VFP_0\n+    add     ip, sp, #16             ; compute entry sp\n+    sub     sp, sp, #32             ; save space for closure_frame->result\n+    vstmdb  sp!, {d0-d7}            ; push closure_frame->vfp_space\n+\n+    mov     r3, sp                  ; save closure_frame\n+    stmdb   sp!, {ip,lr}\n+\n+    bl      ffi_closure_inner_VFP\n+\n+    ; Load values returned in registers.\n+    add     r2, sp, #64+8           ; load result\n+    bl      ffi_closure_ret\n+    ldmfd   sp!, {ip,lr}\n+    mov     sp, ip                  ; restore stack pointer\n+    mov     pc, lr\n+    NESTED_END ffi_closure_VFP_fake\n+\n+/* Load values returned in registers for both closure entry points.\n+   Note that we use LDM with SP in the register set.  This is deprecated\n+   by ARM, but not yet unpredictable.  */\n+\n+    NESTED_ENTRY_FFI ffi_closure_ret\n+    stmdb sp!, {fp,lr}\n+\n+    ALIGN 8\n+    lsl     r0, #3\n+    add     r0, r0, pc\n+    add     r0, #8\n+    mov     pc, r0\n+\n+E(ARM_TYPE_VFP_S, ffi_closure)\n+    ALIGN 8\n+    vldr s0, [r2]\n+    b call_epilogue\n+E(ARM_TYPE_VFP_D, ffi_closure)\n+    ALIGN 8\n+    vldr d0, [r2]\n+    b call_epilogue\n+E(ARM_TYPE_VFP_N, ffi_closure)\n+    ALIGN 8\n+    vldm r2, {d0-d3}\n+    b call_epilogue\n+E(ARM_TYPE_INT64, ffi_closure)\n+    ALIGN 8\n+    ldr    r1, [r2, #4]\n+    nop\n+E(ARM_TYPE_INT, ffi_closure)\n+    ALIGN 8\n+    ldr    r0, [r2]\n+    b call_epilogue\n+E(ARM_TYPE_VOID, ffi_closure)\n+    ALIGN 8\n+    b call_epilogue\n+    nop\n+E(ARM_TYPE_STRUCT, ffi_closure)\n+    ALIGN 8\n+    b call_epilogue\n+call_epilogue\n+    ldmfd sp!, {fp,pc}\n+    NESTED_END ffi_closure_ret\n+\n+    AREA |.trampoline|, DATA, THUMB, READONLY\n+    EXPORT |ffi_arm_trampoline|\n+|ffi_arm_trampoline| DATA\n+thisproc    adr    ip, thisproc\n+            stmdb  sp!, {ip, r0}\n+            ldr    pc, [pc, #0]\n+            DCD    0\n+            ;ENDP\n+\n+    END\n\\ No newline at end of file"}, {"sha": "f7bead67b54ebc08f99d07505374693f34624916", "filename": "libffi/src/closures.c", "status": "modified", "additions": 435, "deletions": 54, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n-   closures.c - Copyright (c) 2007, 2009, 2010  Red Hat, Inc.\n+   closures.c - Copyright (c) 2019 Anthony Green\n+                Copyright (c) 2007, 2009, 2010 Red Hat, Inc.\n                 Copyright (C) 2007, 2009, 2010 Free Software Foundation, Inc\n                 Copyright (c) 2011 Plausible Labs Cooperative, Inc.\n \n@@ -30,11 +31,98 @@\n #define _GNU_SOURCE 1\n #endif\n \n+#include <fficonfig.h>\n #include <ffi.h>\n #include <ffi_common.h>\n+#include <tramp.h>\n+\n+#ifdef __NetBSD__\n+#include <sys/param.h>\n+#endif\n+\n+#if __NetBSD_Version__ - 0 >= 799007200\n+/* NetBSD with PROT_MPROTECT */\n+#include <sys/mman.h>\n+\n+#include <stddef.h>\n+#include <unistd.h>\n+#ifdef  HAVE_SYS_MEMFD_H\n+#include <sys/memfd.h>\n+#endif\n+\n+static const size_t overhead =\n+  (sizeof(max_align_t) > sizeof(void *) + sizeof(size_t)) ?\n+    sizeof(max_align_t)\n+    : sizeof(void *) + sizeof(size_t);\n+\n+#define ADD_TO_POINTER(p, d) ((void *)((uintptr_t)(p) + (d)))\n+\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  static size_t page_size;\n+  size_t rounded_size;\n+  void *codeseg, *dataseg;\n+  int prot;\n+\n+  /* Expect that PAX mprotect is active and a separate code mapping is necessary. */\n+  if (!code)\n+    return NULL;\n+\n+  /* Obtain system page size. */\n+  if (!page_size)\n+    page_size = sysconf(_SC_PAGESIZE);\n+\n+  /* Round allocation size up to the next page, keeping in mind the size field and pointer to code map. */\n+  rounded_size = (size + overhead + page_size - 1) & ~(page_size - 1);\n+\n+  /* Primary mapping is RW, but request permission to switch to PROT_EXEC later. */\n+  prot = PROT_READ | PROT_WRITE | PROT_MPROTECT(PROT_EXEC);\n+  dataseg = mmap(NULL, rounded_size, prot, MAP_ANON | MAP_PRIVATE, -1, 0);\n+  if (dataseg == MAP_FAILED)\n+    return NULL;\n+\n+  /* Create secondary mapping and switch it to RX. */\n+  codeseg = mremap(dataseg, rounded_size, NULL, rounded_size, MAP_REMAPDUP);\n+  if (codeseg == MAP_FAILED) {\n+    munmap(dataseg, rounded_size);\n+    return NULL;\n+  }\n+  if (mprotect(codeseg, rounded_size, PROT_READ | PROT_EXEC) == -1) {\n+    munmap(codeseg, rounded_size);\n+    munmap(dataseg, rounded_size);\n+    return NULL;\n+  }\n+\n+  /* Remember allocation size and location of the secondary mapping for ffi_closure_free. */\n+  memcpy(dataseg, &rounded_size, sizeof(rounded_size));\n+  memcpy(ADD_TO_POINTER(dataseg, sizeof(size_t)), &codeseg, sizeof(void *));\n+  *code = ADD_TO_POINTER(codeseg, overhead);\n+  return ADD_TO_POINTER(dataseg, overhead);\n+}\n+\n+void\n+ffi_closure_free (void *ptr)\n+{\n+  void *codeseg, *dataseg;\n+  size_t rounded_size;\n+\n+  dataseg = ADD_TO_POINTER(ptr, -overhead);\n+  memcpy(&rounded_size, dataseg, sizeof(rounded_size));\n+  memcpy(&codeseg, ADD_TO_POINTER(dataseg, sizeof(size_t)), sizeof(void *));\n+  munmap(dataseg, rounded_size);\n+  munmap(codeseg, rounded_size);\n+}\n+\n+int\n+ffi_tramp_is_present (__attribute__((unused)) void *ptr)\n+{\n+  return 0;\n+}\n+#else /* !NetBSD with PROT_MPROTECT */\n \n #if !FFI_MMAP_EXEC_WRIT && !FFI_EXEC_TRAMPOLINE_TABLE\n-# if __gnu_linux__ && !defined(__ANDROID__)\n+# if __linux__ && !defined(__ANDROID__)\n /* This macro indicates it may be forbidden to map anonymous memory\n    with both write and execute permission.  Code compiled when this\n    option is defined will attempt to map such pages once, but if it\n@@ -45,7 +133,7 @@\n #  define FFI_MMAP_EXEC_WRIT 1\n #  define HAVE_MNTENT 1\n # endif\n-# if defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)\n+# if defined(_WIN32) || defined(__OS2__)\n /* Windows systems may have Data Execution Protection (DEP) enabled, \n    which requires the use of VirtualMalloc/VirtualFree to alloc/free\n    executable memory. */\n@@ -54,7 +142,7 @@\n #endif\n \n #if FFI_MMAP_EXEC_WRIT && !defined FFI_MMAP_EXEC_SELINUX\n-# ifdef __linux__\n+# if defined(__linux__) && !defined(__ANDROID__)\n /* When defined to 1 check for SELinux and if SELinux is active,\n    don't attempt PROT_EXEC|PROT_WRITE mapping at all, as that\n    might cause audit messages.  */\n@@ -64,11 +152,226 @@\n \n #if FFI_CLOSURES\n \n-# if FFI_EXEC_TRAMPOLINE_TABLE\n+#if FFI_EXEC_TRAMPOLINE_TABLE\n+\n+#ifdef __MACH__\n+\n+#include <mach/mach.h>\n+#include <pthread.h>\n+#ifdef HAVE_PTRAUTH\n+#include <ptrauth.h>\n+#endif\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern void *ffi_closure_trampoline_table_page;\n+\n+typedef struct ffi_trampoline_table ffi_trampoline_table;\n+typedef struct ffi_trampoline_table_entry ffi_trampoline_table_entry;\n+\n+struct ffi_trampoline_table\n+{\n+  /* contiguous writable and executable pages */\n+  vm_address_t config_page;\n+\n+  /* free list tracking */\n+  uint16_t free_count;\n+  ffi_trampoline_table_entry *free_list;\n+  ffi_trampoline_table_entry *free_list_pool;\n+\n+  ffi_trampoline_table *prev;\n+  ffi_trampoline_table *next;\n+};\n+\n+struct ffi_trampoline_table_entry\n+{\n+  void *(*trampoline) (void);\n+  ffi_trampoline_table_entry *next;\n+};\n+\n+/* Total number of trampolines that fit in one trampoline table */\n+#define FFI_TRAMPOLINE_COUNT (PAGE_MAX_SIZE / FFI_TRAMPOLINE_SIZE)\n+\n+static pthread_mutex_t ffi_trampoline_lock = PTHREAD_MUTEX_INITIALIZER;\n+static ffi_trampoline_table *ffi_trampoline_tables = NULL;\n+\n+static ffi_trampoline_table *\n+ffi_trampoline_table_alloc (void)\n+{\n+  ffi_trampoline_table *table;\n+  vm_address_t config_page;\n+  vm_address_t trampoline_page;\n+  vm_address_t trampoline_page_template;\n+  vm_prot_t cur_prot;\n+  vm_prot_t max_prot;\n+  kern_return_t kt;\n+  uint16_t i;\n+\n+  /* Allocate two pages -- a config page and a placeholder page */\n+  config_page = 0x0;\n+  kt = vm_allocate (mach_task_self (), &config_page, PAGE_MAX_SIZE * 2,\n+\t\t    VM_FLAGS_ANYWHERE);\n+  if (kt != KERN_SUCCESS)\n+    return NULL;\n+\n+  /* Remap the trampoline table on top of the placeholder page */\n+  trampoline_page = config_page + PAGE_MAX_SIZE;\n+\n+#ifdef HAVE_PTRAUTH\n+  trampoline_page_template = (vm_address_t)(uintptr_t)ptrauth_auth_data((void *)&ffi_closure_trampoline_table_page, ptrauth_key_function_pointer, 0);\n+#else\n+  trampoline_page_template = (vm_address_t)&ffi_closure_trampoline_table_page;\n+#endif\n+\n+#ifdef __arm__\n+  /* ffi_closure_trampoline_table_page can be thumb-biased on some ARM archs */\n+  trampoline_page_template &= ~1UL;\n+#endif\n+  kt = vm_remap (mach_task_self (), &trampoline_page, PAGE_MAX_SIZE, 0x0,\n+\t\t VM_FLAGS_OVERWRITE, mach_task_self (), trampoline_page_template,\n+\t\t FALSE, &cur_prot, &max_prot, VM_INHERIT_SHARE);\n+  if (kt != KERN_SUCCESS || !(cur_prot & VM_PROT_EXECUTE))\n+    {\n+      vm_deallocate (mach_task_self (), config_page, PAGE_MAX_SIZE * 2);\n+      return NULL;\n+    }\n+\n+  /* We have valid trampoline and config pages */\n+  table = calloc (1, sizeof (ffi_trampoline_table));\n+  table->free_count = FFI_TRAMPOLINE_COUNT;\n+  table->config_page = config_page;\n+\n+  /* Create and initialize the free list */\n+  table->free_list_pool =\n+    calloc (FFI_TRAMPOLINE_COUNT, sizeof (ffi_trampoline_table_entry));\n+\n+  for (i = 0; i < table->free_count; i++)\n+    {\n+      ffi_trampoline_table_entry *entry = &table->free_list_pool[i];\n+      entry->trampoline =\n+\t(void *) (trampoline_page + (i * FFI_TRAMPOLINE_SIZE));\n+#ifdef HAVE_PTRAUTH\n+      entry->trampoline = ptrauth_sign_unauthenticated(entry->trampoline, ptrauth_key_function_pointer, 0);\n+#endif\n+\n+      if (i < table->free_count - 1)\n+\tentry->next = &table->free_list_pool[i + 1];\n+    }\n+\n+  table->free_list = table->free_list_pool;\n+\n+  return table;\n+}\n+\n+static void\n+ffi_trampoline_table_free (ffi_trampoline_table *table)\n+{\n+  /* Remove from the list */\n+  if (table->prev != NULL)\n+    table->prev->next = table->next;\n+\n+  if (table->next != NULL)\n+    table->next->prev = table->prev;\n+\n+  /* Deallocate pages */\n+  vm_deallocate (mach_task_self (), table->config_page, PAGE_MAX_SIZE * 2);\n+\n+  /* Deallocate free list */\n+  free (table->free_list_pool);\n+  free (table);\n+}\n+\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  /* Create the closure */\n+  ffi_closure *closure = malloc (size);\n+  if (closure == NULL)\n+    return NULL;\n+\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n+\n+  /* Check for an active trampoline table with available entries. */\n+  ffi_trampoline_table *table = ffi_trampoline_tables;\n+  if (table == NULL || table->free_list == NULL)\n+    {\n+      table = ffi_trampoline_table_alloc ();\n+      if (table == NULL)\n+\t{\n+\t  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\t  free (closure);\n+\t  return NULL;\n+\t}\n+\n+      /* Insert the new table at the top of the list */\n+      table->next = ffi_trampoline_tables;\n+      if (table->next != NULL)\n+\ttable->next->prev = table;\n+\n+      ffi_trampoline_tables = table;\n+    }\n+\n+  /* Claim the free entry */\n+  ffi_trampoline_table_entry *entry = ffi_trampoline_tables->free_list;\n+  ffi_trampoline_tables->free_list = entry->next;\n+  ffi_trampoline_tables->free_count--;\n+  entry->next = NULL;\n+\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\n+  /* Initialize the return values */\n+  *code = entry->trampoline;\n+  closure->trampoline_table = table;\n+  closure->trampoline_table_entry = entry;\n+\n+  return closure;\n+}\n+\n+void\n+ffi_closure_free (void *ptr)\n+{\n+  ffi_closure *closure = ptr;\n+\n+  pthread_mutex_lock (&ffi_trampoline_lock);\n+\n+  /* Fetch the table and entry references */\n+  ffi_trampoline_table *table = closure->trampoline_table;\n+  ffi_trampoline_table_entry *entry = closure->trampoline_table_entry;\n+\n+  /* Return the entry to the free list */\n+  entry->next = table->free_list;\n+  table->free_list = entry;\n+  table->free_count++;\n+\n+  /* If all trampolines within this table are free, and at least one other table exists, deallocate\n+   * the table */\n+  if (table->free_count == FFI_TRAMPOLINE_COUNT\n+      && ffi_trampoline_tables != table)\n+    {\n+      ffi_trampoline_table_free (table);\n+    }\n+  else if (ffi_trampoline_tables != table)\n+    {\n+      /* Otherwise, bump this table to the top of the list */\n+      table->prev = NULL;\n+      table->next = ffi_trampoline_tables;\n+      if (ffi_trampoline_tables != NULL)\n+\tffi_trampoline_tables->prev = table;\n+\n+      ffi_trampoline_tables = table;\n+    }\n+\n+  pthread_mutex_unlock (&ffi_trampoline_lock);\n+\n+  /* Free the closure */\n+  free (closure);\n+}\n+\n+#endif\n \n // Per-target implementation; It's unclear what can reasonable be shared between two OS/architecture implementations.\n \n-# elif FFI_MMAP_EXEC_WRIT /* !FFI_EXEC_TRAMPOLINE_TABLE */\n+#elif FFI_MMAP_EXEC_WRIT /* !FFI_EXEC_TRAMPOLINE_TABLE */\n \n #define USE_LOCKS 1\n #define USE_DL_PREFIX 1\n@@ -94,14 +397,6 @@\n /* Don't allocate more than a page unless needed.  */\n #define DEFAULT_GRANULARITY ((size_t)malloc_getpagesize)\n \n-#if FFI_CLOSURE_TEST\n-/* Don't release single pages, to avoid a worst-case scenario of\n-   continuously allocating and releasing single pages, but release\n-   pairs of pages, which should do just as well given that allocations\n-   are likely to be small.  */\n-#define DEFAULT_TRIM_THRESHOLD ((size_t)malloc_getpagesize)\n-#endif\n-\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <fcntl.h>\n@@ -111,7 +406,7 @@\n #endif\n #include <string.h>\n #include <stdio.h>\n-#if !defined(X86_WIN32) && !defined(X86_WIN64)\n+#if !defined(_WIN32)\n #ifdef HAVE_MNTENT\n #include <mntent.h>\n #endif /* HAVE_MNTENT */\n@@ -237,11 +532,11 @@ static int dlmalloc_trim(size_t) MAYBE_UNUSED;\n static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;\n static void dlmalloc_stats(void) MAYBE_UNUSED;\n \n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n /* Use these for mmap and munmap within dlmalloc.c.  */\n static void *dlmmap(void *, size_t, int, int, int, off_t);\n static int dlmunmap(void *, size_t);\n-#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n+#endif /* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n \n #define mmap dlmmap\n #define munmap dlmunmap\n@@ -251,7 +546,7 @@ static int dlmunmap(void *, size_t);\n #undef mmap\n #undef munmap\n \n-#if !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n+#if !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX)\n \n /* A mutex used to synchronize access to *exec* variables in this file.  */\n static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;\n@@ -263,6 +558,17 @@ static int execfd = -1;\n /* The amount of space already allocated from the temporary file.  */\n static size_t execsize = 0;\n \n+#ifdef HAVE_MEMFD_CREATE\n+/* Open a temporary file name, and immediately unlink it.  */\n+static int\n+open_temp_exec_file_memfd (const char *name)\n+{\n+  int fd;\n+  fd = memfd_create (name, MFD_CLOEXEC);\n+  return fd;\n+}\n+#endif\n+\n /* Open a temporary file name, and immediately unlink it.  */\n static int\n open_temp_exec_file_name (char *name, int flags)\n@@ -308,7 +614,7 @@ open_temp_exec_file_dir (const char *dir)\n   }\n #endif\n \n-  lendir = strlen (dir);\n+  lendir = (int) strlen (dir);\n   tempname = __builtin_alloca (lendir + sizeof (suffix));\n \n   if (!tempname)\n@@ -390,6 +696,10 @@ static struct\n   const char *arg;\n   int repeat;\n } open_temp_exec_file_opts[] = {\n+#ifdef HAVE_MEMFD_CREATE\n+  { open_temp_exec_file_memfd, \"libffi\", 0 },\n+#endif\n+  { open_temp_exec_file_env, \"LIBFFI_TMPDIR\", 0 },\n   { open_temp_exec_file_env, \"TMPDIR\", 0 },\n   { open_temp_exec_file_dir, \"/tmp\", 0 },\n   { open_temp_exec_file_dir, \"/var/tmp\", 0 },\n@@ -449,6 +759,36 @@ open_temp_exec_file (void)\n   return fd;\n }\n \n+/* We need to allocate space in a file that will be backing a writable\n+   mapping.  Several problems exist with the usual approaches:\n+   - fallocate() is Linux-only\n+   - posix_fallocate() is not available on all platforms\n+   - ftruncate() does not allocate space on filesystems with sparse files\n+   Failure to allocate the space will cause SIGBUS to be thrown when\n+   the mapping is subsequently written to.  */\n+static int\n+allocate_space (int fd, off_t offset, off_t len)\n+{\n+  static size_t page_size;\n+\n+  /* Obtain system page size. */\n+  if (!page_size)\n+    page_size = sysconf(_SC_PAGESIZE);\n+\n+  unsigned char buf[page_size];\n+  memset (buf, 0, page_size);\n+\n+  while (len > 0)\n+    {\n+      off_t to_write = (len < page_size) ? len : page_size;\n+      if (write (fd, buf, to_write) < to_write)\n+        return -1;\n+      len -= to_write;\n+    }\n+\n+  return 0;\n+}\n+\n /* Map in a chunk of memory from the temporary exec file into separate\n    locations in the virtual memory address space, one writable and one\n    executable.  Returns the address of the writable portion, after\n@@ -470,7 +810,7 @@ dlmmap_locked (void *start, size_t length, int prot, int flags, off_t offset)\n \n   offset = execsize;\n \n-  if (ftruncate (execfd, offset + length))\n+  if (allocate_space (execfd, offset, length))\n     return MFAIL;\n \n   flags &= ~(MAP_PRIVATE | MAP_ANONYMOUS);\n@@ -485,7 +825,13 @@ dlmmap_locked (void *start, size_t length, int prot, int flags, off_t offset)\n \t  close (execfd);\n \t  goto retry_open;\n \t}\n-      ftruncate (execfd, offset);\n+      if (ftruncate (execfd, offset) != 0)\n+      {\n+        /* Fixme : Error logs can be added here. Returning an error for\n+         * ftruncte() will not add any advantage as it is being\n+         * validating in the error case. */\n+      }\n+\n       return MFAIL;\n     }\n   else if (!offset\n@@ -497,7 +843,12 @@ dlmmap_locked (void *start, size_t length, int prot, int flags, off_t offset)\n   if (start == MFAIL)\n     {\n       munmap (ptr, length);\n-      ftruncate (execfd, offset);\n+      if (ftruncate (execfd, offset) != 0)\n+      {\n+        /* Fixme : Error logs can be added here. Returning an error for\n+         * ftruncte() will not add any advantage as it is being\n+         * validating in the error case. */\n+      }\n       return start;\n     }\n \n@@ -521,9 +872,11 @@ dlmmap (void *start, size_t length, int prot,\n \t  && flags == (MAP_PRIVATE | MAP_ANONYMOUS)\n \t  && fd == -1 && offset == 0);\n \n-#if FFI_CLOSURE_TEST\n-  printf (\"mapping in %zi\\n\", length);\n-#endif\n+  if (execfd == -1 && ffi_tramp_is_supported ())\n+    {\n+      ptr = mmap (start, length, prot & ~PROT_EXEC, flags, fd, offset);\n+      return ptr;\n+    }\n \n   if (execfd == -1 && is_emutramp_enabled ())\n     {\n@@ -570,10 +923,6 @@ dlmunmap (void *start, size_t length)\n   msegmentptr seg = segment_holding (gm, start);\n   void *code;\n \n-#if FFI_CLOSURE_TEST\n-  printf (\"unmapping %zi\\n\", length);\n-#endif\n-\n   if (seg && (code = add_segment_exec_offset (start, seg)) != start)\n     {\n       int ret = munmap (code, length);\n@@ -600,31 +949,60 @@ segment_holding_code (mstate m, char* addr)\n }\n #endif\n \n-#endif /* !(defined(X86_WIN32) || defined(X86_WIN64) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n+#endif /* !(defined(_WIN32) || defined(__OS2__)) || defined (__CYGWIN__) || defined(__INTERIX) */\n \n /* Allocate a chunk of memory with the given size.  Returns a pointer\n    to the writable address, and sets *CODE to the executable\n    corresponding virtual address.  */\n void *\n ffi_closure_alloc (size_t size, void **code)\n {\n-  void *ptr;\n+  void *ptr, *ftramp;\n \n   if (!code)\n     return NULL;\n \n-  ptr = dlmalloc (size);\n+  ptr = FFI_CLOSURE_PTR (dlmalloc (size));\n \n   if (ptr)\n     {\n       msegmentptr seg = segment_holding (gm, ptr);\n \n       *code = add_segment_exec_offset (ptr, seg);\n+      if (!ffi_tramp_is_supported ())\n+        return ptr;\n+\n+      ftramp = ffi_tramp_alloc (0);\n+      if (ftramp == NULL)\n+      {\n+        dlfree (FFI_RESTORE_PTR (ptr));\n+        return NULL;\n+      }\n+      *code = ffi_tramp_get_addr (ftramp);\n+      ((ffi_closure *) ptr)->ftramp = ftramp;\n     }\n \n   return ptr;\n }\n \n+void *\n+ffi_data_to_code_pointer (void *data)\n+{\n+  msegmentptr seg = segment_holding (gm, data);\n+  /* We expect closures to be allocated with ffi_closure_alloc(), in\n+     which case seg will be non-NULL.  However, some users take on the\n+     burden of managing this memory themselves, in which case this\n+     we'll just return data. */\n+  if (seg)\n+    {\n+      if (!ffi_tramp_is_supported ())\n+        return add_segment_exec_offset (data, seg);\n+      return ffi_tramp_get_addr (((ffi_closure *) data)->ftramp);\n+    }\n+  else\n+    return data;\n+}\n+\n /* Release a chunk of memory allocated with ffi_closure_alloc.  If\n    FFI_CLOSURE_FREE_CODE is nonzero, the given address can be the\n    writable or the executable address given.  Otherwise, only the\n@@ -638,30 +1016,19 @@ ffi_closure_free (void *ptr)\n   if (seg)\n     ptr = sub_segment_exec_offset (ptr, seg);\n #endif\n+  if (ffi_tramp_is_supported ())\n+    ffi_tramp_free (((ffi_closure *) ptr)->ftramp);\n \n-  dlfree (ptr);\n+  dlfree (FFI_RESTORE_PTR (ptr));\n }\n \n-\n-#if FFI_CLOSURE_TEST\n-/* Do some internal sanity testing to make sure allocation and\n-   deallocation of pages are working as intended.  */\n-int main ()\n-{\n-  void *p[3];\n-#define GET(idx, len) do { p[idx] = dlmalloc (len); printf (\"allocated %zi for p[%i]\\n\", (len), (idx)); } while (0)\n-#define PUT(idx) do { printf (\"freeing p[%i]\\n\", (idx)); dlfree (p[idx]); } while (0)\n-  GET (0, malloc_getpagesize / 2);\n-  GET (1, 2 * malloc_getpagesize - 64 * sizeof (void*));\n-  PUT (1);\n-  GET (1, 2 * malloc_getpagesize);\n-  GET (2, malloc_getpagesize / 2);\n-  PUT (1);\n-  PUT (0);\n-  PUT (2);\n-  return 0;\n+int\n+ffi_tramp_is_present (void *ptr)\n+{\n+  msegmentptr seg = segment_holding (gm, ptr);\n+  return seg != NULL && ffi_tramp_is_supported();\n }\n-#endif /* FFI_CLOSURE_TEST */\n+\n # else /* ! FFI_MMAP_EXEC_WRIT */\n \n /* On many systems, memory returned by malloc is writable and\n@@ -675,14 +1042,28 @@ ffi_closure_alloc (size_t size, void **code)\n   if (!code)\n     return NULL;\n \n-  return *code = malloc (size);\n+  return *code = FFI_CLOSURE_PTR (malloc (size));\n }\n \n void\n ffi_closure_free (void *ptr)\n {\n-  free (ptr);\n+  free (FFI_RESTORE_PTR (ptr));\n+}\n+\n+void *\n+ffi_data_to_code_pointer (void *data)\n+{\n+  return data;\n+}\n+\n+int\n+ffi_tramp_is_present (__attribute__((unused)) void *ptr)\n+{\n+  return 0;\n }\n \n # endif /* ! FFI_MMAP_EXEC_WRIT */\n #endif /* FFI_CLOSURES */\n+\n+#endif /* NetBSD with PROT_MPROTECT */"}, {"sha": "9011fdec03a877521536ac8c2a64d0afe60d0816", "filename": "libffi/src/cris/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcris%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcris%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcris%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -29,7 +29,7 @@\n #include <ffi.h>\n #include <ffi_common.h>\n \n-#define STACK_ARG_SIZE(x) ALIGN(x, FFI_SIZEOF_ARG)\n+#define STACK_ARG_SIZE(x) FFI_ALIGN(x, FFI_SIZEOF_ARG)\n \n static ffi_status\n initialize_aggregate_packed_struct (ffi_type * arg)\n@@ -190,7 +190,7 @@ ffi_prep_cif_core (ffi_cif * cif,\n       FFI_ASSERT_VALID_TYPE (*ptr);\n \n       if (((*ptr)->alignment - 1) & bytes)\n-\tbytes = ALIGN (bytes, (*ptr)->alignment);\n+\tbytes = FFI_ALIGN (bytes, (*ptr)->alignment);\n       if ((*ptr)->type == FFI_TYPE_STRUCT)\n \t{\n \t  if ((*ptr)->size > 8)"}, {"sha": "af50b7c648dfe1d68f6866d3b6891c7c2628b1cf", "filename": "libffi/src/csky/ffi.c", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcsky%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,395 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c\n+\n+   CSKY Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments\n+*/\n+void ffi_prep_args(char *stack, extended_cif *ecif)\n+{\n+ register unsigned int i;\n+ register void **p_argv;\n+ register char *argp;\n+ register ffi_type **p_arg;\n+\n+ argp = stack;\n+\n+ if ( ecif->cif->flags == FFI_TYPE_STRUCT ) {\n+  *(void **) argp = ecif->rvalue;\n+  argp += 4;\n+ }\n+\n+ p_argv = ecif->avalue;\n+\n+ for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n+   (i != 0);\n+   i--, p_arg++)\n+ {\n+  size_t z;\n+  size_t alignment;\n+\n+  /* Align if necessary */\n+  alignment = (*p_arg)->alignment;\n+#ifdef __CSKYABIV1__\n+  /*\n+   * Adapt ABIV1 bug.\n+   * If struct's size is larger than 8 bytes, then it always alignment as 4 bytes.\n+   */\n+  if (((*p_arg)->type == FFI_TYPE_STRUCT) && ((*p_arg)->size > 8) && (alignment == 8)) {\n+   alignment = 4;\n+  }\n+#endif\n+\n+  if ((alignment - 1) & (unsigned) argp) {\n+   argp = (char *) FFI_ALIGN(argp, alignment);\n+  }\n+\n+  if ((*p_arg)->type == FFI_TYPE_STRUCT)\n+   argp = (char *) FFI_ALIGN(argp, 4);\n+\n+  z = (*p_arg)->size;\n+  if (z < sizeof(int))\n+  {\n+   z = sizeof(int);\n+   switch ((*p_arg)->type)\n+   {\n+   case FFI_TYPE_SINT8:\n+    *(signed int *) argp = (signed int)*(SINT8 *)(* p_argv);\n+    break;\n+\n+   case FFI_TYPE_UINT8:\n+    *(unsigned int *) argp = (unsigned int)*(UINT8 *)(* p_argv);\n+    break;\n+\n+   case FFI_TYPE_SINT16:\n+    *(signed int *) argp = (signed int)*(SINT16 *)(* p_argv);\n+    break;\n+\n+   case FFI_TYPE_UINT16:\n+    *(unsigned int *) argp = (unsigned int)*(UINT16 *)(* p_argv);\n+    break;\n+\n+   case FFI_TYPE_STRUCT:\n+#ifdef __CSKYBE__\n+    memcpy((argp + 4 - (*p_arg)->size), *p_argv, (*p_arg)->size);\n+#else\n+    memcpy(argp, *p_argv, (*p_arg)->size);\n+#endif\n+    break;\n+\n+   default:\n+    FFI_ASSERT(0);\n+   }\n+  }\n+  else if (z == sizeof(int))\n+  {\n+   *(unsigned int *) argp = (unsigned int)*(UINT32 *)(* p_argv);\n+  }\n+  else\n+  {\n+   memcpy(argp, *p_argv, z);\n+  }\n+  p_argv++;\n+  argp += z;\n+ }\n+\n+ return;\n+}\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  /* Round the stack up to a multiple of 8 bytes.  This isn't needed\n+     everywhere, but it is on some platforms, and it doesn't hcsky anything\n+     when it isn't needed.  */\n+  cif->bytes = (cif->bytes + 7) & ~7;\n+\n+  /* Set the return type flag */\n+  switch (cif->rtype->type)\n+    {\n+\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      cif->flags = (unsigned) FFI_TYPE_SINT64;\n+      break;\n+\n+    case FFI_TYPE_STRUCT:\n+      if (cif->rtype->size <= 4)\n+ /* A Composite Type not larger than 4 bytes is returned in r0.  */\n+ cif->flags = (unsigned)FFI_TYPE_INT;\n+      else if (cif->rtype->size <= 8)\n+ /* A Composite Type not larger than 8 bytes is returned in r0, r1.  */\n+ cif->flags = (unsigned)FFI_TYPE_SINT64;\n+      else\n+ /* A Composite Type larger than 8 bytes, or whose size cannot\n+    be determined statically ... is stored in memory at an\n+    address passed [in r0].  */\n+ cif->flags = (unsigned)FFI_TYPE_STRUCT;\n+      break;\n+\n+    default:\n+      cif->flags = FFI_TYPE_INT;\n+      break;\n+    }\n+\n+  return FFI_OK;\n+}\n+\n+/* Perform machine dependent cif processing for variadic calls */\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+        unsigned int nfixedargs,\n+        unsigned int ntotalargs)\n+{\n+  return ffi_prep_cif_machdep(cif);\n+}\n+\n+/* Prototypes for assembly functions, in sysv.S */\n+extern void ffi_call_SYSV (void (*fn)(void), extended_cif *, unsigned, unsigned, unsigned *);\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  int small_struct = (cif->flags == FFI_TYPE_INT\n+        && cif->rtype->type == FFI_TYPE_STRUCT);\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+\n+  unsigned int temp;\n+\n+  /* If the return value is a struct and we don't have a return */\n+  /* value address then we need to make one          */\n+\n+  if ((rvalue == NULL) &&\n+      (cif->flags == FFI_TYPE_STRUCT))\n+    {\n+      ecif.rvalue = alloca(cif->rtype->size);\n+    }\n+  else if (small_struct)\n+    ecif.rvalue = &temp;\n+  else\n+    ecif.rvalue = rvalue;\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_SYSV:\n+      ffi_call_SYSV (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n+      break;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+  if (small_struct)\n+#ifdef __CSKYBE__\n+    memcpy (rvalue, ((unsigned char *)&temp + (4 - cif->rtype->size)), cif->rtype->size);\n+#else\n+    memcpy (rvalue, &temp, cif->rtype->size);\n+#endif\n+}\n+\n+/** private members **/\n+\n+static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n+      void** args, ffi_cif* cif);\n+\n+void ffi_closure_SYSV (ffi_closure *);\n+\n+/* This function is jumped to by the trampoline */\n+\n+unsigned int\n+ffi_closure_SYSV_inner (closure, respp, args)\n+     ffi_closure *closure;\n+     void **respp;\n+     void *args;\n+{\n+  // our various things...\n+  ffi_cif       *cif;\n+  void         **arg_area;\n+\n+  cif         = closure->cif;\n+  arg_area    = (void**) alloca (cif->nargs * sizeof (void*));\n+\n+  /* this call will initialize ARG_AREA, such that each\n+   * element in that array points to the corresponding\n+   * value on the stack; and if the function returns\n+   * a structure, it will re-set RESP to point to the\n+   * structure return address.  */\n+\n+  ffi_prep_incoming_args_SYSV(args, respp, arg_area, cif);\n+\n+  (closure->fun) (cif, *respp, arg_area, closure->user_data);\n+\n+#ifdef __CSKYBE__\n+  if (cif->flags == FFI_TYPE_INT && cif->rtype->type == FFI_TYPE_STRUCT) {\n+      unsigned int tmp = 0;\n+      tmp = *(unsigned int *)(*respp);\n+      *(unsigned int *)(*respp) = (tmp >> ((4 - cif->rtype->size) * 8));\n+  }\n+#endif\n+\n+  return cif->flags;\n+}\n+\n+\n+static void\n+ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n+       void **avalue, ffi_cif *cif)\n+{\n+  register unsigned int i;\n+  register void **p_argv;\n+  register char *argp;\n+  register ffi_type **p_arg;\n+\n+  argp = stack;\n+\n+  if ( cif->flags == FFI_TYPE_STRUCT ) {\n+    *rvalue = *(void **) argp;\n+    argp += 4;\n+  }\n+\n+  p_argv = avalue;\n+\n+  for (i = cif->nargs, p_arg = cif->arg_types; (i != 0); i--, p_arg++)\n+    {\n+      size_t z;\n+      size_t alignment;\n+\n+      alignment = (*p_arg)->alignment;\n+      if (alignment < 4)\n+ alignment = 4;\n+\n+#ifdef __CSKYABIV1__\n+      /*\n+       * Adapt ABIV1 bug.\n+       * If struct's size is larger than 8 bytes, then it always alignment as 4 bytes.\n+       */\n+      if (((*p_arg)->type == FFI_TYPE_STRUCT) && ((*p_arg)->size > 8) && (alignment == 8)) {\n+        alignment = 4;\n+      }\n+#endif\n+\n+      /* Align if necessary */\n+      if ((alignment - 1) & (unsigned) argp) {\n+ argp = (char *) FFI_ALIGN(argp, alignment);\n+      }\n+\n+      z = (*p_arg)->size;\n+\n+#ifdef __CSKYBE__\n+      unsigned int tmp = 0;\n+      if ((*p_arg)->size < 4) {\n+        tmp = *(unsigned int *)argp;\n+        memcpy(argp, ((unsigned char *)&tmp + (4 - (*p_arg)->size)), (*p_arg)->size);\n+      }\n+#else\n+      /* because we're little endian, this is what it turns into.   */\n+#endif\n+      *p_argv = (void*) argp;\n+\n+      p_argv++;\n+      argp += z;\n+    }\n+\n+  return;\n+}\n+\n+/* How to make a trampoline.  */\n+\n+extern unsigned char ffi_csky_trampoline[TRAMPOLINE_SIZE];\n+\n+/*\n+ * Since there is no __clear_cache in libgcc in csky toolchain.\n+ * define ffi_csky_cacheflush in sysv.S.\n+ * void ffi_csky_cacheflush(uint32 start_addr, uint32 size, int cache)\n+ */\n+#define CACHEFLUSH_IN_FFI 1\n+#if CACHEFLUSH_IN_FFI\n+extern void ffi_csky_cacheflush(unsigned char *__tramp, unsigned int k,\n+  int i);\n+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)                              \\\n+({ unsigned char *__tramp = (unsigned char*)(TRAMP);                    \\\n+   unsigned int  __fun = (unsigned int)(FUN);                           \\\n+   unsigned int  __ctx = (unsigned int)(CTX);                           \\\n+   unsigned char *insns = (unsigned char *)(CTX);                       \\\n+   memcpy (__tramp, ffi_csky_trampoline, TRAMPOLINE_SIZE);              \\\n+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE] = __ctx;                  \\\n+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE + 4] = __fun;              \\\n+   ffi_csky_cacheflush(&__tramp[0], TRAMPOLINE_SIZE, 3); /* Clear data mapping.  */ \\\n+   ffi_csky_cacheflush(insns, TRAMPOLINE_SIZE, 3);                       \\\n+                                                 /* Clear instruction   \\\n+                                                    mapping.  */        \\\n+ })\n+#else\n+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX)                              \\\n+({ unsigned char *__tramp = (unsigned char*)(TRAMP);                    \\\n+   unsigned int  __fun = (unsigned int)(FUN);                           \\\n+   unsigned int  __ctx = (unsigned int)(CTX);                           \\\n+   unsigned char *insns = (unsigned char *)(CTX);                       \\\n+   memcpy (__tramp, ffi_csky_trampoline, TRAMPOLINE_SIZE);              \\\n+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE] = __ctx;                  \\\n+   *(unsigned int*) &__tramp[TRAMPOLINE_SIZE + 4] = __fun;              \\\n+   __clear_cache((&__tramp[0]), (&__tramp[TRAMPOLINE_SIZE-1])); /* Clear data mapping.  */ \\\n+   __clear_cache(insns, insns + TRAMPOLINE_SIZE);                       \\\n+                                                 /* Clear instruction   \\\n+                                                    mapping.  */        \\\n+ })\n+#endif\n+\n+/* the cif must already be prep'ed */\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+        ffi_cif* cif,\n+        void (*fun)(ffi_cif*,void*,void**,void*),\n+        void *user_data,\n+        void *codeloc)\n+{\n+  void (*closure_func)(ffi_closure*) = NULL;\n+\n+  if (cif->abi == FFI_SYSV)\n+    closure_func = &ffi_closure_SYSV;\n+  else\n+    return FFI_BAD_ABI;\n+\n+  FFI_INIT_TRAMPOLINE (&closure->tramp[0], \\\n+         closure_func,  \\\n+         codeloc);\n+\n+  closure->cif  = cif;\n+  closure->user_data = user_data;\n+  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}\n+\n+"}, {"sha": "f770aac66f1d4d77fafd8cfa1f4f9961e71d46e1", "filename": "libffi/src/csky/ffitarget.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcsky%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,63 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n+                 Copyright (c) 2010  CodeSourcery\n+                 Copyright (c) 1996-2003  Red Hat, Inc.\n+\n+   Target configuration macros for CSKY.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV,\n+} ffi_abi;\n+#endif\n+\n+#ifdef __CSKYABIV2__\n+#define FFI_ASM_ARGREG_SIZE 16\n+#define TRAMPOLINE_SIZE 16\n+#define FFI_TRAMPOLINE_SIZE 24\n+#else\n+#define FFI_ASM_ARGREG_SIZE 24\n+#define TRAMPOLINE_SIZE 20\n+#define FFI_TRAMPOLINE_SIZE 28\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+#endif"}, {"sha": "21670bfd3d030915af7396b7699919dfe32b0928", "filename": "libffi/src/csky/sysv.S", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fcsky%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcsky%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,371 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S\n+\n+   CSKY Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+.macro CSKY_FUNC_START name\n+ .text\n+ .align 2\n+ .globl \\name\n+ .type \\name, @function\n+ \\name:\n+.endm\n+\n+#ifdef __CSKYABIV2__\n+\n+ /*\n+  * a0:   fn\n+  * a1:   &ecif\n+  * a2:   cif->bytes\n+  * a3:   fig->flags\n+  * sp+0: ecif.rvalue\n+  */\n+CSKY_FUNC_START ffi_call_SYSV\n+ /* Save registers */\n+ .cfi_startproc\n+ subi sp, 28\n+ .cfi_def_cfa_offset 28\n+ stw a0, (sp, 0x0)\n+ .cfi_offset 0, -28\n+ stw a1, (sp, 0x4)\n+ .cfi_offset 1, -24\n+ stw a2, (sp, 0x8)\n+ .cfi_offset 2, -20\n+ stw a3, (sp, 0xC)\n+ .cfi_offset 3, -16\n+ stw l0, (sp, 0x10)\n+ .cfi_offset 4, -12\n+ stw l1, (sp, 0x14)\n+ .cfi_offset 5, -8\n+ stw lr, (sp, 0x18)\n+ .cfi_offset 15, -4\n+\n+ mov l0, sp\n+ .cfi_def_cfa_register 4\n+\n+ /* Make room for all of the new args. */\n+ subu sp, sp, a2\n+\n+ /* Place all of the ffi_prep_args in position */\n+ mov a0, sp\n+ /*     a1 already set */\n+\n+ /* Call ffi_prep_args(stack, &ecif) */\n+ jsri ffi_prep_args\n+\n+ /* move first 4 parameters in registers */\n+ ldw a0, (sp, 0x0)\n+ ldw a1, (sp, 0x4)\n+ ldw a2, (sp, 0x8)\n+ ldw a3, (sp, 0xC)\n+\n+ /* and adjust stack */\n+ subu lr, l0, sp /* cif->bytes == l0 - sp */\n+ cmphsi lr, 16\n+ movi l1, 16\n+ movt lr, l1\n+ addu sp, sp, lr\n+\n+ ldw l1, (l0, 0) /* load fn() in advance */\n+\n+ /* call (fn) (...) */\n+ jsr l1\n+\n+ /* Remove the space we pushed for the args */\n+ mov sp, l0\n+\n+ /* Load r2 with the pointer to storage for the return value */\n+ ldw a2, (sp, 0x1C)\n+\n+ /* Load r3 with the return type code */\n+ ldw a3, (sp, 0xC)\n+\n+ /* If the return value pointer is NULL, assume no return value. */\n+ cmpnei a2, 0\n+ bf .Lepilogue\n+\n+ cmpnei a3, FFI_TYPE_STRUCT\n+ bf .Lepilogue\n+\n+ /* return INT64 */\n+ cmpnei a3, FFI_TYPE_SINT64\n+ bt .Lretint\n+ /* stw a0, (a2, 0x0) at .Lretint */\n+ stw a1, (a2, 0x4)\n+\n+.Lretint:\n+ /* return INT */\n+ stw a0, (a2, 0x0)\n+\n+.Lepilogue:\n+ ldw a0, (sp, 0x0)\n+ ldw a1, (sp, 0x4)\n+ ldw a2, (sp, 0x8)\n+ ldw a3, (sp, 0xC)\n+ ldw l0, (sp, 0x10)\n+ ldw l1, (sp, 0x14)\n+ ldw lr, (sp, 0x18)\n+ addi sp, sp, 28\n+ rts\n+ .cfi_endproc\n+        .size    ffi_call_SYSV, .-ffi_call_SYSV\n+\n+\n+ /*\n+  * unsigned int FFI_HIDDEN\n+  * ffi_closure_SYSV_inner (closure, respp, args)\n+  *      ffi_closure *closure;\n+  *      void **respp;\n+  *      void *args;\n+  */\n+CSKY_FUNC_START ffi_closure_SYSV\n+ .cfi_startproc\n+ mov a2, sp\n+ addi a1, sp, 16\n+ subi sp, sp, 24\n+ .cfi_def_cfa_offset 40\n+ stw a1, (sp, 0x10)\n+ .cfi_offset 1, -24\n+ stw lr, (sp, 0x14)\n+ .cfi_offset 15, -20\n+ stw sp, (sp, 0x8)\n+ addi a1, sp, 8\n+ jsri ffi_closure_SYSV_inner\n+ ldw a0, (sp, 0x0)\n+ /*\n+  * if FFI_TYPE_SINT64, need a1.\n+  * if FFI_TYPE_INT, ignore a1.\n+  */\n+ ldw a1, (sp, 0x4)\n+\n+ ldw lr, (sp, 0x14)\n+ addi sp, sp, 40\n+ rts\n+ .cfi_endproc\n+        .size    ffi_closure_SYSV, .-ffi_closure_SYSV\n+\n+CSKY_FUNC_START ffi_csky_trampoline\n+ subi sp, sp, 16\n+ stw a0, (sp, 0x0)\n+ stw a1, (sp, 0x4)\n+ stw a2, (sp, 0x8)\n+ stw a3, (sp, 0xC)\n+ lrw a0, [.Lctx]\n+ lrw a1, [.Lfun]\n+ jmp a1\n+.Lctx:\n+ mov a0, a0\n+ mov a0, a0\n+.Lfun:\n+\n+        .size    ffi_csky_trampoline, .-ffi_csky_trampoline\n+\n+CSKY_FUNC_START ffi_csky_cacheflush\n+ mov t0, r7\n+ movi r7, 123\n+ trap 0\n+ mov r7, t0\n+ rts\n+\n+        .size    ffi_csky_cacheflush, .-ffi_csky_cacheflush\n+\n+#else /* !__CSKYABIV2__ */\n+\n+ /*\n+  * a0:   fn\n+  * a1:   &ecif\n+  * a2:   cif->bytes\n+  * a3:   fig->flags\n+  * a4:   ecif.rvalue\n+  */\n+CSKY_FUNC_START ffi_call_SYSV\n+ /* Save registers */\n+ .cfi_startproc\n+ subi sp, 32\n+ subi sp, 8\n+ .cfi_def_cfa_offset 40\n+ stw a0, (sp, 0x0)\n+ .cfi_offset 2, -40\n+ stw a1, (sp, 0x4)\n+ .cfi_offset 3, -36\n+ stw a2, (sp, 0x8)\n+ .cfi_offset 4, -32\n+ stw a3, (sp, 0xC)\n+ .cfi_offset 5, -28\n+ stw a4, (sp, 0x10)\n+ .cfi_offset 6, -24\n+ stw a5, (sp, 0x14)\n+ .cfi_offset 7, -20\n+ stw l0, (sp, 0x18)\n+ .cfi_offset 8, -16\n+ stw l1, (sp, 0x1C)\n+ .cfi_offset 9, -12\n+ stw lr, (sp, 0x20)\n+ .cfi_offset 15, -8\n+\n+ mov l0, sp\n+ .cfi_def_cfa_register 8\n+\n+ /* Make room for all of the new args. */\n+ subu sp, sp, a2\n+\n+ /* Place all of the ffi_prep_args in position */\n+ mov a0, sp\n+ /*     a1 already set */\n+\n+ /* Call ffi_prep_args(stack, &ecif) */\n+ jsri ffi_prep_args\n+\n+ /* move first 4 parameters in registers */\n+ ldw a0, (sp, 0x0)\n+ ldw a1, (sp, 0x4)\n+ ldw a2, (sp, 0x8)\n+ ldw a3, (sp, 0xC)\n+ ldw a4, (sp, 0x10)\n+ ldw a5, (sp, 0x14)\n+\n+ /* and adjust stack */\n+ mov lr, l0\n+ subu lr, sp  /* cif->bytes == l0 - sp */\n+ movi l1, 24\n+ cmphs lr, l1\n+ movt lr, l1\n+ addu sp, sp, lr\n+\n+ ldw l1, (l0, 0) /* load fn() in advance */\n+\n+ /* call (fn) (...) */\n+ jsr l1\n+\n+ /* Remove the space we pushed for the args */\n+ mov sp, l0\n+\n+ /* Load r2 with the pointer to storage for the return value */\n+ ldw a2, (sp, 0x10)\n+\n+ /* Load r3 with the return type code */\n+ ldw a3, (sp, 0xC)\n+\n+ /* If the return value pointer is NULL, assume no return value. */\n+ cmpnei a2, 0\n+ bf .Lepilogue\n+\n+ cmpnei a3, FFI_TYPE_STRUCT\n+ bf .Lepilogue\n+\n+ /* return INT64 */\n+ cmpnei a3, FFI_TYPE_SINT64\n+ bt .Lretint\n+ /* stw a0, (a2, 0x0) at .Lretint */\n+ stw a1, (a2, 0x4)\n+\n+.Lretint:\n+ /* return INT */\n+ stw a0, (a2, 0x0)\n+\n+.Lepilogue:\n+ ldw a0, (sp, 0x0)\n+ ldw a1, (sp, 0x4)\n+ ldw a2, (sp, 0x8)\n+ ldw a3, (sp, 0xC)\n+ ldw a4, (sp, 0x10)\n+ ldw a5, (sp, 0x14)\n+ ldw l0, (sp, 0x18)\n+ ldw l1, (sp, 0x1C)\n+ ldw lr, (sp, 0x20)\n+ addi sp, sp, 32\n+ addi sp, sp, 8\n+ rts\n+ .cfi_endproc\n+\n+        .size    ffi_call_SYSV, .-ffi_call_SYSV\n+\n+\n+ /*\n+  * unsigned int FFI_HIDDEN\n+  * ffi_closure_SYSV_inner (closure, respp, args)\n+  *      ffi_closure *closure;\n+  *      void **respp;\n+  *      void *args;\n+  */\n+CSKY_FUNC_START ffi_closure_SYSV\n+ .cfi_startproc\n+ mov a2, sp\n+ mov a1, sp\n+ addi a1, 24\n+ subi sp, sp, 24\n+ .cfi_def_cfa_offset 48\n+ stw a1, (sp, 0x10)\n+ .cfi_offset 3, -32\n+ stw lr, (sp, 0x14)\n+ .cfi_offset 15, -28\n+ stw sp, (sp, 0x8)\n+ mov a1, sp\n+ addi a1, 8\n+ jsri ffi_closure_SYSV_inner\n+ ldw a0, (sp, 0x0)\n+ /*\n+  * if FFI_TYPE_SINT64, need a1.\n+  * if FFI_TYPE_INT, ignore a1.\n+  */\n+ ldw a1, (sp, 0x4)\n+\n+ ldw lr, (sp, 0x14)\n+ addi sp, sp, 24\n+ addi sp, sp, 24\n+ rts\n+ .cfi_endproc\n+\n+        .size    ffi_closure_SYSV, .-ffi_closure_SYSV\n+\n+CSKY_FUNC_START ffi_csky_trampoline\n+ subi sp, 24\n+ stw a0, (sp, 0x0)\n+ stw a1, (sp, 0x4)\n+ stw a2, (sp, 0x8)\n+ stw a3, (sp, 0xC)\n+ stw a4, (sp, 0x10)\n+ stw a5, (sp, 0x14)\n+ lrw a0, [.Lctx]\n+ lrw a1, [.Lfun]\n+ jmp a1\n+.Lctx:\n+ mov a0, a0\n+ mov a0, a0\n+.Lfun:\n+\n+        .size    ffi_csky_trampoline, .-ffi_csky_trampoline\n+\n+CSKY_FUNC_START ffi_csky_cacheflush\n+ lrw r1, 123\n+ trap 0\n+ rts\n+\n+        .size    ffi_csky_cacheflush, .-ffi_csky_cacheflush\n+\n+#endif /* __CSKYABIV2__ */"}, {"sha": "1aba657edb51fb8d067985d3a8e707b5cf4adb5c", "filename": "libffi/src/dlmalloc.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fdlmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fdlmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdlmalloc.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -438,6 +438,11 @@ DEFAULT_MMAP_THRESHOLD       default: 256K\n \n */\n \n+#if defined __linux__ && !defined _GNU_SOURCE\n+/* mremap() on Linux requires this via sys/mman.h */\n+#define _GNU_SOURCE 1\n+#endif\n+\n #ifndef WIN32\n #ifdef _WIN32\n #define WIN32 1\n@@ -2366,7 +2371,7 @@ static size_t traverse_and_check(mstate m);\n \n #else /* GNUC */\n #if  USE_BUILTIN_FFS\n-#define compute_bit2idx(X, I) I = ffs(X)-1\n+#define compute_bit2idx(X, I) I = __builtin_ffs(X)-1\n \n #else /* USE_BUILTIN_FFS */\n #define compute_bit2idx(X, I)\\"}, {"sha": "ed1c65a1a362b09a8b60af72d0230c04d9afa4eb", "filename": "libffi/src/frv/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ffrv%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ffrv%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ffrv%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -107,7 +107,7 @@ void *ffi_prep_args(char *stack, extended_cif *ecif)\n       count += z;\n     }\n \n-  return (stack + ((count > 24) ? 24 : ALIGN_DOWN(count, 8)));\n+  return (stack + ((count > 24) ? 24 : FFI_ALIGN_DOWN(count, 8)));\n }\n \n /* Perform machine dependent cif processing */\n@@ -118,7 +118,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   else\n     cif->flags = cif->rtype->size;\n \n-  cif->bytes = ALIGN (cif->bytes, 8);\n+  cif->bytes = FFI_ALIGN (cif->bytes, 8);\n \n   return FFI_OK;\n }"}, {"sha": "b1d04c3e749b0c6111f32207fad873b64c347a9b", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -220,8 +220,8 @@ hfa_element_type (ffi_type *type, int nested)\n \n /* Perform machine dependent cif processing. */\n \n-ffi_status\n-ffi_prep_cif_machdep(ffi_cif *cif)\n+static ffi_status\n+ffi_prep_cif_machdep_core(ffi_cif *cif)\n {\n   int flags;\n \n@@ -271,6 +271,22 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  cif->nfixedargs = cif->nargs;\n+  return ffi_prep_cif_machdep_core(cif);\n+}\n+\n+ffi_status\n+ffi_prep_cif_machdep_var(ffi_cif *cif,\n+\t\t\t unsigned int nfixedargs,\n+\t\t\t unsigned int ntotalargs MAYBE_UNUSED)\n+{\n+  cif->nfixedargs = nfixedargs;\n+  return ffi_prep_cif_machdep_core(cif);\n+}\n+\n extern int ffi_call_unix (struct ia64_args *, PTR64, void (*)(void), UINT64);\n \n void\n@@ -454,10 +470,11 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n   ffi_cif *cif;\n   void **avalue;\n   ffi_type **p_arg;\n-  long i, avn, gpcount, fpcount;\n+  long i, avn, gpcount, fpcount, nfixedargs;\n \n   cif = closure->cif;\n   avn = cif->nargs;\n+  nfixedargs = cif->nfixedargs;\n   avalue = alloca (avn * sizeof (void *));\n \n   /* If the structure return value is passed in memory get that location\n@@ -468,6 +485,7 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n   gpcount = fpcount = 0;\n   for (i = 0, p_arg = cif->arg_types; i < avn; i++, p_arg++)\n     {\n+      int named = i < nfixedargs;\n       switch ((*p_arg)->type)\n \t{\n \tcase FFI_TYPE_SINT8:\n@@ -491,7 +509,7 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  if (gpcount < 8 && fpcount < 8)\n+\t  if (named && gpcount < 8 && fpcount < 8)\n \t    {\n \t      fpreg *addr = &stack->fp_regs[fpcount++];\n \t      float result;\n@@ -505,7 +523,7 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  if (gpcount < 8 && fpcount < 8)\n+\t  if (named && gpcount < 8 && fpcount < 8)\n \t    {\n \t      fpreg *addr = &stack->fp_regs[fpcount++];\n \t      double result;\n@@ -521,7 +539,7 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \tcase FFI_TYPE_LONGDOUBLE:\n \t  if (gpcount & 1)\n \t    gpcount++;\n-\t  if (LDBL_MANT_DIG == 64 && gpcount < 8 && fpcount < 8)\n+\t  if (LDBL_MANT_DIG == 64 && named && gpcount < 8 && fpcount < 8)\n \t    {\n \t      fpreg *addr = &stack->fp_regs[fpcount++];\n \t      __float80 result;"}, {"sha": "fd5b9a0ee1c7c90d77042dafd4c73c08a1a93b65", "filename": "libffi/src/ia64/ffitarget.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -50,6 +50,7 @@ typedef enum ffi_abi {\n #define FFI_TRAMPOLINE_SIZE 24  /* Really the following struct, which \t*/\n \t\t\t\t/* can be interpreted as a C function\t*/\n \t\t\t\t/* descriptor:\t\t\t\t*/\n+#define FFI_TARGET_SPECIFIC_VARIADIC 1\n+#define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs\n \n #endif\n-"}, {"sha": "e2547e02b3aa1c173bdbc80fc8ef78c00194c34f", "filename": "libffi/src/ia64/unix.S", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Funix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fia64%2Funix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Funix.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -175,7 +175,6 @@ ffi_call_unix:\n \t;;\n \n .Lst_small_struct:\n-\tadd\tsp = -16, sp\n \tcmp.lt\tp6, p0 = 8, in3\n \tcmp.lt\tp7, p0 = 16, in3\n \tcmp.lt\tp8, p0 = 24, in3\n@@ -191,6 +190,12 @@ ffi_call_unix:\n (p8)\tst8\t[r18] = r11\n \tmov\tout1 = sp\n \tmov\tout2 = in3\n+\t;;\n+\t// ia64 software calling convention requires\n+\t// top 16 bytes of stack to be scratch space\n+\t// PLT resolver uses that scratch space at\n+\t// 'memcpy' symbol reolution time\n+\tadd\tsp = -16, sp\n \tbr.call.sptk.many b0 = memcpy#\n \t;;\n \tmov\tar.pfs = loc0\n@@ -529,6 +534,7 @@ ffi_closure_unix:\n \tdata8\t@pcrel(.Lst_int64)\t\t// FFI_TYPE_SINT64\n \tdata8\t@pcrel(.Lst_void)\t\t// FFI_TYPE_STRUCT\n \tdata8\t@pcrel(.Lst_int64)\t\t// FFI_TYPE_POINTER\n+\tdata8\t@pcrel(.Lst_void)\t\t// FFI_TYPE_COMPLEX (not implemented)\n \tdata8 \t@pcrel(.Lst_small_struct)\t// FFI_IA64_TYPE_SMALL_STRUCT\n \tdata8\t@pcrel(.Lst_hfa_float)\t\t// FFI_IA64_TYPE_HFA_FLOAT\n \tdata8\t@pcrel(.Lst_hfa_double)\t\t// FFI_IA64_TYPE_HFA_DOUBLE\n@@ -550,6 +556,7 @@ ffi_closure_unix:\n \tdata8\t@pcrel(.Lld_int)\t\t// FFI_TYPE_SINT64\n \tdata8\t@pcrel(.Lld_void)\t\t// FFI_TYPE_STRUCT\n \tdata8\t@pcrel(.Lld_int)\t\t// FFI_TYPE_POINTER\n+\tdata8\t@pcrel(.Lld_void)\t\t// FFI_TYPE_COMPLEX (not implemented)\n \tdata8 \t@pcrel(.Lld_small_struct)\t// FFI_IA64_TYPE_SMALL_STRUCT\n \tdata8\t@pcrel(.Lld_hfa_float)\t\t// FFI_IA64_TYPE_HFA_FLOAT\n \tdata8\t@pcrel(.Lld_hfa_double)\t\t// FFI_IA64_TYPE_HFA_DOUBLE"}, {"sha": "114d3e47fcdef36a29172a23e8b5acad30cdd584", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -114,7 +114,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)\n \tdefault:\n \t  *args = raw;\n \t  raw +=\n-\t    ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n+\t    FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n \t}\n     }\n \n@@ -142,7 +142,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args)\n #else /* FFI_SIZEOF_JAVA_RAW != 8 */\n \t*args = (void*) raw;\n \traw +=\n-\t  ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n+\t  FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n #endif /* FFI_SIZEOF_JAVA_RAW == 8 */\n     }\n \n@@ -234,7 +234,7 @@ ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw)\n #else\n \t  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);\n \t  raw +=\n-\t    ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n+\t    FFI_ALIGN ((*tp)->size, sizeof(ffi_java_raw)) / sizeof(ffi_java_raw);\n #endif\n \t}\n     }"}, {"sha": "4edba410d8206251d641a5ded4bcb0a309cd1e28", "filename": "libffi/src/kvx/asm.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fkvx%2Fasm.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,5 @@\n+/* args are passed on registers from r0 up to r11 => 12*8 bytes */\n+#define REG_ARGS_SIZE (12*8)\n+#define KVX_REGISTER_SIZE (8)\n+#define KVX_ABI_SLOT_SIZE (KVX_REGISTER_SIZE)\n+#define KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE (4*KVX_ABI_SLOT_SIZE)"}, {"sha": "58f6aef5ca473b8f3604da9be16d4e5365829477", "filename": "libffi/src/kvx/ffi.c", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fkvx%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,273 @@\n+/* Copyright (c) 2020 Kalray\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#if defined(__kvx__)\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#include \"ffi_common.h\"\n+#include \"asm.h\"\n+\n+#define ALIGN(x, a) ALIGN_MASK(x, (typeof(x))(a) - 1)\n+#define ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))\n+#define KVX_ABI_STACK_ALIGNMENT (32)\n+#define KVX_ABI_STACK_ARG_ALIGNMENT (8)\n+#define max(a,b) ((a) > (b) ? (a) : (b))\n+\n+#ifdef FFI_DEBUG\n+#define DEBUG_PRINT(...) do{ fprintf( stderr, __VA_ARGS__ ); } while(0)\n+#else\n+#define DEBUG_PRINT(...)\n+#endif\n+\n+struct ret_value {\n+\tunsigned long int r0;\n+\tunsigned long int r1;\n+\tunsigned long int r2;\n+\tunsigned long int r3;\n+};\n+\n+extern struct ret_value ffi_call_SYSV(unsigned total_size,\n+                                      unsigned size,\n+                                      extended_cif *ecif,\n+                                      unsigned *rvalue_addr,\n+                                      void *fn,\n+                                      unsigned int_ext_method);\n+\n+/* Perform machine dependent cif processing */\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  cif->flags = cif->rtype->size;\n+  return FFI_OK;\n+}\n+\n+/* ffi_prep_args is called by the assembly routine once stack space\n+   has been allocated for the function's arguments */\n+\n+void *ffi_prep_args(char *stack, unsigned int arg_slots_size, extended_cif *ecif)\n+{\n+  char *stacktemp = stack;\n+  char *current_arg_passed_by_value = stack + arg_slots_size;\n+  int i, s;\n+  ffi_type **arg;\n+  int count = 0;\n+  ffi_cif *cif = ecif->cif;\n+  void **argv = ecif->avalue;\n+\n+  arg = cif->arg_types;\n+\n+  DEBUG_PRINT(\"stack: %p\\n\", stack);\n+  DEBUG_PRINT(\"arg_slots_size: %u\\n\", arg_slots_size);\n+  DEBUG_PRINT(\"current_arg_passed_by_value: %p\\n\", current_arg_passed_by_value);\n+  DEBUG_PRINT(\"ecif: %p\\n\", ecif);\n+  DEBUG_PRINT(\"ecif->avalue: %p\\n\", ecif->avalue);\n+\n+  for (i = 0; i < cif->nargs; i++) {\n+\n+    s = KVX_ABI_SLOT_SIZE;\n+    switch((*arg)->type) {\n+      case FFI_TYPE_SINT8:\n+      case FFI_TYPE_UINT8:\n+      case FFI_TYPE_SINT16:\n+      case FFI_TYPE_UINT16:\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_FLOAT:\n+      case FFI_TYPE_DOUBLE:\n+      case FFI_TYPE_UINT64:\n+      case FFI_TYPE_SINT64:\n+      case FFI_TYPE_POINTER:\n+        DEBUG_PRINT(\"INT64/32/16/8/FLOAT/DOUBLE or POINTER @%p\\n\", stack);\n+        *(uint64_t *) stack = *(uint64_t *)(* argv);\n+        break;\n+\n+      case FFI_TYPE_COMPLEX:\n+        if ((*arg)->size == 8)\n+          *(_Complex float *) stack = *(_Complex float *)(* argv);\n+        else if ((*arg)->size == 16) {\n+          *(_Complex double *) stack = *(_Complex double *)(* argv);\n+          s = 16;\n+        } else\n+          abort();\n+        break;\n+      case FFI_TYPE_STRUCT: {\n+        char *value;\n+        unsigned int written_size = 0;\n+        DEBUG_PRINT(\"struct by value @%p\\n\", stack);\n+        if ((*arg)->size > KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE) {\n+          DEBUG_PRINT(\"big struct\\n\");\n+          *(uint64_t *) stack = (uintptr_t)current_arg_passed_by_value;\n+          value = current_arg_passed_by_value;\n+          current_arg_passed_by_value += (*arg)->size;\n+          written_size = KVX_ABI_SLOT_SIZE;\n+        } else {\n+          value = stack;\n+          written_size = (*arg)->size;\n+        }\n+        memcpy(value, *argv, (*arg)->size);\n+        s = ALIGN(written_size, KVX_ABI_STACK_ARG_ALIGNMENT);\n+        break;\n+      }\n+      default:\n+        printf(\"Error: unsupported arg type %d\\n\", (*arg)->type);\n+        abort();\n+        break;\n+\n+    }\n+    stack += s;\n+    count += s;\n+    argv++;\n+    arg++;\n+  }\n+#ifdef FFI_DEBUG\n+  FFI_ASSERT(((intptr_t)(stacktemp + REG_ARGS_SIZE) & (KVX_ABI_STACK_ALIGNMENT-1)) == 0);\n+#endif\n+  return stacktemp + REG_ARGS_SIZE;\n+}\n+\n+/* Perform machine dependent cif processing when we have a variadic function */\n+\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs,\n+                                    unsigned int ntotalargs)\n+{\n+  cif->flags = cif->rtype->size;\n+  return FFI_OK;\n+}\n+\n+static unsigned long handle_small_int_ext(kvx_intext_method *int_ext_method,\n+                                          const ffi_type *rtype)\n+{\n+  switch (rtype->type) {\n+    case FFI_TYPE_SINT8:\n+      *int_ext_method = KVX_RET_SXBD;\n+      return KVX_REGISTER_SIZE;\n+\n+    case FFI_TYPE_SINT16:\n+      *int_ext_method = KVX_RET_SXHD;\n+      return KVX_REGISTER_SIZE;\n+\n+    case FFI_TYPE_SINT32:\n+      *int_ext_method = KVX_RET_SXWD;\n+      return KVX_REGISTER_SIZE;\n+\n+    case FFI_TYPE_UINT8:\n+      *int_ext_method = KVX_RET_ZXBD;\n+      return KVX_REGISTER_SIZE;\n+\n+    case FFI_TYPE_UINT16:\n+      *int_ext_method = KVX_RET_ZXHD;\n+      return KVX_REGISTER_SIZE;\n+\n+    case FFI_TYPE_UINT32:\n+      *int_ext_method = KVX_RET_ZXWD;\n+      return KVX_REGISTER_SIZE;\n+\n+    default:\n+      *int_ext_method = KVX_RET_NONE;\n+      return rtype->size;\n+  }\n+}\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  int i;\n+  unsigned long int slot_fitting_args_size = 0;\n+  unsigned long int total_size = 0;\n+  unsigned long int big_struct_size = 0;\n+  kvx_intext_method int_extension_method;\n+  ffi_type **arg;\n+  struct ret_value local_rvalue = {0};\n+  size_t wb_size;\n+\n+\n+  /* Calculate size to allocate on stack */\n+  for (i = 0, arg = cif->arg_types; i < cif->nargs; i++, arg++) {\n+    DEBUG_PRINT(\"argument %d, type %d, size %lu\\n\", i, (*arg)->type, (*arg)->size);\n+    if (((*arg)->type == FFI_TYPE_STRUCT) || ((*arg)->type == FFI_TYPE_COMPLEX)) {\n+      if ((*arg)->size <= KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE) {\n+        slot_fitting_args_size += ALIGN((*arg)->size, KVX_ABI_SLOT_SIZE);\n+      } else {\n+        slot_fitting_args_size += KVX_ABI_SLOT_SIZE; /* aggregate passed by reference */\n+        big_struct_size += ALIGN((*arg)->size, KVX_ABI_SLOT_SIZE);\n+      }\n+    } else if ((*arg)->size <= KVX_ABI_SLOT_SIZE) {\n+      slot_fitting_args_size += KVX_ABI_SLOT_SIZE;\n+    } else {\n+      printf(\"Error: unsupported arg size %ld arg type %d\\n\", (*arg)->size, (*arg)->type);\n+      abort(); /* should never happen? */\n+    }\n+  }\n+\n+  extended_cif ecif;\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  ecif.rvalue = rvalue;\n+\n+  /* This implementation allocates anyway for all register based args */\n+  slot_fitting_args_size = max(slot_fitting_args_size, REG_ARGS_SIZE);\n+  total_size = slot_fitting_args_size + big_struct_size;\n+  total_size = ALIGN(total_size, KVX_ABI_STACK_ALIGNMENT);\n+\n+  /* wb_size: write back size, the size we will need to write back to user\n+   * provided buffer. In theory it should always be cif->flags which is\n+   * cif->rtype->size. But libffi API mandates that for integral types\n+   * of size <= system register size, then we *MUST* write back\n+   * the size of system register size.\n+   * in our case, if size <= 8 bytes we must write back 8 bytes.\n+   * floats, complex and structs are not affected, only integrals.\n+   */\n+  wb_size = handle_small_int_ext(&int_extension_method, cif->rtype);\n+\n+  switch (cif->abi) {\n+    case FFI_SYSV:\n+      DEBUG_PRINT(\"total_size: %lu\\n\", total_size);\n+      DEBUG_PRINT(\"slot fitting args size: %lu\\n\", slot_fitting_args_size);\n+      DEBUG_PRINT(\"rvalue: %p\\n\", rvalue);\n+      DEBUG_PRINT(\"fn: %p\\n\", fn);\n+      DEBUG_PRINT(\"rsize: %u\\n\", cif->flags);\n+      DEBUG_PRINT(\"wb_size: %u\\n\", wb_size);\n+      DEBUG_PRINT(\"int_extension_method: %u\\n\", int_extension_method);\n+      local_rvalue = ffi_call_SYSV(total_size, slot_fitting_args_size,\n+                                   &ecif, rvalue, fn, int_extension_method);\n+      if ((cif->flags <= KVX_ABI_MAX_AGGREGATE_IN_REG_SIZE)\n+          && (cif->rtype->type != FFI_TYPE_VOID))\n+        memcpy(rvalue, &local_rvalue, wb_size);\n+      break;\n+    default:\n+      abort();\n+      break;\n+  }\n+}\n+\n+/* Closures not supported yet */\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+                      ffi_cif* cif,\n+                      void (*fun)(ffi_cif*,void*,void**,void*),\n+                      void *user_data,\n+                      void *codeloc)\n+{\n+  return FFI_BAD_ABI;\n+}\n+\n+#endif /* (__kvx__) */"}, {"sha": "8df8735e3f2d85b7d263d396c701599f85d6d077", "filename": "libffi/src/kvx/ffitarget.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fkvx%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,75 @@\n+/* -----------------------------------------------------------------------\n+   ffitarget.h - Copyright (c) 2020 Kalray\n+\n+   KVX Target configuration macros\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source. Use ffi.h instead.\"\n+#endif\n+\n+/* ---- System specific configurations ----------------------------------- */\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed long            ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+\n+/* Those values are set depending on return type\n+ * they are used in the assembly code in sysv.S\n+ */\n+typedef enum kvx_intext_method {\n+  KVX_RET_NONE = 0,\n+  KVX_RET_SXBD = 1,\n+  KVX_RET_SXHD = 2,\n+  KVX_RET_SXWD = 3,\n+  KVX_RET_ZXBD = 4,\n+  KVX_RET_ZXHD = 5,\n+  KVX_RET_ZXWD = 6\n+} kvx_intext_method;\n+\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+/* This is only to allow Python to compile\n+ * but closures are not supported yet\n+ */\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 0\n+\n+#define FFI_NATIVE_RAW_API 0\n+#define FFI_TARGET_SPECIFIC_VARIADIC 1\n+#define FFI_TARGET_HAS_COMPLEX_TYPE\n+\n+#endif\n+"}, {"sha": "952afc7063bc0c96c4e69664da5058f7854cd35a", "filename": "libffi/src/kvx/sysv.S", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fkvx%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fkvx%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,127 @@\n+/* Copyright (c) 2020 Kalray\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#if defined(__kvx__)\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+#include <ffi_cfi.h>\n+#include <kvx/asm.h>\n+\n+.text\n+.global ffi_call_SYSV\n+.type ffi_call_SYSV, @function\n+.type ffi_prep_args, @function\n+.align 8\n+\n+/* ffi_call_SYSV\n+\n+  r0: total size to allocate on stack\n+  r1: size of arg slots\n+  r2: extended cif structure, DO NOT REMOVE: it is used by ffi_prep_args()\n+  r3: return value address\n+  r4: function to call\n+  r5: integer sign extension method to be used\n+*/\n+ffi_call_SYSV:\n+\taddd $r12 = $r12, -64\n+\tso (-32)[$r12] = $r20r21r22r23\n+\t;;\n+\tsd (0)[$r12] = $r24\n+\t;;\n+\tget $r23 = $ra\n+\tcopyd $r20 = $r12\n+\tsbfd $r12 = $r0, $r12\n+\t;;\n+\tcopyd $r0 = $r12\n+\tcopyd $r21 = $r3\n+\tcopyd $r22 = $r4\n+\tcopyd $r24 = $r5\n+\tcall ffi_prep_args\n+\t;;\n+\tlo $r8r9r10r11 = (64)[$r12]\n+\t;;\n+\tlo $r4r5r6r7 = (32)[$r12]\n+\t;;\n+\tlo $r0r1r2r3 = (0)[$r12]\n+\tcopyd $r12 = $r0\n+\t/* $r15 is the register used by the ABI to return big (>32 bytes)\n+\t * structs by value.\n+\t * It is also referred to as the \"struct register\" in the ABI.\n+\t */\n+\tcopyd $r15 = $r21\n+\ticall $r22\n+\t;;\n+\tpcrel $r4 = @pcrel(.Ltable)\n+\tcb.deqz $r24 ? .Lend\n+\t;;\n+\taddx8d $r24 = $r24, $r4\n+\t;;\n+\tigoto $r24\n+\t;;\n+.Ltable:\n+0: /* we should never arrive here */\n+\tgoto .Lerror\n+\tnop\n+\t;;\n+1: /* Sign extend byte to double */\n+\tsxbd $r0 = $r0\n+\tgoto .Lend\n+\t;;\n+2: /* Sign extend half to double */\n+\tsxhd $r0 = $r0\n+\tgoto .Lend\n+\t;;\n+3: /* Sign extend word to double */\n+\tsxwd $r0 = $r0\n+\tgoto .Lend\n+\t;;\n+4: /* Zero extend byte to double */\n+\tzxbd $r0 = $r0\n+\tgoto .Lend\n+\t;;\n+5: /* Zero extend half to double */\n+\tzxhd $r0 = $r0\n+\tgoto .Lend\n+\t;;\n+6: /* Zero extend word to double */\n+\tzxwd $r0 = $r0\n+\t/* Fallthrough to .Lend */\n+\t;;\n+.Lend:\n+\tld $r24 = (0)[$r12]\n+\t;;\n+\tset $ra = $r23\n+\tlo $r20r21r22r23 = (32)[$r20]\n+\taddd $r12 = $r20, 64\n+\t;;\n+\tret\n+\t;;\n+.Lerror:\n+\terrop\n+\t;;\n+\n+#endif /* __kvx__ */\n+\n+#if defined __ELF__ && defined __linux__\n+\t.section .note.GNU-stack,\"\",%progbits\n+#endif\n+"}, {"sha": "ab8fc4e48a250a14d8d14f4f3d247a55524b8692", "filename": "libffi/src/m32r/ffi.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm32r%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm32r%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm32r%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -61,7 +61,7 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \n       /* Align if necessary.  */\n       if (((*p_arg)->alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, (*p_arg)->alignment);\n+\targp = (char *) FFI_ALIGN (argp, (*p_arg)->alignment);\n \n       if (avn != 0) \n \t{"}, {"sha": "033018480ca93347a9bca559789e7685315abb51", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -105,7 +105,7 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n \n \t  /* Align if necessary.  */\n \t  if ((sizeof(int) - 1) & z)\n-\t    z = ALIGN(z, sizeof(int));\n+\t    z = FFI_ALIGN(z, sizeof(int));\n \t}\n \n       p_argv++;\n@@ -297,7 +297,7 @@ ffi_prep_incoming_args_SYSV (char *stack, void **avalue, ffi_cif *cif)\n \n \t  /* Align if necessary */\n \t  if ((sizeof(int) - 1) & z)\n-\t    z = ALIGN(z, sizeof(int));\n+\t    z = FFI_ALIGN(z, sizeof(int));\n \t}\n \n       p_argv++;"}, {"sha": "ea40f1100ba9e426327773b99ef20cf3153457c9", "filename": "libffi/src/m68k/sysv.S", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm68k%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm68k%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -3,7 +3,7 @@\n    sysv.S - Copyright (c) 2012 Alan Hourihane\n \t    Copyright (c) 1998, 2012 Andreas Schwab\n \t    Copyright (c) 2008 Red Hat, Inc.\n-\t    Copyright (c) 2012 Thorsten Glaser\n+\t    Copyright (c) 2012, 2016 Thorsten Glaser\n \n    m68k Foreign Function Interface\n \n@@ -72,6 +72,15 @@ CALLFUNC(ffi_call_SYSV):\n \tpea\t4(%sp)\n #if !defined __PIC__\n \tjsr\tCALLFUNC(ffi_prep_args)\n+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)\n+\tmove.l  _current_shared_library_a5_offset_(%a5),%a0\n+\tmove.l  CALLFUNC(ffi_prep_args@GOT)(%a0),%a0\n+\tjsr     (%a0)\n+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)\n+\tmove.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0\n+\tlea     (-6,%pc,%a0),%a0\n+\tmove.l  CALLFUNC(ffi_prep_args@GOT)(%a0),%a0\n+\tjsr     (%a0)\n #else\n \tbsr.l\tCALLFUNC(ffi_prep_args@PLTPC)\n #endif\n@@ -215,6 +224,15 @@ CALLFUNC(ffi_closure_SYSV):\n \tmove.l\t%a0,-(%sp)\n #if !defined __PIC__\n \tjsr\tCALLFUNC(ffi_closure_SYSV_inner)\n+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)\n+\tmove.l  _current_shared_library_a5_offset_(%a5),%a0\n+\tmove.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0\n+\tjsr     (%a0)\n+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)\n+\tmove.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0\n+\tlea     (-6,%pc,%a0),%a0\n+\tmove.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0\n+\tjsr     (%a0)\n #else\n \tbsr.l\tCALLFUNC(ffi_closure_SYSV_inner@PLTPC)\n #endif\n@@ -317,6 +335,15 @@ CALLFUNC(ffi_closure_struct_SYSV):\n \tmove.l\t%a0,-(%sp)\n #if !defined __PIC__\n \tjsr\tCALLFUNC(ffi_closure_SYSV_inner)\n+#elif defined(__uClinux__) && defined(__ID_SHARED_LIBRARY__)\n+\tmove.l  _current_shared_library_a5_offset_(%a5),%a0\n+\tmove.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0\n+\tjsr     (%a0)\n+#elif defined(__mcoldfire__) && !defined(__mcfisab__) && !defined(__mcfisac__)\n+\tmove.l  #_GLOBAL_OFFSET_TABLE_@GOTPC,%a0\n+\tlea     (-6,%pc,%a0),%a0\n+\tmove.l  CALLFUNC(ffi_closure_SYSV_inner@GOT)(%a0),%a0\n+\tjsr     (%a0)\n #else\n \tbsr.l\tCALLFUNC(ffi_closure_SYSV_inner@PLTPC)\n #endif"}, {"sha": "57b344f4b9a0e8620b80c1f54abd65e547753388", "filename": "libffi/src/m88k/ffi.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm88k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fm88k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm88k%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -134,7 +134,7 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n       /* Enforce proper stack alignment of 64-bit types */\n       if (argp == stackp && a > sizeof (int))\n \t{\n-\t  stackp = (char *) ALIGN(stackp, a);\n+\t  stackp = (char *) FFI_ALIGN(stackp, a);\n \t  argp = stackp;\n \t}\n \n@@ -177,7 +177,7 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n \n       /* Align if necessary.  */\n       if ((sizeof (int) - 1) & z)\n-\tz = ALIGN(z, sizeof (int));\n+\tz = FFI_ALIGN(z, sizeof (int));\n \n       p_argv++;\n \n@@ -320,7 +320,7 @@ ffi_prep_closure_args_OBSD (ffi_cif *cif, void **avalue, unsigned int *regp,\n       /* Enforce proper stack alignment of 64-bit types */\n       if (argp == stackp && a > sizeof (int))\n \t{\n-\t  stackp = (char *) ALIGN(stackp, a);\n+\t  stackp = (char *) FFI_ALIGN(stackp, a);\n \t  argp = stackp;\n \t}\n \n@@ -331,7 +331,7 @@ ffi_prep_closure_args_OBSD (ffi_cif *cif, void **avalue, unsigned int *regp,\n \n       /* Align if necessary */\n       if ((sizeof (int) - 1) & z)\n-\tz = ALIGN(z, sizeof (int));\n+\tz = FFI_ALIGN(z, sizeof (int));\n \n       p_argv++;\n "}, {"sha": "3aecb0b8115631efdacea339e75a43c3da5b855b", "filename": "libffi/src/metag/ffi.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmetag%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmetag%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmetag%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -61,7 +61,7 @@ unsigned int ffi_prep_args(char *stack, extended_cif *ecif)\n \t\targp -= z;\n \n \t\t/* Align if necessary */\n-\t\targp = (char *) ALIGN_DOWN(ALIGN_DOWN(argp, (*p_arg)->alignment), 4);\n+\t\targp = (char *) FFI_ALIGN_DOWN(FFI_ALIGN_DOWN(argp, (*p_arg)->alignment), 4);\n \n \t\tif (z < sizeof(int)) {\n \t\t\tz = sizeof(int);\n@@ -93,7 +93,7 @@ unsigned int ffi_prep_args(char *stack, extended_cif *ecif)\n \n \t/* return the size of the arguments to be passed in registers,\n \t   padded to an 8 byte boundary to preserve stack alignment */\n-\treturn ALIGN(MIN(stack - argp, 6*4), 8);\n+\treturn FFI_ALIGN(MIN(stack - argp, 6*4), 8);\n }\n \n /* Perform machine dependent cif processing */\n@@ -112,20 +112,20 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n \t\t/* Add any padding if necessary */\n \t\tif (((*ptr)->alignment - 1) & bytes)\n-\t\t\tbytes = ALIGN(bytes, (*ptr)->alignment);\n+\t\t\tbytes = FFI_ALIGN(bytes, (*ptr)->alignment);\n \n-\t\tbytes += ALIGN((*ptr)->size, 4);\n+\t\tbytes += FFI_ALIGN((*ptr)->size, 4);\n \t}\n \n \t/* Ensure arg space is aligned to an 8-byte boundary */\n-\tbytes = ALIGN(bytes, 8);\n+\tbytes = FFI_ALIGN(bytes, 8);\n \n \t/* Make space for the return structure pointer */\n \tif (cif->rtype->type == FFI_TYPE_STRUCT) {\n \t\tbytes += sizeof(void*);\n \n \t\t/* Ensure stack is aligned to an 8-byte boundary */\n-\t\tbytes = ALIGN(bytes, 8);\n+\t\tbytes = FFI_ALIGN(bytes, 8);\n \t}\n \n \tcif->bytes = bytes;\n@@ -319,7 +319,7 @@ static void ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n \t\tif (alignment < 4)\n \t\t\talignment = 4;\n \t\tif ((alignment - 1) & (unsigned)argp)\n-\t\t\targp = (char *) ALIGN(argp, alignment);\n+\t\t\targp = (char *) FFI_ALIGN(argp, alignment);\n \n \t\tz = (*p_arg)->size;\n \t\t*p_argv = (void*) argp;"}, {"sha": "df6e33c97d4c0090f9179fa3910edf89ee9c57d4", "filename": "libffi/src/microblaze/ffi.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmicroblaze%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmicroblaze%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmicroblaze%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -35,7 +35,7 @@ extern void ffi_closure_SYSV(void);\n \n #define WORD_SIZE\t\t\tsizeof(unsigned int)\n #define ARGS_REGISTER_SIZE\t(WORD_SIZE * 6)\n-#define WORD_ALIGN(x)\t\tALIGN(x, WORD_SIZE)\n+#define WORD_FFI_ALIGN(x)\t\tFFI_ALIGN(x, WORD_SIZE)\n \n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n@@ -46,12 +46,12 @@ void ffi_prep_args(void* stack, extended_cif* ecif)\n \tvoid** p_argv;\n \tvoid* stack_args_p = stack;\n \n-\tp_argv = ecif->avalue;\n-\n \tif (ecif == NULL || ecif->cif == NULL) {\n \t\treturn; /* no description to prepare */\n \t}\n \n+\tp_argv = ecif->avalue;\n+\n \tif ((ecif->cif->rtype != NULL) &&\n \t\t\t(ecif->cif->rtype->type == FFI_TYPE_STRUCT))\n \t{\n@@ -74,7 +74,7 @@ void ffi_prep_args(void* stack, extended_cif* ecif)\n \t\tint type = (*p_arg)->type;\n \t\tvoid* value = p_argv[i];\n \t\tchar* addr = stack_args_p;\n-\t\tint aligned_size = WORD_ALIGN(size);\n+\t\tint aligned_size = WORD_FFI_ALIGN(size);\n \n \t\t/* force word alignment on the stack */\n \t\tstack_args_p += aligned_size;\n@@ -259,7 +259,7 @@ void ffi_closure_call_SYSV(void* register_args, void* stack_args,\n \t\t\t\tavalue[i] = ptr;\n \t\t\t\tbreak;\n \t\t}\n-\t\tptr += WORD_ALIGN(arg_types[i]->size);\n+\t\tptr += WORD_FFI_ALIGN(arg_types[i]->size);\n \t}\n \n \t/* set the return type info passed back to the wrapper */"}, {"sha": "979ca49f1bd64b7b49c7f757709bc6eacc9e134c", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 111, "deletions": 35, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -29,6 +29,7 @@\n #include <ffi.h>\n #include <ffi_common.h>\n \n+#include <stdint.h>\n #include <stdlib.h>\n \n #ifdef __GNUC__\n@@ -38,7 +39,9 @@\n #endif\n \n #ifndef USE__BUILTIN___CLEAR_CACHE\n-#  if defined(__OpenBSD__)\n+#  if defined(__FreeBSD__)\n+#    include <machine/sysarch.h>\n+#  elif defined(__OpenBSD__)\n #    include <mips64/sysarch.h>\n #  else\n #    include <sys/cachectl.h>\n@@ -116,7 +119,7 @@ static void ffi_prep_args(char *stack,\n       \n       if ((a - 1) & (unsigned long) argp)\n \t{\n-\t  argp = (char *) ALIGN(argp, a);\n+\t  argp = (char *) FFI_ALIGN(argp, a);\n \t  FIX_ARGP;\n \t}\n \n@@ -247,7 +250,7 @@ calc_n32_struct_flags(int soft_float, ffi_type *arg,\n   while ((e = arg->elements[index]))\n     {\n       /* Align this object.  */\n-      *loc = ALIGN(*loc, e->alignment);\n+      *loc = FFI_ALIGN(*loc, e->alignment);\n       if (e->type == FFI_TYPE_DOUBLE)\n \t{\n           /* Already aligned to FFI_SIZEOF_ARG.  */\n@@ -262,7 +265,7 @@ calc_n32_struct_flags(int soft_float, ffi_type *arg,\n       index++;\n     }\n   /* Next Argument register at alignment of FFI_SIZEOF_ARG.  */\n-  *arg_reg = ALIGN(*loc, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+  *arg_reg = FFI_ALIGN(*loc, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \n   return flags;\n }\n@@ -322,9 +325,10 @@ calc_n32_return_struct_flags(int soft_float, ffi_type *arg)\n #endif\n \n /* Perform machine dependent cif processing */\n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+static ffi_status ffi_prep_cif_machdep_int(ffi_cif *cif, unsigned nfixedargs)\n {\n   cif->flags = 0;\n+  cif->mips_nfixedargs = nfixedargs;\n \n #ifdef FFI_MIPS_O32\n   /* Set the flags necessary for O32 processing.  FFI_O32_SOFT_FLOAT\n@@ -333,7 +337,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n   if (cif->rtype->type != FFI_TYPE_STRUCT && cif->abi == FFI_O32)\n     {\n-      if (cif->nargs > 0)\n+      if (cif->nargs > 0 && cif->nargs == nfixedargs)\n \t{\n \t  switch ((cif->arg_types)[0]->type)\n \t    {\n@@ -450,7 +454,9 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     while (count-- > 0 && arg_reg < 8)\n       {\n \ttype = (cif->arg_types)[index]->type;\n-\tif (soft_float)\n+\n+\t// Pass variadic arguments in integer registers even if they're floats\n+\tif (soft_float || index >= nfixedargs)\n \t  {\n \t    switch (type)\n \t      {\n@@ -474,9 +480,9 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t    break;\n           case FFI_TYPE_LONGDOUBLE:\n             /* Align it.  */\n-            arg_reg = ALIGN(arg_reg, 2);\n+            arg_reg = FFI_ALIGN(arg_reg, 2);\n             /* Treat it as two adjacent doubles.  */\n-\t    if (soft_float) \n+\t    if (soft_float || index >= nfixedargs)\n \t      {\n \t\targ_reg += 2;\n \t      }\n@@ -493,7 +499,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n \t  case FFI_TYPE_STRUCT:\n             loc = arg_reg * FFI_SIZEOF_ARG;\n-\t    cif->flags += calc_n32_struct_flags(soft_float,\n+\t    cif->flags += calc_n32_struct_flags(soft_float || index >= nfixedargs,\n \t\t\t\t\t\t(cif->arg_types)[index],\n \t\t\t\t\t\t&loc, &arg_reg);\n \t    break;\n@@ -578,17 +584,30 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+    return ffi_prep_cif_machdep_int(cif, cif->nargs);\n+}\n+\n+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,\n+                                    unsigned nfixedargs,\n+                                    unsigned ntotalargs MAYBE_UNUSED)\n+{\n+    return ffi_prep_cif_machdep_int(cif, nfixedargs);\n+}\n+\n /* Low level routine for calling O32 functions */\n extern int ffi_call_O32(void (*)(char *, extended_cif *, int, int), \n \t\t\textended_cif *, unsigned, \n-\t\t\tunsigned, unsigned *, void (*)(void));\n+\t\t\tunsigned, unsigned *, void (*)(void), void *closure);\n \n /* Low level routine for calling N32 functions */\n extern int ffi_call_N32(void (*)(char *, extended_cif *, int, int), \n \t\t\textended_cif *, unsigned, \n-\t\t\tunsigned, void *, void (*)(void));\n+\t\t\tunsigned, void *, void (*)(void), void *closure);\n \n-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+void ffi_call_int(ffi_cif *cif, void (*fn)(void), void *rvalue, \n+\t      void **avalue, void *closure)\n {\n   extended_cif ecif;\n \n@@ -610,7 +629,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     case FFI_O32:\n     case FFI_O32_SOFT_FLOAT:\n       ffi_call_O32(ffi_prep_args, &ecif, cif->bytes, \n-\t\t   cif->flags, ecif.rvalue, fn);\n+\t\t   cif->flags, ecif.rvalue, fn, closure);\n       break;\n #endif\n \n@@ -642,7 +661,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n #endif\n \t  }\n         ffi_call_N32(ffi_prep_args, &ecif, cif->bytes,\n-                     cif->flags, rvalue_copy, fn);\n+                     cif->flags, rvalue_copy, fn, closure);\n         if (copy_rvalue)\n           memcpy(ecif.rvalue, rvalue_copy + copy_offset, cif->rtype->size);\n       }\n@@ -655,11 +674,27 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n }\n \n+void\n+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n+}\n+\n+void\n+ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,\n+\t     void **avalue, void *closure)\n+{\n+  ffi_call_int (cif, fn, rvalue, avalue, closure);\n+}\n+\n+\n #if FFI_CLOSURES\n #if defined(FFI_MIPS_O32)\n extern void ffi_closure_O32(void);\n+extern void ffi_go_closure_O32(void);\n #else\n extern void ffi_closure_N32(void);\n+extern void ffi_go_closure_N32(void);\n #endif /* FFI_MIPS_O32 */\n \n ffi_status\n@@ -744,11 +779,13 @@ ffi_prep_closure_loc (ffi_closure *closure,\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n+#if !defined(__FreeBSD__)\n #ifdef USE__BUILTIN___CLEAR_CACHE\n   __builtin___clear_cache(clear_location, clear_location + FFI_TRAMPOLINE_SIZE);\n #else\n   cacheflush (clear_location, FFI_TRAMPOLINE_SIZE, ICACHE);\n #endif\n+#endif /* ! __FreeBSD__ */\n   return FFI_OK;\n }\n \n@@ -770,27 +807,28 @@ ffi_prep_closure_loc (ffi_closure *closure,\n  * Based on the similar routine for sparc.\n  */\n int\n-ffi_closure_mips_inner_O32 (ffi_closure *closure,\n+ffi_closure_mips_inner_O32 (ffi_cif *cif,\n+                            void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t\t    void *user_data,\n \t\t\t    void *rvalue, ffi_arg *ar,\n \t\t\t    double *fpr)\n {\n-  ffi_cif *cif;\n   void **avaluep;\n   ffi_arg *avalue;\n   ffi_type **arg_types;\n   int i, avn, argn, seen_int;\n \n-  cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof (ffi_arg));\n   avaluep = alloca (cif->nargs * sizeof (ffi_arg));\n \n-  seen_int = (cif->abi == FFI_O32_SOFT_FLOAT);\n+  seen_int = (cif->abi == FFI_O32_SOFT_FLOAT) || (cif->mips_nfixedargs != cif->nargs);\n   argn = 0;\n \n   if ((cif->flags >> (FFI_FLAG_BITS * 2)) == FFI_TYPE_STRUCT)\n     {\n-      rvalue = (void *)(UINT32)ar[0];\n+      rvalue = (void *)(uintptr_t)ar[0];\n       argn = 1;\n+      seen_int = 1;\n     }\n \n   i = 0;\n@@ -799,6 +837,8 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \n   while (i < avn)\n     {\n+      if (arg_types[i]->alignment == 8 && (argn & 0x1))\n+        argn++;\n       if (i < 2 && !seen_int &&\n \t  (arg_types[i]->type == FFI_TYPE_FLOAT ||\n \t   arg_types[i]->type == FFI_TYPE_DOUBLE ||\n@@ -813,8 +853,6 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \t}\n       else\n \t{\n-\t  if (arg_types[i]->alignment == 8 && (argn & 0x1))\n-\t    argn++;\n \t  switch (arg_types[i]->type)\n \t    {\n \t      case FFI_TYPE_SINT8:\n@@ -843,12 +881,12 @@ ffi_closure_mips_inner_O32 (ffi_closure *closure,\n \t    }\n \t  seen_int = 1;\n \t}\n-      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+      argn += FFI_ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n       i++;\n     }\n \n   /* Invoke the closure. */\n-  (closure->fun) (cif, rvalue, avaluep, closure->user_data);\n+  fun(cif, rvalue, avaluep, user_data);\n \n   if (cif->abi == FFI_O32_SOFT_FLOAT)\n     {\n@@ -884,7 +922,7 @@ copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,\n       char *argp;\n       char *fpp;\n \n-      o = ALIGN(offset, elt_type->alignment);\n+      o = FFI_ALIGN(offset, elt_type->alignment);\n       arg_offset += o - offset;\n       offset = o;\n       argn += arg_offset / sizeof(ffi_arg);\n@@ -924,19 +962,19 @@ copy_struct_N32(char *target, unsigned offset, ffi_abi abi, ffi_type *type,\n  *\n  */\n int\n-ffi_closure_mips_inner_N32 (ffi_closure *closure,\n+ffi_closure_mips_inner_N32 (ffi_cif *cif, \n+\t\t\t    void (*fun)(ffi_cif*, void*, void**, void*),\n+                            void *user_data,\n \t\t\t    void *rvalue, ffi_arg *ar,\n \t\t\t    ffi_arg *fpr)\n {\n-  ffi_cif *cif;\n   void **avaluep;\n   ffi_arg *avalue;\n   ffi_type **arg_types;\n   int i, avn, argn;\n   int soft_float;\n   ffi_arg *argp;\n \n-  cif = closure->cif;\n   soft_float = cif->abi == FFI_N64_SOFT_FLOAT\n     || cif->abi == FFI_N32_SOFT_FLOAT;\n   avalue = alloca (cif->nargs * sizeof (ffi_arg));\n@@ -964,10 +1002,10 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n \t  || arg_types[i]->type == FFI_TYPE_DOUBLE\n \t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE)\n         {\n-          argp = (argn >= 8 || soft_float) ? ar + argn : fpr + argn;\n-          if ((arg_types[i]->type == FFI_TYPE_LONGDOUBLE) && ((unsigned)argp & (arg_types[i]->alignment-1)))\n+          argp = (argn >= 8 || i >= cif->mips_nfixedargs || soft_float) ? ar + argn : fpr + argn;\n+          if ((arg_types[i]->type == FFI_TYPE_LONGDOUBLE) && ((uintptr_t)argp & (arg_types[i]->alignment-1)))\n             {\n-              argp=(ffi_arg*)ALIGN(argp,arg_types[i]->alignment);\n+              argp=(ffi_arg*)FFI_ALIGN(argp,arg_types[i]->alignment);\n               argn++;\n             }\n #if defined(__MIPSEB__) || defined(_MIPSEB)\n@@ -982,7 +1020,7 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n           unsigned type = arg_types[i]->type;\n \n           if (arg_types[i]->alignment > sizeof(ffi_arg))\n-            argn = ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));\n+            argn = FFI_ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));\n \n           argp = ar + argn;\n \n@@ -1033,7 +1071,7 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n                      it was passed in registers.  */\n                   avaluep[i] = alloca(arg_types[i]->size);\n                   copy_struct_N32(avaluep[i], 0, cif->abi, arg_types[i],\n-                                  argn, 0, ar, fpr, soft_float);\n+                                  argn, 0, ar, fpr, i >= cif->mips_nfixedargs || soft_float);\n \n                   break;\n                 }\n@@ -1043,16 +1081,54 @@ ffi_closure_mips_inner_N32 (ffi_closure *closure,\n               break;\n             }\n         }\n-      argn += ALIGN(arg_types[i]->size, sizeof(ffi_arg)) / sizeof(ffi_arg);\n+      argn += FFI_ALIGN(arg_types[i]->size, sizeof(ffi_arg)) / sizeof(ffi_arg);\n       i++;\n     }\n \n   /* Invoke the closure. */\n-  (closure->fun) (cif, rvalue, avaluep, closure->user_data);\n+  fun (cif, rvalue, avaluep, user_data);\n \n   return cif->flags >> (FFI_FLAG_BITS * 8);\n }\n \n #endif /* FFI_MIPS_N32 */\n \n+#if defined(FFI_MIPS_O32)\n+extern void ffi_closure_O32(void);\n+extern void ffi_go_closure_O32(void);\n+#else\n+extern void ffi_closure_N32(void);\n+extern void ffi_go_closure_N32(void);\n+#endif /* FFI_MIPS_O32 */\n+\n+ffi_status\n+ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,\n+\t\t     void (*fun)(ffi_cif*,void*,void**,void*))\n+{\n+  void * fn;\n+\n+#if defined(FFI_MIPS_O32)\n+  if (cif->abi != FFI_O32 && cif->abi != FFI_O32_SOFT_FLOAT)\n+    return FFI_BAD_ABI;\n+  fn = ffi_go_closure_O32;\n+#else\n+#if _MIPS_SIM ==_ABIN32\n+  if (cif->abi != FFI_N32\n+      && cif->abi != FFI_N32_SOFT_FLOAT)\n+    return FFI_BAD_ABI;\n+#else\n+  if (cif->abi != FFI_N64\n+      && cif->abi != FFI_N64_SOFT_FLOAT)\n+    return FFI_BAD_ABI;\n+#endif\n+  fn = ffi_go_closure_N32;\n+#endif /* FFI_MIPS_O32 */\n+\n+  closure->tramp = (void *)fn;\n+  closure->cif = cif;\n+  closure->fun = fun;\n+\n+  return FFI_OK;\n+}\n+\n #endif /* FFI_CLOSURES */"}, {"sha": "fdd5ca90ac432e271d36feea82a21ab540e6617c", "filename": "libffi/src/mips/ffitarget.h", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -32,7 +32,7 @@\n #error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n #endif\n \n-#ifdef linux\n+#ifdef __linux__\n # include <asm/sgidefs.h>\n #elif defined(__rtems__)\n /*\n@@ -41,7 +41,7 @@\n #define _MIPS_SIM_ABI32\t\t1\n #define _MIPS_SIM_NABI32\t2\n #define _MIPS_SIM_ABI64\t\t3\n-#elif !defined(__OpenBSD__)\n+#elif !defined(__OpenBSD__) && !defined(__FreeBSD__)\n # include <sgidefs.h>\n #endif\n \n@@ -224,24 +224,21 @@ typedef enum ffi_abi {\n #endif\n } ffi_abi;\n \n-#define FFI_EXTRA_CIF_FIELDS unsigned rstruct_flag\n+#define FFI_EXTRA_CIF_FIELDS unsigned rstruct_flag; unsigned mips_nfixedargs\n+#define FFI_TARGET_SPECIFIC_VARIADIC\n #endif /* !LIBFFI_ASM */\n \n /* ---- Definitions for closures ----------------------------------------- */\n \n-#if defined(FFI_MIPS_O32)\n #define FFI_CLOSURES 1\n-#define FFI_TRAMPOLINE_SIZE 20\n-#else\n-/* N32/N64. */\n-# define FFI_CLOSURES 1\n-#if _MIPS_SIM==_ABI64\n-#define FFI_TRAMPOLINE_SIZE 52\n+#define FFI_GO_CLOSURES 1\n+#define FFI_NATIVE_RAW_API 0\n+\n+#if defined(FFI_MIPS_O32) || (_MIPS_SIM ==_ABIN32)\n+# define FFI_TRAMPOLINE_SIZE 20\n #else\n-#define FFI_TRAMPOLINE_SIZE 20\n+# define FFI_TRAMPOLINE_SIZE 56\n #endif\n-#endif /* FFI_MIPS_O32 */\n-#define FFI_NATIVE_RAW_API 0\n \n #endif\n "}, {"sha": "23b77fdfde5071c7ed4e0eefc83d35c04b8b0e9c", "filename": "libffi/src/mips/n32.S", "status": "modified", "additions": 118, "deletions": 33, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fn32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fn32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fn32.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -37,8 +37,12 @@\n #define flags\t a3\n #define raddr    a4\n #define fn       a5\n+#define closure  a6\n \n-#define SIZEOF_FRAME\t( 8 * FFI_SIZEOF_ARG )\n+/* Note: to keep stack 16 byte aligned we need even number slots \n+   used 9 slots here\n+*/\n+#define SIZEOF_FRAME\t( 10 * FFI_SIZEOF_ARG )\n \n #ifdef __GNUC__\n \t.abicalls\n@@ -51,24 +55,25 @@\n \t.globl\tffi_call_N32\n \t.ent\tffi_call_N32\n ffi_call_N32:\t\n-.LFB3:\n+.LFB0:\n \t.frame\t$fp, SIZEOF_FRAME, ra\n \t.mask\t0xc0000000,-FFI_SIZEOF_ARG\n \t.fmask\t0x00000000,0\n \n \t# Prologue\n \tSUBU\t$sp, SIZEOF_FRAME\t\t\t# Frame size\n-.LCFI0:\n+.LCFI00:\n \tREG_S\t$fp, SIZEOF_FRAME - 2*FFI_SIZEOF_ARG($sp)\t# Save frame pointer\n \tREG_S\tra, SIZEOF_FRAME - 1*FFI_SIZEOF_ARG($sp)\t# Save return address\n-.LCFI1:\n+.LCFI01:\n \tmove\t$fp, $sp\n-.LCFI3:\n+.LCFI02:\n \tmove\tt9, callback\t# callback function pointer\n \tREG_S\tbytes, 2*FFI_SIZEOF_ARG($fp) # bytes\n \tREG_S\tflags, 3*FFI_SIZEOF_ARG($fp) # flags\n \tREG_S\traddr, 4*FFI_SIZEOF_ARG($fp) # raddr\n \tREG_S\tfn,    5*FFI_SIZEOF_ARG($fp) # fn\n+\tREG_S\tclosure, 6*FFI_SIZEOF_ARG($fp) # closure\n \n \t# Allocate at least 4 words in the argstack\n \tmove\tv0, bytes\n@@ -109,6 +114,16 @@ loadregs:\n \n \tREG_L\tt6, 3*FFI_SIZEOF_ARG($fp)  # load the flags word into t6.\n \n+#ifdef __mips_soft_float\n+\tREG_L\ta0, 0*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta1, 1*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta2, 2*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta3, 3*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta4, 4*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta5, 5*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta6, 6*FFI_SIZEOF_ARG(t9)\n+\tREG_L\ta7, 7*FFI_SIZEOF_ARG(t9)\n+#else\n \tand\tt4, t6, ((1<<FFI_FLAG_BITS)-1)\n \tREG_L\ta0, 0*FFI_SIZEOF_ARG(t9)\n \tbeqz\tt4, arg1_next\n@@ -195,11 +210,15 @@ arg7_next:\n arg8_doublep:\t\n  \tl.d\t$f19, 7*FFI_SIZEOF_ARG(t9)\t\n arg8_next:\t\n+#endif\n \n callit:\t\t\n \t# Load the function pointer\n \tREG_L\tt9, 5*FFI_SIZEOF_ARG($fp)\n \n+\t# install the static chain(t7=$15)\n+\tREG_L\tt7, 6*FFI_SIZEOF_ARG($fp)\n+\n \t# If the return value pointer is NULL, assume no return value.\n \tREG_L\tt5, 4*FFI_SIZEOF_ARG($fp)\n \tbeqz\tt5, noretval\n@@ -216,6 +235,7 @@ retint:\n \tb\tepilogue\n \n retfloat:\n+#ifndef __mips_soft_float\n \tbne     t6, FFI_TYPE_FLOAT, retdouble\n \tjal\tt9\n \tREG_L\tt4, 4*FFI_SIZEOF_ARG($fp)\n@@ -274,6 +294,7 @@ retstruct_f_d:\n \ts.s\t$f0, 0(t4)\n \ts.d\t$f2, 8(t4)\n \tb\tepilogue\n+#endif\n \n retstruct_d_soft:\n \tbne\tt6, FFI_TYPE_STRUCT_D_SOFT, retstruct_f_soft\n@@ -348,7 +369,7 @@ epilogue:\n \tADDU\t$sp, SIZEOF_FRAME\t\t      # Fix stack pointer\n \tj\tra\n \n-.LFE3:\n+.LFE0:\n \t.end\tffi_call_N32\n \n /* ffi_closure_N32. Expects address of the passed-in ffi_closure in t0\n@@ -407,6 +428,41 @@ epilogue:\n #define RA_OFF2\t\t(1  * FFI_SIZEOF_ARG)\n #define GP_OFF2\t\t(0  * FFI_SIZEOF_ARG)\n \n+\t.align\t2\n+\t.globl\tffi_go_closure_N32\n+\t.ent\tffi_go_closure_N32\n+ffi_go_closure_N32:\n+.LFB1:\n+\t.frame\t$sp, SIZEOF_FRAME2, ra\n+\t.mask\t0x90000000,-(SIZEOF_FRAME2 - RA_OFF2)\n+\t.fmask\t0x00000000,0\n+\tSUBU\t$sp, SIZEOF_FRAME2\n+.LCFI10:\n+\t.cpsetup t9, GP_OFF2, ffi_go_closure_N32\n+\tREG_S\tra, RA_OFF2($sp)\t# Save return address\n+.LCFI11:\n+\n+\tREG_S\ta0, A0_OFF2($sp)\n+\tREG_S\ta1, A1_OFF2($sp)\n+\tREG_S\ta2, A2_OFF2($sp)\n+\tREG_S\ta3, A3_OFF2($sp)\n+\tREG_S\ta4, A4_OFF2($sp)\n+\tREG_S\ta5, A5_OFF2($sp)\n+\n+\t# Call ffi_closure_mips_inner_N32 to do the real work.\n+\tLA\tt9, ffi_closure_mips_inner_N32\n+\tREG_L\ta0, 8($15)   # cif\n+\tREG_L\ta1, 16($15) # fun\n+\tmove\ta2, t7                     # userdata=closure\n+\tADDU\ta3, $sp, V0_OFF2           # rvalue\n+\tADDU\ta4, $sp, A0_OFF2           # ar\n+\tADDU\ta5, $sp, F12_OFF2          # fpr\n+\n+\tb\t$do_closure\n+\n+.LFE1:\t\n+\t.end\tffi_go_closure_N32\n+\n \t.align\t2\n \t.globl\tffi_closure_N32\n \t.ent\tffi_closure_N32\n@@ -416,21 +472,33 @@ ffi_closure_N32:\n \t.mask\t0x90000000,-(SIZEOF_FRAME2 - RA_OFF2)\n \t.fmask\t0x00000000,0\n \tSUBU\t$sp, SIZEOF_FRAME2\n-.LCFI5:\n+.LCFI20:\n \t.cpsetup t9, GP_OFF2, ffi_closure_N32\n \tREG_S\tra, RA_OFF2($sp)\t# Save return address\n-.LCFI6:\n-\t# Store all possible argument registers. If there are more than\n-\t# fit in registers, then they were stored on the stack.\n+.LCFI21:\n \tREG_S\ta0, A0_OFF2($sp)\n \tREG_S\ta1, A1_OFF2($sp)\n \tREG_S\ta2, A2_OFF2($sp)\n \tREG_S\ta3, A3_OFF2($sp)\n \tREG_S\ta4, A4_OFF2($sp)\n \tREG_S\ta5, A5_OFF2($sp)\n+\n+\t# Call ffi_closure_mips_inner_N32 to do the real work.\n+\tLA\tt9, ffi_closure_mips_inner_N32\n+\tREG_L\ta0, 56($12)   # cif\n+\tREG_L\ta1, 64($12)   # fun\n+\tREG_L\ta2, 72($12) # user_data\n+\tADDU\ta3, $sp, V0_OFF2\n+\tADDU\ta4, $sp, A0_OFF2\n+\tADDU\ta5, $sp, F12_OFF2\n+\n+$do_closure:\n+\t# Store all possible argument registers. If there are more than\n+\t# fit in registers, then they were stored on the stack.\n \tREG_S\ta6, A6_OFF2($sp)\n \tREG_S\ta7, A7_OFF2($sp)\n \n+#ifndef __mips_soft_float\n \t# Store all possible float/double registers.\n \ts.d\t$f12, F12_OFF2($sp)\n \ts.d\t$f13, F13_OFF2($sp)\n@@ -440,13 +508,8 @@ ffi_closure_N32:\n \ts.d\t$f17, F17_OFF2($sp)\n \ts.d\t$f18, F18_OFF2($sp)\n \ts.d\t$f19, F19_OFF2($sp)\n+#endif\n \n-\t# Call ffi_closure_mips_inner_N32 to do the real work.\n-\tLA\tt9, ffi_closure_mips_inner_N32\n-\tmove\ta0, $12\t # Pointer to the ffi_closure\n-\tADDU\ta1, $sp, V0_OFF2\n-\tADDU\ta2, $sp, A0_OFF2\n-\tADDU\ta3, $sp, F12_OFF2\n \tjalr\tt9\n \n \t# Return flags are in v0\n@@ -460,6 +523,7 @@ cls_retint:\n \tb\tcls_epilogue\n \n cls_retfloat:\n+#ifndef __mips_soft_float\n \tbne     v0, FFI_TYPE_FLOAT, cls_retdouble\n \tl.s\t$f0, V0_OFF2($sp)\n \tb\tcls_epilogue\n@@ -502,6 +566,7 @@ cls_retstruct_f_d:\n \tl.s\t$f0, V0_OFF2($sp)\n \tl.d\t$f2, V1_OFF2($sp)\n \tb\tcls_epilogue\n+#endif\n \t\n cls_retstruct_small2:\t\n \tREG_L\tv0, V0_OFF2($sp)\n@@ -517,7 +582,7 @@ cls_epilogue:\n \t.end\tffi_closure_N32\n \n #ifdef __GNUC__\n-        .section        .eh_frame,\"aw\",@progbits\n+        .section        .eh_frame,EH_FRAME_FLAGS,@progbits\n .Lframe1:\n         .4byte  .LECIE1-.LSCIE1\t\t# length\n .LSCIE1:\n@@ -533,46 +598,66 @@ cls_epilogue:\n         .align  EH_FRAME_ALIGN\n .LECIE1:\n \n-.LSFDE1:\n-        .4byte  .LEFDE1-.LASFDE1\t# length.\n-.LASFDE1:\n-        .4byte  .LASFDE1-.Lframe1\t# CIE_pointer.\n-        FDE_ADDR_BYTES  .LFB3\t\t# initial_location.\n-        FDE_ADDR_BYTES  .LFE3-.LFB3\t# address_range.\n+.LSFDE0:\n+        .4byte  .LEFDE0-.LASFDE0\t# length.\n+.LASFDE0:\n+        .4byte  .LASFDE0-.Lframe1\t# CIE_pointer.\n+        FDE_ADDR_BYTES  .LFB0\t\t# initial_location.\n+        FDE_ADDR_BYTES  .LFE0-.LFB0\t# address_range.\n         .byte   0x4\t\t\t# DW_CFA_advance_loc4\n-        .4byte  .LCFI0-.LFB3\t\t# to .LCFI0\n+        .4byte  .LCFI00-.LFB0\t\t# to .LCFI00\n         .byte   0xe\t\t\t# DW_CFA_def_cfa_offset\n         .uleb128 SIZEOF_FRAME\t\t# adjust stack.by SIZEOF_FRAME\n         .byte   0x4\t\t\t# DW_CFA_advance_loc4\n-        .4byte  .LCFI1-.LCFI0\t\t# to .LCFI1\n+        .4byte  .LCFI01-.LCFI00\t\t# to .LCFI01\n         .byte   0x9e\t\t\t# DW_CFA_offset of $fp\n         .uleb128 2*FFI_SIZEOF_ARG/4\t# \n         .byte   0x9f\t\t\t# DW_CFA_offset of ra\n         .uleb128 1*FFI_SIZEOF_ARG/4\t# \n         .byte   0x4\t\t\t# DW_CFA_advance_loc4\n-        .4byte  .LCFI3-.LCFI1\t\t# to .LCFI3\n+        .4byte  .LCFI02-.LCFI01\t\t# to .LCFI02\n         .byte   0xd\t\t\t# DW_CFA_def_cfa_register\n         .uleb128 0x1e\t\t\t# in $fp\n         .align  EH_FRAME_ALIGN\n+.LEFDE0:\n+\n+.LSFDE1:\n+\t.4byte\t.LEFDE1-.LASFDE1\t# length\n+.LASFDE1:\n+\t.4byte\t.LASFDE1-.Lframe1\t# CIE_pointer.\n+\tFDE_ADDR_BYTES\t.LFB1\t\t# initial_location.\n+\tFDE_ADDR_BYTES\t.LFE1-.LFB1\t# address_range.\n+\t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI10-.LFB1\t\t# to .LCFI10\n+\t.byte\t0xe\t\t\t# DW_CFA_def_cfa_offset\n+\t.uleb128 SIZEOF_FRAME2\t\t# adjust stack.by SIZEOF_FRAME\n+\t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI11-.LCFI10\t\t# to .LCFI11\n+\t.byte\t0x9c\t\t\t# DW_CFA_offset of $gp ($28)\n+\t.uleb128 (SIZEOF_FRAME2 - GP_OFF2)/4\n+\t.byte\t0x9f\t\t\t# DW_CFA_offset of ra ($31)\n+\t.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4\n+\t.align\tEH_FRAME_ALIGN\n .LEFDE1:\n-.LSFDE3:\n-\t.4byte\t.LEFDE3-.LASFDE3\t# length\n-.LASFDE3:\n-\t.4byte\t.LASFDE3-.Lframe1\t# CIE_pointer.\n+\n+.LSFDE2:\n+\t.4byte\t.LEFDE2-.LASFDE2\t# length\n+.LASFDE2:\n+\t.4byte\t.LASFDE2-.Lframe1\t# CIE_pointer.\n \tFDE_ADDR_BYTES\t.LFB2\t\t# initial_location.\n \tFDE_ADDR_BYTES\t.LFE2-.LFB2\t# address_range.\n \t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI5-.LFB2\t\t# to .LCFI5\n+\t.4byte\t.LCFI20-.LFB2\t\t# to .LCFI20\n \t.byte\t0xe\t\t\t# DW_CFA_def_cfa_offset\n \t.uleb128 SIZEOF_FRAME2\t\t# adjust stack.by SIZEOF_FRAME\n \t.byte\t0x4\t\t\t# DW_CFA_advance_loc4\n-\t.4byte\t.LCFI6-.LCFI5\t\t# to .LCFI6\n+\t.4byte\t.LCFI21-.LCFI20\t\t# to .LCFI21\n \t.byte\t0x9c\t\t\t# DW_CFA_offset of $gp ($28)\n \t.uleb128 (SIZEOF_FRAME2 - GP_OFF2)/4\n \t.byte\t0x9f\t\t\t# DW_CFA_offset of ra ($31)\n \t.uleb128 (SIZEOF_FRAME2 - RA_OFF2)/4\n \t.align\tEH_FRAME_ALIGN\n-.LEFDE3:\n+.LEFDE2:\n #endif /* __GNUC__ */\t\n \t\n #endif"}, {"sha": "799139b2968b10e43788590a49c86d5adb065673", "filename": "libffi/src/mips/o32.S", "status": "modified", "additions": 150, "deletions": 27, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fo32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmips%2Fo32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fo32.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -50,14 +50,14 @@ ffi_call_O32:\n $LFB0:\n \t# Prologue\n \tSUBU\t$sp, SIZEOF_FRAME\t# Frame size\n-$LCFI0:\n+$LCFI00:\n \tREG_S\t$fp, FP_OFF($sp)\t# Save frame pointer\n-$LCFI1:\n+$LCFI01:\n \tREG_S\tra, RA_OFF($sp)\t\t# Save return address\n-$LCFI2:\n+$LCFI02:\n \tmove\t$fp, $sp\n \n-$LCFI3:\n+$LCFI03:\n \tmove\tt9, callback\t\t# callback function pointer\n \tREG_S\tflags, A3_OFF($fp)\t# flags\n \n@@ -82,13 +82,16 @@ sixteen:\n \t\t\n \tADDU\t$sp, 4 * FFI_SIZEOF_ARG\t\t# adjust $sp to new args\n \n+#ifndef __mips_soft_float\n \tbnez\tt0, pass_d\t\t\t# make it quick for int\n+#endif\n \tREG_L\ta0, 0*FFI_SIZEOF_ARG($sp)\t# just go ahead and load the\n \tREG_L\ta1, 1*FFI_SIZEOF_ARG($sp)\t# four regs.\n \tREG_L\ta2, 2*FFI_SIZEOF_ARG($sp)\n \tREG_L\ta3, 3*FFI_SIZEOF_ARG($sp)\n \tb\tcall_it\n \n+#ifndef __mips_soft_float\n pass_d:\n \tbne\tt0, FFI_ARGS_D, pass_f\n \tl.d\t$f12, 0*FFI_SIZEOF_ARG($sp)\t# load $fp regs from args\n@@ -130,8 +133,12 @@ pass_f_d:\n  #\tbne\tt0, FFI_ARGS_F_D, call_it\n \tl.s\t$f12, 0*FFI_SIZEOF_ARG($sp)\t# load $fp regs from args\n \tl.d\t$f14, 2*FFI_SIZEOF_ARG($sp)\t# passing double and float\n+#endif\n \n call_it:\t\n+\t# Load the static chain pointer\n+\tREG_L\tt7, SIZEOF_FRAME + 6*FFI_SIZEOF_ARG($fp)\n+\n \t# Load the function pointer\n \tREG_L\tt9, SIZEOF_FRAME + 5*FFI_SIZEOF_ARG($fp)\n \n@@ -158,14 +165,23 @@ retfloat:\n \tbne     t2, FFI_TYPE_FLOAT, retdouble\n \tjalr\tt9\n \tREG_L\tt0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)\n+#ifndef __mips_soft_float\n \ts.s\t$f0, 0(t0)\n+#else\n+\tREG_S\tv0, 0(t0)\n+#endif\n \tb\tepilogue\n \n retdouble:\t\n \tbne\tt2, FFI_TYPE_DOUBLE, noretval\n \tjalr\tt9\n \tREG_L\tt0, SIZEOF_FRAME + 4*FFI_SIZEOF_ARG($fp)\n+#ifndef __mips_soft_float\n \ts.d\t$f0, 0(t0)\n+#else\n+\tREG_S\tv1, 4(t0)\n+\tREG_S\tv0, 0(t0)\n+#endif\n \tb\tepilogue\n \t\n noretval:\t\n@@ -204,13 +220,15 @@ $LFE0:\n \t-8 - f14 (le low, be high)\n \t-9 - f12 (le high, be low)\n        -10 - f12 (le low, be high)\n-       -11 - Called function a3 save\n-       -12 - Called function a2 save\n-       -13 - Called function a1 save\n-       -14 - Called function a0 save, our sp and fp point here\n+       -11 - Called function a5 save\n+       -12 - Called function a4 save\n+       -13 - Called function a3 save\n+       -14 - Called function a2 save\n+       -15 - Called function a1 save\n+       -16 - Called function a0 save, our sp and fp point here\n \t */\n \t\n-#define SIZEOF_FRAME2\t(14 * FFI_SIZEOF_ARG)\n+#define SIZEOF_FRAME2\t(16 * FFI_SIZEOF_ARG)\n #define A3_OFF2\t\t(SIZEOF_FRAME2 + 3 * FFI_SIZEOF_ARG)\n #define A2_OFF2\t\t(SIZEOF_FRAME2 + 2 * FFI_SIZEOF_ARG)\n #define A1_OFF2\t\t(SIZEOF_FRAME2 + 1 * FFI_SIZEOF_ARG)\n@@ -225,28 +243,88 @@ $LFE0:\n #define FA_1_0_OFF2\t(SIZEOF_FRAME2 - 8 * FFI_SIZEOF_ARG)\n #define FA_0_1_OFF2\t(SIZEOF_FRAME2 - 9 * FFI_SIZEOF_ARG)\n #define FA_0_0_OFF2\t(SIZEOF_FRAME2 - 10 * FFI_SIZEOF_ARG)\n+#define CALLED_A5_OFF2  (SIZEOF_FRAME2 - 11 * FFI_SIZEOF_ARG)\n+#define CALLED_A4_OFF2  (SIZEOF_FRAME2 - 12 * FFI_SIZEOF_ARG)\n \n \t.text\n+\n+\t.align\t2\n+\t.globl\tffi_go_closure_O32\n+\t.ent\tffi_go_closure_O32\n+ffi_go_closure_O32:\n+$LFB1:\n+\t# Prologue\n+\t.frame\t$fp, SIZEOF_FRAME2, ra\n+\t.set\tnoreorder\n+\t.cpload\tt9\n+\t.set\treorder\n+\tSUBU\t$sp, SIZEOF_FRAME2\n+\t.cprestore GP_OFF2\n+$LCFI10:\n+\n+\tREG_S\t$16, S0_OFF2($sp)\t # Save s0\n+\tREG_S\t$fp, FP_OFF2($sp)\t # Save frame pointer\n+\tREG_S\tra, RA_OFF2($sp)\t # Save return address\n+$LCFI11:\n+\n+\tmove\t$fp, $sp\n+$LCFI12:\n+\n+\tREG_S\ta0, A0_OFF2($fp)\n+\tREG_S\ta1, A1_OFF2($fp)\n+\tREG_S\ta2, A2_OFF2($fp)\n+\tREG_S\ta3, A3_OFF2($fp)\n+\n+\t# Load ABI enum to s0\n+\tREG_L\t$16, 4($15)\t# cif \n+\tREG_L\t$16, 0($16)\t# abi is first member.\n+\n+\tli\t$13, 1\t\t# FFI_O32\n+\tbne\t$16, $13, 1f\t# Skip fp save if FFI_O32_SOFT_FLOAT\n+\t\n+#ifndef __mips_soft_float\n+\t# Store all possible float/double registers.\n+\ts.d\t$f12, FA_0_0_OFF2($fp)\n+\ts.d\t$f14, FA_1_0_OFF2($fp)\n+#endif\n+1:\n+\t# prepare arguments for ffi_closure_mips_inner_O32\n+\tREG_L\ta0, 4($15)\t # cif \n+\tREG_L\ta1, 8($15)\t # fun\n+\tmove\ta2, $15\t\t # user_data = go closure\n+\taddu\ta3, $fp, V0_OFF2 # rvalue\n+\n+\taddu\tt9, $fp, A0_OFF2 # ar\n+\tREG_S   t9, CALLED_A4_OFF2($fp)\n+\n+\taddu\tt9, $fp, FA_0_0_OFF2 #fpr\n+\tREG_S   t9, CALLED_A5_OFF2($fp)\n+\n+\tb $do_closure\n+\n+$LFE1:\n+\t.end ffi_go_closure_O32\n+\n \t.align\t2\n \t.globl\tffi_closure_O32\n \t.ent\tffi_closure_O32\n ffi_closure_O32:\n-$LFB1:\n+$LFB2:\n \t# Prologue\n \t.frame\t$fp, SIZEOF_FRAME2, ra\n \t.set\tnoreorder\n \t.cpload\tt9\n \t.set\treorder\n \tSUBU\t$sp, SIZEOF_FRAME2\n \t.cprestore GP_OFF2\n-$LCFI4:\n+$LCFI20:\n \tREG_S\t$16, S0_OFF2($sp)\t # Save s0\n \tREG_S\t$fp, FP_OFF2($sp)\t # Save frame pointer\n \tREG_S\tra, RA_OFF2($sp)\t # Save return address\n-$LCFI6:\n+$LCFI21:\n \tmove\t$fp, $sp\n \n-$LCFI7:\n+$LCFI22:\n \t# Store all possible argument registers. If there are more than\n \t# four arguments, then they are stored above where we put a3.\n \tREG_S\ta0, A0_OFF2($fp)\n@@ -261,16 +339,27 @@ $LCFI7:\n \tli\t$13, 1\t\t# FFI_O32\n \tbne\t$16, $13, 1f\t# Skip fp save if FFI_O32_SOFT_FLOAT\n \t\n+#ifndef __mips_soft_float\n \t# Store all possible float/double registers.\n \ts.d\t$f12, FA_0_0_OFF2($fp)\n \ts.d\t$f14, FA_1_0_OFF2($fp)\n+#endif\n 1:\t\n-\t# Call ffi_closure_mips_inner_O32 to do the work.\n+\t# prepare arguments for ffi_closure_mips_inner_O32\n+\tREG_L\ta0, 20($12)\t # cif pointer follows tramp.\n+\tREG_L\ta1, 24($12)\t # fun\n+\tREG_L\ta2, 28($12)\t # user_data\n+\taddu\ta3, $fp, V0_OFF2 # rvalue\n+\n+\taddu\tt9, $fp, A0_OFF2 # ar\n+\tREG_S   t9, CALLED_A4_OFF2($fp)\n+\n+\taddu\tt9, $fp, FA_0_0_OFF2 #fpr\n+\tREG_S   t9, CALLED_A5_OFF2($fp)\n+\n+$do_closure:\n \tla\tt9, ffi_closure_mips_inner_O32\n-\tmove\ta0, $12\t # Pointer to the ffi_closure\n-\taddu\ta1, $fp, V0_OFF2\n-\taddu\ta2, $fp, A0_OFF2\n-\taddu\ta3, $fp, FA_0_0_OFF2\n+\t# Call ffi_closure_mips_inner_O32 to do the work.\n \tjalr\tt9\n \n \t# Load the return value into the appropriate register.\n@@ -281,13 +370,15 @@ $LCFI7:\n \tli\t$13, 1\t\t# FFI_O32\n \tbne\t$16, $13, 1f\t# Skip fp restore if FFI_O32_SOFT_FLOAT\n \n+#ifndef __mips_soft_float\n \tli\t$9, FFI_TYPE_FLOAT\n \tl.s\t$f0, V0_OFF2($fp)\n \tbeq\t$8, $9, closure_done\n \n \tli\t$9, FFI_TYPE_DOUBLE\n \tl.d\t$f0, V0_OFF2($fp)\n \tbeq\t$8, $9, closure_done\n+#endif\n 1:\t\n \tREG_L\t$3, V1_OFF2($fp)\n \tREG_L\t$2, V0_OFF2($fp)\n@@ -300,7 +391,7 @@ closure_done:\n \tREG_L\tra,  RA_OFF2($sp)\t # Restore return address\n \tADDU\t$sp, SIZEOF_FRAME2\n \tj\tra\n-$LFE1:\n+$LFE2:\n \t.end\tffi_closure_O32\n \n /* DWARF-2 unwind info. */\n@@ -322,6 +413,7 @@ $LSCIE0:\n \t.uleb128 0x0\n \t.align\t2\n $LECIE0:\n+\n $LSFDE0:\n \t.4byte\t$LEFDE0-$LASFDE0\t # FDE Length\n $LASFDE0:\n@@ -330,24 +422,25 @@ $LASFDE0:\n \t.4byte\t$LFE0-$LFB0\t # FDE address range\n \t.uleb128 0x0\t # Augmentation size\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI0-$LFB0\n+\t.4byte\t$LCFI00-$LFB0\n \t.byte\t0xe\t # DW_CFA_def_cfa_offset\n \t.uleb128 0x18\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI2-$LCFI0\n+\t.4byte\t$LCFI01-$LCFI00\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x1e\t # $fp\n \t.sleb128 -2\t # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x1f\t # $ra\n \t.sleb128 -1\t # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI3-$LCFI2\n+\t.4byte\t$LCFI02-$LCFI01\n \t.byte\t0xc\t # DW_CFA_def_cfa\n \t.uleb128 0x1e\n \t.uleb128 0x18\n \t.align\t2\n $LEFDE0:\n+\n $LSFDE1:\n \t.4byte\t$LEFDE1-$LASFDE1\t # FDE Length\n $LASFDE1:\n@@ -356,11 +449,11 @@ $LASFDE1:\n \t.4byte\t$LFE1-$LFB1\t # FDE address range\n \t.uleb128 0x0\t # Augmentation size\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI4-$LFB1\n+\t.4byte\t$LCFI10-$LFB1\n \t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 0x38\n+\t.uleb128 SIZEOF_FRAME2\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI6-$LCFI4\n+\t.4byte\t$LCFI11-$LCFI10\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x10\t # $16\n \t.sleb128 -3\t # SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\n@@ -371,11 +464,41 @@ $LASFDE1:\n \t.uleb128 0x1f\t # $ra\n \t.sleb128 -1\t # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\n \t.byte\t0x4\t # DW_CFA_advance_loc4\n-\t.4byte\t$LCFI7-$LCFI6\n+\t.4byte\t$LCFI12-$LCFI11\n \t.byte\t0xc\t # DW_CFA_def_cfa\n \t.uleb128 0x1e\n-\t.uleb128 0x38\n+\t.uleb128 SIZEOF_FRAME2\n \t.align\t2\n $LEFDE1:\n \n+$LSFDE2:\n+\t.4byte\t$LEFDE2-$LASFDE2\t # FDE Length\n+$LASFDE2:\n+\t.4byte\t$LASFDE2-$Lframe0\t # FDE CIE offset\n+\t.4byte\t$LFB2\t # FDE initial location\n+\t.4byte\t$LFE2-$LFB2\t # FDE address range\n+\t.uleb128 0x0\t # Augmentation size\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI20-$LFB2\n+\t.byte\t0xe\t # DW_CFA_def_cfa_offset\n+\t.uleb128 SIZEOF_FRAME2\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI21-$LCFI20\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x10\t # $16\n+\t.sleb128 -3\t # SIZEOF_FRAME2 - 3*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1e\t # $fp\n+\t.sleb128 -2\t # SIZEOF_FRAME2 - 2*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x11\t # DW_CFA_offset_extended_sf\n+\t.uleb128 0x1f\t # $ra\n+\t.sleb128 -1\t # SIZEOF_FRAME2 - 1*FFI_SIZEOF_ARG($sp)\n+\t.byte\t0x4\t # DW_CFA_advance_loc4\n+\t.4byte\t$LCFI22-$LCFI21\n+\t.byte\t0xc\t # DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 SIZEOF_FRAME2\n+\t.align\t2\n+$LEFDE2:\n+\n #endif"}, {"sha": "10cfb0448ea937a1c258cb6545af15b062376b9b", "filename": "libffi/src/moxie/eabi.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmoxie%2Feabi.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmoxie%2Feabi.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmoxie%2Feabi.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -59,7 +59,7 @@ ffi_call_EABI:\n \tmov \t$r6, $r4 /* Save result buffer */\n \tmov\t$r7, $r5 /* Save the target fn */\n \tmov\t$r8, $r3 /* Save the flags */\n-\tsub.l\t$sp, $r2 /* Allocate stack space */\n+\tsub\t$sp, $r2 /* Allocate stack space */\n \tmov\t$r0, $sp /* We can stomp over $r0 */\n \t/* $r1 is already set up */\n \tjsra \tffi_prep_args"}, {"sha": "16d2bb37c8eaa19bec89b15cbbcc8ca061050f51", "filename": "libffi/src/moxie/ffi.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmoxie%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fmoxie%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmoxie%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (C) 2012, 2013  Anthony Green\n+   ffi.c - Copyright (C) 2012, 2013, 2018  Anthony Green\n    \n    Moxie Foreign Function Interface \n \n@@ -100,7 +100,7 @@ void *ffi_prep_args(char *stack, extended_cif *ecif)\n       count += z;\n     }\n \n-  return (stack + ((count > 24) ? 24 : ALIGN_DOWN(count, 8)));\n+  return (stack + ((count > 24) ? 24 : FFI_ALIGN_DOWN(count, 8)));\n }\n \n /* Perform machine dependent cif processing */\n@@ -111,7 +111,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   else\n     cif->flags = cif->rtype->size;\n \n-  cif->bytes = ALIGN (cif->bytes, 8);\n+  cif->bytes = FFI_ALIGN (cif->bytes, 8);\n \n   return FFI_OK;\n }\n@@ -159,7 +159,7 @@ void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,\n \t\t       unsigned arg4, unsigned arg5, unsigned arg6)\n {\n   /* This function is called by a trampoline.  The trampoline stows a\n-     pointer to the ffi_closure object in $r7.  We must save this\n+     pointer to the ffi_closure object in $r12.  We must save this\n      pointer in a place that will persist while we do our work.  */\n   register ffi_closure *creg __asm__ (\"$r12\");\n   ffi_closure *closure = creg;\n@@ -215,16 +215,29 @@ void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,\n \t  break;\n \tdefault:\n \t  /* This is an 8-byte value.  */\n-\t  avalue[i] = ptr;\n+\t  if (ptr == (char *) &register_args[5])\n+\t    {\n+\t      /* The value is split across two locations */\n+\t      unsigned *ip = alloca(8);\n+\t      avalue[i] = ip;\n+\t      ip[0] = *(unsigned *) ptr;\n+\t      ip[1] = *(unsigned *) stack_args;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = ptr;\n+\t    }\n \t  ptr += 4;\n \t  break;\n \t}\n       ptr += 4;\n \n       /* If we've handled more arguments than fit in registers,\n \t start looking at the those passed on the stack.  */\n-      if (ptr == &register_args[6])\n+      if (ptr == (char *) &register_args[6])\n \tptr = stack_args;\n+      else if (ptr == (char *) &register_args[7])\n+\tptr = stack_args + 4;\n     }\n \n   /* Invoke the closure.  */\n@@ -257,7 +270,7 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   fn = (unsigned long) ffi_closure_eabi;\n \n-  tramp[0] = 0x01e0; /* ldi.l $r7, .... */\n+  tramp[0] = 0x01e0; /* ldi.l $r12, .... */\n   tramp[1] = cls >> 16;\n   tramp[2] = cls & 0xffff;\n   tramp[3] = 0x1a00; /* jmpa .... */"}, {"sha": "721080d45ebe2990aa46cad8b899feef5b86c210", "filename": "libffi/src/nios2/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fnios2%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fnios2%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fnios2%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -101,7 +101,7 @@ void ffi_prep_args (char *stack, extended_cif *ecif)\n \n       /* Align argp as appropriate for the argument type.  */\n       if ((alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, alignment);\n+\targp = (char *) FFI_ALIGN (argp, alignment);\n \n       /* Copy the argument, promoting integral types smaller than a\n \t word to word size.  */\n@@ -230,7 +230,7 @@ ffi_closure_helper (unsigned char *args,\n \n       /* Align argp as appropriate for the argument type.  */\n       if ((alignment - 1) & (unsigned) argp)\n-\targp = (char *) ALIGN (argp, alignment);\n+\targp = (char *) FFI_ALIGN (argp, alignment);\n \n       /* Arguments smaller than an int are promoted to int.  */\n       if (size < sizeof (int))"}, {"sha": "95e669473e1ecda58a1d5f50e05b7b132b414b5c", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 59, "deletions": 157, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,6 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - (c) 2016 John David Anglin\n-\t   (c) 2011 Anthony Green\n+   ffi.c - (c) 2011 Anthony Green\n            (c) 2008 Red Hat, Inc.\n \t   (c) 2006 Free Software Foundation, Inc.\n            (c) 2003-2004 Randolph Chung <tausq@debian.org>\n@@ -52,8 +51,7 @@\n \n #define debug(lvl, x...) do { if (lvl <= DEBUG_LEVEL) { printf(x); } } while (0)\n \n-static inline int\n-ffi_struct_type (ffi_type *t)\n+static inline int ffi_struct_type(ffi_type *t)\n {\n   size_t sz = t->size;\n \n@@ -141,8 +139,7 @@ ffi_struct_type (ffi_type *t)\n    NOTE: We load floating point args in this function... that means we\n    assume gcc will not mess with fp regs in here.  */\n \n-void\n-ffi_prep_args_pa32 (UINT32 *stack, extended_cif *ecif, unsigned bytes)\n+void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n {\n   register unsigned int i;\n   register ffi_type **p_arg;\n@@ -278,8 +275,7 @@ ffi_prep_args_pa32 (UINT32 *stack, extended_cif *ecif, unsigned bytes)\n   return;\n }\n \n-static void\n-ffi_size_stack_pa32 (ffi_cif *cif)\n+static void ffi_size_stack_pa32(ffi_cif *cif)\n {\n   ffi_type **ptr;\n   int i;\n@@ -320,8 +316,7 @@ ffi_size_stack_pa32 (ffi_cif *cif)\n }\n \n /* Perform machine dependent cif processing.  */\n-ffi_status\n-ffi_prep_cif_machdep (ffi_cif *cif)\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n   /* Set the return type flag */\n   switch (cif->rtype->type)\n@@ -374,13 +369,11 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   return FFI_OK;\n }\n \n-extern void ffi_call_pa32 (void (*)(UINT32 *, extended_cif *, unsigned),\n-\t\t\t   extended_cif *, unsigned, unsigned, unsigned *,\n-\t\t\t   void (*fn)(void), void *closure);\n+extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),\n+\t\t\t  extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t  void (*fn)(void));\n \n-static void\n-ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n-\t      void *closure)\n+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -408,8 +401,8 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n     {\n     case FFI_PA32:\n       debug(3, \"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n-      ffi_call_pa32 (ffi_prep_args_pa32, &ecif, cif->bytes,\n-\t\t     cif->flags, ecif.rvalue, fn, closure);\n+      ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,\n+\t\t     cif->flags, ecif.rvalue, fn);\n       break;\n \n     default:\n@@ -418,60 +411,35 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n     }\n }\n \n-void\n-ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n-{\n-  ffi_call_int (cif, fn, rvalue, avalue, NULL);\n-}\n-\n-void\n-ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue,\n-\t     void *closure)\n-{\n-  ffi_call_int (cif, fn, rvalue, avalue, closure);\n-}\n-\n #if FFI_CLOSURES\n /* This is more-or-less an inverse of ffi_call -- we have arguments on\n    the stack, and we need to fill them into a cif structure and invoke\n    the user function. This really ought to be in asm to make sure\n    the compiler doesn't do things we don't expect.  */\n-ffi_status\n-ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n+ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n {\n   ffi_cif *cif;\n-  void (*fun)(ffi_cif *,void *,void **,void *); \n-  void *user_data;\n   void **avalue;\n   void *rvalue;\n-  UINT32 ret[2]; /* function can return up to 64-bits in registers */\n+  /* Functions can return up to 64-bits in registers.  Return address\n+     must be double word aligned.  */\n+  union { double rd; UINT32 ret[2]; } u;\n   ffi_type **p_arg;\n   char *tmp;\n   int i, avn;\n   unsigned int slot = FIRST_ARG_SLOT;\n   register UINT32 r28 asm(\"r28\");\n+  ffi_closure *c = (ffi_closure *)FFI_RESTORE_PTR (closure);\n \n-  /* A non-zero closure type indicates a go closure.  */\n-  if (closure_type)\n-    {\n-      cif = ((ffi_go_closure *)closure)->cif;\n-      fun = ((ffi_go_closure *)closure)->fun;\n-      user_data = closure;\n-    }\n-  else\n-    {\n-      cif = ((ffi_closure *)closure)->cif;\n-      fun = ((ffi_closure *)closure)->fun;\n-      user_data = ((ffi_closure *)closure)->user_data;\n-    }\n+  cif = closure->cif;\n \n   /* If returning via structure, callee will write to our pointer.  */\n   if (cif->flags == FFI_TYPE_STRUCT)\n     rvalue = (void *)r28;\n   else\n-    rvalue = &ret[0];\n+    rvalue = &u;\n \n-  avalue = (void **) alloca (cif->nargs * FFI_SIZEOF_ARG);\n+  avalue = (void **)alloca(cif->nargs * FFI_SIZEOF_ARG);\n   avn = cif->nargs;\n   p_arg = cif->arg_types;\n \n@@ -564,35 +532,35 @@ ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n     }\n \n   /* Invoke the closure.  */\n-  fun (cif, rvalue, avalue, user_data);\n+  (c->fun) (cif, rvalue, avalue, c->user_data);\n \n-  debug(3, \"after calling function, ret[0] = %08x, ret[1] = %08x\\n\", ret[0],\n-\tret[1]);\n+  debug(3, \"after calling function, ret[0] = %08x, ret[1] = %08x\\n\", u.ret[0],\n+\tu.ret[1]);\n \n   /* Store the result using the lower 2 bytes of the flags.  */\n   switch (cif->flags)\n     {\n     case FFI_TYPE_UINT8:\n-      *(stack - FIRST_ARG_SLOT) = (UINT8)(ret[0] >> 24);\n+      *(stack - FIRST_ARG_SLOT) = (UINT8)(u.ret[0] >> 24);\n       break;\n     case FFI_TYPE_SINT8:\n-      *(stack - FIRST_ARG_SLOT) = (SINT8)(ret[0] >> 24);\n+      *(stack - FIRST_ARG_SLOT) = (SINT8)(u.ret[0] >> 24);\n       break;\n     case FFI_TYPE_UINT16:\n-      *(stack - FIRST_ARG_SLOT) = (UINT16)(ret[0] >> 16);\n+      *(stack - FIRST_ARG_SLOT) = (UINT16)(u.ret[0] >> 16);\n       break;\n     case FFI_TYPE_SINT16:\n-      *(stack - FIRST_ARG_SLOT) = (SINT16)(ret[0] >> 16);\n+      *(stack - FIRST_ARG_SLOT) = (SINT16)(u.ret[0] >> 16);\n       break;\n     case FFI_TYPE_INT:\n     case FFI_TYPE_SINT32:\n     case FFI_TYPE_UINT32:\n-      *(stack - FIRST_ARG_SLOT) = ret[0];\n+      *(stack - FIRST_ARG_SLOT) = u.ret[0];\n       break;\n     case FFI_TYPE_SINT64:\n     case FFI_TYPE_UINT64:\n-      *(stack - FIRST_ARG_SLOT) = ret[0];\n-      *(stack - FIRST_ARG_SLOT - 1) = ret[1];\n+      *(stack - FIRST_ARG_SLOT) = u.ret[0];\n+      *(stack - FIRST_ARG_SLOT - 1) = u.ret[1];\n       break;\n \n     case FFI_TYPE_DOUBLE:\n@@ -612,7 +580,7 @@ ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n     case FFI_TYPE_SMALL_STRUCT4:\n       tmp = (void*)(stack -  FIRST_ARG_SLOT);\n       tmp += 4 - cif->rtype->size;\n-      memcpy((void*)tmp, &ret[0], cif->rtype->size);\n+      memcpy((void*)tmp, &u, cif->rtype->size);\n       break;\n \n     case FFI_TYPE_SMALL_STRUCT5:\n@@ -633,7 +601,7 @@ ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n \t  }\n \n \tmemset (ret2, 0, sizeof (ret2));\n-\tmemcpy ((char *)ret2 + off, ret, 8 - off);\n+\tmemcpy ((char *)ret2 + off, &u, 8 - off);\n \n \t*(stack - FIRST_ARG_SLOT) = ret2[0];\n \t*(stack - FIRST_ARG_SLOT - 1) = ret2[1];\n@@ -656,7 +624,6 @@ ffi_closure_inner_pa32 (void *closure, UINT32 *stack, int closure_type)\n    cif specifies the argument and result types for fun.\n    The cif must already be prep'ed.  */\n \n-extern void ffi_go_closure_pa32(void);\n extern void ffi_closure_pa32(void);\n \n ffi_status\n@@ -666,107 +633,42 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \t\t      void *user_data,\n \t\t      void *codeloc)\n {\n-  UINT32 *tramp = (UINT32 *)(closure->tramp);\n-#ifdef PA_HPUX\n-  UINT32 *tmp;\n-#endif\n-\n-  if (cif->abi != FFI_PA32)\n-    return FFI_BAD_ABI;\n-\n-  /* Make a small trampoline that will branch to our\n-     handler function. Use PC-relative addressing.  */\n-\n-#ifdef PA_LINUX\n-  tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8 */\n-  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits */\n-  tramp[2] = 0x4aa10028; /* ldw 20(%r21),%r1    ; load plabel */\n-  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21   ; get closure addr */\n-  tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler */\n-  tramp[5] = 0xeac0c000; /* bv%r0(%r22)         ; branch to handler */\n-  tramp[6] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler */\n-  tramp[7] = ((UINT32)(ffi_closure_pa32) & ~2);\n-\n-  /* Flush d/icache -- have to flush up 2 two lines because of\n-     alignment.  */\n-  __asm__ volatile(\n-\t\t   \"fdc 0(%0)\\n\\t\"\n-\t\t   \"fdc %1(%0)\\n\\t\"\n-\t\t   \"fic 0(%%sr4, %0)\\n\\t\"\n-\t\t   \"fic %1(%%sr4, %0)\\n\\t\"\n-\t\t   \"sync\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\"\n-\t\t   :\n-\t\t   : \"r\"((unsigned long)tramp & ~31),\n-\t\t     \"r\"(32 /* stride */)\n-\t\t   : \"memory\");\n-#endif\n+  ffi_closure *c = (ffi_closure *)FFI_RESTORE_PTR (closure);\n \n-#ifdef PA_HPUX\n-  tramp[0] = 0xeaa00000; /* b,l .+8,%r21        ; %r21 <- pc+8  */\n-  tramp[1] = 0xd6a01c1e; /* depi 0,31,2,%r21    ; mask priv bits  */\n-  tramp[2] = 0x4aa10038; /* ldw 28(%r21),%r1    ; load plabel  */\n-  tramp[3] = 0x36b53ff1; /* ldo -8(%r21),%r21   ; get closure addr  */\n-  tramp[4] = 0x0c201096; /* ldw 0(%r1),%r22     ; address of handler  */\n-  tramp[5] = 0x02c010b4; /* ldsid (%r22),%r20   ; load space id  */\n-  tramp[6] = 0x00141820; /* mtsp %r20,%sr0      ; into %sr0  */\n-  tramp[7] = 0xe2c00000; /* be 0(%sr0,%r22)     ; branch to handler  */\n-  tramp[8] = 0x0c281093; /* ldw 4(%r1),%r19     ; GP of handler  */\n-  tramp[9] = ((UINT32)(ffi_closure_pa32) & ~2);\n-\n-  /* Flush d/icache -- have to flush three lines because of alignment.  */\n-  __asm__ volatile(\n-\t\t   \"copy %1,%0\\n\\t\"\n-\t\t   \"fdc,m %2(%0)\\n\\t\"\n-\t\t   \"fdc,m %2(%0)\\n\\t\"\n-\t\t   \"fdc,m %2(%0)\\n\\t\"\n-\t\t   \"ldsid (%1),%0\\n\\t\"\n-\t\t   \"mtsp %0,%%sr0\\n\\t\"\n-\t\t   \"copy %1,%0\\n\\t\"\n-\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n-\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n-\t\t   \"fic,m %2(%%sr0,%0)\\n\\t\"\n-\t\t   \"sync\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\\t\"\n-\t\t   \"nop\\n\"\n-\t\t   : \"=&r\" ((unsigned long)tmp)\n-\t\t   : \"r\" ((unsigned long)tramp & ~31),\n-\t\t     \"r\" (32/* stride */)\n-\t\t   : \"memory\");\n-#endif\n+  /* The layout of a function descriptor.  A function pointer with the PLABEL\n+     bit set points to a function descriptor.  */\n+  struct pa32_fd\n+  {\n+    UINT32 code_pointer;\n+    UINT32 gp;\n+  };\n \n-  closure->cif  = cif;\n-  closure->user_data = user_data;\n-  closure->fun  = fun;\n+  struct ffi_pa32_trampoline_struct\n+  {\n+     UINT32 code_pointer;        /* Pointer to ffi_closure_unix.  */\n+     UINT32 fake_gp;             /* Pointer to closure, installed as gp.  */\n+     UINT32 real_gp;             /* Real gp value.  */\n+  };\n \n-  return FFI_OK;\n-}\n+  struct ffi_pa32_trampoline_struct *tramp;\n+  struct pa32_fd *fd;\n \n-#ifdef FFI_GO_CLOSURES\n-ffi_status\n-ffi_prep_go_closure (ffi_go_closure *closure,\n-\t\t     ffi_cif *cif,\n-\t\t     void (*fun)(ffi_cif *, void *, void **, void *))\n-{\n   if (cif->abi != FFI_PA32)\n     return FFI_BAD_ABI;\n \n-  closure->tramp = &ffi_go_closure_pa32;\n-  closure->cif = cif;\n-  closure->fun = fun;\n+  /* Get function descriptor address for ffi_closure_pa32.  */\n+  fd = (struct pa32_fd *)((UINT32)ffi_closure_pa32 & ~3);\n+\n+  /* Setup trampoline.  */\n+  tramp = (struct ffi_pa32_trampoline_struct *)c->tramp;\n+  tramp->code_pointer = fd->code_pointer;\n+  tramp->fake_gp = (UINT32)codeloc & ~3;\n+  tramp->real_gp = fd->gp;\n+\n+  c->cif  = cif;\n+  c->user_data = user_data;\n+  c->fun  = fun;\n \n   return FFI_OK;\n }\n-#endif /* FFI_GO_CLOSURES */\n #endif"}, {"sha": "df1209eb16700e0284d114ed134bca2fa0afdecd", "filename": "libffi/src/pa/ffitarget.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,6 +1,5 @@\n /* -----------------------------------------------------------------*-C-*-\n-   ffitarget.h - Copyright (c) 2016  John David Anglin\n-\t\t Copyright (c) 2012  Anthony Green\n+   ffitarget.h - Copyright (c) 2012  Anthony Green\n                  Copyright (c) 1996-2003  Red Hat, Inc.\n    Target configuration macros for hppa.\n \n@@ -68,14 +67,8 @@ typedef enum ffi_abi {\n /* ---- Definitions for closures ----------------------------------------- */\n \n #define FFI_CLOSURES 1\n-#define FFI_GO_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n-\n-#ifdef PA_LINUX\n-#define FFI_TRAMPOLINE_SIZE 32\n-#else\n-#define FFI_TRAMPOLINE_SIZE 40\n-#endif\n+#define FFI_TRAMPOLINE_SIZE 12\n \n #define FFI_TYPE_SMALL_STRUCT2 -1\n #define FFI_TYPE_SMALL_STRUCT3 -2"}, {"sha": "d0e5f695297bb837f3a360e5af27b0c4010da508", "filename": "libffi/src/pa/hpux32.S", "status": "modified", "additions": 5, "deletions": 71, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fhpux32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Fhpux32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fhpux32.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,7 +1,6 @@\n /* -----------------------------------------------------------------------\n    hpux32.S - Copyright (c) 2006 Free Software Foundation, Inc.\n \t                (c) 2008 Red Hat, Inc.\n-\t\t\t(c) 2016 John David Anglin\n    based on src/pa/linux.S\n \n    HP-UX PA Foreign Function Interface\n@@ -42,8 +41,7 @@\n \t\t\t       unsigned bytes,\n \t\t\t       unsigned flags,\n \t\t\t       unsigned *rvalue,\n-\t\t\t       void (*fn)(void),\n-\t\t\t       ffi_go_closure *closure);\n+\t\t\t       void (*fn)(void));\n \t */\n \n \t.export\tffi_call_pa32,ENTRY,PRIV_LEV=3\n@@ -106,7 +104,6 @@ L$CFI13\n \t   we need to give it a place to put the result.  */\n \tldw\t-52(%r3), %ret0\t\t; %ret0 <- rvalue\n \tldw\t-56(%r3), %r22\t\t; %r22 <- function to call\n-\tldw\t-60(%r3), %ret1\t\t; %ret1 <- closure\n \tbl\t$$dyncall, %r31\t\t; Call the user function\n \tcopy\t%r31, %rp\n \n@@ -262,7 +259,7 @@ L$done\n L$FE1\n \n \t/* void ffi_closure_pa32(void);\n-\t   Called with closure argument in %r21 */\n+\t   Called with closure argument in %r19 */\n \n \t.SPACE $TEXT$\n \t.SUBSPA $CODE$\n@@ -288,9 +285,9 @@ L$CFI22\n \tstw\t%arg2, -44(%r3)\n \tstw\t%arg3, -48(%r3)\n \n-\t/* Closure type 0.  */\n-\tcopy\t%r21, %arg0\n-\tcopy\t%r0, %arg2\n+\t/* Retrieve closure pointer and real gp.  */\n+\tcopy\t%r19, %arg0\n+\tldw\t8(%r19), %r19\n \tbl\tffi_closure_inner_pa32, %r2\n \tcopy    %r3, %arg1\n \tldwm\t-64(%sp), %r3\n@@ -302,47 +299,6 @@ L$CFI22\n \t.procend\n L$FE2:\n \n-\t/* void ffi_go_closure_pa32(void);\n-\t   Called with closure argument in %ret1 */\n-\n-\t.SPACE $TEXT$\n-\t.SUBSPA $CODE$\n-\t.export ffi_go_closure_pa32,ENTRY,PRIV_LEV=3,RTNVAL=GR\n-\t.import ffi_closure_inner_pa32,CODE\n-\t.align 4\n-L$FB3\n-ffi_go_closure_pa32\n-\t.proc\n-\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n-\t.entry\n-\n-\tstw\t%rp, -20(%sp)\n-\tcopy\t%r3, %r1\n-L$CFI31\n-\tcopy\t%sp, %r3\n-L$CFI32\n-\tstwm\t%r1, 64(%sp)\n-\n-\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n-\tstw\t%arg0, -36(%r3)\n-\tstw\t%arg1, -40(%r3)\n-\tstw\t%arg2, -44(%r3)\n-\tstw\t%arg3, -48(%r3)\n-\n-\t/* Closure type 1.  */\n-\tcopy\t%ret1, %arg0\n-\tldi\t1, %arg2\n-\tbl\tffi_closure_inner_pa32, %r2\n-\tcopy    %r3, %arg1\n-\tldwm\t-64(%sp), %r3\n-\tldw\t-20(%sp), %rp\n-\tldw\t-36(%sp), %ret0\n-\tbv\t%r0(%rp)\n-\tldw\t-40(%sp), %ret1\n-\t.exit\n-\t.procend\n-L$FE3:\n-\n \t.SPACE $PRIVATE$\n \t.SUBSPA $DATA$\n \n@@ -412,25 +368,3 @@ L$ASFDE2:\n \n \t.align 4\n L$EFDE2:\n-\n-L$SFDE3:\n-\t.word   L$EFDE3-L$ASFDE3        ;# FDE Length\n-L$ASFDE3:\n-\t.word   L$ASFDE3-L$frame1       ;# FDE CIE offset\n-\t.word   L$FB3   ;# FDE initial location\n-\t.word   L$FE3-L$FB3     ;# FDE address range\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   L$CFI31-L$FB3\n-\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n-\t.uleb128 0x0\n-\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n-\t.uleb128 0x2\n-\t.sleb128 -5\n-\n-\t.byte   0x4     ;# DW_CFA_advance_loc4\n-\t.word   L$CFI32-L$CFI31\n-\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n-\t.uleb128 0x3\n-\n-\t.align 4\n-L$EFDE3:"}, {"sha": "33ef0b137a4118bcfce9bc1e4b1dc4335cb4f027", "filename": "libffi/src/pa/linux.S", "status": "modified", "additions": 100, "deletions": 60, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Flinux.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpa%2Flinux.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Flinux.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,7 +1,6 @@\n /* -----------------------------------------------------------------------\n    linux.S - (c) 2003-2004 Randolph Chung <tausq@debian.org>\n \t     (c) 2008 Red Hat, Inc.\n-\t     (c) 2016 John David Anglin\n \n    HPPA Foreign Function Interface\n \n@@ -38,26 +37,24 @@\n \t\t\t       unsigned bytes,\n \t\t\t       unsigned flags,\n \t\t\t       unsigned *rvalue,\n-\t\t\t       void (*fn)(void),\n-\t\t\t       ffi_go_closure *closure);\n+\t\t\t       void (*fn)(void));\n \t */\n \n \t.export ffi_call_pa32,code\n \t.import ffi_prep_args_pa32,code\n \n \t.type ffi_call_pa32, @function\n-\t.cfi_startproc\n+.LFB1:\n ffi_call_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4\n \t.entry\n \tstw %rp, -20(%sp)\n \tcopy %r3, %r1\n-        .cfi_offset 2, -20\n-        .cfi_register 3, 1\n+.LCFI11:\n \n \tcopy %sp, %r3\n-\t.cfi_def_cfa_register 3\n+.LCFI12:\n \n \t/* Setup the stack for calling prep_args...\n \t   We want the stack to look like this:\n@@ -73,8 +70,8 @@ ffi_call_pa32:\n \t */\n \n \tstwm %r1, 64(%sp)\n-\t.cfi_offset 3, 0\n \tstw %r4, 12(%r3)\n+.LCFI13:\n \tcopy %sp, %r4\n \n \taddl %arg2, %r4, %arg0      /* arg stack */\n@@ -101,7 +98,6 @@ ffi_call_pa32:\n \t   we need to give it a place to put the result.  */\n \tldw -52(%r3), %ret0                     /* %ret0 <- rvalue */\n \tldw -56(%r3), %r22                      /* %r22 <- function to call */\n-\tldw -60(%r3), %ret1                     /* %ret1 <- closure */\n \tbl $$dyncall, %r31                      /* Call the user function */\n \tcopy %r31, %rp\n \n@@ -253,37 +249,37 @@ ffi_call_pa32:\n \tnop\n \t.exit\n \t.procend\n-\t.cfi_endproc\n+.LFE1:\n \n \t/* void ffi_closure_pa32(void);\n-\t   Called with ffi_closure argument in %r21.  */\n+\t   Called with closure argument in %r19 */\n \t.export ffi_closure_pa32,code\n \t.import ffi_closure_inner_pa32,code\n+\n \t.type ffi_closure_pa32, @function\n-\t.cfi_startproc\n+.LFB2:\n ffi_closure_pa32:\n \t.proc\n \t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n \t.entry\n \n \tstw %rp, -20(%sp)\n+.LCFI20:\n \tcopy %r3, %r1\n-\t.cfi_offset 2, -20\n-\t.cfi_register 3, 1\n+.LCFI21:\n \tcopy %sp, %r3\n-\t.cfi_def_cfa_register 3\n+.LCFI22:\n \tstwm %r1, 64(%sp)\n-\t.cfi_offset 3, 0\n \n \t/* Put arguments onto the stack and call ffi_closure_inner.  */\n \tstw %arg0, -36(%r3)\n \tstw %arg1, -40(%r3)\n \tstw %arg2, -44(%r3)\n \tstw %arg3, -48(%r3)\n \n-\t/* Closure type 0.  */\n-\tcopy %r21, %arg0\n-\tcopy %r0, %arg2\n+\t/* Retrieve closure pointer and real gp.  */\n+\tcopy    %r19, %arg0\n+\tldw     8(%r19), %r19\n \tbl ffi_closure_inner_pa32, %r2\n \tcopy %r3, %arg1\n \n@@ -295,46 +291,90 @@ ffi_closure_pa32:\n \n \t.exit\n \t.procend\n-\t.cfi_endproc\n-\n-\t/* void ffi_go_closure_pa32(void);\n-\t   Called with ffi_go_closure argument in %ret1.  */\n-\t.export ffi_go_closure_pa32,code\n-\t.import ffi_closure_inner_pa32,code\n-\t.type ffi_go_closure_pa32, @function\n-\t.cfi_startproc\n-ffi_go_closure_pa32:\n-\t.proc\n-\t.callinfo FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=3\n-\t.entry\n-\n-\tstw %rp, -20(%sp)\n-\tcopy %r3, %r1\n-\t.cfi_offset 2, -20\n-\t.cfi_register 3, 1\n-\tcopy %sp, %r3\n-\t.cfi_def_cfa_register 3\n-\tstwm %r1, 64(%sp)\n-\t.cfi_offset 3, 0\n-\n-\t/* Put arguments onto the stack and call ffi_closure_inner.  */\n-\tstw %arg0, -36(%r3)\n-\tstw %arg1, -40(%r3)\n-\tstw %arg2, -44(%r3)\n-\tstw %arg3, -48(%r3)\n-\n-\t/* Closure type 1.  */\n-\tcopy %ret1, %arg0\n-\tldi 1, %arg2\n-\tbl ffi_closure_inner_pa32, %r2\n-\tcopy %r3, %arg1\n+.LFE2:\n+\n+\t.section        \".eh_frame\",EH_FRAME_FLAGS,@progbits\n+.Lframe1:\n+\t.word   .LECIE1-.LSCIE1 ;# Length of Common Information Entry\n+.LSCIE1:\n+\t.word   0x0     ;# CIE Identifier Tag\n+\t.byte   0x1     ;# CIE Version\n+#ifdef __PIC__\n+\t.ascii  \"zR\\0\"  ;# CIE Augmentation: 'z' - data, 'R' - DW_EH_PE_... data\n+#else\n+\t.ascii \"\\0\"     ;# CIE Augmentation\n+#endif\n+\t.uleb128 0x1    ;# CIE Code Alignment Factor\n+\t.sleb128 4      ;# CIE Data Alignment Factor\n+\t.byte   0x2     ;# CIE RA Column\n+#ifdef __PIC__\n+\t.uleb128 0x1    ;# Augmentation size\n+\t.byte\t0x1b    ;# FDE Encoding (DW_EH_PE_pcrel|DW_EH_PE_sdata4)\n+#endif\n+\t.byte   0xc     ;# DW_CFA_def_cfa\n+\t.uleb128 0x1e\n+\t.uleb128 0x0\n+\t.align 4\n+.LECIE1:\n+.LSFDE1:\n+\t.word   .LEFDE1-.LASFDE1        ;# FDE Length\n+.LASFDE1:\n+\t.word   .LASFDE1-.Lframe1       ;# FDE CIE offset\n+#ifdef __PIC__\n+\t.word\t.LFB1-. ;# FDE initial location\n+#else\n+\t.word\t.LFB1   ;# FDE initial location\n+#endif\n+\t.word   .LFE1-.LFB1     ;# FDE address range\n+#ifdef __PIC__\n+\t.uleb128 0x0\t;# Augmentation size: no data\n+#endif\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI11-.LFB1\n+\t.byte\t0x83\t;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf; save r2 at [r30-20]\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI12-.LCFI11\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI13-.LCFI12\n+\t.byte\t0x84\t;# DW_CFA_offset, column 0x4\n+\t.uleb128 0x3\n \n-\tldwm -64(%sp), %r3\n-\tldw -20(%sp), %rp\n-\tldw -36(%sp), %ret0\n-\tbv %r0(%r2)\n-\tldw -40(%sp), %ret1\n+\t.align 4\n+.LEFDE1:\n+\n+.LSFDE2:\n+\t.word   .LEFDE2-.LASFDE2        ;# FDE Length\n+.LASFDE2:\n+\t.word   .LASFDE2-.Lframe1       ;# FDE CIE offset\n+#ifdef __PIC__\n+\t.word   .LFB2-. ;# FDE initial location\n+#else\n+\t.word   .LFB2   ;# FDE initial location\n+#endif\n+\t.word   .LFE2-.LFB2     ;# FDE address range\n+#ifdef __PIC__\n+\t.uleb128 0x0\t;# Augmentation size: no data\n+#endif\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI21-.LFB2\n+\t.byte   0x83    ;# DW_CFA_offset, column 0x3\n+\t.uleb128 0x0\n+\t.byte   0x11    ;# DW_CFA_offset_extended_sf\n+\t.uleb128 0x2\n+\t.sleb128 -5\n+\n+\t.byte   0x4     ;# DW_CFA_advance_loc4\n+\t.word   .LCFI22-.LCFI21\n+\t.byte   0xd     ;# DW_CFA_def_cfa_register = r3\n+\t.uleb128 0x3\n \n-\t.exit\n-\t.procend\n-\t.cfi_endproc\n+\t.align 4\n+.LEFDE2:"}, {"sha": "27b22f670a232873bd721f4286aafbc3ccc27160", "filename": "libffi/src/powerpc/asm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fasm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fasm.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -93,7 +93,7 @@\n /* EALIGN is like ENTRY, but does alignment to 'words'*4 bytes\n    past a 2^align boundary.  */\n #ifdef PROF\n-#define EALIGN(name, alignt, words)\t\t\t\t\t      \\\n+#define EFFI_ALIGN(name, alignt, words)\t\t\t\t\t      \\\n   ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name);\t\t\t\t      \\\n   ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function)\t\t\t      \\\n   .align ALIGNARG(2);\t\t\t\t\t\t\t      \\\n@@ -104,7 +104,7 @@\n   EALIGN_W_##words;\t\t\t\t\t\t\t      \\\n   0:\n #else /* PROF */\n-#define EALIGN(name, alignt, words)\t\t\t\t\t      \\\n+#define EFFI_ALIGN(name, alignt, words)\t\t\t\t\t      \\\n   ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME(name);\t\t\t\t      \\\n   ASM_TYPE_DIRECTIVE (C_SYMBOL_NAME(name),@function)\t\t\t      \\\n   .align ALIGNARG(alignt);\t\t\t\t\t\t      \\"}, {"sha": "3121e6ac26d319ff123d5223278499670454c755", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -353,7 +353,7 @@ Lret_type13:\n \tbgt\tLstructend\t\t; not a special small case\n \tb\tLsmallstruct\t\t; see if we need more.\n #else\n-\tcmpi\t0,r0,4\n+\tcmpwi\t0,r0,4\n \tbgt\tLfinish\t\t; not by value\n \tlg\tr3,0(r5)\n \tb\tLfinish\n@@ -494,8 +494,8 @@ LSFDE1:\n LASFDE1:\n \t.long\tLASFDE1-EH_frame1\t; FDE CIE offset\n \t.g_long\tLstartcode-.\t; FDE initial location\n-\t.set\tL$set$3,LFE1-Lstartcode\n-\t.g_long\tL$set$3\t; FDE address range\n+\t.set\tL$set$2,LFE1-Lstartcode\n+\t.g_long\tL$set$2\t; FDE address range\n \t.byte   0x0     ; uleb128 0x0; Augmentation size\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n \t.set\tL$set$3,LCFI1-LCFI0"}, {"sha": "a19bcbbfc52ffd1fda52820e8664745cba00e769", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -85,8 +85,9 @@ ffi_call_int (ffi_cif *cif,\n      can write r3 and r4 to memory without worrying about struct size.\n    \n      For ELFv2 ABI, use a bounce buffer for homogeneous structs too,\n-     for similar reasons.  */\n-  unsigned long smst_buffer[8];\n+     for similar reasons. This bounce buffer must be aligned to 16\n+     bytes for use with homogeneous structs of vectors (float128).  */\n+  float128 smst_buffer[8];\n   extended_cif ecif;\n \n   ecif.cif = cif;\n@@ -121,8 +122,9 @@ ffi_call_int (ffi_cif *cif,\n # endif\n \t/* The SYSV ABI returns a structure of up to 8 bytes in size\n \t   left-padded in r3/r4, and the ELFv2 ABI similarly returns a\n-\t   structure of up to 8 bytes in size left-padded in r3.  */\n-\tif (rsize <= 8)\n+\t   structure of up to 8 bytes in size left-padded in r3. But\n+\t   note that a structure of a single float is not paddded.  */\n+\tif (rsize <= 8 && (cif->flags & FLAG_RETURNS_FP) == 0)\n \t  memcpy (rvalue, (char *) smst_buffer + 8 - rsize, rsize);\n \telse\n #endif"}, {"sha": "64bb94dfae7e3d9a15aca95ce64282122bfcfa6a", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -33,7 +33,10 @@\n #include <stdlib.h>\n \n extern void ffi_closure_ASM (void);\n+\n+#if defined (FFI_GO_CLOSURES)\n extern void ffi_go_closure_ASM (void);\n+#endif\n \n enum {\n   /* The assembly depends on these exact flags.  \n@@ -256,7 +259,7 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n \tcase FFI_TYPE_STRUCT:\n \t  size_al = (*ptr)->size;\n #if defined(POWERPC_DARWIN64)\n-\t  next_arg = (unsigned long *)ALIGN((char *)next_arg, (*ptr)->alignment);\n+\t  next_arg = (unsigned long *)FFI_ALIGN((char *)next_arg, (*ptr)->alignment);\n \t  darwin64_pass_struct_by_value (*ptr, (char *) *p_argv, \n \t\t\t\t\t (unsigned) size_al,\n \t\t\t\t\t (unsigned int *) &fparg_count,\n@@ -267,7 +270,7 @@ ffi_prep_args (extended_cif *ecif, unsigned long *const stack)\n \t  /* If the first member of the struct is a double, then include enough\n \t     padding in the struct size to align it to double-word.  */\n \t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN((*ptr)->size, 8);\n+\t    size_al = FFI_ALIGN((*ptr)->size, 8);\n \n #  if defined(POWERPC64) \n \t  FFI_ASSERT (abi != FFI_DARWIN);\n@@ -353,7 +356,7 @@ darwin64_struct_size_exceeds_gprs_p (ffi_type *s, char *src, unsigned *nfpr)\n       ffi_type *p = s->elements[i];\n       /* Find the start of this item (0 for the first one).  */\n       if (i > 0)\n-        struct_offset = ALIGN(struct_offset, p->alignment);\n+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);\n \n       item_base = src + struct_offset;\n \n@@ -437,7 +440,7 @@ darwin64_pass_struct_floats (ffi_type *s, char *src,\n       ffi_type *p = s->elements[i];\n       /* Find the start of this item (0 for the first one).  */\n       if (i > 0)\n-        struct_offset = ALIGN(struct_offset, p->alignment);\n+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);\n       item_base = src + struct_offset;\n \n       switch (p->type)\n@@ -528,7 +531,7 @@ darwin64_struct_floats_to_mem (ffi_type *s, char *dest, double *fprs, unsigned *\n       ffi_type *p = s->elements[i];\n       /* Find the start of this item (0 for the first one).  */\n       if (i > 0)\n-        struct_offset = ALIGN(struct_offset, p->alignment);\n+        struct_offset = FFI_ALIGN(struct_offset, p->alignment);\n       item_base = dest + struct_offset;\n \n       switch (p->type)\n@@ -605,10 +608,10 @@ darwin_adjust_aggregate_sizes (ffi_type *s)\n \talign = 4;\n #endif\n       /* Pad, if necessary, before adding the current item.  */\n-      s->size = ALIGN(s->size, align) + p->size;\n+      s->size = FFI_ALIGN(s->size, align) + p->size;\n     }\n   \n-  s->size = ALIGN(s->size, s->alignment);\n+  s->size = FFI_ALIGN(s->size, s->alignment);\n   \n   /* This should not be necessary on m64, but harmless.  */\n   if (s->elements[0]->type == FFI_TYPE_UINT64\n@@ -641,10 +644,10 @@ aix_adjust_aggregate_sizes (ffi_type *s)\n       align = p->alignment;\n       if (i != 0 && p->type == FFI_TYPE_DOUBLE)\n \talign = 4;\n-      s->size = ALIGN(s->size, align) + p->size;\n+      s->size = FFI_ALIGN(s->size, align) + p->size;\n     }\n   \n-  s->size = ALIGN(s->size, s->alignment);\n+  s->size = FFI_ALIGN(s->size, s->alignment);\n   \n   if (s->elements[0]->type == FFI_TYPE_UINT64\n       || s->elements[0]->type == FFI_TYPE_SINT64\n@@ -810,9 +813,9 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t     16-byte-aligned.  */\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n #if defined (POWERPC64)\n-\t    intarg_count = ALIGN(intarg_count, 2);\n+\t    intarg_count = FFI_ALIGN(intarg_count, 2);\n #else\n-\t    intarg_count = ALIGN(intarg_count, 4);\n+\t    intarg_count = FFI_ALIGN(intarg_count, 4);\n #endif\n \t  break;\n #endif\n@@ -839,7 +842,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n #if defined(POWERPC_DARWIN64)\n \t  align_words = (*ptr)->alignment >> 3;\n \t  if (align_words)\n-\t    intarg_count = ALIGN(intarg_count, align_words);\n+\t    intarg_count = FFI_ALIGN(intarg_count, align_words);\n \t  /* Base size of the struct.  */\n \t  intarg_count += (size_al + 7) / 8;\n \t  /* If 16 bytes then don't worry about floats.  */\n@@ -849,11 +852,11 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n #else\n \t  align_words = (*ptr)->alignment >> 2;\n \t  if (align_words)\n-\t    intarg_count = ALIGN(intarg_count, align_words);\n+\t    intarg_count = FFI_ALIGN(intarg_count, align_words);\n \t  /* If the first member of the struct is a double, then align\n \t     the struct to double-word. \n \t  if ((*ptr)->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN((*ptr)->size, 8); */\n+\t    size_al = FFI_ALIGN((*ptr)->size, 8); */\n #  ifdef POWERPC64\n \t  intarg_count += (size_al + 7) / 8;\n #  else\n@@ -898,7 +901,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n     bytes += NUM_GPR_ARG_REGISTERS * sizeof(long);\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n-  bytes = ALIGN(bytes, 16) ;\n+  bytes = FFI_ALIGN(bytes, 16) ;\n \n   cif->flags = flags;\n   cif->bytes = bytes;\n@@ -909,8 +912,10 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n extern void ffi_call_AIX(extended_cif *, long, unsigned, unsigned *,\n \t\t\t void (*fn)(void), void (*fn2)(void));\n \n+#if defined (FFI_GO_CLOSURES)\n extern void ffi_call_go_AIX(extended_cif *, long, unsigned, unsigned *,\n \t\t\t    void (*fn)(void), void (*fn2)(void), void *closure);\n+#endif\n \n extern void ffi_call_DARWIN(extended_cif *, long, unsigned, unsigned *,\n \t\t\t    void (*fn)(void), void (*fn2)(void), ffi_type*);\n@@ -950,6 +955,7 @@ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n }\n \n+#if defined (FFI_GO_CLOSURES)\n void\n ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n \t     void *closure)\n@@ -981,6 +987,7 @@ ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n       break;\n     }\n }\n+#endif\n \n static void flush_icache(char *);\n static void flush_range(char *, int);\n@@ -1110,6 +1117,7 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   return FFI_OK;\n }\n \n+#if defined (FFI_GO_CLOSURES)\n ffi_status\n ffi_prep_go_closure (ffi_go_closure* closure,\n \t\t     ffi_cif* cif,\n@@ -1133,6 +1141,7 @@ ffi_prep_go_closure (ffi_go_closure* closure,\n     }\n   return FFI_OK;\n }\n+#endif\n \n static void\n flush_icache(char *addr)\n@@ -1168,9 +1177,11 @@ ffi_type *\n ffi_closure_helper_DARWIN (ffi_closure *, void *,\n \t\t\t   unsigned long *, ffi_dblfl *);\n \n+#if defined (FFI_GO_CLOSURES)\n ffi_type *\n ffi_go_closure_helper_DARWIN (ffi_go_closure*, void *,\n \t\t\t      unsigned long *, ffi_dblfl *);\n+#endif\n \n /* Basically the trampoline invokes ffi_closure_ASM, and on\n    entry, r11 holds the address of the closure.\n@@ -1272,7 +1283,7 @@ ffi_closure_helper_common (ffi_cif* cif,\n \tcase FFI_TYPE_STRUCT:\n \t  size_al = arg_types[i]->size;\n #if defined(POWERPC_DARWIN64)\n-\t  pgr = (unsigned long *)ALIGN((char *)pgr, arg_types[i]->alignment);\n+\t  pgr = (unsigned long *)FFI_ALIGN((char *)pgr, arg_types[i]->alignment);\n \t  if (size_al < 3 || size_al == 4)\n \t    {\n \t      avalue[i] = ((char *)pgr)+8-size_al;\n@@ -1297,7 +1308,7 @@ ffi_closure_helper_common (ffi_cif* cif,\n \t  /* If the first member of the struct is a double, then align\n \t     the struct to double-word.  */\n \t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n-\t    size_al = ALIGN(arg_types[i]->size, 8);\n+\t    size_al = FFI_ALIGN(arg_types[i]->size, 8);\n #  if defined(POWERPC64)\n \t  FFI_ASSERT (cif->abi != FFI_DARWIN);\n \t  avalue[i] = pgr;\n@@ -1430,11 +1441,12 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \t\t\t\t    closure->user_data, rvalue, pgr, pfr);\n }\n \n+#if defined (FFI_GO_CLOSURES)\n ffi_type *\n ffi_go_closure_helper_DARWIN (ffi_go_closure *closure, void *rvalue,\n \t\t\t      unsigned long *pgr, ffi_dblfl *pfr)\n {\n   return ffi_closure_helper_common (closure->cif, closure->fun,\n \t\t\t\t    closure, rvalue, pgr, pfr);\n }\n-\n+#endif"}, {"sha": "4d50878e402a2a6a2f842e7d2a0c6d8d1e1ebe02", "filename": "libffi/src/powerpc/ffi_linux64.c", "status": "modified", "additions": 213, "deletions": 34, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_linux64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -38,7 +38,8 @@\n /* About the LINUX64 ABI.  */\n enum {\n   NUM_GPR_ARG_REGISTERS64 = 8,\n-  NUM_FPR_ARG_REGISTERS64 = 13\n+  NUM_FPR_ARG_REGISTERS64 = 13,\n+  NUM_VEC_ARG_REGISTERS64 = 12,\n };\n enum { ASM_NEEDS_REGISTERS64 = 4 };\n \n@@ -63,10 +64,31 @@ ffi_prep_types_linux64 (ffi_abi abi)\n \n \n static unsigned int\n-discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n+discover_homogeneous_aggregate (ffi_abi abi,\n+                                const ffi_type *t,\n+                                unsigned int *elnum)\n {\n   switch (t->type)\n     {\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+    case FFI_TYPE_LONGDOUBLE:\n+      /* 64-bit long doubles are equivalent to doubles. */\n+      if ((abi & FFI_LINUX_LONG_DOUBLE_128) == 0)\n+        {\n+          *elnum = 1;\n+          return FFI_TYPE_DOUBLE;\n+        }\n+      /* IBM extended precision values use unaligned pairs\n+         of FPRs, but according to the ABI must be considered\n+         distinct from doubles. They are also limited to a\n+         maximum of four members in a homogeneous aggregate. */\n+      else if ((abi & FFI_LINUX_LONG_DOUBLE_IEEE128) == 0)\n+        {\n+          *elnum = 2;\n+          return FFI_TYPE_LONGDOUBLE;\n+        }\n+      /* Fall through. */\n+#endif\n     case FFI_TYPE_FLOAT:\n     case FFI_TYPE_DOUBLE:\n       *elnum = 1;\n@@ -79,7 +101,7 @@ discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n \twhile (*el)\n \t  {\n \t    unsigned int el_elt, el_elnum = 0;\n-\t    el_elt = discover_homogeneous_aggregate (*el, &el_elnum);\n+\t    el_elt = discover_homogeneous_aggregate (abi, *el, &el_elnum);\n \t    if (el_elt == 0\n \t\t|| (base_elt && base_elt != el_elt))\n \t      return 0;\n@@ -110,13 +132,23 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n {\n   ffi_type **ptr;\n   unsigned bytes;\n-  unsigned i, fparg_count = 0, intarg_count = 0;\n+  unsigned i, fparg_count = 0, intarg_count = 0, vecarg_count = 0;\n   unsigned flags = cif->flags;\n-  unsigned int elt, elnum;\n+  unsigned elt, elnum, rtype;\n \n #if FFI_TYPE_LONGDOUBLE == FFI_TYPE_DOUBLE\n-  /* If compiled without long double support..  */\n-  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+  /* If compiled without long double support... */\n+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0 ||\n+      (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+    return FFI_BAD_ABI;\n+#elif !defined(__VEC__)\n+  /* If compiled without vector register support (used by assembly)... */\n+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+    return FFI_BAD_ABI;\n+#else\n+  /* If the IEEE128 flag is set, but long double is only 64 bits wide... */\n+  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) == 0 &&\n+      (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n     return FFI_BAD_ABI;\n #endif\n \n@@ -138,10 +170,19 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n #endif\n \n   /* Return value handling.  */\n-  switch (cif->rtype->type)\n+  rtype = cif->rtype->type;\n+#if _CALL_ELF == 2\n+homogeneous:\n+#endif\n+  switch (rtype)\n     {\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n     case FFI_TYPE_LONGDOUBLE:\n+      if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+        {\n+          flags |= FLAG_RETURNS_VEC;\n+          break;\n+        }\n       if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n \tflags |= FLAG_RETURNS_128BITS;\n       /* Fall through.  */\n@@ -164,19 +205,18 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n \n     case FFI_TYPE_STRUCT:\n #if _CALL_ELF == 2\n-      elt = discover_homogeneous_aggregate (cif->rtype, &elnum);\n+      elt = discover_homogeneous_aggregate (cif->abi, cif->rtype, &elnum);\n       if (elt)\n-\t{\n-\t  if (elt == FFI_TYPE_DOUBLE)\n-\t    flags |= FLAG_RETURNS_64BITS;\n-\t  flags |= FLAG_RETURNS_FP | FLAG_RETURNS_SMST;\n-\t  break;\n-\t}\n+        {\n+          flags |= FLAG_RETURNS_SMST;\n+          rtype = elt;\n+          goto homogeneous;\n+        }\n       if (cif->rtype->size <= 16)\n-\t{\n-\t  flags |= FLAG_RETURNS_SMST;\n-\t  break;\n-\t}\n+        {\n+          flags |= FLAG_RETURNS_SMST;\n+          break;\n+        }\n #endif\n       intarg_count++;\n       flags |= FLAG_RETVAL_REFERENCE;\n@@ -198,6 +238,15 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n \t{\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n+          if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+            {\n+              vecarg_count++;\n+              /* Align to 16 bytes, plus the 16-byte argument. */\n+              intarg_count = (intarg_count + 3) & ~0x1;\n+              if (vecarg_count > NUM_VEC_ARG_REGISTERS64)\n+                flags |= FLAG_ARG_NEEDS_PSAVE;\n+              break;\n+            }\n \t  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n \t    {\n \t      fparg_count++;\n@@ -221,10 +270,21 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n \t\talign = 16;\n \t      align = align / 8;\n \t      if (align > 1)\n-\t\tintarg_count = ALIGN (intarg_count, align);\n+\t\tintarg_count = FFI_ALIGN (intarg_count, align);\n \t    }\n \t  intarg_count += ((*ptr)->size + 7) / 8;\n-\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+\t  elt = discover_homogeneous_aggregate (cif->abi, *ptr, &elnum);\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+          if (elt == FFI_TYPE_LONGDOUBLE &&\n+              (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+            {\n+              vecarg_count += elnum;\n+              if (vecarg_count > NUM_VEC_ARG_REGISTERS64)\n+                flags |= FLAG_ARG_NEEDS_PSAVE;\n+              break;\n+            }\n+\t  else\n+#endif\n \t  if (elt)\n \t    {\n \t      fparg_count += elnum;\n@@ -263,10 +323,17 @@ ffi_prep_cif_linux64_core (ffi_cif *cif)\n     flags |= FLAG_FP_ARGUMENTS;\n   if (intarg_count > 4)\n     flags |= FLAG_4_GPR_ARGUMENTS;\n+  if (vecarg_count != 0)\n+    flags |= FLAG_VEC_ARGUMENTS;\n \n   /* Space for the FPR registers, if needed.  */\n   if (fparg_count != 0)\n     bytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);\n+  /* Space for the vector registers, if needed, aligned to 16 bytes. */\n+  if (vecarg_count != 0) {\n+    bytes = (bytes + 15) & ~0xF;\n+    bytes += NUM_VEC_ARG_REGISTERS64 * sizeof (float128);\n+  }\n \n   /* Stack space.  */\n #if _CALL_ELF == 2\n@@ -349,6 +416,8 @@ ffi_prep_cif_linux64_var (ffi_cif *cif,\n    |--------------------------------------------| |\n    |   FPR registers f1-f13 (optional)\t13*8\t| |\n    |--------------------------------------------| |\n+   |   VEC registers v2-v13 (optional)  12*16   | |\n+   |--------------------------------------------| |\n    |   Parameter save area\t\t        | |\n    |--------------------------------------------| |\n    |   TOC save area\t\t\t8\t| |\n@@ -378,6 +447,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n     unsigned long *ul;\n     float *f;\n     double *d;\n+    float128 *f128;\n     size_t p;\n   } valp;\n \n@@ -391,11 +461,16 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n   valp rest;\n   valp next_arg;\n \n-  /* 'fpr_base' points at the space for fpr3, and grows upwards as\n+  /* 'fpr_base' points at the space for f1, and grows upwards as\n      we use FPR registers.  */\n   valp fpr_base;\n   unsigned int fparg_count;\n \n+  /* 'vec_base' points at the space for v2, and grows upwards as\n+     we use vector registers.  */\n+  valp vec_base;\n+  unsigned int vecarg_count;\n+\n   unsigned int i, words, nargs, nfixedargs;\n   ffi_type **ptr;\n   double double_tmp;\n@@ -412,6 +487,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n     unsigned long **ul;\n     float **f;\n     double **d;\n+    float128 **f128;\n   } p_argv;\n   unsigned long gprvalue;\n   unsigned long align;\n@@ -426,11 +502,21 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n #endif\n   fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;\n   fparg_count = 0;\n+  /* Place the vector args below the FPRs, if used, else the GPRs. */\n+  if (ecif->cif->flags & FLAG_FP_ARGUMENTS)\n+    vec_base.p = fpr_base.p & ~0xF;\n+  else\n+    vec_base.p = gpr_base.p;\n+  vec_base.f128 -= NUM_VEC_ARG_REGISTERS64;\n+  vecarg_count = 0;\n   next_arg.ul = gpr_base.ul;\n \n   /* Check that everything starts aligned properly.  */\n   FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n   FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) gpr_base.c & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) gpr_end.c  & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) vec_base.c & 0xF) == 0);\n   FFI_ASSERT ((bytes & 0xF) == 0);\n \n   /* Deal with return values that are actually pass-by-reference.  */\n@@ -455,6 +541,22 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t{\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n+          if ((ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+            {\n+              next_arg.p = FFI_ALIGN (next_arg.p, 16);\n+              if (next_arg.ul == gpr_end.ul)\n+                next_arg.ul = rest.ul;\n+              if (vecarg_count < NUM_VEC_ARG_REGISTERS64 && i < nfixedargs)\n+\t\tmemcpy (vec_base.f128++, *p_argv.f128, sizeof (float128));\n+              else\n+\t\tmemcpy (next_arg.f128, *p_argv.f128, sizeof (float128));\n+              if (++next_arg.f128 == gpr_end.f128)\n+                next_arg.f128 = rest.f128;\n+              vecarg_count++;\n+              FFI_ASSERT (__LDBL_MANT_DIG__ == 113);\n+              FFI_ASSERT (flags & FLAG_VEC_ARGUMENTS);\n+              break;\n+            }\n \t  if ((ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n \t    {\n \t      double_tmp = (*p_argv.d)[0];\n@@ -492,7 +594,9 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t  /* Fall through.  */\n #endif\n \tcase FFI_TYPE_DOUBLE:\n+#if _CALL_ELF != 2\n \tdo_double:\n+#endif\n \t  double_tmp = **p_argv.d;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n \t    {\n@@ -511,7 +615,9 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+#if _CALL_ELF != 2\n \tdo_float:\n+#endif\n \t  double_tmp = **p_argv.f;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n \t    {\n@@ -548,19 +654,43 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t      if (align > 16)\n \t\talign = 16;\n \t      if (align > 1)\n-\t\tnext_arg.p = ALIGN (next_arg.p, align);\n+                {\n+                  next_arg.p = FFI_ALIGN (next_arg.p, align);\n+                  if (next_arg.ul == gpr_end.ul)\n+                    next_arg.ul = rest.ul;\n+                }\n \t    }\n-\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+\t  elt = discover_homogeneous_aggregate (ecif->cif->abi, *ptr, &elnum);\n \t  if (elt)\n \t    {\n #if _CALL_ELF == 2\n \t      union {\n \t\tvoid *v;\n \t\tfloat *f;\n \t\tdouble *d;\n+\t\tfloat128 *f128;\n \t      } arg;\n \n \t      arg.v = *p_argv.v;\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+              if (elt == FFI_TYPE_LONGDOUBLE &&\n+                  (ecif->cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+                {\n+                  do\n+                    {\n+                      if (vecarg_count < NUM_VEC_ARG_REGISTERS64\n+                          && i < nfixedargs)\n+\t\t        memcpy (vec_base.f128++, arg.f128, sizeof (float128));\n+                      else\n+\t\t        memcpy (next_arg.f128, arg.f128++, sizeof (float128));\n+                      if (++next_arg.f128 == gpr_end.f128)\n+                        next_arg.f128 = rest.f128;\n+                      vecarg_count++;\n+                    }\n+                  while (--elnum != 0);\n+                }\n+              else\n+#endif\n \t      if (elt == FFI_TYPE_FLOAT)\n \t\t{\n \t\t  do\n@@ -576,11 +706,9 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \t\t      fparg_count++;\n \t\t    }\n \t\t  while (--elnum != 0);\n-\t\t  if ((next_arg.p & 3) != 0)\n-\t\t    {\n-\t\t      if (++next_arg.f == gpr_end.f)\n-\t\t\tnext_arg.f = rest.f;\n-\t\t    }\n+\t\t  if ((next_arg.p & 7) != 0)\n+                    if (++next_arg.f == gpr_end.f)\n+                      next_arg.f = rest.f;\n \t\t}\n \t      else\n \t\tdo\n@@ -733,17 +861,20 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t\t\t    void *user_data,\n \t\t\t    void *rvalue,\n \t\t\t    unsigned long *pst,\n-\t\t\t    ffi_dblfl *pfr)\n+                            ffi_dblfl *pfr,\n+                            float128 *pvec)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n   /* pst is the pointer to parameter save area\n      (r3-r10 are stored into its first 8 slots by ffi_closure_LINUX64) */\n   /* pfr is the pointer to where f1-f13 are stored in ffi_closure_LINUX64 */\n+  /* pvec is the pointer to where v2-v13 are stored in ffi_closure_LINUX64 */\n \n   void **avalue;\n   ffi_type **arg_types;\n   unsigned long i, avn, nfixedargs;\n   ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n+  float128 *end_pvec = pvec + NUM_VEC_ARG_REGISTERS64;\n   unsigned long align;\n \n   avalue = alloca (cif->nargs * sizeof (void *));\n@@ -811,9 +942,9 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t      if (align > 16)\n \t\talign = 16;\n \t      if (align > 1)\n-\t\tpst = (unsigned long *) ALIGN ((size_t) pst, align);\n+\t\tpst = (unsigned long *) FFI_ALIGN ((size_t) pst, align);\n \t    }\n-\t  elt = discover_homogeneous_aggregate (arg_types[i], &elnum);\n+\t  elt = discover_homogeneous_aggregate (cif->abi, arg_types[i], &elnum);\n \t  if (elt)\n \t    {\n #if _CALL_ELF == 2\n@@ -822,20 +953,49 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t\tunsigned long *ul;\n \t\tfloat *f;\n \t\tdouble *d;\n+\t\tfloat128 *f128;\n \t\tsize_t p;\n \t      } to, from;\n \n \t      /* Repackage the aggregate from its parts.  The\n \t\t aggregate size is not greater than the space taken by\n \t\t the registers so store back to the register/parameter\n \t\t save arrays.  */\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+              if (elt == FFI_TYPE_LONGDOUBLE &&\n+                  (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+                {\n+                  if (pvec + elnum <= end_pvec)\n+                    to.v = pvec;\n+                  else\n+                    to.v = pst;\n+                }\n+              else\n+#endif\n \t      if (pfr + elnum <= end_pfr)\n \t\tto.v = pfr;\n \t      else\n \t\tto.v = pst;\n \n \t      avalue[i] = to.v;\n \t      from.ul = pst;\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+              if (elt == FFI_TYPE_LONGDOUBLE &&\n+                  (cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+                {\n+                  do\n+                    {\n+                      if (pvec < end_pvec && i < nfixedargs)\n+\t\t        memcpy (to.f128, pvec++, sizeof (float128));\n+                      else\n+\t\t        memcpy (to.f128, from.f128, sizeof (float128));\n+                      to.f128++;\n+                      from.f128++;\n+                    }\n+                  while (--elnum != 0);\n+                }\n+              else\n+#endif\n \t      if (elt == FFI_TYPE_FLOAT)\n \t\t{\n \t\t  do\n@@ -891,7 +1051,18 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n+          if ((cif->abi & FFI_LINUX_LONG_DOUBLE_IEEE128) != 0)\n+            {\n+              if (((unsigned long) pst & 0xF) != 0)\n+                ++pst;\n+              if (pvec < end_pvec && i < nfixedargs)\n+                avalue[i] = pvec++;\n+              else\n+                avalue[i] = pst;\n+              pst += 2;\n+              break;\n+            }\n+          else if ((cif->abi & FFI_LINUX_LONG_DOUBLE_128) != 0)\n \t    {\n \t      if (pfr + 1 < end_pfr && i + 1 < nfixedargs)\n \t\t{\n@@ -915,7 +1086,9 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t  /* Fall through.  */\n #endif\n \tcase FFI_TYPE_DOUBLE:\n+#if _CALL_ELF != 2\n \tdo_double:\n+#endif\n \t  /* On the outgoing stack all values are aligned to 8 */\n \t  /* there are 13 64bit floating point registers */\n \n@@ -930,7 +1103,9 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n+#if _CALL_ELF != 2\n \tdo_float:\n+#endif\n \t  if (pfr < end_pfr && i < nfixedargs)\n \t    {\n \t      /* Float values are stored as doubles in the\n@@ -962,13 +1137,17 @@ ffi_closure_helper_LINUX64 (ffi_cif *cif,\n   /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n   if ((cif->flags & FLAG_RETURNS_SMST) != 0)\n     {\n-      if ((cif->flags & FLAG_RETURNS_FP) == 0)\n+      if ((cif->flags & (FLAG_RETURNS_FP | FLAG_RETURNS_VEC)) == 0)\n \treturn FFI_V2_TYPE_SMALL_STRUCT + cif->rtype->size - 1;\n+      else if ((cif->flags & FLAG_RETURNS_VEC) != 0)\n+        return FFI_V2_TYPE_VECTOR_HOMOG;\n       else if ((cif->flags & FLAG_RETURNS_64BITS) != 0)\n \treturn FFI_V2_TYPE_DOUBLE_HOMOG;\n       else\n \treturn FFI_V2_TYPE_FLOAT_HOMOG;\n     }\n+  if ((cif->flags & FLAG_RETURNS_VEC) != 0)\n+    return FFI_V2_TYPE_VECTOR;\n   return cif->rtype->type;\n }\n #endif"}, {"sha": "960a5c42213a0d5ff624a8d30fc58f31e293608e", "filename": "libffi/src/powerpc/ffi_powerpc.h", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_powerpc.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -31,22 +31,24 @@\n enum {\n   /* The assembly depends on these exact flags.  */\n   /* These go in cr7 */\n-  FLAG_RETURNS_SMST\t= 1 << (31-31), /* Used for FFI_SYSV small structs.  */\n+  FLAG_RETURNS_SMST     = 1 << (31-31), /* Used for FFI_SYSV small structs.  */\n   FLAG_RETURNS_NOTHING  = 1 << (31-30),\n   FLAG_RETURNS_FP       = 1 << (31-29),\n-  FLAG_RETURNS_64BITS   = 1 << (31-28),\n+  FLAG_RETURNS_VEC      = 1 << (31-28),\n \n-  /* This goes in cr6 */\n-  FLAG_RETURNS_128BITS  = 1 << (31-27),\n+  /* These go in cr6 */\n+  FLAG_RETURNS_64BITS   = 1 << (31-27),\n+  FLAG_RETURNS_128BITS  = 1 << (31-26),\n \n-  FLAG_COMPAT\t\t= 1 << (31- 8), /* Not used by assembly */\n+  FLAG_COMPAT           = 1 << (31- 8), /* Not used by assembly */\n \n   /* These go in cr1 */\n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7), /* Used by sysv code */\n   FLAG_ARG_NEEDS_PSAVE  = FLAG_ARG_NEEDS_COPY, /* Used by linux64 code */\n   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n   FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),\n-  FLAG_RETVAL_REFERENCE = 1 << (31- 4)\n+  FLAG_RETVAL_REFERENCE = 1 << (31- 4),\n+  FLAG_VEC_ARGUMENTS    = 1 << (31- 3),\n };\n \n typedef union\n@@ -55,6 +57,14 @@ typedef union\n   double d;\n } ffi_dblfl;\n \n+#if defined(__FLOAT128_TYPE__) && defined(__HAVE_FLOAT128)\n+typedef _Float128 float128;\n+#elif defined(__FLOAT128__)\n+typedef __float128 float128;\n+#else\n+typedef char float128[16] __attribute__((aligned(16)));\n+#endif\n+\n void FFI_HIDDEN ffi_closure_SYSV (void);\n void FFI_HIDDEN ffi_go_closure_sysv (void);\n void FFI_HIDDEN ffi_call_SYSV(extended_cif *, void (*)(void), void *,\n@@ -91,4 +101,5 @@ int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_cif *,\n \t\t\t\t\t   void (*) (ffi_cif *, void *,\n \t\t\t\t\t\t     void **, void *),\n \t\t\t\t\t   void *, void *,\n-\t\t\t\t\t   unsigned long *, ffi_dblfl *);\n+\t\t\t\t\t   unsigned long *, ffi_dblfl *,\n+\t\t\t\t\t   float128 *);"}, {"sha": "7fb9a93908271086f0d8e3d4a8f9882827f80268", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -91,15 +91,19 @@ typedef enum ffi_abi {\n   /* This and following bits can reuse FFI_COMPAT values.  */\n   FFI_LINUX_STRUCT_ALIGN = 1,\n   FFI_LINUX_LONG_DOUBLE_128 = 2,\n+  FFI_LINUX_LONG_DOUBLE_IEEE128 = 4,\n   FFI_DEFAULT_ABI = (FFI_LINUX\n #  ifdef __STRUCT_PARM_ALIGN__\n \t\t     | FFI_LINUX_STRUCT_ALIGN\n #  endif\n #  ifdef __LONG_DOUBLE_128__\n \t\t     | FFI_LINUX_LONG_DOUBLE_128\n+#   ifdef __LONG_DOUBLE_IEEE128__\n+\t\t     | FFI_LINUX_LONG_DOUBLE_IEEE128\n+#   endif\n #  endif\n \t\t     ),\n-  FFI_LAST_ABI = 12\n+  FFI_LAST_ABI = 16\n \n # else\n   /* This bit, always set in new code, must not be set in any of the\n@@ -167,9 +171,11 @@ typedef enum ffi_abi {\n #define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_PPC_TYPE_LAST + 2)\n \n /* Used by ELFv2 for homogenous structure returns.  */\n-#define FFI_V2_TYPE_FLOAT_HOMOG\t\t(FFI_PPC_TYPE_LAST + 1)\n-#define FFI_V2_TYPE_DOUBLE_HOMOG\t(FFI_PPC_TYPE_LAST + 2)\n-#define FFI_V2_TYPE_SMALL_STRUCT\t(FFI_PPC_TYPE_LAST + 3)\n+#define FFI_V2_TYPE_VECTOR\t\t(FFI_PPC_TYPE_LAST + 1)\n+#define FFI_V2_TYPE_VECTOR_HOMOG\t(FFI_PPC_TYPE_LAST + 2)\n+#define FFI_V2_TYPE_FLOAT_HOMOG\t\t(FFI_PPC_TYPE_LAST + 3)\n+#define FFI_V2_TYPE_DOUBLE_HOMOG\t(FFI_PPC_TYPE_LAST + 4)\n+#define FFI_V2_TYPE_SMALL_STRUCT\t(FFI_PPC_TYPE_LAST + 5)\n \n #if _CALL_ELF == 2\n # define FFI_TRAMPOLINE_SIZE 32"}, {"sha": "e92d64af34fdd15a1c9b0bbd4de2c24bf52b0a48", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 83, "deletions": 28, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -109,40 +109,70 @@ ffi_call_LINUX64:\n \tld\t%r2, 8(%r29)\n # endif\n \t/* Now do the call.  */\n-\t/* Set up cr1 with bits 4-7 of the flags.  */\n-\tmtcrf\t0x40, %r31\n+\t/* Set up cr1 with bits 3-7 of the flags.  */\n+\tmtcrf\t0xc0, %r31\n \n \t/* Get the address to call into CTR.  */\n \tmtctr\t%r12\n \t/* Load all those argument registers.  */\n-\tld\t%r3, -32-(8*8)(%r28)\n-\tld\t%r4, -32-(7*8)(%r28)\n-\tld\t%r5, -32-(6*8)(%r28)\n-\tld\t%r6, -32-(5*8)(%r28)\n+\taddi\t%r29, %r28, -32-(8*8)\n+\tld\t%r3,  (0*8)(%r29)\n+\tld\t%r4,  (1*8)(%r29)\n+\tld\t%r5,  (2*8)(%r29)\n+\tld\t%r6,  (3*8)(%r29)\n \tbf-\t5, 1f\n-\tld\t%r7, -32-(4*8)(%r28)\n-\tld\t%r8, -32-(3*8)(%r28)\n-\tld\t%r9, -32-(2*8)(%r28)\n-\tld\t%r10, -32-(1*8)(%r28)\n+\tld\t%r7,  (4*8)(%r29)\n+\tld\t%r8,  (5*8)(%r29)\n+\tld\t%r9,  (6*8)(%r29)\n+\tld\t%r10, (7*8)(%r29)\n 1:\n \n \t/* Load all the FP registers.  */\n \tbf-\t6, 2f\n-\tlfd\t%f1, -32-(21*8)(%r28)\n-\tlfd\t%f2, -32-(20*8)(%r28)\n-\tlfd\t%f3, -32-(19*8)(%r28)\n-\tlfd\t%f4, -32-(18*8)(%r28)\n-\tlfd\t%f5, -32-(17*8)(%r28)\n-\tlfd\t%f6, -32-(16*8)(%r28)\n-\tlfd\t%f7, -32-(15*8)(%r28)\n-\tlfd\t%f8, -32-(14*8)(%r28)\n-\tlfd\t%f9, -32-(13*8)(%r28)\n-\tlfd\t%f10, -32-(12*8)(%r28)\n-\tlfd\t%f11, -32-(11*8)(%r28)\n-\tlfd\t%f12, -32-(10*8)(%r28)\n-\tlfd\t%f13, -32-(9*8)(%r28)\n+\taddi\t%r29, %r29, -(14*8)\n+\tlfd\t%f1,  ( 1*8)(%r29)\n+\tlfd\t%f2,  ( 2*8)(%r29)\n+\tlfd\t%f3,  ( 3*8)(%r29)\n+\tlfd\t%f4,  ( 4*8)(%r29)\n+\tlfd\t%f5,  ( 5*8)(%r29)\n+\tlfd\t%f6,  ( 6*8)(%r29)\n+\tlfd\t%f7,  ( 7*8)(%r29)\n+\tlfd\t%f8,  ( 8*8)(%r29)\n+\tlfd\t%f9,  ( 9*8)(%r29)\n+\tlfd\t%f10, (10*8)(%r29)\n+\tlfd\t%f11, (11*8)(%r29)\n+\tlfd\t%f12, (12*8)(%r29)\n+\tlfd\t%f13, (13*8)(%r29)\n 2:\n \n+\t/* Load all the vector registers.  */\n+\tbf-\t3, 3f\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v13, 0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v12, 0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v11, 0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v10, 0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v9,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v8,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v7,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v6,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v5,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v4,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v3,  0, %r29\n+\taddi\t%r29, %r29, -16\n+\tlvx\t%v2,  0, %r29\n+3:\n+\n \t/* Make the call.  */\n \tld\t%r11, 8(%r28)\n \tbctrl\n@@ -160,6 +190,7 @@ ffi_call_LINUX64:\n \tbt\t31, .Lstruct_return_value\n \tbt\t30, .Ldone_return_value\n \tbt\t29, .Lfp_return_value\n+\tbt\t28, .Lvec_return_value\n \tstd\t%r3, 0(%r30)\n \t/* Fall through...  */\n \n@@ -175,21 +206,26 @@ ffi_call_LINUX64:\n \tld\t%r31, -8(%r1)\n \tblr\n \n+.Lvec_return_value:\n+\tstvx\t%v2, 0, %r30\n+\tb\t.Ldone_return_value\n+\n .Lfp_return_value:\n \t.cfi_def_cfa_register 28\n-\tbf\t28, .Lfloat_return_value\n-\tstfd\t%f1, 0(%r30)\n \tmtcrf\t0x02, %r31 /* cr6  */\n-\tbf\t27, .Ldone_return_value\n+\tbf\t27, .Lfloat_return_value\n+\tstfd\t%f1, 0(%r30)\n+\tbf\t26, .Ldone_return_value\n \tstfd\t%f2, 8(%r30)\n \tb\t.Ldone_return_value\n .Lfloat_return_value:\n \tstfs\t%f1, 0(%r30)\n \tb\t.Ldone_return_value\n \n .Lstruct_return_value:\n-\tbf\t29, .Lsmall_struct\n-\tbf\t28, .Lfloat_homog_return_value\n+\tbf\t29, .Lvec_homog_or_small_struct\n+\tmtcrf\t0x02, %r31 /* cr6  */\n+\tbf\t27, .Lfloat_homog_return_value\n \tstfd\t%f1, 0(%r30)\n \tstfd\t%f2, 8(%r30)\n \tstfd\t%f3, 16(%r30)\n@@ -211,6 +247,25 @@ ffi_call_LINUX64:\n \tstfs\t%f8, 28(%r30)\n \tb\t.Ldone_return_value\n \n+.Lvec_homog_or_small_struct:\n+\tbf\t28, .Lsmall_struct\n+\tstvx\t%v2, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v3, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v4, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v5, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v6, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v7, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v8, 0, %r30\n+\taddi\t%r30, %r30, 16\n+\tstvx\t%v9, 0, %r30\n+\tb\t.Ldone_return_value\n+\n .Lsmall_struct:\n \tstd\t%r3, 0(%r30)\n \tstd\t%r4, 8(%r30)"}, {"sha": "3469a2cbb01ee38188a348992517ae4fa19bcaa2", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -63,9 +63,15 @@ ffi_closure_LINUX64:\n # endif\n \n # if _CALL_ELF == 2\n-#  32 byte special reg save area + 64 byte parm save area\n-#  + 64 byte retval area + 13*8 fpr save area + round to 16\n-#  define STACKFRAME 272\n+#  ifdef __VEC__\n+#   32 byte special reg save area + 64 byte parm save area\n+#   + 128 byte retval area + 13*8 fpr save area + 12*16 vec save area + round to 16\n+#   define STACKFRAME 528\n+#  else\n+#   32 byte special reg save area + 64 byte parm save area\n+#   + 64 byte retval area + 13*8 fpr save area + round to 16\n+#   define STACKFRAME 272\n+#  endif\n #  define PARMSAVE 32\n #  define RETVAL PARMSAVE+64\n # else\n@@ -148,6 +154,35 @@ ffi_closure_LINUX64:\n \t# load up the pointer to the saved fpr registers\n \taddi\t%r8, %r1, -104\n \n+# ifdef __VEC__\n+\t# load up the pointer to the saved vector registers\n+\t# 8 bytes padding for 16-byte alignment at -112(%r1)\n+\taddi\t%r9, %r8, -24\n+\tstvx\t%v13, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v12, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v11, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v10, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v9, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v8, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v7, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v6, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v5, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v4, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v3, 0, %r9\n+\taddi\t%r9, %r9, -16\n+\tstvx\t%v2, 0, %r9\n+# endif\n+\n \t# load up the pointer to the result storage\n \taddi\t%r6, %r1, -STACKFRAME+RETVAL\n \n@@ -323,6 +358,16 @@ ffi_closure_LINUX64:\n \t.cfi_def_cfa_offset 0\n \tblr\n \t.cfi_def_cfa_offset STACKFRAME\n+# case FFI_V2_TYPE_VECTOR\n+\taddi %r3, %r1, RETVAL\n+\tlvx %v2, 0, %r3\n+\tmtlr %r0\n+\tb .Lfinish\n+# case FFI_V2_TYPE_VECTOR_HOMOG\n+\taddi %r3, %r1, RETVAL\n+\tlvx %v2, 0, %r3\n+\taddi %r3, %r3, 16\n+\tb .Lmorevector\n # case FFI_V2_TYPE_FLOAT_HOMOG\n \tlfs %f1, RETVAL+0(%r1)\n \tlfs %f2, RETVAL+4(%r1)\n@@ -342,6 +387,25 @@ ffi_closure_LINUX64:\n \t.cfi_def_cfa_offset 0\n \tblr\n \t.cfi_def_cfa_offset STACKFRAME\n+.Lmorevector:\n+\tlvx %v3, 0, %r3\n+\taddi %r3, %r3, 16\n+\tlvx %v4, 0, %r3\n+\taddi %r3, %r3, 16\n+\tlvx %v5, 0, %r3\n+\tmtlr %r0\n+\taddi %r3, %r3, 16\n+\tlvx %v6, 0, %r3\n+\taddi %r3, %r3, 16\n+\tlvx %v7, 0, %r3\n+\taddi %r3, %r3, 16\n+\tlvx %v8, 0, %r3\n+\taddi %r3, %r3, 16\n+\tlvx %v9, 0, %r3\n+\taddi %r1, %r1, STACKFRAME\n+\t.cfi_def_cfa_offset 0\n+\tblr\n+\t.cfi_def_cfa_offset STACKFRAME\n .Lmorefloat:\n \tlfs %f4, RETVAL+12(%r1)\n \tmtlr %r0"}, {"sha": "df9773427cba5c78e7727973f7ca259124048849", "filename": "libffi/src/powerpc/sysv.S", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fpowerpc%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -104,17 +104,16 @@ ENTRY(ffi_call_SYSV)\n \tbctrl\n \n \t/* Now, deal with the return value.  */\n-\tmtcrf\t0x01,%r31 /* cr7  */\n+\tmtcrf\t0x03,%r31 /* cr6-cr7  */\n \tbt-\t31,L(small_struct_return_value)\n \tbt-\t30,L(done_return_value)\n #ifndef __NO_FPRS__\n \tbt-\t29,L(fp_return_value)\n #endif\n \tstw\t%r3,0(%r30)\n-\tbf+\t28,L(done_return_value)\n+\tbf+\t27,L(done_return_value)\n \tstw\t%r4,4(%r30)\n-\tmtcrf\t0x02,%r31 /* cr6  */\n-\tbf\t27,L(done_return_value)\n+\tbf\t26,L(done_return_value)\n \tstw     %r5,8(%r30)\n \tstw\t%r6,12(%r30)\n \t/* Fall through...  */\n@@ -145,10 +144,9 @@ L(done_return_value):\n #ifndef __NO_FPRS__\n L(fp_return_value):\n \t.cfi_restore_state\n-\tbf\t28,L(float_return_value)\n+\tbf\t27,L(float_return_value)\n \tstfd\t%f1,0(%r30)\n-\tmtcrf   0x02,%r31 /* cr6  */\n-\tbf\t27,L(done_return_value)\n+\tbf\t26,L(done_return_value)\n \tstfd\t%f2,8(%r30)\n \tb\tL(done_return_value)\n L(float_return_value):"}, {"sha": "c1832b10302fa355ecf9d5d2b749946492b88246", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   prep_cif.c - Copyright (c) 2011, 2012  Anthony Green\n+   prep_cif.c - Copyright (c) 2011, 2012, 2021  Anthony Green\n                 Copyright (c) 1996, 1998, 2007  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -29,12 +29,12 @@\n \n /* Round up to FFI_SIZEOF_ARG. */\n \n-#define STACK_ARG_SIZE(x) ALIGN(x, FFI_SIZEOF_ARG)\n+#define STACK_ARG_SIZE(x) FFI_ALIGN(x, FFI_SIZEOF_ARG)\n \n /* Perform machine independent initialization of aggregate type\n    specifications. */\n \n-static ffi_status initialize_aggregate(ffi_type *arg)\n+static ffi_status initialize_aggregate(ffi_type *arg, size_t *offsets)\n {\n   ffi_type **ptr;\n \n@@ -52,13 +52,15 @@ static ffi_status initialize_aggregate(ffi_type *arg)\n   while ((*ptr) != NULL)\n     {\n       if (UNLIKELY(((*ptr)->size == 0)\n-\t\t    && (initialize_aggregate((*ptr)) != FFI_OK)))\n+\t\t    && (initialize_aggregate((*ptr), NULL) != FFI_OK)))\n \treturn FFI_BAD_TYPEDEF;\n \n       /* Perform a sanity check on the argument type */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n-      arg->size = ALIGN(arg->size, (*ptr)->alignment);\n+      arg->size = FFI_ALIGN(arg->size, (*ptr)->alignment);\n+      if (offsets)\n+\t*offsets++ = arg->size;\n       arg->size += (*ptr)->size;\n \n       arg->alignment = (arg->alignment > (*ptr)->alignment) ?\n@@ -74,7 +76,7 @@ static ffi_status initialize_aggregate(ffi_type *arg)\n      struct A { long a; char b; }; struct B { struct A x; char y; };\n      should find y at an offset of 2*sizeof(long) and result in a\n      total size of 3*sizeof(long).  */\n-  arg->size = ALIGN (arg->size, arg->alignment);\n+  arg->size = FFI_ALIGN (arg->size, arg->alignment);\n \n   /* On some targets, the ABI defines that structures have an additional\n      alignment beyond the \"natural\" one based on their elements.  */\n@@ -127,13 +129,16 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n   cif->rtype = rtype;\n \n   cif->flags = 0;\n-\n+#if (defined(_M_ARM64) || defined(__aarch64__)) && defined(_WIN32)\n+  cif->is_variadic = isvariadic;\n+#endif\n #if HAVE_LONG_DOUBLE_VARIANT\n   ffi_prep_types (abi);\n #endif\n \n   /* Initialize the return type if necessary */\n-  if ((cif->rtype->size == 0) && (initialize_aggregate(cif->rtype) != FFI_OK))\n+  if ((cif->rtype->size == 0)\n+      && (initialize_aggregate(cif->rtype, NULL) != FFI_OK))\n     return FFI_BAD_TYPEDEF;\n \n #ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n@@ -164,7 +169,8 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n     {\n \n       /* Initialize any uninitialized aggregate type definitions */\n-      if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n+      if (((*ptr)->size == 0)\n+\t  && (initialize_aggregate((*ptr), NULL) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n \n #ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n@@ -179,7 +185,7 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n \t{\n \t  /* Add any padding if necessary */\n \t  if (((*ptr)->alignment - 1) & bytes)\n-\t    bytes = (unsigned)ALIGN(bytes, (*ptr)->alignment);\n+\t    bytes = (unsigned)FFI_ALIGN(bytes, (*ptr)->alignment);\n \n #ifdef TILE\n \t  if (bytes < 10 * FFI_SIZEOF_ARG &&\n@@ -195,7 +201,7 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n \t    bytes = 6*4;\n #endif\n \n-\t  bytes += STACK_ARG_SIZE((*ptr)->size);\n+\t  bytes += (unsigned int)STACK_ARG_SIZE((*ptr)->size);\n \t}\n #endif\n     }\n@@ -225,7 +231,26 @@ ffi_status ffi_prep_cif_var(ffi_cif *cif,\n                             ffi_type *rtype,\n                             ffi_type **atypes)\n {\n-  return ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);\n+  ffi_status rc;\n+  size_t int_size = ffi_type_sint.size;\n+  int i;\n+\n+  rc = ffi_prep_cif_core(cif, abi, 1, nfixedargs, ntotalargs, rtype, atypes);\n+\n+  if (rc != FFI_OK)\n+    return rc;\n+\n+  for (i = 1; i < ntotalargs; i++)\n+    {\n+      ffi_type *arg_type = atypes[i];\n+      if (arg_type == &ffi_type_float\n+          || ((arg_type->type != FFI_TYPE_STRUCT\n+               && arg_type->type != FFI_TYPE_COMPLEX)\n+              && arg_type->size < int_size))\n+        return FFI_BAD_ARGTYPE;\n+    }\n+\n+  return FFI_OK;\n }\n \n #if FFI_CLOSURES\n@@ -240,3 +265,18 @@ ffi_prep_closure (ffi_closure* closure,\n }\n \n #endif\n+\n+ffi_status\n+ffi_get_struct_offsets (ffi_abi abi, ffi_type *struct_type, size_t *offsets)\n+{\n+  if (! (abi > FFI_FIRST_ABI && abi < FFI_LAST_ABI))\n+    return FFI_BAD_ABI;\n+  if (struct_type->type != FFI_TYPE_STRUCT)\n+    return FFI_BAD_TYPEDEF;\n+\n+#if HAVE_LONG_DOUBLE_VARIANT\n+  ffi_prep_types (abi);\n+#endif\n+\n+  return initialize_aggregate(struct_type, offsets);\n+}"}, {"sha": "be156116cb0d99fe1e635823e9fec93b782cd7ad", "filename": "libffi/src/raw_api.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fraw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fraw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fraw_api.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -43,10 +43,10 @@ ffi_raw_size (ffi_cif *cif)\n     {\n #if !FFI_NO_STRUCTS\n       if ((*at)->type == FFI_TYPE_STRUCT)\n-\tresult += ALIGN (sizeof (void*), FFI_SIZEOF_ARG);\n+\tresult += FFI_ALIGN (sizeof (void*), FFI_SIZEOF_ARG);\n       else\n #endif\n-\tresult += ALIGN ((*at)->size, FFI_SIZEOF_ARG);\n+\tresult += FFI_ALIGN ((*at)->size, FFI_SIZEOF_ARG);\n     }\n \n   return result;\n@@ -98,7 +98,7 @@ ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \t  \n \tdefault:\n \t  *args = raw;\n-\t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  raw += FFI_ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t}\n     }\n \n@@ -123,7 +123,7 @@ ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n       else\n \t{\n \t  *args = (void*) raw;\n-\t  raw += ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);\n+\t  raw += FFI_ALIGN ((*tp)->size, sizeof (void*)) / sizeof (void*);\n \t}\n     }\n \n@@ -186,7 +186,7 @@ ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n \n \tdefault:\n \t  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);\n-\t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  raw += FFI_ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \t}\n     }\n }"}, {"sha": "c910858896ae60d38da2b992c4790932767a5e20", "filename": "libffi/src/riscv/ffi.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Friscv%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Friscv%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Friscv%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -120,7 +120,7 @@ static float_struct_info struct_passed_as_elements(call_builder *cb, ffi_type *t\n \n         ret.type1 = fields[0]->type;\n         ret.type2 = fields[1]->type;\n-        ret.offset2 = ALIGN(fields[0]->size, fields[1]->alignment);\n+        ret.offset2 = FFI_ALIGN(fields[0]->size, fields[1]->alignment);\n         ret.as_elements = 1;\n     }\n \n@@ -238,8 +238,8 @@ static void marshal(call_builder *cb, ffi_type *type, int var, void *data) {\n         /* variadics are aligned even in registers */\n         if (type->alignment > __SIZEOF_POINTER__) {\n             if (var)\n-                cb->used_integer = ALIGN(cb->used_integer, 2);\n-            cb->used_stack = (size_t *)ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);\n+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n         }\n \n         memcpy(realign, data, type->size);\n@@ -286,8 +286,8 @@ static void *unmarshal(call_builder *cb, ffi_type *type, int var, void *data) {\n         /* variadics are aligned even in registers */\n         if (type->alignment > __SIZEOF_POINTER__) {\n             if (var)\n-                cb->used_integer = ALIGN(cb->used_integer, 2);\n-            cb->used_stack = (size_t *)ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);\n+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);\n         }\n \n         if (type->size > 0)\n@@ -334,10 +334,10 @@ ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n     /* this is a conservative estimate, assuming a complex return value and\n        that all remaining arguments are long long / __int128 */\n     size_t arg_bytes = cif->nargs <= 3 ? 0 :\n-        ALIGN(2 * sizeof(size_t) * (cif->nargs - 3), STKALIGN);\n+        FFI_ALIGN(2 * sizeof(size_t) * (cif->nargs - 3), STKALIGN);\n     size_t rval_bytes = 0;\n     if (rvalue == NULL && cif->rtype->size > 2*__SIZEOF_POINTER__)\n-        rval_bytes = ALIGN(cif->rtype->size, STKALIGN);\n+        rval_bytes = FFI_ALIGN(cif->rtype->size, STKALIGN);\n     size_t alloc_size = arg_bytes + rval_bytes + sizeof(call_context);\n \n     /* the assembly code will deallocate all stack data at lower addresses\n@@ -350,7 +350,7 @@ ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,\n            guarantee alloca alignment to at least that much */\n         alloc_base = (size_t)alloca(alloc_size);\n     } else {\n-        alloc_base = ALIGN(alloca(alloc_size + STKALIGN - 1), STKALIGN);\n+        alloc_base = FFI_ALIGN(alloca(alloc_size + STKALIGN - 1), STKALIGN);\n     }\n \n     if (rval_bytes)"}, {"sha": "9e406d0af678b8722538d09514f1008436904453", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -153,7 +153,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n \t  /* FALLTHRU */\n \n \tdefault:\n-\t  z = ALIGN(z, 4);\n+\t  z = FFI_ALIGN(z, 4);\n \t}\n       bytes += z;\n     }\n@@ -167,7 +167,7 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n   bytes += 4;\n \n   /* The stack must be 2 word aligned, so round bytes up appropriately. */\n-  bytes = ALIGN(bytes, 2 * 4);\n+  bytes = FFI_ALIGN(bytes, 2 * 4);\n \n   /* Include the call frame to prep_args.  */\n   bytes += 4*16 + 4*8;\n@@ -293,7 +293,7 @@ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,\n      got to pass the return value to the callee.  Otherwise ignore it.  */\n   if (rvalue == NULL\n       && (cif->flags & SPARC_FLAG_RET_MASK) == SPARC_RET_STRUCT)\n-    bytes += ALIGN (cif->rtype->size, 8);\n+    bytes += FFI_ALIGN (cif->rtype->size, 8);\n \n   ffi_call_v8(cif, fn, rvalue, avalue, -bytes, closure);\n }"}, {"sha": "9e04061a4283c997a74c87d54c2bd2c0b5acd1ec", "filename": "libffi/src/sparc/ffi64.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fsparc%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fsparc%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -75,7 +75,7 @@ ffi_struct_float_mask (ffi_type *outer_type, int size_mask)\n       size_t z = t->size;\n       int o, m, tt;\n \n-      size_mask = ALIGN(size_mask, t->alignment);\n+      size_mask = FFI_ALIGN(size_mask, t->alignment);\n       switch (t->type)\n \t{\n \tcase FFI_TYPE_STRUCT:\n@@ -99,7 +99,7 @@ ffi_struct_float_mask (ffi_type *outer_type, int size_mask)\n       size_mask += z;\n     }\n \n-  size_mask = ALIGN(size_mask, outer_type->alignment);\n+  size_mask = FFI_ALIGN(size_mask, outer_type->alignment);\n   FFI_ASSERT ((size_mask & 0xff) == outer_type->size);\n \n   return size_mask;\n@@ -284,8 +284,8 @@ ffi_prep_cif_machdep_core(ffi_cif *cif)\n \t  flags |= SPARC_FLAG_FP_ARGS;\n \t  break;\n \t}\n-      bytes = ALIGN(bytes, a);\n-      bytes += ALIGN(z, 8);\n+      bytes = FFI_ALIGN(bytes, a);\n+      bytes += FFI_ALIGN(z, 8);\n     }\n \n   /* Sparc call frames require that space is allocated for 6 args,\n@@ -294,7 +294,7 @@ ffi_prep_cif_machdep_core(ffi_cif *cif)\n     bytes = 6 * 8;\n \n   /* The stack must be 2 word aligned, so round bytes up appropriately. */\n-  bytes = ALIGN(bytes, 16);\n+  bytes = FFI_ALIGN(bytes, 16);\n \n   /* Include the call frame to prep_args.  */\n   bytes += 8*16 + 8*8;\n@@ -405,7 +405,7 @@ ffi_prep_args_v9(ffi_cif *cif, unsigned long *argp, void *rvalue, void **avalue)\n \t  if (((unsigned long)argp & 15) && ty->alignment > 8)\n \t    argp++;\n \t  memcpy(argp, a, z);\n-\t  argp += ALIGN(z, 8) / 8;\n+\t  argp += FFI_ALIGN(z, 8) / 8;\n \t  break;\n \n \tdefault:\n@@ -425,7 +425,7 @@ ffi_call_int(ffi_cif *cif, void (*fn)(void), void *rvalue,\n   FFI_ASSERT (cif->abi == FFI_V9);\n \n   if (rvalue == NULL && (cif->flags & SPARC_FLAG_RET_IN_MEM))\n-    bytes += ALIGN (cif->rtype->size, 16);\n+    bytes += FFI_ALIGN (cif->rtype->size, 16);\n \n   ffi_call_v9(cif, fn, rvalue, avalue, -bytes, closure);\n }\n@@ -547,7 +547,7 @@ ffi_closure_sparc_inner_v9(ffi_cif *cif,\n \t    a = *(void **)a;\n \t  else\n \t    {\n-\t      argx = argn + ALIGN (z, 8) / 8;\n+\t      argx = argn + FFI_ALIGN (z, 8) / 8;\n \t      if (named && argn < 16)\n \t\t{\n \t\t  int size_mask = ffi_struct_float_mask (ty, 0);\n@@ -561,7 +561,7 @@ ffi_closure_sparc_inner_v9(ffi_cif *cif,\n \t  break;\n \n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  argn = ALIGN (argn, 2);\n+\t  argn = FFI_ALIGN (argn, 2);\n \t  a = (named && argn < 16 ? fpr : gpr) + argn;\n \t  argx = argn + 2;\n \t  break;"}, {"sha": "265aeaa3cdf8d8a77c27c7d00a33b84e8f227cf2", "filename": "libffi/src/tramp.c", "status": "added", "additions": 729, "deletions": 0, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ftramp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ftramp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftramp.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,729 @@\n+/* -----------------------------------------------------------------------\n+   tramp.c - Copyright (c) 2020 Madhavan T. Venkataraman\n+\n+   API and support functions for managing statically defined closure\n+   trampolines.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <fficonfig.h>\n+\n+#ifdef FFI_EXEC_STATIC_TRAMP\n+\n+/* -------------------------- Headers and Definitions ---------------------*/\n+/*\n+ * Add support for other OSes later. For now, it is just Linux.\n+ */\n+\n+#if defined __linux__\n+#ifdef __linux__\n+#define _GNU_SOURCE 1\n+#endif\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <sys/mman.h>\n+#include <tramp.h>\n+#ifdef __linux__\n+#include <linux/limits.h>\n+#include <linux/types.h>\n+#endif\n+#endif /* __linux__ */\n+\n+/*\n+ * Each architecture defines static code for a trampoline code table. The\n+ * trampoline code table is mapped into the address space of a process.\n+ *\n+ * The following architecture specific function returns:\n+ *\n+ *\t- the address of the trampoline code table in the text segment\n+ *\t- the size of each trampoline in the trampoline code table\n+ *\t- the size of the mapping for the whole trampoline code table\n+ */\n+void __attribute__((weak)) *ffi_tramp_arch (size_t *tramp_size,\n+  size_t *map_size);\n+\n+/* ------------------------- Trampoline Data Structures --------------------*/\n+\n+struct tramp;\n+\n+/*\n+ * Trampoline table. Manages one trampoline code table and one trampoline\n+ * parameter table.\n+ *\n+ * prev, next\tLinks in the global trampoline table list.\n+ * code_table\tTrampoline code table mapping.\n+ * parm_table\tTrampoline parameter table mapping.\n+ * array\tArray of trampolines malloced.\n+ * free\t\tList of free trampolines.\n+ * nfree\tNumber of free trampolines.\n+ */\n+struct tramp_table\n+{\n+  struct tramp_table *prev;\n+  struct tramp_table *next;\n+  void *code_table;\n+  void *parm_table;\n+  struct tramp *array;\n+  struct tramp *free;\n+  int nfree;\n+};\n+\n+/*\n+ * Parameters for each trampoline.\n+ *\n+ * data\n+ *\tData for the target code that the trampoline jumps to.\n+ * target\n+ *\tTarget code that the trampoline jumps to.\n+ */\n+struct tramp_parm\n+{\n+  void *data;\n+  void *target;\n+};\n+\n+/*\n+ * Trampoline structure for each trampoline.\n+ *\n+ * prev, next\tLinks in the trampoline free list of a trampoline table.\n+ * table\tTrampoline table to which this trampoline belongs.\n+ * code\t\tAddress of this trampoline in the code table mapping.\n+ * parm\t\tAddress of this trampoline's parameters in the parameter\n+ *\t\ttable mapping.\n+ */\n+struct tramp\n+{\n+  struct tramp *prev;\n+  struct tramp *next;\n+  struct tramp_table *table;\n+  void *code;\n+  struct tramp_parm *parm;\n+};\n+\n+enum tramp_globals_status {\n+\tTRAMP_GLOBALS_UNINITIALIZED = 0,\n+\tTRAMP_GLOBALS_PASSED,\n+\tTRAMP_GLOBALS_FAILED,\n+};\n+\n+/*\n+ * Trampoline globals.\n+ *\n+ * fd\n+ *\tFile descriptor of binary file that contains the trampoline code table.\n+ * offset\n+ *\tOffset of the trampoline code table in that file.\n+ * text\n+ *\tAddress of the trampoline code table in the text segment.\n+ * map_size\n+ *\tSize of the trampoline code table mapping.\n+ * size\n+ *\tSize of one trampoline in the trampoline code table.\n+ * ntramp\n+ *\tTotal number of trampolines in the trampoline code table.\n+ * free_tables\n+ *\tList of trampoline tables that contain free trampolines.\n+ * nfree_tables\n+ *\tNumber of trampoline tables that contain free trampolines.\n+ * status\n+ *\tInitialization status.\n+ */\n+struct tramp_globals\n+{\n+  int fd;\n+  off_t offset;\n+  void *text;\n+  size_t map_size;\n+  size_t size;\n+  int ntramp;\n+  struct tramp_table *free_tables;\n+  int nfree_tables;\n+  enum tramp_globals_status status;\n+};\n+\n+static struct tramp_globals tramp_globals;\n+\n+/* --------------------- Trampoline File Initialization --------------------*/\n+\n+/*\n+ * The trampoline file is the file used to map the trampoline code table into\n+ * the address space of a process. There are two ways to get this file:\n+ *\n+ * - From the OS. E.g., on Linux, /proc/<pid>/maps lists all the memory\n+ *   mappings for <pid>. For file-backed mappings, maps supplies the file name\n+ *   and the file offset. Using this, we can locate the mapping that maps\n+ *   libffi and get the path to the libffi binary. And, we can compute the\n+ *   offset of the trampoline code table within that binary.\n+ *\n+ * - Else, if we can create a temporary file, we can write the trampoline code\n+ *   table from the text segment into the temporary file.\n+ *\n+ * The first method is the preferred one. If the OS security subsystem\n+ * disallows mapping unsigned files with PROT_EXEC, then the second method\n+ * will fail.\n+ *\n+ * If an OS allows the trampoline code table in the text segment to be\n+ * directly remapped (e.g., MACH vm_remap ()), then we don't need the\n+ * trampoline file.\n+ */\n+static int tramp_table_alloc (void);\n+\n+#if defined __linux__\n+\n+static int\n+ffi_tramp_get_libffi (void)\n+{\n+  FILE *fp;\n+  char file[PATH_MAX], line[PATH_MAX+100], perm[10], dev[10];\n+  unsigned long start, end, offset, inode;\n+  uintptr_t addr = (uintptr_t) tramp_globals.text;\n+  int nfields, found;\n+\n+  snprintf (file, PATH_MAX, \"/proc/%d/maps\", getpid());\n+  fp = fopen (file, \"r\");\n+  if (fp == NULL)\n+    return 0;\n+\n+  found = 0;\n+  while (feof (fp) == 0) {\n+    if (fgets (line, sizeof (line), fp) == 0)\n+      break;\n+\n+    nfields = sscanf (line, \"%lx-%lx %9s %lx %9s %ld %s\",\n+      &start, &end, perm, &offset, dev, &inode, file);\n+    if (nfields != 7)\n+      continue;\n+\n+    if (addr >= start && addr < end) {\n+      tramp_globals.offset = offset + (addr - start);\n+      found = 1;\n+      break;\n+    }\n+  }\n+  fclose (fp);\n+\n+  if (!found)\n+    return 0;\n+\n+  tramp_globals.fd = open (file, O_RDONLY);\n+  if (tramp_globals.fd == -1)\n+    return 0;\n+\n+  /*\n+   * Allocate a trampoline table just to make sure that the trampoline code\n+   * table can be mapped.\n+   */\n+  if (!tramp_table_alloc ())\n+    {\n+      close (tramp_globals.fd);\n+      tramp_globals.fd = -1;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+#endif /* __linux__ */\n+\n+#if defined __linux__\n+\n+#if defined HAVE_MKSTEMP\n+\n+static int\n+ffi_tramp_get_temp_file (void)\n+{\n+  char template[12] = \"/tmp/XXXXXX\";\n+  ssize_t count;\n+\n+  tramp_globals.offset = 0;\n+  tramp_globals.fd = mkstemp (template);\n+  if (tramp_globals.fd == -1)\n+    return 0;\n+\n+  unlink (template);\n+  /*\n+   * Write the trampoline code table into the temporary file and allocate a\n+   * trampoline table to make sure that the temporary file can be mapped.\n+   */\n+  count = write(tramp_globals.fd, tramp_globals.text, tramp_globals.map_size);\n+  if (count == tramp_globals.map_size && tramp_table_alloc ())\n+    return 1;\n+\n+  close (tramp_globals.fd);\n+  tramp_globals.fd = -1;\n+  return 0;\n+}\n+\n+#else /* !defined HAVE_MKSTEMP */\n+\n+/*\n+ * TODO:\n+ * src/closures.c contains code for finding temp file that has EXEC\n+ * permissions. May be, some of that code can be shared with static\n+ * trampolines.\n+ */\n+static int\n+ffi_tramp_get_temp_file (void)\n+{\n+  tramp_globals.offset = 0;\n+  tramp_globals.fd = -1;\n+  return 0;\n+}\n+\n+#endif /* defined HAVE_MKSTEMP */\n+\n+#endif /* __linux__ */\n+\n+/* ------------------------ OS-specific Initialization ----------------------*/\n+\n+#if defined __linux__\n+\n+static int\n+ffi_tramp_init_os (void)\n+{\n+  if (ffi_tramp_get_libffi ())\n+    return 1;\n+  return ffi_tramp_get_temp_file ();\n+}\n+\n+#endif /* __linux__ */\n+\n+/* --------------------------- OS-specific Locking -------------------------*/\n+\n+#if defined __linux__\n+\n+static pthread_mutex_t tramp_globals_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+static void\n+ffi_tramp_lock(void)\n+{\n+  pthread_mutex_lock (&tramp_globals_mutex);\n+}\n+\n+static void\n+ffi_tramp_unlock()\n+{\n+  pthread_mutex_unlock (&tramp_globals_mutex);\n+}\n+\n+#endif /* __linux__ */\n+\n+/* ------------------------ OS-specific Memory Mapping ----------------------*/\n+\n+/*\n+ * Create a trampoline code table mapping and a trampoline parameter table\n+ * mapping. The two mappings must be adjacent to each other for PC-relative\n+ * access.\n+ *\n+ * For each trampoline in the code table, there is a corresponding parameter\n+ * block in the parameter table. The size of the parameter block is the same\n+ * as the size of the trampoline. This means that the parameter block is at\n+ * a fixed offset from its trampoline making it easy for a trampoline to find\n+ * its parameters using PC-relative access.\n+ *\n+ * The parameter block will contain a struct tramp_parm. This means that\n+ * sizeof (struct tramp_parm) cannot exceed the size of a parameter block.\n+ */\n+\n+#if defined __linux__\n+\n+static int\n+tramp_table_map (struct tramp_table *table)\n+{\n+  char *addr;\n+\n+  /*\n+   * Create an anonymous mapping twice the map size. The top half will be used\n+   * for the code table. The bottom half will be used for the parameter table.\n+   */\n+  addr = mmap (NULL, tramp_globals.map_size * 2, PROT_READ | PROT_WRITE,\n+    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (addr == MAP_FAILED)\n+    return 0;\n+\n+  /*\n+   * Replace the top half of the anonymous mapping with the code table mapping.\n+   */\n+  table->code_table = mmap (addr, tramp_globals.map_size, PROT_READ | PROT_EXEC,\n+    MAP_PRIVATE | MAP_FIXED, tramp_globals.fd, tramp_globals.offset);\n+  if (table->code_table == MAP_FAILED)\n+    {\n+      (void) munmap (addr, tramp_globals.map_size * 2);\n+      return 0;\n+    }\n+  table->parm_table = table->code_table + tramp_globals.map_size;\n+  return 1;\n+}\n+\n+static void\n+tramp_table_unmap (struct tramp_table *table)\n+{\n+  (void) munmap (table->code_table, tramp_globals.map_size);\n+  (void) munmap (table->parm_table, tramp_globals.map_size);\n+}\n+\n+#endif /* __linux__ */\n+\n+/* ------------------------ Trampoline Initialization ----------------------*/\n+\n+/*\n+ * Initialize the static trampoline feature.\n+ */\n+static int\n+ffi_tramp_init (void)\n+{\n+  if (tramp_globals.status == TRAMP_GLOBALS_PASSED)\n+    return 1;\n+\n+  if (tramp_globals.status == TRAMP_GLOBALS_FAILED)\n+    return 0;\n+\n+  if (ffi_tramp_arch == NULL)\n+    {\n+      tramp_globals.status = TRAMP_GLOBALS_FAILED;\n+      return 0;\n+    }\n+\n+  tramp_globals.free_tables = NULL;\n+  tramp_globals.nfree_tables = 0;\n+\n+  /*\n+   * Get trampoline code table information from the architecture.\n+   */\n+  tramp_globals.text = ffi_tramp_arch (&tramp_globals.size,\n+    &tramp_globals.map_size);\n+  tramp_globals.ntramp = tramp_globals.map_size / tramp_globals.size;\n+\n+  if (sysconf (_SC_PAGESIZE) > tramp_globals.map_size)\n+    return 0;\n+\n+  if (ffi_tramp_init_os ())\n+    {\n+      tramp_globals.status = TRAMP_GLOBALS_PASSED;\n+      return 1;\n+    }\n+\n+  tramp_globals.status = TRAMP_GLOBALS_FAILED;\n+  return 0;\n+}\n+\n+/* ---------------------- Trampoline Table functions ---------------------- */\n+\n+/* This code assumes that malloc () is available on all OSes. */\n+\n+static void tramp_add (struct tramp *tramp);\n+\n+/*\n+ * Allocate and initialize a trampoline table.\n+ */\n+static int\n+tramp_table_alloc (void)\n+{\n+  struct tramp_table *table;\n+  struct tramp *tramp_array, *tramp;\n+  size_t size;\n+  char *code, *parm;\n+  int i;\n+\n+  /*\n+   * If we already have tables with free trampolines, there is no need to\n+   * allocate a new table.\n+   */\n+  if (tramp_globals.nfree_tables > 0)\n+    return 1;\n+\n+  /*\n+   * Allocate a new trampoline table structure.\n+   */\n+  table = malloc (sizeof (*table));\n+  if (table == NULL)\n+    return 0;\n+\n+  /*\n+   * Allocate new trampoline structures.\n+   */\n+  tramp_array = malloc (sizeof (*tramp) * tramp_globals.ntramp);\n+  if (tramp_array == NULL)\n+    goto free_table;\n+\n+  /*\n+   * Map a code table and a parameter table into the caller's address space.\n+   */\n+  if (!tramp_table_map (table))\n+    {\n+      /*\n+       * Failed to map the code and parameter tables.\n+       */\n+      goto free_tramp_array;\n+    }\n+\n+  /*\n+   * Initialize the trampoline table.\n+   */\n+  table->array = tramp_array;\n+  table->free = NULL;\n+  table->nfree = 0;\n+\n+  /*\n+   * Populate the trampoline table free list. This will also add the trampoline\n+   * table to the global list of trampoline tables.\n+   */\n+  size = tramp_globals.size;\n+  code = table->code_table;\n+  parm = table->parm_table;\n+  for (i = 0; i < tramp_globals.ntramp; i++)\n+    {\n+      tramp = &tramp_array[i];\n+      tramp->table = table;\n+      tramp->code = code;\n+      tramp->parm = (struct tramp_parm *) parm;\n+      tramp_add (tramp);\n+\n+      code += size;\n+      parm += size;\n+    }\n+  /* Success */\n+  return 1;\n+\n+/* Failure */\n+free_tramp_array:\n+  free (tramp_array);\n+free_table:\n+  free (table);\n+  return 0;\n+}\n+\n+/*\n+ * Free a trampoline table.\n+ */\n+static void\n+tramp_table_free (struct tramp_table *table)\n+{\n+  tramp_table_unmap (table);\n+  free (table->array);\n+  free (table);\n+}\n+\n+/*\n+ * Add a new trampoline table to the global table list.\n+ */\n+static void\n+tramp_table_add (struct tramp_table *table)\n+{\n+  table->next = tramp_globals.free_tables;\n+  table->prev = NULL;\n+  if (tramp_globals.free_tables != NULL)\n+    tramp_globals.free_tables->prev = table;\n+  tramp_globals.free_tables = table;\n+  tramp_globals.nfree_tables++;\n+}\n+\n+/*\n+ * Delete a trampoline table from the global table list.\n+ */\n+static void\n+tramp_table_del (struct tramp_table *table)\n+{\n+  tramp_globals.nfree_tables--;\n+  if (table->prev != NULL)\n+    table->prev->next = table->next;\n+  if (table->next != NULL)\n+    table->next->prev = table->prev;\n+  if (tramp_globals.free_tables == table)\n+    tramp_globals.free_tables = table->next;\n+}\n+\n+/* ------------------------- Trampoline functions ------------------------- */\n+\n+/*\n+ * Add a trampoline to its trampoline table.\n+ */\n+static void\n+tramp_add (struct tramp *tramp)\n+{\n+  struct tramp_table *table = tramp->table;\n+\n+  tramp->next = table->free;\n+  tramp->prev = NULL;\n+  if (table->free != NULL)\n+    table->free->prev = tramp;\n+  table->free = tramp;\n+  table->nfree++;\n+\n+  if (table->nfree == 1)\n+    tramp_table_add (table);\n+\n+  /*\n+   * We don't want to keep too many free trampoline tables lying around.\n+   */\n+  if (table->nfree == tramp_globals.ntramp &&\n+    tramp_globals.nfree_tables > 1)\n+    {\n+      tramp_table_del (table);\n+      tramp_table_free (table);\n+    }\n+}\n+\n+/*\n+ * Remove a trampoline from its trampoline table.\n+ */\n+static void\n+tramp_del (struct tramp *tramp)\n+{\n+  struct tramp_table *table = tramp->table;\n+\n+  table->nfree--;\n+  if (tramp->prev != NULL)\n+    tramp->prev->next = tramp->next;\n+  if (tramp->next != NULL)\n+    tramp->next->prev = tramp->prev;\n+  if (table->free == tramp)\n+    table->free = tramp->next;\n+\n+  if (table->nfree == 0)\n+    tramp_table_del (table);\n+}\n+\n+/* ------------------------ Trampoline API functions ------------------------ */\n+\n+int\n+ffi_tramp_is_supported(void)\n+{\n+  int ret;\n+\n+  ffi_tramp_lock();\n+  ret = ffi_tramp_init ();\n+  ffi_tramp_unlock();\n+  return ret;\n+}\n+\n+/*\n+ * Allocate a trampoline and return its opaque address.\n+ */\n+void *\n+ffi_tramp_alloc (int flags)\n+{\n+  struct tramp *tramp;\n+\n+  ffi_tramp_lock();\n+\n+  if (!ffi_tramp_init () || flags != 0)\n+    {\n+      ffi_tramp_unlock();\n+      return NULL;\n+    }\n+\n+  if (!tramp_table_alloc ())\n+    {\n+      ffi_tramp_unlock();\n+      return NULL;\n+    }\n+\n+  tramp = tramp_globals.free_tables->free;\n+  tramp_del (tramp);\n+\n+  ffi_tramp_unlock();\n+\n+  return tramp;\n+}\n+\n+/*\n+ * Set the parameters for a trampoline.\n+ */\n+void\n+ffi_tramp_set_parms (void *arg, void *target, void *data)\n+{\n+  struct tramp *tramp = arg;\n+\n+  ffi_tramp_lock();\n+  tramp->parm->target = target;\n+  tramp->parm->data = data;\n+  ffi_tramp_unlock();\n+}\n+\n+/*\n+ * Get the invocation address of a trampoline.\n+ */\n+void *\n+ffi_tramp_get_addr (void *arg)\n+{\n+  struct tramp *tramp = arg;\n+  void *addr;\n+\n+  ffi_tramp_lock();\n+  addr = tramp->code;\n+  ffi_tramp_unlock();\n+\n+  return addr;\n+}\n+\n+/*\n+ * Free a trampoline.\n+ */\n+void\n+ffi_tramp_free (void *arg)\n+{\n+  struct tramp *tramp = arg;\n+\n+  ffi_tramp_lock();\n+  tramp_add (tramp);\n+  ffi_tramp_unlock();\n+}\n+\n+/* ------------------------------------------------------------------------- */\n+\n+#else /* !FFI_EXEC_STATIC_TRAMP */\n+\n+#include <stddef.h>\n+\n+int\n+ffi_tramp_is_supported(void)\n+{\n+  return 0;\n+}\n+\n+void *\n+ffi_tramp_alloc (int flags)\n+{\n+  return NULL;\n+}\n+\n+void\n+ffi_tramp_set_parms (void *arg, void *target, void *data)\n+{\n+}\n+\n+void *\n+ffi_tramp_get_addr (void *arg)\n+{\n+  return NULL;\n+}\n+\n+void\n+ffi_tramp_free (void *arg)\n+{\n+}\n+\n+#endif /* FFI_EXEC_STATIC_TRAMP */"}, {"sha": "9ec27f6cf37676d83bfb489bbe1bb7c7c7363378", "filename": "libffi/src/types.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -38,6 +38,7 @@ struct struct_align_##name {\t\t\t\\\n   char c;\t\t\t\t\t\\\n   type x;\t\t\t\t\t\\\n };\t\t\t\t\t\t\\\n+FFI_EXTERN\t\t\t\t\t\\\n maybe_const ffi_type ffi_type_##name = {\t\\\n   sizeof(type),\t\t\t\t\t\\\n   offsetof(struct struct_align_##name, x),\t\\\n@@ -52,6 +53,7 @@ struct struct_align_complex_##name {\t\t\t\\\n   char c;\t\t\t\t\t\t\\\n   _Complex type x;\t\t\t\t\t\\\n };\t\t\t\t\t\t\t\\\n+FFI_EXTERN\t\t\t\t\t\t\\\n maybe_const ffi_type ffi_type_complex_##name = {\t\\\n   sizeof(_Complex type),\t\t\t\t\\\n   offsetof(struct struct_align_complex_##name, x),\t\\\n@@ -60,7 +62,7 @@ maybe_const ffi_type ffi_type_complex_##name = {\t\\\n }\n \n /* Size and alignment are fake here. They must not be 0. */\n-const ffi_type ffi_type_void = {\n+FFI_EXTERN const ffi_type ffi_type_void = {\n   1, 1, FFI_TYPE_VOID, NULL\n };\n "}, {"sha": "e52caec86da2e8ebec5fdd173ff4b247f8a98489", "filename": "libffi/src/vax/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fvax%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fvax%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fvax%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -108,7 +108,7 @@ ffi_prep_args (extended_cif *ecif, void *stack)\n \n \t  /* Align if necessary.  */\n \t  if ((sizeof(int) - 1) & z)\n-\t    z = ALIGN(z, sizeof(int));\n+\t    z = FFI_ALIGN(z, sizeof(int));\n \t}\n \n       p_argv++;\n@@ -215,7 +215,7 @@ ffi_prep_closure_elfbsd (ffi_cif *cif, void **avalue, char *stackp)\n \n       /* Align if necessary */\n       if ((sizeof (int) - 1) & z)\n-\tz = ALIGN(z, sizeof (int));\n+\tz = FFI_ALIGN(z, sizeof (int));\n \n       p_argv++;\n       stackp += z;"}, {"sha": "7551021e17ebab8f168b2b9359fb6f67ccc6f3b8", "filename": "libffi/src/x86/asmnames.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fasmnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fasmnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fasmnames.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "patch": "@@ -0,0 +1,30 @@\n+#ifndef ASMNAMES_H\n+#define ASMNAMES_H\n+\n+#define C2(X, Y)  X ## Y\n+#define C1(X, Y)  C2(X, Y)\n+#ifdef __USER_LABEL_PREFIX__\n+# define C(X)     C1(__USER_LABEL_PREFIX__, X)\n+#else\n+# define C(X)     X\n+#endif\n+\n+#ifdef __APPLE__\n+# define L(X)     C1(L, X)\n+#else\n+# define L(X)     C1(.L, X)\n+#endif\n+\n+#if defined(__ELF__) && defined(__PIC__)\n+# define PLT(X)\t  X@PLT\n+#else\n+# define PLT(X)\t  X\n+#endif\n+\n+#ifdef __ELF__\n+# define ENDF(X)  .type\tX,@function; .size X, . - X\n+#else\n+# define ENDF(X)\n+#endif\n+\n+#endif /* ASMNAMES_H */"}, {"sha": "8f0f0707aaf040bda76d1172c1bd7d398421fc70", "filename": "libffi/src/x86/darwin.S", "status": "removed", "additions": 0, "deletions": 444, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin.S?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170", "patch": "@@ -1,444 +0,0 @@\n-/* -----------------------------------------------------------------------\n-   darwin.S - Copyright (c) 1996, 1998, 2001, 2002, 2003, 2005  Red Hat, Inc.\n-\tCopyright (C) 2008  Free Software Foundation, Inc.\n-\n-   X86 Foreign Function Interface\n-\n-   Permission is hereby granted, free of charge, to any person obtaining\n-   a copy of this software and associated documentation files (the\n-   ``Software''), to deal in the Software without restriction, including\n-   without limitation the rights to use, copy, modify, merge, publish,\n-   distribute, sublicense, and/or sell copies of the Software, and to\n-   permit persons to whom the Software is furnished to do so, subject to\n-   the following conditions:\n-\n-   The above copyright notice and this permission notice shall be included\n-   in all copies or substantial portions of the Software.\n-\n-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-   DEALINGS IN THE SOFTWARE.\n-   -----------------------------------------------------------------------\n-   */\n-\n-#ifndef __x86_64__\n-\n-#define LIBFFI_ASM\t\n-#include <fficonfig.h>\n-#include <ffi.h>\n-\n-.text\n-\n-.globl _ffi_prep_args\n-\n-\t.align 4\n-.globl _ffi_call_SYSV\n-\n-_ffi_call_SYSV:\n-.LFB1:\n-        pushl %ebp\n-.LCFI0:\n-        movl  %esp,%ebp\n-.LCFI1:\n-        subl $8,%esp\n-\t/* Make room for all of the new args.  */\n-\tmovl  16(%ebp),%ecx\n-\tsubl  %ecx,%esp\n-\n-\tmovl  %esp,%eax\n-\n-\t/* Place all of the ffi_prep_args in position  */\n-\tsubl  $8,%esp\n-\tpushl 12(%ebp)\n-\tpushl %eax\n-\tcall  *8(%ebp)\n-\n-\t/* Return stack to previous state and call the function  */\n-\taddl  $16,%esp\t\n-\n-\tcall  *28(%ebp)\n-\n-\t/* Load %ecx with the return type code  */\n-\tmovl  20(%ebp),%ecx\t\n-\n-\t/* Protect %esi.  We're going to pop it in the epilogue.  */\n-\tpushl %esi\n-\n-\t/* If the return value pointer is NULL, assume no return value.  */\n-\tcmpl  $0,24(%ebp)\n-\tjne  0f\n-\n-\t/* Even if there is no space for the return value, we are \n-\t   obliged to handle floating-point values.  */\n-\tcmpl  $FFI_TYPE_FLOAT,%ecx\n-\tjne   noretval\n-\tfstp  %st(0)\n-\n-\tjmp   epilogue\n-0:\n-\t.align 4\n-\tcall 1f\n-.Lstore_table:\n-\t.long   noretval-.Lstore_table\t\t/* FFI_TYPE_VOID */\n-\t.long   retint-.Lstore_table\t\t/* FFI_TYPE_INT */\n-\t.long   retfloat-.Lstore_table\t\t/* FFI_TYPE_FLOAT */\n-\t.long   retdouble-.Lstore_table\t\t/* FFI_TYPE_DOUBLE */\n-\t.long   retlongdouble-.Lstore_table     /* FFI_TYPE_LONGDOUBLE */\n-\t.long   retuint8-.Lstore_table\t\t/* FFI_TYPE_UINT8 */\n-\t.long   retsint8-.Lstore_table\t\t/* FFI_TYPE_SINT8 */\n-\t.long   retuint16-.Lstore_table\t\t/* FFI_TYPE_UINT16 */\n-\t.long   retsint16-.Lstore_table\t\t/* FFI_TYPE_SINT16 */\n-\t.long   retint-.Lstore_table\t\t/* FFI_TYPE_UINT32 */\n-\t.long   retint-.Lstore_table\t\t/* FFI_TYPE_SINT32 */\n-\t.long   retint64-.Lstore_table\t\t/* FFI_TYPE_UINT64 */\n-\t.long   retint64-.Lstore_table\t\t/* FFI_TYPE_SINT64 */\n-\t.long   retstruct-.Lstore_table\t\t/* FFI_TYPE_STRUCT */\n-\t.long   retint-.Lstore_table\t\t/* FFI_TYPE_POINTER */\n-\t.long   retstruct1b-.Lstore_table\t/* FFI_TYPE_SMALL_STRUCT_1B */\n-\t.long   retstruct2b-.Lstore_table\t/* FFI_TYPE_SMALL_STRUCT_2B */\n-1:\n-\tpop  %esi\n-\tadd  (%esi, %ecx, 4), %esi\n-\tjmp  *%esi\n-\n-\t/* Sign/zero extend as appropriate.  */\n-retsint8:\n-\tmovsbl  %al, %eax\n-\tjmp  retint\n-\n-retsint16:\n-\tmovswl  %ax, %eax\n-\tjmp  retint\n-\n-retuint8:\n-\tmovzbl  %al, %eax\n-\tjmp  retint\n-\n-retuint16:\n-\tmovzwl  %ax, %eax\n-\tjmp  retint\n-\n-retfloat:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tfstps (%ecx)\n-\tjmp   epilogue\n-\n-retdouble:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tfstpl (%ecx)\n-\tjmp   epilogue\n-\n-retlongdouble:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tfstpt (%ecx)\n-\tjmp   epilogue\n-\n-retint64:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tmovl  %eax,0(%ecx)\n-\tmovl  %edx,4(%ecx)\n-\tjmp   epilogue\n-\n-retstruct1b:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tmovb  %al,0(%ecx)\n-\tjmp   epilogue\n-\n-retstruct2b:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tmovw  %ax,0(%ecx)\n-\tjmp   epilogue\n-\n-retint:\n-\t/* Load %ecx with the pointer to storage for the return value  */\n-\tmovl  24(%ebp),%ecx\n-\tmovl  %eax,0(%ecx)\n-\n-retstruct:\n-\t/* Nothing to do!  */\n-\n-noretval:\n-epilogue:\n-\tpopl %esi\n-\tmovl %ebp,%esp\n-\tpopl %ebp\n-\tret\n-\n-.LFE1:\n-.ffi_call_SYSV_end:\n-\n-\t.align\t4\n-FFI_HIDDEN (ffi_closure_SYSV)\n-.globl _ffi_closure_SYSV\n-\n-_ffi_closure_SYSV:\n-.LFB2:\n-\tpushl\t%ebp\n-.LCFI2:\n-\tmovl\t%esp, %ebp\n-.LCFI3:\n-\tsubl\t$40, %esp\n-\tleal\t-24(%ebp), %edx\n-\tmovl\t%edx, -12(%ebp)\t/* resp */\n-\tleal\t8(%ebp), %edx\n-\tmovl\t%edx, 4(%esp)\t/* args = __builtin_dwarf_cfa () */\n-\tleal\t-12(%ebp), %edx\n-\tmovl\t%edx, (%esp)\t/* &resp */\n-\tmovl\t%ebx, 8(%esp)\n-.LCFI7:\n-\tcall\tL_ffi_closure_SYSV_inner$stub\n-\tmovl\t8(%esp), %ebx\n-\tmovl\t-12(%ebp), %ecx\n-\tcmpl\t$FFI_TYPE_INT, %eax\n-\tje\t.Lcls_retint\n-\n-\t/* Handle FFI_TYPE_UINT8, FFI_TYPE_SINT8, FFI_TYPE_UINT16,\n-\t   FFI_TYPE_SINT16, FFI_TYPE_UINT32, FFI_TYPE_SINT32.  */\n-\tcmpl\t$FFI_TYPE_UINT64, %eax\n-\tjge\t0f\n-\tcmpl\t$FFI_TYPE_UINT8, %eax\n-\tjge\t.Lcls_retint\n-\n-0:\tcmpl\t$FFI_TYPE_FLOAT, %eax\n-\tje\t.Lcls_retfloat\n-\tcmpl\t$FFI_TYPE_DOUBLE, %eax\n-\tje\t.Lcls_retdouble\n-\tcmpl\t$FFI_TYPE_LONGDOUBLE, %eax\n-\tje\t.Lcls_retldouble\n-\tcmpl\t$FFI_TYPE_SINT64, %eax\n-\tje\t.Lcls_retllong\n-\tcmpl\t$FFI_TYPE_SMALL_STRUCT_1B, %eax\n-\tje\t.Lcls_retstruct1b\n-\tcmpl\t$FFI_TYPE_SMALL_STRUCT_2B, %eax\n-\tje\t.Lcls_retstruct2b\n-\tcmpl\t$FFI_TYPE_STRUCT, %eax\n-\tje\t.Lcls_retstruct\n-.Lcls_epilogue:\n-\tmovl\t%ebp, %esp\n-\tpopl\t%ebp\n-\tret\n-.Lcls_retint:\n-\tmovl\t(%ecx), %eax\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retfloat:\n-\tflds\t(%ecx)\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retdouble:\n-\tfldl\t(%ecx)\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retldouble:\n-\tfldt\t(%ecx)\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retllong:\n-\tmovl\t(%ecx), %eax\n-\tmovl\t4(%ecx), %edx\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retstruct1b:\n-\tmovsbl\t(%ecx), %eax\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retstruct2b:\n-\tmovswl\t(%ecx), %eax\n-\tjmp\t.Lcls_epilogue\n-.Lcls_retstruct:\n-\tlea -8(%ebp),%esp\n-\tmovl\t%ebp, %esp\n-\tpopl\t%ebp\n-\tret $4\n-.LFE2:\n-\n-#if !FFI_NO_RAW_API\n-\n-#define RAW_CLOSURE_CIF_OFFSET ((FFI_TRAMPOLINE_SIZE + 3) & ~3)\n-#define RAW_CLOSURE_FUN_OFFSET (RAW_CLOSURE_CIF_OFFSET + 4)\n-#define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)\n-#define CIF_FLAGS_OFFSET 20\n-\n-\t.align\t4\n-FFI_HIDDEN (ffi_closure_raw_SYSV)\n-.globl _ffi_closure_raw_SYSV\n-\n-_ffi_closure_raw_SYSV:\n-.LFB3:\n-\tpushl\t%ebp\n-.LCFI4:\n-\tmovl\t%esp, %ebp\n-.LCFI5:\n-\tpushl\t%esi\n-.LCFI6:\n-\tsubl\t$36, %esp\n-\tmovl\tRAW_CLOSURE_CIF_OFFSET(%eax), %esi\t /* closure->cif */\n-\tmovl\tRAW_CLOSURE_USER_DATA_OFFSET(%eax), %edx /* closure->user_data */\n-\tmovl\t%edx, 12(%esp)\t/* user_data */\n-\tleal\t8(%ebp), %edx\t/* __builtin_dwarf_cfa () */\n-\tmovl\t%edx, 8(%esp)\t/* raw_args */\n-\tleal\t-24(%ebp), %edx\n-\tmovl\t%edx, 4(%esp)\t/* &res */\n-\tmovl\t%esi, (%esp)\t/* cif */\n-\tcall\t*RAW_CLOSURE_FUN_OFFSET(%eax)\t\t /* closure->fun */\n-\tmovl\tCIF_FLAGS_OFFSET(%esi), %eax\t\t /* rtype */\n-\tcmpl\t$FFI_TYPE_INT, %eax\n-\tje\t.Lrcls_retint\n-\n-\t/* Handle FFI_TYPE_UINT8, FFI_TYPE_SINT8, FFI_TYPE_UINT16,\n-\t   FFI_TYPE_SINT16, FFI_TYPE_UINT32, FFI_TYPE_SINT32.  */\n-\tcmpl\t$FFI_TYPE_UINT64, %eax\n-\tjge\t0f\n-\tcmpl\t$FFI_TYPE_UINT8, %eax\n-\tjge\t.Lrcls_retint\n-0:\n-\tcmpl\t$FFI_TYPE_FLOAT, %eax\n-\tje\t.Lrcls_retfloat\n-\tcmpl\t$FFI_TYPE_DOUBLE, %eax\n-\tje\t.Lrcls_retdouble\n-\tcmpl\t$FFI_TYPE_LONGDOUBLE, %eax\n-\tje\t.Lrcls_retldouble\n-\tcmpl\t$FFI_TYPE_SINT64, %eax\n-\tje\t.Lrcls_retllong\n-.Lrcls_epilogue:\n-\taddl\t$36, %esp\n-\tpopl\t%esi\n-\tpopl\t%ebp\n-\tret\n-.Lrcls_retint:\n-\tmovl\t-24(%ebp), %eax\n-\tjmp\t.Lrcls_epilogue\n-.Lrcls_retfloat:\n-\tflds\t-24(%ebp)\n-\tjmp\t.Lrcls_epilogue\n-.Lrcls_retdouble:\n-\tfldl\t-24(%ebp)\n-\tjmp\t.Lrcls_epilogue\n-.Lrcls_retldouble:\n-\tfldt\t-24(%ebp)\n-\tjmp\t.Lrcls_epilogue\n-.Lrcls_retllong:\n-\tmovl\t-24(%ebp), %eax\n-\tmovl\t-20(%ebp), %edx\n-\tjmp\t.Lrcls_epilogue\n-.LFE3:\n-#endif\n-\n-.section __IMPORT,__jump_table,symbol_stubs,self_modifying_code+pure_instructions,5\n-L_ffi_closure_SYSV_inner$stub:\n-\t.indirect_symbol _ffi_closure_SYSV_inner\n-\thlt ; hlt ; hlt ; hlt ; hlt\n-\n-\n-.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n-EH_frame1:\n-\t.set\tL$set$0,LECIE1-LSCIE1\n-\t.long\tL$set$0\n-LSCIE1:\n-\t.long\t0x0\n-\t.byte\t0x1\n-\t.ascii \"zR\\0\"\n-\t.byte\t0x1\n-\t.byte\t0x7c\n-\t.byte\t0x8\n-\t.byte\t0x1\n-\t.byte\t0x10\n-\t.byte\t0xc\n-\t.byte\t0x5\n-\t.byte\t0x4\n-\t.byte\t0x88\n-\t.byte\t0x1\n-\t.align 2\n-LECIE1:\n-.globl _ffi_call_SYSV.eh\n-_ffi_call_SYSV.eh:\n-LSFDE1:\n-\t.set\tL$set$1,LEFDE1-LASFDE1\n-\t.long\tL$set$1\n-LASFDE1:\n-\t.long\tLASFDE1-EH_frame1\n-\t.long\t.LFB1-.\n-\t.set L$set$2,.LFE1-.LFB1\n-\t.long L$set$2\n-\t.byte\t0x0\n-\t.byte\t0x4\n-\t.set L$set$3,.LCFI0-.LFB1\n-\t.long L$set$3\n-\t.byte\t0xe\n-\t.byte\t0x8\n-\t.byte\t0x84\n-\t.byte\t0x2\n-\t.byte\t0x4\n-\t.set L$set$4,.LCFI1-.LCFI0\n-\t.long L$set$4\n-\t.byte\t0xd\n-\t.byte\t0x4\n-\t.align 2\n-LEFDE1:\n-.globl _ffi_closure_SYSV.eh\n-_ffi_closure_SYSV.eh:\n-LSFDE2:\n-\t.set\tL$set$5,LEFDE2-LASFDE2\n-\t.long\tL$set$5\n-LASFDE2:\n-\t.long\tLASFDE2-EH_frame1\n-\t.long\t.LFB2-.\n-\t.set L$set$6,.LFE2-.LFB2\n-\t.long L$set$6\n-\t.byte\t0x0\n-\t.byte\t0x4\n-\t.set L$set$7,.LCFI2-.LFB2\n-\t.long L$set$7\n-\t.byte\t0xe\n-\t.byte\t0x8\n-\t.byte\t0x84\n-\t.byte\t0x2\n-\t.byte\t0x4\n-\t.set L$set$8,.LCFI3-.LCFI2\n-\t.long L$set$8\n-\t.byte\t0xd\n-\t.byte\t0x4\n-\t.align 2\n-LEFDE2:\n-\n-#if !FFI_NO_RAW_API\n-\n-.globl _ffi_closure_raw_SYSV.eh\n-_ffi_closure_raw_SYSV.eh:\n-LSFDE3:\n-\t.set\tL$set$10,LEFDE3-LASFDE3\n-\t.long\tL$set$10\n-LASFDE3:\n-\t.long\tLASFDE3-EH_frame1\n-\t.long\t.LFB3-.\n-\t.set L$set$11,.LFE3-.LFB3\n-\t.long L$set$11\n-\t.byte\t0x0\n-\t.byte\t0x4\n-\t.set L$set$12,.LCFI4-.LFB3\n-\t.long L$set$12\n-\t.byte\t0xe\n-\t.byte\t0x8\n-\t.byte\t0x84\n-\t.byte\t0x2\n-\t.byte\t0x4\n-\t.set L$set$13,.LCFI5-.LCFI4\n-\t.long L$set$13\n-\t.byte\t0xd\n-\t.byte\t0x4\n-\t.byte\t0x4\n-\t.set L$set$14,.LCFI6-.LCFI5\n-\t.long L$set$14\n-\t.byte\t0x85\n-\t.byte\t0x3\n-\t.align 2\n-LEFDE3:\n-\n-#endif\n-\n-#endif /* ifndef __x86_64__ */"}, {"sha": "2f7394ef4bfaf82aa649075199ea75ab573866fe", "filename": "libffi/src/x86/darwin64.S", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin64.S?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "1daa1c0b6fd84ea47acd27a1d16047265ee980eb", "filename": "libffi/src/x86/darwin64_c.c", "status": "removed", "additions": 0, "deletions": 643, "changes": 643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin64_c.c?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "6338de2a0f227b261fc6bce737b509c21c4ebe22", "filename": "libffi/src/x86/darwin_c.c", "status": "removed", "additions": 0, "deletions": 843, "changes": 843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Fsrc%2Fx86%2Fdarwin_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fdarwin_c.c?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "24431c170ba539c7af5d7eff03a92614ca87286e", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 128, "deletions": 34, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "438b374e2fbbf89bc97deefe7a2085f2a06c6661", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 134, "deletions": 30, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "f454341a22d1ddab735aa07afcd82bf422195d4e", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "6870d07c92b787c26544ff5e69c8bd4febe3e71c", "filename": "libffi/src/x86/ffiw64.c", "status": "modified", "additions": 88, "deletions": 26, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffiw64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fffiw64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffiw64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "23be7a2232692df72833440227f7ffc2401e407a", "filename": "libffi/src/x86/internal.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Finternal.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "282b408027444e9abf3dda04257c17626ddb83b2", "filename": "libffi/src/x86/internal64.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Finternal64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Finternal64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Finternal64.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "7110f02f5f3ebb3bea92db8c2e26c4de40776945", "filename": "libffi/src/x86/sysv.S", "status": "modified", "additions": 201, "deletions": 14, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "3cafd71ce18fcd9a7b2fdd0719a8600572e8e3fb", "filename": "libffi/src/x86/sysv_intel.S", "status": "added", "additions": 995, "deletions": 0, "changes": 995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fsysv_intel.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fsysv_intel.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fsysv_intel.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "ca6fe0cb4cfabb26f19f56b9654af9ecd1a75cf4", "filename": "libffi/src/x86/unix64.S", "status": "modified", "additions": 177, "deletions": 27, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Funix64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Funix64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Funix64.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "f3ace8d07733f0f6dc9179a50a5acca640c632d1", "filename": "libffi/src/x86/win64.S", "status": "modified", "additions": 103, "deletions": 67, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fwin64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fwin64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin64.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "970a4f997a9811dbc2ebe23b718f26cc29aaefb4", "filename": "libffi/src/x86/win64_intel.S", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fwin64_intel.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fx86%2Fwin64_intel.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin64_intel.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "9a0575ff90d44ef74fee170e1bc4b3800b75eedf", "filename": "libffi/src/xtensa/ffi.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fxtensa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fxtensa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fxtensa%2Fffi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "e9421796fd868ea6898552114d714e8e37867392", "filename": "libffi/src/xtensa/sysv.S", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fxtensa%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Fsrc%2Fxtensa%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fxtensa%2Fsysv.S?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "1e4b35a34117defde95a90ae614032339f550910", "filename": "libffi/testsuite/Makefile.am", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.am?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "8b574dad5d73025c6129f0d1391aa5d541a78397", "filename": "libffi/testsuite/Makefile.in", "status": "removed", "additions": 0, "deletions": 572, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "4f4dd48d2c61b06629059ae1c77a2b3347b57f15", "filename": "libffi/testsuite/lib/libffi.exp", "status": "modified", "additions": 268, "deletions": 46, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi.exp?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "3322de94f7ab926b9b92b63b2f68202824f2ad7d", "filename": "libffi/testsuite/libffi.bhaible/Makefile", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2FMakefile?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "be8540b64fa97e03c261f50c8b4cdb1313f4fde8", "filename": "libffi/testsuite/libffi.bhaible/README", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2FREADME?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "00604a513ad37eb61fd577edbe4bac52b8909076", "filename": "libffi/testsuite/libffi.bhaible/alignof.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Falignof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Falignof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2Falignof.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "44aebc5e063798c0255d124587343ef57ae2b30c", "filename": "libffi/testsuite/libffi.bhaible/bhaible.exp", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Fbhaible.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Fbhaible.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2Fbhaible.exp?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "cf9219e26637848b032cdc85d7e6dbb63d2f3617", "filename": "libffi/testsuite/libffi.bhaible/test-call.c", "status": "added", "additions": 1745, "deletions": 0, "changes": 1745, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-call.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "0b16799d868d9c17411344863c3d9ca252facaba", "filename": "libffi/testsuite/libffi.bhaible/test-callback.c", "status": "added", "additions": 2885, "deletions": 0, "changes": 2885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-callback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-callback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftest-callback.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "23a6f466096f7c4a652b1e3905b376c8e8705e25", "filename": "libffi/testsuite/libffi.bhaible/testcases.c", "status": "added", "additions": 747, "deletions": 0, "changes": 747, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftestcases.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftestcases.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.bhaible%2Ftestcases.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "5d4959ce975bb34e3f318e910b2265343f99a634", "filename": "libffi/testsuite/libffi.call/align_mixed.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Falign_mixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Falign_mixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Falign_mixed.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "5e5cb860cce9ab7803dc63e1821fd6c8b3351d5e", "filename": "libffi/testsuite/libffi.call/align_stdcall.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Falign_stdcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Falign_stdcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Falign_stdcall.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "13ba2bdcd4922b2c454589833dd562792e796c73", "filename": "libffi/testsuite/libffi.call/call.exp", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcall.exp?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "6491c5b3df15ee1436995c4212e38f4d27953619", "filename": "libffi/testsuite/libffi.call/cls_uchar_va.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "37aa1064ea71d80f9bcc9740f00f139a16836d1a", "filename": "libffi/testsuite/libffi.call/cls_ushort_va.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "95d96a83f18c7dfa3cb6beea988e71e7f90b1514", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "57cd9e30f92866a25e49ae849aa5ef4255202218", "filename": "libffi/testsuite/libffi.call/float2.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "23d88b35d56514c88c60d9d92fa1cee55da09989", "filename": "libffi/testsuite/libffi.call/offsets.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Foffsets.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Foffsets.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Foffsets.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "17b1377424121af0c8fed36675941ddd24832110", "filename": "libffi/testsuite/libffi.call/struct10.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fstruct10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fstruct10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct10.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "ccc6faf5c932dfe8f018795c7d9478e0c0e60629", "filename": "libffi/testsuite/libffi.call/va_1.c", "status": "modified", "additions": 1, "deletions": 119, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "0589d08489ca812199ae76750b2988fdc9758d29", "filename": "libffi/testsuite/libffi.call/va_2.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fva_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.call%2Fva_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "ed4145ca843b4a293400afaed431c99ee4b5699b", "filename": "libffi/testsuite/libffi.closures/closure.exp", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure.exp?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "a579ff6c979f3f219cd5fab04c52678c67cf12f0", "filename": "libffi/testsuite/libffi.closures/closure_fn0.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn0.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn0.c"}, {"sha": "91231738c13b5240d2ee07b2d416b0738e9dac7a", "filename": "libffi/testsuite/libffi.closures/closure_fn1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn1.c"}, {"sha": "08ff9d92274c317162ec862934e7e226564ada56", "filename": "libffi/testsuite/libffi.closures/closure_fn2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn2.c"}, {"sha": "9b54d805c8296ad87dd89502dc158284e90a2927", "filename": "libffi/testsuite/libffi.closures/closure_fn3.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn3.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn3.c"}, {"sha": "d4a1530b065b21a0cf87a4515cd3ce216b6225db", "filename": "libffi/testsuite/libffi.closures/closure_fn4.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn4.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn4.c"}, {"sha": "99074426c67b5a65e383b48254ea0b8a8950fdda", "filename": "libffi/testsuite/libffi.closures/closure_fn5.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn5.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn5.c"}, {"sha": "73c54fd6b16016846b47c10b6d6d2f69da45f73a", "filename": "libffi/testsuite/libffi.closures/closure_fn6.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_fn6.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_fn6.c"}, {"sha": "ad488acaa877d8317ae30b8c180a18074255e579", "filename": "libffi/testsuite/libffi.closures/closure_loc_fn0.c", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_loc_fn0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_loc_fn0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_loc_fn0.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_loc_fn0.c"}, {"sha": "5a4e728d4a42a72ff4d5f1dfdabc35880c44cd9d", "filename": "libffi/testsuite/libffi.closures/closure_simple.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fclosure_simple.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/closure_simple.c"}, {"sha": "ea0825d175a6571e5706505010971bc1ea86bf6a", "filename": "libffi/testsuite/libffi.closures/cls_12byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_12byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_12byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_12byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_12byte.c"}, {"sha": "89a08a2d97bb1a45a41dede9fab9559ed20bab54", "filename": "libffi/testsuite/libffi.closures/cls_16byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_16byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_16byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_16byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_16byte.c"}, {"sha": "9f75da80aa05faa5aea74f237ac5c20e6fda0b09", "filename": "libffi/testsuite/libffi.closures/cls_18byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_18byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_18byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_18byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_18byte.c"}, {"sha": "278794b5b8773039a5b1d7a9c9ddcc378f98bc27", "filename": "libffi/testsuite/libffi.closures/cls_19byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_19byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_19byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_19byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_19byte.c"}, {"sha": "82492c020e2bc8452b6064d5e64a88cfca910609", "filename": "libffi/testsuite/libffi.closures/cls_1_1byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_1_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_1_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_1_1byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_1_1byte.c"}, {"sha": "34ea021fb885eddb15151e5c8b87a3e83f320188", "filename": "libffi/testsuite/libffi.closures/cls_20byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_20byte.c"}, {"sha": "eab4be6031d8a9f6a558a401d3901071ddc1a89c", "filename": "libffi/testsuite/libffi.closures/cls_20byte1.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_20byte1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_20byte1.c"}, {"sha": "78796da92dd92d8f7320cdee1e1914cecd3ce27a", "filename": "libffi/testsuite/libffi.closures/cls_24byte.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_24byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_24byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_24byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_24byte.c"}, {"sha": "81bb0a64a3ee50eeedfcb373b531f7e563a48913", "filename": "libffi/testsuite/libffi.closures/cls_2byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_2byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_2byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_2byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_2byte.c"}, {"sha": "b7827466f6ef43b17176c4abd0976f96d3491768", "filename": "libffi/testsuite/libffi.closures/cls_3_1byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3_1byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_3_1byte.c"}, {"sha": "a02c463af9f0f36cd81a768bb1c6d05cf3f22460", "filename": "libffi/testsuite/libffi.closures/cls_3byte1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_3byte1.c"}, {"sha": "c7251cead60308e21e2f889f92ba603bdee30fe8", "filename": "libffi/testsuite/libffi.closures/cls_3byte2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3byte2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_3byte2.c"}, {"sha": "48888f8405f95daa8b77732ad156173834082104", "filename": "libffi/testsuite/libffi.closures/cls_3float.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_3float.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "2d6d8b622c3734c3b68c2a89294c1f5020294fae", "filename": "libffi/testsuite/libffi.closures/cls_4_1byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4_1byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_4_1byte.c"}, {"sha": "4ac378776b5cd1ea6792b2ffdda31fb0549a0430", "filename": "libffi/testsuite/libffi.closures/cls_4byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_4byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_4byte.c"}, {"sha": "8db761cd5b79c1693390bad3a9d45d2ec8fffab3", "filename": "libffi/testsuite/libffi.closures/cls_5_1_byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5_1_byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_5_1_byte.c"}, {"sha": "fbb69ce4a83095092a1a37c8472239a7dcc0495e", "filename": "libffi/testsuite/libffi.closures/cls_5byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_5byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_5byte.c"}, {"sha": "a55edc2c7b9df3e70689730920fab6dc03400074", "filename": "libffi/testsuite/libffi.closures/cls_64byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_64byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_64byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_64byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_64byte.c"}, {"sha": "797098628663af9fa7ebc765c4d203d23e5fa534", "filename": "libffi/testsuite/libffi.closures/cls_6_1_byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6_1_byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_6_1_byte.c"}, {"sha": "e89c73cf88d13164fec105a18f9e6f2d3e4c6aa3", "filename": "libffi/testsuite/libffi.closures/cls_6byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_6byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_6byte.c"}, {"sha": "94b1a44bded9a6dfcede9148e6792f5e46bd1b47", "filename": "libffi/testsuite/libffi.closures/cls_7_1_byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7_1_byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_7_1_byte.c"}, {"sha": "3aa8d6cfe377ab2a6868716b94000c7d38b93313", "filename": "libffi/testsuite/libffi.closures/cls_7byte.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_7byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_7byte.c"}, {"sha": "f6c1ea570ac8638227b2e8541bc42f7f8ef71506", "filename": "libffi/testsuite/libffi.closures/cls_8byte.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_8byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_8byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_8byte.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_8byte.c"}, {"sha": "6eb45203688ae92c765ccb673db80e544876c72b", "filename": "libffi/testsuite/libffi.closures/cls_9byte1.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_9byte1.c"}, {"sha": "26e460bc7ecf81c59dd5253bd098cfbcb2622d12", "filename": "libffi/testsuite/libffi.closures/cls_9byte2.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_9byte2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_9byte2.c"}, {"sha": "910e2287d9e339344570e50ab1ffb03db1dd52e8", "filename": "libffi/testsuite/libffi.closures/cls_align_double.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_double.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_double.c"}, {"sha": "56161ef632e2446aa2605a79cecf64a641d9d32f", "filename": "libffi/testsuite/libffi.closures/cls_align_float.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_float.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_float.c"}, {"sha": "3dccdef10e15d814538b522df62de1bb9850924f", "filename": "libffi/testsuite/libffi.closures/cls_align_longdouble.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_longdouble.c"}, {"sha": "9b01cbd01a5873068743a213ad9ecb0f776f3dbd", "filename": "libffi/testsuite/libffi.closures/cls_align_longdouble_split.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split.c"}, {"sha": "8a973e7a22d15ac4482a30800a7189ffaf99450b", "filename": "libffi/testsuite/libffi.closures/cls_align_longdouble_split2.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_longdouble_split2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split2.c"}, {"sha": "ef59259dff0233e34426364769a2498ff2561b43", "filename": "libffi/testsuite/libffi.closures/cls_align_pointer.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_pointer.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_pointer.c"}, {"sha": "79977093d0e497acd583bfa39d31b1efdc0f1345", "filename": "libffi/testsuite/libffi.closures/cls_align_sint16.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint16.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_sint16.c"}, {"sha": "5edde72249fa27dbe3336478e24a0e1daa11e08a", "filename": "libffi/testsuite/libffi.closures/cls_align_sint32.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint32.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_sint32.c"}, {"sha": "bcba22f3ed66405dda680f79f97244990593bbf1", "filename": "libffi/testsuite/libffi.closures/cls_align_sint64.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_sint64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_sint64.c"}, {"sha": "f33c0ec6866046ae404a1f56c1f6b4a50dde0211", "filename": "libffi/testsuite/libffi.closures/cls_align_uint16.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint16.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_uint16.c"}, {"sha": "c96eee6bb29bf9fb955954bdec6e8d4d4278c90f", "filename": "libffi/testsuite/libffi.closures/cls_align_uint32.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint32.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_uint32.c"}, {"sha": "958e1c2cab035ebf1cbb3785497c53c73b9f1f28", "filename": "libffi/testsuite/libffi.closures/cls_align_uint64.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_align_uint64.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_align_uint64.c"}, {"sha": "25b8b635069e24a9e7db29bce9b8f35f4a60d915", "filename": "libffi/testsuite/libffi.closures/cls_dbls_struct.c", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_dbls_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_dbls_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_dbls_struct.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_dbls_struct.c"}, {"sha": "84ad4cb7d925b69d238bd129ee3601c36a6c547b", "filename": "libffi/testsuite/libffi.closures/cls_double.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_double.c"}, {"sha": "e077f92b8638398efdf87211f0ef5af26c8978cc", "filename": "libffi/testsuite/libffi.closures/cls_double_va.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_double_va.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_double_va.c"}, {"sha": "0090fed9063174d0e2e2412280e9841b4ecc86ae", "filename": "libffi/testsuite/libffi.closures/cls_float.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_float.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_float.c"}, {"sha": "d24e72e4aed3c48b73a1acc53e4220c523e3b682", "filename": "libffi/testsuite/libffi.closures/cls_longdouble.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_longdouble.c"}, {"sha": "39b438b289a85e4c8b24cde34c29ef42b895e5dd", "filename": "libffi/testsuite/libffi.closures/cls_longdouble_va.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_longdouble_va.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c"}, {"sha": "7fd6c8207ac756dd7c5583be805d5b8d6b358b15", "filename": "libffi/testsuite/libffi.closures/cls_many_mixed_args.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_args.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_many_mixed_args.c"}, {"sha": "62b0697ac01c9b7009744478dcc25f4ad03d939a", "filename": "libffi/testsuite/libffi.closures/cls_many_mixed_float_double.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_float_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_float_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_many_mixed_float_double.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_many_mixed_float_double.c"}, {"sha": "417f7be8299c8c981c9e6e335afd32fca599a80f", "filename": "libffi/testsuite/libffi.closures/cls_multi_schar.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_schar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_schar.c"}, {"sha": "467146dbd60c4e88f1d53e17cc92273d349b3bfb", "filename": "libffi/testsuite/libffi.closures/cls_multi_sshort.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshort.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_sshort.c"}, {"sha": "de45b593e32a4e084f7c02e9979888a837342cf6", "filename": "libffi/testsuite/libffi.closures/cls_multi_sshortchar.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_sshortchar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_sshortchar.c"}, {"sha": "eb93e95e3b3545196941103a7038be26fa6f0fa3", "filename": "libffi/testsuite/libffi.closures/cls_multi_uchar.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_uchar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_uchar.c"}, {"sha": "0e5838df103a31ca440bac2c16127172f3c9cda8", "filename": "libffi/testsuite/libffi.closures/cls_multi_ushort.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushort.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_ushort.c"}, {"sha": "69aedfe0d233531def5e876a8b19377a079881b6", "filename": "libffi/testsuite/libffi.closures/cls_multi_ushortchar.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushortchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushortchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_multi_ushortchar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_multi_ushortchar.c"}, {"sha": "d82a87a71b6168414fdcd35bdc973ad2b1c75561", "filename": "libffi/testsuite/libffi.closures/cls_pointer.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_pointer.c"}, {"sha": "1f1d9157b9d967ee82a49cc721230e6d0203cf3e", "filename": "libffi/testsuite/libffi.closures/cls_pointer_stack.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer_stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer_stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_pointer_stack.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_pointer_stack.c"}, {"sha": "82986b172c365d2d9bf9313568b056eb922ae821", "filename": "libffi/testsuite/libffi.closures/cls_schar.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_schar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_schar.c"}, {"sha": "c7e13b73a3bae7e9f6efed156bea48e28e6c1052", "filename": "libffi/testsuite/libffi.closures/cls_sint.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sint.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_sint.c"}, {"sha": "846d57ed1ba553794ae52c4cca7cf952647dfd2e", "filename": "libffi/testsuite/libffi.closures/cls_sshort.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_sshort.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_sshort.c"}, {"sha": "6d1fdaeb606ac90f09cdd1ec2408e67a846d0681", "filename": "libffi/testsuite/libffi.closures/cls_struct_va1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_struct_va1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_struct_va1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_struct_va1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_struct_va1.c"}, {"sha": "c1317e795fd65d1b9d5328c449a4b38ca41c2c64", "filename": "libffi/testsuite/libffi.closures/cls_uchar.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uchar.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_uchar.c"}, {"sha": "885cff5c3146831c3a2736ebf885afdea0c1f03d", "filename": "libffi/testsuite/libffi.closures/cls_uint.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_uint.c"}, {"sha": "b04cfd19c2ce42fbd08906fd8e72aa7eac928f90", "filename": "libffi/testsuite/libffi.closures/cls_uint_va.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_uint_va.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_uint_va.c"}, {"sha": "0315082e093ba0154e0429ec1b7c67575b619091", "filename": "libffi/testsuite/libffi.closures/cls_ulong_va.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulong_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulong_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulong_va.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_ulong_va.c"}, {"sha": "62f2cae63a9b48d9a2c46c148ed5864f23b5ea1c", "filename": "libffi/testsuite/libffi.closures/cls_ulonglong.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulonglong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulonglong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ulonglong.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_ulonglong.c"}, {"sha": "a00100e07f8c954f7a15a08ee5a873754d8558d5", "filename": "libffi/testsuite/libffi.closures/cls_ushort.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fcls_ushort.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/cls_ushort.c"}, {"sha": "f5a73179ec96a345cc3f9f6199c54cdcb33941c0", "filename": "libffi/testsuite/libffi.closures/err_bad_abi.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Ferr_bad_abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Ferr_bad_abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Ferr_bad_abi.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/err_bad_abi.c"}, {"sha": "95d96a83f18c7dfa3cb6beea988e71e7f90b1514", "filename": "libffi/testsuite/libffi.closures/ffitest.h", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fffitest.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "e8e1d8601fb050e937a711778773afa7092d0a54", "filename": "libffi/testsuite/libffi.closures/huge_struct.c", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fhuge_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fhuge_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fhuge_struct.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/huge_struct.c"}, {"sha": "10797a345f2ed1f91bdac82e3f857998226edaf6", "filename": "libffi/testsuite/libffi.closures/nested_struct.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct.c"}, {"sha": "df8ab5973d1a4b8f6322f6443b2c494f7a6ebde5", "filename": "libffi/testsuite/libffi.closures/nested_struct1.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct1.c"}, {"sha": "3cf2b44abe89e9790fd75cdc0af3469b50aa0faa", "filename": "libffi/testsuite/libffi.closures/nested_struct10.c", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct10.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct10.c"}, {"sha": "351049382c620224d544f49d3bc57564d2cc0310", "filename": "libffi/testsuite/libffi.closures/nested_struct11.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct11.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct11.c"}, {"sha": "0d307ae91f1e783abc2bd7837eda51e0c6c95334", "filename": "libffi/testsuite/libffi.closures/nested_struct12.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct12.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "6c139b9526882b7d3bd1a6fdb7055727eaa43996", "filename": "libffi/testsuite/libffi.closures/nested_struct13.c", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct13.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct12.c"}, {"sha": "d919e5c932db663d4d8285265417a14321014750", "filename": "libffi/testsuite/libffi.closures/nested_struct2.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct2.c"}, {"sha": "7d4c2cf801b41bca9368c45f2e362f3dd849840b", "filename": "libffi/testsuite/libffi.closures/nested_struct3.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct3.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct3.c"}, {"sha": "2ffb4d65a0635cafa530d0f2f35f597f12c50142", "filename": "libffi/testsuite/libffi.closures/nested_struct4.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct4.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct4.c"}, {"sha": "6c79845d984a68693c4a21087ebb99b9afd52e8d", "filename": "libffi/testsuite/libffi.closures/nested_struct5.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct5.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct5.c"}, {"sha": "59d35796f8def3db59580e42343f203d5c7de194", "filename": "libffi/testsuite/libffi.closures/nested_struct6.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct6.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct6.c"}, {"sha": "27595e6f5c301c151cf192d4da680f863aefca90", "filename": "libffi/testsuite/libffi.closures/nested_struct7.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct7.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct7.c"}, {"sha": "0e6c68281e1a0ff66d8afc5e93b9466dd7e6d93e", "filename": "libffi/testsuite/libffi.closures/nested_struct8.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct8.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct8.c"}, {"sha": "5f7ac67752caa154ed93eaeeff46b706795f8f95", "filename": "libffi/testsuite/libffi.closures/nested_struct9.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fnested_struct9.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/nested_struct9.c"}, {"sha": "6a91555a1fa8ddaf285b777774a9564358b19ee5", "filename": "libffi/testsuite/libffi.closures/problem1.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fproblem1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fproblem1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fproblem1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/problem1.c"}, {"sha": "00c4e174494d3316d61f83a3edbf49f7dfd2a2bf", "filename": "libffi/testsuite/libffi.closures/single_entry_structs1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs1.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "ab6556bf4ca0d834b56a3824ae2650892725a3f8", "filename": "libffi/testsuite/libffi.closures/single_entry_structs2.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "4f619cbf7c8263e11567b9802e83641e1e057adf", "filename": "libffi/testsuite/libffi.closures/single_entry_structs3.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fsingle_entry_structs3.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "71c2469e1c4dc6995fafe9e34533a356cc9bd6d3", "filename": "libffi/testsuite/libffi.closures/stret_large.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/stret_large.c"}, {"sha": "d9c750ee1c040928c86ab9f7193caaba57bbddd1", "filename": "libffi/testsuite/libffi.closures/stret_large2.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_large2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/stret_large2.c"}, {"sha": "56e3d9d8fc06dcc877d7f79919dd7727c78bef1f", "filename": "libffi/testsuite/libffi.closures/stret_medium.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/stret_medium.c"}, {"sha": "0746b6ee4b7425d120718bba9d12d1ad2bf0244b", "filename": "libffi/testsuite/libffi.closures/stret_medium2.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Fstret_medium2.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/stret_medium2.c"}, {"sha": "600368e0c9d08944d9c32157ddc2b52fd188d771", "filename": "libffi/testsuite/libffi.closures/testclosure.c", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Ftestclosure.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Ftestclosure.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Ftestclosure.c?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.call/testclosure.c"}, {"sha": "e1145657d14d59509706914cc7f23366a0e6202a", "filename": "libffi/testsuite/libffi.closures/unwindtest.cc", "status": "renamed", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest.cc?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.special/unwindtest.cc"}, {"sha": "153d24094080e00f75e92b10a575feea296ca9ca", "filename": "libffi/testsuite/libffi.closures/unwindtest_ffi_call.cc", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest_ffi_call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest_ffi_call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.closures%2Funwindtest_ffi_call.cc?ref=92456a4e5658e138e2cea79e390e3306b07685b0", "previous_filename": "libffi/testsuite/libffi.special/unwindtest_ffi_call.cc"}, {"sha": "3675b40a54c844358369bc8720818efe3843339f", "filename": "libffi/testsuite/libffi.go/static-chain.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92456a4e5658e138e2cea79e390e3306b07685b0/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.go%2Fstatic-chain.h?ref=92456a4e5658e138e2cea79e390e3306b07685b0"}, {"sha": "83f5442849e5f1b39932a89ed4216d7ea13fd898", "filename": "libffi/testsuite/libffi.special/ffitestcxx.h", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}, {"sha": "74671b1c646dcec7d0f71c68063f593663819239", "filename": "libffi/testsuite/libffi.special/special.exp", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d738405e7fe62cc8eb9580948a6ea39005cd7170/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Fspecial.exp?ref=d738405e7fe62cc8eb9580948a6ea39005cd7170"}]}