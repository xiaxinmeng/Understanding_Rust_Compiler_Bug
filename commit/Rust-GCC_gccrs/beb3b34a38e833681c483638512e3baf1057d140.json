{"sha": "beb3b34a38e833681c483638512e3baf1057d140", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmViM2IzNGEzOGU4MzM2ODFjNDgzNjM4NTEyZTNiYWYxMDU3ZDE0MA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T04:47:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T04:47:58Z"}, "message": "Initial revision\n\nFrom-SVN: r218", "tree": {"sha": "7c21ed200c71c4e767095ef00760d70be02e920b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c21ed200c71c4e767095ef00760d70be02e920b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beb3b34a38e833681c483638512e3baf1057d140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb3b34a38e833681c483638512e3baf1057d140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb3b34a38e833681c483638512e3baf1057d140", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb3b34a38e833681c483638512e3baf1057d140/comments", "author": null, "committer": null, "parents": [{"sha": "114cbee61c04db655b2a2987366a8326df89fbef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114cbee61c04db655b2a2987366a8326df89fbef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114cbee61c04db655b2a2987366a8326df89fbef"}], "stats": {"total": 603, "additions": 603, "deletions": 0}, "files": [{"sha": "91c4047801f9d66d5c443f6b0acc949fa05b1d2c", "filename": "gcc/config/m68k/crds.h", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beb3b34a38e833681c483638512e3baf1057d140/gcc%2Fconfig%2Fm68k%2Fcrds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beb3b34a38e833681c483638512e3baf1057d140/gcc%2Fconfig%2Fm68k%2Fcrds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcrds.h?ref=beb3b34a38e833681c483638512e3baf1057d140", "patch": "@@ -0,0 +1,603 @@\n+/* Definitions of target machine for GNU compiler.\n+   Charles River Data Systems UNiverse/32\n+\n+   Written by Gary E. Miller\n+   bug reports to Gary_Edmunds_Miller@cup.portal.com\n+\n+   Copyright (C) 1987 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n+#define SGS\t\t\t/* Uses SGS assembler */\n+#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n+#define CRDS\t\t\t/* Charles River Data Systems assembler */\n+\n+#include \"m68k.h\"\n+\n+/* Without STRUCTURE_SIZE_BOUNDARY, we can't ensure that structures are\n+   aligned such that we can correctly extract bitfields from them.\n+   Someone should check whether the usual compiler on the crds machine\n+   provides the equivalent behavior of STRUCTURE_SIZE_BOUNDARY.  */\n+#error This doesn't define STRUCTURE_SIZE_BOUNDARY\n+\n+/* See m68k.h.  0 means 680[01]0 with no 68881.  */\n+\n+#undef TARGET_DEFAULT\n+#define\tTARGET_DEFAULT 0\n+\n+/* special flags to the unos assembler.  */\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"-g\"\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!p:%{!pg:-lunos}}%{p:-lc_p}%{pg:-lc_p}\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC  \\\n+  \"%{pg:gcrt0.o%s}%{!pg:%{p:mc68rt0.o%s}%{!p:c68rt0.o%s}}\"\n+\n+/* CC1 spec */\n+#if 0\n+/* c.sac only used in _s_call_r() in libunos.a and malloc() in libmalloc.a */\n+/* so we do not need to bother ! */\n+#define CC1_SPEC \"-fpcc-struct-return\"\n+#endif\n+\n+/* -O2 for MAX optimization */\n+#undef CC1_SPEC\n+#define CC1_SPEC \"%{O2:-fstrength-reduce}\"\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Make output for SDB.  */\n+\n+/* #define SDB_DEBUGGING_INFO UNOS casm has no debugging :-( */\n+\n+/* UNOS has vprintf() */ \n+\n+#define HAVE_VPRINTF\n+\n+/* UNOS need stack probe :-( */\n+\n+#define HAVE_probe 1\n+#define gen_probe()  gen_rtx(ASM_INPUT, VOIDmode, \"tstb -2048(sp)\\t;probe\\n\")\n+\n+/* use memcpy, memset instead of bcopy, etc. */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Don't try to define `gcc_compiled.' since the assembler might not\n+   accept symbols with periods and GDB doesn't run on this machine anyway.  */\n+#define ASM_IDENTIFY_GCC(FILE)\n+\n+/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.  */\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dmc68k -DM68000 -Dmc68000 -Dunos -Dunix\"\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+/* unos uses \".comm c.sac\" returns &c.sac in d0 */\n+/* make pointer to c.sac ?\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE gen_rtx(MEM, Pmode, gen_rtx( , , ) )\n+*/\n+\n+#define EXTRA_SECTIONS in_bss\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+bss_section ()\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_bss)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \".bss\\n\");\t\t\t\t\t\\\n+      in_section = in_bss;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Specify how to pad function arguments.\n+   Value should be `upward', `downward' or `none'.\n+   Same as the default, except no padding for large or variable-size args.  */\n+\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n+    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n+       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n+    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n+   ? downward : none)\n+\n+/* Override part of the obstack macros.  */\n+\n+#define __PTR_TO_INT(P) ((int)(P))\n+#define __INT_TO_PTR(P) ((char *)(P))\n+\n+/* Override parts of m68k.h to fit the CRuDS assembler.  */\n+\n+#undef TARGET_VERSION \n+#define TARGET_VERSION fprintf (stderr, \" (68k, CRDS/UNOS)\");\n+\n+/* Specify extra dir to search for include files.  */\n+#define SYSTEM_INCLUDE_DIR \"/include\"\n+\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\\\n+  fprintf (FILE, \";#NO_APP\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \";#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#undef ASM_APP_OFF \n+#define ASM_APP_OFF \";#NO_APP\\n\"\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+do { union { double f; long l[2];} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.long 0x%x, 0x%x\\n\", tem.l[0], tem.l[1]);\t\\\n+   } while (0)\n+\n+/*unos has no .skip :-( */\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)\t \t\\\n+    fprintf (FILE, \"\\t. = . + %u\\n\", (SIZE));\t\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+/* should use bss_section instead of data_section but this makes casm die ? */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+{ data_section ();\t\t\t\t\\\n+  if ((SIZE) > 1) fprintf (FILE, \"\\t.even\\n\");\t\\\n+  assemble_name ((FILE), (NAME));\t\t\\\n+  fprintf ((FILE), \":\\t. = . + %u\\n\", (ROUNDED));}\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_PUSH\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovel %s,-(sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#undef ASM_OUTPUT_REG_POP\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovel (sp)+,%s\\n\", reg_names[REGNO])\n+\n+#undef  ASM_OUTPUT_ASCII\n+#define  ASM_OUTPUT_ASCII(FILE, P , SIZE)\t\t\t\t\\\n+{  int i;\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\t.ascii \\\"\");\t\t\t\t\\\n+\t  for (i = 0; i < (SIZE); i++)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      register int c = (P)[i];\t\t\t\t\t\\\n+\t      if (i != 0 && (i / 200) * 200 == i)\t\t\t\\\n+\t\tfprintf ((FILE), \"\\\"\\n\\t.ascii \\\"\");\t\t\t\\\n+\t      if (c >= ' ' && c < 0177) {\t\t\t\t\\\n+\t        if (c != '\\\"' && c != '\\\\') {\t\t\t\t\\\n+\t\t  putc (c, (FILE));\t\t\t\t\t\\\n+\t\t  continue;\t\t\t\t\t\t\\\n+\t        }\t\t\t\t\t\t\t\\\n+\t       }\t\t\t\t\t\t\t\\\n+\t       /* brain dead asm doesn't understand char escapes */  \\\n+\t       fprintf ((FILE), \"\\\"\\n\\t.byte\\t%d\\n\\t.ascii \\\"\", c);\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+ }\n+\n+\n+/* Change all JBxx to Bxx.  Also change all DBRA to DBF.\n+   Also change divs.l, etc., to divs, etc.  But don't change divsl.l.  */\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n+{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n+    { ++(PTR); }\t\t\t\t\t\\\n+  else if ((PTR)[0] == 'd')\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (!strncmp ((PTR), \"dbra\", 4))\t\t\t\\\n+\t{ fprintf ((FILE), \"dbf\"); (PTR) += 4; }\t\\\n+      else if (!strncmp ((PTR), \"div\", 3) && (PTR)[5] == ' ')  \\\n+\t{ fprintf ((FILE), \"div%c\", (PTR)[3]); (PTR) += 6; }   \\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   On the 68000, we use several CODE characters:\n+   '.' for dot needed in Motorola-style opcode names.\n+   '-' for an operand pushing on the stack:\n+       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n+   '+' for an operand pushing on the stack:\n+       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n+   '@' for a reference to the top word on the stack:\n+       sp@, (sp) or (%sp) depending on the style of syntax.\n+   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n+       but & in SGS syntax, $ in unos syntax).\n+   '!' for the cc register (used in an `and to cc' insn).\n+\n+   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n+   'd' to force memory addressing to be absolute, not relative.\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n+       than directly).  Second part of 'y' below.\n+   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n+       or print pair of registers as rx:ry.\n+   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n+       CONST_DOUBLE's as SunFPA constant RAM registers if\n+       possible, so it should not be used except for the SunFPA. */\n+\n+#undef PRINT_OPERAND_PUNCT_VALID_P\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n+   || (CODE) == '+' || (CODE) == '@' || (CODE) == '!')\n+\n+#undef PRINT_OPERAND\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ int i;\t\t\t\t\t\t\t\t\\\n+  if (CODE == '.') ;\t\t\t\t\t\t\t\\\n+  else if (CODE == '#') fprintf (FILE, \"$\");\t\t\t\t\\\n+  else if (CODE == '-') fprintf (FILE, \"-(sp)\");\t\t\t\\\n+  else if (CODE == '+') fprintf (FILE, \"(sp)+\");\t\t\t\\\n+  else if (CODE == '@') fprintf (FILE, \"(sp)\");\t\t\t\t\\\n+  else if (CODE == '!') fprintf (FILE, \"cc\");\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    { if (REGNO (X) < 16 && (CODE == 'y' || CODE == 'x') && GET_MODE (X) == DFmode)\t\\\n+        fprintf (FILE, \"%s:%s\", reg_names[REGNO (X)], reg_names[REGNO (X)+1]); \\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      output_address (XEXP (X, 0));\t\t\t\t\t\\\n+      if (CODE == 'd' && ! TARGET_68020\t\t\t\t\t\\\n+\t  && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n+\t/* fprintf (FILE, \".l\") */;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((CODE == 'y' || CODE == 'w')\t\t\t\t\t\\\n+\t   && GET_CODE(X) == CONST_DOUBLE\t\t\t\t\\\n+\t   && (i = standard_sun_fpa_constant_p (X)))\t\t\t\\\n+    fprintf (FILE, \"%%%d\", i & 0x1ff);\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+\tASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"$0x%x\", u1.i); }\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      ASM_OUTPUT_DOUBLE_OPERAND (FILE, u.d); }\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\f\n+/* Note that this contains a kludge that knows that the only reason\n+   we have an address (plus (label_ref...) (reg...))\n+   is in the insn before a tablejump, and we know that m68k.md\n+   generates a label LInnn: on such an insn.  */\n+#undef PRINT_OPERAND_ADDRESS\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset;\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PRE_DEC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case POST_INC:\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n+\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n+\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n+      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n+      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n+\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n+\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { int scale = 1;\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n+\t    fprintf (FILE, \"L%d-LI%d-2(pc,%s.w\",\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"L%d-LI%d-2(pc,%s.l\",\t\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n+\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \":%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n+        { fprintf (FILE, \"L%d-LI%d-2(pc,%s.l\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n+\t{ int scale = 1;\t\t\t\t\t\t\\\n+\t  if (breg == 0)\t\t\t\t\t\t\\\n+\t    abort ();\t\t\t\t\t\t\t\\\n+\t  if (addr && GET_CODE (addr) == LABEL_REF) abort ();\t\t\\\n+\t  if (addr != 0)\t\t\t\t\t\t\\\n+\t    output_addr_const (FILE, addr);\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n+\t  if (breg != 0 && ireg != 0)\t\t\t\t\t\\\n+\t    putc (',', FILE);\t\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n+\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n+\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n+\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n+\t  else if (ireg != 0)\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n+\t  if (scale != 1) fprintf (FILE, \":%d\", scale);\t\t\t\\\n+\t  putc (')', FILE);\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n+\t{ fprintf (FILE, \"L%d-LI%d-2(pc,%s.l)\",\t\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n+\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n+\t  break; }\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n+\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n+\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n+\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        output_addr_const (FILE, addr);\t\t\t\t\t\\\n+    }}\n+\f\n+#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n+  fprintf (FILE, \"\\t; file\\t\\\"%s\\\"\\n\", FILENAME)\n+\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n+  fprintf (FILE, \"\\t; ln\\t%d\\n\",\t\t\t\\\n+\t   (sdb_begin_function_line\t\t\\\n+\t    ? last_linenum - sdb_begin_function_line : 1))\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+/* Note that the order of the bit mask for fmovem is the opposite\n+   of the order for movem!  */\n+\n+#undef FUNCTION_PROLOGUE\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask = 0;\t\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  /* unos stack probe */\t\t\t\t\t\\\n+  if ( fsize > 30000 ) {\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmovel sp,a0\\n\");\t\t\t\t\\\n+    fprintf (FILE, \"\\taddl $-%d,a0\\n\", 2048 + fsize);\t\t\\\n+    fprintf (FILE, \"\\ttstb (a0)\\n\");\t\t\t\t\\\n+  } else {\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\ttstb -%d(sp)\\n\", 2048 + fsize);\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    { if (TARGET_68020 || fsize < 0x8000)\t\t\t\\\n+        fprintf (FILE, \"\\tlink a6,$%d\\n\", -fsize);\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tlink a6,$0\\n\\tsubl $%d,sp\\n\", fsize); }  \\\n+  for (regno = 24; regno < 56; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      fprintf(FILE, \"\\tfpmoved %s, sp@-\\n\",\t\t\t\\\n+\t      reg_names[regno]);\t\t\t\t\\\n+  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (regno - 16);\t\t\t\t\\\n+  if ((mask & 0xff) != 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tfmovem $0x%x,-(sp)\\n\", mask & 0xff);       \\\n+  mask = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+       mask |= 1 << (15 - regno);\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    mask &= ~ (1 << (15-FRAME_POINTER_REGNUM));\t\t\t\\\n+  if (exact_log2 (mask) >= 0)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tmovel %s,-(sp)\\n\", reg_names[15 - exact_log2 (mask)]);  \\\n+  else if (mask) fprintf (FILE, \"\\tmovem $0x%x,-(sp)\\n\", mask); }\n+\n+/* Must put address in  %a0 , not  %d0 . -- LGM, 7/15/88 */\n+/* UNOS ?? */\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n+    fprintf (FILE, \"\\tmovl &LP%%%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO))\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#undef FUNCTION_EPILOGUE\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno;\t\t\t\t\t\t\\\n+  register int mask, fmask;\t\t\t\t\t\\\n+  register int nregs;\t\t\t\t\t\t\\\n+  int offset, foffset, fpoffset;\t\t\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n+  int big = 0;\t\t\t\t\t\t\t\\\n+  nregs = 0;  fmask = 0; fpoffset = 0;\t\t\t\t\\\n+  for (regno = 24 ; regno < 56 ; regno++)\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      nregs++;\t\t\t\t\t\t\t\\\n+  fpoffset = nregs*8;\t\t\t\t\t\t\\\n+  nregs = 0;\t\t\t\t\t\t\t\\\n+  for (regno = 16; regno < 24; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; fmask |= 1 << (23 - regno); }\t\t\t\\\n+  foffset = fpoffset + nregs * 12;\t\t\t\t\\\n+  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n+  offset = foffset + nregs * 4;\t\t\t\t\t\\\n+  if (offset + fsize >= 0x8000 \t\t\t\t\t\\\n+      && frame_pointer_needed \t\t\t\t\t\\\n+      && (mask || fmask || fpoffset)) \t\t\t\t\\\n+    { fprintf (FILE, \"\\tmovel $%d,a0\\n\", -fsize);\t\t\\\n+      fsize = 0, big = 1; }\t\t\t\t\t\\\n+  if (exact_log2 (mask) >= 0) {\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovel -%d(a6,a0.l),%s\\n\",\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]);\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovel (sp)+,%s\\n\",\t\t\t\\\n+\t       reg_names[exact_log2 (mask)]);\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovel -%d(a6),%s\\n\",\t\t\t\\\n+\t       offset + fsize, reg_names[exact_log2 (mask)]); }\t\\\n+  else if (mask) {\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem -%d(a6,a0.l),$0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem (sp)+,$0x%x\\n\", mask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovem -%d(a6),$0x%x\\n\",\t\t\\\n+\t       offset + fsize, mask); }\t\t\t\t\\\n+  if (fmask) {\t\t\t\t\t\t\t\\\n+    if (big)\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(a6,a0.l),$0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask);\t\t\t\t\\\n+    else if (! frame_pointer_needed)\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem (sp)+,$0x%x\\n\", fmask);\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tfmovem -%d(a6),$0x%x\\n\",\t\t\\\n+\t       foffset + fsize, fmask); }\t\t\t\\\n+  if (fpoffset != 0)\t\t\t\t\t\t\\\n+    for (regno = 55; regno >= 24; regno--)\t\t\t\\\n+      if (regs_ever_live[regno] && ! call_used_regs[regno]) {\t\\\n+\tif (big)\t\t\t\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved -%d(a6,a0.l), %s\\n\",\t\\\n+\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n+\telse if (! frame_pointer_needed)\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved (sp)+, %s\\n\",\t\t\t\\\n+\t\t  reg_names[regno]);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  fprintf(FILE, \"\\tfpmoved -%d(a6), %s\\n\",\t\t\\\n+\t\t  fpoffset + fsize, reg_names[regno]);\t\t\\\n+\tfpoffset -= 8;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tunlk a6\\n\");\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\trtd $%d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\trts\\n\"); }\n+"}]}