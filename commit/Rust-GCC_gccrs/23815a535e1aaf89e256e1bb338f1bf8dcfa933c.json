{"sha": "23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "node_id": "C_kwDOANBUbNoAKDIzODE1YTUzNWUxYWFmODllMjU2ZTFiYjMzOGYxYmY4ZGNmYTkzM2M", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-24T07:49:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-24T07:49:54Z"}, "message": "Merge #1327 #1329 #1330\n\n1327: Lower const generics structures r=CohenArthur a=CohenArthur\n\nThis PR adds lowering for both the `ConstGenericParam` type and the `ConstGenericArg` one. Ideally, we should be able to avoid ambiguites (`let a: Foo<N>;` -> what is N? A type? A const?) by going through the name resolver, and resolve either to a different `AST::ConstGenericArg` either to a correct `AST::Type` or equivalent. So I think we can avoid doing the same \"Ambiguous/Clear\" dance in the `HIR::ConstGenericArg` type.\r\n\r\nIf that ends up not being possible, we can always add it and disambiguate during typechecking or other.\r\n\r\nCloses #1318\n\n1329: gccrs const folding port: start porting potential_constant_expression\u2026 r=CohenArthur a=abbasfaisal\n\nCard: [Link](https://github.com/Rust-GCC/gccrs/projects/16#card-82300805).\r\n\r\nSince [this](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L8350) is a huge function, we will start by porting chunks on which it depends as that would reduce the chance of missing something important and be easier to review.\r\n\r\nThis changeset ports over the below typedefs, structs and functions in addition to the macros:\r\n\r\nTypedefs:\r\n - [tsubst_flags_t](https://github.com/Rust-GCC/gccrs/blob/7eef766dc5a8abda2ca2cf8d535cdf160f40b50c/gcc/cp/cp-tree.h#L5533)\r\n\r\nStructs:\r\n - [lang_type](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L2300)\r\n - [tree_pair_s](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L2281)\r\n\r\nFunctions:\r\n - [cp_expr_loc_or_loc](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L8073)\r\n - [cp_expr_loc_or_input_loc](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L8082)\r\n - [cp_expr_location](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L6056)\r\n - [is_really_empty_class](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/class.cc#L8867)\r\n - [is_empty_class](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/class.cc#L8850)\r\n - [array_type_nelts_top](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L3055)\r\n\r\nI feel we do not need [is_really_empty_class](https://github.com/abbasfaisal/gccrs/blob/port-potential-const-expression-1-part-by-part/gcc/rust/backend/rust-tree.cc#L786) and [is_empty_class](https://github.com/abbasfaisal/gccrs/blob/port-potential-const-expression-1-part-by-part/gcc/rust/backend/rust-tree.cc#L827) as they are concerned with classes, record types and unions. The tree codes they surround come from [tree.def](https://github.com/Rust-GCC/gccrs/blob/master/gcc/tree.def). I think the class and record tree codes are not relevant to Rust. Feel free to say so and I will remove these functions or if you would like me to dig more into them.\r\n\r\n\n\n1330: Add location to HIR::Type base class and improve privacy error reporting r=CohenArthur a=graphman65\n\nFix #1256\r\n\r\nAdds location to the HIR::Type base class, removes it from all the subclasses and then use it  in the `check_type_privacy` method to improve privacy error reporting.\r\n\r\nThe privacy error now looks like this (instead of what you can see in the example #1256).\r\n\r\n```rust\r\ngcc/testsuite/rust/compile/privacy5.rs:15:20: error: definition is private in this context\r\n   15 |         fn any(a0: green::Foo, a1: green::Bar) {}\r\n      |                    ^\r\n```\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Faisal Abbas <90.abbasfaisal@gmail.com>\nCo-authored-by: Sebastien Lacoste <dev@graphman.fr>", "tree": {"sha": "29bd03a759ef63482d6770ccc02f18548949e820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29bd03a759ef63482d6770ccc02f18548949e820"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitWyiCRBK7hj4Ov3rIwAApogIALKoWmGL6ZSmtr4ZMHbpagp9\n9avfnVmkc+Mhj/oFonSXCYfxp+MDsl9eQ8mU7nOUF5GBWwGCIKJjOyL3GFckMZqw\ny2Bgc/Y0qbphE9feROXjvImVpJId9lkEGon/tfX5DCoHRzPDzR5OCesx+9A0qOo3\nWnfVCouwmuNJ4Z5Sl5VKVpc+piCMAIQWfphNHf6APcFmqgK7BkZAwYHj5F1zAQJ6\nLX5z30zCDIdeo9F/UTQM2XIvQ7xucqz0D4SwFq6jTU5JAdpxSEMFdfZpQZIS3UXB\ncVfmfuPqyHO3VP/wZtSFyKxnDcqpoM0A3k/vdBOt7+glGUJubTwMBVBbZcck/jg=\n=hX5w\n-----END PGP SIGNATURE-----\n", "payload": "tree 29bd03a759ef63482d6770ccc02f18548949e820\nparent e6b7d184d01f032efe5c41d5503945081c7a0aea\nparent 6e5468e256dd06eb6988a0eca37c86bc52722457\nparent 67470f5d6697337808fd23061cc765173ed0825d\nparent 5d7841fa235cd53a807dae813d20f474362fb5c1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1656056994 +0000\ncommitter GitHub <noreply@github.com> 1656056994 +0000\n\nMerge #1327 #1329 #1330\n\n1327: Lower const generics structures r=CohenArthur a=CohenArthur\n\nThis PR adds lowering for both the `ConstGenericParam` type and the `ConstGenericArg` one. Ideally, we should be able to avoid ambiguites (`let a: Foo<N>;` -> what is N? A type? A const?) by going through the name resolver, and resolve either to a different `AST::ConstGenericArg` either to a correct `AST::Type` or equivalent. So I think we can avoid doing the same \"Ambiguous/Clear\" dance in the `HIR::ConstGenericArg` type.\r\n\r\nIf that ends up not being possible, we can always add it and disambiguate during typechecking or other.\r\n\r\nCloses #1318\n\n1329: gccrs const folding port: start porting potential_constant_expression\u2026 r=CohenArthur a=abbasfaisal\n\nCard: [Link](https://github.com/Rust-GCC/gccrs/projects/16#card-82300805).\r\n\r\nSince [this](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L8350) is a huge function, we will start by porting chunks on which it depends as that would reduce the chance of missing something important and be easier to review.\r\n\r\nThis changeset ports over the below typedefs, structs and functions in addition to the macros:\r\n\r\nTypedefs:\r\n - [tsubst_flags_t](https://github.com/Rust-GCC/gccrs/blob/7eef766dc5a8abda2ca2cf8d535cdf160f40b50c/gcc/cp/cp-tree.h#L5533)\r\n\r\nStructs:\r\n - [lang_type](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L2300)\r\n - [tree_pair_s](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L2281)\r\n\r\nFunctions:\r\n - [cp_expr_loc_or_loc](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L8073)\r\n - [cp_expr_loc_or_input_loc](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/cp-tree.h#L8082)\r\n - [cp_expr_location](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L6056)\r\n - [is_really_empty_class](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/class.cc#L8867)\r\n - [is_empty_class](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/class.cc#L8850)\r\n - [array_type_nelts_top](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L3055)\r\n\r\nI feel we do not need [is_really_empty_class](https://github.com/abbasfaisal/gccrs/blob/port-potential-const-expression-1-part-by-part/gcc/rust/backend/rust-tree.cc#L786) and [is_empty_class](https://github.com/abbasfaisal/gccrs/blob/port-potential-const-expression-1-part-by-part/gcc/rust/backend/rust-tree.cc#L827) as they are concerned with classes, record types and unions. The tree codes they surround come from [tree.def](https://github.com/Rust-GCC/gccrs/blob/master/gcc/tree.def). I think the class and record tree codes are not relevant to Rust. Feel free to say so and I will remove these functions or if you would like me to dig more into them.\r\n\r\n\n\n1330: Add location to HIR::Type base class and improve privacy error reporting r=CohenArthur a=graphman65\n\nFix #1256\r\n\r\nAdds location to the HIR::Type base class, removes it from all the subclasses and then use it  in the `check_type_privacy` method to improve privacy error reporting.\r\n\r\nThe privacy error now looks like this (instead of what you can see in the example #1256).\r\n\r\n```rust\r\ngcc/testsuite/rust/compile/privacy5.rs:15:20: error: definition is private in this context\r\n   15 |         fn any(a0: green::Foo, a1: green::Bar) {}\r\n      |                    ^\r\n```\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\nCo-authored-by: Faisal Abbas <90.abbasfaisal@gmail.com>\nCo-authored-by: Sebastien Lacoste <dev@graphman.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6b7d184d01f032efe5c41d5503945081c7a0aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6b7d184d01f032efe5c41d5503945081c7a0aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6b7d184d01f032efe5c41d5503945081c7a0aea"}, {"sha": "6e5468e256dd06eb6988a0eca37c86bc52722457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e5468e256dd06eb6988a0eca37c86bc52722457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e5468e256dd06eb6988a0eca37c86bc52722457"}, {"sha": "67470f5d6697337808fd23061cc765173ed0825d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67470f5d6697337808fd23061cc765173ed0825d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67470f5d6697337808fd23061cc765173ed0825d"}, {"sha": "5d7841fa235cd53a807dae813d20f474362fb5c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7841fa235cd53a807dae813d20f474362fb5c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7841fa235cd53a807dae813d20f474362fb5c1"}], "stats": {"total": 741, "additions": 560, "deletions": 181}, "files": [{"sha": "76324dc73040157effd7efd3033b2fcf4e882056", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -1381,6 +1381,9 @@ class ConstGenericParam : public GenericParam\n   }\n \n   bool has_type () { return type != nullptr; }\n+  bool has_default_value () { return default_value != nullptr; }\n+\n+  const Identifier &get_name () const { return name; }\n \n   std::unique_ptr<AST::Type> &get_type ()\n   {"}, {"sha": "6e2b020171e91c1c20b0f2ae968fc283af3cb9a7", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -191,6 +191,8 @@ class ConstGenericArg\n \n   Kind get_kind () const { return kind; }\n \n+  std::unique_ptr<AST::Expr> &get_expression () { return expression; }\n+\n   std::string as_string () const\n   {\n     switch (get_kind ())"}, {"sha": "a71b584618c9b3e427391eaa38821bd39f79ea76", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -760,4 +760,92 @@ rs_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func, void *data,\n #undef WALK_SUBTREE\n }\n \n+// forked from gcc/cp/tree.cc cp_expr_location\n+\n+/* Like EXPR_LOCATION, but also handle some tcc_exceptional that have\n+   locations.  */\n+\n+location_t\n+cp_expr_location (const_tree t_)\n+{\n+  tree t = CONST_CAST_TREE (t_);\n+  if (t == NULL_TREE)\n+    return UNKNOWN_LOCATION;\n+\n+  return EXPR_LOCATION (t);\n+}\n+\n+// forked from gcc/cp/class.cc\n+\n+/* Returns true if TYPE contains no actual data, just various\n+   possible combinations of empty classes.  If IGNORE_VPTR is true,\n+   a vptr doesn't prevent the class from being considered empty.  Typically\n+   we want to ignore the vptr on assignment, and not on initialization.  */\n+\n+bool\n+is_really_empty_class (tree type, bool ignore_vptr)\n+{\n+  if (CLASS_TYPE_P (type))\n+    {\n+      tree field;\n+      tree binfo;\n+      tree base_binfo;\n+      int i;\n+\n+      /* CLASSTYPE_EMPTY_P isn't set properly until the class is actually laid\n+\t out, but we'd like to be able to check this before then.  */\n+      if (COMPLETE_TYPE_P (type) && is_empty_class (type))\n+\treturn true;\n+\n+      if (!ignore_vptr && TYPE_CONTAINS_VPTR_P (type))\n+\treturn false;\n+\n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n+\tif (!is_really_empty_class (BINFO_TYPE (base_binfo), ignore_vptr))\n+\t  return false;\n+      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (field)\n+\t    /* An unnamed bit-field is not a data member.  */\n+\t    && !DECL_UNNAMED_BIT_FIELD (field)\n+\t    && !is_really_empty_class (TREE_TYPE (field), ignore_vptr))\n+\t  return false;\n+      return true;\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    return (integer_zerop (array_type_nelts_top (type))\n+\t    || is_really_empty_class (TREE_TYPE (type), ignore_vptr));\n+  return false;\n+}\n+\n+// forked from gcc/cp/class.cc is_empty_class\n+\n+/* Returns 1 if TYPE contains only padding bytes.  */\n+\n+int\n+is_empty_class (tree type)\n+{\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (!CLASS_TYPE_P (type))\n+    return 0;\n+\n+  return CLASSTYPE_EMPTY_P (type);\n+}\n+\n+// forked from gcc/cp/tree.cc array_type_nelts_top\n+\n+/* Return, as an INTEGER_CST node, the number of elements for TYPE\n+   (which is an ARRAY_TYPE).  This counts only elements of the top\n+   array.  */\n+\n+tree\n+array_type_nelts_top (tree type)\n+{\n+  return fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n+\t\t\t  array_type_nelts (type), size_one_node);\n+}\n+\n } // namespace Rust"}, {"sha": "b5640907e353961d5300b7023ab95a9aa8cc6206", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -111,8 +111,186 @@\n    has been duly initialized in its constructor.  */\n #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))\n \n+/* Nonzero if T is a class type.  Zero for template type parameters,\n+   typename types, and so forth.  */\n+#define CLASS_TYPE_P(T)                                                        \\\n+  (RECORD_OR_UNION_CODE_P (TREE_CODE (T)) && TYPE_LANG_FLAG_5 (T))\n+\n+/* [class.virtual]\n+\n+   A class that declares or inherits a virtual function is called a\n+   polymorphic class.  */\n+#define TYPE_POLYMORPHIC_P(NODE) (TREE_LANG_FLAG_2 (NODE))\n+\n+/* Nonzero if this class has a virtual function table pointer.  */\n+#define TYPE_CONTAINS_VPTR_P(NODE)                                             \\\n+  (TYPE_POLYMORPHIC_P (NODE) || CLASSTYPE_VBASECLASSES (NODE))\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* A vector of BINFOs for the direct and indirect virtual base classes\n+   that this type uses in a post-order depth-first left-to-right\n+   order.  (In other words, these bases appear in the order that they\n+   should be initialized.)  */\n+#define CLASSTYPE_VBASECLASSES(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->vbases)\n+\n+/* We used to have a variant type for lang_type.  Keep the name of the\n+   checking accessor for the sole survivor.  */\n+#define LANG_TYPE_CLASS_CHECK(NODE) (TYPE_LANG_SPECIFIC (NODE))\n+\n+/* Keep these checks in ascending code order.  */\n+#define RECORD_OR_UNION_CODE_P(T) ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n+#define OVERLOAD_TYPE_P(T) (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n+\n+/* Nonzero if this class is \"empty\" in the sense of the C++ ABI.  */\n+#define CLASSTYPE_EMPTY_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->empty_p)\n+\n+// Below macros are copied from gcc/c-family/c-common.h\n+\n+/* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n+#define DECL_C_BIT_FIELD(NODE) (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n+#define SET_DECL_C_BIT_FIELD(NODE)                                             \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n+#define CLEAR_DECL_C_BIT_FIELD(NODE)                                           \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n+\n+/* True if the decl was an unnamed bitfield.  */\n+#define DECL_UNNAMED_BIT_FIELD(NODE)                                           \\\n+  (DECL_C_BIT_FIELD (NODE) && !DECL_NAME (NODE))\n+\n+// Above macros are copied from gcc/c-family/c-common.h\n+\n+// forked from gcc/cp/cp-tree.h treee_pair_s\n+\n+struct GTY (()) tree_pair_s\n+{\n+  tree purpose;\n+  tree value;\n+};\n+\n+// forked from gcc/cp/cp-tree.h tree_pair_p\n+\n+typedef tree_pair_s *tree_pair_p;\n+\n+// forked from gcc/cp/cp-tree.h lang_type\n+\n+/* This structure provides additional information above and beyond\n+   what is provide in the ordinary tree_type.  In the past, we used it\n+   for the types of class types, template parameters types, typename\n+   types, and so forth.  However, there can be many (tens to hundreds\n+   of thousands) of template parameter types in a compilation, and\n+   there's no need for this additional information in that case.\n+   Therefore, we now use this data structure only for class types.\n+\n+   In the past, it was thought that there would be relatively few\n+   class types.  However, in the presence of heavy use of templates,\n+   many (i.e., thousands) of classes can easily be generated.\n+   Therefore, we should endeavor to keep the size of this structure to\n+   a minimum.  */\n+struct GTY (()) lang_type\n+{\n+  unsigned char align;\n+\n+  unsigned has_type_conversion : 1;\n+  unsigned has_copy_ctor : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_copy_assign : 1;\n+  unsigned use_template : 2;\n+\n+  unsigned has_mutable : 1;\n+  unsigned com_interface : 1;\n+  unsigned non_pod_class : 1;\n+  unsigned nearly_empty_p : 1;\n+  unsigned user_align : 1;\n+  unsigned has_copy_assign : 1;\n+  unsigned has_new : 1;\n+  unsigned has_array_new : 1;\n+\n+  unsigned gets_delete : 2;\n+  unsigned interface_only : 1;\n+  unsigned interface_unknown : 1;\n+  unsigned contains_empty_class_p : 1;\n+  unsigned anon_aggr : 1;\n+  unsigned non_zero_init : 1;\n+  unsigned empty_p : 1;\n+  /* 32 bits allocated.  */\n+\n+  unsigned vec_new_uses_cookie : 1;\n+  unsigned declared_class : 1;\n+  unsigned diamond_shaped : 1;\n+  unsigned repeated_base : 1;\n+  unsigned being_defined : 1;\n+  unsigned debug_requested : 1;\n+  unsigned fields_readonly : 1;\n+  unsigned ptrmemfunc_flag : 1;\n+\n+  unsigned lazy_default_ctor : 1;\n+  unsigned lazy_copy_ctor : 1;\n+  unsigned lazy_copy_assign : 1;\n+  unsigned lazy_destructor : 1;\n+  unsigned has_const_copy_ctor : 1;\n+  unsigned has_complex_copy_ctor : 1;\n+  unsigned has_complex_copy_assign : 1;\n+  unsigned non_aggregate : 1;\n+\n+  unsigned has_complex_dflt : 1;\n+  unsigned has_list_ctor : 1;\n+  unsigned non_std_layout : 1;\n+  unsigned is_literal : 1;\n+  unsigned lazy_move_ctor : 1;\n+  unsigned lazy_move_assign : 1;\n+  unsigned has_complex_move_ctor : 1;\n+  unsigned has_complex_move_assign : 1;\n+\n+  unsigned has_constexpr_ctor : 1;\n+  unsigned unique_obj_representations : 1;\n+  unsigned unique_obj_representations_set : 1;\n+  bool erroneous : 1;\n+  bool non_pod_aggregate : 1;\n+\n+  /* When adding a flag here, consider whether or not it ought to\n+     apply to a template instance if it applies to the template.  If\n+     so, make sure to copy it in instantiate_class_template!  */\n+\n+  /* There are some bits left to fill out a 32-bit word.  Keep track\n+     of this by updating the size of this bitfield whenever you add or\n+     remove a flag.  */\n+  unsigned dummy : 3;\n+\n+  tree primary_base;\n+  vec<tree_pair_s, va_gc> *vcall_indices;\n+  tree vtables;\n+  tree typeinfo_var;\n+  vec<tree, va_gc> *vbases;\n+  tree as_base;\n+  vec<tree, va_gc> *pure_virtuals;\n+  tree friend_classes;\n+  vec<tree, va_gc> *GTY ((reorder (\"resort_type_member_vec\"))) members;\n+  tree key_method;\n+  tree decl_list;\n+  tree befriending_classes;\n+  /* In a RECORD_TYPE, information specific to Objective-C++, such\n+     as a list of adopted protocols or a pointer to a corresponding\n+     @interface.  See objc/objc-act.h for details.  */\n+  tree objc_info;\n+  /* FIXME reuse another field?  */\n+  tree lambda_expr;\n+};\n+\n namespace Rust {\n \n+// forked from gcc/cp/cp-tree.h tsubst_flags_t\n+\n+/* This type is used for parameters and variables which hold\n+   combinations of the flags in enum tsubst_flags.  */\n+typedef int tsubst_flags_t;\n+\n // forked from gcc/cp/cvt.cc convert_to_void\n //\n // When an expression is used in a void context, its value is discarded and\n@@ -220,13 +398,46 @@ get_fndecl_from_callee (tree fn);\n extern tree\n pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n \n+/* A tree node, together with a location, so that we can track locations\n+   (and ranges) during parsing.\n+\n+   The location is redundant for node kinds that have locations,\n+   but not all node kinds do (e.g. constants, and references to\n+   params, locals, etc), so we stash a copy here.  */\n+\n+extern location_t cp_expr_location (const_tree);\n+\n+extern int\n+is_empty_class (tree type);\n+\n+extern tree array_type_nelts_top (tree);\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\\n   walk_tree_1 (tp, func, data, pset, rs_walk_subtrees)\n #define rs_walk_tree_without_duplicates(tp, func, data)                        \\\n   walk_tree_without_duplicates_1 (tp, func, data, rs_walk_subtrees)\n \n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_loc\n+\n+inline location_t\n+cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n+{\n+  location_t loc = cp_expr_location (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+// forked from gcc/cp/cp-tree.h cp_expr_loc_or_input_loc\n+\n+inline location_t\n+cp_expr_loc_or_input_loc (const_tree t)\n+{\n+  return cp_expr_loc_or_loc (t, input_location);\n+}\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}, {"sha": "7e80f81109214b8fede7bc9875ac37611a6e4044", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -612,8 +612,19 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n       type_args.push_back (std::unique_ptr<HIR::Type> (t));\n     }\n \n+  std::vector<HIR::ConstGenericArg> const_args;\n+  for (auto &const_arg : args.get_const_args ())\n+    const_args.emplace_back (HIR::ConstGenericArg (\n+      std::unique_ptr<HIR::Expr> (\n+\tASTLoweringExpr::translate (const_arg.get_expression ().get ())),\n+      Location ()));\n+\n+  // FIXME:\n+  // const_arg.get_locus ());\n+\n   return HIR::GenericArgs (std::move (lifetime_args), std::move (type_args),\n-\t\t\t   std::move (binding_args), args.get_locus ());\n+\t\t\t   std::move (binding_args), std::move (const_args),\n+\t\t\t   args.get_locus ());\n }\n \n HIR::SelfParam\n@@ -650,29 +661,17 @@ ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n   bool has_separating_scope_resolution\n     = segment.get_separating_scope_resolution ();\n \n-  std::vector<HIR::Lifetime> lifetime_args;\n-  for (auto &lifetime : segment.get_generic_args ().get_lifetime_args ())\n-    {\n-      HIR::Lifetime l = lower_lifetime (lifetime);\n-      lifetime_args.push_back (std::move (l));\n-    }\n-\n-  std::vector<std::unique_ptr<HIR::Type>> type_args;\n-  for (auto &type : segment.get_generic_args ().get_type_args ())\n-    {\n-      HIR::Type *t = ASTLoweringType::translate (type.get ());\n-      type_args.push_back (std::unique_ptr<HIR::Type> (t));\n-    }\n+  auto generic_args = lower_generic_args (segment.get_generic_args ());\n \n   auto crate_num = mappings->get_current_crate ();\n   auto hirid = mappings->get_next_hir_id (crate_num);\n   Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n \t\t\t\t UNKNOWN_LOCAL_DEFID);\n \n-  translated_segment = new HIR::TypePathSegmentGeneric (\n-    std::move (mapping), segment_name, has_separating_scope_resolution,\n-    std::move (lifetime_args), std::move (type_args), std::move (binding_args),\n-    segment.get_locus ());\n+  translated_segment\n+    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n+\t\t\t\t       has_separating_scope_resolution,\n+\t\t\t\t       generic_args, segment.get_locus ());\n }\n \n void"}, {"sha": "dc20be7cd112eb32bf9ba06ce462722cec83cec0", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -375,13 +375,17 @@ class ASTLowerGenericParam : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n \n-    // FIXME: This creates a BOGUS HIR::Lifetime instance because we do not have\n-    // an `HIR::ConstGenericParam` type yet. This needs to be removed, but for\n-    // now it avoids bogus ICEs\n-    HIR::Lifetime lt (mapping, AST::Lifetime::LifetimeType::WILDCARD, \"fixme\",\n-\t\t      param.get_locus ());\n-    translated = new HIR::LifetimeParam (mapping, lt, param.get_locus (),\n-\t\t\t\t\t std::vector<Lifetime> ());\n+    auto type = ASTLoweringType::translate (param.get_type ().get ());\n+    auto default_expr\n+      = param.has_default_value ()\n+\t  ? ASTLoweringExpr::translate (param.get_default_value ().get ())\n+\t  : nullptr;\n+\n+    translated\n+      = new HIR::ConstGenericParam (param.get_name (),\n+\t\t\t\t    std::unique_ptr<Type> (type),\n+\t\t\t\t    std::unique_ptr<Expr> (default_expr),\n+\t\t\t\t    mapping, param.get_locus ());\n   }\n \n   void visit (AST::TypeParam &param) override"}, {"sha": "8000e5c5894a0a0dcfc7804dd9dd51230a7b69b3", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -5285,5 +5285,20 @@ StaticItem::accept_vis (HIRVisItemVisitor &vis)\n   vis.visit (*this);\n }\n \n+std::string\n+ConstGenericParam::as_string () const\n+{\n+  auto result = \"ConstGenericParam: \" + name + \" : \" + type->as_string ();\n+\n+  if (default_expression)\n+    result += \" = \" + default_expression->as_string ();\n+\n+  return result;\n+}\n+\n+void\n+ConstGenericParam::accept_vis (HIRFullVisitor &vis)\n+{}\n+\n } // namespace HIR\n } // namespace Rust"}, {"sha": "64c6ddc9d544c4d0f7c2ec8f99635a50e8d3d529", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -112,12 +112,41 @@ struct GenericArgsBinding\n   Location get_locus () const { return locus; }\n };\n \n+class ConstGenericArg\n+{\n+  // FIXME: Do we need to disambiguate or no? We should be able to disambiguate\n+  // at name-resolution, hence no need for ambiguities here\n+\n+public:\n+  ConstGenericArg (std::unique_ptr<Expr> expression, Location locus)\n+    : expression (std::move (expression)), locus (locus)\n+  {}\n+\n+  ConstGenericArg (const ConstGenericArg &other) : locus (other.locus)\n+  {\n+    expression = other.expression->clone_expr ();\n+  }\n+\n+  ConstGenericArg operator= (const ConstGenericArg &other)\n+  {\n+    expression = other.expression->clone_expr ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+private:\n+  std::unique_ptr<Expr> expression;\n+  Location locus;\n+};\n+\n // Generic arguments allowed in each path expression segment - inline?\n struct GenericArgs\n {\n   std::vector<Lifetime> lifetime_args;\n   std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n+  std::vector<ConstGenericArg> const_args;\n   Location locus;\n \n public:\n@@ -130,18 +159,21 @@ struct GenericArgs\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n \t       std::vector<std::unique_ptr<Type> > type_args,\n-\t       std::vector<GenericArgsBinding> binding_args, Location locus)\n+\t       std::vector<GenericArgsBinding> binding_args,\n+\t       std::vector<ConstGenericArg> const_args, Location locus)\n     : lifetime_args (std::move (lifetime_args)),\n       type_args (std::move (type_args)),\n-      binding_args (std::move (binding_args)), locus (locus)\n+      binding_args (std::move (binding_args)),\n+      const_args (std::move (const_args)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   GenericArgs (GenericArgs const &other)\n     : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n-      locus (other.locus)\n+      const_args (other.const_args), locus (other.locus)\n   {\n     type_args.reserve (other.type_args.size ());\n+\n     for (const auto &e : other.type_args)\n       type_args.push_back (e->clone_type ());\n   }\n@@ -153,6 +185,7 @@ struct GenericArgs\n   {\n     lifetime_args = other.lifetime_args;\n     binding_args = other.binding_args;\n+    const_args = other.const_args;\n     locus = other.locus;\n \n     type_args.reserve (other.type_args.size ());\n@@ -169,9 +202,7 @@ struct GenericArgs\n   // Creates an empty GenericArgs (no arguments)\n   static GenericArgs create_empty (Location locus = Location ())\n   {\n-    return GenericArgs (std::vector<Lifetime> (),\n-\t\t\tstd::vector<std::unique_ptr<Type> > (),\n-\t\t\tstd::vector<GenericArgsBinding> (), locus);\n+    return GenericArgs ({}, {}, {}, {}, locus);\n   }\n \n   bool is_empty () const\n@@ -188,6 +219,8 @@ struct GenericArgs\n \n   std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n \n+  std::vector<ConstGenericArg> &get_const_args () { return const_args; }\n+\n   Location get_locus () const { return locus; }\n };\n \n@@ -464,12 +497,13 @@ class TypePathSegmentGeneric : public TypePathSegment\n \t\t\t  std::vector<Lifetime> lifetime_args,\n \t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  std::vector<ConstGenericArg> const_args,\n \t\t\t  Location locus)\n     : TypePathSegment (std::move (mappings), std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n-      generic_args (GenericArgs (std::move (lifetime_args),\n-\t\t\t\t std::move (type_args),\n-\t\t\t\t std::move (binding_args), locus))\n+      generic_args (\n+\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t     std::move (binding_args), std::move (const_args), locus))\n   {}\n \n   std::string as_string () const override;\n@@ -623,7 +657,6 @@ class TypePath : public TypeNoBounds\n public:\n   bool has_opening_scope_resolution;\n   std::vector<std::unique_ptr<TypePathSegment> > segments;\n-  Location locus;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -660,16 +693,15 @@ class TypePath : public TypeNoBounds\n   TypePath (Analysis::NodeMapping mappings,\n \t    std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n-    : TypeNoBounds (mappings),\n+    : TypeNoBounds (mappings, locus),\n       has_opening_scope_resolution (has_opening_scope_resolution),\n-      segments (std::move (segments)), locus (locus)\n+      segments (std::move (segments))\n   {}\n \n   // Copy constructor with vector clone\n   TypePath (TypePath const &other)\n-    : TypeNoBounds (other.mappings),\n-      has_opening_scope_resolution (other.has_opening_scope_resolution),\n-      locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      has_opening_scope_resolution (other.has_opening_scope_resolution)\n   {\n     segments.reserve (other.segments.size ());\n     for (const auto &e : other.segments)\n@@ -703,8 +735,6 @@ class TypePath : public TypeNoBounds\n   // Creates a trait bound with a clone of this type path as its only element.\n   TraitBound *to_trait_bound (bool in_parens) const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n@@ -865,7 +895,6 @@ class QualifiedPathInType : public TypeNoBounds\n   QualifiedPathType path_type;\n   std::unique_ptr<TypePathSegment> associated_segment;\n   std::vector<std::unique_ptr<TypePathSegment> > segments;\n-  Location locus;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -888,18 +917,17 @@ class QualifiedPathInType : public TypeNoBounds\n     std::unique_ptr<TypePathSegment> associated_segment,\n     std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n     Location locus = Location ())\n-    : TypeNoBounds (mappings), path_type (std::move (qual_path_type)),\n+    : TypeNoBounds (mappings, locus), path_type (std::move (qual_path_type)),\n       associated_segment (std::move (associated_segment)),\n-      segments (std::move (path_segments)), locus (locus)\n+      segments (std::move (path_segments))\n   {}\n \n   /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n    * as params */\n \n   // Copy constructor with vector clone\n   QualifiedPathInType (QualifiedPathInType const &other)\n-    : TypeNoBounds (other.mappings), path_type (other.path_type),\n-      locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus), path_type (other.path_type)\n   {\n     segments.reserve (other.segments.size ());\n     for (const auto &e : other.segments)\n@@ -943,8 +971,6 @@ class QualifiedPathInType : public TypeNoBounds\n   {\n     return segments;\n   }\n-\n-  Location get_locus () { return locus; }\n };\n \n class SimplePathSegment"}, {"sha": "0d2e7436acc3a5b9140da750afccbdf7ec44aead", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 47, "deletions": 93, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -87,9 +87,7 @@ class ImplTraitType : public Type\n {\n   // TypeParamBounds type_param_bounds;\n   // inlined form\n-  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n-\n-  Location locus;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -100,17 +98,15 @@ class ImplTraitType : public Type\n   }\n \n public:\n-  ImplTraitType (\n-    Analysis::NodeMapping mappings,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    Location locus)\n-    : Type (mappings), type_param_bounds (std::move (type_param_bounds)),\n-      locus (locus)\n+  ImplTraitType (Analysis::NodeMapping mappings,\n+\t\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t\t Location locus)\n+    : Type (mappings, locus), type_param_bounds (std::move (type_param_bounds))\n   {}\n \n   // copy constructor with vector clone\n   ImplTraitType (ImplTraitType const &other)\n-    : Type (other.mappings), locus (other.locus)\n+    : Type (other.mappings, other.locus)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -136,8 +132,6 @@ class ImplTraitType : public Type\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n };\n@@ -146,8 +140,7 @@ class ImplTraitType : public Type\n class TraitObjectType : public Type\n {\n   bool has_dyn;\n-  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n-  Location locus;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -160,15 +153,15 @@ class TraitObjectType : public Type\n public:\n   TraitObjectType (\n     Analysis::NodeMapping mappings,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n     Location locus, bool is_dyn_dispatch)\n-    : Type (mappings), has_dyn (is_dyn_dispatch),\n-      type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+    : Type (mappings, locus), has_dyn (is_dyn_dispatch),\n+      type_param_bounds (std::move (type_param_bounds))\n   {}\n \n   // copy constructor with vector clone\n   TraitObjectType (TraitObjectType const &other)\n-    : Type (other.mappings), has_dyn (other.has_dyn), locus (other.locus)\n+    : Type (other.mappings, other.locus), has_dyn (other.has_dyn)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -194,17 +187,15 @@ class TraitObjectType : public Type\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n \n-  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n@@ -215,7 +206,6 @@ class TraitObjectType : public Type\n class ParenthesisedType : public TypeNoBounds\n {\n   std::unique_ptr<Type> type_in_parens;\n-  Location locus;\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -236,15 +226,15 @@ class ParenthesisedType : public TypeNoBounds\n   // Constructor uses Type pointer for polymorphism\n   ParenthesisedType (Analysis::NodeMapping mappings,\n \t\t     std::unique_ptr<Type> type_inside_parens, Location locus)\n-    : TypeNoBounds (mappings), type_in_parens (std::move (type_inside_parens)),\n-      locus (locus)\n+    : TypeNoBounds (mappings, locus),\n+      type_in_parens (std::move (type_inside_parens))\n   {}\n \n   /* Copy constructor uses custom deep copy method for type to preserve\n    * polymorphism */\n   ParenthesisedType (ParenthesisedType const &other)\n-    : TypeNoBounds (other.mappings),\n-      type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      type_in_parens (other.type_in_parens->clone_type ())\n   {}\n \n   // overload assignment operator to use custom clone method\n@@ -274,8 +264,6 @@ class ParenthesisedType : public TypeNoBounds\n     return type_in_parens->to_trait_bound (true);\n   }\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n };\n@@ -285,8 +273,6 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n {\n   TraitBound trait_bound;\n \n-  Location locus;\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -305,14 +291,11 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n public:\n   ImplTraitTypeOneBound (Analysis::NodeMapping mappings, TraitBound trait_bound,\n \t\t\t Location locus)\n-    : TypeNoBounds (mappings), trait_bound (std::move (trait_bound)),\n-      locus (locus)\n+    : TypeNoBounds (mappings, locus), trait_bound (std::move (trait_bound))\n   {}\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n };\n@@ -323,21 +306,20 @@ class TypePath; // definition moved to \"rust-path.h\"\n  * specific order */\n class TupleType : public TypeNoBounds\n {\n-  std::vector<std::unique_ptr<Type> > elems;\n-  Location locus;\n+  std::vector<std::unique_ptr<Type>> elems;\n \n public:\n   // Returns whether the tuple type is the unit type, i.e. has no elements.\n   bool is_unit_type () const { return elems.empty (); }\n \n   TupleType (Analysis::NodeMapping mappings,\n-\t     std::vector<std::unique_ptr<Type> > elems, Location locus)\n-    : TypeNoBounds (mappings), elems (std::move (elems)), locus (locus)\n+\t     std::vector<std::unique_ptr<Type>> elems, Location locus)\n+    : TypeNoBounds (mappings, locus), elems (std::move (elems))\n   {}\n \n   // copy constructor with vector clone\n   TupleType (TupleType const &other)\n-    : TypeNoBounds (other.mappings), locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus)\n   {\n     mappings = other.mappings;\n     elems.reserve (other.elems.size ());\n@@ -363,16 +345,11 @@ class TupleType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n-  const std::vector<std::unique_ptr<Type> > &get_elems () const\n-  {\n-    return elems;\n-  }\n+  std::vector<std::unique_ptr<Type>> &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type>> &get_elems () const { return elems; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -392,8 +369,6 @@ class TupleType : public TypeNoBounds\n  * Represented as \"!\". */\n class NeverType : public TypeNoBounds\n {\n-  Location locus;\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -408,13 +383,11 @@ class NeverType : public TypeNoBounds\n \n public:\n   NeverType (Analysis::NodeMapping mappings, Location locus)\n-    : TypeNoBounds (mappings), locus (locus)\n+    : TypeNoBounds (mappings, locus)\n   {}\n \n   std::string as_string () const override { return \"! (never type)\"; }\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n };\n@@ -425,19 +398,18 @@ class RawPointerType : public TypeNoBounds\n private:\n   Mutability mut;\n   std::unique_ptr<Type> type;\n-  Location locus;\n \n public:\n   // Constructor requires pointer for polymorphism reasons\n   RawPointerType (Analysis::NodeMapping mappings, Mutability mut,\n \t\t  std::unique_ptr<Type> type, Location locus)\n-    : TypeNoBounds (mappings), mut (mut), type (std::move (type)), locus (locus)\n+    : TypeNoBounds (mappings, locus), mut (mut), type (std::move (type))\n   {}\n \n   // Copy constructor calls custom polymorphic clone function\n   RawPointerType (RawPointerType const &other)\n-    : TypeNoBounds (other.mappings), mut (other.mut),\n-      type (other.type->clone_type ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus), mut (other.mut),\n+      type (other.type->clone_type ())\n   {}\n \n   // overload assignment operator to use custom clone method\n@@ -456,8 +428,6 @@ class RawPointerType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n@@ -495,7 +465,6 @@ class ReferenceType : public TypeNoBounds\n \n   Mutability mut;\n   std::unique_ptr<Type> type;\n-  Location locus;\n \n public:\n   // Returns whether the reference is mutable or immutable.\n@@ -508,14 +477,14 @@ class ReferenceType : public TypeNoBounds\n   ReferenceType (Analysis::NodeMapping mappings, Mutability mut,\n \t\t std::unique_ptr<Type> type_no_bounds, Location locus,\n \t\t Lifetime lifetime)\n-    : TypeNoBounds (mappings), lifetime (std::move (lifetime)), mut (mut),\n-      type (std::move (type_no_bounds)), locus (locus)\n+    : TypeNoBounds (mappings, locus), lifetime (std::move (lifetime)),\n+      mut (mut), type (std::move (type_no_bounds))\n   {}\n \n   // Copy constructor with custom clone method\n   ReferenceType (ReferenceType const &other)\n-    : TypeNoBounds (other.mappings), lifetime (other.lifetime), mut (other.mut),\n-      type (other.type->clone_type ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus), lifetime (other.lifetime),\n+      mut (other.mut), type (other.type->clone_type ())\n   {}\n \n   // Operator overload assignment operator to custom clone the unique pointer\n@@ -536,8 +505,6 @@ class ReferenceType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n@@ -568,20 +535,20 @@ class ArrayType : public TypeNoBounds\n {\n   std::unique_ptr<Type> elem_type;\n   std::unique_ptr<Expr> size;\n-  Location locus;\n \n public:\n   // Constructor requires pointers for polymorphism\n   ArrayType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n \t     std::unique_ptr<Expr> array_size, Location locus)\n-    : TypeNoBounds (mappings), elem_type (std::move (type)),\n-      size (std::move (array_size)), locus (locus)\n+    : TypeNoBounds (mappings, locus), elem_type (std::move (type)),\n+      size (std::move (array_size))\n   {}\n \n   // Copy constructor requires deep copies of both unique pointers\n   ArrayType (ArrayType const &other)\n-    : TypeNoBounds (other.mappings), elem_type (other.elem_type->clone_type ()),\n-      size (other.size->clone_expr ()), locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ())\n   {}\n \n   // Overload assignment operator to deep copy pointers\n@@ -600,17 +567,13 @@ class ArrayType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n   Type *get_element_type () { return elem_type.get (); }\n \n   Expr *get_size_expr () { return size.get (); }\n \n-  Location &get_locus () { return locus; }\n-\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -629,19 +592,18 @@ class ArrayType : public TypeNoBounds\n class SliceType : public TypeNoBounds\n {\n   std::unique_ptr<Type> elem_type;\n-  Location locus;\n \n public:\n   // Constructor requires pointer for polymorphism\n   SliceType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n \t     Location locus)\n-    : TypeNoBounds (mappings), elem_type (std::move (type)), locus (locus)\n+    : TypeNoBounds (mappings, locus), elem_type (std::move (type))\n   {}\n \n   // Copy constructor requires deep copy of Type smart pointer\n   SliceType (SliceType const &other)\n-    : TypeNoBounds (other.mappings), elem_type (other.elem_type->clone_type ()),\n-      locus (other.locus)\n+    : TypeNoBounds (other.mappings, other.locus),\n+      elem_type (other.elem_type->clone_type ())\n   {}\n \n   // Overload assignment operator to deep copy\n@@ -660,8 +622,6 @@ class SliceType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n \n@@ -684,8 +644,6 @@ class SliceType : public TypeNoBounds\n  * pattern) */\n class InferredType : public TypeNoBounds\n {\n-  Location locus;\n-\n   // e.g. Vec<_> = whatever\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -704,13 +662,11 @@ class InferredType : public TypeNoBounds\n \n public:\n   InferredType (Analysis::NodeMapping mappings, Location locus)\n-    : TypeNoBounds (mappings), locus (locus)\n+    : TypeNoBounds (mappings, locus)\n   {}\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n };\n@@ -804,8 +760,6 @@ class BareFunctionType : public TypeNoBounds\n \n   std::unique_ptr<Type> return_type; // inlined version\n \n-  Location locus;\n-\n public:\n   // Whether a return type is defined with the function.\n   bool has_return_type () const { return return_type != nullptr; }\n@@ -818,18 +772,20 @@ class BareFunctionType : public TypeNoBounds\n \t\t    FunctionQualifiers qualifiers,\n \t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n \t\t    std::unique_ptr<Type> type, Location locus)\n-    : TypeNoBounds (mappings), for_lifetimes (std::move (lifetime_params)),\n+    : TypeNoBounds (mappings, locus),\n+      for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n-      return_type (std::move (type)), locus (locus)\n+      return_type (std::move (type))\n   {}\n \n   // Copy constructor with clone\n   BareFunctionType (BareFunctionType const &other)\n-    : TypeNoBounds (other.mappings), for_lifetimes (other.for_lifetimes),\n+    : TypeNoBounds (other.mappings, other.locus),\n+      for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n       is_variadic (other.is_variadic),\n-      return_type (other.return_type->clone_type ()), locus (other.locus)\n+      return_type (other.return_type->clone_type ())\n   {}\n \n   // Overload assignment operator to deep copy\n@@ -852,8 +808,6 @@ class BareFunctionType : public TypeNoBounds\n \n   std::string as_string () const override;\n \n-  Location get_locus () const { return locus; }\n-\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRTypeVisitor &vis) override;\n "}, {"sha": "8f9435478b21b59ca76f919aeb44ac6c2f517e17", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -478,16 +478,18 @@ class Type : public Node\n   virtual void accept_vis (HIRTypeVisitor &vis) = 0;\n \n   virtual Analysis::NodeMapping get_mappings () const { return mappings; }\n+  virtual Location get_locus () const { return locus; }\n \n protected:\n-  Type (Analysis::NodeMapping mappings) : mappings (mappings) {}\n+  Type (Analysis::NodeMapping mappings, Location locus)\n+    : mappings (mappings), locus (locus)\n+  {}\n \n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n \n   Analysis::NodeMapping mappings;\n-\n-  // FIXME: How do we get the location here for each type?\n+  Location locus;\n };\n \n // A type without parentheses? - abstract\n@@ -501,7 +503,9 @@ class TypeNoBounds : public Type\n   }\n \n protected:\n-  TypeNoBounds (Analysis::NodeMapping mappings) : Type (mappings) {}\n+  TypeNoBounds (Analysis::NodeMapping mappings, Location locus)\n+    : Type (mappings, locus)\n+  {}\n \n   // Clone function implementation as pure virtual method\n   virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n@@ -615,13 +619,11 @@ class GenericParam\n public:\n   virtual ~GenericParam () {}\n \n-  enum GenericKind\n+  enum class GenericKind\n   {\n     TYPE,\n     LIFETIME,\n-\n-    // CONST generic parameter not yet handled\n-    // CONST,\n+    CONST,\n   };\n \n   // Unique pointer custom clone function\n@@ -648,7 +650,8 @@ class GenericParam\n \n   enum GenericKind kind;\n \n-  GenericParam (Analysis::NodeMapping mapping, enum GenericKind kind = TYPE)\n+  GenericParam (Analysis::NodeMapping mapping,\n+\t\tenum GenericKind kind = GenericKind::TYPE)\n     : mappings (mapping), kind (kind)\n   {}\n };\n@@ -732,6 +735,52 @@ class LifetimeParam : public GenericParam\n   }\n };\n \n+class ConstGenericParam : public GenericParam\n+{\n+public:\n+  ConstGenericParam (std::string name, std::unique_ptr<Type> type,\n+\t\t     std::unique_ptr<Expr> default_expression,\n+\t\t     Analysis::NodeMapping mapping, Location locus)\n+    : GenericParam (mapping, GenericKind::CONST), name (std::move (name)),\n+      type (std::move (type)),\n+      default_expression (std::move (default_expression)), locus (locus)\n+  {}\n+\n+  ConstGenericParam (const ConstGenericParam &other) : GenericParam (other)\n+  {\n+    name = other.name;\n+    locus = other.locus;\n+\n+    if (other.type)\n+      type = other.type->clone_type ();\n+    if (other.default_expression)\n+      default_expression = other.default_expression->clone_expr ();\n+  }\n+\n+  std::string as_string () const override final;\n+\n+  void accept_vis (HIRFullVisitor &vis) override final;\n+\n+  Location get_locus () const override final { return locus; };\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConstGenericParam *clone_generic_param_impl () const override\n+  {\n+    return new ConstGenericParam (*this);\n+  }\n+\n+private:\n+  std::string name;\n+  std::unique_ptr<Type> type;\n+\n+  /* Optional - can be a null pointer if there is no default expression */\n+  std::unique_ptr<Expr> default_expression;\n+\n+  Location locus;\n+};\n+\n // Item used in trait declarations - abstract base class\n class TraitItem : public Node\n {"}, {"sha": "77f477b8303b7da2c76fa1e6e035fc8c5b8d2f01", "filename": "gcc/rust/privacy/rust-privacy-reporter.cc", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -188,8 +188,7 @@ PrivacyReporter::check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n }\n \n void\n-PrivacyReporter::check_type_privacy (const HIR::Type *type,\n-\t\t\t\t     const Location &locus)\n+PrivacyReporter::check_type_privacy (const HIR::Type *type)\n {\n   rust_assert (type);\n \n@@ -198,7 +197,7 @@ PrivacyReporter::check_type_privacy (const HIR::Type *type,\n     ty_ctx.lookup_type (type->get_mappings ().get_hirid (), &lookup));\n \n   auto node_mappings = type->get_mappings ();\n-  return check_base_type_privacy (node_mappings, lookup, locus);\n+  return check_base_type_privacy (node_mappings, lookup, type->get_locus ());\n }\n \n void\n@@ -634,9 +633,7 @@ void\n PrivacyReporter::visit (HIR::Function &function)\n {\n   for (auto &param : function.get_function_params ())\n-    check_type_privacy (param.get_type (), param.get_locus ());\n-\n-  // FIXME: It would be better if it was specifically the type's locus (#1256)\n+    check_type_privacy (param.get_type ());\n \n   function.get_definition ()->accept_vis (*this);\n }\n@@ -737,8 +734,7 @@ PrivacyReporter::visit (HIR::LetStmt &stmt)\n {\n   auto type = stmt.get_type ();\n   if (type)\n-    check_type_privacy (type, stmt.get_locus ());\n-  // FIXME: #1256\n+    check_type_privacy (type);\n \n   auto init_expr = stmt.get_init_expr ();\n   if (init_expr)"}, {"sha": "a04e318e9eade2530f7dbd83204f2554f43185cc", "filename": "gcc/rust/privacy/rust-privacy-reporter.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-privacy-reporter.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -74,9 +74,8 @@ types\n    *\n    * @param type Reference to an explicit type used in a statement, expression\n    * \t\tor parameter\n-   * @param locus Location of said type\n    */\n-  void check_type_privacy (const HIR::Type *type, const Location &locus);\n+  void check_type_privacy (const HIR::Type *type);\n \n   virtual void visit (HIR::StructExprFieldIdentifier &field);\n   virtual void visit (HIR::StructExprFieldIdentifierValue &field);"}, {"sha": "b322e29bfc31ea9686844860ebe32c0151aaa1c6", "filename": "gcc/rust/privacy/rust-reachability.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Fprivacy%2Frust-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-reachability.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -48,7 +48,7 @@ ReachabilityVisitor::visit_generic_predicates (\n \n   for (const auto &generic : generics)\n     {\n-      if (generic->get_kind () == HIR::GenericParam::TYPE)\n+      if (generic->get_kind () == HIR::GenericParam::GenericKind::TYPE)\n \t{\n \t  TyTy::BaseType *generic_ty = nullptr;\n \t  auto ok = ty_ctx.lookup_type (generic->get_mappings ().get_hirid (),"}, {"sha": "c0087636aeac7b8eca2fcbacf535d28af03a8be4", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -141,7 +141,9 @@ TraitResolver::resolve_trait (HIR::Trait *trait_reference)\n       switch (generic_param.get ()->get_kind ())\n \t{\n \tcase HIR::GenericParam::GenericKind::LIFETIME:\n-\t  // Skipping Lifetime completely until better handling.\n+\tcase HIR::GenericParam::GenericKind::CONST:\n+\t  // FIXME: Skipping Lifetime and Const completely until better\n+\t  // handling.\n \t  break;\n \n \t  case HIR::GenericParam::GenericKind::TYPE: {\n@@ -383,7 +385,9 @@ AssociatedImplTrait::setup_associated_types (\n       switch (generic_param.get ()->get_kind ())\n \t{\n \tcase HIR::GenericParam::GenericKind::LIFETIME:\n-\t  // Skipping Lifetime completely until better handling.\n+\tcase HIR::GenericParam::GenericKind::CONST:\n+\t  // FIXME: Skipping Lifetime and Const completely until better\n+\t  // handling.\n \t  break;\n \n \t  case HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "0bca9b467daca948a4bc124f2b1b69ba0d4158bb", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -57,7 +57,9 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -190,7 +192,9 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "84a33f85c62dc024aaa8b5bdca62b06d75b1d992", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -51,7 +51,9 @@ class TypeCheckItem : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "67eddb55c9518bd3c5d970bfced6bf0ab24e548f", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -139,7 +139,9 @@ class TypeCheckStmt : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -215,7 +217,9 @@ class TypeCheckStmt : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -273,7 +277,9 @@ class TypeCheckStmt : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -347,7 +353,9 @@ class TypeCheckStmt : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -415,7 +423,9 @@ class TypeCheckStmt : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "af63c5a09318e8fe19045c5ba604f7b83f4d04c9", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -64,7 +64,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -150,7 +152,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -228,7 +232,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -286,7 +292,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -374,7 +382,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {\n@@ -457,7 +467,9 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t    switch (generic_param.get ()->get_kind ())\n \t      {\n \t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n+\t      case HIR::GenericParam::GenericKind::CONST:\n+\t\t// FIXME: Skipping Lifetime and Const completely until better\n+\t\t// handling.\n \t\tbreak;\n \n \t\tcase HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "7cfb952152fe072a41fa30dcd18743781f2d8962", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -203,7 +203,9 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n \t  switch (generic_param.get ()->get_kind ())\n \t    {\n \t    case HIR::GenericParam::GenericKind::LIFETIME:\n-\t      // Skipping Lifetime completely until better handling.\n+\t    case HIR::GenericParam::GenericKind::CONST:\n+\t      // FIXME: Skipping Lifetime and Const completely until better\n+\t      // handling.\n \t      break;\n \n \t      case HIR::GenericParam::GenericKind::TYPE: {"}, {"sha": "0e0e496dde234b6f7c33eb8c1a858ac2f3010624", "filename": "gcc/testsuite/rust/compile/privacy5.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23815a535e1aaf89e256e1bb338f1bf8dcfa933c/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fprivacy5.rs?ref=23815a535e1aaf89e256e1bb338f1bf8dcfa933c", "patch": "@@ -12,7 +12,6 @@ mod orange {\n \n         let _: green::Foo; // { dg-error \"definition is private in this context\" }\n \n-        fn any(a0: green::Foo, a1: green::Bar) {}\n-        // { dg-error \"definition is private in this context\" \"\" { target *-*-* } .-1 }\n+        fn any(a0: green::Foo, a1: green::Bar) {} // { dg-error \"20:definition is private in this context\" }\n     }\n }"}]}