{"sha": "0d756922b0ded67e9c702fefcf0d0fe682444431", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3NTY5MjJiMGRlZDY3ZTljNzAyZmVmY2YwZDBmZTY4MjQ0NDQzMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-07-31T09:56:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-31T09:56:43Z"}, "message": "[Ada] Unnesting: improve support for entries in protected objects\n\n2018-07-31  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* exp_unst.adb (Subp_Index): In the case of a protected\n\toperation, the relevant entry is the generated\n\tprotected_subprogram_body into which the original body is\n\trewritten. Assorted cleanup and optimizations.\n\nFrom-SVN: r263105", "tree": {"sha": "5a0b32d8c92f803fbc75b8c6cc976e41d564dfa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a0b32d8c92f803fbc75b8c6cc976e41d564dfa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d756922b0ded67e9c702fefcf0d0fe682444431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d756922b0ded67e9c702fefcf0d0fe682444431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d756922b0ded67e9c702fefcf0d0fe682444431", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d756922b0ded67e9c702fefcf0d0fe682444431/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "948071faa6c0c6566056e0cb7b0a41c6c4b0ae79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948071faa6c0c6566056e0cb7b0a41c6c4b0ae79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948071faa6c0c6566056e0cb7b0a41c6c4b0ae79"}], "stats": {"total": 84, "additions": 54, "deletions": 30}, "files": [{"sha": "a713ceb8fecc2b5ed17495a8744a13646956a26a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d756922b0ded67e9c702fefcf0d0fe682444431/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d756922b0ded67e9c702fefcf0d0fe682444431/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0d756922b0ded67e9c702fefcf0d0fe682444431", "patch": "@@ -1,3 +1,10 @@\n+2018-07-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_unst.adb (Subp_Index): In the case of a protected\n+\toperation, the relevant entry is the generated\n+\tprotected_subprogram_body into which the original body is\n+\trewritten. Assorted cleanup and optimizations.\n+\n 2018-07-31  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_attr.adb (Expand_Attribute, case Fixed_Value): Set the"}, {"sha": "c5b03c4100d519b81fda97299a09ef099a5f31ab", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d756922b0ded67e9c702fefcf0d0fe682444431/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d756922b0ded67e9c702fefcf0d0fe682444431/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=0d756922b0ded67e9c702fefcf0d0fe682444431", "patch": "@@ -259,6 +259,16 @@ package body Exp_Unst is\n       if Subps_Index (E) = Uint_0 then\n          E := Ultimate_Alias (E);\n \n+         --  The body of a protected operation has a different name and\n+         --  has been scanned at this point, and thus has an entry in\n+         --  the subprogram table.\n+\n+         if E = Sub\n+           and then Convention (E) = Convention_Protected\n+         then\n+            E := Protected_Body_Subprogram (E);\n+         end if;\n+\n          if Ekind (E) = E_Function\n            and then Rewritten_For_C (E)\n            and then Present (Corresponding_Procedure (E))\n@@ -494,12 +504,13 @@ package body Exp_Unst is\n \n                   if Is_Entity_Name (N) then\n                      if Present (Entity (N))\n+                       and then not Is_Type (Entity (N))\n                        and then Present (Enclosing_Subprogram (Entity (N)))\n                        and then Ekind (Entity (N)) /= E_Discriminant\n                      then\n                         Note_Uplevel_Ref\n                           (E      => Entity (N),\n-                           N      => Ref,\n+                           N      => Empty,\n                            Caller => Current_Subprogram,\n                            Callee => Enclosing_Subprogram (Entity (N)));\n                      end if;\n@@ -538,9 +549,12 @@ package body Exp_Unst is\n                   elsif Nkind (N) in N_Unary_Op then\n                      Note_Uplevel_Bound (Right_Opnd (N), Ref);\n \n-                  --  Explicit dereference case\n+                  --  Explicit dereference and selected component case\n \n-                  elsif Nkind (N) = N_Explicit_Dereference then\n+                  elsif Nkind_In (N,\n+                    N_Explicit_Dereference,\n+                    N_Selected_Component)\n+                  then\n                      Note_Uplevel_Bound (Prefix (N), Ref);\n \n                   --  Conversion case\n@@ -861,6 +875,20 @@ package body Exp_Unst is\n                         Check_Static_Type\n                           (Etype (Expression (Expression (N))), Empty,  DT);\n                      end;\n+\n+                  --  For a Return or Free (all other nodes we handle here),\n+                  --  we usually need the size of the object, so we need to be\n+                  --  sure that any nonstatic bounds of the expression's type\n+                  --  that are uplevel are handled.\n+\n+                  elsif Nkind (N) /= N_Allocator\n+                    and then Present (Expression (N))\n+                  then\n+                     declare\n+                        DT : Boolean := False;\n+                     begin\n+                        Check_Static_Type (Etype (Expression (N)), Empty,  DT);\n+                     end;\n                   end if;\n \n                --  A 'Access reference is a (potential) call. So is 'Address,\n@@ -1141,10 +1169,7 @@ package body Exp_Unst is\n \n                            begin\n                               Check_Static_Type (Ent, N, DT);\n-\n-                              if Is_Static_Type (Ent) then\n-                                 return OK;\n-                              end if;\n+                              return OK;\n                            end;\n                         end if;\n \n@@ -1336,10 +1361,7 @@ package body Exp_Unst is\n                     and then Ekind (URJ.Ent) /= E_Discriminant\n                   then\n                      Set_Is_Uplevel_Referenced_Entity (URJ.Ent);\n-\n-                     if not Is_Type (URJ.Ent) then\n-                        Append_New_Elmt (URJ.Ent, SUBT.Uents);\n-                     end if;\n+                     Append_New_Elmt (URJ.Ent, SUBT.Uents);\n                   end if;\n \n                   --  And set uplevel indication for caller\n@@ -1395,7 +1417,8 @@ package body Exp_Unst is\n                      Write_Eol;\n                   end if;\n \n-                  --  Rewrite declaration and body to null statements\n+                  --  Rewrite declaration, body, and corresponding freeze node\n+                  --  to null statements.\n \n                   --  A subprogram instantiation does not have an explicit\n                   --  body. If unused, we could remove the corresponding\n@@ -1407,6 +1430,11 @@ package body Exp_Unst is\n                      if Present (Spec) then\n                         Decl := Parent (Declaration_Node (Spec));\n                         Rewrite (Decl, Make_Null_Statement (Sloc (Decl)));\n+\n+                        if Present (Freeze_Node (Spec)) then\n+                           Rewrite (Freeze_Node (Spec),\n+                                    Make_Null_Statement (Sloc (Decl)));\n+                        end if;\n                      end if;\n \n                      Rewrite (STJ.Bod, Make_Null_Statement (Sloc (STJ.Bod)));\n@@ -1829,7 +1857,11 @@ package body Exp_Unst is\n                         Decl_Assign := Empty;\n                      end if;\n \n-                     Prepend_List_To (Declarations (STJ.Bod), Decls);\n+                     if No (Declarations (STJ.Bod)) then\n+                        Set_Declarations (STJ.Bod, Decls);\n+                     else\n+                        Prepend_List_To (Declarations (STJ.Bod), Decls);\n+                     end if;\n \n                      --  Analyze the newly inserted declarations. Note that we\n                      --  do not need to establish the whole scope stack, since\n@@ -1987,24 +2019,10 @@ package body Exp_Unst is\n             --  Also ignore if no reference was specified or if the rewriting\n             --  has already been done (this can happen if the N_Identifier\n             --  occurs more than one time in the tree).\n-           --  Also ignore uplevel references to bounds of types that come\n-           --  from the original type reference.\n \n-            if Is_Type (UPJ.Ent)\n-              or else No (UPJ.Ref)\n+            if No (UPJ.Ref)\n               or else not Is_Entity_Name (UPJ.Ref)\n               or else not Present (Entity (UPJ.Ref))\n-              or else Is_Type (Entity (UPJ.Ref))\n-            then\n-               goto Continue;\n-            end if;\n-\n-            --  Also ignore uplevel references to bounds of types that come\n-            --  from the original type reference.\n-\n-            if Is_Entity_Name (UPJ.Ref)\n-              and then Present (Entity (UPJ.Ref))\n-              and then Is_Type (Entity (UPJ.Ref))\n             then\n                goto Continue;\n             end if;\n@@ -2347,13 +2365,12 @@ package body Exp_Unst is\n                   Unnest_Subprogram (Spec_Id, N);\n                end if;\n             end;\n-         end if;\n \n          --  The proper body of a stub may contain nested subprograms, and\n          --  therefore must be visited explicitly. Nested stubs are examined\n          --  recursively in Visit_Node.\n \n-         if Nkind (N) in N_Body_Stub then\n+         elsif Nkind (N) in N_Body_Stub then\n             Do_Search (Library_Unit (N));\n          end if;\n "}]}