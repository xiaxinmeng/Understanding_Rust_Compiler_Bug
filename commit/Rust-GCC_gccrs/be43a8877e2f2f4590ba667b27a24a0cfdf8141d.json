{"sha": "be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0M2E4ODc3ZTJmMmY0NTkwYmE2NjdiMjdhMjRhMGNmZGY4MTQxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-24T11:46:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-24T11:46:58Z"}, "message": "re PR tree-optimization/87105 (Autovectorization [X86, SSE2, AVX2, DoublePrecision])\n\n2018-10-24  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/87105\n\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Adjust\n\tdump classification.\n\t(vect_analyze_data_ref_accesses): Handle duplicate loads and\n\tstores by splitting the affected group after the fact.\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Dump when we\n\tfail the SLP build because of size constraints.\n\n\t* gcc.dg/vect/bb-slp-39.c: New testcase.\n\t* gfortran.dg/vect/pr83232.f90: Un-XFAIL.\n\nFrom-SVN: r265457", "tree": {"sha": "38f1f1b6f93d26561fa494f9ee9c140d9667c87e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38f1f1b6f93d26561fa494f9ee9c140d9667c87e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc6b6330c5d708ba319778b2befed0b7314271b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6b6330c5d708ba319778b2befed0b7314271b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6b6330c5d708ba319778b2befed0b7314271b8"}], "stats": {"total": 153, "additions": 121, "deletions": 32}, "files": [{"sha": "bd70bab9265426ed675bb412e4062d4b7273b1e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -1,3 +1,13 @@\n+2018-10-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87105\n+\t* tree-vect-data-refs.c (vect_analyze_group_access_1): Adjust\n+\tdump classification.\n+\t(vect_analyze_data_ref_accesses): Handle duplicate loads and\n+\tstores by splitting the affected group after the fact.\n+\t* tree-vect-slp.c (vect_build_slp_tree_2): Dump when we\n+\tfail the SLP build because of size constraints.\n+\n 2018-10-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_ld_aligned_shf_merge): New test."}, {"sha": "df476ec2eb98c097f7d6c54dbaccf48ca7f20f55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -1,3 +1,9 @@\n+2018-10-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87105\n+\t* gcc.dg/vect/bb-slp-39.c: New testcase.\n+\t* gfortran.dg/vect/pr83232.f90: Un-XFAIL.\n+\n 2018-10-24  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84013"}, {"sha": "255bb1095dc5bd1398f2de1afcd82168d074b29d", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-39.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-39.c?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double x[1024];\n+\n+void foo (double *p)\n+{\n+  x[0] = 1.;\n+  x[1] = 2.;\n+  *p = 7.; // aliasing store\n+  x[0] = x[0] + 1;\n+  x[1] = x[1] + 1;\n+  *p = 8.; // aliasing store\n+  x[1] = x[1] + 1;\n+  x[0] = x[0] + 1;\n+}\n+\n+/* See that we vectorize three SLP instances.  */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"slp2\" } } */"}, {"sha": "a35357839fedc3695aa753090a459e07dc7dd5c5", "filename": "gcc/testsuite/gfortran.dg/vect/pr83232.f90", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr83232.f90?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -27,7 +27,5 @@ SUBROUTINE MATERIAL_41_INTEGRATION ( STRESS,YLDC,EFPS,                   &\n       call foo (Einc)\n       END SUBROUTINE\n \n-! We should vectorize (1) and (2)\n-! { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"slp1\" } }\n-! We fail to vectorize at (3), this can be fixed in the future\n-! { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"slp1\" { xfail *-*-* } } }\n+! We should vectorize (1), (2) and (3)\n+! { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"slp1\" } }"}, {"sha": "9185b1bd1c0ccba6664f2c84063a1226f6ac3d28", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 80, "deletions": 28, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -2472,7 +2472,7 @@ vect_analyze_group_access_1 (dr_vec_info *dr_info)\n                 }\n \n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"Two or more load stmts share the same dr.\\n\");\n \n \t      /* For load use the same data-ref load.  */\n@@ -2838,6 +2838,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n      determining what dependencies are reversed.  */\n   vec<data_reference_p> datarefs_copy = datarefs.copy ();\n   datarefs_copy.qsort (dr_group_sort_cmp);\n+  hash_set<stmt_vec_info> to_fixup;\n \n   /* Build the interleaving chains.  */\n   for (i = 0; i < datarefs_copy.length () - 1;)\n@@ -2920,36 +2921,32 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t    {\n \t      gcc_assert (gimple_uid (DR_STMT (datarefs_copy[i-1]))\n \t\t\t  < gimple_uid (DR_STMT (drb)));\n-\t      /* ???  For now we simply \"drop\" the later reference which is\n-\t         otherwise the same rather than finishing off this group.\n-\t\t In the end we'd want to re-process duplicates forming\n-\t\t multiple groups from the refs, likely by just collecting\n-\t\t all candidates (including duplicates and split points\n-\t\t below) in a vector and then process them together.  */\n-\t      continue;\n+\t      /* Simply link in duplicates and fix up the chain below.  */\n \t    }\n-\n-\t  /* If init_b == init_a + the size of the type * k, we have an\n-\t     interleaving, and DRA is accessed before DRB.  */\n-\t  HOST_WIDE_INT type_size_a = tree_to_uhwi (sza);\n-\t  if (type_size_a == 0\n-\t      || (init_b - init_a) % type_size_a != 0)\n-\t    break;\n-\n-\t  /* If we have a store, the accesses are adjacent.  This splits\n-\t     groups into chunks we support (we don't support vectorization\n-\t     of stores with gaps).  */\n-\t  if (!DR_IS_READ (dra) && init_b - init_prev != type_size_a)\n-\t    break;\n-\n-\t  /* If the step (if not zero or non-constant) is greater than the\n-\t     difference between data-refs' inits this splits groups into\n-\t     suitable sizes.  */\n-\t  if (tree_fits_shwi_p (DR_STEP (dra)))\n+\t  else\n \t    {\n-\t      HOST_WIDE_INT step = tree_to_shwi (DR_STEP (dra));\n-\t      if (step != 0 && step <= (init_b - init_a))\n+\t      /* If init_b == init_a + the size of the type * k, we have an\n+\t\t interleaving, and DRA is accessed before DRB.  */\n+\t      HOST_WIDE_INT type_size_a = tree_to_uhwi (sza);\n+\t      if (type_size_a == 0\n+\t\t  || (init_b - init_a) % type_size_a != 0)\n \t\tbreak;\n+\n+\t      /* If we have a store, the accesses are adjacent.  This splits\n+\t\t groups into chunks we support (we don't support vectorization\n+\t\t of stores with gaps).  */\n+\t      if (!DR_IS_READ (dra) && init_b - init_prev != type_size_a)\n+\t\tbreak;\n+\n+\t      /* If the step (if not zero or non-constant) is greater than the\n+\t\t difference between data-refs' inits this splits groups into\n+\t\t suitable sizes.  */\n+\t      if (tree_fits_shwi_p (DR_STEP (dra)))\n+\t\t{\n+\t\t  HOST_WIDE_INT step = tree_to_shwi (DR_STEP (dra));\n+\t\t  if (step != 0 && step <= (init_b - init_a))\n+\t\t    break;\n+\t\t}\n \t    }\n \n \t  if (dump_enabled_p ())\n@@ -2968,9 +2965,64 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = stmtinfo_a;\n \t  DR_GROUP_NEXT_ELEMENT (lastinfo) = stmtinfo_b;\n \t  lastinfo = stmtinfo_b;\n+\n+\t  if (init_b == init_prev\n+\t      && !to_fixup.add (DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n+\t      && dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Queuing group with duplicate access for fixup\\n\");\n \t}\n     }\n \n+  /* Fixup groups with duplicate entries by splitting it.  */\n+  while (1)\n+    {\n+      hash_set<stmt_vec_info>::iterator it = to_fixup.begin ();\n+      if (!(it != to_fixup.end ()))\n+\tbreak;\n+      stmt_vec_info grp = *it;\n+      to_fixup.remove (grp);\n+\n+      /* Find the earliest duplicate group member.  */\n+      unsigned first_duplicate = -1u;\n+      stmt_vec_info next, g = grp;\n+      while ((next = DR_GROUP_NEXT_ELEMENT (g)))\n+\t{\n+\t  if ((DR_INIT (STMT_VINFO_DR_INFO (next)->dr)\n+\t       == DR_INIT (STMT_VINFO_DR_INFO (g)->dr))\n+\t      && gimple_uid (STMT_VINFO_STMT (next)) < first_duplicate)\n+\t    first_duplicate = gimple_uid (STMT_VINFO_STMT (next));\n+\t  g = next;\n+\t}\n+      if (first_duplicate == -1U)\n+\tcontinue;\n+\n+      /* Then move all stmts after the first duplicate to a new group.\n+         Note this is a heuristic but one with the property that *it\n+\t is fixed up completely.  */\n+      g = grp;\n+      stmt_vec_info newgroup = NULL, ng;\n+      while ((next = DR_GROUP_NEXT_ELEMENT (g)))\n+\t{\n+\t  if (gimple_uid (STMT_VINFO_STMT (next)) >= first_duplicate)\n+\t    {\n+\t      DR_GROUP_NEXT_ELEMENT (g) = DR_GROUP_NEXT_ELEMENT (next);\n+\t      if (!newgroup)\n+\t\tnewgroup = next;\n+\t      else\n+\t\tDR_GROUP_NEXT_ELEMENT (ng) = next;\n+\t      ng = next;\n+\t      DR_GROUP_FIRST_ELEMENT (ng) = newgroup;\n+\t    }\n+\t  else\n+\t    g = DR_GROUP_NEXT_ELEMENT (g);\n+\t}\n+      DR_GROUP_NEXT_ELEMENT (ng) = NULL;\n+\n+      /* Fixup the new group which still may contain duplicates.  */\n+      to_fixup.add (newgroup);\n+    }\n+\n   FOR_EACH_VEC_ELT (datarefs_copy, i, dr)\n     {\n       dr_vec_info *dr_info = vinfo->lookup_dr (dr);"}, {"sha": "3aae1776ef91b27ea98d4e68e6e11cf566dfcbd6", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be43a8877e2f2f4590ba667b27a24a0cfdf8141d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=be43a8877e2f2f4590ba667b27a24a0cfdf8141d", "patch": "@@ -1191,6 +1191,10 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n       if (++this_tree_size > max_tree_size)\n \t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n+\t\t\t     vect_location,\n+\t\t\t     \"Build SLP failed: SLP tree too large\\n\");\n \t  FOR_EACH_VEC_ELT (children, j, child)\n \t    vect_free_slp_tree (child, false);\n \t  vect_free_oprnd_info (oprnds_info);"}]}