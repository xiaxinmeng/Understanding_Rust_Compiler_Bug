{"sha": "45e3a33db7e23a4328974d19a5843d5053461eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVlM2EzM2RiN2UyM2E0MzI4OTc0ZDE5YTU4NDNkNTA1MzQ2MWVlYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-12T12:50:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-12T12:50:56Z"}, "message": "Kill CLASSTYPE_SORTED_FIELDS.\n\n\t* cp-tree.h (struct lang_type): Lose sorted_fields member.\n\t(CLASSTYPE_SORTED_FIELDS): Delete.\n\t* name-lookup.h (set_class_bindings): Add EXTRA arg.\n\t* name-lookup.c (fields_linear_search): New, broken out of ...\n\t(lookup_field_1): ... here.  Delete remainder of function.\n\t(get_class_binding_direct): Reimplement without sorted_fields.\n\t(get_class_binding): Rename TYPE arg to KLASS, for consistency.\n\t(get_method_slot): Call set_class_binding when creating method_vec\n\ton complete type.\n\t(method_name_cmp): Order identically named slots.\n\t(sorted_fields_type_new): Delete.\n\t(field_vc_append_class_fields): Rename to ...\n\t(method_vec_append_class_fields): ... here.  Adjust.\n\t(field_vec_append_enum_values): Renme to ...\n\t(method_vec_append_enum_values): ... here. Adjust.\n\t(method_vec_dedup): New.\n\t(set_class_bindings): Reimplement.\n\t(insert_late_enum_def_bindings): Reimplement.\n\nFrom-SVN: r252005", "tree": {"sha": "9efd23e51160d2e92bd32f30d928a7d16301d189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9efd23e51160d2e92bd32f30d928a7d16301d189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45e3a33db7e23a4328974d19a5843d5053461eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e3a33db7e23a4328974d19a5843d5053461eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45e3a33db7e23a4328974d19a5843d5053461eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45e3a33db7e23a4328974d19a5843d5053461eec/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20614c86632bcc03d09303b7d4df97cd590a8f38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20614c86632bcc03d09303b7d4df97cd590a8f38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20614c86632bcc03d09303b7d4df97cd590a8f38"}], "stats": {"total": 479, "additions": 310, "deletions": 169}, "files": [{"sha": "9e011e94429f7a94d4be0cb768897dd4461896c7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=45e3a33db7e23a4328974d19a5843d5053461eec", "patch": "@@ -1,5 +1,25 @@\n 2017-09-12  Nathan Sidwell  <nathan@acm.org>\n \n+\tKill CLASSTYPE_SORTED_FIELDS.\n+\t* cp-tree.h (struct lang_type): Lose sorted_fields member.\n+\t(CLASSTYPE_SORTED_FIELDS): Delete.\n+\t* name-lookup.h (set_class_bindings): Add EXTRA arg.\n+\t* name-lookup.c (fields_linear_search): New, broken out of ...\n+\t(lookup_field_1): ... here.  Delete remainder of function.\n+\t(get_class_binding_direct): Reimplement without sorted_fields.\n+\t(get_class_binding): Rename TYPE arg to KLASS, for consistency.\n+\t(get_method_slot): Call set_class_binding when creating method_vec\n+\ton complete type.\n+\t(method_name_cmp): Order identically named slots.\n+\t(sorted_fields_type_new): Delete.\n+\t(field_vc_append_class_fields): Rename to ...\n+\t(method_vec_append_class_fields): ... here.  Adjust.\n+\t(field_vec_append_enum_values): Renme to ...\n+\t(method_vec_append_enum_values): ... here. Adjust.\n+\t(method_vec_dedup): New.\n+\t(set_class_bindings): Reimplement.\n+\t(insert_late_enum_def_bindings): Reimplement.\n+\n \t* name-lookup.c (get_class_binding): Rename TYPE arg to KLASS for\n \tconsistency.\n \t(restort_data): Move later."}, {"sha": "e2c9673dc71caff4725f5182ce94d439eee812f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=45e3a33db7e23a4328974d19a5843d5053461eec", "patch": "@@ -2008,10 +2008,6 @@ struct GTY(()) lang_type {\n      as a list of adopted protocols or a pointer to a corresponding\n      @interface.  See objc/objc-act.h for details.  */\n   tree objc_info;\n-  /* sorted_fields is sorted based on a pointer, so we need to be able\n-     to resort it if pointers get rearranged.  */\n-  struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\")))\n-    sorted_fields;\n   /* FIXME reuse another field?  */\n   tree lambda_expr;\n };\n@@ -3229,11 +3225,6 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    && TREE_CODE (TYPE_NAME (NODE)) == TYPE_DECL\t\\\n    && TYPE_DECL_ALIAS_P (TYPE_NAME (NODE)))\n \n-/* For a class type: if this structure has many fields, we'll sort them\n-   and put them into a TREE_VEC.  */\n-#define CLASSTYPE_SORTED_FIELDS(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->sorted_fields)\n-\n /* If non-NULL for a VAR_DECL, FUNCTION_DECL, TYPE_DECL or\n    TEMPLATE_DECL, the entity is either a template specialization (if\n    DECL_USE_TEMPLATE is nonzero) or the abstract instance of the"}, {"sha": "243fbb4eecdb11a43d01d6de15c588a3c9daccb3", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 289, "deletions": 159, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=45e3a33db7e23a4328974d19a5843d5053461eec", "patch": "@@ -1156,103 +1156,54 @@ method_vec_linear_search (vec<tree, va_gc> *method_vec, tree name)\n   return NULL_TREE;\n }\n \n-/* Do a 1-level search for NAME as a member of TYPE.  The caller must\n-   figure out whether it can access this field.  (Since it is only one\n-   level, this is reasonable.)  */\n+/* Linear search of (partially ordered) fields of KLASS for NAME.  */\n \n static tree\n-lookup_field_1 (tree type, tree name, bool want_type)\n+fields_linear_search (tree klass, tree name, bool want_type)\n {\n-  tree field;\n-\n-  gcc_assert (identifier_p (name) && RECORD_OR_UNION_TYPE_P (type));\n-\n-  if (CLASSTYPE_SORTED_FIELDS (type))\n+  for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n     {\n-      tree *fields = &CLASSTYPE_SORTED_FIELDS (type)->elts[0];\n-      int lo = 0, hi = CLASSTYPE_SORTED_FIELDS (type)->len;\n-      int i;\n+      tree decl = fields;\n \n-      while (lo < hi)\n+      if (!want_type\n+\t  && TREE_CODE (decl) == FIELD_DECL\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (decl)))\n \t{\n-\t  i = (lo + hi) / 2;\n-\n-\t  if (DECL_NAME (fields[i]) > name)\n-\t    hi = i;\n-\t  else if (DECL_NAME (fields[i]) < name)\n-\t    lo = i + 1;\n+\t  tree anon = TREE_TYPE (decl);\n+\t  gcc_assert (COMPLETE_TYPE_P (anon));\n+\t  tree temp;\n+\t  \n+\t  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (anon))\n+\t    temp = method_vec_linear_search (method_vec, name);\n \t  else\n-\t    {\n-\t      field = NULL_TREE;\n-\n-\t      /* We might have a nested class and a field with the\n-\t\t same name; we sorted them appropriately via\n-\t\t field_decl_cmp, so just look for the first or last\n-\t\t field with this name.  */\n-\t      if (want_type)\n-\t\t{\n-\t\t  do\n-\t\t    field = fields[i--];\n-\t\t  while (i >= lo && DECL_NAME (fields[i]) == name);\n-\t\t  if (!DECL_DECLARES_TYPE_P (field))\n-\t\t    field = NULL_TREE;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  do\n-\t\t    field = fields[i++];\n-\t\t  while (i < hi && DECL_NAME (fields[i]) == name);\n-\t\t}\n+\t    temp = fields_linear_search (anon, name, want_type);\n \n-\t      if (field)\n-\t      \t{\n-\t      \t  field = strip_using_decl (field);\n-\t      \t  if (is_overloaded_fn (field))\n-\t      \t    field = NULL_TREE;\n-\t      \t}\n-\n-\t      return field;\n+\t  if (temp)\n+\t    {\n+\t      /* Anon members can only contain fields.  */\n+\t      gcc_assert (!STAT_HACK_P (temp) && !DECL_DECLARES_TYPE_P (temp));\n+\t      return temp;\n \t    }\n \t}\n-      return NULL_TREE;\n-    }\n-\n-  field = TYPE_FIELDS (type);\n-\n-  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-    {\n-      tree decl = field;\n \n-      if (DECL_DECLARES_FUNCTION_P (decl))\n-\t/* Functions are kep separately, at the moment.  */\n+      if (DECL_NAME (decl) != name)\n \tcontinue;\n-\n-      gcc_assert (DECL_P (field));\n-      if (DECL_NAME (field) == NULL_TREE\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  tree temp = lookup_field_1 (TREE_TYPE (field), name, want_type);\n-\t  if (temp)\n-\t    return temp;\n-\t}\n-\n-      if (TREE_CODE (decl) == USING_DECL\n-\t  && DECL_NAME (decl) == name)\n+      \n+      if (TREE_CODE (decl) == USING_DECL)\n \t{\n \t  decl = strip_using_decl (decl);\n \t  if (is_overloaded_fn (decl))\n \t    continue;\n \t}\n \n-      if (DECL_NAME (decl) == name\n-\t  && (!want_type || DECL_DECLARES_TYPE_P (decl)))\n+      if (DECL_DECLARES_FUNCTION_P (decl))\n+\t/* Functions are found separately.  */\n+\tcontinue;\n+\n+      if (!want_type || DECL_DECLARES_TYPE_P (decl))\n \treturn decl;\n     }\n \n-  /* We used to special-case vptr_identifier.  Make sure it's not\n-     special any more.  */\n-  gcc_assert (name != vptr_identifier || !TYPE_VFIELD (type));\n-\n   return NULL_TREE;\n }\n \n@@ -1273,25 +1224,49 @@ get_class_binding_direct (tree klass, tree name, int type_or_fns)\n   bool conv_op = IDENTIFIER_CONV_OP_P (name);\n   tree lookup = conv_op ? conv_op_identifier : name;\n   tree val = NULL_TREE;\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n \n-  if (type_or_fns > 0)\n-    /* User wants type.  Don't look in method_vec.  */;\n-  else if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass))\n+  if (COMPLETE_TYPE_P (klass) && method_vec)\n     {\n-      if (COMPLETE_TYPE_P (klass))\n-\tval = method_vec_binary_search (method_vec, lookup);\n-      else\n-\tval = method_vec_linear_search (method_vec, lookup);\n+      val = method_vec_binary_search (method_vec, lookup);\n+      if (!val)\n+\t;\n+      else if (type_or_fns > 0)\n+\t{\n+\t  if (STAT_HACK_P (val))\n+\t    val = STAT_TYPE (val);\n+\t  else if (!DECL_DECLARES_TYPE_P (val))\n+\t    val = NULL_TREE;\n+\t}\n+      else if (STAT_HACK_P (val))\n+\tval = STAT_DECL (val);\n+\n+      if (val && TREE_CODE (val) == OVERLOAD\n+\t  && TREE_CODE (OVL_FUNCTION (val)) == USING_DECL)\n+\t{\n+\t  /* An overload with a dependent USING_DECL.  Does the caller\n+\t     want the USING_DECL or the functions?  */\n+\t  if (type_or_fns < 0)\n+\t    val = OVL_CHAIN (val);\n+\t  else\n+\t    val = OVL_FUNCTION (val);  \n+\t}\n     }\n+  else\n+    {\n+      if (method_vec && type_or_fns <= 0)\n+\tval = method_vec_linear_search (method_vec, lookup);\n \n-  if (type_or_fns < 0)\n-    /* User wants functions.  Don't look for a field. */;\n-  else if (!val || (TREE_CODE (val) == OVERLOAD && OVL_USING_P (val)))\n-    /* Dependent using declarations are a 'field', make sure we\n-       return that even if we saw an overload already.  */\n-    if (tree field_val = lookup_field_1 (klass, lookup, type_or_fns > 0))\n-      if (!val || TREE_CODE (field_val) == USING_DECL)\n-\tval = field_val;\n+      if (type_or_fns < 0)\n+\t/* Don't bother looking for field.  We don't want it.  */;\n+      else if (!val || (TREE_CODE (val) == OVERLOAD && OVL_USING_P (val)))\n+\t/* Dependent using declarations are a 'field', make sure we\n+\t   return that even if we saw an overload already.  */\n+\tif (tree field_val = fields_linear_search (klass, lookup,\n+\t\t\t\t\t\t   type_or_fns > 0))\n+\t  if (!val || TREE_CODE (field_val) == USING_DECL)\n+\t    val = field_val;\n+    }\n \n   /* Extract the conversion operators asked for, unless the general\n      conversion operator was requested.   */\n@@ -1359,6 +1334,15 @@ get_method_slot (tree klass, tree name)\n     {\n       vec_alloc (method_vec, 8);\n       CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+      if (complete_p)\n+\t{\n+\t  /* If the class is complete but had no method_vec, we need\n+\t     to add the TYPE_FIELDS into it.  We're also most likely\n+\t     to be adding ctors & dtors, so ask for 6 spare slots (the\n+\t     abstract cdtors and their clones).  */\n+\t  set_class_bindings (klass, 6);\n+\t  method_vec = CLASSTYPE_METHOD_VEC (klass);\n+\t}\n     }\n \n   if (IDENTIFIER_CONV_OP_P (name))\n@@ -1372,6 +1356,12 @@ get_method_slot (tree klass, tree name)\n \n       if (fn_name == name)\n \t{\n+\t  /* If we found an existing slot, it must be a function set.\n+\t     Even with insertion after completion, because those only\n+\t     happen with artificial fns that have unspellable names.\n+\t     This means we do not have to deal with the stat hack\n+\t     either.  */\n+\t  gcc_checking_assert (OVL_P (*slot));\n \t  if (name == conv_op_identifier)\n \t    {\n \t      gcc_checking_assert (OVL_FUNCTION (*slot) == conv_op_marker);\n@@ -1413,7 +1403,9 @@ get_method_slot (tree klass, tree name)\n }\n \n /* Comparison function to compare two TYPE_METHOD_VEC entries by\n-   name.  */\n+   name.  Because we can have duplicates during insertion of\n+   TYPE_FIELDS, we do extra checking so deduping doesn't have to deal\n+   with so many cases.  */\n \n static int\n method_name_cmp (const void *a_p, const void *b_p)\n@@ -1423,8 +1415,48 @@ method_name_cmp (const void *a_p, const void *b_p)\n   tree name_a = DECL_NAME (TREE_CODE (a) == OVERLOAD ? OVL_FUNCTION (a) : a);\n   tree name_b = DECL_NAME (TREE_CODE (b) == OVERLOAD ? OVL_FUNCTION (b) : b);\n \n-  gcc_checking_assert (name_a && name_b && name_a != name_b);\n-  return name_a < name_b ? -1 : +1;\n+  gcc_checking_assert (name_a && name_b);\n+  if (name_a != name_b)\n+    return name_a < name_b ? -1 : +1;\n+\n+  if (name_a == conv_op_identifier)\n+    {\n+      /* Strip the conv-op markers. */\n+      gcc_checking_assert (OVL_FUNCTION (a) == conv_op_marker\n+\t\t\t   && OVL_FUNCTION (b) == conv_op_marker);\n+      a = OVL_CHAIN (a);\n+      b = OVL_CHAIN (b);\n+    }\n+\n+  if (TREE_CODE (a) == OVERLOAD)\n+    a = OVL_FUNCTION (a);\n+  if (TREE_CODE (b) == OVERLOAD)\n+    b = OVL_FUNCTION (b);\n+\n+  /* We're in STAT_HACK or USING_DECL territory (or possibly error-land). */\n+  if (TREE_CODE (a) == TREE_CODE (b))\n+    /* We can get two TYPE_DECLs or two USING_DECLs.  Place in source\n+       order.  */\n+    return DECL_SOURCE_LOCATION (a) < DECL_SOURCE_LOCATION (b) ? -1 : +1;\n+\n+  /* If one of them is a TYPE_DECL, it loses.  */\n+  if (TREE_CODE (a) == TYPE_DECL)\n+    return +1;\n+  else if (TREE_CODE (b) == TYPE_DECL)\n+    return -1;\n+\n+  /* If one of them is a USING_DECL, it loses.  */\n+  if (TREE_CODE (a) == USING_DECL)\n+    return +1;\n+  else if (TREE_CODE (b) == USING_DECL)\n+    return -1;\n+\n+  /* There are no other cases, as duplicate detection should have\n+     kicked in earlier.  However, some erroneous cases get though.\n+     Order by source location.  We should really prevent this\n+     happening.  */\n+  gcc_assert (errorcount);\n+  return DECL_SOURCE_LOCATION (a) < DECL_SOURCE_LOCATION (b) ? -1 : +1;\n }\n \n static struct {\n@@ -1467,20 +1499,6 @@ resort_type_method_vec (void *obj, void */*orig_obj*/,\n     }\n }\n \n-/* Allocate and return an instance of struct sorted_fields_type with\n-   N fields.  */\n-\n-static struct sorted_fields_type *\n-sorted_fields_type_new (int n)\n-{\n-  struct sorted_fields_type *sft;\n-  sft = (sorted_fields_type *) ggc_internal_alloc (sizeof (sorted_fields_type)\n-\t\t\t\t      + n * sizeof (tree));\n-  sft->len = n;\n-\n-  return sft;\n-}\n-\n /* Recursively count the number of fields in KLASS, including anonymous\n    union members.  */\n \n@@ -1501,58 +1519,176 @@ count_class_fields (tree klass)\n   return n_fields;\n }\n \n-/* Append all the nonfunction members fields of KLASS to FIELD_VEC\n-   starting at IDX. Recurse for anonymous members.  The array must\n-   have space.  Returns the next available index.  */\n+/* Append all the nonfunction members fields of KLASS to METHOD_VEC.\n+   Recurse for anonymous members.  METHOD_VEC must have space.  */\n \n-static unsigned\n-field_vec_append_class_fields (struct sorted_fields_type *field_vec,\n-\t\t\t       tree klass, unsigned idx)\n+static void\n+method_vec_append_class_fields (vec<tree, va_gc> *method_vec, tree klass)\n {\n   for (tree fields = TYPE_FIELDS (klass); fields; fields = DECL_CHAIN (fields))\n     if (DECL_DECLARES_FUNCTION_P (fields))\n       /* Functions are handled separately.  */;\n     else if (TREE_CODE (fields) == FIELD_DECL\n \t     && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n-      idx = field_vec_append_class_fields (field_vec, TREE_TYPE (fields), idx);\n+      method_vec_append_class_fields (method_vec, TREE_TYPE (fields));\n     else if (DECL_NAME (fields))\n-      field_vec->elts[idx++] = fields;\n-\n-  return idx;\n+      {\n+\ttree field = fields;\n+\t/* Mark a conv-op USING_DECL with the conv-op-marker.  */\n+\tif (TREE_CODE (field) == USING_DECL\n+\t    && IDENTIFIER_CONV_OP_P (DECL_NAME (field)))\n+\t  field = ovl_make (conv_op_marker, field);\n+\tmethod_vec->quick_push (field);\n+      }\n }\n \n-/* Append all of the enum values of ENUMTYPE to FIELD_VEC starting at IDX.\n-   FIELD_VEC must have space.  */\n+/* Append all of the enum values of ENUMTYPE to METHOD_VEC.\n+   METHOD_VEC must have space.  */\n \n-static unsigned\n-field_vec_append_enum_values (struct sorted_fields_type *field_vec,\n-\t\t\t      tree enumtype, unsigned idx)\n+static void\n+method_vec_append_enum_values (vec<tree, va_gc> *method_vec, tree enumtype)\n {\n   for (tree values = TYPE_VALUES (enumtype);\n        values; values = TREE_CHAIN (values))\n-    field_vec->elts[idx++] = TREE_VALUE (values);\n+    method_vec->quick_push (TREE_VALUE (values));\n+}\n+\n+/* METHOD_VEC has just had new DECLs added to it, but is sorted.\n+   DeDup adjacent DECLS of the same name.  We already dealt with\n+   conflict resolution when adding the fields or methods themselves.\n+   There are three cases (which could all be combined):\n+   1) a TYPE_DECL and non TYPE_DECL.  Deploy STAT_HACK as appropriate.\n+   2) a USING_DECL and an overload.  If the USING_DECL is dependent,\n+   it wins.  Otherwise the OVERLOAD does.\n+   3) two USING_DECLS. ...\n+\n+   method_name_cmp will have ordered duplicates as\n+   <fns><using><type>  */\n+\n+static void\n+method_vec_dedup (vec<tree, va_gc> *method_vec)\n+{\n+  unsigned len = method_vec->length ();\n+  unsigned store = 0;\n+\n+  tree current = (*method_vec)[0], name = OVL_NAME (current);\n+  tree next = NULL_TREE, next_name = NULL_TREE;\n+  for (unsigned jx, ix = 0; ix < len;\n+       ix = jx, current = next, name = next_name)\n+    {\n+      tree to_type = NULL_TREE;\n+      tree to_using = NULL_TREE;\n+      tree marker = NULL_TREE;\n+      if (IDENTIFIER_CONV_OP_P (name))\n+\t{\n+\t  marker = current;\n+\t  current = OVL_CHAIN (current);\n+\t  name = DECL_NAME (OVL_FUNCTION (marker));\n+\t  gcc_checking_assert (name == conv_op_identifier);\n+\t}\n+\n+      if (TREE_CODE (current) == USING_DECL)\n+\t{\n+\t  current = strip_using_decl (current);\n+\t  if (is_overloaded_fn (current))\n+\t    current = NULL_TREE;\n+\t  else if (TREE_CODE (current) == USING_DECL)\n+\t    {\n+\t      to_using = current;\n+\t      current = NULL_TREE;\n+\t    }\n+\t}\n+\n+      if (current && DECL_DECLARES_TYPE_P (current))\n+\t{\n+\t  to_type = current;\n+\t  current = NULL_TREE;\n+\t}\n+\n+      for (jx = ix + 1; jx < len; jx++)\n+\t{\n+\t  next = (*method_vec)[jx];\n+\t  next_name = OVL_NAME (next);\n+\t  if (next_name != name)\n+\t    break;\n+\n+\t  if (marker)\n+\t    {\n+\t      gcc_checking_assert (OVL_FUNCTION (marker)\n+\t\t\t\t   == OVL_FUNCTION (next));\n+\t      next = OVL_CHAIN (next);\n+\t    }\n \n-  return idx;\n+\t  if (TREE_CODE (next) == USING_DECL)\n+\t    {\n+\t      next = strip_using_decl (next);\n+\t      if (is_overloaded_fn (next))\n+\t\tnext = NULL_TREE;\n+\t      else if (TREE_CODE (next) == USING_DECL)\n+\t\t{\n+\t\t  to_using = next;\n+\t\t  next = NULL_TREE;\n+\t\t}\n+\t    }\n+\n+\t  if (next && DECL_DECLARES_TYPE_P (next))\n+\t    to_type = next;\n+\t}\n+\n+      if (to_using)\n+\t{\n+\t  if (!current)\n+\t    current = to_using;\n+\t  else\n+\t    current = ovl_make (to_using, current);\n+\t}\n+\n+      if (to_type)\n+\t{\n+\t  if (!current)\n+\t    current = to_type;\n+\t  else\n+\t    current = stat_hack (current, to_type);\n+\t}\n+\n+      gcc_assert (current);\n+      if (marker)\n+\t{\n+\t  OVL_CHAIN (marker) = current;\n+\t  current = marker;\n+\t}\n+      (*method_vec)[store++] = current;\n+    }\n+\n+  while (store++ < len)\n+    method_vec->pop ();\n }\n \n-/* Insert FIELDS into KLASS for the sorted case if the FIELDS count is\n-   big enough.  Sort the METHOD_VEC too.  */\n+/* Add the non-function members to CLASSTYPE_METHOD_VEC.  If there is\n+   no existing METHOD_VEC and fewer than 8 fields, do nothing.  We\n+   know there must be at least 1 field -- the self-reference\n+   TYPE_DECL, except for anon aggregates, which will have at least\n+   one field.  */\n \n void \n-set_class_bindings (tree klass)\n+set_class_bindings (tree klass, unsigned extra)\n {\n-  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass))\n-    qsort (method_vec->address (), method_vec->length (),\n-\t   sizeof (tree), method_name_cmp);\n+  unsigned n_fields = count_class_fields (klass);\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n \n-  int n_fields = count_class_fields (klass);\n-  if (n_fields >= 8)\n+  if (method_vec || n_fields >= 8)\n     {\n-      struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n-      unsigned idx = field_vec_append_class_fields (field_vec, klass, 0);\n-      gcc_assert (idx == unsigned (field_vec->len));\n-      qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n-      CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n+      /* Append the new fields.  */\n+      vec_safe_reserve_exact (method_vec, extra + n_fields);\n+      method_vec_append_class_fields (method_vec, klass);\n+    }\n+\n+  if (method_vec)\n+    {\n+      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+      qsort (method_vec->address (), method_vec->length (),\n+\t     sizeof (tree), method_name_cmp);\n+      method_vec_dedup (method_vec);\n     }\n }\n \n@@ -1561,33 +1697,27 @@ set_class_bindings (tree klass)\n void\n insert_late_enum_def_bindings (tree klass, tree enumtype)\n {\n-  unsigned n_fields;\n-  struct sorted_fields_type *sorted_fields = CLASSTYPE_SORTED_FIELDS (klass);\n+  int n_fields;\n+  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass);\n \n-  /* The enum values will already be on the TYPE_FIELDS, so don't\n+  /* The enum bindings will already be on the TYPE_FIELDS, so don't\n      count them twice.  */\n-  if (sorted_fields)\n-    n_fields = list_length (TYPE_VALUES (enumtype)) + sorted_fields->len;\n-  else\n+  if (!method_vec)\n     n_fields = count_class_fields (klass);\n+  else\n+    n_fields = list_length (TYPE_VALUES (enumtype));\n \n-  if (n_fields >= 8)\n+  if (method_vec || n_fields >= 8)\n     {\n-      struct sorted_fields_type *field_vec = sorted_fields_type_new (n_fields);\n-      unsigned idx;\n-\n-      if (sorted_fields)\n-\t{\n-\t  for (idx = 0; idx < unsigned (sorted_fields->len); ++idx)\n-\t    field_vec->elts[idx] = sorted_fields->elts[idx];\n-\n-\t  idx = field_vec_append_enum_values (field_vec, enumtype, idx);\n-\t}\n+      vec_safe_reserve_exact (method_vec, n_fields);\n+      if (CLASSTYPE_METHOD_VEC (klass))\n+\tmethod_vec_append_enum_values (method_vec, enumtype);\n       else\n-\tidx = field_vec_append_class_fields (field_vec, klass, 0);\n-      gcc_assert (idx == unsigned (field_vec->len));\n-      qsort (field_vec->elts, n_fields, sizeof (tree), field_decl_cmp);\n-      CLASSTYPE_SORTED_FIELDS (klass) = field_vec;\n+\tmethod_vec_append_class_fields (method_vec, klass);\n+      CLASSTYPE_METHOD_VEC (klass) = method_vec;\n+      qsort (method_vec->address (), method_vec->length (),\n+\t     sizeof (tree), method_name_cmp);\n+      method_vec_dedup (method_vec);\n     }\n }\n "}, {"sha": "005b2900c0e5ae796bcb8baccaf5af86d0a2a0b5", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45e3a33db7e23a4328974d19a5843d5053461eec/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=45e3a33db7e23a4328974d19a5843d5053461eec", "patch": "@@ -324,7 +324,7 @@ extern tree get_class_binding (tree, tree, int type_or_fns = -1);\n extern tree *get_method_slot (tree klass, tree name);\n extern void resort_type_method_vec (void *, void *,\n \t\t\t\t    gt_pointer_operator, void *);\n-extern void set_class_bindings (tree);\n+extern void set_class_bindings (tree, unsigned extra = 0);\n extern void insert_late_enum_def_bindings (tree, tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);"}]}