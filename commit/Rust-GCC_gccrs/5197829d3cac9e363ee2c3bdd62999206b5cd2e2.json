{"sha": "5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5NzgyOWQzY2FjOWUzNjNlZTJjM2JkZDYyOTk5MjA2YjVjZDJlMg==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1999-03-26T00:58:14Z"}, "committer": {"name": "Martin v. L\u00f6wis", "email": "loewis@gcc.gnu.org", "date": "1999-03-26T00:58:14Z"}, "message": "gcc.texi (Copy Assignment): New node.\n\n\t* gcc.texi (Copy Assignment): New node.\n\t* gxxint.texi: Remove old discussion on copying virtual bases.\n\nFrom-SVN: r25992", "tree": {"sha": "138dafe05e32b1894dc59d93ac353706522dc005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/138dafe05e32b1894dc59d93ac353706522dc005"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/comments", "author": null, "committer": null, "parents": [{"sha": "dd4b5f0d25ba0dd80d105e0b29b4be3f8b6d333e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4b5f0d25ba0dd80d105e0b29b4be3f8b6d333e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd4b5f0d25ba0dd80d105e0b29b4be3f8b6d333e"}], "stats": {"total": 107, "additions": 72, "deletions": 35}, "files": [{"sha": "92d0f80ae51656981726f2b06a423b5cda123cec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "patch": "@@ -1,4 +1,8 @@\n-999-03-25 Zack Weinberg  <zack@rabi.columbia.edu>\n+Thu Mar 25 22:53:27 1999  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* gcc.texi (Copy Assignment): New node.\n+\n+1999-03-25 Zack Weinberg  <zack@rabi.columbia.edu>\n \n \t* gcc.c: Compile unconditionally all code formerly dependent\n \ton #ifdef LANG_SPECIFIC_DRIVER."}, {"sha": "82d096c0e1bff8da2792567759ad99be0906c4b3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "patch": "@@ -1,3 +1,7 @@\n+1999-03-25  Martin von L\ufffdwis  <loewis@informatik.hu-berlin.de>\n+\n+\t* gxxint.texi: Remove old discussion on copying virtual bases.\n+\n 1999-03-25  Zack Weinberg  <zack@rabi.columbia.edu>\n \n \t* Make-lang.in: Remove all references to g++.o/g++.c."}, {"sha": "2f3790528777f64bed8568a74dad3977184b0840", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "patch": "@@ -23,7 +23,6 @@ Questions and comments to Benjamin Kosnik @code{<bkoz@@cygnus.com>}.\n * Access Control::              \n * Error Reporting::             \n * Parser::                      \n-* Copying Objects::             \n * Exception Handling::          \n * Free Store::                  \n * Mangling::  Function name mangling for C++ and Java\n@@ -931,7 +930,7 @@ To have the line number on the error message indicate the line of the\n DECL, use @code{cp_error_at} and its ilk; to indicate which argument you want,\n use @code{%+D}, or it will default to the first.\n \n-@node Parser, Copying Objects, Error Reporting, Top\n+@node Parser, Exception Handling, Error Reporting, Top\n @section Parser\n \n Some comments on the parser:\n@@ -1022,33 +1021,7 @@ conflicts.\n \n Unlike the others, this ambiguity is not recognized by the Working Paper.\n \n-@node  Copying Objects, Exception Handling, Parser, Top\n-@section Copying Objects\n-\n-The generated copy assignment operator in g++ does not currently do the\n-right thing for multiple inheritance involving virtual bases; it just\n-calls the copy assignment operators for its direct bases.  What it\n-should probably do is:\n-\n-1) Split up the copy assignment operator for all classes that have\n-vbases into \"copy my vbases\" and \"copy everything else\" parts.  Or do\n-the trickiness that the constructors do to ensure that vbases don't get\n-initialized by intermediate bases.\n-\n-2) Wander through the class lattice, find all vbases for which no\n-intermediate base has a user-defined copy assignment operator, and call\n-their \"copy everything else\" routines.  If not all of my vbases satisfy\n-this criterion, warn, because this may be surprising behavior.\n-\n-3) Call the \"copy everything else\" routine for my direct bases.\n-\n-If we only have one direct base, we can just foist everything off onto\n-them.\n-\n-This issue is currently under discussion in the core reflector\n-(2/28/94).\n-\n-@node  Exception Handling, Free Store, Copying Objects, Top\n+@node  Exception Handling, Free Store, Parser, Top\n @section Exception Handling\n \n Note, exception handling in g++ is still under development.  "}, {"sha": "4f9ceeb4ea8dba075173155a1d0f842fd6e40601", "filename": "gcc/gcc.texi", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5197829d3cac9e363ee2c3bdd62999206b5cd2e2/gcc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.texi?ref=5197829d3cac9e363ee2c3bdd62999206b5cd2e2", "patch": "@@ -1643,15 +1643,16 @@ in scope at the time of the call.\n @cindex misunderstandings in C++\n @cindex surprises in C++\n @cindex C++ misunderstandings\n-C++ is a complex language and an evolving one, and its standard definition\n-(the ANSI C++ draft standard) is also evolving.  As a result,\n-your C++ compiler may occasionally surprise you, even when its behavior is\n-correct.  This section discusses some areas that frequently give rise to\n-questions of this sort.\n+C++ is a complex language and an evolving one, and its standard\n+definition (the ISO C++ standard) was only recently completed.  As a\n+result, your C++ compiler may occasionally surprise you, even when its\n+behavior is correct.  This section discusses some areas that frequently\n+give rise to questions of this sort.\n \n @menu\n * Static Definitions::  Static member declarations are not definitions\n * Temporaries::         Temporaries may vanish before you expect\n+* Copy Assignment::     Copy Assignment operators copy virtual bases twice\n @end menu\n \n @node Static Definitions\n@@ -1746,6 +1747,61 @@ string& tmp = strfunc ();\n charfunc (tmp.c_str ());\n @end example\n \n+@node Copy Assignment\n+@subsection Implicit Copy-Assignment for Virtual Bases\n+\n+When a base class is virtual, only one subobject of the base class\n+belongs to each full object. Also, the constructors and destructors are\n+invoked only once, and called from the most-derived class. However, such\n+objects behave unspecified when being assigned. For example:\n+\n+@example\n+struct Base@{\n+  char *name;\n+  Base(char *n) : name(strdup(n))@{@}\n+  Base& operator= (const Base& other)@{\n+   free (name);\n+   name = strdup (other.name);\n+  @}\n+@};\n+\n+struct A:virtual Base@{\n+  int val;\n+  A():Base(\"A\")@{@}\n+@};\n+\n+struct B:virtual Base@{\n+  int bval;\n+  B():Base(\"B\")@{@}\n+@};\n+\n+struct Derived:public A, public B@{\n+  Derived():Base(\"Derived\")@{@}\n+@};\n+\n+void func(Derived &d1, Derived &d2)\n+@{\n+  d1 = d2;\n+@}\n+@end example\n+\n+The C++ standard specifies that @samp{Base::Base} is only called once\n+when constructing or copy-constructing a Derived object. It is\n+unspecified whether @samp{Base::operator=} is called more than once when\n+the implicit copy-assignment for Derived objects is invoked (as it is\n+inside @samp{func} in the example).\n+\n+g++ implements the \"intuitive\" algorithm for copy-assignment: assign all\n+direct bases, then assign all members. In that algorithm, the virtual\n+base subobject can be encountered many times. In the example, copying\n+proceeds in the following order: @samp{val}, @samp{name} (via\n+@code{strdup}), @samp{bval}, and @samp{name} again.\n+\n+If application code relies on copy-assignment, a user-defined\n+copy-assignment operator removes any uncertainties. With such an\n+operator, the application can define whether and how the virtual base\n+subobject is assigned.\n+\n @node Protoize Caveats\n @section Caveats of using @code{protoize}\n "}]}