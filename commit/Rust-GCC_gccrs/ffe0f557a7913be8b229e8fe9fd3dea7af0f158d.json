{"sha": "ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlMGY1NTdhNzkxM2JlOGIyMjllOGZlOWZkM2RlYTdhZjBmMTU4ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-04-11T15:51:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-04-11T15:51:40Z"}, "message": "pt.c (tsubst_copy): Don't call tsubst for local variables, look them up instead.\n\n\t* pt.c (tsubst_copy) [VAR_DECL]: Don't call tsubst for\n\tlocal variables, look them up instead.\n\t(tsubst_decl) [VAR_DECL]: Remove handling for anonymous union\n\tproxies and substitution in unevaluated context.\n\t(tsubst_expr) [OMP_FOR]: Instantiate OMP_FOR_PRE_BODY\n\tbefore the iterators.\n\nFrom-SVN: r197811", "tree": {"sha": "05813c0fdc3e2b450d3ac9076fde811cb7cbed7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05813c0fdc3e2b450d3ac9076fde811cb7cbed7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a3763018e63de8cee68d98f877221275adb42bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a3763018e63de8cee68d98f877221275adb42bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a3763018e63de8cee68d98f877221275adb42bc"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "dff5cf99c7ec484db8a250c198de683c61deed40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "patch": "@@ -1,5 +1,12 @@\n 2013-04-11  Jason Merrill  <jason@redhat.com>\n \n+\t* pt.c (tsubst_copy) [VAR_DECL]: Don't call tsubst for\n+\tlocal variables, look them up instead.\n+\t(tsubst_decl) [VAR_DECL]: Remove handling for anonymous union\n+\tproxies and substitution in unevaluated context.\n+\t(tsubst_expr) [OMP_FOR]: Instantiate OMP_FOR_PRE_BODY\n+\tbefore the iterators.\n+\n \tPR c++/23055\n \t* pt.c (uses_deducible_template_parms): New.\n \t(deducible_array_bound, deducible_expression): New."}, {"sha": "dc1385e075df9ff3e84e8ce0bd7b467ae090dfcf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe0f557a7913be8b229e8fe9fd3dea7af0f158d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ffe0f557a7913be8b229e8fe9fd3dea7af0f158d", "patch": "@@ -10633,16 +10633,6 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    break;\n \t  }\n \n-\tif (VAR_P (t) && DECL_ANON_UNION_VAR_P (t))\n-\t  {\n-\t    /* Just use name lookup to find a member alias for an anonymous\n-\t       union, but then add it to the hash table.  */\n-\t    r = lookup_name (DECL_NAME (t));\n-\t    gcc_assert (DECL_ANON_UNION_VAR_P (r));\n-\t    register_local_specialization (r, t);\n-\t    break;\n-\t  }\n-\n \t/* Create a new node for the specialization we need.  */\n \tr = copy_decl (t);\n \tif (type == NULL_TREE)\n@@ -10747,21 +10737,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }\n \telse if (cp_unevaluated_operand)\n-\t  {\n-\t    /* We're substituting this var in a decltype outside of its\n-\t       scope, such as for a lambda return type.  Don't add it to\n-\t       local_specializations, do perform auto deduction.  */\n-\t    tree auto_node = type_uses_auto (type);\n-\t    if (auto_node)\n-\t      {\n-\t\ttree init\n-\t\t  = tsubst_expr (DECL_INITIAL (t), args, complain, in_decl,\n-\t\t\t\t /*constant_expression_p=*/false);\n-\t\tinit = resolve_nondeduced_context (init);\n-\t\tTREE_TYPE (r) = type\n-\t\t  = do_auto_deduction (type, init, auto_node);\n-\t      }\n-\t  }\n+\t  gcc_unreachable ();\n \telse\n \t  register_local_specialization (r, t);\n \n@@ -12175,11 +12151,32 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n     case VAR_DECL:\n     case FUNCTION_DECL:\n-      if ((DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n-\t  || local_variable_p (t))\n-\tt = tsubst (t, args, complain, in_decl);\n-      mark_used (t);\n-      return t;\n+      if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t))\n+\tr = tsubst (t, args, complain, in_decl);\n+      else if (local_variable_p (t))\n+\t{\n+\t  r = retrieve_local_specialization (t);\n+\t  if (r == NULL_TREE)\n+\t    {\n+\t      if (DECL_ANON_UNION_VAR_P (t))\n+\t\t{\n+\t\t  /* Just use name lookup to find a member alias for an\n+\t\t     anonymous union, but then add it to the hash table.  */\n+\t\t  r = lookup_name (DECL_NAME (t));\n+\t\t  gcc_assert (DECL_ANON_UNION_VAR_P (r));\n+\t\t  register_local_specialization (r, t);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (errorcount || sorrycount);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tr = t;\n+      mark_used (r);\n+      return r;\n \n     case NAMESPACE_DECL:\n       return t;\n@@ -13218,15 +13215,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n \tstmt = begin_omp_structured_block ();\n \n+\tpre_body = push_stmt_list ();\n+\tRECUR (OMP_FOR_PRE_BODY (t));\n+\tpre_body = pop_stmt_list (pre_body);\n+\n \tfor (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (t)); i++)\n \t  tsubst_omp_for_iterator (t, i, declv, initv, condv, incrv,\n \t\t\t\t   &clauses, args, complain, in_decl,\n \t\t\t\t   integral_constant_expression_p);\n \n-\tpre_body = push_stmt_list ();\n-\tRECUR (OMP_FOR_PRE_BODY (t));\n-\tpre_body = pop_stmt_list (pre_body);\n-\n \tbody = push_stmt_list ();\n \tRECUR (OMP_FOR_BODY (t));\n \tbody = pop_stmt_list (body);"}]}