{"sha": "6be777481ea7fa281c38dc84a76674e80013603b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlNzc3NDgxZWE3ZmEyODFjMzhkYzg0YTc2Njc0ZTgwMDEzNjAzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-07-02T12:16:58Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-07-02T12:16:58Z"}, "message": "c-common.h (TDI_inlined): New ast dump phase.\n\n\t* c-common.h (TDI_inlined): New ast dump phase.\n\t(dump_flag_name): New function.\n\t* c-dump.c (dump_files): Add inlined phase.\n\t(dump_flag_name): Define.\n\t* doc/invoke.texi (-fdump-ast-inlined): Document.\ncp:\n\t* optimize.c (optimize_inline_calls): New function, broken out\n\tof ...\n\t(optimize_function): ... here. Call it. Don't inline if it is\n\ta thunk.\n\t(dump_function): Print name of dump flag causing this dump.\n\t* semantics.c (expand_body): Move thunk inline check to\n\toptimize_function.\n\nFrom-SVN: r43687", "tree": {"sha": "23c0745f9141013fbdd206b748a7c2c6fad106d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23c0745f9141013fbdd206b748a7c2c6fad106d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be777481ea7fa281c38dc84a76674e80013603b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be777481ea7fa281c38dc84a76674e80013603b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be777481ea7fa281c38dc84a76674e80013603b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be777481ea7fa281c38dc84a76674e80013603b/comments", "author": null, "committer": null, "parents": [{"sha": "3aa12a583f98074d6eaca377d9f3842df7c387ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa12a583f98074d6eaca377d9f3842df7c387ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa12a583f98074d6eaca377d9f3842df7c387ed"}], "stats": {"total": 205, "additions": 129, "deletions": 76}, "files": [{"sha": "c829d92d055ee31bf80c1777fa999e097412d5a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -1,3 +1,11 @@\n+2001-07-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-common.h (TDI_inlined): New ast dump phase.\n+\t(dump_flag_name): New function.\n+\t* c-dump.c (dump_files): Add inlined phase.\n+\t(dump_flag_name): Define.\n+\t* doc/invoke.texi (-fdump-ast-inlined): Document.\n+\n Mon Jul  2 06:29:36 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* stor-layout.c (layout_decl): Revert change to handling of alignment"}, {"sha": "147ffa41eaa2d93acf1ca91e02605a0776472dea", "filename": "gcc/c-common.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -826,9 +826,11 @@ extern int c_unsafe_for_reeval\t\t\tPARAMS ((tree));\n enum tree_dump_index\n {\n   TDI_all,\t\t\t/* dump the whole translation unit */\n-  TDI_original,\t\t\t/* dump each function before optimizing it */\n-  TDI_optimized,\t\t\t/* dump each function after optimizing it */\n   TDI_class,\t\t\t/* dump class heirarchy */\n+  TDI_original,\t\t\t/* dump each function before optimizing it */\n+  TDI_optimized,\t\t/* dump each function after optimizing it */\n+  TDI_inlined,\t\t\t/* dump each function after inlining\n+\t\t\t\t   within it. */\n   TDI_end\n };\n \n@@ -852,6 +854,7 @@ extern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\n extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n extern int dump_switch_p                PARAMS ((const char *));\n+extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n \n /* Information recorded about each file examined during compilation.  */\n "}, {"sha": "095626699d485b511381ca1e683dcd56718b68df", "filename": "gcc/c-dump.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -799,9 +799,10 @@ struct dump_file_info\n static struct dump_file_info dump_files[TDI_end] =\n {\n   {\".tu\", \"dump-translation-unit\", 0, 0},\n+  {\".class\", \"dump-class-hierarchy\", 0, 0},\n   {\".original\", \"dump-ast-original\", 0, 0},\n   {\".optimized\", \"dump-ast-optimized\", 0, 0},\n-  {\".class\", \"dump-class-hierarchy\", 0, 0},\n+  {\".inlined\", \"dump-ast-inlined\", 0, 0},\n };\n \n /* Begin a tree dump for PHASE. Stores any user supplied flag in\n@@ -835,16 +836,27 @@ dump_begin (phase, flag_ptr)\n \n /* Returns non-zero if tree dump PHASE is enabled. */\n \n-int dump_enabled_p (phase)\n+int\n+dump_enabled_p (phase)\n      enum tree_dump_index phase;\n {\n   return dump_files[phase].state;\n }\n \n+/* Returns the switch name of PHASE. */\n+\n+const char *\n+dump_flag_name (phase)\n+     enum tree_dump_index phase;\n+{\n+  return dump_files[phase].swtch;\n+}\n+\n /* Finish a tree dump for PHASE. STREAM is the stream created by\n    dump_begin. */\n \n-void dump_end (phase, stream)\n+void\n+dump_end (phase, stream)\n      enum tree_dump_index phase ATTRIBUTE_UNUSED;\n      FILE *stream;\n {\n@@ -854,7 +866,8 @@ void dump_end (phase, stream)\n /* Parse ARG as a dump switch. Return non-zero if it is, and store the\n    relevant details in the dump_files array. */\n \n-int dump_switch_p (arg)\n+int\n+dump_switch_p (arg)\n      const char *arg;\n {\n   unsigned ix;"}, {"sha": "dfe82c029f87832943d7d8de0bfdbbb8c4077232", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -1,3 +1,13 @@\n+2001-07-02  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* optimize.c (optimize_inline_calls): New function, broken out\n+\tof ...\n+\t(optimize_function): ... here. Call it. Don't inline if it is\n+\ta thunk.\n+\t(dump_function): Print name of dump flag causing this dump.\n+\t* semantics.c (expand_body): Move thunk inline check to\n+\toptimize_function.\n+\n 2001-06-29  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* typeck.c (COMP_TYPE_ATTRIBUTES): Don't define."}, {"sha": "4e713c3b06f0315ae11ed1c8df698e2b9254d566", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 77, "deletions": 61, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -78,7 +78,7 @@ typedef struct inline_data\n   int inlined_stmts;\n   /* We use the same mechanism to build clones that we do to perform\n      inlining.  However, there are a few places where we need to\n-     distinguish between those two situations.  This flag is true nif\n+     distinguish between those two situations.  This flag is true if\n      we are cloning, rather than inlining.  */\n   bool cloning_p;\n   /* Hash table used to prevent walk_tree from visiting the same node\n@@ -98,6 +98,7 @@ static int inlinable_function_p PARAMS ((tree, inline_data *));\n static tree remap_decl PARAMS ((tree, inline_data *));\n static void remap_block PARAMS ((tree, tree, inline_data *));\n static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n+static void optimize_inline_calls PARAMS ((tree));\n static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n static void update_cloned_parm PARAMS ((tree, tree));\n static void dump_function PARAMS ((enum tree_dump_index, tree));\n@@ -934,6 +935,69 @@ expand_calls_inline (tp, id)\n   walk_tree (tp, expand_call_inline, id, id->tree_pruner);\n }\n \n+/* Expand calls to inline functions in the body of FN.  */\n+\n+static void\n+optimize_inline_calls (fn)\n+     tree fn;\n+{\n+  inline_data id;\n+  tree prev_fn;\n+  struct saved_scope *s;\n+  \n+  /* Clear out ID.  */\n+  memset (&id, 0, sizeof (id));\n+\n+  /* Don't allow recursion into FN.  */\n+  VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n+  VARRAY_PUSH_TREE (id.fns, fn);\n+  /* Or any functions that aren't finished yet.  */\n+  prev_fn = NULL_TREE;\n+  if (current_function_decl)\n+    {\n+      VARRAY_PUSH_TREE (id.fns, current_function_decl);\n+      prev_fn = current_function_decl;\n+    }\n+  for (s = scope_chain; s; s = s->prev)\n+    if (s->function_decl && s->function_decl != prev_fn)\n+      {\n+\tVARRAY_PUSH_TREE (id.fns, s->function_decl);\n+\tprev_fn = s->function_decl;\n+      }\n+  \n+  /* Create the stack of TARGET_EXPRs.  */\n+  VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n+\n+  /* Create the list of functions this call will inline.  */\n+  VARRAY_TREE_INIT (id.inlined_fns, 32, \"inlined_fns\");\n+\n+  /* Keep track of the low-water mark, i.e., the point where the first\n+     real inlining is represented in ID.FNS.  */\n+  id.first_inlined_fn = VARRAY_ACTIVE_SIZE (id.fns);\n+\n+  /* Replace all calls to inline functions with the bodies of those\n+     functions.  */\n+  id.tree_pruner = htab_create (37, htab_hash_pointer,\n+\t\t\t\thtab_eq_pointer, NULL);\n+  expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n+\n+  /* Clean up.  */\n+  htab_delete (id.tree_pruner);\n+  VARRAY_FREE (id.fns);\n+  VARRAY_FREE (id.target_exprs);\n+  if (DECL_LANG_SPECIFIC (fn))\n+    {\n+      tree ifn = make_tree_vec (VARRAY_ACTIVE_SIZE (id.inlined_fns));\n+      \n+      memcpy (&TREE_VEC_ELT (ifn, 0), &VARRAY_TREE (id.inlined_fns, 0),\n+\t      VARRAY_ACTIVE_SIZE (id.inlined_fns) * sizeof (tree));\n+      DECL_INLINED_FNS (fn) = ifn;\n+    }\n+  VARRAY_FREE (id.inlined_fns);\n+  \n+  dump_function (TDI_inlined, fn);\n+}\n+\n /* Optimize the body of FN. */\n \n void\n@@ -953,64 +1017,14 @@ optimize_function (fn)\n      of the function.  */\n   ++function_depth;\n \n-  /* Expand calls to inline functions.  */\n-  if (flag_inline_trees)\n-    {\n-      inline_data id;\n-      tree prev_fn;\n-      struct saved_scope *s;\n-\n-      /* Clear out ID.  */\n-      memset (&id, 0, sizeof (id));\n-\n-      /* Don't allow recursion into FN.  */\n-      VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n-      VARRAY_PUSH_TREE (id.fns, fn);\n-      /* Or any functions that aren't finished yet.  */\n-      prev_fn = NULL_TREE;\n-      if (current_function_decl)\n-\t{\n-\t  VARRAY_PUSH_TREE (id.fns, current_function_decl);\n-\t  prev_fn = current_function_decl;\n-\t}\n-      for (s = scope_chain; s; s = s->prev)\n-\tif (s->function_decl && s->function_decl != prev_fn)\n-\t  {\n-\t    VARRAY_PUSH_TREE (id.fns, s->function_decl);\n-\t    prev_fn = s->function_decl;\n-\t  }\n-\n-      /* Create the stack of TARGET_EXPRs.  */\n-      VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n-\n-      /* Create the list of functions this call will inline.  */\n-      VARRAY_TREE_INIT (id.inlined_fns, 32, \"inlined_fns\");\n-\n-      /* Keep track of the low-water mark, i.e., the point where\n-\t the first real inlining is represented in ID.FNS.  */\n-      id.first_inlined_fn = VARRAY_ACTIVE_SIZE (id.fns);\n-\n-      /* Replace all calls to inline functions with the bodies of those\n-\t functions.  */\n-      id.tree_pruner = htab_create (37, htab_hash_pointer,\n-\t\t\t\t    htab_eq_pointer, NULL);\n-      expand_calls_inline (&DECL_SAVED_TREE (fn), &id);\n-\n-      /* Clean up.  */\n-      htab_delete (id.tree_pruner);\n-      VARRAY_FREE (id.fns);\n-      VARRAY_FREE (id.target_exprs);\n-      if (DECL_LANG_SPECIFIC (fn))\n-\t{\n-\t  tree ifn = make_tree_vec (VARRAY_ACTIVE_SIZE (id.inlined_fns));\n-\n-\t  memcpy (&TREE_VEC_ELT (ifn, 0), &VARRAY_TREE (id.inlined_fns, 0),\n-\t\t  VARRAY_ACTIVE_SIZE (id.inlined_fns) * sizeof (tree));\n-\t  DECL_INLINED_FNS (fn) = ifn;\n-\t}\n-      VARRAY_FREE (id.inlined_fns);\n-    }\n-\n+  if (flag_inline_trees\n+      /* We do not inline thunks, as (a) the backend tries to optimize\n+         the call to the thunkee, (b) tree based inlining breaks that\n+         optimization, (c) virtual functions are rarely inlineable,\n+         and (d) ASM_OUTPUT_MI_THUNK is there to DTRT anyway.  */\n+      && !DECL_THUNK_P (fn))\n+    optimize_inline_calls (fn);\n+  \n   /* Undo the call to ggc_push_context above.  */\n   --function_depth;\n   \n@@ -1246,8 +1260,10 @@ dump_function (phase, fn)\n     {\n       fprintf (stream, \"\\n;; Function %s\",\n \t       decl_as_string (fn, TFF_DECL_SPECIFIERS));\n-      fprintf (stream, \" (%s)\", decl_as_string (DECL_ASSEMBLER_NAME (fn), 0));\n-      fprintf (stream, \"\\n\\n\");\n+      fprintf (stream, \" (%s)\\n\",\n+\t       decl_as_string (DECL_ASSEMBLER_NAME (fn), 0));\n+      fprintf (stream, \";; enabled by -%s\\n\", dump_flag_name (phase));\n+      fprintf (stream, \"\\n\");\n       \n       dump_node (fn, TDF_SLIM | flags, stream);\n       dump_end (phase, stream);"}, {"sha": "050e1be314c7719fea38e7b336da7fb3eb75b757", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -2408,13 +2408,8 @@ expand_body (fn)\n \n   timevar_push (TV_INTEGRATION);\n \n-  /* Optimize the body of the function before expanding it.  We do not\n-     optimize thunks, as (1) the backend tries to optimize the call to\n-     the thunkee, (b) the tree based inliner breaks that optimization,\n-     (c) virtual functions are rarely inlineable, and (d)\n-     ASM_OUTPUT_MI_THUNK is there to DTRT anyway.  */\n-  if (!DECL_THUNK_P (fn))\n-    optimize_function (fn);\n+  /* Optimize the body of the function before expanding it.  */\n+  optimize_function (fn);\n \n   timevar_pop (TV_INTEGRATION);\n   timevar_push (TV_EXPAND);"}, {"sha": "359dcbc8c81ac957cca6f331537d91556edc3711", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be777481ea7fa281c38dc84a76674e80013603b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6be777481ea7fa281c38dc84a76674e80013603b", "patch": "@@ -239,6 +239,7 @@ in the following sections.\n -a  -ax  -d@var{letters}  -dumpspecs  -dumpmachine  -dumpversion @gol\n -fdump-unnumbered -fdump-translation-unit@r{[}-@var{n}@r{]} -fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol\n -fdump-ast-original@r{[}-@var{n}@r{]} -fdump-ast-optimized@r{[}-@var{n}@r{]} @gol\n+-fdump-ast-inlined@r{[}-@var{n}@r{]} @gol\n -fmem-report  -fpretend-float @gol\n -fprofile-arcs  -ftest-coverage  -ftime-report @gol\n -g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-1  -gdwarf-1+  -gdwarf-2 @gol\n@@ -3029,6 +3030,9 @@ The following tree dumps are possible:\n Dump before any tree based optimization, to @file{@var{file}.original}.\n @item optimized\n Dump after all tree based optimization, to @file{@var{file}.optimized}.\n+@item inlined\n+Dump after inlining within the body of the function, to\n+@file{@var{file}.inlined}.\n @end table\n \n @item -fpretend-float\n@@ -3867,8 +3871,8 @@ the directories you have specified with @option{-I} options (and the\n current directory, if appropriate) are searched.  @xref{Directory\n Options}, for information on @option{-I}.\n \n-By using both @option{-nostdinc} and @option{-I-}, you can limit the include-file\n-search path to only those directories you specify explicitly.\n+By using both @option{-nostdinc} and @option{-I-}, you can limit the\n+include-file search path to only those directories you specify explicitly.\n \n @item -remap\n @opindex remap\n@@ -4352,6 +4356,10 @@ system header files (use @option{-isystem} for that).  If you use more than\n one @option{-I} option, the directories are scanned in left-to-right\n order; the standard system directories come after.\n \n+GCC will detect and warn you, if a directory is specified with both the\n+@option{-I} and also is a system search directory (either by default, or\n+with @option{-isystem}).\n+\n @item -I-\n @opindex I-\n Any directories you specify with @option{-I} options before the @option{-I-}"}]}