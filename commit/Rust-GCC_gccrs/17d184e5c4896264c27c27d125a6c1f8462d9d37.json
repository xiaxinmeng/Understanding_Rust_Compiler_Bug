{"sha": "17d184e5c4896264c27c27d125a6c1f8462d9d37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdkMTg0ZTVjNDg5NjI2NGMyN2MyN2QxMjVhNmMxZjg0NjJkOWQzNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-01T08:55:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-01T08:55:50Z"}, "message": "Remove clobber_high\n\nThe AArch64 SVE tlsdesc patterns were the main motivating reason\nfor clobber_high.  It's no longer needed now that the patterns use\ncalls instead.\n\nAt the time, one of the possible future uses for clobber_high was for\nasm statements.  However, the current code wouldn't handle that case\nwithout modification, so I think we might as well remove it for now.\nWe can always reapply it in future if it turns out to be useful again.\n\n2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* rtl.def (CLOBBER_HIGH): Delete.\n\t* doc/rtl.texi (clobber_high): Remove documentation.\n\t* rtl.h (SET_DEST): Remove CLOBBER_HIGH from the list of codes.\n\t(reg_is_clobbered_by_clobber_high): Delete.\n\t(gen_hard_reg_clobber_high): Likewise.\n\t* alias.c (record_set): Remove CLOBBER_HIGH handling.\n\t* cfgexpand.c (expand_gimple_stmt): Likewise.\n\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n\t* combine.c (find_single_use_1, set_nonzero_bits_and_sign_copies)\n\t(can_combine_p, is_parallel_of_n_reg_sets, try_combine)\n\t(record_dead_and_set_regs_1, reg_dead_at_p_1): Likewise.\n\t* cse.c (invalidate_reg): Remove clobber_high parameter.\n\t(invalidate): Update call accordingly.\n\t(canonicalize_insn): Remove CLOBBER_HIGH handling.\n\t(invalidate_from_clobbers, invalidate_from_sets_and_clobbers)\n\t(count_reg_usage, insn_live_p): Likewise.\n\t* cselib.h (cselib_invalidate_rtx): Remove sett argument.\n\t* cselib.c (cselib_invalidate_regno, cselib_invalidate_rtx): Likewise.\n\t(cselib_invalidate_rtx_note_stores): Update call accordingly.\n\t(cselib_expand_value_rtx_1): Remove CLOBBER_HIGH handling.\n\t(cselib_invalidate_regno, cselib_process_insn): Likewise.\n\t* dce.c (deletable_insn_p, mark_nonreg_stores_1): Likewise.\n\t(mark_nonreg_stores_2): Likewise.\n\t* df-scan.c (df_find_hard_reg_defs, df_uses_record): Likewise.\n\t(df_get_call_refs): Likewise.\n\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n\t* emit-rtl.c (verify_rtx_sharing): Likewise.\n\t(copy_insn_1, copy_rtx_if_shared_1): Likewise.\n\t(hard_reg_clobbers_high, gen_hard_reg_clobber_high): Delete.\n\t* genconfig.c (walk_insn_part): Remove CLOBBER_HIGH handling.\n\t* genemit.c (gen_exp, gen_insn): Likewise.\n\t* genrecog.c (validate_pattern, remove_clobbers): Likewise.\n\t* haifa-sched.c (haifa_classify_rtx): Likewise.\n\t* ira-build.c (create_insn_allocnos): Likewise.\n\t* ira-costs.c (scan_one_insn): Likewise.\n\t* ira.c (equiv_init_movable_p, memref_referenced_p): Likewise.\n\t(rtx_moveable_p, interesting_dest_for_shprep): Likewise.\n\t* jump.c (mark_jump_label_1): Likewise.\n\t* lra-int.h (lra_insn_reg::clobber_high): Delete.\n\t* lra-eliminations.c (lra_eliminate_regs_1): Remove CLOBBER_HIGH\n\thandling.\n\t(mark_not_eliminable): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* lra.c (new_insn_reg): Remove clobber_high parameter.\n\t(collect_non_operand_hard_regs): Likewise.  Update call to new\n\tinsn_reg.  Remove CLOBBER_HIGH handling.\n\t(lra_set_insn_recog_data): Remove CLOBBER_HIGH handling.  Update call\n\tto collect_non_operand_hard_regs.\n\t(add_regs_to_insn_regno_info): Remove CLOBBER_HIGH handling.\n\tUpdate call to new_insn_reg.\n\t(lra_update_insn_regno_info): Remove CLOBBER_HIGH handling.\n\t* postreload.c (reload_cse_simplify, reload_combine_note_use)\n\t(move2add_note_store): Likewise.\n\t* print-rtl.c (print_pattern): Likewise.\n\t* recog.c (store_data_bypass_p_1, store_data_bypass_p): Likewise.\n\t(if_test_bypass_p): Likewise.\n\t* regcprop.c (kill_clobbered_value, kill_set_value): Likewise.\n\t* reginfo.c (reg_scan_mark_refs): Likewise.\n\t* reload1.c (maybe_fix_stack_asms, eliminate_regs_1): Likewise.\n\t(elimination_effects, mark_not_eliminable, scan_paradoxical_subregs)\n\t(forget_old_reloads_1): Likewise.\n\t* reorg.c (find_end_label, try_merge_delay_insns, redundant_insn)\n\t(own_thread_p, fill_simple_delay_slots, fill_slots_from_thread)\n\t(dbr_schedule): Likewise.\n\t* resource.c (update_live_status, mark_referenced_resources)\n\t(mark_set_resources): Likewise.\n\t* rtl.c (copy_rtx): Likewise.\n\t* rtlanal.c (reg_referenced_p, set_of_1, single_set_2, noop_move_p)\n\t(note_pattern_stores): Likewise.\n\t(reg_is_clobbered_by_clobber_high): Delete.\n\t* sched-deps.c (sched_analyze_reg, sched_analyze_insn): Remove\n\tCLOBBER_HIGH handling.\n\nFrom-SVN: r276393", "tree": {"sha": "1dca9c9172cc83f10975cf111475bbf1c2327df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dca9c9172cc83f10975cf111475bbf1c2327df6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17d184e5c4896264c27c27d125a6c1f8462d9d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d184e5c4896264c27c27d125a6c1f8462d9d37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17d184e5c4896264c27c27d125a6c1f8462d9d37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17d184e5c4896264c27c27d125a6c1f8462d9d37/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bb6ce448fc194cca8e51aea274a1b2408c7746c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6ce448fc194cca8e51aea274a1b2408c7746c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6ce448fc194cca8e51aea274a1b2408c7746c3"}], "stats": {"total": 602, "additions": 152, "deletions": 450}, "files": [{"sha": "2c515e156fc29e193ca628f15e142891328b7fc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1,3 +1,78 @@\n+2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* rtl.def (CLOBBER_HIGH): Delete.\n+\t* doc/rtl.texi (clobber_high): Remove documentation.\n+\t* rtl.h (SET_DEST): Remove CLOBBER_HIGH from the list of codes.\n+\t(reg_is_clobbered_by_clobber_high): Delete.\n+\t(gen_hard_reg_clobber_high): Likewise.\n+\t* alias.c (record_set): Remove CLOBBER_HIGH handling.\n+\t* cfgexpand.c (expand_gimple_stmt): Likewise.\n+\t* combine-stack-adj.c (single_set_for_csa): Likewise.\n+\t* combine.c (find_single_use_1, set_nonzero_bits_and_sign_copies)\n+\t(can_combine_p, is_parallel_of_n_reg_sets, try_combine)\n+\t(record_dead_and_set_regs_1, reg_dead_at_p_1): Likewise.\n+\t* cse.c (invalidate_reg): Remove clobber_high parameter.\n+\t(invalidate): Update call accordingly.\n+\t(canonicalize_insn): Remove CLOBBER_HIGH handling.\n+\t(invalidate_from_clobbers, invalidate_from_sets_and_clobbers)\n+\t(count_reg_usage, insn_live_p): Likewise.\n+\t* cselib.h (cselib_invalidate_rtx): Remove sett argument.\n+\t* cselib.c (cselib_invalidate_regno, cselib_invalidate_rtx): Likewise.\n+\t(cselib_invalidate_rtx_note_stores): Update call accordingly.\n+\t(cselib_expand_value_rtx_1): Remove CLOBBER_HIGH handling.\n+\t(cselib_invalidate_regno, cselib_process_insn): Likewise.\n+\t* dce.c (deletable_insn_p, mark_nonreg_stores_1): Likewise.\n+\t(mark_nonreg_stores_2): Likewise.\n+\t* df-scan.c (df_find_hard_reg_defs, df_uses_record): Likewise.\n+\t(df_get_call_refs): Likewise.\n+\t* dwarf2out.c (mem_loc_descriptor): Likewise.\n+\t* emit-rtl.c (verify_rtx_sharing): Likewise.\n+\t(copy_insn_1, copy_rtx_if_shared_1): Likewise.\n+\t(hard_reg_clobbers_high, gen_hard_reg_clobber_high): Delete.\n+\t* genconfig.c (walk_insn_part): Remove CLOBBER_HIGH handling.\n+\t* genemit.c (gen_exp, gen_insn): Likewise.\n+\t* genrecog.c (validate_pattern, remove_clobbers): Likewise.\n+\t* haifa-sched.c (haifa_classify_rtx): Likewise.\n+\t* ira-build.c (create_insn_allocnos): Likewise.\n+\t* ira-costs.c (scan_one_insn): Likewise.\n+\t* ira.c (equiv_init_movable_p, memref_referenced_p): Likewise.\n+\t(rtx_moveable_p, interesting_dest_for_shprep): Likewise.\n+\t* jump.c (mark_jump_label_1): Likewise.\n+\t* lra-int.h (lra_insn_reg::clobber_high): Delete.\n+\t* lra-eliminations.c (lra_eliminate_regs_1): Remove CLOBBER_HIGH\n+\thandling.\n+\t(mark_not_eliminable): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* lra.c (new_insn_reg): Remove clobber_high parameter.\n+\t(collect_non_operand_hard_regs): Likewise.  Update call to new\n+\tinsn_reg.  Remove CLOBBER_HIGH handling.\n+\t(lra_set_insn_recog_data): Remove CLOBBER_HIGH handling.  Update call\n+\tto collect_non_operand_hard_regs.\n+\t(add_regs_to_insn_regno_info): Remove CLOBBER_HIGH handling.\n+\tUpdate call to new_insn_reg.\n+\t(lra_update_insn_regno_info): Remove CLOBBER_HIGH handling.\n+\t* postreload.c (reload_cse_simplify, reload_combine_note_use)\n+\t(move2add_note_store): Likewise.\n+\t* print-rtl.c (print_pattern): Likewise.\n+\t* recog.c (store_data_bypass_p_1, store_data_bypass_p): Likewise.\n+\t(if_test_bypass_p): Likewise.\n+\t* regcprop.c (kill_clobbered_value, kill_set_value): Likewise.\n+\t* reginfo.c (reg_scan_mark_refs): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms, eliminate_regs_1): Likewise.\n+\t(elimination_effects, mark_not_eliminable, scan_paradoxical_subregs)\n+\t(forget_old_reloads_1): Likewise.\n+\t* reorg.c (find_end_label, try_merge_delay_insns, redundant_insn)\n+\t(own_thread_p, fill_simple_delay_slots, fill_slots_from_thread)\n+\t(dbr_schedule): Likewise.\n+\t* resource.c (update_live_status, mark_referenced_resources)\n+\t(mark_set_resources): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t* rtlanal.c (reg_referenced_p, set_of_1, single_set_2, noop_move_p)\n+\t(note_pattern_stores): Likewise.\n+\t(reg_is_clobbered_by_clobber_high): Delete.\n+\t* sched-deps.c (sched_analyze_reg, sched_analyze_insn): Remove\n+\tCLOBBER_HIGH handling.\n+\n 2019-10-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR target/91452"}, {"sha": "34e19fe8ca12198e292bcd186f8442b7ffbb52d7", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1556,16 +1556,6 @@ record_set (rtx dest, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n-      /* A CLOBBER_HIGH only wipes out the old value if the mode of the old\n-\t value is greater than that of the clobber.  */\n-      else if (GET_CODE (set) == CLOBBER_HIGH)\n-\t{\n-\t  if (new_reg_base_value[regno] != 0\n-\t      && reg_is_clobbered_by_clobber_high (\n-\t\t   regno, GET_MODE (new_reg_base_value[regno]), XEXP (set, 0)))\n-\t    new_reg_base_value[regno] = 0;\n-\t  return;\n-\t}\n \n       src = SET_SRC (set);\n     }"}, {"sha": "c34a53b526b50d49cd73ab5a5c383efc6da5a23e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -3891,7 +3891,6 @@ expand_gimple_stmt (gimple *stmt)\n \t      /* If we want exceptions for non-call insns, any\n \t\t may_trap_p instruction may throw.  */\n \t      && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH\n \t      && GET_CODE (PATTERN (insn)) != USE\n \t      && insn_could_throw_p (insn))\n \t    make_reg_eh_region_note (insn, 0, lp_nr);"}, {"sha": "d14d59abced05b34309f3241f18ab0190a335ca4", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -133,7 +133,6 @@ single_set_for_csa (rtx_insn *insn)\n \t  && SET_SRC (this_rtx) == SET_DEST (this_rtx))\n \t;\n       else if (GET_CODE (this_rtx) != CLOBBER\n-\t       && GET_CODE (this_rtx) != CLOBBER_HIGH\n \t       && GET_CODE (this_rtx) != USE)\n \treturn NULL_RTX;\n     }"}, {"sha": "d295a81abf968da06124cf588116214633a69a4d", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -572,7 +572,6 @@ find_single_use_1 (rtx dest, rtx *loc)\n     case SYMBOL_REF:\n     CASE_CONST_ANY:\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       return 0;\n \n     case SET:\n@@ -1763,9 +1762,6 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t  return;\n \t}\n \n-      /* Should not happen as we only using pseduo registers.  */\n-      gcc_assert (GET_CODE (set) != CLOBBER_HIGH);\n-\n       /* If this register is being initialized using itself, and the\n \t register is uninitialized in this basic block, and there are\n \t no LOG_LINKS which set the register, then part of the\n@@ -1924,7 +1920,6 @@ can_combine_p (rtx_insn *insn, rtx_insn *i3, rtx_insn *pred ATTRIBUTE_UNUSED,\n \n \t      /* We can ignore CLOBBERs.  */\n \t    case CLOBBER:\n-\t    case CLOBBER_HIGH:\n \t      break;\n \n \t    case SET:\n@@ -2595,8 +2590,6 @@ is_parallel_of_n_reg_sets (rtx pat, int n)\n \tif (XEXP (XVECEXP (pat, 0, i), 0) == const0_rtx)\n \t  return false;\n \tbreak;\n-      case CLOBBER_HIGH:\n-\tbreak;\n       default:\n \treturn false;\n       }\n@@ -2897,8 +2890,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       for (i = 0; ok && i < XVECLEN (p2, 0); i++)\n \t{\n \t  if ((GET_CODE (XVECEXP (p2, 0, i)) == SET\n-\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER\n-\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER_HIGH)\n+\t       || GET_CODE (XVECEXP (p2, 0, i)) == CLOBBER)\n \t      && reg_overlap_mentioned_p (SET_DEST (PATTERN (i3)),\n \t\t\t\t\t  SET_DEST (XVECEXP (p2, 0, i))))\n \t    ok = false;\n@@ -13409,15 +13401,6 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n \t\t\t      ? SET_SRC (setter)\n \t\t\t      : gen_lowpart (GET_MODE (dest),\n \t\t\t\t\t     SET_SRC (setter)));\n-      else if (GET_CODE (setter) == CLOBBER_HIGH)\n-\t{\n-\t  reg_stat_type *rsp = &reg_stat[REGNO (dest)];\n-\t  if (rsp->last_set_value\n-\t      && reg_is_clobbered_by_clobber_high\n-\t\t   (REGNO (dest), GET_MODE (rsp->last_set_value),\n-\t\t    XEXP (setter, 0)))\n-\t    record_value_for_reg (dest, NULL, NULL_RTX);\n-\t}\n       else\n \trecord_value_for_reg (dest, record_dead_insn, NULL_RTX);\n     }\n@@ -13863,10 +13846,6 @@ reg_dead_at_p_1 (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (!REG_P (dest))\n     return;\n \n-  if (GET_CODE (x) == CLOBBER_HIGH\n-      && !reg_is_clobbered_by_clobber_high (reg_dead_reg, XEXP (x, 0)))\n-    return;\n-\n   regno = REGNO (dest);\n   endregno = END_REGNO (dest);\n   if (reg_dead_endregno > regno && reg_dead_regno < endregno)"}, {"sha": "097fb94e7733c2e7c0ef905baec0ec0a0f9be61a", "filename": "gcc/cse.c", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -561,7 +561,6 @@ static struct table_elt *insert_with_costs (rtx, struct table_elt *, unsigned,\n static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n \t\t\t\t machine_mode);\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n-static void invalidate_reg (rtx, bool);\n static void invalidate (rtx, machine_mode);\n static void remove_invalid_refs (unsigned int);\n static void remove_invalid_subreg_refs (unsigned int, poly_uint64,\n@@ -1822,12 +1821,10 @@ check_dependence (const_rtx x, rtx exp, machine_mode mode, rtx addr)\n }\n \n /* Remove from the hash table, or mark as invalid, all expressions whose\n-   values could be altered by storing in register X.\n-\n-   CLOBBER_HIGH is set if X was part of a CLOBBER_HIGH expression.  */\n+   values could be altered by storing in register X.  */\n \n static void\n-invalidate_reg (rtx x, bool clobber_high)\n+invalidate_reg (rtx x)\n {\n   gcc_assert (GET_CODE (x) == REG);\n \n@@ -1852,10 +1849,7 @@ invalidate_reg (rtx x, bool clobber_high)\n   SUBREG_TICKED (regno) = -1;\n \n   if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      gcc_assert (!clobber_high);\n-      remove_pseudo_from_table (x, hash);\n-    }\n+    remove_pseudo_from_table (x, hash);\n   else\n     {\n       HOST_WIDE_INT in_table = TEST_HARD_REG_BIT (hard_regs_in_table, regno);\n@@ -1883,18 +1877,10 @@ invalidate_reg (rtx x, bool clobber_high)\n \t      if (!REG_P (p->exp) || REGNO (p->exp) >= FIRST_PSEUDO_REGISTER)\n \t\tcontinue;\n \n-\t      if (clobber_high)\n-\t\t{\n-\t\t  if (reg_is_clobbered_by_clobber_high (p->exp, x))\n-\t\t    remove_from_table (p, hash);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  unsigned int tregno = REGNO (p->exp);\n-\t\t  unsigned int tendregno = END_REGNO (p->exp);\n-\t\t  if (tendregno > regno && tregno < endregno)\n-\t\t    remove_from_table (p, hash);\n-\t\t}\n+\t      unsigned int tregno = REGNO (p->exp);\n+\t      unsigned int tendregno = END_REGNO (p->exp);\n+\t      if (tendregno > regno && tregno < endregno)\n+\t\tremove_from_table (p, hash);\n \t    }\n     }\n }\n@@ -1921,7 +1907,7 @@ invalidate (rtx x, machine_mode full_mode)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      invalidate_reg (x, false);\n+      invalidate_reg (x);\n       return;\n \n     case SUBREG:\n@@ -4425,8 +4411,6 @@ canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n       if (MEM_P (XEXP (x, 0)))\n \tcanon_reg (XEXP (x, 0), insn);\n     }\n-  else if (GET_CODE (x) == CLOBBER_HIGH)\n-    gcc_assert (REG_P (XEXP (x, 0)));\n   else if (GET_CODE (x) == USE\n \t   && ! (REG_P (XEXP (x, 0))\n \t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER))\n@@ -4458,8 +4442,6 @@ canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n \t      if (MEM_P (XEXP (y, 0)))\n \t\tcanon_reg (XEXP (y, 0), insn);\n \t    }\n-\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n-\t    gcc_assert (REG_P (XEXP (y, 0)));\n \t  else if (GET_CODE (y) == USE\n \t\t   && ! (REG_P (XEXP (y, 0))\n \t\t\t && REGNO (XEXP (y, 0)) < FIRST_PSEUDO_REGISTER))\n@@ -6149,12 +6131,6 @@ invalidate_from_clobbers (rtx_insn *insn)\n \t    invalidate (XEXP (ref, 0), GET_MODE (ref));\n \t}\n     }\n-  if (GET_CODE (x) == CLOBBER_HIGH)\n-    {\n-      rtx ref = XEXP (x, 0);\n-      gcc_assert (REG_P (ref));\n-      invalidate_reg (ref, true);\n-    }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n       int i;\n@@ -6171,12 +6147,6 @@ invalidate_from_clobbers (rtx_insn *insn)\n \t\t       || GET_CODE (ref) == ZERO_EXTRACT)\n \t\tinvalidate (XEXP (ref, 0), GET_MODE (ref));\n \t    }\n-\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n-\t    {\n-\t      rtx ref = XEXP (y, 0);\n-\t      gcc_assert (REG_P (ref));\n-\t      invalidate_reg (ref, true);\n-\t    }\n \t}\n     }\n }\n@@ -6198,12 +6168,6 @@ invalidate_from_sets_and_clobbers (rtx_insn *insn)\n \t  rtx temx = XEXP (tem, 0);\n \t  if (GET_CODE (temx) == CLOBBER)\n \t    invalidate (SET_DEST (temx), VOIDmode);\n-\t  else if (GET_CODE (temx) == CLOBBER_HIGH)\n-\t    {\n-\t      rtx temref = XEXP (temx, 0);\n-\t      gcc_assert (REG_P (temref));\n-\t      invalidate_reg (temref, true);\n-\t    }\n \t}\n     }\n \n@@ -6231,12 +6195,6 @@ invalidate_from_sets_and_clobbers (rtx_insn *insn)\n \t\t       || GET_CODE (clobbered) == ZERO_EXTRACT)\n \t\tinvalidate (XEXP (clobbered, 0), GET_MODE (clobbered));\n \t    }\n-\t  else if (GET_CODE (y) == CLOBBER_HIGH)\n-\t    {\n-\t      rtx ref = XEXP (y, 0);\n-\t      gcc_assert (REG_P (ref));\n-\t      invalidate_reg (ref, true);\n-\t    }\n \t  else if (GET_CODE (y) == SET && GET_CODE (SET_SRC (y)) == CALL)\n \t    invalidate (SET_DEST (y), VOIDmode);\n \t}\n@@ -6896,10 +6854,6 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \tcount_reg_usage (XEXP (XEXP (x, 0), 0), counts, NULL_RTX, incr);\n       return;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (REG_P ((XEXP (x, 0))));\n-      return;\n-\n     case SET:\n       /* Unless we are setting a REG, count everything in SET_DEST.  */\n       if (!REG_P (SET_DEST (x)))\n@@ -6952,8 +6906,7 @@ count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n \t  || (REG_NOTE_KIND (x) != REG_NONNEG && GET_CODE (XEXP (x,0)) == USE)\n \t  /* FUNCTION_USAGE expression lists may include (CLOBBER (mem /u)),\n \t     involving registers in the address.  */\n-\t  || GET_CODE (XEXP (x, 0)) == CLOBBER\n-\t  || GET_CODE (XEXP (x, 0)) == CLOBBER_HIGH)\n+\t  || GET_CODE (XEXP (x, 0)) == CLOBBER)\n \tcount_reg_usage (XEXP (x, 0), counts, NULL_RTX, incr);\n \n       count_reg_usage (XEXP (x, 1), counts, NULL_RTX, incr);\n@@ -7037,9 +6990,7 @@ insn_live_p (rtx_insn *insn, int *counts)\n \t      if (set_live_p (elt, insn, counts))\n \t\treturn true;\n \t    }\n-\t  else if (GET_CODE (elt) != CLOBBER\n-\t\t   && GET_CODE (elt) != CLOBBER_HIGH\n-\t\t   && GET_CODE (elt) != USE)\n+\t  else if (GET_CODE (elt) != CLOBBER && GET_CODE (elt) != USE)\n \t    return true;\n \t}\n       return false;"}, {"sha": "500793ba40eb59001c0b3f3848b86ab61c27b93c", "filename": "gcc/cselib.c", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -55,8 +55,7 @@ static unsigned int cselib_hash_rtx (rtx, int, machine_mode);\n static cselib_val *new_cselib_val (unsigned int, machine_mode, rtx);\n static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n static cselib_val *cselib_lookup_mem (rtx, int);\n-static void cselib_invalidate_regno (unsigned int, machine_mode,\n-\t\t\t\t     const_rtx = NULL);\n+static void cselib_invalidate_regno (unsigned int, machine_mode);\n static void cselib_invalidate_mem (rtx);\n static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n static void cselib_record_sets (rtx_insn *);\n@@ -1663,7 +1662,6 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return orig;\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       if (REG_P (XEXP (orig, 0)) && HARD_REGISTER_NUM_P (REGNO (XEXP (orig, 0))))\n \treturn orig;\n       break;\n@@ -2166,8 +2164,7 @@ cselib_lookup (rtx x, machine_mode mode,\n    invalidating call clobbered registers across a call.  */\n \n static void\n-cselib_invalidate_regno (unsigned int regno, machine_mode mode,\n-\t\t\t const_rtx setter)\n+cselib_invalidate_regno (unsigned int regno, machine_mode mode)\n {\n   unsigned int endregno;\n   unsigned int i;\n@@ -2190,9 +2187,6 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode,\n \ti = regno - max_value_regs;\n \n       endregno = end_hard_regno (mode, regno);\n-\n-      if (setter && GET_CODE (setter) == CLOBBER_HIGH)\n-\tgcc_assert (endregno == regno + 1);\n     }\n   else\n     {\n@@ -2225,19 +2219,6 @@ cselib_invalidate_regno (unsigned int regno, machine_mode mode,\n \t      continue;\n \t    }\n \n-\t  /* Ignore if clobber high and the register isn't clobbered.  */\n-\t  if (setter && GET_CODE (setter) == CLOBBER_HIGH)\n-\t    {\n-\t      gcc_assert (endregno == regno + 1);\n-\t      const_rtx x = XEXP (setter, 0);\n-\t      if (!reg_is_clobbered_by_clobber_high (i, GET_MODE (v->val_rtx),\n-\t\t\t\t\t\t     x))\n-\t\t{\n-\t\t  l = &(*l)->next;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n \t  /* We have an overlap.  */\n \t  if (*l == REG_VALUES (i))\n \t    {\n@@ -2372,29 +2353,29 @@ cselib_invalidate_mem (rtx mem_rtx)\n   *vp = &dummy_val;\n }\n \n-/* Invalidate DEST, which is being assigned to or clobbered by SETTER.  */\n+/* Invalidate DEST.  */\n \n void\n-cselib_invalidate_rtx (rtx dest, const_rtx setter)\n+cselib_invalidate_rtx (rtx dest)\n {\n   while (GET_CODE (dest) == SUBREG\n \t || GET_CODE (dest) == ZERO_EXTRACT\n \t || GET_CODE (dest) == STRICT_LOW_PART)\n     dest = XEXP (dest, 0);\n \n   if (REG_P (dest))\n-    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest), setter);\n+    cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n   else if (MEM_P (dest))\n     cselib_invalidate_mem (dest);\n }\n \n /* A wrapper for cselib_invalidate_rtx to be called via note_stores.  */\n \n static void\n-cselib_invalidate_rtx_note_stores (rtx dest, const_rtx setter,\n+cselib_invalidate_rtx_note_stores (rtx dest, const_rtx,\n \t\t\t\t   void *data ATTRIBUTE_UNUSED)\n {\n-  cselib_invalidate_rtx (dest, setter);\n+  cselib_invalidate_rtx (dest);\n }\n \n /* Record the result of a SET instruction.  DEST is being set; the source\n@@ -2809,11 +2790,9 @@ cselib_process_insn (rtx_insn *insn)\n   if (CALL_P (insn))\n     {\n       for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n-\t{\n-\t  gcc_assert (GET_CODE (XEXP (x, 0)) != CLOBBER_HIGH);\n-\t  if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n-\t    cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0));\n-\t}\n+\tif (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\t  cselib_invalidate_rtx (XEXP (XEXP (x, 0), 0));\n+\n       /* Flush everything on setjmp.  */\n       if (cselib_preserve_constants\n \t  && find_reg_note (insn, REG_SETJMP, NULL))"}, {"sha": "b5854aedc1bc2ea35bcf8511c2d6f44bbdd98032", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -92,7 +92,7 @@ extern bool cselib_dummy_expand_value_rtx_cb (rtx, bitmap, int,\n \t\t\t\t\t      cselib_expand_callback, void *);\n extern rtx cselib_subst_to_values (rtx, machine_mode);\n extern rtx cselib_subst_to_values_from_insn (rtx, machine_mode, rtx_insn *);\n-extern void cselib_invalidate_rtx (rtx, const_rtx = NULL);\n+extern void cselib_invalidate_rtx (rtx);\n \n extern void cselib_reset_table (unsigned int);\n extern unsigned int cselib_get_next_uid (void);"}, {"sha": "2894fa57ba40522f16b2b9b6f14648685def00f7", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -174,7 +174,6 @@ deletable_insn_p (rtx_insn *insn, bool fast, bitmap arg_stores)\n       return false;\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       if (fast)\n \t{\n \t  /* A CLOBBER of a dead pseudo register serves no purpose.\n@@ -244,10 +243,7 @@ static void\n mark_nonreg_stores_1 (rtx dest, const_rtx pattern, void *data)\n {\n   if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n-    {\n-      gcc_checking_assert (GET_CODE (pattern) != CLOBBER_HIGH);\n-      mark_insn ((rtx_insn *) data, true);\n-    }\n+    mark_insn ((rtx_insn *) data, true);\n }\n \n \n@@ -258,10 +254,7 @@ static void\n mark_nonreg_stores_2 (rtx dest, const_rtx pattern, void *data)\n {\n   if (GET_CODE (pattern) != CLOBBER && !REG_P (dest))\n-    {\n-      gcc_checking_assert (GET_CODE (pattern) != CLOBBER_HIGH);\n-      mark_insn ((rtx_insn *) data, false);\n-    }\n+    mark_insn ((rtx_insn *) data, false);\n }\n \n "}, {"sha": "55c03c8fe6374bf24558f3d96fb21fbbf200fb71", "filename": "gcc/df-scan.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -2775,7 +2775,6 @@ df_find_hard_reg_defs (rtx x, HARD_REG_SET *defs)\n       break;\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       df_find_hard_reg_defs_1 (XEXP (x, 0), defs);\n       break;\n \n@@ -2835,10 +2834,6 @@ df_uses_record (class df_collection_rec *collection_rec,\n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (REG_P (XEXP (x, 0)));\n-      return;\n-\n     case MEM:\n       df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD,\n@@ -3133,7 +3128,6 @@ df_get_call_refs (class df_collection_rec *collection_rec,\n   for (note = CALL_INSN_FUNCTION_USAGE (insn_info->insn); note;\n        note = XEXP (note, 1))\n     {\n-      gcc_assert (GET_CODE (XEXP (note, 0)) != CLOBBER_HIGH);\n       if (GET_CODE (XEXP (note, 0)) == USE)\n         df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n \t\t\tDF_REF_REG_USE, bb, insn_info, flags);"}, {"sha": "3df798216b232138ed0279ad4bca64f4c8931966", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -3295,18 +3295,6 @@ There is one other known use for clobbering a pseudo register in a\n clobbered by the insn.  In this case, using the same pseudo register in\n the clobber and elsewhere in the insn produces the expected results.\n \n-@findex clobber_high\n-@item (clobber_high @var{x})\n-Represents the storing or possible storing of an unpredictable,\n-undescribed value into the upper parts of @var{x}. The mode of the expression\n-represents the lower parts of the register which will not be overwritten.\n-@code{reg} must be a reg expression.\n-\n-One place this is used is when calling into functions where the registers are\n-preserved, but only up to a given number of bits.  For example when using\n-Aarch64 SVE, calling a TLS descriptor will cause only the lower 128 bits of\n-each of the vector registers to be preserved.\n-\n @findex use\n @item (use @var{x})\n Represents the use of the value of @var{x}.  It indicates that the\n@@ -3360,8 +3348,7 @@ Represents several side effects performed in parallel.  The square\n brackets stand for a vector; the operand of @code{parallel} is a\n vector of expressions.  @var{x0}, @var{x1} and so on are individual\n side effect expressions---expressions of code @code{set}, @code{call},\n-@code{return}, @code{simple_return}, @code{clobber} @code{use} or\n-@code{clobber_high}.\n+@code{return}, @code{simple_return}, @code{clobber} or @code{use}.\n \n ``In parallel'' means that first all the values used in the individual\n side-effects are computed, and second all the actual side-effects are"}, {"sha": "d33f19b818d75c463f5aff8dc7b8533db24f90fc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -16430,7 +16430,6 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n     case CONST_FIXED:\n     case CLRSB:\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       break;\n \n     case CONST_STRING:"}, {"sha": "feff49aa44f976e312abc20f0a306bc85c67b688", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -2898,7 +2898,6 @@ verify_rtx_sharing (rtx orig, rtx insn)\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return;\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n@@ -3152,7 +3151,6 @@ copy_rtx_if_shared_1 (rtx *orig1)\n       /* SCRATCH must be shared because they represent distinct values.  */\n       return;\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n@@ -5726,7 +5724,6 @@ copy_insn_1 (rtx orig)\n     case SIMPLE_RETURN:\n       return orig;\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       /* Share clobbers of hard registers (like cc0), but do not share pseudo reg\n          clobbers or clobbers of hard registers that originated as pseudos.\n          This is needed to allow safe register renaming.  */\n@@ -6538,21 +6535,6 @@ gen_hard_reg_clobber (machine_mode mode, unsigned int regno)\n \t    gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (mode, regno)));\n }\n \n-static GTY((deletable)) rtx\n-hard_reg_clobbers_high[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n-\n-/* Return a CLOBBER_HIGH expression for register REGNO that clobbers MODE,\n-   caching into HARD_REG_CLOBBERS_HIGH.  */\n-rtx\n-gen_hard_reg_clobber_high (machine_mode mode, unsigned int regno)\n-{\n-  if (hard_reg_clobbers_high[mode][regno])\n-    return hard_reg_clobbers_high[mode][regno];\n-  else\n-    return (hard_reg_clobbers_high[mode][regno]\n-\t    = gen_rtx_CLOBBER_HIGH (VOIDmode, gen_rtx_REG (mode, regno)));\n-}\n-\n location_t prologue_location;\n location_t epilogue_location;\n "}, {"sha": "6f914b1e4fb4d59526e4947a9a2dcc8a8c921ff2", "filename": "gcc/genconfig.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -72,7 +72,6 @@ walk_insn_part (rtx part, int recog_p, int non_pc_set_src)\n   switch (code)\n     {\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       clobbers_seen_this_insn++;\n       break;\n "}, {"sha": "73ed3231cf697f43107f8b8138e48d6b803f1e82", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -169,15 +169,6 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used, md_rtx_info *info)\n \t  return;\n \t}\n       break;\n-    case CLOBBER_HIGH:\n-      if (!REG_P (XEXP (x, 0)))\n-\terror (\"CLOBBER_HIGH argument is not a register expr, at %s:%d\",\n-\t       info->loc.filename, info->loc.lineno);\n-      printf (\"gen_hard_reg_clobber_high (%smode, %i)\",\n-\t      GET_MODE_NAME (GET_MODE (XEXP (x, 0))),\n-\t      REGNO (XEXP (x, 0)));\n-      return;\n-      break;\n     case CC0:\n       printf (\"cc0_rtx\");\n       return;\n@@ -343,8 +334,7 @@ gen_insn (md_rtx_info *info)\n \n       for (i = XVECLEN (insn, 1) - 1; i > 0; i--)\n \t{\n-\t  if (GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER\n-\t      && GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER_HIGH)\n+\t  if (GET_CODE (XVECEXP (insn, 1, i)) != CLOBBER)\n \t    break;\n \n \t  if (REG_P (XEXP (XVECEXP (insn, 1, i), 0)))"}, {"sha": "d38a55ff11af236e33571f6dd47ea14134498205", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -718,7 +718,6 @@ validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n       }\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       validate_pattern (SET_DEST (pattern), info, pattern, '=');\n       return;\n \n@@ -5313,7 +5312,7 @@ remove_clobbers (acceptance_type *acceptance_ptr, rtx *pattern_ptr)\n   for (i = XVECLEN (pattern, 0); i > 0; i--)\n     {\n       rtx x = XVECEXP (pattern, 0, i - 1);\n-      if ((GET_CODE (x) != CLOBBER && GET_CODE (x) != CLOBBER_HIGH)\n+      if (GET_CODE (x) != CLOBBER\n \t  || (!REG_P (XEXP (x, 0))\n \t      && GET_CODE (XEXP (x, 0)) != MATCH_SCRATCH))\n \tbreak;"}, {"sha": "41cf1f362e8c34d009b0a310ff5b9a9ffb613631", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -530,9 +530,6 @@ haifa_classify_rtx (const_rtx x)\n \t  /* Test if it is a 'store'.  */\n \t  tmp_class = may_trap_exp (XEXP (x, 0), 1);\n \t  break;\n-\tcase CLOBBER_HIGH:\n-\t  gcc_assert (REG_P (XEXP (x, 0)));\n-\t  break;\n \tcase SET:\n \t  /* Test if it is a store.  */\n \t  tmp_class = may_trap_exp (SET_DEST (x), 1);"}, {"sha": "222956e22ee420df168120e7ca48e99818e83e89", "filename": "gcc/ira-build.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1873,11 +1873,6 @@ create_insn_allocnos (rtx x, rtx outer, bool output_p)\n       create_insn_allocnos (XEXP (x, 0), NULL, true);\n       return;\n     }\n-  else if (code == CLOBBER_HIGH)\n-    {\n-      gcc_assert (REG_P (XEXP (x, 0)) && HARD_REGISTER_P (XEXP (x, 0)));\n-      return;\n-    }\n   else if (code == MEM)\n     {\n       create_insn_allocnos (XEXP (x, 0), NULL, false);"}, {"sha": "baf7261ddfe66acbaecc827747713e8bc8252d99", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1477,13 +1477,6 @@ scan_one_insn (rtx_insn *insn)\n       return insn;\n     }\n \n-  if (pat_code == CLOBBER_HIGH)\n-    {\n-      gcc_assert (REG_P (XEXP (PATTERN (insn), 0))\n-\t\t  && HARD_REGISTER_P (XEXP (PATTERN (insn), 0)));\n-      return insn;\n-    }\n-\n   counted_mem = false;\n   set = single_set (insn);\n   extract_insn (insn);"}, {"sha": "9f8da67539cfca3720cdcd7ac8342332d2ec5626", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -3063,7 +3063,6 @@ equiv_init_movable_p (rtx x, int regno)\n \n     case CC0:\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       return 0;\n \n     case PRE_INC:\n@@ -3170,7 +3169,6 @@ memref_referenced_p (rtx memref, rtx x, bool read_p)\n       return memref_referenced_p (memref, SET_SRC (x), true);\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       if (process_set_for_memref_referenced_p (memref, XEXP (x, 0)))\n \treturn true;\n \n@@ -4451,7 +4449,6 @@ rtx_moveable_p (rtx *loc, enum op_type type)\n \t      && rtx_moveable_p (&XEXP (x, 2), OP_IN));\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       return rtx_moveable_p (&SET_DEST (x), OP_OUT);\n \n     case UNSPEC_VOLATILE:\n@@ -4904,9 +4901,7 @@ interesting_dest_for_shprep (rtx_insn *insn, basic_block call_dom)\n   for (int i = 0; i < XVECLEN (pat, 0); i++)\n     {\n       rtx sub = XVECEXP (pat, 0, i);\n-      if (GET_CODE (sub) == USE\n-\t  || GET_CODE (sub) == CLOBBER\n-\t  || GET_CODE (sub) == CLOBBER_HIGH)\n+      if (GET_CODE (sub) == USE || GET_CODE (sub) == CLOBBER)\n \tcontinue;\n       if (GET_CODE (sub) != SET\n \t  || side_effects_p (sub))"}, {"sha": "17642a95bf18261709b192281c3d5e499cf97022", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1094,7 +1094,6 @@ mark_jump_label_1 (rtx x, rtx_insn *insn, bool in_mem, bool is_target)\n     case CC0:\n     case REG:\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n     case CALL:\n       return;\n "}, {"sha": "04dc6dfa7c307cb6a406ccd2550cd825747553d0", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -655,7 +655,6 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n       return x;\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n     case SET:\n       gcc_unreachable ();\n \n@@ -808,16 +807,6 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \t    setup_can_eliminate (ep, false);\n       return;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (REG_P (XEXP (x, 0)));\n-      gcc_assert (REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER);\n-      for (ep = reg_eliminate;\n-\t   ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n-\t   ep++)\n-\tif (reg_is_clobbered_by_clobber_high (ep->to_rtx, XEXP (x, 0)))\n-\t  setup_can_eliminate (ep, false);\n-      return;\n-\n     case SET:\n       if (SET_DEST (x) == stack_pointer_rtx\n \t  && GET_CODE (SET_SRC (x)) == PLUS"}, {"sha": "707b5d450db7ea6aef44ef229eb98606130d6a24", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -154,8 +154,6 @@ struct lra_insn_reg\n   /* True if the reg is accessed through a subreg and the subreg is\n      just a part of the register.  */\n   unsigned int subreg_p : 1;\n-  /* True if the reg is clobber highed by the operand.  */\n-  unsigned int clobber_high : 1;\n   /* The corresponding regno of the register.  */\n   int regno;\n   /* Next reg info of the same insn.  */"}, {"sha": "389a79d701dab5f7da566c3c62a2a9e5d75d7e1b", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -668,7 +668,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       bool call_p;\n       int n_alt, dst_regno, src_regno;\n       rtx set;\n-      struct lra_insn_reg *reg, *hr;\n+      struct lra_insn_reg *reg;\n \n       if (!NONDEBUG_INSN_P (curr_insn))\n \tcontinue;\n@@ -700,7 +700,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\tbreak;\n \t      }\n \t  for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\t    if (reg->type != OP_IN && !reg->clobber_high)\n+\t    if (reg->type != OP_IN)\n \t      {\n \t\tremove_p = false;\n \t\tbreak;\n@@ -837,23 +837,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t unused values because they still conflict with quantities\n \t that are live at the time of the definition.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\t{\n-\t  if (reg->type != OP_IN)\n-\t    {\n-\t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n-\t      mark_regno_live (reg->regno, reg->biggest_mode);\n-\t      /* ??? Should be a no-op for unused registers.  */\n-\t      check_pseudos_live_through_calls (reg->regno, last_call_abi);\n-\t    }\n-\n-\t  if (!HARD_REGISTER_NUM_P (reg->regno))\n-\t    for (hr = curr_static_id->hard_regs; hr != NULL; hr = hr->next)\n-\t      if (hr->clobber_high\n-\t\t  && maybe_gt (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno)),\n-\t\t\t       GET_MODE_SIZE (hr->biggest_mode)))\n-\t\tSET_HARD_REG_BIT (lra_reg_info[reg->regno].conflict_hard_regs,\n-\t\t\t\t  hr->regno);\n-\t}\n+\tif (reg->type != OP_IN)\n+\t  {\n+\t    update_pseudo_point (reg->regno, curr_point, USE_POINT);\n+\t    mark_regno_live (reg->regno, reg->biggest_mode);\n+\t    /* ??? Should be a no-op for unused registers.  */\n+\t    check_pseudos_live_through_calls (reg->regno, last_call_abi);\n+\t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type != OP_IN)"}, {"sha": "2c9a29a66a43334d9be649e01ff2959003ca6b4c", "filename": "gcc/lra.c", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -540,13 +540,12 @@ object_allocator<lra_insn_reg> lra_insn_reg_pool (\"insn regs\");\n    is reference through subreg (SUBREG_P), and reference to the next\n    insn reg info (NEXT).  If REGNO can be early clobbered,\n    alternatives in which it can be early clobbered are given by\n-   EARLY_CLOBBER_ALTS.  CLOBBER_HIGH marks if reference is a clobber\n-   high.  */\n+   EARLY_CLOBBER_ALTS.  */\n static struct lra_insn_reg *\n new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n \t      machine_mode mode, bool subreg_p,\n \t      alternative_mask early_clobber_alts,\n-\t      struct lra_insn_reg *next, bool clobber_high)\n+\t      struct lra_insn_reg *next)\n {\n   lra_insn_reg *ir = lra_insn_reg_pool.allocate ();\n   ir->type = type;\n@@ -556,7 +555,6 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n     lra_reg_info[regno].biggest_mode = mode;\n   ir->subreg_p = subreg_p;\n   ir->early_clobber_alts = early_clobber_alts;\n-  ir->clobber_high = clobber_high;\n   ir->regno = regno;\n   ir->next = next;\n   return ir;\n@@ -824,13 +822,12 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n    not the insn operands, in X with TYPE (in/out/inout) and flag that\n    it is early clobbered in the insn (EARLY_CLOBBER) and add the info\n    to LIST.  X is a part of insn given by DATA.\t Return the result\n-   list.  CLOBBER_HIGH marks if X is a clobber high.  */\n+   list.  */\n static struct lra_insn_reg *\n collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t\t\t       lra_insn_recog_data_t data,\n \t\t\t       struct lra_insn_reg *list,\n-\t\t\t       enum op_type type, bool early_clobber,\n-\t\t\t       bool clobber_high)\n+\t\t\t       enum op_type type, bool early_clobber)\n {\n   int i, j, regno, last;\n   bool subreg_p;\n@@ -890,8 +887,7 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t\t\t && regno <= LAST_STACK_REG));\n #endif\n \t      list = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list,\n-\t\t\t\t   clobber_high);\n+\t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list);\n \t    }\n \t}\n       return list;\n@@ -900,44 +896,36 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n     {\n     case SET:\n       list = collect_non_operand_hard_regs (insn, &SET_DEST (op), data,\n-\t\t\t\t\t    list, OP_OUT, false, false);\n+\t\t\t\t\t    list, OP_OUT, false);\n       list = collect_non_operand_hard_regs (insn, &SET_SRC (op), data,\n-\t\t\t\t\t    list, OP_IN, false, false);\n+\t\t\t\t\t    list, OP_IN, false);\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early clobber.  */\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_OUT, true, false);\n-      break;\n-    case CLOBBER_HIGH:\n-      /* Clobber high should always span exactly one register.  */\n-      gcc_assert (REG_NREGS (XEXP (op, 0)) == 1);\n-      /* We treat clobber of non-operand hard registers as early clobber.  */\n-      list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_OUT, true, true);\n+\t\t\t\t\t    list, OP_OUT, true);\n       break;\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_INOUT, false, false);\n+\t\t\t\t\t    list, OP_INOUT, false);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_INOUT, false, false);\n+\t\t\t\t\t    list, OP_INOUT, false);\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 1), data,\n-\t\t\t\t\t    list, OP_IN, false, false);\n+\t\t\t\t\t    list, OP_IN, false);\n       break;\n     default:\n       fmt = GET_RTX_FORMAT (code);\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n \t    list = collect_non_operand_hard_regs (insn, &XEXP (op, i), data,\n-\t\t\t\t\t\t  list, OP_IN, false, false);\n+\t\t\t\t\t\t  list, OP_IN, false);\n \t  else if (fmt[i] == 'E')\n \t    for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n \t      list = collect_non_operand_hard_regs (insn, &XVECEXP (op, i, j),\n-\t\t\t\t\t\t    data, list, OP_IN, false,\n-\t\t\t\t\t\t    false);\n+\t\t\t\t\t\t    data, list, OP_IN, false);\n \t}\n     }\n   return list;\n@@ -1086,7 +1074,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n   else\n     insn_static_data->hard_regs\n       = collect_non_operand_hard_regs (insn, &PATTERN (insn), data,\n-\t\t\t\t       NULL, OP_IN, false, false);\n+\t\t\t\t       NULL, OP_IN, false);\n   data->arg_hard_regs = NULL;\n   if (CALL_P (insn))\n     {\n@@ -1112,10 +1100,6 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t      arg_hard_regs[n_hard_regs++]\n \t\t= regno + i + (use_p ? 0 : FIRST_PSEUDO_REGISTER);\n \t  }\n-\telse if (GET_CODE (XEXP (link, 0)) == CLOBBER_HIGH)\n-\t  /* We could support CLOBBER_HIGH and treat it in the same way as\n-\t     HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n-\t  gcc_unreachable ();\n \n       if (n_hard_regs != 0)\n \t{\n@@ -1475,7 +1459,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n       if (bitmap_set_bit (&lra_reg_info[regno].insn_bitmap, INSN_UID (insn)))\n \t{\n \t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n-\t\t\t\t     early_clobber_alts, data->regs, false);\n+\t\t\t\t     early_clobber_alts, data->regs);\n \t  return;\n \t}\n       else\n@@ -1488,7 +1472,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n \t\t     structure.  */\n \t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n \t\t\t\t\t     subreg_p, early_clobber_alts,\n-\t\t\t\t\t     data->regs, false);\n+\t\t\t\t\t     data->regs);\n \t\telse\n \t\t  {\n \t\t    if (curr->type != type)\n@@ -1513,8 +1497,6 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_OUT,\n \t\t\t\t   ALL_ALTERNATIVES);\n       break;\n-    case CLOBBER_HIGH:\n-      gcc_unreachable ();\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, 0);\n       break;\n@@ -1650,9 +1632,6 @@ lra_update_insn_regno_info (rtx_insn *insn)\n \t link = XEXP (link, 1))\n       {\n \tcode = GET_CODE (XEXP (link, 0));\n-\t/* We could support CLOBBER_HIGH and treat it in the same way as\n-\t   HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n-\tgcc_assert (code != CLOBBER_HIGH);\n \tif ((code == USE || code == CLOBBER)\n \t    && MEM_P (XEXP (XEXP (link, 0), 0)))\n \t  add_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), insn,"}, {"sha": "12d74fcc0504fd657bdba28671e67572314bb65f", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -134,8 +134,6 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    {\n \t      rtx part = XVECEXP (body, 0, i);\n-\t      /* asms can only have full clobbers, not clobber_highs.  */\n-\t      gcc_assert (GET_CODE (part) != CLOBBER_HIGH);\n \t      if (GET_CODE (part) == CLOBBER && REG_P (XEXP (part, 0)))\n \t\tcselib_invalidate_rtx (XEXP (part, 0));\n \t    }\n@@ -158,9 +156,7 @@ reload_cse_simplify (rtx_insn *insn, rtx testreg)\n \t\t  value = SET_DEST (part);\n \t\t}\n \t    }\n-\t  else if (GET_CODE (part) != CLOBBER\n-\t\t   && GET_CODE (part) != CLOBBER_HIGH\n-\t\t   && GET_CODE (part) != USE)\n+\t  else if (GET_CODE (part) != CLOBBER && GET_CODE (part) != USE)\n \t    break;\n \t}\n \n@@ -1515,10 +1511,6 @@ reload_combine_note_use (rtx *xp, rtx_insn *insn, int ruid, rtx containing_mem)\n \t}\n       break;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (REG_P (SET_DEST (x)));\n-      return;\n-\n     case PLUS:\n       /* We are interested in (plus (reg) (const_int)) .  */\n       if (!REG_P (XEXP (x, 0))\n@@ -2284,13 +2276,6 @@ move2add_note_store (rtx dst, const_rtx set, void *data)\n \n       move2add_record_mode (dst);\n     }\n-  else if (GET_CODE (set) == CLOBBER_HIGH)\n-    {\n-      /* Only invalidate if actually clobbered.  */\n-      if (reg_mode[regno] == BLKmode\n-\t  || reg_is_clobbered_by_clobber_high (regno, reg_mode[regno], dst))\n-\t goto invalidate;\n-    }\n   else\n     {\n     invalidate:"}, {"sha": "b0ee30010b22f183149016e42c95117129fc46b1", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1763,7 +1763,6 @@ print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n       print_exp (pp, x, verbose);\n       break;\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n     case USE:\n       pp_printf (pp, \"%s \", GET_RTX_NAME (GET_CODE (x)));\n       print_value (pp, XEXP (x, 0), verbose);"}, {"sha": "9e9cca7db024cc81f638c38ee179aa6ffee9eda6", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -3726,8 +3726,7 @@ store_data_bypass_p_1 (rtx_insn *out_insn, rtx in_set)\n     {\n       rtx out_exp = XVECEXP (out_pat, 0, i);\n \n-      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE\n-\t  || GET_CODE (out_exp) == CLOBBER_HIGH)\n+      if (GET_CODE (out_exp) == CLOBBER || GET_CODE (out_exp) == USE)\n \tcontinue;\n \n       gcc_assert (GET_CODE (out_exp) == SET);\n@@ -3758,8 +3757,7 @@ store_data_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n     {\n       rtx in_exp = XVECEXP (in_pat, 0, i);\n \n-      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE\n-\t  || GET_CODE (in_exp) == CLOBBER_HIGH)\n+      if (GET_CODE (in_exp) == CLOBBER || GET_CODE (in_exp) == USE)\n \tcontinue;\n \n       gcc_assert (GET_CODE (in_exp) == SET);\n@@ -3811,7 +3809,7 @@ if_test_bypass_p (rtx_insn *out_insn, rtx_insn *in_insn)\n \t{\n \t  rtx exp = XVECEXP (out_pat, 0, i);\n \n-\t  if (GET_CODE (exp) == CLOBBER  || GET_CODE (exp) == CLOBBER_HIGH)\n+\t  if (GET_CODE (exp) == CLOBBER)\n \t    continue;\n \n \t  gcc_assert (GET_CODE (exp) == SET);"}, {"sha": "4b0b53f6b3f7acdea7b10260c8c6ce912ac7e1a4", "filename": "gcc/regcprop.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -238,11 +238,8 @@ static void\n kill_clobbered_value (rtx x, const_rtx set, void *data)\n {\n   struct value_data *const vd = (struct value_data *) data;\n-  gcc_assert (GET_CODE (set) != CLOBBER_HIGH || REG_P (x));\n \n-  if (GET_CODE (set) == CLOBBER\n-      || (GET_CODE (set) == CLOBBER_HIGH\n-\t  && reg_is_clobbered_by_clobber_high (x, XEXP (set, 0))))\n+  if (GET_CODE (set) == CLOBBER)\n     kill_value (x, vd);\n }\n \n@@ -263,8 +260,7 @@ kill_set_value (rtx x, const_rtx set, void *data)\n   if (rtx_equal_p (x, ksvd->ignore_set_reg))\n     return;\n \n-  gcc_assert (GET_CODE (set) != CLOBBER_HIGH || REG_P (x));\n-  if (GET_CODE (set) != CLOBBER && GET_CODE (set) != CLOBBER_HIGH)\n+  if (GET_CODE (set) != CLOBBER)\n     {\n       kill_value (x, ksvd->vd);\n       if (REG_P (x))"}, {"sha": "6bed844ac94fb65d17dab9bd464df3890c97f9a3", "filename": "gcc/reginfo.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1025,10 +1025,6 @@ reg_scan_mark_refs (rtx x, rtx_insn *insn)\n \treg_scan_mark_refs (XEXP (XEXP (x, 0), 0), insn);\n       break;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (!(MEM_P (XEXP (x, 0))));\n-      break;\n-\n     case SET:\n       /* Count a set of the destination if it is a register.  */\n       for (dest = SET_DEST (x);"}, {"sha": "2d96fe9433df3b643f3e31074641c4722a50e89a", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1337,8 +1337,6 @@ maybe_fix_stack_asms (void)\n \t  rtx t = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (t) == CLOBBER && STACK_REG_P (XEXP (t, 0)))\n \t    SET_HARD_REG_BIT (clobbered, REGNO (XEXP (t, 0)));\n-\t  /* CLOBBER_HIGH is only supported for LRA.  */\n-\t  gcc_assert (GET_CODE (t) != CLOBBER_HIGH);\n \t}\n \n       /* Get the operand values and constraints out of the insn.  */\n@@ -2879,7 +2877,6 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n       return x;\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n     case ASM_OPERANDS:\n       gcc_assert (insn && DEBUG_INSN_P (insn));\n       break;\n@@ -3090,10 +3087,6 @@ elimination_effects (rtx x, machine_mode mem_mode)\n       elimination_effects (XEXP (x, 0), mem_mode);\n       return;\n \n-    case CLOBBER_HIGH:\n-      /* CLOBBER_HIGH is only supported for LRA.  */\n-      return;\n-\n     case SET:\n       /* Check for setting a register that we know about.  */\n       if (REG_P (SET_DEST (x)))\n@@ -3725,9 +3718,6 @@ mark_not_eliminable (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (dest == hard_frame_pointer_rtx)\n     return;\n \n-  /* CLOBBER_HIGH is only supported for LRA.  */\n-  gcc_assert (GET_CODE (x) != CLOBBER_HIGH);\n-\n   for (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n     if (reg_eliminate[i].can_eliminate && dest == reg_eliminate[i].to_rtx\n \t&& (GET_CODE (x) != SET\n@@ -4355,7 +4345,6 @@ scan_paradoxical_subregs (rtx x)\n     case PC:\n     case USE:\n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       return;\n \n     case SUBREG:\n@@ -4809,8 +4798,7 @@ reload_as_needed (int live_known)\n    to be forgotten later.  */\n \n static void\n-forget_old_reloads_1 (rtx x, const_rtx setter,\n-\t\t      void *data)\n+forget_old_reloads_1 (rtx x, const_rtx, void *data)\n {\n   unsigned int regno;\n   unsigned int nr;\n@@ -4829,9 +4817,6 @@ forget_old_reloads_1 (rtx x, const_rtx setter,\n   if (!REG_P (x))\n     return;\n \n-  /* CLOBBER_HIGH is only supported for LRA.  */\n-  gcc_assert (setter == NULL_RTX || GET_CODE (setter) != CLOBBER_HIGH);\n-\n   regno = REGNO (x);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)"}, {"sha": "cba183e9c72817e67a9222be5089fb956f38f41b", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -410,8 +410,7 @@ find_end_label (rtx kind)\n   while (NOTE_P (insn)\n \t || (NONJUMP_INSN_P (insn)\n \t     && (GET_CODE (PATTERN (insn)) == USE\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER_HIGH)))\n+\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n     insn = PREV_INSN (insn);\n \n   /* When a target threads its epilogue we might already have a\n@@ -1311,8 +1310,7 @@ try_merge_delay_insns (rtx_insn *insn, rtx_insn *thread)\n \n       /* TRIAL must be a CALL_INSN or INSN.  Skip USE and CLOBBER.  */\n       if (NONJUMP_INSN_P (trial)\n-\t  && (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t      || GET_CODE (pat) == CLOBBER_HIGH))\n+\t  && (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER))\n \tcontinue;\n \n       if (GET_CODE (next_to_match) == GET_CODE (trial)\n@@ -1506,8 +1504,7 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n       --insns_to_search;\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t  || GET_CODE (pat) == CLOBBER_HIGH)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -1605,8 +1602,7 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n       --insns_to_search;\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t  || GET_CODE (pat) == CLOBBER_HIGH)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -1718,8 +1714,7 @@ own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n \t|| LABEL_P (insn)\n \t|| (NONJUMP_INSN_P (insn)\n \t    && GET_CODE (PATTERN (insn)) != USE\n-\t    && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t    && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH))\n+\t    && GET_CODE (PATTERN (insn)) != CLOBBER))\n       return 0;\n \n   return 1;\n@@ -2042,8 +2037,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      pat = PATTERN (trial);\n \n \t      /* Stand-alone USE and CLOBBER are just for flow.  */\n-\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t\t  || GET_CODE (pat) == CLOBBER_HIGH)\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \t\tcontinue;\n \n \t      /* And DEBUG_INSNs never go into delay slots.  */\n@@ -2169,8 +2163,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t      pat = PATTERN (trial);\n \n \t      /* Stand-alone USE and CLOBBER are just for flow.  */\n-\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t\t  || GET_CODE (pat) == CLOBBER_HIGH)\n+\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \t\tcontinue;\n \n \t      /* And DEBUG_INSNs do not go in delay slots.  */\n@@ -2438,8 +2431,7 @@ fill_slots_from_thread (rtx_jump_insn *insn, rtx condition,\n \t}\n \n       pat = PATTERN (trial);\n-      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER\n-\t  || GET_CODE (pat) == CLOBBER_HIGH)\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \tcontinue;\n \n       if (GET_CODE (trial) == DEBUG_INSN)\n@@ -3833,8 +3825,7 @@ dbr_schedule (rtx_insn *first)\n \t  if (! insn->deleted ()\n \t      && NONJUMP_INSN_P (insn)\n \t      && GET_CODE (PATTERN (insn)) != USE\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t      && GET_CODE (PATTERN (insn)) != CLOBBER_HIGH)\n+\t      && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    {\n \t      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t\t{"}, {"sha": "bf2d6beaf39e6ceaa3d5793e352606d373d61751", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -109,11 +109,6 @@ update_live_status (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n   if (GET_CODE (x) == CLOBBER)\n     for (i = first_regno; i < last_regno; i++)\n       CLEAR_HARD_REG_BIT (current_live_regs, i);\n-  else if (GET_CODE (x) == CLOBBER_HIGH)\n-    /* No current target supports both branch delay slots and CLOBBER_HIGH.\n-       We'd need more elaborate liveness tracking to handle that\n-       combination.  */\n-    gcc_unreachable ();\n   else\n     for (i = first_regno; i < last_regno; i++)\n       {\n@@ -299,7 +294,6 @@ mark_referenced_resources (rtx x, struct resources *res,\n       return;\n \n     case CLOBBER:\n-    case CLOBBER_HIGH:\n       return;\n \n     case CALL_INSN:\n@@ -670,15 +664,9 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n \n \t  for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n \t       link; link = XEXP (link, 1))\n-\t    {\n-\t      /* We could support CLOBBER_HIGH and treat it in the same way as\n-\t\t HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that\n-\t\t yet.  */\n-\t      gcc_assert (GET_CODE (XEXP (link, 0)) != CLOBBER_HIGH);\n-\t      if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t\tmark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n-\t\t\t\t    MARK_SRC_DEST);\n-\t    }\n+\t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n+\t      mark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n+\t\t\t\t  MARK_SRC_DEST);\n \n \t  /* Check for a REG_SETJMP.  If it exists, then we must\n \t     assume that this call can clobber any register.  */\n@@ -721,12 +709,6 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n       mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n \n-    case CLOBBER_HIGH:\n-      /* No current target supports both branch delay slots and CLOBBER_HIGH.\n-\t We'd need more elaborate liveness tracking to handle that\n-\t combination.  */\n-      gcc_unreachable ();\n-\n     case SEQUENCE:\n       {\n         rtx_sequence *seq = as_a <rtx_sequence *> (x);"}, {"sha": "8822ff694592f37024c97dcd0ce61c2a00ff13bd", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -310,10 +310,6 @@ copy_rtx (rtx orig)\n \treturn orig;\n       break;\n \n-    case CLOBBER_HIGH:\n-\tgcc_assert (REG_P (XEXP (orig, 0)));\n-\treturn orig;\n-\n     case CONST:\n       if (shared_const_p (orig))\n \treturn orig;"}, {"sha": "d8683a9d9b950888c4480cf8151f78f982066b55", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -312,16 +312,6 @@ DEF_RTL_EXPR(USE, \"use\", \"e\", RTX_EXTRA)\n    is considered undeletable before reload.  */\n DEF_RTL_EXPR(CLOBBER, \"clobber\", \"e\", RTX_EXTRA)\n \n-/* Indicate that the upper parts of something are clobbered in a way that we\n-   don't want to explain.  The MODE references the lower bits that will be\n-   preserved.  Anything above that size will be clobbered.\n-\n-   CLOBBER_HIGH only occurs as the operand of a PARALLEL rtx.  It cannot appear\n-   in other contexts, and unlike CLOBBER, it cannot appear on its own.\n-   CLOBBER_HIGH can only be used with fixed register rtxes.  */\n-\n-DEF_RTL_EXPR(CLOBBER_HIGH, \"clobber_high\", \"e\", RTX_EXTRA)\n-\n /* Call a subroutine.\n    Operand 1 is the address to call.\n    Operand 2 is the number of arguments.  */"}, {"sha": "1369e66a13619b04886e6cc4cb8298c13b322bf5", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -2679,7 +2679,7 @@ do {\t\t\t\t\t\t\t\t        \\\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n-#define SET_DEST(RTX) XC3EXP (RTX, 0, SET, CLOBBER, CLOBBER_HIGH)\n+#define SET_DEST(RTX) XC2EXP (RTX, 0, SET, CLOBBER)\n #define SET_SRC(RTX) XCEXP (RTX, 1, SET)\n #define SET_IS_RETURN_P(RTX)\t\t\t\t\t\t\\\n   (RTL_FLAG_CHECK1 (\"SET_IS_RETURN_P\", (RTX), SET)->jump)\n@@ -3524,16 +3524,6 @@ extern rtx tablejump_casesi_pattern (const rtx_insn *insn);\n extern int computed_jump_p (const rtx_insn *);\n extern bool tls_referenced_p (const_rtx);\n extern bool contains_mem_rtx_p (rtx x);\n-extern bool reg_is_clobbered_by_clobber_high (unsigned int, machine_mode,\n-\t\t\t\t\t      const_rtx);\n-\n-/* Convenient wrapper for reg_is_clobbered_by_clobber_high.  */\n-inline bool\n-reg_is_clobbered_by_clobber_high (const_rtx x, const_rtx clobber_high_op)\n-{\n-  return reg_is_clobbered_by_clobber_high (REGNO (x), GET_MODE (x),\n-\t\t\t\t\t   clobber_high_op);\n-}\n \n /* Overload for refers_to_regno_p for checking a single register.  */\n inline bool\n@@ -4330,7 +4320,6 @@ extern void vt_equate_reg_base_value (const_rtx, const_rtx);\n extern bool memory_modified_in_insn_p (const_rtx, const_rtx);\n extern bool may_be_sp_based_p (rtx);\n extern rtx gen_hard_reg_clobber (machine_mode, unsigned int);\n-extern rtx gen_hard_reg_clobber_high (machine_mode, unsigned int);\n extern rtx get_reg_known_value (unsigned int);\n extern bool get_reg_known_equiv_p (unsigned int);\n extern rtx get_reg_base_value (unsigned int);"}, {"sha": "720aa093a23f37b77ca3e3c3aaece90683b66d2f", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -1216,10 +1216,6 @@ reg_referenced_p (const_rtx x, const_rtx body)\n \t  return 1;\n       return 0;\n \n-    case CLOBBER_HIGH:\n-      gcc_assert (REG_P (XEXP (body, 0)));\n-      return 0;\n-\n     case COND_EXEC:\n       if (reg_overlap_mentioned_p (x, COND_EXEC_TEST (body)))\n \treturn 1;\n@@ -1442,11 +1438,7 @@ set_of_1 (rtx x, const_rtx pat, void *data1)\n {\n   struct set_of_data *const data = (struct set_of_data *) (data1);\n   if (rtx_equal_p (x, data->pat)\n-      || (GET_CODE (pat) == CLOBBER_HIGH\n-\t  && REGNO(data->pat) == REGNO(XEXP (pat, 0))\n-\t  && reg_is_clobbered_by_clobber_high (data->pat, XEXP (pat, 0)))\n-      || (GET_CODE (pat) != CLOBBER_HIGH && !MEM_P (x)\n-\t  && reg_overlap_mentioned_p (data->pat, x)))\n+      || (!MEM_P (x) && reg_overlap_mentioned_p (data->pat, x)))\n     data->found = pat;\n }\n \n@@ -1533,7 +1525,6 @@ single_set_2 (const rtx_insn *insn, const_rtx pat)\n \t    {\n \t    case USE:\n \t    case CLOBBER:\n-\t    case CLOBBER_HIGH:\n \t      break;\n \n \t    case SET:\n@@ -1687,9 +1678,7 @@ noop_move_p (const rtx_insn *insn)\n \t{\n \t  rtx tem = XVECEXP (pat, 0, i);\n \n-\t  if (GET_CODE (tem) == USE\n-\t      || GET_CODE (tem) == CLOBBER\n-\t      || GET_CODE (tem) == CLOBBER_HIGH)\n+\t  if (GET_CODE (tem) == USE || GET_CODE (tem) == CLOBBER)\n \t    continue;\n \n \t  if (GET_CODE (tem) != SET || ! set_noop_p (tem))\n@@ -1923,9 +1912,7 @@ note_pattern_stores (const_rtx x,\n   if (GET_CODE (x) == COND_EXEC)\n     x = COND_EXEC_CODE (x);\n \n-  if (GET_CODE (x) == SET\n-      || GET_CODE (x) == CLOBBER\n-      || GET_CODE (x) == CLOBBER_HIGH)\n+  if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n       rtx dest = SET_DEST (x);\n \n@@ -6658,32 +6645,3 @@ tls_referenced_p (const_rtx x)\n       return true;\n   return false;\n }\n-\n-/* Return true if reg REGNO with mode REG_MODE would be clobbered by the\n-   clobber_high operand in CLOBBER_HIGH_OP.  */\n-\n-bool\n-reg_is_clobbered_by_clobber_high (unsigned int regno, machine_mode reg_mode,\n-\t\t\t\t  const_rtx clobber_high_op)\n-{\n-  unsigned int clobber_regno = REGNO (clobber_high_op);\n-  machine_mode clobber_mode = GET_MODE (clobber_high_op);\n-  unsigned char regno_nregs = hard_regno_nregs (regno, reg_mode);\n-\n-  /* Clobber high should always span exactly one register.  */\n-  gcc_assert (REG_NREGS (clobber_high_op) == 1);\n-\n-  /* Clobber high needs to match with one of the registers in X.  */\n-  if (clobber_regno < regno || clobber_regno >= regno + regno_nregs)\n-    return false;\n-\n-  gcc_assert (reg_mode != BLKmode && clobber_mode != BLKmode);\n-\n-  if (reg_mode == VOIDmode)\n-    return clobber_mode != VOIDmode;\n-\n-  /* Clobber high will clobber if its size might be greater than the size of\n-     register regno.  */\n-  return maybe_gt (exact_div (GET_MODE_SIZE (reg_mode), regno_nregs),\n-\t\t GET_MODE_SIZE (clobber_mode));\n-}"}, {"sha": "308db4e3ca0458a15a33707cfc91099254bed13d", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17d184e5c4896264c27c27d125a6c1f8462d9d37/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=17d184e5c4896264c27c27d125a6c1f8462d9d37", "patch": "@@ -2320,13 +2320,6 @@ sched_analyze_reg (class deps_desc *deps, int regno, machine_mode mode,\n \t  while (--i >= 0)\n \t    note_reg_use (regno + i);\n \t}\n-      else if (ref == CLOBBER_HIGH)\n-\t{\n-\t  gcc_assert (i == 1);\n-\t  /* We don't know the current state of the register, so have to treat\n-\t     the clobber high as a full clobber.  */\n-\t  note_reg_clobber (regno);\n-\t}\n       else\n \t{\n \t  while (--i >= 0)\n@@ -2350,8 +2343,6 @@ sched_analyze_reg (class deps_desc *deps, int regno, machine_mode mode,\n       else if (ref == USE)\n \tnote_reg_use (regno);\n       else\n-\t/* For CLOBBER_HIGH, we don't know the current state of the register,\n-\t   so have to treat it as a full clobber.  */\n \tnote_reg_clobber (regno);\n \n       /* Pseudos that are REG_EQUIV to something may be replaced\n@@ -2974,7 +2965,7 @@ sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n \t      sub = COND_EXEC_CODE (sub);\n \t      code = GET_CODE (sub);\n \t    }\n-\t  else if (code == SET || code == CLOBBER || code == CLOBBER_HIGH)\n+\t  else if (code == SET || code == CLOBBER)\n \t    sched_analyze_1 (deps, sub, insn);\n \t  else\n \t    sched_analyze_2 (deps, sub, insn);\n@@ -2990,10 +2981,6 @@ sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n \t{\n \t  if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n \t    sched_analyze_1 (deps, XEXP (link, 0), insn);\n-\t  else if (GET_CODE (XEXP (link, 0)) == CLOBBER_HIGH)\n-\t    /* We could support CLOBBER_HIGH and treat it in the same way as\n-\t      HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n-\t    gcc_unreachable ();\n \t  else if (GET_CODE (XEXP (link, 0)) != SET)\n \t    sched_analyze_2 (deps, XEXP (link, 0), insn);\n \t}"}]}