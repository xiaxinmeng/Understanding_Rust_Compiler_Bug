{"sha": "a696bc4fec986318a1765c31ac9ee2db3849934a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY5NmJjNGZlYzk4NjMxOGExNzY1YzMxYWM5ZWUyZGIzODQ5OTM0YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:02:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:02:46Z"}, "message": "poly_int: loop versioning threshold\n\nThis patch splits the loop versioning threshold out from the\ncost model threshold so that the former can become a poly_uint64.\nWe still use a single test to enforce both limits where possible.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_loop_vec_info): Add a versioning_threshold\n\tfield.\n\t(LOOP_VINFO_VERSIONING_THRESHOLD): New macro\n\t(vect_loop_versioning): Take the loop versioning threshold as a\n\tseparate parameter.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n\tversioning_threshold.\n\t(vect_analyze_loop_2): Compute the loop versioning threshold\n\twhenever loop versioning is needed, and store it in the new\n\tfield rather than combining it with the cost model threshold.\n\t(vect_transform_loop): Update call to vect_loop_versioning.\n\tTry to combine the loop versioning and cost thresholds here.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255934", "tree": {"sha": "b024ac8449c4eccf850126c2747e34a781b7931b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b024ac8449c4eccf850126c2747e34a781b7931b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a696bc4fec986318a1765c31ac9ee2db3849934a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a696bc4fec986318a1765c31ac9ee2db3849934a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a696bc4fec986318a1765c31ac9ee2db3849934a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a696bc4fec986318a1765c31ac9ee2db3849934a/comments", "author": null, "committer": null, "parents": [{"sha": "d2fd6a04f958346c6311113f4244540ac28efef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2fd6a04f958346c6311113f4244540ac28efef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2fd6a04f958346c6311113f4244540ac28efef2"}], "stats": {"total": 67, "additions": 57, "deletions": 10}, "files": [{"sha": "2a69053477cd363d45c5c410e50a5e86187e8aff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a696bc4fec986318a1765c31ac9ee2db3849934a", "patch": "@@ -1,3 +1,21 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (_loop_vec_info): Add a versioning_threshold\n+\tfield.\n+\t(LOOP_VINFO_VERSIONING_THRESHOLD): New macro\n+\t(vect_loop_versioning): Take the loop versioning threshold as a\n+\tseparate parameter.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n+\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Initialize\n+\tversioning_threshold.\n+\t(vect_analyze_loop_2): Compute the loop versioning threshold\n+\twhenever loop versioning is needed, and store it in the new\n+\tfield rather than combining it with the cost model threshold.\n+\t(vect_transform_loop): Update call to vect_loop_versioning.\n+\tTry to combine the loop versioning and cost thresholds here.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "4b02a58313ef178875c8b753afae1985f4b6a7cb", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=a696bc4fec986318a1765c31ac9ee2db3849934a", "patch": "@@ -2154,7 +2154,8 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n \n void\n vect_loop_versioning (loop_vec_info loop_vinfo,\n-\t\t      unsigned int th, bool check_profitability)\n+\t\t      unsigned int th, bool check_profitability,\n+\t\t      poly_uint64 versioning_threshold)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo), *nloop;\n   struct loop *scalar_loop = LOOP_VINFO_SCALAR_LOOP (loop_vinfo);\n@@ -2179,6 +2180,17 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n     cond_expr = fold_build2 (GE_EXPR, boolean_type_node, scalar_loop_iters,\n \t\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters),\n \t\t\t\t\t    th - 1));\n+  if (maybe_ne (versioning_threshold, 0U))\n+    {\n+      tree expr = fold_build2 (GE_EXPR, boolean_type_node, scalar_loop_iters,\n+\t\t\t       build_int_cst (TREE_TYPE (scalar_loop_iters),\n+\t\t\t\t\t      versioning_threshold - 1));\n+      if (cond_expr)\n+\tcond_expr = fold_build2 (BIT_AND_EXPR, boolean_type_node,\n+\t\t\t\t expr, cond_expr);\n+      else\n+\tcond_expr = expr;\n+    }\n \n   if (version_niter)\n     vect_create_cond_for_niters_checks (loop_vinfo, &cond_expr);"}, {"sha": "810fa5f3ce9f225d2e22b4372e39c4f4eff5a68f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a696bc4fec986318a1765c31ac9ee2db3849934a", "patch": "@@ -1112,6 +1112,7 @@ _loop_vec_info::_loop_vec_info (struct loop *loop_in)\n     num_iters_unchanged (NULL_TREE),\n     num_iters_assumptions (NULL_TREE),\n     th (0),\n+    versioning_threshold (0),\n     vectorization_factor (0),\n     max_vectorization_factor (0),\n     unaligned_dr (NULL),\n@@ -2176,11 +2177,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n      enough for both peeled prolog loop and vector loop.  This check\n      can be merged along with threshold check of loop versioning, so\n      increase threshold for this case if necessary.  */\n-  if (LOOP_REQUIRES_VERSIONING (loop_vinfo)\n-      && (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo)\n-\t  || LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo)))\n+  if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n     {\n-      unsigned niters_th;\n+      poly_uint64 niters_th;\n \n       /* Niters for peeled prolog loop.  */\n       if (LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n@@ -2197,9 +2196,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       niters_th += LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       /* One additional iteration because of peeling for gap.  */\n       if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n-\tniters_th++;\n-      if (LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) < niters_th)\n-\tLOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = niters_th;\n+\tniters_th += 1;\n+      LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo) = niters_th;\n     }\n \n   gcc_assert (vectorization_factor\n@@ -2302,6 +2300,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n   LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = false;\n   LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = 0;\n+  LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo) = 0;\n \n   goto start_over;\n }\n@@ -7380,7 +7379,17 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n     {\n-      vect_loop_versioning (loop_vinfo, th, check_profitability);\n+      poly_uint64 versioning_threshold\n+\t= LOOP_VINFO_VERSIONING_THRESHOLD (loop_vinfo);\n+      if (check_profitability\n+\t  && ordered_p (poly_uint64 (th), versioning_threshold))\n+\t{\n+\t  versioning_threshold = ordered_max (poly_uint64 (th),\n+\t\t\t\t\t      versioning_threshold);\n+\t  check_profitability = false;\n+\t}\n+      vect_loop_versioning (loop_vinfo, th, check_profitability,\n+\t\t\t    versioning_threshold);\n       check_profitability = false;\n     }\n "}, {"sha": "8291a71a0574a791a95706f99407f7ae64921804", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a696bc4fec986318a1765c31ac9ee2db3849934a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a696bc4fec986318a1765c31ac9ee2db3849934a", "patch": "@@ -238,6 +238,12 @@ typedef struct _loop_vec_info : public vec_info {\n      PARAM_MIN_VECT_LOOP_BOUND.  */\n   unsigned int th;\n \n+  /* When applying loop versioning, the vector form should only be used\n+     if the number of scalar iterations is >= this value, on top of all\n+     the other requirements.  Ignored when loop versioning is not being\n+     used.  */\n+  poly_uint64 versioning_threshold;\n+\n   /* Unrolling factor  */\n   int vectorization_factor;\n \n@@ -357,6 +363,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_VINFO_NITERS_UNCHANGED(L)     (L)->num_iters_unchanged\n #define LOOP_VINFO_NITERS_ASSUMPTIONS(L)   (L)->num_iters_assumptions\n #define LOOP_VINFO_COST_MODEL_THRESHOLD(L) (L)->th\n+#define LOOP_VINFO_VERSIONING_THRESHOLD(L) (L)->versioning_threshold\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n@@ -1142,7 +1149,8 @@ extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n struct loop *slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *,\n \t\t\t\t\t\t     struct loop *, edge);\n-extern void vect_loop_versioning (loop_vec_info, unsigned int, bool);\n+extern void vect_loop_versioning (loop_vec_info, unsigned int, bool,\n+\t\t\t\t  poly_uint64);\n extern struct loop *vect_do_peeling (loop_vec_info, tree, tree,\n \t\t\t\t     tree *, int, bool, bool);\n extern source_location find_loop_location (struct loop *);"}]}