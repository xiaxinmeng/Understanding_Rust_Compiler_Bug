{"sha": "adb252d824eac519413d0114a813543391c10592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiMjUyZDgyNGVhYzUxOTQxM2QwMTE0YTgxMzU0MzM5MWMxMDU5Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:02:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-19T11:02:48Z"}, "message": "[multiple changes]\n\n2014-02-19  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_attr.adb (Expand_Min_Max_Attribute): Use Insert_Declaration\n\t(Expand_Min_Max_Attribute): Use Matching_Standard_Type.\n\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Remove special\n\thandling for the case of Modify_Tree_For_C, this approach did\n\tnot work.\n\t* exp_util.adb (Matching_Standard_Type): New function\n\t(Side_Effect_Free): New top level functions (from\n\tRemove_Side_Effects).\n\t* exp_util.ads (Side_Effect_Free): New top level functions\n\t(moved from body).\n\t* sinfo.ads: Minor comment updates.\n\n2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Simple_Function_Return): If return\n\ttype is unconstrained and uses the secondary stack, mark the\n\tenclosing function accordingly, to ensure that the value is not\n\tprematurely removed.\n\n2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* par.adb Alphabetize the routines in Par.Sync.\n\t(Resync_Past_Malformed_Aspect): New routine.\n\t* par-ch13.adb (Get_Aspect_Specifications): Alphabetize local\n\tvariables. Code and comment reformatting. Detect missing\n\tparentheses on aspects [Refined_]Global and [Refined_]Depends\n\twith a non-null definition.\n\t* par-sync.adb: Alphabetize all routines in this separate unit.\n\t(Resync_Past_Malformed_Aspect): New routine.\n\nFrom-SVN: r207890", "tree": {"sha": "c5da7428ceb37eac13e1c97e08e78fc4ac813549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5da7428ceb37eac13e1c97e08e78fc4ac813549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb252d824eac519413d0114a813543391c10592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb252d824eac519413d0114a813543391c10592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb252d824eac519413d0114a813543391c10592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb252d824eac519413d0114a813543391c10592/comments", "author": null, "committer": null, "parents": [{"sha": "a03670050f7aa17d56e3c2f873612343c883f980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a03670050f7aa17d56e3c2f873612343c883f980", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a03670050f7aa17d56e3c2f873612343c883f980"}], "stats": {"total": 1530, "additions": 862, "deletions": 668}, "files": [{"sha": "e8f0c63c1d5ba4242eeff087725dbdd973f23adb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -1,3 +1,35 @@\n+2014-02-19  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Min_Max_Attribute): Use Insert_Declaration\n+\t(Expand_Min_Max_Attribute): Use Matching_Standard_Type.\n+\t* exp_ch4.adb (Expand_N_Expression_With_Actions): Remove special\n+\thandling for the case of Modify_Tree_For_C, this approach did\n+\tnot work.\n+\t* exp_util.adb (Matching_Standard_Type): New function\n+\t(Side_Effect_Free): New top level functions (from\n+\tRemove_Side_Effects).\n+\t* exp_util.ads (Side_Effect_Free): New top level functions\n+\t(moved from body).\n+\t* sinfo.ads: Minor comment updates.\n+\n+2014-02-19  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Simple_Function_Return): If return\n+\ttype is unconstrained and uses the secondary stack, mark the\n+\tenclosing function accordingly, to ensure that the value is not\n+\tprematurely removed.\n+\n+2014-02-19  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* par.adb Alphabetize the routines in Par.Sync.\n+\t(Resync_Past_Malformed_Aspect): New routine.\n+\t* par-ch13.adb (Get_Aspect_Specifications): Alphabetize local\n+\tvariables. Code and comment reformatting. Detect missing\n+\tparentheses on aspects [Refined_]Global and [Refined_]Depends\n+\twith a non-null definition.\n+\t* par-sync.adb: Alphabetize all routines in this separate unit.\n+\t(Resync_Past_Malformed_Aspect): New routine.\n+\n 2014-02-19  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_eval.ads, sem_eval.adb (Subtypes_Statically_Match): Return False"}, {"sha": "2e370ac01609c20a1452423b99757800b8b72f19", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -1062,8 +1062,6 @@ package body Exp_Attr is\n             Expr  : constant Node_Id    := First (Expressions (N));\n             Left  : constant Node_Id    := Relocate_Node (Expr);\n             Right : constant Node_Id    := Relocate_Node (Next (Expr));\n-            Ltyp  : constant Entity_Id  := Etype (Left);\n-            Rtyp  : constant Entity_Id  := Etype (Right);\n \n             function Make_Compare (Left, Right : Node_Id) return Node_Id;\n             --  Returns Left >= Right for Max, Left <= Right for Min\n@@ -1090,57 +1088,81 @@ package body Exp_Attr is\n          --  Start of processing for Min_Max\n \n          begin\n-            --  If both Left and Right are simple entity names, then we can\n-            --  just use Duplicate_Expr to duplicate the references and return\n+            --  If both Left and Right are side effect free, then we can just\n+            --  use Duplicate_Expr to duplicate the references and return\n \n             --    (if Left >=|<= Right then Left else Right)\n \n-            if Is_Entity_Name (Left) and then Is_Entity_Name (Right) then\n+            if Side_Effect_Free (Left) and then Side_Effect_Free (Right) then\n                Rewrite (N,\n                  Make_If_Expression (Loc,\n                    Expressions => New_List (\n                      Make_Compare (Left, Right),\n                      Duplicate_Subexpr_No_Checks (Left),\n                      Duplicate_Subexpr_No_Checks (Right))));\n \n-            --  Otherwise we wrap things in an expression with actions. You\n-            --  might think we could just use the approach above, but there\n-            --  are problems, in particular with escaped discriminants. In\n-            --  this case we generate:\n+            --  Otherwise we generate declarations to capture the values. We\n+            --  can't put these declarations inside the if expression, since\n+            --  we could end up with an N_Expression_With_Actions which has\n+            --  declarations in the actions, forbidden for Modify_Tree_For_C.\n+\n+            --  The translation is\n+\n+            --    T1 : styp;    --  inserted high up in tree\n+            --    T2 : styp;    --  inserted high up in tree\n \n             --    do\n-            --      T1 : constant typ := Left;\n-            --      T2 : constant typ := Right;\n+            --      T1 := styp!(Left);\n+            --      T2 := styp!(Right);\n             --    in\n-            --      (if T1 >=|<= T2 then T1 else T2)\n+            --      (if T1 >=|<= T2 then typ!(T1) else typ!(T2))\n             --    end;\n \n+            --  We insert the T1,T2 declarations with Insert_Declaration which\n+            --  inserts these declarations high up in the tree unconditionally.\n+            --  This is safe since no code is associated with the declarations.\n+            --  Here styp is a standard type whose Esize matches the size of\n+            --  our type. We do this because the actual type may be a result of\n+            --  some local declaration which would not be visible at the point\n+            --  where we insert the declarations of T1 and T2.\n+\n             else\n                declare\n-                  T1 : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n-                  T2 : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n+                  T1   : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n+                  T2   : constant Entity_Id := Make_Temporary (Loc, 'T', Left);\n+                  Styp : constant Entity_Id := Matching_Standard_Type (Typ);\n \n                begin\n+                  Insert_Declaration (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => T1,\n+                      Object_Definition   => New_Occurrence_Of (Styp, Loc)));\n+\n+                  Insert_Declaration (N,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => T2,\n+                      Object_Definition   => New_Occurrence_Of (Styp, Loc)));\n+\n                   Rewrite (N,\n                     Make_Expression_With_Actions (Loc,\n                       Actions => New_List (\n-                        Make_Object_Declaration (Loc,\n-                          Defining_Identifier => T1,\n-                          Object_Definition   => New_Occurrence_Of (Ltyp, Loc),\n-                          Expression          => Left),\n-                        Make_Object_Declaration (Loc,\n-                          Defining_Identifier => T2,\n-                          Object_Definition   => New_Occurrence_Of (Rtyp, Loc),\n-                          Expression          => Right)),\n+                        Make_Assignment_Statement (Loc,\n+                          Name       => New_Occurrence_Of (T1, Loc),\n+                          Expression => Unchecked_Convert_To (Styp, Left)),\n+                        Make_Assignment_Statement (Loc,\n+                          Name       => New_Occurrence_Of (T2, Loc),\n+                          Expression => Unchecked_Convert_To (Styp, Right))),\n \n                       Expression =>\n                         Make_If_Expression (Loc,\n                           Expressions => New_List (\n                             Make_Compare\n                               (New_Occurrence_Of (T1, Loc),\n                                New_Occurrence_Of (T2, Loc)),\n-                            New_Occurrence_Of (T1, Loc),\n-                            New_Occurrence_Of (T2, Loc)))));\n+                            Unchecked_Convert_To (Typ,\n+                              New_Occurrence_Of (T1, Loc)),\n+                            Unchecked_Convert_To (Typ,\n+                              New_Occurrence_Of (T2, Loc))))));\n                end;\n             end if;\n "}, {"sha": "512ebd838a43a29b229d2a3399a2c3dda677ffaf", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -5067,42 +5067,13 @@ package body Exp_Ch4 is\n    --------------------------------------\n \n    procedure Expand_N_Expression_With_Actions (N : Node_Id) is\n-      procedure Insert_Declaration (Decl : Node_Id);\n-      --  This is like Insert_Action, but inserts outside the expression in\n-      --  which N appears. This is needed, because otherwise we can end up\n-      --  inserting a declaration in the actions of a short circuit, and that\n-      --  will not do, because that's likely where we (the expression with\n-      --  actions) node came from the first place. We are only inserting a\n-      --  declaration with no side effects, so it is harmless (and needed)\n-      --  to insert at a higher point in the tree.\n \n       function Process_Action (Act : Node_Id) return Traverse_Result;\n       --  Inspect and process a single action of an expression_with_actions for\n       --  transient controlled objects. If such objects are found, the routine\n       --  generates code to clean them up when the context of the expression is\n       --  evaluated or elaborated.\n \n-      ------------------------\n-      -- Insert_Declaration --\n-      ------------------------\n-\n-      procedure Insert_Declaration (Decl : Node_Id) is\n-         P : Node_Id;\n-\n-      begin\n-         --  Climb out of the current expression\n-\n-         P := Decl;\n-         loop\n-            exit when Nkind (Parent (P)) not in N_Subexpr;\n-            P := Parent (P);\n-         end loop;\n-\n-         --  Now do the insertion\n-\n-         Insert_Action (P, Decl);\n-      end Insert_Declaration;\n-\n       --------------------\n       -- Process_Action --\n       --------------------\n@@ -5135,11 +5106,7 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n-      Loc : Source_Ptr;\n       Act : Node_Id;\n-      Def : Entity_Id;\n-      Exp : Node_Id;\n-      Nxt : Node_Id;\n \n    --  Start of processing for Expand_N_Expression_With_Actions\n \n@@ -5152,48 +5119,6 @@ package body Exp_Ch4 is\n          Next (Act);\n       end loop;\n \n-      --  In Modify_Tree_For_C, we have trouble in C with object declarations\n-      --  in the actions list (expressions are fine). So if we have an object\n-      --  declaration, insert it higher in the tree, if necessary replacing it\n-      --  with an assignment to capture initialization.\n-\n-      if Modify_Tree_For_C then\n-         Act := First (Actions (N));\n-         while Present (Act) loop\n-            if Nkind (Act) = N_Object_Declaration then\n-               Def := Defining_Identifier (Act);\n-               Exp := Expression (Act);\n-               Set_Constant_Present (Act, False);\n-               Set_Expression (Act, Empty);\n-               Insert_Declaration (Relocate_Node (Act));\n-\n-               Loc := Sloc (Act);\n-\n-               --  Expression present, rewrite as assignment, get next action\n-\n-               if Present (Exp) then\n-                  Rewrite (Act,\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Def, Loc),\n-                      Expression => Exp));\n-                  Next (Act);\n-\n-               --  No expression, remove action and move to next\n-\n-               else\n-                  Nxt := Next (Act);\n-                  Remove (Act);\n-                  Act := Nxt;\n-               end if;\n-\n-            --  Not an object declaration, move to next action\n-\n-            else\n-               Next (Act);\n-            end if;\n-         end loop;\n-      end if;\n-\n       --  Deal with case where there are no actions. In this case we simply\n       --  rewrite the node with its expression since we don't need the actions\n       --  and the specification of this node does not allow a null action list."}, {"sha": "e1c4722c5c306db48f265e35246e22a4cca4f6f2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -7834,6 +7834,13 @@ package body Exp_Ch6 is\n                Set_Sec_Stack_Needed_For_Return (S, True);\n                S := Enclosing_Dynamic_Scope (S);\n             end loop;\n+\n+            --  The enclosing function itself must be marked as well, to\n+            --  prevent premature secondary stack cleanup.\n+\n+            if Ekind (S) = E_Function then\n+               Set_Sec_Stack_Needed_For_Return (Scope_Id);\n+            end if;\n          end;\n \n          --  Optimize the case where the result is a function call. In this"}, {"sha": "251e919a98a235a84d39cf347dc8a280fcdb9b7e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 445, "deletions": 439, "changes": 884, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -3962,11 +3962,13 @@ package body Exp_Util is\n \n       --  Climb until we find a procedure or a package\n \n-      P := Parent (N);\n+      P := N;\n       loop\n+         pragma Assert (Present (Parent (P)));\n+         P := Parent (P);\n+\n          if Is_List_Member (P) then\n             exit when Nkind_In (Parent (P), N_Package_Specification,\n-                                            N_Package_Body,\n                                             N_Subprogram_Body);\n \n             --  Special handling for handled sequence of statements, we must\n@@ -3977,8 +3979,6 @@ package body Exp_Util is\n                exit;\n             end if;\n          end if;\n-\n-         P := Parent (P);\n       end loop;\n \n       --  Now do the insertion\n@@ -5970,7 +5970,7 @@ package body Exp_Util is\n       Siz : constant Uint := Esize (Typ);\n \n    begin\n-      --  Float-point cases\n+      --  Floating-point cases\n \n       if Is_Floating_Point_Type (Typ) then\n          if Siz <= Esize (Standard_Short_Float) then\n@@ -5987,7 +5987,7 @@ package body Exp_Util is\n \n       --  Integer cases (includes fixed-point types)\n \n-      --  Unsigned cases (includes normal enumeration types)\n+      --  Unsigned integer cases (includes normal enumeration types)\n \n       elsif Is_Unsigned_Type (Typ) then\n          if Siz <= Esize (Standard_Short_Short_Unsigned) then\n@@ -6004,7 +6004,7 @@ package body Exp_Util is\n             raise Program_Error;\n          end if;\n \n-      --  Signed cases\n+      --  Signed integer cases\n \n       else\n          if Siz <= Esize (Standard_Short_Short_Integer) then\n@@ -6635,435 +6635,6 @@ package body Exp_Util is\n       Ref_Type     : Entity_Id;\n       Res          : Node_Id;\n \n-      function Side_Effect_Free (N : Node_Id) return Boolean;\n-      --  Determines if the tree N represents an expression that is known not\n-      --  to have side effects, and for which no processing is required.\n-\n-      function Side_Effect_Free (L : List_Id) return Boolean;\n-      --  Determines if all elements of the list L are side effect free\n-\n-      function Safe_Prefixed_Reference (N : Node_Id) return Boolean;\n-      --  The argument N is a construct where the Prefix is dereferenced if it\n-      --  is an access type and the result is a variable. The call returns True\n-      --  if the construct is side effect free (not considering side effects in\n-      --  other than the prefix which are to be tested by the caller).\n-\n-      function Within_In_Parameter (N : Node_Id) return Boolean;\n-      --  Determines if N is a subcomponent of a composite in-parameter. If so,\n-      --  N is not side-effect free when the actual is global and modifiable\n-      --  indirectly from within a subprogram, because it may be passed by\n-      --  reference. The front-end must be conservative here and assume that\n-      --  this may happen with any array or record type. On the other hand, we\n-      --  cannot create temporaries for all expressions for which this\n-      --  condition is true, for various reasons that might require clearing up\n-      --  ??? For example, discriminant references that appear out of place, or\n-      --  spurious type errors with class-wide expressions. As a result, we\n-      --  limit the transformation to loop bounds, which is so far the only\n-      --  case that requires it.\n-\n-      -----------------------------\n-      -- Safe_Prefixed_Reference --\n-      -----------------------------\n-\n-      function Safe_Prefixed_Reference (N : Node_Id) return Boolean is\n-      begin\n-         --  If prefix is not side effect free, definitely not safe\n-\n-         if not Side_Effect_Free (Prefix (N)) then\n-            return False;\n-\n-         --  If the prefix is of an access type that is not access-to-constant,\n-         --  then this construct is a variable reference, which means it is to\n-         --  be considered to have side effects if Variable_Ref is set True.\n-\n-         elsif Is_Access_Type (Etype (Prefix (N)))\n-           and then not Is_Access_Constant (Etype (Prefix (N)))\n-           and then Variable_Ref\n-         then\n-            --  Exception is a prefix that is the result of a previous removal\n-            --  of side-effects.\n-\n-            return Is_Entity_Name (Prefix (N))\n-              and then not Comes_From_Source (Prefix (N))\n-              and then Ekind (Entity (Prefix (N))) = E_Constant\n-              and then Is_Internal_Name (Chars (Entity (Prefix (N))));\n-\n-         --  If the prefix is an explicit dereference then this construct is a\n-         --  variable reference, which means it is to be considered to have\n-         --  side effects if Variable_Ref is True.\n-\n-         --  We do NOT exclude dereferences of access-to-constant types because\n-         --  we handle them as constant view of variables.\n-\n-         elsif Nkind (Prefix (N)) = N_Explicit_Dereference\n-           and then Variable_Ref\n-         then\n-            return False;\n-\n-         --  Note: The following test is the simplest way of solving a complex\n-         --  problem uncovered by the following test (Side effect on loop bound\n-         --  that is a subcomponent of a global variable:\n-\n-         --    with Text_Io; use Text_Io;\n-         --    procedure Tloop is\n-         --      type X is\n-         --        record\n-         --          V : Natural := 4;\n-         --          S : String (1..5) := (others => 'a');\n-         --        end record;\n-         --      X1 : X;\n-\n-         --      procedure Modi;\n-\n-         --      generic\n-         --        with procedure Action;\n-         --      procedure Loop_G (Arg : X; Msg : String)\n-\n-         --      procedure Loop_G (Arg : X; Msg : String) is\n-         --      begin\n-         --        Put_Line (\"begin loop_g \" & Msg & \" will loop till: \"\n-         --                  & Natural'Image (Arg.V));\n-         --        for Index in 1 .. Arg.V loop\n-         --          Text_Io.Put_Line\n-         --            (Natural'Image (Index) & \" \" & Arg.S (Index));\n-         --          if Index > 2 then\n-         --            Modi;\n-         --          end if;\n-         --        end loop;\n-         --        Put_Line (\"end loop_g \" & Msg);\n-         --      end;\n-\n-         --      procedure Loop1 is new Loop_G (Modi);\n-         --      procedure Modi is\n-         --      begin\n-         --        X1.V := 1;\n-         --        Loop1 (X1, \"from modi\");\n-         --      end;\n-         --\n-         --    begin\n-         --      Loop1 (X1, \"initial\");\n-         --    end;\n-\n-         --  The output of the above program should be:\n-\n-         --    begin loop_g initial will loop till:  4\n-         --     1 a\n-         --     2 a\n-         --     3 a\n-         --    begin loop_g from modi will loop till:  1\n-         --     1 a\n-         --    end loop_g from modi\n-         --     4 a\n-         --    begin loop_g from modi will loop till:  1\n-         --     1 a\n-         --    end loop_g from modi\n-         --    end loop_g initial\n-\n-         --  If a loop bound is a subcomponent of a global variable, a\n-         --  modification of that variable within the loop may incorrectly\n-         --  affect the execution of the loop.\n-\n-         elsif Nkind (Parent (Parent (N))) = N_Loop_Parameter_Specification\n-           and then Within_In_Parameter (Prefix (N))\n-           and then Variable_Ref\n-         then\n-            return False;\n-\n-         --  All other cases are side effect free\n-\n-         else\n-            return True;\n-         end if;\n-      end Safe_Prefixed_Reference;\n-\n-      ----------------------\n-      -- Side_Effect_Free --\n-      ----------------------\n-\n-      function Side_Effect_Free (N : Node_Id) return Boolean is\n-      begin\n-         --  Note on checks that could raise Constraint_Error. Strictly, if we\n-         --  take advantage of 11.6, these checks do not count as side effects.\n-         --  However, we would prefer to consider that they are side effects,\n-         --  since the backend CSE does not work very well on expressions which\n-         --  can raise Constraint_Error. On the other hand if we don't consider\n-         --  them to be side effect free, then we get some awkward expansions\n-         --  in -gnato mode, resulting in code insertions at a point where we\n-         --  do not have a clear model for performing the insertions.\n-\n-         --  Special handling for entity names\n-\n-         if Is_Entity_Name (N) then\n-\n-            --  Variables are considered to be a side effect if Variable_Ref\n-            --  is set or if we have a volatile reference and Name_Req is off.\n-            --  If Name_Req is True then we can't help returning a name which\n-            --  effectively allows multiple references in any case.\n-\n-            if Is_Variable (N, Use_Original_Node => False) then\n-               return not Variable_Ref\n-                 and then (not Is_Volatile_Reference (N) or else Name_Req);\n-\n-            --  Any other entity (e.g. a subtype name) is definitely side\n-            --  effect free.\n-\n-            else\n-               return True;\n-            end if;\n-\n-         --  A value known at compile time is always side effect free\n-\n-         elsif Compile_Time_Known_Value (N) then\n-            return True;\n-\n-         --  A variable renaming is not side-effect free, because the renaming\n-         --  will function like a macro in the front-end in some cases, and an\n-         --  assignment can modify the component designated by N, so we need to\n-         --  create a temporary for it.\n-\n-         --  The guard testing for Entity being present is needed at least in\n-         --  the case of rewritten predicate expressions, and may well also be\n-         --  appropriate elsewhere. Obviously we can't go testing the entity\n-         --  field if it does not exist, so it's reasonable to say that this is\n-         --  not the renaming case if it does not exist.\n-\n-         elsif Is_Entity_Name (Original_Node (N))\n-           and then Present (Entity (Original_Node (N)))\n-           and then Is_Renaming_Of_Object (Entity (Original_Node (N)))\n-           and then Ekind (Entity (Original_Node (N))) /= E_Constant\n-         then\n-            declare\n-               RO : constant Node_Id :=\n-                      Renamed_Object (Entity (Original_Node (N)));\n-\n-            begin\n-               --  If the renamed object is an indexed component, or an\n-               --  explicit dereference, then the designated object could\n-               --  be modified by an assignment.\n-\n-               if Nkind_In (RO, N_Indexed_Component,\n-                                N_Explicit_Dereference)\n-               then\n-                  return False;\n-\n-               --  A selected component must have a safe prefix\n-\n-               elsif Nkind (RO) = N_Selected_Component then\n-                  return Safe_Prefixed_Reference (RO);\n-\n-               --  In all other cases, designated object cannot be changed so\n-               --  we are side effect free.\n-\n-               else\n-                  return True;\n-               end if;\n-            end;\n-\n-         --  Remove_Side_Effects generates an object renaming declaration to\n-         --  capture the expression of a class-wide expression. In VM targets\n-         --  the frontend performs no expansion for dispatching calls to\n-         --  class- wide types since they are handled by the VM. Hence, we must\n-         --  locate here if this node corresponds to a previous invocation of\n-         --  Remove_Side_Effects to avoid a never ending loop in the frontend.\n-\n-         elsif VM_Target /= No_VM\n-            and then not Comes_From_Source (N)\n-            and then Nkind (Parent (N)) = N_Object_Renaming_Declaration\n-            and then Is_Class_Wide_Type (Etype (N))\n-         then\n-            return True;\n-         end if;\n-\n-         --  For other than entity names and compile time known values,\n-         --  check the node kind for special processing.\n-\n-         case Nkind (N) is\n-\n-            --  An attribute reference is side effect free if its expressions\n-            --  are side effect free and its prefix is side effect free or\n-            --  is an entity reference.\n-\n-            --  Is this right? what about x'first where x is a variable???\n-\n-            when N_Attribute_Reference =>\n-               return Side_Effect_Free (Expressions (N))\n-                 and then Attribute_Name (N) /= Name_Input\n-                 and then (Is_Entity_Name (Prefix (N))\n-                            or else Side_Effect_Free (Prefix (N)));\n-\n-            --  A binary operator is side effect free if and both operands are\n-            --  side effect free. For this purpose binary operators include\n-            --  membership tests and short circuit forms.\n-\n-            when N_Binary_Op | N_Membership_Test | N_Short_Circuit =>\n-               return Side_Effect_Free (Left_Opnd  (N))\n-                        and then\n-                      Side_Effect_Free (Right_Opnd (N));\n-\n-            --  An explicit dereference is side effect free only if it is\n-            --  a side effect free prefixed reference.\n-\n-            when N_Explicit_Dereference =>\n-               return Safe_Prefixed_Reference (N);\n-\n-            --  An expression with action is side effect free if its expression\n-            --  is side effect free and it has no actions.\n-\n-            when N_Expression_With_Actions =>\n-               return Is_Empty_List (Actions (N))\n-                        and then\n-                      Side_Effect_Free (Expression (N));\n-\n-            --  A call to _rep_to_pos is side effect free, since we generate\n-            --  this pure function call ourselves. Moreover it is critically\n-            --  important to make this exception, since otherwise we can have\n-            --  discriminants in array components which don't look side effect\n-            --  free in the case of an array whose index type is an enumeration\n-            --  type with an enumeration rep clause.\n-\n-            --  All other function calls are not side effect free\n-\n-            when N_Function_Call =>\n-               return Nkind (Name (N)) = N_Identifier\n-                 and then Is_TSS (Name (N), TSS_Rep_To_Pos)\n-                 and then\n-                   Side_Effect_Free (First (Parameter_Associations (N)));\n-\n-            --  An indexed component is side effect free if it is a side\n-            --  effect free prefixed reference and all the indexing\n-            --  expressions are side effect free.\n-\n-            when N_Indexed_Component =>\n-               return Side_Effect_Free (Expressions (N))\n-                 and then Safe_Prefixed_Reference (N);\n-\n-            --  A type qualification is side effect free if the expression\n-            --  is side effect free.\n-\n-            when N_Qualified_Expression =>\n-               return Side_Effect_Free (Expression (N));\n-\n-            --  A selected component is side effect free only if it is a side\n-            --  effect free prefixed reference. If it designates a component\n-            --  with a rep. clause it must be treated has having a potential\n-            --  side effect, because it may be modified through a renaming, and\n-            --  a subsequent use of the renaming as a macro will yield the\n-            --  wrong value. This complex interaction between renaming and\n-            --  removing side effects is a reminder that the latter has become\n-            --  a headache to maintain, and that it should be removed in favor\n-            --  of the gcc mechanism to capture values ???\n-\n-            when N_Selected_Component =>\n-               if Nkind (Parent (N)) = N_Explicit_Dereference\n-                 and then Has_Non_Standard_Rep (Designated_Type (Etype (N)))\n-               then\n-                  return False;\n-               else\n-                  return Safe_Prefixed_Reference (N);\n-               end if;\n-\n-            --  A range is side effect free if the bounds are side effect free\n-\n-            when N_Range =>\n-               return Side_Effect_Free (Low_Bound (N))\n-                 and then Side_Effect_Free (High_Bound (N));\n-\n-            --  A slice is side effect free if it is a side effect free\n-            --  prefixed reference and the bounds are side effect free.\n-\n-            when N_Slice =>\n-               return Side_Effect_Free (Discrete_Range (N))\n-                 and then Safe_Prefixed_Reference (N);\n-\n-            --  A type conversion is side effect free if the expression to be\n-            --  converted is side effect free.\n-\n-            when N_Type_Conversion =>\n-               return Side_Effect_Free (Expression (N));\n-\n-            --  A unary operator is side effect free if the operand\n-            --  is side effect free.\n-\n-            when N_Unary_Op =>\n-               return Side_Effect_Free (Right_Opnd (N));\n-\n-            --  An unchecked type conversion is side effect free only if it\n-            --  is safe and its argument is side effect free.\n-\n-            when N_Unchecked_Type_Conversion =>\n-               return Safe_Unchecked_Type_Conversion (N)\n-                 and then Side_Effect_Free (Expression (N));\n-\n-            --  An unchecked expression is side effect free if its expression\n-            --  is side effect free.\n-\n-            when N_Unchecked_Expression =>\n-               return Side_Effect_Free (Expression (N));\n-\n-            --  A literal is side effect free\n-\n-            when N_Character_Literal    |\n-                 N_Integer_Literal      |\n-                 N_Real_Literal         |\n-                 N_String_Literal       =>\n-               return True;\n-\n-            --  We consider that anything else has side effects. This is a bit\n-            --  crude, but we are pretty close for most common cases, and we\n-            --  are certainly correct (i.e. we never return True when the\n-            --  answer should be False).\n-\n-            when others =>\n-               return False;\n-         end case;\n-      end Side_Effect_Free;\n-\n-      --  A list is side effect free if all elements of the list are side\n-      --  effect free.\n-\n-      function Side_Effect_Free (L : List_Id) return Boolean is\n-         N : Node_Id;\n-\n-      begin\n-         if L = No_List or else L = Error_List then\n-            return True;\n-\n-         else\n-            N := First (L);\n-            while Present (N) loop\n-               if not Side_Effect_Free (N) then\n-                  return False;\n-               else\n-                  Next (N);\n-               end if;\n-            end loop;\n-\n-            return True;\n-         end if;\n-      end Side_Effect_Free;\n-\n-      -------------------------\n-      -- Within_In_Parameter --\n-      -------------------------\n-\n-      function Within_In_Parameter (N : Node_Id) return Boolean is\n-      begin\n-         if not Comes_From_Source (N) then\n-            return False;\n-\n-         elsif Is_Entity_Name (N) then\n-            return Ekind (Entity (N)) = E_In_Parameter;\n-\n-         elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n-            return Within_In_Parameter (Prefix (N));\n-\n-         else\n-            return False;\n-         end if;\n-      end Within_In_Parameter;\n-\n-   --  Start of processing for Remove_Side_Effects\n-\n    begin\n       --  Handle cases in which there is nothing to do. In GNATprove mode,\n       --  removal of side effects is useful for the light expansion of\n@@ -7085,7 +6656,7 @@ package body Exp_Util is\n \n       --  No action needed for side-effect free expressions\n \n-      elsif Side_Effect_Free (Exp) then\n+      elsif Side_Effect_Free (Exp, Name_Req, Variable_Ref) then\n          return;\n       end if;\n \n@@ -7099,7 +6670,7 @@ package body Exp_Util is\n       --  If it is a scalar type and we need to capture the value, just make\n       --  a copy. Likewise for a function call, an attribute reference, a\n       --  conditional expression, an allocator, or an operator. And if we have\n-      --  a volatile reference and Name_Req is not set (see comments above for\n+      --  a volatile reference and Name_Req is not set (see comments for\n       --  Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)\n@@ -7223,7 +6794,7 @@ package body Exp_Util is\n       --  approach would generate an illegal access value (an access value\n       --  cannot designate such an object - see Analyze_Reference). We skip\n       --  using this scheme if we have an object of a volatile type and we do\n-      --  not have Name_Req set true (see comments above for Side_Effect_Free).\n+      --  not have Name_Req set true (see comments for Side_Effect_Free).\n \n       --  In Ada 2012 a qualified expression is an object, but for purposes of\n       --  removing side effects it still need to be transformed into a separate\n@@ -8095,6 +7666,441 @@ package body Exp_Util is\n       end if;\n    end Set_Renamed_Subprogram;\n \n+   ----------------------\n+   -- Side_Effect_Free --\n+   ----------------------\n+\n+   function Side_Effect_Free\n+     (N            : Node_Id;\n+      Name_Req     : Boolean := False;\n+      Variable_Ref : Boolean := False) return Boolean\n+   is\n+      function Safe_Prefixed_Reference (N : Node_Id) return Boolean;\n+      --  The argument N is a construct where the Prefix is dereferenced if it\n+      --  is an access type and the result is a variable. The call returns True\n+      --  if the construct is side effect free (not considering side effects in\n+      --  other than the prefix which are to be tested by the caller).\n+\n+      function Within_In_Parameter (N : Node_Id) return Boolean;\n+      --  Determines if N is a subcomponent of a composite in-parameter. If so,\n+      --  N is not side-effect free when the actual is global and modifiable\n+      --  indirectly from within a subprogram, because it may be passed by\n+      --  reference. The front-end must be conservative here and assume that\n+      --  this may happen with any array or record type. On the other hand, we\n+      --  cannot create temporaries for all expressions for which this\n+      --  condition is true, for various reasons that might require clearing up\n+      --  ??? For example, discriminant references that appear out of place, or\n+      --  spurious type errors with class-wide expressions. As a result, we\n+      --  limit the transformation to loop bounds, which is so far the only\n+      --  case that requires it.\n+\n+      -----------------------------\n+      -- Safe_Prefixed_Reference --\n+      -----------------------------\n+\n+      function Safe_Prefixed_Reference (N : Node_Id) return Boolean is\n+      begin\n+         --  If prefix is not side effect free, definitely not safe\n+\n+         if not Side_Effect_Free (Prefix (N), Name_Req, Variable_Ref) then\n+            return False;\n+\n+         --  If the prefix is of an access type that is not access-to-constant,\n+         --  then this construct is a variable reference, which means it is to\n+         --  be considered to have side effects if Variable_Ref is set True.\n+\n+         elsif Is_Access_Type (Etype (Prefix (N)))\n+           and then not Is_Access_Constant (Etype (Prefix (N)))\n+           and then Variable_Ref\n+         then\n+            --  Exception is a prefix that is the result of a previous removal\n+            --  of side-effects.\n+\n+            return Is_Entity_Name (Prefix (N))\n+              and then not Comes_From_Source (Prefix (N))\n+              and then Ekind (Entity (Prefix (N))) = E_Constant\n+              and then Is_Internal_Name (Chars (Entity (Prefix (N))));\n+\n+         --  If the prefix is an explicit dereference then this construct is a\n+         --  variable reference, which means it is to be considered to have\n+         --  side effects if Variable_Ref is True.\n+\n+         --  We do NOT exclude dereferences of access-to-constant types because\n+         --  we handle them as constant view of variables.\n+\n+         elsif Nkind (Prefix (N)) = N_Explicit_Dereference\n+           and then Variable_Ref\n+         then\n+            return False;\n+\n+         --  Note: The following test is the simplest way of solving a complex\n+         --  problem uncovered by the following test (Side effect on loop bound\n+         --  that is a subcomponent of a global variable:\n+\n+         --    with Text_Io; use Text_Io;\n+         --    procedure Tloop is\n+         --      type X is\n+         --        record\n+         --          V : Natural := 4;\n+         --          S : String (1..5) := (others => 'a');\n+         --        end record;\n+         --      X1 : X;\n+\n+         --      procedure Modi;\n+\n+         --      generic\n+         --        with procedure Action;\n+         --      procedure Loop_G (Arg : X; Msg : String)\n+\n+         --      procedure Loop_G (Arg : X; Msg : String) is\n+         --      begin\n+         --        Put_Line (\"begin loop_g \" & Msg & \" will loop till: \"\n+         --                  & Natural'Image (Arg.V));\n+         --        for Index in 1 .. Arg.V loop\n+         --          Text_Io.Put_Line\n+         --            (Natural'Image (Index) & \" \" & Arg.S (Index));\n+         --          if Index > 2 then\n+         --            Modi;\n+         --          end if;\n+         --        end loop;\n+         --        Put_Line (\"end loop_g \" & Msg);\n+         --      end;\n+\n+         --      procedure Loop1 is new Loop_G (Modi);\n+         --      procedure Modi is\n+         --      begin\n+         --        X1.V := 1;\n+         --        Loop1 (X1, \"from modi\");\n+         --      end;\n+         --\n+         --    begin\n+         --      Loop1 (X1, \"initial\");\n+         --    end;\n+\n+         --  The output of the above program should be:\n+\n+         --    begin loop_g initial will loop till:  4\n+         --     1 a\n+         --     2 a\n+         --     3 a\n+         --    begin loop_g from modi will loop till:  1\n+         --     1 a\n+         --    end loop_g from modi\n+         --     4 a\n+         --    begin loop_g from modi will loop till:  1\n+         --     1 a\n+         --    end loop_g from modi\n+         --    end loop_g initial\n+\n+         --  If a loop bound is a subcomponent of a global variable, a\n+         --  modification of that variable within the loop may incorrectly\n+         --  affect the execution of the loop.\n+\n+         elsif Nkind (Parent (Parent (N))) = N_Loop_Parameter_Specification\n+           and then Within_In_Parameter (Prefix (N))\n+           and then Variable_Ref\n+         then\n+            return False;\n+\n+         --  All other cases are side effect free\n+\n+         else\n+            return True;\n+         end if;\n+      end Safe_Prefixed_Reference;\n+\n+      -------------------------\n+      -- Within_In_Parameter --\n+      -------------------------\n+\n+      function Within_In_Parameter (N : Node_Id) return Boolean is\n+      begin\n+         if not Comes_From_Source (N) then\n+            return False;\n+\n+         elsif Is_Entity_Name (N) then\n+            return Ekind (Entity (N)) = E_In_Parameter;\n+\n+         elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n+            return Within_In_Parameter (Prefix (N));\n+\n+         else\n+            return False;\n+         end if;\n+      end Within_In_Parameter;\n+\n+   --  Start of processing for Side_Effect_Free\n+\n+   begin\n+      --  Note on checks that could raise Constraint_Error. Strictly, if we\n+      --  take advantage of 11.6, these checks do not count as side effects.\n+      --  However, we would prefer to consider that they are side effects,\n+      --  since the backend CSE does not work very well on expressions which\n+      --  can raise Constraint_Error. On the other hand if we don't consider\n+      --  them to be side effect free, then we get some awkward expansions\n+      --  in -gnato mode, resulting in code insertions at a point where we\n+      --  do not have a clear model for performing the insertions.\n+\n+      --  Special handling for entity names\n+\n+      if Is_Entity_Name (N) then\n+\n+         --  Variables are considered to be a side effect if Variable_Ref\n+         --  is set or if we have a volatile reference and Name_Req is off.\n+         --  If Name_Req is True then we can't help returning a name which\n+         --  effectively allows multiple references in any case.\n+\n+         if Is_Variable (N, Use_Original_Node => False) then\n+            return not Variable_Ref\n+              and then (not Is_Volatile_Reference (N) or else Name_Req);\n+\n+         --  Any other entity (e.g. a subtype name) is definitely side\n+         --  effect free.\n+\n+         else\n+            return True;\n+         end if;\n+\n+      --  A value known at compile time is always side effect free\n+\n+      elsif Compile_Time_Known_Value (N) then\n+         return True;\n+\n+      --  A variable renaming is not side-effect free, because the renaming\n+      --  will function like a macro in the front-end in some cases, and an\n+      --  assignment can modify the component designated by N, so we need to\n+      --  create a temporary for it.\n+\n+      --  The guard testing for Entity being present is needed at least in\n+      --  the case of rewritten predicate expressions, and may well also be\n+      --  appropriate elsewhere. Obviously we can't go testing the entity\n+      --  field if it does not exist, so it's reasonable to say that this is\n+      --  not the renaming case if it does not exist.\n+\n+      elsif Is_Entity_Name (Original_Node (N))\n+        and then Present (Entity (Original_Node (N)))\n+        and then Is_Renaming_Of_Object (Entity (Original_Node (N)))\n+        and then Ekind (Entity (Original_Node (N))) /= E_Constant\n+      then\n+         declare\n+            RO : constant Node_Id :=\n+                   Renamed_Object (Entity (Original_Node (N)));\n+\n+         begin\n+            --  If the renamed object is an indexed component, or an\n+            --  explicit dereference, then the designated object could\n+            --  be modified by an assignment.\n+\n+            if Nkind_In (RO, N_Indexed_Component,\n+                             N_Explicit_Dereference)\n+            then\n+               return False;\n+\n+            --  A selected component must have a safe prefix\n+\n+            elsif Nkind (RO) = N_Selected_Component then\n+               return Safe_Prefixed_Reference (RO);\n+\n+            --  In all other cases, designated object cannot be changed so\n+            --  we are side effect free.\n+\n+            else\n+               return True;\n+            end if;\n+         end;\n+\n+      --  Remove_Side_Effects generates an object renaming declaration to\n+      --  capture the expression of a class-wide expression. In VM targets\n+      --  the frontend performs no expansion for dispatching calls to\n+      --  class- wide types since they are handled by the VM. Hence, we must\n+      --  locate here if this node corresponds to a previous invocation of\n+      --  Remove_Side_Effects to avoid a never ending loop in the frontend.\n+\n+      elsif VM_Target /= No_VM\n+         and then not Comes_From_Source (N)\n+         and then Nkind (Parent (N)) = N_Object_Renaming_Declaration\n+         and then Is_Class_Wide_Type (Etype (N))\n+      then\n+         return True;\n+      end if;\n+\n+      --  For other than entity names and compile time known values,\n+      --  check the node kind for special processing.\n+\n+      case Nkind (N) is\n+\n+         --  An attribute reference is side effect free if its expressions\n+         --  are side effect free and its prefix is side effect free or\n+         --  is an entity reference.\n+\n+         --  Is this right? what about x'first where x is a variable???\n+\n+         when N_Attribute_Reference =>\n+            return Side_Effect_Free (Expressions (N), Name_Req, Variable_Ref)\n+              and then Attribute_Name (N) /= Name_Input\n+              and then (Is_Entity_Name (Prefix (N))\n+                         or else Side_Effect_Free\n+                                   (Prefix (N), Name_Req, Variable_Ref));\n+\n+         --  A binary operator is side effect free if and both operands are\n+         --  side effect free. For this purpose binary operators include\n+         --  membership tests and short circuit forms.\n+\n+         when N_Binary_Op | N_Membership_Test | N_Short_Circuit =>\n+            return Side_Effect_Free (Left_Opnd  (N), Name_Req, Variable_Ref)\n+                     and then\n+                   Side_Effect_Free (Right_Opnd (N), Name_Req, Variable_Ref);\n+\n+         --  An explicit dereference is side effect free only if it is\n+         --  a side effect free prefixed reference.\n+\n+         when N_Explicit_Dereference =>\n+            return Safe_Prefixed_Reference (N);\n+\n+         --  An expression with action is side effect free if its expression\n+         --  is side effect free and it has no actions.\n+\n+         when N_Expression_With_Actions =>\n+            return Is_Empty_List (Actions (N))\n+              and then\n+                Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n+\n+         --  A call to _rep_to_pos is side effect free, since we generate\n+         --  this pure function call ourselves. Moreover it is critically\n+         --  important to make this exception, since otherwise we can have\n+         --  discriminants in array components which don't look side effect\n+         --  free in the case of an array whose index type is an enumeration\n+         --  type with an enumeration rep clause.\n+\n+         --  All other function calls are not side effect free\n+\n+         when N_Function_Call =>\n+            return Nkind (Name (N)) = N_Identifier\n+              and then Is_TSS (Name (N), TSS_Rep_To_Pos)\n+              and then\n+                Side_Effect_Free\n+                  (First (Parameter_Associations (N)), Name_Req, Variable_Ref);\n+\n+         --  An indexed component is side effect free if it is a side\n+         --  effect free prefixed reference and all the indexing\n+         --  expressions are side effect free.\n+\n+         when N_Indexed_Component =>\n+            return Side_Effect_Free (Expressions (N), Name_Req, Variable_Ref)\n+              and then Safe_Prefixed_Reference (N);\n+\n+         --  A type qualification is side effect free if the expression\n+         --  is side effect free.\n+\n+         when N_Qualified_Expression =>\n+            return Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n+\n+         --  A selected component is side effect free only if it is a side\n+         --  effect free prefixed reference. If it designates a component\n+         --  with a rep. clause it must be treated has having a potential\n+         --  side effect, because it may be modified through a renaming, and\n+         --  a subsequent use of the renaming as a macro will yield the\n+         --  wrong value. This complex interaction between renaming and\n+         --  removing side effects is a reminder that the latter has become\n+         --  a headache to maintain, and that it should be removed in favor\n+         --  of the gcc mechanism to capture values ???\n+\n+         when N_Selected_Component =>\n+            if Nkind (Parent (N)) = N_Explicit_Dereference\n+              and then Has_Non_Standard_Rep (Designated_Type (Etype (N)))\n+            then\n+               return False;\n+            else\n+               return Safe_Prefixed_Reference (N);\n+            end if;\n+\n+         --  A range is side effect free if the bounds are side effect free\n+\n+         when N_Range =>\n+            return Side_Effect_Free (Low_Bound (N),  Name_Req, Variable_Ref)\n+                      and then\n+                   Side_Effect_Free (High_Bound (N), Name_Req, Variable_Ref);\n+\n+         --  A slice is side effect free if it is a side effect free\n+         --  prefixed reference and the bounds are side effect free.\n+\n+         when N_Slice =>\n+            return Side_Effect_Free\n+                     (Discrete_Range (N), Name_Req, Variable_Ref)\n+              and then Safe_Prefixed_Reference (N);\n+\n+         --  A type conversion is side effect free if the expression to be\n+         --  converted is side effect free.\n+\n+         when N_Type_Conversion =>\n+            return Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n+\n+         --  A unary operator is side effect free if the operand\n+         --  is side effect free.\n+\n+         when N_Unary_Op =>\n+            return Side_Effect_Free (Right_Opnd (N), Name_Req, Variable_Ref);\n+\n+         --  An unchecked type conversion is side effect free only if it\n+         --  is safe and its argument is side effect free.\n+\n+         when N_Unchecked_Type_Conversion =>\n+            return Safe_Unchecked_Type_Conversion (N)\n+              and then\n+                Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n+\n+         --  An unchecked expression is side effect free if its expression\n+         --  is side effect free.\n+\n+         when N_Unchecked_Expression =>\n+            return Side_Effect_Free (Expression (N), Name_Req, Variable_Ref);\n+\n+         --  A literal is side effect free\n+\n+         when N_Character_Literal    |\n+              N_Integer_Literal      |\n+              N_Real_Literal         |\n+              N_String_Literal       =>\n+            return True;\n+\n+         --  We consider that anything else has side effects. This is a bit\n+         --  crude, but we are pretty close for most common cases, and we\n+         --  are certainly correct (i.e. we never return True when the\n+         --  answer should be False).\n+\n+         when others =>\n+            return False;\n+      end case;\n+   end Side_Effect_Free;\n+\n+   --  A list is side effect free if all elements of the list are side\n+   --  effect free.\n+\n+   function Side_Effect_Free\n+     (L            : List_Id;\n+      Name_Req     : Boolean := False;\n+      Variable_Ref : Boolean := False) return Boolean\n+   is\n+      N : Node_Id;\n+\n+   begin\n+      if L = No_List or else L = Error_List then\n+         return True;\n+\n+      else\n+         N := First (L);\n+         while Present (N) loop\n+            if not Side_Effect_Free (N, Name_Req, Variable_Ref) then\n+               return False;\n+            else\n+               Next (N);\n+            end if;\n+         end loop;\n+\n+         return True;\n+      end if;\n+   end Side_Effect_Free;\n+\n    ----------------------------------\n    -- Silly_Boolean_Array_Not_Test --\n    ----------------------------------"}, {"sha": "40a6fbeebd032e789c3b0dc1332af1f3b6b72b8c", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -770,14 +770,14 @@ package Exp_Util is\n    --  Given the node for a subexpression, this function replaces the node if\n    --  necessary by an equivalent subexpression that is guaranteed to be side\n    --  effect free. This is done by extracting any actions that could cause\n-   --  side effects, and inserting them using Insert_Actions into the tree to\n-   --  which Exp is attached. Exp must be analyzed and resolved before the call\n-   --  and is analyzed and resolved on return. The Name_Req may only be set to\n+   --  side effects, and inserting them using Insert_Actions into the tree\n+   --  to which Exp is attached. Exp must be analyzed and resolved before the\n+   --  call and is analyzed and resolved on return. Name_Req may only be set to\n    --  True if Exp has the form of a name, and the effect is to guarantee that\n    --  any replacement maintains the form of name. If Variable_Ref is set to\n    --  TRUE, a variable is considered as side effect (used in implementing\n-   --  Force_Evaluation). Note: after call to Remove_Side_Effects, it is safe\n-   --  to call New_Copy_Tree to obtain a copy of the resulting expression.\n+   --  Force_Evaluation). Note: after call to Remove_Side_Effects, it is\n+   --  safe to call New_Copy_Tree to obtain a copy of the resulting expression.\n \n    function Represented_As_Scalar (T : Entity_Id) return Boolean;\n    --  Returns True iff the implementation of this type in code generation\n@@ -826,6 +826,29 @@ package Exp_Util is\n    --  renamed subprogram. The node is rewritten to be an identifier that\n    --  refers directly to the renamed subprogram, given by entity E.\n \n+   function Side_Effect_Free\n+     (N            : Node_Id;\n+      Name_Req     : Boolean := False;\n+      Variable_Ref : Boolean := False) return Boolean;\n+   --  Determines if the tree N represents an expression that is known not\n+   --  to have side effects. If this function returns True, then for example\n+   --  a call to Remove_Side_Effects has no effect.\n+   --\n+   --  Name_Req controls the handling of volatile variable references. If\n+   --  Name_Req is False (the normal case), then volatile references are\n+   --  considered to be side effects. If Name_Req is True, then volatility\n+   --  of variables is ignored.\n+   --\n+   --  If Variable_Ref is True, then all variable references are considered to\n+   --  be side effects (regardless of volatility or the setting of Name_Req).\n+\n+   function Side_Effect_Free\n+     (L            : List_Id;\n+      Name_Req     : Boolean := False;\n+      Variable_Ref : Boolean := False) return Boolean;\n+   --  Determines if all elements of the list L are side effect free. Name_Req\n+   --  and Variable_Ref are as described above.\n+\n    procedure Silly_Boolean_Array_Not_Test (N : Node_Id; T : Entity_Id);\n    --  N is the node for a boolean array NOT operation, and T is the type of\n    --  the array. This routine deals with the silly case where the subtype of"}, {"sha": "fffa594d6261944dfddd987905c2f5bbb5ca5d59", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 167, "deletions": 53, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -149,9 +149,9 @@ package body Ch13 is\n    function Get_Aspect_Specifications\n      (Semicolon : Boolean := True) return List_Id\n    is\n-      Aspects : List_Id;\n-      Aspect  : Node_Id;\n       A_Id    : Aspect_Id;\n+      Aspect  : Node_Id;\n+      Aspects : List_Id;\n       OK      : Boolean;\n \n    begin\n@@ -173,27 +173,30 @@ package body Ch13 is\n       loop\n          OK := True;\n \n+         --  The aspect mark is not an identifier\n+\n          if Token /= Tok_Identifier then\n             Error_Msg_SC (\"aspect identifier expected\");\n \n+            --  Skip the whole aspect specification list\n+\n             if Semicolon then\n                Resync_Past_Semicolon;\n             end if;\n \n             return Aspects;\n          end if;\n \n-         --  We have an identifier (which should be an aspect identifier)\n-\n          A_Id := Get_Aspect_Id (Token_Name);\n          Aspect :=\n            Make_Aspect_Specification (Token_Ptr,\n              Identifier => Token_Node);\n \n-         --  No valid aspect identifier present\n+         --  The aspect mark is not recognized\n \n          if A_Id = No_Aspect then\n             Error_Msg_SC (\"aspect identifier expected\");\n+            OK := False;\n \n             --  Check bad spelling\n \n@@ -209,17 +212,23 @@ package body Ch13 is\n             Scan; -- past incorrect identifier\n \n             if Token = Tok_Apostrophe then\n-               Scan; -- past '\n+               Scan; -- past apostrophe\n                Scan; -- past presumably CLASS\n             end if;\n \n+            --  Attempt to parse the aspect definition by assuming it is an\n+            --  expression.\n+\n             if Token = Tok_Arrow then\n-               Scan; -- Past arrow\n+               Scan; -- past arrow\n                Set_Expression (Aspect, P_Expression);\n-               OK := False;\n+\n+            --  The aspect may behave as a boolean aspect\n \n             elsif Token = Tok_Comma then\n-               OK := False;\n+               null;\n+\n+            --  Otherwise the aspect contains a junk definition\n \n             else\n                if Semicolon then\n@@ -229,68 +238,66 @@ package body Ch13 is\n                return Aspects;\n             end if;\n \n-         --  OK aspect scanned\n+         --  Aspect mark is OK\n \n          else\n             Scan; -- past identifier\n \n             --  Check for 'Class present\n \n             if Token = Tok_Apostrophe then\n-               if not Class_Aspect_OK (A_Id) then\n-                  Error_Msg_Node_1 := Identifier (Aspect);\n-                  Error_Msg_SC (\"aspect& does not permit attribute here\");\n-                  Scan; -- past apostrophe\n-                  Scan; -- past presumed CLASS\n-                  OK := False;\n-\n-               else\n+               if Class_Aspect_OK (A_Id) then\n                   Scan; -- past apostrophe\n \n-                  if Token /= Tok_Identifier\n-                    or else Token_Name /= Name_Class\n+                  if Token = Tok_Identifier\n+                    and then Token_Name = Name_Class\n                   then\n+                     Scan; -- past CLASS\n+                     Set_Class_Present (Aspect);\n+                  else\n                      Error_Msg_SC (\"Class attribute expected here\");\n                      OK := False;\n \n                      if Token = Tok_Identifier then\n                         Scan; -- past identifier not CLASS\n                      end if;\n-\n-                  else\n-                     Scan; -- past CLASS\n-                     Set_Class_Present (Aspect);\n                   end if;\n+\n+               --  The aspect does not allow 'Class\n+\n+               else\n+                  Error_Msg_Node_1 := Identifier (Aspect);\n+                  Error_Msg_SC (\"aspect& does not permit attribute here\");\n+                  OK := False;\n+\n+                  Scan; -- past apostrophe\n+                  Scan; -- past presumably CLASS\n                end if;\n             end if;\n \n-            --  Test case of missing aspect definition\n+            --  Check for a missing aspect definition. Aspects with optional\n+            --  definitions are not considered.\n \n-            if Token = Tok_Comma\n-              or else Token = Tok_Semicolon\n-            then\n+            if Token = Tok_Comma or else Token = Tok_Semicolon then\n                if Aspect_Argument (A_Id) /= Optional_Expression\n-                    and then\n-                  Aspect_Argument (A_Id) /= Optional_Name\n+                 and then Aspect_Argument (A_Id) /= Optional_Name\n                then\n                   Error_Msg_Node_1 := Identifier (Aspect);\n                   Error_Msg_AP (\"aspect& requires an aspect definition\");\n                   OK := False;\n                end if;\n \n+            --  Check for a missing arrow when the aspect has a definition\n+\n             elsif not Semicolon and then Token /= Tok_Arrow then\n                if Aspect_Argument (A_Id) /= Optional_Expression\n-                    and then\n-                  Aspect_Argument (A_Id) /= Optional_Name\n+                 and then Aspect_Argument (A_Id) /= Optional_Name\n                then\n-                  --  The name or expression may be there, but the arrow is\n-                  --  missing. Skip to the end of the declaration.\n-\n                   T_Arrow;\n                   Resync_To_Semicolon;\n                end if;\n \n-            --  Here we have an aspect definition\n+            --  Otherwise we have an aspect definition\n \n             else\n                if Token = Tok_Arrow then\n@@ -300,9 +307,107 @@ package body Ch13 is\n                   OK := False;\n                end if;\n \n+               --  Detect a common error where the non-null definition of\n+               --  aspect Depends, Global, Refined_Depends or Refined_Global\n+               --  must be enclosed in parentheses.\n+\n+               if Token /= Tok_Left_Paren and then Token /= Tok_Null then\n+\n+                  --  [Refined_]Depends\n+\n+                  if A_Id = Aspect_Depends\n+                       or else\n+                     A_Id = Aspect_Refined_Depends\n+                  then\n+                     Error_Msg_SC -- CODEFIX\n+                       (\"missing \"\"(\"\"\");\n+                     Resync_Past_Malformed_Aspect;\n+\n+                     --  Return when the current aspect is the last in the list\n+                     --  of specifications and the list applies to a body.\n+\n+                     if Token = Tok_Is then\n+                        return Aspects;\n+                     end if;\n+\n+                  --  [Refined_]Global\n+\n+                  elsif A_Id = Aspect_Global\n+                          or else\n+                        A_Id = Aspect_Refined_Global\n+                  then\n+                     declare\n+                        Scan_State : Saved_Scan_State;\n+\n+                     begin\n+                        Save_Scan_State (Scan_State);\n+                        Scan; -- past item or mode_selector\n+\n+                        --  Emit an error when the aspect has a mode_selector\n+                        --  as the moded_global_list must be parenthesized:\n+                        --    with Global => Output => Item\n+\n+                        if Token = Tok_Arrow then\n+                           Restore_Scan_State (Scan_State);\n+                           Error_Msg_SC -- CODEFIX\n+                             (\"missing \"\"(\"\"\");\n+                           Resync_Past_Malformed_Aspect;\n+\n+                           --  Return when the current aspect is the last in\n+                           --  the list of specifications and the list applies\n+                           --  to a body.\n+\n+                           if Token = Tok_Is then\n+                              return Aspects;\n+                           end if;\n+\n+                        elsif Token = Tok_Comma then\n+                           Scan; -- past comma\n+\n+                           --  An item followed by a comma does not need to\n+                           --  be parenthesized if the next token is a valid\n+                           --  aspect name:\n+                           --    with Global => Item,\n+                           --         Aspect => ...\n+\n+                           if Token = Tok_Identifier\n+                             and then Get_Aspect_Id (Token_Name) /= No_Aspect\n+                           then\n+                              Restore_Scan_State (Scan_State);\n+\n+                           --  Otherwise this is a list of items in which case\n+                           --  the list must be parenthesized.\n+\n+                           else\n+                              Restore_Scan_State (Scan_State);\n+                              Error_Msg_SC -- CODEFIX\n+                                (\"missing \"\"(\"\"\");\n+                              Resync_Past_Malformed_Aspect;\n+\n+                              --  Return when the current aspect is the last\n+                              --  in the list of specifications and the list\n+                              --  applies to a body.\n+\n+                              if Token = Tok_Is then\n+                                 return Aspects;\n+                              end if;\n+                           end if;\n+\n+                        --  The definition of [Refined_]Global does not need to\n+                        --  be parenthesized.\n+\n+                        else\n+                           Restore_Scan_State (Scan_State);\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n+\n+               --  Parse the aspect definition depening on the expected\n+               --  argument kind.\n+\n                if Aspect_Argument (A_Id) = Name\n-                    or else\n-                  Aspect_Argument (A_Id) = Optional_Name\n+                 or else Aspect_Argument (A_Id) = Optional_Name\n                then\n                   Set_Expression (Aspect, P_Name);\n \n@@ -315,18 +420,21 @@ package body Ch13 is\n                end if;\n             end if;\n \n-            --  If OK clause scanned, add it to the list\n+            --  Add the aspect to the resulting list only when it was properly\n+            --  parsed.\n \n             if OK then\n                Append (Aspect, Aspects);\n             end if;\n \n+            --  The aspect specification list contains more than one aspect\n+\n             if Token = Tok_Comma then\n                Scan; -- past comma\n                goto Continue;\n \n-            --  Recognize the case where a comma is missing between two\n-            --  aspects, issue an error and proceed with next aspect.\n+            --  Check for a missing comma between two aspects. Emit an error\n+            --  and proceed to the next aspect.\n \n             elsif Token = Tok_Identifier\n               and then Get_Aspect_Id (Token_Name) /= No_Aspect\n@@ -338,20 +446,25 @@ package body Ch13 is\n                   Save_Scan_State (Scan_State);\n                   Scan; -- past identifier\n \n-                  if Token = Tok_Arrow then\n+                  --  Attempt to detect ' or => following a potential aspect\n+                  --  mark.\n+\n+                  if Token = Tok_Apostrophe or else Token = Tok_Arrow then\n                      Restore_Scan_State (Scan_State);\n                      Error_Msg_AP -- CODEFIX\n                        (\"|missing \"\",\"\"\");\n                      goto Continue;\n \n+                  --  The construct following the current aspect is not an\n+                  --  aspect.\n+\n                   else\n                      Restore_Scan_State (Scan_State);\n                   end if;\n                end;\n \n-            --  Recognize the case where a semicolon was mistyped for a comma\n-            --  between two aspects, issue an error and proceed with next\n-            --  aspect.\n+            --  Check for a mistyped semicolon in place of a comma between two\n+            --  aspects. Emit an error and proceed to the next aspect.\n \n             elsif Token = Tok_Semicolon then\n                declare\n@@ -366,20 +479,22 @@ package body Ch13 is\n                   then\n                      Scan; -- past identifier\n \n-                     if Token = Tok_Arrow then\n+                     --  Attempt to detect ' or => following a potential aspect\n+                     --  mark.\n+\n+                     if Token = Tok_Apostrophe or else Token = Tok_Arrow then\n                         Restore_Scan_State (Scan_State);\n                         Error_Msg_SC -- CODEFIX\n                           (\"|\"\";\"\" should be \"\",\"\"\");\n                         Scan; -- past semicolon\n                         goto Continue;\n-\n-                     else\n-                        Restore_Scan_State (Scan_State);\n                      end if;\n-\n-                  else\n-                     Restore_Scan_State (Scan_State);\n                   end if;\n+\n+                  --  The construct following the current aspect is not an\n+                  --  aspect.\n+\n+                  Restore_Scan_State (Scan_State);\n                end;\n             end if;\n \n@@ -397,7 +512,6 @@ package body Ch13 is\n       end loop;\n \n       return Aspects;\n-\n    end Get_Aspect_Specifications;\n \n    --------------------------------------------"}, {"sha": "83987da8f5a06c10c9a79584fd9a4a076053d422", "filename": "gcc/ada/par-sync.adb", "status": "modified", "additions": 115, "deletions": 51, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar-sync.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar-sync.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-sync.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -148,54 +148,83 @@ package body Sync is\n       end if;\n    end Resync_Init;\n \n-   ---------------------------\n-   -- Resync_Past_Semicolon --\n-   ---------------------------\n+   ----------------------------------\n+   -- Resync_Past_Malformed_Aspect --\n+   ----------------------------------\n \n-   procedure Resync_Past_Semicolon is\n+   procedure Resync_Past_Malformed_Aspect is\n    begin\n       Resync_Init;\n \n       loop\n-         --  Done if we are at a semicolon\n+         --  A comma may separate two aspect specifications, but it may also\n+         --  delimit multiple arguments of a single aspect.\n \n-         if Token = Tok_Semicolon then\n-            Scan; -- past semicolon\n+         if Token = Tok_Comma then\n+            declare\n+               Scan_State : Saved_Scan_State;\n+\n+            begin\n+               Save_Scan_State (Scan_State);\n+               Scan; -- past comma\n+\n+               --  The identifier following the comma is a valid aspect, the\n+               --  current malformed aspect has been successfully skipped.\n+\n+               if Token = Tok_Identifier\n+                 and then Get_Aspect_Id (Token_Name) /= No_Aspect\n+               then\n+                  Restore_Scan_State (Scan_State);\n+                  exit;\n+\n+               --  The comma is delimiting multiple arguments of an aspect\n+\n+               else\n+                  Restore_Scan_State (Scan_State);\n+               end if;\n+            end;\n+\n+         --  An IS signals the last aspect specification when the related\n+         --  context is a body.\n+\n+         elsif Token = Tok_Is then\n             exit;\n \n-         --  Done if we are at a token which normally appears only after\n-         --  a semicolon. One special glitch is that the keyword private is\n-         --  in this category only if it does NOT appear after WITH.\n+         --  A semicolon signals the last aspect specification\n \n-         elsif Token in Token_Class_After_SM\n-            and then (Token /= Tok_Private or else Prev_Token /= Tok_With)\n-         then\n+         elsif Token = Tok_Semicolon then\n             exit;\n \n-         --  Otherwise keep going\n+         --  In the case of a mistyped semicolon, any token which follows a\n+         --  semicolon signals the last aspect specification.\n \n-         else\n-            Scan;\n+         elsif Token in Token_Class_After_SM then\n+            exit;\n          end if;\n+\n+         --  Keep on resyncing\n+\n+         Scan;\n       end loop;\n \n       --  Fall out of loop with resynchronization complete\n \n       Resync_Resume;\n-   end Resync_Past_Semicolon;\n+   end Resync_Past_Malformed_Aspect;\n \n-   -------------------------\n-   -- Resync_To_Semicolon --\n-   -------------------------\n+   ---------------------------\n+   -- Resync_Past_Semicolon --\n+   ---------------------------\n \n-   procedure Resync_To_Semicolon is\n+   procedure Resync_Past_Semicolon is\n    begin\n       Resync_Init;\n \n       loop\n          --  Done if we are at a semicolon\n \n          if Token = Tok_Semicolon then\n+            Scan; -- past semicolon\n             exit;\n \n          --  Done if we are at a token which normally appears only after\n@@ -217,7 +246,7 @@ package body Sync is\n       --  Fall out of loop with resynchronization complete\n \n       Resync_Resume;\n-   end Resync_To_Semicolon;\n+   end Resync_Past_Semicolon;\n \n    ----------------------------------------------\n    -- Resync_Past_Semicolon_Or_To_Loop_Or_Then --\n@@ -275,35 +304,6 @@ package body Sync is\n       end if;\n    end Resync_Resume;\n \n-   --------------------\n-   -- Resync_To_When --\n-   --------------------\n-\n-   procedure Resync_To_When is\n-   begin\n-      Resync_Init;\n-\n-      loop\n-         --  Done if at semicolon, WHEN or IS\n-\n-         if Token = Tok_Semicolon\n-           or else Token = Tok_When\n-           or else Token = Tok_Is\n-         then\n-            exit;\n-\n-         --  Otherwise keep going\n-\n-         else\n-            Scan;\n-         end if;\n-      end loop;\n-\n-      --  Fall out of loop with resynchronization complete\n-\n-      Resync_Resume;\n-   end Resync_To_When;\n-\n    ---------------------------\n    -- Resync_Semicolon_List --\n    ---------------------------\n@@ -340,4 +340,68 @@ package body Sync is\n       Resync_Resume;\n    end Resync_Semicolon_List;\n \n+   -------------------------\n+   -- Resync_To_Semicolon --\n+   -------------------------\n+\n+   procedure Resync_To_Semicolon is\n+   begin\n+      Resync_Init;\n+\n+      loop\n+         --  Done if we are at a semicolon\n+\n+         if Token = Tok_Semicolon then\n+            exit;\n+\n+         --  Done if we are at a token which normally appears only after\n+         --  a semicolon. One special glitch is that the keyword private is\n+         --  in this category only if it does NOT appear after WITH.\n+\n+         elsif Token in Token_Class_After_SM\n+           and then (Token /= Tok_Private or else Prev_Token /= Tok_With)\n+         then\n+            exit;\n+\n+         --  Otherwise keep going\n+\n+         else\n+            Scan;\n+         end if;\n+      end loop;\n+\n+      --  Fall out of loop with resynchronization complete\n+\n+      Resync_Resume;\n+   end Resync_To_Semicolon;\n+\n+   --------------------\n+   -- Resync_To_When --\n+   --------------------\n+\n+   procedure Resync_To_When is\n+   begin\n+      Resync_Init;\n+\n+      loop\n+         --  Done if at semicolon, WHEN or IS\n+\n+         if Token = Tok_Semicolon\n+           or else Token = Tok_When\n+           or else Token = Tok_Is\n+         then\n+            exit;\n+\n+         --  Otherwise keep going\n+\n+         else\n+            Scan;\n+         end if;\n+      end loop;\n+\n+      --  Fall out of loop with resynchronization complete\n+\n+      Resync_Resume;\n+   end Resync_To_When;\n+\n end Sync;"}, {"sha": "7de8458d58b0074639d1e4e9b94f744594d58123", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -1079,6 +1079,10 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  advanced to the next vertical bar, arrow, or semicolon, whichever\n       --  comes first. We also quit if we encounter an end of file.\n \n+      procedure Resync_Cunit;\n+      --  Synchronize to next token which could be the start of a compilation\n+      --  unit, or to the end of file token.\n+\n       procedure Resync_Expression;\n       --  Used if an error is detected during the parsing of an expression.\n       --  It skips past tokens until either a token which cannot be part of\n@@ -1087,37 +1091,38 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  current parenthesis level (a parenthesis level counter is maintained\n       --  to carry out this test).\n \n+      procedure Resync_Past_Malformed_Aspect;\n+      --  Used when parsing aspect specifications to skip a malformed aspect.\n+      --  The scan pointer is positioned next to a comma, a semicolon or \"is\"\n+      --  when the aspect applies to a body.\n+\n       procedure Resync_Past_Semicolon;\n       --  Used if an error occurs while scanning a sequence of declarations.\n       --  The scan pointer is positioned past the next semicolon and the scan\n       --  resumes. The scan is also resumed on encountering a token which\n       --  starts a declaration (but we make sure to skip at least one token\n       --  in this case, to avoid getting stuck in a loop).\n \n-      procedure Resync_To_Semicolon;\n-      --  Similar to Resync_Past_Semicolon, except that the scan pointer is\n-      --  left pointing to the semicolon rather than past it.\n-\n       procedure Resync_Past_Semicolon_Or_To_Loop_Or_Then;\n       --  Used if an error occurs while scanning a sequence of statements. The\n       --  scan pointer is positioned past the next semicolon, or to the next\n       --  occurrence of either then or loop, and the scan resumes.\n \n-      procedure Resync_To_When;\n-      --  Used when an error occurs scanning an entry index specification. The\n-      --  scan pointer is positioned to the next WHEN (or to IS or semicolon if\n-      --  either of these appear before WHEN, indicating another error has\n-      --  occurred).\n-\n       procedure Resync_Semicolon_List;\n       --  Used if an error occurs while scanning a parenthesized list of items\n       --  separated by semicolons. The scan pointer is advanced to the next\n       --  semicolon or right parenthesis at the outer parenthesis level, or\n       --  to the next is or RETURN keyword occurrence, whichever comes first.\n \n-      procedure Resync_Cunit;\n-      --  Synchronize to next token which could be the start of a compilation\n-      --  unit, or to the end of file token.\n+      procedure Resync_To_Semicolon;\n+      --  Similar to Resync_Past_Semicolon, except that the scan pointer is\n+      --  left pointing to the semicolon rather than past it.\n+\n+      procedure Resync_To_When;\n+      --  Used when an error occurs scanning an entry index specification. The\n+      --  scan pointer is positioned to the next WHEN (or to IS or semicolon if\n+      --  either of these appear before WHEN, indicating another error has\n+      --  occurred).\n    end Sync;\n \n    --------------"}, {"sha": "af476c0da825225fef29d93efe4690b16a4d81e0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb252d824eac519413d0114a813543391c10592/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=adb252d824eac519413d0114a813543391c10592", "patch": "@@ -649,9 +649,8 @@ package Sinfo is\n    --    Mod for signed integer types is expanded into equivalent expressions\n    --    using Rem (which is % in C) and other C-available operators.\n \n-   --    The Actions list of an Expression_With_Actions node has any object\n-   --    declarations removed, so that it is composed only of expressions\n-   --    (so that DO X,... Y IN Z can be represented as (X, .. Y, Z) in C).\n+   --    The Actions list of an Expression_With_Actions node does not contain\n+   --    any declarations,(so that DO X, .. Y IN Z becomes (X, .. Y, Z) in C).\n \n    ------------------------------------\n    -- Description of Semantic Fields --\n@@ -7426,11 +7425,8 @@ package Sinfo is\n       --  not a proper expression), and in the long term all cases of this\n       --  idiom should instead use a new node kind N_Compound_Statement.\n \n-      --  Note: In Modify_Tree_For_C, we eliminate declarations from the list\n-      --  of actions, inserting them at the outer level. If we move an object\n-      --  declaration with an initialization expression in this manner, then\n-      --  the action is replaced by an appropriate assignment, otherwise it is\n-      --  removed from the list of actions.\n+      --  Note: In Modify_Tree_For_C, we never generate any declarations in\n+      --  the action list, which can contain only non-declarative statements.\n \n       --------------------\n       -- Free Statement --"}]}