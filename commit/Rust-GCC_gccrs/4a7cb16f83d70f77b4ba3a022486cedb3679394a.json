{"sha": "4a7cb16f83d70f77b4ba3a022486cedb3679394a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3Y2IxNmY4M2Q3MGY3N2I0YmEzYTAyMjQ4NmNlZGIzNjc5Mzk0YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2013-10-24T19:02:44Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2013-10-24T19:02:44Z"}, "message": "builtins.c (dummy_object, [...]): Move to gimplify.c.\n\n\n\n\t* builtins.c (dummy_object, gimplify_va_arg_expr): Move to gimplify.c.\n\t* gimplify.c (build_va_arg_indirect_ref, std_gimplify_va_arg_expr):\n\tMove to targhooks.c.\n\t(dummy_object, gimplify_va_arg_expr): Relocate from builtins.c.\n\t* targhooks.c (build_va_arg_indirect_ref, std_gimplify_va_arg_expr):\n\tRelocate from gimplify.c.\n\t* targhooks.h: Add 2 prototypes.\n\t* tree.h. Delete 2 prototypes.\n\nFrom-SVN: r204032", "tree": {"sha": "8e5d786c4996eaadcbdecf7ae75cd2cf03575a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e5d786c4996eaadcbdecf7ae75cd2cf03575a95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a7cb16f83d70f77b4ba3a022486cedb3679394a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7cb16f83d70f77b4ba3a022486cedb3679394a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7cb16f83d70f77b4ba3a022486cedb3679394a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7cb16f83d70f77b4ba3a022486cedb3679394a/comments", "author": null, "committer": null, "parents": [{"sha": "f258df2d19bfd37f1458d71e32cf206fe6b34bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f258df2d19bfd37f1458d71e32cf206fe6b34bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f258df2d19bfd37f1458d71e32cf206fe6b34bb0"}], "stats": {"total": 410, "additions": 211, "deletions": 199}, "files": [{"sha": "3f23ec6937d3cae70126b7bcc19f4e4cdaa06615", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -1,3 +1,14 @@\n+2013-10-24  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* builtins.c (dummy_object, gimplify_va_arg_expr): Move to gimplify.c.\n+\t* gimplify.c (build_va_arg_indirect_ref, std_gimplify_va_arg_expr):\n+\tMove to targhooks.c.\n+\t(dummy_object, gimplify_va_arg_expr): Relocate from builtins.c.\n+\t* targhooks.c (build_va_arg_indirect_ref, std_gimplify_va_arg_expr):\n+\tRelocate from gimplify.c.\n+\t* targhooks.h: Add 2 prototypes.\n+\t* tree.h: Delete 2 prototypes.\n+\n 2013-10-24  Igor Shevlyakov  <igor.shevlyakov@gmail.com>\n \n \t* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p ): Check both"}, {"sha": "b380c2c6d0b70c729f2c8354fa23fa733499afa8", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -4234,110 +4234,6 @@ expand_builtin_va_start (tree exp)\n   return const0_rtx;\n }\n \n-\n-/* Return a dummy expression of type TYPE in order to keep going after an\n-   error.  */\n-\n-static tree\n-dummy_object (tree type)\n-{\n-  tree t = build_int_cst (build_pointer_type (type), 0);\n-  return build2 (MEM_REF, type, t, t);\n-}\n-\n-/* Gimplify __builtin_va_arg, aka VA_ARG_EXPR, which is not really a\n-   builtin function, but a very special sort of operator.  */\n-\n-enum gimplify_status\n-gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n-{\n-  tree promoted_type, have_va_type;\n-  tree valist = TREE_OPERAND (*expr_p, 0);\n-  tree type = TREE_TYPE (*expr_p);\n-  tree t;\n-  location_t loc = EXPR_LOCATION (*expr_p);\n-\n-  /* Verify that valist is of the proper type.  */\n-  have_va_type = TREE_TYPE (valist);\n-  if (have_va_type == error_mark_node)\n-    return GS_ERROR;\n-  have_va_type = targetm.canonical_va_list_type (have_va_type);\n-\n-  if (have_va_type == NULL_TREE)\n-    {\n-      error_at (loc, \"first argument to %<va_arg%> not of type %<va_list%>\");\n-      return GS_ERROR;\n-    }\n-\n-  /* Generate a diagnostic for requesting data of a type that cannot\n-     be passed through `...' due to type promotion at the call site.  */\n-  if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n-\t   != type)\n-    {\n-      static bool gave_help;\n-      bool warned;\n-\n-      /* Unfortunately, this is merely undefined, rather than a constraint\n-\t violation, so we cannot make this an error.  If this call is never\n-\t executed, the program is still strictly conforming.  */\n-      warned = warning_at (loc, 0,\n-\t  \t\t   \"%qT is promoted to %qT when passed through %<...%>\",\n-\t\t\t   type, promoted_type);\n-      if (!gave_help && warned)\n-\t{\n-\t  gave_help = true;\n-\t  inform (loc, \"(so you should pass %qT not %qT to %<va_arg%>)\",\n-\t\t  promoted_type, type);\n-\t}\n-\n-      /* We can, however, treat \"undefined\" any way we please.\n-\t Call abort to encourage the user to fix the program.  */\n-      if (warned)\n-\tinform (loc, \"if this code is reached, the program will abort\");\n-      /* Before the abort, allow the evaluation of the va_list\n-\t expression to exit or longjmp.  */\n-      gimplify_and_add (valist, pre_p);\n-      t = build_call_expr_loc (loc,\n-\t\t\t       builtin_decl_implicit (BUILT_IN_TRAP), 0);\n-      gimplify_and_add (t, pre_p);\n-\n-      /* This is dead code, but go ahead and finish so that the\n-\t mode of the result comes out right.  */\n-      *expr_p = dummy_object (type);\n-      return GS_ALL_DONE;\n-    }\n-  else\n-    {\n-      /* Make it easier for the backends by protecting the valist argument\n-\t from multiple evaluations.  */\n-      if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n-\t{\n-\t  /* For this case, the backends will be expecting a pointer to\n-\t     TREE_TYPE (abi), but it's possible we've\n-\t     actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n-\t     So fix it.  */\n-\t  if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n-\t    {\n-\t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n-\t      valist = fold_convert_loc (loc, p1,\n-\t\t\t\t\t build_fold_addr_expr_loc (loc, valist));\n-\t    }\n-\n-\t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n-\t}\n-      else\n-\tgimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n-\n-      if (!targetm.gimplify_va_arg_expr)\n-\t/* FIXME: Once most targets are converted we should merely\n-\t   assert this is non-null.  */\n-\treturn GS_ALL_DONE;\n-\n-      *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);\n-      return GS_OK;\n-    }\n-}\n-\n /* Expand EXP, a call to __builtin_va_end.  */\n \n static rtx"}, {"sha": "d5b535d2bfb1d30eb1a358f577f3579539572592", "filename": "gcc/gimplify.c", "status": "modified", "additions": 82, "deletions": 93, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -9258,118 +9258,107 @@ force_gimple_operand_gsi (gimple_stmt_iterator *gsi, tree expr,\n \t\t\t\t     var, before, m);\n }\n \n-#ifndef PAD_VARARGS_DOWN\n-#define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n-#endif\n+/* Return a dummy expression of type TYPE in order to keep going after an\n+   error.  */\n \n-/* Build an indirect-ref expression over the given TREE, which represents a\n-   piece of a va_arg() expansion.  */\n-tree\n-build_va_arg_indirect_ref (tree addr)\n+static tree\n+dummy_object (tree type)\n {\n-  addr = build_simple_mem_ref_loc (EXPR_LOCATION (addr), addr);\n-\n-  if (flag_mudflap) /* Don't instrument va_arg INDIRECT_REF.  */\n-    mf_mark (addr);\n-\n-  return addr;\n+  tree t = build_int_cst (build_pointer_type (type), 0);\n+  return build2 (MEM_REF, type, t, t);\n }\n \n-/* The \"standard\" implementation of va_arg: read the value from the\n-   current (padded) address and increment by the (padded) size.  */\n+/* Gimplify __builtin_va_arg, aka VA_ARG_EXPR, which is not really a\n+   builtin function, but a very special sort of operator.  */\n \n-tree\n-std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n-\t\t\t  gimple_seq *post_p)\n-{\n-  tree addr, t, type_size, rounded_size, valist_tmp;\n-  unsigned HOST_WIDE_INT align, boundary;\n-  bool indirect;\n-\n-#ifdef ARGS_GROW_DOWNWARD\n-  /* All of the alignment and movement below is for args-grow-up machines.\n-     As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n-     implement their own specialized gimplify_va_arg_expr routines.  */\n-  gcc_unreachable ();\n-#endif\n-\n-  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n-  if (indirect)\n-    type = build_pointer_type (type);\n+enum gimplify_status\n+gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n+{\n+  tree promoted_type, have_va_type;\n+  tree valist = TREE_OPERAND (*expr_p, 0);\n+  tree type = TREE_TYPE (*expr_p);\n+  tree t;\n+  location_t loc = EXPR_LOCATION (*expr_p);\n \n-  align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  boundary = targetm.calls.function_arg_boundary (TYPE_MODE (type), type);\n+  /* Verify that valist is of the proper type.  */\n+  have_va_type = TREE_TYPE (valist);\n+  if (have_va_type == error_mark_node)\n+    return GS_ERROR;\n+  have_va_type = targetm.canonical_va_list_type (have_va_type);\n \n-  /* When we align parameter on stack for caller, if the parameter\n-     alignment is beyond MAX_SUPPORTED_STACK_ALIGNMENT, it will be\n-     aligned at MAX_SUPPORTED_STACK_ALIGNMENT.  We will match callee\n-     here with caller.  */\n-  if (boundary > MAX_SUPPORTED_STACK_ALIGNMENT)\n-    boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n+  if (have_va_type == NULL_TREE)\n+    {\n+      error_at (loc, \"first argument to %<va_arg%> not of type %<va_list%>\");\n+      return GS_ERROR;\n+    }\n \n-  boundary /= BITS_PER_UNIT;\n+  /* Generate a diagnostic for requesting data of a type that cannot\n+     be passed through `...' due to type promotion at the call site.  */\n+  if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n+\t   != type)\n+    {\n+      static bool gave_help;\n+      bool warned;\n \n-  /* Hoist the valist value into a temporary for the moment.  */\n-  valist_tmp = get_initialized_tmp_var (valist, pre_p, NULL);\n+      /* Unfortunately, this is merely undefined, rather than a constraint\n+\t violation, so we cannot make this an error.  If this call is never\n+\t executed, the program is still strictly conforming.  */\n+      warned = warning_at (loc, 0,\n+\t  \t\t   \"%qT is promoted to %qT when passed through %<...%>\",\n+\t\t\t   type, promoted_type);\n+      if (!gave_help && warned)\n+\t{\n+\t  gave_help = true;\n+\t  inform (loc, \"(so you should pass %qT not %qT to %<va_arg%>)\",\n+\t\t  promoted_type, type);\n+\t}\n \n-  /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n-     requires greater alignment, we must perform dynamic alignment.  */\n-  if (boundary > align\n-      && !integer_zerop (TYPE_SIZE (type)))\n-    {\n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  fold_build_pointer_plus_hwi (valist_tmp, boundary - 1));\n+      /* We can, however, treat \"undefined\" any way we please.\n+\t Call abort to encourage the user to fix the program.  */\n+      if (warned)\n+\tinform (loc, \"if this code is reached, the program will abort\");\n+      /* Before the abort, allow the evaluation of the va_list\n+\t expression to exit or longjmp.  */\n+      gimplify_and_add (valist, pre_p);\n+      t = build_call_expr_loc (loc,\n+\t\t\t       builtin_decl_implicit (BUILT_IN_TRAP), 0);\n       gimplify_and_add (t, pre_p);\n \n-      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  fold_build2 (BIT_AND_EXPR, TREE_TYPE (valist),\n-\t\t\t       valist_tmp,\n-\t\t\t       build_int_cst (TREE_TYPE (valist), -boundary)));\n-      gimplify_and_add (t, pre_p);\n+      /* This is dead code, but go ahead and finish so that the\n+\t mode of the result comes out right.  */\n+      *expr_p = dummy_object (type);\n+      return GS_ALL_DONE;\n     }\n   else\n-    boundary = align;\n-\n-  /* If the actual alignment is less than the alignment of the type,\n-     adjust the type accordingly so that we don't assume strict alignment\n-     when dereferencing the pointer.  */\n-  boundary *= BITS_PER_UNIT;\n-  if (boundary < TYPE_ALIGN (type))\n     {\n-      type = build_variant_type_copy (type);\n-      TYPE_ALIGN (type) = boundary;\n-    }\n+      /* Make it easier for the backends by protecting the valist argument\n+\t from multiple evaluations.  */\n+      if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n+\t{\n+\t  /* For this case, the backends will be expecting a pointer to\n+\t     TREE_TYPE (abi), but it's possible we've\n+\t     actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n+\t     So fix it.  */\n+\t  if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n+\t    {\n+\t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n+\t      valist = fold_convert_loc (loc, p1,\n+\t\t\t\t\t build_fold_addr_expr_loc (loc, valist));\n+\t    }\n \n-  /* Compute the rounded size of the type.  */\n-  type_size = size_in_bytes (type);\n-  rounded_size = round_up (type_size, align);\n+\t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n+\t}\n+      else\n+\tgimplify_expr (&valist, pre_p, post_p, is_gimple_min_lval, fb_lvalue);\n \n-  /* Reduce rounded_size so it's sharable with the postqueue.  */\n-  gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n+      if (!targetm.gimplify_va_arg_expr)\n+\t/* FIXME: Once most targets are converted we should merely\n+\t   assert this is non-null.  */\n+\treturn GS_ALL_DONE;\n \n-  /* Get AP.  */\n-  addr = valist_tmp;\n-  if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n-    {\n-      /* Small args are padded downward.  */\n-      t = fold_build2_loc (input_location, GT_EXPR, sizetype,\n-\t\t       rounded_size, size_int (align));\n-      t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n-\t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n-      addr = fold_build_pointer_plus (addr, t);\n+      *expr_p = targetm.gimplify_va_arg_expr (valist, type, pre_p, post_p);\n+      return GS_OK;\n     }\n-\n-  /* Compute new value for AP.  */\n-  t = fold_build_pointer_plus (valist_tmp, rounded_size);\n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n-  gimplify_and_add (t, pre_p);\n-\n-  addr = fold_convert (build_pointer_type (type), addr);\n-\n-  if (indirect)\n-    addr = build_va_arg_indirect_ref (addr);\n-\n-  return build_va_arg_indirect_ref (addr);\n }\n \n #include \"gt-gimplify.h\""}, {"sha": "bee404d52f7f907dbb93c105e6c22d7031005f65", "filename": "gcc/targhooks.c", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssanames.h\"\n #include \"tree-ssa-alias.h\"\n #include \"insn-codes.h\"\n+#include \"tree-mudflap.h\"\n \n \n bool\n@@ -1565,4 +1566,119 @@ default_canonicalize_comparison (int *, rtx *, rtx *, bool)\n {\n }\n \n+#ifndef PAD_VARARGS_DOWN\n+#define PAD_VARARGS_DOWN BYTES_BIG_ENDIAN\n+#endif\n+\n+/* Build an indirect-ref expression over the given TREE, which represents a\n+   piece of a va_arg() expansion.  */\n+tree\n+build_va_arg_indirect_ref (tree addr)\n+{\n+  addr = build_simple_mem_ref_loc (EXPR_LOCATION (addr), addr);\n+\n+  if (flag_mudflap) /* Don't instrument va_arg INDIRECT_REF.  */\n+    mf_mark (addr);\n+\n+  return addr;\n+}\n+\n+/* The \"standard\" implementation of va_arg: read the value from the\n+   current (padded) address and increment by the (padded) size.  */\n+\n+tree\n+std_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t  gimple_seq *post_p)\n+{\n+  tree addr, t, type_size, rounded_size, valist_tmp;\n+  unsigned HOST_WIDE_INT align, boundary;\n+  bool indirect;\n+\n+#ifdef ARGS_GROW_DOWNWARD\n+  /* All of the alignment and movement below is for args-grow-up machines.\n+     As of 2004, there are only 3 ARGS_GROW_DOWNWARD targets, and they all\n+     implement their own specialized gimplify_va_arg_expr routines.  */\n+  gcc_unreachable ();\n+#endif\n+\n+  indirect = pass_by_reference (NULL, TYPE_MODE (type), type, false);\n+  if (indirect)\n+    type = build_pointer_type (type);\n+\n+  align = PARM_BOUNDARY / BITS_PER_UNIT;\n+  boundary = targetm.calls.function_arg_boundary (TYPE_MODE (type), type);\n+\n+  /* When we align parameter on stack for caller, if the parameter\n+     alignment is beyond MAX_SUPPORTED_STACK_ALIGNMENT, it will be\n+     aligned at MAX_SUPPORTED_STACK_ALIGNMENT.  We will match callee\n+     here with caller.  */\n+  if (boundary > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\n+  boundary /= BITS_PER_UNIT;\n+\n+  /* Hoist the valist value into a temporary for the moment.  */\n+  valist_tmp = get_initialized_tmp_var (valist, pre_p, NULL);\n+\n+  /* va_list pointer is aligned to PARM_BOUNDARY.  If argument actually\n+     requires greater alignment, we must perform dynamic alignment.  */\n+  if (boundary > align\n+      && !integer_zerop (TYPE_SIZE (type)))\n+    {\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+\t\t  fold_build_pointer_plus_hwi (valist_tmp, boundary - 1));\n+      gimplify_and_add (t, pre_p);\n+\n+      t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n+\t\t  fold_build2 (BIT_AND_EXPR, TREE_TYPE (valist),\n+\t\t\t       valist_tmp,\n+\t\t\t       build_int_cst (TREE_TYPE (valist), -boundary)));\n+      gimplify_and_add (t, pre_p);\n+    }\n+  else\n+    boundary = align;\n+\n+  /* If the actual alignment is less than the alignment of the type,\n+     adjust the type accordingly so that we don't assume strict alignment\n+     when dereferencing the pointer.  */\n+  boundary *= BITS_PER_UNIT;\n+  if (boundary < TYPE_ALIGN (type))\n+    {\n+      type = build_variant_type_copy (type);\n+      TYPE_ALIGN (type) = boundary;\n+    }\n+\n+  /* Compute the rounded size of the type.  */\n+  type_size = size_in_bytes (type);\n+  rounded_size = round_up (type_size, align);\n+\n+  /* Reduce rounded_size so it's sharable with the postqueue.  */\n+  gimplify_expr (&rounded_size, pre_p, post_p, is_gimple_val, fb_rvalue);\n+\n+  /* Get AP.  */\n+  addr = valist_tmp;\n+  if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n+    {\n+      /* Small args are padded downward.  */\n+      t = fold_build2_loc (input_location, GT_EXPR, sizetype,\n+\t\t       rounded_size, size_int (align));\n+      t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n+\t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n+      addr = fold_build_pointer_plus (addr, t);\n+    }\n+\n+  /* Compute new value for AP.  */\n+  t = fold_build_pointer_plus (valist_tmp, rounded_size);\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n+  gimplify_and_add (t, pre_p);\n+\n+  addr = fold_convert (build_pointer_type (type), addr);\n+\n+  if (indirect)\n+    addr = build_va_arg_indirect_ref (addr);\n+\n+  return build_va_arg_indirect_ref (addr);\n+}\n+\n+\n #include \"gt-targhooks.h\""}, {"sha": "48de2a8b53cdef40213d3c1c11b21ca3a4234f69", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -202,3 +202,5 @@ extern void default_asm_output_ident_directive (const char*);\n \n extern enum machine_mode default_cstore_mode (enum insn_code);\n extern bool default_member_type_forces_blk (const_tree, enum machine_mode);\n+extern tree build_va_arg_indirect_ref (tree);\n+extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);"}, {"sha": "7732d6926d0fdba3b26297dfc3a16b766a17a789", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7cb16f83d70f77b4ba3a022486cedb3679394a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4a7cb16f83d70f77b4ba3a022486cedb3679394a", "patch": "@@ -4508,8 +4508,6 @@ extern tree build_call_expr_loc (location_t, tree, int, ...);\n extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree c_strlen (tree, int);\n-extern tree std_gimplify_va_arg_expr (tree, tree, gimple_seq *, gimple_seq *);\n-extern tree build_va_arg_indirect_ref (tree);\n extern tree build_string_literal (int, const char *);\n extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);"}]}