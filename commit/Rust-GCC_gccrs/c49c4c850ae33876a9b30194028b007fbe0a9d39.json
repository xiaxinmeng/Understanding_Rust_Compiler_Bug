{"sha": "c49c4c850ae33876a9b30194028b007fbe0a9d39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ5YzRjODUwYWUzMzg3NmE5YjMwMTk0MDI4YjAwN2ZiZTBhOWQzOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-13T12:59:34Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-13T12:59:34Z"}, "message": "invoke.texi (SPARC options): Document -mfix-at697f.\n\n\t* doc/invoke.texi (SPARC options): Document -mfix-at697f.\n\t* config/sparc/sparc.opt (mfix-at697f): New option.\n\t* config/sparc/sparc.c (TARGET_MACHINE_DEPENDENT_REORG): Define.\n\t(sparc_reorg): New function.\n\nFrom-SVN: r179921", "tree": {"sha": "feddc9b4cf6fbc50bb402d91410999c749063ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/feddc9b4cf6fbc50bb402d91410999c749063ec6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c49c4c850ae33876a9b30194028b007fbe0a9d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49c4c850ae33876a9b30194028b007fbe0a9d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49c4c850ae33876a9b30194028b007fbe0a9d39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49c4c850ae33876a9b30194028b007fbe0a9d39/comments", "author": null, "committer": null, "parents": [{"sha": "83e0724ec706dfab4de4278d8819c84d2c548829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e0724ec706dfab4de4278d8819c84d2c548829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e0724ec706dfab4de4278d8819c84d2c548829"}], "stats": {"total": 121, "additions": 117, "deletions": 4}, "files": [{"sha": "5ecfe95b34abcb407d1dd2ddf71bc7c72b4fc838", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c49c4c850ae33876a9b30194028b007fbe0a9d39", "patch": "@@ -444,6 +444,7 @@ static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT, tree);\n static bool sparc_can_output_mi_thunk (const_tree, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, const_tree);\n+static void sparc_reorg (void);\n static struct machine_function * sparc_init_machine_status (void);\n static bool sparc_cannot_force_const_mem (enum machine_mode, rtx);\n static rtx sparc_tls_get_addr (void);\n@@ -582,6 +583,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK sparc_can_output_mi_thunk\n \n+#undef TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG sparc_reorg\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS sparc_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -10389,6 +10393,104 @@ sparc_can_output_mi_thunk (const_tree thunk_fndecl ATTRIBUTE_UNUSED,\n   return (vcall_offset >= -32768 || ! fixed_regs[5]);\n }\n \n+/* We use the machine specific reorg pass to enable workarounds for errata.  */\n+\n+static void\n+sparc_reorg (void)\n+{\n+  rtx insn, next;\n+\n+  /* The only erratum we handle for now is that of the AT697F processor.  */\n+  if (!sparc_fix_at697f)\n+    return;\n+\n+  /* We need to have the (essentially) final form of the insn stream in order\n+     to properly detect the various hazards.  Run delay slot scheduling.  */\n+  if (optimize > 0 && flag_delayed_branch)\n+    dbr_schedule (get_insns ());\n+\n+  /* Now look for specific patterns in the insn stream.  */\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      bool insert_nop = false;\n+      rtx set;\n+\n+      /* Look for a single-word load into an odd-numbered FP register.  */\n+      if (NONJUMP_INSN_P (insn)\n+\t  && (set = single_set (insn)) != NULL_RTX\n+\t  && GET_MODE_SIZE (GET_MODE (SET_SRC (set))) == 4\n+\t  && MEM_P (SET_SRC (set))\n+\t  && REG_P (SET_DEST (set))\n+\t  && REGNO (SET_DEST (set)) > 31\n+\t  && REGNO (SET_DEST (set)) % 2 != 0)\n+\t{\n+\t  /* The wrong dependency is on the enclosing double register.  */\n+\t  unsigned int x = REGNO (SET_DEST (set)) - 1;\n+\t  unsigned int src1, src2, dest;\n+\t  int code;\n+\n+\t  /* If the insn has a delay slot, then it cannot be problematic.  */\n+\t  next = next_active_insn (insn);\n+\t  if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n+\t    code = -1;\n+\t  else\n+\t    {\n+\t      extract_insn (next);\n+\t      code = INSN_CODE (next);\n+\t    }\n+\n+\t  switch (code)\n+\t    {\n+\t    case CODE_FOR_adddf3:\n+\t    case CODE_FOR_subdf3:\n+\t    case CODE_FOR_muldf3:\n+\t    case CODE_FOR_divdf3:\n+\t      dest = REGNO (recog_data.operand[0]);\n+\t      src1 = REGNO (recog_data.operand[1]);\n+\t      src2 = REGNO (recog_data.operand[2]);\n+\t      if (src1 != src2)\n+\t\t{\n+\t\t  /* Case [1-4]:\n+\t\t\t\t ld [address], %fx+1\n+\t\t\t\t FPOPd %f{x,y}, %f{y,x}, %f{x,y}  */\n+\t\t  if ((src1 == x || src2 == x)\n+\t\t      && (dest == src1 || dest == src2))\n+\t\t    insert_nop = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Case 5:\n+\t\t\t     ld [address], %fx+1\n+\t\t\t     FPOPd %fx, %fx, %fx  */\n+\t\t  if (src1 == x\n+\t\t      && dest == src1\n+\t\t      && (code == CODE_FOR_adddf3 || code == CODE_FOR_muldf3))\n+\t\t    insert_nop = true;\n+\t\t}\n+\t      break;\n+\n+\t    case CODE_FOR_sqrtdf2:\n+\t      dest = REGNO (recog_data.operand[0]);\n+\t      src1 = REGNO (recog_data.operand[1]);\n+\t      /* Case 6:\n+\t\t\t ld [address], %fx+1\n+\t\t\t fsqrtd %fx, %fx  */\n+\t      if (src1 == x && dest == src1)\n+\t\tinsert_nop = true;\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      else\n+\tnext = NEXT_INSN (insn);\n+\n+      if (insert_nop)\n+\temit_insn_after (gen_nop (), insn);\n+    }\n+}\n+\n /* How to allocate a 'struct machine_function'.  */\n \n static struct machine_function *"}, {"sha": "ca16e6de8adb151a7b039b636959ee400f06119c", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=c49c4c850ae33876a9b30194028b007fbe0a9d39", "patch": "@@ -184,6 +184,11 @@ mstd-struct-return\n Target Report RejectNegative Var(sparc_std_struct_return)\n Enable strict 32-bit psABI struct return checking.\n \n+mfix-at697f\n+Target Report RejectNegative Var(sparc_fix_at697f)\n+Enable workaround for single erratum of AT697F processor\n+(corresponding to erratum #13 of AT697E processor)\n+\n Mask(LITTLE_ENDIAN)\n ;; Generate code for little-endian\n "}, {"sha": "4df10ab7f92b5c676eca4d314cbb5bb3fcf768e3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c49c4c850ae33876a9b30194028b007fbe0a9d39/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c49c4c850ae33876a9b30194028b007fbe0a9d39", "patch": "@@ -885,7 +885,8 @@ See RS/6000 and PowerPC Options.\n -munaligned-doubles  -mno-unaligned-doubles @gol\n -mv8plus  -mno-v8plus  -mvis  -mno-vis @gol\n -mvis2  -mno-vis2  -mvis3  -mno-vis3 @gol\n--mfmaf  -mno-fmaf  -mpopc  -mno-popc}\n+-mfmaf  -mno-fmaf  -mpopc  -mno-popc @gol\n+-mfix-at697f}\n \n @emph{SPU Options}\n @gccoptlist{-mwarn-reloc -merror-reloc @gol\n@@ -4001,19 +4002,19 @@ The message is in keeping with the output of @option{-fstack-usage}.\n If the stack usage is fully static but exceeds the specified amount, it's:\n \n @smallexample\n-\ufffd warning: stack usage is 1120 bytes\n+  warning: stack usage is 1120 bytes\n @end smallexample\n @item\n If the stack usage is (partly) dynamic but bounded, it's:\n \n @smallexample\n-\ufffd warning: stack usage might be 1648 bytes\n+  warning: stack usage might be 1648 bytes\n @end smallexample\n @item\n If the stack usage is (partly) dynamic and not bounded, it's:\n \n @smallexample\n-\ufffd warning: stack usage might be unbounded\n+  warning: stack usage might be unbounded\n @end smallexample\n @end itemize\n \n@@ -17549,6 +17550,11 @@ With @option{-mfmaf}, GCC generates code that takes advantage of the UltraSPARC\n Fused Multiply-Add Floating-point extensions.  The default is @option{-mfmaf}\n when targetting a cpu that supports such instructions, such as Niagara-3 and\n later.\n+\n+@item -mfix-at697f\n+@opindex mfix-at697f\n+Enable the documented workaround for the single erratum of the Atmel AT697F\n+processor (which corresponds to erratum #13 of the AT697E processor).\n @end table\n \n These @samp{-m} options are supported in addition to the above"}]}