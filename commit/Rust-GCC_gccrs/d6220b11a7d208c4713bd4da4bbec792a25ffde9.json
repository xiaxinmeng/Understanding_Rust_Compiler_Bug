{"sha": "d6220b11a7d208c4713bd4da4bbec792a25ffde9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYyMjBiMTFhN2QyMDhjNDcxM2JkNGRhNGJiZWM3OTJhMjVmZmRlOQ==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2014-12-19T04:40:11Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2014-12-19T04:40:11Z"}, "message": "* Add TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV target macro.\n\nFrom-SVN: r218886", "tree": {"sha": "fd00faa99d4eef198022a52515e9b805f18b3d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd00faa99d4eef198022a52515e9b805f18b3d04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6220b11a7d208c4713bd4da4bbec792a25ffde9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6220b11a7d208c4713bd4da4bbec792a25ffde9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6220b11a7d208c4713bd4da4bbec792a25ffde9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6220b11a7d208c4713bd4da4bbec792a25ffde9/comments", "author": null, "committer": null, "parents": [{"sha": "70712859a1068dfd0683199fe6fa669280ecfec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70712859a1068dfd0683199fe6fa669280ecfec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70712859a1068dfd0683199fe6fa669280ecfec4"}], "stats": {"total": 64, "additions": 63, "deletions": 1}, "files": [{"sha": "315496c08a82010177c28cbb1878cacffdbd8730", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -1,3 +1,13 @@\n+2014-12-19  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* lra-constraints.c (get_equiv): Don't return memory equivalence\n+\twhen targetm.cannot_substitute_mem_equiv_p is true.\n+\t* target.def (cannot_substitute_mem_equiv_p): New hook.\n+\t* config/sh/sh.c (sh_cannot_substitute_mem_equiv_p): New function.\n+\t(TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P): Define.\n+\t* doc/tm.texi.in (TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\n 2014-12-19  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* lra-constraints.c (process_address_1): Swap base_term and"}, {"sha": "eb19c42894bb81f70ca356f0bece996d402b19ff", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -291,6 +291,7 @@ static reg_class_t sh_secondary_reload (bool, rtx, reg_class_t,\n static bool sh_legitimate_address_p (machine_mode, rtx, bool);\n static rtx sh_legitimize_address (rtx, rtx, machine_mode);\n static rtx sh_delegitimize_address (rtx);\n+static bool sh_cannot_substitute_mem_equiv_p (rtx);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n@@ -630,6 +631,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P\tsh_legitimate_address_p\n \n+#undef TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P\n+#define TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P sh_cannot_substitute_mem_equiv_p\n+\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT\t\tsh_trampoline_init\n #undef TARGET_TRAMPOLINE_ADJUST_ADDRESS\n@@ -13214,6 +13218,24 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Return true if SUBST can't safely replace its equivalent during RA.  */\n+static bool\n+sh_cannot_substitute_mem_equiv_p (rtx)\n+{\n+  if (TARGET_SHMEDIA)\n+    return false;\n+\n+  /* If SUBST is mem[base+index] or QI/HImode mem[base+disp], the insn\n+     uses R0 and may cause spill failure when R0 is already used.\n+     We have to return true for that case at least.\n+     Moreover SH has strong R0 parity and also have not enough numbers of\n+     the hard registers to make the equiv substitution win in the size\n+     and the speed on average working sets.  The pseudos produced to\n+     hold the equiv values can't get good hard registers for bad cases\n+     and end up memory save/restore insns which make the code worse.  */\n+  return true;\n+}\n+\n static void\n sh_conditional_register_usage (void)\n {"}, {"sha": "50e80f642263da7ed67f82fb81728e215c0c9f8f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -2847,6 +2847,16 @@ A target hook which returns true if we need register usage leveling.  That means\n A target hook which returns true if an address with the same structure  can have different maximal legitimate displacement.  For example, the  displacement can depend on memory mode or on operand combinations in  the insn.    The default version of this target hook returns always false.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P (rtx @var{subst})\n+A target hook which returns @code{true} if @var{subst} can't\n+substitute safely pseudos with equivalent memory values during\n+register allocation.\n+The default version of this target hook returns @code{false}.\n+On most machines, this default should be used.  For generally\n+machines with non orthogonal register usage for addressing, such\n+as SH, this hook can be used to avoid excessive spilling.\n+@end deftypefn\n+\n @deftypefn {Target Hook} reg_class_t TARGET_SPILL_CLASS (reg_class_t, @var{machine_mode})\n This hook defines a class of registers which could be used for spilling  pseudos of the given mode and class, or @code{NO_REGS} if only memory  should be used.  Not defining this hook is equivalent to returning  @code{NO_REGS} for all inputs.\n @end deftypefn"}, {"sha": "a99cc72b2e22d0771f665b7952fdc30719aaa670", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -2481,6 +2481,8 @@ as below:\n \n @hook TARGET_DIFFERENT_ADDR_DISPLACEMENT_P\n \n+@hook TARGET_CANNOT_SUBSTITUTE_MEM_EQUIV_P\n+\n @hook TARGET_SPILL_CLASS\n \n @hook TARGET_CSTORE_MODE"}, {"sha": "9e9539c1a845e7eaf3abd64e61eb67fef88592a4", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -488,7 +488,11 @@ get_equiv (rtx x)\n       || lra_get_regno_hard_regno (regno) >= 0)\n     return x;\n   if ((res = ira_reg_equiv[regno].memory) != NULL_RTX)\n-    return res;\n+    {\n+      if (targetm.cannot_substitute_mem_equiv_p (res))\n+\treturn x;\n+      return res;\n+    }\n   if ((res = ira_reg_equiv[regno].constant) != NULL_RTX)\n     return res;\n   if ((res = ira_reg_equiv[regno].invariant) != NULL_RTX)"}, {"sha": "a380381695d1b44be5895887eca2aab8d95fa875", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b11a7d208c4713bd4da4bbec792a25ffde9/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d6220b11a7d208c4713bd4da4bbec792a25ffde9", "patch": "@@ -5037,6 +5037,20 @@ DEFHOOK\n  reg_class_t, (reg_class_t rclass),\n  default_preferred_rename_class)\n \n+/* This target hook allows the backend to avoid unsafe substitution\n+   during register allocation.  */\n+DEFHOOK\n+(cannot_substitute_mem_equiv_p,\n+ \"A target hook which returns @code{true} if @var{subst} can't\\n\\\n+substitute safely pseudos with equivalent memory values during\\n\\\n+register allocation.\\n\\\n+The default version of this target hook returns @code{false}.\\n\\\n+On most machines, this default should be used.  For generally\\n\\\n+machines with non orthogonal register usage for addressing, such\\n\\\n+as SH, this hook can be used to avoid excessive spilling.\",\n+ bool, (rtx subst),\n+ hook_bool_rtx_false)\n+\n /* This target hook allows the backend to perform additional\n    processing while initializing for variable expansion.  */\n DEFHOOK"}]}