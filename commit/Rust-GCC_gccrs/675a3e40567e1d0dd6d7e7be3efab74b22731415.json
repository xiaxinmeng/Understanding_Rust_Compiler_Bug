{"sha": "675a3e40567e1d0dd6d7e7be3efab74b22731415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc1YTNlNDA1NjdlMWQwZGQ2ZDdlN2JlM2VmYWI3NGIyMjczMTQxNQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-18T20:36:19Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-08-24T13:44:31Z"}, "message": "Add transitive operations to the relation oracle.\n\nWhen registering relations in the oracle, search for other relations which\nimply new transitive relations.\n\n\tgcc/\n\t* value-relation.cc (rr_transitive_table): New.\n\t(relation_transitive): New.\n\t(value_relation::swap): Remove.\n\t(value_relation::apply_transitive): New.\n\t(relation_oracle::relation_oracle): Allocate a new tmp bitmap.\n\t(relation_oracle::register_relation): Call register_transitives.\n\t(relation_oracle::register_transitives): New.\n\t* value-relation.h (relation_oracle): Add new temporary bitmap and\n\tmethods.\n\n\tgcc/testsuite/\n\t* gcc.dg/predict-1.c: Disable evrp.\n\t* gcc.dg/tree-ssa/evrp-trans.c: New.", "tree": {"sha": "5d16f2ce64a80674eaa79dcf3ccca2615686e014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d16f2ce64a80674eaa79dcf3ccca2615686e014"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/675a3e40567e1d0dd6d7e7be3efab74b22731415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675a3e40567e1d0dd6d7e7be3efab74b22731415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/675a3e40567e1d0dd6d7e7be3efab74b22731415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/675a3e40567e1d0dd6d7e7be3efab74b22731415/comments", "author": null, "committer": null, "parents": [{"sha": "d8b7282ea27e02f687272cb8ea5f66ca900f1582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8b7282ea27e02f687272cb8ea5f66ca900f1582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8b7282ea27e02f687272cb8ea5f66ca900f1582"}], "stats": {"total": 442, "additions": 410, "deletions": 32}, "files": [{"sha": "d2e753e624ed287869ae056fa70be7795c06ee3f", "filename": "gcc/testsuite/gcc.dg/predict-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-1.c?ref=675a3e40567e1d0dd6d7e7be3efab74b22731415", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate --disable-tree-evrp\" } */\n \n extern int global;\n "}, {"sha": "8ee8e3c3f42dca22bae83069c5d6fb6316c91ed4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/evrp-trans.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fevrp-trans.c?ref=675a3e40567e1d0dd6d7e7be3efab74b22731415", "patch": "@@ -0,0 +1,144 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+/* Simple tests to make sure transitives are working. */\n+void keep();\n+void kill();\n+\n+void\n+f1 (int x, int y, int z)\n+{\n+  if (x > y)\n+    if (y > z)\n+      {\n+\tif (x > z)\n+\t  keep ();\n+\telse\n+\t  kill ();\n+      }\n+}\n+\n+void\n+f2 (int w, int x, int y, int z)\n+{  \n+  // Test one equivalence.\n+  if (w == z)\n+    if (x > y)\n+      if (y > z)\n+\t{\n+\t  if (x > w)\n+\t    keep ();\n+\t  else\n+\t    kill ();\n+\t}\n+}\n+\n+void\n+f3 (int a, int w, int x, int y, int z)\n+{  \n+  // Test two equivlaences.\n+  if (a == x)\n+    if (w == z)\n+      if (x > y)\n+\tif (y > z)\n+\t  {\n+\t    if (a > w)\n+\t      keep ();\n+\t    else\n+\t      kill ();\n+\t  }\n+}\n+\n+void\n+f4 (int x, int y, int z)\n+{\n+  // test X > Y >= Z\n+  if (x > y)\n+    if (y >= z)\n+      {\n+        if (x > z)\n+          keep ();\n+        else\n+          kill ();\n+      }\n+}\n+void\n+f5 (int x, int y, int z)\n+{\n+  // test X >= Y > Z\n+  if (x >= y)\n+    if (y > z)\n+      {\n+        if (x > z)\n+          keep ();\n+        else\n+          kill ();\n+      }\n+}\n+\n+void\n+f6 (int x, int y, int z)\n+{\n+  // test X >= Y >= Z\n+  if (x >= y)\n+    if (y >= z)\n+      {\n+        if (x > z)\n+          keep ();\n+        else if (x == z)\n+\t  keep ();\n+         else\n+          kill ();\n+      }\n+}\n+\n+void\n+f7 (int x, int y, int z)\n+{\n+  // test Y <= X , Z <= Y\n+  if (y <= x)\n+    if (z <= y)\n+      {\n+        if (x > z)\n+          keep ();\n+        else if (x == z)\n+\t  keep ();\n+\telse\n+          kill ();\n+      }\n+}\n+\n+void\n+f8 (int x, int y, int z)\n+{\n+  // test X >= Y, Z <= Y\n+  if (x >= y)\n+    if (z <= y)\n+      {\n+        if (x > z)\n+          keep ();\n+        else if (x == z)\n+\t  keep ();\n+\telse\n+          kill ();\n+      }\n+}\n+\n+void\n+f9 (int x, int y, int z)\n+{\n+  // test Y <= X   Y >= Z\n+  if (y <= x)\n+    if (y >= z)\n+      {\n+        if (x > z)\n+          keep ();\n+        else if (x == z)\n+\t  keep ();\n+        else\n+          kill ();\n+      }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"kill\" \"evrp\" } }  */\n+/* { dg-final { scan-tree-dump-times \"keep\" 13 \"evrp\"} } */"}, {"sha": "8edd98b612a4074e683abf0196e9bf278b39e264", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 258, "deletions": 29, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=675a3e40567e1d0dd6d7e7be3efab74b22731415", "patch": "@@ -112,7 +112,7 @@ relation_kind rr_intersect_table[VREL_COUNT][VREL_COUNT] = {\n   { NE_EXPR, LT_EXPR, LT_EXPR, GT_EXPR, GT_EXPR, VREL_EMPTY, VREL_EMPTY, NE_EXPR } };\n \n \n-// Intersect relation R! with relation R2 and return the resulting relation.\n+// Intersect relation R1 with relation R2 and return the resulting relation.\n \n relation_kind\n relation_intersect (relation_kind r1, relation_kind r2)\n@@ -155,6 +155,39 @@ relation_union (relation_kind r1, relation_kind r2)\n }\n \n \n+// This table is used to determine transitivity between 2 relations.\n+// (A relation0 B) and (B relation1 C) implies  (A result C)\n+\n+relation_kind rr_transitive_table[VREL_COUNT][VREL_COUNT] = {\n+//   NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, EMPTY, EQ_EXPR, NE_EXPR\n+// VREL_NONE\n+  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n+// LT_EXPR\n+  { VREL_NONE, LT_EXPR, LT_EXPR, VREL_NONE, VREL_NONE, VREL_NONE, LT_EXPR, VREL_NONE },\n+// LE_EXPR\n+  { VREL_NONE, LT_EXPR, LE_EXPR, VREL_NONE, VREL_NONE, VREL_NONE, LE_EXPR, VREL_NONE },\n+// GT_EXPR\n+  { VREL_NONE, VREL_NONE, VREL_NONE, GT_EXPR, GT_EXPR, VREL_NONE, GT_EXPR, VREL_NONE },\n+// GE_EXPR\n+  { VREL_NONE, VREL_NONE, VREL_NONE, GT_EXPR, GE_EXPR, VREL_NONE, GE_EXPR, VREL_NONE },\n+// VREL_EMPTY\n+  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE },\n+// EQ_EXPR\n+  { VREL_NONE, LT_EXPR, LE_EXPR, GT_EXPR, GE_EXPR, VREL_NONE, EQ_EXPR, VREL_NONE },\n+// NE_EXPR\n+  { VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE, VREL_NONE } };\n+\n+// Apply transitive operation between relation R1 and relation R2, and\n+// return the resulting relation, if any.\n+\n+relation_kind\n+relation_transitive (relation_kind r1, relation_kind r2)\n+{\n+  vrel_range_assert (r1);\n+  vrel_range_assert (r2);\n+  return rr_transitive_table[r1 - VREL_FIRST][r2 - VREL_FIRST];\n+}\n+\n // -------------------------------------------------------------------------\n \n // This class represents an equivalency set, and contains a link to the next\n@@ -472,7 +505,7 @@ class value_relation\n   bool union_ (value_relation &p);\n   bool intersect (value_relation &p);\n   void negate ();\n-  void swap ();\n+  bool apply_transitive (const value_relation &rel);\n \n   void dump (FILE *f) const;\n private:\n@@ -517,14 +550,6 @@ value_relation::negate ()\n   related = relation_negate (related);\n }\n \n-// Modify the relation as if the operands were being swapped.\n-\n-void\n-value_relation::swap ()\n-{\n-  related = relation_swap (related);\n-}\n-\n // Perform an intersection between 2 relations. *this &&= p.\n \n bool\n@@ -561,6 +586,73 @@ value_relation::union_ (value_relation &p)\n   return old != related;\n }\n \n+// Identify and apply any transitive relations between REL\n+// and THIS.  Return true if there was a transformation.\n+\n+bool\n+value_relation::apply_transitive (const value_relation &rel)\n+{\n+  relation_kind k = VREL_NONE;\n+\n+  // Idenity any common operand, and notrmalize the relations to\n+  // the form : A < B  B < C produces A < C\n+  if (rel.op1 () == name2)\n+    {\n+      // A < B   B < C\n+      if (rel.op2 () == name1)\n+\treturn false;\n+      k = relation_transitive (kind (), rel.kind ());\n+      if (k != VREL_NONE)\n+\t{\n+\t  related = k;\n+\t  name2 = rel.op2 ();\n+\t  return true;\n+\t}\n+    }\n+  else if (rel.op1 () == name1)\n+    {\n+      // B > A   B < C\n+      if (rel.op2 () == name2)\n+\treturn false;\n+      k = relation_transitive (relation_swap (kind ()), rel.kind ());\n+      if (k != VREL_NONE)\n+\t{\n+\t  related = k;\n+\t  name1 = name2;\n+\t  name2 = rel.op2 ();\n+\t  return true;\n+\t}\n+    }\n+  else if (rel.op2 () == name2)\n+    {\n+       // A < B   C > B\n+       if (rel.op1 () == name1)\n+\t return false;\n+      k = relation_transitive (kind (), relation_swap (rel.kind ()));\n+      if (k != VREL_NONE)\n+\t{\n+\t  related = k;\n+\t  name2 = rel.op1 ();\n+\t  return true;\n+\t}\n+    }\n+  else if (rel.op2 () == name1)\n+    {\n+      // B > A  C > B\n+      if (rel.op1 () == name2)\n+\treturn false;\n+      k = relation_transitive (relation_swap (kind ()),\n+\t\t\t       relation_swap (rel.kind ()));\n+      if (k != VREL_NONE)\n+\t{\n+\t  related = k;\n+\t  name1 = name2;\n+\t  name2 = rel.op1 ();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n \n // Dump the relation to file F.\n \n@@ -597,6 +689,7 @@ relation_oracle::relation_oracle ()\n   m_relations.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n   m_relation_set = BITMAP_ALLOC (&m_bitmaps);\n   m_tmp = BITMAP_ALLOC (&m_bitmaps);\n+  m_tmp2 = BITMAP_ALLOC (&m_bitmaps);\n }\n \n // Destruct a relation oracle.\n@@ -669,10 +762,12 @@ relation_oracle::register_relation (edge e, relation_kind k, tree op1,\n // Register relation K between OP! and OP2 in block BB.\n // This creates the record and searches for existing records in the dominator\n // tree to merge with.\n+// TRANSITIVE_P is true if this is being registered as a transitive operation,\n+// and should not try to register further transitives.\n \n void\n relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n-\t\t\t\t    tree op2)\n+\t\t\t\t    tree op2, bool transitive_p)\n {\n   gcc_checking_assert (k != VREL_NONE);\n \n@@ -710,26 +805,160 @@ relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n \t  ptr->dump (dump_file);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      return;\n+    }\n+  else\n+    {\n+      // Check for an existing relation further up the DOM chain.\n+      // By including dominating relations, The first one found in any search\n+      // will be the aggregate of all the previous ones.\n+      curr = find_relation_dom (bb, v1, v2);\n+      if (curr != VREL_NONE)\n+\tk = relation_intersect (curr, k);\n+\n+      bitmap_set_bit (bm, v1);\n+      bitmap_set_bit (bm, v2);\n+      bitmap_set_bit (m_relation_set, v1);\n+      bitmap_set_bit (m_relation_set, v2);\n+\n+      ptr = (relation_chain *) obstack_alloc (&m_chain_obstack,\n+\t\t\t\t\t      sizeof (relation_chain));\n+      ptr->set_relation (k, op1, op2);\n+      ptr->m_next = m_relations[bbi].m_head;\n+      m_relations[bbi].m_head = ptr;;\n     }\n \n-  // Check for an existing relation further up the DOM chain.\n-  // By including dominating relations, The first one found in any search\n-  // will be the aggregate of all the previous ones.\n-  curr = find_relation_dom (bb, v1, v2);\n-  if (curr != VREL_NONE)\n-    k = relation_intersect (curr, k);\n-\n-  bitmap_set_bit (bm, v1);\n-  bitmap_set_bit (bm, v2);\n-  bitmap_set_bit (m_relation_set, v1);\n-  bitmap_set_bit (m_relation_set, v2);\n-\n-  ptr = (relation_chain *) obstack_alloc (&m_chain_obstack,\n-\t\t\t\t\t  sizeof (relation_chain));\n-  ptr->set_relation (k, op1, op2);\n-  ptr->m_next = m_relations[bbi].m_head;\n-  m_relations[bbi].m_head = ptr;;\n+  if (!transitive_p)\n+    register_transitives (bb, *ptr);\n+}\n+\n+// Starting at ROOT_BB search the DOM tree  looking for relations which\n+// may produce transitive relations to RELATION.  EQUIV1 and EQUIV2 are\n+// bitmaps for op1/op2 and any of their equivalences that should also be\n+// considered.\n+\n+void\n+relation_oracle::register_transitives (basic_block root_bb,\n+\t\t\t\t       const value_relation &relation,\n+\t\t\t\t       const_bitmap equiv1,\n+\t\t\t\t       const_bitmap equiv2)\n+{\n+  basic_block bb;\n+  for (bb = root_bb; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    {\n+      int bbi = bb->index;\n+      if (bbi >= (int)m_relations.length())\n+\tcontinue;\n+      const_bitmap bm = m_relations[bbi].m_names;\n+      if (!bm)\n+\tcontinue;\n+      if (!bitmap_intersect_p (bm, equiv1) && !bitmap_intersect_p (bm, equiv2))\n+\tcontinue;\n+      // At least one of the 2 ops has a relation in this block.\n+      relation_chain *ptr;\n+      for (ptr = m_relations[bbi].m_head; ptr ; ptr = ptr->m_next)\n+\t{\n+\t  // In the presence of an equivalence, 2 operands may do not\n+\t  // naturally match. ie  with equivalence a_2 == b_3\n+\t  // given c_1 < a_2 && b_3 < d_4\n+\t  // convert the second relation (b_3 < d_4) to match any\n+\t  // equivalences to found in the first relation.\n+\t  // ie convert b_3 < d_4 to a_2 < d_4, which then exposes the\n+\t  // transitive operation:  c_1 < a_2 && a_2 < d_4 -> c_1 < d_4\n+\n+\t  tree r1, r2;\n+\t  tree p1 = ptr->op1 ();\n+\t  tree p2 = ptr->op2 ();\n+\t  // Find which equivalence is in the first operand.\n+\t  if (bitmap_bit_p (equiv1, SSA_NAME_VERSION (p1)))\n+\t    r1 = p1;\n+\t  else if (bitmap_bit_p (equiv1, SSA_NAME_VERSION (p2)))\n+\t    r1 = p2;\n+\t  else\n+\t    r1 = NULL_TREE;\n+\n+\t  // Find which equivalence is in the second operand.\n+\t  if (bitmap_bit_p (equiv2, SSA_NAME_VERSION (p1)))\n+\t    r2 = p1;\n+\t  else if (bitmap_bit_p (equiv2, SSA_NAME_VERSION (p2)))\n+\t    r2 = p2;\n+\t  else\n+\t    r2 = NULL_TREE;\n+\n+\t  // Ignore if both NULL (not relevant relation) or the same,\n+\t  if (r1 == r2)\n+\t    continue;\n+\n+\t  // Any operand not an equivalence, just take the real operand.\n+\t  if (!r1)\n+\t    r1 = relation.op1 ();\n+\t  if (!r2)\n+\t    r2 = relation.op2 ();\n+\n+\t  value_relation nr (relation.kind (), r1, r2);\n+\t  if (nr.apply_transitive (*ptr))\n+\t    {\n+\t      register_relation (root_bb, nr.kind (), nr.op1 (), nr.op2 (),\n+\t\t\t\t true);\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"   Registering transitive relation \");\n+\t\t  nr.dump (dump_file);\n+\t\t  fputc ('\\n', dump_file);\n+\t\t}\n+\t    }\n+\n+\t}\n+    }\n+}\n+\n+// Find adn register any transitive relations implied by RELATION occuring\n+// in block BB.\n+\n+void\n+relation_oracle::register_transitives (basic_block bb,\n+\t\t\t\t       const value_relation &relation)\n+{\n+  // Only apply transitives to certain kinds of operations.\n+  switch (relation.kind ())\n+    {\n+      case LE_EXPR:\n+      case LT_EXPR:\n+      case GT_EXPR:\n+      case GE_EXPR:\n+\tbreak;\n+      default:\n+\treturn;\n+    }\n+\n+  // Set up the bitmaps for op1 and op2, and if there are no equivalencies,\n+  // set just op1 or op2 in their own bitmap.\n+  const_bitmap equiv1 = equiv_set (relation.op1 (), bb);\n+  const_bitmap equiv2 = equiv_set (relation.op2 (), bb);\n+  if (equiv1)\n+    {\n+      if (equiv2)\n+\tregister_transitives (bb, relation, equiv1, equiv2);\n+      else\n+\t{\n+\t  bitmap_clear (m_tmp);\n+\t  bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op2 ()));\n+\t  register_transitives (bb, relation, equiv1, m_tmp);\n+\t}\n+    }\n+  else if (equiv2)\n+    {\n+      bitmap_clear (m_tmp);\n+      bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op1 ()));\n+      register_transitives (bb, relation, m_tmp, equiv2);\n+    }\n+  else\n+    {\n+      bitmap_clear (m_tmp);\n+      bitmap_clear (m_tmp2);\n+      bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op1 ()));\n+      bitmap_set_bit (m_tmp2, SSA_NAME_VERSION (relation.op2 ()));\n+      register_transitives (bb, relation, m_tmp, m_tmp2);\n+    }\n }\n \n // Find the relation between any ssa_name in B1 and any name in B2 in block BB."}, {"sha": "e0e2f82c9aed66e72210baa97e6a3655a7ca0e94", "filename": "gcc/value-relation.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/675a3e40567e1d0dd6d7e7be3efab74b22731415/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=675a3e40567e1d0dd6d7e7be3efab74b22731415", "patch": "@@ -143,7 +143,7 @@ class relation_oracle : public equiv_oracle\n   void dump (FILE *f, basic_block bb) const;\n   void dump (FILE *f) const;\n private:\n-  bitmap m_tmp;\n+  bitmap m_tmp, m_tmp2;\n   bitmap m_relation_set;  // Index by ssa-name. True if a relation exists\n   vec <relation_chain_head> m_relations;  // Index by BB, list of relations.\n   relation_kind find_relation_block (unsigned bb, const_bitmap b1,\n@@ -153,7 +153,12 @@ class relation_oracle : public equiv_oracle\n   relation_kind find_relation_block (int bb, unsigned v1, unsigned v2,\n \t\t\t\t     relation_chain **obj = NULL);\n   relation_kind find_relation_dom (basic_block bb, unsigned v1, unsigned v2);\n-  void register_relation (basic_block bb, relation_kind k, tree op1, tree op2);\n+  void register_relation (basic_block bb, relation_kind k, tree op1, tree op2,\n+\t\t\t  bool transitive_p = false);\n+  void register_transitives (basic_block, const class value_relation &);\n+  void register_transitives (basic_block, const value_relation &, const_bitmap,\n+\t\t\t     const_bitmap);\n+\n };\n \n #endif  /* GCC_VALUE_RELATION_H */"}]}