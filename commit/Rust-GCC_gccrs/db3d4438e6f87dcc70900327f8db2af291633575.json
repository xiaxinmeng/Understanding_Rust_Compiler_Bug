{"sha": "db3d4438e6f87dcc70900327f8db2af291633575", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzZDQ0MzhlNmY4N2RjYzcwOTAwMzI3ZjhkYjJhZjI5MTYzMzU3NQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-06-26T13:04:40Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-06-26T13:04:40Z"}, "message": "sparc.h (REGNO_OK_FOR_{INDEX,BASE,FP,CCFP}_P): Explicitly mark the constant being compared against as unsigned.\n\n\t* config/sparc/sparc.h (REGNO_OK_FOR_{INDEX,BASE,FP,CCFP}_P):\n\tExplicitly mark the constant being compared against as unsigned.\n\t* config/sparc/sparc.c (sparc_select, cpu_default, cpu_table):\n\tFully initialize final members.\n\t(mem_aligned_8): Explicit init of offset to zero.\n\t(output_function_prologue): Explicit init of n_regs to zero.\n\t(output_function_epilogue): Likewise, and mark arg size as\n\tunused.\n\t(init_cumulative_args): Mark libname and indirect as unused.\n\t(function_arg_pass_by_reference): Likewise for cum and named.\n\t(sparc_builtin_saveregs): Likewise for arglist.\n\t(sparc_flat_eligible_for_epilogue_delay): Likewise for slot.\n\nFrom-SVN: r20739", "tree": {"sha": "c0dc0fe2e0186aca62cf8248b6b7d8b8b9ac407a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0dc0fe2e0186aca62cf8248b6b7d8b8b9ac407a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3d4438e6f87dcc70900327f8db2af291633575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3d4438e6f87dcc70900327f8db2af291633575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3d4438e6f87dcc70900327f8db2af291633575", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3d4438e6f87dcc70900327f8db2af291633575/comments", "author": null, "committer": null, "parents": [{"sha": "ed4c4348a5c602d11652d3b2b3f449122142d3dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4c4348a5c602d11652d3b2b3f449122142d3dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed4c4348a5c602d11652d3b2b3f449122142d3dc"}], "stats": {"total": 52, "additions": 35, "deletions": 17}, "files": [{"sha": "87a4a7a87f07760bf3a9308dbbc65fe5589bc7b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3d4438e6f87dcc70900327f8db2af291633575", "patch": "@@ -1,3 +1,18 @@\n+Fri Jun 26 11:54:11 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.h (REGNO_OK_FOR_{INDEX,BASE,FP,CCFP}_P):\n+\tExplicitly mark the constant being compared against as unsigned.\n+\t* config/sparc/sparc.c (sparc_select, cpu_default, cpu_table):\n+\tFully initialize final members.\n+\t(mem_aligned_8): Explicit init of offset to zero.\n+\t(output_function_prologue): Explicit init of n_regs to zero.\n+\t(output_function_epilogue): Likewise, and mark arg size as\n+\tunused.\n+\t(init_cumulative_args): Mark libname and indirect as unused.\n+\t(function_arg_pass_by_reference): Likewise for cum and named.\n+\t(sparc_builtin_saveregs): Likewise for arglist.\n+\t(sparc_flat_eligible_for_epilogue_delay): Likewise for slot.\n+\n Fri Jun 26 06:58:54 1998  Richard Earnshaw (rearnsha@arm.com)\n \n \t* arm.h (SECONDARY_INPUT_RELOAD_CLASS): Only need a secondary reload"}, {"sha": "343fac88e5eb9c04af2df24f8574678b06a0694d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=db3d4438e6f87dcc70900327f8db2af291633575", "patch": "@@ -139,7 +139,7 @@ struct sparc_cpu_select sparc_select[] =\n   { (char *)0,\t\"default\",\t1,\t1 },\n   { (char *)0,\t\"-mcpu=\",\t1,\t1 },\n   { (char *)0,\t\"-mtune=\",\t1,\t0 },\n-  { 0, 0 }\n+  { 0, 0, 0, 0 }\n };\n \n /* CPU type.  This is set from TARGET_CPU_DEFAULT and -m{cpu,tune}=xxx.  */\n@@ -176,7 +176,7 @@ sparc_override_options ()\n     { TARGET_CPU_supersparc, \"supersparc\" },\n     { TARGET_CPU_v9, \"v9\" },\n     { TARGET_CPU_ultrasparc, \"ultrasparc\" },\n-    { 0 }\n+    { 0, 0 }\n   };\n   struct cpu_default *def;\n   /* Table of values for -m{cpu,tune}=.  */\n@@ -202,7 +202,7 @@ sparc_override_options ()\n     { \"v9\",         PROCESSOR_V9, MASK_ISA, MASK_V9 },\n     /* TI ultrasparc */\n     { \"ultrasparc\", PROCESSOR_ULTRASPARC, MASK_ISA, MASK_V9 },\n-    { 0 }\n+    { 0, 0, 0, 0 }\n   };\n   struct cpu_table *cpu;\n   struct sparc_cpu_select *sel;\n@@ -1878,7 +1878,7 @@ mem_aligned_8 (mem)\n      assumption.  */\n \n   /* See what register we use in the address.  */\n-  base = 0;\n+  base = offset = 0;\n   if (GET_CODE (addr) == PLUS)\n     {\n       if (GET_CODE (XEXP (addr, 0)) == REG\n@@ -3659,6 +3659,7 @@ output_function_prologue (file, size, leaf_function)\n \t  base = frame_base_name;\n \t}\n \n+      n_regs = 0;\n       if (TARGET_EPILOGUE && ! leaf_function)\n \t/* ??? Originally saved regs 0-15 here.  */\n \tn_regs = save_regs (file, 0, 8, base, offset, 0, real_offset);\n@@ -3684,7 +3685,7 @@ output_function_prologue (file, size, leaf_function)\n void\n output_function_epilogue (file, size, leaf_function)\n      FILE *file;\n-     int size;\n+     int size ATTRIBUTE_UNUSED;\n      int leaf_function;\n {\n   char *ret;\n@@ -3731,6 +3732,7 @@ output_function_epilogue (file, size, leaf_function)\n \t  base = frame_base_name;\n \t}\n \n+      n_regs = 0;\n       if (TARGET_EPILOGUE && ! leaf_function)\n \t/* ??? Originally saved regs 0-15 here.  */\n \tn_regs = restore_regs (file, 0, 8, base, offset, 0);\n@@ -3867,8 +3869,9 @@ output_function_epilogue (file, size, leaf_function)\n void\n init_cumulative_args (cum, fntype, libname, indirect)\n      CUMULATIVE_ARGS *cum;\n-     tree fntype, libname;\n-     int indirect;\n+     tree fntype;\n+     tree libname ATTRIBUTE_UNUSED;\n+     int indirect ATTRIBUTE_UNUSED;\n {\n   cum->words = 0;\n   cum->prototype_p = fntype && TYPE_ARG_TYPES (fntype);\n@@ -4515,10 +4518,10 @@ function_arg_partial_nregs (cum, mode, type, named)\n \n int\n function_arg_pass_by_reference (cum, mode, type, named)\n-     const CUMULATIVE_ARGS *cum;\n+     const CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n   if (TARGET_ARCH32)\n     {\n@@ -4667,7 +4670,7 @@ function_value (type, mode, incoming_p)\n \n rtx\n sparc_builtin_saveregs (arglist)\n-     tree arglist;\n+     tree arglist ATTRIBUTE_UNUSED;\n {\n   int first_reg = current_function_args_info.words;\n   rtx address;\n@@ -6408,7 +6411,7 @@ sparc_flat_epilogue_delay_slots ()\n int\n sparc_flat_eligible_for_epilogue_delay (trial, slot)\n      rtx trial;\n-     int slot;\n+     int slot ATTRIBUTE_UNUSED;\n {\n   rtx pat = PATTERN (trial);\n "}, {"sha": "198f256ba6c64c4d39fd5ba5d7123a5a8be71ed8", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3d4438e6f87dcc70900327f8db2af291633575/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=db3d4438e6f87dcc70900327f8db2af291633575", "patch": "@@ -2245,16 +2245,16 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    has been allocated, which happens in local-alloc.c.  */\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32U)\n #define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32U)\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-  (((unsigned) (REGNO) - 32 < (TARGET_V9 ? 64 : 32)) \\\n-   || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? 64 : 32)))\n+  (((unsigned) (REGNO) - 32 < (TARGET_V9 ? 64U : 32U)) \\\n+   || ((unsigned) reg_renumber[REGNO] - 32 < (TARGET_V9 ? 64U : 32U)))\n #define REGNO_OK_FOR_CCFP_P(REGNO) \\\n  (TARGET_V9 \\\n-  && (((unsigned) (REGNO) - 96 < 4) \\\n-      || ((unsigned) reg_renumber[REGNO] - 96 < 4)))\n+  && (((unsigned) (REGNO) - 96 < 4U) \\\n+      || ((unsigned) reg_renumber[REGNO] - 96 < 4U)))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class."}]}