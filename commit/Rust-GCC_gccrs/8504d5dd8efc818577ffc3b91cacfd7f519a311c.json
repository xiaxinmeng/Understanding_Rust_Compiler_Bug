{"sha": "8504d5dd8efc818577ffc3b91cacfd7f519a311c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUwNGQ1ZGQ4ZWZjODE4NTc3ZmZjM2I5MWNhY2ZkN2Y1MTlhMzExYw==", "commit": {"author": {"name": "Cesar Philippidis", "email": "cesar@codesourcery.com", "date": "2015-11-19T14:56:51Z"}, "committer": {"name": "Cesar Philippidis", "email": "cesar@gcc.gnu.org", "date": "2015-11-19T14:56:51Z"}, "message": "parser.h (struct cp_omp_declare_simd_data): Add clauses member.\n\n\tgcc/cp/\n\t* parser.h (struct cp_omp_declare_simd_data): Add clauses member.\n\t(struct cp_parser): Change type the of oacc_routine to\n\tcp_omp_declare_simd_data.\n\t* parser.c (cp_ensure_no_oacc_routine): Rework to use\n\tcp_omp_declare_simd_data.\n\t(cp_parser_simple_declaration): Remove boolean first.  Update call to\n\tcp_parser_init_declarator. Don't NULL out oacc_routine.\n\t(cp_parser_init_declarator): Remove boolean first parameter.  Update\n\tcalls to cp_finalize_oacc_routine.\n\t(cp_parser_late_return_type_opt): Handle acc routines. \n\t(cp_parser_member_declaration): Remove first variable.  Handle\n\tacc routines like omp declare simd.\n\t(cp_parser_function_definition_from_specifiers_and_declarator): Update\n\tcall to cp_finalize_oacc_routine.\n\t(cp_parser_single_declaration): Update call to\n\tcp_parser_init_declarator.\n\t(cp_parser_save_member_function_body): Remove first_decl parameter.\n\tUpdate call to cp_finalize_oacc_routine.\n\t(cp_parser_finish_oacc_routine): Delete.\n\t(cp_parser_oacc_routine): Rework to use cp_omp_declare_simd_data.\n\t(cp_parser_late_parsing_oacc_routine): New function.\n\t(cp_finalize_oacc_routine): Remove first argument.  Add more error\n\thandling and set the acc routine and 'omp declare target' attributes.\n\t(cp_parser_pragma): Remove unnecessary call to\n\tcp_ensure_no_oacc_routine.\n\nFrom-SVN: r230607", "tree": {"sha": "364cbbd307a4a08c1812a6f247257f86197e6799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/364cbbd307a4a08c1812a6f247257f86197e6799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8504d5dd8efc818577ffc3b91cacfd7f519a311c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8504d5dd8efc818577ffc3b91cacfd7f519a311c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8504d5dd8efc818577ffc3b91cacfd7f519a311c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8504d5dd8efc818577ffc3b91cacfd7f519a311c/comments", "author": {"login": "cesarjp", "id": 4576177, "node_id": "MDQ6VXNlcjQ1NzYxNzc=", "avatar_url": "https://avatars.githubusercontent.com/u/4576177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cesarjp", "html_url": "https://github.com/cesarjp", "followers_url": "https://api.github.com/users/cesarjp/followers", "following_url": "https://api.github.com/users/cesarjp/following{/other_user}", "gists_url": "https://api.github.com/users/cesarjp/gists{/gist_id}", "starred_url": "https://api.github.com/users/cesarjp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cesarjp/subscriptions", "organizations_url": "https://api.github.com/users/cesarjp/orgs", "repos_url": "https://api.github.com/users/cesarjp/repos", "events_url": "https://api.github.com/users/cesarjp/events{/privacy}", "received_events_url": "https://api.github.com/users/cesarjp/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6c164570bd3d97ff77ca4e95c0c09df29ef85065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c164570bd3d97ff77ca4e95c0c09df29ef85065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c164570bd3d97ff77ca4e95c0c09df29ef85065"}], "stats": {"total": 390, "additions": 277, "deletions": 113}, "files": [{"sha": "024290c16d04af7be5245abe02170cffe38746fd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8504d5dd8efc818577ffc3b91cacfd7f519a311c", "patch": "@@ -1,3 +1,31 @@\n+2015-11-19  Cesar Philippidis  <cesar@codesourcery.com>\n+\n+\t* parser.h (struct cp_omp_declare_simd_data): Add clauses member.\n+\t(struct cp_parser): Change type the of oacc_routine to\n+\tcp_omp_declare_simd_data.\n+\t* parser.c (cp_ensure_no_oacc_routine): Rework to use\n+\tcp_omp_declare_simd_data.\n+\t(cp_parser_simple_declaration): Remove boolean first.  Update call to\n+\tcp_parser_init_declarator. Don't NULL out oacc_routine.\n+\t(cp_parser_init_declarator): Remove boolean first parameter.  Update\n+\tcalls to cp_finalize_oacc_routine.\n+\t(cp_parser_late_return_type_opt): Handle acc routines.\n+\t(cp_parser_member_declaration): Remove first variable.  Handle\n+\tacc routines like omp declare simd.\n+\t(cp_parser_function_definition_from_specifiers_and_declarator): Update\n+\tcall to cp_finalize_oacc_routine.\n+\t(cp_parser_single_declaration): Update call to\n+\tcp_parser_init_declarator.\n+\t(cp_parser_save_member_function_body): Remove first_decl parameter.\n+\tUpdate call to cp_finalize_oacc_routine.\n+\t(cp_parser_finish_oacc_routine): Delete.\n+\t(cp_parser_oacc_routine): Rework to use cp_omp_declare_simd_data.\n+\t(cp_parser_late_parsing_oacc_routine): New function.\n+\t(cp_finalize_oacc_routine): Remove first argument.  Add more error\n+\thandling and set the acc routine and 'omp declare target' attributes.\n+\t(cp_parser_pragma): Remove unnecessary call to\n+\tcp_ensure_no_oacc_routine.\n+\n 2015-11-17  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* cp-gimplify.c (cp_fold_r): Add support for OACC_LOOP."}, {"sha": "30cde0bc678e3cc0276da937272b4898c4730ccb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 246, "deletions": 111, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8504d5dd8efc818577ffc3b91cacfd7f519a311c", "patch": "@@ -241,7 +241,7 @@ static bool cp_parser_omp_declare_reduction_exprs\n static tree cp_parser_cilk_simd_vectorlength \n   (cp_parser *, tree, bool);\n static void cp_finalize_oacc_routine\n-  (cp_parser *, tree, bool, bool);\n+  (cp_parser *, tree, bool);\n \n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n@@ -1318,13 +1318,21 @@ cp_finalize_omp_declare_simd (cp_parser *parser, tree fndecl)\n     }\n }\n \n-/* Diagnose if #pragma omp routine isn't followed immediately\n-   by function declaration or definition.   */\n+/* Diagnose if #pragma acc routine isn't followed immediately by function\n+   declaration or definition.  */\n \n static inline void\n cp_ensure_no_oacc_routine (cp_parser *parser)\n {\n-  cp_finalize_oacc_routine (parser, NULL_TREE, false, true);\n+  if (parser->oacc_routine && !parser->oacc_routine->error_seen)\n+    {\n+      tree clauses = parser->oacc_routine->clauses;\n+      location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n+\n+      error_at (loc, \"%<#pragma oacc routine%> not followed by function \"\n+\t\t\"declaration or definition\");\n+      parser->oacc_routine = NULL;\n+    }\n }\n \f\n /* Decl-specifiers.  */\n@@ -2130,7 +2138,7 @@ static tree cp_parser_decltype\n \n static tree cp_parser_init_declarator\n   (cp_parser *, cp_decl_specifier_seq *, vec<deferred_access_check, va_gc> *,\n-   bool, bool, int, bool *, tree *, bool, location_t *);\n+   bool, bool, int, bool *, tree *, location_t *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool, bool);\n static cp_declarator *cp_parser_direct_declarator\n@@ -2186,6 +2194,9 @@ static tree cp_parser_late_parsing_omp_declare_simd\n static tree cp_parser_late_parsing_cilk_simd_fn_info\n   (cp_parser *, tree);\n \n+static tree cp_parser_late_parsing_oacc_routine\n+  (cp_parser *, tree);\n+\n static tree synthesize_implicit_template_parm\n   (cp_parser *, tree);\n static tree finish_fully_implicit_template\n@@ -2440,7 +2451,7 @@ static tree cp_parser_single_declaration\n static tree cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n-  (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree, bool);\n+  (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);\n static tree cp_parser_save_nsdmi\n   (cp_parser *);\n static tree cp_parser_enclosed_template_argument_list\n@@ -11870,7 +11881,6 @@ cp_parser_simple_declaration (cp_parser* parser,\n   bool saw_declarator;\n   location_t comma_loc = UNKNOWN_LOCATION;\n   location_t init_loc = UNKNOWN_LOCATION;\n-  bool first = true;\n \n   if (maybe_range_for_decl)\n     *maybe_range_for_decl = NULL_TREE;\n@@ -11967,10 +11977,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t\t\t\t\tdeclares_class_or_enum,\n \t\t\t\t\t&function_definition_p,\n \t\t\t\t\tmaybe_range_for_decl,\n-\t\t\t\t\tfirst,\n \t\t\t\t\t&init_loc);\n-      first = false;\n-\n       /* If an error occurred while parsing tentatively, exit quickly.\n \t (That usually happens when in the body of a function; each\n \t statement is treated as a declaration-statement until proven\n@@ -12069,9 +12076,6 @@ cp_parser_simple_declaration (cp_parser* parser,\n \n  done:\n   pop_deferring_access_checks ();\n-\n-  /* Reset any acc routine clauses.  */\n-  parser->oacc_routine = NULL;\n }\n \n /* Parse a decl-specifier-seq.\n@@ -17811,8 +17815,6 @@ cp_parser_asm_definition (cp_parser* parser)\n    if present, will not be consumed.  If returned, this declarator will be\n    created with SD_INITIALIZED but will not call cp_finish_decl.\n \n-   FIRST indicates if this is the first declarator in a declaration sequence.\n-\n    If INIT_LOC is not NULL, and *INIT_LOC is equal to UNKNOWN_LOCATION,\n    and there is an initializer, the pointed location_t is set to the\n    location of the '=' or `(', or '{' in C++11 token introducing the\n@@ -17827,7 +17829,6 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   int declares_class_or_enum,\n \t\t\t   bool* function_definition_p,\n \t\t\t   tree* maybe_range_for_decl,\n-\t\t\t   bool first,\n \t\t\t   location_t* init_loc)\n {\n   cp_token *token = NULL, *asm_spec_start_token = NULL,\n@@ -17964,8 +17965,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t    decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\tdecl_specifiers,\n \t\t\t\t\t\t\tdeclarator,\n-\t\t\t\t\t\t\tprefix_attributes,\n-\t\t\t\t\t\t\ttrue);\n+\t\t\t\t\t\t\tprefix_attributes);\n \t  else\n \t    decl =\n \t      (cp_parser_function_definition_from_specifiers_and_declarator\n@@ -18069,7 +18069,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t range_for_decl_p? SD_INITIALIZED : is_initialized,\n \t\t\t attributes, prefix_attributes, &pushed_scope);\n       cp_finalize_omp_declare_simd (parser, decl);\n-      cp_finalize_oacc_routine (parser, decl, false, first);\n+      cp_finalize_oacc_routine (parser, decl, false);\n       /* Adjust location of decl if declarator->id_loc is more appropriate:\n \t set, and decl wasn't merged with another decl, in which case its\n \t location would be different from input_location, and more accurate.  */\n@@ -18183,7 +18183,7 @@ cp_parser_init_declarator (cp_parser* parser,\n       if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \tcp_parser_save_default_args (parser, decl);\n       cp_finalize_omp_declare_simd (parser, decl);\n-      cp_finalize_oacc_routine (parser, decl, false, first);\n+      cp_finalize_oacc_routine (parser, decl, false);\n     }\n \n   /* Finish processing the declaration.  But, skip member\n@@ -19289,13 +19289,17 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n \n   bool cilk_simd_fn_vector_p = (parser->cilk_simd_fn_info \n \t\t\t\t&& declarator && declarator->kind == cdk_id);\n-  \n+\n+  bool oacc_routine_p = (parser->oacc_routine\n+\t\t\t && declarator\n+\t\t\t && declarator->kind == cdk_id);\n+\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* A late-specified return type is indicated by an initial '->'. */\n   if (token->type != CPP_DEREF\n       && token->keyword != RID_REQUIRES\n-      && !(declare_simd_p || cilk_simd_fn_vector_p))\n+      && !(declare_simd_p || cilk_simd_fn_vector_p || oacc_routine_p))\n     return NULL_TREE;\n \n   tree save_ccp = current_class_ptr;\n@@ -19326,6 +19330,10 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n     declarator->std_attributes\n       = cp_parser_late_parsing_omp_declare_simd (parser,\n \t\t\t\t\t\t declarator->std_attributes);\n+  if (oacc_routine_p)\n+    declarator->std_attributes\n+      = cp_parser_late_parsing_oacc_routine (parser,\n+\t\t\t\t\t     declarator->std_attributes);\n \n   if (quals >= 0)\n     {\n@@ -21887,7 +21895,6 @@ cp_parser_member_declaration (cp_parser* parser)\n   else\n     {\n       bool assume_semicolon = false;\n-      bool first = true;\n \n       /* Clear attributes from the decl_specifiers but keep them\n \t around as prefix attributes that apply them to the entity\n@@ -22075,10 +22082,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t  decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\t      &decl_specifiers,\n \t\t\t\t\t\t\t      declarator,\n-\t\t\t\t\t\t\t      attributes,\n-\t\t\t\t\t\t\t      first);\n-\t\t  first = false;\n-\n+\t\t\t\t\t\t\t      attributes);\n \t\t  if (parser->fully_implicit_function_template_p)\n \t\t    decl = finish_fully_implicit_template (parser, decl);\n \t\t  /* If the member was not a friend, declare it here.  */\n@@ -22108,8 +22112,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    }\n \n \t  cp_finalize_omp_declare_simd (parser, decl);\n-\t  cp_finalize_oacc_routine (parser, decl, false, first);\n-\t  first = false;\n+\t  cp_finalize_oacc_routine (parser, decl, false);\n \n \t  /* Reset PREFIX_ATTRIBUTES.  */\n \t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n@@ -22172,9 +22175,6 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  if (assume_semicolon)\n \t    goto out;\n \t}\n-\n-      /* Reset any OpenACC routine clauses.  */\n-      parser->oacc_routine = NULL;\n     }\n \n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n@@ -24716,7 +24716,7 @@ cp_parser_function_definition_from_specifiers_and_declarator\n     {\n       cp_finalize_omp_declare_simd (parser, current_function_decl);\n       parser->omp_declare_simd = NULL;\n-      cp_finalize_oacc_routine (parser, current_function_decl, true, true);\n+      cp_finalize_oacc_routine (parser, current_function_decl, true);\n       parser->oacc_routine = NULL;\n     }\n \n@@ -25282,7 +25282,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t        member_p,\n \t\t\t\t        declares_class_or_enum,\n \t\t\t\t        &function_definition_p,\n-\t\t\t\t\tNULL, true, NULL);\n+\t\t\t\t\tNULL, NULL);\n \n     /* 7.1.1-1 [dcl.stc]\n \n@@ -25384,15 +25384,14 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n /* Save the tokens that make up the body of a member function defined\n    in a class-specifier.  The DECL_SPECIFIERS and DECLARATOR have\n    already been parsed.  The ATTRIBUTES are any GNU \"__attribute__\"\n-   specifiers applied to the declaration. FIRST_DECL indicates if\n-   DECLARATOR is the first declarator in a declaration sequence.  Returns\n-   the FUNCTION_DECL for the member function.  */\n+   specifiers applied to the declaration.  Returns the FUNCTION_DECL\n+   for the member function.  */\n \n static tree\n cp_parser_save_member_function_body (cp_parser* parser,\n \t\t\t\t     cp_decl_specifier_seq *decl_specifiers,\n \t\t\t\t     cp_declarator *declarator,\n-\t\t\t\t     tree attributes, bool first_decl)\n+\t\t\t\t     tree attributes)\n {\n   cp_token *first;\n   cp_token *last;\n@@ -25401,7 +25400,7 @@ cp_parser_save_member_function_body (cp_parser* parser,\n   /* Create the FUNCTION_DECL.  */\n   fn = grokmethod (decl_specifiers, declarator, attributes);\n   cp_finalize_omp_declare_simd (parser, fn);\n-  cp_finalize_oacc_routine (parser, fn, true, first_decl);\n+  cp_finalize_oacc_routine (parser, fn, true);\n   /* If something went badly wrong, bail out now.  */\n   if (fn == error_mark_node)\n     {\n@@ -35773,59 +35772,6 @@ cp_parser_omp_taskloop (cp_parser *parser, cp_token *pragma_tok,\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR)\t\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SEQ))\n \n-/* Finalize #pragma acc routine clauses after direct declarator has\n-   been parsed, and put that into \"omp declare target\" attribute.  */\n-\n-static void\n-cp_parser_finish_oacc_routine (cp_parser *ARG_UNUSED (parser), tree fndecl,\n-\t\t\t       tree clauses, bool named, bool is_defn,\n-\t\t\t       bool first)\n-{\n-  location_t loc  = OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses));\n-\n-  if (named && fndecl && is_overloaded_fn (fndecl)\n-      && (TREE_CODE (fndecl) != FUNCTION_DECL\n-\t  || DECL_FUNCTION_TEMPLATE_P  (fndecl)))\n-    {\n-      error_at (loc, \"%<#pragma acc routine%> names a set of overloads\");\n-      return;\n-    }\n-\n-  if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL\n-      || (!named && !first))\n-    {\n-      error_at (loc, \"%<#pragma acc routine%> %s\",\n-\t\tnamed ? \"does not refer to a function\"\n-\t\t: \"not followed by single function\");\n-      return;\n-    }\n-\n-  /* Perhaps we should use the same rule as declarations in different\n-     namespaces?  */\n-  if (named && !DECL_NAMESPACE_SCOPE_P (fndecl))\n-    {\n-      error_at (loc, \"%<#pragma acc routine%> does not refer to a\"\n-\t\t\" namespace scope function\");\n-      return;\n-    }\n-\n-  if (get_oacc_fn_attrib (fndecl))\n-    error_at (loc, \"%<#pragma acc routine%> already applied to %D\", fndecl);\n-\n-  if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n-    error_at (OMP_CLAUSE_LOCATION (TREE_PURPOSE (clauses)),\n-\t      \"%<#pragma acc routine%> must be applied before %s\",\n-\t      TREE_USED (fndecl) ? \"use\" : \"definition\");\n-\n-  /* Process for function attrib  */\n-  tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n-  replace_oacc_fn_attrib (fndecl, dims);\n-\n-  /* Also attach as a declare.  */\n-  DECL_ATTRIBUTES (fndecl)\n-    = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t clauses, DECL_ATTRIBUTES (fndecl));\n-}\n \n /* Parse the OpenACC routine pragma.  This has an optional '( name )'\n    component, which must resolve to a declared namespace-scope\n@@ -35837,16 +35783,50 @@ static void\n cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t\t\tenum pragma_context context)\n {\n+  bool first_p = parser->oacc_routine == NULL;\n+  location_t loc = pragma_tok->location;\n+  cp_omp_declare_simd_data data;\n+  if (first_p)\n+    {\n+      data.error_seen = false;\n+      data.fndecl_seen = false;\n+      data.tokens = vNULL;\n+      data.clauses = NULL_TREE;\n+      parser->oacc_routine = &data;\n+    }\n+\n   tree decl = NULL_TREE;\n   /* Create a dummy claue, to record location.  */\n   tree c_head = build_omp_clause (pragma_tok->location, OMP_CLAUSE_SEQ);\n \n   if (context != pragma_external)\n-    cp_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n-  \n+    {\n+      cp_parser_error (parser, \"%<#pragma acc routine%> not at file scope\");\n+      parser->oacc_routine->error_seen = true;\n+      parser->oacc_routine = NULL;\n+      return;\n+    }\n+\n   /* Look for optional '( name )'.  */\n-  if (cp_lexer_next_token_is (parser->lexer,CPP_OPEN_PAREN))\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n+      if (!first_p)\n+\t{\n+\t  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n+\t\t && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+\t    parser->oacc_routine->error_seen = true;\n+\t  cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+\t  error_at (OMP_CLAUSE_LOCATION (parser->oacc_routine->clauses),\n+\t\t    \"%<#pragma oacc routine%> not followed by a single \"\n+\t\t    \"function declaration or definition\");\n+\n+\t  parser->oacc_routine->error_seen = true;\n+\t  return;\n+\t}\n+\n       cp_lexer_consume_token (parser->lexer);\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n@@ -35868,36 +35848,192 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \t{\n \t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\t  parser->oacc_routine = NULL;\n \t  return;\n \t}\n+\n+      /* Build a chain of clauses.  */\n+      parser->lexer->in_pragma = true;\n+      tree clauses = NULL_TREE;\n+      clauses = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t\t    \"#pragma acc routine\",\n+\t\t\t\t\t    cp_lexer_peek_token\n+\t\t\t\t\t    (parser->lexer));\n+\n+      /* Force clauses to be non-null, by attaching context to it.  */\n+      clauses = tree_cons (c_head, clauses, NULL_TREE);\n+\n+      if (decl && is_overloaded_fn (decl)\n+\t  && (TREE_CODE (decl) != FUNCTION_DECL\n+\t      || DECL_FUNCTION_TEMPLATE_P  (decl)))\n+\t{\n+\t  error_at (loc, \"%<#pragma acc routine%> names a set of overloads\");\n+\t  parser->oacc_routine = NULL;\n+\t  return;\n+\t}\n+\n+      /* Perhaps we should use the same rule as declarations in different\n+\t namespaces?  */\n+      if (!DECL_NAMESPACE_SCOPE_P (decl))\n+\t{\n+\t  error_at (loc, \"%<#pragma acc routine%> does not refer to a \"\n+\t\t    \"namespace scope function\");\n+\t  parser->oacc_routine = NULL;\n+\t  return;\n+\t}\n+\n+      if (!decl || TREE_CODE (decl) != FUNCTION_DECL)\n+\t{\n+\t  error_at (loc,\n+\t\t    \"%<#pragma acc routine%> does not refer to a function\");\n+\t  parser->oacc_routine = NULL;\n+\t  return;\n+\t}\n+\n+      data.clauses = clauses;\n+\n+      cp_finalize_oacc_routine (parser, decl, false);\n+      data.tokens.release ();\n+      parser->oacc_routine = NULL;\n     }\n+  else\n+    {\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n+\t     && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n+\tcp_lexer_consume_token (parser->lexer);\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+\tparser->oacc_routine->error_seen = true;\n+      cp_parser_require_pragma_eol (parser, pragma_tok);\n+\n+      struct cp_token_cache *cp\n+\t= cp_token_cache_new (pragma_tok, cp_lexer_peek_token (parser->lexer));\n+      parser->oacc_routine->tokens.safe_push (cp);\n \n-  /* Build a chain of clauses.  */\n+      if (first_p)\n+\tparser->oacc_routine->clauses = c_head;\n+\n+      while (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA))\n+\tcp_parser_pragma (parser, context);\n+\n+      if (first_p)\n+\t{\n+\t  /* Create an empty list of clauses.  */\n+\t  parser->oacc_routine->clauses = tree_cons (c_head, NULL_TREE,\n+\t\t\t\t\t\t     NULL_TREE);\n+\t  cp_parser_declaration (parser);\n+\n+\t  if (parser->oacc_routine\n+\t      && !parser->oacc_routine->error_seen\n+\t      && !parser->oacc_routine->fndecl_seen)\n+\t    error_at (loc, \"%<#pragma acc routine%> not followed by \"\n+\t\t      \"function declaration or definition\");\n+\n+\t  data.tokens.release ();\n+\t  parser->oacc_routine = NULL;\n+\t}\n+    }\n+}\n+\n+/* Finalize #pragma acc routine clauses after direct declarator has\n+   been parsed, and put that into \"oacc routine\" attribute.  */\n+\n+static tree\n+cp_parser_late_parsing_oacc_routine (cp_parser *parser, tree attrs)\n+{\n+  struct cp_token_cache *ce;\n+  cp_omp_declare_simd_data *data = parser->oacc_routine;\n+  tree cl, clauses = parser->oacc_routine->clauses;\n+  location_t loc;\n+\n+  loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE(clauses));\n+  \n+  if ((!data->error_seen && data->fndecl_seen)\n+      || data->tokens.length () != 1)\n+    {\n+      error_at (loc, \"%<#pragma oacc routine%> not followed by a single \"\n+\t\t\"function declaration or definition\");\n+      data->error_seen = true;\n+      return attrs;\n+    }\n+  if (data->error_seen)\n+    return attrs;\n+\n+  ce = data->tokens[0];\n+\n+  cp_parser_push_lexer_for_tokens (parser, ce);\n   parser->lexer->in_pragma = true;\n-  tree clauses = NULL_TREE;\n-  clauses = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n-\t\t\t\t\t\"#pragma acc routine\",\n-\t\t\t\t\tcp_lexer_peek_token (parser->lexer));\n+  gcc_assert (cp_lexer_peek_token (parser->lexer)->type == CPP_PRAGMA);\n+\n+  cp_token *pragma_tok = cp_lexer_consume_token (parser->lexer);\n+  cl = cp_parser_oacc_all_clauses (parser, OACC_ROUTINE_CLAUSE_MASK,\n+\t\t\t\t  \"#pragma oacc routine\", pragma_tok);\n+  cp_parser_pop_lexer (parser);\n+\n+  tree c_head = build_omp_clause (loc, OMP_CLAUSE_SEQ);\n \n   /* Force clauses to be non-null, by attaching context to it.  */\n-  clauses = tree_cons (c_head, clauses, NULL_TREE);\n+  parser->oacc_routine->clauses = tree_cons (c_head, cl, NULL_TREE);\n \n-  if (decl)\n-    cp_parser_finish_oacc_routine (parser, decl, clauses, true, false, 0);\n-  else\n-    parser->oacc_routine = clauses;\n+  data->fndecl_seen = true;\n+  return attrs;\n }\n \n /* Apply any saved OpenACC routine clauses to a just-parsed\n    declaration.  */\n \n static void\n-cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn,\n-\t\t\t  bool first)\n+cp_finalize_oacc_routine (cp_parser *parser, tree fndecl, bool is_defn)\n {\n-  if (parser->oacc_routine)\n-    cp_parser_finish_oacc_routine (parser, fndecl, parser->oacc_routine,\n-\t\t\t\t   false, is_defn, first);\n+  if (__builtin_expect (parser->oacc_routine != NULL, 0))\n+    {\n+      tree clauses = parser->oacc_routine->clauses;\n+      location_t loc = OMP_CLAUSE_LOCATION (TREE_PURPOSE(clauses));\n+\n+      if (parser->oacc_routine->error_seen)\n+\treturn;\n+      \n+      if (fndecl == error_mark_node)\n+\t{\n+\t  parser->oacc_routine = NULL;\n+\t  return;\n+\t}\n+\n+      if (TREE_CODE (fndecl) != FUNCTION_DECL)\n+\t{\n+\t  cp_ensure_no_oacc_routine (parser);\n+\t  return;\n+\t}\n+\n+      if (!fndecl || TREE_CODE (fndecl) != FUNCTION_DECL)\n+\t{\n+\t  error_at (loc,\n+\t\t    \"%<#pragma acc routine%> not followed by single function\");\n+\t  parser->oacc_routine = NULL;\n+\t}\n+\t  \n+      if (get_oacc_fn_attrib (fndecl))\n+\t{\n+\t  error_at (loc, \"%<#pragma acc routine%> already applied to %D\",\n+\t\t    fndecl);\n+\t  parser->oacc_routine = NULL;\n+\t}\n+\n+      if (TREE_USED (fndecl) || (!is_defn && DECL_SAVED_TREE (fndecl)))\n+\t{\n+\t  error_at (loc, \"%<#pragma acc routine%> must be applied before %s\",\n+\t\t    TREE_USED (fndecl) ? \"use\" : \"definition\");\n+\t  parser->oacc_routine = NULL;\n+\t}\n+\n+      /* Process for function attrib  */\n+      tree dims = build_oacc_routine_dims (TREE_VALUE (clauses));\n+      replace_oacc_fn_attrib (fndecl, dims);\n+      \n+      /* Add an \"omp target\" attribute.  */\n+      DECL_ATTRIBUTES (fndecl)\n+\t= tree_cons (get_identifier (\"omp declare target\"),\n+\t\t     NULL_TREE, DECL_ATTRIBUTES (fndecl));\n+    }\n }\n \n /* Main entry point to OpenMP statement pragmas.  */\n@@ -36381,7 +36517,6 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n   id = pragma_tok->pragma_kind;\n   if (id != PRAGMA_OMP_DECLARE_REDUCTION && id != PRAGMA_OACC_ROUTINE)\n     cp_ensure_no_omp_declare_simd (parser);\n-  cp_ensure_no_oacc_routine (parser);\n   switch (id)\n     {\n     case PRAGMA_GCC_PCH_PREPROCESS:"}, {"sha": "a6b8e74feb6e621b32c808cb51bdddc453917568", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8504d5dd8efc818577ffc3b91cacfd7f519a311c/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=8504d5dd8efc818577ffc3b91cacfd7f519a311c", "patch": "@@ -203,6 +203,7 @@ struct cp_omp_declare_simd_data {\n   bool error_seen; /* Set if error has been reported.  */\n   bool fndecl_seen; /* Set if one fn decl/definition has been seen already.  */\n   vec<cp_token_cache_ptr> tokens;\n+  tree clauses;\n };\n \n \n@@ -371,8 +372,8 @@ struct GTY(()) cp_parser {\n      necessary.  */\n   cp_omp_declare_simd_data * GTY((skip)) cilk_simd_fn_info;\n \n-  /* OpenACC routine clauses for subsequent decl/defn.  */\n-  tree oacc_routine;\n+  /* Parsing information for #pragma acc routine.  */\n+  cp_omp_declare_simd_data * GTY((skip)) oacc_routine;\n   \n   /* Nonzero if parsing a parameter list where 'auto' should trigger an implicit\n      template parameter.  */"}]}