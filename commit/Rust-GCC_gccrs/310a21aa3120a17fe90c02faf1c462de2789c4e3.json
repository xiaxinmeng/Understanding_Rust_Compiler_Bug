{"sha": "310a21aa3120a17fe90c02faf1c462de2789c4e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEwYTIxYWEzMTIwYTE3ZmU5MGMwMmZhZjFjNDYyZGUyNzg5YzRlMw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2010-12-30T13:12:02Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2010-12-30T13:12:02Z"}, "message": "Repeat processing all basic blocks for vzeroupper optimization.\n\ngcc/\n\n2010-12-30  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46519\n\t* config/i386/i386.c (block_info_def): Remove referenced, count\n\tand rescanned.\n\t(move_or_delete_vzeroupper_2): Updated.\n\t(move_or_delete_vzeroupper_1): Rewritten to avoid recursive call.\n\t(rescan_move_or_delete_vzeroupper): Removed.\n\t(move_or_delete_vzeroupper): Repeat processing all basic blocks\n\tuntil no basic block state is changed to used at exit.\n\ngcc/testsuite/\n\n2010-12-30  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR target/46519\n\t* gfortran.dg/pr46519-2.f90: New.\n\nFrom-SVN: r168342", "tree": {"sha": "1bc4f0ed9cbf606b4497b63a9f70a59e13576510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bc4f0ed9cbf606b4497b63a9f70a59e13576510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/310a21aa3120a17fe90c02faf1c462de2789c4e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310a21aa3120a17fe90c02faf1c462de2789c4e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310a21aa3120a17fe90c02faf1c462de2789c4e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310a21aa3120a17fe90c02faf1c462de2789c4e3/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ecdee6655c695b6b3e47a0cfcba9fda5b7ccd813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecdee6655c695b6b3e47a0cfcba9fda5b7ccd813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecdee6655c695b6b3e47a0cfcba9fda5b7ccd813"}], "stats": {"total": 192, "additions": 89, "deletions": 103}, "files": [{"sha": "cc0f6fe1ccb0dd03f83c6893375b2060684234fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=310a21aa3120a17fe90c02faf1c462de2789c4e3", "patch": "@@ -1,3 +1,14 @@\n+2010-12-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46519\n+\t* config/i386/i386.c (block_info_def): Remove referenced, count\n+\tand rescanned.\n+\t(move_or_delete_vzeroupper_2): Updated.\n+\t(move_or_delete_vzeroupper_1): Rewritten to avoid recursive call.\n+\t(rescan_move_or_delete_vzeroupper): Removed.\n+\t(move_or_delete_vzeroupper): Repeat processing all basic blocks\n+\tuntil no basic block state is changed to used at exit.\n+\n 2010-12-30  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/pdp11.md (movmemhi, movmemhi1): Correct"}, {"sha": "2fb1dfa9c8cec9a5c18a4b78c5382f06e602b199", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 42, "deletions": 103, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=310a21aa3120a17fe90c02faf1c462de2789c4e3", "patch": "@@ -68,14 +68,8 @@ typedef struct block_info_def\n {\n   /* State of the upper 128bits of any AVX registers at exit.  */\n   enum upper_128bits_state state;\n-  /* If the upper 128bits of any AVX registers are referenced.  */\n-  enum upper_128bits_state referenced;\n-  /* Number of vzerouppers in this block.  */\n-  unsigned int count;\n   /* TRUE if block has been processed.  */\n   bool processed;\n-  /* TRUE if block has been rescanned.  */\n-  bool rescanned;\n } *block_info;\n \n #define BLOCK_INFO(B)   ((block_info) (B)->aux)\n@@ -127,8 +121,6 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n   rtx vzeroupper_insn = NULL_RTX;\n   rtx pat;\n   int avx256;\n-  enum upper_128bits_state referenced = BLOCK_INFO (bb)->referenced;\n-  int count = BLOCK_INFO (bb)->count;\n \n   if (dump_file)\n     fprintf (dump_file, \" [bb %i] entry: upper 128bits: %d\\n\",\n@@ -191,24 +183,20 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \t      /* Delete pending vzeroupper insertion.  */\n \t      if (vzeroupper_insn)\n \t\t{\n-\t\t  count--;\n \t\t  delete_insn (vzeroupper_insn);\n \t\t  vzeroupper_insn = NULL_RTX;\n \t\t}\n \t    }\n-\t  else if (state != used && referenced != unused)\n+\t  else if (state != used)\n \t    {\n \t      /* No need to call note_stores if the upper 128bits of\n \t\t AVX registers are never referenced.  */\n \t      note_stores (pat, check_avx256_stores, &state);\n-\t      if (state == used)\n-\t\treferenced = used;\n \t    }\n \t  continue;\n \t}\n \n       /* Process vzeroupper intrinsic.  */\n-      count++;\n       avx256 = INTVAL (XVECEXP (pat, 0, 0));\n \n       if (state == unused)\n@@ -226,7 +214,6 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \t      fprintf (dump_file, \"Delete redundant vzeroupper:\\n\");\n \t      print_rtl_single (dump_file, insn);\n \t    }\n-\t  count--;\n \t  delete_insn (insn);\n \t}\n       else\n@@ -246,7 +233,6 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \t\t  fprintf (dump_file, \"Delete callee pass vzeroupper:\\n\");\n \t\t  print_rtl_single (dump_file, insn);\n \t\t}\n-\t      count--;\n \t      delete_insn (insn);\n \t    }\n \t  else\n@@ -256,30 +242,22 @@ move_or_delete_vzeroupper_2 (basic_block bb,\n \n   BLOCK_INFO (bb)->state = state;\n \n-  if (BLOCK_INFO (bb)->referenced == unknown)\n-    {\n-      /* The upper 128bits of AVX registers are never referenced if\n-\t REFERENCED isn't updated.  */\n-      if (referenced == unknown)\n-\treferenced = unused;\n-      BLOCK_INFO (bb)->referenced = referenced;\n-      BLOCK_INFO (bb)->count = count;\n-    }\n-\n   if (dump_file)\n     fprintf (dump_file, \" [bb %i] exit: upper 128bits: %d\\n\",\n \t     bb->index, state);\n }\n \n /* Helper function for move_or_delete_vzeroupper.  Process vzeroupper\n-   in BLOCK and its predecessor blocks recursively.  */\n+   in BLOCK and check its predecessor blocks.  Treat UNKNOWN state\n+   as USED if UNKNOWN_IS_UNUSED is true.  */\n \n static void\n-move_or_delete_vzeroupper_1 (basic_block block)\n+move_or_delete_vzeroupper_1 (basic_block block, bool unknown_is_unused)\n {\n   edge e;\n   edge_iterator ei;\n-  enum upper_128bits_state state;\n+  enum upper_128bits_state state, old_state, new_state;\n+  bool seen_unknown;\n \n   if (dump_file)\n     fprintf (dump_file, \" Process [bb %i]: status: %d\\n\",\n@@ -288,83 +266,42 @@ move_or_delete_vzeroupper_1 (basic_block block)\n   if (BLOCK_INFO (block)->processed)\n     return;\n \n-  BLOCK_INFO (block)->processed = true;\n-\n-  state = unknown;\n+  state = unused;\n \n-  /* Process all predecessor edges of this block.  */\n+  /* Check all predecessor edges of this block.  */\n+  seen_unknown = false;\n   FOR_EACH_EDGE (e, ei, block->preds)\n     {\n       if (e->src == block)\n \tcontinue;\n-      move_or_delete_vzeroupper_1 (e->src);\n       switch (BLOCK_INFO (e->src)->state)\n \t{\n \tcase unknown:\n-\t  if (state == unused)\n-\t    state = unknown;\n+\t  if (!unknown_is_unused)\n+\t    seen_unknown = true;\n+\tcase unused:\n \t  break;\n \tcase used:\n \t  state = used;\n-\t  break;\n-\tcase unused:\n-\t  break;\n+\t  goto done;\n \t}\n     }\n \n-  /* If state of any predecessor edges is unknown, we need to rescan.  */\n-  if (state == unknown)\n-    cfun->machine->rescan_vzeroupper_p = 1;\n+  if (seen_unknown)\n+    state = unknown;\n \n-  /* Process this block.  */\n+done:\n+  old_state = BLOCK_INFO (block)->state;\n   move_or_delete_vzeroupper_2 (block, state);\n-}\n-\n-/* Helper function for move_or_delete_vzeroupper.  Rescan vzeroupper\n-   in BLOCK and its predecessor blocks recursively.  */\n-\n-static void\n-rescan_move_or_delete_vzeroupper (basic_block block)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  enum upper_128bits_state state;\n-\n-  if (dump_file)\n-    fprintf (dump_file, \" Rescan [bb %i]: status: %d\\n\",\n-\t     block->index, BLOCK_INFO (block)->rescanned);\n-\n-  if (BLOCK_INFO (block)->rescanned)\n-    return;\n-\n-  BLOCK_INFO (block)->rescanned = true;\n-\n-  state = unused;\n+  new_state = BLOCK_INFO (block)->state;\n \n-  /* Rescan all predecessor edges of this block.  */\n-  FOR_EACH_EDGE (e, ei, block->preds)\n-    {\n-      if (e->src == block)\n-\tcontinue;\n-      rescan_move_or_delete_vzeroupper (e->src);\n-      /* For rescan, UKKNOWN state is treated as UNUSED.  */\n-      if (BLOCK_INFO (e->src)->state == used)\n-\tstate = used;\n-    }\n+  if (state != unknown || new_state == used)\n+    BLOCK_INFO (block)->processed = true;\n \n-  /* Rescan this block only if there are vzerouppers or the upper\n-     128bits of AVX registers are referenced.  */\n-  if (BLOCK_INFO (block)->count == 0\n-      && (state == used || BLOCK_INFO (block)->referenced != used))\n-    {\n-      if (state == used)\n-\tBLOCK_INFO (block)->state = state;\n-      if (dump_file)\n-\tfprintf (dump_file, \" [bb %i] exit: upper 128bits: %d\\n\",\n-\t\t block->index, BLOCK_INFO (block)->state);\n-    }\n-  else\n-    move_or_delete_vzeroupper_2 (block, state);\n+  /* Need to rescan if the upper 128bits of AVX registers are changed\n+     to USED at exit.  */\n+  if (new_state != old_state && new_state == used)\n+    cfun->machine->rescan_vzeroupper_p = 1;\n }\n \n /* Go through the instruction stream looking for vzeroupper.  Delete\n@@ -377,7 +314,7 @@ move_or_delete_vzeroupper (void)\n   edge e;\n   edge_iterator ei;\n   basic_block bb;\n-  unsigned int count = 0;\n+  unsigned int count;\n \n   /* Set up block info for each basic block.  */\n   alloc_aux_for_blocks (sizeof (struct block_info_def));\n@@ -392,28 +329,30 @@ move_or_delete_vzeroupper (void)\n \t\t\t\t   cfun->machine->caller_pass_avx256_p\n \t\t\t\t   ? used : unused);\n       BLOCK_INFO (e->dest)->processed = true;\n-      BLOCK_INFO (e->dest)->rescanned = true;\n     }\n \n   /* Process all basic blocks.  */\n-  if (dump_file)\n-    fprintf (dump_file, \"Process all basic blocks\\n\");\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      move_or_delete_vzeroupper_1 (bb);\n-      count += BLOCK_INFO (bb)->count;\n-    }\n-\n-  /* Rescan all basic blocks if needed.  */\n-  if (count && cfun->machine->rescan_vzeroupper_p)\n+  count = 0;\n+  do\n     {\n       if (dump_file)\n-\tfprintf (dump_file, \"Rescan all basic blocks\\n\");\n-\n+\tfprintf (dump_file, \"Process all basic blocks: trip %d\\n\",\n+\t\t count);\n+      cfun->machine->rescan_vzeroupper_p = 0;\n       FOR_EACH_BB (bb)\n-\trescan_move_or_delete_vzeroupper (bb);\n+\tmove_or_delete_vzeroupper_1 (bb, false);\n     }\n+  while (cfun->machine->rescan_vzeroupper_p && count++ < 20);\n+\n+  /* FIXME: Is 20 big enough?  */\n+  if (count >= 20)\n+    gcc_unreachable ();\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Process all basic blocks\\n\");\n+\n+  FOR_EACH_BB (bb)\n+    move_or_delete_vzeroupper_1 (bb, true);\n \n   free_aux_for_blocks ();\n }"}, {"sha": "69ab495c212ef9a3c870a7f8400deea762a6793f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=310a21aa3120a17fe90c02faf1c462de2789c4e3", "patch": "@@ -1,3 +1,8 @@\n+2010-12-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/46519\n+\t* gfortran.dg/pr46519-2.f90: New.\n+\n 2010-12-30  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47085"}, {"sha": "b4d6980550561d4888dee5e54a8617c309418b55", "filename": "gcc/testsuite/gfortran.dg/pr46519-2.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/310a21aa3120a17fe90c02faf1c462de2789c4e3/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr46519-2.f90?ref=310a21aa3120a17fe90c02faf1c462de2789c4e3", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile { target i?86-*-* x86_64-*-* } }\n+! { dg-options \"-O3 -mavx -mvzeroupper -mtune=generic -dp\" }\n+\n+  SUBROUTINE func(kts, kte, qrz, qiz, rho)\n+  IMPLICIT NONE\n+  INTEGER, INTENT(IN)               :: kts, kte\n+  REAL,    DIMENSION(kts:kte), INTENT(INOUT) :: qrz, qiz, rho\n+  INTEGER                              :: k\n+  REAL, DIMENSION(kts:kte)    ::  praci, vtiold\n+  REAL                          :: fluxout\n+  INTEGER                       :: min_q, max_q, var\n+  do k=kts,kte\n+    praci(k)=0.0\n+  enddo\n+  min_q=kte\n+  max_q=kts-1\n+  DO var=1,20\n+    do k=max_q,min_q,-1\n+       fluxout=rho(k)*qrz(k)\n+    enddo\n+    qrz(min_q-1)=qrz(min_q-1)+fluxout\n+  ENDDO\n+  DO var=1,20\n+    do k=kts,kte-1\n+      vtiold(k)= (rho(k))**0.16\n+    enddo\n+  ENDDO\n+  STOP\n+  END SUBROUTINE func\n+\n+! { dg-final { scan-assembler \"avx_vzeroupper\" } }"}]}