{"sha": "c9954996cd647daf0ba03e34dd279b97982f671f", "node_id": "C_kwDOANBUbNoAKGM5OTU0OTk2Y2Q2NDdkYWYwYmEwM2UzNGRkMjc5Yjk3OTgyZjY3MWY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-28T13:20:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-29T06:33:00Z"}, "message": "tree-optimization/109154 - improve if-conversion for vectorization\n\nWith multi-argument PHIs and now doing VN on the if-converted blocks\nthe optimization of CSEing condition and negated condition doesn't\nwork well anymore.  The following restores this a little bit for\nthe case of a single inverted condition into a COND_EXPR where\nwe can instead swap the COND_EXPR arms.  The same optimization\nis already done for the case of two-argument PHIs.\n\nThis avoids one comparison/mask for the testcase at hand.\n\n\tPR tree-optimization/109154\n\t* tree-if-conv.cc (gen_phi_arg_condition): Handle single\n\tinverted condition specially by inverting at the caller.\n\t(gen_phi_arg_condition): Swap COND_EXPR arms if requested.", "tree": {"sha": "f51a515351d496e17ae4475d93848c2db3b81c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f51a515351d496e17ae4475d93848c2db3b81c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9954996cd647daf0ba03e34dd279b97982f671f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9954996cd647daf0ba03e34dd279b97982f671f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9954996cd647daf0ba03e34dd279b97982f671f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9954996cd647daf0ba03e34dd279b97982f671f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91293ffb6af18705ab7857dc47656bdd74a9ce31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91293ffb6af18705ab7857dc47656bdd74a9ce31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91293ffb6af18705ab7857dc47656bdd74a9ce31"}], "stats": {"total": 24, "additions": 19, "deletions": 5}, "files": [{"sha": "3494dccfe624a2cfb453db55a2de0616a134544a", "filename": "gcc/tree-if-conv.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9954996cd647daf0ba03e34dd279b97982f671f/gcc%2Ftree-if-conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9954996cd647daf0ba03e34dd279b97982f671f/gcc%2Ftree-if-conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.cc?ref=c9954996cd647daf0ba03e34dd279b97982f671f", "patch": "@@ -1873,18 +1873,20 @@ convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n   return rhs;\n }\n \n-/* Produce condition for all occurrences of ARG in PHI node.  */\n+/* Produce condition for all occurrences of ARG in PHI node.  Set *INVERT\n+   as to whether the condition is inverted.  */\n \n static tree\n gen_phi_arg_condition (gphi *phi, vec<int> *occur,\n-\t\t       gimple_stmt_iterator *gsi)\n+\t\t       gimple_stmt_iterator *gsi, bool *invert)\n {\n   int len;\n   int i;\n   tree cond = NULL_TREE;\n   tree c;\n   edge e;\n \n+  *invert = false;\n   len = occur->length ();\n   gcc_assert (len > 0);\n   for (i = 0; i < len; i++)\n@@ -1896,6 +1898,13 @@ gen_phi_arg_condition (gphi *phi, vec<int> *occur,\n \t  cond = c;\n \t  break;\n \t}\n+      /* If we have just a single inverted predicate, signal that and\n+\t instead invert the COND_EXPR arms.  */\n+      if (len == 1 && TREE_CODE (c) == TRUTH_NOT_EXPR)\n+\t{\n+\t  c = TREE_OPERAND (c, 0);\n+\t  *invert = true;\n+\t}\n       c = force_gimple_operand_gsi (gsi, unshare_expr (c),\n \t\t\t\t    true, NULL_TREE, true, GSI_SAME_STMT);\n       if (cond != NULL_TREE)\n@@ -2116,9 +2125,14 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n \t    lhs = make_temp_ssa_name (type, NULL, \"_ifc_\");\n \t  else\n \t    lhs = res;\n-\t  cond = gen_phi_arg_condition (phi, indexes, gsi);\n-\t  rhs = fold_build_cond_expr (type, unshare_expr (cond),\n-\t\t\t\t      arg0, arg1);\n+\t  bool invert;\n+\t  cond = gen_phi_arg_condition (phi, indexes, gsi, &invert);\n+\t  if (invert)\n+\t    rhs = fold_build_cond_expr (type, unshare_expr (cond),\n+\t\t\t\t\targ1, arg0);\n+\t  else\n+\t    rhs = fold_build_cond_expr (type, unshare_expr (cond),\n+\t\t\t\t\targ0, arg1);\n \t  new_stmt = gimple_build_assign (lhs, rhs);\n \t  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n \t  update_stmt (new_stmt);"}]}