{"sha": "25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVhYWI1ZDBhZGRlZmUwZTNiODE0YTdlYzU0MGExZmE4ODNjZDExZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-17T14:15:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-17T14:15:29Z"}, "message": "decl.c (xref_tag): Revise handling of nested template declarations.\n\n\t* decl.c (xref_tag): Revise handling of nested template\n\tdeclarations.\n\t* pt.c (check_explicit_specialization): Tweak handling of friend\n\ttemplates in template classes.\n\t(tsubst_friend_class): Handle friend declarations for nested\n\tmember template classes.\n\nFrom-SVN: r26520", "tree": {"sha": "a0691edea065b47d3afc29a947078d78f4039179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0691edea065b47d3afc29a947078d78f4039179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/comments", "author": null, "committer": null, "parents": [{"sha": "4e6a144034de387e9ff11a6ae78d6af86f0dc228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6a144034de387e9ff11a6ae78d6af86f0dc228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6a144034de387e9ff11a6ae78d6af86f0dc228"}], "stats": {"total": 223, "additions": 154, "deletions": 69}, "files": [{"sha": "ceb79ca46f2cc642ab793f634cdde66be5e6f693", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "patch": "@@ -1,3 +1,12 @@\n+1999-04-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (xref_tag): Revise handling of nested template\n+\tdeclarations.\n+\t* pt.c (check_explicit_specialization): Tweak handling of friend\n+\ttemplates in template classes.\n+\t(tsubst_friend_class): Handle friend declarations for nested\n+\tmember template classes.\n+\t\n 1999-04-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (finish_struct): Remove unused variable."}, {"sha": "87eae50b715b481526a12184b57dbcf1a926de66", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 79, "deletions": 62, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "patch": "@@ -12323,6 +12323,7 @@ xref_tag (code_type_node, name, globalize)\n   struct binding_level *b = current_binding_level;\n   int got_type = 0;\n   tree attributes = NULL_TREE;\n+  tree context = NULL_TREE;\n \n   /* If we are called from the parser, code_type_node will sometimes be a\n      TREE_LIST.  This indicates that the user wrote\n@@ -12375,72 +12376,87 @@ xref_tag (code_type_node, name, globalize)\n     }\n   else\n     {\n-      if (current_class_type \n-\t  && template_class_depth (current_class_type) \n-\t  && PROCESSING_REAL_TEMPLATE_DECL_P ())\n-      /* Since GLOBALIZE is non-zero, we are not looking at a\n-\t definition of this tag.  Since, in addition, we are currently\n-\t processing a (member) template declaration of a template\n-\t class, we don't want to do any lookup at all; consider:\n-\n-\t   template <class X>\n-\t   struct S1\n-\n-\t   template <class U>\n-\t   struct S2\n-\t   { template <class V>\n-\t     friend struct S1; };\n-\t   \n-\t Here, the S2::S1 declaration should not be confused with the\n-\t outer declaration.  In particular, the inner version should\n-\t have a template parameter of level 2, not level 1.  This\n-\t would be particularly important if the member declaration\n-\t were instead:\n-\n-\t   template <class V = U> friend struct S1;\n-\n-\t say, when we should tsubst into `U' when instantiating S2.  */\n-\tref = NULL_TREE;\n-      else \n+      if (t)\n \t{\n-\t  if (t)\n-\t    {\n-\t      /* [dcl.type.elab] If the identifier resolves to a\n-\t\t typedef-name or a template type-parameter, the\n-\t\t elaborated-type-specifier is ill-formed.  */\n-\t      if (t != TYPE_MAIN_VARIANT (t)\n-\t\t  || (CLASS_TYPE_P (t) && TYPE_WAS_ANONYMOUS (t)))\n-\t\tcp_pedwarn (\"using typedef-name `%D' after `%s'\",\n-\t\t\t    TYPE_NAME (t), tag_name (tag_code));\n-\t      else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\tcp_error (\"using template type parameter `%T' after `%s'\",\n-\t\t\t  t, tag_name (tag_code));\n-\n-\t      ref = t;\n-\t    }\n-\t  else\n-\t    ref = lookup_tag (code, name, b, 0);\n+\t  /* [dcl.type.elab] If the identifier resolves to a\n+\t     typedef-name or a template type-parameter, the\n+\t     elaborated-type-specifier is ill-formed.  */\n+\t  if (t != TYPE_MAIN_VARIANT (t)\n+\t      || (CLASS_TYPE_P (t) && TYPE_WAS_ANONYMOUS (t)))\n+\t    cp_pedwarn (\"using typedef-name `%D' after `%s'\",\n+\t\t\tTYPE_NAME (t), tag_name (tag_code));\n+\t  else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\t    cp_error (\"using template type parameter `%T' after `%s'\",\n+\t\t      t, tag_name (tag_code));\n+\n+\t  ref = t;\n+\t}\n+      else\n+\tref = lookup_tag (code, name, b, 0);\n \t  \n-\t  if (! ref)\n-\t    {\n-\t      /* Try finding it as a type declaration.  If that wins,\n-\t\t use it.  */ \n-\t      ref = lookup_name (name, 1);\n-\n-\t      if (ref != NULL_TREE\n-\t\t  && processing_template_decl\n-\t\t  && DECL_CLASS_TEMPLATE_P (ref)\n-\t\t  && template_class_depth (current_class_type) == 0)\n-\t\t/* Since GLOBALIZE is true, we're declaring a global\n+      if (! ref)\n+\t{\n+\t  /* Try finding it as a type declaration.  If that wins,\n+\t     use it.  */ \n+\t  ref = lookup_name (name, 1);\n+\n+\t  if (ref != NULL_TREE\n+\t      && processing_template_decl\n+\t      && DECL_CLASS_TEMPLATE_P (ref)\n+\t      && template_class_depth (current_class_type) == 0)\n+\t    /* Since GLOBALIZE is true, we're declaring a global\n \t       template, so we want this type.  */\n-\t\tref = DECL_RESULT (ref);\n+\t    ref = DECL_RESULT (ref);\n \n-\t      if (ref && TREE_CODE (ref) == TYPE_DECL\n-\t\t  && TREE_CODE (TREE_TYPE (ref)) == code)\n-\t\tref = TREE_TYPE (ref);\n-\t      else\n-\t\tref = NULL_TREE;\n-\t    }\n+\t  if (ref && TREE_CODE (ref) == TYPE_DECL\n+\t      && TREE_CODE (TREE_TYPE (ref)) == code)\n+\t    ref = TREE_TYPE (ref);\n+\t  else\n+\t    ref = NULL_TREE;\n+\t}\n+\n+      if (ref && current_class_type \n+\t  && template_class_depth (current_class_type) \n+\t  && PROCESSING_REAL_TEMPLATE_DECL_P ()) \n+\t{\n+\t  /* Since GLOBALIZE is non-zero, we are not looking at a\n+\t     definition of this tag.  Since, in addition, we are currently\n+\t     processing a (member) template declaration of a template\n+\t     class, we must be very careful; consider:\n+\n+\t       template <class X>\n+\t       struct S1\n+\n+\t       template <class U>\n+\t       struct S2\n+\t       { template <class V>\n+\t       friend struct S1; };\n+\n+\t     Here, the S2::S1 declaration should not be confused with the\n+\t     outer declaration.  In particular, the inner version should\n+\t     have a template parameter of level 2, not level 1.  This\n+\t     would be particularly important if the member declaration\n+\t     were instead:\n+\n+\t       template <class V = U> friend struct S1;\n+\n+\t     say, when we should tsubst into `U' when instantiating\n+\t     S2.  On the other hand, when presented with:\n+\n+\t         template <class T>\n+\t         struct S1 {\n+\t\t   template <class U>\n+\t           struct S2 {};\n+\t\t   template <class U>\n+\t\t   friend struct S2;\n+\t\t };\n+\n+              we must find the inner binding eventually.  We\n+\t      accomplish this by making sure that the new type we\n+\t      create to represent this declaration has the right\n+\t      TYPE_CONTEXT.  */\n+\t  context = TYPE_CONTEXT (ref);\n+\t  ref = NULL_TREE;\n \t}\n     }\n \n@@ -12487,6 +12503,7 @@ xref_tag (code_type_node, name, globalize)\n \t  struct binding_level *old_b = class_binding_level;\n \n \t  ref = make_lang_type (code);\n+\t  TYPE_CONTEXT (ref) = context;\n \n \t  if (tag_code == signature_type)\n \t    {"}, {"sha": "b26b88a4dcccc8b7f25243b1b76b05f04c3e24fa", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "patch": "@@ -1281,7 +1281,6 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n   if (specialization || member_specialization || explicit_instantiation)\n     {\n-      tree gen_tmpl;\n       tree tmpl = NULL_TREE;\n       tree targs = NULL_TREE;\n \n@@ -1435,13 +1434,34 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \treturn error_mark_node;\n       else\n \t{\n-\t  gen_tmpl = most_general_template (tmpl);\n+\t  tree gen_tmpl = most_general_template (tmpl);\n \n \t  if (explicit_instantiation)\n \t    {\n \t      /* We don't set DECL_EXPLICIT_INSTANTIATION here; that\n-\t\t is done by do_decl_instantiation later.  */\n-\t      decl = instantiate_template (tmpl, innermost_args (targs));\n+\t\t is done by do_decl_instantiation later.  */ \n+\n+\t      int arg_depth = TMPL_ARGS_DEPTH (targs);\n+\t      int parm_depth = TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (tmpl));\n+\n+\t      if (arg_depth > parm_depth)\n+\t\t{\n+\t\t  /* If TMPL is not the most general template (for\n+\t\t     example, if TMPL is a friend template that is\n+\t\t     injected into namespace scope), then there will\n+\t\t     be too many levels fo TARGS.  Remove some of them\n+\t\t     here.  */\n+\t\t  int i;\n+\t\t  tree new_targs;\n+\n+\t\t  new_targs = make_temp_vec (parm_depth);\n+\t\t  for (i = arg_depth - parm_depth; i < arg_depth; ++i)\n+\t\t    TREE_VEC_ELT (new_targs, i - (arg_depth - parm_depth))\n+\t\t      = TREE_VEC_ELT (targs, i);\n+\t\t  targs = new_targs;\n+\t\t}\n+\t\t  \n+\t      decl = instantiate_template (tmpl, targs);\n \t      return decl;\n \t    }\n \t  \n@@ -4583,11 +4603,29 @@ tsubst_friend_class (friend_tmpl, args)\n      tree args;\n {\n   tree friend_type;\n-  tree tmpl = lookup_name (DECL_NAME (friend_tmpl), 1); \n+  tree tmpl;\n \n-  tmpl = maybe_get_template_decl_from_type_decl (tmpl);\n+  /* First, we look for a class template.  */\n+  tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/0); \n+  \n+  /* But, if we don't find one, it might be because we're in a\n+     situation like this:\n+\n+       template <class T>\n+       struct S {\n+         template <class U>\n+\t friend struct S;\n+       };\n+\n+     Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL\n+     for `S<int>', not the TEMPLATE_DECL.  */\n+  if (!DECL_CLASS_TEMPLATE_P (tmpl))\n+    {\n+      tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/1);\n+      tmpl = maybe_get_template_decl_from_type_decl (tmpl);\n+    }\n \n-  if (tmpl != NULL_TREE && DECL_CLASS_TEMPLATE_P (tmpl))\n+  if (tmpl && DECL_CLASS_TEMPLATE_P (tmpl))\n     {\n       /* The friend template has already been declared.  Just\n \t check to see that the declarations match, and install any new"}, {"sha": "d6b74a084d7b7108c74b964e803048bf1d8b7185", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend41.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25aab5d0addefe0e3b814a7ec540a1fa883cd11f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend41.C?ref=25aab5d0addefe0e3b814a7ec540a1fa883cd11f", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+class S {\n+public:\n+  template <class U>\n+  class C {\n+  public:\n+    void f() { S::i = 3; }\n+  };\n+\n+  template <class U>\n+  friend class C;\n+\n+private:\n+  static int i;\n+};\n+\n+\n+template void S<int>::C<double>::f();"}]}