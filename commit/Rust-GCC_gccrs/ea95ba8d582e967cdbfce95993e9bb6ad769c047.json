{"sha": "ea95ba8d582e967cdbfce95993e9bb6ad769c047", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5NWJhOGQ1ODJlOTY3Y2RiZmNlOTU5OTNlOWJiNmFkNzY5YzA0Nw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-08-04T10:31:23Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-08-18T19:10:53Z"}, "message": "Decouple adjust_range_from_scev from vr_values and value_range_equiv.\n\ngcc/ChangeLog:\n\n\t* vr-values.c (check_for_binary_op_overflow): Change type of store\n\tto range_query.\n\t(vr_values::adjust_range_with_scev): Abstract most of the code...\n\t(range_of_var_in_loop): ...here.  Remove value_range_equiv uses.\n\t(simplify_using_ranges::simplify_using_ranges): Change type of store\n\tto range_query.\n\t* vr-values.h (class range_query): New.\n\t(class simplify_using_ranges): Use range_query.\n\t(class vr_values): Add OVERRIDE to get_value_range.\n\t(range_of_var_in_loop): New.", "tree": {"sha": "c3d740d5773179e7c1a37ae46a67f72f18f49bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3d740d5773179e7c1a37ae46a67f72f18f49bbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea95ba8d582e967cdbfce95993e9bb6ad769c047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea95ba8d582e967cdbfce95993e9bb6ad769c047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea95ba8d582e967cdbfce95993e9bb6ad769c047", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea95ba8d582e967cdbfce95993e9bb6ad769c047/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d367f5fcb579d21c3093cf5c464f5787fe584a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d367f5fcb579d21c3093cf5c464f5787fe584a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d367f5fcb579d21c3093cf5c464f5787fe584a1d"}], "stats": {"total": 192, "additions": 103, "deletions": 89}, "files": [{"sha": "9b21441dff31c9b9087d1191bc61d62cd286dee2", "filename": "gcc/vr-values.c", "status": "modified", "additions": 85, "deletions": 84, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea95ba8d582e967cdbfce95993e9bb6ad769c047/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea95ba8d582e967cdbfce95993e9bb6ad769c047/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=ea95ba8d582e967cdbfce95993e9bb6ad769c047", "patch": "@@ -1006,7 +1006,7 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n    overflow.  */\n \n static bool\n-check_for_binary_op_overflow (vr_values *store,\n+check_for_binary_op_overflow (range_query *store,\n \t\t\t      enum tree_code subcode, tree type,\n \t\t\t      tree op0, tree op1, bool *ovf)\n {\n@@ -1736,42 +1736,40 @@ compare_range_with_value (enum tree_code comp, const value_range *vr,\n \n   gcc_unreachable ();\n }\n-/* Given a range VR, a LOOP and a variable VAR, determine whether it\n-   would be profitable to adjust VR using scalar evolution information\n-   for VAR.  If so, update VR with the new limits.  */\n \n-void\n-vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n-\t\t\t\t   gimple *stmt, tree var)\n+/* Given a VAR in STMT within LOOP, determine the bounds of the\n+   variable and store it in MIN/MAX and return TRUE.  If no bounds\n+   could be determined, return FALSE.  */\n+\n+bool\n+bounds_of_var_in_loop (tree *min, tree *max, range_query *query,\n+\t\t       class loop *loop, gimple *stmt, tree var)\n {\n-  tree init, step, chrec, tmin, tmax, min, max, type, tem;\n+  tree init, step, chrec, tmin, tmax, type = TREE_TYPE (var);\n   enum ev_direction dir;\n \n-  /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n-     better opportunities than a regular range, but I'm not sure.  */\n-  if (vr->kind () == VR_ANTI_RANGE)\n-    return;\n-\n   chrec = instantiate_parameters (loop, analyze_scalar_evolution (loop, var));\n \n   /* Like in PR19590, scev can return a constant function.  */\n   if (is_gimple_min_invariant (chrec))\n     {\n-      vr->set (chrec);\n-      return;\n+      *min = *max = chrec;\n+      return true;\n     }\n \n   if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n-    return;\n+    return false;\n \n   init = initial_condition_in_loop_num (chrec, loop->num);\n-  tem = op_with_constant_singleton_value_range (init);\n-  if (tem)\n-    init = tem;\n   step = evolution_part_in_loop_num (chrec, loop->num);\n-  tem = op_with_constant_singleton_value_range (step);\n-  if (tem)\n-    step = tem;\n+\n+  /* If INIT is an SSA with a singleton range, set INIT to said\n+     singleton, otherwise leave INIT alone.  */\n+  if (TREE_CODE (init) == SSA_NAME)\n+    query->get_value_range (init, stmt)->singleton_p (&init);\n+  /* Likewise for step.  */\n+  if (TREE_CODE (step) == SSA_NAME)\n+    query->get_value_range (step, stmt)->singleton_p (&step);\n \n   /* If STEP is symbolic, we can't know whether INIT will be the\n      minimum or maximum value in the range.  Also, unless INIT is\n@@ -1780,7 +1778,7 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n   if (step == NULL_TREE\n       || !is_gimple_min_invariant (step)\n       || !valid_value_p (init))\n-    return;\n+    return false;\n \n   dir = scev_direction (chrec);\n   if (/* Do not adjust ranges if we do not know whether the iv increases\n@@ -1789,9 +1787,8 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n       /* ... or if it may wrap.  */\n       || scev_probably_wraps_p (NULL_TREE, init, step, stmt,\n \t\t\t\tget_chrec_loop (chrec), true))\n-    return;\n+    return false;\n \n-  type = TREE_TYPE (var);\n   if (POINTER_TYPE_P (type) || !TYPE_MIN_VALUE (type))\n     tmin = lower_bound_in_type (type, type);\n   else\n@@ -1806,7 +1803,7 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n   if (TREE_CODE (step) == INTEGER_CST\n       && is_gimple_val (init)\n       && (TREE_CODE (init) != SSA_NAME\n-\t  || get_value_range (init, stmt)->kind () == VR_RANGE))\n+\t  || query->get_value_range (init, stmt)->kind () == VR_RANGE))\n     {\n       widest_int nit;\n \n@@ -1829,21 +1826,29 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n \t      && (sgn == UNSIGNED\n \t\t  || wi::gts_p (wtmp, 0) == wi::gts_p (wi::to_wide (step), 0)))\n \t    {\n-\t      value_range_equiv maxvr;\n-\t      tem = wide_int_to_tree (TREE_TYPE (init), wtmp);\n-\t      extract_range_from_binary_expr (&maxvr, PLUS_EXPR,\n-\t\t\t\t\t      TREE_TYPE (init), init, tem);\n+\t      value_range maxvr, vr0, vr1;\n+\t      if (TREE_CODE (init) == SSA_NAME)\n+\t\tvr0 = *(query->get_value_range (init, stmt));\n+\t      else if (is_gimple_min_invariant (init))\n+\t\tvr0.set (init);\n+\t      else\n+\t\tvr0.set_varying (TREE_TYPE (init));\n+\t      tree tem = wide_int_to_tree (TREE_TYPE (init), wtmp);\n+\t      vr1.set (tem, tem);\n+\t      range_fold_binary_expr (&maxvr, PLUS_EXPR,\n+\t\t\t\t      TREE_TYPE (init), &vr0, &vr1);\n+\n \t      /* Likewise if the addition did.  */\n \t      if (maxvr.kind () == VR_RANGE)\n \t\t{\n \t\t  value_range initvr;\n \n \t\t  if (TREE_CODE (init) == SSA_NAME)\n-\t\t    initvr = *(get_value_range (init, stmt));\n+\t\t    initvr = *(query->get_value_range (init, stmt));\n \t\t  else if (is_gimple_min_invariant (init))\n \t\t    initvr.set (init);\n \t\t  else\n-\t\t    return;\n+\t\t    return false;\n \n \t\t  /* Check if init + nit * step overflows.  Though we checked\n \t\t     scev {init, step}_loop doesn't wrap, it is not enough\n@@ -1853,7 +1858,7 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n \t\t       && compare_values (maxvr.min (), initvr.min ()) != -1)\n \t\t      || (dir == EV_DIR_GROWS\n \t\t\t  && compare_values (maxvr.max (), initvr.max ()) != 1))\n-\t\t    return;\n+\t\t    return false;\n \n \t\t  tmin = maxvr.min ();\n \t\t  tmax = maxvr.max ();\n@@ -1862,66 +1867,62 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n \t}\n     }\n \n-  if (vr->varying_p () || vr->undefined_p ())\n-    {\n-      min = tmin;\n-      max = tmax;\n+  *min = tmin;\n+  *max = tmax;\n+  if (dir == EV_DIR_DECREASES)\n+    *max = init;\n+  else\n+    *min = init;\n \n-      /* For VARYING or UNDEFINED ranges, just about anything we get\n-\t from scalar evolutions should be better.  */\n+  /* Even for valid range info, sometimes overflow flag will leak in.\n+     As GIMPLE IL should have no constants with TREE_OVERFLOW set, we\n+     drop them.  */\n+  if (TREE_OVERFLOW_P (*min))\n+    *min = drop_tree_overflow (*min);\n+  if (TREE_OVERFLOW_P (*max))\n+    *max = drop_tree_overflow (*max);\n \n-      if (dir == EV_DIR_DECREASES)\n-\tmax = init;\n-      else\n-\tmin = init;\n-    }\n-  else if (vr->kind () == VR_RANGE)\n-    {\n-      min = vr->min ();\n-      max = vr->max ();\n+  gcc_checking_assert (compare_values (*min, *max) != 1);\n+  return true;\n+}\n+\n+/* Given a range VR, a LOOP and a variable VAR, determine whether it\n+   would be profitable to adjust VR using scalar evolution information\n+   for VAR.  If so, update VR with the new limits.  */\n \n-      if (dir == EV_DIR_DECREASES)\n+void\n+vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n+\t\t\t\t   gimple *stmt, tree var)\n+{\n+  tree min, max;\n+  if (bounds_of_var_in_loop (&min, &max, this, loop, stmt, var))\n+    {\n+      if (vr->undefined_p () || vr->varying_p ())\n \t{\n-\t  /* INIT is the maximum value.  If INIT is lower than VR->MAX ()\n-\t     but no smaller than VR->MIN (), set VR->MAX () to INIT.  */\n-\t  if (compare_values (init, max) == -1)\n-\t    max = init;\n+\t  /* For VARYING or UNDEFINED ranges, just about anything we get\n+\t     from scalar evolutions should be better.  */\n+\t  vr->update (min, max);\n+\t}\n+      else if (vr->kind () == VR_RANGE)\n+\t{\n+\t  /* Start with the input range... */\n+\t  tree vrmin = vr->min ();\n+\t  tree vrmax = vr->max ();\n \n-\t  /* According to the loop information, the variable does not\n-\t     overflow.  */\n-\t  if (compare_values (min, tmin) == -1)\n-\t    min = tmin;\n+\t  /* ...and narrow it down with what we got from SCEV.  */\n+\t  if (compare_values (min, vrmin) == 1)\n+\t    vrmin = min;\n+\t  if (compare_values (max, vrmax) == -1)\n+\t    vrmax = max;\n \n+\t  vr->update (vrmin, vrmax);\n \t}\n-      else\n+      else if (vr->kind () == VR_ANTI_RANGE)\n \t{\n-\t  /* If INIT is bigger than VR->MIN (), set VR->MIN () to INIT.  */\n-\t  if (compare_values (init, min) == 1)\n-\t    min = init;\n-\n-\t  if (compare_values (tmax, max) == -1)\n-\t    max = tmax;\n+\t  /* ?? As an enhancement, if VR, MIN, and MAX are constants, one\n+\t     could just intersect VR with a range of [MIN,MAX].  */\n \t}\n     }\n-  else\n-    return;\n-\n-  /* If we just created an invalid range with the minimum\n-     greater than the maximum, we fail conservatively.\n-     This should happen only in unreachable\n-     parts of code, or for invalid programs.  */\n-  if (compare_values (min, max) == 1)\n-    return;\n-\n-  /* Even for valid range info, sometimes overflow flag will leak in.\n-     As GIMPLE IL should have no constants with TREE_OVERFLOW set, we\n-     drop them.  */\n-  if (TREE_OVERFLOW_P (min))\n-    min = drop_tree_overflow (min);\n-  if (TREE_OVERFLOW_P (max))\n-    max = drop_tree_overflow (max);\n-\n-  vr->update (min, max);\n }\n \n /* Dump value ranges of all SSA_NAMEs to FILE.  */\n@@ -4216,7 +4217,7 @@ simplify_using_ranges::two_valued_val_range_p (tree var, tree *a, tree *b)\n   return false;\n }\n \n-simplify_using_ranges::simplify_using_ranges (vr_values *store)\n+simplify_using_ranges::simplify_using_ranges (range_query *store)\n   : store (store)\n {\n   to_remove_edges = vNULL;"}, {"sha": "7051e13fc00884d2226f27fd4f10de6ddb6db88b", "filename": "gcc/vr-values.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea95ba8d582e967cdbfce95993e9bb6ad769c047/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea95ba8d582e967cdbfce95993e9bb6ad769c047/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=ea95ba8d582e967cdbfce95993e9bb6ad769c047", "patch": "@@ -22,16 +22,26 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"value-range-equiv.h\"\n \n+// Abstract class to return a range for a given SSA.\n+\n+class range_query\n+{\n+public:\n+  virtual const value_range_equiv *get_value_range (const_tree,\n+\t\t\t\t\t\t    gimple * = NULL) = 0;\n+  virtual ~range_query () { }\n+};\n+\n // Class to simplify a statement using range information.\n //\n // The constructor takes a full vr_values, but all it needs is\n // get_value_range() from it.  This class could be made to work with\n // any range repository.\n \n-class simplify_using_ranges\n+class simplify_using_ranges : public range_query\n {\n public:\n-  simplify_using_ranges (class vr_values *);\n+  simplify_using_ranges (class range_query *);\n   ~simplify_using_ranges ();\n   bool simplify (gimple_stmt_iterator *);\n \n@@ -44,7 +54,7 @@ class simplify_using_ranges\n \n private:\n   const value_range_equiv *get_value_range (const_tree op,\n-\t\t\t\t\t    gimple *stmt = NULL);\n+\t\t\t\t\t    gimple *stmt = NULL) OVERRIDE;\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n@@ -79,7 +89,7 @@ class simplify_using_ranges\n \n   vec<edge> to_remove_edges;\n   vec<switch_update> to_update_switch_stmts;\n-  class vr_values *store;\n+  class range_query *store;\n };\n \n /* The VR_VALUES class holds the current view of range information\n@@ -96,7 +106,7 @@ class simplify_using_ranges\n    gets attached to an SSA_NAME.  It's unclear how useful that global\n    information will be in a world where we can compute context sensitive\n    range information fast or perform on-demand queries.  */\n-class vr_values\n+class vr_values : public range_query\n {\n  public:\n   vr_values (void);\n@@ -177,4 +187,7 @@ extern tree get_output_for_vrp (gimple *);\n // FIXME: Move this to tree-vrp.c.\n void simplify_cond_using_ranges_2 (class vr_values *, gcond *);\n \n+extern bool bounds_of_var_in_loop (tree *min, tree *max, range_query *,\n+\t\t\t\t   class loop *loop, gimple *stmt, tree var);\n+\n #endif /* GCC_VR_VALUES_H */"}]}