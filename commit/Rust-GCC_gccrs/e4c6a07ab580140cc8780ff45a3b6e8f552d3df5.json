{"sha": "e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRjNmEwN2FiNTgwMTQwY2M4NzgwZmY0NWEzYjZlOGY1NTJkM2RmNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-02T16:25:59Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-02T16:25:59Z"}, "message": "re PR tree-optimization/42172 (inefficient bit fields assignments)\n\n\tPR target/42172\n\t* config/arm/arm.c (thumb1_rtx_costs): Improve support for SIGN_EXTEND\n\tand ZERO_EXTEND.\n\t(arm_rtx_costs_1): Likewise.\n\t(arm_size_rtx_costs): Use arm_rtx_costs_1 for these codes.\n\t* config/arm/arm.md (is_arch6): New attribute.\n\t(zero_extendhisi2, zero_extendqisi2, extendhisi2,\n\textendqisi2): Tighten the code somewhat, avoiding invalid\n\tRTL to occur in the expander patterns.\n\t(thumb1_zero_extendhisi2): Merge with thumb1_zero_extendhisi2_v6.\n\t(thumb1_zero_extendhisi2_v6): Delete.\n\t(thumb1_extendhisi2): Merge with thumb1_extendhisi2_v6.\n\t(thumb1_extendhisi2_v6): Delete.\n\t(thumb1_extendqisi2): Merge with thumb1_extendhisi2_v6.\n\t(thumb1_extendqisi2_v6): Delete.\n\t(zero_extendhisi2 for register input splitter): New.\n\t(zero_extendqisi2 for register input splitter): New.\n\t(thumb1_extendhisi2 for register input splitter): New.\n\t(extendhisi2 for register input splitter): New.\n\t(extendqisi2 for register input splitter): New.\n\t(TARGET_THUMB1 extendqisi2 for memory input splitter): New.\n\t(arm_zero_extendhisi2): Allow nonimmediate_operand for operand 1,\n\tand add support for a register alternative requiring a split.\n\t(thumb1_zero_extendqisi2): Likewise.\n\t(arm_zero_extendqisi2): Likewise.\n\t(arm_extendhisi2): Likewise.\n\t(arm_extendqisi2): Likewise.\n\ntestsuite/\n\tPR target/42172\n\t* gcc.target/arm/pr42172-1.c: New test.\n\nFrom-SVN: r161726", "tree": {"sha": "0b3ff1d243847f18cf8f9553e691d395447110b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b3ff1d243847f18cf8f9553e691d395447110b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/comments", "author": null, "committer": null, "parents": [{"sha": "18e8200f7082b15957ee05829ce51a06c381b378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e8200f7082b15957ee05829ce51a06c381b378", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e8200f7082b15957ee05829ce51a06c381b378"}], "stats": {"total": 827, "additions": 335, "deletions": 492}, "files": [{"sha": "bd7b258b4991744c654689dceb6a5d760d917659", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "patch": "@@ -8,6 +8,34 @@\n \t(compare_scc): Now a define_and_split.  Add a number of extra\n \tsplitters before it.\n \n+\tPR target/42172\n+\t* config/arm/arm.c (thumb1_rtx_costs): Improve support for SIGN_EXTEND\n+\tand ZERO_EXTEND.\n+\t(arm_rtx_costs_1): Likewise.\n+\t(arm_size_rtx_costs): Use arm_rtx_costs_1 for these codes.\n+\t* config/arm/arm.md (is_arch6): New attribute.\n+\t(zero_extendhisi2, zero_extendqisi2, extendhisi2,\n+\textendqisi2): Tighten the code somewhat, avoiding invalid\n+\tRTL to occur in the expander patterns.\n+\t(thumb1_zero_extendhisi2): Merge with thumb1_zero_extendhisi2_v6.\n+\t(thumb1_zero_extendhisi2_v6): Delete.\n+\t(thumb1_extendhisi2): Merge with thumb1_extendhisi2_v6.\n+\t(thumb1_extendhisi2_v6): Delete.\n+\t(thumb1_extendqisi2): Merge with thumb1_extendhisi2_v6.\n+\t(thumb1_extendqisi2_v6): Delete.\n+\t(zero_extendhisi2 for register input splitter): New.\n+\t(zero_extendqisi2 for register input splitter): New.\n+\t(thumb1_extendhisi2 for register input splitter): New.\n+\t(extendhisi2 for register input splitter): New.\n+\t(extendqisi2 for register input splitter): New.\n+\t(TARGET_THUMB1 extendqisi2 for memory input splitter): New.\n+\t(arm_zero_extendhisi2): Allow nonimmediate_operand for operand 1,\n+\tand add support for a register alternative requiring a split.\n+\t(thumb1_zero_extendqisi2): Likewise.\n+\t(arm_zero_extendqisi2): Likewise.\n+\t(arm_extendhisi2): Likewise.\n+\t(arm_extendqisi2): Likewise.\n+\n 2010-07-02  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/arm/arm.c (neon_vdup_constant): Expand into canonical RTL"}, {"sha": "2cc8d699b167b439b8dce785169d35529c0dc218", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 35, "deletions": 76, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "patch": "@@ -6214,6 +6214,7 @@ static inline int\n thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n {\n   enum machine_mode mode = GET_MODE (x);\n+  int total;\n \n   switch (code)\n     {\n@@ -6312,24 +6313,20 @@ thumb1_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer)\n \treturn 14;\n       return 2;\n \n+    case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      /* XXX still guessing.  */\n-      switch (GET_MODE (XEXP (x, 0)))\n-\t{\n-\tcase QImode:\n-\t  return (1 + (mode == DImode ? 4 : 0)\n-\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+      total = mode == DImode ? COSTS_N_INSNS (1) : 0;\n+      total += thumb1_rtx_costs (XEXP (x, 0), GET_CODE (XEXP (x, 0)), code);\n \n-\tcase HImode:\n-\t  return (4 + (mode == DImode ? 4 : 0)\n-\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+      if (mode == SImode)\n+\treturn total;\n \n-\tcase SImode:\n-\t  return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+      if (arm_arch6)\n+\treturn total + COSTS_N_INSNS (1);\n \n-\tdefault:\n-\t  return 99;\n-\t}\n+      /* Assume a two-shift sequence.  Increase the cost slightly so\n+\t we prefer actual shifts over an extend operation.  */\n+      return total + 1 + COSTS_N_INSNS (2);\n \n     default:\n       return 99;\n@@ -6798,44 +6795,39 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       return false;\n \n     case SIGN_EXTEND:\n-      if (GET_MODE_CLASS (mode) == MODE_INT)\n-\t{\n-\t  *total = 0;\n-\t  if (mode == DImode)\n-\t    *total += COSTS_N_INSNS (1);\n-\n-\t  if (GET_MODE (XEXP (x, 0)) != SImode)\n-\t    {\n-\t      if (arm_arch6)\n-\t\t{\n-\t\t  if (GET_CODE (XEXP (x, 0)) != MEM)\n-\t\t    *total += COSTS_N_INSNS (1);\n-\t\t}\n-\t      else if (!arm_arch4 || GET_CODE (XEXP (x, 0)) != MEM)\n-\t\t*total += COSTS_N_INSNS (2);\n-\t    }\n-\n-\t  return false;\n-\t}\n-\n-      /* Fall through */\n     case ZERO_EXTEND:\n       *total = 0;\n       if (GET_MODE_CLASS (mode) == MODE_INT)\n \t{\n+\t  rtx op = XEXP (x, 0);\n+\t  enum machine_mode opmode = GET_MODE (op);\n+\n \t  if (mode == DImode)\n \t    *total += COSTS_N_INSNS (1);\n \n-\t  if (GET_MODE (XEXP (x, 0)) != SImode)\n+\t  if (opmode != SImode)\n \t    {\n-\t      if (arm_arch6)\n+\t      if (MEM_P (op))\n \t\t{\n-\t\t  if (GET_CODE (XEXP (x, 0)) != MEM)\n-\t\t    *total += COSTS_N_INSNS (1);\n+\t\t  /* If !arm_arch4, we use one of the extendhisi2_mem\n+\t\t     or movhi_bytes patterns for HImode.  For a QImode\n+\t\t     sign extension, we first zero-extend from memory\n+\t\t     and then perform a shift sequence.  */\n+\t\t  if (!arm_arch4 && (opmode != QImode || code == SIGN_EXTEND))\n+\t\t    *total += COSTS_N_INSNS (2);\n \t\t}\n-\t      else if (!arm_arch4 || GET_CODE (XEXP (x, 0)) != MEM)\n-\t\t*total += COSTS_N_INSNS (GET_MODE (XEXP (x, 0)) == QImode ?\n-\t\t\t\t\t 1 : 2);\n+\t      else if (arm_arch6)\n+\t\t*total += COSTS_N_INSNS (1);\n+\n+\t      /* We don't have the necessary insn, so we need to perform some\n+\t\t other operation.  */\n+\t      else if (TARGET_ARM && code == ZERO_EXTEND && mode == QImode)\n+\t\t/* An and with constant 255.  */\n+\t\t*total += COSTS_N_INSNS (1);\n+\t      else\n+\t\t/* A shift sequence.  Increase costs slightly to avoid\n+\t\t   combining two shifts into an extend operation.  */\n+\t\t*total += COSTS_N_INSNS (2) + 1;\n \t    }\n \n \t  return false;\n@@ -7191,41 +7183,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case SIGN_EXTEND:\n-      *total = 0;\n-      if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) < 4)\n-\t{\n-\t  if (!(arm_arch4 && MEM_P (XEXP (x, 0))))\n-\t    *total += COSTS_N_INSNS (arm_arch6 ? 1 : 2);\n-\t}\n-      if (mode == DImode)\n-\t*total += COSTS_N_INSNS (1);\n-      return false;\n-\n     case ZERO_EXTEND:\n-      *total = 0;\n-      if (!(arm_arch4 && MEM_P (XEXP (x, 0))))\n-\t{\n-\t  switch (GET_MODE (XEXP (x, 0)))\n-\t    {\n-\t    case QImode:\n-\t      *total += COSTS_N_INSNS (1);\n-\t      break;\n-\n-\t    case HImode:\n-\t      *total += COSTS_N_INSNS (arm_arch6 ? 1 : 2);\n-\n-\t    case SImode:\n-\t      break;\n-\n-\t    default:\n-\t      *total += COSTS_N_INSNS (2);\n-\t    }\n-\t}\n-\n-      if (mode == DImode)\n-\t*total += COSTS_N_INSNS (1);\n-\n-      return false;\n+      return arm_rtx_costs_1 (x, outer_code, total, 0);\n \n     case CONST_INT:\n       if (const_ok_for_arm (INTVAL (x)))"}, {"sha": "659ff7e95e7386cbd3114f16898e8ead5bbce45b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 250, "deletions": 416, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "patch": "@@ -148,6 +148,9 @@\n ; patterns that share the same RTL in both ARM and Thumb code.\n (define_attr \"is_thumb\" \"no,yes\" (const (symbol_ref \"thumb_code\")))\n \n+; IS_ARCH6 is set to 'yes' when we are generating code form ARMv6.\n+(define_attr \"is_arch6\" \"no,yes\" (const (symbol_ref \"arm_arch6\")))\n+\n ;; Operand number of an input operand that is shifted.  Zero if the\n ;; given instruction does not shift one of its input operands.\n (define_attr \"shift\" \"\" (const_int 0))\n@@ -3987,93 +3990,46 @@\n )\n \n (define_expand \"zero_extendhisi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (const_int 16)))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(lshiftrt:SI (match_dup 2) (const_int 16)))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"\n-  {\n-    if ((TARGET_THUMB1 || arm_arch4) && GET_CODE (operands[1]) == MEM)\n-      {\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n-\tDONE;\n-      }\n-\n-    if (TARGET_ARM && GET_CODE (operands[1]) == MEM)\n-      {\n-\temit_insn (gen_movhi_bytes (operands[0], operands[1]));\n-\tDONE;\n-      }\n-\n-    if (!s_register_operand (operands[1], HImode))\n-      operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-\n-    if (arm_arch6)\n-      {\n-\temit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\tgen_rtx_ZERO_EXTEND (SImode, operands[1])));\n-\tDONE;\n-      }\n-\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_reg_rtx (SImode);\n-  }\"\n-)\n-\n-(define_insn \"*thumb1_zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_THUMB1 && !arm_arch6\"\n-  \"*\n-  rtx mem = XEXP (operands[1], 0);\n-\n-  if (GET_CODE (mem) == CONST)\n-    mem = XEXP (mem, 0);\n-    \n-  if (GET_CODE (mem) == LABEL_REF)\n-    return \\\"ldr\\\\t%0, %1\\\";\n-    \n-  if (GET_CODE (mem) == PLUS)\n+{\n+  if (TARGET_ARM && !arm_arch4 && MEM_P (operands[1]))\n     {\n-      rtx a = XEXP (mem, 0);\n-      rtx b = XEXP (mem, 1);\n-\n-      /* This can happen due to bugs in reload.  */\n-      if (GET_CODE (a) == REG && REGNO (a) == SP_REGNUM)\n-        {\n-          rtx ops[2];\n-          ops[0] = operands[0];\n-          ops[1] = a;\n-      \n-          output_asm_insn (\\\"mov\t%0, %1\\\", ops);\n-\n-          XEXP (mem, 0) = operands[0];\n-       }\n-\n-      else if (   GET_CODE (a) == LABEL_REF\n-\t       && GET_CODE (b) == CONST_INT)\n-        return \\\"ldr\\\\t%0, %1\\\";\n+      emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n+      DONE;\n     }\n-    \n-  return \\\"ldrh\\\\t%0, %1\\\";\n-  \"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"load_byte\")\n-   (set_attr \"pool_range\" \"60\")]\n-)\n+  if (!arm_arch6 && !MEM_P (operands[1]))\n+    {\n+      rtx t = gen_lowpart (SImode, operands[1]);\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashlsi3 (tmp, t, GEN_INT (16)));\n+      emit_insn (gen_lshrsi3 (operands[0], tmp, GEN_INT (16)));\n+      DONE;\n+    }\n+})\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:HI 1 \"register_operand\" \"l,m\")))]\n+  \"!TARGET_THUMB2 && !arm_arch6\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 16)))]\n+{\n+  operands[2] = gen_lowpart (SImode, operands[1]);\n+})\n \n-(define_insn \"*thumb1_zero_extendhisi2_v6\"\n+(define_insn \"*thumb1_zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))]\n-  \"TARGET_THUMB1 && arm_arch6\"\n+  \"TARGET_THUMB1\"\n   \"*\n   rtx mem;\n \n-  if (which_alternative == 0)\n+  if (which_alternative == 0 && arm_arch6)\n     return \\\"uxth\\\\t%0, %1\\\";\n+  if (which_alternative == 0)\n+    return \\\"#\\\";\n \n   mem = XEXP (operands[1], 0);\n \n@@ -4107,20 +4063,25 @@\n     \n   return \\\"ldrh\\\\t%0, %1\\\";\n   \"\n-  [(set_attr \"length\" \"2,4\")\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t       (const_int 2) (const_int 4))\n+\t\t\t (const_int 4)])\n    (set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"pool_range\" \"*,60\")]\n )\n \n (define_insn \"*arm_zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n-  \"ldr%(h%)\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load_byte\")\n+  \"@\n+   #\n+   ldr%(h%)\\\\t%0, %1\"\n+  [(set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"256\")\n-   (set_attr \"neg_pool_range\" \"244\")]\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n )\n \n (define_insn \"*arm_zero_extendhisi2_v6\"\n@@ -4150,50 +4111,49 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"\n-  if (!arm_arch6 && GET_CODE (operands[1]) != MEM)\n+{\n+  if (TARGET_ARM && !arm_arch6 && GET_CODE (operands[1]) != MEM)\n     {\n-      if (TARGET_ARM)\n-        {\n-          emit_insn (gen_andsi3 (operands[0],\n-\t\t\t\t gen_lowpart (SImode, operands[1]),\n-\t\t\t         GEN_INT (255)));\n-        }\n-      else /* TARGET_THUMB */\n-        {\n-          rtx temp = gen_reg_rtx (SImode);\n-\t  rtx ops[3];\n-\t  \n-          operands[1] = copy_to_mode_reg (QImode, operands[1]);\n-          operands[1] = gen_lowpart (SImode, operands[1]);\n-\n-\t  ops[0] = temp;\n-\t  ops[1] = operands[1];\n-\t  ops[2] = GEN_INT (24);\n-\n-\t  emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\t  gen_rtx_ASHIFT (SImode, ops[1], ops[2])));\n-\t  \n-          ops[0] = operands[0];\n-\t  ops[1] = temp;\n-\t  ops[2] = GEN_INT (24);\n+      emit_insn (gen_andsi3 (operands[0],\n+\t\t\t     gen_lowpart (SImode, operands[1]),\n+\t\t\t\t\t  GEN_INT (255)));\n+      DONE;\n+    }\n+  if (!arm_arch6 && !MEM_P (operands[1]))\n+    {\n+      rtx t = gen_lowpart (SImode, operands[1]);\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashlsi3 (tmp, t, GEN_INT (24)));\n+      emit_insn (gen_lshrsi3 (operands[0], tmp, GEN_INT (24)));\n+      DONE;\n+    }\n+})\n \n-\t  emit_insn (gen_rtx_SET (VOIDmode, ops[0],\n-\t\t\t\t  gen_rtx_LSHIFTRT (SImode, ops[1], ops[2])));\n-\t}\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"!arm_arch6\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 24)))\n+   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 24)))]\n+{\n+  operands[2] = simplify_gen_subreg (SImode, operands[1], QImode, 0);\n+  if (TARGET_ARM)\n+    {\n+      emit_insn (gen_andsi3 (operands[0], operands[2], GEN_INT (255)));\n       DONE;\n     }\n-  \"\n-)\n+})\n \n (define_insn \"*thumb1_zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,m\")))]\n   \"TARGET_THUMB1 && !arm_arch6\"\n-  \"ldrb\\\\t%0, %1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"load_byte\")\n-   (set_attr \"pool_range\" \"32\")]\n+  \"@\n+   #\n+   ldrb\\\\t%0, %1\"\n+  [(set_attr \"length\" \"4,2\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n+   (set_attr \"pool_range\" \"*,32\")]\n )\n \n (define_insn \"*thumb1_zero_extendqisi2_v6\"\n@@ -4209,14 +4169,17 @@\n )\n \n (define_insn \"*arm_zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"TARGET_ARM && !arm_arch6\"\n-  \"ldr%(b%)\\\\t%0, %1\\\\t%@ zero_extendqisi2\"\n-  [(set_attr \"type\" \"load_byte\")\n+  \"@\n+   #\n+   ldr%(b%)\\\\t%0, %1\\\\t%@ zero_extendqisi2\"\n+  [(set_attr \"length\" \"8,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"4096\")\n-   (set_attr \"neg_pool_range\" \"4084\")]\n+   (set_attr \"pool_range\" \"*,4096\")\n+   (set_attr \"neg_pool_range\" \"*,4084\")]\n )\n \n (define_insn \"*arm_zero_extendqisi2_v6\"\n@@ -4295,108 +4258,42 @@\n )\n \n (define_expand \"extendhisi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t   (const_int 16)))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ashiftrt:SI (match_dup 2)\n-\t\t     (const_int 16)))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"\n-  {\n-    if (GET_CODE (operands[1]) == MEM)\n-      {\n-\tif (TARGET_THUMB1)\n-\t  {\n-\t    emit_insn (gen_thumb1_extendhisi2 (operands[0], operands[1]));\n-\t    DONE;\n-          }\n-\telse if (arm_arch4)\n-\t  {\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t       gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-\t    DONE;\n-\t  }\n-      }\n-\n-    if (TARGET_ARM && GET_CODE (operands[1]) == MEM)\n-      {\n-        emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n-        DONE;\n-      }\n-\n-    if (!s_register_operand (operands[1], HImode))\n-      operands[1] = copy_to_mode_reg (HImode, operands[1]);\n-\n-    if (arm_arch6)\n-      {\n-\tif (TARGET_THUMB1)\n-\t  emit_insn (gen_thumb1_extendhisi2 (operands[0], operands[1]));\n-\telse\n-\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t     gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-\n-\tDONE;\n-      }\n-\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_reg_rtx (SImode);\n-  }\"\n-)\n-\n-(define_insn \"thumb1_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))\n-   (clobber (match_scratch:SI 2 \"=&l\"))]\n-  \"TARGET_THUMB1 && !arm_arch6\"\n-  \"*\n-  {\n-    rtx ops[4];\n-    rtx mem = XEXP (operands[1], 0);\n-\n-    /* This code used to try to use 'V', and fix the address only if it was\n-       offsettable, but this fails for e.g. REG+48 because 48 is outside the\n-       range of QImode offsets, and offsettable_address_p does a QImode\n-       address check.  */\n-       \n-    if (GET_CODE (mem) == CONST)\n-      mem = XEXP (mem, 0);\n-    \n-    if (GET_CODE (mem) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n-    \n-    if (GET_CODE (mem) == PLUS)\n-      {\n-        rtx a = XEXP (mem, 0);\n-        rtx b = XEXP (mem, 1);\n-\n-        if (GET_CODE (a) == LABEL_REF\n-\t    && GET_CODE (b) == CONST_INT)\n-          return \\\"ldr\\\\t%0, %1\\\";\n-\n-        if (GET_CODE (b) == REG)\n-          return \\\"ldrsh\\\\t%0, %1\\\";\n-\t  \n-        ops[1] = a;\n-        ops[2] = b;\n-      }\n-    else\n-      {\n-        ops[1] = mem;\n-        ops[2] = const0_rtx;\n-      }\n+{\n+  if (TARGET_THUMB1)\n+    {\n+      emit_insn (gen_thumb1_extendhisi2 (operands[0], operands[1]));\n+      DONE;\n+    }\n+  if (MEM_P (operands[1]) && TARGET_ARM && !arm_arch4)\n+    {\n+      emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n+      DONE;\n+    }\n \n-    gcc_assert (GET_CODE (ops[1]) == REG);\n+  if (!arm_arch6 && !MEM_P (operands[1]))\n+    {\n+      rtx t = gen_lowpart (SImode, operands[1]);\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashlsi3 (tmp, t, GEN_INT (16)));\n+      emit_insn (gen_ashrsi3 (operands[0], tmp, GEN_INT (16)));\n+      DONE;\n+    }\n+})\n \n-    ops[0] = operands[0];\n-    ops[3] = operands[2];\n-    output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n-    return \\\"\\\";\n-  }\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"load_byte\")\n-   (set_attr \"pool_range\" \"1020\")]\n-)\n+(define_split\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t  (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))\n+     (clobber (match_scratch:SI 2 \"\"))])]\n+  \"!arm_arch6\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 16)))]\n+{\n+  operands[2] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n+})\n \n ;; We used to have an early-clobber on the scratch register here.\n ;; However, there's a bug somewhere in reload which means that this\n@@ -4405,16 +4302,18 @@\n ;; we try to verify the operands.  Fortunately, we don't really need\n ;; the early-clobber: we can always use operand 0 if operand 2\n ;; overlaps the address.\n-(define_insn \"*thumb1_extendhisi2_insn_v6\"\n+(define_insn \"thumb1_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"l,m\")))\n    (clobber (match_scratch:SI 2 \"=X,l\"))]\n-  \"TARGET_THUMB1 && arm_arch6\"\n+  \"TARGET_THUMB1\"\n   \"*\n   {\n     rtx ops[4];\n     rtx mem;\n \n+    if (which_alternative == 0 && !arm_arch6)\n+      return \\\"#\\\";\n     if (which_alternative == 0)\n       return \\\"sxth\\\\t%0, %1\\\";\n \n@@ -4462,7 +4361,10 @@\n     output_asm_insn (\\\"mov\\\\t%3, %2\\;ldrsh\\\\t%0, [%1, %3]\\\", ops);\n     return \\\"\\\";\n   }\"\n-  [(set_attr \"length\" \"2,4\")\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 2) (const_int 4))\n+\t\t\t  (const_int 4)])\n    (set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"pool_range\" \"*,1020\")]\n )\n@@ -4503,15 +4405,28 @@\n   }\"\n )\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"!arm_arch6\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 16)))]\n+{\n+  operands[2] = simplify_gen_subreg (SImode, operands[1], HImode, 0);\n+})\n+\n (define_insn \"*arm_extendhisi2\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n   \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n-  \"ldr%(sh%)\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load_byte\")\n+  \"@\n+   #\n+   ldr%(sh%)\\\\t%0, %1\"\n+  [(set_attr \"length\" \"8,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"256\")\n-   (set_attr \"neg_pool_range\" \"244\")]\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n )\n \n ;; ??? Check Thumb-2 pool range\n@@ -4573,46 +4488,45 @@\n )\n \n (define_expand \"extendqisi2\"\n-  [(set (match_dup 2)\n-\t(ashift:SI (match_operand:QI 1 \"arm_reg_or_extendqisi_mem_op\" \"\")\n-\t\t   (const_int 24)))\n-   (set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(ashiftrt:SI (match_dup 2)\n-\t\t     (const_int 24)))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"arm_reg_or_extendqisi_mem_op\" \"\")))]\n   \"TARGET_EITHER\"\n-  \"\n-  {\n-    if ((TARGET_THUMB || arm_arch4) && GET_CODE (operands[1]) == MEM)\n-      {\n-        emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t        gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-        DONE;\n-      }\n-\n-    if (!s_register_operand (operands[1], QImode))\n-      operands[1] = copy_to_mode_reg (QImode, operands[1]);\n+{\n+  if (!arm_arch4 && MEM_P (operands[1]))\n+    operands[1] = copy_to_mode_reg (QImode, operands[1]);\n \n-    if (arm_arch6)\n-      {\n-        emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t        gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-        DONE;\n-      }\n+  if (!arm_arch6 && !MEM_P (operands[1]))\n+    {\n+      rtx t = gen_lowpart (SImode, operands[1]);\n+      rtx tmp = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashlsi3 (tmp, t, GEN_INT (24)));\n+      emit_insn (gen_ashrsi3 (operands[0], tmp, GEN_INT (24)));\n+      DONE;\n+    }\n+})\n \n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_reg_rtx (SImode);\n-  }\"\n-)\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"!arm_arch6\"\n+  [(set (match_dup 0) (ashift:SI (match_dup 2) (const_int 24)))\n+   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (const_int 24)))]\n+{\n+  operands[2] = simplify_gen_subreg (SImode, operands[1], QImode, 0);\n+})\n \n (define_insn \"*arm_extendqisi\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"arm_extendqisi_mem_op\" \"Uq\")))]\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"arm_reg_or_extendqisi_mem_op\" \"r,Uq\")))]\n   \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n-  \"ldr%(sb%)\\\\t%0, %1\"\n-  [(set_attr \"type\" \"load_byte\")\n+  \"@\n+   #\n+   ldr%(sb%)\\\\t%0, %1\"\n+  [(set_attr \"length\" \"8,4\")\n+   (set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"pool_range\" \"256\")\n-   (set_attr \"neg_pool_range\" \"244\")]\n+   (set_attr \"pool_range\" \"*,256\")\n+   (set_attr \"neg_pool_range\" \"*,244\")]\n )\n \n (define_insn \"*arm_extendqisi_v6\"\n@@ -4640,162 +4554,82 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_insn \"*thumb1_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"V,m\")))]\n-  \"TARGET_THUMB1 && !arm_arch6\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    rtx mem = XEXP (operands[1], 0);\n-    \n-    if (GET_CODE (mem) == CONST)\n-      mem = XEXP (mem, 0);\n-    \n-    if (GET_CODE (mem) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"\")))]\n+  \"TARGET_THUMB1 && reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (sign_extend:SI (match_dup 3)))]\n+{\n+  rtx addr = XEXP (operands[1], 0);\n \n-    if (GET_CODE (mem) == PLUS\n-        && GET_CODE (XEXP (mem, 0)) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n-      \n-    if (which_alternative == 0)\n-      return \\\"ldrsb\\\\t%0, %1\\\";\n-      \n-    ops[0] = operands[0];\n-    \n-    if (GET_CODE (mem) == PLUS)\n-      {\n-        rtx a = XEXP (mem, 0);\n-\trtx b = XEXP (mem, 1);\n-\t\n-        ops[1] = a;\n-        ops[2] = b;\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n \n-        if (GET_CODE (a) == REG)\n-\t  {\n-\t    if (GET_CODE (b) == REG)\n-              output_asm_insn (\\\"ldrsb\\\\t%0, [%1, %2]\\\", ops);\n-            else if (REGNO (a) == REGNO (ops[0]))\n-\t      {\n-                output_asm_insn (\\\"ldrb\\\\t%0, [%1, %2]\\\", ops);\n-\t\toutput_asm_insn (\\\"lsl\\\\t%0, %0, #24\\\", ops);\n-\t\toutput_asm_insn (\\\"asr\\\\t%0, %0, #24\\\", ops);\n-\t      }\n-\t    else\n-              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-\t  }\n-\telse\n-          {\n-\t    gcc_assert (GET_CODE (b) == REG);\n-            if (REGNO (b) == REGNO (ops[0]))\n-\t      {\n-                output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\\", ops);\n-\t\toutput_asm_insn (\\\"lsl\\\\t%0, %0, #24\\\", ops);\n-\t\toutput_asm_insn (\\\"asr\\\\t%0, %0, #24\\\", ops);\n-\t      }\n-\t    else\n-              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-          }\n-      }\n-    else if (GET_CODE (mem) == REG && REGNO (ops[0]) == REGNO (mem))\n-      {\n-        output_asm_insn (\\\"ldrb\\\\t%0, [%0, #0]\\\", ops);\n-\toutput_asm_insn (\\\"lsl\\\\t%0, %0, #24\\\", ops);\n-\toutput_asm_insn (\\\"asr\\\\t%0, %0, #24\\\", ops);\n-      }\n-    else\n-      {\n-        ops[1] = mem;\n-        ops[2] = const0_rtx;\n-\t\n-        output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-      }\n-    return \\\"\\\";\n-  }\"\n-  [(set_attr \"length\" \"2,6\")\n-   (set_attr \"type\" \"load_byte,load_byte\")\n-   (set_attr \"pool_range\" \"32,32\")]\n-)\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n+    /* No split necessary.  */\n+    FAIL;\n+\n+  if (GET_CODE (addr) == PLUS\n+      && !REG_P (XEXP (addr, 0)) && !REG_P (XEXP (addr, 1)))\n+    FAIL;\n+\n+  if (reg_overlap_mentioned_p (operands[0], addr))\n+    {\n+      rtx t = gen_lowpart (QImode, operands[0]);\n+      emit_move_insn (t, operands[1]);\n+      emit_insn (gen_thumb1_extendqisi2 (operands[0], t));\n+      DONE;\n+    }\n+\n+  if (REG_P (addr))\n+    {\n+      addr = gen_rtx_PLUS (Pmode, addr, operands[0]);\n+      operands[2] = const0_rtx;\n+    }\n+  else if (GET_CODE (addr) != PLUS)\n+    FAIL;\n+  else if (REG_P (XEXP (addr, 0)))\n+    {\n+      operands[2] = XEXP (addr, 1);\n+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 0), operands[0]);\n+    }\n+  else\n+    {\n+      operands[2] = XEXP (addr, 0);\n+      addr = gen_rtx_PLUS (Pmode, XEXP (addr, 1), operands[0]);\n+    }\n+\n+  operands[3] = change_address (operands[1], QImode, addr);\n+})\n \n-(define_insn \"*thumb1_extendqisi2_v6\"\n+(define_insn \"thumb1_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,l,l\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"l,V,m\")))]\n-  \"TARGET_THUMB1 && arm_arch6\"\n-  \"*\n-  {\n-    rtx ops[3];\n-    rtx mem;\n-\n-    if (which_alternative == 0)\n-      return \\\"sxtb\\\\t%0, %1\\\";\n+  \"TARGET_THUMB1\"\n+{\n+  rtx addr;\n \n-    mem = XEXP (operands[1], 0);\n-    \n-    if (GET_CODE (mem) == CONST)\n-      mem = XEXP (mem, 0);\n-    \n-    if (GET_CODE (mem) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n+  if (which_alternative == 0 && arm_arch6)\n+    return \"sxtb\\\\t%0, %1\";\n+  if (which_alternative == 0)\n+    return \"#\";\n \n-    if (GET_CODE (mem) == PLUS\n-        && GET_CODE (XEXP (mem, 0)) == LABEL_REF)\n-      return \\\"ldr\\\\t%0, %1\\\";\n-      \n-    if (which_alternative == 0)\n-      return \\\"ldrsb\\\\t%0, %1\\\";\n+  addr = XEXP (operands[1], 0);\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0)) && REG_P (XEXP (addr, 1)))\n+    return \"ldrsb\\\\t%0, %1\";\n       \n-    ops[0] = operands[0];\n-    \n-    if (GET_CODE (mem) == PLUS)\n-      {\n-        rtx a = XEXP (mem, 0);\n-\trtx b = XEXP (mem, 1);\n-\t\n-        ops[1] = a;\n-        ops[2] = b;\n-\n-        if (GET_CODE (a) == REG)\n-\t  {\n-\t    if (GET_CODE (b) == REG)\n-              output_asm_insn (\\\"ldrsb\\\\t%0, [%1, %2]\\\", ops);\n-            else if (REGNO (a) == REGNO (ops[0]))\n-\t      {\n-                output_asm_insn (\\\"ldrb\\\\t%0, [%1, %2]\\\", ops);\n-\t\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n-\t      }\n-\t    else\n-              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-\t  }\n-\telse\n-          {\n-\t    gcc_assert (GET_CODE (b) == REG);\n-            if (REGNO (b) == REGNO (ops[0]))\n-\t      {\n-                output_asm_insn (\\\"ldrb\\\\t%0, [%2, %1]\\\", ops);\n-\t\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n-\t      }\n-\t    else\n-              output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-          }\n-      }\n-    else if (GET_CODE (mem) == REG && REGNO (ops[0]) == REGNO (mem))\n-      {\n-        output_asm_insn (\\\"ldrb\\\\t%0, [%0, #0]\\\", ops);\n-\toutput_asm_insn (\\\"sxtb\\\\t%0, %0\\\", ops);\n-      }\n-    else\n-      {\n-        ops[1] = mem;\n-        ops[2] = const0_rtx;\n-\t\n-        output_asm_insn (\\\"mov\\\\t%0, %2\\;ldrsb\\\\t%0, [%1, %0]\\\", ops);\n-      }\n-    return \\\"\\\";\n-  }\"\n-  [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"type\" \"alu_shift,load_byte,load_byte\")\n-   (set_attr \"pool_range\" \"*,32,32\")]\n+  return \"#\";\n+}\n+  [(set_attr_alternative \"length\"\n+\t\t\t [(if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 2) (const_int 4))\n+\t\t\t  (const_int 2)\n+\t\t\t  (if_then_else (eq_attr \"is_arch6\" \"yes\")\n+\t\t\t\t\t(const_int 4) (const_int 6))])\n+   (set_attr \"type\" \"alu_shift,load_byte,load_byte\")]\n )\n \n (define_expand \"extendsfdf2\""}, {"sha": "33a1cae3978acd327f2de266d37301fc03bbb4b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "patch": "@@ -3,6 +3,9 @@\n \tPR target/42835\n \t* gcc.target/arm/pr42835.c: New test.\n \n+\tPR target/42172\n+\t* gcc.target/arm/pr42172-1.c: New test.\n+\n 2010-07-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/template/crash98.C: Remove stray // from dg-error comment."}, {"sha": "207f6001fb7d4c14fca2634dedd7a90d8e72f7ff", "filename": "gcc/testsuite/gcc.target/arm/pr42172-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42172-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4c6a07ab580140cc8780ff45a3b6e8f552d3df5/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42172-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42172-1.c?ref=e4c6a07ab580140cc8780ff45a3b6e8f552d3df5", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-O2\" }  */\n+\n+struct A {\n+  unsigned int f1 : 3;\n+  unsigned int f2 : 3;\n+  unsigned int f3 : 1;\n+  unsigned int f4 : 1;\n+\n+};\n+\n+void init_A (struct A *this)\n+{\n+  this->f1 = 0;\n+  this->f2 = 1;\n+  this->f3 = 0;\n+  this->f4 = 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"ldr\" 1 } } */"}]}