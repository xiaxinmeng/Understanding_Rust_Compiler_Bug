{"sha": "d746694a4593b1401b9638d605f59083d488af1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NjY5NGE0NTkzYjE0MDFiOTYzOGQ2MDVmNTkwODNkNDg4YWYxZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-11T10:51:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-11T10:51:17Z"}, "message": "alias.c (nonoverlapping_memrefs_p): Not overlapping if one base is constant and one is on frame.\n\n\t* alias.c (nonoverlapping_memrefs_p): Not overlapping if one base is\n\tconstant and one is on frame.\n\tIf know memref offset, adjust size from decl.\n\nFrom-SVN: r46925", "tree": {"sha": "f0cb79d87d3ffba6c6d96bd6fdd04a7c440ba780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0cb79d87d3ffba6c6d96bd6fdd04a7c440ba780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d746694a4593b1401b9638d605f59083d488af1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d746694a4593b1401b9638d605f59083d488af1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d746694a4593b1401b9638d605f59083d488af1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d746694a4593b1401b9638d605f59083d488af1e/comments", "author": null, "committer": null, "parents": [{"sha": "6f38bb171dc664170c69b2ebb8a54796adde92a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f38bb171dc664170c69b2ebb8a54796adde92a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f38bb171dc664170c69b2ebb8a54796adde92a1"}], "stats": {"total": 27, "additions": 18, "deletions": 9}, "files": [{"sha": "00e473681df57b9d84e5ac79e11e659041953a15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746694a4593b1401b9638d605f59083d488af1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746694a4593b1401b9638d605f59083d488af1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d746694a4593b1401b9638d605f59083d488af1e", "patch": "@@ -1,3 +1,9 @@\n+Sun Nov 11 05:56:01 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (nonoverlapping_memrefs_p): Not overlapping if one base is\n+\tconstant and one is on frame.\n+\tIf know memref offset, adjust size from decl.\n+\n 2001-11-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* alpha/unicosmk.h (ASM_OUTPUT_DOUBLE, ASM_OUTPUT_FLOAT): Fix"}, {"sha": "2e03a068a55de314e3d84bd63b43c7fdfc584937", "filename": "gcc/alias.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d746694a4593b1401b9638d605f59083d488af1e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d746694a4593b1401b9638d605f59083d488af1e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d746694a4593b1401b9638d605f59083d488af1e", "patch": "@@ -1798,13 +1798,16 @@ nonoverlapping_memrefs_p (x, y)\n   if (GET_CODE (basey) == PLUS && GET_CODE (XEXP (basey, 1)) == CONST_INT)\n     offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n \n-  /* If the bases are both constant and they are different, we know these\n-     do not overlap.  If they are both registers, we can only deduce\n-     something if they are the same register.  */\n-  if (CONSTANT_P (basex) && CONSTANT_P (basey) && ! rtx_equal_p (basex, basey))\n-    return 1;\n-  else if (! rtx_equal_p (basex, basey))\n-    return 0;\n+  /* If the bases are different, we know they do not overlap if both\n+     are constants or if one is a constant and the other a pointer into the \n+     stack frame.  Otherwise a different base means we can't tell if they\n+     overlap or not.  */\n+  if (! rtx_equal_p (basex, basey))\n+      return ((CONSTANT_P (basex) && CONSTANT_P (basey))\n+\t      || (CONSTANT_P (basex) && REG_P (basey)\n+\t\t  && REGNO (basey) <= LAST_VIRTUAL_REGISTER)\n+\t      || (CONSTANT_P (basey) && REG_P (basex)\n+\t\t  && REGNO (basex) <= LAST_VIRTUAL_REGISTER));\n \n   sizex = (REG_P (rtlx) ? GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n@@ -1816,9 +1819,9 @@ nonoverlapping_memrefs_p (x, y)\n   /* If we have an offset or size for either memref, it can update the values\n      computed above.  */\n   if (MEM_OFFSET (x))\n-    offsetx += INTVAL (MEM_OFFSET (x));\n+    offsetx += INTVAL (MEM_OFFSET (x)), sizex -= INTVAL (MEM_OFFSET (x));\n   if (MEM_OFFSET (y))\n-    offsety += INTVAL (MEM_OFFSET (y));\n+    offsety += INTVAL (MEM_OFFSET (y)), sizey -= INTVAL (MEM_OFFSET (y));\n \n   if (MEM_SIZE (x))\n     sizex = INTVAL (MEM_SIZE (x));"}]}