{"sha": "4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA4MWFkYTJjN2FlNzE4ZjUwOWRjNDAzZjgzYTRhMDhmMmE2ZmU0YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-10-03T05:42:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-10-03T05:42:47Z"}, "message": "cgraph.h (ipa_polymorphic_call_context): Turn bools into bitfields...\n\n\n\t* cgraph.h (ipa_polymorphic_call_context):\n\tTurn bools into bitfields; add DYNAMIC; make MAKE_SPECULATIVE\n\tprivate, add POSSIBLE_DYNAMIC_TYPE_CHANGE.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::restrict_to_inner_class): Allow accesses\n\tpast end of dynamic types.\n\t(ipa_polymorphic_call_context::stream_out,\n\tspeculative_outer_type): Stream dynamic flag.\n\t(ipa_polymorphic_call_context::set_by_decl): Clear DYNAMIC.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context):\n\tClear DYNAMIC.\n\t(ipa_polymorphic_call_context::get_dynamic_type): Use DYNAMIC;\n\tset it.\n\t(ipa_polymorphic_call_context::combine_with): Propagate dynamic.\n\t* ipa-prop.c (update_jump_functions_after_inlining,\n\ttry_make_edge_direct_virtual_call): Use possible_dynamic_type_change.\n\nFrom-SVN: r215833", "tree": {"sha": "b9737fb423d0d6d55ae7190b20d8a112e6ff3062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9737fb423d0d6d55ae7190b20d8a112e6ff3062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/comments", "author": null, "committer": null, "parents": [{"sha": "60d9e9fc19291ce72458f41cd7c4679e26251084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d9e9fc19291ce72458f41cd7c4679e26251084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d9e9fc19291ce72458f41cd7c4679e26251084"}], "stats": {"total": 109, "additions": 85, "deletions": 24}, "files": [{"sha": "955d57a4a87d3ab3a5aa4bcb20ffc8ee09cfdff6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "patch": "@@ -1,3 +1,22 @@\n+2014-10-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (ipa_polymorphic_call_context):\n+\tTurn bools into bitfields; add DYNAMIC; make MAKE_SPECULATIVE\n+\tprivate, add POSSIBLE_DYNAMIC_TYPE_CHANGE.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::restrict_to_inner_class): Allow accesses\n+\tpast end of dynamic types.\n+\t(ipa_polymorphic_call_context::stream_out,\n+\tspeculative_outer_type): Stream dynamic flag.\n+\t(ipa_polymorphic_call_context::set_by_decl): Clear DYNAMIC.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context):\n+\tClear DYNAMIC.\n+\t(ipa_polymorphic_call_context::get_dynamic_type): Use DYNAMIC;\n+\tset it.\n+\t(ipa_polymorphic_call_context::combine_with): Propagate dynamic.\n+\t* ipa-prop.c (update_jump_functions_after_inlining,\n+\ttry_make_edge_direct_virtual_call): Use possible_dynamic_type_change.\n+\n 2014-10-02  Teresa Johnson  <tejohnson@google.com>\n \n \t* tree-ssa-threadupdate.c (freqs_to_counts_path): Scale frequencies"}, {"sha": "8bc6fc945d193f122e66a20d305247b701f45915", "filename": "gcc/cgraph.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "patch": "@@ -1281,15 +1281,17 @@ class GTY(()) ipa_polymorphic_call_context {\n   tree outer_type;\n   tree speculative_outer_type;\n   /* True if outer object may be in construction or destruction.  */\n-  bool maybe_in_construction;\n+  unsigned maybe_in_construction : 1;\n   /* True if outer object may be of derived type.  */\n-  bool maybe_derived_type;\n+  unsigned maybe_derived_type : 1;\n   /* True if speculative outer object may be of derived type.  We always\n      speculate that construction does not happen.  */\n-  bool speculative_maybe_derived_type;\n+  unsigned speculative_maybe_derived_type : 1;\n   /* True if the context is invalid and all calls should be redirected\n      to BUILTIN_UNREACHABLE.  */\n-  bool invalid;\n+  unsigned invalid : 1;\n+  /* True if the outer type is dynamic.  */\n+  unsigned dynamic : 1;\n \n   /* Build empty \"I know nothing\" context.  */\n   ipa_polymorphic_call_context ();\n@@ -1329,12 +1331,9 @@ class GTY(()) ipa_polymorphic_call_context {\n \n   /* Adjust all offsets in contexts by given number of bits.  */\n   void offset_by (HOST_WIDE_INT);\n-  /* Take non-speculative info, merge it with speculative and clear speculatoin.\n-     Used when we no longer manage to keep track of actual outer type, but we\n-     think it is still there. \n-     If OTR_TYPE is set, the transformation can be done more effectively assuming\n-     that context is going to be used only that way.  */\n-  void make_speculative (tree otr_type = NULL);\n+  /* Use when we can not track dynamic type change.  This speculatively assume\n+     type change is not happening.  */\n+  void possible_dynamic_type_change (tree otr_type = NULL);\n   /* Assume that both THIS and a given context is valid and strenghten THIS\n      if possible.  Return true if any strenghtening was made.\n      If actual type the context is being used in is known, OTR_TYPE should be\n@@ -1358,6 +1357,7 @@ class GTY(()) ipa_polymorphic_call_context {\n   bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n   void clear_outer_type (tree otr_type = NULL);\n   bool speculation_consistent_p (tree, HOST_WIDE_INT, bool, tree);\n+  void make_speculative (tree otr_type = NULL);\n };\n \n /* Structure containing additional information about an indirect call.  */\n@@ -2662,6 +2662,7 @@ ipa_polymorphic_call_context::clear_outer_type (tree otr_type)\n   offset = 0;\n   maybe_derived_type = true;\n   maybe_in_construction = true;\n+  dynamic = true;\n }\n \n /* Adjust all offsets in contexts by OFF bits.  */"}, {"sha": "4f0c360b8cf4551a436960838387769d96009ad3", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "patch": "@@ -167,8 +167,11 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n      type = otr_type;\n      cur_offset = 0;\n \n-     /* If derived type is not allowed, we know that the context is invalid.  */\n-     if (!maybe_derived_type)\n+     /* If derived type is not allowed, we know that the context is invalid.\n+\tFor dynamic types, we really do not have information about\n+\tsize of the memory location.  It is possible that completely\n+\tdifferent type is stored after outer_type.  */\n+     if (!maybe_derived_type && !dynamic)\n        {\n \t clear_speculation ();\n \t invalid = true;\n@@ -575,7 +578,7 @@ ipa_polymorphic_call_context::dump (FILE *f) const\n \tfprintf (f, \"nothing known\");\n       if (outer_type || offset)\n \t{\n-\t  fprintf (f, \"Outer type:\");\n+\t  fprintf (f, \"Outer type%s:\", dynamic ? \" (dynamic)\":\"\");\n \t  print_generic_expr (f, outer_type, TDF_SLIM);\n \t  if (maybe_derived_type)\n \t    fprintf (f, \" (or a derived type)\");\n@@ -618,6 +621,7 @@ ipa_polymorphic_call_context::stream_out (struct output_block *ob) const\n   bp_pack_value (&bp, maybe_in_construction, 1);\n   bp_pack_value (&bp, maybe_derived_type, 1);\n   bp_pack_value (&bp, speculative_maybe_derived_type, 1);\n+  bp_pack_value (&bp, dynamic, 1);\n   bp_pack_value (&bp, outer_type != NULL, 1);\n   bp_pack_value (&bp, offset != 0, 1);\n   bp_pack_value (&bp, speculative_outer_type != NULL, 1);\n@@ -648,6 +652,7 @@ ipa_polymorphic_call_context::stream_in (struct lto_input_block *ib,\n   maybe_in_construction = bp_unpack_value (&bp, 1);\n   maybe_derived_type = bp_unpack_value (&bp, 1);\n   speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n+  dynamic = bp_unpack_value (&bp, 1);\n   bool outer_type_p = bp_unpack_value (&bp, 1);\n   bool offset_p = bp_unpack_value (&bp, 1);\n   bool speculative_outer_type_p = bp_unpack_value (&bp, 1);\n@@ -679,17 +684,24 @@ void\n ipa_polymorphic_call_context::set_by_decl (tree base, HOST_WIDE_INT off)\n {\n   gcc_assert (DECL_P (base));\n+  clear_speculation ();\n \n+  if (!contains_polymorphic_type_p (TREE_TYPE (base)))\n+    {\n+      clear_outer_type ();\n+      offset = off;\n+      return;\n+    }\n   outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n   offset = off;\n-  clear_speculation ();\n   /* Make very conservative assumption that all objects\n      may be in construction. \n  \n      It is up to caller to revisit this via\n      get_dynamic_type or decl_maybe_in_construction_p.  */\n   maybe_in_construction = true;\n   maybe_derived_type = false;\n+  dynamic = false;\n }\n \n /* CST is an invariant (address of decl), try to get meaningful\n@@ -832,7 +844,7 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t\t      return;\n \t\t    }\n \t\t  set_by_decl (base, offset + offset2);\n-\t\t  if (maybe_in_construction && stmt)\n+\t\t  if (outer_type && maybe_in_construction && stmt)\n \t\t    maybe_in_construction\n \t\t     = decl_maybe_in_construction_p (base,\n \t\t\t\t\t\t     outer_type,\n@@ -889,6 +901,8 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t      return;\n \t    }\n \n+\t  dynamic = true;\n+\n \t  /* If the function is constructor or destructor, then\n \t     the type is possibly in construction, but we know\n \t     it is not derived type.  */\n@@ -1192,6 +1206,7 @@ record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset\n       context.outer_type = type;\n       context.maybe_in_construction = false;\n       context.maybe_derived_type = false;\n+      context.dynamic = true;\n       /* If we failed to find the inner type, we know that the call\n \t would be undefined for type produced here.  */\n       if (!context.restrict_to_inner_class (tci->otr_type))\n@@ -1540,6 +1555,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \n   if (!tci.type_maybe_changed\n       || (outer_type\n+\t  && !dynamic\n \t  && !tci.seen_unanalyzed_store\n \t  && !tci.multiple_types_encountered\n \t  && offset == tci.offset\n@@ -1563,6 +1579,7 @@ ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n \t{\n \t  outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n \t  offset = tci.known_current_offset;\n+\t  dynamic = true;\n \t  maybe_in_construction = false;\n \t  maybe_derived_type = false;\n \t  if (dump_file)\n@@ -1599,6 +1616,12 @@ ipa_polymorphic_call_context::speculation_consistent_p (tree spec_outer_type,\n {\n   if (!flag_devirtualize_speculatively)\n     return false;\n+\n+  /* Non-polymorphic types are useless for deriving likely polymorphic\n+     call targets.  */\n+  if (!spec_outer_type || !contains_polymorphic_type_p (spec_outer_type))\n+    return false;\n+\n   /* If we know nothing, speculation is always good.  */\n   if (!outer_type)\n     return true;\n@@ -1614,11 +1637,6 @@ ipa_polymorphic_call_context::speculation_consistent_p (tree spec_outer_type,\n   if (types_must_be_same_for_odr (spec_outer_type, outer_type))\n     return maybe_derived_type && !spec_maybe_derived_type;\n \n-  /* Non-polymorphic types are useless for deriving likely polymorphic\n-     call targets.  */\n-  if (!contains_polymorphic_type_p (spec_outer_type))\n-    return false;\n-\n   /* If speculation does not contain the type in question, ignore it.  */\n   if (otr_type\n       && !contains_type_p (spec_outer_type, spec_offset, otr_type, false, true))\n@@ -1792,6 +1810,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n     {\n       outer_type = ctx.outer_type;\n       offset = ctx.offset;\n+      dynamic = ctx.dynamic;\n       maybe_in_construction = ctx.maybe_in_construction;\n       maybe_derived_type = ctx.maybe_derived_type;\n       updated = true;\n@@ -1822,6 +1841,11 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t  updated = true;\n \t  maybe_derived_type = false;\n \t}\n+      if (dynamic && !ctx.dynamic)\n+\t{\n+\t  updated = true;\n+\t  dynamic = false;\n+\t}\n     }\n   /* If we know the type precisely, there is not much to improve.  */\n   else if (!maybe_derived_type && !maybe_in_construction\n@@ -1856,6 +1880,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t  outer_type = ctx.outer_type;\n \t  maybe_derived_type = ctx.maybe_derived_type;\n \t  offset = ctx.offset;\n+\t  dynamic = ctx.dynamic;\n \t  updated = true;\n \t}\n \n@@ -1906,6 +1931,7 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \t  maybe_in_construction = ctx.maybe_in_construction;\n \t  maybe_derived_type = ctx.maybe_derived_type;\n \t  offset = ctx.offset;\n+\t  dynamic = ctx.dynamic;\n           updated = true;\n \t}\n     }\n@@ -1952,7 +1978,10 @@ ipa_polymorphic_call_context::combine_with (ipa_polymorphic_call_context ctx,\n \n /* Take non-speculative info, merge it with speculative and clear speculation.\n    Used when we no longer manage to keep track of actual outer type, but we\n-   think it is still there.  */\n+   think it is still there.\n+\n+   If OTR_TYPE is set, the transformation can be done more effectively assuming\n+   that context is going to be used only that way.  */\n \n void\n ipa_polymorphic_call_context::make_speculative (tree otr_type)\n@@ -1975,3 +2004,15 @@ ipa_polymorphic_call_context::make_speculative (tree otr_type)\n \t\t\t    spec_maybe_derived_type,\n \t\t\t    otr_type);\n }\n+\n+/* Use when we can not track dynamic type change.  This speculatively assume\n+   type change is not happening.  */\n+\n+void\n+ipa_polymorphic_call_context::possible_dynamic_type_change (tree otr_type)\n+{\n+  if (dynamic)\n+    make_speculative (otr_type);\n+  else\n+    maybe_in_construction = true;\n+}"}, {"sha": "5ac5dc5200bc6220ff3b1e44c7415f5de1dd872d", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4081ada2c7ae718f509dc403f83a4a08f2a6fe4a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=4081ada2c7ae718f509dc403f83a4a08f2a6fe4a", "patch": "@@ -2652,7 +2652,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n \t      /* TODO: Make type preserved safe WRT contexts.  */\n \t      if (!dst->value.ancestor.agg_preserved)\n-\t\tctx.make_speculative ();\n+\t\tctx.possible_dynamic_type_change ();\n \t      ctx.offset_by (dst->value.ancestor.offset);\n \t      if (!ctx.useless_p ())\n \t\t{\n@@ -2722,7 +2722,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n \t\t  /* TODO: Make type preserved safe WRT contexts.  */\n \t\t  if (!dst->value.ancestor.agg_preserved)\n-\t\t    ctx.make_speculative ();\n+\t\t    ctx.possible_dynamic_type_change ();\n \t\t  if (!ctx.useless_p ())\n \t\t    {\n \t\t      if (!dst_ctx)\n@@ -3128,7 +3128,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n       /* TODO: We want to record if type change happens.  \n \t Old code did not do that that seems like a bug.  */\n-      ctx.make_speculative (ie->indirect_info->otr_type);\n+      ctx.possible_dynamic_type_change (ie->indirect_info->otr_type);\n \n       updated = ie->indirect_info->context.combine_with\n \t\t  (ctx, ie->indirect_info->otr_type);"}]}