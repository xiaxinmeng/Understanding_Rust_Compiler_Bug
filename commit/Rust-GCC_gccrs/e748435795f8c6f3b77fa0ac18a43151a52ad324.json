{"sha": "e748435795f8c6f3b77fa0ac18a43151a52ad324", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc0ODQzNTc5NWY4YzZmM2I3N2ZhMGFjMThhNDMxNTFhNTJhZDMyNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-06-14T11:29:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-06-14T11:29:44Z"}, "message": "tree-loop-distribution.c (classify_partition): Return whether a reduction appeared in all partitions and do not stop builtin...\n\n2019-06-14  Richard Biener  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (classify_partition): Return\n\twhether a reduction appeared in all partitions and do not\n\tstop builtin detection because of this.\n\t(distribute_loop): Sort a non-builtin partition last if\n\tthere's a reduction in all partitions and make sure the\n\tpartition prevailing as last is not a builtin.\n\n\t* gcc.dg/tree-ssa/ldist-26.c: Adjust.\n\nFrom-SVN: r272284", "tree": {"sha": "43a482d1b56a79b82c0422e99490701c1090d933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43a482d1b56a79b82c0422e99490701c1090d933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e748435795f8c6f3b77fa0ac18a43151a52ad324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e748435795f8c6f3b77fa0ac18a43151a52ad324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e748435795f8c6f3b77fa0ac18a43151a52ad324", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e748435795f8c6f3b77fa0ac18a43151a52ad324/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46771da57463c62f66af32e9189f1b6fb8bbe8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46771da57463c62f66af32e9189f1b6fb8bbe8c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46771da57463c62f66af32e9189f1b6fb8bbe8c7"}], "stats": {"total": 87, "additions": 69, "deletions": 18}, "files": [{"sha": "00c252e0b71aa162daceb10d66ebfa43ca29a664", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e748435795f8c6f3b77fa0ac18a43151a52ad324", "patch": "@@ -1,3 +1,12 @@\n+2019-06-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (classify_partition): Return\n+\twhether a reduction appeared in all partitions and do not\n+\tstop builtin detection because of this.\n+\t(distribute_loop): Sort a non-builtin partition last if\n+\tthere's a reduction in all partitions and make sure the\n+\tpartition prevailing as last is not a builtin.\n+\n 2019-06-14  Feng Xue  <fxue@os.amperecomputing.com>\n \n \tPR ipa/90401"}, {"sha": "3cebc56974875b148fb65098b83d61fc517e00be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e748435795f8c6f3b77fa0ac18a43151a52ad324", "patch": "@@ -1,3 +1,7 @@\n+2019-06-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ldist-26.c: Adjust.\n+\n 2019-06-14  Feng Xue  <fxue@os.amperecomputing.com>\n \n \tPR ipa/90401"}, {"sha": "98450cf8c2be874b3060c005f7568fc96958daa8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-26.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c?ref=e748435795f8c6f3b77fa0ac18a43151a52ad324", "patch": "@@ -31,6 +31,8 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"distributed: split to 2 loops and 0 library calls\" \"ldist\" } } */\n-/* { dg-final { scan-tree-dump \"distributed: split to 1 loops and 1 library calls\" \"ldist\" } } */\n-/* { dg-final { scan-tree-dump \"generated memset zero\" \"ldist\" } } */\n+/* Loop splitting splits the iteration space so we end up with two\n+   loops entering loop distribution.  Both should have the b[i] = 0\n+   part split out as memset.  */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 1 loops and 1 library calls\" 2 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated memset zero\" 2 \"ldist\" } } */"}, {"sha": "3881aaff9e5ff7864d5183c08fd716b8c8f45aeb", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e748435795f8c6f3b77fa0ac18a43151a52ad324/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=e748435795f8c6f3b77fa0ac18a43151a52ad324", "patch": "@@ -1658,9 +1658,11 @@ classify_builtin_ldst (loop_p loop, struct graph *rdg, partition *partition,\n \n /* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n    For the moment we detect memset, memcpy and memmove patterns.  Bitmap\n-   STMT_IN_ALL_PARTITIONS contains statements belonging to all partitions.  */\n+   STMT_IN_ALL_PARTITIONS contains statements belonging to all partitions.\n+   Returns true if there is a reduction in all partitions and we\n+   possibly did not mark PARTITION as having one for this reason.  */\n \n-static void\n+static bool\n classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n \t\t    bitmap stmt_in_all_partitions)\n {\n@@ -1688,25 +1690,27 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n \t     to all partitions.  In such case, reduction will be computed\n \t     correctly no matter how partitions are fused/distributed.  */\n \t  if (!bitmap_bit_p (stmt_in_all_partitions, i))\n-\t    {\n-\t      partition->reduction_p = true;\n-\t      return;\n-\t    }\n-\t  has_reduction = true;\n+\t    partition->reduction_p = true;\n+\t  else\n+\t    has_reduction = true;\n \t}\n     }\n \n+  /* Simple workaround to prevent classifying the partition as builtin\n+     if it contains any use outside of loop.  For the case where all\n+     partitions have the reduction this simple workaround is delayed\n+     to only affect the last partition.  */\n+  if (partition->reduction_p)\n+     return has_reduction;\n+\n   /* Perform general partition disqualification for builtins.  */\n   if (volatiles_p\n-      /* Simple workaround to prevent classifying the partition as builtin\n-\t if it contains any use outside of loop.  */\n-      || has_reduction\n       || !flag_tree_loop_distribute_patterns)\n-    return;\n+    return has_reduction;\n \n   /* Find single load/store data references for builtin partition.  */\n   if (!find_single_drs (loop, rdg, partition, &single_st, &single_ld))\n-    return;\n+    return has_reduction;\n \n   partition->loc = gimple_location (DR_STMT (single_st));\n \n@@ -1715,6 +1719,7 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n     classify_builtin_st (loop, partition, single_st);\n   else\n     classify_builtin_ldst (loop, rdg, partition, single_st, single_ld);\n+  return has_reduction;\n }\n \n /* Returns true when PARTITION1 and PARTITION2 access the same memory\n@@ -2782,7 +2787,6 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   ddrs_table = new hash_table<ddr_hasher> (389);\n   struct graph *rdg;\n   partition *partition;\n-  bool any_builtin;\n   int i, nbp;\n \n   *destroy_p = false;\n@@ -2842,10 +2846,12 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   for (i = 1; partitions.iterate (i, &partition); ++i)\n     bitmap_and_into (stmt_in_all_partitions, partitions[i]->stmts);\n \n-  any_builtin = false;\n+  bool any_builtin = false;\n+  bool reduction_in_all = false;\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     {\n-      classify_partition (loop, rdg, partition, stmt_in_all_partitions);\n+      reduction_in_all\n+\t|= classify_partition (loop, rdg, partition, stmt_in_all_partitions);\n       any_builtin |= partition_builtin_p (partition);\n     }\n \n@@ -2920,6 +2926,21 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \ti--;\n     }\n \n+  /* Put a non-builtin partition last if we need to preserve a reduction.\n+     ???  This is a workaround that makes sort_partitions_by_post_order do\n+     the correct thing while in reality it should sort each component\n+     separately and then put the component with a reduction or a non-builtin\n+     last.  */\n+  if (reduction_in_all\n+      && partition_builtin_p (partitions.last()))\n+    FOR_EACH_VEC_ELT (partitions, i, partition)\n+      if (!partition_builtin_p (partition))\n+\t{\n+\t  partitions.unordered_remove (i);\n+\t  partitions.quick_push (partition);\n+\t  break;\n+\t}\n+\n   /* Build the partition dependency graph and fuse partitions in strong\n      connected component.  */\n   if (partitions.length () > 1)\n@@ -2940,6 +2961,21 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \n   finalize_partitions (loop, &partitions, &alias_ddrs);\n \n+  /* If there is a reduction in all partitions make sure the last one\n+     is not classified for builtin code generation.  */\n+  if (reduction_in_all)\n+    {\n+      partition = partitions.last ();\n+      if (only_patterns_p\n+\t  && partition_builtin_p (partition)\n+\t  && !partition_builtin_p (partitions[0]))\n+\t{\n+\t  nbp = 0;\n+\t  goto ldist_done;\n+\t}\n+      partition->kind = PKIND_NORMAL;\n+    }\n+\n   nbp = partitions.length ();\n   if (nbp == 0\n       || (nbp == 1 && !partition_builtin_p (partitions[0]))"}]}