{"sha": "118ea793126f7e628d11de81cd4d100785e104e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE4ZWE3OTMxMjZmN2U2MjhkMTFkZTgxY2Q0ZDEwMDc4NWUxMDRlOA==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2005-07-23T08:36:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-07-23T08:36:54Z"}, "message": "mips-dsp.md: New file.\n\n\t* config/mips/mips-dsp.md: New file.\n\t* config/mips/mips-modes.def (V4QI, V2HI, CCDSP): New modes.\n\t* config/mips/mips.c (mips_function_type): Add types for DSP builtin\n\tfunctions.\n\t(mips_builtin_type): Add MIPS_BUILTIN_DIRECT_NO_TARGET and\n\tMIPS_BUILTIN_BPOSGE32.\n\t(mips_expand_builtin_direct): Add one parameter to indicate that\n\tbuiltin functions need to return a value.\n\t(mips_expand_builtin_bposge): New for expanding \"bposge\" builtin\n\tfunctions.\n\t(mips_regno_to_class): Add classes for 12 new DSP registers.\n\t(mips_subword): Change to check four HI registers.\n\t(mips_output_move): Output move to and from 6 new DSP accumulators.\n\t(override_options): Make sure -mdsp and -mips16 are not used together.\n\tMap 'A' to DSP_ACC_REGS and 'a' to ACC_REGS.  Enable DSP accumulators\n\tfor machine modes.\n\t(mips_conditional_register_usage): Disable 6 new DSP accumulators\n\twhen !TARGET_DSP.\n\t(print_operand): Add 'q' for printing DSP accumulators.\n\t(mips_cannot_change_mode_class): Check ACC_REGS.\n\t(mips_secondary_reload_class): Check ACC_REGS.\n\t(mips_vector_mode_supported_p): Enable V2HI and V4QI when TARGET_DSP.\n\t(mips_register_move_cost): Check ACC_REGS.\n\t(CODE_FOR_mips_addq_ph, CODE_FOR_mips_addu_qb, CODE_FOR_mips_subq_ph)\n\t(CODE_FOR_mips_subu_qb): New code-aliasing macros.\n\t(DIRECT_NO_TARGET_BUILTIN, BPOSGE_BUILTIN): New macros.\n\t(dsp_bdesc): New array.\n\t(bdesc_arrays): Add DSP builtin function table.\n\t(mips_prepare_builtin_arg): Check predicate again after\n\tcopy_to_mode_reg.\n\t(mips_expand_builtin): Add one more parameter to\n\tmips_expand_builtin_direct. Expand MIPS_BUILTIN_DIRECT_NO_TARGET and\n\tMIPS_BUILTIN_BPOSGE32.\n\t(mips_init_builtins): Initialize new function types.\n\t(mips_expand_builtin_direct): Check if builtin functions need to\n\treturn a value and pass operands properly.\n\t(mips_expand_builtin_bposge): New function.\n\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Add __mips_dsp.\n\t(ASM_SPEC): Map -mdsp to -mdsp in GAS.\n\t(FIRST_PSEUDO_REGISTER): Increase to 188.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS):\n\tUpdate for 12 new DSP registers.\n\t(DSP_ACC_REG_FIRST, DSP_ACC_REG_LAST, DSP_ACC_REG_NUM, AC1HI_REGNUM)\n\t(AC1LO_REGNUM, AC2HI_REGNUM, AC2LO_REGNUM, AC3HI_REGNUM, AC3LO_REGNUM):\n\t(DSP_ACC_REG_P, ACC_REG_P, ACC_HI_REG_P): New macros.\n\t(reg_class): Add DSP_ACC_REGS and ACC_REGS.\n\t(REG_CLASS_NAMES): Add names for DSP_ACC_REGS and ACC_REGS.\n\t(REG_CLASS_CONTENTS): Update for DSP_ACC_REGS, ACC_REGS and ALL_REGS.\n\t(REG_ALLOC_ORDER): Update for 12 new DSP registers.\n\t(mips_char_to_class): Add 'A' for DSP_ACC_REGS and 'a' for ACC_REGS.\n\t(UIMM6_OPERAND, IMM10_OPERAND): New macros.\n\t(EXTRA_CONSTRAINT_Y): Add YA and YB extra constraints.\n\t(REGISTER_NAMES): Add names for 12 new DSP registers.\n\t* config/mips/mips.md: Include mips-dsp.md.\n\t(UNSPEC_ADDQ, UNSPEC_ADDQ_S, UNSPEC_SUBQ, UNSPEC_SUBQ_S, UNSPEC_ADDSC)\n\t(UNSPEC_ADDWC, UNSPEC_MODSUB, UNSPEC_RADDU_W_QB, UNSPEC_ABSQ_S)\n\t(UNSPEC_PRECRQ_QB_PH, UNSPEC_PRECRQ_PH_W, UNSPEC_PRECRQ_RS_PH_W)\n\t(UNSPEC_PRECRQU_S_QB_PH, UNSPEC_PRECEQ_W_PHL, UNSPEC_PRECEQ_W_PHR)\n\t(UNSPEC_PRECEQU_PH_QBL, UNSPEC_PRECEQU_PH_QBR, UNSPEC_PRECEQU_PH_QBLA)\n\t(UNSPEC_PRECEQU_PH_QBRA, UNSPEC_PRECEU_PH_QBL, UNSPEC_PRECEU_PH_QBR)\n\t(UNSPEC_PRECEU_PH_QBLA, UNSPEC_PRECEU_PH_QBRA, UNSPEC_SHLL)\n\t(UNSPEC_SHLL_S, UNSPEC_SHRL_QB, UNSPEC_SHRA_PH, UNSPEC_SHRA_R)\n\t(UNSPEC_MULEU_S_PH_QBL, UNSPEC_MULEU_S_PH_QBR, UNSPEC_MULQ_RS_PH)\n\t(UNSPEC_MULEQ_S_W_PHL, UNSPEC_MULEQ_S_W_PHR, UNSPEC_DPAU_H_QBL)\n\t(UNSPEC_DPAU_H_QBR, UNSPEC_DPSU_H_QBL, UNSPEC_DPSU_H_QBR)\n\t(UNSPEC_DPAQ_S_W_PH, UNSPEC_DPSQ_S_W_PH, UNSPEC_MULSAQ_S_W_PH)\n\t(UNSPEC_DPAQ_SA_L_W, UNSPEC_DPSQ_SA_L_W, UNSPEC_MAQ_S_W_PHL)\n\t(UNSPEC_MAQ_S_W_PHR, UNSPEC_MAQ_SA_W_PHL, UNSPEC_MAQ_SA_W_PHR)\n\t(UNSPEC_BITREV, UNSPEC_INSV, UNSPEC_REPL_QB, UNSPEC_REPL_PH)\n\t(UNSPEC_CMP_EQ, UNSPEC_CMP_LT, UNSPEC_CMP_LE, UNSPEC_CMPGU_EQ_QB)\n\t(UNSPEC_CMPGU_LT_QB, UNSPEC_CMPGU_LE_QB, UNSPEC_PICK, UNSPEC_PACKRL_PH)\n\t(UNSPEC_EXTR_W, UNSPEC_EXTR_R_W, UNSPEC_EXTR_RS_W, UNSPEC_EXTR_S_H)\n\t(UNSPEC_EXTP, UNSPEC_EXTPDP, UNSPEC_SHILO, UNSPEC_MTHLIP, UNSPEC_WRDSP)\n\t(UNSPEC_RDDSP): New constants.\n\t(*movdi_32bit): Change 'x' to 'a' for ACC_REGS.\n\t(*movsi_internal): Change 'x' to 'a' for ACC_REGS.  Add an\n\tA<-d alternative.\n\t* config/mips/mips.opt (-mdsp): New option.\n\t* config/mips/predicates.md (const_uimm6_operand, const_imm10_operand)\n\t(reg_imm10_operand): New predicates.\n\t* doc/extend.texi (MIPS DSP Built-in Functions): New section.\n\t* doc/invoke.texi (-mdsp): Document new option.\n\nFrom-SVN: r102307", "tree": {"sha": "de53c7e62cba65c95a59ce4c1dcd2c4ffdcc6ffb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de53c7e62cba65c95a59ce4c1dcd2c4ffdcc6ffb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/118ea793126f7e628d11de81cd4d100785e104e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118ea793126f7e628d11de81cd4d100785e104e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/118ea793126f7e628d11de81cd4d100785e104e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/118ea793126f7e628d11de81cd4d100785e104e8/comments", "author": null, "committer": null, "parents": [{"sha": "5887a1bb9c70faa8f917ea8f41600c61f462cfb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5887a1bb9c70faa8f917ea8f41600c61f462cfb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5887a1bb9c70faa8f917ea8f41600c61f462cfb8"}], "stats": {"total": 3254, "additions": 3158, "deletions": 96}, "files": [{"sha": "73d386b25038ef527f6d2f518d1262111e9fac6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -1,3 +1,88 @@\n+2005-07-23  Chao-ying Fu  <fu@mips.com>\n+\n+\t* config/mips/mips-dsp.md: New file.\n+\t* config/mips/mips-modes.def (V4QI, V2HI, CCDSP): New modes.\n+\t* config/mips/mips.c (mips_function_type): Add types for DSP builtin\n+\tfunctions.\n+\t(mips_builtin_type): Add MIPS_BUILTIN_DIRECT_NO_TARGET and\n+\tMIPS_BUILTIN_BPOSGE32.\n+\t(mips_expand_builtin_direct): Add one parameter to indicate that\n+\tbuiltin functions need to return a value.\n+\t(mips_expand_builtin_bposge): New for expanding \"bposge\" builtin\n+\tfunctions.\n+\t(mips_regno_to_class): Add classes for 12 new DSP registers.\n+\t(mips_subword): Change to check four HI registers.\n+\t(mips_output_move): Output move to and from 6 new DSP accumulators.\n+\t(override_options): Make sure -mdsp and -mips16 are not used together.\n+\tMap 'A' to DSP_ACC_REGS and 'a' to ACC_REGS.  Enable DSP accumulators\n+\tfor machine modes.\n+\t(mips_conditional_register_usage): Disable 6 new DSP accumulators\n+\twhen !TARGET_DSP.\n+\t(print_operand): Add 'q' for printing DSP accumulators.\n+\t(mips_cannot_change_mode_class): Check ACC_REGS.\n+\t(mips_secondary_reload_class): Check ACC_REGS.\n+\t(mips_vector_mode_supported_p): Enable V2HI and V4QI when TARGET_DSP.\n+\t(mips_register_move_cost): Check ACC_REGS.\n+\t(CODE_FOR_mips_addq_ph, CODE_FOR_mips_addu_qb, CODE_FOR_mips_subq_ph)\n+\t(CODE_FOR_mips_subu_qb): New code-aliasing macros.\n+\t(DIRECT_NO_TARGET_BUILTIN, BPOSGE_BUILTIN): New macros.\n+\t(dsp_bdesc): New array.\n+\t(bdesc_arrays): Add DSP builtin function table.\n+\t(mips_prepare_builtin_arg): Check predicate again after\n+\tcopy_to_mode_reg.\n+\t(mips_expand_builtin): Add one more parameter to\n+\tmips_expand_builtin_direct. Expand MIPS_BUILTIN_DIRECT_NO_TARGET and\n+\tMIPS_BUILTIN_BPOSGE32.\n+\t(mips_init_builtins): Initialize new function types.\n+\t(mips_expand_builtin_direct): Check if builtin functions need to\n+\treturn a value and pass operands properly.\n+\t(mips_expand_builtin_bposge): New function.\n+\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Add __mips_dsp.\n+\t(ASM_SPEC): Map -mdsp to -mdsp in GAS.\n+\t(FIRST_PSEUDO_REGISTER): Increase to 188.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS, CALL_REALLY_USED_REGISTERS):\n+\tUpdate for 12 new DSP registers.\n+\t(DSP_ACC_REG_FIRST, DSP_ACC_REG_LAST, DSP_ACC_REG_NUM, AC1HI_REGNUM)\n+\t(AC1LO_REGNUM, AC2HI_REGNUM, AC2LO_REGNUM, AC3HI_REGNUM, AC3LO_REGNUM):\n+\t(DSP_ACC_REG_P, ACC_REG_P, ACC_HI_REG_P): New macros.\n+\t(reg_class): Add DSP_ACC_REGS and ACC_REGS.\n+\t(REG_CLASS_NAMES): Add names for DSP_ACC_REGS and ACC_REGS.\n+\t(REG_CLASS_CONTENTS): Update for DSP_ACC_REGS, ACC_REGS and ALL_REGS.\n+\t(REG_ALLOC_ORDER): Update for 12 new DSP registers.\n+\t(mips_char_to_class): Add 'A' for DSP_ACC_REGS and 'a' for ACC_REGS.\n+\t(UIMM6_OPERAND, IMM10_OPERAND): New macros.\n+\t(EXTRA_CONSTRAINT_Y): Add YA and YB extra constraints.\n+\t(REGISTER_NAMES): Add names for 12 new DSP registers.\n+\t* config/mips/mips.md: Include mips-dsp.md.\n+\t(UNSPEC_ADDQ, UNSPEC_ADDQ_S, UNSPEC_SUBQ, UNSPEC_SUBQ_S, UNSPEC_ADDSC)\n+\t(UNSPEC_ADDWC, UNSPEC_MODSUB, UNSPEC_RADDU_W_QB, UNSPEC_ABSQ_S)\n+\t(UNSPEC_PRECRQ_QB_PH, UNSPEC_PRECRQ_PH_W, UNSPEC_PRECRQ_RS_PH_W)\n+\t(UNSPEC_PRECRQU_S_QB_PH, UNSPEC_PRECEQ_W_PHL, UNSPEC_PRECEQ_W_PHR)\n+\t(UNSPEC_PRECEQU_PH_QBL, UNSPEC_PRECEQU_PH_QBR, UNSPEC_PRECEQU_PH_QBLA)\n+\t(UNSPEC_PRECEQU_PH_QBRA, UNSPEC_PRECEU_PH_QBL, UNSPEC_PRECEU_PH_QBR)\n+\t(UNSPEC_PRECEU_PH_QBLA, UNSPEC_PRECEU_PH_QBRA, UNSPEC_SHLL)\n+\t(UNSPEC_SHLL_S, UNSPEC_SHRL_QB, UNSPEC_SHRA_PH, UNSPEC_SHRA_R)\n+\t(UNSPEC_MULEU_S_PH_QBL, UNSPEC_MULEU_S_PH_QBR, UNSPEC_MULQ_RS_PH)\n+\t(UNSPEC_MULEQ_S_W_PHL, UNSPEC_MULEQ_S_W_PHR, UNSPEC_DPAU_H_QBL)\n+\t(UNSPEC_DPAU_H_QBR, UNSPEC_DPSU_H_QBL, UNSPEC_DPSU_H_QBR)\n+\t(UNSPEC_DPAQ_S_W_PH, UNSPEC_DPSQ_S_W_PH, UNSPEC_MULSAQ_S_W_PH)\n+\t(UNSPEC_DPAQ_SA_L_W, UNSPEC_DPSQ_SA_L_W, UNSPEC_MAQ_S_W_PHL)\n+\t(UNSPEC_MAQ_S_W_PHR, UNSPEC_MAQ_SA_W_PHL, UNSPEC_MAQ_SA_W_PHR)\n+\t(UNSPEC_BITREV, UNSPEC_INSV, UNSPEC_REPL_QB, UNSPEC_REPL_PH)\n+\t(UNSPEC_CMP_EQ, UNSPEC_CMP_LT, UNSPEC_CMP_LE, UNSPEC_CMPGU_EQ_QB)\n+\t(UNSPEC_CMPGU_LT_QB, UNSPEC_CMPGU_LE_QB, UNSPEC_PICK, UNSPEC_PACKRL_PH)\n+\t(UNSPEC_EXTR_W, UNSPEC_EXTR_R_W, UNSPEC_EXTR_RS_W, UNSPEC_EXTR_S_H)\n+\t(UNSPEC_EXTP, UNSPEC_EXTPDP, UNSPEC_SHILO, UNSPEC_MTHLIP, UNSPEC_WRDSP)\n+\t(UNSPEC_RDDSP): New constants.\n+\t(*movdi_32bit): Change 'x' to 'a' for ACC_REGS.\n+\t(*movsi_internal): Change 'x' to 'a' for ACC_REGS.  Add an\n+\tA<-d alternative.\n+\t* config/mips/mips.opt (-mdsp): New option.\n+\t* config/mips/predicates.md (const_uimm6_operand, const_imm10_operand)\n+\t(reg_imm10_operand): New predicates.\n+\t* doc/extend.texi (MIPS DSP Built-in Functions): New section.\n+\t* doc/invoke.texi (-mdsp): Document new option.\n+\n 2005-07-22  DJ Delorie  <dj@redhat.com>\n \n \t* c-objc-common.c (c_cannot_inline_tree_fn): Add warning control"}, {"sha": "a61b23f0acddec2a0c2a351ecceb709281bc2611", "filename": "gcc/config/mips/mips-dsp.md", "status": "added", "additions": 1058, "deletions": 0, "changes": 1058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips-dsp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-dsp.md?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -0,0 +1,1058 @@\n+(define_constants\n+  [(CCDSP_PO_REGNUM\t182)\n+   (CCDSP_SC_REGNUM\t183)\n+   (CCDSP_CA_REGNUM\t184)\n+   (CCDSP_OU_REGNUM\t185)\n+   (CCDSP_CC_REGNUM\t186)\n+   (CCDSP_EF_REGNUM\t187)])\n+\n+;; This mode macro allows si, v2hi, v4qi for all possible modes in DSP ASE.\n+(define_mode_macro DSP [(SI \"TARGET_DSP\")\n+\t\t\t(V2HI \"TARGET_DSP\")\n+\t\t \t(V4QI \"TARGET_DSP\")])\n+\n+;; This mode macro allows v2hi, v4qi for vector/SIMD data.\n+(define_mode_macro DSPV [(V2HI \"TARGET_DSP\")\n+\t\t\t (V4QI \"TARGET_DSP\")])\n+\n+;; This mode macro allows si, v2hi for Q31 and V2Q15 fixed-point data.\n+(define_mode_macro DSPQ [(SI \"TARGET_DSP\")\n+\t\t         (V2HI \"TARGET_DSP\")])\n+\n+;; DSP instructions use q for fixed-point data, and u for integer in the infix.\n+(define_mode_attr dspfmt1 [(SI \"q\") (V2HI \"q\") (V4QI \"u\")])\n+\n+;; DSP instructions use nothing for fixed-point data, and u for integer in\n+;; the infix.\n+(define_mode_attr dspfmt1_1 [(SI \"\") (V2HI \"\") (V4QI \"u\")])\n+\n+;; DSP instructions use w, ph, qb in the postfix.\n+(define_mode_attr dspfmt2 [(SI \"w\") (V2HI \"ph\") (V4QI \"qb\")])\n+\n+;; DSP shift masks for SI, V2HI, V4QI.\n+(define_mode_attr dspshift_mask [(SI \"0x1f\") (V2HI \"0xf\") (V4QI \"0x7\")])\n+\n+;; MIPS DSP ASE Revision 0.98 3/24/2005\n+;; Table 2-1. MIPS DSP ASE Instructions: Arithmetic\n+;; ADDQ*\n+(define_insn \"add<DSPV:mode>3\"\n+  [(parallel\n+    [(set (match_operand:DSPV 0 \"register_operand\" \"=d\")\n+\t  (plus:DSPV (match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t     (match_operand:DSPV 2 \"register_operand\" \"d\")))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ))])]\n+  \"\"\n+  \"add<DSPV:dspfmt1>.<DSPV:dspfmt2>\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_add<DSP:dspfmt1>_s_<DSP:dspfmt2>\"\n+  [(parallel\n+    [(set (match_operand:DSP 0 \"register_operand\" \"=d\")\n+\t  (unspec:DSP [(match_operand:DSP 1 \"register_operand\" \"d\")\n+\t\t       (match_operand:DSP 2 \"register_operand\" \"d\")]\n+\t\t      UNSPEC_ADDQ_S))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDQ_S))])]\n+  \"\"\n+  \"add<DSP:dspfmt1>_s.<DSP:dspfmt2>\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; SUBQ*\n+(define_insn \"sub<DSPV:mode>3\"\n+  [(parallel\n+    [(set (match_operand:DSPV 0 \"register_operand\" \"=d\")\n+\t  (minus:DSPV (match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:DSPV 2 \"register_operand\" \"d\")))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ))])]\n+  \"TARGET_DSP\"\n+  \"sub<DSPV:dspfmt1>.<DSPV:dspfmt2>\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_sub<DSP:dspfmt1>_s_<DSP:dspfmt2>\"\n+  [(parallel\n+    [(set (match_operand:DSP 0 \"register_operand\" \"=d\")\n+\t  (unspec:DSP [(match_operand:DSP 1 \"register_operand\" \"d\")\n+\t\t       (match_operand:DSP 2 \"register_operand\" \"d\")]\n+\t\t      UNSPEC_SUBQ_S))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SUBQ_S))])]\n+  \"TARGET_DSP\"\n+  \"sub<DSP:dspfmt1>_s.<DSP:dspfmt2>\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; ADDSC\n+(define_insn \"mips_addsc\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t  (unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_ADDSC))\n+     (set (reg:CCDSP CCDSP_CA_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDSC))])]\n+  \"TARGET_DSP\"\n+  \"addsc\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; ADDWC\n+(define_insn \"mips_addwc\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t  (unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t    (reg:CCDSP CCDSP_CA_REGNUM)]\n+\t\t     UNSPEC_ADDWC))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_ADDWC))])]\n+  \"TARGET_DSP\"\n+  \"addwc\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MODSUB\n+(define_insn \"mips_modsub\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_MODSUB))]\n+  \"TARGET_DSP\"\n+  \"modsub\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; RADDU*\n+(define_insn \"mips_raddu_w_qb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_RADDU_W_QB))]\n+  \"TARGET_DSP\"\n+  \"raddu.w.qb\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; ABSQ*\n+(define_insn \"mips_absq_s_<DSPQ:dspfmt2>\"\n+  [(parallel\n+    [(set (match_operand:DSPQ 0 \"register_operand\" \"=d\")\n+\t  (unspec:DSPQ [(match_operand:DSPQ 1 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_ABSQ_S))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1)] UNSPEC_ABSQ_S))])]\n+  \"TARGET_DSP\"\n+  \"absq_s.<DSPQ:dspfmt2>\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PRECRQ*\n+(define_insn \"mips_precrq_qb_ph\"\n+  [(set (match_operand:V4QI 0 \"register_operand\" \"=d\")\n+\t(unspec:V4QI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECRQ_QB_PH))]\n+  \"TARGET_DSP\"\n+  \"precrq.qb.ph\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_precrq_ph_w\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECRQ_PH_W))]\n+  \"TARGET_DSP\"\n+  \"precrq.ph.w\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_precrq_rs_ph_w\"\n+  [(parallel\n+    [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t  (unspec:V2HI [(match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:SI 2 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_PRECRQ_RS_PH_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)]\n+\t\t\tUNSPEC_PRECRQ_RS_PH_W))])]\n+  \"TARGET_DSP\"\n+  \"precrq_rs.ph.w\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PRECRQU*\n+(define_insn \"mips_precrqu_s_qb_ph\"\n+  [(parallel\n+    [(set (match_operand:V4QI 0 \"register_operand\" \"=d\")\n+\t  (unspec:V4QI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_PRECRQU_S_QB_PH))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)]\n+\t\t\tUNSPEC_PRECRQU_S_QB_PH))])]\n+  \"TARGET_DSP\"\n+  \"precrqu_s.qb.ph\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PRECEQ*\n+(define_insn \"mips_preceq_w_phl\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_PRECEQ_W_PHL))]\n+  \"TARGET_DSP\"\n+  \"preceq.w.phl\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_preceq_w_phr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_PRECEQ_W_PHR))]\n+  \"TARGET_DSP\"\n+  \"preceq.w.phr\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PRECEQU*\n+(define_insn \"mips_precequ_ph_qbl\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEQU_PH_QBL))]\n+  \"TARGET_DSP\"\n+  \"precequ.ph.qbl\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_precequ_ph_qbr\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEQU_PH_QBR))]\n+  \"TARGET_DSP\"\n+  \"precequ.ph.qbr\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_precequ_ph_qbla\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEQU_PH_QBLA))]\n+  \"TARGET_DSP\"\n+  \"precequ.ph.qbla\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_precequ_ph_qbra\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEQU_PH_QBRA))]\n+  \"TARGET_DSP\"\n+  \"precequ.ph.qbra\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PRECEU*\n+(define_insn \"mips_preceu_ph_qbl\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEU_PH_QBL))]\n+  \"TARGET_DSP\"\n+  \"preceu.ph.qbl\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_preceu_ph_qbr\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEU_PH_QBR))]\n+  \"TARGET_DSP\"\n+  \"preceu.ph.qbr\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_preceu_ph_qbla\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEU_PH_QBLA))]\n+  \"TARGET_DSP\"\n+  \"preceu.ph.qbla\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_preceu_ph_qbra\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PRECEU_PH_QBRA))]\n+  \"TARGET_DSP\"\n+  \"preceu.ph.qbra\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-2. MIPS DSP ASE Instructions: Shift\n+;; SHLL*\n+(define_insn \"mips_shll_<DSPV:dspfmt2>\"\n+  [(parallel\n+    [(set (match_operand:DSPV 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:DSPV [(match_operand:DSPV 1 \"register_operand\" \"d,d\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t       UNSPEC_SHLL))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SHLL))])]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2])\n+\t  & ~(unsigned HOST_WIDE_INT) <DSPV:dspshift_mask>)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & <DSPV:dspshift_mask>);\n+      return \"shll.<DSPV:dspfmt2>\\t%0,%1,%2\";\n+    }\n+  return \"shllv.<DSPV:dspfmt2>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\"\t\"shift\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_shll_s_<DSPQ:dspfmt2>\"\n+  [(parallel\n+    [(set (match_operand:DSPQ 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:DSPQ [(match_operand:DSPQ 1 \"register_operand\" \"d,d\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t       UNSPEC_SHLL_S))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_SHLL_S))])]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2])\n+          & ~(unsigned HOST_WIDE_INT) <DSPQ:dspshift_mask>)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & <DSPQ:dspshift_mask>);\n+      return \"shll_s.<DSPQ:dspfmt2>\\t%0,%1,%2\";\n+    }\n+  return \"shllv_s.<DSPQ:dspfmt2>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\"\t\"shift\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; SHRL*\n+(define_insn \"mips_shrl_qb\"\n+  [(set (match_operand:V4QI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:V4QI [(match_operand:V4QI 1 \"register_operand\" \"d,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_SHRL_QB))]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x7)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x7);\n+      return \"shrl.qb\\t%0,%1,%2\";\n+    }\n+  return \"shrlv.qb\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\"\t\"shift\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; SHRA*\n+(define_insn \"mips_shra_ph\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:V2HI [(match_operand:V2HI 1 \"register_operand\" \"d,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_SHRA_PH))]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0xf)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0xf);\n+      return \"shra.ph\\t%0,%1,%2\";\n+    }\n+  return \"shrav.ph\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\"\t\"shift\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_shra_r_<DSPQ:dspfmt2>\"\n+  [(set (match_operand:DSPQ 0 \"register_operand\" \"=d,d\")\n+\t(unspec:DSPQ [(match_operand:DSPQ 1 \"register_operand\" \"d,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_SHRA_R))]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2])\n+\t  & ~(unsigned HOST_WIDE_INT) <DSPQ:dspshift_mask>)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & <DSPQ:dspshift_mask>);\n+      return \"shra_r.<DSPQ:dspfmt2>\\t%0,%1,%2\";\n+    }\n+  return \"shrav_r.<DSPQ:dspfmt2>\\t%0,%1,%2\";\n+}\n+  [(set_attr \"type\"\t\"shift\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-3. MIPS DSP ASE Instructions: Multiply\n+;; MULEU*\n+(define_insn \"mips_muleu_s_ph_qbl\"\n+  [(parallel\n+    [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t  (unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_MULEU_S_PH_QBL))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_MULEU_S_PH_QBL))\n+     (clobber (match_scratch:DI 3 \"=x\"))])]\n+  \"TARGET_DSP\"\n+  \"muleu_s.ph.qbl\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul3\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_muleu_s_ph_qbr\"\n+  [(parallel\n+    [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t  (unspec:V2HI [(match_operand:V4QI 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_MULEU_S_PH_QBR))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_MULEU_S_PH_QBR))\n+     (clobber (match_scratch:DI 3 \"=x\"))])]\n+  \"TARGET_DSP\"\n+  \"muleu_s.ph.qbr\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul3\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MULQ*\n+(define_insn \"mips_mulq_rs_ph\"\n+  [(parallel\n+    [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t  (unspec:V2HI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t\t(match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t       UNSPEC_MULQ_RS_PH))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_MULQ_RS_PH))\n+     (clobber (match_scratch:DI 3 \"=x\"))])]\n+  \"TARGET_DSP\"\n+  \"mulq_rs.ph\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul3\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MULEQ*\n+(define_insn \"mips_muleq_s_w_phl\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t  (unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MULEQ_S_W_PHL))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_MULEQ_S_W_PHL))\n+     (clobber (match_scratch:DI 3 \"=x\"))])]\n+  \"TARGET_DSP\"\n+  \"muleq_s.w.phl\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul3\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_muleq_s_w_phr\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t  (unspec:SI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MULEQ_S_W_PHR))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_MULEQ_S_W_PHR))\n+     (clobber (match_scratch:DI 3 \"=x\"))])]\n+  \"TARGET_DSP\"\n+  \"muleq_s.w.phr\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"imul3\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPAU*\n+(define_insn \"mips_dpau_h_qbl\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 3 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_DPAU_H_QBL))]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpau.h.qbl\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_dpau_h_qbr\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 3 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_DPAU_H_QBR))]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpau.h.qbr\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPSU*\n+(define_insn \"mips_dpsu_h_qbl\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 3 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_DPSU_H_QBL))]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpsu.h.qbl\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_dpsu_h_qbr\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 3 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_DPSU_H_QBR))]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpsu.h.qbr\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPAQ*\n+(define_insn \"mips_dpaq_s_w_ph\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_DPAQ_S_W_PH))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_DPAQ_S_W_PH))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpaq_s.w.ph\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPSQ*\n+(define_insn \"mips_dpsq_s_w_ph\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_DPSQ_S_W_PH))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_DPSQ_S_W_PH))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpsq_s.w.ph\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MULSAQ*\n+(define_insn \"mips_mulsaq_s_w_ph\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MULSAQ_S_W_PH))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_MULSAQ_S_W_PH))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"mulsaq_s.w.ph\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPAQ*\n+(define_insn \"mips_dpaq_sa_l_w\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_DPAQ_SA_L_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_DPAQ_SA_L_W))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpaq_sa.l.w\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; DPSQ*\n+(define_insn \"mips_dpsq_sa_l_w\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_DPSQ_SA_L_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_DPSQ_SA_L_W))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"dpsq_sa.l.w\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MAQ*\n+(define_insn \"mips_maq_s_w_phl\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MAQ_S_W_PHL))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_MAQ_S_W_PHL))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"maq_s.w.phl\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_maq_s_w_phr\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MAQ_S_W_PHR))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_MAQ_S_W_PHR))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"maq_s.w.phr\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MAQ_SA*\n+(define_insn \"mips_maq_sa_w_phl\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MAQ_SA_W_PHL))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_MAQ_SA_W_PHL))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"maq_sa.w.phl\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_maq_sa_w_phr\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 3 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_MAQ_SA_W_PHR))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2) (match_dup 3)]\n+\t\t\tUNSPEC_MAQ_SA_W_PHR))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"maq_sa.w.phr\\t%q0,%2,%3\"\n+  [(set_attr \"type\"\t\"imadd\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-4. MIPS DSP ASE Instructions: General Bit/Manipulation\n+;; BITREV\n+(define_insn \"mips_bitrev\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_BITREV))]\n+  \"TARGET_DSP\"\n+  \"bitrev\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; INSV\n+(define_insn \"mips_insv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t    (reg:CCDSP CCDSP_SC_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_PO_REGNUM)]\n+\t\t   UNSPEC_INSV))]\n+  \"TARGET_DSP\"\n+  \"insv\\t%0,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; REPL*\n+(define_insn \"mips_repl_qb\"\n+  [(set (match_operand:V4QI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:V4QI [(match_operand:SI 1 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_REPL_QB))]\n+  \"TARGET_DSP\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[1]) & ~(unsigned HOST_WIDE_INT) 0xff)\n+\toperands[1] = GEN_INT (INTVAL (operands[1]) & 0xff);\n+      return \"repl.qb\\t%0,%1\";\n+    }\n+  return \"replv.qb\\t%0,%1\";\n+}\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_repl_ph\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d,d\")\n+\t(unspec:V2HI [(match_operand:SI 1 \"reg_imm10_operand\" \"YB,d\")]\n+\t\t     UNSPEC_REPL_PH))]\n+  \"TARGET_DSP\"\n+  \"@\n+   repl.ph\\t%0,%1\n+   replv.ph\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-5. MIPS DSP ASE Instructions: Compare-Pick\n+;; CMPU.* CMP.*\n+(define_insn \"mips_cmp<DSPV:dspfmt1_1>_eq_<DSPV:dspfmt2>\"\n+  [(set (reg:CCDSP CCDSP_CC_REGNUM)\n+\t(unspec:CCDSP [(match_operand:DSPV 0 \"register_operand\" \"d\")\n+\t\t       (match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t       (reg:CCDSP CCDSP_CC_REGNUM)]\n+\t\t      UNSPEC_CMP_EQ))]\n+  \"TARGET_DSP\"\n+  \"cmp<DSPV:dspfmt1_1>.eq.<DSPV:dspfmt2>\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_cmp<DSPV:dspfmt1_1>_lt_<DSPV:dspfmt2>\"\n+  [(set (reg:CCDSP CCDSP_CC_REGNUM)\n+\t(unspec:CCDSP [(match_operand:DSPV 0 \"register_operand\" \"d\")\n+\t\t       (match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t       (reg:CCDSP CCDSP_CC_REGNUM)]\n+\t\t      UNSPEC_CMP_LT))]\n+  \"TARGET_DSP\"\n+  \"cmp<DSPV:dspfmt1_1>.lt.<DSPV:dspfmt2>\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_cmp<DSPV:dspfmt1_1>_le_<DSPV:dspfmt2>\"\n+  [(set (reg:CCDSP CCDSP_CC_REGNUM)\n+\t(unspec:CCDSP [(match_operand:DSPV 0 \"register_operand\" \"d\")\n+\t\t       (match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t       (reg:CCDSP CCDSP_CC_REGNUM)]\n+\t\t      UNSPEC_CMP_LE))]\n+  \"TARGET_DSP\"\n+  \"cmp<DSPV:dspfmt1_1>.le.<DSPV:dspfmt2>\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_cmpgu_eq_qb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V4QI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_CMPGU_EQ_QB))]\n+  \"TARGET_DSP\"\n+  \"cmpgu.eq.qb\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_cmpgu_lt_qb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V4QI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_CMPGU_LT_QB))]\n+  \"TARGET_DSP\"\n+  \"cmpgu.lt.qb\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_cmpgu_le_qb\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:V4QI 1 \"register_operand\" \"d\")\n+\t\t    (match_operand:V4QI 2 \"register_operand\" \"d\")]\n+\t\t   UNSPEC_CMPGU_LE_QB))]\n+  \"TARGET_DSP\"\n+  \"cmpgu.le.qb\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PICK*\n+(define_insn \"mips_pick_<DSPV:dspfmt2>\"\n+  [(set (match_operand:DSPV 0 \"register_operand\" \"=d\")\n+\t(unspec:DSPV [(match_operand:DSPV 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:DSPV 2 \"register_operand\" \"d\")\n+\t\t      (reg:CCDSP CCDSP_CC_REGNUM)]\n+\t\t     UNSPEC_PICK))]\n+  \"TARGET_DSP\"\n+  \"pick.<DSPV:dspfmt2>\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; PACKRL*\n+(define_insn \"mips_packrl_ph\"\n+  [(set (match_operand:V2HI 0 \"register_operand\" \"=d\")\n+\t(unspec:V2HI [(match_operand:V2HI 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:V2HI 2 \"register_operand\" \"d\")]\n+\t\t     UNSPEC_PACKRL_PH))]\n+  \"TARGET_DSP\"\n+  \"packrl.ph\\t%0,%1,%2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-6. MIPS DSP ASE Instructions: Accumulator and DSPControl Access\n+;; EXTR*\n+(define_insn \"mips_extr_w\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_EXTR_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTR_W))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extr.w\\t%0,%q1,%2\";\n+    }\n+  return \"extrv.w\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_extr_r_w\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_EXTR_R_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTR_R_W))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extr_r.w\\t%0,%q1,%2\";\n+    }\n+  return \"extrv_r.w\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_extr_rs_w\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_EXTR_RS_W))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTR_RS_W))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extr_rs.w\\t%0,%q1,%2\";\n+    }\n+  return \"extrv_rs.w\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; EXTR*_S.H\n+(define_insn \"mips_extr_s_h\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t     UNSPEC_EXTR_S_H))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTR_S_H))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extr_s.h\\t%0,%q1,%2\";\n+    }\n+  return \"extrv_s.h\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; EXTP*\n+(define_insn \"mips_extp\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")\n+\t\t      (reg:CCDSP CCDSP_PO_REGNUM)]\n+\t\t     UNSPEC_EXTP))\n+     (set (reg:CCDSP CCDSP_EF_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTP))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extp\\t%0,%q1,%2\";\n+    }\n+  return \"extpv\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+(define_insn \"mips_extpdp\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t  (unspec:SI [(match_operand:DI 1 \"register_operand\" \"a,a\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"I,d\")\n+\t\t      (reg:CCDSP CCDSP_PO_REGNUM)]\n+\t\t     UNSPEC_EXTPDP))\n+     (set (reg:CCDSP CCDSP_PO_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)\n+\t\t\t (reg:CCDSP CCDSP_PO_REGNUM)] UNSPEC_EXTPDP))\n+     (set (reg:CCDSP CCDSP_EF_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)] UNSPEC_EXTPDP))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) & ~(unsigned HOST_WIDE_INT) 0x1f)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+      return \"extpdp\\t%0,%q1,%2\";\n+    }\n+  return \"extpdpv\\t%0,%q1,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; SHILO*\n+(define_insn \"mips_shilo\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a,a\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"0,0\")\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"I,d\")]\n+\t\t   UNSPEC_SHILO))]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+{\n+  if (which_alternative == 0)\n+    {\n+      if (INTVAL (operands[2]) < -32 || INTVAL (operands[2]) > 31)\n+\toperands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n+      return \"shilo\\t%q0,%2\";\n+    }\n+  return \"shilov\\t%q0,%2\";\n+}\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; MTHLIP*\n+(define_insn \"mips_mthlip\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t  (unspec:DI [(match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"d\")\n+\t\t      (reg:CCDSP CCDSP_PO_REGNUM)]\n+\t\t     UNSPEC_MTHLIP))\n+     (set (reg:CCDSP CCDSP_PO_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 1) (match_dup 2)\n+\t\t\t (reg:CCDSP CCDSP_PO_REGNUM)] UNSPEC_MTHLIP))])]\n+  \"TARGET_DSP && !TARGET_64BIT\"\n+  \"mthlip\\t%2,%q0\"\n+  [(set_attr \"type\"\t\"mfhilo\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; WRDSP\n+(define_insn \"mips_wrdsp\"\n+  [(parallel\n+    [(set (reg:CCDSP CCDSP_PO_REGNUM)\n+\t  (unspec:CCDSP [(match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"const_uimm6_operand\" \"YA\")]\n+\t\t\t UNSPEC_WRDSP))\n+     (set (reg:CCDSP CCDSP_SC_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))\n+     (set (reg:CCDSP CCDSP_CA_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))\n+     (set (reg:CCDSP CCDSP_OU_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))\n+     (set (reg:CCDSP CCDSP_CC_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))\n+     (set (reg:CCDSP CCDSP_EF_REGNUM)\n+\t  (unspec:CCDSP [(match_dup 0) (match_dup 1)] UNSPEC_WRDSP))])]\n+  \"TARGET_DSP\"\n+  \"wrdsp\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; RDDSP\n+(define_insn \"mips_rddsp\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(match_operand:SI 1 \"const_uimm6_operand\" \"YA\")\n+\t\t    (reg:CCDSP CCDSP_PO_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_SC_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_CA_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_OU_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_CC_REGNUM)\n+\t\t    (reg:CCDSP CCDSP_EF_REGNUM)]\n+\t\t   UNSPEC_RDDSP))]\n+  \"TARGET_DSP\"\n+  \"rddsp\\t%0,%1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")])\n+\n+;; Table 2-7. MIPS DSP ASE Instructions: Indexed-Load\n+;; L*X\n+(define_insn \"mips_lbux\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(zero_extend:SI (mem:QI (plus:SI (match_operand:SI 1\n+\t\t\t\t\t  \"register_operand\" \"d\")\n+\t\t\t\t\t (match_operand:SI 2\n+\t\t\t\t\t  \"register_operand\" \"d\")))))]\n+  \"TARGET_DSP\"\n+  \"lbux\\t%0,%2(%1)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"mips_lhx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:SI (mem:HI (plus:SI (match_operand:SI 1\n+\t\t\t\t\t  \"register_operand\" \"d\")\n+\t\t\t\t\t (match_operand:SI 2\n+\t\t\t\t\t  \"register_operand\" \"d\")))))]\n+  \"TARGET_DSP\"\n+  \"lhx\\t%0,%2(%1)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+(define_insn \"mips_lwx\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"TARGET_DSP\"\n+  \"lwx\\t%0,%2(%1)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"4\")])\n+\n+;; Table 2-8. MIPS DSP ASE Instructions: Branch\n+;; BPOSGE32\n+(define_insn \"mips_bposge\"\n+  [(set (pc)\n+\t(if_then_else\n+\t   (ge:CCDSP (reg:CCDSP CCDSP_PO_REGNUM)\n+\t\t     (match_operand:SI 0 \"immediate_operand\" \"I\"))\n+\t   (label_ref (match_operand 1 \"\" \"\"))\n+\t   (pc)))]\n+  \"TARGET_DSP\"\n+  \"%*bposge%0\\t%1%/\"\n+  [(set_attr \"type\"\t\"branch\")\n+   (set_attr \"mode\"\t\"none\")])\n+"}, {"sha": "39c2f164978526e1ba9da0f5864e6f990bd8cba9", "filename": "gcc/config/mips/mips-modes.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-modes.def?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -28,6 +28,7 @@ FLOAT_MODE (TF, 16, mips_quad_format);\n \n /* Vector modes.  */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n+VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n \n /* Paired single comparison instructions use 2 or 4 CC.  */\n CC_MODE (CCV2);\n@@ -37,3 +38,6 @@ ADJUST_ALIGNMENT (CCV2, 8);\n CC_MODE (CCV4);\n ADJUST_BYTESIZE (CCV4, 16);\n ADJUST_ALIGNMENT (CCV4, 16);\n+\n+/* For MIPS DSP control registers.  */\n+CC_MODE (CCDSP);"}, {"sha": "63eb6943b4300aaa1b31718b9ba43eb520889362", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 510, "deletions": 80, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -150,6 +150,35 @@ enum mips_function_type\n   MIPS_DF_FTYPE_DF,\n   MIPS_DF_FTYPE_DF_DF,\n \n+  /* For MIPS DSP ASE  */\n+  MIPS_DI_FTYPE_DI_SI,\n+  MIPS_DI_FTYPE_DI_SI_SI,\n+  MIPS_DI_FTYPE_DI_V2HI_V2HI,\n+  MIPS_DI_FTYPE_DI_V4QI_V4QI,\n+  MIPS_SI_FTYPE_DI_SI,\n+  MIPS_SI_FTYPE_PTR_SI,\n+  MIPS_SI_FTYPE_SI,\n+  MIPS_SI_FTYPE_SI_SI,\n+  MIPS_SI_FTYPE_V2HI,\n+  MIPS_SI_FTYPE_V2HI_V2HI,\n+  MIPS_SI_FTYPE_V4QI,\n+  MIPS_SI_FTYPE_V4QI_V4QI,\n+  MIPS_SI_FTYPE_VOID,\n+  MIPS_V2HI_FTYPE_SI,\n+  MIPS_V2HI_FTYPE_SI_SI,\n+  MIPS_V2HI_FTYPE_V2HI,\n+  MIPS_V2HI_FTYPE_V2HI_SI,\n+  MIPS_V2HI_FTYPE_V2HI_V2HI,\n+  MIPS_V2HI_FTYPE_V4QI,\n+  MIPS_V2HI_FTYPE_V4QI_V2HI,\n+  MIPS_V4QI_FTYPE_SI,\n+  MIPS_V4QI_FTYPE_V2HI_V2HI,\n+  MIPS_V4QI_FTYPE_V4QI_SI,\n+  MIPS_V4QI_FTYPE_V4QI_V4QI,\n+  MIPS_VOID_FTYPE_SI_SI,\n+  MIPS_VOID_FTYPE_V2HI_V2HI,\n+  MIPS_VOID_FTYPE_V4QI_V4QI,\n+\n   /* The last type.  */\n   MIPS_MAX_FTYPE_MAX\n };\n@@ -162,6 +191,10 @@ enum mips_builtin_type\n      operands 1 and above.  */\n   MIPS_BUILTIN_DIRECT,\n \n+  /* The builtin corresponds directly to an .md pattern.  There is no return\n+     value and the arguments are mapped to operands 0 and above.  */\n+  MIPS_BUILTIN_DIRECT_NO_TARGET,\n+\n   /* The builtin corresponds to a comparison instruction followed by\n      a mips_cond_move_tf_ps pattern.  The first two arguments are the\n      values to compare and the second two arguments are the vector\n@@ -185,7 +218,10 @@ enum mips_builtin_type\n   MIPS_BUILTIN_CMP_LOWER,\n \n   /* As above, but the instruction only sets a single $fcc register.  */\n-  MIPS_BUILTIN_CMP_SINGLE\n+  MIPS_BUILTIN_CMP_SINGLE,\n+\n+  /* For generating bposge32 branch instructions in MIPS32 DSP ASE.  */\n+  MIPS_BUILTIN_BPOSGE32\n };\n \n /* Invokes MACRO (COND) for each c.cond.fmt condition.  */\n@@ -362,13 +398,14 @@ static rtx mips_prepare_builtin_arg (enum insn_code, unsigned int, tree *);\n static rtx mips_prepare_builtin_target (enum insn_code, unsigned int, rtx);\n static rtx mips_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n static void mips_init_builtins (void);\n-static rtx mips_expand_builtin_direct (enum insn_code, rtx, tree);\n+static rtx mips_expand_builtin_direct (enum insn_code, rtx, tree, bool);\n static rtx mips_expand_builtin_movtf (enum mips_builtin_type,\n \t\t\t\t      enum insn_code, enum mips_fp_condition,\n \t\t\t\t      rtx, tree);\n static rtx mips_expand_builtin_compare (enum mips_builtin_type,\n \t\t\t\t\tenum insn_code, enum mips_fp_condition,\n \t\t\t\t\trtx, tree);\n+static rtx mips_expand_builtin_bposge (enum mips_builtin_type, rtx);\n \n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n@@ -644,7 +681,10 @@ const enum reg_class mips_regno_to_class[] =\n   COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n   COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n   COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n-  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS\n+  COP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\tCOP3_REGS,\n+  DSP_ACC_REGS,\tDSP_ACC_REGS,\tDSP_ACC_REGS,\tDSP_ACC_REGS,\n+  DSP_ACC_REGS,\tDSP_ACC_REGS,\tALL_REGS,\tALL_REGS,\n+  ALL_REGS,\tALL_REGS,\tALL_REGS,\tALL_REGS\n };\n \n /* Map register constraint character to register class.  */\n@@ -2608,8 +2648,8 @@ mips_subword (rtx op, int high_p)\n     {\n       if (FP_REG_P (REGNO (op)))\n \treturn gen_rtx_REG (word_mode, high_p ? REGNO (op) + 1 : REGNO (op));\n-      if (REGNO (op) == HI_REGNUM)\n-\treturn gen_rtx_REG (word_mode, high_p ? HI_REGNUM : LO_REGNUM);\n+      if (ACC_HI_REG_P (REGNO (op)))\n+\treturn gen_rtx_REG (word_mode, high_p ? REGNO (op) : REGNO (op) + 1);\n     }\n \n   if (MEM_P (op))\n@@ -2723,6 +2763,14 @@ mips_output_move (rtx dest, rtx src)\n \t  if (MD_REG_P (REGNO (dest)))\n \t    return \"mt%0\\t%z1\";\n \n+\t  if (DSP_ACC_REG_P (REGNO (dest)))\n+\t    {\n+\t      static char retval[] = \"mt__\\t%z1,%q0\";\n+\t      retval[2] = reg_names[REGNO (dest)][4];\n+\t      retval[3] = reg_names[REGNO (dest)][5];\n+\t      return retval;\n+\t    }\n+\n \t  if (FP_REG_P (REGNO (dest)))\n \t    return (dbl_p ? \"dmtc1\\t%z1,%0\" : \"mtc1\\t%z1,%0\");\n \n@@ -2741,6 +2789,14 @@ mips_output_move (rtx dest, rtx src)\n     {\n       if (src_code == REG)\n \t{\n+\t  if (DSP_ACC_REG_P (REGNO (src)))\n+\t    {\n+\t      static char retval[] = \"mf__\\t%0,%q1\";\n+\t      retval[2] = reg_names[REGNO (src)][4];\n+\t      retval[3] = reg_names[REGNO (src)][5];\n+\t      return retval;\n+\t    }\n+\n \t  if (ST_REG_P (REGNO (src)) && ISA_HAS_8CC)\n \t    return \"lui\\t%0,0x3f80\\n\\tmovf\\t%0,%.,%1\";\n \n@@ -4722,6 +4778,9 @@ override_options (void)\n   if (TARGET_PAIRED_SINGLE_FLOAT && !ISA_MIPS64)\n     error (\"-mips3d/-mpaired-single must be used with -mips64\");\n \n+  if (TARGET_MIPS16 && TARGET_DSP)\n+    error (\"-mips16 and -mdsp cannot be used together\");\n+\n   mips_print_operand_punct['?'] = 1;\n   mips_print_operand_punct['#'] = 1;\n   mips_print_operand_punct['/'] = 1;\n@@ -4761,6 +4820,8 @@ override_options (void)\n   mips_char_to_class['B'] = COP0_REGS;\n   mips_char_to_class['C'] = COP2_REGS;\n   mips_char_to_class['D'] = COP3_REGS;\n+  mips_char_to_class['A'] = DSP_ACC_REGS;\n+  mips_char_to_class['a'] = ACC_REGS;\n \n   /* Set up array to map GCC register number to debug register number.\n      Ignore the special purpose register numbers.  */\n@@ -4826,10 +4887,10 @@ override_options (void)\n \t\t\t/* Allow TFmode for CCmode reloads.  */\n \t\t\t|| (ISA_HAS_8CC && mode == TFmode));\n \n-\t  else if (MD_REG_P (regno))\n+          else if (ACC_REG_P (regno))\n \t    temp = (INTEGRAL_MODE_P (mode)\n \t\t    && (size <= UNITS_PER_WORD\n-\t\t\t|| (regno == MD_REG_FIRST\n+\t\t\t|| (ACC_HI_REG_P (regno)\n \t\t\t    && size == 2 * UNITS_PER_WORD)));\n \n \t  else if (ALL_COP_REG_P (regno))\n@@ -4978,6 +5039,13 @@ override_options (void)\n void\n mips_conditional_register_usage (void)\n {\n+  if (!TARGET_DSP)\n+    {\n+      int regno;\n+\n+      for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno++)\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\n+    }\n   if (!TARGET_HARD_FLOAT)\n     {\n       int regno;\n@@ -5122,6 +5190,7 @@ mips_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n    'Y'  for a CONST_INT X, print mips_fp_conditions[X]\n    'Z'  print the operand and a comma for ISA_HAS_8CC, otherwise print nothing\n    'R'  print the reloc associated with LO_SUM\n+   'q'  print DSP accumulator registers\n \n    The punctuation characters are:\n \n@@ -5372,6 +5441,22 @@ print_operand (FILE *file, rtx op, int letter)\n \t}\n     }\n \n+  else if (letter == 'q')\n+    {\n+      int regnum;\n+\n+      if (code != REG)\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%q\", op);\n+\n+      regnum = REGNO (op);\n+      if (MD_REG_P (regnum))\n+\tfprintf (file, \"$ac0\");\n+      else if (DSP_ACC_REG_P (regnum))\n+\tfprintf (file, \"$ac%c\", reg_names[regnum][3]);\n+      else\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%q\", op);\n+    }\n+\n   else if (code == REG || code == SUBREG)\n     {\n       register int regnum;\n@@ -7316,8 +7401,10 @@ mips_cannot_change_mode_class (enum machine_mode from,\n \t  /* LO_REGNO == HI_REGNO + 1, so if a multi-word value is stored\n \t     in LO and HI, the high word always comes first.  We therefore\n \t     can't allow values stored in HI to change between single-word\n-\t     and multi-word modes.  */\n-\t  if (reg_classes_intersect_p (HI_REG, class))\n+\t     and multi-word modes.\n+\t     This rule applies to both the original HI/LO pair and the new\n+\t     DSP accumulators.  */\n+\t  if (reg_classes_intersect_p (ACC_REGS, class))\n \t    return true;\n \t}\n     }\n@@ -7398,8 +7485,10 @@ mips_secondary_reload_class (enum reg_class class,\n     }\n \n   /* Copying from HI or LO to anywhere other than a general register\n-     requires a general register.  */\n-  if (class == HI_REG || class == LO_REG || class == MD_REGS)\n+     requires a general register.\n+     This rule applies to both the original HI/LO pair and the new\n+     DSP accumulators.  */\n+  if (reg_class_subset_p (class, ACC_REGS))\n     {\n       if (TARGET_MIPS16 && in_p)\n \t{\n@@ -7408,7 +7497,7 @@ mips_secondary_reload_class (enum reg_class class,\n \t}\n       return gp_reg_p ? NO_REGS : gr_regs;\n     }\n-  if (MD_REG_P (regno))\n+  if (ACC_REG_P (regno))\n     {\n       if (TARGET_MIPS16 && ! in_p)\n \t{\n@@ -7519,10 +7608,18 @@ mips_valid_pointer_mode (enum machine_mode mode)\n static bool\n mips_vector_mode_supported_p (enum machine_mode mode)\n {\n-  if (mode == V2SFmode && TARGET_PAIRED_SINGLE_FLOAT)\n-    return true;\n-  else\n-    return false;\n+  switch (mode)\n+    {\n+    case V2SFmode:\n+      return TARGET_PAIRED_SINGLE_FLOAT;\n+\n+    case V2HImode:\n+    case V4QImode:\n+      return TARGET_DSP;\n+\n+    default:\n+      return false;\n+    }\n }\n \f\n /* If we can access small data directly (using gp-relative relocation\n@@ -8887,7 +8984,7 @@ mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t}\n       else if (to == FP_REGS)\n \treturn 4;\n-      else if (to == HI_REG || to == LO_REG || to == MD_REGS)\n+      else if (reg_class_subset_p (to, ACC_REGS))\n \t{\n \t  if (TARGET_MIPS16)\n \t    return 12;\n@@ -8908,7 +9005,7 @@ mips_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n       else if (to == ST_REGS)\n \treturn 8;\n     }\n-  else if (from == HI_REG || from == LO_REG || from == MD_REGS)\n+  else if (reg_class_subset_p (from, ACC_REGS))\n     {\n       if (GR_REG_CLASS_P (to))\n \t{\n@@ -9910,6 +10007,116 @@ static const struct builtin_description sb1_bdesc[] =\n   DIRECT_BUILTIN (sqrt_ps, MIPS_V2SF_FTYPE_V2SF, MASK_PAIRED_SINGLE_FLOAT)\n };\n \n+/* Builtin functions for DSP ASE.  */\n+\n+#define CODE_FOR_mips_addq_ph CODE_FOR_addv2hi3\n+#define CODE_FOR_mips_addu_qb CODE_FOR_addv4qi3\n+#define CODE_FOR_mips_subq_ph CODE_FOR_subv2hi3\n+#define CODE_FOR_mips_subu_qb CODE_FOR_subv4qi3\n+\n+/* Define a MIPS_BUILTIN_DIRECT_NO_TARGET function for instruction\n+   CODE_FOR_mips_<INSN>.  FUNCTION_TYPE and TARGET_FLAGS are\n+   builtin_description fields.  */\n+#define DIRECT_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, TARGET_FLAGS)\t\\\n+  { CODE_FOR_mips_ ## INSN, 0, \"__builtin_mips_\" #INSN,\t\t\t\\\n+    MIPS_BUILTIN_DIRECT_NO_TARGET, FUNCTION_TYPE, TARGET_FLAGS }\n+\n+/* Define __builtin_mips_bposge<VALUE>.  <VALUE> is 32 for the MIPS32 DSP\n+   branch instruction.  TARGET_FLAGS is a builtin_description field.  */\n+#define BPOSGE_BUILTIN(VALUE, TARGET_FLAGS)\t\t\t\t\\\n+  { CODE_FOR_mips_bposge, 0, \"__builtin_mips_bposge\" #VALUE,\t\t\\\n+    MIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, TARGET_FLAGS }\n+\n+static const struct builtin_description dsp_bdesc[] =\n+{\n+  DIRECT_BUILTIN (addq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (addq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (addq_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (addu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (addu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (subq_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (subq_s_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (subq_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (subu_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (subu_s_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (addsc, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (addwc, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (modsub, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (raddu_w_qb, MIPS_SI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (absq_s_ph, MIPS_V2HI_FTYPE_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (absq_s_w, MIPS_SI_FTYPE_SI, MASK_DSP),\n+  DIRECT_BUILTIN (precrq_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (precrq_ph_w, MIPS_V2HI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (precrq_rs_ph_w, MIPS_V2HI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (precrqu_s_qb_ph, MIPS_V4QI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (preceq_w_phl, MIPS_SI_FTYPE_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (preceq_w_phr, MIPS_SI_FTYPE_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (precequ_ph_qbl, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (precequ_ph_qbr, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (precequ_ph_qbla, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (precequ_ph_qbra, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (preceu_ph_qbl, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (preceu_ph_qbr, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (preceu_ph_qbla, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (preceu_ph_qbra, MIPS_V2HI_FTYPE_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (shll_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shll_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shll_s_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shll_s_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shrl_qb, MIPS_V4QI_FTYPE_V4QI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shra_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shra_r_ph, MIPS_V2HI_FTYPE_V2HI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shra_r_w, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (muleu_s_ph_qbl, MIPS_V2HI_FTYPE_V4QI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (muleu_s_ph_qbr, MIPS_V2HI_FTYPE_V4QI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (mulq_rs_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (muleq_s_w_phl, MIPS_SI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (muleq_s_w_phr, MIPS_SI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (dpau_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (dpau_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (dpsu_h_qbl, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (dpsu_h_qbr, MIPS_DI_FTYPE_DI_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (dpaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (dpsq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (mulsaq_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (dpaq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (dpsq_sa_l_w, MIPS_DI_FTYPE_DI_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (maq_s_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (maq_s_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (maq_sa_w_phl, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (maq_sa_w_phr, MIPS_DI_FTYPE_DI_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (bitrev, MIPS_SI_FTYPE_SI, MASK_DSP),\n+  DIRECT_BUILTIN (insv, MIPS_SI_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (repl_qb, MIPS_V4QI_FTYPE_SI, MASK_DSP),\n+  DIRECT_BUILTIN (repl_ph, MIPS_V2HI_FTYPE_SI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmpu_eq_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmpu_lt_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmpu_le_qb, MIPS_VOID_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (cmpgu_eq_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (cmpgu_lt_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (cmpgu_le_qb, MIPS_SI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmp_eq_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmp_lt_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (cmp_le_ph, MIPS_VOID_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (pick_qb, MIPS_V4QI_FTYPE_V4QI_V4QI, MASK_DSP),\n+  DIRECT_BUILTIN (pick_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (packrl_ph, MIPS_V2HI_FTYPE_V2HI_V2HI, MASK_DSP),\n+  DIRECT_BUILTIN (extr_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (extr_r_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (extr_rs_w, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (extr_s_h, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (extp, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (extpdp, MIPS_SI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (shilo, MIPS_DI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (mthlip, MIPS_DI_FTYPE_DI_SI, MASK_DSP),\n+  DIRECT_NO_TARGET_BUILTIN (wrdsp, MIPS_VOID_FTYPE_SI_SI, MASK_DSP),\n+  DIRECT_BUILTIN (rddsp, MIPS_SI_FTYPE_SI, MASK_DSP),\n+  DIRECT_BUILTIN (lbux, MIPS_SI_FTYPE_PTR_SI, MASK_DSP),\n+  DIRECT_BUILTIN (lhx, MIPS_SI_FTYPE_PTR_SI, MASK_DSP),\n+  DIRECT_BUILTIN (lwx, MIPS_SI_FTYPE_PTR_SI, MASK_DSP),\n+  BPOSGE_BUILTIN (32, MASK_DSP)\n+};\n+\n /* This helps provide a mapping from builtin function codes to bdesc\n    arrays.  */\n \n@@ -9929,7 +10136,8 @@ struct bdesc_map\n static const struct bdesc_map bdesc_arrays[] =\n {\n   { mips_bdesc, ARRAY_SIZE (mips_bdesc), PROCESSOR_MAX },\n-  { sb1_bdesc, ARRAY_SIZE (sb1_bdesc), PROCESSOR_SB1 }\n+  { sb1_bdesc, ARRAY_SIZE (sb1_bdesc), PROCESSOR_SB1 },\n+  { dsp_bdesc, ARRAY_SIZE (dsp_bdesc), PROCESSOR_MAX }\n };\n \n /* Take the head of argument list *ARGLIST and convert it into a form\n@@ -9946,7 +10154,15 @@ mips_prepare_builtin_arg (enum insn_code icode,\n   value = expand_expr (TREE_VALUE (*arglist), NULL_RTX, VOIDmode, 0);\n   mode = insn_data[icode].operand[op].mode;\n   if (!insn_data[icode].operand[op].predicate (value, mode))\n-    value = copy_to_mode_reg (mode, value);\n+    {\n+      value = copy_to_mode_reg (mode, value);\n+      /* Check the predicate again.  */\n+      if (!insn_data[icode].operand[op].predicate (value, mode))\n+\t{\n+\t  error (\"invalid argument to builtin function\");\n+\t  return const0_rtx;\n+\t}\n+    }\n \n   *arglist = TREE_CHAIN (*arglist);\n   return value;\n@@ -10003,7 +10219,10 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   switch (type)\n     {\n     case MIPS_BUILTIN_DIRECT:\n-      return mips_expand_builtin_direct (icode, target, arglist);\n+      return mips_expand_builtin_direct (icode, target, arglist, true);\n+\n+    case MIPS_BUILTIN_DIRECT_NO_TARGET:\n+      return mips_expand_builtin_direct (icode, target, arglist, false);\n \n     case MIPS_BUILTIN_MOVT:\n     case MIPS_BUILTIN_MOVF:\n@@ -10018,6 +10237,9 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       return mips_expand_builtin_compare (type, icode, bdesc[fcode].cond,\n \t\t\t\t\t  target, arglist);\n \n+    case MIPS_BUILTIN_BPOSGE32:\n+      return mips_expand_builtin_bposge (type, target);\n+\n     default:\n       return 0;\n     }\n@@ -10032,70 +10254,214 @@ mips_init_builtins (void)\n   const struct bdesc_map *m;\n   tree types[(int) MIPS_MAX_FTYPE_MAX];\n   tree V2SF_type_node;\n+  tree V2HI_type_node;\n+  tree V4QI_type_node;\n   unsigned int offset;\n \n-  /* We have only builtins for -mpaired-single and -mips3d.  */\n-  if (!TARGET_PAIRED_SINGLE_FLOAT)\n+  /* We have only builtins for -mpaired-single, -mips3d and -mdsp.  */\n+  if (!TARGET_PAIRED_SINGLE_FLOAT && !TARGET_DSP)\n     return;\n \n-  V2SF_type_node = build_vector_type_for_mode (float_type_node, V2SFmode);\n-\n-  types[MIPS_V2SF_FTYPE_V2SF]\n-    = build_function_type_list (V2SF_type_node, V2SF_type_node, NULL_TREE);\n-\n-  types[MIPS_V2SF_FTYPE_V2SF_V2SF]\n-    = build_function_type_list (V2SF_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node, NULL_TREE);\n-\n-  types[MIPS_V2SF_FTYPE_V2SF_V2SF_INT]\n-    = build_function_type_list (V2SF_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-\n-  types[MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF]\n-    = build_function_type_list (V2SF_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node, NULL_TREE);\n+  if (TARGET_PAIRED_SINGLE_FLOAT)\n+    {\n+      V2SF_type_node = build_vector_type_for_mode (float_type_node, V2SFmode);\n \n-  types[MIPS_V2SF_FTYPE_SF_SF]\n-    = build_function_type_list (V2SF_type_node,\n-\t\t\t\tfloat_type_node, float_type_node, NULL_TREE);\n+      types[MIPS_V2SF_FTYPE_V2SF]\n+\t= build_function_type_list (V2SF_type_node, V2SF_type_node, NULL_TREE);\n \n-  types[MIPS_INT_FTYPE_V2SF_V2SF]\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node, NULL_TREE);\n+      types[MIPS_V2SF_FTYPE_V2SF_V2SF]\n+\t= build_function_type_list (V2SF_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node, NULL_TREE);\n \n-  types[MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF]\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node,\n-\t\t\t\tV2SF_type_node, V2SF_type_node, NULL_TREE);\n+      types[MIPS_V2SF_FTYPE_V2SF_V2SF_INT]\n+\t= build_function_type_list (V2SF_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n \n-  types[MIPS_INT_FTYPE_SF_SF]\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tfloat_type_node, float_type_node, NULL_TREE);\n+      types[MIPS_V2SF_FTYPE_V2SF_V2SF_V2SF_V2SF]\n+\t= build_function_type_list (V2SF_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node, NULL_TREE);\n \n-  types[MIPS_INT_FTYPE_DF_DF]\n-    = build_function_type_list (integer_type_node,\n-\t\t\t\tdouble_type_node, double_type_node, NULL_TREE);\n+      types[MIPS_V2SF_FTYPE_SF_SF]\n+\t= build_function_type_list (V2SF_type_node,\n+\t\t\t\t    float_type_node, float_type_node, NULL_TREE);\n \n-  types[MIPS_SF_FTYPE_V2SF]\n-    = build_function_type_list (float_type_node, V2SF_type_node, NULL_TREE);\n+      types[MIPS_INT_FTYPE_V2SF_V2SF]\n+\t= build_function_type_list (integer_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node, NULL_TREE);\n \n-  types[MIPS_SF_FTYPE_SF]\n-    = build_function_type_list (float_type_node,\n-\t\t\t\tfloat_type_node, NULL_TREE);\n+      types[MIPS_INT_FTYPE_V2SF_V2SF_V2SF_V2SF]\n+\t= build_function_type_list (integer_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node,\n+\t\t\t\t    V2SF_type_node, V2SF_type_node, NULL_TREE);\n \n-  types[MIPS_SF_FTYPE_SF_SF]\n-    = build_function_type_list (float_type_node,\n-\t\t\t\tfloat_type_node, float_type_node, NULL_TREE);\n+      types[MIPS_INT_FTYPE_SF_SF]\n+\t= build_function_type_list (integer_type_node,\n+\t\t\t\t    float_type_node, float_type_node, NULL_TREE);\n \n-  types[MIPS_DF_FTYPE_DF]\n-    = build_function_type_list (double_type_node,\n-\t\t\t\tdouble_type_node, NULL_TREE);\n+      types[MIPS_INT_FTYPE_DF_DF]\n+\t= build_function_type_list (integer_type_node,\n+\t\t\t\t    double_type_node, double_type_node, NULL_TREE);\n \n-  types[MIPS_DF_FTYPE_DF_DF]\n-    = build_function_type_list (double_type_node,\n-\t\t\t\tdouble_type_node, double_type_node, NULL_TREE);\n+      types[MIPS_SF_FTYPE_V2SF]\n+\t= build_function_type_list (float_type_node, V2SF_type_node, NULL_TREE);\n+\n+      types[MIPS_SF_FTYPE_SF]\n+\t= build_function_type_list (float_type_node,\n+\t\t\t\t    float_type_node, NULL_TREE);\n+\n+      types[MIPS_SF_FTYPE_SF_SF]\n+\t= build_function_type_list (float_type_node,\n+\t\t\t\t    float_type_node, float_type_node, NULL_TREE);\n+\n+      types[MIPS_DF_FTYPE_DF]\n+\t= build_function_type_list (double_type_node,\n+\t\t\t\t    double_type_node, NULL_TREE);\n+\n+      types[MIPS_DF_FTYPE_DF_DF]\n+\t= build_function_type_list (double_type_node,\n+\t\t\t\t    double_type_node, double_type_node, NULL_TREE);\n+    }\n+\n+  if (TARGET_DSP)\n+    {\n+      V2HI_type_node = build_vector_type_for_mode (intHI_type_node, V2HImode);\n+      V4QI_type_node = build_vector_type_for_mode (intQI_type_node, V4QImode);\n+\n+      types[MIPS_V2HI_FTYPE_V2HI_V2HI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    V2HI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_SI_SI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    intSI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V4QI_FTYPE_V4QI_V4QI]\n+\t= build_function_type_list (V4QI_type_node,\n+\t\t\t\t    V4QI_type_node, V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_V4QI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_V2HI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_SI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V4QI_FTYPE_V2HI_V2HI]\n+\t= build_function_type_list (V4QI_type_node,\n+\t\t\t\t    V2HI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_SI_SI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    intSI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_V2HI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_V4QI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V4QI_FTYPE_V4QI_SI]\n+\t= build_function_type_list (V4QI_type_node,\n+\t\t\t\t    V4QI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_V2HI_SI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    V2HI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_V4QI_V2HI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    V4QI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_V2HI_V2HI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    V2HI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_DI_FTYPE_DI_V4QI_V4QI]\n+\t= build_function_type_list (intDI_type_node,\n+\t\t\t\t    intDI_type_node, V4QI_type_node, V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_DI_FTYPE_DI_V2HI_V2HI]\n+\t= build_function_type_list (intDI_type_node,\n+\t\t\t\t    intDI_type_node, V2HI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_DI_FTYPE_DI_SI_SI]\n+\t= build_function_type_list (intDI_type_node,\n+\t\t\t\t    intDI_type_node, intSI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V4QI_FTYPE_SI]\n+\t= build_function_type_list (V4QI_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_V2HI_FTYPE_SI]\n+\t= build_function_type_list (V2HI_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_VOID_FTYPE_V4QI_V4QI]\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    V4QI_type_node, V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_V4QI_V4QI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    V4QI_type_node, V4QI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_VOID_FTYPE_V2HI_V2HI]\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    V2HI_type_node, V2HI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_DI_SI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    intDI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_DI_FTYPE_DI_SI]\n+\t= build_function_type_list (intDI_type_node,\n+\t\t\t\t    intDI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_VOID_FTYPE_SI_SI]\n+\t= build_function_type_list (void_type_node,\n+\t\t\t\t    intSI_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_PTR_SI]\n+\t= build_function_type_list (intSI_type_node,\n+\t\t\t\t    ptr_type_node, intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      types[MIPS_SI_FTYPE_VOID]\n+\t= build_function_type (intSI_type_node, void_list_node);\n+    }\n \n   /* Iterate through all of the bdesc arrays, initializing all of the\n      builtin functions.  */\n@@ -10115,30 +10481,40 @@ mips_init_builtins (void)\n \n /* Expand a MIPS_BUILTIN_DIRECT function.  ICODE is the code of the\n    .md pattern and ARGLIST is the list of function arguments.  TARGET,\n-   if nonnull, suggests a good place to put the result.  */\n+   if nonnull, suggests a good place to put the result.\n+   HAS_TARGET indicates the function must return something.  */\n \n static rtx\n-mips_expand_builtin_direct (enum insn_code icode, rtx target, tree arglist)\n+mips_expand_builtin_direct (enum insn_code icode, rtx target, tree arglist,\n+\t\t\t    bool has_target)\n {\n   rtx ops[MAX_RECOG_OPERANDS];\n-  int i;\n+  int i = 0;\n \n-  target = mips_prepare_builtin_target (icode, 0, target);\n-  for (i = 1; i < insn_data[icode].n_operands; i++)\n+  if (has_target)\n+    {\n+      /* We save target to ops[0].  */\n+      ops[0] = mips_prepare_builtin_target (icode, 0, target);\n+      i = 1;\n+    }\n+\n+  /* We need to test if arglist is not zero.  Some instructions have extra\n+     clobber registers.  */\n+  for (; i < insn_data[icode].n_operands && arglist != 0; i++)\n     ops[i] = mips_prepare_builtin_arg (icode, i, &arglist);\n \n-  switch (insn_data[icode].n_operands)\n+  switch (i)\n     {\n     case 2:\n-      emit_insn (GEN_FCN (icode) (target, ops[1]));\n+      emit_insn (GEN_FCN (icode) (ops[0], ops[1]));\n       break;\n \n     case 3:\n-      emit_insn (GEN_FCN (icode) (target, ops[1], ops[2]));\n+      emit_insn (GEN_FCN (icode) (ops[0], ops[1], ops[2]));\n       break;\n \n     case 4:\n-      emit_insn (GEN_FCN (icode) (target, ops[1], ops[2], ops[3]));\n+      emit_insn (GEN_FCN (icode) (ops[0], ops[1], ops[2], ops[3]));\n       break;\n \n     default:\n@@ -10268,5 +10644,59 @@ mips_expand_builtin_compare (enum mips_builtin_type builtin_type,\n \n   return target;\n }\n+\n+/* Expand a bposge builtin of type BUILTIN_TYPE.  TARGET, if nonnull,\n+   suggests a good place to put the boolean result.\n+\n+   The sequence we want is\n+\n+\tli\ttarget, 0\n+\tbposge*\tlabel1\n+\tj\tlabel2\n+   label1:\n+\tli \ttarget, 1\n+   label2:  */\n+\n+static rtx\n+mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n+{\n+  rtx label1, label2, if_then_else;\n+  rtx cmp_result;\n+  int cmp_value;\n+\n+  if (target == 0 || GET_MODE (target) != SImode)\n+    target = gen_reg_rtx (SImode);\n+\n+  cmp_result = gen_rtx_REG (CCDSPmode, CCDSP_PO_REGNUM);\n+\n+  if (builtin_type == MIPS_BUILTIN_BPOSGE32)\n+    cmp_value = 32;\n+  else\n+    gcc_assert (0);\n+\n+  /* Move 0 to target */\n+  emit_move_insn (target, const0_rtx);\n+\n+  /* Generate two labels */\n+  label1 = gen_label_rtx ();\n+  label2 = gen_label_rtx ();\n+\n+  /* Generate if_then_else */\n+  if_then_else\n+    = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t    gen_rtx_fmt_ee (GE, CCDSPmode,\n+\t\t\t\t\t    cmp_result, GEN_INT (cmp_value)),\n+\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label1), pc_rtx);\n+\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, if_then_else));\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+                               gen_rtx_LABEL_REF (VOIDmode, label2)));\n+  emit_barrier ();\n+  emit_label (label1);\n+  emit_move_insn (target, const1_rtx);\n+  emit_label (label2);\n+\n+  return target;\n+}\n \f\n #include \"gt-mips.h\""}, {"sha": "cc38e118dd6412bf1972c122586c0908bfdaaec8", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -316,6 +316,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n       if (TARGET_MIPS3D)\t\t\t\t\t\\\n \tbuiltin_define (\"__mips3d\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n+      if (TARGET_DSP)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__mips_dsp\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n       MIPS_CPP_SET_PROCESSOR (\"_MIPS_ARCH\", mips_arch_info);\t\\\n       MIPS_CPP_SET_PROCESSOR (\"_MIPS_TUNE\", mips_tune_info);\t\\\n \t\t\t\t\t\t\t\t\\\n@@ -807,6 +810,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n %{mips32} %{mips32r2} %{mips64} \\\n %{mips16:%{!mno-mips16:-mips16}} %{mno-mips16:-no-mips16} \\\n %{mips3d:-mips3d} \\\n+%{mdsp} \\\n %{mfix-vr4120} %{mfix-vr4130} \\\n %(subtarget_asm_optimizing_spec) \\\n %(subtarget_asm_debugging_spec) \\\n@@ -1149,9 +1153,11 @@ extern const struct mips_rtx_cost_data *mips_cost;\n \t- ARG_POINTER_REGNUM\n \t- FRAME_POINTER_REGNUM\n \t- FAKE_CALL_REGNO (see the comment above load_callsi for details)\n-   - 3 dummy entries that were used at various times in the past.  */\n+   - 3 dummy entries that were used at various times in the past.\n+   - 6 DSP accumulator registers (3 hi-lo pairs) for MIPS DSP ASE\n+   - 6 DSP control registers  */\n \n-#define FIRST_PSEUDO_REGISTER 176\n+#define FIRST_PSEUDO_REGISTER 188\n \n /* By default, fix the kernel registers ($26 and $27), the global\n    pointer ($28) and the stack pointer ($29).  This can change\n@@ -1178,7 +1184,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP3 registers */\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* 6 DSP accumulator registers & 6 control registers */\t\t\\\n+  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1\t\t\t\t\t\\\n }\n \n \n@@ -1208,7 +1216,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   /* COP3 registers */\t\t\t\t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  /* 6 DSP accumulator registers & 6 control registers */\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\t\t\t\t\t\\\n }\n \n \n@@ -1231,7 +1241,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   /* COP3 registers */\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  /* 6 DSP accumulator registers & 6 control registers */\t\t\\\n+  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0\t\t\t\t\t\\\n }\n \n /* Internal macros to classify a register number as to whether it's a\n@@ -1273,9 +1285,19 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* ALL_COP_REG_NUM assumes that COP0,2,and 3 are numbered consecutively.  */\n #define ALL_COP_REG_NUM (COP3_REG_LAST - COP0_REG_FIRST + 1)\n \n+#define DSP_ACC_REG_FIRST 176\n+#define DSP_ACC_REG_LAST 181\n+#define DSP_ACC_REG_NUM (DSP_ACC_REG_LAST - DSP_ACC_REG_FIRST + 1)\n+\n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n+#define AC1HI_REGNUM\t(DSP_ACC_REG_FIRST + 0)\n+#define AC1LO_REGNUM\t(DSP_ACC_REG_FIRST + 1)\n+#define AC2HI_REGNUM\t(DSP_ACC_REG_FIRST + 2)\n+#define AC2LO_REGNUM\t(DSP_ACC_REG_FIRST + 3)\n+#define AC3HI_REGNUM\t(DSP_ACC_REG_FIRST + 4)\n+#define AC3LO_REGNUM\t(DSP_ACC_REG_FIRST + 5)\n \n /* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.\n    If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG\n@@ -1300,6 +1322,16 @@ extern const struct mips_rtx_cost_data *mips_cost;\n   ((unsigned int) ((int) (REGNO) - COP3_REG_FIRST) < COP3_REG_NUM)\n #define ALL_COP_REG_P(REGNO) \\\n   ((unsigned int) ((int) (REGNO) - COP0_REG_FIRST) < ALL_COP_REG_NUM)\n+/* Test if REGNO is one of the 6 new DSP accumulators.  */\n+#define DSP_ACC_REG_P(REGNO) \\\n+  ((unsigned int) ((int) (REGNO) - DSP_ACC_REG_FIRST) < DSP_ACC_REG_NUM)\n+/* Test if REGNO is hi, lo, or one of the 6 new DSP accumulators.  */\n+#define ACC_REG_P(REGNO) \\\n+  (MD_REG_P (REGNO) || DSP_ACC_REG_P (REGNO))\n+/* Test if REGNO is HI or the first register of 3 new DSP accumulator pairs.  */\n+#define ACC_HI_REG_P(REGNO) \\\n+  ((REGNO) == HI_REGNUM || (REGNO) == AC1HI_REGNUM || (REGNO) == AC2HI_REGNUM \\\n+   || (REGNO) == AC3HI_REGNUM)\n \n #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n \n@@ -1442,6 +1474,8 @@ enum reg_class\n   ALL_COP_REGS,\n   ALL_COP_AND_GR_REGS,\n   ST_REGS,\t\t\t/* status registers (fp status) */\n+  DSP_ACC_REGS,\t\t\t/* DSP accumulator registers */\n+  ACC_REGS,\t\t\t/* Hi/Lo and DSP accumulator registers */\n   ALL_REGS,\t\t\t/* all registers */\n   LIM_REG_CLASSES\t\t/* max value + 1 */\n };\n@@ -1482,6 +1516,8 @@ enum reg_class\n   \"ALL_COP_REGS\",\t\t\t\t\t\t\t\\\n   \"ALL_COP_AND_GR_REGS\",\t\t\t\t\t\t\\\n   \"ST_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"DSP_ACC_REGS\",\t\t\t\t\t\t\t\\\n+  \"ACC_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n }\n \n@@ -1523,7 +1559,9 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff },                           \\\n   { 0xffffffff, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff },                           \\\n   { 0x00000000, 0x00000000, 0x000007f8, 0x00000000, 0x00000000, 0x00000000 },\t/* status registers */\t\\\n-  { 0xffffffff, 0xffffffff, 0xffff07ff, 0xffffffff, 0xffffffff, 0x0000ffff }\t/* all registers */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x003f0000 },\t/* dsp accumulator registers */\t\\\n+  { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x003f0000 },\t/* hi/lo and dsp accumulator registers */\t\\\n+  { 0xffffffff, 0xffffffff, 0xffff07ff, 0xffffffff, 0xffffffff, 0x0fffffff }\t/* all registers */\t\\\n }\n \n \n@@ -1584,7 +1622,8 @@ extern const enum reg_class mips_regno_to_class[];\n   112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\t\\\n   128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\t\\\n   144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\t\\\n-  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175\t\\\n+  160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\t\\\n+  176,177,178,179,180,181,182,183,184,185,186,187\t\t\t\\\n }\n \n /* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order\n@@ -1615,12 +1654,24 @@ extern const enum reg_class mips_regno_to_class[];\n    'B'  Cop0 register\n    'C'  Cop2 register\n    'D'  Cop3 register\n+   'A'  DSP accumulator registers\n+   'a'  MD registers and DSP accumulator registers\n    'b'\tAll registers */\n \n extern enum reg_class mips_char_to_class[256];\n \n #define REG_CLASS_FROM_LETTER(C) mips_char_to_class[(unsigned char)(C)]\n \n+/* True if VALUE is a unsigned 6-bit number.  */\n+\n+#define UIMM6_OPERAND(VALUE) \\\n+  (((VALUE) & ~(unsigned HOST_WIDE_INT) 0x3f) == 0)\n+\n+/* True if VALUE is a signed 10-bit number.  */\n+\n+#define IMM10_OPERAND(VALUE) \\\n+  ((unsigned HOST_WIDE_INT) (VALUE) + 0x200 < 0x400)\n+\n /* True if VALUE is a signed 16-bit number.  */\n \n #define SMALL_OPERAND(VALUE) \\\n@@ -1718,11 +1769,17 @@ extern enum reg_class mips_char_to_class[256];\n \t This is true for all non-mips16 references (although it can sometimes\n \t be indirect if !TARGET_EXPLICIT_RELOCS).  For mips16, it excludes\n \t stack and constant-pool references.\n-   `YG' is for 0 valued vector constants.  */\n+   `YG' is for 0 valued vector constants.\n+   `YA' is for unsigned 6-bit constants.\n+   `YB' is for signed 10-bit constants.  */\n \n #define EXTRA_CONSTRAINT_Y(OP,STR)\t\t\t\t\t\\\n   (((STR)[1] == 'G')\t  ? (GET_CODE (OP) == CONST_VECTOR\t\t\\\n \t\t\t     && (OP) == CONST0_RTX (GET_MODE (OP)))\t\\\n+   : ((STR)[1] == 'A')\t  ? (GET_CODE (OP) == CONST_INT\t\t\t\\\n+\t\t\t     && UIMM6_OPERAND (INTVAL (OP)))\t\t\\\n+   : ((STR)[1] == 'B')\t  ? (GET_CODE (OP) == CONST_INT\t\t\t\\\n+\t\t\t     && IMM10_OPERAND (INTVAL (OP)))\t\t\\\n    : FALSE)\n \n \n@@ -2386,7 +2443,9 @@ typedef struct mips_args {\n   \"$c3r0\", \"$c3r1\", \"$c3r2\", \"$c3r3\", \"$c3r4\", \"$c3r5\", \"$c3r6\", \"$c3r7\",  \\\n   \"$c3r8\", \"$c3r9\", \"$c3r10\",\"$c3r11\",\"$c3r12\",\"$c3r13\",\"$c3r14\",\"$c3r15\", \\\n   \"$c3r16\",\"$c3r17\",\"$c3r18\",\"$c3r19\",\"$c3r20\",\"$c3r21\",\"$c3r22\",\"$c3r23\", \\\n-  \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\" }\n+  \"$c3r24\",\"$c3r25\",\"$c3r26\",\"$c3r27\",\"$c3r28\",\"$c3r29\",\"$c3r30\",\"$c3r31\", \\\n+  \"$ac1hi\",\"$ac1lo\",\"$ac2hi\",\"$ac2lo\",\"$ac3hi\",\"$ac3lo\",\"$dsp_po\",\"$dsp_sc\", \\\n+  \"$dsp_ca\",\"$dsp_ou\",\"$dsp_cc\",\"$dsp_ef\" }\n \n /* List the \"software\" names for each register.  Also list the numerical\n    names for $fp and $sp.  */"}, {"sha": "a43a0c288474296b1ecb49fb081788ea1b86fd20", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -72,6 +72,76 @@\n    (UNSPEC_RSQRT2\t\t209)\n    (UNSPEC_RECIP1\t\t210)\n    (UNSPEC_RECIP2\t\t211)\n+\n+   ;; MIPS DSP ASE Revision 0.98 3/24/2005\n+   (UNSPEC_ADDQ\t\t\t300)\n+   (UNSPEC_ADDQ_S\t\t301)\n+   (UNSPEC_SUBQ\t\t\t302)\n+   (UNSPEC_SUBQ_S\t\t303)\n+   (UNSPEC_ADDSC\t\t304)\n+   (UNSPEC_ADDWC\t\t305)\n+   (UNSPEC_MODSUB\t\t306)\n+   (UNSPEC_RADDU_W_QB\t\t307)\n+   (UNSPEC_ABSQ_S\t\t308)\n+   (UNSPEC_PRECRQ_QB_PH\t\t309)\n+   (UNSPEC_PRECRQ_PH_W\t\t310)\n+   (UNSPEC_PRECRQ_RS_PH_W\t311)\n+   (UNSPEC_PRECRQU_S_QB_PH\t312)\n+   (UNSPEC_PRECEQ_W_PHL\t\t313)\n+   (UNSPEC_PRECEQ_W_PHR\t\t314)\n+   (UNSPEC_PRECEQU_PH_QBL\t315)\n+   (UNSPEC_PRECEQU_PH_QBR\t316)\n+   (UNSPEC_PRECEQU_PH_QBLA\t317)\n+   (UNSPEC_PRECEQU_PH_QBRA\t318)\n+   (UNSPEC_PRECEU_PH_QBL\t319)\n+   (UNSPEC_PRECEU_PH_QBR\t320)\n+   (UNSPEC_PRECEU_PH_QBLA\t321)\n+   (UNSPEC_PRECEU_PH_QBRA\t322)\n+   (UNSPEC_SHLL\t\t\t323)\n+   (UNSPEC_SHLL_S\t\t324)\n+   (UNSPEC_SHRL_QB\t\t325)\n+   (UNSPEC_SHRA_PH\t\t326)\n+   (UNSPEC_SHRA_R\t\t327)\n+   (UNSPEC_MULEU_S_PH_QBL\t328)\n+   (UNSPEC_MULEU_S_PH_QBR\t329)\n+   (UNSPEC_MULQ_RS_PH\t\t330)\n+   (UNSPEC_MULEQ_S_W_PHL\t331)\n+   (UNSPEC_MULEQ_S_W_PHR\t332)\n+   (UNSPEC_DPAU_H_QBL\t\t333)\n+   (UNSPEC_DPAU_H_QBR\t\t334)\n+   (UNSPEC_DPSU_H_QBL\t\t335)\n+   (UNSPEC_DPSU_H_QBR\t\t336)\n+   (UNSPEC_DPAQ_S_W_PH\t\t337)\n+   (UNSPEC_DPSQ_S_W_PH\t\t338)\n+   (UNSPEC_MULSAQ_S_W_PH\t339)\n+   (UNSPEC_DPAQ_SA_L_W\t\t340)\n+   (UNSPEC_DPSQ_SA_L_W\t\t341)\n+   (UNSPEC_MAQ_S_W_PHL\t\t342)\n+   (UNSPEC_MAQ_S_W_PHR\t\t343)\n+   (UNSPEC_MAQ_SA_W_PHL\t\t344)\n+   (UNSPEC_MAQ_SA_W_PHR\t\t345)\n+   (UNSPEC_BITREV\t\t346)\n+   (UNSPEC_INSV\t\t\t347)\n+   (UNSPEC_REPL_QB\t\t348)\n+   (UNSPEC_REPL_PH\t\t349)\n+   (UNSPEC_CMP_EQ\t\t350)\n+   (UNSPEC_CMP_LT\t\t351)\n+   (UNSPEC_CMP_LE\t\t352)\n+   (UNSPEC_CMPGU_EQ_QB\t\t353)\n+   (UNSPEC_CMPGU_LT_QB\t\t354)\n+   (UNSPEC_CMPGU_LE_QB\t\t355)\n+   (UNSPEC_PICK\t\t\t356)\n+   (UNSPEC_PACKRL_PH\t\t357)\n+   (UNSPEC_EXTR_W\t\t358)\n+   (UNSPEC_EXTR_R_W\t\t359)\n+   (UNSPEC_EXTR_RS_W\t\t360)\n+   (UNSPEC_EXTR_S_H\t\t361)\n+   (UNSPEC_EXTP\t\t\t362)\n+   (UNSPEC_EXTPDP\t\t363)\n+   (UNSPEC_SHILO\t\t364)\n+   (UNSPEC_MTHLIP\t\t365)\n+   (UNSPEC_WRDSP\t\t366)\n+   (UNSPEC_RDDSP\t\t367)\n   ]\n )\n \n@@ -3124,8 +3194,8 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*movdi_32bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*x,*d,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*x,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -3242,15 +3312,15 @@\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,*J*d,*A,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,xfer,xfer,mthilo,xfer,load,xfer,store\")\n+  [(set_attr \"type\"\t\"arith,const,const,load,store,fmove,xfer,fpload,xfer,fpstore,xfer,xfer,mthilo,mfhilo,xfer,load,xfer,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,*,4,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,*,4,*\")])\n \n (define_insn \"*movsi_mips16\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,m\")\n@@ -5353,3 +5423,7 @@\n ; The MIPS Paired-Single Floating Point and MIPS-3D Instructions.\n \n (include \"mips-ps-3d.md\")\n+\n+; The MIPS DSP Instructions.\n+\n+(include \"mips-dsp.md\")"}, {"sha": "737f5edecb1881a06dcfcae824ae13544aa45702", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -55,6 +55,10 @@ mdouble-float\n Target Report RejectNegative InverseMask(SINGLE_FLOAT, DOUBLE_FLOAT)\n Allow hardware floating-point instructions to cover both 32-bit and 64-bit operations\n \n+mdsp\n+Target Report Mask(DSP)\n+Use MIPS-DSP instructions\n+\n mdebug\n Target Var(TARGET_DEBUG_MODE) Undocumented\n "}, {"sha": "e4e3805845f210d6460e3e4c7c529f47b28a1cf9", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -34,6 +34,18 @@\n   (ior (match_operand 0 \"const_arith_operand\")\n        (match_operand 0 \"register_operand\")))\n \n+(define_predicate \"const_uimm6_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"UIMM6_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"const_imm10_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IMM10_OPERAND (INTVAL (op))\")))\n+\n+(define_predicate \"reg_imm10_operand\"\n+  (ior (match_operand 0 \"const_imm10_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n (define_predicate \"sle_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"SMALL_OPERAND (INTVAL (op) + 1)\")))"}, {"sha": "7e137950065b4c0f278185c8706c095516c6260e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -5777,6 +5777,7 @@ instructions, but allow the compiler to schedule those calls.\n * Blackfin Built-in Functions::\n * FR-V Built-in Functions::\n * X86 Built-in Functions::\n+* MIPS DSP Built-in Functions::\n * MIPS Paired-Single Support::\n * PowerPC AltiVec Built-in Functions::\n * SPARC VIS Built-in Functions::\n@@ -6676,6 +6677,208 @@ v2sf __builtin_ia32_pswapdsf (v2sf)\n v2si __builtin_ia32_pswapdsi (v2si)\n @end smallexample\n \n+@node MIPS DSP Built-in Functions\n+@subsection MIPS DSP Built-in Functions\n+\n+The MIPS DSP Application-Specific Extension (ASE) includes new\n+instructions that are designed to improve the performance of DSP and\n+media applications.  It provides instructions that operate on packed\n+8-bit integer data, Q15 fractional data and Q31 fractional data.\n+\n+GCC supports MIPS DSP operations using both the generic\n+vector extensions (@pxref{Vector Extensions}) and a collection of\n+MIPS-specific built-in functions.  Both kinds of support are\n+enabled by the @option{-mdsp} command-line option.\n+\n+At present, GCC only provides support for operations on 32-bit\n+vectors.  The vector type associated with 8-bit integer data is\n+usually called @code{v4i8} and the vector type associated with Q15 is\n+usually called @code{v2q15}.  They can be defined in C as follows:\n+\n+@smallexample\n+typedef char v4i8 __attribute__ ((vector_size(4)));\n+typedef short v2q15 __attribute__ ((vector_size(4)));\n+@end smallexample\n+\n+@code{v4i8} and @code{v2q15} values are initialized in the same way as\n+aggregates.  For example:\n+\n+@smallexample\n+v4i8 a = @{1, 2, 3, 4@};\n+v4i8 b;\n+b = (v4i8) @{5, 6, 7, 8@};\n+\n+v2q15 c = @{0x0fcb, 0x3a75@};\n+v2q15 d;\n+d = (v2q15) @{0.1234 * 0x1.0p15, 0.4567 * 0x1.0p15@};\n+@end smallexample\n+\n+@emph{Note:} The CPU's endianness determines the order in which values\n+are packed.  On little-endian targets, the first value is the least\n+significant and the last value is the most significant.  The opposite\n+order applies to big-endian targets.  For example, the code above will\n+set the lowest byte of @code{a} to @code{1} on little-endian targets\n+and @code{4} on big-endian targets.\n+\n+@emph{Note:} Q15 and Q31 values must be initialized with their integer\n+representation.  As shown in this example, the integer representation\n+of a Q15 value can be obtained by multiplying the fractional value by\n+@code{0x1.0p15}.  The equivalent for Q31 values is to multiply by\n+@code{0x1.0p31}.\n+\n+The table below lists the @code{v4i8} and @code{v2q15} operations for which\n+hardware support exists.  @code{a} and @code{b} are @code{v4i8} values,\n+and @code{c} and @code{d} are @code{v2q15} values.\n+\n+@multitable @columnfractions .50 .50\n+@item C code @tab MIPS instruction\n+@item @code{a + b} @tab @code{addu.qb}\n+@item @code{c + d} @tab @code{addq.ph}\n+@item @code{a - b} @tab @code{subu.qb}\n+@item @code{c - d} @tab @code{subq.ph}\n+@end multitable\n+\n+It is easier to describe the DSP built-in functions if we first define\n+the following types:\n+\n+@smallexample\n+typedef int q31;\n+typedef int i32;\n+typedef long long a64;\n+@end smallexample\n+\n+@code{q31} and @code{i32} are actually the same as @code{int}, but we\n+use @code{q31} to indicate a Q31 fractional value and @code{i32} to\n+indicate a 32-bit integer value.  Similarly, @code{a64} is the same as\n+@code{long long}, but we use @code{a64} to indicate values that will\n+be placed in one of the four DSP accumulators (@code{$ac0},\n+@code{$ac1}, @code{$ac2} or @code{$ac3}).\n+\n+Also, some built-in functions prefer or require immediate numbers as\n+parameters, because the corresponding DSP instructions accept both immediate\n+numbers and register operands, or accept immediate numbers only.  The\n+immediate parameters are listed as follows.\n+\n+@smallexample\n+imm0_7: 0 to 7.\n+imm0_15: 0 to 15.\n+imm0_31: 0 to 31.\n+imm0_63: 0 to 63.\n+imm0_255: 0 to 255.\n+imm_n32_31: -32 to 31.\n+imm_n512_511: -512 to 511.\n+@end smallexample\n+\n+The following built-in functions map directly to a particular MIPS DSP\n+instruction.  Please refer to the architecture specification\n+for details on what each instruction does.\n+\n+@smallexample\n+v2q15 __builtin_mips_addq_ph (v2q15, v2q15)\n+v2q15 __builtin_mips_addq_s_ph (v2q15, v2q15)\n+q31 __builtin_mips_addq_s_w (q31, q31)\n+v4i8 __builtin_mips_addu_qb (v4i8, v4i8)\n+v4i8 __builtin_mips_addu_s_qb (v4i8, v4i8)\n+v2q15 __builtin_mips_subq_ph (v2q15, v2q15)\n+v2q15 __builtin_mips_subq_s_ph (v2q15, v2q15)\n+q31 __builtin_mips_subq_s_w (q31, q31)\n+v4i8 __builtin_mips_subu_qb (v4i8, v4i8)\n+v4i8 __builtin_mips_subu_s_qb (v4i8, v4i8)\n+i32 __builtin_mips_addsc (i32, i32)\n+i32 __builtin_mips_addwc (i32, i32)\n+i32 __builtin_mips_modsub (i32, i32)\n+i32 __builtin_mips_raddu_w_qb (v4i8)\n+v2q15 __builtin_mips_absq_s_ph (v2q15)\n+q31 __builtin_mips_absq_s_w (q31)\n+v4i8 __builtin_mips_precrq_qb_ph (v2q15, v2q15)\n+v2q15 __builtin_mips_precrq_ph_w (q31, q31)\n+v2q15 __builtin_mips_precrq_rs_ph_w (q31, q31)\n+v4i8 __builtin_mips_precrqu_s_qb_ph (v2q15, v2q15)\n+q31 __builtin_mips_preceq_w_phl (v2q15)\n+q31 __builtin_mips_preceq_w_phr (v2q15)\n+v2q15 __builtin_mips_precequ_ph_qbl (v4i8)\n+v2q15 __builtin_mips_precequ_ph_qbr (v4i8)\n+v2q15 __builtin_mips_precequ_ph_qbla (v4i8)\n+v2q15 __builtin_mips_precequ_ph_qbra (v4i8)\n+v2q15 __builtin_mips_preceu_ph_qbl (v4i8)\n+v2q15 __builtin_mips_preceu_ph_qbr (v4i8)\n+v2q15 __builtin_mips_preceu_ph_qbla (v4i8)\n+v2q15 __builtin_mips_preceu_ph_qbra (v4i8)\n+v4i8 __builtin_mips_shll_qb (v4i8, imm0_7)\n+v4i8 __builtin_mips_shll_qb (v4i8, i32)\n+v2q15 __builtin_mips_shll_ph (v2q15, imm0_15)\n+v2q15 __builtin_mips_shll_ph (v2q15, i32)\n+v2q15 __builtin_mips_shll_s_ph (v2q15, imm0_15)\n+v2q15 __builtin_mips_shll_s_ph (v2q15, i32)\n+q31 __builtin_mips_shll_s_w (q31, imm0_31)\n+q31 __builtin_mips_shll_s_w (q31, i32)\n+v4i8 __builtin_mips_shrl_qb (v4i8, imm0_7)\n+v4i8 __builtin_mips_shrl_qb (v4i8, i32)\n+v2q15 __builtin_mips_shra_ph (v2q15, imm0_15)\n+v2q15 __builtin_mips_shra_ph (v2q15, i32)\n+v2q15 __builtin_mips_shra_r_ph (v2q15, imm0_15)\n+v2q15 __builtin_mips_shra_r_ph (v2q15, i32)\n+q31 __builtin_mips_shra_r_w (q31, imm0_31)\n+q31 __builtin_mips_shra_r_w (q31, i32)\n+v2q15 __builtin_mips_muleu_s_ph_qbl (v4i8, v2q15)\n+v2q15 __builtin_mips_muleu_s_ph_qbr (v4i8, v2q15)\n+v2q15 __builtin_mips_mulq_rs_ph (v2q15, v2q15)\n+q31 __builtin_mips_muleq_s_w_phl (v2q15, v2q15)\n+q31 __builtin_mips_muleq_s_w_phr (v2q15, v2q15)\n+a64 __builtin_mips_dpau_h_qbl (a64, v4i8, v4i8)\n+a64 __builtin_mips_dpau_h_qbr (a64, v4i8, v4i8)\n+a64 __builtin_mips_dpsu_h_qbl (a64, v4i8, v4i8)\n+a64 __builtin_mips_dpsu_h_qbr (a64, v4i8, v4i8)\n+a64 __builtin_mips_dpaq_s_w_ph (a64, v2q15, v2q15)\n+a64 __builtin_mips_dpaq_sa_l_w (a64, q31, q31)\n+a64 __builtin_mips_dpsq_s_w_ph (a64, v2q15, v2q15)\n+a64 __builtin_mips_dpsq_sa_l_w (a64, q31, q31)\n+a64 __builtin_mips_mulsaq_s_w_ph (a64, v2q15, v2q15)\n+a64 __builtin_mips_maq_s_w_phl (a64, v2q15, v2q15)\n+a64 __builtin_mips_maq_s_w_phr (a64, v2q15, v2q15)\n+a64 __builtin_mips_maq_sa_w_phl (a64, v2q15, v2q15)\n+a64 __builtin_mips_maq_sa_w_phr (a64, v2q15, v2q15)\n+i32 __builtin_mips_bitrev (i32)\n+i32 __builtin_mips_insv (i32, i32)\n+v4i8 __builtin_mips_repl_qb (imm0_255)\n+v4i8 __builtin_mips_repl_qb (i32)\n+v2q15 __builtin_mips_repl_ph (imm_n512_511)\n+v2q15 __builtin_mips_repl_ph (i32)\n+void __builtin_mips_cmpu_eq_qb (v4i8, v4i8)\n+void __builtin_mips_cmpu_lt_qb (v4i8, v4i8)\n+void __builtin_mips_cmpu_le_qb (v4i8, v4i8)\n+i32 __builtin_mips_cmpgu_eq_qb (v4i8, v4i8)\n+i32 __builtin_mips_cmpgu_lt_qb (v4i8, v4i8)\n+i32 __builtin_mips_cmpgu_le_qb (v4i8, v4i8)\n+void __builtin_mips_cmp_eq_ph (v2q15, v2q15)\n+void __builtin_mips_cmp_lt_ph (v2q15, v2q15)\n+void __builtin_mips_cmp_le_ph (v2q15, v2q15)\n+v4i8 __builtin_mips_pick_qb (v4i8, v4i8)\n+v2q15 __builtin_mips_pick_ph (v2q15, v2q15)\n+v2q15 __builtin_mips_packrl_ph (v2q15, v2q15)\n+i32 __builtin_mips_extr_w (a64, imm0_31)\n+i32 __builtin_mips_extr_w (a64, i32)\n+i32 __builtin_mips_extr_r_w (a64, imm0_31)\n+i32 __builtin_mips_extr_s_h (a64, i32)\n+i32 __builtin_mips_extr_rs_w (a64, imm0_31)\n+i32 __builtin_mips_extr_rs_w (a64, i32)\n+i32 __builtin_mips_extr_s_h (a64, imm0_31)\n+i32 __builtin_mips_extr_r_w (a64, i32)\n+i32 __builtin_mips_extp (a64, imm0_31)\n+i32 __builtin_mips_extp (a64, i32)\n+i32 __builtin_mips_extpdp (a64, imm0_31)\n+i32 __builtin_mips_extpdp (a64, i32)\n+a64 __builtin_mips_shilo (a64, imm_n32_31)\n+a64 __builtin_mips_shilo (a64, i32)\n+a64 __builtin_mips_mthlip (a64, i32)\n+void __builtin_mips_wrdsp (i32, imm0_63)\n+i32 __builtin_mips_rddsp (imm0_63)\n+i32 __builtin_mips_lbux (void *, i32)\n+i32 __builtin_mips_lhx (void *, i32)\n+i32 __builtin_mips_lwx (void *, i32)\n+i32 __builtin_mips_bposge32 (void)\n+@end smallexample\n+\n @node MIPS Paired-Single Support\n @subsection MIPS Paired-Single Support\n "}, {"sha": "988f13b1dbd24809e6d64907933704c6135e13d9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -572,7 +572,7 @@ Objective-C and Objective-C++ Dialects}.\n -mips16  -mno-mips16  -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n -mxgot  -mno-xgot  -mgp32  -mgp64  -mfp32  -mfp64 @gol\n -mhard-float  -msoft-float  -msingle-float  -mdouble-float @gol\n--mpaired-single  -mips3d @gol\n+-mdsp  -mpaired-single  -mips3d @gol\n -mlong64  -mlong32  -msym32  -mno-sym32 @gol\n -G@var{num}  -membedded-data  -mno-embedded-data @gol\n -muninit-const-in-rodata  -mno-uninit-const-in-rodata @gol\n@@ -10065,6 +10065,12 @@ operations.\n Assume that the floating-point coprocessor supports double-precision\n operations.  This is the default.\n \n+@itemx -mdsp\n+@itemx -mno-dsp\n+@opindex mdsp\n+@opindex mno-dsp\n+Use (do not use) the MIPS DSP ASE.  @xref{MIPS DSP Built-in Functions}.\n+\n @itemx -mpaired-single\n @itemx -mno-paired-single\n @opindex mpaired-single"}, {"sha": "a14dccc70abe6bddc19cd3585454a352478b9206", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -1,3 +1,8 @@\n+2005-07-23  Chao-ying Fu  <fu@mips.com>\n+\n+\t* gcc.target/mips/mips32-dsp-type.c: New test.\n+\t* gcc.target/mips/mips32-dsp.c: New test.\n+\n 2005-07-23  Oyvind Harboe  <oyvind.harboe@zylin.com>\n \n \tPR testsuite/21073"}, {"sha": "030a9552c0c850214d335b89a34695e01f6e3ef3", "filename": "gcc/testsuite/gcc.target/mips/mips32-dsp-type.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp-type.c?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -0,0 +1,30 @@\n+/* Test MIPS32 DSP instructions */\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-mips32 -mdsp\" } */\n+/* { dg-final { scan-assembler \"addq.ph\" } } */\n+/* { dg-final { scan-assembler \"addu.qb\" } } */\n+/* { dg-final { scan-assembler \"subq.ph\" } } */\n+/* { dg-final { scan-assembler \"subu.qb\" } } */\n+\n+typedef char v4qi __attribute__ ((vector_size(4)));\n+typedef short v2hi __attribute__ ((vector_size(4)));\n+\n+v2hi add_v2hi (v2hi a, v2hi b)\n+{\n+  return a + b;\n+}\n+\n+v4qi add_v4qi (v4qi a, v4qi b)\n+{\n+  return a + b;\n+}\n+\n+v2hi sub_v2hi (v2hi a, v2hi b)\n+{\n+  return a - b;\n+}\n+\n+v4qi sub_v4qi (v4qi a, v4qi b)\n+{\n+  return a - b;\n+}"}, {"sha": "cc38c1b798a1f71f182b5b48639ccc6c4577a69f", "filename": "gcc/testsuite/gcc.target/mips/mips32-dsp.c", "status": "added", "additions": 1092, "deletions": 0, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/118ea793126f7e628d11de81cd4d100785e104e8/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32-dsp.c?ref=118ea793126f7e628d11de81cd4d100785e104e8", "patch": "@@ -0,0 +1,1092 @@\n+/* Test MIPS32 DSP instructions */\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-mips32 -mdsp\" } */\n+/* { dg-final { scan-assembler \"addq.ph\" } } */\n+/* { dg-final { scan-assembler \"addq_s.ph\" } } */\n+/* { dg-final { scan-assembler \"addq_s.w\" } } */\n+/* { dg-final { scan-assembler \"addu.qb\" } } */\n+/* { dg-final { scan-assembler \"addu_s.qb\" } } */\n+/* { dg-final { scan-assembler \"subq.ph\" } } */\n+/* { dg-final { scan-assembler \"subq_s.ph\" } } */\n+/* { dg-final { scan-assembler \"subq_s.w\" } } */\n+/* { dg-final { scan-assembler \"subu.qb\" } } */\n+/* { dg-final { scan-assembler \"subu_s.qb\" } } */\n+/* { dg-final { scan-assembler \"addsc\" } } */\n+/* { dg-final { scan-assembler \"addwc\" } } */\n+/* { dg-final { scan-assembler \"modsub\" } } */\n+/* { dg-final { scan-assembler \"raddu.w.qb\" } } */\n+/* { dg-final { scan-assembler \"absq_s.ph\" } } */\n+/* { dg-final { scan-assembler \"absq_s.w\" } } */\n+/* { dg-final { scan-assembler \"precrq.qb.ph\" } } */\n+/* { dg-final { scan-assembler \"precrq.ph.w\" } } */\n+/* { dg-final { scan-assembler \"precrq_rs.ph.w\" } } */\n+/* { dg-final { scan-assembler \"precrqu_s.qb.ph\" } } */\n+/* { dg-final { scan-assembler \"preceq.w.phl\" } } */\n+/* { dg-final { scan-assembler \"preceq.w.phr\" } } */\n+/* { dg-final { scan-assembler \"precequ.ph.qbl\" } } */\n+/* { dg-final { scan-assembler \"precequ.ph.qbr\" } } */\n+/* { dg-final { scan-assembler \"precequ.ph.qbla\" } } */\n+/* { dg-final { scan-assembler \"precequ.ph.qbra\" } } */\n+/* { dg-final { scan-assembler \"preceu.ph.qbl\" } } */\n+/* { dg-final { scan-assembler \"preceu.ph.qbr\" } } */\n+/* { dg-final { scan-assembler \"preceu.ph.qbla\" } } */\n+/* { dg-final { scan-assembler \"preceu.ph.qbra\" } } */\n+/* { dg-final { scan-assembler \"shllv?.qb\" } } */\n+/* { dg-final { scan-assembler \"shllv?.ph\" } } */\n+/* { dg-final { scan-assembler \"shllv?_s.ph\" } } */\n+/* { dg-final { scan-assembler \"shllv?_s.w\" } } */\n+/* { dg-final { scan-assembler \"shrlv?.qb\" } } */\n+/* { dg-final { scan-assembler \"shrav?.ph\" } } */\n+/* { dg-final { scan-assembler \"shrav?_r.ph\" } } */\n+/* { dg-final { scan-assembler \"shrav?_r.w\" } } */\n+/* { dg-final { scan-assembler \"muleu_s.ph.qbl\" } } */\n+/* { dg-final { scan-assembler \"muleu_s.ph.qbr\" } } */\n+/* { dg-final { scan-assembler \"mulq_rs.ph\" } } */\n+/* { dg-final { scan-assembler \"muleq_s.w.phl\" } } */\n+/* { dg-final { scan-assembler \"muleq_s.w.phr\" } } */\n+/* { dg-final { scan-assembler \"dpau.h.qbl\" } } */\n+/* { dg-final { scan-assembler \"dpau.h.qbr\" } } */\n+/* { dg-final { scan-assembler \"dpsu.h.qbl\" } } */\n+/* { dg-final { scan-assembler \"dpsu.h.qbr\" } } */\n+/* { dg-final { scan-assembler \"dpaq_s.w.ph\" } } */\n+/* { dg-final { scan-assembler \"dpsq_s.w.ph\" } } */\n+/* { dg-final { scan-assembler \"mulsaq_s.w.ph\" } } */\n+/* { dg-final { scan-assembler \"dpaq_sa.l.w\" } } */\n+/* { dg-final { scan-assembler \"dpsq_sa.l.w\" } } */\n+/* { dg-final { scan-assembler \"maq_s.w.phl\" } } */\n+/* { dg-final { scan-assembler \"maq_s.w.phr\" } } */\n+/* { dg-final { scan-assembler \"maq_sa.w.phl\" } } */\n+/* { dg-final { scan-assembler \"maq_sa.w.phr\" } } */\n+/* { dg-final { scan-assembler \"bitrev\" } } */\n+/* { dg-final { scan-assembler \"insv\" } } */\n+/* { dg-final { scan-assembler \"replv?.qb\" } } */\n+/* { dg-final { scan-assembler \"repl.ph\" } } */\n+/* { dg-final { scan-assembler \"replv.ph\" } } */\n+/* { dg-final { scan-assembler \"cmpu.eq.qb\" } } */\n+/* { dg-final { scan-assembler \"cmpu.lt.qb\" } } */\n+/* { dg-final { scan-assembler \"cmpu.le.qb\" } } */\n+/* { dg-final { scan-assembler \"cmpgu.eq.qb\" } } */\n+/* { dg-final { scan-assembler \"cmpgu.lt.qb\" } } */\n+/* { dg-final { scan-assembler \"cmpgu.le.qb\" } } */\n+/* { dg-final { scan-assembler \"cmp.eq.ph\" } } */\n+/* { dg-final { scan-assembler \"cmp.lt.ph\" } } */\n+/* { dg-final { scan-assembler \"cmp.le.ph\" } } */\n+/* { dg-final { scan-assembler \"pick.qb\" } } */\n+/* { dg-final { scan-assembler \"pick.ph\" } } */\n+/* { dg-final { scan-assembler \"packrl.ph\" } } */\n+/* { dg-final { scan-assembler \"extrv?.w\" } } */\n+/* { dg-final { scan-assembler \"extrv?_s.h\" } } */\n+/* { dg-final { scan-assembler \"extrv?_r.w\" } } */\n+/* { dg-final { scan-assembler \"extrv?_rs.w\" } } */\n+/* { dg-final { scan-assembler \"extpv?\" } } */\n+/* { dg-final { scan-assembler \"extpdpv?\" } } */\n+/* { dg-final { scan-assembler \"shilov?\" } } */\n+/* { dg-final { scan-assembler \"mthlip\" } } */\n+/* { dg-final { scan-assembler \"mfhi\" } } */\n+/* { dg-final { scan-assembler \"mflo\" } } */\n+/* { dg-final { scan-assembler \"mthi\" } } */\n+/* { dg-final { scan-assembler \"mtlo\" } } */\n+/* { dg-final { scan-assembler \"wrdsp\" } } */\n+/* { dg-final { scan-assembler \"rddsp\" } } */\n+/* { dg-final { scan-assembler \"lbux?\" } } */\n+/* { dg-final { scan-assembler \"lhx?\" } } */\n+/* { dg-final { scan-assembler \"lwx?\" } } */\n+/* { dg-final { scan-assembler \"bposge32\" } } */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+typedef char v4i8 __attribute__ ((vector_size(4)));\n+typedef short v2q15 __attribute__ ((vector_size(4)));\n+\n+typedef int q31;\n+typedef int i32;\n+typedef long long a64;\n+\n+void test_MIPS_DSP();\n+\n+char array[100];\n+int little_endian;\n+\n+int main()\n+{\n+  int i;\n+\n+  union { long long ll; int i[2]; } endianness_test;\n+  endianness_test.ll = 1;\n+  little_endian = endianness_test.i[0];\n+\n+  for (i = 0; i < 100; i++)\n+    array[i] = i;\n+\n+  test_MIPS_DSP();\n+\n+  exit (0);\n+}\n+\n+v2q15 add_v2q15 (v2q15 a, v2q15 b)\n+{\n+  return __builtin_mips_addq_ph (a, b);\n+}\n+\n+v4i8 add_v4i8 (v4i8 a, v4i8 b)\n+{\n+  return __builtin_mips_addu_qb (a, b);\n+}\n+\n+v2q15 sub_v2q15 (v2q15 a, v2q15 b)\n+{\n+  return __builtin_mips_subq_ph (a, b);\n+}\n+\n+v4i8 sub_v4i8 (v4i8 a, v4i8 b)\n+{\n+  return __builtin_mips_subu_qb (a, b);\n+}\n+\n+void test_MIPS_DSP()\n+{\n+  v4i8 v4i8_a,v4i8_b,v4i8_c,v4i8_r,v4i8_s;\n+  v2q15 v2q15_a,v2q15_b,v2q15_c,v2q15_r,v2q15_s;\n+  q31 q31_a,q31_b,q31_c,q31_r,q31_s;\n+  i32 i32_a,i32_b,i32_c,i32_r,i32_s;\n+  a64 a64_a,a64_b,a64_c,a64_r,a64_s;\n+\n+  void *ptr_a;\n+  int r,s;\n+  long long lr,ls;\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  v2q15_s = (v2q15) {0x81bd, 0x6789};\n+  v2q15_r = add_v2q15 (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  v2q15_s = (v2q15) {0x7fff, 0x6789};\n+  v2q15_r = __builtin_mips_addq_s_ph (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x70000000;\n+  q31_b = 0x71234567;\n+  q31_s = 0x7fffffff;\n+  q31_r = __builtin_mips_addq_s_w (q31_a, q31_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0xff, 0x89, 0x11, 0x11};\n+  v4i8_s = (v4i8) {0xf1, 0xbd, 0x67, 0x89};\n+  v4i8_r = add_v4i8 (v4i8_a, v4i8_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0xff, 0x89, 0x11, 0x11};\n+  v4i8_s = (v4i8) {0xff, 0xbd, 0x67, 0x89};\n+  v4i8_r = __builtin_mips_addu_s_qb (v4i8_a, v4i8_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  v2q15_s = (v2q15) {0xa2ab, 0x4567};\n+  v2q15_r = sub_v2q15 (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x8000, 0x5678};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  v2q15_s = (v2q15) {0x8000, 0x4567};\n+  v2q15_r = __builtin_mips_subq_s_ph (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x70000000;\n+  q31_b = 0x71234567;\n+  q31_s = 0xfedcba99;\n+  q31_r = __builtin_mips_subq_s_w (q31_a, q31_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0xff, 0x89, 0x11, 0x11};\n+  v4i8_s = (v4i8) {0xf3, 0xab, 0x45, 0x67};\n+  v4i8_r = sub_v4i8 (v4i8_a, v4i8_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0xff, 0x89, 0x11, 0x11};\n+  v4i8_s = (v4i8) {0x0, 0x0, 0x45, 0x67};\n+  v4i8_r = __builtin_mips_subu_s_qb (v4i8_a, v4i8_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  i32_a = 0xf5678900;\n+  i32_b = 0x7abcdef0;\n+  i32_s = 0x702467f0;\n+  i32_r = __builtin_mips_addsc (i32_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x75678900;\n+  i32_b = 0x7abcdef0;\n+  i32_s = 0xf02467f1;\n+  i32_r = __builtin_mips_addwc (i32_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0;\n+  i32_b = 0x00000901;\n+  i32_s = 9;\n+  i32_r = __builtin_mips_modsub (i32_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  i32_s = 0x1f4;\n+  i32_r = __builtin_mips_raddu_w_qb (v4i8_a);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x8000, 0x8134};\n+  v2q15_s = (v2q15) {0x7fff, 0x7ecc};\n+  v2q15_r = __builtin_mips_absq_s_ph (v2q15_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = (q31) 0x80000000;\n+  q31_s = (q31) 0x7fffffff;\n+  q31_r = __builtin_mips_absq_s_w (q31_a);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x9999, 0x5612};\n+  v2q15_b = (v2q15) {0x5612, 0x3333};\n+  if (little_endian)\n+    v4i8_s = (v4i8) {0x56, 0x33, 0x99, 0x56};\n+  else\n+    v4i8_s = (v4i8) {0x99, 0x56, 0x56, 0x33};\n+  v4i8_r = __builtin_mips_precrq_qb_ph (v2q15_a, v2q15_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x12348678;\n+  q31_b = 0x44445555;\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x4444, 0x1234};\n+  else\n+    v2q15_s = (v2q15) {0x1234, 0x4444};\n+  v2q15_r = __builtin_mips_precrq_ph_w (q31_a, q31_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x12348678;\n+  q31_b = 0x44445555;\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x4444, 0x1235};\n+  else\n+    v2q15_s = (v2q15) {0x1235, 0x4444};\n+  v2q15_r = __builtin_mips_precrq_rs_ph_w (q31_a, q31_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x9999, 0x5612};\n+  v2q15_b = (v2q15) {0x5612, 0x3333};\n+  if (little_endian)\n+    v4i8_s = (v4i8) {0xac, 0x66, 0x00, 0xac};\n+  else\n+    v4i8_s = (v4i8) {0x00, 0xac, 0xac, 0x66};\n+  v4i8_r = __builtin_mips_precrqu_s_qb_ph (v2q15_a, v2q15_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x3589, 0x4444};\n+  if (little_endian)\n+    q31_s = 0x44440000;\n+  else\n+    q31_s = 0x35890000;\n+  q31_r = __builtin_mips_preceq_w_phl (v2q15_a);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x3589, 0x4444};\n+  if (little_endian)\n+    q31_s = 0x35890000;\n+  else\n+    q31_s = 0x44440000;\n+  q31_r = __builtin_mips_preceq_w_phr (v2q15_a);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x2b00, 0x1980};\n+  else\n+    v2q15_s = (v2q15) {0x0900, 0x2b00};\n+  v2q15_r = __builtin_mips_precequ_ph_qbl (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x0900, 0x2b00};\n+  else\n+    v2q15_s = (v2q15) {0x2b00, 0x1980};\n+  v2q15_r = __builtin_mips_precequ_ph_qbr (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x2b00, 0x1980};\n+  else\n+    v2q15_s = (v2q15) {0x0900, 0x2b00};\n+  v2q15_r = __builtin_mips_precequ_ph_qbla (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x0900, 0x2b00};\n+  else\n+    v2q15_s = (v2q15) {0x2b00, 0x1980};\n+  v2q15_r = __builtin_mips_precequ_ph_qbra (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x56, 0x33};\n+  else\n+    v2q15_s = (v2q15) {0x12, 0x56};\n+  v2q15_r = __builtin_mips_preceu_ph_qbl (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x56, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x12, 0x56};\n+  else\n+    v2q15_s = (v2q15) {0x56, 0x33};\n+  v2q15_r = __builtin_mips_preceu_ph_qbr (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x99, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x99, 0x33};\n+  else\n+    v2q15_s = (v2q15) {0x12, 0x56};\n+  v2q15_r = __builtin_mips_preceu_ph_qbla (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x99, 0x56, 0x33};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x12, 0x56};\n+  else\n+    v2q15_s = (v2q15) {0x99, 0x33};\n+  v2q15_r = __builtin_mips_preceu_ph_qbra (v4i8_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_s = (v4i8) {0xc8, 0xd0, 0x58, 0xe0};\n+  v4i8_r = __builtin_mips_shll_qb (v4i8_a, 2);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  i32_b = 1;\n+  v4i8_s = (v4i8) {0xe4, 0x68, 0xac, 0xf0};\n+  v4i8_r = __builtin_mips_shll_qb (v4i8_a, i32_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_s = (v2q15) {0x48d0, 0x59e0};\n+  v2q15_r = __builtin_mips_shll_ph (v2q15_a, 2);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  i32_b = 1;\n+  v2q15_s = (v2q15) {0x2468, 0xacf0};\n+  v2q15_r = __builtin_mips_shll_ph (v2q15_a, i32_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_s = (v2q15) {0x48d0, 0x7fff};\n+  v2q15_r = __builtin_mips_shll_s_ph (v2q15_a, 2);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  i32_b = 1;\n+  v2q15_s = (v2q15) {0x2468, 0x7fff};\n+  v2q15_r = __builtin_mips_shll_s_ph (v2q15_a, i32_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x70000000;\n+  q31_s = 0x7fffffff;\n+  q31_r = __builtin_mips_shll_s_w (q31_a, 2);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  q31_a = 0x70000000;\n+  i32_b = 1;\n+  q31_s = 0x7fffffff;\n+  q31_r = __builtin_mips_shll_s_w (q31_a, i32_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  v4i8_s = (v4i8) {0x3c, 0xd, 0x15, 0x1e};\n+  v4i8_r = __builtin_mips_shrl_qb (v4i8_a, 2);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0xf2, 0x34, 0x56, 0x78};\n+  i32_b = 1;\n+  v4i8_s = (v4i8) {0x79, 0x1a, 0x2b, 0x3c};\n+  v4i8_r = __builtin_mips_shrl_qb (v4i8_a, i32_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_s = (v2q15) {0x48d, 0x159e};\n+  v2q15_r = __builtin_mips_shra_ph (v2q15_a, 2);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  i32_b = 1;\n+  v2q15_s = (v2q15) {0x91a, 0x2b3c};\n+  v2q15_r = __builtin_mips_shra_ph (v2q15_a, i32_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_s = (v2q15) {0x48d, 0x159e};\n+  v2q15_r = __builtin_mips_shra_r_ph (v2q15_a, 2);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  i32_b = 3;\n+  v2q15_s = (v2q15) {0x247, 0xacf};\n+  v2q15_r = __builtin_mips_shra_r_ph (v2q15_a, i32_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  q31_a = 0x70000000;\n+  q31_s = 0x1c000000;\n+  q31_r = __builtin_mips_shra_r_w (q31_a, 2);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  q31_a = 0x70000004;\n+  i32_b = 3;\n+  q31_s = 0x0e000001;\n+  q31_r = __builtin_mips_shra_r_w (q31_a, i32_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x1, 0x2, 0x3, 0x4};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0xffff, 0x4444};\n+  else\n+    v2q15_s = (v2q15) {0x6f89, 0x2222};\n+  v2q15_r = __builtin_mips_muleu_s_ph_qbl (v4i8_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x1, 0x2, 0x3, 0x4};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x6f89, 0x2222};\n+  else\n+    v2q15_s = (v2q15) {0xffff, 0x4444};\n+  v2q15_r = __builtin_mips_muleu_s_ph_qbr (v4i8_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x6f89, 0x1111};\n+  v2q15_s = (v2q15) {0x0fdd, 0x0b87};\n+  v2q15_r = __builtin_mips_mulq_rs_ph (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x8000, 0x8000};\n+  v2q15_b = (v2q15) {0x8000, 0x8000};\n+  q31_s = 0x7fffffff;\n+  q31_r = __builtin_mips_muleq_s_w_phl (v2q15_a, v2q15_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x8000, 0x8000};\n+  v2q15_b = (v2q15) {0x8000, 0x8000};\n+  q31_s = 0x7fffffff;\n+  q31_r = __builtin_mips_muleq_s_w_phr (v2q15_a, v2q15_b);\n+  if(q31_r != q31_s)\n+    abort ();\n+\n+#ifndef __mips64\n+  a64_a = 0x22221111;\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_c = (v4i8) {0xaa, 0x89, 0x11, 0x34};\n+  if (little_endian)\n+    a64_s = 0x22222f27;\n+  else\n+    a64_s = 0x222238d9;\n+  a64_r = __builtin_mips_dpau_h_qbl (a64_a, v4i8_b, v4i8_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x22221111;\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_c = (v4i8) {0xaa, 0x89, 0x11, 0x34};\n+  if (little_endian)\n+    a64_s = 0x222238d9;\n+  else\n+    a64_s = 0x22222f27;\n+  a64_r = __builtin_mips_dpau_h_qbr (a64_a, v4i8_b, v4i8_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x22221111;\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_c = (v4i8) {0xaa, 0x89, 0x11, 0x34};\n+  if (little_endian)\n+    a64_s = 0x2221f2fb;\n+  else\n+    a64_s = 0x2221e949;\n+  a64_r = __builtin_mips_dpsu_h_qbl (a64_a, v4i8_b, v4i8_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x22221111;\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_c = (v4i8) {0xaa, 0x89, 0x11, 0x34};\n+  if (little_endian)\n+    a64_s = 0x2221e949;\n+  else\n+    a64_s = 0x2221f2fb;\n+  a64_r = __builtin_mips_dpsu_h_qbr (a64_a, v4i8_b, v4i8_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x5678};\n+  v2q15_c = (v2q15) {0x8000, 0x1111};\n+  a64_s = 0x8b877d00;\n+  a64_r = __builtin_mips_dpaq_s_w_ph (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x5678};\n+  v2q15_c = (v2q15) {0x8000, 0x1111};\n+  a64_s = 0xffffffff7478a522LL;\n+  a64_r = __builtin_mips_dpsq_s_w_ph (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x5678};\n+  v2q15_c = (v2q15) {0x8000, 0x1111};\n+  if (little_endian)\n+    a64_s = 0xffffffff8b877d02LL;\n+  else\n+    a64_s = 0x7478a520;\n+  a64_r = __builtin_mips_mulsaq_s_w_ph (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  q31_b = 0x80000000;\n+  q31_c = 0x80000000;\n+  a64_s = 0x7fffffffffffffffLL;\n+  a64_r = __builtin_mips_dpaq_sa_l_w (a64_a, q31_b, q31_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  q31_b = 0x80000000;\n+  q31_c = 0x80000000;\n+  a64_s = 0x8000000000001112LL;\n+  a64_r = __builtin_mips_dpsq_sa_l_w (a64_a, q31_b, q31_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x1};\n+  v2q15_c = (v2q15) {0x8000, 0x2};\n+  if (little_endian)\n+    a64_s = 0x1115;\n+  else\n+    a64_s = 0x80001110;\n+  a64_r = __builtin_mips_maq_s_w_phl (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x1};\n+  v2q15_c = (v2q15) {0x8000, 0x2};\n+  if (little_endian)\n+    a64_s = 0x80001110;\n+  else\n+    a64_s = 0x1115;\n+  a64_r = __builtin_mips_maq_s_w_phr (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x1};\n+  v2q15_c = (v2q15) {0x8000, 0x2};\n+  if (little_endian)\n+    a64_s = 0x1115;\n+  else\n+    a64_s = 0x7fffffff;\n+  a64_r = __builtin_mips_maq_sa_w_phl (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x00001111;\n+  v2q15_b = (v2q15) {0x8000, 0x1};\n+  v2q15_c = (v2q15) {0x8000, 0x2};\n+  if (little_endian)\n+    a64_s = 0x7fffffff;\n+  else\n+    a64_s = 0x1115;\n+  a64_r = __builtin_mips_maq_sa_w_phr (a64_a, v2q15_b, v2q15_c);\n+  if(a64_r != a64_s)\n+    abort ();\n+#endif\n+\n+  i32_a = 0x12345678;\n+  i32_s = 0x00001e6a;\n+  i32_r = __builtin_mips_bitrev (i32_a);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x00000208; // pos is 8, size is 4\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  i32_a = 0x12345678;\n+  i32_b = 0x87654321;\n+  i32_s = 0x12345178;\n+  i32_r = __builtin_mips_insv (i32_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_s = (v4i8) {1, 1, 1, 1};\n+  v4i8_r = __builtin_mips_repl_qb (1);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  i32_a = 99;\n+  v4i8_s = (v4i8) {99, 99, 99, 99};\n+  v4i8_r = __builtin_mips_repl_qb (i32_a);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_s = (v2q15) {30, 30};\n+  v2q15_r = __builtin_mips_repl_ph (30);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  i32_a = 0x5612;\n+  v2q15_s = (v2q15) {0x5612, 0x5612};\n+  v2q15_r = __builtin_mips_repl_ph (i32_a);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x03000000;\n+  else\n+    i32_s = 0x0c000000;\n+  __builtin_mips_cmpu_eq_qb (v4i8_a, v4i8_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x04000000;\n+  else\n+    i32_s = 0x02000000;\n+  __builtin_mips_cmpu_lt_qb (v4i8_a, v4i8_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x07000000;\n+  else\n+    i32_s = 0x0e000000;\n+  __builtin_mips_cmpu_le_qb (v4i8_a, v4i8_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x3;\n+  else\n+    i32_s = 0xc;\n+  i32_r=__builtin_mips_cmpgu_eq_qb (v4i8_a, v4i8_b);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x4;\n+  else\n+    i32_s = 0x2;\n+  i32_r = __builtin_mips_cmpgu_lt_qb (v4i8_a, v4i8_b);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x12, 0x34, 0x78, 0x56};\n+  if (little_endian)\n+    i32_s = 0x7;\n+  else\n+    i32_s = 0xe;\n+  i32_r = __builtin_mips_cmpgu_le_qb (v4i8_a, v4i8_b);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  __builtin_mips_wrdsp (0,31); // Clear all condition code bits.\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x1234, 0x7856};\n+  if (little_endian)\n+    i32_s = 0x01000000;\n+  else\n+    i32_s = 0x02000000;\n+  __builtin_mips_cmp_eq_ph (v2q15_a, v2q15_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x1234, 0x7856};\n+  if (little_endian)\n+    i32_s = 0x02000000;\n+  else\n+    i32_s = 0x01000000;\n+  __builtin_mips_cmp_lt_ph (v2q15_a, v2q15_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x1234, 0x7856};\n+  i32_s = 0x03000000;\n+  __builtin_mips_cmp_le_ph (v2q15_a, v2q15_b);\n+  i32_r = __builtin_mips_rddsp (16);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x0a000000; // cc: 0000 1010\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  v4i8_a = (v4i8) {0x12, 0x34, 0x56, 0x78};\n+  v4i8_b = (v4i8) {0x21, 0x43, 0x65, 0x87};\n+  if (little_endian)\n+    v4i8_s = (v4i8) {0x21, 0x34, 0x65, 0x78};\n+  else\n+    v4i8_s = (v4i8) {0x12, 0x43, 0x56, 0x87};\n+  v4i8_r = __builtin_mips_pick_qb (v4i8_a, v4i8_b);\n+  r = (int) v4i8_r;\n+  s = (int) v4i8_s;\n+  if(r != s)\n+    abort ();\n+\n+  i32_a = 0x02000000; // cc: 0000 0010\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x2143, 0x6587};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x2143, 0x5678};\n+  else\n+    v2q15_s = (v2q15) {0x1234, 0x6587};\n+  v2q15_r = __builtin_mips_pick_ph (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+  v2q15_a = (v2q15) {0x1234, 0x5678};\n+  v2q15_b = (v2q15) {0x1234, 0x7856};\n+  if (little_endian)\n+    v2q15_s = (v2q15) {0x7856, 0x1234};\n+  else\n+    v2q15_s = (v2q15) {0x5678, 0x1234};\n+  v2q15_r = __builtin_mips_packrl_ph (v2q15_a, v2q15_b);\n+  r = (int) v2q15_r;\n+  s = (int) v2q15_s;\n+  if(r != s)\n+    abort ();\n+\n+#ifndef __mips64\n+  a64_a = 0x1234567887654321LL;\n+  i32_s = 0x88765432;\n+  i32_r = __builtin_mips_extr_w (a64_a, 4);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887658321LL;\n+  i32_s = 0x56788766;\n+  i32_r = __builtin_mips_extr_r_w (a64_a, 16);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x12345677fffffff8LL;\n+  i32_s = 0x7fffffff;\n+  i32_r = __builtin_mips_extr_rs_w (a64_a, 4);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887658321LL;\n+  i32_s = 0x7fff;\n+  i32_r = __builtin_mips_extr_s_h (a64_a, 16);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x0000007887658321LL;\n+  i32_b = 24;\n+  i32_s = 0x7887;\n+  i32_r = __builtin_mips_extr_s_h (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887654321LL;\n+  i32_b = 4;\n+  i32_s = 0x88765432;\n+  i32_r = __builtin_mips_extr_w (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887658321LL;\n+  i32_b = 16;\n+  i32_s = 0x56788766;\n+  i32_r = __builtin_mips_extr_r_w (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x12345677fffffff8LL;\n+  i32_b = 4;\n+  i32_s = 0x7fffffff;\n+  i32_r = __builtin_mips_extr_rs_w (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x0000021f; // pos is 31\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  a64_a = 0x1234567887654321LL;\n+  i32_s = 8;\n+  i32_r = __builtin_mips_extp (a64_a, 3); // extract 4 bits\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x0000021f; // pos is 31\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  a64_a = 0x1234567887654321LL;\n+  i32_b = 7; // size is 8. NOTE!! we should use 7\n+  i32_s = 0x87;\n+  i32_r = __builtin_mips_extp (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x0000021f; // pos is 31\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  a64_a = 0x1234567887654321LL;\n+  i32_s = 8;\n+  i32_r = __builtin_mips_extpdp (a64_a, 3); // extract 4 bits\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_s = 0x0000021b; // pos is 27\n+  i32_r = __builtin_mips_rddsp (31);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x0000021f; // pos is 31\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  a64_a = 0x1234567887654321LL;\n+  i32_b = 11; // size is 12. NOTE!!! We should use 11\n+  i32_s = 0x876;\n+  i32_r = __builtin_mips_extpdp (a64_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_s = 0x00000213; // pos is 19\n+  i32_r = __builtin_mips_rddsp (31);\n+  if (i32_r != i32_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887654321LL;\n+  a64_s = 0x0012345678876543LL;\n+  a64_r = __builtin_mips_shilo (a64_a, 8);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  a64_a = 0x1234567887654321LL;\n+  i32_b = -16;\n+  a64_s = 0x5678876543210000LL;\n+  a64_r = __builtin_mips_shilo (a64_a, i32_b);\n+  if(a64_r != a64_s)\n+    abort ();\n+\n+  i32_a = 0x0;\n+  __builtin_mips_wrdsp (i32_a, 31);\n+  a64_a = 0x1234567887654321LL;\n+  i32_b = 0x11112222;\n+  a64_s = 0x8765432111112222LL;\n+  a64_r = __builtin_mips_mthlip (a64_a, i32_b);\n+  if(a64_r != a64_s)\n+    abort ();\n+  i32_s = 32;\n+  i32_r = __builtin_mips_rddsp (31);\n+  if(i32_r != i32_s)\n+    abort ();\n+#endif\n+\n+  i32_a = 0x1357a468;\n+  __builtin_mips_wrdsp (i32_a, 63);\n+  i32_s = 0x03572428;\n+  i32_r = __builtin_mips_rddsp (63);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  ptr_a = &array;\n+  i32_b = 37;\n+  i32_s = 37;\n+  i32_r = __builtin_mips_lbux (ptr_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  ptr_a = &array;\n+  i32_b = 38;\n+  if (little_endian)\n+    i32_s = 0x2726;\n+  else\n+    i32_s = 0x2627;\n+  i32_r = __builtin_mips_lhx (ptr_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  ptr_a = &array;\n+  i32_b = 40;\n+  if (little_endian)\n+    i32_s = 0x2b2a2928;\n+  else\n+    i32_s = 0x28292a2b;\n+  i32_r = __builtin_mips_lwx (ptr_a, i32_b);\n+  if(i32_r != i32_s)\n+    abort ();\n+\n+  i32_a = 0x00000220; // pos is 32, size is 4\n+  __builtin_mips_wrdsp (i32_a, 63);\n+  i32_s = 1;\n+  i32_r = __builtin_mips_bposge32 ();\n+  if(i32_r != i32_s)\n+    abort ();\n+}\n+"}]}