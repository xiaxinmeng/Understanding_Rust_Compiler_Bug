{"sha": "70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBhNmIxN2U4NDZkNTQzYmZhZjUzNWIwOWRkNjNmMzZhYzgwZDRiZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-09-09T15:04:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-09-09T15:04:27Z"}, "message": "re PR tree-optimization/41101 (ICE in compute_antic, at tree-ssa-pre.c:2419)\n\n2009-09-09  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/41101\n\t* tree-ssa-pre.c (maximal_set): Remove.\n\t(compute_antic_aux): Treat the maximal set as implicitly all ones.\n\tDefer all blocks we didn't visit at least one successor.\n\t(add_to_exp_gen): Do not add to the maximal set.\n\t(make_values_for_phi): Likewise.\n\t(compute_avail): Likewise.\n\t(init_pre): Do not allocate the maximal set.\n\t(execute_pre): Do not dump it.\n\n\t* gcc.c-torture/compile/pr41101.c: New testcase.\n\nFrom-SVN: r151561", "tree": {"sha": "d2c69da4c7c91e01f3cb69c83d462844bdd5fa86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2c69da4c7c91e01f3cb69c83d462844bdd5fa86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7648edc4d3f8411a1e6dca4e62633db3337ae5f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7648edc4d3f8411a1e6dca4e62633db3337ae5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7648edc4d3f8411a1e6dca4e62633db3337ae5f3"}], "stats": {"total": 111, "additions": 62, "deletions": 49}, "files": [{"sha": "1035493108c35950ee014e6f4eb80418782ae044", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "patch": "@@ -1,3 +1,15 @@\n+2009-09-09  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/41101\n+\t* tree-ssa-pre.c (maximal_set): Remove.\n+\t(compute_antic_aux): Treat the maximal set as implicitly all ones.\n+\tDefer all blocks we didn't visit at least one successor.\n+\t(add_to_exp_gen): Do not add to the maximal set.\n+\t(make_values_for_phi): Likewise.\n+\t(compute_avail): Likewise.\n+\t(init_pre): Do not allocate the maximal set.\n+\t(execute_pre): Do not dump it.\n+\n 2009-09-09  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-cfg.c (verify_gimple_phi): Check that gimple_phi_result is"}, {"sha": "b8aa7566dd5050b34e55a28ea9542b2220b03ecb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "patch": "@@ -1,3 +1,8 @@\n+2009-09-09  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/41101\n+\t* gcc.c-torture/compile/pr41101.c: New testcase.\n+\n 2009-09-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/41317"}, {"sha": "8d21a00ce8a4e5d031808651d42cb62a9d87020d", "filename": "gcc/testsuite/gcc.c-torture/compile/pr41101.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr41101.c?ref=70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "patch": "@@ -0,0 +1,19 @@\n+int func(int);\n+\n+void\n+bug(int* x, int* y, unsigned long int N)\n+{\n+  unsigned long int i;\n+  int* t;\n+\n+  while (1)\n+    {\n+      for (i=1; i<=N; i++)\n+\t{\n+\t  y[i] = func(x[i] - x[1]);\n+\t  if (y[i])\n+\t    return;\n+\t}\n+      t=x; x=y; y=t;\n+    }\n+}"}, {"sha": "267aeb5e2fde48c852b69b0fb05288a378bc08ee", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70a6b17e846d543bfaf535b09dd63f36ac80d4bd/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=70a6b17e846d543bfaf535b09dd63f36ac80d4bd", "patch": "@@ -401,10 +401,6 @@ typedef struct bb_bitmap_sets\n #define BB_DEFERRED(BB) ((bb_value_sets_t) ((BB)->aux))->deferred\n \n \n-/* Maximal set of values, used to initialize the ANTIC problem, which\n-   is an intersection problem.  */\n-static bitmap_set_t maximal_set;\n-\n /* Basic block list in postorder.  */\n static int *postorder;\n \n@@ -2201,49 +2197,45 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n     {\n       VEC(basic_block, heap) * worklist;\n       size_t i;\n-      basic_block bprime, first;\n+      basic_block bprime, first = NULL;\n \n       worklist = VEC_alloc (basic_block, heap, EDGE_COUNT (block->succs));\n       FOR_EACH_EDGE (e, ei, block->succs)\n-\tVEC_quick_push (basic_block, worklist, e->dest);\n-      first = VEC_index (basic_block, worklist, 0);\n-\n-      if (phi_nodes (first))\n \t{\n-\t  bitmap_set_t from = ANTIC_IN (first);\n-\n-\t  if (!BB_VISITED (first))\n-\t    from = maximal_set;\n-\t  phi_translate_set (ANTIC_OUT, from, block, first);\n+\t  if (!first\n+\t      && BB_VISITED (e->dest))\n+\t    first = e->dest;\n+\t  else if (BB_VISITED (e->dest))\n+\t    VEC_quick_push (basic_block, worklist, e->dest);\n \t}\n-      else\n+\n+      /* Of multiple successors we have to have visited one already.  */\n+      if (!first)\n \t{\n-\t  if (!BB_VISITED (first))\n-\t    bitmap_set_copy (ANTIC_OUT, maximal_set);\n-\t  else\n-\t    bitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\t  SET_BIT (changed_blocks, block->index);\n+\t  BB_VISITED (block) = 0;\n+\t  BB_DEFERRED (block) = 1;\n+\t  changed = true;\n+\t  VEC_free (basic_block, heap, worklist);\n+\t  goto maybe_dump_sets;\n \t}\n \n-      for (i = 1; VEC_iterate (basic_block, worklist, i, bprime); i++)\n+      if (phi_nodes (first))\n+\tphi_translate_set (ANTIC_OUT, ANTIC_IN (first), block, first);\n+      else\n+\tbitmap_set_copy (ANTIC_OUT, ANTIC_IN (first));\n+\n+      for (i = 0; VEC_iterate (basic_block, worklist, i, bprime); i++)\n \t{\n \t  if (phi_nodes (bprime))\n \t    {\n \t      bitmap_set_t tmp = bitmap_set_new ();\n-\t      bitmap_set_t from = ANTIC_IN (bprime);\n-\n-\t      if (!BB_VISITED (bprime))\n-\t\tfrom = maximal_set;\n-\t      phi_translate_set (tmp, from, block, bprime);\n+\t      phi_translate_set (tmp, ANTIC_IN (bprime), block, bprime);\n \t      bitmap_set_and (ANTIC_OUT, tmp);\n \t      bitmap_set_free (tmp);\n \t    }\n \t  else\n-\t    {\n-\t      if (!BB_VISITED (bprime))\n-\t\tbitmap_set_and (ANTIC_OUT, maximal_set);\n-\t      else\n-\t\tbitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n-\t    }\n+\t    bitmap_set_and (ANTIC_OUT, ANTIC_IN (bprime));\n \t}\n       VEC_free (basic_block, heap, worklist);\n     }\n@@ -3711,7 +3703,6 @@ add_to_exp_gen (basic_block block, tree op)\n \treturn;\n       result = get_or_alloc_expr_for_name (op);\n       bitmap_value_insert_into_set (EXP_GEN (block), result);\n-      bitmap_value_insert_into_set (maximal_set, result);\n     }\n }\n \n@@ -3740,7 +3731,6 @@ make_values_for_phi (gimple phi, basic_block block)\n \t\t{\n \t\t  e = get_or_alloc_expr_for_name (arg);\n \t\t  add_to_value (get_expr_value_id (e), e);\n-\t\t  bitmap_value_insert_into_set (maximal_set, e);\n \t\t}\n \t    }\n \t}\n@@ -3781,10 +3771,7 @@ compute_avail (void)\n       e = get_or_alloc_expr_for_name (name);\n       add_to_value (get_expr_value_id (e), e);\n       if (!in_fre)\n-\t{\n-\t  bitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), e);\n-\t  bitmap_value_insert_into_set (maximal_set, e);\n-\t}\n+\tbitmap_insert_into_set (TMP_GEN (ENTRY_BLOCK_PTR), e);\n       bitmap_value_insert_into_set (AVAIL_OUT (ENTRY_BLOCK_PTR), e);\n     }\n \n@@ -3888,11 +3875,7 @@ compute_avail (void)\n \t\tget_or_alloc_expression_id (result);\n \t\tadd_to_value (get_expr_value_id (result), result);\n \t\tif (!in_fre)\n-\t\t  {\n-\t\t    bitmap_value_insert_into_set (EXP_GEN (block),\n-\t\t\t\t\t\t  result);\n-\t\t    bitmap_value_insert_into_set (maximal_set, result);\n-\t\t  }\n+\t\t  bitmap_value_insert_into_set (EXP_GEN (block), result);\n \t\tcontinue;\n \t      }\n \n@@ -3974,10 +3957,7 @@ compute_avail (void)\n \t\tget_or_alloc_expression_id (result);\n \t\tadd_to_value (get_expr_value_id (result), result);\n \t\tif (!in_fre)\n-\t\t  {\n-\t\t    bitmap_value_insert_into_set (EXP_GEN (block), result);\n-\t\t    bitmap_value_insert_into_set (maximal_set, result);\n-\t\t  }\n+\t\t  bitmap_value_insert_into_set (EXP_GEN (block), result);\n \n \t\tcontinue;\n \t      }\n@@ -4515,7 +4495,6 @@ init_pre (bool do_fre)\n       TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n-  maximal_set = in_fre ? NULL : bitmap_set_new ();\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n }\n@@ -4601,8 +4580,6 @@ execute_pre (bool do_fre ATTRIBUTE_UNUSED)\n \t  print_bitmap_set (dump_file, TMP_GEN (bb), \"tmp_gen\", bb->index);\n \t  print_bitmap_set (dump_file, AVAIL_OUT (bb), \"avail_out\", bb->index);\n \t}\n-\n-      print_bitmap_set (dump_file, maximal_set, \"maximal\", 0);\n     }\n \n   /* Insert can get quite slow on an incredibly large number of basic"}]}