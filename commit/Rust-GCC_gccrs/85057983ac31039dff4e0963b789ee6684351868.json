{"sha": "85057983ac31039dff4e0963b789ee6684351868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUwNTc5ODNhYzMxMDM5ZGZmNGUwOTYzYjc4OWVlNjY4NDM1MTg2OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-05-25T21:59:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-05-25T21:59:24Z"}, "message": "cgraph.c (dump_cgraph_node): Dump size/time/benefit.\n\n\t* cgraph.c (dump_cgraph_node): Dump size/time/benefit.\n\t* cgraph.h (struct inline_summary): New filed self_wize,\n\tsize_inlining_benefit, self_time and time_inlining_benefit.\n\t(struct cgraph_global_info): Replace insns by time ans size fields.\n\t* ipa-cp (ipcp_cloning_candidate_p): Base estimate on size\n\t(ipcp_estimate_growth, ipcp_insert_stage): Likewise.\n\t(ipcp_update_callgraph): Do not touch function bodies.\n\t* ipa-inline.c: Include except.h\n\t(MAX_TIME): New constant.\n\t(overall_insns): Remove.\n\t(leaf_node_p): New.\n\t(overall_size, max_benefit): New static variables.\n\t(cgraph_estimate_time_after_inlining): New function.\n\t(cgraph_estimate_size_after_inlining): Rewrite using benefits.\n\t(cgraph_clone_inlined_nodes): Update size.\n\t(cgraph_mark_inline_edge): Update size.\n\t(cgraph_estimate_growth): Use size info.\n\t(cgraph_check_inline_limits): Check size.\n\t(cgraph_default_inline_p): Likewise.\n\t(cgraph_edge_badness): Compute badness based on benefit and size cost.\n\t(cgraph_decide_recursive_inlining): Check size.\n\t(cgraph_decide_inlining_of_small_function): Update size; dump sizes and\n\ttimes.\n\t(cgraph_decide_inlining): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise; honor\n\tPARAM_EARLY_INLINING_INSNS.\n\t(likely_eliminated_by_inlining_p): New predicate.\n\t(estimate_function_body_sizes): New function.\n\t(compute_inline_parameters): Use it.\n\t* except.c (must_not_throw_labels): New function.\n\t* except.h (must_not_throw_labels): Declare.\n\t* tree-inline.c (init_inline_once): Kill inlining_weigths\n\t* tree-ssa-structalias.c: Avoid uninitialized warning.\n\t* params.def (PARAM_MAX_INLINE_INSNS_SINGLE): Reduce to 300.\n\t(PARAM_MAX_INLINE_INSNS_AUTO): Reduce to 60.\n\t(PARAM_INLINE_CALL_COST): Remove.\n\t(PARAM_EARLY_INLINING_INSNS): New.\n\nFrom-SVN: r147852", "tree": {"sha": "cd788cef35d8a937c0812e48a90dc01d40ef1a51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd788cef35d8a937c0812e48a90dc01d40ef1a51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85057983ac31039dff4e0963b789ee6684351868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85057983ac31039dff4e0963b789ee6684351868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85057983ac31039dff4e0963b789ee6684351868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85057983ac31039dff4e0963b789ee6684351868/comments", "author": null, "committer": null, "parents": [{"sha": "01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01df5c8ae2b0d8b2bf7cfa4623b31866141e4ad1"}], "stats": {"total": 558, "additions": 429, "deletions": 129}, "files": [{"sha": "b861286af48cfe309845230bdccfb9e00e21f47a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -1,3 +1,43 @@\n+2009-05-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (dump_cgraph_node): Dump size/time/benefit.\n+\t* cgraph.h (struct inline_summary): New filed self_wize,\n+\tsize_inlining_benefit, self_time and time_inlining_benefit.\n+\t(struct cgraph_global_info): Replace insns by time ans size fields.\n+\t* ipa-cp (ipcp_cloning_candidate_p): Base estimate on size\n+\t(ipcp_estimate_growth, ipcp_insert_stage): Likewise.\n+\t(ipcp_update_callgraph): Do not touch function bodies.\n+\t* ipa-inline.c: Include except.h\n+\t(MAX_TIME): New constant.\n+\t(overall_insns): Remove.\n+\t(leaf_node_p): New.\n+\t(overall_size, max_benefit): New static variables.\n+\t(cgraph_estimate_time_after_inlining): New function.\n+\t(cgraph_estimate_size_after_inlining): Rewrite using benefits.\n+\t(cgraph_clone_inlined_nodes): Update size.\n+\t(cgraph_mark_inline_edge): Update size.\n+\t(cgraph_estimate_growth): Use size info.\n+\t(cgraph_check_inline_limits): Check size.\n+\t(cgraph_default_inline_p): Likewise.\n+\t(cgraph_edge_badness): Compute badness based on benefit and size cost.\n+\t(cgraph_decide_recursive_inlining): Check size.\n+\t(cgraph_decide_inlining_of_small_function): Update size; dump sizes and\n+\ttimes.\n+\t(cgraph_decide_inlining): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise; honor\n+\tPARAM_EARLY_INLINING_INSNS.\n+\t(likely_eliminated_by_inlining_p): New predicate.\n+\t(estimate_function_body_sizes): New function.\n+\t(compute_inline_parameters): Use it.\n+\t* except.c (must_not_throw_labels): New function.\n+\t* except.h (must_not_throw_labels): Declare.\n+\t* tree-inline.c (init_inline_once): Kill inlining_weigths\n+\t* tree-ssa-structalias.c: Avoid uninitialized warning.\n+\t* params.def (PARAM_MAX_INLINE_INSNS_SINGLE): Reduce to 300.\n+\t(PARAM_MAX_INLINE_INSNS_AUTO): Reduce to 60.\n+\t(PARAM_INLINE_CALL_COST): Remove.\n+\t(PARAM_EARLY_INLINING_INSNS): New.\n+\n 2009-05-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36327"}, {"sha": "c7939b9d2c4850e749dd38a41b978ca8e94312f4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -1393,11 +1393,18 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n \t     (HOST_WIDEST_INT)node->count);\n-  if (node->local.inline_summary.self_insns)\n-    fprintf (f, \" %i insns\", node->local.inline_summary.self_insns);\n-  if (node->global.insns && node->global.insns\n-      != node->local.inline_summary.self_insns)\n-    fprintf (f, \" (%i after inlining)\", node->global.insns);\n+  if (node->local.inline_summary.self_time)\n+    fprintf (f, \" %i time, %i benefit\", node->local.inline_summary.self_time,\n+    \t\t\t\t\tnode->local.inline_summary.time_inlining_benefit);\n+  if (node->global.time && node->global.time\n+      != node->local.inline_summary.self_time)\n+    fprintf (f, \" (%i after inlining)\", node->global.time);\n+  if (node->local.inline_summary.self_size)\n+    fprintf (f, \" %i size, %i benefit\", node->local.inline_summary.self_size,\n+    \t\t\t\t\tnode->local.inline_summary.size_inlining_benefit);\n+  if (node->global.size && node->global.size\n+      != node->local.inline_summary.self_size)\n+    fprintf (f, \" (%i after inlining)\", node->global.size);\n   if (node->local.inline_summary.estimated_self_stack_size)\n     fprintf (f, \" %i bytes stack usage\", (int)node->local.inline_summary.estimated_self_stack_size);\n   if (node->global.estimated_stack_size != node->local.inline_summary.estimated_self_stack_size)"}, {"sha": "1f05eedf698ed8a6965fe775fbe7b8ec3eaeb68b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -55,8 +55,14 @@ struct GTY(()) inline_summary\n   /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_self_stack_size;\n \n-  /* Size of the function before inlining.  */\n-  int self_insns;\n+  /* Size of the function body.  */\n+  int self_size;\n+  /* How many instructions are likely going to disappear after inlining.  */\n+  int size_inlining_benefit;\n+  /* Estimated time spent executing the function body.  */\n+  int self_time;\n+  /* How much time is going to be saved by inlining.  */\n+  int time_inlining_benefit;\n };\n \n /* Information about the function collected locally.\n@@ -108,7 +114,8 @@ struct GTY(()) cgraph_global_info {\n   struct cgraph_node *inlined_to;\n \n   /* Estimated size of the function after inlining.  */\n-  int insns;\n+  int time;\n+  int size;\n \n   /* Estimated growth after inlining.  INT_MIN if not computed.  */\n   int estimated_growth;"}, {"sha": "ff45a7e6d727a310b1c891abd2e7751f1604fee2", "filename": "gcc/except.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -1039,6 +1039,43 @@ get_next_region_sharing_label (int region)\n   return r->next_region_sharing_label->region_number;\n }\n \n+/* Return bitmap of all labels that are handlers of must not throw regions.  */\n+\n+bitmap\n+must_not_throw_labels (void)\n+{\n+  struct eh_region_d *i;\n+  bitmap labels = BITMAP_ALLOC (NULL);\n+\n+  i = cfun->eh->region_tree;\n+  if (! i)\n+    return labels;\n+\n+  while (1)\n+    {\n+      if (i->type == ERT_MUST_NOT_THROW && i->tree_label\n+          && LABEL_DECL_UID (i->tree_label) >= 0)\n+        bitmap_set_bit (labels, LABEL_DECL_UID (i->tree_label));\n+\n+      /* If there are sub-regions, process them.  */\n+      if (i->inner)\n+\ti = i->inner;\n+      /* If there are peers, process them.  */\n+      else if (i->next_peer)\n+\ti = i->next_peer;\n+      /* Otherwise, step back up the tree to the next peer.  */\n+      else\n+\t{\n+\t  do {\n+\t    i = i->outer;\n+\t    if (i == NULL)\n+\t      return labels;\n+\t  } while (i->next_peer == NULL);\n+\t  i = i->next_peer;\n+\t}\n+    }\n+}\n+\n /* Set up EH labels for RTL.  */\n \n void"}, {"sha": "58c596a17ba4a2fb97dbf1697f1877c9da798152", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -274,6 +274,6 @@ extern void set_eh_throw_stmt_table (struct function *, struct htab *);\n extern void remove_unreachable_regions (sbitmap, sbitmap);\n extern VEC(int,heap) * label_to_region_map (void);\n extern int num_eh_regions (void);\n-extern struct eh_region_d *redirect_eh_edge_to_label (struct edge_def *, tree,\n-\t\t\t\t\t\t      bool, bool, int);\n+extern bitmap must_not_throw_labels (void);\n+extern struct eh_region_d *redirect_eh_edge_to_label (struct edge_def *, tree, bool, bool, int);\n extern int get_next_region_sharing_label (int);"}, {"sha": "581a88a1b6ca9b686716faa39e7d6864e8e8a76b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -396,7 +396,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n  \t         cgraph_node_name (node));\n       return false;\n     }\n-  if (node->local.inline_summary.self_insns < n_calls)\n+  if (node->local.inline_summary.self_size < n_calls)\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Considering %s for cloning; code would shrink.\\n\",\n@@ -837,10 +837,7 @@ ipcp_update_callgraph (void)\n \t  {\n \t    next = cs->next_caller;\n \t    if (!ipcp_node_is_clone (cs->caller) && ipcp_need_redirect_p (cs))\n-\t      {\n-\t\tcgraph_redirect_edge_callee (cs, orig_node);\n-\t\tgimple_call_set_fndecl (cs->call_stmt, orig_node->decl);\n-\t      }\n+\t      cgraph_redirect_edge_callee (cs, orig_node);\n \t  }\n       }\n }\n@@ -916,7 +913,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n      call site.  Precise cost is dificult to get, as our size metric counts\n      constants and moves as free.  Generally we are looking for cases that\n      small function is called very many times.  */\n-  growth = node->local.inline_summary.self_insns\n+  growth = node->local.inline_summary.self_size\n   \t   - removable_args * redirectable_node_callers;\n   if (growth < 0)\n     return 0;\n@@ -956,7 +953,7 @@ ipcp_estimate_cloning_cost (struct cgraph_node *node)\n     cost /= freq_sum * 1000 / REG_BR_PROB_BASE + 1;\n   if (dump_file)\n     fprintf (dump_file, \"Cost of versioning %s is %i, (size: %i, freq: %i)\\n\",\n-             cgraph_node_name (node), cost, node->local.inline_summary.self_insns,\n+             cgraph_node_name (node), cost, node->local.inline_summary.self_size,\n \t     freq_sum);\n   return cost + 1;\n }\n@@ -1012,7 +1009,7 @@ ipcp_insert_stage (void)\n       {\n \tif (node->count > max_count)\n \t  max_count = node->count;\n-\toverall_size += node->local.inline_summary.self_insns;\n+\toverall_size += node->local.inline_summary.self_size;\n       }\n \n   max_new_size = overall_size;"}, {"sha": "28f0ec9862d1972959149362a0e0e120d9ad6f4b", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 315, "deletions": 97, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -138,6 +138,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"rtl.h\"\n #include \"ipa-prop.h\"\n+#include \"except.h\"\n+\n+#define MAX_TIME 1000000000\n \n /* Mode incremental inliner operate on:\n \n@@ -164,8 +167,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *, enum inlining_mode,\n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n static int nfunctions_inlined;\n-static int overall_insns;\n-static gcov_type max_count;\n+static int overall_size;\n+static gcov_type max_count, max_benefit;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_node_hook_list *function_insertion_hook_holder;\n@@ -176,19 +179,30 @@ inline_summary (struct cgraph_node *node)\n   return &node->local.inline_summary;\n }\n \n-/* Estimate size of the function after inlining WHAT into TO.  */\n+/* Estimate self time of the function after inlining WHAT into TO.  */\n \n static int\n-cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n+cgraph_estimate_time_after_inlining (int frequency, struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n-  int size;\n-  tree fndecl = what->decl, arg;\n-  int call_insns = PARAM_VALUE (PARAM_INLINE_CALL_COST);\n+  gcov_type time = (((gcov_type)what->global.time\n+\t\t     - inline_summary (what)->time_inlining_benefit)\n+  \t\t    * frequency + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE\n+\t\t    + to->global.time;\n+  if (time < 0)\n+    time = 0;\n+  if (time > MAX_TIME)\n+    time = MAX_TIME;\n+  return time;\n+}\n \n-  for (arg = DECL_ARGUMENTS (fndecl); arg; arg = TREE_CHAIN (arg))\n-    call_insns += estimate_move_cost (TREE_TYPE (arg));\n-  size = (what->global.insns - call_insns) * times + to->global.insns;\n+/* Estimate self time of the function after inlining WHAT into TO.  */\n+\n+static int\n+cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n+\t\t\t\t     struct cgraph_node *what)\n+{\n+  int size = (what->global.size - inline_summary (what)->size_inlining_benefit) * times + to->global.size;\n   gcc_assert (size >= 0);\n   return size;\n }\n@@ -214,7 +228,10 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  if (e->callee->analyzed)\n-\t    overall_insns -= e->callee->global.insns, nfunctions_inlined++;\n+\t    {\n+\t      overall_size -= e->callee->global.size;\n+\t      nfunctions_inlined++;\n+\t    }\n \t  duplicate = false;\n \t}\n       else\n@@ -254,9 +271,12 @@ static bool\n cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n \t\t\t VEC (cgraph_edge_p, heap) **new_edges)\n {\n-  int old_insns = 0, new_insns = 0;\n+  int old_size = 0, new_size = 0;\n   struct cgraph_node *to = NULL, *what;\n   struct cgraph_edge *curr = e;\n+  int freq;\n+  bool duplicate = false;\n+  int orig_size = e->callee->global.size;\n \n   gcc_assert (e->inline_failed);\n   e->inline_failed = CIF_OK;\n@@ -265,23 +285,28 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n   e->callee->global.inlined = true;\n \n+  if (e->callee->callers->next_caller\n+      || e->callee->needed)\n+    duplicate = true;\n   cgraph_clone_inlined_nodes (e, true, update_original);\n \n   what = e->callee;\n \n+  freq = e->frequency;\n   /* Now update size of caller and all functions caller is inlined into.  */\n   for (;e && !e->inline_failed; e = e->caller->callers)\n     {\n-      old_insns = e->caller->global.insns;\n-      new_insns = cgraph_estimate_size_after_inlining (1, e->caller,\n-\t\t\t\t\t\t       what);\n-      gcc_assert (new_insns >= 0);\n       to = e->caller;\n-      to->global.insns = new_insns;\n+      old_size = e->caller->global.size;\n+      new_size = cgraph_estimate_size_after_inlining (1, to, what);\n+      to->global.size = new_size;\n+      to->global.time = cgraph_estimate_time_after_inlining (freq, to, what);\n     }\n   gcc_assert (what->global.inlined_to == to);\n-  if (new_insns > old_insns)\n-    overall_insns += new_insns - old_insns;\n+  if (new_size > old_size)\n+    overall_size += new_size - old_size;\n+  if (!duplicate)\n+    overall_size -= orig_size;\n   ncalls_inlined++;\n \n   if (flag_indirect_inlining)\n@@ -336,15 +361,15 @@ cgraph_estimate_growth (struct cgraph_node *node)\n         self_recursive = true;\n       if (e->inline_failed)\n \tgrowth += (cgraph_estimate_size_after_inlining (1, e->caller, node)\n-\t\t   - e->caller->global.insns);\n+\t\t   - e->caller->global.size);\n     }\n \n   /* ??? Wrong for non-trivially self recursive functions or cases where\n      we decide to not inline for different reasons, but it is not big deal\n      as in that case we will keep the body around, but we will also avoid\n      some inlining.  */\n   if (!node->needed && !DECL_EXTERNAL (node->decl) && !self_recursive)\n-    growth -= node->global.insns;\n+    growth -= node->global.size;\n \n   node->global.estimated_growth = growth;\n   return growth;\n@@ -379,17 +404,17 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n \n   /* When inlining large function body called once into small function,\n      take the inlined function as base for limiting the growth.  */\n-  if (inline_summary (to)->self_insns > inline_summary(what)->self_insns)\n-    limit = inline_summary (to)->self_insns;\n+  if (inline_summary (to)->self_size > inline_summary(what)->self_size)\n+    limit = inline_summary (to)->self_size;\n   else\n-    limit = inline_summary (what)->self_insns;\n+    limit = inline_summary (what)->self_size;\n \n   limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = cgraph_estimate_size_after_inlining (times, to, what);\n-  if (newsize >= to->global.insns\n+  if (newsize >= to->global.size\n       && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n     {\n@@ -438,7 +463,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n \n   if (DECL_DECLARED_INLINE_P (decl))\n     {\n-      if (n->global.insns >= MAX_INLINE_INSNS_SINGLE)\n+      if (n->global.size >= MAX_INLINE_INSNS_SINGLE)\n \t{\n \t  if (reason)\n \t    *reason = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -447,7 +472,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n     }\n   else\n     {\n-      if (n->global.insns >= MAX_INLINE_INSNS_AUTO)\n+      if (n->global.size >= MAX_INLINE_INSNS_AUTO)\n \t{\n \t  if (reason)\n \t    *reason = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -489,11 +514,11 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n static int\n cgraph_edge_badness (struct cgraph_edge *edge)\n {\n-  int badness;\n+  gcov_type badness;\n   int growth =\n     cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n \n-  growth -= edge->caller->global.insns;\n+  growth -= edge->caller->global.size;\n \n   /* Always prefer inlining saving code size.  */\n   if (growth <= 0)\n@@ -502,7 +527,8 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n   /* When profiling is available, base priorities -(#calls / growth).\n      So we optimize for overall number of \"executed\" inlined calls.  */\n   else if (max_count)\n-    badness = ((int)((double)edge->count * INT_MIN / max_count)) / growth;\n+    badness = ((int)((double)edge->count * INT_MIN / max_count / (max_benefit + 1))\n+    \t      * (inline_summary (edge->callee)->time_inlining_benefit + 1)) / growth;\n \n   /* When function local profile is available, base priorities on\n      growth / frequency, so we optimize for overall frequency of inlined\n@@ -515,21 +541,23 @@ cgraph_edge_badness (struct cgraph_edge *edge)\n      of the same size gets priority).  */\n   else if (flag_guess_branch_prob)\n     {\n-      int div = edge->frequency * 100 / CGRAPH_FREQ_BASE;\n-      int growth =\n-\tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n-      growth -= edge->caller->global.insns;\n-      badness = growth * 256;\n+      int div = edge->frequency * 100 / CGRAPH_FREQ_BASE + 1;\n+      badness = growth * 10000;\n+      div *= MIN (100 * inline_summary (edge->callee)->time_inlining_benefit\n+      \t          / (edge->callee->global.time + 1) + 1, 100);\n+      \n \n       /* Decrease badness if call is nested.  */\n       /* Compress the range so we don't overflow.  */\n-      if (div > 256)\n-\tdiv = 256 + ceil_log2 (div) - 8;\n+      if (div > 10000)\n+\tdiv = 10000 + ceil_log2 (div) - 8;\n       if (div < 1)\n \tdiv = 1;\n       if (badness > 0)\n \tbadness /= div;\n       badness += cgraph_estimate_growth (edge->callee);\n+      if (badness > INT_MAX)\n+        badness = INT_MAX;\n     }\n   /* When function local profile is not available or it does not give\n      useful information (ie frequency is zero), base the cost on\n@@ -762,8 +790,9 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n   fibheap_delete (heap);\n   if (dump_file)\n     fprintf (dump_file, \n-\t     \"\\n   Inlined %i times, body grown from %i to %i insns\\n\", n,\n-\t     master_clone->global.insns, node->global.insns);\n+\t     \"\\n   Inlined %i times, body grown from size %i to %i, time %i to %i\\n\", n,\n+\t     master_clone->global.size, node->global.size,\n+\t     master_clone->global.time, node->global.time);\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -841,7 +870,7 @@ cgraph_decide_inlining_of_small_functions (void)\n   cgraph_inline_failed_t failed_reason;\n   fibheap_t heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n-  int min_insns, max_insns;\n+  int min_size, max_size;\n   VEC (cgraph_edge_p, heap) *new_indirect_edges = NULL;\n \n   if (flag_indirect_inlining)\n@@ -875,26 +904,26 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  }\n     }\n \n-  max_insns = compute_max_insns (overall_insns);\n-  min_insns = overall_insns;\n+  max_size = compute_max_insns (overall_size);\n+  min_size = overall_size;\n \n-  while (overall_insns <= max_insns\n+  while (overall_size <= max_size\n \t && (edge = (struct cgraph_edge *) fibheap_extract_min (heap)))\n     {\n-      int old_insns = overall_insns;\n+      int old_size = overall_size;\n       struct cgraph_node *where;\n       int growth =\n \tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n       cgraph_inline_failed_t not_good = CIF_OK;\n \n-      growth -= edge->caller->global.insns;\n+      growth -= edge->caller->global.size;\n \n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \n-\t\t   \"\\nConsidering %s with %i insns\\n\",\n+\t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   cgraph_node_name (edge->callee),\n-\t\t   edge->callee->global.insns);\n+\t\t   edge->callee->global.size);\n \t  fprintf (dump_file, \n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n@@ -1036,19 +1065,20 @@ cgraph_decide_inlining_of_small_functions (void)\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \n-\t\t   \" Inlined into %s which now has %i insns,\"\n-\t\t   \"net change of %+i insns.\\n\",\n+\t\t   \" Inlined into %s which now has size %i and self time %i,\"\n+\t\t   \"net change of %+i.\\n\",\n \t\t   cgraph_node_name (edge->caller),\n-\t\t   edge->caller->global.insns,\n-\t\t   overall_insns - old_insns);\n+\t\t   edge->caller->global.time,\n+\t\t   edge->caller->global.size,\n+\t\t   overall_size - old_size);\n \t}\n-      if (min_insns > overall_insns)\n+      if (min_size > overall_size)\n \t{\n-\t  min_insns = overall_insns;\n-\t  max_insns = compute_max_insns (min_insns);\n+\t  min_size = overall_size;\n+\t  max_size = compute_max_insns (min_size);\n \n \t  if (dump_file)\n-\t    fprintf (dump_file, \"New minimal insns reached: %i\\n\", min_insns);\n+\t    fprintf (dump_file, \"New minimal size reached: %i\\n\", min_size);\n \t}\n     }\n   while ((edge = (struct cgraph_edge *) fibheap_extract_min (heap)) != NULL)\n@@ -1077,34 +1107,38 @@ cgraph_decide_inlining (void)\n   int nnodes;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int old_insns = 0;\n+  int old_size = 0;\n   int i;\n-  int initial_insns = 0;\n   bool redo_always_inline = true;\n+  int initial_size = 0;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n \n   max_count = 0;\n+  max_benefit = 0;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed && (node->needed || node->reachable))\n+    if (node->analyzed)\n       {\n \tstruct cgraph_edge *e;\n \n-\tinitial_insns += inline_summary (node)->self_insns;\n-\tgcc_assert (inline_summary (node)->self_insns == node->global.insns);\n+\tgcc_assert (inline_summary (node)->self_size == node->global.size);\n+\tgcc_assert (node->needed || node->reachable);\n+\tinitial_size += node->global.size;\n \tfor (e = node->callees; e; e = e->next_callee)\n \t  if (max_count < e->count)\n \t    max_count = e->count;\n+\tif (max_benefit < inline_summary (node)->time_inlining_benefit)\n+\t  max_benefit = inline_summary (node)->time_inlining_benefit;\n       }\n-  overall_insns = initial_insns;\n   gcc_assert (!max_count || (profile_info && flag_branch_probabilities));\n+  overall_size = initial_size;\n \n   nnodes = cgraph_postorder (order);\n \n   if (dump_file)\n     fprintf (dump_file,\n-\t     \"\\nDeciding on inlining.  Starting with %i insns.\\n\",\n-\t     initial_insns);\n+\t     \"\\nDeciding on inlining.  Starting with size %i.\\n\",\n+\t     initial_size);\n \n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = 0;\n@@ -1138,9 +1172,9 @@ cgraph_decide_inlining (void)\n \t    continue;\n \t  if (dump_file)\n \t    fprintf (dump_file,\n-\t\t     \"\\nConsidering %s %i insns (always inline)\\n\",\n-\t\t     cgraph_node_name (node), node->global.insns);\n-\t  old_insns = overall_insns;\n+\t\t     \"\\nConsidering %s size:%i (always inline)\\n\",\n+\t\t     cgraph_node_name (node), node->global.size);\n+\t  old_size = overall_size;\n \t  for (e = node->callers; e; e = next)\n \t    {\n \t      next = e->next_caller;\n@@ -1159,9 +1193,9 @@ cgraph_decide_inlining (void)\n \t\tredo_always_inline = true;\n \t      if (dump_file)\n \t\tfprintf (dump_file,\n-\t\t\t \" Inlined into %s which now has %i insns.\\n\",\n+\t\t\t \" Inlined into %s which now has size %i.\\n\",\n \t\t\t cgraph_node_name (e->caller),\n-\t\t\t e->caller->global.insns);\n+\t\t\t e->caller->global.size);\n \t    }\n \t  /* Inlining self recursive function might introduce new calls to\n \t     themselves we didn't see in the loop above.  Fill in the proper\n@@ -1171,8 +1205,8 @@ cgraph_decide_inlining (void)\n \t      e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  if (dump_file)\n \t    fprintf (dump_file, \n-\t\t     \" Inlined for a net change of %+i insns.\\n\",\n-\t\t     overall_insns - old_insns);\n+\t\t     \" Inlined for a net change of %+i size.\\n\",\n+\t\t     overall_size - old_size);\n \t}\n     }\n \n@@ -1197,30 +1231,29 @@ cgraph_decide_inlining (void)\n \t      && !DECL_EXTERNAL (node->decl)\n \t      && !DECL_COMDAT (node->decl))\n \t    {\n+\t      old_size = overall_size;\n \t      if (dump_file)\n \t\t{\n \t\t  fprintf (dump_file,\n-\t\t\t   \"\\nConsidering %s %i insns.\\n\",\n-\t\t\t   cgraph_node_name (node), node->global.insns);\n+\t\t\t   \"\\nConsidering %s size %i.\\n\",\n+\t\t\t   cgraph_node_name (node), node->global.size);\n \t\t  fprintf (dump_file,\n \t\t\t   \" Called once from %s %i insns.\\n\",\n \t\t\t   cgraph_node_name (node->callers->caller),\n-\t\t\t   node->callers->caller->global.insns);\n+\t\t\t   node->callers->caller->global.size);\n \t\t}\n \n-\t      old_insns = overall_insns;\n-\n \t      if (cgraph_check_inline_limits (node->callers->caller, node,\n \t\t\t\t\t      NULL, false))\n \t\t{\n \t\t  cgraph_mark_inline (node->callers);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n-\t\t\t     \" Inlined into %s which now has %i insns\"\n-\t\t\t     \" for a net change of %+i insns.\\n\",\n+\t\t\t     \" Inlined into %s which now has %i size\"\n+\t\t\t     \" for a net change of %+i size.\\n\",\n \t\t\t     cgraph_node_name (node->callers->caller),\n-\t\t\t     node->callers->caller->global.insns,\n-\t\t\t     overall_insns - old_insns);\n+\t\t\t     node->callers->caller->global.size,\n+\t\t\t     overall_size - old_size);\n \t\t}\n \t      else\n \t\t{\n@@ -1239,9 +1272,9 @@ cgraph_decide_inlining (void)\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nInlined %i calls, eliminated %i functions, \"\n-\t     \"%i insns turned to %i insns.\\n\\n\",\n-\t     ncalls_inlined, nfunctions_inlined, initial_insns,\n-\t     overall_insns);\n+\t     \"size %i turned to %i size.\\n\\n\",\n+\t     ncalls_inlined, nfunctions_inlined, initial_size,\n+\t     overall_size);\n   free (order);\n   return 0;\n }\n@@ -1326,6 +1359,20 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n   return inlined;\n }\n \n+/* Return true when N is leaf function.  Accept cheap (pure&const) builtins\n+   in leaf functions.  */\n+static bool\n+leaf_node_p (struct cgraph_node *n)\n+{\n+  struct cgraph_edge *e;\n+  for (e = n->callees; e; e = e->next_callee)\n+    if (!DECL_BUILT_IN (e->callee->decl)\n+\t|| (!TREE_READONLY (e->callee->decl)\n+\t    || DECL_PURE_P (e->callee->decl)))\n+      return false;\n+  return true;\n+}\n+\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  \n    DEPTH is depth of recursion, used only for debug output.  */\n@@ -1429,6 +1476,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n   if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE)\n     for (e = node->callees; e; e = e->next_callee)\n       {\n+        int allowed_growth = 0;\n \tif (!e->callee->local.inlinable\n \t    || !e->inline_failed\n \t    || e->callee->local.disregard_inline_limits)\n@@ -1455,29 +1503,33 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t      }\n \t    continue;\n \t  }\n+\n+\tif (cgraph_maybe_hot_edge_p (e) && leaf_node_p (e->callee))\n+\t  allowed_growth = PARAM_VALUE (PARAM_EARLY_INLINING_INSNS);\n+\n \t/* When the function body would grow and inlining the function won't\n \t   eliminate the need for offline copy of the function, don't inline.\n \t */\n \tif (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n \t     || (!flag_inline_functions\n \t\t && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n \t    && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n-\t\t> e->caller->global.insns)\n-\t    && cgraph_estimate_growth (e->callee) > 0)\n+\t\t> e->caller->global.size + allowed_growth)\n+\t    && cgraph_estimate_growth (e->callee) > allowed_growth)\n \t  {\n \t    if (dump_file)\n \t      {\n \t\tindent_to (dump_file, depth);\n \t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: code size would grow by %i insns.\\n\",\n+\t\t\t \"Not inlining: code size would grow by %i.\\n\",\n \t\t\t cgraph_estimate_size_after_inlining (1, e->caller,\n \t\t\t\t\t\t\t      e->callee)\n-\t\t\t - e->caller->global.insns);\n+\t\t\t - e->caller->global.size);\n \t      }\n \t    continue;\n \t  }\n \tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t\t\t\t        false)\n+\t\t\t\t         false)\n \t    || gimple_call_cannot_inline_p (e->call_stmt))\n \t  {\n \t    if (dump_file)\n@@ -1606,6 +1658,178 @@ struct simple_ipa_opt_pass pass_ipa_early_inline =\n  }\n };\n \n+/* See if statement might disappear after inlining.  We are not terribly\n+   sophisficated, basically looking for simple abstraction penalty wrappers.  */\n+\n+static bool\n+likely_eliminated_by_inlining_p (gimple stmt)\n+{\n+  enum gimple_code code = gimple_code (stmt);\n+  switch (code)\n+    {\n+      case GIMPLE_RETURN:\n+        return true;\n+      case GIMPLE_ASSIGN:\n+\tif (gimple_num_ops (stmt) != 2)\n+\t  return false;\n+\n+\t/* Casts of parameters, loads from parameters passed by reference\n+\t   and stores to return value or parameters are probably free after\n+\t   inlining.  */\n+\tif (gimple_assign_rhs_code (stmt) == CONVERT_EXPR\n+\t    || gimple_assign_rhs_code (stmt) == NOP_EXPR\n+\t    || gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR\n+\t    || gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n+\t  {\n+\t    tree rhs = gimple_assign_rhs1 (stmt);\n+            tree lhs = gimple_assign_lhs (stmt);\n+\t    tree inner_rhs = rhs;\n+\t    tree inner_lhs = lhs;\n+\t    bool rhs_free = false;\n+\t    bool lhs_free = false;\n+\n+ \t    while (handled_component_p (inner_lhs) || TREE_CODE (inner_lhs) == INDIRECT_REF)\n+\t      inner_lhs = TREE_OPERAND (inner_lhs, 0);\n+ \t    while (handled_component_p (inner_rhs)\n+\t           || TREE_CODE (inner_rhs) == ADDR_EXPR || TREE_CODE (inner_rhs) == INDIRECT_REF)\n+\t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n+\t\t\n+\n+\t    if (TREE_CODE (inner_rhs) == PARM_DECL\n+\t        || (TREE_CODE (inner_rhs) == SSA_NAME\n+\t\t    && SSA_NAME_IS_DEFAULT_DEF (inner_rhs)\n+\t\t    && TREE_CODE (SSA_NAME_VAR (inner_rhs)) == PARM_DECL))\n+\t      rhs_free = true;\n+\t    if (rhs_free && is_gimple_reg (lhs))\n+\t      lhs_free = true;\n+\t    if (((TREE_CODE (inner_lhs) == PARM_DECL\n+\t          || (TREE_CODE (inner_lhs) == SSA_NAME\n+\t\t      && SSA_NAME_IS_DEFAULT_DEF (inner_lhs)\n+\t\t      && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == PARM_DECL))\n+\t\t && inner_lhs != lhs)\n+\t        || TREE_CODE (inner_lhs) == RESULT_DECL\n+\t        || (TREE_CODE (inner_lhs) == SSA_NAME\n+\t\t    && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == RESULT_DECL))\n+\t      lhs_free = true;\n+\t    if (lhs_free && (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n+\t      rhs_free = true;\n+\t    if (lhs_free && rhs_free)\n+\t      return true;\n+\t  }\n+\treturn false;\n+      default:\n+\treturn false;\n+    }\n+}\n+\n+/* Compute function body size parameters for NODE.  */\n+\n+static void\n+estimate_function_body_sizes (struct cgraph_node *node)\n+{\n+  gcov_type time = 0;\n+  gcov_type time_inlining_benefit = 0;\n+  int size = 0;\n+  int size_inlining_benefit = 0;\n+  basic_block bb;\n+  gimple_stmt_iterator bsi;\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n+  tree arg;\n+  int freq;\n+  tree funtype = TREE_TYPE (node->decl);\n+  bitmap must_not_throw = must_not_throw_labels ();\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Analyzing function body size: %s\\n\", cgraph_node_name (node));\n+    }\n+\n+  gcc_assert (my_function && my_function->cfg);\n+  FOR_EACH_BB_FN (bb, my_function)\n+    {\n+      freq = compute_call_stmt_bb_frequency (node->decl, bb);\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  int this_size = estimate_num_insns (gsi_stmt (bsi), &eni_size_weights);\n+\t  int this_time = estimate_num_insns (gsi_stmt (bsi), &eni_time_weights);\n+\n+\t  /* MUST_NOT_THROW is usually handled by runtime calling terminate and stopping\n+\t     stacking unwinding.  However when there is local cleanup that can resume\n+\t     to MUST_NOT_THROW then we generate explicit handler containing\n+\t     std::terminate () call.\n+\t     \n+\t     Because inlining of function can introduce new cleanup region, prior\n+\t     inlining we keep std::terinate () calls for every MUST_NOT_THROW containing\n+\t     function call.  Wast majority of these will be eliminated after inlining\n+\t     and crossjumping will inify possible duplicated calls.  So ignore\n+\t     the handlers for function body estimates.  */\n+\t  if (gimple_code (gsi_stmt (bsi)) == GIMPLE_LABEL\n+\t      && bitmap_bit_p (must_not_throw, \n+\t      \t\t       LABEL_DECL_UID (gimple_label_label (gsi_stmt (bsi)))))\n+\t    {\n+\t      if (dump_file)\n+\t        fprintf (dump_file, \"  MUST_NOT_THROW landing pad.  Ignoring whole BB.\\n\");\n+\t    }\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"  freq:%6i size:%3i time:%3i \", freq, this_size, this_time);\n+\t      print_gimple_stmt (dump_file, gsi_stmt (bsi), 0, 0);\n+\t    }\n+\t  this_time *= freq;\n+\t  time += this_time;\n+\t  size += this_size;\n+\t  if (likely_eliminated_by_inlining_p (gsi_stmt (bsi)))\n+\t    {\n+\t      size_inlining_benefit += this_size;\n+\t      time_inlining_benefit += this_time;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    Likely eliminated\\n\");\n+\t    }\n+\t  gcc_assert (time >= 0);\n+\t  gcc_assert (size >= 0);\n+\t}\n+    }\n+  time = (time + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n+  time_inlining_benefit = ((time_inlining_benefit + CGRAPH_FREQ_BASE / 2)\n+  \t\t\t   / CGRAPH_FREQ_BASE);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Overall function body time: %i-%i size: %i-%i\\n\",\n+               (int)time, (int)time_inlining_benefit,\n+      \t       size, size_inlining_benefit);\n+    }\n+  time_inlining_benefit += eni_time_weights.call_cost;\n+  size_inlining_benefit += eni_size_weights.call_cost;\n+  if (!VOID_TYPE_P (TREE_TYPE (funtype)))\n+    {\n+      int cost = estimate_move_cost (TREE_TYPE (funtype));\n+      time_inlining_benefit += cost;\n+      size_inlining_benefit += cost;\n+    }\n+  for (arg = DECL_ARGUMENTS (node->decl); arg; arg = TREE_CHAIN (arg))\n+    if (!VOID_TYPE_P (TREE_TYPE (arg)))\n+      {\n+        int cost = estimate_move_cost (TREE_TYPE (arg));\n+        time_inlining_benefit += cost;\n+        size_inlining_benefit += cost;\n+      }\n+  if (time_inlining_benefit > MAX_TIME)\n+    time_inlining_benefit = MAX_TIME;\n+  if (time > MAX_TIME)\n+    time = MAX_TIME;\n+  inline_summary (node)->self_time = time;\n+  inline_summary (node)->self_size = size;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"With function call overhead time: %i-%i size: %i-%i\\n\",\n+               (int)time, (int)time_inlining_benefit,\n+      \t       size, size_inlining_benefit);\n+    }\n+  inline_summary (node)->time_inlining_benefit = time_inlining_benefit;\n+  inline_summary (node)->size_inlining_benefit = size_inlining_benefit;\n+  BITMAP_FREE (must_not_throw);\n+}\n+\n /* Compute parameters of functions used by inliner.  */\n unsigned int\n compute_inline_parameters (struct cgraph_node *node)\n@@ -1623,19 +1847,13 @@ compute_inline_parameters (struct cgraph_node *node)\n \n   /* Can this function be inlined at all?  */\n   node->local.inlinable = tree_inlinable_function_p (current_function_decl);\n-\n-  /* Estimate the number of instructions for this function.\n-     ??? At -O0 we don't use this information except for the dumps, and\n-\t even then only for always_inline functions.  But disabling this\n-\t causes ICEs in the inline heuristics...  */\n-  inline_summary (node)->self_insns\n-      = estimate_num_insns_fn (current_function_decl, &eni_inlining_weights);\n   if (node->local.inlinable && !node->local.disregard_inline_limits)\n     node->local.disregard_inline_limits\n       = DECL_DISREGARD_INLINE_LIMITS (current_function_decl);\n-\n+  estimate_function_body_sizes (node);\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n-  node->global.insns = inline_summary (node)->self_insns;\n+  node->global.time = inline_summary (node)->self_time;\n+  node->global.size = inline_summary (node)->self_size;\n   return 0;\n }\n \n@@ -1653,7 +1871,7 @@ struct gimple_opt_pass pass_inline_parameters =\n {\n  {\n   GIMPLE_PASS,\n-  NULL,\t \t\t\t\t/* name */\n+  \"inline_param\",\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n   compute_inline_parameters_for_current,/* execute */\n   NULL,\t\t\t\t\t/* sub */"}, {"sha": "ccbc305a627527a395f3d0a545f4f6b0ee0556f6", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -100,7 +100,7 @@ DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n \t  \"The maximum number of instructions in a single function eligible for inlining\",\n-\t  450, 0, 0)\n+\t  400, 0, 0)\n \n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n@@ -112,7 +112,7 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n \t  \"The maximum number of instructions when automatically inlining\",\n-\t  90, 0, 0)\n+\t  60, 0, 0)\n \n DEFPARAM (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n \t  \"max-inline-insns-recursive\",\n@@ -212,9 +212,9 @@ DEFPARAM(PARAM_IPCP_UNIT_GROWTH,\n \t \"ipcp-unit-growth\",\n \t \"how much can given compilation unit grow because of the interprocedural constant propagation (in percent)\",\n \t 10, 0, 0)\n-DEFPARAM(PARAM_INLINE_CALL_COST,\n-\t \"inline-call-cost\",\n-\t \"expense of call operation relative to ordinary arithmetic operations\",\n+DEFPARAM(PARAM_EARLY_INLINING_INSNS,\n+\t \"early-inlining-insns\",\n+\t \"maximal estimated growth of function body caused by early inlining of single call\",\n \t 12, 0, 0)\n DEFPARAM(PARAM_LARGE_STACK_FRAME,\n \t \"large-stack-frame\","}, {"sha": "e3b4b83b863e24fe3ba3a6f674d677eac4d230a1", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -168,8 +168,8 @@ cgraph_maybe_hot_edge_p (struct cgraph_edge *edge)\n   if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (edge->caller->decl)))\n     return true;\n   if (flag_guess_branch_prob\n-      && edge->frequency < (CGRAPH_FREQ_MAX\n-      \t\t\t    / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n+      && edge->frequency <= (CGRAPH_FREQ_BASE\n+      \t\t\t     / PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)))\n     return false;\n   return true;\n }"}, {"sha": "b9632a9df8f3f1c4529c80fe1a359460e722433d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -3155,12 +3155,6 @@ estimate_num_insns_fn (tree fndecl, eni_weights *weights)\n void\n init_inline_once (void)\n {\n-  eni_inlining_weights.call_cost = PARAM_VALUE (PARAM_INLINE_CALL_COST);\n-  eni_inlining_weights.target_builtin_call_cost = 1;\n-  eni_inlining_weights.div_mod_cost = 10;\n-  eni_inlining_weights.omp_cost = 40;\n-  eni_inlining_weights.time_based = true;\n-\n   eni_size_weights.call_cost = 1;\n   eni_size_weights.target_builtin_call_cost = 1;\n   eni_size_weights.div_mod_cost = 1;"}, {"sha": "ea47ec61d364a888374b5b98c4a059f03f8f68d5", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85057983ac31039dff4e0963b789ee6684351868/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85057983ac31039dff4e0963b789ee6684351868/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=85057983ac31039dff4e0963b789ee6684351868", "patch": "@@ -3411,7 +3411,7 @@ handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc)\n static void\n handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n {\n-  struct constraint_expr rhsc, tmpc;\n+  struct constraint_expr rhsc, tmpc = {SCALAR, 0, 0};\n   tree tmpvar = NULL_TREE;\n   unsigned int k;\n "}]}