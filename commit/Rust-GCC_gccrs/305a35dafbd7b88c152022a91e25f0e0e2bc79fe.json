{"sha": "305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1YTM1ZGFmYmQ3Yjg4YzE1MjAyMmE5MWUyNWYwZTBlMmJjNzlmZQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-11-25T17:24:09Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2012-11-25T17:24:09Z"}, "message": "re PR fortran/30146 (Redefining do-variable in excecution cycle)\n\n2012-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/30146\n\t* frontend-passes.c (doloop_warn):  New function.\n\t(doloop_list):  New static variable.\n\t(doloop_size):  New static variable.\n\t(doloop_level):  New static variable.\n\t(gfc_run_passes): Call doloop_warn.\n\t(doloop_code):  New function.\n\t(doloop_function):  New function.\n\t(gfc_code_walker):  Keep track of DO level.\n\n2012-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/30146\n\t* gfortran.dg/do_check_6.f90:  New test.\n\nFrom-SVN: r193793", "tree": {"sha": "c87a484350b9810e9356b4733345da9931d42614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c87a484350b9810e9356b4733345da9931d42614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/comments", "author": null, "committer": null, "parents": [{"sha": "99303b325ea337b9947bd3470f81c7467fa7d989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99303b325ea337b9947bd3470f81c7467fa7d989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99303b325ea337b9947bd3470f81c7467fa7d989"}], "stats": {"total": 238, "additions": 236, "deletions": 2}, "files": [{"sha": "bf5f8fbad5b7417f561988bc0c2871277710924c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "patch": "@@ -1,3 +1,15 @@\n+2012-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/30146\n+\t* frontend-passes.c (doloop_warn):  New function.\n+\t(doloop_list):  New static variable.\n+\t(doloop_size):  New static variable.\n+\t(doloop_level):  New static variable.\n+\t(gfc_run_passes): Call doloop_warn.\n+\t(doloop_code):  New function.\n+\t(doloop_function):  New function.\n+\t(gfc_code_walker):  Keep track of DO level.\n+\n 2012-11-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/55314"}, {"sha": "6679368994b2cc32aab33d1010f736443aac82c6", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 179, "deletions": 2, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "patch": "@@ -39,6 +39,7 @@ static bool optimize_trim (gfc_expr *);\n static bool optimize_lexical_comparison (gfc_expr *);\n static void optimize_minmaxloc (gfc_expr **);\n static bool is_empty_string (gfc_expr *e);\n+static void doloop_warn (gfc_namespace *);\n \n /* How deep we are inside an argument list.  */\n \n@@ -76,12 +77,30 @@ static bool in_omp_workshare;\n \n static int iterator_level;\n \n-/* Entry point - run all passes for a namespace.  So far, only an\n-   optimization pass is run.  */\n+/* Keep track of DO loop levels.  */\n+\n+static gfc_code **doloop_list;\n+static int doloop_size, doloop_level;\n+\n+/* Vector of gfc_expr * to keep track of DO loops.  */\n+\n+struct my_struct *evec;\n+\n+/* Entry point - run all passes for a namespace. */\n \n void\n gfc_run_passes (gfc_namespace *ns)\n {\n+\n+  /* Warn about dubious DO loops where the index might\n+     change.  */\n+\n+  doloop_size = 20;\n+  doloop_level = 0;\n+  doloop_list = XNEWVEC(gfc_code *, doloop_size);\n+  doloop_warn (ns);\n+  XDELETEVEC (doloop_list);\n+\n   if (gfc_option.flag_frontend_optimize)\n     {\n       expr_size = 20;\n@@ -1225,6 +1244,160 @@ optimize_minmaxloc (gfc_expr **e)\n   mpz_set_ui (a->expr->value.integer, 1);\n }\n \n+/* Callback function for code checking that we do not pass a DO variable to an\n+   INTENT(OUT) or INTENT(INOUT) dummy variable.  */\n+\n+static int\n+doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code *co;\n+  int i;\n+  gfc_formal_arglist *f;\n+  gfc_actual_arglist *a;\n+\n+  co = *c;\n+\n+  switch (co->op)\n+    {\n+    case EXEC_DO:\n+\n+      /* Grow the temporary storage if necessary.  */\n+      if (doloop_level >= doloop_size)\n+\t{\n+\t  doloop_size = 2 * doloop_size;\n+\t  doloop_list = XRESIZEVEC (gfc_code *, doloop_list, doloop_size);\n+\t}\n+\n+      /* Mark the DO loop variable if there is one.  */\n+      if (co->ext.iterator && co->ext.iterator->var)\n+\tdoloop_list[doloop_level] = co;\n+      else\n+\tdoloop_list[doloop_level] = NULL;\n+      break;\n+\n+    case EXEC_CALL:\n+      f = co->symtree->n.sym->formal;\n+\n+      /* Withot a formal arglist, there is only unknown INTENT,\n+\t which we don't check for.  */\n+      if (f == NULL)\n+\tbreak;\n+\n+      a = co->ext.actual;\n+\n+      while (a && f)\n+\t{\n+\t  for (i=0; i<doloop_level; i++)\n+\t    {\n+\t      gfc_symbol *do_sym;\n+\t      \n+\t      if (doloop_list[i] == NULL)\n+\t\tbreak;\n+\n+\t      do_sym = doloop_list[i]->ext.iterator->var->symtree->n.sym;\n+\t      \n+\t      if (a->expr && a->expr->symtree\n+\t\t  && a->expr->symtree->n.sym == do_sym)\n+\t\t{\n+\t\t  if (f->sym->attr.intent == INTENT_OUT)\n+\t\t    gfc_error_now(\"Variable '%s' at %L set to undefined value \"\n+\t\t\t\t  \"inside loop  beginning at %L as INTENT(OUT) \"\n+\t\t\t\t  \"argument to subroutine '%s'\", do_sym->name,\n+\t\t\t\t  &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t\t  co->symtree->n.sym->name);\n+\t\t  else if (f->sym->attr.intent == INTENT_INOUT)\n+\t\t    gfc_error_now(\"Variable '%s' at %L not definable inside loop \"\n+\t\t\t\t  \"beginning at %L as INTENT(INOUT) argument to \"\n+\t\t\t\t  \"subroutine '%s'\", do_sym->name,\n+\t\t\t\t  &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t\t  co->symtree->n.sym->name);\n+\t\t}\n+\t    }\n+\t  a = a->next;\n+\t  f = f->next;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n+/* Callback function for functions checking that we do not pass a DO variable\n+   to an INTENT(OUT) or INTENT(INOUT) dummy variable.  */\n+\n+static int\n+do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_formal_arglist *f;\n+  gfc_actual_arglist *a;\n+  gfc_expr *expr;\n+  int i;\n+\n+  expr = *e;\n+  if (expr->expr_type != EXPR_FUNCTION)\n+    return 0;\n+\n+  /* Intrinsic functions don't modify their arguments.  */\n+\n+  if (expr->value.function.isym)\n+    return 0;\n+\n+  f = expr->symtree->n.sym->formal;\n+\n+  /* Without a formal arglist, there is only unknown INTENT,\n+     which we don't check for.  */\n+  if (f == NULL)\n+    return 0;\n+\n+  a = expr->value.function.actual;\n+\n+  while (a && f)\n+    {\n+      for (i=0; i<doloop_level; i++)\n+\t{\n+\t  gfc_symbol *do_sym;\n+\t \n+    \n+\t  if (doloop_list[i] == NULL)\n+\t    break;\n+\n+\t  do_sym = doloop_list[i]->ext.iterator->var->symtree->n.sym;\n+\t  \n+\t  if (a->expr && a->expr->symtree\n+\t      && a->expr->symtree->n.sym == do_sym)\n+\t    {\n+\t      if (f->sym->attr.intent == INTENT_OUT)\n+\t\tgfc_error_now(\"Variable '%s' at %L set to undefined value \"\n+\t\t\t      \"inside loop beginning at %L as INTENT(OUT) \"\n+\t\t\t      \"argument to function '%s'\", do_sym->name,\n+\t\t\t      &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t      expr->symtree->n.sym->name);\n+\t      else if (f->sym->attr.intent == INTENT_INOUT)\n+\t\tgfc_error_now(\"Variable '%s' at %L not definable inside loop \"\n+\t\t\t      \"beginning at %L as INTENT(INOUT) argument to \"\n+\t\t\t      \"function '%s'\", do_sym->name,\n+\t\t\t      &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t      expr->symtree->n.sym->name);\n+\t    }\n+\t}\n+      a = a->next;\n+      f = f->next;\n+    }\n+\n+  return 0;\n+}\n+\n+static void\n+doloop_warn (gfc_namespace *ns)\n+{\n+  gfc_code_walker (&ns->code, doloop_code, do_function, NULL);\n+}\n+\n+\n #define WALK_SUBEXPR(NODE) \\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -1383,6 +1556,7 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t      break;\n \n \t    case EXEC_DO:\n+\t      doloop_level ++;\n \t      WALK_SUBEXPR (co->ext.iterator->var);\n \t      WALK_SUBEXPR (co->ext.iterator->start);\n \t      WALK_SUBEXPR (co->ext.iterator->end);\n@@ -1601,6 +1775,9 @@ gfc_code_walker (gfc_code **c, walk_code_fn_t codefn, walk_expr_fn_t exprfn,\n \t  if (co->op == EXEC_FORALL)\n \t    forall_level --;\n \n+\t  if (co->op == EXEC_DO)\n+\t    doloop_level --;\n+\n \t  in_omp_workshare = saved_in_omp_workshare;\n \t}\n     }"}, {"sha": "833f77142962c25c29248b106aecc2bbb8a71a77", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "patch": "@@ -1,3 +1,8 @@\n+2012-11-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/30146\n+\t* gfortran.dg/do_check_7.f90:  New test.\n+\n 2012-11-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/55446"}, {"sha": "964872256883da75040116e32bfd564abf53de7c", "filename": "gcc/testsuite/gfortran.dg/do_check_7.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305a35dafbd7b88c152022a91e25f0e0e2bc79fe/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_check_7.f90?ref=305a35dafbd7b88c152022a91e25f0e0e2bc79fe", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do compile }\n+! PR 30146 - warn about DO variables as argument to INTENT(IN) and\n+! INTENT(INOUT) dummy arguments\n+program main\n+  implicit none\n+  integer :: i,j, k, l\n+  do k=1,2                      ! { dg-error \"undefined value\" }\n+     do i=1,10                  ! { dg-error \"definable\" }\n+        do j=1,10               ! { dg-error \"undefined value\" }\n+           do l=1,10            ! { dg-error \"definable\" }\n+              call s_out(k)      ! { dg-error \"undefined\" }\n+              call s_inout(i)    ! { dg-error \"definable\" }\n+              print *,f_out(j)   ! { dg-error \"undefined\" }\n+              print *,f_inout(l) ! { dg-error \"definable\" }\n+           end do\n+        end do\n+     end do\n+  end do\n+contains\n+  subroutine s_out(i_arg)\n+    integer, intent(out) :: i_arg\n+  end subroutine s_out\n+\n+  subroutine s_inout(i_arg)\n+    integer, intent(inout) :: i_arg\n+  end subroutine s_inout\n+\n+  function f_out(i_arg)\n+    integer, intent(out) :: i_arg\n+    integer :: f_out\n+    f_out = i_arg\n+  end function f_out\n+\n+  function f_inout(i_arg)\n+    integer, intent(inout) :: i_arg\n+    integer :: f_inout\n+    f_inout = i_arg\n+  end function f_inout\n+\n+end program main"}]}