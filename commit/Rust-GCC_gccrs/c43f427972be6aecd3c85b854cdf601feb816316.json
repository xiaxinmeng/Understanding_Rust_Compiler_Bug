{"sha": "c43f427972be6aecd3c85b854cdf601feb816316", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzZjQyNzk3MmJlNmFlY2QzYzg1Yjg1NGNkZjYwMWZlYjgxNjMxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-12T13:29:36Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-12T13:29:36Z"}, "message": "Turn HARD_REGNO_NREGS into a target hook\n\n2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (hard_regno_nregs): New hook.\n\t(class_max_nregs): Refer to it instead of HARD_REGNO_NREGS.\n\t* targhooks.h (default_hard_regno_nregs): Declare.\n\t* targhooks.c (default_hard_regno_nregs): New function.\n\t* doc/tm.texi.in (HARD_REGNO_NREGS): Replace with...\n\t(TARGET_HARD_REGNO_NREGS): ...this hook.\n\t(HARD_REGNO_NREGS_HAS_PADDING): Update accordingly.\n\t(CLASS_MAX_NREGS): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* reginfo.c (init_reg_modes_target): Use targetm.hard_regno_nregs\n\tinstead of HARD_REGNO_NREGS.\n\t* rtl.h (REG_NREGS): Refer to TARGET_HARD_REGNO_NREGS rather than\n\tHARD_REGNO_NREGS in the comment.\n\t* config/aarch64/aarch64.h (HARD_REGNO_NREGS): Delete.\n\t* config/aarch64/aarch64-protos.h (aarch64_hard_regno_nregs): Delete.\n\t* config/aarch64/aarch64.c (aarch64_hard_regno_nregs): Make static.\n\tReturn an unsigned int.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/alpha/alpha.h (HARD_REGNO_NREGS): Delete.\n\t* config/arc/arc.h (HARD_REGNO_NREGS): Delete.\n\t* config/arc/arc.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(arc_hard_regno_nregs): New function.\n\t* config/arm/arm.h (HARD_REGNO_NREGS): Delete.\n\t* config/arm/arm.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(arm_hard_regno_nregs): New function.\n\t* config/avr/avr.h (HARD_REGNO_NREGS): Delete.\n\t* config/bfin/bfin.h (HARD_REGNO_NREGS): Delete.\n\t* config/bfin/bfin.c (bfin_hard_regno_nregs): New function.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/c6x/c6x.h (HARD_REGNO_NREGS): Delete.\n\t* config/cr16/cr16.h (LONG_REG_P): Use targetm.hard_regno_nregs.\n\t(HARD_REGNO_NREGS): Delete.\n\t* config/cr16/cr16.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(cr16_hard_regno_nregs): New function.\n\t(cr16_memory_move_cost): Use it instead of HARD_REGNO_NREGS.\n\t* config/cris/cris.h (HARD_REGNO_NREGS): Delete.\n\t* config/cris/cris.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(cris_hard_regno_nregs): New function.\n\t* config/epiphany/epiphany.h (HARD_REGNO_NREGS): Delete.\n\t* config/fr30/fr30.h (HARD_REGNO_NREGS): Delete.\n\t(CLASS_MAX_NREGS): Use targetm.hard_regno_nregs.\n\t* config/frv/frv.h (HARD_REGNO_NREGS): Delete.\n\t(CLASS_MAX_NREGS): Remove outdated copy of documentation.\n\t* config/frv/frv-protos.h (frv_hard_regno_nregs): Delete.\n\t* config/frv/frv.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(frv_hard_regno_nregs): Make static.  Take and return an\n\tunsigned int.\n\t(frv_class_max_nregs): Remove outdated copy of documentation.\n\t* config/ft32/ft32.h (HARD_REGNO_NREGS): Delete.\n\t* config/h8300/h8300.h (HARD_REGNO_NREGS): Delete.\n\t* config/h8300/h8300-protos.h (h8300_hard_regno_nregs): Delete.\n\t* config/h8300/h8300.c (h8300_hard_regno_nregs): Delete.\n\t* config/i386/i386.h (HARD_REGNO_NREGS): Delete.\n\t* config/i386/i386.c (ix86_hard_regno_nregs): New function.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/ia64/ia64.h (HARD_REGNO_NREGS): Delete.\n\t(CLASS_MAX_NREGS): Update comment.\n\t* config/ia64/ia64.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(ia64_hard_regno_nregs): New function.\n\t* config/iq2000/iq2000.h (HARD_REGNO_NREGS): Delete.\n\t* config/lm32/lm32.h (HARD_REGNO_NREGS): Delete.\n\t* config/m32c/m32c.h (HARD_REGNO_NREGS): Delete.\n\t* config/m32c/m32c-protos.h (m32c_hard_regno_nregs): Delete.\n\t* config/m32c/m32c.c (m32c_hard_regno_nregs_1): Take and return\n\tan unsigned int.\n\t(m32c_hard_regno_nregs): Likewise.  Make static.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/m32r/m32r.h (HARD_REGNO_NREGS): Delete.\n\t* config/m68k/m68k.h (HARD_REGNO_NREGS): Delete.\n\t* config/m68k/m68k.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(m68k_hard_regno_nregs): New function.\n\t* config/mcore/mcore.h (HARD_REGNO_NREGS): Delete.\n\t* config/microblaze/microblaze.h (HARD_REGNO_NREGS): Delete.\n\t* config/mips/mips.h (HARD_REGNO_NREGS): Delete.\n\t* config/mips/mips-protos.h (mips_hard_regno_nregs): Delete.\n\t* config/mips/mips.c (mips_hard_regno_nregs): Make static.\n\tTake and return an unsigned int.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/mmix/mmix.h (HARD_REGNO_NREGS): Delete.\n\t(CLASS_MAX_NREGS): Use targetm.hard_regno_nregs.\n\t* config/mn10300/mn10300.h (HARD_REGNO_NREGS): Delete.\n\t* config/moxie/moxie.h (HARD_REGNO_NREGS): Delete.\n\t* config/msp430/msp430.h (HARD_REGNO_NREGS): Delete.\n\t* config/msp430/msp430-protos.h (msp430_hard_regno_nregs): Delete.\n\t* config/msp430/msp430.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(msp430_hard_regno_nregs): Make static.  Take and return an\n\tunsigned int.\n\t* config/nds32/nds32.h (HARD_REGNO_NREGS): Delete.\n\t* config/nds32/nds32-protos.h (nds32_hard_regno_nregs): Delete.\n\t* config/nds32/nds32.c (nds32_hard_regno_nregs): Delete.\n\t(nds32_hard_regno_mode_ok): Use targetm.hard_regno_nregs.\n\t* config/nios2/nios2.h (HARD_REGNO_NREGS): Delete.\n\t* config/nvptx/nvptx.h (HARD_REGNO_NREGS): Delete.\n\t* config/nvptx/nvptx.c (nvptx_hard_regno_nregs): New function.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/pa/pa32-regs.h (HARD_REGNO_NREGS): Rename to...\n\t(PA_HARD_REGNO_NREGS): ...this.\n\t* config/pa/pa64-regs.h (HARD_REGNO_NREGS): Rename to...\n\t(PA_HARD_REGNO_NREGS): ...this.\n\t* config/pa/pa.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(pa_hard_regno_nregs): New function.\n\t* config/pdp11/pdp11.h (HARD_REGNO_NREGS): Delete.\n\t* config/pdp11/pdp11.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(pdp11_hard_regno_nregs): New function.\n\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_NREGS): Delete.\n\t* config/powerpcspe/powerpcspe.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(rs6000_hard_regno_nregs_hook): New function.\n\t* config/riscv/riscv.h (HARD_REGNO_NREGS): Delete.\n\t* config/riscv/riscv-protos.h (riscv_hard_regno_nregs): Delete.\n\t* config/riscv/riscv.c (riscv_hard_regno_nregs): Make static.\n\tTake and return an unsigned int.  Move earlier in file.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/rl78/rl78.h (HARD_REGNO_NREGS): Delete.\n\t* config/rl78/rl78-protos.h (rl78_hard_regno_nregs): Delete.\n\t* config/rl78/rl78.c (TARGET_HARD_REGNO_NREGS): Reefine.\n\t(rl78_hard_regno_nregs): Make static.  Take and return an\n\tunsigned int.\n\t* config/rs6000/rs6000.h (HARD_REGNO_NREGS): Delete.\n\t* config/rs6000/rs6000.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(rs6000_hard_regno_nregs_hook): New function.\n\t* config/rx/rx.h (HARD_REGNO_NREGS): Delete.\n\t* config/rx/rx.c (rx_hard_regno_nregs): New function.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/s390/s390.h (HARD_REGNO_NREGS): Delete.\n\t* config/s390/s390.c (REGNO_PAIR_OK): Use s390_hard_regno_nregs\n\tinstead of HARD_REGNO_NREGS.\n\t(s390_hard_regno_nregs): New function.\n\t(s390_hard_regno_mode_ok): Add comment from s390.h.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/sh/sh.h (HARD_REGNO_NREGS): Delete.\n\t* config/sh/sh.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(sh_hard_regno_nregs): New function.\n\t(sh_pass_in_reg_p): Use it.\n\t* config/sparc/sparc.h (HARD_REGNO_NREGS): Delete.\n\t* config/sparc/sparc.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(sparc_hard_regno_nregs): New function.\n\t* config/spu/spu.h (HARD_REGNO_NREGS): Delete.\n\t* config/spu/spu.c (spu_hard_regno_nregs): New function.\n\t(spu_function_arg_advance): Use it, supplying a valid register number.\n\t(TARGET_HARD_REGNO_NREGS): Redefine.\n\t* config/stormy16/stormy16.h (HARD_REGNO_NREGS): Delete.\n\t* config/tilegx/tilegx.h (HARD_REGNO_NREGS): Delete.\n\t* config/tilepro/tilepro.h (HARD_REGNO_NREGS): Delete.\n\t* config/v850/v850.h (HARD_REGNO_NREGS): Delete.\n\t* config/vax/vax.h (HARD_REGNO_NREGS): Delete.\n\t* config/visium/visium.h (HARD_REGNO_NREGS): Delete.\n\t(CLASS_MAX_NREGS): Remove copy of old documentation.\n\t* config/visium/visium.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\t(visium_hard_regno_nregs): New function.\n\t(visium_hard_regno_mode_ok): Use it instead of HARD_REGNO_NREGS.\n\t* config/xtensa/xtensa.h (HARD_REGNO_NREGS): Delete.\n\t* config/xtensa/xtensa.c (TARGET_HARD_REGNO_NREGS): Redefine.\n\txtensa_hard_regno_nregs): New function.\n\t* system.h (HARD_REGNO_NREGS): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252016", "tree": {"sha": "9e61c07e12b26365023f6656a4c2db2243dc73f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e61c07e12b26365023f6656a4c2db2243dc73f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c43f427972be6aecd3c85b854cdf601feb816316", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43f427972be6aecd3c85b854cdf601feb816316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43f427972be6aecd3c85b854cdf601feb816316", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43f427972be6aecd3c85b854cdf601feb816316/comments", "author": null, "committer": null, "parents": [{"sha": "a93072ca5fd144dd0711b6225473080db4196793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a93072ca5fd144dd0711b6225473080db4196793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a93072ca5fd144dd0711b6225473080db4196793"}], "stats": {"total": 1101, "additions": 582, "deletions": 519}, "files": [{"sha": "7bc95e86c949a3713f7d52c920468b286ed480b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1,3 +1,162 @@\n+2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood <david.sherwood@arm.com>\n+\n+\t* target.def (hard_regno_nregs): New hook.\n+\t(class_max_nregs): Refer to it instead of HARD_REGNO_NREGS.\n+\t* targhooks.h (default_hard_regno_nregs): Declare.\n+\t* targhooks.c (default_hard_regno_nregs): New function.\n+\t* doc/tm.texi.in (HARD_REGNO_NREGS): Replace with...\n+\t(TARGET_HARD_REGNO_NREGS): ...this hook.\n+\t(HARD_REGNO_NREGS_HAS_PADDING): Update accordingly.\n+\t(CLASS_MAX_NREGS): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* reginfo.c (init_reg_modes_target): Use targetm.hard_regno_nregs\n+\tinstead of HARD_REGNO_NREGS.\n+\t* rtl.h (REG_NREGS): Refer to TARGET_HARD_REGNO_NREGS rather than\n+\tHARD_REGNO_NREGS in the comment.\n+\t* config/aarch64/aarch64.h (HARD_REGNO_NREGS): Delete.\n+\t* config/aarch64/aarch64-protos.h (aarch64_hard_regno_nregs): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_hard_regno_nregs): Make static.\n+\tReturn an unsigned int.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/alpha/alpha.h (HARD_REGNO_NREGS): Delete.\n+\t* config/arc/arc.h (HARD_REGNO_NREGS): Delete.\n+\t* config/arc/arc.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(arc_hard_regno_nregs): New function.\n+\t* config/arm/arm.h (HARD_REGNO_NREGS): Delete.\n+\t* config/arm/arm.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(arm_hard_regno_nregs): New function.\n+\t* config/avr/avr.h (HARD_REGNO_NREGS): Delete.\n+\t* config/bfin/bfin.h (HARD_REGNO_NREGS): Delete.\n+\t* config/bfin/bfin.c (bfin_hard_regno_nregs): New function.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/c6x/c6x.h (HARD_REGNO_NREGS): Delete.\n+\t* config/cr16/cr16.h (LONG_REG_P): Use targetm.hard_regno_nregs.\n+\t(HARD_REGNO_NREGS): Delete.\n+\t* config/cr16/cr16.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(cr16_hard_regno_nregs): New function.\n+\t(cr16_memory_move_cost): Use it instead of HARD_REGNO_NREGS.\n+\t* config/cris/cris.h (HARD_REGNO_NREGS): Delete.\n+\t* config/cris/cris.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(cris_hard_regno_nregs): New function.\n+\t* config/epiphany/epiphany.h (HARD_REGNO_NREGS): Delete.\n+\t* config/fr30/fr30.h (HARD_REGNO_NREGS): Delete.\n+\t(CLASS_MAX_NREGS): Use targetm.hard_regno_nregs.\n+\t* config/frv/frv.h (HARD_REGNO_NREGS): Delete.\n+\t(CLASS_MAX_NREGS): Remove outdated copy of documentation.\n+\t* config/frv/frv-protos.h (frv_hard_regno_nregs): Delete.\n+\t* config/frv/frv.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(frv_hard_regno_nregs): Make static.  Take and return an\n+\tunsigned int.\n+\t(frv_class_max_nregs): Remove outdated copy of documentation.\n+\t* config/ft32/ft32.h (HARD_REGNO_NREGS): Delete.\n+\t* config/h8300/h8300.h (HARD_REGNO_NREGS): Delete.\n+\t* config/h8300/h8300-protos.h (h8300_hard_regno_nregs): Delete.\n+\t* config/h8300/h8300.c (h8300_hard_regno_nregs): Delete.\n+\t* config/i386/i386.h (HARD_REGNO_NREGS): Delete.\n+\t* config/i386/i386.c (ix86_hard_regno_nregs): New function.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/ia64/ia64.h (HARD_REGNO_NREGS): Delete.\n+\t(CLASS_MAX_NREGS): Update comment.\n+\t* config/ia64/ia64.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(ia64_hard_regno_nregs): New function.\n+\t* config/iq2000/iq2000.h (HARD_REGNO_NREGS): Delete.\n+\t* config/lm32/lm32.h (HARD_REGNO_NREGS): Delete.\n+\t* config/m32c/m32c.h (HARD_REGNO_NREGS): Delete.\n+\t* config/m32c/m32c-protos.h (m32c_hard_regno_nregs): Delete.\n+\t* config/m32c/m32c.c (m32c_hard_regno_nregs_1): Take and return\n+\tan unsigned int.\n+\t(m32c_hard_regno_nregs): Likewise.  Make static.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/m32r/m32r.h (HARD_REGNO_NREGS): Delete.\n+\t* config/m68k/m68k.h (HARD_REGNO_NREGS): Delete.\n+\t* config/m68k/m68k.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(m68k_hard_regno_nregs): New function.\n+\t* config/mcore/mcore.h (HARD_REGNO_NREGS): Delete.\n+\t* config/microblaze/microblaze.h (HARD_REGNO_NREGS): Delete.\n+\t* config/mips/mips.h (HARD_REGNO_NREGS): Delete.\n+\t* config/mips/mips-protos.h (mips_hard_regno_nregs): Delete.\n+\t* config/mips/mips.c (mips_hard_regno_nregs): Make static.\n+\tTake and return an unsigned int.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/mmix/mmix.h (HARD_REGNO_NREGS): Delete.\n+\t(CLASS_MAX_NREGS): Use targetm.hard_regno_nregs.\n+\t* config/mn10300/mn10300.h (HARD_REGNO_NREGS): Delete.\n+\t* config/moxie/moxie.h (HARD_REGNO_NREGS): Delete.\n+\t* config/msp430/msp430.h (HARD_REGNO_NREGS): Delete.\n+\t* config/msp430/msp430-protos.h (msp430_hard_regno_nregs): Delete.\n+\t* config/msp430/msp430.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(msp430_hard_regno_nregs): Make static.  Take and return an\n+\tunsigned int.\n+\t* config/nds32/nds32.h (HARD_REGNO_NREGS): Delete.\n+\t* config/nds32/nds32-protos.h (nds32_hard_regno_nregs): Delete.\n+\t* config/nds32/nds32.c (nds32_hard_regno_nregs): Delete.\n+\t(nds32_hard_regno_mode_ok): Use targetm.hard_regno_nregs.\n+\t* config/nios2/nios2.h (HARD_REGNO_NREGS): Delete.\n+\t* config/nvptx/nvptx.h (HARD_REGNO_NREGS): Delete.\n+\t* config/nvptx/nvptx.c (nvptx_hard_regno_nregs): New function.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/pa/pa32-regs.h (HARD_REGNO_NREGS): Rename to...\n+\t(PA_HARD_REGNO_NREGS): ...this.\n+\t* config/pa/pa64-regs.h (HARD_REGNO_NREGS): Rename to...\n+\t(PA_HARD_REGNO_NREGS): ...this.\n+\t* config/pa/pa.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(pa_hard_regno_nregs): New function.\n+\t* config/pdp11/pdp11.h (HARD_REGNO_NREGS): Delete.\n+\t* config/pdp11/pdp11.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(pdp11_hard_regno_nregs): New function.\n+\t* config/powerpcspe/powerpcspe.h (HARD_REGNO_NREGS): Delete.\n+\t* config/powerpcspe/powerpcspe.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(rs6000_hard_regno_nregs_hook): New function.\n+\t* config/riscv/riscv.h (HARD_REGNO_NREGS): Delete.\n+\t* config/riscv/riscv-protos.h (riscv_hard_regno_nregs): Delete.\n+\t* config/riscv/riscv.c (riscv_hard_regno_nregs): Make static.\n+\tTake and return an unsigned int.  Move earlier in file.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/rl78/rl78.h (HARD_REGNO_NREGS): Delete.\n+\t* config/rl78/rl78-protos.h (rl78_hard_regno_nregs): Delete.\n+\t* config/rl78/rl78.c (TARGET_HARD_REGNO_NREGS): Reefine.\n+\t(rl78_hard_regno_nregs): Make static.  Take and return an\n+\tunsigned int.\n+\t* config/rs6000/rs6000.h (HARD_REGNO_NREGS): Delete.\n+\t* config/rs6000/rs6000.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(rs6000_hard_regno_nregs_hook): New function.\n+\t* config/rx/rx.h (HARD_REGNO_NREGS): Delete.\n+\t* config/rx/rx.c (rx_hard_regno_nregs): New function.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/s390/s390.h (HARD_REGNO_NREGS): Delete.\n+\t* config/s390/s390.c (REGNO_PAIR_OK): Use s390_hard_regno_nregs\n+\tinstead of HARD_REGNO_NREGS.\n+\t(s390_hard_regno_nregs): New function.\n+\t(s390_hard_regno_mode_ok): Add comment from s390.h.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/sh/sh.h (HARD_REGNO_NREGS): Delete.\n+\t* config/sh/sh.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(sh_hard_regno_nregs): New function.\n+\t(sh_pass_in_reg_p): Use it.\n+\t* config/sparc/sparc.h (HARD_REGNO_NREGS): Delete.\n+\t* config/sparc/sparc.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(sparc_hard_regno_nregs): New function.\n+\t* config/spu/spu.h (HARD_REGNO_NREGS): Delete.\n+\t* config/spu/spu.c (spu_hard_regno_nregs): New function.\n+\t(spu_function_arg_advance): Use it, supplying a valid register number.\n+\t(TARGET_HARD_REGNO_NREGS): Redefine.\n+\t* config/stormy16/stormy16.h (HARD_REGNO_NREGS): Delete.\n+\t* config/tilegx/tilegx.h (HARD_REGNO_NREGS): Delete.\n+\t* config/tilepro/tilepro.h (HARD_REGNO_NREGS): Delete.\n+\t* config/v850/v850.h (HARD_REGNO_NREGS): Delete.\n+\t* config/vax/vax.h (HARD_REGNO_NREGS): Delete.\n+\t* config/visium/visium.h (HARD_REGNO_NREGS): Delete.\n+\t(CLASS_MAX_NREGS): Remove copy of old documentation.\n+\t* config/visium/visium.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\t(visium_hard_regno_nregs): New function.\n+\t(visium_hard_regno_mode_ok): Use it instead of HARD_REGNO_NREGS.\n+\t* config/xtensa/xtensa.h (HARD_REGNO_NREGS): Delete.\n+\t* config/xtensa/xtensa.c (TARGET_HARD_REGNO_NREGS): Redefine.\n+\txtensa_hard_regno_nregs): New function.\n+\t* system.h (HARD_REGNO_NREGS): Poison.\n+\n 2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/arm/arm.h (THUMB_SECONDARY_INPUT_RELOAD_CLASS): Use"}, {"sha": "e67c2ed5e80a2e4f4858cfcd40573efd2a8a4416", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -371,7 +371,6 @@ int aarch64_asm_preferred_eh_data_format (int, int);\n int aarch64_fpconst_pow_of_2 (rtx);\n machine_mode aarch64_hard_regno_caller_save_mode (unsigned, unsigned,\n \t\t\t\t\t\t       machine_mode);\n-int aarch64_hard_regno_nregs (unsigned, machine_mode);\n int aarch64_uxt_size (int, HOST_WIDE_INT);\n int aarch64_vec_fpconst_pow_of_2 (rtx);\n rtx aarch64_eh_return_handler_rtx (void);"}, {"sha": "de1fbdca950b452f5616f37eb0ea719ee793cfdc", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1067,9 +1067,9 @@ aarch64_array_mode_supported_p (machine_mode mode,\n   return false;\n }\n \n-/* Implement HARD_REGNO_NREGS.  */\n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n \n-int\n+static unsigned int\n aarch64_hard_regno_nregs (unsigned regno, machine_mode mode)\n {\n   switch (aarch64_regno_regclass (regno))\n@@ -15686,6 +15686,8 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 4\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS aarch64_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK aarch64_hard_regno_mode_ok\n "}, {"sha": "c3f094e35a53e5a1f30c51e08cea13192e80fa8a", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -401,8 +401,6 @@ extern unsigned aarch64_architecture_version;\n \n #define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (LR_REGNUM)\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\taarch64_hard_regno_nregs (REGNO, MODE)\n-\n #define DWARF2_UNWIND_INFO 1\n \n /* Use R0 through R3 to pass exception handling information.  */"}, {"sha": "56ba895bb19f3183c2c828c54bccbad28a24ae05", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -371,14 +371,6 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n    29, 30, 31, 63\t\t/* gp, sp, ap, sfp */\t\t\t\\\n }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  CEIL (GET_MODE_SIZE (MODE), UNITS_PER_WORD)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "61c83fc9389df9162ffd7a3417e5c69ddc27fca8", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -590,6 +590,8 @@ static void arc_finalize_pic (void);\n #undef TARGET_DWARF_REGISTER_SPAN\n #define TARGET_DWARF_REGISTER_SPAN arc_dwarf_register_span\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS arc_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK arc_hard_regno_mode_ok\n \n@@ -1877,6 +1879,19 @@ arc_conditional_register_usage (void)\n   }\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+arc_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (GET_MODE_SIZE (mode) == 16\n+      && regno >= ARC_FIRST_SIMD_VR_REG\n+      && regno <= ARC_LAST_SIMD_VR_REG)\n+    return 1;\n+\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "bfcb34594ea7f6f5b6e032fd91a90025da04e120", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -441,15 +441,6 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\t\t\\\n   27, 28, 29, 30, 31, 63}\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((GET_MODE_SIZE (MODE) == 16 \\\n-  && REGNO >= ARC_FIRST_SIMD_VR_REG && REGNO <= ARC_LAST_SIMD_VR_REG) ? 1 \\\n- : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Internal macros to classify a register number as to whether it's a\n    general purpose register for compact insns (r0-r3,r12-r15), or\n    stack pointer (r28).  */"}, {"sha": "36c9e0b96b685d965bec7e90dcf18c61e99cdbdb", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -314,6 +314,7 @@ static unsigned int arm_elf_section_type_flags (tree decl, const char *name,\n \t\t\t\t\t\tint reloc);\n static void arm_expand_divmod_libfunc (rtx, machine_mode, rtx, rtx, rtx *, rtx *);\n static opt_scalar_float_mode arm_floatn_mode (int, bool);\n+static unsigned int arm_hard_regno_nregs (unsigned int, machine_mode);\n static bool arm_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool arm_modes_tieable_p (machine_mode, machine_mode);\n \f\n@@ -785,6 +786,8 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_FIXED_CONDITION_CODE_REGS\n #define TARGET_FIXED_CONDITION_CODE_REGS arm_fixed_condition_code_regs\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS arm_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK arm_hard_regno_mode_ok\n \n@@ -23348,6 +23351,21 @@ thumb2_asm_output_opcode (FILE * stream)\n     }\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  On the ARM core regs are\n+   UNITS_PER_WORD bytes wide.  */\n+static unsigned int\n+arm_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (TARGET_32BIT\n+      && regno > PC_REGNUM\n+      && regno != FRAME_POINTER_REGNUM\n+      && regno != ARG_POINTER_REGNUM\n+      && !IS_VFP_REGNUM (regno))\n+    return 1;\n+\n+  return ARM_NUM_REGS (mode);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n static bool\n arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)"}, {"sha": "e8f32f19774564b12c5e307e235d2f56210591aa", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -976,20 +976,6 @@ extern int arm_arch_cmse;\n #define SUBTARGET_FRAME_POINTER_REQUIRED 0\n #endif\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the ARM core regs are UNITS_PER_WORD bits wide.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)  \t\\\n-  ((TARGET_32BIT\t\t\t\\\n-    && REGNO > PC_REGNUM\t\t\\\n-    && REGNO != FRAME_POINTER_REGNUM\t\\\n-    && REGNO != ARG_POINTER_REGNUM)\t\\\n-    && !IS_VFP_REGNUM (REGNO)\t\t\\\n-   ? 1 : ARM_NUM_REGS (MODE))\n-\n #define VALID_IWMMXT_REG_MODE(MODE) \\\n  (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)\n "}, {"sha": "531a2ce6e9c99d50929ce2010f7e83b1c416a26f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -209,9 +209,6 @@ FIXME: DRIVER_SELF_SPECS has changed.\n #define ADJUST_REG_ALLOC_ORDER avr_adjust_reg_alloc_order()\n \n \n-#define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n enum reg_class {\n   NO_REGS,\n   R0_REG,\t\t\t/* r0 */"}, {"sha": "7ef173aface6a0b69f160df3ba5067fbe2d20d32", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -2114,6 +2114,18 @@ bfin_expand_call (rtx retval, rtx fnaddr, rtx callarg1, rtx cookie, int sibcall)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n }\n \f\n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+bfin_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (mode == PDImode && (regno == REG_A0 || regno == REG_A1))\n+    return 1;\n+  if (mode == V2PDImode && (regno == REG_A0 || regno == REG_A1))\n+    return 2;\n+  return CLASS_MAX_NREGS (GENERAL_REGS, mode);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.\n \n    Do not allow to store a value in REG_CC for any mode.\n@@ -5862,6 +5874,8 @@ bfin_conditional_register_usage (void)\n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P bfin_can_use_doloop_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS bfin_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK bfin_hard_regno_mode_ok\n "}, {"sha": "47d57faecc4e736c3184d257a350f6baaf6e0c8e", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -683,11 +683,6 @@ enum reg_class\n   ((MODE) == V2PDImode && (CLASS) == AREGS ? 2\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((MODE) == PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) ? 1\t\\\n-   : (MODE) == V2PDImode && ((REGNO) == REG_A0 || (REGNO) == REG_A1) ? 2 \\\n-   : CLASS_MAX_NREGS (GENERAL_REGS, MODE))\n-\n /* A C expression that is nonzero if hard register TO can be\n    considered for use as a rename register for FROM register */\n #define HARD_REGNO_RENAME_OK(FROM, TO) bfin_hard_regno_rename_ok (FROM, TO)"}, {"sha": "aa58f600a573a2dabccad8f4385dea804eb7a0ed", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -181,11 +181,6 @@ extern c6x_cpu_t c6x_arch;\n     REG_A1, REG_A2, REG_B0, REG_B1, REG_B2, REG_ILC\t\t\t\\\n   }\n \n-#define HARD_REGNO_NREGS(regno, mode)\t\t\\\n-  ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)  \\\n-   / UNITS_PER_WORD)\n-\n-\n /* Register Classes.  */\n \n enum reg_class"}, {"sha": "c4100710a2fa66205ad11e4087ce49edeb1c6e02", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -220,6 +220,8 @@ static const struct attribute_spec cr16_attribute_table[] = {\n #undef TARGET_ASM_UNALIGNED_DI_OP\n #define TARGET_ASM_UNALIGNED_DI_OP \tTARGET_ASM_ALIGNED_DI_OP\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS\t\tcr16_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK\tcr16_hard_regno_mode_ok\n #undef TARGET_MODES_TIEABLE_P\n@@ -468,6 +470,16 @@ cr16_regno_reg_class (int regno)\n   return NO_REGS;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+cr16_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno >= CR16_FIRST_DWORD_REGISTER)\n+    return CEIL (GET_MODE_SIZE (mode), CR16_UNITS_PER_DWORD);\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  On the CR16 architecture, all\n    registers can hold all modes, except that double precision floats\n    (and double ints) must fall on even-register boundaries.  */\n@@ -1371,7 +1383,7 @@ cr16_memory_move_cost (machine_mode mode,\n {\n   /* One LD or ST takes twice the time of a simple reg-reg move.  */\n   if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n-    return (4 * HARD_REGNO_NREGS (0, mode));\n+    return (4 * cr16_hard_regno_nregs (0, mode));\n   else\n     return (100);\n }"}, {"sha": "a068b4bfa984f8655407aeefaf367c5d1f55354a", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -197,12 +197,8 @@ while (0)\n \n /* Returns 1 if the register is longer than word size, 0 otherwise.  */\n #define LONG_REG_P(REGNO)                                                    \\\n-  (HARD_REGNO_NREGS (REGNO, GET_MODE_WIDER_MODE (word_mode).require ()) == 1)\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)                                         \\\n- ((REGNO >= CR16_FIRST_DWORD_REGISTER)                                        \\\n-  ? ((GET_MODE_SIZE (MODE) + CR16_UNITS_PER_DWORD - 1) / CR16_UNITS_PER_DWORD)\\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD       - 1) / UNITS_PER_WORD))\n+  (targetm.hard_regno_nregs (REGNO,                                          \\\n+\t\t\t     GET_MODE_WIDER_MODE (word_mode).require ()) == 1)\n \n #define NOTICE_UPDATE_CC(EXP, INSN) \\\n    notice_update_cc ((EXP))"}, {"sha": "1b2add032988dfb98f421c9ca38b8c2114b4506b", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -163,6 +163,7 @@ static rtx cris_function_value(const_tree, const_tree, bool);\n static rtx cris_libcall_value (machine_mode, const_rtx);\n static bool cris_function_value_regno_p (const unsigned int);\n static void cris_file_end (void);\n+static unsigned int cris_hard_regno_nregs (unsigned int, machine_mode);\n static bool cris_hard_regno_mode_ok (unsigned int, machine_mode);\n \n /* This is the parsed result of the \"-max-stack-stackframe=\" option.  If\n@@ -281,6 +282,8 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #undef TARGET_FUNCTION_VALUE_REGNO_P\n #define TARGET_FUNCTION_VALUE_REGNO_P cris_function_value_regno_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS cris_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK cris_hard_regno_mode_ok\n \n@@ -4296,6 +4299,19 @@ cris_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n      sake of a trampoline.  */\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.\n+\n+   The VOIDmode test is so we can omit mode on anonymous insns.  FIXME:\n+   Still needed in 2.9x, at least for Axis-20000319.  */\n+\n+static unsigned int\n+cris_hard_regno_nregs (unsigned int, machine_mode mode)\n+{\n+  if (mode == VOIDmode)\n+    return 1;\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.\n \n    CRIS permits all registers to hold all modes.  Well, except for the"}, {"sha": "4b332a9badf220f6731e4b7d1c85994fd157109d", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -469,14 +469,6 @@ extern int cris_cpu_version;\n  {15, 9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 17, 16, 14, 18, 19}\n \n \n-/* Node: Values in Registers */\n-\n-/* The VOIDmode test is so we can omit mode on anonymous insns.  FIXME:\n-   Still needed in 2.9x, at least for Axis-20000319.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n- (MODE == VOIDmode \\\n-  ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* Node: Leaf Functions */\n /* (no definitions) */\n "}, {"sha": "c9bd5b5f8d258171dc9051cc8d19cba11b9297ce", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -302,13 +302,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define HARD_REGNO_RENAME_OK(SRC, DST) epiphany_regno_rename_ok (SRC, DST)\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Register classes and constants.  */\n \n /* Define the classes of registers for register constraints in the"}, {"sha": "9aa0199779be47e04b7cee9e5d4e2951c779a6eb", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -237,15 +237,6 @@ along with GCC; see the file COPYING3.  If not see\n   {\"r13\", 13}, {\"r14\", 14}, {\"r15\", 15}, {\"usp\", 15}, {\"ps\", 16}\\\n }\n \n-/*}}}*/ \f\n-/*{{{  How Values Fit in Registers.  */ \n-\n-/* A C expression for the number of consecutive hard registers, starting at\n-   register number REGNO, required to hold a value of mode MODE.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /*}}}*/ \f\n /*{{{  Register Classes.  */ \n \n@@ -345,16 +336,7 @@ enum reg_class\n    will reload one or both registers only if neither labeling works.  */\n #define REGNO_OK_FOR_INDEX_P(NUM) 1\n \n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value\n-   of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the maximum value of\n-   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) HARD_REGNO_NREGS (0, MODE)\n+#define CLASS_MAX_NREGS(CLASS, MODE) targetm.hard_regno_nregs (0, MODE)\n \n /*}}}*/ \f\n /*{{{  Basic Stack Layout.  */ "}, {"sha": "2f7fdf455c5d236a9eb41df312670b19ed28ebd0", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -74,7 +74,6 @@ extern void frv_ifcvt_modify_cancel\t(struct ce_if_block *);\n extern enum reg_class frv_secondary_reload_class\n \t\t\t\t\t(enum reg_class,\n \t\t\t\t\t machine_mode, rtx);\n-extern int frv_hard_regno_nregs\t\t(int, machine_mode);\n extern int frv_class_max_nregs\t\t(enum reg_class rclass,\n \t\t\t\t\t machine_mode mode);\n extern machine_mode frv_select_cc_mode (enum rtx_code, rtx, rtx);"}, {"sha": "85e22c7dcf412eb436f59b82e1fb5ee557b16ad7", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -397,6 +397,7 @@ static bool frv_can_eliminate\t\t\t(const int, const int);\n static void frv_conditional_register_usage\t(void);\n static void frv_trampoline_init\t\t\t(rtx, tree, rtx);\n static bool frv_class_likely_spilled_p \t\t(reg_class_t);\n+static unsigned int frv_hard_regno_nregs\t(unsigned int, machine_mode);\n static bool frv_hard_regno_mode_ok\t\t(unsigned int, machine_mode);\n static bool frv_modes_tieable_p\t\t\t(machine_mode, machine_mode);\n \f\n@@ -516,6 +517,8 @@ static bool frv_modes_tieable_p\t\t\t(machine_mode, machine_mode);\n #undef TARGET_LIBCALL_VALUE\n #define TARGET_LIBCALL_VALUE frv_libcall_value\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS frv_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK frv_hard_regno_mode_ok\n #undef TARGET_MODES_TIEABLE_P\n@@ -6600,23 +6603,15 @@ frv_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n }\n \n \f\n-/* A C expression for the number of consecutive hard registers, starting at\n-   register number REGNO, required to hold a value of mode MODE.\n+/* Implement TARGET_HARD_REGNO_NREGS.\n \n-   On a machine where all registers are exactly one word, a suitable definition\n-   of this macro is\n-\n-        #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-           ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-            / UNITS_PER_WORD))  */\n-\n-/* On the FRV, make the CC_FP mode take 3 words in the integer registers, so\n+   On the FRV, make the CC_FP mode take 3 words in the integer registers, so\n    that we can build the appropriate instructions to properly reload the\n    values.  Also, make the byte-sized accumulator guards use one guard\n    for each byte.  */\n \n-int\n-frv_hard_regno_nregs (int regno, machine_mode mode)\n+static unsigned int\n+frv_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n   if (ACCG_P (regno))\n     return GET_MODE_SIZE (mode);\n@@ -6625,17 +6620,7 @@ frv_hard_regno_nregs (int regno, machine_mode mode)\n }\n \n \f\n-/* A C expression for the maximum number of consecutive registers of\n-   class RCLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value\n-   of the macro `CLASS_MAX_NREGS (RCLASS, MODE)' should be the maximum value of\n-   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class RCLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.\n-\n-   This declaration is required.  */\n+/* Implement CLASS_MAX_NREGS.  */\n \n int\n frv_class_max_nregs (enum reg_class rclass, machine_mode mode)"}, {"sha": "ee32d47462a9f6db037719ccd969541b60999193", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -747,22 +747,6 @@\n }\n \n \f\n-/* How Values Fit in Registers.  */\n-\n-/* A C expression for the number of consecutive hard registers, starting at\n-   register number REGNO, required to hold a value of mode MODE.\n-\n-   On a machine where all registers are exactly one word, a suitable definition\n-   of this macro is\n-\n-        #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-           ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-            / UNITS_PER_WORD))  */\n-\n-/* On the FRV, make the CC modes take 3 words in the integer registers, so that\n-   we can build the appropriate instructions to properly reload the values.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) frv_hard_regno_nregs (REGNO, MODE)\n-\n /* Define this macro if the compiler should avoid copies to/from CCmode\n    registers.  You should only define this macro if support fo copying to/from\n    CCmode is incomplete.  */\n@@ -930,17 +914,6 @@ extern enum reg_class regno_reg_class[];\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n   frv_secondary_reload_class (CLASS, MODE, X)\n \n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value\n-   of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the maximum value of\n-   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.\n-\n-   This declaration is required.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) frv_class_max_nregs (CLASS, MODE)\n \n #define ZERO_P(x) (x == CONST0_RTX (GET_MODE (x)))"}, {"sha": "4eb3b7f8cace46be5e3d53f881f38de659b8cdec", "filename": "gcc/config/ft32/ft32.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fft32%2Fft32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fft32%2Fft32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -171,13 +171,6 @@ enum reg_class\n #define REGNO_REG_CLASS(R) ((R < FT32_PC) ? GENERAL_REGS :                \\\n                             (R == FT32_CC ? CC_REGS : SPECIAL_REGS))\n \n-/* A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of mode\n-   MODE.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)                      \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)             \\\n-   / UNITS_PER_WORD)\n-\n /* The Overall Framework of an Assembler File */\n \n #undef  ASM_SPEC"}, {"sha": "d6adebbbe94390c5aa1f593a43eecd0f8f1f744a", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -99,7 +99,6 @@ extern int h8300_current_function_monitor_function_p (void);\n extern int h8300_initial_elimination_offset (int, int);\n extern int h8300_regs_ok_for_stm (int, rtx[]);\n extern int h8300_hard_regno_rename_ok (unsigned int, unsigned int);\n-extern int h8300_hard_regno_nregs (int, machine_mode);\n extern bool h8300_move_ok (rtx, rtx);\n \n struct cpp_reader;"}, {"sha": "bf1160130e4622eece30eb08dfcbfa5bd09d8c81", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -5878,17 +5878,6 @@ h8300_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n   return 0;\n }\n \n-/* Worker function for HARD_REGNO_NREGS.\n-\n-   We pretend the MAC register is 32bits -- we don't have any data\n-   types on the H8 series to handle more than 32bits.  */\n-\n-int\n-h8300_hard_regno_nregs (int regno ATTRIBUTE_UNUSED, machine_mode mode)\n-{\n-  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-}\n-\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "c7bfc2aefd069afc48e5838fb696f9667e16cfe4", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -236,9 +236,6 @@ extern const char * const *h8_reg_names;\n /* r0 r1 r2 r3 r4 r5 r6 r7 mac ap rap  fp */\t\\\n   { 2, 3, 0, 1, 4, 5, 6, 8,  7, 9, 10, 11 }\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\\\n-  h8300_hard_regno_nregs ((REGNO), (MODE))\n-\n /* A C expression that is nonzero if hard register NEW_REG can be\n    considered for use as a rename register for OLD_REG register */\n "}, {"sha": "edcc2d655b744efe4027990f0417236ddb8dda3b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -41410,6 +41410,32 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n   return 2;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  This is ordinarily the length in\n+   words of a value of mode MODE but can be less for certain modes in\n+   special long registers.\n+\n+   Actually there are no two word move instructions for consecutive\n+   registers.  And only registers 0-3 may have mov byte instructions\n+   applied to them.  */\n+\n+static unsigned int\n+ix86_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (GENERAL_REGNO_P (regno))\n+    {\n+      if (mode == XFmode)\n+\treturn TARGET_64BIT ? 2 : 3;\n+      if (mode == XCmode)\n+\treturn TARGET_64BIT ? 4 : 6;\n+      return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+    }\n+  if (COMPLEX_MODE_P (mode))\n+    return 2;\n+  if (mode == V64SFmode || mode == V64SImode)\n+    return 4;\n+  return 1;\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool\n@@ -53376,6 +53402,8 @@ ix86_run_selftests (void)\n #undef TARGET_NOCE_CONVERSION_PROFITABLE_P\n #define TARGET_NOCE_CONVERSION_PROFITABLE_P ix86_noce_conversion_profitable_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS ix86_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK ix86_hard_regno_mode_ok\n "}, {"sha": "a89782af13f25c6d93e517840059d3bb6b7113e9", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1073,25 +1073,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n \n #define OVERRIDE_ABI_FORMAT(FNDECL) ix86_call_abi_override (FNDECL)\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   Actually there are no two word move instructions for consecutive\n-   registers.  And only registers 0-3 may have mov byte instructions\n-   applied to them.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (GENERAL_REGNO_P (REGNO)\t\t\t\t\t\t\\\n-   ? ((MODE) == XFmode\t\t\t\t\t\t\t\\\n-      ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n-      : ((MODE) == XCmode\t\t\t\t\t\t\\\n-\t ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\\\n-\t : CEIL (GET_MODE_SIZE (MODE), UNITS_PER_WORD)))\t\t\\\n-   : (COMPLEX_MODE_P (MODE) ? 2 :\t\t\t\t\t\\\n-      (((MODE == V64SFmode) || (MODE == V64SImode)) ? 4 : 1)))\n-\n #define HARD_REGNO_NREGS_HAS_PADDING(REGNO, MODE)\t\t\t\\\n   (TARGET_128BIT_LONG_DOUBLE && !TARGET_64BIT\t\t\t\t\\\n    && GENERAL_REGNO_P (REGNO)\t\t\t\t\t\t\\"}, {"sha": "d1f44d6b1cece0fed487b67d015bf0a0a5b29a9d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -336,6 +336,7 @@ static section * ia64_hpux_function_section (tree, enum node_frequency,\n static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t      const unsigned char *sel);\n \n+static unsigned int ia64_hard_regno_nregs (unsigned int, machine_mode);\n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool ia64_modes_tieable_p (machine_mode, machine_mode);\n \n@@ -659,6 +660,8 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 0\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS ia64_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK ia64_hard_regno_mode_ok\n \n@@ -4263,6 +4266,30 @@ ia64_hard_regno_rename_ok (int from, int to)\n   return 1;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.\n+\n+   ??? We say that BImode PR values require two registers.  This allows us to\n+   easily store the normal and inverted values.  We use CCImode to indicate\n+   a single predicate register.  */\n+\n+static unsigned int\n+ia64_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno == PR_REG (0) && mode == DImode)\n+    return 64;\n+  if (PR_REGNO_P (regno) && (mode) == BImode)\n+    return 2;\n+  if ((PR_REGNO_P (regno) || GR_REGNO_P (regno)) && mode == CCImode)\n+    return 1;\n+  if (FR_REGNO_P (regno) && mode == XFmode)\n+    return 1;\n+  if (FR_REGNO_P (regno) && mode == RFmode)\n+    return 1;\n+  if (FR_REGNO_P (regno) && mode == XCmode)\n+    return 2;\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "cdb91a38ce52dbd5b04c9e969956fb88e29c7b77", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -598,22 +598,6 @@ while (0)\n \f\n /* How Values Fit in Registers */\n \n-/* A C expression for the number of consecutive hard registers, starting at\n-   register number REGNO, required to hold a value of mode MODE.  */\n-\n-/* ??? We say that BImode PR values require two registers.  This allows us to\n-   easily store the normal and inverted values.  We use CCImode to indicate\n-   a single predicate register.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  ((REGNO) == PR_REG (0) && (MODE) == DImode ? 64\t\t\t\\\n-   : PR_REGNO_P (REGNO) && (MODE) == BImode ? 2\t\t\t\t\\\n-   : (PR_REGNO_P (REGNO) || GR_REGNO_P (REGNO)) && (MODE) == CCImode ? 1\\\n-   : FR_REGNO_P (REGNO) && (MODE) == XFmode ? 1\t\t\t\t\\\n-   : FR_REGNO_P (REGNO) && (MODE) == RFmode ? 1\t\t\t\t\\\n-   : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2\t\t\t\t\\\n-   : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Specify the modes required to caller save a given hard regno.\n    We need to ensure floating pt regs are not saved as DImode.  */\n \n@@ -803,7 +787,7 @@ enum reg_class\n \n /* A C expression for the maximum number of consecutive registers of\n    class CLASS needed to hold a value of mode MODE.\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  */\n+   This is closely related to TARGET_HARD_REGNO_NREGS.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((MODE) == BImode && (CLASS) == PR_REGS ? 2\t\t\t\\"}, {"sha": "907d89ba861fb3718a90ff81aa8626bf2c1f0a5e", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -160,10 +160,6 @@\n }\n \n \f\n-/* How Values Fit in Registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n #define AVOID_CCMODE_COPIES\n "}, {"sha": "40f15628ef384aa9457e4bfc1db2532fc26f6e5f", "filename": "gcc/config/lm32/lm32.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -163,9 +163,6 @@ do {                                                    \\\n   0, 0, 0, 0, 0, 0, 0, 0,   \\\n   0, 0, 1, 0, 1, 0, 1, 1}\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n-    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #define AVOID_CCMODE_COPIES\n \n /*----------------------------------*/"}, {"sha": "1c6465a91c47ec432844dff5131d7b48eab16096", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -49,7 +49,6 @@ int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n bool m32c_matches_constraint_p (rtx, int);\n-int  m32c_hard_regno_nregs (int, machine_mode);\n bool m32c_illegal_subreg_p (rtx);\n bool m32c_immd_dbl_mov (rtx *, machine_mode);\n rtx  m32c_incoming_return_addr_rtx (void);"}, {"sha": "168489ed4e79f03abb85f6b971b15e371b0ccda0", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -539,11 +539,11 @@ m32c_conditional_register_usage (void)\n \n /* How Values Fit in Registers */\n \n-/* Implements HARD_REGNO_NREGS.  This is complicated by the fact that\n+/* Implements TARGET_HARD_REGNO_NREGS.  This is complicated by the fact that\n    different registers are different sizes from each other, *and* may\n    be different sizes in different chip families.  */\n-static int\n-m32c_hard_regno_nregs_1 (int regno, machine_mode mode)\n+static unsigned int\n+m32c_hard_regno_nregs_1 (unsigned int regno, machine_mode mode)\n {\n   if (regno == FLG_REGNO && mode == CCmode)\n     return 1;\n@@ -568,10 +568,10 @@ m32c_hard_regno_nregs_1 (int regno, machine_mode mode)\n   return 0;\n }\n \n-int\n-m32c_hard_regno_nregs (int regno, machine_mode mode)\n+static unsigned int\n+m32c_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n-  int rv = m32c_hard_regno_nregs_1 (regno, mode);\n+  unsigned int rv = m32c_hard_regno_nregs_1 (regno, mode);\n   return rv ? rv : 1;\n }\n \n@@ -4489,6 +4489,8 @@ m32c_output_compare (rtx_insn *insn, rtx *operands)\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_true\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS m32c_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK m32c_hard_regno_mode_ok\n #undef TARGET_MODES_TIEABLE_P"}, {"sha": "231eff341140ee364cf5871035003851ae02ac1f", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -255,7 +255,6 @@ machine_function;\n \n /* How Values Fit in Registers */\n \n-#define HARD_REGNO_NREGS(R,M) m32c_hard_regno_nregs (R, M)\n #define AVOID_CCMODE_COPIES\n \n /* Register Classes */"}, {"sha": "b0d2ceb45047e9c3751356556b5d9066fe2212ec", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -389,13 +389,6 @@\n }\n #endif\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   m32r_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \f"}, {"sha": "cd2e15e2f6c8cc5cf05ae00ca4d88ee5c2e1cdef", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -187,6 +187,7 @@ static bool m68k_output_addr_const_extra (FILE *, rtx);\n static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n static enum flt_eval_method\n m68k_excess_precision (enum excess_precision_type);\n+static unsigned int m68k_hard_regno_nregs (unsigned int, machine_mode);\n static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool m68k_modes_tieable_p (machine_mode, machine_mode);\n \f\n@@ -336,6 +337,8 @@ static bool m68k_modes_tieable_p (machine_mode, machine_mode);\n #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS m68k_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK m68k_hard_regno_mode_ok\n \n@@ -5178,6 +5181,20 @@ m68k_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.\n+\n+   On the m68k, ordinary registers hold 32 bits worth;\n+   for the 68881 registers, a single register is always enough for\n+   anything that can be stored in them at all.  */\n+\n+static unsigned int\n+m68k_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno >= 16)\n+    return GET_MODE_NUNITS (mode);\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  On the 68000, we let the cpu\n    registers can hold any mode, but restrict the 68881 registers to\n    floating-point modes.  */"}, {"sha": "5d712ea2fed89627895b2d7001561cc0c90b3183", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -381,13 +381,6 @@ along with GCC; see the file COPYING3.  If not see\n }\n \n \n-/* On the m68k, ordinary registers hold 32 bits worth;\n-   for the 68881 registers, a single register is always enough for\n-   anything that can be stored in them at all.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= 16 ? GET_MODE_NUNITS (MODE)\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* A C expression that is nonzero if hard register NEW_REG can be\n    considered for use as a rename register for OLD_REG register.  */\n "}, {"sha": "e3b12aef18d1a9dc0e1dbf7ab08816ca24715ad5", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -239,15 +239,6 @@ extern char * mcore_current_function_name;\n  /* r7  r6  r5  r4  r3  r2  r15 r14 r13 r12 r11 r10  r9  r8  r1  r0  ap  c   fp x19*/ \\\n   {  7,  6,  5,  4,  3,  2,  15, 14, 13, 12, 11, 10,  9,  8,  1,  0, 16, 17, 18, 19}\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the MCore regs are UNITS_PER_WORD bits wide; */\n-#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n-   (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* Definitions for register eliminations.\n \n    We have two registers that can be eliminated on the MCore.  First, the"}, {"sha": "639b4f445d67e7ed9f263666526ed9edc9ebfcca", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -292,9 +292,6 @@ extern enum pipeline_type microblaze_pipe;\n #define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n #define ST_REG_P(REGNO) ((REGNO) == ST_REG)\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-\t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #define STACK_POINTER_REGNUM   (GP_REG_FIRST + MB_ABI_STACK_POINTER_REGNUM)\n \n #define STACK_POINTER_OFFSET   FIRST_PARM_OFFSET(FNDECL)"}, {"sha": "ed26aaa8184e700381cfe5831ddb3c8c8493dafd", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -323,7 +323,6 @@ extern const char *mips_output_division (const char *, rtx *);\n extern const char *mips_msa_output_division (const char *, rtx *);\n extern const char *mips_output_probe_stack_range (rtx, rtx);\n extern bool mips_hard_regno_rename_ok (unsigned int, unsigned int);\n-extern unsigned int mips_hard_regno_nregs (int, machine_mode);\n extern bool mips_linked_madd_p (rtx_insn *, rtx_insn *);\n extern bool mips_store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern int mips_dspalu_bypass_p (rtx, rtx);"}, {"sha": "266daec191935dc157a906725447f58e1f26fffc", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -12888,10 +12888,10 @@ mips_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n-/* Implement HARD_REGNO_NREGS.  */\n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n \n-unsigned int\n-mips_hard_regno_nregs (int regno, machine_mode mode)\n+static unsigned int\n+mips_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n   if (ST_REG_P (regno))\n     /* The size of FP status registers is always 4, because they only hold\n@@ -22591,6 +22591,8 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK mips_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS mips_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK mips_hard_regno_mode_ok\n "}, {"sha": "4ebefcca5bc510023db54aa9c76bea7303f8b50f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1959,8 +1959,6 @@ FP_ASM_SPEC \"\\\n    : COP3_REG_P (REGNO) ? '3' : '?')\n \n \n-#define HARD_REGNO_NREGS(REGNO, MODE) mips_hard_regno_nregs (REGNO, MODE)\n-\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG)\t\t\t\t\\\n   mips_hard_regno_rename_ok (OLD_REG, NEW_REG)\n "}, {"sha": "dc632f21c9f7642fe7d063936d2f4863b3de787f", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -380,12 +380,6 @@ struct GTY(()) machine_function\n /* The default one.  */\n #define REG_ALLOC_ORDER MMIX_MMIXWARE_ABI_REG_ALLOC_ORDER\n \n-/* Node: Values in Registers */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)            \t\\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \t\\\n-    / UNITS_PER_WORD)\n-\n /* Node: Leaf Functions */\n /* (empty) */\n \n@@ -438,7 +432,7 @@ enum reg_class\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n  mmix_secondary_reload_class (CLASS, MODE, X, 0)\n \n-#define CLASS_MAX_NREGS(CLASS, MODE) HARD_REGNO_NREGS (CLASS, MODE)\n+#define CLASS_MAX_NREGS(CLASS, MODE) targetm.hard_regno_nregs (CLASS, MODE)\n \n \n /* Node: Frame Layout */"}, {"sha": "9d909bc8e3acc4ec291940b86f1698719143d8f0", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -224,15 +224,6 @@ extern enum processor_type mn10300_tune_cpu;\n   , 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 50, 51 \\\n   }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* 4 data, and effectively 3 address registers is small as far as I'm\n    concerned.  */\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true"}, {"sha": "4730807c03fbe129e2cab8b037c19819e8c30996", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -176,13 +176,6 @@ enum reg_class\n #define REGNO_REG_CLASS(R) ((R < MOXIE_PC) ? GENERAL_REGS :\t\t\\\n                             (R == MOXIE_CC ? CC_REGS : SPECIAL_REGS))\n \n-/* A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of mode\n-   MODE.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\t   \\\n-   / UNITS_PER_WORD)\n-\n /* The Overall Framework of an Assembler File */\n \n #undef  ASM_SPEC"}, {"sha": "69f0352c842d5057a64287036985c05d0eb6938d", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -29,7 +29,6 @@ void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n void\tmsp430_expand_prologue (void);\n const char * msp430x_extendhisi (rtx *);\n void\tmsp430_fixup_compare_operands (machine_mode, rtx *);\n-int\tmsp430_hard_regno_nregs (int, machine_mode);\n int\tmsp430_hard_regno_nregs_has_padding (int, machine_mode);\n int\tmsp430_hard_regno_nregs_with_padding (int, machine_mode);\n bool    msp430_hwmult_enabled (void);"}, {"sha": "535d4baf6763d89d2c41156def438578c600d744", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -900,11 +900,11 @@ msp430_ms_bitfield_layout_p (const_tree record_type ATTRIBUTE_UNUSED)\n \n /* Register Usage */\n \n-/* Implements HARD_REGNO_NREGS.  MSP430X registers can hold a single\n-   PSImode value, but not an SImode value.  */\n-int\n-msp430_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n-\t\t\t machine_mode mode)\n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS msp430_hard_regno_nregs\n+\n+static unsigned int\n+msp430_hard_regno_nregs (unsigned int, machine_mode mode)\n {\n   if (mode == PSImode && msp430x)\n     return 1;"}, {"sha": "edc416cc1d0a84168f52c90b23690870dd56c5a2", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -332,9 +332,6 @@ typedef struct\n #define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n     fprintf (FILE, \"\\tcall\\t__mcount\\n\");\n \f\n-#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-  msp430_hard_regno_nregs (REGNO, MODE)\n-\f\n /* Exception Handling */\n \n /* R12,R13,R14 - EH data"}, {"sha": "433cb81c38dea65122eaf842a7c85e317425e4da", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -25,13 +25,6 @@\n \n extern void nds32_init_expanders (void);\n \n-\f\n-/* Register Usage.  */\n-\n-/* -- How Values Fit in Registers.  */\n-\n-extern int nds32_hard_regno_nregs (int, machine_mode);\n-\n \f\n /* Register Classes.  */\n "}, {"sha": "7e2e24a90372a7a6c92580aec2e3d68786d74f01", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -2746,20 +2746,13 @@ nds32_init_expanders (void)\n \n /* -- How Values Fit in Registers.  */\n \n-int\n-nds32_hard_regno_nregs (int regno ATTRIBUTE_UNUSED,\n-\t\t\tmachine_mode mode)\n-{\n-  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n-}\n-\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool\n nds32_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   /* Restrict double-word quantities to even register pairs.  */\n-  if (HARD_REGNO_NREGS (regno, mode) == 1\n+  if (targetm.hard_regno_nregs (regno, mode) == 1\n       || !((regno) & 1))\n     return true;\n "}, {"sha": "9a022f23ec7f987a61e30b92087b0d657fd502da", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -596,10 +596,6 @@ enum nds32_builtins\n    own cost calculations.  */\n #define HONOR_REG_ALLOC_ORDER optimize_size\n \n-/* The number of consecutive hard regs needed starting at\n-   reg \"regno\" for holding a value of mode \"mode\".  */\n-#define HARD_REGNO_NREGS(regno, mode) nds32_hard_regno_nregs (regno, mode)\n-\n \f\n /* Register Classes.  */\n "}, {"sha": "9a299f24d9b1dc60f979de1df50d247ce4c94126", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -172,9 +172,6 @@\n /*  30 */  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \\\n   }\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Order in which to allocate registers.  Each register must be\n    listed once.  This is the default ordering for R1 and non-CDX R2\n    code.  For CDX, we overwrite this in ADJUST_REG_ALLOC_ORDER.  */"}, {"sha": "cc34271e52a39a58eac0324b89a979ef2e9c6f15", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -5521,6 +5521,14 @@ nvptx_modes_tieable_p (machine_mode, machine_mode)\n   return false;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+nvptx_hard_regno_nregs (unsigned int, machine_mode)\n+{\n+  return 1;\n+}\n+\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE nvptx_option_override\n \n@@ -5648,6 +5656,9 @@ nvptx_modes_tieable_p (machine_mode, machine_mode)\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P nvptx_modes_tieable_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS nvptx_hard_regno_nregs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-nvptx.h\""}, {"sha": "8fccbc72aaf11176248428f155c74936f0862532", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -95,8 +95,6 @@\n #define FIXED_REGISTERS\t    { 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n #define CALL_USED_REGISTERS { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n \n-#define HARD_REGNO_NREGS(REG, MODE)\t\t\\\n-  ((void)(REG), (void)(MODE), 1)\n #define CANNOT_CHANGE_MODE_CLASS(M1, M2, CLS)\t\\\n   ((void)(M1), (void)(M2), (void)(CLS), true)\n "}, {"sha": "f9c7a7cdb4b8e8bf8cd57ae2769cf1192516a11c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -199,6 +199,7 @@ static unsigned int pa_section_type_flags (tree, const char *, int);\n static bool pa_legitimate_address_p (machine_mode, rtx, bool);\n static bool pa_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n+static unsigned int pa_hard_regno_nregs (unsigned int, machine_mode);\n static bool pa_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool pa_modes_tieable_p (machine_mode, machine_mode);\n \n@@ -409,6 +410,8 @@ static size_t n_deferred_plabels = 0;\n #undef TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS pa_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK pa_hard_regno_mode_ok\n #undef TARGET_MODES_TIEABLE_P\n@@ -10765,6 +10768,14 @@ pa_callee_copies (cumulative_args_t cum ATTRIBUTE_UNUSED,\n   return !TARGET_CALLER_COPIES;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+pa_hard_regno_nregs (unsigned int regno ATTRIBUTE_UNUSED, machine_mode mode)\n+{\n+  return PA_HARD_REGNO_NREGS (regno, mode);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "f168ecfeab3e80367db4968c9093d12eaf4580a8", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -166,7 +166,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    point registers are 64 bits wide.  Snake fp regs are treated as\n    32 bits wide since the left and right parts are independently\n    accessible.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+#define PA_HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\\\n   (FP_REGNO_P (REGNO)\t\t\t\t\t\t\t\\\n    ? (!TARGET_PA_11\t\t\t\t\t\t\t\\\n       ? COMPLEX_MODE_P (MODE) ? 2 : 1\t\t\t\t\t\\"}, {"sha": "15b88089e9a1d9c3b61f34ed9f2249a4a5938f30", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -137,7 +137,7 @@ along with GCC; see the file COPYING3.  If not see\n    WORD_SIZE bits.  Note that SCmode values are placed in a single FPR.\n    Thus, any patterns defined to operate on these values would have to\n    use the 32-bit addressability of the FPR registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+#define PA_HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* These are the valid FP modes.  */"}, {"sha": "fd50e6aeec7cc4f8f6533d61612641c1f0dcfc10", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -236,6 +236,8 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n #undef  TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P pdp11_scalar_mode_supported_p\n \n+#undef  TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS pdp11_hard_regno_nregs\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK pdp11_hard_regno_mode_ok\n \n@@ -1931,6 +1933,16 @@ pdp11_branch_cost ()\n   return (TARGET_BRANCH_CHEAP ? 0 : 1);\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+pdp11_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno <= PC_REGNUM)\n+    return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+  return 1;\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  On the pdp, the cpu registers\n    can hold any mode other than float (because otherwise we may end up\n    being asked to move from CPU to FPU register, which isn't a valid"}, {"sha": "cd1d135403542db03d15eb3f13117d9b6c50751a", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -164,18 +164,6 @@ extern const struct real_format pdp11_d_format;\n  0, 0, 0, 0, 0, 0, 1, 1 }\n \n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-*/\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-((REGNO <= PC_REGNUM)?\t\t\t\t\t\t\t\\\n-    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\t\\\n-    :1)\n-    \n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "77846763585be72bb89690e7f7df7d791458be72", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1977,6 +1977,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS rs6000_hard_regno_nregs_hook\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n \n@@ -2174,6 +2176,14 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+rs6000_hard_regno_nregs_hook (unsigned int regno, machine_mode mode)\n+{\n+  return rs6000_hard_regno_nregs[mode][regno];\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "c4b6dc39feff0a03f9001235420b3de50a6ef19f", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1263,11 +1263,6 @@ enum data_align { align_abi, align_opt, align_both };\n   (INT_REGNO_P (N) || ALTIVEC_REGNO_P (N)\t\t\t\t\\\n    || (TARGET_VSX && FP_REGNO_P (N)))\t\t\t\t\t\\\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs[(MODE)][(REGNO)]\n-\n /* When setting up caller-save slots (MODE == VOIDmode) ensure we allocate\n    enough space to account for vectors in FP regs.  However, TFmode/TDmode\n    should not use VSX instructions to do a caller save. */"}, {"sha": "ae551fb39775acbc265ba1ebcb3b3a2e5435e263", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -68,7 +68,6 @@ extern void riscv_expand_prologue (void);\n extern void riscv_expand_epilogue (bool);\n extern bool riscv_can_use_return_insn (void);\n extern rtx riscv_function_value (const_tree, const_tree, machine_mode);\n-extern unsigned int riscv_hard_regno_nregs (int, machine_mode);\n \n /* Routines implemented in riscv-c.c.  */\n void riscv_cpu_cpp_builtins (cpp_reader *);"}, {"sha": "999f93e1f1e3a8574392894c92d3cae8a39ae021", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -3519,6 +3519,18 @@ riscv_register_move_cost (machine_mode mode,\n   return SECONDARY_MEMORY_NEEDED (from, to, mode) ? 8 : 2;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+riscv_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (FP_REG_P (regno))\n+    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n+\n+  /* All other registers are word-sized.  */\n+  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool\n@@ -3571,18 +3583,6 @@ riscv_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n \t       && GET_MODE_CLASS (mode2) == MODE_FLOAT));\n }\n \n-/* Implement HARD_REGNO_NREGS.  */\n-\n-unsigned int\n-riscv_hard_regno_nregs (int regno, machine_mode mode)\n-{\n-  if (FP_REG_P (regno))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_REG - 1) / UNITS_PER_FP_REG;\n-\n-  /* All other registers are word-sized.  */\n-  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-}\n-\n /* Implement CLASS_MAX_NREGS.  */\n \n static unsigned char\n@@ -4104,6 +4104,8 @@ riscv_slow_unaligned_access (machine_mode, unsigned int)\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN riscv_expand_builtin\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS riscv_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK riscv_hard_regno_mode_ok\n "}, {"sha": "4e672119ce954d1f998bed5eef52265184ca16fa", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -292,8 +292,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n \n-#define HARD_REGNO_NREGS(REGNO, MODE) riscv_hard_regno_nregs (REGNO, MODE)\n-\n /* Use s0 as the frame pointer if it is so requested.  */\n #define HARD_FRAME_POINTER_REGNUM 8\n #define STACK_POINTER_REGNUM 2"}, {"sha": "a155df61b99207c3a76765f9b5b6e613d86bb8ac", "filename": "gcc/config/rl78/rl78-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78-protos.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -29,7 +29,6 @@ void\t\trl78_expand_eh_epilogue (rtx);\n void\t\trl78_expand_epilogue (void);\n void\t\trl78_expand_prologue (void);\n int\t\trl78_far_p (rtx x);\n-int\t\trl78_hard_regno_nregs (int, machine_mode);\n bool\t\trl78_hl_b_c_addr_p (rtx);\n int\t\trl78_initial_elimination_offset (int, int);\n bool\t\trl78_as_legitimate_address (machine_mode, rtx,"}, {"sha": "6b13a80a8f3b4ae08cf5e9f335e61b9a7d670a27", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -449,9 +449,11 @@ rl78_real_insns_ok (void)\n   return false;\n }\n \n-/* Implements HARD_REGNO_NREGS.  */\n-int\n-rl78_hard_regno_nregs (int regno, machine_mode mode)\n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS rl78_hard_regno_nregs\n+\n+static unsigned int\n+rl78_hard_regno_nregs (unsigned int regno, machine_mode mode)\n {\n   int rs = register_sizes[regno];\n   if (rs < 1)"}, {"sha": "0716715d3679147542d536e6700573c3146e900f", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -407,10 +407,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n     fprintf (FILE, \"\\tbsr\\t__mcount\\n\");\n \f\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-  rl78_hard_regno_nregs (REGNO, MODE)\n-\f\n-\n #define TEXT_SECTION_ASM_OP \".text\"\n #define DATA_SECTION_ASM_OP \".data\"\n #define BSS_SECTION_ASM_OP \".bss\""}, {"sha": "87b5d4db6e70f6d2e34334287ace11a01911c001", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1967,6 +1967,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_OPTION_FUNCTION_VERSIONS\n #define TARGET_OPTION_FUNCTION_VERSIONS common_function_versions\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS rs6000_hard_regno_nregs_hook\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n \n@@ -2141,6 +2143,14 @@ rs6000_hard_regno_mode_ok_uncached (int regno, machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+rs6000_hard_regno_nregs_hook (unsigned int regno, machine_mode mode)\n+{\n+  return rs6000_hard_regno_nregs[mode][regno];\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "7ac6e3b3d08ab9088ab487e178411038cfc42ba1", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1202,11 +1202,6 @@ enum data_align { align_abi, align_opt, align_both };\n   (INT_REGNO_P (N) || ALTIVEC_REGNO_P (N)\t\t\t\t\\\n    || (TARGET_VSX && FP_REGNO_P (N)))\t\t\t\t\t\\\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs[(MODE)][(REGNO)]\n-\n /* When setting up caller-save slots (MODE == VOIDmode) ensure we allocate\n    enough space to account for vectors in FP regs.  However, TFmode/TDmode\n    should not use VSX instructions to do a caller save. */"}, {"sha": "021cf5c8aa7abd76c269c9538917c6bafa5242fa", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -3434,6 +3434,14 @@ rx_atomic_sequence::~rx_atomic_sequence (void)\n     emit_insn (gen_mvtc (GEN_INT (CTRLREG_PSW), m_prev_psw_reg));\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+rx_hard_regno_nregs (unsigned int, machine_mode mode)\n+{\n+  return CLASS_MAX_NREGS (0, mode);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool\n@@ -3606,6 +3614,8 @@ rx_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n #undef  TARGET_LRA_P\n #define TARGET_LRA_P \t\t\t\trx_enable_lra\n \n+#undef  TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS\t\t\trx_hard_regno_nregs\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK\t\trx_hard_regno_mode_ok\n "}, {"sha": "93b51c18281c7076394a77ba87b115d25bb0d126", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -331,10 +331,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n     fprintf (FILE, \"\\tbsr\\t__mcount\\n\");\n \f\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)   CLASS_MAX_NREGS (0, MODE)\n-\n-\f\n-\n #define REGISTER_NAMES\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n     \"r0\",  \"r1\",  \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",\t\\"}, {"sha": "46d6c32bd9c40b02736299a8a60e6093f90c29af", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -496,7 +496,7 @@ struct GTY(()) machine_function\n         CONST_OK_FOR_CONSTRAINT_P((x), 'O', \"On\")\n \n #define REGNO_PAIR_OK(REGNO, MODE)                               \\\n-  (HARD_REGNO_NREGS ((REGNO), (MODE)) == 1 || !((REGNO) & 1))\n+  (s390_hard_regno_nregs ((REGNO), (MODE)) == 1 || !((REGNO) & 1))\n \n /* That's the read ahead of the dynamic branch prediction unit in\n    bytes on a z10 (or higher) CPU.  */\n@@ -10383,7 +10383,32 @@ s390_optimize_nonescaping_tx (void)\n   return;\n }\n \n-/* Implement TARGET_HARD_REGNO_MODE_OK.  */\n+/* Implement TARGET_HARD_REGNO_NREGS.  Because all registers in a class\n+   have the same size, this is equivalent to CLASS_MAX_NREGS.  */\n+\n+static unsigned int\n+s390_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  return s390_class_max_nregs (REGNO_REG_CLASS (regno), mode);\n+}\n+\n+/* Implement TARGET_HARD_REGNO_MODE_OK.\n+\n+   Integer modes <= word size fit into any GPR.\n+   Integer modes > word size fit into successive GPRs, starting with\n+   an even-numbered register.\n+   SImode and DImode fit into FPRs as well.\n+\n+   Floating point modes <= word size fit into any FPR or GPR.\n+   Floating point modes > word size (i.e. DFmode on 32-bit) fit\n+   into any FPR, or an even-odd GPR pair.\n+   TFmode fits only into an even-odd FPR pair.\n+\n+   Complex floating point modes fit either into two FPRs, or into\n+   successive GPRs (again starting with an even number).\n+   TCmode fits only into two successive even-odd FPR pairs.\n+\n+   Condition code modes fit only into the CC register.  */\n \n static bool\n s390_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n@@ -15977,6 +16002,8 @@ s390_asan_shadow_offset (void)\n #undef TARGET_HARD_REGNO_SCRATCH_OK\n #define TARGET_HARD_REGNO_SCRATCH_OK s390_hard_regno_scratch_ok\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS s390_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK s390_hard_regno_mode_ok\n #undef TARGET_MODES_TIEABLE_P"}, {"sha": "0682fb668bced796b3c1b43489e38c663fb9fd16", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -469,29 +469,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n      15, 32, 33, 34, 35, 36, 37 }\n \n \n-/* Fitting values into registers.  */\n-\n-/* Integer modes <= word size fit into any GPR.\n-   Integer modes > word size fit into successive GPRs, starting with\n-   an even-numbered register.\n-   SImode and DImode fit into FPRs as well.\n-\n-   Floating point modes <= word size fit into any FPR or GPR.\n-   Floating point modes > word size (i.e. DFmode on 32-bit) fit\n-   into any FPR, or an even-odd GPR pair.\n-   TFmode fits only into an even-odd FPR pair.\n-\n-   Complex floating point modes fit either into two FPRs, or into\n-   successive GPRs (again starting with an even number).\n-   TCmode fits only into two successive even-odd FPR pairs.\n-\n-   Condition code modes fit only into the CC register.  */\n-\n-/* Because all registers in a class have the same size HARD_REGNO_NREGS\n-   is equivalent to CLASS_MAX_NREGS.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n-  s390_class_max_nregs (REGNO_REG_CLASS (REGNO), (MODE))\n-\n #define HARD_REGNO_RENAME_OK(FROM, TO)          \\\n   s390_hard_regno_rename_ok ((FROM), (TO))\n "}, {"sha": "22e3939c26e4ca808a5fa5abe99731f7fc3602b7", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -322,6 +322,7 @@ static bool sh_legitimate_combined_insn (rtx_insn* insn);\n static bool sh_fixed_condition_code_regs (unsigned int* p1, unsigned int* p2);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n+static unsigned int sh_hard_regno_nregs (unsigned int, machine_mode);\n static bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool sh_modes_tieable_p (machine_mode, machine_mode);\n \f\n@@ -644,6 +645,8 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM sh_cannot_force_const_mem_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS sh_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK sh_hard_regno_mode_ok\n \n@@ -7954,7 +7957,7 @@ sh_pass_in_reg_p (const CUMULATIVE_ARGS& cum, machine_mode mode,\n \t      + int_size_in_bytes (type))\n \t     <= NPARM_REGS (SImode) * UNITS_PER_WORD)\n \t  : ((sh_round_reg (cum, mode)\n-\t      + HARD_REGNO_NREGS (BASE_ARG_REG (mode), mode))\n+\t      + sh_hard_regno_nregs (BASE_ARG_REG (mode), mode))\n \t     <= NPARM_REGS (mode)))\n        : sh_round_reg (cum, mode) < NPARM_REGS (mode)));\n }\n@@ -10503,6 +10506,17 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   return target;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  On the SH all but the XD regs are\n+   UNITS_PER_WORD bits wide.  */\n+\n+static unsigned int\n+sh_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (XD_REGISTER_P (regno))\n+    return CEIL (GET_MODE_SIZE (mode), 2 * UNITS_PER_WORD);\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.\n \n    We can allow any mode in any general register.  The special registers"}, {"sha": "56e5021f34e0eb1d68e44a970d887e131bb4595f", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -812,17 +812,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n   1,      1,      0,      0,\t\t\t\t\t\t\\\n }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the SH all but the XD regs are UNITS_PER_WORD bits wide.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-   (XD_REGISTER_P (REGNO) \\\n-    ? ((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD - 1)) / (2*UNITS_PER_WORD)) \\\n-    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* Specify the modes required to caller save a given hard regno.  */\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\\\n   sh_hard_regno_caller_save_mode ((REGNO), (NREGS), (MODE))"}, {"sha": "1a750ec8093709cb7a39dfb19144c271ea318fd0", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -676,6 +676,7 @@ static scalar_int_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static unsigned int sparc_min_arithmetic_precision (void);\n+static unsigned int sparc_hard_regno_nregs (unsigned int, machine_mode);\n static bool sparc_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool sparc_modes_tieable_p (machine_mode, machine_mode);\n \n@@ -905,6 +906,8 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS sparc_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK sparc_hard_regno_mode_ok\n \n@@ -13149,6 +13152,28 @@ sparc_regmode_natural_size (machine_mode mode)\n   return size;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.\n+\n+   On SPARC, ordinary registers hold 32 bits worth; this means both\n+   integer and floating point registers.  On v9, integer regs hold 64\n+   bits worth; floating point regs hold 32 bits worth (this includes the\n+   new fp regs as even the odd ones are included in the hard register\n+   count).  */\n+\n+static unsigned int\n+sparc_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno == SPARC_GSR_REG)\n+    return 1;\n+  if (TARGET_ARCH64)\n+    {\n+      if (SPARC_INT_REG_P (regno) || regno == FRAME_POINTER_REGNUM)\n+\treturn CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+      return CEIL (GET_MODE_SIZE (mode), 4);\n+    }\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.\n \n    ??? Because of the funny way we pass parameters we should allow certain"}, {"sha": "e037897d642e373474817bf0b18479b7bbccb817", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -745,25 +745,6 @@ extern enum cmodel sparc_cmodel;\n \t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1}\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On SPARC, ordinary registers hold 32 bits worth;\n-   this means both integer and floating point registers.\n-   On v9, integer regs hold 64 bits worth; floating point regs hold\n-   32 bits worth (this includes the new fp regs as even the odd ones are\n-   included in the hard register count).  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((REGNO) == SPARC_GSR_REG ? 1 :\t\t\t\t\t\\\n-   (TARGET_ARCH64\t\t\t\t\t\t\t\\\n-    ? (SPARC_INT_REG_P (REGNO) || (REGNO) == FRAME_POINTER_REGNUM\t\t\t\\\n-       ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\t\\\n-       : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\\\n-    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n-\n /* Due to the ARCH64 discrepancy above we must override this next\n    macro too.  */\n #define REGMODE_NATURAL_SIZE(MODE) sparc_regmode_natural_size (MODE)"}, {"sha": "279adf30b72d97682e8a9fcc42b798b65418ef47", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -281,6 +281,14 @@ spu_option_override (void)\n   REAL_MODE_FORMAT (SFmode) = &spu_single_format;\n }\n \f\n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+spu_hard_regno_nregs (unsigned int, machine_mode mode)\n+{\n+  return CEIL (GET_MODE_BITSIZE (mode), MAX_FIXED_MODE_SIZE);\n+}\n+\n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n    struct attribute_spec.handler.  */\n \n@@ -3870,7 +3878,7 @@ spu_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n \t   ? ((int_size_in_bytes (type) + 15) / 16)\n \t   : mode == VOIDmode\n \t   ? 1\n-\t   : HARD_REGNO_NREGS (cum, mode));\n+\t   : spu_hard_regno_nregs (FIRST_ARG_REGNUM, mode));\n }\n \n /* Implement TARGET_FUNCTION_ARG_PADDING.  */\n@@ -7382,6 +7390,9 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_MODES_TIEABLE_P\n #define TARGET_MODES_TIEABLE_P spu_modes_tieable_p\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS spu_hard_regno_nregs\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-spu.h\""}, {"sha": "1b01a74ab09e26ae9c11da4a633d9764448912ec", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -170,12 +170,6 @@ extern GTY(()) int spu_tune;\n     1, 1, 1 \\\n }\n \n-\f\n-/* Values in Registers */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-    ((GET_MODE_BITSIZE(MODE)+MAX_FIXED_MODE_SIZE-1)/MAX_FIXED_MODE_SIZE)\n-\n \f\n /* Register Classes */\n "}, {"sha": "faa965f2d736169fea4566fb468d5ef31d88fb15", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -139,12 +139,6 @@\n \n #define REG_ALLOC_ORDER { 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 10, 11, 12, 13, 14, 15, 16 }\n \n-\f\n-/* How Values Fit in Registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n \f\n /* Register Classes.  */\n "}, {"sha": "2cedd4270f5170dc7c64f39f71c4865aa807f5f4", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -156,9 +156,6 @@\n       66, 67\t\t\t\t\t\t\\\n }\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Register that holds an address into the text segment that can be\n    used by pic code.  */\n #define TILEGX_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)"}, {"sha": "a865c8a422d556033e804bcbc9293b97a1ea715e", "filename": "gcc/config/tilepro/tilepro.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -121,9 +121,6 @@\n       66\t\t\t\t\t\t\\\n }\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Register that holds an address into the text segment that can be\n    used by pic code.  */\n #define TILEPRO_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)"}, {"sha": "49fe3cd84c2bf1be91682b8f5be428c1dac6e012", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -291,15 +291,6 @@ extern GTY(()) rtx v850_compare_op1;\n   34, 35\t\t\t\t\t\t\t\t\\\n }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants."}, {"sha": "b6d31c23c1ad364c27c3f5809f4fccf6e7002e3d", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -135,14 +135,6 @@ along with GCC; see the file COPYING3.  If not see\n    Aside from that, you can include as many other registers as you like.  */\n #define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-   On the VAX, all registers are one word long.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "4a68f18835769791678785bda5f6f0a7771880c3", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -228,6 +228,8 @@ static void visium_init_libfuncs (void);\n \n static unsigned int visium_reorg (void);\n \n+static unsigned int visium_hard_regno_nregs (unsigned int, machine_mode);\n+\n static bool visium_hard_regno_mode_ok (unsigned int, machine_mode);\n \n static bool visium_modes_tieable_p (machine_mode, machine_mode);\n@@ -343,6 +345,9 @@ static bool visium_modes_tieable_p (machine_mode, machine_mode);\n #undef TARGET_FLAGS_REGNUM\n #define TARGET_FLAGS_REGNUM FLAGS_REGNUM\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS visium_hard_regno_nregs\n+\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK visium_hard_regno_mode_ok\n \n@@ -846,6 +851,16 @@ visium_hard_regno_rename_ok (unsigned int from ATTRIBUTE_UNUSED,\n   return 1;\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+visium_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (regno == MDB_REGNUM)\n+    return CEIL (GET_MODE_SIZE (mode), 2 * UNITS_PER_WORD);\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.\n \n    Modes with sizes which cross from the one register class to the\n@@ -863,7 +878,7 @@ visium_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n     return mode == SFmode || (mode == SImode && TARGET_FPU_IEEE);\n \n   return (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && HARD_REGNO_NREGS (regno, mode) == 1);\n+\t  && visium_hard_regno_nregs (regno, mode) == 1);\n }\n \n /* Implement TARGET_MODES_TIEABLE_P.  */"}, {"sha": "4e7485e3cd413aba324e5b0919d4f66e8fbd0225", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -556,16 +556,6 @@\n    50, 51, 52,                             /* flags, arg, frame */ \\\n    0, 34 }                                 /* r0, f0 */\n \n-/* `HARD_REGNO_NREGS (REGNO, MODE)'\n-\n-   A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of mode\n-   MODE.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-  ((REGNO) == MDB_REGNUM ?                    \\\n-  ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* `HARD_REGNO_RENAME_OK (OLD_REG, NEW_REG)'\n \n    A C expression which is nonzero if hard register NEW_REG can be\n@@ -751,18 +741,6 @@ enum reg_class\n #define CANNOT_CHANGE_MODE_CLASS(FROM,TO,CLASS) \\\n   (CLASS == MDB ? (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)) : 0)\n \n-/* `CLASS_MAX_NREGS (CLASS, MODE)'\n-\n-   A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact,\n-   the value of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be\n-   the maximum value of `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO\n-   values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)    \\\n   ((CLASS) == MDB ?                     \\\n   ((GET_MODE_SIZE (MODE) + 2 * UNITS_PER_WORD - 1) / (2 * UNITS_PER_WORD)) \\"}, {"sha": "9c11ae043b528f5f92aabc017a5c7440ef64da81", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -178,6 +178,7 @@ static bool xtensa_member_type_forces_blk (const_tree,\n \t\t\t\t\t   machine_mode mode);\n \n static void xtensa_conditional_register_usage (void);\n+static unsigned int xtensa_hard_regno_nregs (unsigned int, machine_mode);\n static bool xtensa_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool xtensa_modes_tieable_p (machine_mode, machine_mode);\n \n@@ -308,6 +309,8 @@ static bool xtensa_modes_tieable_p (machine_mode, machine_mode);\n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE xtensa_conditional_register_usage\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS xtensa_hard_regno_nregs\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK xtensa_hard_regno_mode_ok\n \n@@ -2262,6 +2265,16 @@ xtensa_option_override (void)\n     }\n }\n \n+/* Implement TARGET_HARD_REGNO_NREGS.  */\n+\n+static unsigned int\n+xtensa_hard_regno_nregs (unsigned int regno, machine_mode mode)\n+{\n+  if (FP_REG_P (regno))\n+    return CEIL (GET_MODE_SIZE (mode), UNITS_PER_FPREG);\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool"}, {"sha": "abdd8ef8066f72ccee9e78a06fa985d5a4962a3f", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -321,13 +321,6 @@ extern int leaf_function;\n #define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n #define ACC_REG_P(REGNO) ((unsigned) ((REGNO) - ACC_REG_FIRST) < ACC_REG_NUM)\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (FP_REG_P (REGNO) ?\t\t\t\t\t\t\t\\\n-\t((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG) : \\\n-\t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 1)\n "}, {"sha": "98e6015e378df019d9a4f9232f1e56c10c44482b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -2013,31 +2013,24 @@ This section discusses the macros that describe which kinds of values\n (specifically, which machine modes) each register can hold, and how many\n consecutive registers are needed for a given mode.\n \n-@defmac HARD_REGNO_NREGS (@var{regno}, @var{mode})\n-A C expression for the number of consecutive hard registers, starting\n+@deftypefn {Target Hook} {unsigned int} TARGET_HARD_REGNO_NREGS (unsigned int @var{regno}, machine_mode @var{mode})\n+This hook returns the number of consecutive hard registers, starting\n at register number @var{regno}, required to hold a value of mode\n-@var{mode}.  This macro must never return zero, even if a register\n+@var{mode}.  This hook must never return zero, even if a register\n cannot hold the requested mode - indicate that with\n @code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\n instead.\n \n-On a machine where all registers are exactly one word, a suitable\n-definition of this macro is\n-\n-@smallexample\n-#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-    / UNITS_PER_WORD)\n-@end smallexample\n-@end defmac\n+The default definition returns the number of words in @var{mode}.\n+@end deftypefn\n \n @defmac HARD_REGNO_NREGS_HAS_PADDING (@var{regno}, @var{mode})\n A C expression that is nonzero if a value of mode @var{mode}, stored\n in memory, ends with padding that causes it to take up more space than\n in registers starting at register number @var{regno} (as determined by\n multiplying GCC's notion of the size of the register when containing\n this mode by the number of registers returned by\n-@code{HARD_REGNO_NREGS}).  By default this is zero.\n+@code{TARGET_HARD_REGNO_NREGS}).  By default this is zero.\n \n For example, if a floating-point value is stored in three 32-bit\n registers but takes up 128 bits in memory, then this would be\n@@ -2798,10 +2791,10 @@ pressure.\n A target hook returns the maximum number of consecutive registers\n of class @var{rclass} needed to hold a value of mode @var{mode}.\n \n-This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\n-the value returned by @code{TARGET_CLASS_MAX_NREGS (@var{rclass},\n+This is closely related to the macro @code{TARGET_HARD_REGNO_NREGS}.\n+In fact, the value returned by @code{TARGET_CLASS_MAX_NREGS (@var{rclass},\n @var{mode})} target hook should be the maximum value of\n-@code{HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\n+@code{TARGET_HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\n values in the class @var{rclass}.\n \n This target hook helps control the handling of multiple-word values\n@@ -2815,9 +2808,9 @@ in words.\n A C expression for the maximum number of consecutive registers\n of class @var{class} needed to hold a value of mode @var{mode}.\n \n-This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\n+This is closely related to the macro @code{TARGET_HARD_REGNO_NREGS}.  In fact,\n the value of the macro @code{CLASS_MAX_NREGS (@var{class}, @var{mode})}\n-should be the maximum value of @code{HARD_REGNO_NREGS (@var{regno},\n+should be the maximum value of @code{TARGET_HARD_REGNO_NREGS (@var{regno},\n @var{mode})} for all @var{regno} values in the class @var{class}.\n \n This macro helps control the handling of multiple-word values"}, {"sha": "acf47e0d812b8d5a44260cbf839915e7a31cde38", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1804,31 +1804,15 @@ This section discusses the macros that describe which kinds of values\n (specifically, which machine modes) each register can hold, and how many\n consecutive registers are needed for a given mode.\n \n-@defmac HARD_REGNO_NREGS (@var{regno}, @var{mode})\n-A C expression for the number of consecutive hard registers, starting\n-at register number @var{regno}, required to hold a value of mode\n-@var{mode}.  This macro must never return zero, even if a register\n-cannot hold the requested mode - indicate that with\n-@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\n-instead.\n-\n-On a machine where all registers are exactly one word, a suitable\n-definition of this macro is\n-\n-@smallexample\n-#define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-    / UNITS_PER_WORD)\n-@end smallexample\n-@end defmac\n+@hook TARGET_HARD_REGNO_NREGS\n \n @defmac HARD_REGNO_NREGS_HAS_PADDING (@var{regno}, @var{mode})\n A C expression that is nonzero if a value of mode @var{mode}, stored\n in memory, ends with padding that causes it to take up more space than\n in registers starting at register number @var{regno} (as determined by\n multiplying GCC's notion of the size of the register when containing\n this mode by the number of registers returned by\n-@code{HARD_REGNO_NREGS}).  By default this is zero.\n+@code{TARGET_HARD_REGNO_NREGS}).  By default this is zero.\n \n For example, if a floating-point value is stored in three 32-bit\n registers but takes up 128 bits in memory, then this would be\n@@ -2372,9 +2356,9 @@ is @code{BITS_PER_WORD} bits wide is correct for your machine.\n A C expression for the maximum number of consecutive registers\n of class @var{class} needed to hold a value of mode @var{mode}.\n \n-This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\n+This is closely related to the macro @code{TARGET_HARD_REGNO_NREGS}.  In fact,\n the value of the macro @code{CLASS_MAX_NREGS (@var{class}, @var{mode})}\n-should be the maximum value of @code{HARD_REGNO_NREGS (@var{regno},\n+should be the maximum value of @code{TARGET_HARD_REGNO_NREGS (@var{regno},\n @var{mode})} for all @var{regno} values in the class @var{class}.\n \n This macro helps control the handling of multiple-word values"}, {"sha": "4061736f537efeb6227ebe9df907a43db0b40c08", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -509,7 +509,7 @@ init_reg_modes_target (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (j = 0; j < MAX_MACHINE_MODE; j++)\n       this_target_regs->x_hard_regno_nregs[i][j]\n-\t= HARD_REGNO_NREGS (i, (machine_mode)j);\n+\t= targetm.hard_regno_nregs (i, (machine_mode) j);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "a450a04c2374fbd8227bbaf01c5ff21758aaa7a8", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1802,7 +1802,7 @@ set_label_ref_label (rtx ref, rtx_insn *label)\n #define SET_REGNO(RTX, N) (df_ref_change_reg_with_loc (RTX, N))\n \n /* Return the number of consecutive registers in a REG.  This is always\n-   1 for pseudo registers and is determined by HARD_REGNO_NREGS for\n+   1 for pseudo registers and is determined by TARGET_HARD_REGNO_NREGS for\n    hard registers.  */\n #define REG_NREGS(RTX) (REG_CHECK (RTX)->nregs)\n "}, {"sha": "00c3e3f9b89f1c833b2a6a13deb0995adeb6608c", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -912,7 +912,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tCLEAR_BY_PIECES_P MOVE_BY_PIECES_P SET_BY_PIECES_P\t\t\\\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n \tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n-\tMODES_TIEABLE_P FUNCTION_ARG_PADDING SLOW_UNALIGNED_ACCESS\n+\tMODES_TIEABLE_P FUNCTION_ARG_PADDING SLOW_UNALIGNED_ACCESS\t\\\n+\tHARD_REGNO_NREGS\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "6462c942b4d567b7331203fa51b42e7e4e60b434", "filename": "gcc/target.def", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -5345,10 +5345,10 @@ DEFHOOK\n  \"A target hook returns the maximum number of consecutive registers\\n\\\n of class @var{rclass} needed to hold a value of mode @var{mode}.\\n\\\n \\n\\\n-This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\\n\\\n-the value returned by @code{TARGET_CLASS_MAX_NREGS (@var{rclass},\\n\\\n+This is closely related to the macro @code{TARGET_HARD_REGNO_NREGS}.\\n\\\n+In fact, the value returned by @code{TARGET_CLASS_MAX_NREGS (@var{rclass},\\n\\\n @var{mode})} target hook should be the maximum value of\\n\\\n-@code{HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\\n\\\n+@code{TARGET_HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\\n\\\n values in the class @var{rclass}.\\n\\\n \\n\\\n This target hook helps control the handling of multiple-word values\\n\\\n@@ -5424,6 +5424,19 @@ that are not actually in any insns yet, but will be later.\",\n  void, (void),\n  hook_void_void)\n \n+DEFHOOK\n+(hard_regno_nregs,\n+ \"This hook returns the number of consecutive hard registers, starting\\n\\\n+at register number @var{regno}, required to hold a value of mode\\n\\\n+@var{mode}.  This hook must never return zero, even if a register\\n\\\n+cannot hold the requested mode - indicate that with\\n\\\n+@code{TARGET_HARD_REGNO_MODE_OK} and/or @code{CANNOT_CHANGE_MODE_CLASS}\\n\\\n+instead.\\n\\\n+\\n\\\n+The default definition returns the number of words in @var{mode}.\",\n+ unsigned int, (unsigned int regno, machine_mode mode),\n+ default_hard_regno_nregs)\n+\n DEFHOOK\n (hard_regno_mode_ok,\n  \"This hook returns true if it is permissible to store a value\\n\\"}, {"sha": "d2b70827d72a537f06b8fbbd7cd350468679b99a", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -1424,6 +1424,14 @@ default_addr_space_convert (rtx op ATTRIBUTE_UNUSED,\n   gcc_unreachable ();\n }\n \n+/* The defualt implementation of TARGET_HARD_REGNO_NREGS.  */\n+\n+unsigned int\n+default_hard_regno_nregs (unsigned int, machine_mode mode)\n+{\n+  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+}\n+\n bool\n default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)\n {"}, {"sha": "a0bd4aa3e24c05b409381f01989386f490e8bc52", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c43f427972be6aecd3c85b854cdf601feb816316/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=c43f427972be6aecd3c85b854cdf601feb816316", "patch": "@@ -165,6 +165,7 @@ extern int default_reloc_rw_mask (void);\n extern tree default_mangle_decl_assembler_name (tree, tree);\n extern tree default_emutls_var_fields (tree, tree *);\n extern tree default_emutls_var_init (tree, tree, tree);\n+extern unsigned int default_hard_regno_nregs (unsigned int, machine_mode);\n extern bool default_hard_regno_scratch_ok (unsigned int);\n extern bool default_mode_dependent_address_p (const_rtx, addr_space_t);\n extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);"}]}