{"sha": "83647bf4511856b555c34287863f8db75be254c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM2NDdiZjQ1MTE4NTZiNTU1YzM0Mjg3ODYzZjhkYjc1YmUyNTRjNQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2006-11-23T23:35:59Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2006-11-23T23:35:59Z"}, "message": "* gfortran.dg/overload_1.f90: New test.\n\nFrom-SVN: r119135", "tree": {"sha": "ff7ba589f00fa66d213e74c5415ace97a8142db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7ba589f00fa66d213e74c5415ace97a8142db2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83647bf4511856b555c34287863f8db75be254c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83647bf4511856b555c34287863f8db75be254c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83647bf4511856b555c34287863f8db75be254c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83647bf4511856b555c34287863f8db75be254c5/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a2a61a2215ce2694ea8201e164a6448984b5071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2a61a2215ce2694ea8201e164a6448984b5071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a2a61a2215ce2694ea8201e164a6448984b5071"}], "stats": {"total": 187, "additions": 187, "deletions": 0}, "files": [{"sha": "d61436802db8c97539756f587595a472596829e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83647bf4511856b555c34287863f8db75be254c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83647bf4511856b555c34287863f8db75be254c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83647bf4511856b555c34287863f8db75be254c5", "patch": "@@ -1,3 +1,7 @@\n+2006-11-23  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* gfortran.dg/overload_1.f90: New test.\n+\n 2006-11-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c/9072 "}, {"sha": "97aa8433510f1afdec2c83fc64f1d623a05db9f7", "filename": "gcc/testsuite/gfortran.dg/overload_1.f90", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83647bf4511856b555c34287863f8db75be254c5/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83647bf4511856b555c34287863f8db75be254c5/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foverload_1.f90?ref=83647bf4511856b555c34287863f8db75be254c5", "patch": "@@ -0,0 +1,183 @@\n+! { dg-do run }\n+! tests that operator overloading works correctly for operators with\n+! different spellings\n+module m\n+  type t\n+     integer :: i\n+  end type t\n+  \n+  interface operator (==)\n+     module procedure teq\n+  end interface\n+\n+  interface operator (/=)\n+     module procedure tne\n+  end interface\n+\n+  interface operator (>)\n+     module procedure tgt\n+  end interface\n+\n+  interface operator (>=)\n+     module procedure tge\n+  end interface\n+  \n+  interface operator (<)\n+     module procedure tlt\n+  end interface\n+\n+  interface operator (<=)\n+     module procedure tle\n+  end interface\n+\n+  type u\n+     integer :: i\n+  end type u\n+  \n+  interface operator (.eq.)\n+     module procedure ueq\n+  end interface\n+\n+  interface operator (.ne.)\n+     module procedure une\n+  end interface\n+\n+  interface operator (.gt.)\n+     module procedure ugt\n+  end interface\n+\n+  interface operator (.ge.)\n+     module procedure uge\n+  end interface\n+  \n+  interface operator (.lt.)\n+     module procedure ult\n+  end interface\n+\n+  interface operator (.le.)\n+     module procedure ule\n+  end interface\n+\n+contains\n+  function teq (a, b)\n+    logical teq\n+    type (t), intent (in) :: a, b\n+\n+    teq = a%i == b%i\n+  end function teq\n+\n+  function tne (a, b)\n+    logical tne\n+    type (t), intent (in) :: a, b\n+\n+    tne = a%i /= b%i\n+  end function tne\n+\n+  function tgt (a, b)\n+    logical tgt\n+    type (t), intent (in) :: a, b\n+\n+    tgt = a%i > b%i\n+  end function tgt\n+\n+  function tge (a, b)\n+    logical tge\n+    type (t), intent (in) :: a, b\n+\n+    tge = a%i >= b%i\n+  end function tge\n+\n+  function tlt (a, b)\n+    logical tlt\n+    type (t), intent (in) :: a, b\n+\n+    tlt = a%i < b%i\n+  end function tlt\n+\n+  function tle (a, b)\n+    logical tle\n+    type (t), intent (in) :: a, b\n+\n+    tle = a%i <= b%i\n+  end function tle\n+\n+  function ueq (a, b)\n+    logical ueq\n+    type (u), intent (in) :: a, b\n+\n+    ueq = a%i == b%i\n+  end function ueq\n+\n+  function une (a, b)\n+    logical une\n+    type (u), intent (in) :: a, b\n+\n+    une = a%i /= b%i\n+  end function une\n+\n+  function ugt (a, b)\n+    logical ugt\n+    type (u), intent (in) :: a, b\n+\n+    ugt = a%i > b%i\n+  end function ugt\n+\n+  function uge (a, b)\n+    logical uge\n+    type (u), intent (in) :: a, b\n+\n+    uge = a%i >= b%i\n+  end function uge\n+\n+  function ult (a, b)\n+    logical ult\n+    type (u), intent (in) :: a, b\n+\n+    ult = a%i < b%i\n+  end function ult\n+\n+  function ule (a, b)\n+    logical ule\n+    type (u), intent (in) :: a, b\n+\n+    ule = a%i <= b%i\n+  end function ule\n+end module m\n+\n+\n+program main\n+  call checkt\n+  call checku\n+\n+contains\n+  \n+  subroutine checkt\n+    use m\n+\n+    type (t) :: a, b\n+    logical :: r1(6), r2(6)\n+    a%i = 0; b%i = 1\n+\n+    r1 = (/ a == b, a /= b, a <  b, a <= b, a >  b, a >= b /)\n+    r2 = (/ a.eq.b, a.ne.b, a.lt.b, a.le.b, a.gt.b, a.ge.b /)\n+    if (any (r1.neqv.r2)) call abort\n+    if (any (r1.neqv. &\n+         (/ .false.,.true.,.true., .true., .false.,.false. /) )) call&\n+         & abort\n+  end subroutine checkt\n+\n+  subroutine checku\n+    use m\n+\n+    type (u) :: a, b\n+    logical :: r1(6), r2(6)\n+    a%i = 0; b%i = 1\n+\n+    r1 = (/ a == b, a /= b, a <  b, a <= b, a >  b, a >= b /)\n+    r2 = (/ a.eq.b, a.ne.b, a.lt.b, a.le.b, a.gt.b, a.ge.b /)\n+    if (any (r1.neqv.r2)) call abort\n+    if (any (r1.neqv. &\n+         (/ .false.,.true.,.true., .true., .false.,.false. /) )) call&\n+         & abort\n+  end subroutine checku\n+end program main"}]}