{"sha": "d88b27daa164c87af447cc2243bf18d9a3543ff3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg4YjI3ZGFhMTY0Yzg3YWY0NDdjYzIyNDNiZjE4ZDlhMzU0M2ZmMw==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-11-20T17:56:30Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-11-20T17:56:30Z"}, "message": "AMD GCN libgomp plugin queue-full condition locking fix\n\n\tlibgomp/\n\t* plugin/plugin-gcn.c (wait_for_queue_nonfull): Don't lock/unlock\n\taq->mutex here.\n\t(queue_push_launch): Lock aq->mutex before calling\n\twait_for_queue_nonfull.\n\t(queue_push_callback): Likewise.\n\t(queue_push_asyncwait): Likewise.\n\t(queue_push_placeholder): Likewise.\n\nReviewed-by: Andrew Stubbs <ams@codesourcery.com>\n\nFrom-SVN: r278517", "tree": {"sha": "233fabd58e81614607b30bf5495b268343080f72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/233fabd58e81614607b30bf5495b268343080f72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d88b27daa164c87af447cc2243bf18d9a3543ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88b27daa164c87af447cc2243bf18d9a3543ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d88b27daa164c87af447cc2243bf18d9a3543ff3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d88b27daa164c87af447cc2243bf18d9a3543ff3/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d2f4ddfd70f2ad9829cdc404e9c382f6fc9b072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2f4ddfd70f2ad9829cdc404e9c382f6fc9b072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2f4ddfd70f2ad9829cdc404e9c382f6fc9b072"}], "stats": {"total": 33, "additions": 20, "deletions": 13}, "files": [{"sha": "c739b4179be1962bef4e85aac7969d70142759ac", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88b27daa164c87af447cc2243bf18d9a3543ff3/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88b27daa164c87af447cc2243bf18d9a3543ff3/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d88b27daa164c87af447cc2243bf18d9a3543ff3", "patch": "@@ -1,3 +1,13 @@\n+2019-11-20  Julian Brown  <julian@codesourcery.com>\n+\n+\t* plugin/plugin-gcn.c (wait_for_queue_nonfull): Don't lock/unlock\n+\taq->mutex here.\n+\t(queue_push_launch): Lock aq->mutex before calling\n+\twait_for_queue_nonfull.\n+\t(queue_push_callback): Likewise.\n+\t(queue_push_asyncwait): Likewise.\n+\t(queue_push_placeholder): Likewise.\n+\n 2019-11-20  Julian Brown  <julian@codesourcery.com>\n \n \t* plugin/plugin-gcn.c (hsa_memory_copy_wrapper): New."}, {"sha": "9287e27e022163496aaecc8163404e338151a013", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d88b27daa164c87af447cc2243bf18d9a3543ff3/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d88b27daa164c87af447cc2243bf18d9a3543ff3/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=d88b27daa164c87af447cc2243bf18d9a3543ff3", "patch": "@@ -2725,20 +2725,17 @@ drain_queue_synchronous (struct goacc_asyncqueue *aq)\n   pthread_mutex_unlock (&aq->mutex);\n }\n \n-/* Block the current thread until an async queue is writable.  */\n+/* Block the current thread until an async queue is writable.  The aq->mutex\n+   lock should be held on entry, and remains locked on exit.  */\n \n static void\n wait_for_queue_nonfull (struct goacc_asyncqueue *aq)\n {\n   if (aq->queue_n == ASYNC_QUEUE_SIZE)\n     {\n-      pthread_mutex_lock (&aq->mutex);\n-\n       /* Queue is full.  Wait for it to not be full.  */\n       while (aq->queue_n == ASYNC_QUEUE_SIZE)\n \tpthread_cond_wait (&aq->queue_cond_out, &aq->mutex);\n-\n-      pthread_mutex_unlock (&aq->mutex);\n     }\n }\n \n@@ -2752,10 +2749,10 @@ queue_push_launch (struct goacc_asyncqueue *aq, struct kernel_info *kernel,\n {\n   assert (aq->agent == kernel->agent);\n \n-  wait_for_queue_nonfull (aq);\n-\n   pthread_mutex_lock (&aq->mutex);\n \n+  wait_for_queue_nonfull (aq);\n+\n   int queue_last = ((aq->queue_first + aq->queue_n)\n \t\t    % ASYNC_QUEUE_SIZE);\n   if (DEBUG_QUEUES)\n@@ -2785,10 +2782,10 @@ static void\n queue_push_callback (struct goacc_asyncqueue *aq, void (*fn)(void *),\n \t\t     void *data)\n {\n-  wait_for_queue_nonfull (aq);\n-\n   pthread_mutex_lock (&aq->mutex);\n \n+  wait_for_queue_nonfull (aq);\n+\n   int queue_last = ((aq->queue_first + aq->queue_n)\n \t\t    % ASYNC_QUEUE_SIZE);\n   if (DEBUG_QUEUES)\n@@ -2818,10 +2815,10 @@ static void\n queue_push_asyncwait (struct goacc_asyncqueue *aq,\n \t\t      struct placeholder *placeholderp)\n {\n-  wait_for_queue_nonfull (aq);\n-\n   pthread_mutex_lock (&aq->mutex);\n \n+  wait_for_queue_nonfull (aq);\n+\n   int queue_last = ((aq->queue_first + aq->queue_n) % ASYNC_QUEUE_SIZE);\n   if (DEBUG_QUEUES)\n     GCN_DEBUG (\"queue_push_asyncwait %d:%d: at %i\\n\", aq->agent->device_id,\n@@ -2849,10 +2846,10 @@ queue_push_placeholder (struct goacc_asyncqueue *aq)\n {\n   struct placeholder *placeholderp;\n \n-  wait_for_queue_nonfull (aq);\n-\n   pthread_mutex_lock (&aq->mutex);\n \n+  wait_for_queue_nonfull (aq);\n+\n   int queue_last = ((aq->queue_first + aq->queue_n) % ASYNC_QUEUE_SIZE);\n   if (DEBUG_QUEUES)\n     GCN_DEBUG (\"queue_push_placeholder %d:%d: at %i\\n\", aq->agent->device_id,"}]}