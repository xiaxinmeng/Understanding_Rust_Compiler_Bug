{"sha": "685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1YjBkMTM0ZDdlN2RjMjEwYTg1YmRmYmQxODljOWY2OWY4MmE2Mg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-08-07T07:15:41Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-08-07T07:15:41Z"}, "message": "ipa-prop.h (enum jump_func_type): New value IPA_JF_ANCESTOR, changed comments.\n\n2009-08-07  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (enum jump_func_type): New value IPA_JF_ANCESTOR, changed\n\tcomments.\n\t(struct ipa_pass_through_data): New type.\n\t(struct ipa_ancestor_jf_data): New type.\n\t(union jump_func_value): Removed field formal_id, added fields\n\tpass_through and ancestor.\n\t(struct ipa_param_call_note): Changed type of formal_id to int from\n\tunsigned.\n\t* ipa-prop.c (ipa_print_node_jump_functions): Print pass through with\n\toperations jump functions and ancestor jump functions.\n\t(compute_complex_pass_through): New function.\n\t(compute_scalar_jump_functions): Call compute_complex_pass_through,\n\treflect changes in the jump function strucutre.\n\t(update_jump_functions_after_inlining): Ignore complex pass-through\n\tand ancestor jump functions.\n\t* ipa-cp.c (ipcp_lattice_from_jfunc): Added support for ancestor and\n\tpolynomial pass-through with operation jump functions.\n\nFrom-SVN: r150554", "tree": {"sha": "7db8c0f01fc8a04789a979aba7c5334034fbdd67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7db8c0f01fc8a04789a979aba7c5334034fbdd67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17f6e37dc188165f634dbb606ecb23892bf2e125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f6e37dc188165f634dbb606ecb23892bf2e125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f6e37dc188165f634dbb606ecb23892bf2e125"}], "stats": {"total": 254, "additions": 223, "deletions": 31}, "files": [{"sha": "96b291a5ae4c620b675a40ba2b242307304fbf47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "patch": "@@ -1,3 +1,23 @@\n+2009-08-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (enum jump_func_type): New value IPA_JF_ANCESTOR, changed\n+\tcomments.\n+\t(struct ipa_pass_through_data): New type.\n+\t(struct ipa_ancestor_jf_data): New type.\n+\t(union jump_func_value): Removed field formal_id, added fields\n+\tpass_through and ancestor.\n+\t(struct ipa_param_call_note): Changed type of formal_id to int from\n+\tunsigned.\n+\t* ipa-prop.c (ipa_print_node_jump_functions): Print pass through with\n+\toperations jump functions and ancestor jump functions.\n+\t(compute_complex_pass_through): New function.\n+\t(compute_scalar_jump_functions): Call compute_complex_pass_through,\n+\treflect changes in the jump function strucutre.\n+\t(update_jump_functions_after_inlining): Ignore complex pass-through\n+\tand ancestor jump functions.\n+\t* ipa-cp.c (ipcp_lattice_from_jfunc): Added support for ancestor and\n+\tpolynomial pass-through with operation jump functions.\n+\n 2009-08-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (output_fde): When doing hot/cold partitioning, use"}, {"sha": "df6972417bd8b61f94adf4e975e3f5ccbd3dc9a7", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "patch": "@@ -290,10 +290,43 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n   else if (jfunc->type == IPA_JF_PASS_THROUGH)\n     {\n       struct ipcp_lattice *caller_lat;\n+      tree cst;\n \n-      caller_lat = ipcp_get_lattice (info, jfunc->value.formal_id);\n+      caller_lat = ipcp_get_lattice (info, jfunc->value.pass_through.formal_id);\n       lat->type = caller_lat->type;\n-      lat->constant = caller_lat->constant;\n+      if (caller_lat->type != IPA_CONST_VALUE)\n+\treturn;\n+      cst = caller_lat->constant;\n+\n+      if (jfunc->value.pass_through.operation != NOP_EXPR)\n+\tcst = fold_binary (jfunc->value.pass_through.operation,\n+\t\t\t   TREE_TYPE (cst), cst,\n+\t\t\t   jfunc->value.pass_through.operand);\n+      gcc_assert (cst && is_gimple_ip_invariant (cst));\n+      lat->constant = cst;\n+    }\n+  else if (jfunc->type == IPA_JF_ANCESTOR)\n+    {\n+      struct ipcp_lattice *caller_lat;\n+      tree t;\n+      bool ok;\n+\n+      caller_lat = ipcp_get_lattice (info, jfunc->value.ancestor.formal_id);\n+      lat->type = caller_lat->type;\n+      if (caller_lat->type != IPA_CONST_VALUE)\n+\treturn;\n+      if (TREE_CODE (caller_lat->constant) != ADDR_EXPR)\n+\t{\n+\t  /* This can happen when the constant is a NULL pointer.  */\n+\t  lat->type = IPA_BOTTOM;\n+\t  return;\n+\t}\n+      t = TREE_OPERAND (caller_lat->constant, 0);\n+      ok = build_ref_for_offset (&t, TREE_TYPE (t),\n+\t\t\t\t jfunc->value.ancestor.offset,\n+\t\t\t\t jfunc->value.ancestor.type, false);\n+      gcc_assert (ok);\n+      lat->constant = build_fold_addr_expr (t);\n     }\n   else\n     lat->type = IPA_BOTTOM;"}, {"sha": "2842088d8f1b9d075c6f9456170edab6a06b50c7", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 117, "deletions": 15, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "patch": "@@ -300,8 +300,22 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t  else if (type == IPA_JF_PASS_THROUGH)\n  \t    {\n \t      fprintf (f, \"PASS THROUGH: \");\n-\t      fprintf (f, \"%d\\n\", jump_func->value.formal_id);\n+\t      fprintf (f, \"%d, op %s \",\n+\t\t       jump_func->value.pass_through.formal_id,\n+\t\t       tree_code_name[(int)\n+\t\t\t\t      jump_func->value.pass_through.operation]);\n+\t      if (jump_func->value.pass_through.operation != NOP_EXPR)\n+\t\tprint_generic_expr (dump_file,\n+\t\t\t\t    jump_func->value.pass_through.operand, 0);\n+\t      fprintf (dump_file, \"\\n\");\n  \t    }\n+\t  else if (type == IPA_JF_ANCESTOR)\n+\t    {\n+\t      fprintf (f, \"ANCESTOR: \");\n+\t      fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t\t       jump_func->value.ancestor.formal_id,\n+\t\t       jump_func->value.ancestor.offset);\n+\t    }\n \t}\n     }\n }\n@@ -320,6 +334,67 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n+/* Determine whether passing ssa name NAME constitutes a polynomial\n+   pass-through function or getting an address of an acestor and if so, write\n+   such a jump function to JFUNC.  INFO describes the caller.  */\n+\n+static void\n+compute_complex_pass_through (struct ipa_node_params *info,\n+\t\t\t      struct ipa_jump_func *jfunc,\n+\t\t\t      tree name)\n+{\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree op1, op2, type;\n+  int index;\n+  gimple stmt = SSA_NAME_DEF_STMT (name);\n+\n+  if (!is_gimple_assign (stmt))\n+    return;\n+  op1 = gimple_assign_rhs1 (stmt);\n+  op2 = gimple_assign_rhs2 (stmt);\n+\n+  if (op2)\n+    {\n+      if (TREE_CODE (op1) != SSA_NAME\n+\t  || !SSA_NAME_IS_DEFAULT_DEF (op1)\n+\t  || !is_gimple_ip_invariant (op2))\n+\treturn;\n+\n+      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n+      if (index >= 0)\n+\t{\n+\t  jfunc->type = IPA_JF_PASS_THROUGH;\n+\t  jfunc->value.pass_through.formal_id = index;\n+\t  jfunc->value.pass_through.operation = gimple_assign_rhs_code (stmt);\n+\t  jfunc->value.pass_through.operand = op2;\n+\t}\n+      return;\n+    }\n+\n+  if (TREE_CODE (op1) != ADDR_EXPR)\n+    return;\n+  op1 = TREE_OPERAND (op1, 0);\n+  type = TREE_TYPE (op1);\n+\n+  op1 = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n+  if (TREE_CODE (op1) != INDIRECT_REF)\n+    return;\n+  op1 = TREE_OPERAND (op1, 0);\n+  if (TREE_CODE (op1) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (op1))\n+    return;\n+\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n+  if (index >= 0)\n+    {\n+      jfunc->type = IPA_JF_ANCESTOR;\n+      jfunc->value.ancestor.formal_id = index;\n+      jfunc->value.ancestor.offset = offset;\n+      jfunc->value.ancestor.type = type;\n+    }\n+}\n+\n+\n /* Determine the jump functions of scalar arguments.  Scalar means SSA names\n    and constants of a number of selected types.  INFO is the ipa_node_params\n    structure associated with the caller, FUNCTIONS is a pointer to an array of\n@@ -343,15 +418,21 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t  functions[num].type = IPA_JF_CONST;\n \t  functions[num].value.constant = arg;\n \t}\n-      else if ((TREE_CODE (arg) == SSA_NAME) && SSA_NAME_IS_DEFAULT_DEF (arg))\n+      else if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n-\n-\t  if (index >= 0)\n+\t  if (SSA_NAME_IS_DEFAULT_DEF (arg))\n \t    {\n-\t      functions[num].type = IPA_JF_PASS_THROUGH;\n-\t      functions[num].value.formal_id = index;\n+\t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n+\n+\t      if (index >= 0)\n+\t\t{\n+\t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n+\t\t  functions[num].value.pass_through.formal_id = index;\n+\t\t  functions[num].value.pass_through.operation = NOP_EXPR;\n+\t\t}\n \t    }\n+\t  else\n+\t    compute_complex_pass_through (info, &functions[num], arg);\n \t}\n     }\n }\n@@ -418,7 +499,8 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      if (!ipa_is_param_modified (info, index))\n \t\t{\n \t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n-\t\t  functions[num].value.formal_id = index;\n+\t\t  functions[num].value.pass_through.formal_id = index;\n+\t\t  functions[num].value.pass_through.operation = NOP_EXPR;\n \t\t}\n \t      else\n \t\tundecided_members = true;\n@@ -883,7 +965,10 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n \n /* Update the jump functions associated with call graph edge E when the call\n    graph edge CS is being inlined, assuming that E->caller is already (possibly\n-   indirectly) inlined into CS->callee and that E has not been inlined.  */\n+   indirectly) inlined into CS->callee and that E has not been inlined.\n+\n+   We keep pass through functions only if they do not contain any operation.\n+   This is sufficient for inlining and greately simplifies things.  */\n \n static void\n update_jump_functions_after_inlining (struct cgraph_edge *cs,\n@@ -898,17 +983,26 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n     {\n       struct ipa_jump_func *src, *dst = ipa_get_ith_jump_func (args, i);\n \n+      if (dst->type == IPA_JF_ANCESTOR)\n+\t{\n+\t  dst->type = IPA_JF_UNKNOWN;\n+\t  continue;\n+\t}\n+\n       if (dst->type != IPA_JF_PASS_THROUGH)\n \tcontinue;\n \n-      /* We must check range due to calls with variable number of arguments:  */\n-      if (dst->value.formal_id >= (unsigned) ipa_get_cs_argument_count (top))\n+      /* We must check range due to calls with variable number of arguments and\n+\t we cannot combine jump functions with operations.  */\n+      if (dst->value.pass_through.operation != NOP_EXPR\n+\t  || (dst->value.pass_through.formal_id\n+\t      >= ipa_get_cs_argument_count (top)))\n \t{\n \t  dst->type = IPA_JF_UNKNOWN;\n \t  continue;\n \t}\n \n-      src = ipa_get_ith_jump_func (top, dst->value.formal_id);\n+      src = ipa_get_ith_jump_func (top, dst->value.pass_through.formal_id);\n       *dst = *src;\n     }\n }\n@@ -959,15 +1053,16 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \tcontinue;\n \n       /* We must check range due to calls with variable number of arguments:  */\n-      if (nt->formal_id >= (unsigned) ipa_get_cs_argument_count (top))\n+      if (nt->formal_id >= ipa_get_cs_argument_count (top))\n \t{\n \t  nt->processed = true;\n \t  continue;\n \t}\n \n       jfunc = ipa_get_ith_jump_func (top, nt->formal_id);\n-      if (jfunc->type == IPA_JF_PASS_THROUGH)\n-\tnt->formal_id = jfunc->value.formal_id;\n+      if (jfunc->type == IPA_JF_PASS_THROUGH\n+\t  && jfunc->value.pass_through.operation == NOP_EXPR)\n+\tnt->formal_id = jfunc->value.pass_through.formal_id;\n       else if (jfunc->type == IPA_JF_CONST\n \t       || jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n \t{\n@@ -1004,6 +1099,13 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t    VEC_safe_push (cgraph_edge_p, heap, *new_edges, new_indirect_edge);\n \t  top = IPA_EDGE_REF (cs);\n \t}\n+      else\n+\t{\n+\t  /* Ancestor jum functions and pass theoughs with operations should\n+\t     not be used on parameters that then get called.  */\n+\t  gcc_assert (jfunc->type == IPA_JF_UNKNOWN);\n+\t  nt->processed = true;\n+\t}\n     }\n   return res;\n }"}, {"sha": "9b5f74f87ad88f0c8271f7fcd3f631abea7ecbda", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/685b0d134d7e7dc210a85bdfbd189c9f69f82a62/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=685b0d134d7e7dc210a85bdfbd189c9f69f82a62", "patch": "@@ -31,18 +31,26 @@ along with GCC; see the file COPYING3.  If not see\n \n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. There are three main types of values :\n-   Formal - the caller's formal parameter is passed as an actual argument.\n-   Constant - a constant is passed as an actual argument.\n-   Unknown - neither of the above.\n-   Integer and real constants are represented as IPA_JF_CONST.\n-   Finally, IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers\n-   constants.  */\n+\n+   Pass-through - the caller's formal parameter is passed as an actual\n+                  argument, possibly one simple operation performed on it.\n+   Constant     - a constant (is_gimple_ip_invariant)is passed as an actual\n+                  argument.\n+   Unknown      - neither of the above.\n+\n+   IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers, other constants are\n+   represented with IPA_JF_CONST.\n+\n+   In addition to \"ordinary\" pass through functions represented by\n+   IPA_JF_PASS_THROUGH, IPA_JF_ANCESTOR represents getting addresses of of\n+   ancestor fields in C++ (e.g. &this_1(D)->D.1766.D.1756).  */\n enum jump_func_type\n {\n   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n   IPA_JF_CONST,\n   IPA_JF_CONST_MEMBER_PTR,\n-  IPA_JF_PASS_THROUGH\n+  IPA_JF_PASS_THROUGH,\n+  IPA_JF_ANCESTOR\n };\n \n /* All formal parameters in the program have a lattice associated with it\n@@ -61,6 +69,36 @@ enum ipa_lattice_type\n   IPA_TOP\n };\n \n+\n+/* Structure holding data required to describe a pass-through jump function.  */\n+\n+struct ipa_pass_through_data\n+{\n+  /* If an operation is to be performed on the original parameter, this is the\n+     second (constant) operand.  */\n+  tree operand;\n+  /* Number of the caller's formal parameter being passed.  */\n+  int formal_id;\n+  /* Operation that is performed on the argument before it is passed on.\n+     NOP_EXPR means no operation.  Otherwise oper must be a simple binary\n+     arithmetic operation where the caller's parameter is the first operand and\n+     operand field from this structure is the second one.  */\n+  enum tree_code operation;\n+};\n+\n+/* Structure holding data required to describe and ancestor pass throu\n+   funkci.  */\n+\n+struct ipa_ancestor_jf_data\n+{\n+  /* Offset of the field representing the ancestor.  */\n+  HOST_WIDE_INT offset;\n+  /* TYpe of the result.  */\n+  tree type;\n+  /* Number of the caller's formal parameter being passed.  */\n+  int formal_id;\n+};\n+\n /* Structure holding a C++ member pointer constant.  Holds a pointer to the\n    method and delta offset.  */\n struct ipa_member_ptr_cst\n@@ -69,15 +107,14 @@ struct ipa_member_ptr_cst\n   tree delta;\n };\n \n-/* Represents a value of a jump function.  formal_id is used only in jump\n-   function context and represents pass-through parameter (the formal parameter\n-   of the caller is passed as argument).  constant represents the actual\n-   constant in constant jump functions and member_cst holds constant c++ member\n-   functions.  */\n+/* Represents a value of a jump function.  pass_through is used only in jump\n+   function context.  constant represents the actual constant in constant jump\n+   functions and member_cst holds constant c++ member functions.  */\n union jump_func_value\n {\n-  unsigned int formal_id;\n   tree constant;\n+  struct ipa_pass_through_data pass_through;\n+  struct ipa_ancestor_jf_data ancestor;\n   struct ipa_member_ptr_cst member_cst;\n };\n \n@@ -109,7 +146,7 @@ struct ipa_param_call_note\n   /* Statement that contains the call to the parameter above.  */\n   gimple stmt;\n   /* Index of the parameter that is called.  */\n-  unsigned int formal_id;\n+  int formal_id;\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n   /* Expected frequency of executions within the function. see cgraph_edge in"}]}