{"sha": "c61f89850a5c6721e859041f04d5315deb021522", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYxZjg5ODUwYTVjNjcyMWU4NTkwNDFmMDRkNTMxNWRlYjAyMTUyMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-05-31T14:39:52Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-05-31T14:39:52Z"}, "message": "tree-loop-distribution.c (struct partition_s): New struct, typedef and vector type.\n\n2012-05-31  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (struct partition_s): New struct,\n\ttypedef and vector type.\n\t(partition_alloc, partition_free): New functions.\n\t(generate_loops_for_partition, generate_builtin,\n\tgenerate_code_for_partition, rdg_flag_uses, rdg_flag_vertex,\n\trdg_flag_vertex_and_dependent, rdg_flag_loop_exits,\n\tbuild_rdg_partition_for_component, can_generate_builtin,\n\tsimilar_memory_accesses, fuse_partitions_with_similar_memory_accesses,\n\trdg_build_partitions, dump_rdg_partitions, debug_rdg_partitions,\n\tnumber_of_rw_in_partition, partition_contains_all_rw,\n\tldist_gen): Use partition_t instead of bitmap.\n\nFrom-SVN: r188064", "tree": {"sha": "299bfa422f5819eba0b2f97c9d211e573c2936c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/299bfa422f5819eba0b2f97c9d211e573c2936c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c61f89850a5c6721e859041f04d5315deb021522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61f89850a5c6721e859041f04d5315deb021522", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c61f89850a5c6721e859041f04d5315deb021522", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61f89850a5c6721e859041f04d5315deb021522/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc2442cd78651d159418ac8e739bfc93f925ab2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2442cd78651d159418ac8e739bfc93f925ab2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2442cd78651d159418ac8e739bfc93f925ab2b"}], "stats": {"total": 166, "additions": 106, "deletions": 60}, "files": [{"sha": "fb791bb53a98e51a99e79be822f25b198f5ec9f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c61f89850a5c6721e859041f04d5315deb021522/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c61f89850a5c6721e859041f04d5315deb021522/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c61f89850a5c6721e859041f04d5315deb021522", "patch": "@@ -1,3 +1,17 @@\n+2012-05-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (struct partition_s): New struct,\n+\ttypedef and vector type.\n+\t(partition_alloc, partition_free): New functions.\n+\t(generate_loops_for_partition, generate_builtin,\n+\tgenerate_code_for_partition, rdg_flag_uses, rdg_flag_vertex,\n+\trdg_flag_vertex_and_dependent, rdg_flag_loop_exits,\n+\tbuild_rdg_partition_for_component, can_generate_builtin,\n+\tsimilar_memory_accesses, fuse_partitions_with_similar_memory_accesses,\n+\trdg_build_partitions, dump_rdg_partitions, debug_rdg_partitions,\n+\tnumber_of_rw_in_partition, partition_contains_all_rw,\n+\tldist_gen): Use partition_t instead of bitmap.\n+\n 2012-05-31  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-loop-distribution.c (stmt_has_scalar_dependences_outside_loop):"}, {"sha": "3802467ac123e7e88dd10d6e97b84927830870b3", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 92, "deletions": 60, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c61f89850a5c6721e859041f04d5315deb021522/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c61f89850a5c6721e859041f04d5315deb021522/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=c61f89850a5c6721e859041f04d5315deb021522", "patch": "@@ -52,6 +52,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n \n+typedef struct partition_s\n+{\n+  bitmap stmts;\n+} *partition_t;\n+\n+DEF_VEC_P (partition_t);\n+DEF_VEC_ALLOC_P (partition_t, heap);\n+\n+/* Allocate and initialize a partition from BITMAP.  */\n+\n+static partition_t\n+partition_alloc (bitmap stmts)\n+{\n+  partition_t partition = XCNEW (struct partition_s);\n+  partition->stmts = stmts ? stmts : BITMAP_ALLOC (NULL);\n+  return partition;\n+}\n+\n+/* Free PARTITION.  */\n+\n+static void\n+partition_free (partition_t partition)\n+{\n+  BITMAP_FREE (partition->stmts);\n+  free (partition);\n+}\n+\n+\n /* If bit I is not set, it means that this node represents an\n    operation that has already been performed, and that should not be\n    performed again.  This is the subgraph of remaining important\n@@ -192,7 +220,8 @@ create_bb_after_loop (struct loop *loop)\n    the code gen succeeded. */\n \n static bool\n-generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n+generate_loops_for_partition (struct loop *loop, partition_t partition,\n+\t\t\t      bool copy_p)\n {\n   unsigned i, x;\n   gimple_stmt_iterator bsi;\n@@ -219,15 +248,15 @@ generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n \tbasic_block bb = bbs[i];\n \n \tfor (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t  if (!bitmap_bit_p (partition, x++))\n+\t  if (!bitmap_bit_p (partition->stmts, x++))\n \t    reset_debug_uses (gsi_stmt (bsi));\n \n \tfor (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t  {\n \t    gimple stmt = gsi_stmt (bsi);\n \t    if (gimple_code (stmt) != GIMPLE_LABEL\n \t\t&& !is_gimple_debug (stmt)\n-\t\t&& !bitmap_bit_p (partition, x++))\n+\t\t&& !bitmap_bit_p (partition->stmts, x++))\n \t      reset_debug_uses (stmt);\n \t  }\n       }\n@@ -237,7 +266,7 @@ generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n       basic_block bb = bbs[i];\n \n       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi);)\n-\tif (!bitmap_bit_p (partition, x++))\n+\tif (!bitmap_bit_p (partition->stmts, x++))\n \t  {\n \t    gimple phi = gsi_stmt (bsi);\n \t    if (!is_gimple_reg (gimple_phi_result (phi)))\n@@ -252,7 +281,7 @@ generate_loops_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n \t  gimple stmt = gsi_stmt (bsi);\n \t  if (gimple_code (stmt) != GIMPLE_LABEL\n \t      && !is_gimple_debug (stmt)\n-\t      && !bitmap_bit_p (partition, x++))\n+\t      && !bitmap_bit_p (partition->stmts, x++))\n \t    {\n \t      unlink_stmt_vdef (stmt);\n \t      gsi_remove (&bsi, true);\n@@ -337,7 +366,7 @@ generate_memset_zero (gimple stmt, tree op0, tree nb_iter,\n    operation succeeded.  */\n \n static bool\n-generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n+generate_builtin (struct loop *loop, partition_t partition, bool copy_p)\n {\n   bool res = false;\n   unsigned i, x = 0;\n@@ -366,7 +395,7 @@ generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n \t      || is_gimple_debug (stmt))\n \t    continue;\n \n-\t  if (!bitmap_bit_p (partition, x++))\n+\t  if (!bitmap_bit_p (partition->stmts, x++))\n \t    continue;\n \n \t  /* If the stmt has uses outside of the loop fail.\n@@ -432,7 +461,8 @@ generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n    generate a built-in.  */\n \n static bool\n-generate_code_for_partition (struct loop *loop, bitmap partition, bool copy_p)\n+generate_code_for_partition (struct loop *loop, partition_t partition,\n+\t\t\t     bool copy_p)\n {\n   if (generate_builtin (loop, partition, copy_p))\n     return true;\n@@ -544,14 +574,14 @@ has_upstream_mem_writes (int u)\n   return bitmap_bit_p (upstream_mem_writes, u);\n }\n \n-static void rdg_flag_vertex_and_dependent (struct graph *, int, bitmap, bitmap,\n-\t\t\t\t\t   bitmap, bool *);\n+static void rdg_flag_vertex_and_dependent (struct graph *, int, partition_t,\n+\t\t\t\t\t   bitmap, bitmap, bool *);\n \n /* Flag the uses of U stopping following the information from\n    upstream_mem_writes.  */\n \n static void\n-rdg_flag_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,\n+rdg_flag_uses (struct graph *rdg, int u, partition_t partition, bitmap loops,\n \t       bitmap processed, bool *part_has_writes)\n {\n   use_operand_p use_p;\n@@ -617,12 +647,12 @@ rdg_flag_uses (struct graph *rdg, int u, bitmap partition, bitmap loops,\n    in LOOPS.  */\n \n static void\n-rdg_flag_vertex (struct graph *rdg, int v, bitmap partition, bitmap loops,\n+rdg_flag_vertex (struct graph *rdg, int v, partition_t partition, bitmap loops,\n \t\t bool *part_has_writes)\n {\n   struct loop *loop;\n \n-  if (!bitmap_set_bit (partition, v))\n+  if (!bitmap_set_bit (partition->stmts, v))\n     return;\n \n   loop = loop_containing_stmt (RDG_STMT (rdg, v));\n@@ -639,7 +669,7 @@ rdg_flag_vertex (struct graph *rdg, int v, bitmap partition, bitmap loops,\n    Also flag their loop number in LOOPS.  */\n \n static void\n-rdg_flag_vertex_and_dependent (struct graph *rdg, int v, bitmap partition,\n+rdg_flag_vertex_and_dependent (struct graph *rdg, int v, partition_t partition,\n \t\t\t       bitmap loops, bitmap processed,\n \t\t\t       bool *part_has_writes)\n {\n@@ -686,7 +716,7 @@ collect_condition_stmts (struct loop *loop, VEC (gimple, heap) **conds)\n    RDG.  */\n \n static void\n-rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n+rdg_flag_loop_exits (struct graph *rdg, bitmap loops, partition_t partition,\n \t\t     bitmap processed, bool *part_has_writes)\n {\n   unsigned i;\n@@ -720,12 +750,12 @@ rdg_flag_loop_exits (struct graph *rdg, bitmap loops, bitmap partition,\n    the strongly connected component C of the RDG are flagged, also\n    including the loop exit conditions.  */\n \n-static bitmap\n+static partition_t\n build_rdg_partition_for_component (struct graph *rdg, rdgc c,\n \t\t\t\t   bool *part_has_writes)\n {\n   int i, v;\n-  bitmap partition = BITMAP_ALLOC (NULL);\n+  partition_t partition = partition_alloc (NULL);\n   bitmap loops = BITMAP_ALLOC (NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n \n@@ -803,15 +833,15 @@ rdg_build_components (struct graph *rdg, VEC (int, heap) *starting_vertices,\n    zero pattern.  */\n \n static bool\n-can_generate_builtin (struct graph *rdg, bitmap partition)\n+can_generate_builtin (struct graph *rdg, partition_t partition)\n {\n   unsigned i;\n   bitmap_iterator bi;\n   int nb_reads = 0;\n   int nb_writes = 0;\n   int stores_zero = 0;\n \n-  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, bi)\n     if (RDG_MEM_READS_STMT (rdg, i))\n       nb_reads++;\n     else if (RDG_MEM_WRITE_STMT (rdg, i))\n@@ -830,16 +860,16 @@ can_generate_builtin (struct graph *rdg, bitmap partition)\n    accesses in RDG.  */\n \n static bool\n-similar_memory_accesses (struct graph *rdg, bitmap partition1,\n-\t\t\t bitmap partition2)\n+similar_memory_accesses (struct graph *rdg, partition_t partition1,\n+\t\t\t partition_t partition2)\n {\n   unsigned i, j;\n   bitmap_iterator bi, bj;\n \n-  EXECUTE_IF_SET_IN_BITMAP (partition1, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (partition1->stmts, 0, i, bi)\n     if (RDG_MEM_WRITE_STMT (rdg, i)\n \t|| RDG_MEM_READS_STMT (rdg, i))\n-      EXECUTE_IF_SET_IN_BITMAP (partition2, 0, j, bj)\n+      EXECUTE_IF_SET_IN_BITMAP (partition2->stmts, 0, j, bj)\n \tif (RDG_MEM_WRITE_STMT (rdg, j)\n \t    || RDG_MEM_READS_STMT (rdg, j))\n \t  if (rdg_has_similar_memory_accesses (rdg, i, j))\n@@ -855,20 +885,20 @@ similar_memory_accesses (struct graph *rdg, bitmap partition1,\n \n static void\n fuse_partitions_with_similar_memory_accesses (struct graph *rdg,\n-\t\t\t\t\t      VEC (bitmap, heap) **partitions)\n+\t\t\t\t\t      VEC (partition_t, heap) **partitions)\n {\n   int p1, p2;\n-  bitmap partition1, partition2;\n+  partition_t partition1, partition2;\n \n-  FOR_EACH_VEC_ELT (bitmap, *partitions, p1, partition1)\n+  FOR_EACH_VEC_ELT (partition_t, *partitions, p1, partition1)\n     if (!can_generate_builtin (rdg, partition1))\n-      FOR_EACH_VEC_ELT (bitmap, *partitions, p2, partition2)\n+      FOR_EACH_VEC_ELT (partition_t, *partitions, p2, partition2)\n \tif (p1 != p2\n \t    && !can_generate_builtin (rdg, partition2)\n \t    && similar_memory_accesses (rdg, partition1, partition2))\n \t  {\n-\t    bitmap_ior_into (partition1, partition2);\n-\t    VEC_ordered_remove (bitmap, *partitions, p2);\n+\t    bitmap_ior_into (partition1->stmts, partition2->stmts);\n+\t    VEC_ordered_remove (partition_t, *partitions, p2);\n \t    p2--;\n \t  }\n }\n@@ -880,36 +910,36 @@ fuse_partitions_with_similar_memory_accesses (struct graph *rdg,\n static void\n rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n \t\t      VEC (int, heap) **other_stores,\n-\t\t      VEC (bitmap, heap) **partitions, bitmap processed)\n+\t\t      VEC (partition_t, heap) **partitions, bitmap processed)\n {\n   int i;\n   rdgc x;\n-  bitmap partition = BITMAP_ALLOC (NULL);\n+  partition_t partition = partition_alloc (NULL);\n \n   FOR_EACH_VEC_ELT (rdgc, components, i, x)\n     {\n-      bitmap np;\n+      partition_t np;\n       bool part_has_writes = false;\n       int v = VEC_index (int, x->vertices, 0);\n \n       if (bitmap_bit_p (processed, v))\n \tcontinue;\n \n       np = build_rdg_partition_for_component (rdg, x, &part_has_writes);\n-      bitmap_ior_into (partition, np);\n-      bitmap_ior_into (processed, np);\n-      BITMAP_FREE (np);\n+      bitmap_ior_into (partition->stmts, np->stmts);\n+      bitmap_ior_into (processed, np->stmts);\n+      partition_free (np);\n \n       if (part_has_writes)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"ldist useful partition:\\n\");\n-\t      dump_bitmap (dump_file, partition);\n+\t      dump_bitmap (dump_file, partition->stmts);\n \t    }\n \n-\t  VEC_safe_push (bitmap, heap, *partitions, partition);\n-\t  partition = BITMAP_ALLOC (NULL);\n+\t  VEC_safe_push (partition_t, heap, *partitions, partition);\n+\t  partition = partition_alloc (NULL);\n \t}\n     }\n \n@@ -937,31 +967,31 @@ rdg_build_partitions (struct graph *rdg, VEC (rdgc, heap) *components,\n     }\n \n   /* If there is something left in the last partition, save it.  */\n-  if (bitmap_count_bits (partition) > 0)\n-    VEC_safe_push (bitmap, heap, *partitions, partition);\n+  if (bitmap_count_bits (partition->stmts) > 0)\n+    VEC_safe_push (partition_t, heap, *partitions, partition);\n   else\n-    BITMAP_FREE (partition);\n+    partition_free (partition);\n \n   fuse_partitions_with_similar_memory_accesses (rdg, partitions);\n }\n \n /* Dump to FILE the PARTITIONS.  */\n \n static void\n-dump_rdg_partitions (FILE *file, VEC (bitmap, heap) *partitions)\n+dump_rdg_partitions (FILE *file, VEC (partition_t, heap) *partitions)\n {\n   int i;\n-  bitmap partition;\n+  partition_t partition;\n \n-  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n-    debug_bitmap_file (file, partition);\n+  FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n+    debug_bitmap_file (file, partition->stmts);\n }\n \n /* Debug PARTITIONS.  */\n-extern void debug_rdg_partitions (VEC (bitmap, heap) *);\n+extern void debug_rdg_partitions (VEC (partition_t, heap) *);\n \n DEBUG_FUNCTION void\n-debug_rdg_partitions (VEC (bitmap, heap) *partitions)\n+debug_rdg_partitions (VEC (partition_t, heap) *partitions)\n {\n   dump_rdg_partitions (stderr, partitions);\n }\n@@ -989,13 +1019,13 @@ number_of_rw_in_rdg (struct graph *rdg)\n    the RDG.  */\n \n static int\n-number_of_rw_in_partition (struct graph *rdg, bitmap partition)\n+number_of_rw_in_partition (struct graph *rdg, partition_t partition)\n {\n   int res = 0;\n   unsigned i;\n   bitmap_iterator ii;\n \n-  EXECUTE_IF_SET_IN_BITMAP (partition, 0, i, ii)\n+  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, i, ii)\n     {\n       if (RDG_MEM_WRITE_STMT (rdg, i))\n \t++res;\n@@ -1011,13 +1041,13 @@ number_of_rw_in_partition (struct graph *rdg, bitmap partition)\n    write operations of RDG.  */\n \n static bool\n-partition_contains_all_rw (struct graph *rdg, VEC (bitmap, heap) *partitions)\n+partition_contains_all_rw (struct graph *rdg, VEC (partition_t, heap) *partitions)\n {\n   int i;\n-  bitmap partition;\n+  partition_t partition;\n   int nrw = number_of_rw_in_rdg (rdg);\n \n-  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n+  FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n     if (nrw == number_of_rw_in_partition (rdg, partition))\n       return true;\n \n@@ -1033,9 +1063,10 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n {\n   int i, nbp;\n   VEC (rdgc, heap) *components = VEC_alloc (rdgc, heap, 3);\n-  VEC (bitmap, heap) *partitions = VEC_alloc (bitmap, heap, 3);\n+  VEC (partition_t, heap) *partitions = VEC_alloc (partition_t, heap, 3);\n   VEC (int, heap) *other_stores = VEC_alloc (int, heap, 3);\n-  bitmap partition, processed = BITMAP_ALLOC (NULL);\n+  partition_t partition;\n+  bitmap processed = BITMAP_ALLOC (NULL);\n \n   remaining_stmts = BITMAP_ALLOC (NULL);\n   upstream_mem_writes = BITMAP_ALLOC (NULL);\n@@ -1069,19 +1100,20 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   rdg_build_partitions (rdg, components, &other_stores, &partitions,\n \t\t\tprocessed);\n   BITMAP_FREE (processed);\n-  nbp = VEC_length (bitmap, partitions);\n \n+  nbp = VEC_length (partition_t, partitions);\n   if (nbp == 0\n       || (nbp == 1\n-\t  && !can_generate_builtin (rdg, VEC_index (bitmap, partitions, 0)))\n+\t  && !can_generate_builtin (rdg,\n+\t\t\t\t    VEC_index (partition_t, partitions, 0)))\n       || (nbp > 1\n \t  && partition_contains_all_rw (rdg, partitions)))\n     goto ldist_done;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_rdg_partitions (dump_file, partitions);\n \n-  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n+  FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n     if (!generate_code_for_partition (loop, partition, i < nbp - 1))\n       goto ldist_done;\n \n@@ -1094,11 +1126,11 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   BITMAP_FREE (remaining_stmts);\n   BITMAP_FREE (upstream_mem_writes);\n \n-  FOR_EACH_VEC_ELT (bitmap, partitions, i, partition)\n-    BITMAP_FREE (partition);\n+  FOR_EACH_VEC_ELT (partition_t, partitions, i, partition)\n+    partition_free (partition);\n \n   VEC_free (int, heap, other_stores);\n-  VEC_free (bitmap, heap, partitions);\n+  VEC_free (partition_t, heap, partitions);\n   free_rdg_components (components);\n   return nbp;\n }"}]}