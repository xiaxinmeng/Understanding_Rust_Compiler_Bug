{"sha": "7803ec5ee2a547043fb6708a08ddb1361ba91202", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwM2VjNWVlMmE1NDcwNDNmYjY3MDhhMDhkZGIxMzYxYmE5MTIwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2018-10-31T09:58:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2018-10-31T09:58:48Z"}, "message": "aarch64: Improve atomic-op lse generation\n\nFix constraints; avoid unnecessary split.  Drop the use of the atomic_op\niterator in favor of the ATOMIC_LDOP iterator; this is simplier and more\nlogical for ldclr aka bic.\n\n\t* config/aarch64/aarch64.c (aarch64_emit_bic): Remove.\n\t(aarch64_atomic_ldop_supported_p): Remove.\n\t(aarch64_gen_atomic_ldop): Remove.\n\t* config/aarch64/atomic.md (atomic_<atomic_optab><ALLI>):\n\tFully expand LSE operations here.\n\t(atomic_fetch_<atomic_optab><ALLI>): Likewise.\n\t(atomic_<atomic_optab>_fetch<ALLI>): Likewise.\n\t(aarch64_atomic_<ATOMIC_LDOP><ALLI>_lse): Drop atomic_op iterator\n\tand use ATOMIC_LDOP instead; use register_operand for the input;\n\tdrop the split and emit insns directly.\n\t(aarch64_atomic_fetch_<ATOMIC_LDOP><ALLI>_lse): Likewise.\n\t(aarch64_atomic_<atomic_op>_fetch<ALLI>_lse): Remove.\n\t(@aarch64_atomic_load<ATOMIC_LDOP><ALLI>): Remove.\n\nFrom-SVN: r265660", "tree": {"sha": "dcf5f28df3603081cc04cbce0864e469f2e8d39c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf5f28df3603081cc04cbce0864e469f2e8d39c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7803ec5ee2a547043fb6708a08ddb1361ba91202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7803ec5ee2a547043fb6708a08ddb1361ba91202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7803ec5ee2a547043fb6708a08ddb1361ba91202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7803ec5ee2a547043fb6708a08ddb1361ba91202/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f5603d363a4e0453d2c38c7103aeb0bdca85c4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5603d363a4e0453d2c38c7103aeb0bdca85c4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5603d363a4e0453d2c38c7103aeb0bdca85c4e"}], "stats": {"total": 394, "additions": 122, "deletions": 272}, "files": [{"sha": "bec71246a8c4962f92da11e0573081d751491a7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7803ec5ee2a547043fb6708a08ddb1361ba91202", "patch": "@@ -1,5 +1,19 @@\n 2018-10-31  Richard Henderson  <richard.henderson@linaro.org>\n \n+\t* config/aarch64/aarch64.c (aarch64_emit_bic): Remove.\n+\t(aarch64_atomic_ldop_supported_p): Remove.\n+\t(aarch64_gen_atomic_ldop): Remove.\n+\t* config/aarch64/atomic.md (atomic_<atomic_optab><ALLI>):\n+\tFully expand LSE operations here.\n+\t(atomic_fetch_<atomic_optab><ALLI>): Likewise.\n+\t(atomic_<atomic_optab>_fetch<ALLI>): Likewise.\n+\t(aarch64_atomic_<ATOMIC_LDOP><ALLI>_lse): Drop atomic_op iterator\n+\tand use ATOMIC_LDOP instead; use register_operand for the input;\n+\tdrop the split and emit insns directly.\n+\t(aarch64_atomic_fetch_<ATOMIC_LDOP><ALLI>_lse): Likewise.\n+\t(aarch64_atomic_<atomic_op>_fetch<ALLI>_lse): Remove.\n+\t(@aarch64_atomic_load<ATOMIC_LDOP><ALLI>): Remove.\n+\n \t* config/aarch64/aarch64.c (aarch64_emit_atomic_swap): Remove.\n \t(aarch64_gen_atomic_ldop): Don't call it.\n \t* config/aarch64/atomics.md (atomic_exchange<ALLI>):"}, {"sha": "288efe9fc67422e011c7b094e2781e8e4746d568", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=7803ec5ee2a547043fb6708a08ddb1361ba91202", "patch": "@@ -564,8 +564,6 @@ rtx aarch64_load_tp (rtx);\n void aarch64_expand_compare_and_swap (rtx op[]);\n void aarch64_split_compare_and_swap (rtx op[]);\n \n-bool aarch64_atomic_ldop_supported_p (enum rtx_code);\n-void aarch64_gen_atomic_ldop (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n void aarch64_split_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx, rtx);\n \n bool aarch64_gen_adjusted_ldpstp (rtx *, bool, scalar_mode, RTX_CODE);"}, {"sha": "e646cced7d2eb030b8dd4318c17265c91bc4b42b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7803ec5ee2a547043fb6708a08ddb1361ba91202", "patch": "@@ -14663,32 +14663,6 @@ aarch64_expand_compare_and_swap (rtx operands[])\n   emit_insn (gen_rtx_SET (bval, x));\n }\n \n-/* Test whether the target supports using a atomic load-operate instruction.\n-   CODE is the operation and AFTER is TRUE if the data in memory after the\n-   operation should be returned and FALSE if the data before the operation\n-   should be returned.  Returns FALSE if the operation isn't supported by the\n-   architecture.  */\n-\n-bool\n-aarch64_atomic_ldop_supported_p (enum rtx_code code)\n-{\n-  if (!TARGET_LSE)\n-    return false;\n-\n-  switch (code)\n-    {\n-    case SET:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-    case MINUS:\n-    case PLUS:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n /* Emit a barrier, that is appropriate for memory model MODEL, at the end of a\n    sequence implementing an atomic operation.  */\n \n@@ -14821,156 +14795,6 @@ aarch64_split_compare_and_swap (rtx operands[])\n     aarch64_emit_post_barrier (model);\n }\n \n-/* Emit a BIC instruction.  */\n-\n-static void\n-aarch64_emit_bic (machine_mode mode, rtx dst, rtx s1, rtx s2, int shift)\n-{\n-  rtx shift_rtx = GEN_INT (shift);\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n-\n-  switch (mode)\n-    {\n-    case E_SImode: gen = gen_and_one_cmpl_lshrsi3; break;\n-    case E_DImode: gen = gen_and_one_cmpl_lshrdi3; break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen (dst, s2, shift_rtx, s1));\n-}\n-\n-/* Emit an atomic load+operate.  CODE is the operation.  OUT_DATA is the\n-   location to store the data read from memory.  OUT_RESULT is the location to\n-   store the result of the operation.  MEM is the memory location to read and\n-   modify.  MODEL_RTX is the memory ordering to use.  VALUE is the second\n-   operand for the operation.  Either OUT_DATA or OUT_RESULT, but not both, can\n-   be NULL.  */\n-\n-void\n-aarch64_gen_atomic_ldop (enum rtx_code code, rtx out_data, rtx out_result,\n-\t\t\t rtx mem, rtx value, rtx model_rtx)\n-{\n-  machine_mode mode = GET_MODE (mem);\n-  machine_mode wmode = (mode == DImode ? DImode : SImode);\n-  const bool short_mode = (mode < SImode);\n-  int ldop_code;\n-  rtx src;\n-  rtx x;\n-\n-  if (out_data)\n-    out_data = gen_lowpart (mode, out_data);\n-\n-  if (out_result)\n-    out_result = gen_lowpart (mode, out_result);\n-\n-  /* Make sure the value is in a register, putting it into a destination\n-     register if it needs to be manipulated.  */\n-  if (!register_operand (value, mode)\n-      || code == AND || code == MINUS)\n-    {\n-      src = out_result ? out_result : out_data;\n-      emit_move_insn (src, gen_lowpart (mode, value));\n-    }\n-  else\n-    src = value;\n-  gcc_assert (register_operand (src, mode));\n-\n-  /* Preprocess the data for the operation as necessary.  If the operation is\n-     a SET then emit a swap instruction and finish.  */\n-  switch (code)\n-    {\n-    case MINUS:\n-      /* Negate the value and treat it as a PLUS.  */\n-      {\n-\trtx neg_src;\n-\n-\t/* Resize the value if necessary.  */\n-\tif (short_mode)\n-\t  src = gen_lowpart (wmode, src);\n-\n-\tneg_src = gen_rtx_NEG (wmode, src);\n-\temit_insn (gen_rtx_SET (src, neg_src));\n-\n-\tif (short_mode)\n-\t  src = gen_lowpart (mode, src);\n-      }\n-      /* Fall-through.  */\n-    case PLUS:\n-      ldop_code = UNSPECV_ATOMIC_LDOP_PLUS;\n-      break;\n-\n-    case IOR:\n-      ldop_code = UNSPECV_ATOMIC_LDOP_OR;\n-      break;\n-\n-    case XOR:\n-      ldop_code = UNSPECV_ATOMIC_LDOP_XOR;\n-      break;\n-\n-    case AND:\n-      {\n-\trtx not_src;\n-\n-\t/* Resize the value if necessary.  */\n-\tif (short_mode)\n-\t  src = gen_lowpart (wmode, src);\n-\n-\tnot_src = gen_rtx_NOT (wmode, src);\n-\temit_insn (gen_rtx_SET (src, not_src));\n-\n-\tif (short_mode)\n-\t  src = gen_lowpart (mode, src);\n-      }\n-      ldop_code = UNSPECV_ATOMIC_LDOP_BIC;\n-      break;\n-\n-    default:\n-      /* The operation can't be done with atomic instructions.  */\n-      gcc_unreachable ();\n-    }\n-\n-  emit_insn (gen_aarch64_atomic_load (ldop_code, mode,\n-\t\t\t\t      out_data, mem, src, model_rtx));\n-\n-  /* If necessary, calculate the data in memory after the update by redoing the\n-     operation from values in registers.  */\n-  if (!out_result)\n-    return;\n-\n-  if (short_mode)\n-    {\n-      src = gen_lowpart (wmode, src);\n-      out_data = gen_lowpart (wmode, out_data);\n-      out_result = gen_lowpart (wmode, out_result);\n-    }\n-\n-  x = NULL_RTX;\n-\n-  switch (code)\n-    {\n-    case MINUS:\n-    case PLUS:\n-      x = gen_rtx_PLUS (wmode, out_data, src);\n-      break;\n-    case IOR:\n-      x = gen_rtx_IOR (wmode, out_data, src);\n-      break;\n-    case XOR:\n-      x = gen_rtx_XOR (wmode, out_data, src);\n-      break;\n-    case AND:\n-      aarch64_emit_bic (wmode, out_result, out_data, src, 0);\n-      return;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  emit_set_insn (out_result, x);\n-\n-  return;\n-}\n-\n /* Split an atomic operation.  */\n \n void"}, {"sha": "2198649b1be05758188e4080d06325e0eb3c1615", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 104, "deletions": 93, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=7803ec5ee2a547043fb6708a08ddb1361ba91202", "patch": "@@ -207,13 +207,37 @@\n     rtx (*gen) (rtx, rtx, rtx);\n \n     /* Use an atomic load-operate instruction when possible.  */\n-    if (aarch64_atomic_ldop_supported_p (<CODE>))\n-      gen = gen_aarch64_atomic_<atomic_optab><mode>_lse;\n+    if (TARGET_LSE)\n+      {\n+\tswitch (<CODE>)\n+\t  {\n+\t  case MINUS:\n+\t    operands[1] = expand_simple_unop (<MODE>mode, NEG, operands[1],\n+\t\t\t\t\t      NULL, 1);\n+\t    /* fallthru */\n+\t  case PLUS:\n+\t    gen = gen_aarch64_atomic_add<mode>_lse;\n+\t    break;\n+\t  case IOR:\n+\t    gen = gen_aarch64_atomic_ior<mode>_lse;\n+\t    break;\n+\t  case XOR:\n+\t    gen = gen_aarch64_atomic_xor<mode>_lse;\n+\t    break;\n+\t  case AND:\n+\t    operands[1] = expand_simple_unop (<MODE>mode, NOT, operands[1],\n+\t\t\t\t\t      NULL, 1);\n+\t    gen = gen_aarch64_atomic_bic<mode>_lse;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n+      }\n     else\n       gen = gen_aarch64_atomic_<atomic_optab><mode>;\n \n     emit_insn (gen (operands[0], operands[1], operands[2]));\n-\n     DONE;\n   }\n )\n@@ -239,22 +263,25 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_atomic_<atomic_optab><mode>_lse\"\n+(define_insn \"aarch64_atomic_<atomic_ldoptab><mode>_lse\"\n   [(set (match_operand:ALLI 0 \"aarch64_sync_memory_operand\" \"+Q\")\n-    (unspec_volatile:ALLI\n-      [(atomic_op:ALLI (match_dup 0)\n-\t(match_operand:ALLI 1 \"<atomic_op_operand>\" \"r<const_atomic>\"))\n-       (match_operand:SI 2 \"const_int_operand\")]\n-      UNSPECV_ATOMIC_OP))\n+\t(unspec_volatile:ALLI\n+\t  [(match_dup 0)\n+\t   (match_operand:ALLI 1 \"register_operand\" \"r\")\n+\t   (match_operand:SI 2 \"const_int_operand\")]\n+      ATOMIC_LDOP))\n    (clobber (match_scratch:ALLI 3 \"=&r\"))]\n   \"TARGET_LSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n   {\n-    aarch64_gen_atomic_ldop (<CODE>, operands[3], NULL, operands[0],\n-\t\t\t     operands[1], operands[2]);\n-    DONE;\n+   enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+   if (is_mm_relaxed (model))\n+     return \"ld<atomic_ldop><atomic_sfx>\\t%<w>1, %<w>3, %0\";\n+   else if (is_mm_release (model))\n+     return \"ld<atomic_ldop>l<atomic_sfx>\\t%<w>1, %<w>3, %0\";\n+   else if (is_mm_acquire (model) || is_mm_consume (model))\n+     return \"ld<atomic_ldop>a<atomic_sfx>\\t%<w>1, %<w>3, %0\";\n+   else\n+     return \"ld<atomic_ldop>al<atomic_sfx>\\t%<w>1, %<w>3, %0\";\n   }\n )\n \n@@ -280,7 +307,7 @@\n   }\n )\n \n-;; Load-operate-store, returning the updated memory data.\n+;; Load-operate-store, returning the original memory data.\n \n (define_expand \"atomic_fetch_<atomic_optab><mode>\"\n  [(match_operand:ALLI 0 \"register_operand\" \"\")\n@@ -293,13 +320,37 @@\n   rtx (*gen) (rtx, rtx, rtx, rtx);\n \n   /* Use an atomic load-operate instruction when possible.  */\n-  if (aarch64_atomic_ldop_supported_p (<CODE>))\n-    gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>_lse;\n+  if (TARGET_LSE)\n+    {\n+      switch (<CODE>)\n+        {\n+\tcase MINUS:\n+\t  operands[2] = expand_simple_unop (<MODE>mode, NEG, operands[2],\n+\t\t\t\t\t    NULL, 1);\n+\t  /* fallthru */\n+\tcase PLUS:\n+\t  gen = gen_aarch64_atomic_fetch_add<mode>_lse;\n+\t  break;\n+\tcase IOR:\n+\t  gen = gen_aarch64_atomic_fetch_ior<mode>_lse;\n+\t  break;\n+\tcase XOR:\n+\t  gen = gen_aarch64_atomic_fetch_xor<mode>_lse;\n+\t  break;\n+\tcase AND:\n+\t  operands[2] = expand_simple_unop (<MODE>mode, NOT, operands[2],\n+\t\t\t\t\t    NULL, 1);\n+\t  gen = gen_aarch64_atomic_fetch_bic<mode>_lse;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+    }\n   else\n     gen = gen_aarch64_atomic_fetch_<atomic_optab><mode>;\n \n   emit_insn (gen (operands[0], operands[1], operands[2], operands[3]));\n-\n   DONE;\n })\n \n@@ -326,23 +377,26 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_atomic_fetch_<atomic_optab><mode>_lse\"\n-  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n-    (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n+(define_insn \"aarch64_atomic_fetch_<atomic_ldoptab><mode>_lse\"\n+  [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n+\t(match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n    (set (match_dup 1)\n-    (unspec_volatile:ALLI\n-      [(atomic_op:ALLI (match_dup 1)\n-\t(match_operand:ALLI 2 \"<atomic_op_operand>\" \"r<const_atomic>\"))\n-       (match_operand:SI 3 \"const_int_operand\")]\n-      UNSPECV_ATOMIC_LDOP))]\n+\t(unspec_volatile:ALLI\n+\t  [(match_dup 1)\n+\t   (match_operand:ALLI 2 \"register_operand\" \"r\")\n+\t   (match_operand:SI 3 \"const_int_operand\")]\n+\t  ATOMIC_LDOP))]\n   \"TARGET_LSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n   {\n-    aarch64_gen_atomic_ldop (<CODE>, operands[0], NULL, operands[1],\n-\t\t\t     operands[2], operands[3]);\n-    DONE;\n+   enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+   if (is_mm_relaxed (model))\n+     return \"ld<atomic_ldop><atomic_sfx>\\t%<w>2, %<w>0, %1\";\n+   else if (is_mm_acquire (model) || is_mm_consume (model))\n+     return \"ld<atomic_ldop>a<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n+   else if (is_mm_release (model))\n+     return \"ld<atomic_ldop>l<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n+   else\n+     return \"ld<atomic_ldop>al<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n   }\n )\n \n@@ -370,7 +424,7 @@\n   }\n )\n \n-;; Load-operate-store, returning the original memory data.\n+;; Load-operate-store, returning the updated memory data.\n \n (define_expand \"atomic_<atomic_optab>_fetch<mode>\"\n  [(match_operand:ALLI 0 \"register_operand\" \"\")\n@@ -380,17 +434,23 @@\n   (match_operand:SI 3 \"const_int_operand\")]\n  \"\"\n {\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n-  rtx value = operands[2];\n-\n-  /* Use an atomic load-operate instruction when possible.  */\n-  if (aarch64_atomic_ldop_supported_p (<CODE>))\n-    gen = gen_aarch64_atomic_<atomic_optab>_fetch<mode>_lse;\n+  /* Use an atomic load-operate instruction when possible.  In this case\n+     we will re-compute the result from the original mem value. */\n+  if (TARGET_LSE)\n+    {\n+      rtx tmp = gen_reg_rtx (<MODE>mode);\n+      operands[2] = force_reg (<MODE>mode, operands[2]);\n+      emit_insn (gen_atomic_fetch_<atomic_optab><mode>\n+                 (tmp, operands[1], operands[2], operands[3]));\n+      tmp = expand_simple_binop (<MODE>mode, <CODE>, tmp, operands[2],\n+\t\t\t\t operands[0], 1, OPTAB_WIDEN);\n+      emit_move_insn (operands[0], tmp);\n+    }\n   else\n-    gen = gen_aarch64_atomic_<atomic_optab>_fetch<mode>;\n-\n-  emit_insn (gen (operands[0], operands[1], value, operands[3]));\n-\n+    {\n+      emit_insn (gen_aarch64_atomic_<atomic_optab>_fetch<mode>\n+                 (operands[0], operands[1], operands[2], operands[3]));\n+    }\n   DONE;\n })\n \n@@ -417,29 +477,6 @@\n   }\n )\n \n-(define_insn_and_split \"aarch64_atomic_<atomic_optab>_fetch<mode>_lse\"\n-  [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n-    (atomic_op:ALLI\n-     (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\")\n-     (match_operand:ALLI 2 \"<atomic_op_operand>\" \"r<const_atomic>\")))\n-   (set (match_dup 1)\n-    (unspec_volatile:ALLI\n-      [(match_dup 1)\n-       (match_dup 2)\n-       (match_operand:SI 3 \"const_int_operand\")]\n-      UNSPECV_ATOMIC_LDOP))\n-     (clobber (match_scratch:ALLI 4 \"=&r\"))]\n-  \"TARGET_LSE\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  {\n-    aarch64_gen_atomic_ldop (<CODE>, operands[4], operands[0], operands[1],\n-\t\t\t     operands[2], operands[3]);\n-    DONE;\n-  }\n-)\n-\n (define_insn_and_split \"atomic_nand_fetch<mode>\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=&r\")\n     (not:ALLI\n@@ -585,29 +622,3 @@\n       return \"dmb\\\\tish\";\n   }\n )\n-\n-;; ARMv8.1-A LSE instructions.\n-\n-;; Atomic load-op: Load data, operate, store result, keep data.\n-\n-(define_insn \"@aarch64_atomic_load<atomic_ldop><mode>\"\n- [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n-   (match_operand:ALLI 1 \"aarch64_sync_memory_operand\" \"+Q\"))\n-  (set (match_dup 1)\n-   (unspec_volatile:ALLI\n-    [(match_dup 1)\n-     (match_operand:ALLI 2 \"register_operand\")\n-     (match_operand:SI 3 \"const_int_operand\")]\n-    ATOMIC_LDOP))]\n- \"TARGET_LSE && reload_completed\"\n- {\n-   enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n-   if (is_mm_relaxed (model))\n-     return \"ld<atomic_ldop><atomic_sfx>\\t%<w>2, %<w>0, %1\";\n-   else if (is_mm_acquire (model) || is_mm_consume (model))\n-     return \"ld<atomic_ldop>a<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n-   else if (is_mm_release (model))\n-     return \"ld<atomic_ldop>l<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n-   else\n-     return \"ld<atomic_ldop>al<atomic_sfx>\\t%<w>2, %<w>0, %1\";\n- })"}, {"sha": "524e4e6929bc9a7136966987600de2513748c20b", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7803ec5ee2a547043fb6708a08ddb1361ba91202/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=7803ec5ee2a547043fb6708a08ddb1361ba91202", "patch": "@@ -503,7 +503,6 @@\n     UNSPECV_ATOMIC_CAS\t\t; Represent an atomic CAS.\n     UNSPECV_ATOMIC_SWP\t\t; Represent an atomic SWP.\n     UNSPECV_ATOMIC_OP\t\t; Represent an atomic operation.\n-    UNSPECV_ATOMIC_LDOP\t\t; Represent an atomic load-operation\n     UNSPECV_ATOMIC_LDOP_OR\t; Represent an atomic load-or\n     UNSPECV_ATOMIC_LDOP_BIC\t; Represent an atomic load-bic\n     UNSPECV_ATOMIC_LDOP_XOR\t; Represent an atomic load-xor\n@@ -1591,6 +1590,10 @@\n  [(UNSPECV_ATOMIC_LDOP_OR \"set\") (UNSPECV_ATOMIC_LDOP_BIC \"clr\")\n   (UNSPECV_ATOMIC_LDOP_XOR \"eor\") (UNSPECV_ATOMIC_LDOP_PLUS \"add\")])\n \n+(define_int_attr atomic_ldoptab\n+ [(UNSPECV_ATOMIC_LDOP_OR \"ior\") (UNSPECV_ATOMIC_LDOP_BIC \"bic\")\n+  (UNSPECV_ATOMIC_LDOP_XOR \"xor\") (UNSPECV_ATOMIC_LDOP_PLUS \"add\")])\n+\n ;; -------------------------------------------------------------------\n ;; Int Iterators Attributes.\n ;; -------------------------------------------------------------------"}]}