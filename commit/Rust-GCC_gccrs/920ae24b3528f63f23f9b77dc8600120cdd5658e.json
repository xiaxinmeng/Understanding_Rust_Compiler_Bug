{"sha": "920ae24b3528f63f23f9b77dc8600120cdd5658e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwYWUyNGIzNTI4ZjYzZjIzZjliNzdkYzg2MDAxMjBjZGQ1NjU4ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-08-18T00:25:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-08-18T00:25:09Z"}, "message": "iris6.h (TARGET_IRIX6): New.\n\n        * config/mips/iris6.h (TARGET_IRIX6): New.\n        (current_section_name, current_section_flags): New.\n        (ASM_OUTPUT_ALIGN, ASM_FILE_START, ASM_FILE_END): New.\n        (MAX_OFILE_ALIGNMENT): New.\n        (ASM_OUTPUT_ALIGNED_LOCAL): Use bss_section.\n        * config/mips/mips.c (mips_make_temp_file, temp_filename): Remove.\n        (copy_file_data): Split out from\n        (mips_asm_file_end): ... here.\n        (mips_asm_file_start): Remove extra .section directive.  Use\n        tmpfile instead of mips_make_temp_file.\n        (mips_unique_section): Use const char * as needed for warnings.\n        (iris6_asm_named_section_1): Renamed from iris6_asm_named_section;\n        re-add align parameter.\n        (iris6_asm_named_section): New.\n        (iris_section_align_entry_eq, iris_section_align_entry_hash): New.\n        (iris6_asm_output_align, iris6_section_align_1): New.\n        (iris6_asm_file_start, iris6_asm_file_end): New.\n        * config/mips/mips-protos.h: Update decls.\n\nFrom-SVN: r44991", "tree": {"sha": "da2410ab4bf0dc57ca5d7b9a952a21c1d8c76b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da2410ab4bf0dc57ca5d7b9a952a21c1d8c76b0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/920ae24b3528f63f23f9b77dc8600120cdd5658e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920ae24b3528f63f23f9b77dc8600120cdd5658e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920ae24b3528f63f23f9b77dc8600120cdd5658e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920ae24b3528f63f23f9b77dc8600120cdd5658e/comments", "author": null, "committer": null, "parents": [{"sha": "5cc3b0c784d524e351c4e5902bd0a5aac54e4de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc3b0c784d524e351c4e5902bd0a5aac54e4de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cc3b0c784d524e351c4e5902bd0a5aac54e4de3"}], "stats": {"total": 363, "additions": 278, "deletions": 85}, "files": [{"sha": "da042fe084057e7f510210db8a7e2d30d7c97b02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=920ae24b3528f63f23f9b77dc8600120cdd5658e", "patch": "@@ -1,3 +1,24 @@\n+2001-08-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/mips/iris6.h (TARGET_IRIX6): New.\n+\t(current_section_name, current_section_flags): New.\n+\t(ASM_OUTPUT_ALIGN, ASM_FILE_START, ASM_FILE_END): New.\n+\t(MAX_OFILE_ALIGNMENT): New.\n+\t(ASM_OUTPUT_ALIGNED_LOCAL): Use bss_section.\n+\t* config/mips/mips.c (mips_make_temp_file, temp_filename): Remove.\n+\t(copy_file_data): Split out from \n+\t(mips_asm_file_end): ... here.\n+\t(mips_asm_file_start): Remove extra .section directive.  Use\n+\ttmpfile instead of mips_make_temp_file.\n+\t(mips_unique_section): Use const char * as needed for warnings.\n+\t(iris6_asm_named_section_1): Renamed from iris6_asm_named_section;\n+\tre-add align parameter.\n+\t(iris6_asm_named_section): New.\n+\t(iris_section_align_entry_eq, iris_section_align_entry_hash): New.\n+\t(iris6_asm_output_align, iris6_section_align_1): New.\n+\t(iris6_asm_file_start, iris6_asm_file_end): New.\n+\t* config/mips/mips-protos.h: Update decls.\n+\n 2001-08-17  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/install.texi (Install GCC): Add links to build status pages."}, {"sha": "ce9df16fff347afc88dc083b5f45152c91552a4d", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=920ae24b3528f63f23f9b77dc8600120cdd5658e", "patch": "@@ -18,6 +18,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+/* Let mips.c know we need the Irix6 functions.  */\n+#define TARGET_IRIX6 1\n+\n /* Default to -mabi=n32 and -mips3.  */\n #define MIPS_ISA_DEFAULT 3\n #define MIPS_ABI_DEFAULT ABI_N32\n@@ -31,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"mips/abi64.h\"\n \n /* Irix6 assembler does handle DWARF2 directives.  Override setting in\n- irix5.h file.  */\n+   irix5.h file.  */\n #undef DWARF2_UNWIND_INFO\n \n /* The Irix6 assembler will sometimes assign labels to the wrong\n@@ -130,6 +133,7 @@ Boston, MA 02111-1307, USA.  */\n /* Force the generation of dwarf .debug_frame sections even if not\n    compiling -g.  This guarantees that we can unwind the stack. */\n #define DWARF2_FRAME_INFO 1\n+\n /* The size in bytes of a DWARF field indicating an offset or length\n    relative to a debug info section, specified to be 4 bytes in the DWARF-2\n    specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */\n@@ -289,13 +293,61 @@ rdata_section ()\t\t\t\t\t\t\t\\\n \tfprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP_32);\t\\\n       in_section = in_rdata;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+const char *\t\t\t\t\t\t\t\t\\\n+current_section_name ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  switch (in_section)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case no_section:\treturn NULL;\t\t\t\t\t\\\n+    case in_text:\treturn \".text\";\t\t\t\t\t\\\n+    case in_data:\treturn \".data\";\t\t\t\t\t\\\n+    case in_sdata:\treturn \".sdata\";\t\t\t\t\\\n+    case in_bss:\treturn \".bss\";\t\t\t\t\t\\\n+    case in_rdata:\t\t\t\t\t\t\t\\\n+    case in_const:\t\t\t\t\t\t\t\\\n+      if (mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t\\\n+\treturn \".rodata\";\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\treturn \".rdata\";\t\t\t\t\t\t\\\n+    case in_named:\t\t\t\t\t\t\t\\\n+      return in_named_name;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  abort ();\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+unsigned int\t\t\t\t\t\t\t\t\\\n+current_section_flags ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  switch (in_section)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case no_section:\treturn 0;\t\t\t\t\t\\\n+    case in_text:\treturn SECTION_CODE;\t\t\t\t\\\n+    case in_data:\treturn SECTION_WRITE;\t\t\t\t\\\n+    case in_sdata:\treturn SECTION_WRITE | SECTION_SMALL;\t\t\\\n+    case in_bss:\treturn SECTION_WRITE | SECTION_BSS;\t\t\\\n+    case in_rdata:\t\t\t\t\t\t\t\\\n+    case in_const:\treturn 0;\t\t\t\t\t\\\n+    case in_named:\treturn get_named_section_flags (in_named_name);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  abort ();\t\t\t\t\t\t\t\t\\\n }\n \n /* Switch into a generic section.  */\n #undef TARGET_ASM_NAMED_SECTION\n #define TARGET_ASM_NAMED_SECTION  iris6_asm_named_section\n \n-/* ??? Perhaps just include svr4.h in this file?  */\n+/* SGI assembler needs all sorts of extra help to do alignment properly.  */\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN iris6_asm_output_align\n+#undef ASM_FILE_START\n+#define ASM_FILE_START  iris6_asm_file_start\n+#undef ASM_FILE_END\n+#define ASM_FILE_END\tiris6_asm_file_end\n+\n+#undef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT (32768*8)\n \n /* ??? SGI assembler may core dump when compiling with -g.\n    Sometimes as succeeds, but then we get a linker error. (cmds.c in 072.sc)\n@@ -317,11 +369,10 @@ do\t\t\t\t\t\t\t\t\t   \\\n   {\t\t\t\t\t\t\t\t\t   \\\n     if (mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t   \\\n       {\t\t\t\t\t\t\t\t\t   \\\n-\tfprintf (STREAM, \"%s\\n\", BSS_SECTION_ASM_OP);\t\t\t   \\\n+\tbss_section ();\t\t\t\t\t\t\t   \\\n \tmips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\t\t   \\\n \tASM_OUTPUT_ALIGN (STREAM, floor_log2 (ALIGN / BITS_PER_UNIT));\t   \\\n \tASM_OUTPUT_SKIP (STREAM, SIZE);\t\t\t\t\t   \\\n-\tfprintf (STREAM, \"%s\\n\", POPSECTION_ASM_OP);\t\t\t   \\\n       }\t\t\t\t\t\t\t\t\t   \\\n     else\t\t\t\t\t\t\t\t   \\\n       mips_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\", \",%u\\n\", (SIZE)); \\"}, {"sha": "5cc409c339771bcadc4b8db6d77085b7728a4035", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=920ae24b3528f63f23f9b77dc8600120cdd5658e", "patch": "@@ -29,6 +29,11 @@ Boston, MA 02111-1307, USA.  */\n extern HOST_WIDE_INT\tcompute_frame_size PARAMS ((HOST_WIDE_INT));\n extern void\t\tmips_asm_file_end PARAMS ((FILE *));\n extern void\t\tmips_asm_file_start PARAMS ((FILE *));\n+extern void\t\tiris6_asm_file_start PARAMS ((FILE *));\n+extern void\t\tiris6_asm_file_end PARAMS ((FILE *));\n+extern void\t\tiris6_asm_output_align PARAMS ((FILE *, unsigned));\n+extern const char *\tcurrent_section_name PARAMS ((void));\n+extern unsigned int\tcurrent_section_flags PARAMS ((void));\n extern int\t\tmips_can_use_return_insn PARAMS ((void));\n extern void\t\tmips_declare_object PARAMS ((FILE *, const char *, const char *, const char *, int));\n extern void\t\tmips_expand_epilogue PARAMS ((void));"}, {"sha": "d9cdcf5d2583ac9a5409cf847c4da2aa55d8fa42", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 197, "deletions": 81, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ae24b3528f63f23f9b77dc8600120cdd5658e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=920ae24b3528f63f23f9b77dc8600120cdd5658e", "patch": "@@ -40,7 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n-\n #include \"tree.h\"\n #include \"function.h\"\n #include \"expr.h\"\n@@ -50,6 +49,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"ggc.h\"\n #include \"gstab.h\"\n+#include \"hashtab.h\"\n+#include \"debug.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n \n@@ -90,7 +91,6 @@ static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t int,\n \t\t\t\t\t\t\t rtx, rtx));\n static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n-static FILE *mips_make_temp_file\t\tPARAMS ((void));\n static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t\t FILE *));\n static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n@@ -115,8 +115,18 @@ static void mips_add_gc_roots                   PARAMS ((void));\n static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void mips_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n static enum processor_type mips_parse_cpu       PARAMS ((const char *));\n+static void copy_file_data\t\t\tPARAMS ((FILE *, FILE *));\n+#ifdef TARGET_IRIX6\n+static void iris6_asm_named_section_1\t\tPARAMS ((const char *,\n+\t\t\t\t\t\t\t unsigned int,\n+\t\t\t\t\t\t\t unsigned int));\n static void iris6_asm_named_section\t\tPARAMS ((const char *,\n \t\t\t\t\t\t\t unsigned int));\n+static int iris_section_align_entry_eq\t\tPARAMS ((const PTR, const PTR));\n+static hashval_t iris_section_align_entry_hash\tPARAMS ((const PTR));\n+static int iris6_section_align_1\t\tPARAMS ((void **, void *));\n+#endif\n+\n /* Global variables for machine-dependent things.  */\n \n /* Threshold for data being put into the small data/bss area, instead\n@@ -276,10 +286,6 @@ struct mips_frame_info current_frame_info;\n /* Zero structure to initialize current_frame_info.  */\n struct mips_frame_info zero_frame_info;\n \n-/* Temporary filename used to buffer .text until end of program\n-   for -mgpopt.  */\n-static char *temp_filename;\n-\n /* Pseudo-reg holding the address of the current function when\n    generating embedded PIC code.  Created by LEGITIMIZE_ADDRESS, used\n    by mips_finalize_pic if it was created.  */\n@@ -5786,20 +5792,6 @@ mips_output_external_libcall (file, name)\n }\n #endif\n \f\n-/* Compute a string to use as a temporary file name.  */\n-\n-static FILE *\n-mips_make_temp_file ()\n-{\n-  FILE *stream;\n-\n-  temp_filename = make_temp_file (0);\n-  stream = fopen (temp_filename, \"w+\");\n-  if (!stream)\n-    fatal_io_error (\"can't open %s\", temp_filename);\n-  return stream;\n-}\n-\f\n /* Emit a new filename to a stream.  If this is MIPS ECOFF, watch out\n    for .file's that start within a function.  If we are smuggling stabs, try to\n    put out a MIPS ECOFF file and a stab.  */\n@@ -6045,20 +6037,14 @@ mips_asm_file_start (stream)\n   if (TARGET_MIPS16)\n     fprintf (stream, \"\\t.set\\tmips16\\n\");\n \n-  /* Start a section, so that the first .popsection directive is guaranteed\n-     to have a previously defined section to pop back to.  */\n-  if (mips_abi != ABI_32 && mips_abi != ABI_O64 && mips_abi != ABI_EABI)\n-    fprintf (stream, \"\\t.section\\t.text\\n\");\n-\n   /* This code exists so that we can put all externs before all symbol\n      references.  This is necessary for the MIPS assembler's global pointer\n      optimizations to work.  */\n   if (TARGET_FILE_SWITCHING)\n     {\n       asm_out_data_file = stream;\n-      asm_out_text_file = mips_make_temp_file ();\n+      asm_out_text_file = tmpfile ();\n     }\n-\n   else\n     asm_out_data_file = asm_out_text_file = stream;\n \n@@ -6077,10 +6063,8 @@ void\n mips_asm_file_end (file)\n      FILE *file;\n {\n-  char buffer[8192];\n   tree name_tree;\n   struct extern_list *p;\n-  int len;\n \n   if (HALF_PIC_P ())\n     {\n@@ -6116,23 +6100,30 @@ mips_asm_file_end (file)\n   if (TARGET_FILE_SWITCHING)\n     {\n       fprintf (file, \"\\n\\t.text\\n\");\n-      rewind (asm_out_text_file);\n-      if (ferror (asm_out_text_file))\n-\tfatal_io_error (\"can't rewind %s\", temp_filename);\n+      copy_file_data (file, asm_out_text_file);\n+    }\n+}\n \n-      while ((len = fread (buffer, 1, sizeof (buffer), asm_out_text_file)) > 0)\n-\tif ((int) fwrite (buffer, 1, len, file) != len)\n-\t  fatal_io_error (\"can't write to %s\", asm_file_name);\n+static void\n+copy_file_data (to, from)\n+     FILE *to, *from;\n+{\n+  char buffer[8192];\n+  size_t len;\n \n-      if (len < 0)\n-\tfatal_io_error (\"can't read from %s\", temp_filename);\n+  rewind (from);\n+  if (ferror (from))\n+    fatal_io_error (\"can't rewind temp file\");\n \n-      if (fclose (asm_out_text_file) != 0)\n-\tfatal_io_error (\"can't close %s\", temp_filename);\n+  while ((len = fread (buffer, 1, sizeof (buffer), from)) > 0)\n+    if (fwrite (buffer, 1, len, to) != len)\n+      fatal_io_error (\"can't write to output file\");\n \n-      unlink (temp_filename);\n-      free (temp_filename);\n-    }\n+  if (ferror (from))\n+    fatal_io_error (\"can't read from temp file\");\n+\n+  if (fclose (from))\n+    fatal_io_error (\"can't close temp file\");\n }\n \n /* Emit either a label, .comm, or .lcomm directive, and mark that the symbol\n@@ -9752,43 +9743,6 @@ mips_parse_cpu (cpu_string)\n   return cpu;\n }\n \n-/* Output assembly to switch to section NAME with attribute FLAGS.  */\n-\n-static void\n-iris6_asm_named_section (name, flags)\n-     const char *name;\n-     unsigned int flags;\n-{\n-  unsigned int sh_type, sh_flags, sh_entsize;\n-\n-  sh_flags = 0;\n-  if (!(flags & SECTION_DEBUG))\n-    sh_flags |= 2; /* SHF_ALLOC */\n-  if (flags & SECTION_WRITE)\n-    sh_flags |= 1; /* SHF_WRITE */\n-  if (flags & SECTION_CODE)\n-    sh_flags |= 4; /* SHF_EXECINSTR */\n-  if (flags & SECTION_SMALL)\n-    sh_flags |= 0x10000000; /* SHF_MIPS_GPREL */\n-  if (strcmp (name, \".debug_frame\") == 0)\n-    sh_flags |= 0x08000000; /* SHF_MIPS_NOSTRIP */\n-\n-  if (flags & SECTION_DEBUG)\n-    sh_type = 0x7000001e; /* SHT_MIPS_DWARF */\n-  else if (flags & SECTION_BSS)\n-    sh_type = 8; /* SHT_NOBITS */\n-  else\n-    sh_type = 1; /* SHT_PROGBITS */\n-\n-  if (flags & SECTION_CODE)\n-    sh_entsize = 4;\n-  else\n-    sh_entsize = 0;\n-\n-  fprintf (asm_out_file, \"\\t.section %s,%u,%u,%u,%u\\n\",\n-\t   name, sh_type, sh_flags, sh_entsize, 0);\n-}\n-\n /* Cover function for UNIQUE_SECTION.  */\n \n void\n@@ -9797,8 +9751,9 @@ mips_unique_section (decl, reloc)\n      int reloc;\n {\n   int len, size, sec;\n-  char *name, *string, *prefix;\n-  static char *prefixes[4][2] = {\n+  const char *name, *prefix;\n+  char *string;\n+  static const char *prefixes[4][2] = {\n     { \".text.\", \".gnu.linkonce.t.\" },\n     { \".rodata.\", \".gnu.linkonce.r.\" },\n     { \".data.\", \".gnu.linkonce.d.\" },\n@@ -9860,3 +9815,164 @@ mips_unique_section (decl, reloc)\n \n   DECL_SECTION_NAME (decl) = build_string (len, string);\n }\n+\f\n+#ifdef TARGET_IRIX6\n+/* Output assembly to switch to section NAME with attribute FLAGS.  */\n+\n+static void\n+iris6_asm_named_section_1 (name, flags, align)\n+     const char *name;\n+     unsigned int flags;\n+     unsigned int align;\n+{\n+  unsigned int sh_type, sh_flags, sh_entsize;\n+\n+  sh_flags = 0;\n+  if (!(flags & SECTION_DEBUG))\n+    sh_flags |= 2; /* SHF_ALLOC */\n+  if (flags & SECTION_WRITE)\n+    sh_flags |= 1; /* SHF_WRITE */\n+  if (flags & SECTION_CODE)\n+    sh_flags |= 4; /* SHF_EXECINSTR */\n+  if (flags & SECTION_SMALL)\n+    sh_flags |= 0x10000000; /* SHF_MIPS_GPREL */\n+  if (strcmp (name, \".debug_frame\") == 0)\n+    sh_flags |= 0x08000000; /* SHF_MIPS_NOSTRIP */\n+\n+  if (flags & SECTION_DEBUG)\n+    sh_type = 0x7000001e; /* SHT_MIPS_DWARF */\n+  else if (flags & SECTION_BSS)\n+    sh_type = 8; /* SHT_NOBITS */\n+  else\n+    sh_type = 1; /* SHT_PROGBITS */\n+\n+  if (flags & SECTION_CODE)\n+    sh_entsize = 4;\n+  else\n+    sh_entsize = 0;\n+\n+  fprintf (asm_out_file, \"\\t.section %s,%#x,%#x,%u,%u\\n\",\n+\t   name, sh_type, sh_flags, sh_entsize, align);\n+}\n+\n+static void\n+iris6_asm_named_section (name, flags)\n+     const char *name;\n+     unsigned int flags;\n+{\n+  if (TARGET_FILE_SWITCHING && (flags & SECTION_CODE))\n+    asm_out_file = asm_out_text_file;\n+  iris6_asm_named_section_1 (name, flags, 0);\n+}\n+\n+/* In addition to emitting a .align directive, record the maximum\n+   alignment requested for the current section.  */\n+\n+struct iris_section_align_entry\n+{\n+  const char *name;\n+  unsigned int log;\n+  unsigned int flags;\n+};\n+\n+static htab_t iris_section_align_htab;\n+static FILE *iris_orig_asm_out_file;\n+\n+static int\n+iris_section_align_entry_eq (p1, p2)\n+     const PTR p1;\n+     const PTR p2;\n+{\n+  const struct iris_section_align_entry *old = p1;\n+  const char *new = p2;\n+\n+  return strcmp (old->name, new) == 0;\n+}\n+\n+static hashval_t\n+iris_section_align_entry_hash (p)\n+     const PTR p;\n+{\n+  const struct iris_section_align_entry *old = p;\n+  return htab_hash_string (old->name);\n+}\n+\n+void\n+iris6_asm_output_align (file, log)\n+     FILE *file;\n+     unsigned int log;\n+{\n+  const char *section = current_section_name ();\n+  struct iris_section_align_entry **slot, *entry;\n+\n+  if (! section)\n+    abort ();\n+\n+  slot = (struct iris_section_align_entry **)\n+    htab_find_slot_with_hash (iris_section_align_htab, section,\n+\t\t\t      htab_hash_string (section), INSERT);\n+  entry = *slot;\n+  if (! entry)\n+    {\n+      entry = (struct iris_section_align_entry *)\n+\txmalloc (sizeof (struct iris_section_align_entry));\n+      *slot = entry;\n+      entry->name = section;\n+      entry->log = log;\n+      entry->flags = current_section_flags ();\n+    }\n+  else if (entry->log < log)\n+    entry->log = log;\n+\n+  fprintf (file, \"\\t.align\\t%u\\n\", log);\n+}\n+\n+/* The Iris assembler does not record alignment from .align directives,\n+   but takes it from the first .section directive seen.  Play yet more\n+   file switching games so that we can emit a .section directive at the\n+   beginning of the file with the proper alignment attached.  */\n+   \n+void\n+iris6_asm_file_start (stream)\n+     FILE *stream;\n+{\n+  mips_asm_file_start (stream);\n+\n+  iris_orig_asm_out_file = asm_out_file;\n+  stream = tmpfile ();\n+  asm_out_file = stream;\n+  asm_out_data_file = stream;\n+  if (! TARGET_FILE_SWITCHING)\n+    asm_out_text_file = stream;\n+\n+  iris_section_align_htab = htab_create (31, iris_section_align_entry_hash,\n+\t\t\t\t\t iris_section_align_entry_eq, NULL);\n+}\n+\n+static int\n+iris6_section_align_1 (slot, data)\n+     void **slot;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  const struct iris_section_align_entry *entry\n+    = *(const struct iris_section_align_entry **) slot;\n+\n+  iris6_asm_named_section_1 (entry->name, entry->flags, 1 << entry->log);\n+  return 1;\n+}\n+\n+void\n+iris6_asm_file_end (stream)\n+     FILE *stream;\n+{\n+  /* Emit section directives with the proper alignment at the top of the\n+     real output file.  */\n+  asm_out_file = iris_orig_asm_out_file;\n+  htab_traverse (iris_section_align_htab, iris6_section_align_1, NULL);\n+\n+  /* Copy the data emitted to the temp file to the real output file.  */\n+  copy_file_data (asm_out_file, stream);\n+\n+  mips_asm_file_end (stream);\n+}\n+#endif /* TARGET_IRIX6 */"}]}