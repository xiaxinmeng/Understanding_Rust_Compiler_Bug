{"sha": "62760ffd155d4ff29cf8f3092d756016a953b99e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI3NjBmZmQxNTVkNGZmMjljZjhmMzA5MmQ3NTYwMTZhOTUzYjk5ZQ==", "commit": {"author": {"name": "Caroline Tice", "email": "ctice@apple.com", "date": "2007-07-13T23:11:15Z"}, "committer": {"name": "Caroline Tice", "email": "ctice@gcc.gnu.org", "date": "2007-07-13T23:11:15Z"}, "message": "Add ability to track uninitialized variables, and mark uninitialized variables in the Dwarf debug info.\n\nAdd ability to track uninitialized variables, and mark uninitialized\nvariables in the Dwarf debug info.  Controlled by compile option\n-fvar-tracking-uninit\n\nFrom-SVN: r126630", "tree": {"sha": "b87516d5c9ea7c2c70b26f837f1dada3f4c4d0f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b87516d5c9ea7c2c70b26f837f1dada3f4c4d0f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62760ffd155d4ff29cf8f3092d756016a953b99e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62760ffd155d4ff29cf8f3092d756016a953b99e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62760ffd155d4ff29cf8f3092d756016a953b99e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62760ffd155d4ff29cf8f3092d756016a953b99e/comments", "author": null, "committer": null, "parents": [{"sha": "f861f54dd7ac84b6266d7bed21f5e79885cc5003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f861f54dd7ac84b6266d7bed21f5e79885cc5003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f861f54dd7ac84b6266d7bed21f5e79885cc5003"}], "stats": {"total": 702, "additions": 596, "deletions": 106}, "files": [{"sha": "01c0bdb3353e98b39f3c70aac48b5f2b360c3605", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -1,3 +1,102 @@\n+2007-07-13  Caroline Tice  <ctice@apple.com>\n+\t\n+\t* toplev.c (process_options): Turn flag_var_tracking_uninit off when\n+\tflag_var_tracking is explicitly turned off (i.e. when variable\n+\ttracking is not feasible); otherwise, turn flag_var_tracking on when\n+\tflag_var_tracking_uninit is on.\n+\t* rtl.def (VAR_LOCATION): Add a new integer subfield to VAR_LOCATION\n+\tnote definitions, to allow recording of initialization status in the\n+\tnotes.\n+\t* dwarf2out.c (dwarf_stack_op_name): Add case for DW_OP_GNU_uninit.\n+\t(add_var_loc_to_decl): Add comparison of NOTE_VAR_LOCATION_STATUS to\n+\tdetermine if two note locations are equal.\n+\t(output_loc_list): Don't output list entries whose start & end labels\n+\tare the same.\n+\t(reg_loc_descriptor): Add parameter for initialization status; pass it\n+\tto other loc descriptor functions.\n+\t(one_reg_loc_descriptor): Add parameter for initialization status;\n+\tcheck its value and add DW_OP_GNU_uninit to returned loc descr if\n+\tappropriate.\n+\t(multiple_reg_loc_descriptor): Add parameter for initialization\n+\tstatus;\n+\tpass init status argument to other loc descriptor functions; check\n+\tvalue of intialization parameter and add DW_OP_GNU_uninit to returned\n+\tloc descr if appropriate.\n+\t(based_loc_descr): Add parameter for initialization status; add new\n+\tvariable for return value; check value of initialization parameter and\n+\tadd DW_OP_GNU_uninit to returned loc descr if appropriate.\n+\t(concatn_mem_loc_descriptor): Add parameter for initialization status;\n+\tpass init status argument to other loc descriptor functions; check\n+\tvalue of intialization parameter and add DW_OP_GNU_uninit to returned\n+\tloc descr if appropriate.\n+\t(mem_loc_descriptor): Likewise.\n+\t(concat_loc_descriptor): Likewise.\n+\t(concatn_loc_descriptor): Likewise.\n+\t(loc_descriptor): Add parameter for initialization status; pass it as\n+\targument to other loc descriptor function calls.\n+\t(loc_descriptor_from_tree_1): Add appropriate initialization status\n+\tto loc descriptor function calls.\n+\t(add_location_or_const_value_attribute): Get initialization status\n+\tfrom VAR_LOCATION note; add initialization status to loc descriptor\n+\tfunction calls.\n+\t* dwarf2.h (enum dwarf_location_atom): New op, DW_OP_GNU_uninit.\n+\t* print-rtl.c (print_rtx): When printing a VAR_LOCATION note, if\n+\tstatus is uninitialized, add \"[uninint]\" to output.\n+\t* common.opt (fvar-tracking-uninit): New option, similar to\n+\tfvar-tracking, to turn on tracking of uninitialized variables; creates\n+\ta new global flag, flag_var_tracking_uninit.\n+\t* rtl.h (NOTE_VAR_LOCATION_STATUS): New macro for accessing new field.\n+\t(enum var_init_status): New type, for var initialization status field.\n+\t* var-tracking.c (struct location_chain_def): Two new fields, init,\n+\tfor initialization status, and set_src for the assignment value expr.\n+\t(unshare_variable): New parameter for initialization status;\n+\tinitialize new init and set_src fields.\n+\t(var_reg_set): New parameters for initialization status and value;\n+\tpass them to set_variable_part.\n+\t(var_mem_set): Likewise.\n+\t(get_init_value): New function.\n+\t(var_reg_delete_and_set): New initialization status & value\n+\tparameters; add call to get_init_value if status is unknown; pass new\n+\tparameters to clobber_variable_part and var_reg_set.\n+\t(var_mem_delete_and_set): Likewise.\n+\t(var_reg_delete): Pass null set_src value to clobber_variable_part.\n+\t(var_mem_delete): Likewise.\n+\t(variable_union): Pass status to unshare_variable; initialize new init\n+\tand set_src fields. If flag_var_tracking_uninit is not set, force\n+\tstatus to initialized.\n+\t(add_stores): Store insn, rather than NEXT_INSN(insn), so it can be\n+\tused later to get the set_src value.\n+\t(find_src_status): New function.\n+\t(find_src_set_src): New function.\n+\t(compute_bb_dataflow): Pass init status to calls to var_reg_set,\n+\tvar_mem_set, var_reg_delete_and_set and var_mem_delete_and_set; for\n+\tMO_SET, get set_src value and pass it to var_reg_delete_and_set\n+\tand var_mem_delete_and_set.\n+\t(dump_variable): Print out \"[uninit]\" if appropriate.\n+\t(set_variable_part): Add new initialization and set_src parameters;\n+\tpass status to unshare_variable; set node->init and node- >set_src\n+\tfields and modify slot in hash table appropriately; save the init and\n+\tset_src values if appropriate and assign to the new node.\n+\t(clobber_variable_part): New set_src parameter; if two nodes have\n+\tsame variable and same location but different set_src (assignment)\n+\tvalues, clobber old node.\n+\t(delete_variable_part): Pass init status to unshare_variable.\n+\t(emit_note_insn_var_location): Add initialized var; assign var's init\n+\tstatus to new 'initialized'; pass new init status field to calls to\n+\tgen_rtx_VAR_LOCATION. If flag_var_tracking_uninit is not set, force\n+\tstatus to initialized.\n+\t(emit_notes_in_bb): Pass initialization status to calls to\n+\tvar_reg_set, var_mem_set, var_reg_delete_and_set and\n+\tvar_mem_delete_and_set; for MO_SET, get set_src value and pass it to\n+\tvar_reg_delete_and_set and var_mem_delete_and_set; call\n+\temit_notes_for_changes on NEXT_INSN(insn) rather than on insn, to\n+\tmake up for change in add_stores.\n+\t(vt_add_function_parameters): Add status to calls to\n+\tset_variable_part.\n+\t* config/darwin.c (darwin_override_options): Turn on uninitialized\n+\ttracking automatically, if var_tracking is on and the system is\n+\t10.5 or higher.\n+\t\n 2007-07-13  Sa Liu  <saliu@de.ibm.com>\n \n \t* config.gcc: Add options for arch and tune on SPU."}, {"sha": "a37d3fcdd1d5cb3142a5386885344f431f045067", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -1130,6 +1130,10 @@ fvar-tracking\n Common Report Var(flag_var_tracking) VarExists Optimization\n Perform variable tracking\n \n+fvar-tracking-uninit\n+Common Report Var(flag_var_tracking_uninit) Optimization\n+Perform variable tracking and also tag variables that are uninitialized\n+\n ftree-vectorize\n Common Report Var(flag_tree_vectorize) Optimization\n Enable loop vectorization on trees"}, {"sha": "0673915200f30c2b7fedefaec0233ced6542c319", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -1728,6 +1728,9 @@ darwin_override_options (void)\n       /* No -fnon-call-exceptions data in kexts.  */\n       flag_non_call_exceptions = 0;\n     }\n+  if (flag_var_tracking\n+      && strverscmp (darwin_macosx_version_min, \"10.5\") >= 0)\n+    flag_var_tracking_uninit = 1;\n }\n \n #include \"gt-darwin.h\""}, {"sha": "ac0b3ba1a97f70ebb61b9d99972ee906676d3a0d", "filename": "gcc/dwarf2.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2.h?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -540,6 +540,8 @@ enum dwarf_location_atom\n     DW_OP_bit_piece = 0x9d,\n     /* GNU extensions.  */\n     DW_OP_GNU_push_tls_address = 0xe0,\n+    /* The following is for marking variables that are uninitialized.  */\n+    DW_OP_GNU_uninit     = 0xf0,\n     /* HP extensions.  */\n     DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */\n     DW_OP_HP_is_value    = 0xe1,"}, {"sha": "974419ffa75ec01be4575ae6a01ea39bd45aa2c3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 127, "deletions": 52, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -3125,6 +3125,8 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_call_ref\";\n     case DW_OP_GNU_push_tls_address:\n       return \"DW_OP_GNU_push_tls_address\";\n+    case DW_OP_GNU_uninit:\n+      return \"DW_OP_GNU_uninit\";\n     default:\n       return \"OP_<unknown>\";\n     }\n@@ -4193,15 +4195,20 @@ static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);\n static int type_is_enum (tree);\n static unsigned int dbx_reg_number (rtx);\n static void add_loc_descr_op_piece (dw_loc_descr_ref *, int);\n-static dw_loc_descr_ref reg_loc_descriptor (rtx);\n-static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int);\n-static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx);\n+static dw_loc_descr_ref reg_loc_descriptor (rtx, enum var_init_status);\n+static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int, \n+\t\t\t\t\t\tenum var_init_status);\n+static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,\n+\t\t\t\t\t\t     enum var_init_status);\n static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n-static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT);\n+static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n+\t\t\t\t\t enum var_init_status);\n static int is_based_loc (rtx);\n-static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode);\n-static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx);\n-static dw_loc_descr_ref loc_descriptor (rtx);\n+static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode,\n+\t\t\t\t\t    enum var_init_status);\n+static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n+\t\t\t\t\t       enum var_init_status);\n+static dw_loc_descr_ref loc_descriptor (rtx, enum var_init_status);\n static dw_loc_descr_ref loc_descriptor_from_tree_1 (tree, int);\n static dw_loc_descr_ref loc_descriptor_from_tree (tree);\n static HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n@@ -5757,9 +5764,16 @@ add_var_loc_to_decl (tree decl, struct var_loc_node *loc)\n   if (temp->last)\n     {\n       /* If the current location is the same as the end of the list,\n+\t and either both or neither of the locations is uninitialized,\n \t we have nothing to do.  */\n-      if (!rtx_equal_p (NOTE_VAR_LOCATION_LOC (temp->last->var_loc_note),\n-\t\t\tNOTE_VAR_LOCATION_LOC (loc->var_loc_note)))\n+      if ((!rtx_equal_p (NOTE_VAR_LOCATION_LOC (temp->last->var_loc_note),\n+\t\t\t NOTE_VAR_LOCATION_LOC (loc->var_loc_note)))\n+\t  || ((NOTE_VAR_LOCATION_STATUS (temp->last->var_loc_note)\n+\t       != NOTE_VAR_LOCATION_STATUS (loc->var_loc_note))\n+\t      && ((NOTE_VAR_LOCATION_STATUS (temp->last->var_loc_note)\n+\t\t   == VAR_INIT_STATUS_UNINITIALIZED)\n+\t\t  || (NOTE_VAR_LOCATION_STATUS (loc->var_loc_note)\n+\t\t      == VAR_INIT_STATUS_UNINITIALIZED))))\n \t{\n \t  /* Add LOC to the end of list and update LAST.  */\n \t  temp->last->next = loc;\n@@ -7069,6 +7083,9 @@ output_loc_list (dw_loc_list_ref list_head)\n   for (curr = list_head; curr != NULL; curr = curr->dw_loc_next)\n     {\n       unsigned long size;\n+      /* Don't output an entry that starts and ends at the same address.  */\n+      if (strcmp (curr->begin, curr->end) == 0)\n+\tcontinue;\n       if (!have_multiple_function_sections)\n \t{\n \t  dw2_asm_output_delta (DWARF2_ADDR_SIZE, curr->begin, curr->section,\n@@ -8747,7 +8764,7 @@ add_loc_descr_op_piece (dw_loc_descr_ref *list_head, int size)\n    zero if there is none.  */\n \n static dw_loc_descr_ref\n-reg_loc_descriptor (rtx rtl)\n+reg_loc_descriptor (rtx rtl, enum var_init_status initialized)\n {\n   rtx regs;\n \n@@ -8757,28 +8774,35 @@ reg_loc_descriptor (rtx rtl)\n   regs = targetm.dwarf_register_span (rtl);\n \n   if (hard_regno_nregs[REGNO (rtl)][GET_MODE (rtl)] > 1 || regs)\n-    return multiple_reg_loc_descriptor (rtl, regs);\n+    return multiple_reg_loc_descriptor (rtl, regs, initialized);\n   else\n-    return one_reg_loc_descriptor (dbx_reg_number (rtl));\n+    return one_reg_loc_descriptor (dbx_reg_number (rtl), initialized);\n }\n \n /* Return a location descriptor that designates a machine register for\n    a given hard register number.  */\n \n static dw_loc_descr_ref\n-one_reg_loc_descriptor (unsigned int regno)\n+one_reg_loc_descriptor (unsigned int regno, enum var_init_status initialized)\n {\n+  dw_loc_descr_ref reg_loc_descr;\n   if (regno <= 31)\n-    return new_loc_descr (DW_OP_reg0 + regno, 0, 0);\n+    reg_loc_descr = new_loc_descr (DW_OP_reg0 + regno, 0, 0);\n   else\n-    return new_loc_descr (DW_OP_regx, regno, 0);\n+    reg_loc_descr = new_loc_descr (DW_OP_regx, regno, 0);\n+\n+  if (initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&reg_loc_descr, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n+  return reg_loc_descr;\n }\n \n /* Given an RTL of a register, return a location descriptor that\n    designates a value that spans more than one register.  */\n \n static dw_loc_descr_ref\n-multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n+multiple_reg_loc_descriptor (rtx rtl, rtx regs, \n+\t\t\t     enum var_init_status initialized)\n {\n   int nregs, size, i;\n   unsigned reg;\n@@ -8806,7 +8830,8 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n \t{\n \t  dw_loc_descr_ref t;\n \n-\t  t = one_reg_loc_descriptor (DBX_REGISTER_NUMBER (reg));\n+\t  t = one_reg_loc_descriptor (DBX_REGISTER_NUMBER (reg),\n+\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n \t  add_loc_descr (&loc_result, t);\n \t  add_loc_descr_op_piece (&loc_result, size);\n \t  ++reg;\n@@ -8825,11 +8850,15 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n     {\n       dw_loc_descr_ref t;\n \n-      t = one_reg_loc_descriptor (REGNO (XVECEXP (regs, 0, i)));\n+      t = one_reg_loc_descriptor (REGNO (XVECEXP (regs, 0, i)),\n+\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n       add_loc_descr (&loc_result, t);\n       size = GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0)));\n       add_loc_descr_op_piece (&loc_result, size);\n     }\n+\n+  if (loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n   return loc_result;\n }\n \n@@ -8875,9 +8904,11 @@ int_loc_descriptor (HOST_WIDE_INT i)\n /* Return a location descriptor that designates a base+offset location.  */\n \n static dw_loc_descr_ref\n-based_loc_descr (rtx reg, HOST_WIDE_INT offset)\n+based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n+\t\t enum var_init_status initialized)\n {\n   unsigned int regno;\n+  dw_loc_descr_ref result;\n \n   /* We only use \"frame base\" when we're sure we're talking about the\n      post-prologue local stack frame.  We do this by *not* running\n@@ -8904,9 +8935,14 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset)\n \n   regno = dbx_reg_number (reg);\n   if (regno <= 31)\n-    return new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n+    result = new_loc_descr (DW_OP_breg0 + regno, offset, 0);\n   else\n-    return new_loc_descr (DW_OP_bregx, regno, offset);\n+    result = new_loc_descr (DW_OP_bregx, regno, offset);\n+\n+  if (initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n+  return result;\n }\n \n /* Return true if this RTL expression describes a base+offset calculation.  */\n@@ -8924,7 +8960,8 @@ is_based_loc (rtx rtl)\n    used to form the address of a memory location.  */\n \n static dw_loc_descr_ref\n-concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode)\n+concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode,\n+\t\t\t    enum var_init_status initialized)\n {\n   unsigned int i;\n   dw_loc_descr_ref cc_loc_result = NULL;\n@@ -8935,14 +8972,17 @@ concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode)\n       dw_loc_descr_ref ref;\n       rtx x = XVECEXP (concatn, 0, i);\n \n-      ref = mem_loc_descriptor (x, mode);\n+      ref = mem_loc_descriptor (x, mode, VAR_INIT_STATUS_INITIALIZED);\n       if (ref == NULL)\n \treturn NULL;\n \n       add_loc_descr (&cc_loc_result, ref);\n       add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x)));\n     }\n \n+  if (cc_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n   return cc_loc_result;\n }\n \n@@ -8965,7 +9005,8 @@ concatn_mem_loc_descriptor (rtx concatn, enum machine_mode mode)\n    Return 0 if we can't represent the location.  */\n \n static dw_loc_descr_ref\n-mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n+mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n+\t\t    enum var_init_status initialized)\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n   enum dwarf_location_atom op;\n@@ -9012,11 +9053,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n \t memory) so DWARF consumers need to be aware of the subtle\n \t distinction between OP_REG and OP_BASEREG.  */\n       if (REGNO (rtl) < FIRST_PSEUDO_REGISTER)\n-\tmem_loc_result = based_loc_descr (rtl, 0);\n+\tmem_loc_result = based_loc_descr (rtl, 0, VAR_INIT_STATUS_INITIALIZED);\n       break;\n \n     case MEM:\n-      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n+      mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n       if (mem_loc_result != 0)\n \tadd_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_deref, 0, 0));\n       break;\n@@ -9083,10 +9125,12 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n     plus:\n       if (is_based_loc (rtl))\n \tmem_loc_result = based_loc_descr (XEXP (rtl, 0),\n-\t\t\t\t\t  INTVAL (XEXP (rtl, 1)));\n+\t\t\t\t\t  INTVAL (XEXP (rtl, 1)),\n+\t\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n       else\n \t{\n-\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode);\n+\t  mem_loc_result = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n \t  if (mem_loc_result == 0)\n \t    break;\n \n@@ -9098,7 +9142,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n \t  else\n \t    {\n \t      add_loc_descr (&mem_loc_result,\n-\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode));\n+\t\t\t     mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\t\t\t VAR_INIT_STATUS_INITIALIZED));\n \t      add_loc_descr (&mem_loc_result,\n \t\t\t     new_loc_descr (DW_OP_plus, 0, 0));\n \t    }\n@@ -9125,8 +9170,10 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n \n     do_binop:\n       {\n-\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode);\n-\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode);\n+\tdw_loc_descr_ref op0 = mem_loc_descriptor (XEXP (rtl, 0), mode,\n+\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n+\tdw_loc_descr_ref op1 = mem_loc_descriptor (XEXP (rtl, 1), mode,\n+\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n \n \tif (op0 == 0 || op1 == 0)\n \t  break;\n@@ -9142,25 +9189,29 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode)\n       break;\n \n     case CONCATN:\n-      mem_loc_result = concatn_mem_loc_descriptor (rtl, mode);\n+      mem_loc_result = concatn_mem_loc_descriptor (rtl, mode, \n+\t\t\t\t\t\t   VAR_INIT_STATUS_INITIALIZED);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  if (mem_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&mem_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n   return mem_loc_result;\n }\n \n /* Return a descriptor that describes the concatenation of two locations.\n    This is typically a complex variable.  */\n \n static dw_loc_descr_ref\n-concat_loc_descriptor (rtx x0, rtx x1)\n+concat_loc_descriptor (rtx x0, rtx x1, enum var_init_status initialized)\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n-  dw_loc_descr_ref x0_ref = loc_descriptor (x0);\n-  dw_loc_descr_ref x1_ref = loc_descriptor (x1);\n+  dw_loc_descr_ref x0_ref = loc_descriptor (x0, VAR_INIT_STATUS_INITIALIZED);\n+  dw_loc_descr_ref x1_ref = loc_descriptor (x1, VAR_INIT_STATUS_INITIALIZED);\n \n   if (x0_ref == 0 || x1_ref == 0)\n     return 0;\n@@ -9171,14 +9222,17 @@ concat_loc_descriptor (rtx x0, rtx x1)\n   add_loc_descr (&cc_loc_result, x1_ref);\n   add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x1)));\n \n+  if (initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n   return cc_loc_result;\n }\n \n /* Return a descriptor that describes the concatenation of N\n    locations.  */\n \n static dw_loc_descr_ref\n-concatn_loc_descriptor (rtx concatn)\n+concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)\n {\n   unsigned int i;\n   dw_loc_descr_ref cc_loc_result = NULL;\n@@ -9189,14 +9243,17 @@ concatn_loc_descriptor (rtx concatn)\n       dw_loc_descr_ref ref;\n       rtx x = XVECEXP (concatn, 0, i);\n \n-      ref = loc_descriptor (x);\n+      ref = loc_descriptor (x, VAR_INIT_STATUS_INITIALIZED);\n       if (ref == NULL)\n \treturn NULL;\n \n       add_loc_descr (&cc_loc_result, ref);\n       add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x)));\n     }\n \n+  if (cc_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n+    add_loc_descr (&cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n+\n   return cc_loc_result;\n }\n \n@@ -9209,7 +9266,7 @@ concatn_loc_descriptor (rtx concatn)\n    If we don't know how to describe it, return 0.  */\n \n static dw_loc_descr_ref\n-loc_descriptor (rtx rtl)\n+loc_descriptor (rtx rtl, enum var_init_status initialized)\n {\n   dw_loc_descr_ref loc_result = NULL;\n \n@@ -9226,26 +9283,28 @@ loc_descriptor (rtx rtl)\n       /* ... fall through ...  */\n \n     case REG:\n-      loc_result = reg_loc_descriptor (rtl);\n+      loc_result = reg_loc_descriptor (rtl, initialized);\n       break;\n \n     case MEM:\n-      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl));\n+      loc_result = mem_loc_descriptor (XEXP (rtl, 0), GET_MODE (rtl),\n+\t\t\t\t       initialized);\n       break;\n \n     case CONCAT:\n-      loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1));\n+      loc_result = concat_loc_descriptor (XEXP (rtl, 0), XEXP (rtl, 1),\n+\t\t\t\t\t  initialized);\n       break;\n \n     case CONCATN:\n-      loc_result = concatn_loc_descriptor (rtl);\n+      loc_result = concatn_loc_descriptor (rtl, initialized);\n       break;\n \n     case VAR_LOCATION:\n       /* Single part.  */\n       if (GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n \t{\n-\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0));\n+\t  loc_result = loc_descriptor (XEXP (XEXP (rtl, 1), 0), initialized);\n \t  break;\n \t}\n \n@@ -9260,14 +9319,16 @@ loc_descriptor (rtx rtl)\n \tint i;\n \n \t/* Create the first one, so we have something to add to.  */\n-\tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0));\n+\tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n+\t\t\t\t     initialized);\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n \tadd_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n \tfor (i = 1; i < num_elem; i++)\n \t  {\n \t    dw_loc_descr_ref temp;\n \n-\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0));\n+\t    temp = loc_descriptor (XEXP (RTVEC_ELT (par_elems, i), 0),\n+\t\t\t\t   initialized);\n \t    add_loc_descr (&loc_result, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n \t    add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n@@ -9399,15 +9460,15 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \n \t    /* Certain constructs can only be represented at top-level.  */\n \t    if (want_address == 2)\n-\t      return loc_descriptor (rtl);\n+\t      return loc_descriptor (rtl, VAR_INIT_STATUS_INITIALIZED);\n \n \t    mode = GET_MODE (rtl);\n \t    if (MEM_P (rtl))\n \t      {\n \t\trtl = XEXP (rtl, 0);\n \t\thave_address = 1;\n \t      }\n-\t    ret = mem_loc_descriptor (rtl, mode);\n+\t    ret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n \t  }\n       }\n       break;\n@@ -9488,7 +9549,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t  return 0;\n \tmode = GET_MODE (rtl);\n \trtl = XEXP (rtl, 0);\n-\tret = mem_loc_descriptor (rtl, mode);\n+\tret = mem_loc_descriptor (rtl, mode, VAR_INIT_STATUS_INITIALIZED);\n \thave_address = 1;\n \tbreak;\n       }\n@@ -10575,6 +10636,7 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       const char *endname, *secname;\n       dw_loc_list_ref list;\n       rtx varloc;\n+      enum var_init_status initialized;\n \n       /* Now that we know what section we are using for a base,\n \t actually construct the list of locations.\n@@ -10591,7 +10653,12 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n       secname = secname_for_decl (decl);\n \n-      list = new_loc_list (loc_descriptor (varloc),\n+      if (NOTE_VAR_LOCATION_LOC (node->var_loc_note))\n+\tinitialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+      else\n+\tinitialized = VAR_INIT_STATUS_INITIALIZED;\n+\n+      list = new_loc_list (loc_descriptor (varloc, initialized),\n \t\t\t   node->label, node->next->label, secname, 1);\n       node = node->next;\n \n@@ -10600,8 +10667,11 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t  {\n \t    /* The variable has a location between NODE->LABEL and\n \t       NODE->NEXT->LABEL.  */\n+\t    enum var_init_status initialized =\n+\t      NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \t    varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\t    add_loc_descr_to_loc_list (&list, loc_descriptor (varloc),\n+\t    add_loc_descr_to_loc_list (&list, \n+\t\t\t\t       loc_descriptor (varloc, initialized),\n \t\t\t\t       node->label, node->next->label, secname);\n \t  }\n \n@@ -10610,6 +10680,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n       if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n \t{\n \t  char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t  enum var_init_status initialized =\n+\t    NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \n \t  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n \t  if (!current_function_decl)\n@@ -10620,7 +10692,8 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t\t\t\t\t   current_function_funcdef_no);\n \t      endname = ggc_strdup (label_id);\n \t    }\n-\t  add_loc_descr_to_loc_list (&list, loc_descriptor (varloc),\n+\t  add_loc_descr_to_loc_list (&list, \n+\t\t\t\t     loc_descriptor (varloc, initialized),\n \t\t\t\t     node->label, endname, secname);\n \t}\n \n@@ -10644,8 +10717,10 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n      location list, try generating a location from that.  */\n   if (loc_list && loc_list->first)\n     {\n+      enum var_init_status status;\n       node = loc_list->first;\n-      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note));\n+      status = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n+      descr = loc_descriptor (NOTE_VAR_LOCATION (node->var_loc_note), status);\n       if (descr)\n \t{\n \t  add_AT_location_description (die, attr, descr);"}, {"sha": "52b5c6581684764ff5c456536405c28b8ed2156a", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -325,6 +325,9 @@ print_rtx (rtx in_rtx)\n \t\tprint_mem_expr (outfile, NOTE_VAR_LOCATION_DECL (in_rtx));\n \t\tfprintf (outfile, \" \");\n \t\tprint_rtx (NOTE_VAR_LOCATION_LOC (in_rtx));\n+\t\tif (NOTE_VAR_LOCATION_STATUS (in_rtx) == \n+\t\t                                 VAR_INIT_STATUS_UNINITIALIZED)\n+\t\t  fprintf (outfile, \" [uninit]\");\n \t\tfprintf (outfile, \")\");\n #endif\n \t\tbreak;"}, {"sha": "1326202cc88cc1ca268f7a947d45764174cb3ec6", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -680,7 +680,9 @@ DEF_RTL_EXPR(SS_TRUNCATE, \"ss_truncate\", \"e\", RTX_UNARY)\n DEF_RTL_EXPR(US_TRUNCATE, \"us_truncate\", \"e\", RTX_UNARY)\n \n /* Information about the variable and its location.  */\n-DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"te\", RTX_EXTRA)\n+/* Changed 'te' to 'tei'; the 'i' field is for recording\n+   initialization status of variables.  */\n+DEF_RTL_EXPR(VAR_LOCATION, \"var_location\", \"tei\", RTX_EXTRA)\n \n /* All expressions from this point forward appear only in machine\n    descriptions.  */"}, {"sha": "63f65730d1092d4abf122c26a463c3949fab91ee", "filename": "gcc/rtl.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -847,6 +847,22 @@ extern const char * const reg_note_name[];\n #define NOTE_VAR_LOCATION_LOC(INSN)\t(XCEXP (XCEXP (INSN, 4, NOTE),  \\\n \t\t\t\t\t\t1, VAR_LOCATION))\n \n+/* Initialization status of the variable in the location.  Status\n+   can be unknown, uninitialized or initialized.  See enumeration\n+   type below.  */\n+#define NOTE_VAR_LOCATION_STATUS(INSN)  (XCINT (XCEXP (INSN, 4, NOTE), \\\n+\t\t\t\t\t\t2, VAR_LOCATION))\n+\n+/* Possible initialization status of a variable.   When requested\n+   by the user, this information is tracked and recorded in the DWARF\n+   debug information, along with the variable's location.  */\n+enum var_init_status\n+{\n+  VAR_INIT_STATUS_UNKNOWN,\n+  VAR_INIT_STATUS_UNINITIALIZED,\n+  VAR_INIT_STATUS_INITIALIZED\n+};\n+\n /* Codes that appear in the NOTE_KIND field for kinds of notes\n    that are not line numbers.  These codes are all negative.\n    "}, {"sha": "de86b38ae1693649be217064d62d5e5da95867d0", "filename": "gcc/toplev.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -1874,7 +1874,8 @@ process_options (void)\n   if (debug_info_level < DINFO_LEVEL_NORMAL\n       || debug_hooks->var_location == do_nothing_debug_hooks.var_location)\n     {\n-      if (flag_var_tracking == 1)\n+      if (flag_var_tracking == 1\n+\t  || flag_var_tracking_uninit == 1)\n         {\n \t  if (debug_info_level < DINFO_LEVEL_NORMAL)\n \t    warning (0, \"variable tracking requested, but useless unless \"\n@@ -1884,6 +1885,7 @@ process_options (void)\n \t\t     \"by this debug format\");\n \t}\n       flag_var_tracking = 0;\n+      flag_var_tracking_uninit = 0;\n     }\n \n   if (flag_rename_registers == AUTODETECT_VALUE)\n@@ -1893,6 +1895,12 @@ process_options (void)\n   if (flag_var_tracking == AUTODETECT_VALUE)\n     flag_var_tracking = optimize >= 1;\n \n+  /* If the user specifically requested variable tracking with tagging\n+     uninitialized variables, we need to turn on variable tracking.\n+     (We already determined above that variable tracking is feasible.)  */\n+  if (flag_var_tracking_uninit)\n+    flag_var_tracking = 1;\n+\n   /* If auxiliary info generation is desired, open the output file.\n      This goes in the same directory as the source file--unlike\n      all the other output files.  */"}, {"sha": "56dcc198d7dda027c33e6c2cdd307a934c1745c2", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 330, "deletions": 52, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62760ffd155d4ff29cf8f3092d756016a953b99e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=62760ffd155d4ff29cf8f3092d756016a953b99e", "patch": "@@ -219,6 +219,12 @@ typedef struct location_chain_def\n \n   /* The location (REG or MEM).  */\n   rtx loc;\n+\n+  /* The \"value\" stored in this location.  */\n+  rtx set_src;\n+\n+  /* Initialized? */\n+  enum var_init_status init;\n } *location_chain;\n \n /* Structure describing one part of variable.  */\n@@ -294,16 +300,19 @@ static void attrs_list_copy (attrs *, attrs);\n static void attrs_list_union (attrs *, attrs);\n \n static void vars_clear (htab_t);\n-static variable unshare_variable (dataflow_set *set, variable var);\n+static variable unshare_variable (dataflow_set *set, variable var, \n+\t\t\t\t  enum var_init_status);\n static int vars_copy_1 (void **, void *);\n static void vars_copy (htab_t, htab_t);\n static tree var_debug_decl (tree);\n-static void var_reg_set (dataflow_set *, rtx);\n-static void var_reg_delete_and_set (dataflow_set *, rtx, bool);\n+static void var_reg_set (dataflow_set *, rtx, enum var_init_status, rtx);\n+static void var_reg_delete_and_set (dataflow_set *, rtx, bool, \n+\t\t\t\t    enum var_init_status, rtx);\n static void var_reg_delete (dataflow_set *, rtx, bool);\n static void var_regno_delete (dataflow_set *, int);\n-static void var_mem_set (dataflow_set *, rtx);\n-static void var_mem_delete_and_set (dataflow_set *, rtx, bool);\n+static void var_mem_set (dataflow_set *, rtx, enum var_init_status, rtx);\n+static void var_mem_delete_and_set (dataflow_set *, rtx, bool, \n+\t\t\t\t    enum var_init_status, rtx);\n static void var_mem_delete (dataflow_set *, rtx, bool);\n \n static void dataflow_set_init (dataflow_set *, int);\n@@ -338,8 +347,10 @@ static void dump_dataflow_set (dataflow_set *);\n static void dump_dataflow_sets (void);\n \n static void variable_was_changed (variable, htab_t);\n-static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n-static void clobber_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n+static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT, \n+\t\t\t       enum var_init_status, rtx);\n+static void clobber_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT, \n+\t\t\t\t   rtx);\n static void delete_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n static int emit_note_insn_var_location (void **, void *);\n static void emit_notes_for_changes (rtx, enum emit_note_where);\n@@ -727,7 +738,8 @@ vars_clear (htab_t vars)\n /* Return a copy of a variable VAR and insert it to dataflow set SET.  */\n \n static variable\n-unshare_variable (dataflow_set *set, variable var)\n+unshare_variable (dataflow_set *set, variable var, \n+\t\t  enum var_init_status initialized)\n {\n   void **slot;\n   variable new_var;\n@@ -752,6 +764,14 @@ unshare_variable (dataflow_set *set, variable var)\n \n \t  new_lc = pool_alloc (loc_chain_pool);\n \t  new_lc->next = NULL;\n+\t  if (node->init > initialized)\n+\t    new_lc->init = node->init;\n+\t  else\n+\t    new_lc->init = initialized;\n+\t  if (node->set_src && !(MEM_P (node->set_src)))\n+\t    new_lc->set_src = node->set_src;\n+\t  else\n+\t    new_lc->set_src = NULL;\n \t  new_lc->loc = node->loc;\n \n \t  *nextp = new_lc;\n@@ -819,7 +839,8 @@ var_debug_decl (tree decl)\n /* Set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n \n static void\n-var_reg_set (dataflow_set *set, rtx loc)\n+var_reg_set (dataflow_set *set, rtx loc, enum var_init_status initialized, \n+\t     rtx set_src)\n {\n   tree decl = REG_EXPR (loc);\n   HOST_WIDE_INT offset = REG_OFFSET (loc);\n@@ -832,7 +853,38 @@ var_reg_set (dataflow_set *set, rtx loc)\n       break;\n   if (!node)\n     attrs_list_insert (&set->regs[REGNO (loc)], decl, offset, loc);\n-  set_variable_part (set, loc, decl, offset);\n+  set_variable_part (set, loc, decl, offset, initialized, set_src);\n+}\n+\n+static int\n+get_init_value (dataflow_set *set, rtx loc, tree decl)\n+{\n+  void **slot;\n+  variable var;\n+  int i;\n+  int ret_val = VAR_INIT_STATUS_UNKNOWN;\n+\n+  if (! flag_var_tracking_uninit)\n+    return VAR_INIT_STATUS_INITIALIZED;\n+\n+  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n+\t\t\t\t   NO_INSERT);\n+  if (slot)\n+    {\n+      var = * (variable *) slot;\n+      for (i = 0; i < var->n_var_parts && ret_val == VAR_INIT_STATUS_UNKNOWN; i++)\n+\t{\n+\t  location_chain nextp;\n+\t  for (nextp = var->var_part[i].loc_chain; nextp; nextp = nextp->next)\n+\t    if (rtx_equal_p (nextp->loc, loc))\n+\t      {\n+\t\tret_val = nextp->init;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  return ret_val;\n }\n \n /* Delete current content of register LOC in dataflow set SET and set\n@@ -843,7 +895,8 @@ var_reg_set (dataflow_set *set, rtx loc)\n    part.  */\n \n static void\n-var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n+var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify, \n+\t\t\tenum var_init_status initialized, rtx set_src)\n {\n   tree decl = REG_EXPR (loc);\n   HOST_WIDE_INT offset = REG_OFFSET (loc);\n@@ -852,6 +905,9 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n \n   decl = var_debug_decl (decl);\n \n+  if (initialized == VAR_INIT_STATUS_UNKNOWN)\n+    initialized = get_init_value (set, loc, decl);\n+\n   nextp = &set->regs[REGNO (loc)];\n   for (node = *nextp; node; node = next)\n     {\n@@ -869,8 +925,8 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n \t}\n     }\n   if (modify)\n-    clobber_variable_part (set, loc, decl, offset);\n-  var_reg_set (set, loc);\n+    clobber_variable_part (set, loc, decl, offset, set_src);\n+  var_reg_set (set, loc, initialized, set_src);\n }\n \n /* Delete current content of register LOC in dataflow set SET.  If\n@@ -890,7 +946,7 @@ var_reg_delete (dataflow_set *set, rtx loc, bool clobber)\n \n       decl = var_debug_decl (decl);\n \n-      clobber_variable_part (set, NULL, decl, offset);\n+      clobber_variable_part (set, NULL, decl, offset, NULL);\n     }\n \n   for (node = *reg; node; node = next)\n@@ -924,14 +980,15 @@ var_regno_delete (dataflow_set *set, int regno)\n    Adjust the address first if it is stack pointer based.  */\n \n static void\n-var_mem_set (dataflow_set *set, rtx loc)\n+var_mem_set (dataflow_set *set, rtx loc, enum var_init_status initialized, \n+\t     rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n \n   decl = var_debug_decl (decl);\n \n-  set_variable_part (set, loc, decl, offset);\n+  set_variable_part (set, loc, decl, offset, initialized, set_src);\n }\n \n /* Delete and set the location part of variable MEM_EXPR (LOC) in\n@@ -942,16 +999,20 @@ var_mem_set (dataflow_set *set, rtx loc)\n    Adjust the address first if it is stack pointer based.  */\n \n static void\n-var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n+var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify, \n+\t\t\tenum var_init_status initialized, rtx set_src)\n {\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n \n   decl = var_debug_decl (decl);\n \n+  if (initialized == VAR_INIT_STATUS_UNKNOWN)\n+    initialized = get_init_value (set, loc, decl);\n+\n   if (modify)\n-    clobber_variable_part (set, NULL, decl, offset);\n-  var_mem_set (set, loc);\n+    clobber_variable_part (set, NULL, decl, offset, set_src);\n+  var_mem_set (set, loc, initialized, set_src);\n }\n \n /* Delete the location part LOC from dataflow set SET.  If CLOBBER is\n@@ -966,7 +1027,7 @@ var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n \n   decl = var_debug_decl (decl);\n   if (clobber)\n-    clobber_variable_part (set, NULL, decl, offset);\n+    clobber_variable_part (set, NULL, decl, offset, NULL);\n   delete_variable_part (set, loc, decl, offset);\n }\n \n@@ -1078,7 +1139,14 @@ variable_union (void **slot, void *data)\n \t    }\n \t}\n       if (k < src->n_var_parts)\n-\tunshare_variable (set, src);\n+\t{\n+\t  enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n+\t  \n+\t  if (! flag_var_tracking_uninit)\n+\t    status = VAR_INIT_STATUS_INITIALIZED;\n+\n+\t  unshare_variable (set, src, status);\n+\t}\n       else\n \t*dstp = src;\n \n@@ -1112,7 +1180,13 @@ variable_union (void **slot, void *data)\n   gcc_assert (k <= MAX_VAR_PARTS);\n \n   if (dst->refcount > 1 && dst->n_var_parts != k)\n-    dst = unshare_variable (set, dst);\n+    {\n+      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n+      \n+      if (! flag_var_tracking_uninit)\n+\tstatus = VAR_INIT_STATUS_INITIALIZED;\n+      dst = unshare_variable (set, dst, status);\n+    }\n \n   i = src->n_var_parts - 1;\n   j = dst->n_var_parts - 1;\n@@ -1145,10 +1219,12 @@ variable_union (void **slot, void *data)\n \t\t\t && REG_P (node->loc)\n \t\t\t && REGNO (node2->loc) == REGNO (node->loc))\n \t\t\t|| rtx_equal_p (node2->loc, node->loc)))\n+\t\t    if (node2->init < node->init)\n+\t\t      node2->init = node->init;\n \t\t    break;\n \t\t}\n \t      if (node || node2)\n-\t\tdst = unshare_variable (set, dst);\n+\t\tdst = unshare_variable (set, dst, VAR_INIT_STATUS_UNKNOWN);\n \t    }\n \n \t  src_l = 0;\n@@ -1194,6 +1270,11 @@ variable_union (void **slot, void *data)\n \t\t  /* Copy the location from SRC.  */\n \t\t  new_node = pool_alloc (loc_chain_pool);\n \t\t  new_node->loc = node->loc;\n+\t\t  new_node->init = node->init;\n+\t\t  if (!node->set_src || MEM_P (node->set_src))\n+\t\t    new_node->set_src = NULL;\n+\t\t  else\n+\t\t    new_node->set_src = node->set_src;\n \t\t  vui[n].lc = new_node;\n \t\t  vui[n].pos_src = ii;\n \t\t  vui[n].pos_dst = src_l + dst_l;\n@@ -1240,6 +1321,11 @@ variable_union (void **slot, void *data)\n \n \t      new_lc = pool_alloc (loc_chain_pool);\n \t      new_lc->next = NULL;\n+\t      new_lc->init = node->init;\n+\t      if (!node->set_src || MEM_P (node->set_src))\n+\t\tnew_lc->set_src = NULL;\n+\t      else\n+\t\tnew_lc->set_src = node->set_src;\n \t      new_lc->loc = node->loc;\n \n \t      *nextp = new_lc;\n@@ -1258,6 +1344,18 @@ variable_union (void **slot, void *data)\n \tdst->var_part[k].cur_loc = NULL;\n     }\n \n+  for (i = 0; i < src->n_var_parts && i < dst->n_var_parts; i++)\n+    {\n+      location_chain node, node2;\n+      for (node = src->var_part[i].loc_chain; node; node = node->next)\n+\tfor (node2 = dst->var_part[i].loc_chain; node2; node2 = node2->next)\n+\t  if (rtx_equal_p (node->loc, node2->loc))\n+\t    {\n+\t      if (node->init > node2->init)\n+\t\tnode2->init = node->init;\n+\t    }\n+    }\n+\n   /* Continue traversing the hash table.  */\n   return 1;\n }\n@@ -1679,7 +1777,7 @@ add_stores (rtx loc, rtx expr, void *insn)\n       else\n \tmo->type = MO_SET;\n       mo->u.loc = loc;\n-      mo->insn = NEXT_INSN ((rtx) insn);\n+      mo->insn = (rtx) insn;\n     }\n   else if (MEM_P (loc)\n \t   && MEM_EXPR (loc)\n@@ -1700,10 +1798,99 @@ add_stores (rtx loc, rtx expr, void *insn)\n       else\n \tmo->type = MO_SET;\n       mo->u.loc = loc;\n-      mo->insn = NEXT_INSN ((rtx) insn);\n+      mo->insn = (rtx) insn;\n     }\n }\n \n+static enum var_init_status\n+find_src_status (dataflow_set *in, rtx loc, rtx insn)\n+{\n+  rtx src = NULL_RTX;\n+  tree decl = NULL_TREE;\n+  enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n+\n+  if (! flag_var_tracking_uninit)\n+    status = VAR_INIT_STATUS_INITIALIZED;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    src = SET_SRC (PATTERN (insn));\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      int i;\n+      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET\n+\t    && SET_DEST (XVECEXP (PATTERN (insn), 0, i)) == loc)\n+\t  src = SET_SRC (XVECEXP (PATTERN (insn), 0, i));\n+    }\n+\n+  if (REG_P (src))\n+    decl = var_debug_decl (REG_EXPR (src));\n+  else if (MEM_P (src))\n+    decl = var_debug_decl (MEM_EXPR (src));\n+\n+  if (src && decl)\n+    status = get_init_value (in, src, decl);\n+\n+  return status;\n+}\n+\n+/* LOC is the destination the variable is being copied to.  INSN \n+   contains the copy instruction.  SET is the dataflow set containing\n+   the variable in LOC.  */\n+\n+static rtx\n+find_src_set_src (dataflow_set *set, rtx loc, rtx insn)\n+{\n+  tree decl = NULL_TREE;   /* The variable being copied around.          */\n+  rtx src = NULL_RTX;      /* The location \"decl\" is being copied from.  */\n+  rtx set_src = NULL_RTX;  /* The value for \"decl\" stored in \"src\".      */\n+  void **slot;\n+  variable var;\n+  location_chain nextp;\n+  int i;\n+  bool found;\n+\n+  if (GET_CODE (PATTERN (insn)) == SET)\n+    src = SET_SRC (PATTERN (insn));\n+  else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t   || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    {\n+      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\tif (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET\n+\t    && SET_DEST (XVECEXP (PATTERN (insn), 0, i)) == loc)\n+\t  src = SET_SRC (XVECEXP (PATTERN (insn), 0, i));\n+    }\n+\n+  if (REG_P (src))\n+    decl = var_debug_decl (REG_EXPR (src));\n+  else if (MEM_P (src))\n+    decl = var_debug_decl (MEM_EXPR (src));\n+\n+  if (src && decl)\n+    {\n+      slot = htab_find_slot_with_hash (set->vars, decl, \n+\t\t\t\t       VARIABLE_HASH_VAL (decl), NO_INSERT);\n+\n+      if (slot)\n+\t{\n+\t  var = *(variable *) slot;\n+\t  found = false;\n+\t  for (i = 0; i < var->n_var_parts && !found; i++)\n+\t    for (nextp = var->var_part[i].loc_chain; nextp && !found; \n+\t\t nextp = nextp->next)\n+\t      if (rtx_equal_p (nextp->loc, src))\n+\t\t{\n+\t\t  set_src = nextp->set_src;\n+\t\t  found = true;\n+\t\t}\n+\t      \n+\t}\n+    }\n+\n+  return set_src;\n+}\n+\n /* Compute the changes of variable locations in the basic block BB.  */\n \n static bool\n@@ -1733,33 +1920,65 @@ compute_bb_dataflow (basic_block bb)\n \t  case MO_USE:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n+\n+\t      if (! flag_var_tracking_uninit)\n+\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n \n \t      if (GET_CODE (loc) == REG)\n-\t\tvar_reg_set (out, loc);\n+\t\tvar_reg_set (out, loc, status, NULL);\n \t      else if (GET_CODE (loc) == MEM)\n-\t\tvar_mem_set (out, loc);\n+\t\tvar_mem_set (out, loc, status, NULL);\n \t    }\n \t    break;\n \n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx set_src =  NULL;\n+\t      rtx insn = VTI (bb)->mos[i].insn;\n+\n+\t      if (GET_CODE (PATTERN (insn)) == SET)\n+\t\tset_src = SET_SRC (PATTERN (insn));\n+\t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t\t{\n+\t\t  int j;\n+\t\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n+\t\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n+\t\t\t&& SET_DEST (XVECEXP (PATTERN (insn), 0, j)) == loc)\n+\t\t      set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, j));\n+\t\t}\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (out, loc, true);\n+\t\tvar_reg_delete_and_set (out, loc, true, VAR_INIT_STATUS_INITIALIZED,\n+\t\t\t\t\tset_src);\n \t      else if (MEM_P (loc))\n-\t\tvar_mem_delete_and_set (out, loc, true);\n+\t\tvar_mem_delete_and_set (out, loc, true, VAR_INIT_STATUS_INITIALIZED,\n+\t\t\t\t\tset_src);\n \t    }\n \t    break;\n \n \t  case MO_COPY:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      enum var_init_status src_status;\n+\t      rtx set_src;\n+\n+\t      if (! flag_var_tracking_uninit)\n+\t\tsrc_status = VAR_INIT_STATUS_INITIALIZED;\n+\t      else\n+\t\tsrc_status = find_src_status (in, loc, VTI (bb)->mos[i].insn);\n+\n+\t      if (src_status == VAR_INIT_STATUS_UNKNOWN)\n+\t\tsrc_status = find_src_status (out, loc, VTI (bb)->mos[i].insn);\n+\n+\t      set_src = find_src_set_src (in, loc, VTI (bb)->mos[i].insn);\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (out, loc, false);\n+\t\tvar_reg_delete_and_set (out, loc, false, src_status, set_src);\n \t      else if (MEM_P (loc))\n-\t\tvar_mem_delete_and_set (out, loc, false);\n+\t\tvar_mem_delete_and_set (out, loc, false, src_status, set_src);\n \t    }\n \t    break;\n \n@@ -1932,6 +2151,8 @@ dump_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n       for (node = var->var_part[i].loc_chain; node; node = node->next)\n \t{\n \t  fprintf (dump_file, \"      \");\n+\t  if (node->init == VAR_INIT_STATUS_UNINITIALIZED)\n+\t    fprintf (dump_file, \"[uninit]\");\n \t  print_rtl_single (dump_file, node->loc);\n \t}\n     }\n@@ -2077,7 +2298,8 @@ find_variable_location_part (variable var, HOST_WIDE_INT offset,\n    part's location by LOC.  */\n \n static void\n-set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n+set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset,\n+\t\t   enum var_init_status initialized, rtx set_src)\n {\n   int pos;\n   location_chain node, next;\n@@ -2119,13 +2341,19 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t    {\n \t      /* LOC is in the beginning of the chain so we have nothing\n \t\t to do.  */\n+\t      if (node->init < initialized)\n+\t\tnode->init = initialized;\n+\t      if (set_src != NULL)\n+\t\tnode->set_src = set_src;\n+\n+\t      *slot = var;\n \t      return;\n \t    }\n \t  else\n \t    {\n \t      /* We have to make a copy of a shared variable.  */\n \t      if (var->refcount > 1)\n-\t\tvar = unshare_variable (set, var);\n+\t\tvar = unshare_variable (set, var, initialized);\n \t    }\n \t}\n       else\n@@ -2134,7 +2362,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \n \t  /* We have to make a copy of the shared variable.  */\n \t  if (var->refcount > 1)\n-\t    var = unshare_variable (set, var);\n+\t    var = unshare_variable (set, var, initialized);\n \n \t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n \t     thus there are at most MAX_VAR_PARTS different offsets.  */\n@@ -2161,6 +2389,12 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t   && REGNO (node->loc) == REGNO (loc))\n \t  || rtx_equal_p (node->loc, loc))\n \t{\n+\t  /* Save these values, to assign to the new node, before\n+\t     deleting this one.  */\n+\t  if (node->init > initialized)\n+\t    initialized = node->init;\n+\t  if (node->set_src != NULL && set_src == NULL)\n+\t    set_src = node->set_src;\n \t  pool_free (loc_chain_pool, node);\n \t  *nextp = next;\n \t  break;\n@@ -2172,6 +2406,8 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n   /* Add the location to the beginning.  */\n   node = pool_alloc (loc_chain_pool);\n   node->loc = loc;\n+  node->init = initialized;\n+  node->set_src = set_src;\n   node->next = var->var_part[pos].loc_chain;\n   var->var_part[pos].loc_chain = node;\n \n@@ -2190,7 +2426,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \n static void\n clobber_variable_part (dataflow_set *set, rtx loc, tree decl,\n-\t\t      HOST_WIDE_INT offset)\n+\t\t       HOST_WIDE_INT offset, rtx set_src)\n {\n   void **slot;\n \n@@ -2213,7 +2449,11 @@ clobber_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t  for (node = next; node; node = next)\n \t    {\n \t      next = node->next;\n-\t      if (node->loc != loc)\n+\t      if (node->loc != loc \n+\t\t  && (!flag_var_tracking_uninit\n+\t\t      || !set_src \n+\t\t      || MEM_P (set_src)\n+\t\t      || !rtx_equal_p (set_src, node->set_src)))\n \t\t{\n \t\t  if (REG_P (node->loc))\n \t\t    {\n@@ -2278,7 +2518,10 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t       && REGNO (node->loc) == REGNO (loc))\n \t\t      || rtx_equal_p (node->loc, loc))\n \t\t    {\n-\t\t      var = unshare_variable (set, var);\n+\t\t      enum var_init_status status = VAR_INIT_STATUS_UNKNOWN;\n+\t\t      if (! flag_var_tracking_uninit)\n+\t\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n+\t\t      var = unshare_variable (set, var, status);\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -2345,13 +2588,17 @@ emit_note_insn_var_location (void **varp, void *data)\n   rtx note;\n   int i, j, n_var_parts;\n   bool complete;\n+  enum var_init_status initialized = VAR_INIT_STATUS_UNINITIALIZED;\n   HOST_WIDE_INT last_limit;\n   tree type_size_unit;\n   HOST_WIDE_INT offsets[MAX_VAR_PARTS];\n   rtx loc[MAX_VAR_PARTS];\n \n   gcc_assert (var->decl);\n \n+  if (! flag_var_tracking_uninit)\n+    initialized = VAR_INIT_STATUS_INITIALIZED;\n+\n   complete = true;\n   last_limit = 0;\n   n_var_parts = 0;\n@@ -2369,6 +2616,7 @@ emit_note_insn_var_location (void **varp, void *data)\n       offsets[n_var_parts] = var->var_part[i].offset;\n       loc[n_var_parts] = var->var_part[i].loc_chain->loc;\n       mode = GET_MODE (loc[n_var_parts]);\n+      initialized = var->var_part[i].loc_chain->init;\n       last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n \n       /* Attempt to merge adjacent registers or memory.  */\n@@ -2447,18 +2695,22 @@ emit_note_insn_var_location (void **varp, void *data)\n   else\n     note = emit_note_before (NOTE_INSN_VAR_LOCATION, insn);\n \n+  if (! flag_var_tracking_uninit)\n+    initialized = VAR_INIT_STATUS_INITIALIZED;\n+\n   if (!complete)\n     {\n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n-\t\t\t\t\t\t       NULL_RTX);\n+\t\t\t\t\t\t       NULL_RTX, (int) initialized);\n     }\n   else if (n_var_parts == 1)\n     {\n       rtx expr_list\n \t= gen_rtx_EXPR_LIST (VOIDmode, loc[0], GEN_INT (offsets[0]));\n \n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n-\t\t\t\t\t\t       expr_list);\n+\t\t\t\t\t\t       expr_list, \n+\t\t\t\t\t\t       (int) initialized);\n     }\n   else if (n_var_parts)\n     {\n@@ -2471,7 +2723,8 @@ emit_note_insn_var_location (void **varp, void *data)\n       parallel = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t   gen_rtvec_v (n_var_parts, loc));\n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n-\t\t\t\t\t\t       parallel);\n+\t\t\t\t\t\t       parallel, \n+\t\t\t\t\t\t       (int) initialized);\n     }\n \n   htab_clear_slot (changed_variables, varp);\n@@ -2602,11 +2855,14 @@ emit_notes_in_bb (basic_block bb)\n \t  case MO_USE:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n-\n+      \n+\t      enum var_init_status status = VAR_INIT_STATUS_UNINITIALIZED;\n+\t      if (! flag_var_tracking_uninit)\n+\t\tstatus = VAR_INIT_STATUS_INITIALIZED;\n \t      if (GET_CODE (loc) == REG)\n-\t\tvar_reg_set (&set, loc);\n+\t\tvar_reg_set (&set, loc, status, NULL);\n \t      else\n-\t\tvar_mem_set (&set, loc);\n+\t\tvar_mem_set (&set, loc, status, NULL);\n \n \t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n \t    }\n@@ -2615,26 +2871,46 @@ emit_notes_in_bb (basic_block bb)\n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx set_src =  NULL;\n+\n+\t      if (GET_CODE (PATTERN (insn)) == SET)\n+\t\tset_src = SET_SRC (PATTERN (insn));\n+\t      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t\t       || GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t\t{\n+\t\t  int j;\n+\t\t  for (j = XVECLEN (PATTERN (insn), 0) - 1; j >= 0; j--)\n+\t\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET\n+\t\t\t&& SET_DEST (XVECEXP (PATTERN (insn), 0, j)) == loc)\n+\t\t      set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, j));\n+\t\t}\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (&set, loc, true);\n+\t\tvar_reg_delete_and_set (&set, loc, true, VAR_INIT_STATUS_INITIALIZED, \n+\t\t\t\t\tset_src);\n \t      else\n-\t\tvar_mem_delete_and_set (&set, loc, true);\n+\t\tvar_mem_delete_and_set (&set, loc, true, VAR_INIT_STATUS_INITIALIZED, \n+\t\t\t\t\tset_src);\n \n-\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n \t  case MO_COPY:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      enum var_init_status src_status;\n+\t      rtx set_src;\n+\n+\t      src_status = find_src_status (&set, loc, VTI (bb)->mos[i].insn);\n+\t      set_src = find_src_set_src (&set, loc, VTI (bb)->mos[i].insn);\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (&set, loc, false);\n+\t\tvar_reg_delete_and_set (&set, loc, false, src_status, set_src);\n \t      else\n-\t\tvar_mem_delete_and_set (&set, loc, false);\n+\t\tvar_mem_delete_and_set (&set, loc, false, src_status, set_src);\n \n-\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n@@ -2660,7 +2936,7 @@ emit_notes_in_bb (basic_block bb)\n \t      else\n \t\tvar_mem_delete (&set, loc, true);\n \n-\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t      emit_notes_for_changes (NEXT_INSN (insn), EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n@@ -2776,10 +3052,12 @@ vt_add_function_parameters (void)\n \t  gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n \t  attrs_list_insert (&out->regs[REGNO (incoming)],\n \t\t\t     parm, offset, incoming);\n-\t  set_variable_part (out, incoming, parm, offset);\n+\t  set_variable_part (out, incoming, parm, offset, VAR_INIT_STATUS_INITIALIZED, \n+\t\t\t     NULL);\n \t}\n       else if (MEM_P (incoming))\n-\tset_variable_part (out, incoming, parm, offset);\n+\tset_variable_part (out, incoming, parm, offset, VAR_INIT_STATUS_INITIALIZED, \n+\t\t\t   NULL);\n     }\n }\n "}]}