{"sha": "58393038d74a065fe2dd2980cf2e3e344f4f261b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgzOTMwMzhkNzRhMDY1ZmUyZGQyOTgwY2YyZTNlMzQ0ZjRmMjYxYg==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2005-05-24T22:24:38Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-05-24T22:24:38Z"}, "message": "c-common.h (objc_comptypes): Remove prototype.\n\n        * c-common.h (objc_comptypes): Remove prototype.\n        (objc_compare_types): New prototype.\n        (objc_volatilized_decl): Likewise.\n        (objc_type_quals_match): Likewise.\n        * c-decl.c (objc_mark_locals_volatile): Streamline by calling\n        objc_volatilize_decl().\n        * c-typeck.c (comp_target_types): Remove third parameter; do\n        not call objc_comptypes().\n        (comptypes): Remove calls to objc_comptypes().\n        (build_function_call): Extend compatible prototype check to ObjC.\n        (build_conditional_expr): Adjust call to comp_target_types().\n        (convert_for_assignment): Call objc_compare_types() instead of\n        objc_comptypes(); adjust calls to comp_target_types(); call\n        objc_type_quals_match() before issuing qualifier mismatch\n        warnings.\n        (build_binary_op): Call objc_compare_types() before issuing\n        pointer mismatch warnings; adjust calls to\n        comp_target_types().\n        * stub-objc.c (objc_comptypes): Remove stub.\n        (objc_compare_types): New stub.\n        (objc_volatilized_decl): Likewise.\n        (objc_type_quals_match): Likewise.\n\nFrom-SVN: r100126", "tree": {"sha": "dcf9d3d9c6e1b321845950ca9b3634cdd447bcba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf9d3d9c6e1b321845950ca9b3634cdd447bcba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58393038d74a065fe2dd2980cf2e3e344f4f261b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58393038d74a065fe2dd2980cf2e3e344f4f261b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58393038d74a065fe2dd2980cf2e3e344f4f261b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58393038d74a065fe2dd2980cf2e3e344f4f261b/comments", "author": null, "committer": null, "parents": [{"sha": "660845bf3a71cab364902d2e3b0830f08572d8f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660845bf3a71cab364902d2e3b0830f08572d8f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660845bf3a71cab364902d2e3b0830f08572d8f4"}], "stats": {"total": 192, "additions": 114, "deletions": 78}, "files": [{"sha": "5a6bae10167fe08dbea38d5c6866bcb7020273d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58393038d74a065fe2dd2980cf2e3e344f4f261b", "patch": "@@ -1,3 +1,28 @@\n+2005-05-24  Ziemowit Laski  <zlaski@apple.com>\n+\n+\t* c-common.h (objc_comptypes): Remove prototype.\n+\t(objc_compare_types): New prototype.\n+\t(objc_volatilized_decl): Likewise.\n+\t(objc_type_quals_match): Likewise.\n+\t* c-decl.c (objc_mark_locals_volatile): Streamline by calling\n+\tobjc_volatilize_decl().\n+\t* c-typeck.c (comp_target_types): Remove third parameter; do\n+\tnot call objc_comptypes().\n+\t(comptypes): Remove calls to objc_comptypes().\n+\t(build_function_call): Extend compatible prototype check to ObjC.\n+\t(build_conditional_expr): Adjust call to comp_target_types().\n+\t(convert_for_assignment): Call objc_compare_types() instead of\n+\tobjc_comptypes(); adjust calls to comp_target_types(); call\n+\tobjc_type_quals_match() before issuing qualifier mismatch\n+\twarnings.\n+\t(build_binary_op): Call objc_compare_types() before issuing\n+\tpointer mismatch warnings; adjust calls to\n+\tcomp_target_types().\n+\t* stub-objc.c (objc_comptypes): Remove stub.\n+\t(objc_compare_types): New stub.\n+\t(objc_volatilized_decl): Likewise.\n+\t(objc_type_quals_match): Likewise.\n+\n 2005-05-24  Paolo Carlini  <pcarlini@suse.de>\n \n \t* config/ia64/ia64intrin.h: Define nothing for C++:"}, {"sha": "4b860e2adeda0a16656ac13d7939f463ee4a0263", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=58393038d74a065fe2dd2980cf2e3e344f4f261b", "patch": "@@ -877,7 +877,9 @@ extern tree objc_is_class_name (tree);\n extern tree objc_is_object_ptr (tree);\n extern void objc_check_decl (tree);\n extern int objc_is_reserved_word (tree);\n-extern int objc_comptypes (tree, tree, int);\n+extern bool objc_compare_types (tree, tree, int, tree);\n+extern void objc_volatilize_decl (tree);\n+extern bool objc_type_quals_match (tree, tree);\n extern tree objc_rewrite_function_call (tree, tree);\n extern tree objc_message_selector (void);\n extern tree objc_lookup_ivar (tree, tree);"}, {"sha": "8653d8f2b2d9d167d03ffda039c74a70408944bb", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=58393038d74a065fe2dd2980cf2e3e344f4f261b", "patch": "@@ -566,25 +566,7 @@ objc_mark_locals_volatile (void *enclosing_blk)\n        scope = scope->outer)\n     {\n       for (b = scope->bindings; b; b = b->prev)\n-\t{\n-\t  tree decl = b->decl;\n-\n-\t  /* Do not mess with variables that are 'static' or (already)\n-\t     'volatile'.  */\n-\t  if (!TREE_THIS_VOLATILE (decl) && !TREE_STATIC (decl)\n-\t      && (TREE_CODE (decl) == VAR_DECL\n-\t\t  || TREE_CODE (decl) == PARM_DECL))\n-\t    {\n-\t      TREE_TYPE (decl)\n-\t\t= build_qualified_type (TREE_TYPE (decl),\n-\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (decl))\n-\t\t\t\t\t | TYPE_QUAL_VOLATILE));\n-\t      TREE_THIS_VOLATILE (decl) = 1;\n-\t      TREE_SIDE_EFFECTS (decl) = 1;\n-\t      DECL_REGISTER (decl) = 0;\n-\t      C_DECL_REGISTER (decl) = 0;\n-\t    }\n-\t}\n+\tobjc_volatilize_decl (b->decl);\n \n       /* Do not climb up past the current function.  */\n       if (scope->function_body)"}, {"sha": "1911ae593322a22df23da234c92bb448ba95d614", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 70, "deletions": 54, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=58393038d74a065fe2dd2980cf2e3e344f4f261b", "patch": "@@ -76,7 +76,7 @@ static int require_constant_elements;\n \n static tree qualify_type (tree, tree);\n static int tagged_types_tu_compatible_p (tree, tree);\n-static int comp_target_types (tree, tree, int);\n+static int comp_target_types (tree, tree);\n static int function_types_compatible_p (tree, tree);\n static int type_lists_compatible_p (tree, tree);\n static tree decl_constant_value_for_broken_optimization (tree);\n@@ -711,10 +711,6 @@ comptypes (tree type1, tree type2)\n   switch (TREE_CODE (t1))\n     {\n     case POINTER_TYPE:\n-      /* We must give ObjC the first crack at comparing pointers, since\n-\t   protocol qualifiers may be involved.  */\n-      if (c_dialect_objc () && (val = objc_comptypes (t1, t2, 0)) >= 0)\n-\tbreak;\n       /* Do not remove mode or aliasing information.  */\n       if (TYPE_MODE (t1) != TYPE_MODE (t2)\n \t  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n@@ -766,13 +762,8 @@ comptypes (tree type1, tree type2)\n         break;\n       }\n \n-    case RECORD_TYPE:\n-      /* We are dealing with two distinct structs.  In assorted Objective-C\n-\t corner cases, however, these can still be deemed equivalent.  */\n-      if (c_dialect_objc () && objc_comptypes (t1, t2, 0) == 1)\n-\tval = 1;\n-\n     case ENUMERAL_TYPE:\n+    case RECORD_TYPE:\n     case UNION_TYPE:\n       if (val != 1 && !same_translation_unit_p (t1, t2))\n \tval = tagged_types_tu_compatible_p (t1, t2);\n@@ -790,22 +781,14 @@ comptypes (tree type1, tree type2)\n }\n \n /* Return 1 if TTL and TTR are pointers to types that are equivalent,\n-   ignoring their qualifiers.  REFLEXIVE is only used by ObjC - set it\n-   to 1 or 0 depending if the check of the pointer types is meant to\n-   be reflexive or not (typically, assignments are not reflexive,\n-   while comparisons are reflexive).\n-*/\n+   ignoring their qualifiers.  */\n \n static int\n-comp_target_types (tree ttl, tree ttr, int reflexive)\n+comp_target_types (tree ttl, tree ttr)\n {\n   int val;\n   tree mvl, mvr;\n \n-  /* Give objc_comptypes a crack at letting these types through.  */\n-  if ((val = objc_comptypes (ttl, ttr, reflexive)) >= 0)\n-    return val;\n-\n   /* Do not lose qualifiers on element types of array types that are\n      pointer targets by taking their TYPE_MAIN_VARIANT.  */\n   mvl = TREE_TYPE (ttl);\n@@ -2049,13 +2032,8 @@ build_function_call (tree function, tree params)\n      If it is not, replace the call by a trap, wrapped up in a compound\n      expression if necessary.  This has the nice side-effect to prevent\n      the tree-inliner from generating invalid assignment trees which may\n-     blow up in the RTL expander later.\n-\n-     ??? This doesn't work for Objective-C because objc_comptypes\n-     refuses to compare function prototypes, yet the compiler appears\n-     to build calls that are flagged as invalid by C's comptypes.  */\n-  if (!c_dialect_objc ()\n-      && TREE_CODE (function) == NOP_EXPR\n+     blow up in the RTL expander later.  */\n+  if (TREE_CODE (function) == NOP_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (function, 0)) == ADDR_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (tem, 0)) == FUNCTION_DECL\n       && !comptypes (fntype, TREE_TYPE (tem)))\n@@ -3058,7 +3036,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     }\n   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)\n     {\n-      if (comp_target_types (type1, type2, 1))\n+      if (comp_target_types (type1, type2))\n \tresult_type = common_pointer_type (type1, type2);\n       else if (integer_zerop (op1) && TREE_TYPE (type1) == void_type_node\n \t       && TREE_CODE (orig_op1) != NOP_EXPR)\n@@ -3532,6 +3510,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n   tree rhstype;\n   enum tree_code coder;\n   tree rname = NULL_TREE;\n+  bool objc_ok = false;\n \n   if (errtype == ic_argpass || errtype == ic_argpass_nonproto)\n     {\n@@ -3593,14 +3572,35 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n   if (coder == ERROR_MARK)\n     return error_mark_node;\n \n+  if (c_dialect_objc ())\n+    {\n+      int parmno;\n+\n+      switch (errtype)\n+\t{\n+\tcase ic_return:\n+\t  parmno = 0;\n+\t  break;\n+\n+\tcase ic_assign:\n+\t  parmno = -1;\n+\t  break;\n+\n+\tcase ic_init:\n+\t  parmno = -2;\n+\t  break;\n+\n+\tdefault:\n+\t  parmno = parmnum;\n+\t  break;\n+\t}\n+\n+      objc_ok = objc_compare_types (type, rhstype, parmno, rname);\n+    }\n+\n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype))\n     {\n       overflow_warning (rhs);\n-      /* Check for Objective-C protocols.  This will automatically\n-\t issue a warning if there are protocol violations.  No need to\n-\t use the return value.  */\n-      if (c_dialect_objc ())\n-\tobjc_comptypes (type, rhstype, 0);\n       return rhs;\n     }\n \n@@ -3683,7 +3683,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t Meanwhile, the lhs target must have all the qualifiers of\n \t\t the rhs.  */\n \t      if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t\t  || comp_target_types (memb_type, rhstype, 0))\n+\t\t  || comp_target_types (memb_type, rhstype))\n \t\t{\n \t\t  /* If this type won't generate any warnings, use it.  */\n \t\t  if (TYPE_QUALS (ttl) == TYPE_QUALS (ttr)\n@@ -3786,7 +3786,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n       if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n-\t  || (target_cmp = comp_target_types (type, rhstype, 0))\n+\t  || (target_cmp = comp_target_types (type, rhstype))\n \t  || is_opaque_pointer\n \t  || (c_common_unsigned_type (mvl)\n \t      == c_common_unsigned_type (mvr)))\n@@ -3814,14 +3814,20 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n \t      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n-\t\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE discards \"\n-\t\t\t\t\t\"qualifiers from pointer target type\"),\n-\t\t\t\t     N_(\"assignment discards qualifiers \"\n-\t\t\t\t\t\"from pointer target type\"),\n-\t\t\t\t     N_(\"initialization discards qualifiers \"\n-\t\t\t\t\t\"from pointer target type\"),\n-\t\t\t\t     N_(\"return discards qualifiers from \"\n-\t\t\t\t\t\"pointer target type\"));\n+\t\t{\n+\t\t  /* Types differing only by the presence of the 'volatile'\n+\t\t     qualifier are acceptable if the 'volatile' has been added\n+\t\t     in by the Objective-C EH machinery.  */\n+\t\t  if (!objc_type_quals_match (ttl, ttr))\n+\t\t    WARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t    \"qualifiers from pointer target type\"),\n+\t\t\t\t\t N_(\"assignment discards qualifiers \"\n+\t\t\t\t\t    \"from pointer target type\"),\n+\t\t\t\t\t N_(\"initialization discards qualifiers \"\n+\t\t\t\t\t    \"from pointer target type\"),\n+\t\t\t\t\t N_(\"return discards qualifiers from \"\n+\t\t\t\t\t    \"pointer target type\"));\n+\t\t}\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n \t      else if (VOID_TYPE_P (ttl) || VOID_TYPE_P (ttr)\n@@ -3858,12 +3864,15 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    }\n \t}\n       else\n-\tWARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE from \"\n-\t\t\t\t\"incompatible pointer type\"),\n-\t\t\t     N_(\"assignment from incompatible pointer type\"),\n-\t\t\t     N_(\"initialization from incompatible \"\n-\t\t\t\t\"pointer type\"),\n-\t\t\t     N_(\"return from incompatible pointer type\"));\n+\t/* Avoid warning about the volatile ObjC EH puts on decls.  */\n+\tif (!objc_ok)\n+\t  WARN_FOR_ASSIGNMENT (N_(\"passing argument %d of %qE from \"\n+\t\t\t\t  \"incompatible pointer type\"),\n+\t\t\t       N_(\"assignment from incompatible pointer type\"),\n+\t\t\t       N_(\"initialization from incompatible \"\n+\t\t\t\t  \"pointer type\"),\n+\t\t\t       N_(\"return from incompatible pointer type\"));\n+\n       return convert (type, rhs);\n     }\n   else if (codel == POINTER_TYPE && coder == ARRAY_TYPE)\n@@ -7444,6 +7453,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* Nonzero means set RESULT_TYPE to the common type of the args.  */\n   int common = 0;\n \n+  /* True means types are compatible as far as ObjC is concerned.  */\n+  bool objc_ok;\n+\n   if (convert_p)\n     {\n       op0 = default_conversion (orig_op0);\n@@ -7473,6 +7485,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if (code0 == ERROR_MARK || code1 == ERROR_MARK)\n     return error_mark_node;\n \n+  objc_ok = objc_compare_types (type0, type1, -3, NULL_TREE);\n+\n   switch (code)\n     {\n     case PLUS_EXPR:\n@@ -7489,7 +7503,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       /* Subtraction of two similar pointers.\n \t We must subtract them as integers, then divide by object size.  */\n       if (code0 == POINTER_TYPE && code1 == POINTER_TYPE\n-\t  && comp_target_types (type0, type1, 1))\n+\t  && comp_target_types (type0, type1))\n \treturn pointer_diff (op0, op1);\n       /* Handle pointer minus int.  Just like pointer plus int.  */\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n@@ -7658,7 +7672,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  /* Anything compares with void *.  void * compares with anything.\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n-\t  if (comp_target_types (type0, type1, 1))\n+\t  if (comp_target_types (type0, type1))\n \t    result_type = common_pointer_type (type0, type1);\n \t  else if (VOID_TYPE_P (tt0))\n \t    {\n@@ -7677,7 +7691,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t\t \" with function pointer\");\n \t    }\n \t  else\n-\t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t    /* Avoid warning about the volatile ObjC EH puts on decls.  */\n+\t    if (!objc_ok)\n+\t      pedwarn (\"comparison of distinct pointer types lacks a cast\");\n \n \t  if (result_type == NULL_TREE)\n \t    result_type = ptr_type_node;\n@@ -7710,7 +7726,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  if (comp_target_types (type0, type1, 1))\n+\t  if (comp_target_types (type0, type1))\n \t    {\n \t      result_type = common_pointer_type (type0, type1);\n \t      if (!COMPLETE_TYPE_P (TREE_TYPE (type0))"}, {"sha": "f889bb9a9418cc2b9a8fd097c4dbcb5022f9c32c", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58393038d74a065fe2dd2980cf2e3e344f4f261b/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=58393038d74a065fe2dd2980cf2e3e344f4f261b", "patch": "@@ -63,11 +63,22 @@ objc_is_reserved_word (tree ARG_UNUSED (ident))\n   return 0;\n }\n \n-int\n-objc_comptypes (tree ARG_UNUSED (lhs), tree ARG_UNUSED (rhs),\n-                int ARG_UNUSED (reflexive))\n+bool\n+objc_compare_types (tree ARG_UNUSED (ltyp), tree ARG_UNUSED (rtyp),\n+\t\t    int ARG_UNUSED (argno), tree ARG_UNUSED (callee))\n+{\n+  return false;\n+}\n+\n+void\n+objc_volatilize_decl (tree ARG_UNUSED (decl))\n+{\n+}\n+\n+bool\n+objc_type_quals_match (tree ARG_UNUSED (ltyp), tree ARG_UNUSED (rtyp))\n {\n-  return -1;\n+  return false;\n }\n \n tree"}]}