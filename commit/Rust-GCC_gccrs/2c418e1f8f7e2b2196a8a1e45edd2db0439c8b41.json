{"sha": "2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0MThlMWY4ZjdlMmIyMTk2YThhMWU0NWVkZDJkYjA0MzljOGI0MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-05-06T21:24:19Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-05-06T21:24:19Z"}, "message": "escape: Add escape graph nodes.\n\n    \n    Introduces the nodes used to model connectivity in the escape graph\n    and related state: a node's escape level and an encoding that will\n    be added to import and export data.\n    \n    Reviewed-on: https://go-review.googlesource.com/18268\n\nFrom-SVN: r235988", "tree": {"sha": "9cff1c5a1d2140e4d01dba22cfbff722417e36d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cff1c5a1d2140e4d01dba22cfbff722417e36d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/comments", "author": null, "committer": null, "parents": [{"sha": "5e5b938aba46ad3de9fd20c9df60a17dc25981c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5b938aba46ad3de9fd20c9df60a17dc25981c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5b938aba46ad3de9fd20c9df60a17dc25981c1"}], "stats": {"total": 726, "additions": 709, "deletions": 17}, "files": [{"sha": "01f6e23183cc5b24d2cd2db8f2f192ea412f69b5", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "patch": "@@ -1,4 +1,4 @@\n-33f1d1d151721305ba37f3e23652d21310f868af\n+7f5a9fde801eb755a5252fd4ff588b0a47475bd3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4a5c46c55224f16c98a56f34b258ecb3fc9a21c6", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 262, "deletions": 10, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "patch": "@@ -4,9 +4,263 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+#include <limits>\n+#include <stack>\n+\n #include \"gogo.h\"\n+#include \"types.h\"\n+#include \"expressions.h\"\n+#include \"statements.h\"\n #include \"escape.h\"\n \n+// class Node.\n+\n+// Return the node's type, if it makes sense for it to have one.\n+\n+Type*\n+Node::type() const\n+{\n+  if (this->object() != NULL\n+      && this->object()->is_variable())\n+    return this->object()->var_value()->type();\n+  else if (this->object() != NULL\n+\t   && this->object()->is_function())\n+    return this->object()->func_value()->type();\n+  else if (this->expr() != NULL)\n+    return this->expr()->type();\n+  else\n+    return NULL;\n+}\n+\n+// A helper for reporting; return this node's location.\n+\n+Location\n+Node::location() const\n+{\n+  if (this->object() != NULL && !this->object()->is_sink())\n+    return this->object()->location();\n+  else if (this->expr() != NULL)\n+    return this->expr()->location();\n+  else if (this->statement() != NULL)\n+    return this->statement()->location();\n+  else\n+    return Linemap::unknown_location();\n+}\n+\n+// Return this node's state, creating it if has not been initialized.\n+\n+Node::Escape_state*\n+Node::state(Escape_context* context, Named_object* fn)\n+{\n+  if (this->state_ == NULL)\n+    {\n+      if (this->expr() != NULL && this->expr()->var_expression() != NULL)\n+\t{\n+\t  // Tie state of variable references to underlying variables.\n+\t  Named_object* var_no = this->expr()->var_expression()->named_object();\n+\t  Node* var_node = Node::make_node(var_no);\n+\t  this->state_ = var_node->state(context, fn);\n+\t}\n+      else\n+\t{\n+\t  this->state_ = new Node::Escape_state;\n+\t  if (fn == NULL)\n+\t    fn = context->current_function();\n+\n+\t  this->state_->fn = fn;\n+\t}\n+    }\n+  go_assert(this->state_ != NULL);\n+  return this->state_;\n+}\n+\n+void\n+Node::set_encoding(int enc)\n+{\n+  this->encoding_ = enc;\n+  if (this->expr() != NULL\n+      && this->expr()->var_expression() != NULL)\n+    {\n+      // Set underlying object as well.\n+      Named_object* no = this->expr()->var_expression()->named_object();\n+      Node::make_node(no)->set_encoding(enc);\n+    }\n+}\n+\n+bool\n+Node::is_sink() const\n+{\n+  if (this->object() != NULL\n+      && this->object()->is_sink())\n+    return true;\n+  else if (this->expr() != NULL\n+\t   && this->expr()->is_sink_expression())\n+    return true;\n+  return false;\n+}\n+\n+std::map<Named_object*, Node*> Node::objects;\n+std::map<Expression*, Node*> Node::expressions;\n+std::map<Statement*, Node*> Node::statements;\n+\n+// Make a object node or return a cached node for this object.\n+\n+Node*\n+Node::make_node(Named_object* no)\n+{\n+  if (Node::objects.find(no) != Node::objects.end())\n+    return Node::objects[no];\n+\n+  Node* n = new Node(no);\n+  std::pair<Named_object*, Node*> val(no, n);\n+  Node::objects.insert(val);\n+  return n;\n+}\n+\n+// Make an expression node or return a cached node for this expression.\n+\n+Node*\n+Node::make_node(Expression* e)\n+{\n+  if (Node::expressions.find(e) != Node::expressions.end())\n+    return Node::expressions[e];\n+\n+  Node* n = new Node(e);\n+  std::pair<Expression*, Node*> val(e, n);\n+  Node::expressions.insert(val);\n+  return n;\n+}\n+\n+// Make a statement node or return a cached node for this statement.\n+\n+Node*\n+Node::make_node(Statement* s)\n+{\n+  if (Node::statements.find(s) != Node::statements.end())\n+    return Node::statements[s];\n+\n+  Node* n = new Node(s);\n+  std::pair<Statement*, Node*> val(s, n);\n+  Node::statements.insert(val);\n+  return n;\n+}\n+\n+// Returns the maximum of an exisiting escape value\n+// (and its additional parameter flow flags) and a new escape type.\n+\n+int\n+Node::max_encoding(int e, int etype)\n+{\n+  if ((e & ESCAPE_MASK) >= etype)\n+    return e;\n+  if (etype == Node::ESCAPE_NONE || etype == Node::ESCAPE_RETURN)\n+    return (e & ~ESCAPE_MASK) | etype;\n+  return etype;\n+}\n+\n+// Return a modified encoding for an input parameter that flows into an\n+// output parameter.\n+\n+// Class Escape_context.\n+\n+Escape_context::Escape_context(Gogo* gogo, bool recursive)\n+  : gogo_(gogo), current_function_(NULL), recursive_(recursive),\n+    sink_(Node::make_node(Named_object::make_sink())), loop_depth_(0)\n+{\n+  // The sink always escapes to heap and strictly lives outside of the\n+  // current function i.e. loop_depth == -1.\n+  this->sink_->set_encoding(Node::ESCAPE_HEAP);\n+  Node::Escape_state* state = this->sink_->state(this, NULL);\n+  state->loop_depth = -1;\n+}\n+\n+// Initialize the dummy return values for this Node N using the results\n+// in FNTYPE.\n+\n+void\n+Escape_context::init_retvals(Node* n, Function_type* fntype)\n+{\n+  if (fntype == NULL || fntype->results() == NULL)\n+    return;\n+\n+  Node::Escape_state* state = n->state(this, NULL);\n+  Location loc = n->location();\n+\n+  int i = 0;\n+  char buf[50];\n+  for (Typed_identifier_list::const_iterator p = fntype->results()->begin();\n+       p != fntype->results()->end();\n+       ++p, ++i)\n+    {\n+      snprintf(buf, sizeof buf, \".out%d\", i);\n+      Variable* dummy_var = new Variable(p->type(), NULL, false, false,\n+\t\t\t\t\t false, loc);\n+      dummy_var->set_is_used();\n+      Named_object* dummy_no =\n+\tNamed_object::make_variable(buf, NULL, dummy_var);\n+      Node* dummy_node = Node::make_node(dummy_no);\n+      // Initialize the state of the dummy output node.\n+      dummy_node->state(this, NULL);\n+\n+      // Add dummy node to the retvals of n.\n+      state->retvals.push_back(dummy_node);\n+    }\n+}\n+\n+\n+// Apply an indirection to N and return the result.\n+// This really only works if N is an expression node; it essentially becomes\n+// Node::make_node(n->expr()->deref()).  We need the escape context to set the\n+// correct loop depth, however.\n+\n+Node*\n+Escape_context::add_dereference(Node* n)\n+{\n+  // Just return the original node if we can't add an indirection.\n+  if (n->object() != NULL || n->statement() != NULL)\n+    return n;\n+\n+  Node* ind = Node::make_node(n->expr()->deref());\n+  // Initialize the state if this node doesn't already exist.\n+  ind->state(this, NULL);\n+  return ind;\n+}\n+\n+void\n+Escape_context::track(Node* n)\n+{\n+  n->set_encoding(Node::ESCAPE_NONE);\n+  // Initialize this node's state if it hasn't been encountered\n+  // before.\n+  Node::Escape_state* state = n->state(this, NULL);\n+  state->loop_depth = this->loop_depth_;\n+\n+  this->noesc_.push_back(n);\n+}\n+\n+// Return the string representation of an escapement encoding.\n+\n+std::string\n+Escape_note::make_tag(int encoding)\n+{\n+  char buf[50];\n+  snprintf(buf, sizeof buf, \"esc:0x%x\", encoding);\n+  return buf;\n+}\n+\n+// Return the escapement encoding for a string tag.\n+\n+int\n+Escape_note::parse_tag(std::string* tag)\n+{\n+  if (tag == NULL || tag->substr(0, 4) != \"esc:\")\n+    return Node::ESCAPE_UNKNOWN;\n+  int encoding = (int)strtol(tag->substr(4).c_str(), NULL, 0);\n+  if (encoding == 0)\n+    return Node::ESCAPE_UNKNOWN;\n+  return encoding;\n+}\n+\n // Analyze the program flow for escape information.\n \n void\n@@ -21,7 +275,7 @@ Gogo::analyze_escape()\n        ++p)\n     {\n       std::vector<Named_object*> stack = p->first;\n-      Escape_context* context = new Escape_context(p->second);\n+      Escape_context* context = new Escape_context(this, p->second);\n \n       // Analyze the flow of each function; build the connection graph.\n       // This is the assign phase.\n@@ -33,13 +287,12 @@ Gogo::analyze_escape()\n \t  this->assign_connectivity(context, *fn);\n \t}\n \n-      // TODO(cmang): Introduce escape node.\n       // Propagate levels across each dst.  This is the flood phase.\n-      // std::vector<Node*> dsts = context->dsts();\n-      // for (std::vector<Node*>::iterator n = dsts.begin();\n-      //      n != dsts.end();\n-      //      ++n)\n-      //   this->propagate_escape(context, *n);\n+      std::set<Node*> dsts = context->dsts();\n+      for (std::set<Node*>::iterator n = dsts.begin();\n+           n != dsts.end();\n+           ++n)\n+        this->propagate_escape(context, *n);\n \n       // Tag each exported function's parameters with escape information.\n       for (std::vector<Named_object*>::iterator fn = stack.begin();\n@@ -71,11 +324,10 @@ Gogo::assign_connectivity(Escape_context*, Named_object*)\n   // TODO(cmang): Analyze the current function's body.\n }\n \n-// Propagate escape information across the nodes modeled in this Analysis_set,\n-// TODO(cmang): Introduce escape analysis node.\n+// Propagate escape information across the nodes modeled in this Analysis_set.\n \n void\n-Gogo::propagate_escape(Escape_context*)\n+Gogo::propagate_escape(Escape_context*, Node*)\n {\n   // TODO(cmang): Do a breadth-first traversal of a node's upstream, adjusting\n   // the Level appropriately."}, {"sha": "c409acb310c579f152d2c1d9cf6a417efc4265f6", "filename": "gcc/go/gofrontend/escape.h", "status": "modified", "additions": 401, "deletions": 3, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "patch": "@@ -7,16 +7,324 @@\n #ifndef GO_ESCAPE_H\n #define GO_ESCAPE_H\n \n+#include \"gogo.h\"\n+\n class Named_object;\n+class Expression;\n+class Statement;\n+class Escape_context;\n+\n+// There can be loops in the escape graph that lead to arbitrary recursions.\n+// See comment in gc/esc.go.\n+static const int MIN_LEVEL = -2;\n+\n+// Level models the escapement of a Node using two integers that are computed\n+// by backwards-analyzing the flow of a function from its sink and increasing or\n+// decreasing based on dereferences and addressing, respectively.\n+// One integer, known as the level's VALUE (think absolute value), is just the\n+// sum of indirections (via referencing or dereferencing) applied to the Node.\n+// The second, known as the level's SUFFIX_VALUE, is the amount of indirections\n+// applied after some data has been copied from the node.  When accessing a\n+// field F of an object O and then applying indirections, for example, the field\n+// access O.F is assumed to copy that data from O before applying indirections.\n+// With this, even if O.F escapes, it might mean that the content of O escape,\n+// but not the object O itself.\n+\n+class Level\n+{\n+public:\n+  Level()\n+    : value_(0), suffix_value_(0)\n+  { }\n+\n+  Level(int value, int suffix)\n+    : value_(value), suffix_value_(suffix)\n+  { }\n+\n+  // Return this level's value.\n+  int\n+  value() const\n+  { return this->value_; }\n+\n+  // Return this level's suffix value.\n+  int\n+  suffix_value() const\n+  { return this->suffix_value_; }\n+\n+  // Increase the level because a node is referenced.\n+  Level\n+  increase() const\n+  {\n+    if (this->value_ <= MIN_LEVEL)\n+      return Level(MIN_LEVEL, 0);\n+\n+    return Level(this->value_ + 1, this->suffix_value_ + 1);\n+  }\n+\n+  // Decrease the level because a node is dereferenced.\n+  Level\n+  decrease() const\n+  {\n+    if (this->value_ <= MIN_LEVEL)\n+      return Level(MIN_LEVEL, 0);\n+\n+    return Level(this->value_ - 1, this->suffix_value_ - 1);\n+  }\n+\n+  // Model a node being copied.\n+  Level\n+  copy() const\n+  {\n+    return Level(this->value_, std::max(this->suffix_value_, 0));\n+  }\n+\n+  // Return a level with the minimum values of this level and l.\n+  Level\n+  min(const Level& l) const\n+  {\n+    return Level(std::min(this->value_, l.value()),\n+                 std::min(this->suffix_value_, l.suffix_value()));\n+  }\n+\n+  // Compare two levels for equality.\n+  bool\n+  operator==(const Level& l) const\n+  {\n+    return (this->value_ == l.value()\n+\t    && this->suffix_value_ == l.suffix_value());\n+  }\n+\n+  // Create a level from an integer value.\n+  static Level\n+  From(int i)\n+  {\n+    if (i <= MIN_LEVEL)\n+      return Level(MIN_LEVEL, 0);\n+    return Level(i, 0);\n+  }\n+\n+private:\n+  // The sum of all indirects (-1) and references (+1) applied to a Node.\n+  int value_;\n+  // The sum of all indirects (-1) abd references (+1) applied to a copied Node.\n+  int suffix_value_;\n+};\n+\n+// A node in the escape graph.  This node is an alias to a particular node\n+// in the Go parse tree.  Specifically, it can represent an expression node,\n+// a statement node, or a named object node (a variable or function).\n+\n+class Node\n+{\n+ public:\n+  // This classification represents type of nodes in the Go parse tree that are\n+  // interesting during the analysis.\n+  enum Node_classification\n+    {\n+      NODE_OBJECT,\n+      NODE_EXPRESSION,\n+      NODE_STATEMENT\n+    };\n+\n+  // The state necessary to keep track of how a node escapes.\n+  struct Escape_state\n+  {\n+    // The current function.\n+    Named_object* fn;\n+    // A list of source nodes that flow into this node.\n+    std::set<Node*> flows;\n+    // If the node is a function call, the list of nodes returned.\n+    std::vector<Node*> retvals;\n+    // The node's loop depth.\n+    int loop_depth;\n+    // There is an extra loop depth in the flood phase used to account for\n+    // variables referenced across closures.  This is the maximum value of the\n+    // extra loop depth seen during the flood that touches this node.\n+    int max_extra_loop_depth;\n+    // The node's level.\n+    Level level;\n+    // An ID given to a node when it is encountered as a flow from the current\n+    // dst node.  This is used to avoid infinite recursion of cyclic nodes.\n+    int flood_id;\n+\n+    Escape_state()\n+      : fn(NULL), loop_depth(0), max_extra_loop_depth(0), flood_id(0)\n+    { }\n+  };\n+\n+  // Note: values in this enum appear in export data, and therefore MUST NOT\n+  // change.\n+  enum Escapement_encoding\n+  {\n+    ESCAPE_UNKNOWN,\n+    // Does not escape to heap, result, or parameters.\n+    ESCAPE_NONE,\n+    // Is returned or reachable from a return statement.\n+    ESCAPE_RETURN,\n+    // Allocated in an inner loop, assigned to an outer loop,\n+    // which allows construction of non-escaping but arbitrarily large linked\n+    // data structures (i.e., not eligible for allocation in a fixed-size stack\n+    // stack frame).\n+    ESCAPE_SCOPE,\n+    // Reachable from the heap.\n+    ESCAPE_HEAP,\n+    // By construction will not escape.\n+    ESCAPE_NEVER\n+  };\n+\n+  // Multiple constructors for each classification.\n+  Node(Named_object* no)\n+    : classification_(NODE_OBJECT), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+  { this->u_.object_val = no; }\n+\n+  Node(Expression* e)\n+    : classification_(NODE_EXPRESSION), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+  { this->u_.expression_val = e; }\n+\n+  Node(Statement* s)\n+    : classification_(NODE_STATEMENT), state_(NULL), encoding_(ESCAPE_UNKNOWN)\n+  { this->u_.statement_val = s; }\n+\n+  // Return this node's type.\n+  Type*\n+  type() const;\n+\n+  // Return this node's location.\n+  Location\n+  location() const;\n+\n+  // Return this node's escape state.\n+  Escape_state*\n+  state(Escape_context* context, Named_object* fn);\n+\n+  // Return this node's escape encoding.\n+  int\n+  encoding() const\n+  { return this->encoding_; }\n+\n+  // Set the node's escape encoding.\n+  void\n+  set_encoding(int enc);\n+\n+  // Is this node a sink?\n+  bool\n+  is_sink() const;\n+\n+  // Methods to return the underlying value in the Node union.\n+  Named_object*\n+  object() const\n+  {\n+    return (this->classification_ == NODE_OBJECT\n+            ? this->u_.object_val\n+            : NULL);\n+  }\n+\n+  Expression*\n+  expr() const\n+  {\n+    return (this->classification_ == NODE_EXPRESSION\n+            ? this->u_.expression_val\n+            : NULL);\n+  }\n+\n+  Statement*\n+  statement() const\n+  {\n+    return (this->classification_ == NODE_STATEMENT\n+            ? this->u_.statement_val\n+            : NULL);\n+  }\n+\n+  // Static creation methods for each value supported in the union.\n+  static Node*\n+  make_node(Named_object*);\n+\n+  static Node*\n+  make_node(Expression*);\n+\n+  static Node*\n+  make_node(Statement*);\n+\n+  // Return the maximum of an existing escape encoding E and a new\n+  // escape type.\n+  static int\n+  max_encoding(int e, int etype);\n+\n+ private:\n+  // The classification of this Node.\n+  Node_classification classification_;\n+  // The value union.\n+  union\n+  {\n+    // If NODE_OBJECT.\n+    Named_object* object_val;\n+    // If NODE_EXPRESSION.\n+    Expression* expression_val;\n+    // If NODE_STATEMENT.\n+    Statement* statement_val;\n+  } u_;\n+  // The node's escape state.\n+  Escape_state* state_;\n+  // The node's escape encoding.\n+  // The encoding:\n+  // | Return Encoding: (width - ESCAPE_RETURN_BITS) |\n+  // | Content Escapes bit: 1 |\n+  // | Escapement_encoding: ESCAPE_BITS |\n+  int encoding_;\n+\n+  // Cache all the Nodes created via Node::make_node to make the API simpler.\n+  static std::map<Named_object*, Node*> objects;\n+  static std::map<Expression*, Node*> expressions;\n+  static std::map<Statement*, Node*> statements;\n+};\n+\n+// The amount of bits used for the escapement encoding.\n+static const int ESCAPE_BITS = 3;\n+\n+// Mask used to extract encoding.\n+static const int ESCAPE_MASK = (1 << ESCAPE_BITS) - 1;\n+\n+// Value obtained by indirect of parameter escapes to heap.\n+static const int ESCAPE_CONTENT_ESCAPES = 1 << ESCAPE_BITS;\n+\n+// The amount of bits used in encoding of return values.\n+static const int ESCAPE_RETURN_BITS = ESCAPE_BITS + 1;\n+\n+// For each output, the number of bits for a tag.\n+static const int ESCAPE_BITS_PER_OUTPUT_IN_TAG = 3;\n+\n+// The bit max to extract a single tag.\n+static const int ESCAPE_BITS_MASK_FOR_TAG = (1 << ESCAPE_BITS_PER_OUTPUT_IN_TAG) - 1;\n+\n+// The largest level that can be stored in a tag.\n+static const int ESCAPE_MAX_ENCODED_LEVEL = ESCAPE_BITS_MASK_FOR_TAG - 1;\n+\n+// A helper for converting escape notes from encoded integers to a\n+// textual format and vice-versa.\n+\n+class Escape_note\n+{\n+ public:\n+  // Return the string representation of an escapement encoding.\n+  static std::string\n+  make_tag(int encoding);\n+\n+  // Return the escapement encoding for a string tag.\n+  static int\n+  parse_tag(std::string* tag);\n+};\n \n // The escape context for a set of functions being analyzed.\n \n class Escape_context\n {\n  public:\n-  Escape_context(bool recursive)\n-    : current_function_(NULL), recursive_(recursive)\n-  { }\n+  Escape_context(Gogo* gogo, bool recursive);\n+\n+  // Return the Go IR.\n+  Gogo*\n+  gogo() const\n+  { return this->gogo_; }\n \n   // Return the current function being analyzed.\n   Named_object*\n@@ -33,12 +341,102 @@ class Escape_context\n   recursive() const\n   { return this->recursive_; }\n \n+  // Return the special sink node for this context.\n+  Node*\n+  sink()\n+  { return this->sink_; }\n+\n+  // Return the current loop depth.\n+  int\n+  loop_depth() const\n+  { return this->loop_depth_; }\n+\n+  // Increase the loop depth.\n+  void\n+  increase_loop_depth()\n+  { this->loop_depth_++; }\n+\n+  // Decrease the loop depth.\n+  void\n+  decrease_loop_depth()\n+  { this->loop_depth_--; }\n+\n+  void\n+  set_loop_depth(int depth)\n+  { this->loop_depth_ = depth; }\n+\n+  // Return the destination nodes encountered in this context.\n+  const std::set<Node*>&\n+  dsts() const\n+  { return this->dsts_; }\n+\n+  // Add a destination node.\n+  void\n+  add_dst(Node* dst)\n+  { this->dsts_.insert(dst); }\n+\n+  // Return the nodes initially marked as non-escaping before flooding.\n+  const std::vector<Node*>&\n+  non_escaping_nodes() const\n+  { return this->noesc_; }\n+\n+  // Initialize the dummy return values for this Node N using the results\n+  // in FNTYPE.\n+  void\n+  init_retvals(Node* n, Function_type* fntype);\n+\n+  // Return the indirection of Node N.\n+  Node*\n+  add_dereference(Node* n);\n+\n+  // Keep track of possibly non-escaping node N.\n+  void\n+  track(Node* n);\n+\n+  int\n+  flood_id() const\n+  { return this->flood_id_; }\n+\n+  void\n+  increase_flood_id()\n+  { this->flood_id_++; }\n+\n+  int\n+  pdepth() const\n+  { return this->pdepth_; }\n+\n+  void\n+  increase_pdepth()\n+  { this->pdepth_++; }\n+\n+  void\n+  decrease_pdepth()\n+  { this->pdepth_--; }\n+\n  private:\n+  // The Go IR.\n+  Gogo* gogo_;\n   // The current function being analyzed.\n   Named_object* current_function_;\n   // Return whether this is the context for a recursive function or a group of mutually\n   // recursive functions.\n   bool recursive_;\n+  // The sink for this escape context.  Nodes whose reference objects created\n+  // outside the current function are assigned to the sink as well as nodes that\n+  // the analysis loses track of.\n+  Node* sink_;\n+  // Used to detect nested loop scopes.\n+  int loop_depth_;\n+  // All the destination nodes considered in this set of analyzed functions.\n+  std::set<Node*> dsts_;\n+  // All the nodes that were noted as possibly not escaping in this context.\n+  std::vector<Node*> noesc_;\n+  // An ID given to each dst and the flows discovered through DFS of that dst.\n+  // This is used to avoid infinite recursion from nodes that point to each\n+  // other within the flooding phase.\n+  int flood_id_;\n+  // The current level of recursion within a flooded section; used to debug.\n+  int pdepth_;\n };\n \n #endif // !defined(GO_ESCAPE_H)"}, {"sha": "a04999e7f36cf07e9ecb42ec51d6fa7a4958f595", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "patch": "@@ -51,6 +51,7 @@ class Bvariable;\n class Blabel;\n class Bfunction;\n class Escape_context;\n+class Node;\n \n // This file declares the basic classes used to hold the internal\n // representation of Go which is built by the parser.\n@@ -570,7 +571,7 @@ class Gogo\n   // Traverse the objects in the connecitivty graph from the sink, adjusting the\n   // escape levels of each object.\n   void\n-  propagate_escape(Escape_context*);\n+  propagate_escape(Escape_context*, Node*);\n \n   // Add notes about the escape level of a function's input and output\n   // parameters for exporting and importing top level functions. "}, {"sha": "682f61145d2d4a5d03d6064d8e7815192f17a495", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=2c418e1f8f7e2b2196a8a1e45edd2db0439c8b41", "patch": "@@ -8,6 +8,7 @@\n #define GO_TYPES_H\n \n #include \"go-linemap.h\"\n+#include \"escape.h\"\n \n class Gogo;\n class Package;\n@@ -1324,7 +1325,7 @@ class Typed_identifier\n  public:\n   Typed_identifier(const std::string& name, Type* type,\n \t\t   Location location)\n-    : name_(name), type_(type), location_(location)\n+    : name_(name), type_(type), location_(location), note_(NULL)\n   { }\n \n   // Get the name.\n@@ -1351,13 +1352,26 @@ class Typed_identifier\n     this->type_ = type;\n   }\n \n+  // Get the escape note.\n+  std::string*\n+  note() const\n+  { return this->note_; }\n+\n+  // Set the escape note.\n+  void\n+  set_note(const std::string& note)\n+  { this->note_ = new std::string(note); }\n+\n  private:\n   // Identifier name.\n   std::string name_;\n   // Type.\n   Type* type_;\n   // The location where the name was seen.\n   Location location_;\n+  // Escape note for this typed identifier.  Used when importing and exporting\n+  // functions.\n+  std::string* note_;\n };\n \n // A list of Typed_identifiers.\n@@ -1422,6 +1436,10 @@ class Typed_identifier_list\n   back() const\n   { return this->entries_.back(); }\n \n+  Typed_identifier&\n+  at(size_t i)\n+  { return this->entries_.at(i); }\n+\n   const Typed_identifier&\n   at(size_t i) const\n   { return this->entries_.at(i); }\n@@ -1778,14 +1796,19 @@ class Function_type : public Type\n     : Type(TYPE_FUNCTION),\n       receiver_(receiver), parameters_(parameters), results_(results),\n       location_(location), is_varargs_(false), is_builtin_(false),\n-      fnbtype_(NULL)\n+      fnbtype_(NULL), is_tagged_(false)\n   { }\n \n   // Get the receiver.\n   const Typed_identifier*\n   receiver() const\n   { return this->receiver_; }\n \n+  // Add an escape note for the receiver.\n+  void\n+  add_receiver_note(int encoding)\n+  { this->receiver_->set_note(Escape_note::make_tag(encoding)); }\n+\n   // Get the return names and types.\n   const Typed_identifier_list*\n   results() const\n@@ -1796,6 +1819,21 @@ class Function_type : public Type\n   parameters() const\n   { return this->parameters_; }\n \n+  // Add an escape note for the ith parameter.\n+  void\n+  add_parameter_note(int index, int encoding)\n+  { this->parameters_->at(index).set_note(Escape_note::make_tag(encoding)); }\n+\n+  // Whether this function has been tagged during escape analysis.\n+  bool\n+  is_tagged() const\n+  { return this->is_tagged_; }\n+\n+  // Mark this function as tagged after analyzing its escape.\n+  void\n+  set_is_tagged()\n+  { this->is_tagged_ = true; }\n+\n   // Whether this is a varargs function.\n   bool\n   is_varargs() const\n@@ -1950,6 +1988,9 @@ class Function_type : public Type\n   // The backend representation of this type for backend function\n   // declarations and definitions.\n   Btype* fnbtype_;\n+  // Whether this function has been analyzed by escape analysis.  If this is\n+  // TRUE, this function type's parameters contain a summary of the analysis.\n+  bool is_tagged_;\n };\n \n // The type of a function's backend representation."}]}