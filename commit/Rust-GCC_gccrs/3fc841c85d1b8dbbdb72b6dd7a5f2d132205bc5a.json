{"sha": "3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZjODQxYzg1ZDFiOGRiYmRiNzJiNmRkN2E1ZjJkMTMyMjA1YmM1YQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-10-23T15:05:20Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-10-23T15:05:20Z"}, "message": "Fix 41787\n\nFrom-SVN: r153498", "tree": {"sha": "592708a3b16d9ca7fc9ef94cc00b74b25c6833d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/592708a3b16d9ca7fc9ef94cc00b74b25c6833d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/comments", "author": null, "committer": null, "parents": [{"sha": "cb9c2485b2487ee5aa9a3e1b75385c508d28519f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9c2485b2487ee5aa9a3e1b75385c508d28519f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9c2485b2487ee5aa9a3e1b75385c508d28519f"}], "stats": {"total": 132, "additions": 123, "deletions": 9}, "files": [{"sha": "e7068a9a5438789dfabd8a7d43064cd665106c98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "patch": "@@ -1,3 +1,23 @@\n+2009-10-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/41787\n+\t* config/rs6000/rs6000.c (struct machine_function): Add\n+\tvsx_or_altivec_used_p to record if vector types are used.\n+\t(rs6000_expand_to_rtl_hook): Rename from\n+\trs6000_alloc_sdmode_stack_slot.  If VSX, check to see if there are\n+\tany vector operations, so if there are, we can set VRSAVE to\n+\tnon-zero when only floating point vector registers are used.\n+\t(TARGET_EXPAND_TO_RTL_HOOK): Use rs6000_expand_to_rtl_hook.\n+\t(rs6000_check_vector_mode): Inner function to check if vector\n+\ttypes are used in the code.\n+\t(compute_vrsave_mask): If VSX, make sure VRSAVE is non-zero if\n+\tvector instructions are used.\n+\n+\t* config/rs6000/rs6000.h (HARD_REGNO_CALL_PART_CLOBBERED):\n+\tIndicate that VSX registers which overlap floating point\n+\tregisters, can't be used across a call, since the ABI only states\n+\tthe scalar part of the register will be saved and restored.\n+\n 2009-10-23  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/41673"}, {"sha": "88649ea073534c3f683c0bfa89804be3187eaabb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "patch": "@@ -130,6 +130,8 @@ typedef struct GTY(()) machine_function\n      64-bits wide and is allocated early enough so that the offset\n      does not overflow the 16-bit load/store offset field.  */\n   rtx sdmode_stack_slot;\n+  /* True if any VSX or ALTIVEC vector type was used.  */\n+  bool vsx_or_altivec_used_p;\n } machine_function;\n \n /* Target cpu type */\n@@ -913,7 +915,7 @@ static void rs6000_elf_encode_section_info (tree, rtx, int)\n      ATTRIBUTE_UNUSED;\n #endif\n static bool rs6000_use_blocks_for_constant_p (enum machine_mode, const_rtx);\n-static void rs6000_alloc_sdmode_stack_slot (void);\n+static void rs6000_expand_to_rtl_hook (void);\n static void rs6000_instantiate_decls (void);\n #if TARGET_XCOFF\n static void rs6000_xcoff_asm_output_anchor (rtx);\n@@ -1505,7 +1507,7 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n \n #undef TARGET_EXPAND_TO_RTL_HOOK\n-#define TARGET_EXPAND_TO_RTL_HOOK rs6000_alloc_sdmode_stack_slot\n+#define TARGET_EXPAND_TO_RTL_HOOK rs6000_expand_to_rtl_hook\n \n #undef TARGET_INSTANTIATE_DECLS\n #define TARGET_INSTANTIATE_DECLS rs6000_instantiate_decls\n@@ -13190,6 +13192,38 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n+static tree\n+rs6000_check_vector_mode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  /* Don't walk into types.  */\n+  if (*tp == NULL_TREE || *tp == error_mark_node || TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  switch (TREE_CODE (*tp))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case RESULT_DECL:\n+    case SSA_NAME:\n+    case REAL_CST:\n+    case INDIRECT_REF:\n+    case ALIGN_INDIRECT_REF:\n+    case MISALIGNED_INDIRECT_REF:\n+    case VIEW_CONVERT_EXPR:\n+      if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (*tp))))\n+\treturn *tp;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n enum reload_reg_type {\n   GPR_REGISTER_TYPE,\n   VECTOR_REGISTER_TYPE,\n@@ -13630,18 +13664,42 @@ rs6000_ira_cover_classes (void)\n   return (TARGET_VSX) ? cover_vsx : cover_pre_vsx;\n }\n \n-/* Allocate a 64-bit stack slot to be used for copying SDmode\n-   values through if this function has any SDmode references.  */\n+/* Scan the trees looking for certain types.\n+\n+   Allocate a 64-bit stack slot to be used for copying SDmode values through if\n+   this function has any SDmode references.\n+\n+   If VSX, note whether any vector operation was done so we can set VRSAVE to\n+   non-zero, even if we just use the floating point registers to tell the\n+   kernel to save the vector registers.  */\n \n static void\n-rs6000_alloc_sdmode_stack_slot (void)\n+rs6000_expand_to_rtl_hook (void)\n {\n   tree t;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n \n   gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n \n+  /* Check for vectors.  */\n+  if (TARGET_VSX)\n+    {\n+      FOR_EACH_BB (bb)\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    if (walk_gimple_op (gsi_stmt (gsi), rs6000_check_vector_mode,\n+\t\t\t\tNULL))\n+\t      {\n+\t\tcfun->machine->vsx_or_altivec_used_p = true;\n+\t\tgoto found_vector;\n+\t      }\n+\t  }\n+    found_vector:\n+      ;\n+    }\n+\n+  /* Check for SDmode being used.  */\n   FOR_EACH_BB (bb)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n@@ -16783,6 +16841,15 @@ compute_vrsave_mask (void)\n     if (df_regs_ever_live_p (i))\n       mask |= ALTIVEC_REG_BIT (i);\n \n+  /* If VSX is used, we might have used a traditional floating point register\n+     in a vector mode without using any altivec registers.  However the VRSAVE\n+     register does not have room to indicate the floating point registers.\n+     Modern kernels only look to see if the value is non-zero to determine if\n+     they need to save the vector registers, so we just set an arbitrary\n+     value if any vector type was used.  */\n+  if (mask == 0 && TARGET_VSX && cfun->machine->vsx_or_altivec_used_p)\n+    mask = 0xFFF;\n+\n   if (mask == 0)\n     return mask;\n "}, {"sha": "4b1ca3d635a45e9e34362e5b104bf84559b35f8d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "patch": "@@ -1033,10 +1033,12 @@ extern unsigned rs6000_pointer_size;\n \n #define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs[(MODE)][(REGNO)]\n \n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\\\n-  ((TARGET_32BIT && TARGET_POWERPC64\t\t\t\\\n-    && (GET_MODE_SIZE (MODE) > 4)  \\\n-    && INT_REGNO_P (REGNO)) ? 1 : 0)\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n+  (((TARGET_32BIT && TARGET_POWERPC64\t\t\t\t\t\\\n+     && (GET_MODE_SIZE (MODE) > 4)\t\t\t\t\t\\\n+     && INT_REGNO_P (REGNO)) ? 1 : 0)\t\t\t\t\t\\\n+   || (TARGET_VSX && FP_REGNO_P (REGNO)\t\t\t\t\t\\\n+       && GET_MODE_SIZE (MODE) > 8))\n \n #define VSX_VECTOR_MODE(MODE)\t\t\\\n \t ((MODE) == V4SFmode\t\t\\"}, {"sha": "03d21650a0d9e8d25fba87dd5336cb12c9733640", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "patch": "@@ -1,3 +1,8 @@\n+2009-10-22  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/41787\n+\t* gcc.target/powerpc/vsx-vrsave.c: New file.\n+\n 2009-10-23  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/41673"}, {"sha": "83125f67fcc64fe0bd8b32e4aeb20e0062eaa780", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-vrsave.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c?ref=3fc841c85d1b8dbbdb72b6dd7a5f2d132205bc5a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler-times \"mtvrsave\" 2 } } */\n+\n+/* Check whether VRSAVE is set to non-zero if VSX vector operations were\n+   used, but it should not be set if there are no vector operations.  */\n+\n+void\n+generates_vrsave (vector double *a, vector double *b, vector double *c)\n+{\n+  *a = *b + *c;\n+}\n+\n+void\n+no_vrsave (double *a, double *b, double *c)\n+{\n+  *a = *b + *c;\n+}"}]}