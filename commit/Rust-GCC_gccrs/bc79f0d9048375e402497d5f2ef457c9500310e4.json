{"sha": "bc79f0d9048375e402497d5f2ef457c9500310e4", "node_id": "C_kwDOANBUbNoAKGJjNzlmMGQ5MDQ4Mzc1ZTQwMjQ5N2Q1ZjJlZjQ1N2M5NTAwMzEwZTQ", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2022-04-27T07:20:41Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2022-04-27T07:22:46Z"}, "message": "PR102024 - IBM Z: Add psabi diagnostics\n\nFor IBM Z in particular there is a problem with structs like:\n\nstruct A { float a; int :0; };\n\nOur ABI document allows passing a struct in an FPR only if it has\nexactly one member. On the other hand it says that structs of 1,2,4,8\nbytes are passed in a GPR. So this struct is expected to be passed in\na GPR. Since we don't return structs in registers (regardless of the\nnumber of members) it is always returned in memory.\n\nSituation is as follows:\n\nAll compiler versions tested return it in memory - as expected.\n\ngcc 11, gcc 12, g++ 12, and clang 13 pass it in a GPR - as expected.\n\ng++ 11 as well as clang++ 13 pass in an FPR\n\nFor IBM Z we stick to the current GCC 12 behavior, i.e. zero-width\nbitfields are NOT ignored.  A struct as above will be passed in a\nGPR. Rational behind this is that not affecting the C ABI is more\nimportant here.\n\nA patch for clang is in progress: https://reviews.llvm.org/D122388\n\nIn addition to the usual regression test I ran the compat and\nstruct-layout-1 testsuites comparing the compiler before and after the\npatch.\n\ngcc/ChangeLog:\n\tPR target/102024\n\t* config/s390/s390-protos.h (s390_function_arg_vector): Remove\n\tprototype.\n\t* config/s390/s390.cc (s390_single_field_struct_p): New function.\n\t(s390_function_arg_vector): Invoke s390_single_field_struct_p.\n\t(s390_function_arg_float): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR target/102024\n\t* g++.target/s390/pr102024-1.C: New test.\n\t* g++.target/s390/pr102024-2.C: New test.\n\t* g++.target/s390/pr102024-3.C: New test.\n\t* g++.target/s390/pr102024-4.C: New test.\n\t* g++.target/s390/pr102024-5.C: New test.\n\t* g++.target/s390/pr102024-6.C: New test.", "tree": {"sha": "cea01c4ed9ce8c0e2116e677cfc23ff993c4ec08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cea01c4ed9ce8c0e2116e677cfc23ff993c4ec08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc79f0d9048375e402497d5f2ef457c9500310e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc79f0d9048375e402497d5f2ef457c9500310e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc79f0d9048375e402497d5f2ef457c9500310e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc79f0d9048375e402497d5f2ef457c9500310e4/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9715f10c0651c9549b479b69d67be50ac4bd98a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9715f10c0651c9549b479b69d67be50ac4bd98a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9715f10c0651c9549b479b69d67be50ac4bd98a6"}], "stats": {"total": 291, "additions": 187, "deletions": 104}, "files": [{"sha": "fd4acaae44acd701b4265f6232af27cb1d31b0e6", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -49,7 +49,6 @@ extern void s390_function_profiler (FILE *, int);\n extern void s390_set_has_landing_pad_p (bool);\n extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int s390_class_max_nregs (enum reg_class, machine_mode);\n-extern bool s390_function_arg_vector (machine_mode, const_tree);\n extern bool s390_return_addr_from_memory(void);\n extern bool s390_fma_allowed_p (machine_mode);\n #if S390_USE_TARGET_ATTRIBUTE"}, {"sha": "7c3bd6cbe7f8c0f85b06d362e85e8e558c7d1977", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 105, "deletions": 103, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -12142,29 +12142,26 @@ s390_function_arg_size (machine_mode mode, const_tree type)\n   gcc_unreachable ();\n }\n \n-/* Return true if a function argument of type TYPE and mode MODE\n-   is to be passed in a vector register, if available.  */\n-\n-bool\n-s390_function_arg_vector (machine_mode mode, const_tree type)\n+/* Return true if a variable of TYPE should be passed as single value\n+   with type CODE. If STRICT_SIZE_CHECK_P is true the sizes of the\n+   record type and the field type must match.\n+\n+   The ABI says that record types with a single member are treated\n+   just like that member would be.  This function is a helper to\n+   detect such cases.  The function also produces the proper\n+   diagnostics for cases where the outcome might be different\n+   depending on the GCC version.  */\n+static bool\n+s390_single_field_struct_p (enum tree_code code, const_tree type,\n+\t\t\t    bool strict_size_check_p)\n {\n-  if (!TARGET_VX_ABI)\n-    return false;\n-\n-  if (s390_function_arg_size (mode, type) > 16)\n-    return false;\n-\n-  /* No type info available for some library calls ...  */\n-  if (!type)\n-    return VECTOR_MODE_P (mode);\n-\n-  /* The ABI says that record types with a single member are treated\n-     just like that member would be.  */\n   int empty_base_seen = 0;\n+  bool zero_width_bf_skipped_p = false;\n   const_tree orig_type = type;\n+\n   while (TREE_CODE (type) == RECORD_TYPE)\n     {\n-      tree field, single = NULL_TREE;\n+      tree field, single_type = NULL_TREE;\n \n       for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n \t{\n@@ -12181,48 +12178,108 @@ s390_function_arg_vector (machine_mode mode, const_tree type)\n \t      continue;\n \t    }\n \n-\t  if (single == NULL_TREE)\n-\t    single = TREE_TYPE (field);\n+\t  if (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field))\n+\t    {\n+\t      zero_width_bf_skipped_p = true;\n+\t      continue;\n+\t    }\n+\n+\t  if (single_type == NULL_TREE)\n+\t    single_type = TREE_TYPE (field);\n \t  else\n \t    return false;\n \t}\n \n-      if (single == NULL_TREE)\n+      if (single_type == NULL_TREE)\n \treturn false;\n-      else\n-\t{\n-\t  /* If the field declaration adds extra byte due to\n-\t     e.g. padding this is not accepted as vector type.  */\n-\t  if (int_size_in_bytes (single) <= 0\n-\t      || int_size_in_bytes (single) != int_size_in_bytes (type))\n-\t    return false;\n-\t  type = single;\n-\t}\n+\n+      /* Reaching this point we have a struct with a single member and\n+\t zero or more zero-sized bit-fields which have been skipped in the\n+\t past.  */\n+\n+      /* If ZERO_WIDTH_BF_SKIPPED_P then the struct will not be accepted.  In case\n+\t we are not supposed to emit a warning exit early.  */\n+      if (zero_width_bf_skipped_p && !warn_psabi)\n+\treturn false;\n+\n+      /* If the field declaration adds extra bytes due to padding this\n+\t is not accepted with STRICT_SIZE_CHECK_P.  */\n+      if (strict_size_check_p\n+\t  && (int_size_in_bytes (single_type) <= 0\n+\t      || int_size_in_bytes (single_type) != int_size_in_bytes (type)))\n+\treturn false;\n+\n+      type = single_type;\n     }\n \n-  if (!VECTOR_TYPE_P (type))\n+  if (TREE_CODE (type) != code)\n     return false;\n \n-  if (warn_psabi && empty_base_seen)\n+  if (warn_psabi)\n     {\n-      static unsigned last_reported_type_uid;\n       unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (orig_type));\n-      if (uid != last_reported_type_uid)\n-\t{\n-\t  const char *url = CHANGES_ROOT_URL \"gcc-10/changes.html#empty_base\";\n-\t  last_reported_type_uid = uid;\n-\t  if (empty_base_seen & 1)\n-\t    inform (input_location,\n-\t\t    \"parameter passing for argument of type %qT when C++17 \"\n-\t\t    \"is enabled changed to match C++14 %{in GCC 10.1%}\",\n-\t\t    orig_type, url);\n-\t  else\n-\t    inform (input_location,\n-\t\t    \"parameter passing for argument of type %qT with \"\n-\t\t    \"%<[[no_unique_address]]%> members changed \"\n-\t\t    \"%{in GCC 10.1%}\", orig_type, url);\n+\n+      if (empty_base_seen)\n+\t{\n+\t  static unsigned last_reported_type_uid_empty_base;\n+\t  if (uid != last_reported_type_uid_empty_base)\n+\t    {\n+\t      last_reported_type_uid_empty_base = uid;\n+\t      const char *url = CHANGES_ROOT_URL \"gcc-10/changes.html#empty_base\";\n+\t      if (empty_base_seen & 1)\n+\t\tinform (input_location,\n+\t\t\t\"parameter passing for argument of type %qT when C++17 \"\n+\t\t\t\"is enabled changed to match C++14 %{in GCC 10.1%}\",\n+\t\t\torig_type, url);\n+\t      else\n+\t\tinform (input_location,\n+\t\t\t\"parameter passing for argument of type %qT with \"\n+\t\t\t\"%<[[no_unique_address]]%> members changed \"\n+\t\t\t\"%{in GCC 10.1%}\", orig_type, url);\n+\t    }\n+\t}\n+\n+      /* For C++ older GCCs ignored zero width bitfields and therefore\n+\t passed structs more often as single values than GCC 12 does.\n+\t So diagnostics are only required in cases where we do NOT\n+\t accept the struct to be passed as single value.  */\n+      if (zero_width_bf_skipped_p)\n+\t{\n+\t  static unsigned last_reported_type_uid_zero_width;\n+\t  if (uid != last_reported_type_uid_zero_width)\n+\t    {\n+\t      last_reported_type_uid_zero_width = uid;\n+\t      inform (input_location,\n+\t\t      \"parameter passing for argument of type %qT with \"\n+\t\t      \"zero-width bit fields members changed in GCC 12\",\n+\t\t      orig_type);\n+\t    }\n \t}\n     }\n+\n+  return !zero_width_bf_skipped_p;\n+}\n+\n+\n+/* Return true if a function argument of type TYPE and mode MODE\n+   is to be passed in a vector register, if available.  */\n+\n+static bool\n+s390_function_arg_vector (machine_mode mode, const_tree type)\n+{\n+  if (!TARGET_VX_ABI)\n+    return false;\n+\n+  if (s390_function_arg_size (mode, type) > 16)\n+    return false;\n+\n+  /* No type info available for some library calls ...  */\n+  if (!type)\n+    return VECTOR_MODE_P (mode);\n+\n+  if (!s390_single_field_struct_p (VECTOR_TYPE, type, true))\n+    return false;\n+\n   return true;\n }\n \n@@ -12243,64 +12300,9 @@ s390_function_arg_float (machine_mode mode, const_tree type)\n   if (!type)\n     return mode == SFmode || mode == DFmode || mode == SDmode || mode == DDmode;\n \n-  /* The ABI says that record types with a single member are treated\n-     just like that member would be.  */\n-  int empty_base_seen = 0;\n-  const_tree orig_type = type;\n-  while (TREE_CODE (type) == RECORD_TYPE)\n-    {\n-      tree field, single = NULL_TREE;\n-\n-      for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-\t{\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\t  if (DECL_FIELD_ABI_IGNORED (field))\n-\t    {\n-\t      if (lookup_attribute (\"no_unique_address\",\n-\t\t\t\t    DECL_ATTRIBUTES (field)))\n-\t\tempty_base_seen |= 2;\n-\t      else\n-\t\tempty_base_seen |= 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (single == NULL_TREE)\n-\t    single = TREE_TYPE (field);\n-\t  else\n-\t    return false;\n-\t}\n-\n-      if (single == NULL_TREE)\n-\treturn false;\n-      else\n-\ttype = single;\n-    }\n-\n-  if (TREE_CODE (type) != REAL_TYPE)\n+  if (!s390_single_field_struct_p (REAL_TYPE, type, false))\n     return false;\n \n-  if (warn_psabi && empty_base_seen)\n-    {\n-      static unsigned last_reported_type_uid;\n-      unsigned uid = TYPE_UID (TYPE_MAIN_VARIANT (orig_type));\n-      if (uid != last_reported_type_uid)\n-\t{\n-\t  const char *url = CHANGES_ROOT_URL \"gcc-10/changes.html#empty_base\";\n-\t  last_reported_type_uid = uid;\n-\t  if (empty_base_seen & 1)\n-\t    inform (input_location,\n-\t\t    \"parameter passing for argument of type %qT when C++17 \"\n-\t\t    \"is enabled changed to match C++14 %{in GCC 10.1%}\",\n-\t\t    orig_type, url);\n-\t  else\n-\t    inform (input_location,\n-\t\t    \"parameter passing for argument of type %qT with \"\n-\t\t    \"%<[[no_unique_address]]%> members changed \"\n-\t\t    \"%{in GCC 10.1%}\", orig_type, url);\n-\t}\n-    }\n-\n   return true;\n }\n "}, {"sha": "a2cdd40df2afc7cbdf33d5ef55aae5fea44ecc56", "filename": "gcc/testsuite/g++.target/s390/pr102024-1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-1.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,12 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+struct S { float a; int : 0; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { 0.0f };\n+  foo (s);\t// { dg-message \"with zero-width bit fields members changed in GCC 12\" }\n+}"}, {"sha": "3ca7ce666d9949531c12608e28ef835858325a02", "filename": "gcc/testsuite/g++.target/s390/pr102024-2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-2.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,14 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+/* struct would never be passed in an FPR so no warning expected.  */\n+\n+struct S { float a; int :0; float b; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { 0.0f };\n+  foo (s);\t// { dg-bogus \"with zero-width bit fields members changed in GCC 12\" }\n+}"}, {"sha": "51514c3fcf5e9fc9f27cf55af6623ea0710e2f96", "filename": "gcc/testsuite/g++.target/s390/pr102024-3.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-3.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,15 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+/* struct S would not be passed as single value anyway so no warning expected.  */\n+\n+struct T { float a; float b; };\n+struct S { struct T t; int :0; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { { 0.0f, 0.0f } };\n+  foo (s);\t// { dg-bogus \"with zero-width bit fields members changed in GCC 12\" }\n+}"}, {"sha": "075d5713f496539c5856199b70d757cc3519db2a", "filename": "gcc/testsuite/g++.target/s390/pr102024-4.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-4.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,15 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+/* struct S would not be passed as single value anyway so no warning expected.  */\n+\n+struct T { float a; int :0; };\n+struct S { struct T t; int x; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { { 0.0f }, 0 };\n+  foo (s);\t// { dg-bogus \"with zero-width bit fields members changed in GCC 12\" }\n+}"}, {"sha": "a4355e71da2223386e7b769575adab0327be0d36", "filename": "gcc/testsuite/g++.target/s390/pr102024-5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-5.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,14 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+struct U { float a; int :0; };\n+struct T { struct U u; };\n+struct S { struct T t; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { { { 0.0f } } };\n+  foo (s);\t// { dg-message \"with zero-width bit fields members changed in GCC 12\" }\n+}"}, {"sha": "9dd506e59c878a19850afcebc2c70acd9675c4ec", "filename": "gcc/testsuite/g++.target/s390/pr102024-6.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc79f0d9048375e402497d5f2ef457c9500310e4/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fs390%2Fpr102024-6.C?ref=bc79f0d9048375e402497d5f2ef457c9500310e4", "patch": "@@ -0,0 +1,12 @@\n+// PR target/102024\n+// { dg-do compile }\n+\n+struct S { int :0; float a; };\n+void foo (struct S x);\n+\n+void\n+bar (void)\n+{\n+  struct S s = { 0.0f };\n+  foo (s);\t// { dg-message \"with zero-width bit fields members changed in GCC 12\" }\n+}"}]}