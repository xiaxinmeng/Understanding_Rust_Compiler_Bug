{"sha": "31825e5755c97486d8cfdf12887b2cf3c364604b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE4MjVlNTc1NWM5NzQ4NmQ4Y2ZkZjEyODg3YjJjZjNjMzY0NjA0Yg==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-05-21T07:55:22Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-05-21T07:55:22Z"}, "message": "cselib.c (max_value_regs): New.\n\n2002-05-20  David S. Miller  <davem@redhat.com>\n\n\t* cselib.c (max_value_regs): New.\n\t(cselib_lookup, cselib_invalidate_regno): Initialize it when\n\tadding new entries to the REG_VALUES table and we are dealing with\n\ta hard register.\n\t(clear_table): Initialize it.\n\t(cselib_invalidate_regno): Use it to determine which hard\n\tregisters to scan when mode is not VOIDmode.\n\nFrom-SVN: r53684", "tree": {"sha": "932d7037971627befb8ca826cb992f2101ea8745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/932d7037971627befb8ca826cb992f2101ea8745"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31825e5755c97486d8cfdf12887b2cf3c364604b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31825e5755c97486d8cfdf12887b2cf3c364604b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31825e5755c97486d8cfdf12887b2cf3c364604b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31825e5755c97486d8cfdf12887b2cf3c364604b/comments", "author": null, "committer": null, "parents": [{"sha": "74e5c1f4ecb1aa38aafae71631b0e120e50e592c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e5c1f4ecb1aa38aafae71631b0e120e50e592c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e5c1f4ecb1aa38aafae71631b0e120e50e592c"}], "stats": {"total": 49, "additions": 46, "deletions": 3}, "files": [{"sha": "f74e6d55c853681db75aa631374079a7c5fce952", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31825e5755c97486d8cfdf12887b2cf3c364604b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31825e5755c97486d8cfdf12887b2cf3c364604b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31825e5755c97486d8cfdf12887b2cf3c364604b", "patch": "@@ -1,3 +1,13 @@\n+2002-05-20  David S. Miller  <davem@redhat.com>\n+\n+\t* cselib.c (max_value_regs): New.\n+\t(cselib_lookup, cselib_invalidate_regno): Initialize it when\n+\tadding new entries to the REG_VALUES table and we are dealing with\n+\ta hard register.\n+\t(clear_table): Initialize it.\n+\t(cselib_invalidate_regno): Use it to determine which hard\n+\tregisters to scan when mode is not VOIDmode.\n+\n 2002-05-20  Duraid Madina   <duraid@fl.net.au>   \n \n \t* tradcpp.c (fixup_newlines): Use old-style function header."}, {"sha": "b0348fbc46209b4dc6f3b6d4f3b88313545d3bb5", "filename": "gcc/cselib.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31825e5755c97486d8cfdf12887b2cf3c364604b/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31825e5755c97486d8cfdf12887b2cf3c364604b/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=31825e5755c97486d8cfdf12887b2cf3c364604b", "patch": "@@ -104,6 +104,10 @@ static int n_useless_values;\n static varray_type reg_values;\n #define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n \n+/* The largest number of hard regs used by any entry added to the\n+   REG_VALUES table.  Cleared on each clear_table() invocation.   */\n+static unsigned int max_value_regs;\n+\n /* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n    in clear_table() for fast emptying.  */\n static varray_type used_regs;\n@@ -227,6 +231,8 @@ clear_table (clear_all)\n     for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n       REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n \n+  max_value_regs = 0;\n+\n   VARRAY_POP_ALL (used_regs);\n \n   htab_empty (hash_table);\n@@ -897,6 +903,14 @@ cselib_lookup (x, mode, create)\n       if (! create)\n \treturn 0;\n \n+      if (i < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  unsigned int n = HARD_REGNO_NREGS (i, mode);\n+\n+\t  if (n > max_value_regs)\n+\t    max_value_regs = n;\n+\t}\n+\n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n       e->locs = new_elt_loc_list (e->locs, x);\n       if (REG_VALUES (i) == 0)\n@@ -957,11 +971,22 @@ cselib_invalidate_regno (regno, mode)\n      pseudos, only REGNO is affected.  For hard regs, we must take MODE\n      into account, and we must also invalidate lower register numbers\n      if they contain values that overlap REGNO.  */\n-  endregno = regno + 1;\n   if (regno < FIRST_PSEUDO_REGISTER && mode != VOIDmode) \n-    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+    {\n+      if (regno < max_value_regs)\n+\ti = 0;\n+      else\n+\ti = regno - max_value_regs;\n \n-  for (i = 0; i < endregno; i++)\n+      endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+    }\n+  else\n+    {\n+      i = regno;\n+      endregno = regno + 1;\n+    }\n+\n+  for (; i < endregno; i++)\n     {\n       struct elt_list **l = &REG_VALUES (i);\n \n@@ -1171,6 +1196,14 @@ cselib_record_set (dest, src_elt, dest_addr_elt)\n       if (REG_VALUES (dreg) == 0)\n         VARRAY_PUSH_UINT (used_regs, dreg);\n \n+      if (dreg < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  unsigned int n = HARD_REGNO_NREGS (dreg, GET_MODE (dest));\n+\n+\t  if (n > max_value_regs)\n+\t    max_value_regs = n;\n+\t}\n+\n       REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n       if (src_elt->locs == 0)\n \tn_useless_values--;"}]}