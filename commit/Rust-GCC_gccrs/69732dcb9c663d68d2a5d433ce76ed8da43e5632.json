{"sha": "69732dcb9c663d68d2a5d433ce76ed8da43e5632", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3MzJkY2I5YzY2M2Q2OGQyYTVkNDMzY2U3NmVkOGRhNDNlNTYzMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-02-06T13:01:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-02-06T13:01:03Z"}, "message": "flow.c (flow_delete_insn, [...]): Export.\n\n        * flow.c (flow_delete_insn, make_edge, remove_edge): Export.\n        * basic-block.h: Declare them.\n        * emit-rtl.h (active_insn_p): New.\n        (next_active_insn, prev_active_insn): Use it.\n        * rtl.h: Declare it.\n        * function.c (emit_return_into_block): New.\n        (thread_prologue_and_epilogue_insns): Insert return insns instead\n        of epilogues when possible.\n        * jump.c (jump_optimize_1): Remove code to insert a return insn\n        on the fallthru to the exit block.\n\nFrom-SVN: r31826", "tree": {"sha": "14cb8de0063e0e21049d8e2193ad60c82320ff4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14cb8de0063e0e21049d8e2193ad60c82320ff4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69732dcb9c663d68d2a5d433ce76ed8da43e5632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69732dcb9c663d68d2a5d433ce76ed8da43e5632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69732dcb9c663d68d2a5d433ce76ed8da43e5632", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69732dcb9c663d68d2a5d433ce76ed8da43e5632/comments", "author": null, "committer": null, "parents": [{"sha": "52a75c3c22a68d2acdbdf6e2e5070b1f424bfc81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a75c3c22a68d2acdbdf6e2e5070b1f424bfc81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a75c3c22a68d2acdbdf6e2e5070b1f424bfc81"}], "stats": {"total": 201, "additions": 143, "deletions": 58}, "files": [{"sha": "ac0c6433a0ed1cc810f477d4e348e959b1ad6374", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -1,3 +1,16 @@\n+2000-02-06  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (flow_delete_insn, make_edge, remove_edge): Export.\n+\t* basic-block.h: Declare them.\n+\t* emit-rtl.h (active_insn_p): New.\n+\t(next_active_insn, prev_active_insn): Use it.\n+\t* rtl.h: Declare it.\n+\t* function.c (emit_return_into_block): New.\n+\t(thread_prologue_and_epilogue_insns): Insert return insns instead\n+\tof epilogues when possible.\n+\t* jump.c (jump_optimize_1): Remove code to insert a return insn\n+\ton the fallthru to the exit block.\n+\n 2000-02-06  Richard Henderson  <rth@cygnus.com>\n \n \t* simplify-rtx.c (simplify_relational_operation): Canonicalize"}, {"sha": "5f95c3103d020d10c6a9a670fad772d21d50f9a2", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -222,7 +222,11 @@ extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n extern void commit_edge_insertions\tPARAMS ((void));\n extern void remove_fake_edges\t\tPARAMS ((void));\n extern void add_noreturn_fake_exit_edges\tPARAMS ((void));\n+extern rtx flow_delete_insn\t\tPARAMS ((rtx));\n extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n+extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n+\t\t\t\t\t\t basic_block, int));\n+extern void remove_edge\t\t\tPARAMS ((edge));\n \n \n /* Structure to hold information for each natural loop.  */"}, {"sha": "26bfc44e777471a5e7507b68afa13dbc875f5e2a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -2084,19 +2084,25 @@ prev_real_insn (insn)\n    does not look inside SEQUENCEs.  Until reload has completed, this is the\n    same as next_real_insn.  */\n \n+int\n+active_insn_p (insn)\n+     rtx insn;\n+{\n+  return (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n+\t  || (GET_CODE (insn) == INSN\n+\t      && (! reload_completed\n+\t\t  || (GET_CODE (PATTERN (insn)) != USE\n+\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))));\n+}\n+\n rtx\n next_active_insn (insn)\n      rtx insn;\n {\n   while (insn)\n     {\n       insn = NEXT_INSN (insn);\n-      if (insn == 0\n-\t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n-\t  || (GET_CODE (insn) == INSN\n-\t      && (! reload_completed\n-\t\t  || (GET_CODE (PATTERN (insn)) != USE\n-\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))))\n+      if (insn == 0 || active_insn_p (insn))\n \tbreak;\n     }\n \n@@ -2114,12 +2120,7 @@ prev_active_insn (insn)\n   while (insn)\n     {\n       insn = PREV_INSN (insn);\n-      if (insn == 0\n-\t  || GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n-\t  || (GET_CODE (insn) == INSN\n-\t      && (! reload_completed\n-\t\t  || (GET_CODE (PATTERN (insn)) != USE\n-\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER))))\n+      if (insn == 0 || active_insn_p (insn))\n \tbreak;\n     }\n "}, {"sha": "1ce45f0d475d889d4240a1bfa87feb2bddbe3476", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -285,8 +285,6 @@ static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n static void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n static void clear_edges\t\t\tPARAMS ((void));\n static void make_edges\t\t\tPARAMS ((rtx));\n-static void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n-\t\t\t\t\t\t basic_block, int));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t rtx, int));\n static void make_eh_edge\t\tPARAMS ((sbitmap *, eh_nesting_info *,\n@@ -302,7 +300,6 @@ static void delete_eh_regions\t\tPARAMS ((void));\n static int can_delete_note_p\t\tPARAMS ((rtx));\n static int delete_block\t\t\tPARAMS ((basic_block));\n static void expunge_block\t\tPARAMS ((basic_block));\n-static rtx flow_delete_insn\t\tPARAMS ((rtx));\n static int can_delete_label_p\t\tPARAMS ((rtx));\n static int merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\t  basic_block));\n@@ -346,7 +343,6 @@ static void count_reg_sets_1\t\tPARAMS ((rtx));\n static void count_reg_sets\t\tPARAMS ((rtx));\n static void count_reg_references\tPARAMS ((rtx));\n static void invalidate_mems_from_autoinc PARAMS ((rtx));\n-static void remove_edge\t\t\tPARAMS ((edge));\n static void remove_fake_successors\tPARAMS ((basic_block));\n static void flow_nodes_print\tPARAMS ((const char *, const sbitmap, FILE *));\n static void flow_exits_print PARAMS ((const char *, const edge *, int, FILE *));\n@@ -1056,7 +1052,7 @@ make_edges (label_value_list)\n /* Create an edge between two basic blocks.  FLAGS are auxiliary information\n    about the edge that is accumulated between calls.  */\n \n-static void\n+void\n make_edge (edge_cache, src, dst, flags)\n      sbitmap *edge_cache;\n      basic_block src, dst;\n@@ -1982,7 +1978,7 @@ expunge_block (b)\n \n /* Delete INSN by patching it out.  Return the next insn.  */\n \n-static rtx\n+rtx\n flow_delete_insn (insn)\n      rtx insn;\n {\n@@ -6215,7 +6211,7 @@ find_edge_index (edge_list, pred, succ)\n }\n \n /* This function will remove an edge from the flow graph.  */\n-static void\n+void\n remove_edge (e)\n      edge e;\n {"}, {"sha": "9b2182eb16a6a3ea9aab6fd6b72c290361f0a0ed", "filename": "gcc/function.c", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -271,6 +271,7 @@ static int all_blocks\t\tPARAMS ((tree, tree *));\n    can always export `prologue_epilogue_contains'.  */\n static int *record_insns\tPARAMS ((rtx)) ATTRIBUTE_UNUSED;\n static int contains\t\tPARAMS ((rtx, int *));\n+static void emit_return_into_block PARAMS ((basic_block));\n static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n static boolean purge_addressof_1 PARAMS ((rtx *, rtx, int, int, \n \t\t\t\t\t  struct hash_table *));\n@@ -6577,6 +6578,27 @@ prologue_epilogue_contains (insn)\n   return 0;\n }\n \n+/* Insert gen_return at the end of block BB.  This also means updating\n+   block_for_insn appropriately.  */\n+\n+static void\n+emit_return_into_block (bb)\n+     basic_block bb;\n+{\n+  rtx p, end;\n+\n+  end = emit_jump_insn_after (gen_return (), bb->end);\n+  p = NEXT_INSN (bb->end); \n+  while (1)\n+    {\n+      set_block_for_insn (p, bb);\n+      if (p == end)\n+\tbreak;\n+      p = NEXT_INSN (p);\n+    }\n+  bb->end = end;\n+}\n+\n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n    this into place with notes indicating where the prologue ends and where\n    the epilogue begins.  Update the basic block information when possible.  */\n@@ -6629,6 +6651,93 @@ thread_prologue_and_epilogue_insns (f)\n   if (e == NULL)\n     goto epilogue_done;\n \n+#ifdef HAVE_return\n+  if (optimize && HAVE_return)\n+    {\n+      /* If we're allowed to generate a simple return instruction,\n+\t then by definition we don't need a full epilogue.  Examine\n+\t the block that falls through to EXIT.   If it does not \n+\t contain any code, examine its predecessors and try to \n+\t emit (conditional) return instructions.  */\n+\n+      basic_block last;\n+      edge e_next;\n+      rtx label;\n+\n+      for (e = EXIT_BLOCK_PTR->pred; e ; e = e->pred_next)\n+\tif (e->flags & EDGE_FALLTHRU)\n+\t  break;\n+      if (e == NULL)\n+\tgoto epilogue_done;\n+      last = e->src;\n+\n+      /* Verify that there are no active instructions in the last block.  */\n+      label = last->end;\n+      while (label && GET_CODE (label) != CODE_LABEL)\n+\t{\n+\t  if (active_insn_p (label))\n+\t    break;\n+\t  label = PREV_INSN (label);\n+\t}\n+\n+      if (last->head == label && GET_CODE (label) == CODE_LABEL)\n+\t{\n+\t  for (e = last->pred; e ; e = e_next)\n+\t    {\n+\t      basic_block bb = e->src;\n+\t      rtx jump;\n+\n+\t      e_next = e->pred_next;\n+\t      if (bb == ENTRY_BLOCK_PTR)\n+\t\tcontinue;\n+\n+\t      jump = bb->end;\n+\t      if (GET_CODE (jump) != JUMP_INSN)\n+\t\tcontinue;\n+\n+\t      /* If we have an unconditional jump, we can replace that\n+\t\t with a simple return instruction.  */\n+\t      if (simplejump_p (jump))\n+\t\t{\n+\t\t  emit_return_into_block (bb);\n+\t\t  flow_delete_insn (jump);\n+\t\t}\n+\n+\t      /* If we have a conditional jump, we can try to replace\n+\t\t that with a conditional return instruction.  */\n+\t      else if (condjump_p (jump))\n+\t\t{\n+\t\t  rtx ret, *loc;\n+\n+\t\t  ret = SET_SRC (PATTERN (jump));\n+\t\t  if (GET_CODE (XEXP (ret, 1)) == LABEL_REF)\n+\t\t    loc = &XEXP (ret, 1);\n+\t\t  else\n+\t\t    loc = &XEXP (ret, 2);\n+\t\t  ret = gen_rtx_RETURN (VOIDmode);\n+\n+\t\t  if (! validate_change (jump, loc, ret, 0))\n+\t\t    continue;\n+\t\t  if (JUMP_LABEL (jump))\n+\t\t    LABEL_NUSES (JUMP_LABEL (jump))--;\n+\t\t}\n+\t      else\n+\t\tcontinue;\n+\n+\t      /* Fix up the CFG for the successful change we just made.  */\n+\t      remove_edge (e);\n+\t      make_edge (NULL, bb, EXIT_BLOCK_PTR, 0);\n+\t    }\n+\t}\n+\n+      /* Emit a return insn for the exit fallthru block.  Whether\n+\t this is still reachable will be determined later.  */\n+\n+      emit_barrier_after (last->end);\n+      emit_return_into_block (last);\n+      goto epilogue_done;\n+    }\n+#endif\n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {"}, {"sha": "417425d5c82740a7bbedc92b3b0c38c31dc41b1b", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -232,25 +232,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \n   last_insn = delete_unreferenced_labels (f);\n \n-#ifdef HAVE_return\n-  if (optimize && HAVE_return)\n-    {\n-      /* If we fall through to the epilogue, see if we can insert a RETURN insn\n-\t in front of it.  If the machine allows it at this point (we might be\n-\t after reload for a leaf routine), it will improve optimization for it\n-\t to be there.  */\n-      insn = get_last_insn ();\n-      while (insn && GET_CODE (insn) == NOTE)\n-\tinsn = PREV_INSN (insn);\n-\n-      if (insn && GET_CODE (insn) != BARRIER)\n-\t{\n-\t  emit_jump_insn (gen_return ());\n-\t  emit_barrier ();\n-\t}\n-    }\n-#endif\n-\n   if (noop_moves)\n     delete_noop_moves (f);\n \n@@ -2142,26 +2123,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t}\n   }\n \n-#ifdef HAVE_return\n-  if (HAVE_return)\n-    {\n-      /* If we fall through to the epilogue, see if we can insert a RETURN insn\n-\t in front of it.  If the machine allows it at this point (we might be\n-\t after reload for a leaf routine), it will improve optimization for it\n-\t to be there.  We do this both here and at the start of this pass since\n-\t the RETURN might have been deleted by some of our optimizations.  */\n-      insn = get_last_insn ();\n-      while (insn && GET_CODE (insn) == NOTE)\n-\tinsn = PREV_INSN (insn);\n-\n-      if (insn && GET_CODE (insn) != BARRIER)\n-\t{\n-\t  emit_jump_insn (gen_return ());\n-\t  emit_barrier ();\n-\t}\n-    }\n-#endif\n-\n   /* CAN_REACH_END is persistent for each function.  Once set it should\n      not be cleared.  This is especially true for the case where we\n      delete the NOTE_FUNCTION_END note.  CAN_REACH_END is cleared by"}, {"sha": "15185125a316316b591a7f203ed582bd76f970e8", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69732dcb9c663d68d2a5d433ce76ed8da43e5632/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=69732dcb9c663d68d2a5d433ce76ed8da43e5632", "patch": "@@ -1051,6 +1051,7 @@ extern rtx prev_real_insn\t\tPARAMS ((rtx));\n extern rtx next_real_insn\t\tPARAMS ((rtx));\n extern rtx prev_active_insn\t\tPARAMS ((rtx));\n extern rtx next_active_insn\t\tPARAMS ((rtx));\n+extern int active_insn_p\t\tPARAMS ((rtx));\n extern rtx prev_label\t\t\tPARAMS ((rtx));\n extern rtx next_label\t\t\tPARAMS ((rtx));\n extern rtx next_cc0_user\t\tPARAMS ((rtx));"}]}