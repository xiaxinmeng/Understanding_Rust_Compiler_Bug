{"sha": "1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU4NTUyZWJiMmEyN2QxMWZmMGU1YzM0YzhkZDIxODU4OWEzOTM4Zg==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-06-07T19:51:25Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2005-06-07T19:51:25Z"}, "message": "Fixes PR 18403 and meta PR 21861.\n\n\t* Makefile.in (tree-chrec.o): Depend on CFGLOOP_H and TREE_FLOW_H.\n\t* tree-chrec.c: Include cfgloop.h and tree-flow.h.\n\t(evolution_function_is_invariant_rec_p,\n\tevolution_function_is_invariant_p): New.\n\t(chrec_convert): Use an extra parameter AT_STMT for refining the\n\tinformation that is passed down to convert_step.  Integrate the\n\tcode that was in count_ev_in_wider_type.\n\t* tree-chrec.h (count_ev_in_wider_type): Removed.\n\t(chrec_convert): Modify its declaration.\n\t(evolution_function_is_invariant_p): Declared.\n\t(evolution_function_is_affine_p): Use evolution_function_is_invariant_p.\n\t* tree-flow.h (can_count_iv_in_wider_type): Renamed convert_step.\n\t(scev_probably_wraps_p): Declared.\n\t* tree-scalar-evolution.c (count_ev_in_wider_type): Removed.\n\t(follow_ssa_edge_in_rhs, interpret_rhs_modify_expr):\n\tUse an extra parameter AT_STMT for refining the information that is\n\tpassed down to convert_step.\n\t(follow_ssa_edge_inner_loop_phi, follow_ssa_edge,\n\tanalyze_scalar_evolution_1): Initialize AT_STMT with the current\n\tanalyzed statement.\n\t(instantiate_parameters_1): Don't know yet how to initialize AT_STMT.\n\t* tree-ssa-loop-ivopts.c (idx_find_step): Update the use of\n\tcan_count_iv_in_wider_type to use convert_step.\n\t* tree-ssa-loop-niter.c (can_count_iv_in_wider_type_bound): Move\n\tcode that is independent of the loop over the known iteration\n\tbounds to convert_step_widening, the rest is moved to\n\tproved_non_wrapping_p.\n\t(scev_probably_wraps_p): New.\n\t(can_count_iv_in_wider_type): Renamed convert_step.\n\t* tree-vrp.c (adjust_range_with_scev): Take an extra AT_STMT parameter.\n\tUse scev_probably_wraps_p for computing init_is_max.\n\t(vrp_visit_assignment): Pass the current analyzed statement to\n\tadjust_range_with_scev.\n\t(execute_vrp): Call estimate_numbers_of_iterations for refining the\n\tinformation provided by scev analyzer.\n\ntestsuite:\n\n\t* testsuite/gcc.dg/vect/vect-77.c: Remove xfail from lp64.\n\t* testsuite/gcc.dg/vect/vect-78.c: Same.\n\nFrom-SVN: r100718", "tree": {"sha": "4aae0809ad1fc08b9c4dad889abab72475236b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4aae0809ad1fc08b9c4dad889abab72475236b7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89a590b340284a9d5219126e0df2c6f94a297137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a590b340284a9d5219126e0df2c6f94a297137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89a590b340284a9d5219126e0df2c6f94a297137"}], "stats": {"total": 594, "additions": 387, "deletions": 207}, "files": [{"sha": "e200023d66b03771e775e2c12a0b7bc73dda36b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -1,3 +1,42 @@\n+2005-06-07  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\tPR 18403 and meta PR 21861.\n+\t* Makefile.in (tree-chrec.o): Depend on CFGLOOP_H and TREE_FLOW_H.\n+\t* tree-chrec.c: Include cfgloop.h and tree-flow.h.\n+\t(evolution_function_is_invariant_rec_p,\n+\tevolution_function_is_invariant_p): New.\n+\t(chrec_convert): Use an extra parameter AT_STMT for refining the\n+\tinformation that is passed down to convert_step.  Integrate the \n+\tcode that was in count_ev_in_wider_type.\n+\t* tree-chrec.h (count_ev_in_wider_type): Removed.\n+\t(chrec_convert): Modify its declaration.\n+\t(evolution_function_is_invariant_p): Declared.\n+\t(evolution_function_is_affine_p): Use evolution_function_is_invariant_p.\n+\t* tree-flow.h (can_count_iv_in_wider_type): Renamed convert_step.\n+\t(scev_probably_wraps_p): Declared.\n+\t* tree-scalar-evolution.c (count_ev_in_wider_type): Removed.\n+\t(follow_ssa_edge_in_rhs, interpret_rhs_modify_expr):\n+\tUse an extra parameter AT_STMT for refining the information that is\n+\tpassed down to convert_step.\n+\t(follow_ssa_edge_inner_loop_phi, follow_ssa_edge,\n+\tanalyze_scalar_evolution_1): Initialize AT_STMT with the current\n+\tanalyzed statement.\n+\t(instantiate_parameters_1): Don't know yet how to initialize AT_STMT.\n+\t* tree-ssa-loop-ivopts.c (idx_find_step): Update the use of \n+\tcan_count_iv_in_wider_type to use convert_step.\n+\t* tree-ssa-loop-niter.c (can_count_iv_in_wider_type_bound): Move \n+\tcode that is independent of the loop over the known iteration\n+\tbounds to convert_step_widening, the rest is moved to\n+\tproved_non_wrapping_p.\n+\t(scev_probably_wraps_p): New.\n+\t(can_count_iv_in_wider_type): Renamed convert_step.\n+\t* tree-vrp.c (adjust_range_with_scev): Take an extra AT_STMT parameter.\n+\tUse scev_probably_wraps_p for computing init_is_max.\n+\t(vrp_visit_assignment): Pass the current analyzed statement to \n+\tadjust_range_with_scev.\n+\t(execute_vrp): Call estimate_numbers_of_iterations for refining the \n+\tinformation provided by scev analyzer.\n+\n 2005-06-07  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/predicates.md (sleu_operand): Use"}, {"sha": "9e8bbe0930703338cd0f5286a9100489e0b1365e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -1873,7 +1873,7 @@ tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TM_H) coretypes.h\n tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) tree-chrec.h tree-pass.h $(PARAMS_H) \\\n-   $(DIAGNOSTIC_H) $(VARRAY_H)\n+   $(DIAGNOSTIC_H) $(VARRAY_H) $(CFGLOOP_H) $(TREE_FLOW_H)\n tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \\"}, {"sha": "8557b298bf881ccaef089663a119bc80727f2638", "filename": "gcc/testsuite/gcc.dg/vect/vect-77.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-77.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -39,7 +39,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { lp64 || vect_no_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { lp64 || vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a059f308b9c854b646b247c80874dd9e4d75b101", "filename": "gcc/testsuite/gcc.dg/vect/vect-78.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-78.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -40,7 +40,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { lp64 || vect_no_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { lp64 || vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ee171506140e6117bb0275038391b301132fefe6", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 99, "deletions": 40, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -32,6 +32,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree.h\"\n #include \"diagnostic.h\"\n #include \"varray.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-flow.h\"\n #include \"tree-chrec.h\"\n #include \"tree-pass.h\"\n #include \"params.h\"\n@@ -909,6 +911,57 @@ tree_contains_chrecs (tree expr, int *size)\n     }\n }\n \n+/* Recursive helper function.  */\n+\n+static bool\n+evolution_function_is_invariant_rec_p (tree chrec, int loopnum)\n+{\n+  if (evolution_function_is_constant_p (chrec))\n+    return true;\n+\n+  if (TREE_CODE (chrec) == SSA_NAME \n+      && expr_invariant_in_loop_p (current_loops->parray[loopnum],\n+\t\t\t\t   chrec))\n+    return true;\n+\n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n+      && CHREC_VARIABLE (chrec) == (unsigned) loopnum)\n+    return false;\n+\n+  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+    {\n+    case 2:\n+      if (!evolution_function_is_invariant_rec_p (TREE_OPERAND (chrec, 1),\n+\t\t\t\t\t\t  loopnum))\n+\treturn false;\n+      \n+    case 1:\n+      if (!evolution_function_is_invariant_rec_p (TREE_OPERAND (chrec, 0),\n+\t\t\t\t\t\t  loopnum))\n+\treturn false;\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if CHREC is invariant in loop LOOPNUM, false otherwise. */\n+\n+bool\n+evolution_function_is_invariant_p (tree chrec, int loopnum)\n+{\n+  if (evolution_function_is_constant_p (chrec))\n+    return true;\n+  \n+  if (current_loops != NULL)\n+    return evolution_function_is_invariant_rec_p (chrec, loopnum);\n+\n+  return false;\n+}\n+\n /* Determine whether the given tree is an affine multivariate\n    evolution.  */\n \n@@ -1019,11 +1072,17 @@ nb_vars_in_chrec (tree chrec)\n \n \f\n \n-/* Convert CHREC to TYPE.  The following is rule is always true:\n-   TREE_TYPE (chrec) == TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE\n-   (CHREC_RIGHT (chrec)).  An example of what could happen when adding\n-   two chrecs and the type of the CHREC_RIGHT is different than\n-   CHREC_LEFT is:\n+/* Convert CHREC to TYPE.  When the analyzer knows the context in\n+   which the CHREC is built, it sets AT_STMT to the statement that\n+   contains the definition of the analyzed variable, otherwise the\n+   conversion is less accurate: the information is used for\n+   determining a more accurate estimation of the number of iterations.\n+   By default AT_STMT could be safely set to NULL_TREE.\n+\n+   The following rule is always true: TREE_TYPE (chrec) ==\n+   TREE_TYPE (CHREC_LEFT (chrec)) == TREE_TYPE (CHREC_RIGHT (chrec)).\n+   An example of what could happen when adding two chrecs and the type\n+   of the CHREC_RIGHT is different than CHREC_LEFT is:\n    \n    {(uint) 0, +, (uchar) 10} +\n    {(uint) 0, +, (uchar) 250}\n@@ -1038,55 +1097,55 @@ nb_vars_in_chrec (tree chrec)\n */\n \n tree \n-chrec_convert (tree type, \n-\t       tree chrec)\n+chrec_convert (tree type, tree chrec, tree at_stmt)\n {\n-  tree ct;\n-  \n+  tree ct, res;\n+\n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n   \n   ct = chrec_type (chrec);\n   if (ct == type)\n     return chrec;\n \n-  if (TYPE_PRECISION (ct) < TYPE_PRECISION (type))\n-    return count_ev_in_wider_type (type, chrec);\n-\n-  switch (TREE_CODE (chrec))\n+  if (evolution_function_is_affine_p (chrec))\n     {\n-    case POLYNOMIAL_CHREC:\n+      tree step = convert_step (current_loops->parray[CHREC_VARIABLE (chrec)],\n+ \t\t\t\ttype, CHREC_LEFT (chrec), CHREC_RIGHT (chrec),\n+ \t\t\t\tat_stmt);\n+      if (!step)\n+ \treturn fold_convert (type, chrec);\n+\n       return build_polynomial_chrec (CHREC_VARIABLE (chrec),\n-\t\t\t\t     chrec_convert (type,\n-\t\t\t\t\t\t    CHREC_LEFT (chrec)),\n-\t\t\t\t     chrec_convert (type,\n-\t\t\t\t\t\t    CHREC_RIGHT (chrec)));\n+ \t\t\t\t     chrec_convert (type, CHREC_LEFT (chrec),\n+ \t\t\t\t\t\t    at_stmt),\n+ \t\t\t\t     step);\n+    }\n \n-    default:\n-      {\n-\ttree res = fold_convert (type, chrec);\n+  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n+    return chrec_dont_know;\n \n-\t/* Don't propagate overflows.  */\n-\tif (CONSTANT_CLASS_P (res))\n-\t  {\n-\t    TREE_CONSTANT_OVERFLOW (res) = 0;\n-\t    TREE_OVERFLOW (res) = 0;\n-\t  }\n+  res = fold_convert (type, chrec);\n \n-\t/* But reject constants that don't fit in their type after conversion.\n-\t   This can happen if TYPE_MIN_VALUE or TYPE_MAX_VALUE are not the\n-\t   natural values associated with TYPE_PRECISION and TYPE_UNSIGNED,\n-\t   and can cause problems later when computing niters of loops.  Note\n-\t   that we don't do the check before converting because we don't want\n-\t   to reject conversions of negative chrecs to unsigned types.  */\n-\tif (TREE_CODE (res) == INTEGER_CST\n-\t    && TREE_CODE (type) == INTEGER_TYPE\n-\t    && !int_fits_type_p (res, type))\n-\t  res = chrec_dont_know;\n-\n-\treturn res;\n-      }\n+  /* Don't propagate overflows.  */\n+  if (CONSTANT_CLASS_P (res))\n+    {\n+      TREE_CONSTANT_OVERFLOW (res) = 0;\n+      TREE_OVERFLOW (res) = 0;\n     }\n+\n+  /* But reject constants that don't fit in their type after conversion.\n+     This can happen if TYPE_MIN_VALUE or TYPE_MAX_VALUE are not the\n+     natural values associated with TYPE_PRECISION and TYPE_UNSIGNED,\n+     and can cause problems later when computing niters of loops.  Note\n+     that we don't do the check before converting because we don't want\n+     to reject conversions of negative chrecs to unsigned types.  */\n+  if (TREE_CODE (res) == INTEGER_CST\n+      && TREE_CODE (type) == INTEGER_TYPE\n+      && !int_fits_type_p (res, type))\n+    res = chrec_dont_know;\n+\n+  return res;\n }\n \n /* Returns the type of the chrec.  */"}, {"sha": "723c8918e285d9eab51aa9f6736cacc9801de0f9", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -67,8 +67,7 @@ tree_is_chrec (tree expr)\n extern tree chrec_fold_plus (tree, tree, tree);\n extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n-extern tree chrec_convert (tree, tree);\n-extern tree count_ev_in_wider_type (tree, tree);\n+extern tree chrec_convert (tree, tree, tree);\n extern tree chrec_type (tree);\n \n /* Operations.  */\n@@ -146,6 +145,7 @@ evolution_function_is_constant_p (tree chrec)\n     }\n }\n \n+extern bool evolution_function_is_invariant_p (tree, int);\n /* Determine whether the given tree is an affine evolution function or not.  */\n \n static inline bool \n@@ -157,8 +157,10 @@ evolution_function_is_affine_p (tree chrec)\n   switch (TREE_CODE (chrec))\n     {\n     case POLYNOMIAL_CHREC:\n-      if (evolution_function_is_constant_p (CHREC_LEFT (chrec))\n-\t  && evolution_function_is_constant_p (CHREC_RIGHT (chrec)))\n+      if (evolution_function_is_invariant_p (CHREC_LEFT (chrec), \n+\t\t\t\t\t     CHREC_VARIABLE (chrec))\n+\t  && evolution_function_is_invariant_p (CHREC_RIGHT (chrec),\n+\t\t\t\t\t\tCHREC_VARIABLE (chrec)))\n \treturn true;\n       else\n \treturn false;"}, {"sha": "d3180196e1c9a3b086f5a50f5747f434de090f5b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -658,7 +658,8 @@ tree find_loop_niter (struct loop *, edge *);\n tree loop_niter_by_eval (struct loop *, edge);\n tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);\n-tree can_count_iv_in_wider_type (struct loop *, tree, tree, tree, tree);\n+bool scev_probably_wraps_p (tree, tree, tree, tree, struct loop *, bool *);\n+tree convert_step (struct loop *, tree, tree, tree, tree);\n void free_numbers_of_iterations_estimates (struct loops *);\n void rewrite_into_loop_closed_ssa (bitmap, unsigned);\n void verify_loop_closed_ssa (void);"}, {"sha": "49806b2e45dc5566ce4a7b2856ab9a03f9698ce9", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 36, "deletions": 55, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -349,33 +349,6 @@ find_var_scev_info (tree var)\n   return &res->chrec;\n }\n \n-/* Tries to express CHREC in wider type TYPE.  */\n-\n-tree\n-count_ev_in_wider_type (tree type, tree chrec)\n-{\n-  tree base, step;\n-  struct loop *loop;\n-\n-  if (!evolution_function_is_affine_p (chrec))\n-    return fold_convert (type, chrec);\n-\n-  base = CHREC_LEFT (chrec);\n-  step = CHREC_RIGHT (chrec);\n-  loop = current_loops->parray[CHREC_VARIABLE (chrec)];\n-\n-  /* TODO -- if we knew the statement at that the conversion occurs,\n-     we could pass it to can_count_iv_in_wider_type and get a better\n-     result.  */\n-  step = can_count_iv_in_wider_type (loop, type, base, step, NULL_TREE);\n-  if (!step)\n-    return fold_convert (type, chrec);\n-  base = chrec_convert (type, base);\n-\n-  return build_polynomial_chrec (CHREC_VARIABLE (chrec),\n-\t\t\t\t base, step);\n-}\n-\n /* Return true when CHREC contains symbolic names defined in\n    LOOP_NB.  */\n \n@@ -1052,6 +1025,7 @@ static bool follow_ssa_edge (struct loop *loop, tree, tree, tree *);\n \n static bool\n follow_ssa_edge_in_rhs (struct loop *loop,\n+\t\t\ttree at_stmt,\n \t\t\ttree rhs, \n \t\t\ttree halting_phi, \n \t\t\ttree *evolution_of_loop)\n@@ -1071,9 +1045,10 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n     {\n     case NOP_EXPR:\n       /* This assignment is under the form \"a_1 = (cast) rhs.  */\n-      res = follow_ssa_edge_in_rhs (loop, TREE_OPERAND (rhs, 0), halting_phi, \n-\t\t\t\t    evolution_of_loop);\n-      *evolution_of_loop = chrec_convert (TREE_TYPE (rhs), *evolution_of_loop);\n+      res = follow_ssa_edge_in_rhs (loop, at_stmt, TREE_OPERAND (rhs, 0),\n+\t\t\t\t    halting_phi, evolution_of_loop);\n+      *evolution_of_loop = chrec_convert (TREE_TYPE (rhs),\n+\t\t\t\t\t  *evolution_of_loop, at_stmt);\n       break;\n \n     case INTEGER_CST:\n@@ -1107,7 +1082,7 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t      if (res)\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, \n-\t\t   chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t   chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n \t\t   PLUS_EXPR, rhs1);\n \t      \n \t      else\n@@ -1119,7 +1094,7 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t  if (res)\n \t\t    *evolution_of_loop = add_to_evolution \n \t\t      (loop->num, \n-\t\t       chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t       chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n \t\t       PLUS_EXPR, rhs0);\n \t\t}\n \t    }\n@@ -1133,7 +1108,8 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t evolution_of_loop);\n \t      if (res)\n \t\t*evolution_of_loop = add_to_evolution \n-\t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n+\t\t\t\t\t     at_stmt),\n \t\t   PLUS_EXPR, rhs1);\n \t    }\n \t}\n@@ -1147,7 +1123,8 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t     evolution_of_loop);\n \t  if (res)\n \t    *evolution_of_loop = add_to_evolution \n-\t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n+\t\t\t\t\t at_stmt),\n \t       PLUS_EXPR, rhs0);\n \t}\n \n@@ -1174,7 +1151,8 @@ follow_ssa_edge_in_rhs (struct loop *loop,\n \t\t\t\t evolution_of_loop);\n \t  if (res)\n \t    *evolution_of_loop = add_to_evolution \n-\t\t    (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t    (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n+\t\t\t\t\t       at_stmt),\n \t\t     MINUS_EXPR, rhs1);\n \t}\n       else\n@@ -1391,7 +1369,8 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n \t  /* Follow the edges that exit the inner loop.  */\n \t  bb = PHI_ARG_EDGE (loop_phi_node, i)->src;\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n-\t    res = res || follow_ssa_edge_in_rhs (outer_loop, arg, halting_phi,\n+\t    res = res || follow_ssa_edge_in_rhs (outer_loop, loop_phi_node,\n+\t\t\t\t\t\t arg, halting_phi,\n \t\t\t\t\t\t evolution_of_loop);\n \t}\n \n@@ -1404,7 +1383,7 @@ follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n \n   /* Otherwise, compute the overall effect of the inner loop.  */\n   ev = compute_overall_effect_of_inner_loop (loop, ev);\n-  return follow_ssa_edge_in_rhs (outer_loop, ev, halting_phi,\n+  return follow_ssa_edge_in_rhs (outer_loop, loop_phi_node, ev, halting_phi,\n \t\t\t\t evolution_of_loop);\n }\n \n@@ -1456,7 +1435,7 @@ follow_ssa_edge (struct loop *loop,\n       return false;\n \n     case MODIFY_EXPR:\n-      return follow_ssa_edge_in_rhs (loop,\n+      return follow_ssa_edge_in_rhs (loop, def,\n \t\t\t\t     TREE_OPERAND (def, 1), \n \t\t\t\t     halting_phi, \n \t\t\t\t     evolution_of_loop);\n@@ -1665,23 +1644,23 @@ interpret_condition_phi (struct loop *loop, tree condition_phi)\n    analyze the effect of an inner loop: see interpret_loop_phi.  */\n \n static tree\n-interpret_rhs_modify_expr (struct loop *loop,\n+interpret_rhs_modify_expr (struct loop *loop, tree at_stmt,\n \t\t\t   tree opnd1, tree type)\n {\n   tree res, opnd10, opnd11, chrec10, chrec11;\n-  \n+\n   if (is_gimple_min_invariant (opnd1))\n-    return chrec_convert (type, opnd1);\n-  \n+    return chrec_convert (type, opnd1, at_stmt);\n+\n   switch (TREE_CODE (opnd1))\n     {\n     case PLUS_EXPR:\n       opnd10 = TREE_OPERAND (opnd1, 0);\n       opnd11 = TREE_OPERAND (opnd1, 1);\n       chrec10 = analyze_scalar_evolution (loop, opnd10);\n       chrec11 = analyze_scalar_evolution (loop, opnd11);\n-      chrec10 = chrec_convert (type, chrec10);\n-      chrec11 = chrec_convert (type, chrec11);\n+      chrec10 = chrec_convert (type, chrec10, at_stmt);\n+      chrec11 = chrec_convert (type, chrec11, at_stmt);\n       res = chrec_fold_plus (type, chrec10, chrec11);\n       break;\n       \n@@ -1690,15 +1669,15 @@ interpret_rhs_modify_expr (struct loop *loop,\n       opnd11 = TREE_OPERAND (opnd1, 1);\n       chrec10 = analyze_scalar_evolution (loop, opnd10);\n       chrec11 = analyze_scalar_evolution (loop, opnd11);\n-      chrec10 = chrec_convert (type, chrec10);\n-      chrec11 = chrec_convert (type, chrec11);\n+      chrec10 = chrec_convert (type, chrec10, at_stmt);\n+      chrec11 = chrec_convert (type, chrec11, at_stmt);\n       res = chrec_fold_minus (type, chrec10, chrec11);\n       break;\n \n     case NEGATE_EXPR:\n       opnd10 = TREE_OPERAND (opnd1, 0);\n       chrec10 = analyze_scalar_evolution (loop, opnd10);\n-      chrec10 = chrec_convert (type, chrec10);\n+      chrec10 = chrec_convert (type, chrec10, at_stmt);\n       res = chrec_fold_minus (type, build_int_cst (type, 0), chrec10);\n       break;\n \n@@ -1707,25 +1686,27 @@ interpret_rhs_modify_expr (struct loop *loop,\n       opnd11 = TREE_OPERAND (opnd1, 1);\n       chrec10 = analyze_scalar_evolution (loop, opnd10);\n       chrec11 = analyze_scalar_evolution (loop, opnd11);\n-      chrec10 = chrec_convert (type, chrec10);\n-      chrec11 = chrec_convert (type, chrec11);\n+      chrec10 = chrec_convert (type, chrec10, at_stmt);\n+      chrec11 = chrec_convert (type, chrec11, at_stmt);\n       res = chrec_fold_multiply (type, chrec10, chrec11);\n       break;\n       \n     case SSA_NAME:\n-      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd1));\n+      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd1),\n+\t\t\t   at_stmt);\n       break;\n \n     case ASSERT_EXPR:\n       opnd10 = ASSERT_EXPR_VAR (opnd1);\n-      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd10));\n+      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd10),\n+\t\t\t   at_stmt);\n       break;\n       \n     case NOP_EXPR:\n     case CONVERT_EXPR:\n       opnd10 = TREE_OPERAND (opnd1, 0);\n       chrec10 = analyze_scalar_evolution (loop, opnd10);\n-      res = chrec_convert (type, chrec10);\n+      res = chrec_convert (type, chrec10, at_stmt);\n       break;\n       \n     default:\n@@ -1775,7 +1756,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n     return chrec_dont_know;\n \n   if (TREE_CODE (var) != SSA_NAME)\n-    return interpret_rhs_modify_expr (loop, var, type);\n+    return interpret_rhs_modify_expr (loop, NULL_TREE, var, type);\n \n   def = SSA_NAME_DEF_STMT (var);\n   bb = bb_for_stmt (def);\n@@ -1809,7 +1790,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n   switch (TREE_CODE (def))\n     {\n     case MODIFY_EXPR:\n-      res = interpret_rhs_modify_expr (loop, TREE_OPERAND (def, 1), type);\n+      res = interpret_rhs_modify_expr (loop, def, TREE_OPERAND (def, 1), type);\n       break;\n \n     case PHI_NODE:\n@@ -2093,7 +2074,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec,\n       if (op0 == TREE_OPERAND (chrec, 0))\n \treturn chrec;\n \n-      return chrec_convert (TREE_TYPE (chrec), op0);\n+      return chrec_convert (TREE_TYPE (chrec), op0, NULL_TREE);\n \n     case SCEV_NOT_KNOWN:\n       return chrec_dont_know;"}, {"sha": "ed1072243ae7c5a682fff1b7c6018532465c9704", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -1442,11 +1442,8 @@ idx_find_step (tree base, tree *idx, void *data)\n     /* The step for pointer arithmetics already is 1 byte.  */\n     step = build_int_cst (sizetype, 1);\n \n-  if (TYPE_PRECISION (TREE_TYPE (iv->base)) < TYPE_PRECISION (sizetype))\n-    iv_step = can_count_iv_in_wider_type (dta->ivopts_data->current_loop,\n-\t\t\t\t\t  sizetype, iv->base, iv->step, dta->stmt);\n-  else\n-    iv_step = fold_convert (sizetype, iv->step);\n+  iv_step = convert_step (dta->ivopts_data->current_loop,\n+\t\t\t  sizetype, iv->base, iv->step, dta->stmt);\n \n   if (!iv_step)\n     {"}, {"sha": "40f8e4525aa574d377ca0891d38bbd1ce67b2ac5", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 185, "deletions": 77, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -1445,13 +1445,18 @@ stmt_dominates_stmt_p (tree s1, tree s2)\n   return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n }\n \n-/* Checks whether it is correct to count the induction variable BASE + STEP * I\n-   at AT_STMT in wider TYPE, using the fact that statement OF is executed at\n-   most BOUND times in the loop.  If it is possible, return the value of step\n-   of the induction variable in the TYPE, otherwise return NULL_TREE.\n+/* Return true when it is possible to prove that the induction\n+   variable does not wrap: vary outside the type specified bounds.\n+   Checks whether BOUND < VALID_NITER that means in the context of iv\n+   conversion that all the iterations in the loop are safe: not\n+   producing wraps.\n+\n+   The statement NITER_BOUND->AT_STMT is executed at most\n+   NITER_BOUND->BOUND times in the loop.\n    \n-   ADDITIONAL is the additional condition recorded for operands of the bound.\n-   This is useful in the following case, created by loop header copying:\n+   NITER_BOUND->ADDITIONAL is the additional condition recorded for\n+   operands of the bound.  This is useful in the following case,\n+   created by loop header copying:\n \n    i = 0;\n    if (n > 0)\n@@ -1465,108 +1470,211 @@ stmt_dominates_stmt_p (tree s1, tree s2)\n    assumption \"n > 0\" says us that the value of the number of iterations is at\n    most MAX_TYPE - 1 (without this assumption, it might overflow).  */\n \n-static tree\n-can_count_iv_in_wider_type_bound (tree type, tree base, tree step,\n-\t\t\t\t  tree at_stmt,\n-\t\t\t\t  tree bound,\n-\t\t\t\t  tree additional,\n-\t\t\t\t  tree of)\n+static bool\n+proved_non_wrapping_p (tree at_stmt,\n+\t\t       struct nb_iter_bound *niter_bound, \n+\t\t       tree new_type,\n+\t\t       tree valid_niter)\n {\n-  tree inner_type = TREE_TYPE (base), b, bplusstep, new_step, new_step_abs;\n-  tree valid_niter, extreme, unsigned_type, delta, bound_type;\n   tree cond;\n+  tree bound = niter_bound->bound;\n+\n+  if (TYPE_PRECISION (new_type) > TYPE_PRECISION (TREE_TYPE (bound)))\n+    bound = fold_convert (unsigned_type_for (new_type), bound);\n+  else\n+    valid_niter = fold_convert (TREE_TYPE (bound), valid_niter);\n+\n+  /* After the statement niter_bound->at_stmt we know that anything is\n+     executed at most BOUND times.  */\n+  if (at_stmt && stmt_dominates_stmt_p (niter_bound->at_stmt, at_stmt))\n+    cond = fold_build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n+\n+  /* Before the statement niter_bound->at_stmt we know that anything\n+     is executed at most BOUND + 1 times.  */\n+  else\n+    cond = fold_build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n+\n+  if (nonzero_p (cond))\n+    return true;\n+\n+  /* Try taking additional conditions into account.  */\n+  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t      invert_truthvalue (niter_bound->additional),\n+\t\t      cond);\n+\n+  if (nonzero_p (cond))\n+    return true;\n \n-  b = fold_convert (type, base);\n-  bplusstep = fold_convert (type,\n-\t\t\t    fold_build2 (PLUS_EXPR, inner_type, base, step));\n-  new_step = fold_build2 (MINUS_EXPR, type, bplusstep, b);\n-  if (TREE_CODE (new_step) != INTEGER_CST)\n+  return false;\n+}\n+\n+/* Checks whether it is correct to count the induction variable BASE +\n+   STEP * I at AT_STMT in a wider type NEW_TYPE, using the bounds on\n+   numbers of iterations of a LOOP.  If it is possible, return the\n+   value of step of the induction variable in the NEW_TYPE, otherwise\n+   return NULL_TREE.  */\n+\n+static tree\n+convert_step_widening (struct loop *loop, tree new_type, tree base, tree step,\n+\t\t       tree at_stmt)\n+{\n+  struct nb_iter_bound *bound;\n+  tree base_in_new_type, base_plus_step_in_new_type, step_in_new_type;\n+  tree delta, step_abs;\n+  tree unsigned_type, valid_niter;\n+\n+  /* Compute the new step.  For example, {(uchar) 100, +, (uchar) 240}\n+     is converted to {(uint) 100, +, (uint) 0xfffffff0} in order to\n+     keep the values of the induction variable unchanged: 100, 84, 68,\n+     ...\n+\n+     Another example is: (uint) {(uchar)100, +, (uchar)3} is converted\n+     to {(uint)100, +, (uint)3}.  \n+\n+     Before returning the new step, verify that the number of\n+     iterations is less than DELTA / STEP_ABS (i.e. in the previous\n+     example (256 - 100) / 3) such that the iv does not wrap (in which\n+     case the operations are too difficult to be represented and\n+     handled: the values of the iv should be taken modulo 256 in the\n+     wider type; this is not implemented).  */\n+  base_in_new_type = fold_convert (new_type, base);\n+  base_plus_step_in_new_type = \n+    fold_convert (new_type,\n+\t\t  fold_build2 (PLUS_EXPR, TREE_TYPE (base), base, step));\n+  step_in_new_type = fold_build2 (MINUS_EXPR, new_type,\n+\t\t\t\t  base_plus_step_in_new_type,\n+\t\t\t\t  base_in_new_type);\n+\n+  if (TREE_CODE (step_in_new_type) != INTEGER_CST)\n     return NULL_TREE;\n \n-  switch (compare_trees (bplusstep, b))\n+  switch (compare_trees (base_plus_step_in_new_type, base_in_new_type))\n     {\n     case -1:\n-      extreme = upper_bound_in_type (type, inner_type);\n-      delta = fold_build2 (MINUS_EXPR, type, extreme, b);\n-      new_step_abs = new_step;\n-      break;\n+      {\n+\ttree extreme = upper_bound_in_type (new_type, TREE_TYPE (base));\n+\tdelta = fold_build2 (MINUS_EXPR, new_type, extreme,\n+\t\t\t     base_in_new_type);\n+\tstep_abs = step_in_new_type;\n+\tbreak;\n+      }\n \n     case 1:\n-      extreme = lower_bound_in_type (type, inner_type);\n-      new_step_abs = fold_build1 (NEGATE_EXPR, type, new_step);\n-      delta = fold_build2 (MINUS_EXPR, type, b, extreme);\n-      break;\n+      {\n+\ttree extreme = lower_bound_in_type (new_type, TREE_TYPE (base));\n+\tdelta = fold_build2 (MINUS_EXPR, new_type, base_in_new_type,\n+\t\t\t     extreme);\n+\tstep_abs = fold_build1 (NEGATE_EXPR, new_type, step_in_new_type);\n+\tbreak;\n+      }\n \n     case 0:\n-      return new_step;\n+      return step_in_new_type;\n \n     default:\n       return NULL_TREE;\n     }\n \n-  unsigned_type = unsigned_type_for (type);\n+  unsigned_type = unsigned_type_for (new_type);\n   delta = fold_convert (unsigned_type, delta);\n-  new_step_abs = fold_convert (unsigned_type, new_step_abs);\n+  step_abs = fold_convert (unsigned_type, step_abs);\n   valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type,\n-\t\t\t     delta, new_step_abs);\n+\t\t\t     delta, step_abs);\n \n-  bound_type = TREE_TYPE (bound);\n-  if (TYPE_PRECISION (type) > TYPE_PRECISION (bound_type))\n-    bound = fold_convert (unsigned_type, bound);\n-  else\n-    valid_niter = fold_convert (bound_type, valid_niter);\n-    \n-  if (at_stmt && stmt_dominates_stmt_p (of, at_stmt))\n-    {\n-      /* After the statement OF we know that anything is executed at most\n-\t BOUND times.  */\n-      cond = fold_build2 (GE_EXPR, boolean_type_node, valid_niter, bound);\n-    }\n-  else\n+  for (bound = loop->bounds; bound; bound = bound->next)\n+    if (proved_non_wrapping_p (at_stmt, bound, new_type, valid_niter))\n+      return step_in_new_type;\n+\n+  /* Fail when the loop has no bound estimations, or when no bound can\n+     be used for verifying the conversion.  */\n+  return NULL_TREE;\n+}\n+\n+/* Return false only when the induction variable BASE + STEP * I is\n+   known to not overflow: i.e. when the number of iterations is small\n+   enough with respect to the step and initial condition in order to\n+   keep the evolution confined in TYPEs bounds.  Return true when the\n+   iv is known to overflow or when the property is not computable.\n+\n+   Initialize INIT_IS_MAX to true when the evolution goes from\n+   INIT_IS_MAX to LOWER_BOUND_IN_TYPE, false in the contrary case, not\n+   defined when the function returns true.  */\n+\n+bool\n+scev_probably_wraps_p (tree type, tree base, tree step, \n+\t\t       tree at_stmt, struct loop *loop,\n+\t\t       bool *init_is_max)\n+{\n+  struct nb_iter_bound *bound;\n+  tree delta, step_abs;\n+  tree unsigned_type, valid_niter;\n+  tree base_plus_step = fold_build2 (PLUS_EXPR, type, base, step);\n+\n+  switch (compare_trees (base_plus_step, base))\n     {\n-      /* Before the statement OF we know that anything is executed at most\n-\t BOUND + 1 times.  */\n-      cond = fold_build2 (GT_EXPR, boolean_type_node, valid_niter, bound);\n+    case -1:\n+      {\n+\ttree extreme = upper_bound_in_type (type, TREE_TYPE (base));\n+\tdelta = fold_build2 (MINUS_EXPR, type, extreme, base);\n+\tstep_abs = step;\n+\t*init_is_max = false;\n+\tbreak;\n+      }\n+\n+    case 1:\n+      {\n+\ttree extreme = lower_bound_in_type (type, TREE_TYPE (base));\n+\tdelta = fold_build2 (MINUS_EXPR, type, base, extreme);\n+\tstep_abs = fold_build1 (NEGATE_EXPR, type, step);\n+\t*init_is_max = true;\n+\tbreak;\n+      }\n+\n+    case 0:\n+      /* This means step is equal to 0.  This should not happen.  It\n+\t could happen in convert step, but not here.  Safely answer\n+\t don't know as in the default case.  */\n+\n+    default:\n+      return true;\n     }\n \n-  if (nonzero_p (cond))\n-    return new_step;\n+  /* After having set INIT_IS_MAX, we can return false: when not using\n+     wrapping arithmetic, signed types don't wrap.  */\n+  if (!flag_wrapv && !TYPE_UNSIGNED (type))\n+    return false;\n \n-  /* Try taking additional conditions into account.  */\n-  cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t      invert_truthvalue (additional),\n-\t\t      cond);\n-  if (nonzero_p (cond))\n-    return new_step;\n+  unsigned_type = unsigned_type_for (type);\n+  delta = fold_convert (unsigned_type, delta);\n+  step_abs = fold_convert (unsigned_type, step_abs);\n+  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n \n-  return NULL_TREE;\n+  for (bound = loop->bounds; bound; bound = bound->next)\n+    if (proved_non_wrapping_p (at_stmt, bound, type, valid_niter))\n+      return false;\n+\n+  /* At this point we still don't have a proof that the iv does not\n+     overflow: give up.  */\n+  return true;\n }\n \n-/* Checks whether it is correct to count the induction variable BASE + STEP * I\n-   at AT_STMT in wider TYPE, using the bounds on numbers of iterations of a\n-   LOOP.  If it is possible, return the value of step of the induction variable\n-   in the TYPE, otherwise return NULL_TREE.  */\n+/* Return the conversion to NEW_TYPE of the STEP of an induction\n+   variable BASE + STEP * I at AT_STMT.  */\n \n tree\n-can_count_iv_in_wider_type (struct loop *loop, tree type, tree base, tree step,\n-\t\t\t    tree at_stmt)\n+convert_step (struct loop *loop, tree new_type, tree base, tree step,\n+\t      tree at_stmt)\n {\n-  struct nb_iter_bound *bound;\n-  tree new_step;\n+  tree base_type = TREE_TYPE (base);\n \n-  for (bound = loop->bounds; bound; bound = bound->next)\n-    {\n-      new_step = can_count_iv_in_wider_type_bound (type, base, step,\n-\t\t\t\t\t\t   at_stmt,\n-\t\t\t\t\t\t   bound->bound,\n-\t\t\t\t\t\t   bound->additional,\n-\t\t\t\t\t\t   bound->at_stmt);\n-\n-      if (new_step)\n-\treturn new_step;\n-    }\n+  /* When not using wrapping arithmetic, signed types don't wrap.  */\n+  if (!flag_wrapv && !TYPE_UNSIGNED (base_type))\n+    return fold_convert (new_type, step);\n \n-  return NULL_TREE;\n+  if (TYPE_PRECISION (new_type) > TYPE_PRECISION (base_type))\n+    return convert_step_widening (loop, new_type, base, step, at_stmt);\n+\n+  return fold_convert (new_type, step);\n }\n \n /* Frees the information on upper bounds on numbers of iterations of LOOP.  */"}, {"sha": "b42da82612a3f153083240522b9a95709c0a8060", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e8552ebb2a27d11ff0e5c34c8dd218589a3938f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1e8552ebb2a27d11ff0e5c34c8dd218589a3938f", "patch": "@@ -1427,13 +1427,13 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n     set_value_range_to_varying (vr);\n }\n \n-\n-/* Given a range VR, a loop L and a variable VAR, determine whether it\n+/* Given a range VR, a LOOP and a variable VAR, determine whether it\n    would be profitable to adjust VR using scalar evolution information\n    for VAR.  If so, update VR with the new limits.  */\n \n static void\n-adjust_range_with_scev (value_range_t *vr, struct loop *l, tree var)\n+adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n+\t\t\ttree var)\n {\n   tree init, step, chrec;\n   bool init_is_max;\n@@ -1443,7 +1443,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *l, tree var)\n   if (vr->type == VR_ANTI_RANGE)\n     return;\n \n-  chrec = analyze_scalar_evolution (l, var);\n+  chrec = analyze_scalar_evolution (loop, var);\n   if (TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n     return;\n \n@@ -1455,22 +1455,12 @@ adjust_range_with_scev (value_range_t *vr, struct loop *l, tree var)\n   if (!is_gimple_min_invariant (step))\n     return;\n \n-  /* FIXME.  When dealing with unsigned types,\n-     analyze_scalar_evolution sets STEP to very large unsigned values\n-     when the evolution goes backwards.  This confuses this analysis\n-     because we think that INIT is the smallest value that the range\n-     can take, instead of the largest.  Ignore these chrecs for now.  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (step)) && TYPE_UNSIGNED (TREE_TYPE (step)))\n-    return;\n-\n-  /* Do not adjust ranges when using wrapping arithmetic.  */\n-  if (flag_wrapv)\n+  /* Do not adjust ranges when chrec may wrap.  */\n+  if (scev_probably_wraps_p (chrec_type (chrec), init, step, stmt,\n+\t\t\t     cfg_loops->parray[CHREC_VARIABLE (chrec)],\n+\t\t\t     &init_is_max))\n     return;\n \n-  /* If STEP is negative, then INIT is the maximum value the range\n-     will take.  Otherwise, INIT is the minimum value.  */\n-  init_is_max = (tree_int_cst_sgn (step) < 0);\n-\n   if (!POINTER_TYPE_P (TREE_TYPE (init))\n       && (vr->type == VR_VARYING || vr->type == VR_UNDEFINED))\n     {\n@@ -2772,7 +2762,7 @@ vrp_visit_assignment (tree stmt, tree *output_p)\n \t else about the range of LHS by examining scalar evolution\n \t information.  */\n       if (cfg_loops && (l = loop_containing_stmt (stmt)))\n-\tadjust_range_with_scev (&new_vr, l, lhs);\n+\tadjust_range_with_scev (&new_vr, l, stmt, lhs);\n \n       if (update_value_range (lhs, &new_vr))\n \t{\n@@ -3519,7 +3509,10 @@ execute_vrp (void)\n \n   cfg_loops = loop_optimizer_init (NULL);\n   if (cfg_loops)\n-    scev_initialize (cfg_loops);\n+    {\n+      scev_initialize (cfg_loops);\n+      estimate_numbers_of_iterations (cfg_loops);\n+    }\n \n   vrp_initialize ();\n   ssa_propagate (vrp_visit_stmt, vrp_visit_phi_node);"}]}