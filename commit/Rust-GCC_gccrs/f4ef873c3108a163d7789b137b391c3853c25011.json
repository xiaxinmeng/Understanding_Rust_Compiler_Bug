{"sha": "f4ef873c3108a163d7789b137b391c3853c25011", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlZjg3M2MzMTA4YTE2M2Q3Nzg5YjEzN2IzOTFjMzg1M2MyNTAxMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-07-02T19:47:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-02T19:47:44Z"}, "message": "emit-rtl.c (adjust_address): New function.\n\n\t* emit-rtl.c (adjust_address): New function.\n\t* expr.h (adjust_address): Add declaration.\n\t* builtins.c: Replace some calls to change_address with calls to it\n\tor to validize_mem.\n\t* caller-save.c, dwarf2out.c, except.c, expmed.c, expr.c: Likewise.\n\t* function.c, config/a29k/a29k.md, config/alpha/alpha.c: Likewise.\n\t* config/arm/arm.c, config/convex/convex.c: Likewise.\n\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n\t* config/i386/i386.c, config/i386/i386.md: Likewise.\n\t* config/ia64/ia64.c, config/ia64/ia64.md: Likewise.\n\t* config/m32r/m32r.c, config/m68k/m68k.md: Likewise.\n\t* config/m88k/m88k.c, config/mips/mips.md: Likewise.\n\t* config/ns32k/ns32k.c, config/rs6000/rs6000.c: Likewise.\n\t* config/sh/sh.c, config/sparc/sparc.md: Likewise.\n\nFrom-SVN: r43702", "tree": {"sha": "35bfff21e3c73e0c27ad267a7d90a3719cfb86af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35bfff21e3c73e0c27ad267a7d90a3719cfb86af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4ef873c3108a163d7789b137b391c3853c25011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ef873c3108a163d7789b137b391c3853c25011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4ef873c3108a163d7789b137b391c3853c25011", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4ef873c3108a163d7789b137b391c3853c25011/comments", "author": null, "committer": null, "parents": [{"sha": "494fff4cea67e3d1415788d318fb4448cf9411c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494fff4cea67e3d1415788d318fb4448cf9411c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494fff4cea67e3d1415788d318fb4448cf9411c5"}], "stats": {"total": 583, "additions": 236, "deletions": 347}, "files": [{"sha": "3721aff6413b92c2f746070a246a6ffdd18741fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,3 +1,20 @@\n+Mon Jul  2 15:33:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* emit-rtl.c (adjust_address): New function.\n+\t* expr.h (adjust_address): Add declaration.\n+\t* builtins.c: Replace some calls to change_address with calls to it\n+\tor to validize_mem.\n+\t* caller-save.c, dwarf2out.c, except.c, expmed.c, expr.c: Likewise.\n+\t* function.c, config/a29k/a29k.md, config/alpha/alpha.c: Likewise.\n+\t* config/arm/arm.c, config/convex/convex.c: Likewise.\n+\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n+\t* config/i386/i386.c, config/i386/i386.md: Likewise.\n+\t* config/ia64/ia64.c, config/ia64/ia64.md: Likewise.\n+\t* config/m32r/m32r.c, config/m68k/m68k.md: Likewise.\n+\t* config/m88k/m88k.c, config/mips/mips.md: Likewise.\n+\t* config/ns32k/ns32k.c, config/rs6000/rs6000.c: Likewise.\n+\t* config/sh/sh.c, config/sparc/sparc.md: Likewise.\n+\n 2001-07-02  Jim Wilson  <wilson@redhat.com>\n \n \t* config/ia64/ia64.h: Delete obsolete lib1funcs.asm comment."}, {"sha": "f6f76baba15a6ca65df0e1fb7bb05ca68e0b3ab7", "filename": "gcc/builtins.c", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -947,8 +947,7 @@ result_vector (savep, result)\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n \treg = gen_rtx_REG (mode, savep ? regno : INCOMING_REGNO (regno));\n-\tmem = change_address (result, mode,\n-\t\t\t      plus_constant (XEXP (result, 0), size));\n+\tmem = adjust_address (result, mode, size);\n \tsavevec[nelts++] = (savep\n \t\t\t    ? gen_rtx_SET (VOIDmode, mem, reg)\n \t\t\t    : gen_rtx_SET (VOIDmode, reg, mem));\n@@ -989,25 +988,20 @@ expand_builtin_apply_args_1 ()\n \n \ttem = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n \n-\temit_move_insn (change_address (registers, mode,\n-\t\t\t\t\tplus_constant (XEXP (registers, 0),\n-\t\t\t\t\t\t       size)),\n-\t\t\ttem);\n+\temit_move_insn (adjust_address (registers, mode, size), tem);\n \tsize += GET_MODE_SIZE (mode);\n       }\n \n   /* Save the arg pointer to the block.  */\n-  emit_move_insn (change_address (registers, Pmode, XEXP (registers, 0)),\n+  emit_move_insn (adjust_address (registers, Pmode, 0),\n \t\t  copy_to_reg (virtual_incoming_args_rtx));\n   size = GET_MODE_SIZE (Pmode);\n \n   /* Save the structure value address unless this is passed as an\n      \"invisible\" first argument.  */\n   if (struct_value_incoming_rtx)\n     {\n-      emit_move_insn (change_address (registers, Pmode,\n-\t\t\t\t      plus_constant (XEXP (registers, 0),\n-\t\t\t\t\t\t     size)),\n+      emit_move_insn (adjust_address (registers, Pmode, size),\n \t\t      copy_to_reg (struct_value_incoming_rtx));\n       size += GET_MODE_SIZE (Pmode);\n     }\n@@ -1124,11 +1118,7 @@ expand_builtin_apply (function, arguments, argsize)\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n \treg = gen_rtx_REG (mode, regno);\n-\temit_move_insn (reg,\n-\t\t\tchange_address (arguments, mode,\n-\t\t\t\t\tplus_constant (XEXP (arguments, 0),\n-\t\t\t\t\t\t       size)));\n-\n+\temit_move_insn (reg, adjust_address (arguments, mode, size));\n \tuse_reg (&call_fusage, reg);\n \tsize += GET_MODE_SIZE (mode);\n       }\n@@ -1139,10 +1129,7 @@ expand_builtin_apply (function, arguments, argsize)\n   if (struct_value_rtx)\n     {\n       rtx value = gen_reg_rtx (Pmode);\n-      emit_move_insn (value,\n-\t\t      change_address (arguments, Pmode,\n-\t\t\t\t      plus_constant (XEXP (arguments, 0),\n-\t\t\t\t\t\t     size)));\n+      emit_move_insn (value, adjust_address (arguments, Pmode, size));\n       emit_move_insn (struct_value_rtx, value);\n       if (GET_CODE (struct_value_rtx) == REG)\n \t  use_reg (&call_fusage, struct_value_rtx);\n@@ -1186,9 +1173,7 @@ expand_builtin_apply (function, arguments, argsize)\n \t\t\t\t      gen_rtx_MEM (FUNCTION_MODE, function),\n \t\t\t\t      const0_rtx, NULL_RTX, const0_rtx));\n \n-      emit_move_insn (change_address (result, GET_MODE (valreg),\n-\t\t\t\t      XEXP (result, 0)),\n-\t\t      valreg);\n+      emit_move_insn (adjust_address (result, GET_MODE (valreg), 0), valreg);\n     }\n   else\n #endif\n@@ -1264,10 +1249,7 @@ expand_builtin_return (result)\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n \treg = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n-\temit_move_insn (reg,\n-\t\t\tchange_address (result, mode,\n-\t\t\t\t\tplus_constant (XEXP (result, 0),\n-\t\t\t\t\t\t       size)));\n+\temit_move_insn (reg, adjust_address (result, mode, size));\n \n \tpush_to_sequence (call_fusage);\n \temit_insn (gen_rtx_USE (VOIDmode, reg));"}, {"sha": "b41f0866a99866753695c1b74a9036c7286bcfee", "filename": "gcc/caller-save.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,6 +1,6 @@\n /* Save and restore call-clobbered registers which are live across a call.\n    Copyright (C) 1989, 1992, 1994, 1995, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -677,7 +677,7 @@ insert_restore (chain, before_p, regno, maxrestore, save_mode)\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n       && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n-    mem = change_address (mem, save_mode[regno], XEXP (mem, 0));\n+    mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode,\n \t\t     gen_rtx_REG (GET_MODE (mem), \n \t\t\t\t  regno), mem);\n@@ -754,7 +754,7 @@ insert_save (chain, before_p, regno, to_save, save_mode)\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n       && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n-    mem = change_address (mem, save_mode[regno], XEXP (mem, 0));\n+    mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode, mem,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno));"}, {"sha": "a6c29d389e2ea5ff4b1bff7b7aca9dbb686939fa", "filename": "gcc/config/a29k/a29k.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,6 @@\n ;;- Machine description for AMD Am29000 for GNU C compiler\n-;;   Copyright (C) 1991, 1992, 1994, 1998, 1999 Free Software Foundation, Inc.\n+;;   Copyright (C) 1991, 1992, 1994, 1998, 1999, 2001\n+;;   Free Software Foundation, Inc.\n ;;   Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -2375,8 +2376,7 @@\n       operands[1] = force_const_mem (TImode, operands[1]);\n       if (! memory_address_p (TImode, XEXP (operands[1], 0))\n \t  && ! reload_in_progress)\n-        operands[1] = change_address (operands[1], TImode,\n-\t\t\t\t      XEXP (operands[1], 0));\n+        operands[1] = adjust_address (operands[1], TImode, 0);\n     }\n }\")\n \f"}, {"sha": "ffd378674d09bad3e0249f07077746d49c92fcbd", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 27, "deletions": 78, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -2397,9 +2397,8 @@ alpha_split_tfmode_pair (operands)\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {\n-      operands[3] = change_address (operands[1], DImode,\n-\t\t\t\t    plus_constant (XEXP (operands[1], 0), 8));\n-      operands[2] = change_address (operands[1], DImode, NULL_RTX);\n+      operands[3] = adjust_address (operands[1], DImode, 8);\n+      operands[2] = adjust_address (operands[1], DImode, 0);\n     }\n   else if (operands[1] == CONST0_RTX (TFmode))\n     operands[2] = operands[3] = const0_rtx;\n@@ -2413,9 +2412,8 @@ alpha_split_tfmode_pair (operands)\n     }\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n-      operands[1] = change_address (operands[0], DImode,\n-\t\t\t\t    plus_constant (XEXP (operands[0], 0), 8));\n-      operands[0] = change_address (operands[0], DImode, NULL_RTX);\n+      operands[1] = adjust_address (operands[0], DImode, 8);\n+      operands[0] = adjust_address (operands[0], DImode, 0);\n     }\n   else\n     abort ();\n@@ -2694,8 +2692,7 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n   data_regs[words] = gen_reg_rtx (DImode);\n \n   if (ofs != 0)\n-    smem = change_address (smem, GET_MODE (smem),\n-\t\t\t   plus_constant (XEXP (smem, 0), ofs));\n+    smem = adjust_address (smem, GET_MODE (smem), ofs);\n   \n   /* Load up all of the source data.  */\n   for (i = 0; i < words; ++i)\n@@ -2771,9 +2768,7 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n   st_tmp_2 = gen_reg_rtx(DImode);\n   \n   if (ofs != 0)\n-    dmem = change_address (dmem, GET_MODE (dmem),\n-\t\t\t   plus_constant (XEXP (dmem, 0), ofs));\n-  \n+    dmem = adjust_address (dmem, GET_MODE (dmem), ofs);\n \n   st_addr_2 = change_address (dmem, DImode,\n \t\t\t      gen_rtx_AND (DImode,\n@@ -2950,9 +2945,7 @@ alpha_expand_block_move (operands)\n \n       for (i = 0; i < words; ++i)\n \temit_move_insn (data_regs[nregs + i],\n-\t\t\tchange_address (orig_src, DImode,\n-\t\t\t\t\tplus_constant (XEXP (orig_src, 0), \n-\t\t\t\t\t\t       ofs + i * 8)));\n+\t\t\tadjust_address (orig_src, DImode, ofs + i * 8));\n \n       nregs += words;\n       bytes -= words * 8;\n@@ -3006,10 +2999,7 @@ alpha_expand_block_move (operands)\n \t{\n \t  do {\n \t    data_regs[nregs++] = tmp = gen_reg_rtx (HImode);\n-\t    emit_move_insn (tmp,\n-\t\t\t    change_address (orig_src, HImode,\n-\t\t\t\t\t    plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t\t   ofs)));\n+\t    emit_move_insn (tmp, adjust_address (orig_src, HImode, ofs));\n \t    bytes -= 2;\n \t    ofs += 2;\n \t  } while (bytes >= 2);\n@@ -3026,10 +3016,7 @@ alpha_expand_block_move (operands)\n   while (bytes > 0)\n     {\n       data_regs[nregs++] = tmp = gen_reg_rtx (QImode);\n-      emit_move_insn (tmp,\n-\t\t      change_address (orig_src, QImode,\n-\t\t\t\t      plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t     ofs)));\n+      emit_move_insn (tmp, adjust_address (orig_src, QImode, ofs));\n       bytes -= 1;\n       ofs += 1;\n     }\n@@ -3099,9 +3086,7 @@ alpha_expand_block_move (operands)\n     {\n       while (i < nregs && GET_MODE (data_regs[i]) == DImode)\n \t{\n-\t  emit_move_insn (change_address (orig_dst, DImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t ofs)),\n+\t  emit_move_insn (adjust_address (orig_dst, DImode, ofs),\n \t\t\t  data_regs[i]);\n \t  ofs += 8;\n \t  i++;\n@@ -3117,23 +3102,17 @@ alpha_expand_block_move (operands)\n \t  tmp = expand_binop (DImode, lshr_optab, data_regs[i], GEN_INT (32),\n \t\t\t      NULL_RTX, 1, OPTAB_WIDEN);\n \n-\t  emit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t ofs)),\n+\t  emit_move_insn (adjust_address (orig_dst, SImode, ofs),\n \t\t\t  gen_lowpart (SImode, data_regs[i]));\n-\t  emit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t ofs + 4)),\n+\t  emit_move_insn (adjust_address (orig_dst, SImode, ofs + 4),\n \t\t\t  gen_lowpart (SImode, tmp));\n \t  ofs += 8;\n \t  i++;\n \t}\n \n       while (i < nregs && GET_MODE (data_regs[i]) == SImode)\n \t{\n-\t  emit_move_insn (change_address(orig_dst, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs)),\n+\t  emit_move_insn (adjust_address (orig_dst, SImode, ofs),\n \t\t\t  data_regs[i]);\n \t  ofs += 4;\n \t  i++;\n@@ -3171,10 +3150,7 @@ alpha_expand_block_move (operands)\n   if (dst_align >= 16)\n     while (i < nregs && GET_MODE (data_regs[i]) == HImode)\n       {\n-\temit_move_insn (change_address (orig_dst, HImode,\n-\t\t\t\t\tplus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t       ofs)),\n-\t\t\tdata_regs[i]);\n+\temit_move_insn (adjust_address (orig_dst, HImode, ofs), data_regs[i]);\n \ti++;\n \tofs += 2;\n       }\n@@ -3188,10 +3164,7 @@ alpha_expand_block_move (operands)\n \n   while (i < nregs && GET_MODE (data_regs[i]) == QImode)\n     {\n-      emit_move_insn (change_address (orig_dst, QImode,\n-\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t     ofs)),\n-\t\t      data_regs[i]);\n+      emit_move_insn (adjust_address (orig_dst, QImode, ofs), data_regs[i]);\n       i++;\n       ofs += 1;\n     }\n@@ -3278,9 +3251,7 @@ alpha_expand_block_clear (operands)\n \t  rtx mem, tmp;\n \t  HOST_WIDE_INT mask;\n \n-\t  mem = change_address (orig_dst, mode,\n-\t\t\t\tplus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t       ofs - inv_alignofs));\n+\t  mem = adjust_address (orig_dst, mode, ofs - inv_alignofs);\n \t  MEM_ALIAS_SET (mem) = 0;\n \n \t  mask = ~(~(HOST_WIDE_INT)0 << (inv_alignofs * 8));\n@@ -3306,30 +3277,21 @@ alpha_expand_block_clear (operands)\n \n       if (TARGET_BWX && (alignofs & 1) && bytes >= 1)\n \t{\n-\t  emit_move_insn (change_address (orig_dst, QImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t         ofs)),\n-\t\t\t  const0_rtx);\n+\t  emit_move_insn (adjust_address (orig_dst, QImode, ofs), const0_rtx);\n \t  bytes -= 1;\n \t  ofs += 1;\n \t  alignofs -= 1;\n \t}\n       if (TARGET_BWX && align >= 16 && (alignofs & 3) == 2 && bytes >= 2)\n \t{\n-\t  emit_move_insn (change_address (orig_dst, HImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t         ofs)),\n-\t\t\t  const0_rtx);\n+\t  emit_move_insn (adjust_address (orig_dst, HImode, ofs), const0_rtx);\n \t  bytes -= 2;\n \t  ofs += 2;\n \t  alignofs -= 2;\n \t}\n       if (alignofs == 4 && bytes >= 4)\n \t{\n-\t  emit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t         ofs)),\n-\t\t\t  const0_rtx);\n+\t  emit_move_insn (adjust_address (orig_dst, SImode, ofs), const0_rtx);\n \t  bytes -= 4;\n \t  ofs += 4;\n \t  alignofs = 0;\n@@ -3351,10 +3313,8 @@ alpha_expand_block_clear (operands)\n       words = bytes / 8;\n \n       for (i = 0; i < words; ++i)\n-\temit_move_insn (change_address(orig_dst, DImode,\n-\t\t\t\t       plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t      ofs + i * 8)),\n-\t\t\t  const0_rtx);\n+\temit_move_insn (adjust_address(orig_dst, DImode, ofs + i * 8),\n+\t\t\tconst0_rtx);\n \n       bytes -= words * 8;\n       ofs += words * 8;\n@@ -3365,9 +3325,7 @@ alpha_expand_block_clear (operands)\n \n   if (align >= 32 && bytes > 16)\n     {\n-      emit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t      plus_constant (XEXP (orig_dst, 0), ofs)),\n-\t\t      const0_rtx);\n+      emit_move_insn (adjust_address (orig_dst, SImode, ofs), const0_rtx);\n       bytes -= 4;\n       ofs += 4;\n \n@@ -3400,9 +3358,7 @@ alpha_expand_block_clear (operands)\n       words = bytes / 4;\n \n       for (i = 0; i < words; ++i)\n-\temit_move_insn (change_address (orig_dst, SImode,\n-\t\t\t\t\tplus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t       ofs + i * 4)),\n+\temit_move_insn (adjust_address (orig_dst, SImode, ofs + i * 4),\n \t\t\tconst0_rtx);\n \n       bytes -= words * 4;\n@@ -3440,8 +3396,7 @@ alpha_expand_block_clear (operands)\n \t  rtx mem, tmp;\n \t  HOST_WIDE_INT mask;\n \n-\t  mem = change_address (orig_dst, DImode,\n-\t\t\t\tplus_constant (XEXP (orig_dst, 0), ofs));\n+\t  mem = adjust_address (orig_dst, DImode, ofs);\n \t  MEM_ALIAS_SET (mem) = 0;\n \n \t  mask = ~(HOST_WIDE_INT)0 << (bytes * 8);\n@@ -3457,8 +3412,7 @@ alpha_expand_block_clear (operands)\n \t  rtx mem, tmp;\n \t  HOST_WIDE_INT mask;\n \n-\t  mem = change_address (orig_dst, SImode,\n-\t\t\t\tplus_constant (XEXP (orig_dst, 0), ofs));\n+\t  mem = adjust_address (orig_dst, SImode, ofs);\n \t  MEM_ALIAS_SET (mem) = 0;\n \n \t  mask = ~(HOST_WIDE_INT)0 << (bytes * 8);\n@@ -3484,9 +3438,7 @@ alpha_expand_block_clear (operands)\n       if (align >= 16)\n \t{\n \t  do {\n-\t    emit_move_insn (change_address (orig_dst, HImode,\n-\t\t\t\t\t    plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\t   ofs)),\n+\t    emit_move_insn (adjust_address (orig_dst, HImode, ofs),\n \t\t\t    const0_rtx);\n \t    bytes -= 2;\n \t    ofs += 2;\n@@ -3502,10 +3454,7 @@ alpha_expand_block_clear (operands)\n \n   while (bytes > 0)\n     {\n-      emit_move_insn (change_address (orig_dst, QImode,\n-\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t     ofs)),\n-\t\t      const0_rtx);\n+      emit_move_insn (adjust_address (orig_dst, QImode, ofs), const0_rtx);\n       bytes -= 1;\n       ofs += 1;\n     }"}, {"sha": "663877de3e443f75685ce18b4859849db4f2f71b", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -4291,7 +4291,7 @@\n \n     operands[4] = change_address (operands[1], QImode,\n \t\t\t\t  plus_constant (addr, 1));\n-    operands[1] = change_address (operands[1], QImode, NULL_RTX);\n+    operands[1] = adjust_address (operands[1], QImode, 0);\n     operands[3] = gen_lowpart (QImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[2] = gen_reg_rtx (SImode); \n@@ -4315,7 +4315,7 @@\n \n     operands[4] = change_address (operands[1], QImode,\n \t\t\t\t  plus_constant (addr, 1));\n-    operands[1] = change_address (operands[1], QImode, NULL_RTX);\n+    operands[1] = adjust_address (operands[1], QImode, 0);\n     operands[3] = gen_lowpart (QImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n     operands[2] = gen_reg_rtx (SImode);\n@@ -4364,7 +4364,7 @@\n \n     operands[3] = change_address (operands[0], QImode,\n \t\t\t\t  plus_constant (addr, 1));\n-    operands[0] = change_address (operands[0], QImode, NULL_RTX);\n+    operands[0] = adjust_address (operands[0], QImode, 0);\n   }\"\n )\n "}, {"sha": "eecf2bd869908a998c6f2c2499c531f22a66a100", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Convex.\n-   Copyright (C) 1988, 1993, 1994, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1993, 1994, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -369,8 +369,10 @@ expand_movstr (operands)\n \n       /* Get src and dest in the right mode */\n       if (GET_MODE (src) != mode)\n-\tsrc = change_address (src, mode, 0),\n-\tdest = change_address (dest, mode, 0);\n+\t{\n+\t  src = adjust_address (src, mode, 0);\n+\t  dest = adjust_address (dest, mode, 0);\n+\t}\n \n       /* Make load and store patterns for this piece */\n       load = gen_rtx_SET (VOIDmode, reg, src);"}, {"sha": "2d821b5504a5f4bdc8dc815bcc0feda7b72e4719", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1467,7 +1467,7 @@\n \t    rtx stack_slot;\n \t    \n \t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t    stack_slot = validize_mem (stack_slot);\n \t    emit_move_insn (stack_slot, operands[2]);\n \t    operands[2] = stack_slot;\n \t  }\n@@ -1592,7 +1592,7 @@\n \t      rtx stack_slot;\n \t    \n \t      stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t      stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t      stack_slot = validize_mem (stack_slot);\n \t      emit_move_insn (stack_slot, operands[2]);\n \t      operands[2] = stack_slot;\n \t    }\n@@ -1729,16 +1729,18 @@\n \temit_barrier ();\n \temit_label (label1);\n \n-\tif (GET_CODE(operands[2]) != MEM)\n+\tif (GET_CODE (operands[2]) != MEM)\n \t  {\n \t    rtx stack_slot;\n \t    \n \t    stack_slot = assign_stack_temp (QImode, GET_MODE_SIZE(QImode), 0);\n-\t    stack_slot = change_address (stack_slot, VOIDmode, XEXP (stack_slot, 0));\n+\t    stack_slot = validize_mem (stack_slot);\n \t    emit_move_insn (stack_slot, operands[2]);\n \t    operands[2] = stack_slot;\n \t  }\n-\temit_insn (gen_match_ashlhi3_nobmu (operands[0], operands[1], operands[2]));\n+\n+\temit_insn (gen_match_ashlhi3_nobmu (operands[0], operands[1],\n+\t\t\t\t\t    operands[2]));\n \temit_label (label2);\n \tDONE;\n #endif"}, {"sha": "0c18c652e11a2fa25dbab746c096945b5ef6d6b9", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,7 +1,5 @@\n-/*{{{  Introduction */ \n-\n /* FR30 specific functions.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n This file is part of GNU CC.\n@@ -1008,9 +1006,12 @@ fr30_move_double (operands)\n \n \t  if (reverse)\n \t    {\n-\t      emit_insn (gen_rtx_SET (VOIDmode, dest1, change_address (src, SImode, addr)));\n-\t      emit_insn (gen_rtx_SET (SImode, dest0, gen_rtx_REG (SImode, REGNO (addr))));\n-\t      emit_insn (gen_rtx_SET (SImode, dest0, plus_constant (dest0, UNITS_PER_WORD)));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest1,\n+\t\t\t\t      change_address (src, SImode, addr)));\n+\t      emit_insn (gen_rtx_SET (SImode, dest0,\n+\t\t\t\t      gen_rtx_REG (SImode, REGNO (addr))));\n+\t      emit_insn (gen_rtx_SET (SImode, dest0,\n+\t\t\t\t      plus_constant (dest0, UNITS_PER_WORD)));\n \n \t      new_mem = gen_rtx_MEM (SImode, dest0);\n \t      MEM_COPY_ATTRIBUTES (new_mem, src);\n@@ -1019,9 +1020,12 @@ fr30_move_double (operands)\n \t    }\n \t  else\n \t    {\n-\t      emit_insn (gen_rtx_SET (VOIDmode, dest0, change_address (src, SImode, addr)));\n-\t      emit_insn (gen_rtx_SET (SImode, dest1, gen_rtx_REG (SImode, REGNO (addr))));\n-\t      emit_insn (gen_rtx_SET (SImode, dest1, plus_constant (dest1, UNITS_PER_WORD)));\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest0,\n+\t\t\t\t      change_address (src, SImode, addr)));\n+\t      emit_insn (gen_rtx_SET (SImode, dest1,\n+\t\t\t\t      gen_rtx_REG (SImode, REGNO (addr))));\n+\t      emit_insn (gen_rtx_SET (SImode, dest1,\n+\t\t\t\t      plus_constant (dest1, UNITS_PER_WORD)));\n \n \t      new_mem = gen_rtx_MEM (SImode, dest1);\n \t      MEM_COPY_ATTRIBUTES (new_mem, src);\n@@ -1054,12 +1058,15 @@ fr30_move_double (operands)\n       src0 = operand_subword (src, 0, TRUE, mode);\n       src1 = operand_subword (src, 1, TRUE, mode);\n       \n-      emit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, addr), src0));\n-\n-      if (REGNO (addr) == STACK_POINTER_REGNUM)\n-\temit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, plus_constant (stack_pointer_rtx, UNITS_PER_WORD)), src1));\n-      else if (REGNO (addr) == FRAME_POINTER_REGNUM)\n-\temit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, plus_constant (frame_pointer_rtx, UNITS_PER_WORD)), src1));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      change_address (dest, SImode, addr),\n+\t\t\t      src0));\n+\n+      if (REGNO (addr) == STACK_POINTER_REGNUM\n+\t  || REGNO (addr) == FRAME_POINTER_REGNUM)\n+\temit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\tadjust_address (dest, SImode, UNITS_PER_WORD),\n+\t\t\t\tsrc1));\n       else\n \t{\n \t  rtx new_mem;\n@@ -1087,10 +1094,3 @@ fr30_move_double (operands)\n \n   return val;\n }\n-\n-/*}}}*/\n-\n-/* Local Variables: */\n-/* folded-file: t   */\n-/* End:\t\t    */\n-"}, {"sha": "d7e6115daa2fbd77646e57f4216c12468d8165df", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,3 @@\n-;;{{{ Comment \n-\n ;; FR30 machine description.\n ;; Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n ;; Contributed by Cygnus Solutions.\n@@ -1441,5 +1439,3 @@\n ;; mode: md\n ;; folded-file: t\n ;; End:\n-\n-;;}}} \f"}, {"sha": "78bf5ed705da4d9b14d7bd17e183427cf954ef7c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -4408,9 +4408,9 @@ split_di (operands, num, lo_half, hi_half)\n \t}\n       else if (offsettable_memref_p (op))\n \t{\n-\t  rtx lo_addr = XEXP (op, 0);\n \t  rtx hi_addr = XEXP (adj_offsettable_operand (op, 4), 0);\n-\t  lo_half[num] = change_address (op, SImode, lo_addr);\n+\n+\t  lo_half[num] = adjust_address (op, SImode, 0);\n \t  hi_half[num] = change_address (op, SImode, hi_addr);\n \t}\n       else\n@@ -6865,7 +6865,7 @@ ix86_split_to_parts (operand, parts, mode)\n \t    }\n \t  else if (offsettable_memref_p (operand))\n \t    {\n-\t      operand = change_address (operand, SImode, XEXP (operand, 0));\n+\t      operand = adjust_address (operand, SImode, 0);\n \t      parts[0] = operand;\n \t      parts[1] = adj_offsettable_operand (operand, 4);\n \t      if (size == 3)\n@@ -7061,7 +7061,7 @@ ix86_split_long_move (operands)\n \t  if (GET_MODE (part[1][1]) == SImode)\n \t    {\n \t      if (GET_CODE (part[1][1]) == MEM)\n-\t\tpart[1][1] = change_address (part[1][1], DImode, XEXP (part[1][1], 0));\n+\t\tpart[1][1] = adjust_address (part[1][1], DImode, 0);\n \t      else if (REG_P (part[1][1]))\n \t\tpart[1][1] = gen_rtx_REG (DImode, REGNO (part[1][1]));\n \t      else\n@@ -10185,17 +10185,16 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n     case IX86_BUILTIN_SETPS1:\n       target = assign_386_stack_local (SFmode, 0);\n       arg0 = TREE_VALUE (arglist);\n-      emit_move_insn (change_address (target, SFmode, XEXP (target, 0)),\n+      emit_move_insn (adjust_address (target, SFmode, 0),\n \t\t      expand_expr (arg0, NULL_RTX, VOIDmode, 0));\n       op0 = gen_reg_rtx (V4SFmode);\n-      emit_insn (gen_sse_loadss (op0, change_address (target, V4SFmode,\n-\t\t\t\t\t\t      XEXP (target, 0))));\n+      emit_insn (gen_sse_loadss (op0, adjust_address (target, V4SFmode, 0)));\n       emit_insn (gen_sse_shufps (op0, op0, op0, GEN_INT (0)));\n       return op0;\n \n     case IX86_BUILTIN_SETPS:\n       target = assign_386_stack_local (V4SFmode, 0);\n-      op0 = change_address (target, SFmode, XEXP (target, 0));\n+      op0 = adjust_address (target, SFmode, 0);\n       arg0 = TREE_VALUE (arglist);\n       arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n       arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));"}, {"sha": "c460ef689b94ee70e5bfe8be2fb898e8ca040dca", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -8059,7 +8059,7 @@\n       if (! MEM_VOLATILE_P (operands[0]))\n \t{\n \t  mode = smallest_mode_for_size (pos + len, MODE_INT);\n-\t  operands[0] = change_address (operands[0], mode, NULL_RTX);\n+\t  operands[0] = adjust_address (operands[0], mode, 0);\n \t}\n     }\n   else if (mode == HImode && pos + len <= 8)"}, {"sha": "11a21a5229039fced10dc2ab774b01feacfe35d7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -928,11 +928,11 @@ ia64_split_timode (out, in, scratch)\n \tswitch (GET_CODE (base))\n \t  {\n \t  case REG:\n-\t    out[0] = change_address (in, DImode, NULL_RTX);\n+\t    out[0] = adjust_address (in, DImode, 0);\n \t    break;\n \t  case POST_MODIFY:\n \t    base = XEXP (base, 0);\n-\t    out[0] = change_address (in, DImode, NULL_RTX);\n+\t    out[0] = adjust_address (in, DImode, 0);\n \t    break;\n \n \t  /* Since we're changing the mode, we need to change to POST_MODIFY\n@@ -941,13 +941,17 @@ ia64_split_timode (out, in, scratch)\n \t     register handy so let's use it.  */\n \t  case POST_INC:\n \t    base = XEXP (base, 0);\n-\t    out[0] = change_address (in, DImode,\n-\t      gen_rtx_POST_MODIFY (Pmode, base,plus_constant (base, 16)));\n+\t    out[0]\n+\t      = change_address (in, DImode,\n+\t\t\t\tgen_rtx_POST_MODIFY\n+\t\t\t\t(Pmode, base, plus_constant (base, 16)));\n \t    break;\n \t  case POST_DEC:\n \t    base = XEXP (base, 0);\n-\t    out[0] = change_address (in, DImode,\n-\t      gen_rtx_POST_MODIFY (Pmode, base,plus_constant (base, -16)));\n+\t    out[0]\n+\t      = change_address (in, DImode,\n+\t\t\t\tgen_rtx_POST_MODIFY\n+\t\t\t\t(Pmode, base, plus_constant (base, -16)));\n \t    break;\n \t  default:\n \t    abort ();\n@@ -998,9 +1002,7 @@ spill_tfmode_operand (in, force)\n     }\n   else if (GET_CODE (in) == MEM\n \t   && GET_CODE (XEXP (in, 0)) == ADDRESSOF)\n-    {\n-      return change_address (in, TFmode, copy_to_reg (XEXP (in, 0)));\n-    }\n+    return change_address (in, TFmode, copy_to_reg (XEXP (in, 0)));\n   else\n     return in;\n }"}, {"sha": "3a54dd5c9fe01a986964907d4cd2749b89904a98", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,5 @@\n ;; IA-64 Machine description template\n-;; Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+;; Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n ;; Contributed by James E. Wilson <wilson@cygnus.com> and\n ;;\t\t  David Mosberger <davidm@hpl.hp.com>.\n \n@@ -725,11 +725,8 @@\n \t  out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0]));\n \t  out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[0])+1);\n \n-\t  emit_move_insn (out[0], change_address (operands[1], DImode, NULL));\n-\t  emit_move_insn (out[1],\n-\t\t\t  change_address (operands[1], DImode,\n-\t\t\t\t\t  plus_constant (XEXP (operands[1], 0),\n-\t\t\t\t\t\t\t 8)));\n+\t  emit_move_insn (out[0], adjust_address (operands[1], DImode, 0));\n+\t  emit_move_insn (out[1], adjust_address (operands[1], DImode, 8));\n \t  DONE;\n \t}\n "}, {"sha": "ca213af8e269de05dd136c3e6f3a4dddd96aaf28", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,6 @@\n /* Subroutines used for code generation on the Mitsubishi M32R cpu.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1263,8 +1264,8 @@ gen_split_move_double (operands)\n \t{\n \t  /* If the high-address word is used in the address, we must load it\n \t     last.  Otherwise, load it first.  */\n-\t  rtx addr = XEXP (src, 0);\n-\t  int reverse = (refers_to_regno_p (dregno, dregno+1, addr, 0) != 0);\n+\t  int reverse\n+\t    = (refers_to_regno_p (dregno, dregno + 1, XEXP (src, 0), 0) != 0);\n \n \t  /* We used to optimize loads from single registers as\n \n@@ -1279,15 +1280,13 @@ gen_split_move_double (operands)\n \t     which saves 2 bytes and doesn't force longword alignment.  */\n \t  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t  operand_subword (dest, reverse, TRUE, mode),\n-\t\t\t\t  change_address (src, SImode,\n-\t\t\t\t\t\t  plus_constant (addr,\n-\t\t\t\t\t\t\t\t reverse * UNITS_PER_WORD))));\n+\t\t\t\t  adjust_address (src, SImode,\n+\t\t\t\t\t\t  reverse * UNITS_PER_WORD)));\n \n \t  emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\t  operand_subword (dest, !reverse, TRUE, mode),\n-\t\t\t\t  change_address (src, SImode,\n-\t\t\t\t\t\t  plus_constant (addr,\n-\t\t\t\t\t\t\t\t (!reverse) * UNITS_PER_WORD))));\n+\t\t\t\t  adjust_address (src, SImode,\n+\t\t\t\t\t\t  !reverse * UNITS_PER_WORD)));\n \t}\n \n       else\n@@ -1308,15 +1307,12 @@ gen_split_move_double (operands)\n      which saves 2 bytes and doesn't force longword alignment.  */\n   else if (GET_CODE (dest) == MEM && GET_CODE (src) == REG)\n     {\n-      rtx addr = XEXP (dest, 0);\n-\n       emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      change_address (dest, SImode, addr),\n+\t\t\t      adjust_address (dest, SImode, 0),\n \t\t\t      operand_subword (src, 0, TRUE, mode)));\n \n       emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      change_address (dest, SImode,\n-\t\t\t\t\t      plus_constant (addr, UNITS_PER_WORD)),\n+\t\t\t      adjust_address (dest, SImode, UNITS_PER_WORD),\n \t\t\t      operand_subword (src, 1, TRUE, mode)));\n     }\n "}, {"sha": "a6668761ae7a075f059e9765c0349873557b46e7", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler, Motorola 68000 Version\n-;;  Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999\n+;;  Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001\n ;;  Free Software Foundation, Inc.\n \n ;; This file is part of GNU CC.\n@@ -1255,8 +1255,7 @@\n       operands[1] = force_const_mem (XFmode, operands[1]);\n       if (! memory_address_p (XFmode, XEXP (operands[1], 0))\n \t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], XFmode,\n-\t\t\t\t      XEXP (operands[1], 0));\n+\toperands[1] = adjust_address (operands[1], XFmode, 0);\n     }\n   if (flag_pic && TARGET_PCREL && ! reload_in_progress)\n     {"}, {"sha": "12313c9d0d6bc9345c3fad00115334b6afd5a1c3", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for Motorola 88000.\n-   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc. \n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001 Free Software Foundation, Inc. \n    Contributed by Michael Tiemann (tiemann@mcc.com)\n    Currently maintained by (gcc@dg-rtp.dg.com)\n \n@@ -2613,9 +2613,7 @@ m88k_builtin_saveregs ()\n   /* Now store the incoming registers.  */\n   if (fixed < 8)\n     {\n-      dest = change_address (addr, Pmode,\n-\t\t\t     plus_constant (XEXP (addr, 0),\n-\t\t\t\t\t    fixed * UNITS_PER_WORD));\n+      dest = adjust_address (addr, Pmode, fixed * UNITS_PER_WORD);\n       move_block_from_reg (2 + fixed, dest, 8 - fixed,\n \t\t\t   UNITS_PER_WORD * (8 - fixed));\n "}, {"sha": "950e38d96a410fdb1435eb56db3a001f0f388c54", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,6 +1,6 @@\n ;;  Mips.md\t     Machine Description for MIPS based processors\n ;;  Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-;;  1999, 2000 Free Software Foundation, Inc.\n+;;  1999, 2000, 2001 Free Software Foundation, Inc.\n ;;  Contributed by   A. Lichnewsky, lich@inria.inria.fr\n ;;  Changes by       Michael Meissner, meissner@osf.org\n ;;  64 bit r4000 support by Ian Lance Taylor, ian@cygnus.com, and\n@@ -4542,7 +4542,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     FAIL;\n \n   /* Change the mode to BLKmode for aliasing purposes.  */\n-  operands[1] = change_address (operands[1], BLKmode, XEXP (operands[1], 0));\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n \n   /* Otherwise, emit a l[wd]l/l[wd]r pair to load the value.  */\n   if (INTVAL (operands[2]) == 64)\n@@ -4590,7 +4590,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     FAIL;\n \n   /* Change the mode to BLKmode for aliasing purposes.  */\n-  operands[1] = change_address (operands[1], BLKmode, XEXP (operands[1], 0));\n+  operands[1] = adjust_address (operands[1], BLKmode, 0);\n \n   /* Otherwise, emit a lwl/lwr pair to load the value.  */\n   if (INTVAL (operands[2]) == 64)\n@@ -4638,7 +4638,7 @@ move\\\\t%0,%z4\\\\n\\\\\n     FAIL;\n \n   /* Change the mode to BLKmode for aliasing purposes.  */\n-  operands[0] = change_address (operands[0], BLKmode, XEXP (operands[0], 0));\n+  operands[0] = adjust_address (operands[0], BLKmode, 0);\n \n   /* Otherwise, emit a s[wd]l/s[wd]r pair to load the value.  */\n   if (INTVAL (operands[1]) == 64)\n@@ -5069,7 +5069,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  rtx op1 = change_address (operands[1], VOIDmode, addr);\n \n \t  scratch = gen_rtx_REG (SImode, REGNO (scratch));\n-\t  memword = change_address (op1, SImode, NULL_RTX);\n+\t  memword = adjust_address (op1, SImode, 0);\n \t  offword = change_address (adj_offsettable_operand (op1, 4),\n \t\t\t\t    SImode, NULL_RTX);\n \t  if (BYTES_BIG_ENDIAN)\n@@ -5149,7 +5149,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \t  rtx op0 = change_address (operands[0], VOIDmode, addr);\n \n \t  scratch = gen_rtx_REG (SImode, REGNO (operands[2]));\n-\t  memword = change_address (op0, SImode, NULL_RTX);\n+\t  memword = adjust_address (op0, SImode, 0);\n \t  offword = change_address (adj_offsettable_operand (op0, 4),\n \t\t\t\t    SImode, NULL_RTX);\n \t  if (BYTES_BIG_ENDIAN)\n@@ -5679,7 +5679,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* We need to get the source in SFmode so that the insn is\n      recognized.  */\n   if (GET_CODE (operands[1]) == MEM)\n-    source = change_address (operands[1], SFmode, NULL_RTX);\n+    source = adjust_address (operands[1], SFmode, 0);\n   else if (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG)\n     source = gen_rtx_REG (SFmode, true_regnum (operands[1]));\n   else"}, {"sha": "f2d0fe6d7f31c17ce6ff16020915ab96e272d2d1", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the NS32000.\n-   Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -423,23 +423,13 @@ move_tail (operands, bytes, offset)\n {\n   if (bytes & 2)\n     {\n-      rtx src, dest;\n-      dest = change_address (operands[0], HImode,\n-\t\t\t    plus_constant (XEXP (operands[0], 0), offset));\n-      src = change_address (operands[1], HImode,\n-\t\t\t   plus_constant (XEXP (operands[1], 0), offset));\n-      emit_move_insn (dest, src);\n+      emit_move_insn (adjust_address (operands[0], HImode, offset),\n+\t\t      adjust_address (operands[1], HImode, offset));\n       offset += 2;\n     }\n   if (bytes & 1)\n-    {\n-      rtx src, dest;\n-      dest = change_address (operands[0], QImode,\n-\t\t\t    plus_constant (XEXP (operands[0], 0), offset));\n-      src = change_address (operands[1], QImode,\n-\t\t\t   plus_constant (XEXP (operands[1], 0), offset));\n-      emit_move_insn (dest, src);\n-    }\n+    emit_move_insn (adjust_address (operands[0], QImode, offset),\n+\t\t    adjust_address (operands[1], QImode, offset));\n }\n \n void\n@@ -461,20 +451,16 @@ expand_block_move (operands)\n   if (constp && bytes < 20)\n     {\n       int words = bytes >> 2;\n+\n       if (words)\n \t{\n \t  if (words < 3 || flag_unroll_loops)\n \t    {\n \t      int offset = 0;\n+\n \t      for (; words; words--, offset += 4)\n-\t\t{\n-\t\t  rtx src, dest;\n-\t\t  dest = change_address (operands[0], SImode,\n-\t\t\t\t\tplus_constant (XEXP (operands[0], 0), offset));\n-\t\t  src = change_address (operands[1], SImode,\n-\t\t\t\t       plus_constant (XEXP (operands[1], 0), offset));\n-\t\t  emit_move_insn (dest, src);\n-\t\t}\n+\t\temit_move_insn (adjust_address (operands[0], SImode, offset),\n+\t\t\t\tadjust_address (operands[1], SImode, offset));\n \t    }\n \t  else\n \t    {"}, {"sha": "912be346783f8a000c536adcb548b9ee8b1aedad", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1886,8 +1886,7 @@ rs6000_emit_move (dest, source, mode)\n   if (GET_CODE (operands[1]) == MEM\n       && ! memory_address_p (mode, XEXP (operands[1], 0))\n       && ! reload_in_progress)\n-    operands[1] = change_address (operands[1], mode,\n-\t\t\t\t  XEXP (operands[1], 0));\n+    operands[1] = adjust_address (operands[1], mode, 0);\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n   return;"}, {"sha": "09710782f80c47d35dc7ff716d670abc74c5e88b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -4232,10 +4232,8 @@ sh_builtin_saveregs ()\n      named args need not be saved.  */\n   if (n_intregs > 0)\n     move_block_from_reg (BASE_ARG_REG (SImode) + first_intreg,\n-\t\t\t change_address (regbuf, BLKmode,\n-\t\t\t\t\t plus_constant (XEXP (regbuf, 0),\n-\t\t\t\t\t\t\t(n_floatregs\n-\t\t\t\t\t\t\t * UNITS_PER_WORD))), \n+\t\t\t adjust_address (regbuf, BLKmode,\n+\t\t\t\t\t n_floatregs * UNITS_PER_WORD),\n \t\t\t n_intregs, n_intregs * UNITS_PER_WORD);\n \n   /* Save float args."}, {"sha": "c6888049befb4d077b85ca88f49c2e60fc20da5c", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -2957,7 +2957,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[1], SImode, NULL_RTX);\n+  rtx word0 = adjust_address (operands[1], SImode, 0);\n   rtx word1 = change_address (operands[1], SImode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n   rtx high_part = gen_highpart (SImode, operands[0]);\n@@ -2985,7 +2985,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[0], SImode, NULL_RTX);\n+  rtx word0 = adjust_address (operands[0], SImode, 0);\n   rtx word1 = change_address (operands[0], SImode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n   rtx high_part = gen_highpart (SImode, operands[1]);\n@@ -3594,7 +3594,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[1], SFmode, NULL_RTX);\n+  rtx word0 = adjust_address (operands[1], SFmode, 0);\n   rtx word1 = change_address (operands[1], SFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n \n@@ -3629,7 +3629,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[0], SFmode, NULL_RTX);\n+  rtx word0 = adjust_address (operands[0], SFmode, 0);\n   rtx word1 = change_address (operands[0], SFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 4));\n \n@@ -3655,7 +3655,7 @@\n {\n   rtx dest1, dest2;\n \n-  dest1 = change_address (operands[0], SFmode, NULL_RTX);\n+  dest1 = adjust_address (operands[0], SFmode, 0);\n   dest2 = change_address (operands[0], SFmode,\n \t\t\t  plus_constant_for_output (XEXP (dest1, 0), 4));\n   emit_insn (gen_movsf (dest1, CONST0_RTX (SFmode)));\n@@ -3929,7 +3929,7 @@\n       dest2 = gen_df_reg (set_dest, 1);\n       break;\n     case MEM:\n-      dest1 = change_address (set_dest, DFmode, NULL_RTX);\n+      dest1 = adjust_address (set_dest, DFmode, 0);\n       dest2 = change_address (set_dest, DFmode,\n \t\t\t      plus_constant_for_output (XEXP (dest1, 0), 8));\n       break;\n@@ -3950,7 +3950,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word0 = change_address (operands[1], DFmode, NULL_RTX);\n+  rtx word0 = adjust_address (operands[1], DFmode, 0);\n   rtx word1 = change_address (operands[1], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word0, 0), 8));\n   rtx set_dest, dest1, dest2;\n@@ -3986,7 +3986,7 @@\n   [(clobber (const_int 0))]\n   \"\n {\n-  rtx word1 = change_address (operands[0], DFmode, NULL_RTX);\n+  rtx word1 = adjust_address (operands[0], DFmode, 0);\n   rtx word2 = change_address (operands[0], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word1, 0), 8));\n   rtx set_src;\n@@ -8906,10 +8906,9 @@\n     }\n \n   /* Reload the function value registers.  */\n-  emit_move_insn (valreg1, change_address (result, DImode, XEXP (result, 0)));\n+  emit_move_insn (valreg1, adjust_address (result, DImode, 0));\n   emit_move_insn (valreg2,\n-\t\t  change_address (result, TARGET_ARCH64 ? TFmode : DFmode,\n-\t\t\t\t  plus_constant (XEXP (result, 0), 8)));\n+\t\t  adjust_address (result, TARGET_ARCH64 ? TFmode : DFmode, 8));\n \n   /* Put USE insns before the return.  */\n   emit_insn (gen_rtx_USE (VOIDmode, valreg1));"}, {"sha": "1263e90ecd8134ed974be2c8ec663571ae8b198a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -399,9 +399,7 @@ expand_builtin_init_dwarf_reg_sizes (address)\n       if (offset < 0)\n \tcontinue;\n \n-      emit_move_insn (change_address (mem, mode,\n-\t\t\t\t      plus_constant (addr, offset)),\n-\t\t      GEN_INT (size));\n+      emit_move_insn (adjust_address (mem, mode, offset), GEN_INT (size));\n     }\n }\n "}, {"sha": "861e73bf3ad235a4e70b611eb05421c887655aaf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1108,7 +1108,7 @@ gen_lowpart (mode, x)\n \toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n \n-      return change_address (x, mode, plus_constant (XEXP (x, 0), offset));\n+      return adjust_address (x, mode, offset);\n     }\n   else if (GET_CODE (x) == ADDRESSOF)\n     return gen_lowpart (mode, force_reg (GET_MODE (x), x));\n@@ -1601,6 +1601,20 @@ change_address (memref, mode, addr)\n   MEM_COPY_ATTRIBUTES (new, memref);\n   return new;\n }\n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address offset by OFFSET bytes.  */\n+\n+rtx\n+adjust_address (memref, mode, offset)\n+     rtx memref;\n+     enum machine_mode mode;\n+     HOST_WIDE_INT offset;\n+{\n+  /* For now, this is just a wrapper for change_address, but eventually\n+     will do memref tracking.  */\n+  return\n+    change_address (memref, mode, plus_constant (XEXP (memref, 0), offset));\n+}\n \f\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n "}, {"sha": "e298329411f6266211f48d5706cd27c5d13b432a", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -2038,9 +2038,8 @@ sjlj_mark_call_sites (lp_info)\n   int last_call_site = -2;\n   rtx insn, mem;\n \n-  mem = change_address (cfun->eh->sjlj_fc, TYPE_MODE (integer_type_node),\n-\t\t\tplus_constant (XEXP (cfun->eh->sjlj_fc, 0),\n-\t\t\t\t       sjlj_fc_call_site_ofs));\n+  mem = adjust_address (cfun->eh->sjlj_fc, TYPE_MODE (integer_type_node),\n+\t\t\tsjlj_fc_call_site_ofs);\n \n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n@@ -2156,12 +2155,10 @@ sjlj_emit_function_enter (dispatch_label)\n      calling it directly.  Thus, we must call assemble_external_libcall\n      here, as we can not depend on emit_library_call to do it for us.  */\n   assemble_external_libcall (eh_personality_libfunc);\n-  mem = change_address (fc, Pmode,\n-\t\t\tplus_constant (XEXP (fc, 0), sjlj_fc_personality_ofs));\n+  mem = adjust_address (fc, Pmode, sjlj_fc_personality_ofs);\n   emit_move_insn (mem, eh_personality_libfunc);\n \n-  mem = change_address (fc, Pmode,\n-\t\t\tplus_constant (XEXP (fc, 0), sjlj_fc_lsda_ofs));\n+  mem = adjust_address (fc, Pmode, sjlj_fc_lsda_ofs);\n   if (cfun->uses_eh_lsda)\n     {\n       char buf[20];\n@@ -2258,12 +2255,11 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n \n   /* Load up dispatch index, exc_ptr and filter values from the\n      function context.  */\n-  mem = change_address (fc, TYPE_MODE (integer_type_node),\n-\t\t\tplus_constant (XEXP (fc, 0), sjlj_fc_call_site_ofs));\n+  mem = adjust_address (fc, TYPE_MODE (integer_type_node),\n+\t\t\tsjlj_fc_call_site_ofs);\n   dispatch = copy_to_reg (mem);\n \n-  mem = change_address (fc, word_mode,\n-\t\t\tplus_constant (XEXP (fc, 0), sjlj_fc_data_ofs));\n+  mem = adjust_address (fc, word_mode, sjlj_fc_data_ofs);\n   if (word_mode != Pmode)\n     {\n #ifdef POINTERS_EXTEND_UNSIGNED\n@@ -2274,9 +2270,7 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n     }\n   emit_move_insn (cfun->eh->exc_ptr, mem);\n \n-  mem = change_address (fc, word_mode,\n-\t\t\tplus_constant (XEXP (fc, 0),\n-\t\t\t\t       sjlj_fc_data_ofs + UNITS_PER_WORD));\n+  mem = adjust_address (fc, word_mode, sjlj_fc_data_ofs + UNITS_PER_WORD);\n   emit_move_insn (cfun->eh->filter, mem);\n \n   /* Jump to one of the directly reachable regions.  */"}, {"sha": "0a9b41cfdf4d2a7130bec15252a1ee0c5e84d496", "filename": "gcc/expmed.c", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -315,8 +315,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n \t\t\t\t  + (offset * UNITS_PER_WORD));\n \t  else\n-\t    op0 = change_address (op0, fieldmode,\n-\t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n+\t    op0 = adjust_address (op0, fieldmode, offset);\n \t}\n       emit_move_insn (op0, value);\n       return value;\n@@ -331,7 +330,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     if (imode != GET_MODE (op0))\n       {\n \tif (GET_CODE (op0) == MEM)\n-\t  op0 = change_address (op0, imode, NULL_RTX);\n+\t  op0 = adjust_address (op0, imode, 0);\n \telse if (imode != BLKmode)\n \t  op0 = gen_lowpart (imode, op0);\n \telse\n@@ -532,8 +531,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t  /* Compute offset as multiple of this unit, counting in bytes.  */\n \t  offset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n \t  bitpos = bitnum % unit;\n-\t  op0 = change_address (op0, bestmode, \n-\t\t\t\tplus_constant (XEXP (op0, 0), offset));\n+\t  op0 = adjust_address (op0, bestmode,  offset);\n \n \t  /* Fetch that unit, store the bitfield in it, then store\n \t     the unit.  */\n@@ -547,8 +545,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \n       /* Add OFFSET into OP0's address.  */\n       if (GET_CODE (xop0) == MEM)\n-\txop0 = change_address (xop0, byte_mode,\n-\t\t\t       plus_constant (XEXP (xop0, 0), offset));\n+\txop0 = adjust_address (xop0, byte_mode, offset);\n \n       /* If xop0 is a register, we need it in MAXMODE\n \t to make it acceptable to the format of insv.  */\n@@ -710,8 +707,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n \t Then alter OP0 to refer to that word.  */\n       bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n       offset -= (offset % (total_bits / BITS_PER_UNIT));\n-      op0 = change_address (op0, mode,\n-\t\t\t    plus_constant (XEXP (op0, 0), offset));\n+      op0 = adjust_address (op0, mode, offset);\n     }\n \n   mode = GET_MODE (op0);\n@@ -1048,7 +1044,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     if (imode != GET_MODE (op0))\n       {\n \tif (GET_CODE (op0) == MEM)\n-\t  op0 = change_address (op0, imode, NULL_RTX);\n+\t  op0 = adjust_address (op0, imode, 0);\n \telse if (imode != BLKmode)\n \t  op0 = gen_lowpart (imode, op0);\n \telse\n@@ -1115,8 +1111,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t\t  (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n \t\t\t\t  + (offset * UNITS_PER_WORD));\n \t  else\n-\t    op0 = change_address (op0, mode1,\n-\t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n+\t    op0 = adjust_address (op0, mode1, offset);\n \t}\n       if (mode1 != mode)\n \treturn convert_to_mode (tmode, op0, unsignedp);\n@@ -1291,18 +1286,16 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t  unit = GET_MODE_BITSIZE (bestmode);\n \t\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n \t\t  xbitpos = bitnum % unit;\n-\t\t  xop0 = change_address (xop0, bestmode,\n-\t\t\t\t\t plus_constant (XEXP (xop0, 0),\n-\t\t\t\t\t\t\txoffset));\n+\t\t  xop0 = adjust_address (xop0, bestmode, xoffset);\n+\n \t\t  /* Fetch it to a register in that size.  */\n \t\t  xop0 = force_reg (bestmode, xop0);\n \n \t\t  /* XBITPOS counts within UNIT, which is what is expected.  */\n \t\t}\n \t      else\n \t\t/* Get ref to first byte containing part of the field.  */\n-\t\txop0 = change_address (xop0, byte_mode,\n-\t\t\t\t       plus_constant (XEXP (xop0, 0), xoffset));\n+\t\txop0 = adjust_address (xop0, byte_mode, xoffset);\n \n \t      volatile_ok = save_volatile_ok;\n \t    }\n@@ -1428,18 +1421,16 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t  unit = GET_MODE_BITSIZE (bestmode);\n \t\t  xoffset = (bitnum / unit) * GET_MODE_SIZE (bestmode);\n \t\t  xbitpos = bitnum % unit;\n-\t\t  xop0 = change_address (xop0, bestmode,\n-\t\t\t\t\t plus_constant (XEXP (xop0, 0),\n-\t\t\t\t\t\t\txoffset));\n+\t\t  xop0 = adjust_address (xop0, bestmode, xoffset);\n+\n \t\t  /* Fetch it to a register in that size.  */\n \t\t  xop0 = force_reg (bestmode, xop0);\n \n \t\t  /* XBITPOS counts within UNIT, which is what is expected.  */\n \t\t}\n \t      else\n \t\t/* Get ref to first byte containing part of the field.  */\n-\t\txop0 = change_address (xop0, byte_mode,\n-\t\t\t\t       plus_constant (XEXP (xop0, 0), xoffset));\n+\t\txop0 = adjust_address (xop0, byte_mode, xoffset);\n \t    }\n \n \t  /* If op0 is a register, we need it in MAXMODE (which is usually\n@@ -1606,8 +1597,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n \t Then alter OP0 to refer to that word.  */\n       bitpos += (offset % (total_bits / BITS_PER_UNIT)) * BITS_PER_UNIT;\n       offset -= (offset % (total_bits / BITS_PER_UNIT));\n-      op0 = change_address (op0, mode,\n-\t\t\t    plus_constant (XEXP (op0, 0), offset));\n+      op0 = adjust_address (op0, mode, offset);\n     }\n \n   mode = GET_MODE (op0);"}, {"sha": "a83194a1ef991a3f9e3d34bfbb930826bb96b1cd", "filename": "gcc/expr.c", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1581,8 +1581,7 @@ move_by_pieces_1 (genfun, mode, data)\n \t      MEM_COPY_ATTRIBUTES (to1, data->to);\n \t    }\n \t  else\n-\t    to1 = change_address (data->to, mode,\n-\t\t\t\t  plus_constant (data->to_addr, data->offset));\n+\t    to1 = adjust_address (data->to, mode, data->offset);\n \t}\n \n       if (data->autinc_from)\n@@ -1591,8 +1590,7 @@ move_by_pieces_1 (genfun, mode, data)\n \t  MEM_COPY_ATTRIBUTES (from1, data->from);\n \t}\n       else\n-\tfrom1 = change_address (data->from, mode,\n-\t\t\t\tplus_constant (data->from_addr, data->offset));\n+\tfrom1 = adjust_address (data->from, mode, data->offset);\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n \temit_insn (gen_add2_insn (data->to_addr, GEN_INT (-size)));\n@@ -2005,10 +2003,7 @@ emit_group_load (dst, orig_src, ssize, align)\n \t  && bytelen == GET_MODE_SIZE (mode))\n \t{\n \t  tmps[i] = gen_reg_rtx (mode);\n-\t  emit_move_insn (tmps[i],\n-\t\t\t  change_address (src, mode,\n-\t\t\t\t\t  plus_constant (XEXP (src, 0),\n-\t\t\t\t\t\t\t bytepos)));\n+\t  emit_move_insn (tmps[i], adjust_address (src, mode, bytepos));\n \t}\n       else if (GET_CODE (src) == CONCAT)\n \t{\n@@ -2128,13 +2123,10 @@ emit_group_store (orig_dst, src, ssize, align)\n \t  && align >= GET_MODE_ALIGNMENT (mode)\n \t  && bytepos * BITS_PER_UNIT % GET_MODE_ALIGNMENT (mode) == 0\n \t  && bytelen == GET_MODE_SIZE (mode))\n-\temit_move_insn (change_address (dst, mode,\n-\t\t\t\t\tplus_constant (XEXP (dst, 0),\n-\t\t\t\t\t\t       bytepos)),\n-\t\t\ttmps[i]);\n+\temit_move_insn (adjust_address (dst, mode, bytepos), tmps[i]);\n       else\n \tstore_bit_field (dst, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n-\t\t\t   mode, tmps[i], align, ssize);\n+\t\t\t mode, tmps[i], align, ssize);\n     }\n \n   emit_queue ();\n@@ -2521,8 +2513,7 @@ store_by_pieces_2 (genfun, mode, data)\n \t  MEM_COPY_ATTRIBUTES (to1, data->to);\n \t}\n       else\n-\tto1 = change_address (data->to, mode,\n-\t\t\t      plus_constant (data->to_addr, data->offset));\n+\tto1 = adjust_address (data->to, mode, data->offset);\n \n       if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)\n \temit_insn (gen_add2_insn (data->to_addr,\n@@ -2911,7 +2902,7 @@ emit_move_insn_1 (x, y)\n \t\t    {\n \t\t      rtx mem = assign_stack_temp (reg_mode,\n \t\t\t\t\t\t   GET_MODE_SIZE (mode), 0);\n-\t\t      rtx cmem = change_address (mem, mode, NULL_RTX);\n+\t\t      rtx cmem = adjust_address (mem, mode, 0);\n \n \t\t      cfun->cannot_inline\n \t\t\t= N_(\"function using short complex types cannot be inline\");\n@@ -3265,8 +3256,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t because registers will take care of them.  */\n \n       if (partial != 0)\n-\txinner = change_address (xinner, BLKmode,\n-\t\t\t\t plus_constant (XEXP (xinner, 0), used));\n+\txinner = adjust_address (xinner, BLKmode, used);\n \n       /* If the partial register-part of the arg counts in its stack size,\n \t skip the part of stack space corresponding to the registers.\n@@ -3725,10 +3715,9 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t      && (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t      && alignment == GET_MODE_ALIGNMENT (mode1))\n \t    {\n-\t      rtx temp = change_address (to_rtx, mode1,\n-\t\t\t\t         plus_constant (XEXP (to_rtx, 0),\n-\t\t\t\t\t\t        (bitpos /\n-\t\t\t\t\t\t         BITS_PER_UNIT)));\n+\t      rtx temp\n+\t\t= adjust_address (to_rtx, mode1, bitpos / BITS_PER_UNIT);\n+\n \t      if (GET_CODE (XEXP (temp, 0)) == REG)\n \t        to_rtx = temp;\n \t      else\n@@ -3810,9 +3799,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  unsigned int from_align;\n \t  rtx from_rtx = expand_expr_unaligned (from, &from_align);\n \t  rtx inner_to_rtx\n-\t    = change_address (to_rtx, BLKmode,\n-\t\t\t      plus_constant (XEXP (to_rtx, 0),\n-\t\t\t\t\t     bitpos / BITS_PER_UNIT));\n+\t    = adjust_address (to_rtx, BLKmode, bitpos / BITS_PER_UNIT);\n \n \t  emit_block_move (inner_to_rtx, from_rtx, expr_size (from),\n \t\t\t   MIN (alignment, from_align));\n@@ -4459,13 +4446,11 @@ store_constructor_field (target, bitsize, bitpos,\n     {\n       if (bitpos != 0)\n \ttarget\n-\t  = change_address (target,\n+\t  = adjust_address (target,\n \t\t\t    GET_MODE (target) == BLKmode\n \t\t\t    || 0 != (bitpos\n \t\t\t\t     % GET_MODE_ALIGNMENT (GET_MODE (target)))\n-\t\t\t    ? BLKmode : VOIDmode,\n-\t\t\t    plus_constant (XEXP (target, 0),\n-\t\t\t\t\t   bitpos / BITS_PER_UNIT));\n+\t\t\t    ? BLKmode : VOIDmode, bitpos / BITS_PER_UNIT);\n \n \n       /* Show the alignment may no longer be what it was and update the alias\n@@ -4991,10 +4976,7 @@ store_constructor (exp, target, align, cleared, size)\n \t\t\t XEXP if the set is multi-word, but not if\n \t\t\t it's single-word.  */\n \t\t      if (GET_CODE (target) == MEM)\n-\t\t\t{\n-\t\t\t  to_rtx = plus_constant (XEXP (target, 0), offset);\n-\t\t\t  to_rtx = change_address (target, mode, to_rtx);\n-\t\t\t}\n+\t\t\tto_rtx = adjust_address (target, mode, offset);\n \t\t      else if (offset == 0)\n \t\t\tto_rtx = target;\n \t\t      else\n@@ -5252,9 +5234,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t      || bitpos % BITS_PER_UNIT != 0)\n \t    abort ();\n \n-\t  target = change_address (target, VOIDmode,\n-\t\t\t\t   plus_constant (XEXP (target, 0),\n-\t\t\t\t\t\tbitpos / BITS_PER_UNIT));\n+\t  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);\n \n \t  /* Make sure that ALIGN is no stricter than the alignment of EXP.  */\n \t  align = MIN (exp_align, align);\n@@ -7079,10 +7059,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n \t\t&& alignment == GET_MODE_ALIGNMENT (mode1))\n \t      {\n-\t\trtx temp = change_address (op0, mode1,\n-\t\t\t\t\t   plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t\t  (bitpos /\n-\t\t\t\t\t\t\t   BITS_PER_UNIT)));\n+\t\trtx temp = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n+\n \t\tif (GET_CODE (XEXP (temp, 0)) == REG)\n \t\t  op0 = temp;\n \t\telse\n@@ -7181,9 +7159,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t    || bitpos % BITS_PER_UNIT != 0)\n \t\t  abort ();\n \n-\t\top0 = change_address (op0, VOIDmode,\n-\t\t\t\t      plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t     bitpos / BITS_PER_UNIT));\n+\t\top0 = adjust_address (op0, VOIDmode, bitpos / BITS_PER_UNIT);\n \t\tif (target == 0)\n \t\t  target = assign_temp (type, 0, 1, 1);\n \n@@ -7248,9 +7224,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    op0 = new;\n \t  }\n \telse\n-\t  op0 = change_address (op0, mode1,\n-\t\t\t\tplus_constant (XEXP (op0, 0),\n-\t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n+\t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n \tset_mem_attributes (op0, exp, 0);\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n@@ -7450,7 +7424,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (GET_CODE (target) == MEM)\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n-\t\t\tchange_address (target, TYPE_MODE (valtype), 0), 0);\n+\t\t\tadjust_address (target, TYPE_MODE (valtype), 0), 0);\n \n \t  else if (GET_CODE (target) == REG)\n \t    /* Store this field into a union of the proper type.  */\n@@ -9122,9 +9096,7 @@ expand_expr_unaligned (exp, palign)\n \t\t    || bitpos % BITS_PER_UNIT != 0)\n \t\t  abort ();\n \n-\t\top0 = change_address (op0, VOIDmode,\n-\t\t\t\t      plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t     bitpos / BITS_PER_UNIT));\n+\t\top0 = adjust_address (op0, VOIDmode, bitpos / BITS_PER_UNIT);\n \t      }\n \t    else\n \t      {\n@@ -9156,9 +9128,7 @@ expand_expr_unaligned (exp, palign)\n \t  }\n \telse\n \t  /* Get a reference to just this component.  */\n-\t  op0 = change_address (op0, mode1,\n-\t\t\t\tplus_constant (XEXP (op0, 0),\n-\t\t\t\t\t       (bitpos / BITS_PER_UNIT)));\n+\t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n \tMEM_ALIAS_SET (op0) = get_alias_set (exp);\n "}, {"sha": "9dff8e931a88a1c2d7a5cea644de950d6cb7c781", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -1150,6 +1150,10 @@ extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n    NULL for ADDR means don't change the address.)  */\n extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n \n+/* Return a memory reference like MEMREF, but with its mode changed\n+   to MODE and its address offset by OFFSET bytes.  */\n+extern rtx adjust_address PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n+\n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n extern rtx validize_mem PARAMS ((rtx));"}, {"sha": "8ab0037fcf3e3f5df2a394ad1eb9966f7fdd9955", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4ef873c3108a163d7789b137b391c3853c25011/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f4ef873c3108a163d7789b137b391c3853c25011", "patch": "@@ -2518,12 +2518,13 @@ fixup_memory_subreg (x, insn, uncritical)\n       && ! uncritical)\n     abort ();\n \n-  addr = plus_constant (addr, offset);\n-  if (!flag_force_addr && memory_address_p (mode, addr))\n+  if (!flag_force_addr\n+      && memory_address_p (mode, plus_constant (addr, offset)))\n     /* Shortcut if no insns need be emitted.  */\n-    return change_address (SUBREG_REG (x), mode, addr);\n+    return adjust_address (SUBREG_REG (x), mode, offset);\n+\n   start_sequence ();\n-  result = change_address (SUBREG_REG (x), mode, addr);\n+  result = adjust_address (SUBREG_REG (x), mode, offset);\n   emit_insn_before (gen_sequence (), insn);\n   end_sequence ();\n   return result;\n@@ -2721,8 +2722,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t    }\n \n \t  start_sequence ();\n-\t  memref = change_address (memref, mode,\n-\t\t\t\t   plus_constant (XEXP (memref, 0), offset));\n+\t  memref = adjust_address (memref, mode, offset);\n \t  insns = get_insns ();\n \t  end_sequence ();\n \t  emit_insns_before (insns, insn);\n@@ -4987,11 +4987,9 @@ assign_parms (fndecl)\n \t      entry_parm = convert_to_mode (nominal_mode, tempreg,\n \t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (parm)));\n \t      if (stack_parm)\n-\t\t{\n-\t\t  /* ??? This may need a big-endian conversion on sparc64.  */\n-\t\t  stack_parm = change_address (stack_parm, nominal_mode,\n-\t\t\t\t\t       NULL_RTX);\n-\t\t}\n+\t\t/* ??? This may need a big-endian conversion on sparc64.  */\n+\t\tstack_parm = adjust_address (stack_parm, nominal_mode, 0);\n+\n \t      conversion_insns = get_insns ();\n \t      did_conversion = 1;\n \t      end_sequence ();"}]}