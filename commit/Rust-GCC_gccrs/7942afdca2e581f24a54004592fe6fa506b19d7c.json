{"sha": "7942afdca2e581f24a54004592fe6fa506b19d7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0MmFmZGNhMmU1ODFmMjRhNTQwMDQ1OTJmZTZmYTUwNmIxOWQ3Yw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-07-17T01:54:44Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-07-17T01:54:44Z"}, "message": "locale_facets.h (__num_base::_S_atoms_in): Add -+xX.\n\n\n2003-07-16  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/locale_facets.h (__num_base::_S_atoms_in): Add -+xX.\n\t(num_get::_M_convert_int): To _M_insert_int.\n\t(num_get::_M_convert_float): To _M_insert_float.\n\t* include/bits/locale_facets.tcc (num_get::_M_extract_float):\n\tUse caches for ctype, num_get.\n\t(num_get::_M_extract_int): Same.\n\t(num_get::get(bool)): Same.\n\t(__verify_grouping): Use size_t.\n\t* src/locale-inst.cc: Update.\n\t* src/locale.cc: Adjust _S_atoms_in.\n\nFrom-SVN: r69491", "tree": {"sha": "14877f563ae13b78a71b057a66ec6c1290a6b05e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14877f563ae13b78a71b057a66ec6c1290a6b05e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7942afdca2e581f24a54004592fe6fa506b19d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7942afdca2e581f24a54004592fe6fa506b19d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7942afdca2e581f24a54004592fe6fa506b19d7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7942afdca2e581f24a54004592fe6fa506b19d7c/comments", "author": null, "committer": null, "parents": [{"sha": "03988cac5874b40b3e9e2897daeba097cbe4aff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03988cac5874b40b3e9e2897daeba097cbe4aff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03988cac5874b40b3e9e2897daeba097cbe4aff9"}], "stats": {"total": 339, "additions": 174, "deletions": 165}, "files": [{"sha": "6510aa0f7b093947e95ab49dfb5918fc6fd32a9d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7942afdca2e581f24a54004592fe6fa506b19d7c", "patch": "@@ -1,3 +1,16 @@\n+2003-07-16  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/locale_facets.h (__num_base::_S_atoms_in): Add -+xX.\n+\t(num_get::_M_convert_int): To _M_insert_int.\n+\t(num_get::_M_convert_float): To _M_insert_float.\t\n+\t* include/bits/locale_facets.tcc (num_get::_M_extract_float):\n+\tUse caches for ctype, num_get.\n+\t(num_get::_M_extract_int): Same.\n+\t(num_get::get(bool)): Same.\n+\t(__verify_grouping): Use size_t.\n+\t* src/locale-inst.cc: Update.\n+\t* src/locale.cc: Adjust _S_atoms_in.\n+\n 2003-07-16  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/doxygen/mainpage.html:  Move building/writing instructions..."}, {"sha": "7bea5eac5099759c2bd2ec1b011bc63a79bedb26", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=7942afdca2e581f24a54004592fe6fa506b19d7c", "patch": "@@ -557,15 +557,19 @@ namespace std\n     static const char* _S_atoms_out;\n \n     // String literal of acceptable (narrow) input, for num_get.\n-    // \"0123456789eEabcdfABCDF\"\n+    // \"-+xX0123456789eEabcdfABCDF\"\n     static const char* _S_atoms_in;\n \n     enum \n     {  \n+      _S_iminus, \n+      _S_iplus, \n+      _S_ix, \n+      _S_iX, \n       _S_izero,\n       _S_ie = _S_izero + 10,\n       _S_iE = _S_izero + 11,\n-      _S_iend = 21 + 1\n+      _S_iend = 26\n     };\n \n     // num_put\n@@ -590,8 +594,8 @@ namespace std\n       // through the current locale's ctype<_CharT>.widen().\n       _CharT                    \t_M_atoms_out[__num_base::_S_oend + 1];\n \n-      // A list of valid numeric literals for output: in the standard\n-      // \"C\" locale, this is \"0123456789eEabcdfABCDF\"\n+      // A list of valid numeric literals for input: in the standard\n+      // \"C\" locale, this is \"-+xX0123456789eEabcdfABCDF\"\n       // This array contains the chars after having been passed\n       // through the current locale's ctype<_CharT>.widen().\n       _CharT                    \t_M_atoms_in[__num_base::_S_iend + 1];\n@@ -983,8 +987,8 @@ namespace std\n     protected:\n       template<typename _ValueT>\n         iter_type\n-        _M_convert_float(iter_type, ios_base& __io, char_type __fill, \n-\t\t\t char __mod, _ValueT __v) const;\n+        _M_insert_float(iter_type, ios_base& __io, char_type __fill, \n+\t\t\tchar __mod, _ValueT __v) const;\n \n       void\n       _M_group_float(const string& __grouping, char_type __sep, \n@@ -993,8 +997,8 @@ namespace std\n \n       template<typename _ValueT>\n         iter_type\n-        _M_convert_int(iter_type, ios_base& __io, char_type __fill, \n-\t\t       _ValueT __v) const;\n+        _M_insert_int(iter_type, ios_base& __io, char_type __fill, \n+\t\t      _ValueT __v) const;\n \n       void\n       _M_group_int(const string& __grouping, char_type __sep, "}, {"sha": "f724ea27eac770b6303af160f54b33d6bd0946f0", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 123, "deletions": 131, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=7942afdca2e581f24a54004592fe6fa506b19d7c", "patch": "@@ -122,35 +122,34 @@ namespace std\n       }\n     };\n \n-  // Stage 1: Determine a conversion specifier.\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n     _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t     ios_base::iostate& __err, string& __xtrc) const\n     {\n-      typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      typedef char_traits<_CharT>\t\t\t__traits_type;\n+      typedef typename numpunct<_CharT>::__cache_type  \t__cache_type;\n+      __use_cache<__cache_type> __uc;\n+      const locale& __loc = __io._M_getloc();\n+      const __cache_type* __lc = __uc(__loc);\n+      const _CharT* __lit = __lc->_M_atoms_in;\n \n       // First check for sign.\n-      const char_type __plus = __ctype.widen('+');\n-      const char_type __minus = __ctype.widen('-');\n       int __pos = 0;\n       char_type  __c = *__beg;\n-      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))\n+      bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n+      if ((__plus || __traits_type::eq(__c, __lit[_S_iminus])) \n \t  && __beg != __end)\n \t{\n-\t  __xtrc += __ctype.narrow(__c, char());\n+\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] : _S_atoms_in[_S_iminus];\n \t  ++__pos;\n \t  __c = *(++__beg);\n \t}\n \n       // Next, strip leading zeros.\n-      const char_type __zero = __ctype.widen(_S_atoms_in[_S_izero]);\n       bool __found_zero = false;\n-      while (__traits_type::eq(__c, __zero) && __beg != __end)\n+      while (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n \t{\n \t  __c = *(++__beg);\n \t  __found_zero = true;\n@@ -162,35 +161,29 @@ namespace std\n \t}\n \n       // Only need acceptable digits for floating point numbers.\n-      const size_t __len = _S_iE - _S_izero + 1;\n-      char_type  __watoms[__len];\n-      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);\n       bool __found_dec = false;\n       bool __found_sci = false;\n-      const char_type __dec = __np.decimal_point();\n-\n       string __found_grouping;\n-      const string __grouping = __np.grouping();\n-      bool __check_grouping = __grouping.size();\n+      const size_t __len = _S_iE - _S_izero + 1;\n       int __sep_pos = 0;\n-      const char_type __sep = __np.thousands_sep();\n-\n+      bool __e;\n       while (__beg != __end)\n         {\n \t  // Only look in digits.\n-          const char_type* __p = __traits_type::find(__watoms, 10,  __c);\n+          const char_type* __p = __traits_type::find(__lit + _S_izero, 10, \n+\t\t\t\t\t\t     __c);\n \n           // NB: strchr returns true for __c == 0x0\n           if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n \t      ++__pos;\n-\t      __xtrc += _S_atoms_in[__p - __watoms];\n+\t      __xtrc += _S_atoms_in[__p - __lit];\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n-          else if (__traits_type::eq(__c, __sep) \n-\t\t   && __check_grouping && !__found_dec)\n+          else if (__traits_type::eq(__c, __lc->_M_thousands_sep) \n+\t\t   &&  __lc->_M_use_grouping && !__found_dec)\n \t    {\n               // NB: Thousands separator at the beginning of a string\n               // is a no-no, as is two consecutive thousands separators.\n@@ -206,7 +199,8 @@ namespace std\n \t\t  break;\n \t\t}\n             }\n-\t  else if (__traits_type::eq(__c, __dec) && !__found_dec)\n+\t  else if (__traits_type::eq(__c, __lc->_M_decimal_point) \n+\t\t   && !__found_dec)\n \t    {\n \t      // According to the standard, if no grouping chars are seen,\n \t      // no grouping check is applied. Therefore __found_grouping\n@@ -218,21 +212,22 @@ namespace std\n \t      __c = *(++__beg);\n \t      __found_dec = true;\n \t    }\n-\t  else if ((__traits_type::eq(__c, __watoms[_S_ie]) \n-\t\t    || __traits_type::eq(__c, __watoms[_S_iE])) \n+\t  else if ((__e = __traits_type::eq(__c, __lit[_S_ie]) \n+\t\t    || __traits_type::eq(__c, __lit[_S_iE])) \n \t\t   && !__found_sci && __pos)\n \t    {\n \t      // Scientific notation.\n \t      ++__pos;\n-\t      __xtrc += __ctype.narrow(__c, char());\n+\t      __xtrc += __e ? _S_atoms_in[_S_ie] : _S_atoms_in[_S_iE];\n \t      __c = *(++__beg);\n \n \t      // Remove optional plus or minus sign, if they exist.\n-\t      if (__traits_type::eq(__c, __plus) \n-\t\t  || __traits_type::eq(__c, __minus))\n+\t      bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n+\t      if (__plus || __traits_type::eq(__c, __lit[_S_iminus]))\n \t\t{\n \t\t  ++__pos;\n-\t\t  __xtrc += __ctype.narrow(__c, char());\n+\t\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] \n+\t\t                   : _S_atoms_in[_S_iminus];\n \t\t  __c = *(++__beg);\n \t\t}\n \t      __found_sci = true;\n@@ -244,33 +239,36 @@ namespace std\n \n       // Digit grouping is checked. If grouping and found_grouping don't\n       // match, then get very very upset, and set failbit.\n-      if (__check_grouping && __found_grouping.size())\n+      if (__lc->_M_use_grouping && __found_grouping.size())\n         {\n           // Add the ending grouping if a decimal wasn't found.\n \t  if (!__found_dec)\n \t    __found_grouping += static_cast<char>(__sep_pos);\n+\n+\t  const string __grouping = __lc->_M_grouping;\n           if (!std::__verify_grouping(__grouping, __found_grouping))\n \t    __err |= ios_base::failbit;\n         }\n \n-      // Finish up\n+      // Finish up.\n       __xtrc += char();\n       if (__beg == __end)\n         __err |= ios_base::eofbit;\n       return __beg;\n     }\n \n-  // Stage 1: Determine a conversion specifier.\n   template<typename _CharT, typename _InIter>\n     _InIter\n     num_get<_CharT, _InIter>::\n     _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t   ios_base::iostate& __err, string& __xtrc, int& __base) const\n     {\n-      typedef char_traits<_CharT>\t\t__traits_type;\n-      const locale __loc = __io.getloc();\n-      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n-      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n+      typedef char_traits<_CharT>\t\t\t__traits_type;\n+      typedef typename numpunct<_CharT>::__cache_type  \t__cache_type;\n+      __use_cache<__cache_type> __uc;\n+      const locale& __loc = __io._M_getloc();\n+      const __cache_type* __lc = __uc(__loc);\n+      const _CharT* __lit = __lc->_M_atoms_in;\n  \n       // NB: Iff __basefield == 0, this can change based on contents.\n       ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n@@ -284,25 +282,20 @@ namespace std\n       // First check for sign.\n       int __pos = 0;\n       char_type  __c = *__beg;\n-      const char_type __plus = __ctype.widen('+');\n-      const char_type __minus = __ctype.widen('-');\n-\n-      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))\n+      const bool __plus = __traits_type::eq(__c, __lit[_S_iplus]);\n+      if ((__plus || __traits_type::eq(__c, __lit[_S_iminus])) \n \t  && __beg != __end)\n \t{\n-\t  __xtrc += __ctype.narrow(__c, char());\n+\t  __xtrc += __plus ? _S_atoms_in[_S_iplus] : _S_atoms_in[_S_iminus];\n \t  ++__pos;\n \t  __c = *(++__beg);\n \t}\n \n       // Next, strip leading zeros and check required digits for base formats.\n-      const char_type __zero = __ctype.widen(_S_atoms_in[_S_izero]);\n-      const char_type __x = __ctype.widen('x');\n-      const char_type __X = __ctype.widen('X');\n       if (__base == 10)\n \t{\n \t  bool __found_zero = false;\n-\t  while (__traits_type::eq(__c, __zero) && __beg != __end)\n+\t  while (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n \t    {\n \t      __c = *(++__beg);\n \t      __found_zero = true;\n@@ -313,11 +306,11 @@ namespace std\n \t      ++__pos;\n \t      if (__basefield == 0)\n \t\t{\t      \n-\t\t  if ((__traits_type::eq(__c, __x) \n-\t\t       || __traits_type::eq(__c, __X))\n-\t\t      && __beg != __end)\n+\t\t  const bool __x = __traits_type::eq(__c, __lit[_S_ix]);\n+\t\t  const bool __X = __traits_type::eq(__c, __lit[_S_iX]);\n+\t\t  if ((__x || __X) && __beg != __end)\n \t\t    {\n-\t\t      __xtrc += __ctype.narrow(__c, char());\n+\t\t      __xtrc += __x ? _S_atoms_in[_S_ix] : _S_atoms_in[_S_iX];\n \t\t      ++__pos;\n \t\t      __c = *(++__beg);\n \t\t      __base = 16;\n@@ -329,15 +322,17 @@ namespace std\n \t}\n       else if (__base == 16)\n \t{\n-\t  if (__traits_type::eq(__c, __zero) && __beg != __end)\n+\t  if (__traits_type::eq(__c, __lit[_S_izero]) && __beg != __end)\n \t    {\n \t      __xtrc += _S_atoms_in[_S_izero];\n \t      ++__pos;\n \t      __c = *(++__beg); \n-\t      if ((__traits_type::eq(__c, __x) || __traits_type::eq(__c, __X))\n-\t\t  && __beg != __end)\n+\n+\t      const bool __x = __traits_type::eq(__c, __lit[_S_ix]);\n+\t      const bool __X = __traits_type::eq(__c, __lit[_S_iX]);\n+\t      if ((__x || __X) && __beg != __end)\n \t\t{\n-\t\t  __xtrc += __ctype.narrow(__c, char());\n+\t\t  __xtrc += __x ? _S_atoms_in[_S_ix] : _S_atoms_in[_S_iX];\n \t\t  ++__pos;\n \t\t  __c = *(++__beg);\n \t\t}\n@@ -353,27 +348,24 @@ namespace std\n \t__len = __base;\n \n       // Extract.\n-      char_type __watoms[_S_iend];\n-      __ctype.widen(_S_atoms_in, _S_atoms_in + __len, __watoms);\n       string __found_grouping;\n-      const string __grouping = __np.grouping();\n-      bool __check_grouping = __grouping.size();\n+      const char_type __sep = __lc->_M_thousands_sep;\n       int __sep_pos = 0;\n-      const char_type __sep = __np.thousands_sep();\n       while (__beg != __end)\n         {\n-          const char_type* __p = __traits_type::find(__watoms, __len,  __c);\n+          const char_type* __p = __traits_type::find(__lit + _S_izero, \n+\t\t\t\t\t\t     __len,  __c);\n \n           // NB: strchr returns true for __c == 0x0\n           if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n-\t      __xtrc += _S_atoms_in[__p - __watoms];\n+\t      __xtrc += _S_atoms_in[__p - __lit];\n \t      ++__pos;\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n-          else if (__traits_type::eq(__c, __sep) && __check_grouping)\n+          else if (__traits_type::eq(__c, __sep) && __lc->_M_use_grouping)\n \t    {\n               // NB: Thousands separator at the beginning of a string\n               // is a no-no, as is two consecutive thousands separators.\n@@ -396,10 +388,12 @@ namespace std\n \n       // Digit grouping is checked. If grouping and found_grouping don't\n       // match, then get very very upset, and set failbit.\n-      if (__check_grouping && __found_grouping.size())\n+      if (__lc->_M_use_grouping && __found_grouping.size())\n         {\n           // Add the ending grouping.\n           __found_grouping += static_cast<char>(__sep_pos);\n+\n+\t  const string __grouping = __lc->_M_grouping;\n           if (!std::__verify_grouping(__grouping, __found_grouping))\n \t    __err |= ios_base::failbit;\n         }\n@@ -419,56 +413,57 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, bool& __v) const\n     {\n-      // Parse bool values as unsigned long\n       if (!(__io.flags() & ios_base::boolalpha))\n         {\n+\t  // Parse bool values as unsigned long.\n           // NB: We can't just call do_get(long) here, as it might\n           // refer to a derived class.\n           string __xtrc;\n           int __base;\n           __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n \t  unsigned long __ul; \n-\t  std::__convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);\n+\t  std::__convert_to_v(__xtrc.c_str(), __ul, __err, \n+\t\t\t      _S_c_locale, __base);\n \t  if (!(__err & ios_base::failbit) && __ul <= 1)\n \t    __v = __ul;\n \t  else \n             __err |= ios_base::failbit;\n         }\n-\n-      // Parse bool values as alphanumeric\n       else\n         {\n+\t  // Parse bool values as alphanumeric.\n \t  typedef char_traits<_CharT>\t      \t__traits_type;\n-\t  typedef basic_string<_CharT>   \t__string_type;\n-\n-          locale __loc = __io.getloc();\n-\t  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc); \n-\t  const __string_type __true = __np.truename();\n-\t  const __string_type __false = __np.falsename();\n-          const char_type* __trues = __true.c_str();\n-          const char_type* __falses = __false.c_str();\n-          const size_t __truen =  __true.size() - 1;\n-          const size_t __falsen =  __false.size() - 1;\n+\t  typedef typename numpunct<_CharT>::__cache_type  \t__cache_type;\n+\t  __use_cache<__cache_type> __uc;\n+\t  const locale& __loc = __io._M_getloc();\n+\t  const __cache_type* __lc = __uc(__loc);\n+          const size_t __tn = __traits_type::length(__lc->_M_truename) - 1;\n+          const size_t __fn = __traits_type::length(__lc->_M_falsename) - 1;\n \n+\t  bool __testf = false;\n+\t  bool __testt = false;\n           for (size_t __n = 0; __beg != __end; ++__n)\n             {\n               char_type __c = *__beg++;\n-              bool __testf = __n <= __falsen \n-\t\t             ? __traits_type::eq(__c, __falses[__n]) : false;\n-              bool __testt = __n <= __truen \n-\t\t             ? __traits_type::eq(__c, __trues[__n]) : false;\n+\n+\t      if (__n <= __fn)\n+\t\t__testf = __traits_type::eq(__c, __lc->_M_falsename[__n]);\n+\n+\t      if (__n <= __tn)\n+\t\t__testt = __traits_type::eq(__c, __lc->_M_truename[__n]);\n+\n               if (!(__testf || __testt))\n                 {\n                   __err |= ios_base::failbit;\n                   break;\n                 }\n-              else if (__testf && __n == __falsen)\n+              else if (__testf && __n == __fn)\n                 {\n                   __v = 0;\n                   break;\n                 }\n-              else if (__testt && __n == __truen)\n+              else if (__testt && __n == __tn)\n                 {\n                   __v = 1;\n                   break;\n@@ -618,7 +613,7 @@ namespace std\n     do_get(iter_type __beg, iter_type __end, ios_base& __io,\n            ios_base::iostate& __err, void*& __v) const\n     {\n-      // Prepare for hex formatted input\n+      // Prepare for hex formatted input.\n       typedef ios_base::fmtflags        fmtflags;\n       fmtflags __fmt = __io.flags();\n       fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n@@ -629,7 +624,7 @@ namespace std\n       int __base;\n       __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);\n \n-      // Reset from hex formatted input\n+      // Reset from hex formatted input.\n       __io.flags(__fmt);\n \n       unsigned long __ul;\n@@ -660,7 +655,7 @@ namespace std\n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __out, const int __size, long __v,\n-\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n     {\n       unsigned long __ul = static_cast<unsigned long>(__v);\n       bool __neg = false;\n@@ -675,14 +670,14 @@ namespace std\n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __out, const int __size, unsigned long __v,\n-\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n     { return __int_to_char(__out, __size, __v, __lit, __flags, false); }\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __out, const int __size, long long __v,\n-\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n     { \n       unsigned long long __ull = static_cast<unsigned long long>(__v);\n       bool __neg = false;\n@@ -697,7 +692,7 @@ namespace std\n   template<typename _CharT>\n     inline int\n     __int_to_char(_CharT* __out, const int __size, unsigned long long __v,\n-\t\t       const _CharT* __lit, ios_base::fmtflags __flags)\n+\t\t  const _CharT* __lit, ios_base::fmtflags __flags)\n     { return __int_to_char(__out, __size, __v, __lit, __flags, false); }\n #endif\n       \n@@ -790,21 +785,20 @@ namespace std\n \t    *(__new + 1) = *(__cs + 1);\n \t  }\n       _CharT* __p;\n-      __p = std::__add_grouping(__new + __off, __sep, \n-\t\t\t\t__grouping.c_str(),\n-\t\t\t   __grouping.c_str() + __grouping.size(),\n-\t\t\t   __cs + __off, __cs + __len);\n+      __p = std::__add_grouping(__new + __off, __sep, __grouping.c_str(), \n+\t\t\t\t__grouping.c_str() + __grouping.size(),\n+\t\t\t\t__cs + __off, __cs + __len);\n       __len = __p - __new;\n     }\n \n   template<typename _CharT, typename _OutIter>\n     template<typename _ValueT>\n       _OutIter\n       num_put<_CharT, _OutIter>::\n-      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, \n+      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill, \n \t\t     _ValueT __v) const\n       {\n-\ttypedef typename numpunct<_CharT>::__cache_type  __cache_type;\n+\ttypedef typename numpunct<_CharT>::__cache_type\t__cache_type;\n \t__use_cache<__cache_type> __uc;\n \tconst locale& __loc = __io._M_getloc();\n \tconst __cache_type* __lc = __uc(__loc);\n@@ -861,8 +855,7 @@ namespace std\n       // Add grouping, if necessary. \n       _CharT* __p2;\n       int __declen = __p ? __p - __cs : __len;\n-      __p2 = std::__add_grouping(__new, __sep, \n-\t\t\t\t __grouping.c_str(),\n+      __p2 = std::__add_grouping(__new, __sep, __grouping.c_str(),\n \t\t\t\t __grouping.c_str() + __grouping.size(),\n \t\t\t\t __cs, __cs + __declen);\n       \n@@ -891,9 +884,14 @@ namespace std\n     template<typename _ValueT>\n       _OutIter\n       num_put<_CharT, _OutIter>::\n-      _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n+      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,\n \t\t       _ValueT __v) const\n       {\n+\ttypedef typename numpunct<_CharT>::__cache_type\t__cache_type;\n+\t__use_cache<__cache_type> __uc;\n+\tconst locale& __loc = __io._M_getloc();\n+\tconst __cache_type* __lc = __uc(__loc);\n+\n \t// Note: digits10 is rounded down: add 1 to ensure the maximum\n \t// available precision.  Then, in general, one more 1 needs to\n \t// be added since, when the %{g,G} conversion specifiers are\n@@ -910,11 +908,6 @@ namespace std\n \telse if (__prec < static_cast<streamsize>(0))\n \t  __prec = static_cast<streamsize>(6);\n \n-\ttypedef typename numpunct<_CharT>::__cache_type  __cache_type;\n-\t__use_cache<__cache_type> __uc;\n-\tconst locale& __loc = __io._M_getloc();\n-\tconst __cache_type* __lc = __uc(__loc);\n-\n \t// [22.2.2.2.2] Stage 1, numeric conversion to character.\n \tint __len;\n \t// Long enough for the max format spec.\n@@ -943,6 +936,7 @@ namespace std\n \tconst bool __fixed = __io.flags() & ios_base::fixed;\n \tconst int __max_exp = numeric_limits<_ValueT>::max_exponent10;\n \n+\t// The size of the output string is computed as follows.\n \t// ios_base::fixed outputs may need up to __max_exp+1 chars\n \t// for the integer part + up to __max_digits chars for the\n \t// fractional part + 3 chars for sign, decimal point, '\\0'. On\n@@ -953,7 +947,8 @@ namespace std\n \tchar* __cs = static_cast<char*>(__builtin_alloca(__cs_size));\n \n \t_S_format_float(__io, __fbuf, __mod);\n-\t__len = std::__convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale, __prec);\n+\t__len = std::__convert_from_v(__cs, 0, __fbuf, __v, \n+\t\t\t\t      _S_c_locale, __prec);\n #endif\n \n       // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n@@ -1009,35 +1004,33 @@ namespace std\n       if ((__flags & ios_base::boolalpha) == 0)\n         {\n           unsigned long __uv = __v;\n-          __s = _M_convert_int(__s, __io, __fill, __uv);\n+          __s = _M_insert_int(__s, __io, __fill, __uv);\n         }\n       else\n         {\n-\t  typedef typename numpunct<_CharT>::__cache_type  __cache_type;\n+\t  typedef typename numpunct<_CharT>::__cache_type __cache_type;\n \t  __use_cache<__cache_type> __uc;\n \t  const locale& __loc = __io._M_getloc();\n \t  const __cache_type* __lc = __uc(__loc);\n \n-\t  typedef basic_string<_CharT> \t__string_type;\n-\t  __string_type __name;\n+\t  const _CharT* __name;\n           if (__v)\n \t    __name = __lc->_M_truename;\n           else\n \t    __name = __lc->_M_falsename;\n+\t  int __len = char_traits<_CharT>::length(__name);\n \n-\t  const _CharT* __cs = __name.c_str();\n-\t  int __len = __name.size();\n-\t  _CharT* __cs3;\n+\t  _CharT* __cs;\n \t  streamsize __w = __io.width();\n \t  if (__w > static_cast<streamsize>(__len))\n \t    {\n-\t      __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n+\t      __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n \t\t\t\t\t\t\t    * __w));\n-\t      _M_pad(__fill, __w, __io, __cs3, __cs, __len);\n-\t      __cs = __cs3;\n+\t      _M_pad(__fill, __w, __io, __cs, __name, __len);\n+\t      __name = __cs;\n \t    }\n \t  __io.width(0);\n-\t  __s = std::__write(__s, __cs, __len);\n+\t  __s = std::__write(__s, __name, __len);\n \t}\n       return __s;\n     }\n@@ -1046,42 +1039,42 @@ namespace std\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n-    { return _M_convert_int(__s, __io, __fill, __v); }\n+    { return _M_insert_int(__s, __io, __fill, __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long __v) const\n-    { return _M_convert_int(__s, __io, __fill, __v); }\n+    { return _M_insert_int(__s, __io, __fill, __v); }\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n-    { return _M_convert_int(__s, __b, __fill, __v); }\n+    { return _M_insert_int(__s, __b, __fill, __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long long __v) const\n-    { return _M_convert_int(__s, __io, __fill, __v); }\n+    { return _M_insert_int(__s, __io, __fill, __v); }\n #endif\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n-    { return _M_convert_float(__s, __io, __fill, char(), __v); }\n+    { return _M_insert_float(__s, __io, __fill, char(), __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, \n \t   long double __v) const\n-    { return _M_convert_float(__s, __io, __fill, 'L', __v); }\n+    { return _M_insert_float(__s, __io, __fill, 'L', __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n@@ -1095,8 +1088,8 @@ namespace std\n       __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n       try \n \t{\n-\t  __s = _M_convert_int(__s, __io, __fill, \n-\t\t\t       reinterpret_cast<unsigned long>(__v));\n+\t  __s = _M_insert_int(__s, __io, __fill, \n+\t\t\t      reinterpret_cast<unsigned long>(__v));\n \t  __io.flags(__flags);\n \t}\n       catch (...) \n@@ -2223,7 +2216,7 @@ namespace std\n \t  // Pad after the sign, if there is one.\n \t  // Pad after 0[xX], if there is one.\n \t  // Who came up with these rules, anyway? Jeeze.\n-          locale __loc = __io.getloc();\n+          const locale& __loc = __io._M_getloc();\n \t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n \t  const _CharT __minus = __ctype.widen('-');\n \t  const _CharT __plus = __ctype.widen('+');\n@@ -2268,19 +2261,18 @@ namespace std\n \t  __end = const_cast<_CharT*>(__olds);\n \t}\n       _Traits::copy(__news, __beg, __beglen);\n-      _Traits::copy(__news + __beglen, __end, \n-\t\t\t  __newlen - __beglen - __mod);\n+      _Traits::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n     }\n \n   template<typename _CharT>\n     bool\n     __verify_grouping(const basic_string<_CharT>& __grouping, \n \t\t      basic_string<_CharT>& __grouping_tmp)\n     {         \n-      int __i = 0;\n-      int __j = 0;\n-      const int __len = __grouping.size();\n-      const int __n = __grouping_tmp.size();\n+      size_t __i = 0;\n+      size_t __j = 0;\n+      const size_t __len = __grouping.size();\n+      const size_t __n = __grouping_tmp.size();\n       bool __test = true;\n       \n       // Parsed number groupings have to match the"}, {"sha": "b7c4694796e3310df3622166b93cc896c894c4c5", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=7942afdca2e581f24a54004592fe6fa506b19d7c", "patch": "@@ -64,40 +64,40 @@ namespace std\n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n-\t\t   long) const;\n+    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+\t\t  long) const;\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n-\t\t   unsigned long) const;\n+    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+\t\t  unsigned long) const;\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n-\t\t   long long) const;\n+    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+\t\t  long long) const;\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_int(ostreambuf_iterator<char>, ios_base&, char, \n-\t\t   unsigned long long) const;\n+    _M_insert_int(ostreambuf_iterator<char>, ios_base&, char, \n+\t\t  unsigned long long) const;\n #endif\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n-\t\t     double) const;\n+    _M_insert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n+\t\t    double) const;\n \n   template\n     ostreambuf_iterator<char>\n     num_put<char, ostreambuf_iterator<char> >::\n-    _M_convert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n-\t\t     long double) const;\n+    _M_insert_float(ostreambuf_iterator<char>, ios_base&, char, char, \n+\t\t    long double) const;\n   \n #ifdef _GLIBCXX_USE_WCHAR_T\n   template class numpunct<wchar_t>;\n@@ -109,40 +109,40 @@ namespace std\n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n-\t\t   long) const;\n+    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n+\t\t  long) const;\n \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n-\t\t   unsigned long) const;\n+    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, \n+\t\t  unsigned long) const;\n \n #ifdef _GLIBCXX_USE_LONG_LONG\n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n-\t\t   long long) const;\n+    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n+\t\t  long long) const;\n \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n-\t\t   unsigned long long) const;\n+    _M_insert_int(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t,\n+\t\t  unsigned long long) const;\n #endif\n \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t     double) const;\n-\n+    _M_insert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n+\t\t    double) const;\n+  \n   template\n     ostreambuf_iterator<wchar_t>\n     num_put<wchar_t, ostreambuf_iterator<wchar_t> >::\n-    _M_convert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n-\t\t     long double) const;\n+    _M_insert_float(ostreambuf_iterator<wchar_t>, ios_base&, wchar_t, char, \n+\t\t    long double) const;\n #endif\n \n   // time_get and time_put"}, {"sha": "f9244bd93337cd35832758048879ea628f171d87", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7942afdca2e581f24a54004592fe6fa506b19d7c/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=7942afdca2e581f24a54004592fe6fa506b19d7c", "patch": "@@ -475,7 +475,7 @@ namespace std\n   const money_base::pattern \n   money_base::_S_default_pattern =  { {symbol, sign, none, value} };\n \n-  const char* __num_base::_S_atoms_in = \"0123456789eEabcdfABCDF\";\n+  const char* __num_base::_S_atoms_in = \"-+xX0123456789eEabcdfABCDF\";\n   const char* __num_base::_S_atoms_out =\"-+xX0123456789abcdef0123456789ABCDEF\";\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS"}]}