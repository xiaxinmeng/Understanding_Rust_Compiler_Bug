{"sha": "73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3ODBiNzRiMzcxNzVhYTFjOWFmZDIwYmZiODFiNjZlNmE5NmMxYQ==", "commit": {"author": {"name": "Stan Cox", "email": "scox@cygnus.com", "date": "2000-03-27T21:50:15Z"}, "committer": {"name": "Stan Cox", "email": "scox@gcc.gnu.org", "date": "2000-03-27T21:50:15Z"}, "message": "resource.h (mark_resource_type): New.\n\n\t* resource.h (mark_resource_type): New.\n\t* resource.c (find_dead_or_set_registers, mark_target_live_regs,\n\tfind_free_register): Use mark_resource_type.\n\t(mark_set_resources): Change include_delayed_effects\n\tto mark_resource_type.\n\t* reorg.c (steal_delay_list_from_target, try_merge_delay_insns,\n\tredundant_insn, fill_simple_delay_slots, fill_slots_from_thread):\n\tUse mark_resource_type.\n\nFrom-SVN: r32771", "tree": {"sha": "f9c217d68b8377ff6f78d3a2446bf1ca4e70a082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9c217d68b8377ff6f78d3a2446bf1ca4e70a082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/comments", "author": null, "committer": null, "parents": [{"sha": "4e2d1dbdd309f6b7aa3af8ae146bfbc3e2517cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2d1dbdd309f6b7aa3af8ae146bfbc3e2517cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e2d1dbdd309f6b7aa3af8ae146bfbc3e2517cb0"}], "stats": {"total": 124, "additions": 79, "deletions": 45}, "files": [{"sha": "252f8f8e874e295ce74cc585f44b1d65b5d9f2dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "patch": "@@ -1,3 +1,14 @@\n+2000-03-27  Stan Cox  <scox@cygnus.com>\t\n+\n+\t* resource.h (mark_resource_type): New.\n+\t* resource.c (find_dead_or_set_registers, mark_target_live_regs, \n+\tfind_free_register): Use mark_resource_type.\n+\t(mark_set_resources): Change include_delayed_effects\n+\tto mark_resource_type.\n+\t* reorg.c (steal_delay_list_from_target, try_merge_delay_insns, \n+\tredundant_insn, fill_simple_delay_slots, fill_slots_from_thread): \n+\tUse mark_resource_type.\n+\t\n 2000-03-27  Richard Henderson  <rth@cygnus.com>\n \n \t* i386.md (call_pop_0, call_value_pop_0): New."}, {"sha": "3997c746ed87ae3d996ce0f469396039afd5fd0f", "filename": "gcc/reorg.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "patch": "@@ -1246,7 +1246,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n     {\n       rtx trial = XEXP (temp, 0);\n \n-      mark_set_resources (trial, &cc_set, 0, 1);\n+      mark_set_resources (trial, &cc_set, 0, MARK_SRC_DEST_CALL);\n       if (insn_references_resource_p (XVECEXP (seq , 0, 0), &cc_set, 0))\n         return delay_list;\n     }\n@@ -1498,7 +1498,7 @@ try_merge_delay_insns (insn, thread)\n \t  next_to_match = XVECEXP (PATTERN (insn), 0, slot_number);\n \t}\n \n-      mark_set_resources (trial, &set, 0, 1);\n+      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n       mark_referenced_resources (trial, &needed, 1);\n     }\n \n@@ -1513,7 +1513,7 @@ try_merge_delay_insns (insn, thread)\n       rtx filled_insn = XVECEXP (pat, 0, 0);\n \n       /* Account for resources set/needed by the filled insn.  */\n-      mark_set_resources (filled_insn, &set, 0, 1);\n+      mark_set_resources (filled_insn, &set, 0, MARK_SRC_DEST_CALL);\n       mark_referenced_resources (filled_insn, &needed, 1);\n \n       for (i = 1; i < XVECLEN (pat, 0); i++)\n@@ -1552,7 +1552,7 @@ try_merge_delay_insns (insn, thread)\n \t    {\n \t      /* Keep track of the set/referenced resources for the delay\n \t\t slots of any trial insns we encounter.  */\n-              mark_set_resources (dtrial, &set, 0, 1);\n+              mark_set_resources (dtrial, &set, 0, MARK_SRC_DEST_CALL);\n               mark_referenced_resources (dtrial, &needed, 1);\n \t    }\n \t}\n@@ -1687,7 +1687,7 @@ redundant_insn (insn, target, delay_list)\n \n   CLEAR_RESOURCE (&needed);\n   CLEAR_RESOURCE (&set);\n-  mark_set_resources (insn, &set, 0, 1);\n+  mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n   mark_referenced_resources (insn, &needed, 1);\n \n   /* If TARGET is a SEQUENCE, get the main insn.  */\n@@ -2124,7 +2124,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t{\n \t  CLEAR_RESOURCE (&needed);\n \t  CLEAR_RESOURCE (&set);\n-\t  mark_set_resources (insn, &set, 0, 0);\n+\t  mark_set_resources (insn, &set, 0, MARK_SRC_DEST);\n \t  mark_referenced_resources (insn, &needed, 0);\n \n \t  for (trial = prev_nonnote_insn (insn); ! stop_search_p (trial, 1);\n@@ -2170,7 +2170,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t    }\n \t\t}\n \n-\t      mark_set_resources (trial, &set, 0, 1);\n+\t      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (trial, &needed, 1);\n \t    }\n \t}\n@@ -2218,13 +2218,13 @@ fill_simple_delay_slots (non_jumps_p)\n \n \t  if (GET_CODE (insn) == CALL_INSN)\n \t    {\n-\t      mark_set_resources (insn, &set, 0, 1);\n+\t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (insn, &needed, 1);\n \t      maybe_never = 1;\n \t    }\n \t  else \n \t    {\n-\t      mark_set_resources (insn, &set, 0, 1);\n+\t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (insn, &needed, 1);\n \t      if (GET_CODE (insn) == JUMP_INSN)\n \t\ttarget = JUMP_LABEL (insn);\n@@ -2303,7 +2303,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t  continue;\n \t\t}\n \n-\t      mark_set_resources (trial, &set, 0, 1);\n+\t      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n \t      mark_referenced_resources (trial, &needed, 1);\n \n \t      /* Ensure we don't put insns between the setting of cc and the\n@@ -2467,7 +2467,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t    }\n \t}\n \n-      mark_set_resources (trial, &set, 0, 1);\n+      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n       mark_referenced_resources (trial, &needed, 1);\n     }\n \n@@ -2719,7 +2719,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \n       /* This insn can't go into a delay slot.  */\n       lose = 1;\n-      mark_set_resources (trial, &set, 0, 1);\n+      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n       mark_referenced_resources (trial, &needed, 1);\n \n       /* Ensure we don't put insns between the setting of cc and the comparison"}, {"sha": "61b8b0ca48aa02997e10ef48c5066533c09532f9", "filename": "gcc/resource.c", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "patch": "@@ -444,7 +444,8 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t\t underlying insn.  Any registers set by the underlying insn\n \t\t are live since the insn is being done somewhere else.  */\n \t      if (GET_RTX_CLASS (GET_CODE (XEXP (PATTERN (insn), 0))) == 'i')\n-\t\tmark_set_resources (XEXP (PATTERN (insn), 0), res, 0, 1);\n+\t\tmark_set_resources (XEXP (PATTERN (insn), 0), res, 0,\n+\t\t\t\t    MARK_SRC_DEST_CALL);\n \n \t      /* All other USE insns are to be ignored.  */\n \t      continue;\n@@ -518,17 +519,18 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t\t\t  = ! INSN_FROM_TARGET_P (XVECEXP (PATTERN (insn), 0, i));\n \n \t\t      target_set = set;\n-\t\t      mark_set_resources (insn, &target_set, 0, 1);\n+\t\t      mark_set_resources (insn, &target_set, 0,\n+\t\t\t\t\t  MARK_SRC_DEST_CALL);\n \n \t\t      for (i = 1; i < XVECLEN (PATTERN (insn), 0); i++)\n \t\t\tINSN_FROM_TARGET_P (XVECEXP (PATTERN (insn), 0, i))\n \t\t\t  = ! INSN_FROM_TARGET_P (XVECEXP (PATTERN (insn), 0, i));\n \n-\t\t      mark_set_resources (insn, &set, 0, 1);\n+\t\t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      mark_set_resources (insn, &set, 0, 1);\n+\t\t      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t\t      target_set = set;\n \t\t    }\n \n@@ -566,7 +568,7 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \t}\n \n       mark_referenced_resources (insn, &needed, 1);\n-      mark_set_resources (insn, &set, 0, 1);\n+      mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \n       COPY_HARD_REG_SET (scratch, set.regs);\n       AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n@@ -578,8 +580,8 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \f\n /* Given X, a part of an insn, and a pointer to a `struct resource',\n    RES, indicate which resources are modified by the insn. If\n-   INCLUDE_DELAYED_EFFECTS is nonzero, also mark resources potentially\n-   set by the called routine.\n+   MARK_TYPE is MARK_SRC_DEST_CALL, also mark resources potentially\n+   set by the called routine.  If MARK_TYPE is MARK_DEST, only mark SET_DESTs\n \n    If IN_DEST is nonzero, it means we are inside a SET.  Otherwise,\n    objects are being referenced instead of set.\n@@ -591,11 +593,11 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n    our computation and thus may be placed in a delay slot.   */\n \n void\n-mark_set_resources (x, res, in_dest, include_delayed_effects)\n+mark_set_resources (x, res, in_dest, mark_type)\n      register rtx x;\n      register struct resources *res;\n      int in_dest;\n-     int include_delayed_effects;\n+     enum mark_resource_type mark_type;\n {\n   enum rtx_code code;\n   int i, j;\n@@ -631,7 +633,7 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t that aren't saved across calls, global registers and anything\n \t explicitly CLOBBERed immediately after the CALL_INSN.  */\n \n-      if (include_delayed_effects)\n+      if (mark_type == MARK_SRC_DEST_CALL)\n \t{\n \t  rtx next = NEXT_INSN (x);\n \t  rtx prev = PREV_INSN (x);\n@@ -650,7 +652,8 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t  for (link = CALL_INSN_FUNCTION_USAGE (x);\n \t       link; link = XEXP (link, 1))\n \t    if (GET_CODE (XEXP (link, 0)) == CLOBBER)\n-\t      mark_set_resources (SET_DEST (XEXP (link, 0)), res, 1, 0);\n+\t      mark_set_resources (SET_DEST (XEXP (link, 0)), res, 1,\n+\t\t\t\t  MARK_SRC_DEST);\n \n \t  /* Check for a NOTE_INSN_SETJMP.  If it exists, then we must\n \t     assume that this call can clobber any register.  */\n@@ -668,7 +671,7 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t   and doesn't actually do anything, so we ignore it.  */\n \n #ifdef INSN_SETS_ARE_DELAYED\n-      if (! include_delayed_effects\n+      if (mark_type != MARK_SRC_DEST_CALL\n \t  && INSN_SETS_ARE_DELAYED (x))\n \treturn;\n #endif\n@@ -684,36 +687,40 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t effects of the calling routine.  */\n \n       mark_set_resources (SET_DEST (x), res,\n-\t\t\t  (include_delayed_effects\n+\t\t\t  (mark_type == MARK_SRC_DEST_CALL\n \t\t\t   || GET_CODE (SET_SRC (x)) != CALL),\n-\t\t\t  0);\n+\t\t\t  mark_type);\n \n-      mark_set_resources (SET_SRC (x), res, 0, 0);\n+      if (mark_type != MARK_DEST)\n+\tmark_set_resources (SET_SRC (x), res, 0, MARK_SRC_DEST);\n       return;\n \n     case CLOBBER:\n-      mark_set_resources (XEXP (x, 0), res, 1, 0);\n+      mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n       \n     case SEQUENCE:\n       for (i = 0; i < XVECLEN (x, 0); i++)\n \tif (! (INSN_ANNULLED_BRANCH_P (XVECEXP (x, 0, 0))\n \t       && INSN_FROM_TARGET_P (XVECEXP (x, 0, i))))\n-\t  mark_set_resources (XVECEXP (x, 0, i), res, 0,\n-\t\t\t      include_delayed_effects);\n+\t  mark_set_resources (XVECEXP (x, 0, i), res, 0, mark_type);\n       return;\n \n     case POST_INC:\n     case PRE_INC:\n     case POST_DEC:\n     case PRE_DEC:\n-      mark_set_resources (XEXP (x, 0), res, 1, 0);\n+      mark_set_resources (XEXP (x, 0), res, 1, MARK_SRC_DEST);\n       return;\n \n+    case SIGN_EXTRACT:\n     case ZERO_EXTRACT:\n-      mark_set_resources (XEXP (x, 0), res, in_dest, 0);\n-      mark_set_resources (XEXP (x, 1), res, 0, 0);\n-      mark_set_resources (XEXP (x, 2), res, 0, 0);\n+      if (! (mark_type == MARK_DEST && in_dest))\n+\t{\n+\t  mark_set_resources (XEXP (x, 0), res, in_dest, MARK_SRC_DEST);\n+\t  mark_set_resources (XEXP (x, 1), res, 0, MARK_SRC_DEST);\n+\t  mark_set_resources (XEXP (x, 2), res, 0, MARK_SRC_DEST);\n+\t}\n       return;\n \n     case MEM:\n@@ -724,15 +731,14 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t  res->volatil |= MEM_VOLATILE_P (x);\n \t}\n \n-      mark_set_resources (XEXP (x, 0), res, 0, 0);\n+      mark_set_resources (XEXP (x, 0), res, 0, MARK_SRC_DEST);\n       return;\n \n     case SUBREG:\n       if (in_dest)\n \t{\n \t  if (GET_CODE (SUBREG_REG (x)) != REG)\n-\t    mark_set_resources (SUBREG_REG (x), res,\n-\t\t\t\tin_dest, include_delayed_effects);\n+\t    mark_set_resources (SUBREG_REG (x), res, in_dest, mark_type);\n \t  else\n \t    {\n \t      unsigned int regno = REGNO (SUBREG_REG (x)) + SUBREG_WORD (x);\n@@ -751,6 +757,13 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t  SET_HARD_REG_BIT (res->regs, REGNO (x) + r);\n       return;\n \n+    case STRICT_LOW_PART:\n+      if (! (mark_type == MARK_DEST && in_dest))\n+\t{\n+\t  mark_set_resources (XEXP (x, 0), res, 0, MARK_SRC_DEST);\n+\t  return;\n+\t}\n+\n     case UNSPEC_VOLATILE:\n     case ASM_INPUT:\n       /* Traditional asm's are always volatile.  */\n@@ -770,7 +783,8 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n \t traditional asms unlike their normal usage.  */\n       \n       for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n-\tmark_set_resources (ASM_OPERANDS_INPUT (x, i), res, in_dest, 0);\n+\tmark_set_resources (ASM_OPERANDS_INPUT (x, i), res, in_dest,\n+\t\t\t    MARK_SRC_DEST);\n       return;\n \n     default:\n@@ -783,13 +797,12 @@ mark_set_resources (x, res, in_dest, include_delayed_effects)\n     switch (*format_ptr++)\n       {\n       case 'e':\n-\tmark_set_resources (XEXP (x, i), res, in_dest, include_delayed_effects);\n+\tmark_set_resources (XEXP (x, i), res, in_dest, mark_type);\n \tbreak;\n \n       case 'E':\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  mark_set_resources (XVECEXP (x, i, j), res, in_dest,\n-\t\t\t      include_delayed_effects);\n+\t  mark_set_resources (XVECEXP (x, i, j), res, in_dest, mark_type);\n \tbreak;\n       }\n }\n@@ -1098,7 +1111,7 @@ mark_target_live_regs (insns, target, res)\n \t  AND_COMPL_HARD_REG_SET (scratch, set.regs);\n \t  IOR_HARD_REG_SET (new_resources.regs, scratch);\n \n-\t  mark_set_resources (insn, &set, 0, 1);\n+\t  mark_set_resources (insn, &set, 0, MARK_SRC_DEST_CALL);\n \t}\n \n       IOR_HARD_REG_SET (res->regs, new_resources.regs);\n@@ -1178,7 +1191,8 @@ init_resource_info (epilogue_insn)\n   start_of_epilogue_needs = end_of_function_needs;\n \n   while ((epilogue_insn = next_nonnote_insn (epilogue_insn)))\n-    mark_set_resources (epilogue_insn, &end_of_function_needs, 0, 1);\n+    mark_set_resources (epilogue_insn, &end_of_function_needs, 0,\n+\t\t\tMARK_SRC_DEST_CALL);\n \n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n   target_hash_table = (struct target_info **)\n@@ -1277,7 +1291,8 @@ find_free_register (current_insn, last_insn, class_str, mode, reg_set)\n     while (current_insn != last_insn)\n       {\n \t/* Exclude anything set in this insn.  */\n-\tmark_set_resources (PATTERN (current_insn), &used, 0, 1);\n+\tmark_set_resources (PATTERN (current_insn), &used, 0,\n+\t\t\t    MARK_SRC_DEST_CALL);\n \tcurrent_insn = next_nonnote_insn (current_insn);\n       }\n "}, {"sha": "718ec651341f11a6103524839e291212f84ab4a2", "filename": "gcc/resource.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73780b74b37175aa1c9afd20bfb81b66e6a96c1a/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=73780b74b37175aa1c9afd20bfb81b66e6a96c1a", "patch": "@@ -33,9 +33,17 @@ struct resources\n   HARD_REG_SET regs;\t/* Which registers are set or needed.  */\n };\n \n+/* The kinds of rtl mark_*_resources will consider */\n+enum mark_resource_type\n+{\n+  MARK_SRC_DEST = 0,\n+  MARK_SRC_DEST_CALL = 1,\n+  MARK_DEST = 2\n+};\n+\n extern void mark_target_live_regs \tPARAMS ((rtx, rtx, struct resources *));\n extern void mark_set_resources\t\tPARAMS ((rtx, struct resources *, int,\n-\t\t\t\t\t       int));\n+\t\t\t\t\t       enum mark_resource_type));\n extern void mark_referenced_resources\tPARAMS ((rtx, struct resources *, int));\n extern void clear_hashed_info_for_insn\tPARAMS ((rtx));\n extern void incr_ticks_for_insn\t\tPARAMS ((rtx));"}]}