{"sha": "d496134a6b1ef1314c18bd316d8c1900158beae9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ5NjEzNGE2YjFlZjEzMTRjMThiZDMxNmQ4YzE5MDAxNThiZWFlOQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-08T07:33:03Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-08T07:33:03Z"}, "message": "IFN/optabs: Support vector load/store with length\n\nThis patch is to add the internal function and optabs support for\nvector load/store with length.\n\nFor the vector load/store with length optab, the length item would\nbe measured in lanes by default.  For the targets which support\nlength measured in bytes like Power, they should only define VnQI\nmodes to wrap the other same size vector modes.  If the length is\nlarger than total lane/byte count of the given mode, the behavior\nis undefined.  For the remaining lanes/bytes which isn't specified\nby length, they would be taken as undefined value.\n\ngcc/ChangeLog:\n\n\t* doc/md.texi (len_load_@var{m}): Document.\n\t(len_store_@var{m}): Likewise.\n\t* internal-fn.c (len_load_direct): New macro.\n\t(len_store_direct): Likewise.\n\t(expand_len_load_optab_fn): Likewise.\n\t(expand_len_store_optab_fn): Likewise.\n\t(direct_len_load_optab_supported_p): Likewise.\n\t(direct_len_store_optab_supported_p): Likewise.\n\t(expand_mask_load_optab_fn): New macro.  Original renamed to ...\n\t(expand_partial_load_optab_fn): ... here.  Add handlings for\n\tlen_load_optab.\n\t(expand_mask_store_optab_fn): New macro.  Original renamed to ...\n\t(expand_partial_store_optab_fn): ... here. Add handlings for\n\tlen_store_optab.\n\t(internal_load_fn_p): Handle IFN_LEN_LOAD.\n\t(internal_store_fn_p): Handle IFN_LEN_STORE.\n\t(internal_fn_stored_value_index): Handle IFN_LEN_STORE.\n\t* internal-fn.def (LEN_LOAD): New internal function.\n\t(LEN_STORE): Likewise.\n\t* optabs.def (len_load_optab, len_store_optab): New optab.", "tree": {"sha": "bfad76449eb2f1afa06e3972465080f82030f2e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfad76449eb2f1afa06e3972465080f82030f2e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d496134a6b1ef1314c18bd316d8c1900158beae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d496134a6b1ef1314c18bd316d8c1900158beae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d496134a6b1ef1314c18bd316d8c1900158beae9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d496134a6b1ef1314c18bd316d8c1900158beae9/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c832cf1c1d114aed70c2f84566cf4d63de0a56d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c832cf1c1d114aed70c2f84566cf4d63de0a56d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c832cf1c1d114aed70c2f84566cf4d63de0a56d0"}], "stats": {"total": 69, "additions": 63, "deletions": 6}, "files": [{"sha": "2b46286943778e16d95b15def4299bcbf8db7eb8", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=d496134a6b1ef1314c18bd316d8c1900158beae9", "patch": "@@ -5167,6 +5167,32 @@ mode @var{n}.\n \n This pattern is not allowed to @code{FAIL}.\n \n+@cindex @code{len_load_@var{m}} instruction pattern\n+@item @samp{len_load_@var{m}}\n+Load the number of vector elements specified by operand 2 from memory\n+operand 1 into vector register operand 0, setting the other elements of\n+operand 0 to undefined values.  Operands 0 and 1 have mode @var{m},\n+which must be a vector mode.  Operand 2 has whichever integer mode the\n+target prefers.  If operand 2 exceeds the number of elements in mode\n+@var{m}, the behavior is undefined.  If the target prefers the length\n+to be measured in bytes rather than elements, it should only implement\n+this pattern for vectors of @code{QI} elements.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{len_store_@var{m}} instruction pattern\n+@item @samp{len_store_@var{m}}\n+Store the number of vector elements specified by operand 2 from vector\n+register operand 1 into memory operand 0, leaving the other elements of\n+operand 0 unchanged.  Operands 0 and 1 have mode @var{m}, which must be\n+a vector mode.  Operand 2 has whichever integer mode the target prefers.\n+If operand 2 exceeds the number of elements in mode @var{m}, the behavior\n+is undefined.  If the target prefers the length to be measured in bytes\n+rather than elements, it should only implement this pattern for vectors\n+of @code{QI} elements.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_perm@var{m}} instruction pattern\n @item @samp{vec_perm@var{m}}\n Output a (variable) vector permutation.  Operand 0 is the destination"}, {"sha": "a15031f794d849042667da8258068b634ae6baed", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=d496134a6b1ef1314c18bd316d8c1900158beae9", "patch": "@@ -105,6 +105,7 @@ init_internal_fns ()\n #define load_lanes_direct { -1, -1, false }\n #define mask_load_lanes_direct { -1, -1, false }\n #define gather_load_direct { 3, 1, false }\n+#define len_load_direct { -1, -1, false }\n #define mask_store_direct { 3, 2, false }\n #define store_lanes_direct { 0, 0, false }\n #define mask_store_lanes_direct { 0, 0, false }\n@@ -113,6 +114,7 @@ init_internal_fns ()\n #define vec_condu_direct { 0, 0, false }\n #define vec_condeq_direct { 0, 0, false }\n #define scatter_store_direct { 3, 1, false }\n+#define len_store_direct { 3, 3, false }\n #define unary_direct { 0, 0, true }\n #define binary_direct { 0, 0, true }\n #define ternary_direct { 0, 0, true }\n@@ -2483,10 +2485,10 @@ expand_call_mem_ref (tree type, gcall *stmt, int index)\n   return fold_build2 (MEM_REF, type, addr, build_int_cst (alias_ptr_type, 0));\n }\n \n-/* Expand MASK_LOAD{,_LANES} call STMT using optab OPTAB.  */\n+/* Expand MASK_LOAD{,_LANES} or LEN_LOAD call STMT using optab OPTAB.  */\n \n static void\n-expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+expand_partial_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   class expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -2502,6 +2504,8 @@ expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n \n   if (optab == vec_mask_load_lanes_optab)\n     icode = get_multi_vector_move (type, optab);\n+  else if (optab == len_load_optab)\n+    icode = direct_optab_handler (optab, TYPE_MODE (type));\n   else\n     icode = convert_optab_handler (optab, TYPE_MODE (type),\n \t\t\t\t   TYPE_MODE (TREE_TYPE (maskt)));\n@@ -2512,18 +2516,24 @@ expand_mask_load_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n   create_output_operand (&ops[0], target, TYPE_MODE (type));\n   create_fixed_operand (&ops[1], mem);\n-  create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n+  if (optab == len_load_optab)\n+    create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n+\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+  else\n+    create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n   expand_insn (icode, 3, ops);\n   if (!rtx_equal_p (target, ops[0].value))\n     emit_move_insn (target, ops[0].value);\n }\n \n+#define expand_mask_load_optab_fn expand_partial_load_optab_fn\n #define expand_mask_load_lanes_optab_fn expand_mask_load_optab_fn\n+#define expand_len_load_optab_fn expand_partial_load_optab_fn\n \n-/* Expand MASK_STORE{,_LANES} call STMT using optab OPTAB.  */\n+/* Expand MASK_STORE{,_LANES} or LEN_STORE call STMT using optab OPTAB.  */\n \n static void\n-expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n+expand_partial_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n {\n   class expand_operand ops[3];\n   tree type, lhs, rhs, maskt;\n@@ -2537,6 +2547,8 @@ expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n \n   if (optab == vec_mask_store_lanes_optab)\n     icode = get_multi_vector_move (type, optab);\n+  else if (optab == len_store_optab)\n+    icode = direct_optab_handler (optab, TYPE_MODE (type));\n   else\n     icode = convert_optab_handler (optab, TYPE_MODE (type),\n \t\t\t\t   TYPE_MODE (TREE_TYPE (maskt)));\n@@ -2547,11 +2559,17 @@ expand_mask_store_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   reg = expand_normal (rhs);\n   create_fixed_operand (&ops[0], mem);\n   create_input_operand (&ops[1], reg, TYPE_MODE (type));\n-  create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n+  if (optab == len_store_optab)\n+    create_convert_operand_from (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)),\n+\t\t\t\t TYPE_UNSIGNED (TREE_TYPE (maskt)));\n+  else\n+    create_input_operand (&ops[2], mask, TYPE_MODE (TREE_TYPE (maskt)));\n   expand_insn (icode, 3, ops);\n }\n \n+#define expand_mask_store_optab_fn expand_partial_store_optab_fn\n #define expand_mask_store_lanes_optab_fn expand_mask_store_optab_fn\n+#define expand_len_store_optab_fn expand_partial_store_optab_fn\n \n /* Expand VCOND, VCONDU and VCONDEQ optab internal functions.\n    The expansion of STMT happens based on OPTAB table associated.  */\n@@ -3217,6 +3235,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_load_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_gather_load_optab_supported_p convert_optab_supported_p\n+#define direct_len_load_optab_supported_p direct_optab_supported_p\n #define direct_mask_store_optab_supported_p convert_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n #define direct_mask_store_lanes_optab_supported_p multi_vector_optab_supported_p\n@@ -3225,6 +3244,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_vec_condu_optab_supported_p multi_vector_optab_supported_p\n #define direct_vec_condeq_optab_supported_p multi_vector_optab_supported_p\n #define direct_scatter_store_optab_supported_p convert_optab_supported_p\n+#define direct_len_store_optab_supported_p direct_optab_supported_p\n #define direct_while_optab_supported_p convert_optab_supported_p\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p\n #define direct_fold_left_optab_supported_p direct_optab_supported_p\n@@ -3591,6 +3611,7 @@ internal_load_fn_p (internal_fn fn)\n     case IFN_MASK_LOAD_LANES:\n     case IFN_GATHER_LOAD:\n     case IFN_MASK_GATHER_LOAD:\n+    case IFN_LEN_LOAD:\n       return true;\n \n     default:\n@@ -3610,6 +3631,7 @@ internal_store_fn_p (internal_fn fn)\n     case IFN_MASK_STORE_LANES:\n     case IFN_SCATTER_STORE:\n     case IFN_MASK_SCATTER_STORE:\n+    case IFN_LEN_STORE:\n       return true;\n \n     default:\n@@ -3670,6 +3692,7 @@ internal_fn_stored_value_index (internal_fn fn)\n     case IFN_MASK_STORE:\n     case IFN_SCATTER_STORE:\n     case IFN_MASK_SCATTER_STORE:\n+    case IFN_LEN_STORE:\n       return 3;\n \n     default:"}, {"sha": "13e60828fcf5db6c5f15aae2bacd4cf04029e430", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=d496134a6b1ef1314c18bd316d8c1900158beae9", "patch": "@@ -49,11 +49,13 @@ along with GCC; see the file COPYING3.  If not see\n    - load_lanes: currently just vec_load_lanes\n    - mask_load_lanes: currently just vec_mask_load_lanes\n    - gather_load: used for {mask_,}gather_load\n+   - len_load: currently just len_load\n \n    - mask_store: currently just maskstore\n    - store_lanes: currently just vec_store_lanes\n    - mask_store_lanes: currently just vec_mask_store_lanes\n    - scatter_store: used for {mask_,}scatter_store\n+   - len_store: currently just len_store\n \n    - unary: a normal unary optab, such as vec_reverse_<mode>\n    - binary: a normal binary optab, such as vec_interleave_lo_<mode>\n@@ -127,6 +129,8 @@ DEF_INTERNAL_OPTAB_FN (GATHER_LOAD, ECF_PURE, gather_load, gather_load)\n DEF_INTERNAL_OPTAB_FN (MASK_GATHER_LOAD, ECF_PURE,\n \t\t       mask_gather_load, gather_load)\n \n+DEF_INTERNAL_OPTAB_FN (LEN_LOAD, ECF_PURE, len_load, len_load)\n+\n DEF_INTERNAL_OPTAB_FN (SCATTER_STORE, 0, scatter_store, scatter_store)\n DEF_INTERNAL_OPTAB_FN (MASK_SCATTER_STORE, 0,\n \t\t       mask_scatter_store, scatter_store)\n@@ -141,6 +145,8 @@ DEF_INTERNAL_OPTAB_FN (VCONDU, 0, vcondu, vec_condu)\n DEF_INTERNAL_OPTAB_FN (VCONDEQ, 0, vcondeq, vec_condeq)\n DEF_INTERNAL_OPTAB_FN (VCOND_MASK, 0, vcond_mask, vec_cond_mask)\n \n+DEF_INTERNAL_OPTAB_FN (LEN_STORE, 0, len_store, len_store)\n+\n DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n DEF_INTERNAL_OPTAB_FN (CHECK_RAW_PTRS, ECF_CONST | ECF_NOTHROW,\n \t\t       check_raw_ptrs, check_ptrs)"}, {"sha": "78409aa14537d259bf90277751aac00d452a0d3f", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d496134a6b1ef1314c18bd316d8c1900158beae9/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=d496134a6b1ef1314c18bd316d8c1900158beae9", "patch": "@@ -435,3 +435,5 @@ OPTAB_D (check_war_ptrs_optab, \"check_war_ptrs$a\")\n OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)\n OPTAB_DC (vec_series_optab, \"vec_series$a\", VEC_SERIES)\n OPTAB_D (vec_shl_insert_optab, \"vec_shl_insert_$a\")\n+OPTAB_D (len_load_optab, \"len_load_$a\")\n+OPTAB_D (len_store_optab, \"len_store_$a\")"}]}