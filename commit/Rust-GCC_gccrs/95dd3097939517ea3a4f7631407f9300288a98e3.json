{"sha": "95dd3097939517ea3a4f7631407f9300288a98e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVkZDMwOTc5Mzk1MTdlYTNhNGY3NjMxNDA3ZjkzMDAyODhhOThlMw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-05-15T18:24:55Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-15T18:24:55Z"}, "message": "re PR tree-optimization/26830 (Repeated SSA update during loop header copying)\n\n\tPR tree-optimization/26830\n\t* tree-into-ssa.c (struct ssa_name_info): Add age field.\n\t(info_for_ssa_name, current_info_for_ssa_name_age,\n\tblocks_to_update): New variables.\n\t(get_ssa_name_ann): Use info_for_ssa_name instead of SSA_NAME_AUX.\n\t(clear_ssa_name_info, initialize_flags_in_bb,\n\tmark_block_for_update): New functions.\n\t(mark_def_sites, rewrite_stmt): Assert that blocks_to_update is NULL.\n\t(insert_phi_nodes_for, mark_use_interesting, prepare_block_for_update,\n\tprepare_def_site_for): Use mark_block_for_update.\n\t(mark_def_interesting): Assert that the processed block is marked in\n\tblocks_to_update.  Do not take blocks argument.\n\t(prepare_use_sites_for, prepare_names_to_update): Do not take blocks\n\targument.\n\t(rewrite_update_init_block, rewrite_update_stmt): Only process\n\tblocks with statements to rewrite.\n\t(delete_update_ssa): Do not clear SSA_NAME_AUX.\n\t(update_ssa): Initialize and free blocks_to_update.  Do not\n\tclear flags on statements.  Do not use blocks bitmap.\n\t* tree.h (SSA_NAME_AUX): Removed.\n\t(struct tree_ssa_name): Removed aux field.\n\t* print-tree.c (print_node): Do not print SSA_NAME_AUX.\n\nFrom-SVN: r113799", "tree": {"sha": "766c14ddc673f894d7d8cfdf171c0bcd960c9c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/766c14ddc673f894d7d8cfdf171c0bcd960c9c28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95dd3097939517ea3a4f7631407f9300288a98e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dd3097939517ea3a4f7631407f9300288a98e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95dd3097939517ea3a4f7631407f9300288a98e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dd3097939517ea3a4f7631407f9300288a98e3/comments", "author": null, "committer": null, "parents": [{"sha": "f8f80cbb624c69bf1397bd71cc5181cebdce43fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f80cbb624c69bf1397bd71cc5181cebdce43fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8f80cbb624c69bf1397bd71cc5181cebdce43fe"}], "stats": {"total": 266, "additions": 171, "deletions": 95}, "files": [{"sha": "06ecba3c4e46634bced5d06212376b56dacfd67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95dd3097939517ea3a4f7631407f9300288a98e3", "patch": "@@ -1,3 +1,28 @@\n+2006-05-15  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/26830\n+\t* tree-into-ssa.c (struct ssa_name_info): Add age field.\n+\t(info_for_ssa_name, current_info_for_ssa_name_age,\n+\tblocks_to_update): New variables.\n+\t(get_ssa_name_ann): Use info_for_ssa_name instead of SSA_NAME_AUX.\n+\t(clear_ssa_name_info, initialize_flags_in_bb,\n+\tmark_block_for_update): New functions.\n+\t(mark_def_sites, rewrite_stmt): Assert that blocks_to_update is NULL.\n+\t(insert_phi_nodes_for, mark_use_interesting, prepare_block_for_update,\n+\tprepare_def_site_for): Use mark_block_for_update.\n+\t(mark_def_interesting): Assert that the processed block is marked in\n+\tblocks_to_update.  Do not take blocks argument.\n+\t(prepare_use_sites_for, prepare_names_to_update): Do not take blocks\n+\targument.\n+\t(rewrite_update_init_block, rewrite_update_stmt): Only process\n+\tblocks with statements to rewrite.\n+\t(delete_update_ssa): Do not clear SSA_NAME_AUX.\n+\t(update_ssa): Initialize and free blocks_to_update.  Do not\n+\tclear flags on statements.  Do not use blocks bitmap.\n+\t* tree.h (SSA_NAME_AUX): Removed.\n+\t(struct tree_ssa_name): Removed aux field.\n+\t* print-tree.c (print_node): Do not print SSA_NAME_AUX.\n+\n 2006-05-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/27603"}, {"sha": "bfa3ac0a1d6a3a4176e2487290e90d7165e1a225", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=95dd3097939517ea3a4f7631407f9300288a98e3", "patch": "@@ -822,8 +822,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t    fprintf (file, \" in-free-list\");\n \n \t  if (SSA_NAME_PTR_INFO (node)\n-\t      || SSA_NAME_VALUE (node)\n-\t      || SSA_NAME_AUX (node))\n+\t      || SSA_NAME_VALUE (node))\n \t    {\n \t      indent_to (file, indent + 3);\n \t      if (SSA_NAME_PTR_INFO (node))\n@@ -832,8 +831,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t      if (SSA_NAME_VALUE (node))\n \t\tfprintf (file, \" value %p\",\n \t\t\t (void *) SSA_NAME_VALUE (node));\n-\t      if (SSA_NAME_AUX (node))\n-\t\tfprintf (file, \" aux %p\", SSA_NAME_AUX (node));\n \t    }\n \t  break;\n "}, {"sha": "30f25b89d79a5a0e63406cf4800a70dd18983743", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 145, "deletions": 84, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=95dd3097939517ea3a4f7631407f9300288a98e3", "patch": "@@ -194,15 +194,31 @@ struct mark_def_sites_global_data\n /* Information stored for SSA names.  */\n struct ssa_name_info\n {\n+  /* The actual definition of the ssa name.  */\n+  tree current_def;\n+\n   /* This field indicates whether or not the variable may need PHI nodes.\n      See the enum's definition for more detailed information about the\n      states.  */\n   ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n \n-  /* The actual definition of the ssa name.  */\n-  tree current_def;\n+  /* Age of this record (so that info_for_ssa_name table can be cleared\n+     quicky); if AGE < CURRENT_INFO_FOR_SSA_NAME_AGE, then the fields\n+     are assumed to be null.  */\n+  unsigned age;\n };\n \n+/* The information associated with names.  */\n+typedef struct ssa_name_info *ssa_name_info_p;\n+DEF_VEC_P (ssa_name_info_p);\n+DEF_VEC_ALLOC_P (ssa_name_info_p, heap);\n+\n+static VEC(ssa_name_info_p, heap) *info_for_ssa_name;\n+static unsigned current_info_for_ssa_name_age;\n+\n+/* The set of blocks affected by update_ssa.  */\n+\n+static bitmap blocks_to_update;\n \n /* The main entry point to the SSA renamer (rewrite_blocks) may be\n    called several times to do different, but related, tasks.\n@@ -251,12 +267,41 @@ void debug_names_replaced_by (tree);\n static inline struct ssa_name_info *\n get_ssa_name_ann (tree name)\n {\n-  if (!SSA_NAME_AUX (name))\n-    SSA_NAME_AUX (name) = xcalloc (1, sizeof (struct ssa_name_info));\n+  unsigned ver = SSA_NAME_VERSION (name);\n+  unsigned len = VEC_length (ssa_name_info_p, info_for_ssa_name);\n+  struct ssa_name_info *info;\n+\n+  if (ver >= len)\n+    {\n+      unsigned new_len = num_ssa_names;\n+\n+      VEC_reserve (ssa_name_info_p, heap, info_for_ssa_name, new_len);\n+      while (len++ < new_len)\n+\t{\n+\t  struct ssa_name_info *info = XCNEW (struct ssa_name_info);\n+\t  info->age = current_info_for_ssa_name_age;\n+\t  VEC_quick_push (ssa_name_info_p, info_for_ssa_name, info);\n+\t}\n+    }\n+\n+  info = VEC_index (ssa_name_info_p, info_for_ssa_name, ver);\n+  if (info->age < current_info_for_ssa_name_age)\n+    {\n+      info->need_phi_state = 0;\n+      info->current_def = NULL_TREE;\n+      info->age = current_info_for_ssa_name_age;\n+    }\n \n-  return (struct ssa_name_info *) SSA_NAME_AUX (name);\n+  return info;\n }\n \n+/* Clears info for ssa names.  */\n+\n+static void\n+clear_ssa_name_info (void)\n+{\n+  current_info_for_ssa_name_age++;\n+}\n \n /* Gets phi_state field for VAR.  */\n \n@@ -359,6 +404,45 @@ compute_global_livein (bitmap livein, bitmap def_blocks)\n }\n \n \n+/* Cleans up the REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT flags for\n+   all statements in basic block BB.  */\n+\n+static void\n+initialize_flags_in_bb (basic_block bb)\n+{\n+  tree phi, stmt;\n+  block_stmt_iterator bsi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      REWRITE_THIS_STMT (phi) = 0;\n+      REGISTER_DEFS_IN_THIS_STMT (phi) = 0;\n+    }\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      /* We are going to use the operand cache API, such as\n+\t SET_USE, SET_DEF, and FOR_EACH_IMM_USE_FAST.  The operand\n+\t cache for each statement should be up-to-date.  */\n+      gcc_assert (!stmt_modified_p (stmt));\n+      REWRITE_THIS_STMT (stmt) = 0;\n+      REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n+    }\n+}\n+\n+/* Mark block BB as interesting for update_ssa.  */\n+\n+static void\n+mark_block_for_update (basic_block bb)\n+{\n+  gcc_assert (blocks_to_update != NULL);\n+  if (bitmap_bit_p (blocks_to_update, bb->index))\n+    return;\n+  bitmap_set_bit (blocks_to_update, bb->index);\n+  initialize_flags_in_bb (bb);\n+}\n+\n /* Return the set of blocks where variable VAR is defined and the blocks\n    where VAR is live on entry (livein).  If no entry is found in\n    DEF_BLOCKS, a new one is created and returned.  */\n@@ -649,6 +733,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n   stmt = bsi_stmt (bsi);\n   update_stmt_if_modified (stmt);\n \n+  gcc_assert (blocks_to_update == NULL);\n   REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n   REWRITE_THIS_STMT (stmt) = 0;\n \n@@ -850,6 +935,8 @@ insert_phi_nodes_for (tree var, bitmap phi_insertion_points, bool update_p)\n \t\t\t    0, bb_index, bi)\n     {\n       bb = BASIC_BLOCK (bb_index);\n+      if (update_p)\n+\tmark_block_for_update (bb);\n \n       if (update_p && TREE_CODE (var) == SSA_NAME)\n \t{\n@@ -1059,6 +1146,7 @@ rewrite_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \n   /* If mark_def_sites decided that we don't need to rewrite this\n      statement, ignore it.  */\n+  gcc_assert (blocks_to_update == NULL);\n   if (!REWRITE_THIS_STMT (stmt) && !REGISTER_DEFS_IN_THIS_STMT (stmt))\n     return;\n \n@@ -1331,6 +1419,9 @@ rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   /* Mark the unwind point for this block.  */\n   VEC_safe_push (tree, heap, block_defs_stack, NULL_TREE);\n \n+  if (!bitmap_bit_p (blocks_to_update, bb->index))\n+    return;\n+\n   /* Mark the LHS if any of the arguments flows through an abnormal\n      edge.  */\n   is_abnormal_phi = false;\n@@ -1346,6 +1437,7 @@ rewrite_update_init_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n      register it as a new definition for its corresponding name.  Also\n      register definitions for names whose underlying symbols are\n      marked for renaming.  */\n+\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n     {\n       tree lhs, lhs_sym;\n@@ -1483,6 +1575,8 @@ rewrite_update_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   stmt = bsi_stmt (si);\n   ann = stmt_ann (stmt);\n \n+  gcc_assert (bitmap_bit_p (blocks_to_update, bb->index));\n+\n   /* Only update marked statements.  */\n   if (!REWRITE_THIS_STMT (stmt) && !REGISTER_DEFS_IN_THIS_STMT (stmt))\n     return;\n@@ -1843,11 +1937,10 @@ struct tree_opt_pass pass_build_ssa =\n    renamer.  BLOCKS is the set of blocks that need updating.  */\n \n static void\n-mark_def_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n-\t\t      bool insert_phi_p)\n+mark_def_interesting (tree var, tree stmt, basic_block bb, bool insert_phi_p)\n {\n+  gcc_assert (bitmap_bit_p (blocks_to_update, bb->index));\n   REGISTER_DEFS_IN_THIS_STMT (stmt) = 1;\n-  bitmap_set_bit (blocks, bb->index);\n \n   if (insert_phi_p)\n     {\n@@ -1872,19 +1965,20 @@ mark_def_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n \n /* Mark the use of VAR at STMT and BB as interesting for the\n    renamer.  INSERT_PHI_P is true if we are going to insert new PHI\n-   nodes.  BLOCKS is the set of blocks that need updating.  */\n+   nodes.  */\n \n static inline void\n-mark_use_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n-\t\t      bool insert_phi_p)\n+mark_use_interesting (tree var, tree stmt, basic_block bb, bool insert_phi_p)\n {\n   basic_block def_bb = bb_for_stmt (stmt);\n \n+  mark_block_for_update (def_bb);\n+  mark_block_for_update (bb);\n+\n   if (TREE_CODE (stmt) == PHI_NODE)\n     mark_phi_for_rewrite (def_bb, stmt);\n   else\n     REWRITE_THIS_STMT (stmt) = 1;\n-  bitmap_set_bit (blocks, bb->index);\n \n   /* If VAR has not been defined in BB, then it is live-on-entry\n      to BB.  Note that we cannot just use the block holding VAR's\n@@ -1903,20 +1997,21 @@ mark_use_interesting (tree var, tree stmt, basic_block bb, bitmap blocks,\n /* Do a dominator walk starting at BB processing statements that\n    reference symbols in SYMS_TO_RENAME.  This is very similar to\n    mark_def_sites, but the scan handles statements whose operands may\n-   already be SSA names.  Blocks that contain defs or uses of symbols\n-   in SYMS_TO_RENAME are added to BLOCKS.\n+   already be SSA names.\n \n    If INSERT_PHI_P is true, mark those uses as live in the\n    corresponding block.  This is later used by the PHI placement\n    algorithm to make PHI pruning decisions.  */\n \n static void\n-prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n+prepare_block_for_update (basic_block bb, bool insert_phi_p)\n {\n   basic_block son;\n   block_stmt_iterator si;\n   tree phi;\n \n+  mark_block_for_update (bb);\n+\n   /* Process PHI nodes marking interesting those that define or use\n      the symbols that we are interested in.  */\n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n@@ -1927,8 +2022,8 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n \n       if (symbol_marked_for_renaming (lhs_sym))\n \t{\n-\t  mark_use_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n-\t  mark_def_interesting (lhs_sym, phi, bb, blocks, insert_phi_p);\n+\t  mark_use_interesting (lhs_sym, phi, bb, insert_phi_p);\n+\t  mark_def_interesting (lhs_sym, phi, bb, insert_phi_p);\n \t}\n     }\n \n@@ -1947,7 +2042,7 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n \t  tree use = USE_FROM_PTR (use_p);\n \t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n \t  if (symbol_marked_for_renaming (sym))\n-\t    mark_use_interesting (use, stmt, bb, blocks, insert_phi_p);\n+\t    mark_use_interesting (use, stmt, bb, insert_phi_p);\n \t}\n \n       FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, i, SSA_OP_DEF)\n@@ -1956,7 +2051,7 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n \t  tree sym = DECL_P (def) ? def : SSA_NAME_VAR (def);\n \n \t  if (symbol_marked_for_renaming (sym))\n-\t    mark_def_interesting (def, stmt, bb, blocks, insert_phi_p);\n+\t    mark_def_interesting (def, stmt, bb, insert_phi_p);\n \t}\n \n       FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, i, SSA_OP_VIRTUAL_DEFS)\n@@ -1966,8 +2061,8 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n \n \t  if (symbol_marked_for_renaming (sym))\n \t    {\n-\t      mark_use_interesting (sym, stmt, bb, blocks, insert_phi_p);\n-\t      mark_def_interesting (sym, stmt, bb, blocks, insert_phi_p);\n+\t      mark_use_interesting (sym, stmt, bb, insert_phi_p);\n+\t      mark_def_interesting (sym, stmt, bb, insert_phi_p);\n \t    }\n \t}\n \n@@ -1977,15 +2072,15 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n \t  tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n \n \t  if (symbol_marked_for_renaming (sym))\n-\t    mark_use_interesting (sym, stmt, bb, blocks, insert_phi_p);\n+\t    mark_use_interesting (sym, stmt, bb, insert_phi_p);\n \t}\n     }\n \n   /* Now visit all the blocks dominated by BB.  */\n   for (son = first_dom_son (CDI_DOMINATORS, bb);\n       son;\n       son = next_dom_son (CDI_DOMINATORS, son))\n-    prepare_block_for_update (son, blocks, insert_phi_p);\n+    prepare_block_for_update (son, insert_phi_p);\n }\n \n \n@@ -1994,7 +2089,7 @@ prepare_block_for_update (basic_block bb, bitmap blocks, bool insert_phi_p)\n    prepare_names_to_update.  */\n \n static void\n-prepare_use_sites_for (tree name, bitmap blocks, bool insert_phi_p)\n+prepare_use_sites_for (tree name, bool insert_phi_p)\n {\n   use_operand_p use_p;\n   imm_use_iterator iter;\n@@ -2021,7 +2116,7 @@ prepare_use_sites_for (tree name, bitmap blocks, bool insert_phi_p)\n \t     placement algorithm may try to insert PHI nodes in blocks\n \t     that are not only unnecessary but also the renamer would\n \t     not know how to fill in.  */\n-\t  mark_use_interesting (name, stmt, bb, blocks, false);\n+\t  mark_use_interesting (name, stmt, bb, false);\n \n \t  /* As discussed above, we only want to mark NAME live-in\n \t     through the edge corresponding to its slot inside the PHI\n@@ -2043,7 +2138,7 @@ prepare_use_sites_for (tree name, bitmap blocks, bool insert_phi_p)\n \t{\n \t  /* For regular statements, mark this as an interesting use\n \t     for NAME.  */\n-\t  mark_use_interesting (name, stmt, bb, blocks, insert_phi_p);\n+\t  mark_use_interesting (name, stmt, bb, insert_phi_p);\n \t}\n     }\n }\n@@ -2054,7 +2149,7 @@ prepare_use_sites_for (tree name, bitmap blocks, bool insert_phi_p)\n    prepare_names_to_update.  */\n \n static void\n-prepare_def_site_for (tree name, bitmap blocks, bool insert_phi_p)\n+prepare_def_site_for (tree name, bool insert_phi_p)\n {\n   tree stmt;\n   basic_block bb;\n@@ -2067,18 +2162,18 @@ prepare_def_site_for (tree name, bitmap blocks, bool insert_phi_p)\n   if (bb)\n     {\n       gcc_assert (bb->index < last_basic_block);\n-      mark_def_interesting (name, stmt, bb, blocks, insert_phi_p);\n+      mark_block_for_update (bb);\n+      mark_def_interesting (name, stmt, bb, insert_phi_p);\n     }\n }\n \n \n /* Mark definition and use sites of names in NEW_SSA_NAMES and\n-   OLD_SSA_NAMES.  Add each definition block to BLOCKS.  INSERT_PHI_P\n-   is true if the caller wants to insert PHI nodes for newly created\n-   names.  */\n+   OLD_SSA_NAMES.  INSERT_PHI_P is true if the caller wants to insert\n+   PHI nodes for newly created names.  */\n \n static void\n-prepare_names_to_update (bitmap blocks, bool insert_phi_p)\n+prepare_names_to_update (bool insert_phi_p)\n {\n   unsigned i = 0;\n   bitmap_iterator bi;\n@@ -2097,15 +2192,15 @@ prepare_names_to_update (bitmap blocks, bool insert_phi_p)\n      names may be considered to be live-in on blocks that contain\n      definitions for their replacements.  */\n   EXECUTE_IF_SET_IN_SBITMAP (new_ssa_names, 0, i, sbi)\n-    prepare_def_site_for (ssa_name (i), blocks, insert_phi_p);\n+    prepare_def_site_for (ssa_name (i), insert_phi_p);\n \n   /* If an old name is in NAMES_TO_RELEASE, we cannot remove it from\n      OLD_SSA_NAMES, but we have to ignore its definition site.  */\n   EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n     {\n       if (names_to_release == NULL || !bitmap_bit_p (names_to_release, i))\n-\tprepare_def_site_for (ssa_name (i), blocks, insert_phi_p);\n-      prepare_use_sites_for (ssa_name (i), blocks, insert_phi_p);\n+\tprepare_def_site_for (ssa_name (i), insert_phi_p);\n+      prepare_use_sites_for (ssa_name (i), insert_phi_p);\n     }\n }\n \n@@ -2263,16 +2358,7 @@ delete_update_ssa (void)\n       BITMAP_FREE (names_to_release);\n     }\n \n-  for (i = 1; i < num_ssa_names; i++)\n-    {\n-      tree n = ssa_name (i);\n-\n-      if (n)\n-\t{\n-\t  free (SSA_NAME_AUX (n));\n-\t  SSA_NAME_AUX (n) = NULL;\n-\t}\n-    }\n+  clear_ssa_name_info ();\n }\n \n \n@@ -2664,7 +2750,6 @@ switch_virtuals_to_full_rewrite (void)\n void\n update_ssa (unsigned update_flags)\n {\n-  bitmap blocks;\n   basic_block bb, start_bb;\n   bitmap_iterator bi;\n   unsigned i = 0;\n@@ -2680,6 +2765,7 @@ update_ssa (unsigned update_flags)\n   blocks_with_phis_to_rewrite = BITMAP_ALLOC (NULL);\n   if (!phis_to_rewrite)\n     phis_to_rewrite = VEC_alloc (tree_vec, heap, last_basic_block);\n+  blocks_to_update = BITMAP_ALLOC (NULL);\n \n   /* Ensure that the dominance information is up-to-date.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -2719,33 +2805,6 @@ update_ssa (unsigned update_flags)\n       def_blocks = NULL;\n     }\n \n-  blocks = BITMAP_ALLOC (NULL);\n-\n-  /* Clear the REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT flags\n-     for every statement and PHI node.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator si;\n-      tree phi;\n-\n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  REWRITE_THIS_STMT (phi) = 0;\n-\t  REGISTER_DEFS_IN_THIS_STMT (phi) = 0;\n-\t}\n-\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-\t{\n-\t  tree stmt = bsi_stmt (si);\n-\t  /* We are going to use the operand cache API, such as\n-\t     SET_USE, SET_DEF, and FOR_EACH_IMM_USE_FAST.  The operand\n-\t     cache for each statement should be up-to-date.  */\n-\t  gcc_assert (!stmt_modified_p (stmt));\n-\t  REWRITE_THIS_STMT (stmt) = 0;\n-\t  REGISTER_DEFS_IN_THIS_STMT (stmt) = 0;\n-\t}\n-    }\n-\n   /* Heuristic to avoid massive slow downs when the replacement\n      mappings include lots of virtual names.  */\n   if (insert_phi_p && switch_virtuals_to_full_rewrite_p ())\n@@ -2756,7 +2815,7 @@ update_ssa (unsigned update_flags)\n      OLD_SSA_NAMES.  */\n   if (sbitmap_first_set_bit (new_ssa_names) >= 0)\n     {\n-      prepare_names_to_update (blocks, insert_phi_p);\n+      prepare_names_to_update (insert_phi_p);\n \n       /* If all the names in NEW_SSA_NAMES had been marked for\n \t removal, and there are no symbols to rename, then there's\n@@ -2780,13 +2839,14 @@ update_ssa (unsigned update_flags)\n \t in SYMS_TO_RENAME.  Mark interesting blocks and statements\n \t and set local live-in information for the PHI placement\n \t heuristics.  */\n-      prepare_block_for_update (start_bb, blocks, insert_phi_p);\n+      prepare_block_for_update (start_bb, insert_phi_p);\n     }\n   else\n     {\n       /* Otherwise, the entry block to the region is the nearest\n \t common dominator for the blocks in BLOCKS.  */\n-      start_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n+      start_bb = nearest_common_dominator_for_set (CDI_DOMINATORS,\n+\t\t\t\t\t\t   blocks_to_update);\n     }\n \n   /* If requested, insert PHI nodes at the iterated dominance frontier\n@@ -2815,14 +2875,14 @@ update_ssa (unsigned update_flags)\n \t  sbitmap tmp = sbitmap_alloc (old_ssa_names->n_bits);\n \t  sbitmap_copy (tmp, old_ssa_names);\n \t  EXECUTE_IF_SET_IN_SBITMAP (tmp, 0, i, sbi)\n-\t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks,\n+\t    insert_updated_phi_nodes_for (ssa_name (i), dfs, blocks_to_update,\n \t                                  update_flags);\n \t  sbitmap_free (tmp);\n \t}\n \n       EXECUTE_IF_SET_IN_BITMAP (syms_to_rename, 0, i, bi)\n-\tinsert_updated_phi_nodes_for (referenced_var (i), dfs, blocks,\n-\t    \t\t              update_flags);\n+\tinsert_updated_phi_nodes_for (referenced_var (i), dfs,\n+\t\t\t\t      blocks_to_update, update_flags);\n \n       FOR_EACH_BB (bb)\n \tBITMAP_FREE (dfs[bb->index]);\n@@ -2832,7 +2892,8 @@ update_ssa (unsigned update_flags)\n \t We need to re-compute START_BB to include the newly added\n \t blocks.  */\n       if (start_bb != ENTRY_BLOCK_PTR)\n-\tstart_bb = nearest_common_dominator_for_set (CDI_DOMINATORS, blocks);\n+\tstart_bb = nearest_common_dominator_for_set (CDI_DOMINATORS,\n+\t\t\t\t\t\t     blocks_to_update);\n     }\n \n   /* Reset the current definition for name and symbol before renaming\n@@ -2846,7 +2907,7 @@ update_ssa (unsigned update_flags)\n   /* Now start the renaming process at START_BB.  */\n   tmp = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (tmp);\n-  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n     SET_BIT (tmp, i);\n \n   rewrite_blocks (start_bb, REWRITE_UPDATE, tmp);\n@@ -2865,7 +2926,7 @@ update_ssa (unsigned update_flags)\n \t       start_bb->index);\n \n       c = 0;\n-      EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n \tc++;\n       fprintf (dump_file, \"Number of blocks in CFG: %d\\n\", last_basic_block);\n       fprintf (dump_file, \"Number of blocks to update: %d (%3.0f%%)\\n\\n\",\n@@ -2874,7 +2935,7 @@ update_ssa (unsigned update_flags)\n       if (dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"Affected blocks: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i, bi)\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks_to_update, 0, i, bi)\n \t    fprintf (dump_file, \"%u \", i);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n@@ -2892,7 +2953,7 @@ update_ssa (unsigned update_flags)\n       VEC_replace (tree_vec, phis_to_rewrite, i, NULL);\n     }\n   BITMAP_FREE (blocks_with_phis_to_rewrite);\n-  BITMAP_FREE (blocks);\n+  BITMAP_FREE (blocks_to_update);\n   delete_update_ssa ();\n \n   timevar_pop (TV_TREE_SSA_INCREMENTAL);"}, {"sha": "7a4ee33346a6811684559924bd0be821ef0394be", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95dd3097939517ea3a4f7631407f9300288a98e3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=95dd3097939517ea3a4f7631407f9300288a98e3", "patch": "@@ -1678,10 +1678,6 @@ struct tree_exp GTY(())\n #define SSA_NAME_VALUE(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.value_handle\n \n-/* Auxiliary pass-specific data.  */\n-#define SSA_NAME_AUX(N) \\\n-   SSA_NAME_CHECK (N)->ssa_name.aux\n-\n #ifndef _TREE_FLOW_H\n struct ptr_info_def;\n #endif\n@@ -1721,9 +1717,6 @@ struct tree_ssa_name GTY(())\n      as well.  */\n   tree value_handle;\n \n-  /* Auxiliary information stored with the ssa name.  */\n-  PTR GTY((skip)) aux;\n-\n   /* Immediate uses list for this SSA_NAME.  */\n   struct ssa_use_operand_d imm_uses;\n };"}]}