{"sha": "c3e46927e4504374677f4e17838e6e51b5d7b185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNlNDY5MjdlNDUwNDM3NDY3N2Y0ZTE3ODM4ZTZlNTFiNWQ3YjE4NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-05-04T09:08:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-05-04T09:08:01Z"}, "message": "tree.c (array_at_struct_end_p): Handle arrays at struct end with flexarrays more conservatively.\n\n2017-05-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree.c (array_at_struct_end_p): Handle arrays at struct\n\tend with flexarrays more conservatively.  Refactor and treat\n\tarrays of arrays or aggregates more strict.  Fix\n\tVIEW_CONVERT_EXPR handling.  Remove allow_compref argument.\n\t* tree.c (array_at_struct_end_p): Adjust prototype.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Adjust.\n\t* gimple-fold.c (get_range_strlen): Likewise.\n\t* tree-chkp.c (chkp_may_narrow_to_field): Likewise.\n\nFrom-SVN: r247581", "tree": {"sha": "060bfa97ff1fe70567c51cb7685cdc78194aa1db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/060bfa97ff1fe70567c51cb7685cdc78194aa1db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3e46927e4504374677f4e17838e6e51b5d7b185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e46927e4504374677f4e17838e6e51b5d7b185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e46927e4504374677f4e17838e6e51b5d7b185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e46927e4504374677f4e17838e6e51b5d7b185/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99b68476de7635380de3480b83e852a38fe36f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b68476de7635380de3480b83e852a38fe36f64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b68476de7635380de3480b83e852a38fe36f64"}], "stats": {"total": 90, "additions": 65, "deletions": 25}, "files": [{"sha": "1c01a1571c23e50891cb9e08d4fe352197370240", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -1,3 +1,14 @@\n+2017-05-04  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree.c (array_at_struct_end_p): Handle arrays at struct\n+\tend with flexarrays more conservatively.  Refactor and treat\n+\tarrays of arrays or aggregates more strict.  Fix\n+\tVIEW_CONVERT_EXPR handling.  Remove allow_compref argument.\n+\t* tree.c (array_at_struct_end_p): Adjust prototype.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Adjust.\n+\t* gimple-fold.c (get_range_strlen): Likewise.\n+\t* tree-chkp.c (chkp_may_narrow_to_field): Likewise.\n+\n 2017-05-04  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/31130"}, {"sha": "041f2a717607fb273b87c0570367f3a9bd40e7ad", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -1957,7 +1957,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t      || (TREE_CODE (t2) == COMPONENT_REF\n \t\t  /* For trailing arrays t2 doesn't have a size that\n \t\t     covers all valid accesses.  */\n-\t\t  && ! array_at_struct_end_p (t, false)))\n+\t\t  && ! array_at_struct_end_p (t)))\n \t    {\n \t      attrs.expr = t2;\n \t      attrs.offset_known_p = false;"}, {"sha": "d58f62207fa5dfe6dc8ee705b131eb6fe52f24e7", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -1235,7 +1235,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t\t the NUL.\n \t\t Set *FLEXP to true if the array whose bound is being\n \t\t used is at the end of a struct.  */\n-\t      if (array_at_struct_end_p (arg, true))\n+\t      if (array_at_struct_end_p (arg))\n \t\t*flexp = true;\n \n \t      arg = TREE_OPERAND (arg, 1);"}, {"sha": "23f5af98ae3d5b84488a11ac609c1b5f4eadc842", "filename": "gcc/tree-chkp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chkp.c?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -3277,7 +3277,7 @@ chkp_may_narrow_to_field (tree ref, tree field)\n   return DECL_SIZE (field) && TREE_CODE (DECL_SIZE (field)) == INTEGER_CST\n     && tree_to_uhwi (DECL_SIZE (field)) != 0\n     && !(flag_chkp_flexible_struct_trailing_arrays\n-\t && array_at_struct_end_p (ref, true))\n+\t && array_at_struct_end_p (ref))\n     && (!DECL_FIELD_OFFSET (field)\n \t|| TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST)\n     && (!DECL_FIELD_BIT_OFFSET (field)"}, {"sha": "3bc6f1c284d2e0ae6a1263adfbca512d50a0b99f", "filename": "gcc/tree.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -13221,38 +13221,69 @@ array_ref_up_bound (tree exp)\n   return NULL_TREE;\n }\n \n-/* Returns true if REF is an array reference to an array at the end of\n-   a structure.  If this is the case, the array may be allocated larger\n-   than its upper bound implies.  When ALLOW_COMPREF is true considers\n-   REF when it's a COMPONENT_REF in addition ARRAY_REF and\n-   ARRAY_RANGE_REF.  */\n+/* Returns true if REF is an array reference or a component reference\n+   to an array at the end of a structure.\n+   If this is the case, the array may be allocated larger\n+   than its upper bound implies.  */\n \n bool\n-array_at_struct_end_p (tree ref, bool allow_compref)\n+array_at_struct_end_p (tree ref)\n {\n-  if (TREE_CODE (ref) != ARRAY_REF\n-      && TREE_CODE (ref) != ARRAY_RANGE_REF\n-      && (!allow_compref || TREE_CODE (ref) != COMPONENT_REF))\n+  tree atype;\n+\n+  if (TREE_CODE (ref) == ARRAY_REF\n+      || TREE_CODE (ref) == ARRAY_RANGE_REF)\n+    {\n+      atype = TREE_TYPE (TREE_OPERAND (ref, 0));\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+  else if (TREE_CODE (ref) == COMPONENT_REF\n+\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 1))) == ARRAY_TYPE)\n+    atype = TREE_TYPE (TREE_OPERAND (ref, 1));\n+  else\n     return false;\n \n   while (handled_component_p (ref))\n     {\n       /* If the reference chain contains a component reference to a\n          non-union type and there follows another field the reference\n \t is not at the end of a structure.  */\n-      if (TREE_CODE (ref) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == RECORD_TYPE)\n+      if (TREE_CODE (ref) == COMPONENT_REF)\n \t{\n-\t  tree nextf = DECL_CHAIN (TREE_OPERAND (ref, 1));\n-\t  while (nextf && TREE_CODE (nextf) != FIELD_DECL)\n-\t    nextf = DECL_CHAIN (nextf);\n-\t  if (nextf)\n-\t    return false;\n+\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0))) == RECORD_TYPE)\n+\t    {\n+\t      tree nextf = DECL_CHAIN (TREE_OPERAND (ref, 1));\n+\t      while (nextf && TREE_CODE (nextf) != FIELD_DECL)\n+\t\tnextf = DECL_CHAIN (nextf);\n+\t      if (nextf)\n+\t\treturn false;\n+\t    }\n \t}\n+      /* If we have a multi-dimensional array we do not consider\n+         a non-innermost dimension as flex array if the whole\n+\t multi-dimensional array is at struct end.\n+\t Same for an array of aggregates with a trailing array\n+\t member.  */\n+      else if (TREE_CODE (ref) == ARRAY_REF)\n+\treturn false;\n+      else if (TREE_CODE (ref) == ARRAY_RANGE_REF)\n+\t;\n+      /* If we view an underlying object as sth else then what we\n+         gathered up to now is what we have to rely on.  */\n+      else if (TREE_CODE (ref) == VIEW_CONVERT_EXPR)\n+\tbreak;\n+      else\n+\tgcc_unreachable ();\n \n       ref = TREE_OPERAND (ref, 0);\n     }\n \n+  /* The array now is at struct end.  Treat flexible arrays as\n+     always subject to extend, even into just padding constrained by\n+     an underlying decl.  */\n+  if (! TYPE_SIZE (atype))\n+    return true;\n+\n   tree size = NULL;\n \n   if (TREE_CODE (ref) == MEM_REF"}, {"sha": "1b7d86a5257d3b2b25b1457960c986a39df2821c", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3e46927e4504374677f4e17838e6e51b5d7b185/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c3e46927e4504374677f4e17838e6e51b5d7b185", "patch": "@@ -4886,12 +4886,10 @@ extern tree array_ref_up_bound (tree);\n    EXP, an ARRAY_REF or an ARRAY_RANGE_REF.  */\n extern tree array_ref_low_bound (tree);\n \n-/* Returns true if REF is an array reference to an array at the end of\n-   a structure.  If this is the case, the array may be allocated larger\n-   than its upper bound implies.  When second argument is true considers\n-   REF when it's a COMPONENT_REF in addition ARRAY_REF and\n-   ARRAY_RANGE_REF.  */\n-extern bool array_at_struct_end_p (tree, bool = false);\n+/* Returns true if REF is an array reference or a component reference\n+   to an array at the end of a structure.  If this is the case, the array\n+   may be allocated larger than its upper bound implies.  */\n+extern bool array_at_struct_end_p (tree);\n \n /* Return a tree representing the offset, in bytes, of the field referenced\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */"}]}