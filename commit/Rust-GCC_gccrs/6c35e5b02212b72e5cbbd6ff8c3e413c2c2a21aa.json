{"sha": "6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMzNWU1YjAyMjEyYjcyZTVjYmJkNmZmOGMzZTQxM2MyYzJhMjFhYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-07-28T13:38:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-07-28T13:38:01Z"}, "message": "match.pd: Remove superfluous :c.\n\n2017-07-28  Richard Biener  <rguenther@suse.de>\n\n\t* match.pd: Remove superfluous :c.\n\t* genmatch.c (simplify::id): Add member.\n\t(lower_commutative, lower_opt_convert, lower_cond, lower_for):\n\tCopy id.\n\t(current_id): New global.\n\t(dt_node::parent): Move from ...\n\t(dt_operand::parent): ... here.  Add for_id member.\n\t(is_a_helper <dt_operand *>::test): DT_TRUE is also a dt_operand.\n\t(decision_tree::find_node): Relax order requirement when\n\tmerging DT_TRUE nodes to ones inbetween the current simplify\n\tand the one we try to merge with.  Add diagnostic whenever\n\twe need to enforce pattern order by not merging.\n\t(decision_tree::insert): Set current_id.\n\t(decision_tree::print_node): Dump parent node and for_id.\n\t(parser::last_id): Add member.\n\t(parser::push_simplify): Assign unique id.\n\t(parser::parser): Initialize last_id.\n\nFrom-SVN: r250664", "tree": {"sha": "7d9a4dd35344453e4c7b4f54238b8528c9c4c9e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9a4dd35344453e4c7b4f54238b8528c9c4c9e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d7649f8b71f9a16b5e9de0b3f8826c5039fa069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d7649f8b71f9a16b5e9de0b3f8826c5039fa069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d7649f8b71f9a16b5e9de0b3f8826c5039fa069"}], "stats": {"total": 145, "additions": 108, "deletions": 37}, "files": [{"sha": "d153c139b64db7b37d65e62d76f998143d546f7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "patch": "@@ -1,3 +1,23 @@\n+2017-07-28  Richard Biener  <rguenther@suse.de>\n+\n+\t* match.pd: Remove superfluous :c.\n+\t* genmatch.c (simplify::id): Add member.\n+\t(lower_commutative, lower_opt_convert, lower_cond, lower_for):\n+\tCopy id.\n+\t(current_id): New global.\n+\t(dt_node::parent): Move from ...\n+\t(dt_operand::parent): ... here.  Add for_id member.\n+\t(is_a_helper <dt_operand *>::test): DT_TRUE is also a dt_operand.\n+\t(decision_tree::find_node): Relax order requirement when\n+\tmerging DT_TRUE nodes to ones inbetween the current simplify\n+\tand the one we try to merge with.  Add diagnostic whenever\n+\twe need to enforce pattern order by not merging.\n+\t(decision_tree::insert): Set current_id.\n+\t(decision_tree::print_node): Dump parent node and for_id.\n+\t(parser::last_id): Add member.\n+\t(parser::push_simplify): Assign unique id.\n+\t(parser::parser): Initialize last_id.\n+\n 2017-07-28  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/81340"}, {"sha": "9da911a3695e629494c30b2c16f8e8318e2aa480", "filename": "gcc/genmatch.c", "status": "modified", "additions": 87, "deletions": 36, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "patch": "@@ -793,13 +793,17 @@ struct simplify\n {\n   enum simplify_kind { SIMPLIFY, MATCH };\n \n-  simplify (simplify_kind kind_, operand *match_, operand *result_,\n-\t    vec<vec<user_id *> > for_vec_, cid_map_t *capture_ids_)\n-      : kind (kind_), match (match_), result (result_),\n+  simplify (simplify_kind kind_, unsigned id_, operand *match_,\n+\t    operand *result_, vec<vec<user_id *> > for_vec_,\n+\t    cid_map_t *capture_ids_)\n+      : kind (kind_), id (id_), match (match_), result (result_),\n       for_vec (for_vec_), for_subst_vec (vNULL),\n       capture_ids (capture_ids_), capture_max (capture_ids_->elements () - 1) {}\n \n   simplify_kind kind;\n+  /* ID.  This is kept to easily associate related simplifies expanded\n+     from the same original one.  */\n+  unsigned id;\n   /* The expression that is matched against the GENERIC or GIMPLE IL.  */\n   operand *match;\n   /* For a (simplify ...) an expression with ifs and withs with the expression\n@@ -1008,7 +1012,7 @@ lower_commutative (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = commutate (s->match, s->for_vec);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n+      simplify *ns = new simplify (s->kind, s->id, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1137,7 +1141,7 @@ lower_opt_convert (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_opt_convert (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n+      simplify *ns = new simplify (s->kind, s->id, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1238,7 +1242,7 @@ lower_cond (simplify *s, vec<simplify *>& simplifiers)\n   vec<operand *> matchers = lower_cond (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n-      simplify *ns = new simplify (s->kind, matchers[i], s->result,\n+      simplify *ns = new simplify (s->kind, s->id, matchers[i], s->result,\n \t\t\t\t   s->for_vec, s->capture_ids);\n       simplifiers.safe_push (ns);\n     }\n@@ -1453,7 +1457,7 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t      if (skip)\n \t\tcontinue;\n \n-\t      simplify *ns = new simplify (s->kind, match_op, result_op,\n+\t      simplify *ns = new simplify (s->kind, s->id, match_op, result_op,\n \t\t\t\t\t   vNULL, s->capture_ids);\n \t      ns->for_subst_vec.safe_splice (s->for_subst_vec);\n \t      if (result_op\n@@ -1527,28 +1531,34 @@ struct sinfo_hashmap_traits : simple_hashmap_traits<pointer_hash<dt_simplify>,\n typedef hash_map<void * /* unused */, sinfo *, sinfo_hashmap_traits>\n   sinfo_map_t;\n \n+/* Current simplifier ID we are processing during insertion into the\n+   decision tree.  */\n+static unsigned current_id;\n \n-/* Decision tree base class, used for DT_TRUE and DT_NODE.  */\n+/* Decision tree base class, used for DT_NODE.  */\n \n struct dt_node\n {\n   enum dt_type { DT_NODE, DT_OPERAND, DT_TRUE, DT_MATCH, DT_SIMPLIFY };\n \n   enum dt_type type;\n   unsigned level;\n+  dt_node *parent;\n   vec<dt_node *> kids;\n \n   /* Statistics.  */\n   unsigned num_leafs;\n   unsigned total_size;\n   unsigned max_level;\n \n-  dt_node (enum dt_type type_): type (type_), level (0), kids (vNULL) {}\n+  dt_node (enum dt_type type_, dt_node *parent_)\n+    : type (type_), level (0), parent (parent_), kids (vNULL) {}\n \n   dt_node *append_node (dt_node *);\n-  dt_node *append_op (operand *, dt_node *parent = 0, unsigned pos = 0);\n-  dt_node *append_true_op (dt_node *parent = 0, unsigned pos = 0);\n-  dt_node *append_match_op (dt_operand *, dt_node *parent = 0, unsigned pos = 0);\n+  dt_node *append_op (operand *, dt_node *parent, unsigned pos);\n+  dt_node *append_true_op (operand *, dt_node *parent, unsigned pos);\n+  dt_node *append_match_op (operand *, dt_operand *, dt_node *parent,\n+\t\t\t    unsigned pos);\n   dt_node *append_simplify (simplify *, unsigned, dt_operand **);\n \n   virtual void gen (FILE *, int, bool) {}\n@@ -1561,20 +1571,20 @@ struct dt_node\n   void analyze (sinfo_map_t &);\n };\n \n-/* Generic decision tree node used for DT_OPERAND and DT_MATCH.  */\n+/* Generic decision tree node used for DT_OPERAND, DT_MATCH and DT_TRUE.  */\n \n struct dt_operand : public dt_node\n {\n   operand *op;\n   dt_operand *match_dop;\n-  dt_operand *parent;\n   unsigned pos;\n   bool value_match;\n+  unsigned for_id;\n \n   dt_operand (enum dt_type type, operand *op_, dt_operand *match_dop_,\n-\t      dt_operand *parent_ = 0, unsigned pos_ = 0)\n-      : dt_node (type), op (op_), match_dop (match_dop_),\n-      parent (parent_), pos (pos_), value_match (false) {}\n+\t      dt_operand *parent_, unsigned pos_)\n+      : dt_node (type, parent_), op (op_), match_dop (match_dop_),\n+      pos (pos_), value_match (false), for_id (current_id) {}\n \n   void gen (FILE *, int, bool);\n   unsigned gen_predicate (FILE *, int, const char *, bool);\n@@ -1597,7 +1607,7 @@ struct dt_simplify : public dt_node\n   sinfo *info;\n \n   dt_simplify (simplify *s_, unsigned pattern_no_, dt_operand **indexes_)\n-\t: dt_node (DT_SIMPLIFY), s (s_), pattern_no (pattern_no_),\n+\t: dt_node (DT_SIMPLIFY, NULL), s (s_), pattern_no (pattern_no_),\n \t  indexes (indexes_), info (NULL)  {}\n \n   void gen_1 (FILE *, int, bool, operand *);\n@@ -1610,7 +1620,8 @@ inline bool\n is_a_helper <dt_operand *>::test (dt_node *n)\n {\n   return (n->type == dt_node::DT_OPERAND\n-\t  || n->type == dt_node::DT_MATCH);\n+\t  || n->type == dt_node::DT_MATCH\n+\t  || n->type == dt_node::DT_TRUE);\n }\n \n template<>\n@@ -1633,7 +1644,7 @@ struct decision_tree\n   void gen (FILE *f, bool gimple);\n   void print (FILE *f = stderr);\n \n-  decision_tree () { root = new dt_node (dt_node::DT_NODE); }\n+  decision_tree () { root = new dt_node (dt_node::DT_NODE, NULL); }\n \n   static dt_node *insert_operand (dt_node *, operand *, dt_operand **indexes,\n \t\t\t\t  unsigned pos = 0, dt_node *parent = 0);\n@@ -1703,15 +1714,48 @@ decision_tree::find_node (vec<dt_node *>& ops, dt_node *p)\n       && !ops.is_empty ()\n       && ops.last ()->type == dt_node::DT_TRUE)\n     return ops.last ();\n+  dt_operand *true_node = NULL;\n   for (int i = ops.length () - 1; i >= 0; --i)\n     {\n       /* But we can't merge across DT_TRUE nodes as they serve as\n          pattern order barriers to make sure that patterns apply\n \t in order of appearance in case multiple matches are possible.  */\n       if (ops[i]->type == dt_node::DT_TRUE)\n-\treturn NULL;\n+\t{\n+\t  if (! true_node\n+\t      || as_a <dt_operand *> (ops[i])->for_id > true_node->for_id)\n+\t    true_node = as_a <dt_operand *> (ops[i]);\n+\t}\n       if (decision_tree::cmp_node (ops[i], p))\n-\treturn ops[i];\n+\t{\n+\t  /* Unless we are processing the same pattern or the blocking\n+\t     pattern is before the one we are going to merge with.  */\n+\t  if (true_node\n+\t      && true_node->for_id != current_id\n+\t      && true_node->for_id > as_a <dt_operand *> (ops[i])->for_id)\n+\t    {\n+\t      if (verbose >= 1)\n+\t\t{\n+\t\t  source_location p_loc = 0;\n+\t\t  if (p->type == dt_node::DT_OPERAND)\n+\t\t    p_loc = as_a <dt_operand *> (p)->op->location;\n+\t\t  source_location op_loc = 0;\n+\t\t  if (ops[i]->type == dt_node::DT_OPERAND)\n+\t\t    op_loc = as_a <dt_operand *> (ops[i])->op->location;\n+\t\t  source_location true_loc = 0;\n+\t\t  true_loc = true_node->op->location;\n+\t\t  warning_at (p_loc,\n+\t\t\t      \"failed to merge decision tree node\");\n+\t\t  warning_at (op_loc,\n+\t\t\t      \"with the following\");\n+\t\t  warning_at (true_loc,\n+\t\t\t      \"because of the following which serves as ordering \"\n+\t\t\t      \"barrier\");\n+\t\t}\n+\t      return NULL;\n+\t    }\n+\t  return ops[i];\n+\t}\n     }\n   return NULL;\n }\n@@ -1747,20 +1791,21 @@ dt_node::append_op (operand *op, dt_node *parent, unsigned pos)\n /* Append a DT_TRUE decision tree node.  */\n \n dt_node *\n-dt_node::append_true_op (dt_node *parent, unsigned pos)\n+dt_node::append_true_op (operand *op, dt_node *parent, unsigned pos)\n {\n   dt_operand *parent_ = safe_as_a<dt_operand *> (parent);\n-  dt_operand *n = new dt_operand (DT_TRUE, 0, 0, parent_, pos);\n+  dt_operand *n = new dt_operand (DT_TRUE, op, 0, parent_, pos);\n   return append_node (n);\n }\n \n /* Append a DT_MATCH decision tree node.  */\n \n dt_node *\n-dt_node::append_match_op (dt_operand *match_dop, dt_node *parent, unsigned pos)\n+dt_node::append_match_op (operand *op, dt_operand *match_dop,\n+\t\t\t  dt_node *parent, unsigned pos)\n {\n   dt_operand *parent_ = as_a<dt_operand *> (parent);\n-  dt_operand *n = new dt_operand (DT_MATCH, 0, match_dop, parent_, pos);\n+  dt_operand *n = new dt_operand (DT_MATCH, op, match_dop, parent_, pos);\n   return append_node (n);\n }\n \n@@ -1839,7 +1884,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n \t    q = insert_operand (p, c->what, indexes, pos, parent);\n \t  else\n \t    {\n-\t      q = elm = p->append_true_op (parent, pos);\n+\t      q = elm = p->append_true_op (o, parent, pos);\n \t      goto at_assert_elm;\n \t    }\n \t  // get to the last capture\n@@ -1853,19 +1898,19 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n \t      unsigned cc_index = c->where;\n \t      dt_operand *match_op = indexes[cc_index];\n \n-\t      dt_operand temp (dt_node::DT_TRUE, 0, 0);\n+\t      dt_operand temp (dt_node::DT_TRUE, 0, 0, 0, 0);\n \t      elm = decision_tree::find_node (p->kids, &temp);\n \n \t      if (elm == 0)\n \t\t{\n-\t\t  dt_operand temp (dt_node::DT_MATCH, 0, match_op);\n+\t\t  dt_operand temp (dt_node::DT_MATCH, 0, match_op, 0, 0);\n \t\t  temp.value_match = c->value_match;\n \t\t  elm = decision_tree::find_node (p->kids, &temp);\n \t\t}\n \t    }\n \t  else\n \t    {\n-\t      dt_operand temp (dt_node::DT_OPERAND, c->what, 0);\n+\t      dt_operand temp (dt_node::DT_OPERAND, c->what, 0, 0, 0);\n \t      elm = decision_tree::find_node (p->kids, &temp);\n \t    }\n \n@@ -1878,7 +1923,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n \t}\n       else\n \t{\n-\t  p = p->append_match_op (indexes[capt_index], parent, pos);\n+\t  p = p->append_match_op (o, indexes[capt_index], parent, pos);\n \t  as_a <dt_operand *>(p)->value_match = c->value_match;\n \t  if (c->what)\n \t    return insert_operand (p, c->what, indexes, 0, p);\n@@ -1903,6 +1948,7 @@ decision_tree::insert_operand (dt_node *p, operand *o, dt_operand **indexes,\n void\n decision_tree::insert (struct simplify *s, unsigned pattern_no)\n {\n+  current_id = s->id;\n   dt_operand **indexes = XCNEWVEC (dt_operand *, s->capture_max + 1);\n   dt_node *p = decision_tree::insert_operand (root, s->match, indexes);\n   p->append_simplify (s, pattern_no, indexes);\n@@ -1938,9 +1984,12 @@ decision_tree::print_node (dt_node *p, FILE *f, unsigned indent)\n \t    fprintf (f, \"%p, \", (void *) s->indexes[i]);\n \t  fprintf (f, \" } \");\n \t}\n+      if (is_a <dt_operand *> (p))\n+\tfprintf (f, \" [%u]\", as_a <dt_operand *> (p)->for_id);\n     }\n \n-  fprintf (stderr, \" (%p), %u, %u\\n\", (void *) p, p->level, p->kids.length ());\n+  fprintf (stderr, \" (%p, %p), %u, %u\\n\",\n+\t   (void *) p, (void *) p->parent, p->level, p->kids.length ());\n \n   for (unsigned i = 0; i < p->kids.length (); ++i)\n     decision_tree::print_node (p->kids[i], f, indent + 2);\n@@ -2572,12 +2621,12 @@ capture::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n char *\n dt_operand::get_name (char *name)\n {\n-  if (!parent)\n+  if (! parent)\n     sprintf (name, \"t\");\n   else if (parent->level == 1)\n     sprintf (name, \"op%u\", pos);\n   else if (parent->type == dt_node::DT_MATCH)\n-    return parent->get_name (name);\n+    return as_a <dt_operand *> (parent)->get_name (name);\n   else\n     sprintf (name, \"o%u%u\", parent->level, pos);\n   return name;\n@@ -2588,7 +2637,7 @@ dt_operand::get_name (char *name)\n void\n dt_operand::gen_opname (char *name, unsigned pos)\n {\n-  if (!parent)\n+  if (! parent)\n     sprintf (name, \"op%u\", pos);\n   else\n     sprintf (name, \"o%u%u\", level, pos);\n@@ -3819,6 +3868,7 @@ class parser\n   vec<user_id *> oper_lists;\n \n   cid_map_t *capture_ids;\n+  unsigned last_id;\n \n public:\n   vec<simplify *> simplifiers;\n@@ -4314,7 +4364,7 @@ parser::push_simplify (simplify::simplify_kind kind,\n     active_fors.safe_push (oper_lists);\n \n   simplifiers.safe_push\n-    (new simplify (kind, match, result,\n+    (new simplify (kind, last_id++, match, result,\n \t\t   active_fors.copy (), capture_ids));\n \n   if (!oper_lists.is_empty ())\n@@ -4879,6 +4929,7 @@ parser::parser (cpp_reader *r_)\n   capture_ids = NULL;\n   user_predicates = vNULL;\n   parsing_match_operand = false;\n+  last_id = 0;\n \n   const cpp_token *token = next ();\n   while (token->type != CPP_EOF)"}, {"sha": "1cabcfc618a4b810ab18c62041d6e54b3720f52a", "filename": "gcc/match.pd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=6c35e5b02212b72e5cbbd6ff8c3e413c2c2a21aa", "patch": "@@ -900,7 +900,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (X | Y) | (X | Z) -> (X | Y) | Z  */\n (for op (bit_and bit_ior)\n  (simplify\n-  (op:c (convert1?@3 (op:c@4 @0 @1)) (convert2?@5 (op:c@6 @0 @2)))\n+  (op (convert1?@3 (op:c@4 @0 @1)) (convert2?@5 (op:c@6 @0 @2)))\n   (if (tree_nop_conversion_p (type, TREE_TYPE (@1))\n        && tree_nop_conversion_p (type, TREE_TYPE (@2)))\n    (if (single_use (@5) && single_use (@6))"}]}