{"sha": "51d180fcd7e6bce5093978e1a8ff64ac6e7624c7", "node_id": "C_kwDOANBUbNoAKDUxZDE4MGZjZDdlNmJjZTUwOTM5NzhlMWE4ZmY2NGFjNmU3NjI0Yzc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T17:05:43Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-21T11:36:40Z"}, "message": "gccrs: Add missing type resolution for function type segments\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-tyty-bounds.cc (TypeCheckBase::get_predicate_from_bound): Add missing\n\timplementation.", "tree": {"sha": "0fd5887ad89d69b1c69e42343f2f2bdfc0a02381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd5887ad89d69b1c69e42343f2f2bdfc0a02381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "875f722de5ead6e2e256bb62e13feb150617c381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875f722de5ead6e2e256bb62e13feb150617c381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875f722de5ead6e2e256bb62e13feb150617c381"}], "stats": {"total": 69, "additions": 62, "deletions": 7}, "files": [{"sha": "20a81ada6c41650cef90317e192a119d3a2c7dfd", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d180fcd7e6bce5093978e1a8ff64ac6e7624c7/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=51d180fcd7e6bce5093978e1a8ff64ac6e7624c7", "patch": "@@ -84,16 +84,71 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n     = HIR::GenericArgs::create_empty (type_path.get_locus ());\n \n   auto &final_seg = type_path.get_final_segment ();\n-  if (final_seg->is_generic_segment ())\n+  switch (final_seg->get_type ())\n     {\n-      auto final_generic_seg\n-\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n-      if (final_generic_seg->has_generic_args ())\n-\t{\n-\t  args = final_generic_seg->get_generic_args ();\n-\t}\n+      case HIR::TypePathSegment::SegmentType::GENERIC: {\n+\tauto final_generic_seg\n+\t  = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+\tif (final_generic_seg->has_generic_args ())\n+\t  {\n+\t    args = final_generic_seg->get_generic_args ();\n+\t  }\n+      }\n+      break;\n+\n+      case HIR::TypePathSegment::SegmentType::FUNCTION: {\n+\tauto final_function_seg\n+\t  = static_cast<HIR::TypePathSegmentFunction *> (final_seg.get ());\n+\tauto &fn = final_function_seg->get_function_path ();\n+\n+\t// we need to make implicit generic args which must be an implicit Tuple\n+\tauto crate_num = mappings->get_current_crate ();\n+\tHirId implicit_args_id = mappings->get_next_hir_id ();\n+\tAnalysis::NodeMapping mapping (crate_num,\n+\t\t\t\t       final_seg->get_mappings ().get_nodeid (),\n+\t\t\t\t       implicit_args_id, UNKNOWN_LOCAL_DEFID);\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> params_copy;\n+\tfor (auto &p : fn.get_params ())\n+\t  {\n+\t    params_copy.push_back (p->clone_type ());\n+\t  }\n+\n+\tHIR::TupleType *implicit_tuple\n+\t  = new HIR::TupleType (mapping, std::move (params_copy),\n+\t\t\t\tfinal_seg->get_locus ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Type>> inputs;\n+\tinputs.push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n+\n+\targs = HIR::GenericArgs ({} /* lifetimes */,\n+\t\t\t\t std::move (inputs) /* type_args*/,\n+\t\t\t\t {} /* binding_args*/, {} /* const_args */,\n+\t\t\t\t final_seg->get_locus ());\n+\n+\t// resolve the fn_once_output type\n+\tTyTy::BaseType *fn_once_output_ty\n+\t  = fn.has_return_type ()\n+\t      ? TypeCheckType::Resolve (fn.get_return_type ().get ())\n+\t      : TyTy::TupleType::get_unit_type (\n+\t\tfinal_seg->get_mappings ().get_hirid ());\n+\tcontext->insert_implicit_type (final_seg->get_mappings ().get_hirid (),\n+\t\t\t\t       fn_once_output_ty);\n+\n+\t// setup the associated type.. ??\n+\t// fn_once_output_ty->debug ();\n+      }\n+      break;\n+\n+    default:\n+      /* nothing to do */\n+      break;\n     }\n \n+  // FIXME\n+  // I think this should really be just be if the !args.is_empty() because\n+  // someone might wrongly apply generic arguments where they should not and\n+  // they will be missing error diagnostics\n   if (predicate.requires_generic_args ())\n     {\n       // this is applying generic arguments to a trait reference"}]}