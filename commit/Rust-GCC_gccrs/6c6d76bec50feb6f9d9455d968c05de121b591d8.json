{"sha": "6c6d76bec50feb6f9d9455d968c05de121b591d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM2ZDc2YmVjNTBmZWI2ZjlkOTQ1NWQ5NjhjMDVkZTEyMWI1OTFkOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T19:05:50Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T19:05:50Z"}, "message": "postreload-gcse.c: Use rtx_insn in various places\n\ngcc/\n\t* postreload-gcse.c (struct occr): Strengthen field \"insn\" from\n\trtx to rtx_insn *.\n\t(struct unoccr): Likewise.\n\t(struct modifies_mem): Likewise.\n\t(alloc_mem): Likewise for local \"insn\".\n\t(insert_expr_in_table): Likewise for param \"insn\".\n\t(dump_expr_hash_table_entry): Likewise for local \"insn\".\n\t(oprs_unchanged_p): Likewise for param \"insn\".\n\t(load_killed_in_block_p): Likewise for local \"setter\".\n\t(record_last_reg_set_info): Likewise for param \"insn\".\n\t(record_last_reg_set_info_regno): Likewise.\n\t(record_last_mem_set_info): Likewise.\n\t(record_last_set_info): Likewise for local \"last_set_insn\".\n\t(record_opr_changes): Likewise for param \"insn\".\n\t(hash_scan_set): Likewise.\n\t(compute_hash_table): Likewise for local \"insn\".\n\t(get_avail_load_store_reg): Likewise for param \"insn\".\n\t(eliminate_partially_redundant_load): Likewise, also for locals\n\t\"avail_insn\", \"next_pred_bb_end\".  Replace use of NULL_RTX with\n\tRTX for insns.\n\t(eliminate_partially_redundant_loads): Likewise for local \"insn\".\n\nFrom-SVN: r214356", "tree": {"sha": "39adb1582ac134d060877453f15302b976990b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39adb1582ac134d060877453f15302b976990b5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c6d76bec50feb6f9d9455d968c05de121b591d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6d76bec50feb6f9d9455d968c05de121b591d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c6d76bec50feb6f9d9455d968c05de121b591d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c6d76bec50feb6f9d9455d968c05de121b591d8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38295e01e2688696523e999002060a39545d218b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38295e01e2688696523e999002060a39545d218b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38295e01e2688696523e999002060a39545d218b"}], "stats": {"total": 86, "additions": 55, "deletions": 31}, "files": [{"sha": "6e6c06adcffa22f0c16daa9e2579de1f79b3e18f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6d76bec50feb6f9d9455d968c05de121b591d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6d76bec50feb6f9d9455d968c05de121b591d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c6d76bec50feb6f9d9455d968c05de121b591d8", "patch": "@@ -1,3 +1,27 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* postreload-gcse.c (struct occr): Strengthen field \"insn\" from\n+\trtx to rtx_insn *.\n+\t(struct unoccr): Likewise.\n+\t(struct modifies_mem): Likewise.\n+\t(alloc_mem): Likewise for local \"insn\".\n+\t(insert_expr_in_table): Likewise for param \"insn\".\n+\t(dump_expr_hash_table_entry): Likewise for local \"insn\".\n+\t(oprs_unchanged_p): Likewise for param \"insn\".\n+\t(load_killed_in_block_p): Likewise for local \"setter\".\n+\t(record_last_reg_set_info): Likewise for param \"insn\".\n+\t(record_last_reg_set_info_regno): Likewise.\n+\t(record_last_mem_set_info): Likewise.\n+\t(record_last_set_info): Likewise for local \"last_set_insn\".\n+\t(record_opr_changes): Likewise for param \"insn\".\n+\t(hash_scan_set): Likewise.\n+\t(compute_hash_table): Likewise for local \"insn\".\n+\t(get_avail_load_store_reg): Likewise for param \"insn\".\n+\t(eliminate_partially_redundant_load): Likewise, also for locals\n+\t\"avail_insn\", \"next_pred_bb_end\".  Replace use of NULL_RTX with\n+\tRTX for insns.\n+\t(eliminate_partially_redundant_loads): Likewise for local \"insn\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* optabs.c (expand_doubleword_shift): Strengthen local \"insn\" from"}, {"sha": "e8f040887c5d56a5a134a4609b8c4d2e65268770", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c6d76bec50feb6f9d9455d968c05de121b591d8/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c6d76bec50feb6f9d9455d968c05de121b591d8/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=6c6d76bec50feb6f9d9455d968c05de121b591d8", "patch": "@@ -162,7 +162,7 @@ struct occr\n   /* Next occurrence of this expression.  */\n   struct occr *next;\n   /* The insn that computes the expression.  */\n-  rtx insn;\n+  rtx_insn *insn;\n   /* Nonzero if this [anticipatable] occurrence has been deleted.  */\n   char deleted_p;\n };\n@@ -175,7 +175,7 @@ struct unoccr\n {\n   struct unoccr *next;\n   edge pred;\n-  rtx insn;\n+  rtx_insn *insn;\n };\n \n static struct obstack unoccr_obstack;\n@@ -194,7 +194,7 @@ static int *reg_avail_info;\n /* A list of insns that may modify memory within the current basic block.  */\n struct modifies_mem\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   struct modifies_mem *next;\n };\n static struct modifies_mem *modifies_mem_list;\n@@ -218,37 +218,37 @@ static void alloc_mem (void);\n static void free_mem (void);\n \n /* Support for hash table construction and transformations.  */\n-static bool oprs_unchanged_p (rtx, rtx, bool);\n-static void record_last_reg_set_info (rtx, rtx);\n-static void record_last_reg_set_info_regno (rtx, int);\n-static void record_last_mem_set_info (rtx);\n+static bool oprs_unchanged_p (rtx, rtx_insn *, bool);\n+static void record_last_reg_set_info (rtx_insn *, rtx);\n+static void record_last_reg_set_info_regno (rtx_insn *, int);\n+static void record_last_mem_set_info (rtx_insn *);\n static void record_last_set_info (rtx, const_rtx, void *);\n-static void record_opr_changes (rtx);\n+static void record_opr_changes (rtx_insn *);\n \n static void find_mem_conflicts (rtx, const_rtx, void *);\n static int load_killed_in_block_p (int, rtx, bool);\n static void reset_opr_set_tables (void);\n \n /* Hash table support.  */\n static hashval_t hash_expr (rtx, int *);\n-static void insert_expr_in_table (rtx, rtx);\n+static void insert_expr_in_table (rtx, rtx_insn *);\n static struct expr *lookup_expr_in_table (rtx);\n static void dump_hash_table (FILE *);\n \n /* Helpers for eliminate_partially_redundant_load.  */\n static bool reg_killed_on_edge (rtx, edge);\n static bool reg_used_on_edge (rtx, edge);\n \n-static rtx get_avail_load_store_reg (rtx);\n+static rtx get_avail_load_store_reg (rtx_insn *);\n \n static bool bb_has_well_behaved_predecessors (basic_block);\n static struct occr* get_bb_avail_insn (basic_block, struct occr *);\n-static void hash_scan_set (rtx);\n+static void hash_scan_set (rtx_insn *);\n static void compute_hash_table (void);\n \n /* The work horses of this pass.  */\n static void eliminate_partially_redundant_load (basic_block,\n-\t\t\t\t\t\trtx,\n+\t\t\t\t\t\trtx_insn *,\n \t\t\t\t\t\tstruct expr *);\n static void eliminate_partially_redundant_loads (void);\n \f\n@@ -261,7 +261,7 @@ alloc_mem (void)\n {\n   int i;\n   basic_block bb;\n-  rtx insn;\n+  rtx_insn *insn;\n \n   /* Find the largest UID and create a mapping from UIDs to CUIDs.  */\n   uid_cuid = XCNEWVEC (int, get_max_uid () + 1);\n@@ -323,7 +323,7 @@ free_mem (void)\n    basic block.  */\n \n static void\n-insert_expr_in_table (rtx x, rtx insn)\n+insert_expr_in_table (rtx x, rtx_insn *insn)\n {\n   int do_not_record_p;\n   hashval_t hash;\n@@ -444,7 +444,7 @@ dump_expr_hash_table_entry (expr **slot, FILE *file)\n   occr = exprs->avail_occr;\n   while (occr)\n     {\n-      rtx insn = occr->insn;\n+      rtx_insn *insn = occr->insn;\n       print_rtl_single (file, insn);\n       fprintf (file, \"\\n\");\n       occr = occr->next;\n@@ -492,7 +492,7 @@ reg_changed_after_insn_p (rtx x, int cuid)\n    2) from INSN to the end of INSN's basic block if AFTER_INSN is true.  */\n \n static bool\n-oprs_unchanged_p (rtx x, rtx insn, bool after_insn)\n+oprs_unchanged_p (rtx x, rtx_insn *insn, bool after_insn)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -606,7 +606,7 @@ load_killed_in_block_p (int uid_limit, rtx x, bool after_insn)\n \n   while (list_entry)\n     {\n-      rtx setter = list_entry->insn;\n+      rtx_insn *setter = list_entry->insn;\n \n       /* Ignore entries in the list that do not apply.  */\n       if ((after_insn\n@@ -642,7 +642,7 @@ load_killed_in_block_p (int uid_limit, rtx x, bool after_insn)\n /* Record register first/last/block set information for REGNO in INSN.  */\n \n static inline void\n-record_last_reg_set_info (rtx insn, rtx reg)\n+record_last_reg_set_info (rtx_insn *insn, rtx reg)\n {\n   unsigned int regno, end_regno;\n \n@@ -654,7 +654,7 @@ record_last_reg_set_info (rtx insn, rtx reg)\n }\n \n static inline void\n-record_last_reg_set_info_regno (rtx insn, int regno)\n+record_last_reg_set_info_regno (rtx_insn *insn, int regno)\n {\n   reg_avail_info[regno] = INSN_CUID (insn);\n }\n@@ -665,7 +665,7 @@ record_last_reg_set_info_regno (rtx insn, int regno)\n    a CALL_INSN).  We merely need to record which insns modify memory.  */\n \n static void\n-record_last_mem_set_info (rtx insn)\n+record_last_mem_set_info (rtx_insn *insn)\n {\n   struct modifies_mem *list_entry;\n \n@@ -683,7 +683,7 @@ record_last_mem_set_info (rtx insn)\n static void\n record_last_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n-  rtx last_set_insn = (rtx) data;\n+  rtx_insn *last_set_insn = (rtx_insn *) data;\n \n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n@@ -721,7 +721,7 @@ reset_opr_set_tables (void)\n    This data is used by oprs_unchanged_p.  */\n \n static void\n-record_opr_changes (rtx insn)\n+record_opr_changes (rtx_insn *insn)\n {\n   rtx note;\n \n@@ -763,7 +763,7 @@ record_opr_changes (rtx insn)\n    After reload we are interested in loads/stores only.  */\n \n static void\n-hash_scan_set (rtx insn)\n+hash_scan_set (rtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx src = SET_SRC (pat);\n@@ -831,7 +831,7 @@ compute_hash_table (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn;\n+      rtx_insn *insn;\n \n       /* First pass over the instructions records information used to\n \t determine when registers and memory are last set.\n@@ -889,7 +889,7 @@ reg_used_on_edge (rtx reg, edge e)\n /* Return the loaded/stored register of a load/store instruction.  */\n \n static rtx\n-get_avail_load_store_reg (rtx insn)\n+get_avail_load_store_reg (rtx_insn *insn)\n {\n   if (REG_P (SET_DEST (PATTERN (insn))))\n     /* A load.  */\n@@ -954,11 +954,11 @@ get_bb_avail_insn (basic_block bb, struct occr *occr)\n    a redundancy is also worth doing, assuming it is possible.  */\n \n static void\n-eliminate_partially_redundant_load (basic_block bb, rtx insn,\n+eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t\t\t\t    struct expr *expr)\n {\n   edge pred;\n-  rtx avail_insn = NULL_RTX;\n+  rtx_insn *avail_insn = NULL;\n   rtx avail_reg;\n   rtx dest, pat;\n   struct occr *a_occr;\n@@ -987,9 +987,9 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n   /* Check potential for replacing load with copy for predecessors.  */\n   FOR_EACH_EDGE (pred, ei, bb->preds)\n     {\n-      rtx next_pred_bb_end;\n+      rtx_insn *next_pred_bb_end;\n \n-      avail_insn = NULL_RTX;\n+      avail_insn = NULL;\n       avail_reg = NULL_RTX;\n       pred_bb = pred->src;\n       next_pred_bb_end = NEXT_INSN (BB_END (pred_bb));\n@@ -1052,7 +1052,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n \t  not_ok_count += pred->count;\n \t  unoccr = (struct unoccr *) obstack_alloc (&unoccr_obstack,\n \t\t\t\t\t\t    sizeof (struct unoccr));\n-\t  unoccr->insn = NULL_RTX;\n+\t  unoccr->insn = NULL;\n \t  unoccr->pred = pred;\n \t  unoccr->next = unavail_occrs;\n \t  unavail_occrs = unoccr;\n@@ -1154,7 +1154,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx insn,\n static void\n eliminate_partially_redundant_loads (void)\n {\n-  rtx insn;\n+  rtx_insn *insn;\n   basic_block bb;\n \n   /* Note we start at block 1.  */"}]}