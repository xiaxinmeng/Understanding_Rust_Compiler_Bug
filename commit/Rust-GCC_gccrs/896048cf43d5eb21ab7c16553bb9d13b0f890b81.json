{"sha": "896048cf43d5eb21ab7c16553bb9d13b0f890b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk2MDQ4Y2Y0M2Q1ZWIyMWFiN2MxNjU1M2JiOWQxM2IwZjg5MGI4MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-03T14:46:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-03T14:46:54Z"}, "message": "c++: Add __builtin_bit_cast to implement std::bit_cast [PR93121]\n\nThe following patch adds __builtin_bit_cast builtin, similarly to\nclang or MSVC which implement std::bit_cast using such an builtin too.\nIt checks the various std::bit_cast requirements, when not constexpr\nevaluated acts pretty much like VIEW_CONVERT_EXPR of the source argument\nto the destination type and the hardest part is obviously the constexpr\nevaluation.\nI've left out PDP11 handling of those, couldn't figure out how exactly are\nbitfields laid out there\n\n2020-12-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/93121\n\t* fold-const.h (native_encode_initializer): Add mask argument\n\tdefaulted to nullptr.\n\t(find_bitfield_repr_type): Declare.\n\t(native_interpret_aggregate): Declare.\n\t* fold-const.c (find_bitfield_repr_type): New function.\n\t(native_encode_initializer): Add mask argument and support for\n\tfilling it.  Handle also some bitfields without integral\n\tDECL_BIT_FIELD_REPRESENTATIVE.\n\t(native_interpret_aggregate): New function.\n\t* gimple-fold.h (clear_type_padding_in_mask): Declare.\n\t* gimple-fold.c (struct clear_padding_struct): Add clear_in_mask\n\tmember.\n\t(clear_padding_flush): Handle buf->clear_in_mask.\n\t(clear_padding_union): Copy clear_in_mask.  Don't error if\n\tbuf->clear_in_mask is set.\n\t(clear_padding_type): Don't error if buf->clear_in_mask is set.\n\t(clear_type_padding_in_mask): New function.\n\t(gimple_fold_builtin_clear_padding): Set buf.clear_in_mask to false.\n\t* doc/extend.texi (__builtin_bit_cast): Document.\n\n\t* c-common.h (enum rid): Add RID_BUILTIN_BIT_CAST.\n\t* c-common.c (c_common_reswords): Add __builtin_bit_cast.\n\n\t* cp-tree.h (cp_build_bit_cast): Declare.\n\t* cp-tree.def (BIT_CAST_EXPR): New tree code.\n\t* cp-objcp-common.c (names_builtin_p): Handle RID_BUILTIN_BIT_CAST.\n\t(cp_common_init_ts): Handle BIT_CAST_EXPR.\n\t* cxx-pretty-print.c (cxx_pretty_printer::postfix_expression):\n\tLikewise.\n\t* parser.c (cp_parser_postfix_expression): Handle\n\tRID_BUILTIN_BIT_CAST.\n\t* semantics.c (cp_build_bit_cast): New function.\n\t* tree.c (cp_tree_equal): Handle BIT_CAST_EXPR.\n\t(cp_walk_subtrees): Likewise.\n\t* pt.c (tsubst_copy): Likewise.\n\t* constexpr.c (check_bit_cast_type, cxx_eval_bit_cast): New functions.\n\t(cxx_eval_constant_expression): Handle BIT_CAST_EXPR.\n\t(potential_constant_expression_1): Likewise.\n\t* cp-gimplify.c (cp_genericize_r): Likewise.\n\n\t* g++.dg/cpp2a/bit-cast1.C: New test.\n\t* g++.dg/cpp2a/bit-cast2.C: New test.\n\t* g++.dg/cpp2a/bit-cast3.C: New test.\n\t* g++.dg/cpp2a/bit-cast4.C: New test.\n\t* g++.dg/cpp2a/bit-cast5.C: New test.", "tree": {"sha": "3d929f74e3ad0cd70a86d101744be4a961a57450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d929f74e3ad0cd70a86d101744be4a961a57450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/896048cf43d5eb21ab7c16553bb9d13b0f890b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896048cf43d5eb21ab7c16553bb9d13b0f890b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896048cf43d5eb21ab7c16553bb9d13b0f890b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896048cf43d5eb21ab7c16553bb9d13b0f890b81/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341035a54aa8954c66b0492f366b8c65fdb34299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/341035a54aa8954c66b0492f366b8c65fdb34299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/341035a54aa8954c66b0492f366b8c65fdb34299"}], "stats": {"total": 1316, "additions": 1264, "deletions": 52}, "files": [{"sha": "dda23520b96b0977eba581ee635c56325e017345", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -374,6 +374,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__auto_type\",\tRID_AUTO_TYPE,\tD_CONLY },\n   { \"__bases\",          RID_BASES, D_CXXONLY },\n   { \"__builtin_addressof\", RID_ADDRESSOF, D_CXXONLY },\n+  { \"__builtin_bit_cast\", RID_BUILTIN_BIT_CAST, D_CXXONLY },\n   { \"__builtin_call_with_static_chain\",\n     RID_BUILTIN_CALL_WITH_STATIC_CHAIN, D_CONLY },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, D_CONLY },"}, {"sha": "80830d812ccd7700b77f5f28882bcd0f8d3c1696", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -169,7 +169,7 @@ enum rid\n   RID_HAS_NOTHROW_COPY,        RID_HAS_TRIVIAL_ASSIGN,\n   RID_HAS_TRIVIAL_CONSTRUCTOR, RID_HAS_TRIVIAL_COPY,\n   RID_HAS_TRIVIAL_DESTRUCTOR,  RID_HAS_UNIQUE_OBJ_REPRESENTATIONS,\n-  RID_HAS_VIRTUAL_DESTRUCTOR,\n+  RID_HAS_VIRTUAL_DESTRUCTOR,  RID_BUILTIN_BIT_CAST,\n   RID_IS_ABSTRACT,             RID_IS_AGGREGATE,\n   RID_IS_BASE_OF,              RID_IS_CLASS,\n   RID_IS_EMPTY,                RID_IS_ENUM,"}, {"sha": "e0d358027c9ed93399c96ca9aa48da4ccf78a618", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -3950,6 +3950,205 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n   return error_mark_node;\n }\n \n+/* Helper for cxx_eval_bit_cast.\n+   Check [bit.cast]/3 rules, bit_cast is constexpr only if the To and From\n+   types and types of all subobjects have is_union_v<T>, is_pointer_v<T>,\n+   is_member_pointer_v<T>, is_volatile_v<T> false and has no non-static\n+   data members of reference type.  */\n+\n+static bool\n+check_bit_cast_type (const constexpr_ctx *ctx, location_t loc, tree type,\n+\t\t     tree orig_type)\n+{\n+  if (TREE_CODE (type) == UNION_TYPE)\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  if (type == orig_type)\n+\t    error_at (loc, \"%qs is not a constant expression because %qT is \"\n+\t\t\t   \"a union type\", \"__builtin_bit_cast\", type);\n+\t  else\n+\t    error_at (loc, \"%qs is not a constant expression because %qT \"\n+\t\t\t   \"contains a union type\", \"__builtin_bit_cast\",\n+\t\t      orig_type);\n+\t}\n+      return true;\n+    }\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  if (type == orig_type)\n+\t    error_at (loc, \"%qs is not a constant expression because %qT is \"\n+\t\t\t   \"a pointer type\", \"__builtin_bit_cast\", type);\n+\t  else\n+\t    error_at (loc, \"%qs is not a constant expression because %qT \"\n+\t\t\t   \"contains a pointer type\", \"__builtin_bit_cast\",\n+\t\t      orig_type);\n+\t}\n+      return true;\n+    }\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  if (type == orig_type)\n+\t    error_at (loc, \"%qs is not a constant expression because %qT is \"\n+\t\t\t   \"a reference type\", \"__builtin_bit_cast\", type);\n+\t  else\n+\t    error_at (loc, \"%qs is not a constant expression because %qT \"\n+\t\t\t   \"contains a reference type\", \"__builtin_bit_cast\",\n+\t\t      orig_type);\n+\t}\n+      return true;\n+    }\n+  if (TYPE_PTRMEM_P (type))\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  if (type == orig_type)\n+\t    error_at (loc, \"%qs is not a constant expression because %qT is \"\n+\t\t\t   \"a pointer to member type\", \"__builtin_bit_cast\",\n+\t\t      type);\n+\t  else\n+\t    error_at (loc, \"%qs is not a constant expression because %qT \"\n+\t\t\t   \"contains a pointer to member type\",\n+\t\t      \"__builtin_bit_cast\", orig_type);\n+\t}\n+      return true;\n+    }\n+  if (TYPE_VOLATILE (type))\n+    {\n+      if (!ctx->quiet)\n+\t{\n+\t  if (type == orig_type)\n+\t    error_at (loc, \"%qs is not a constant expression because %qT is \"\n+\t\t\t   \"volatile\", \"__builtin_bit_cast\", type);\n+\t  else\n+\t    error_at (loc, \"%qs is not a constant expression because %qT \"\n+\t\t\t   \"contains a volatile subobject\",\n+\t\t      \"__builtin_bit_cast\", orig_type);\n+\t}\n+      return true;\n+    }\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && check_bit_cast_type (ctx, loc, TREE_TYPE (field), orig_type))\n+\treturn true;\n+  return false;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+   Attempt to evaluate a BIT_CAST_EXPR.  */\n+\n+static tree\n+cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n+\t\t   bool *overflow_p)\n+{\n+  if (check_bit_cast_type (ctx, EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t   TREE_TYPE (t))\n+      || check_bit_cast_type (ctx, cp_expr_loc_or_loc (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t       EXPR_LOCATION (t)),\n+\t\t\t      TREE_TYPE (TREE_OPERAND (t, 0)),\n+\t\t\t      TREE_TYPE (TREE_OPERAND (t, 0))))\n+    {\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  tree op = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n+\t\t\t\t\t  non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n+\n+  location_t loc = EXPR_LOCATION (t);\n+  if (BITS_PER_UNIT != 8 || CHAR_BIT != 8)\n+    {\n+      if (!ctx->quiet)\n+\tsorry_at (loc, \"%qs cannot be constant evaluated on the target\",\n+\t\t       \"__builtin_bit_cast\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  if (!tree_fits_shwi_p (TYPE_SIZE_UNIT (TREE_TYPE (t))))\n+    {\n+      if (!ctx->quiet)\n+\tsorry_at (loc, \"%qs cannot be constant evaluated because the \"\n+\t\t       \"type is too large\", \"__builtin_bit_cast\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  HOST_WIDE_INT len = tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (t)));\n+  if (len < 0 || (int) len != len)\n+    {\n+      if (!ctx->quiet)\n+\tsorry_at (loc, \"%qs cannot be constant evaluated because the \"\n+\t\t       \"type is too large\", \"__builtin_bit_cast\");\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  unsigned char buf[64];\n+  unsigned char *ptr, *mask;\n+  size_t alen = (size_t) len * 2;\n+  if (alen <= sizeof (buf))\n+    ptr = buf;\n+  else\n+    ptr = XNEWVEC (unsigned char, alen);\n+  mask = ptr + (size_t) len;\n+  /* At the beginning consider everything indeterminate.  */\n+  memset (mask, ~0, (size_t) len);\n+\n+  if (native_encode_initializer (op, ptr, len, 0, mask) != len)\n+    {\n+      if (!ctx->quiet)\n+\tsorry_at (loc, \"%qs cannot be constant evaluated because the \"\n+\t\t       \"argument cannot be encoded\", \"__builtin_bit_cast\");\n+      *non_constant_p = true;\n+      if (ptr != buf)\n+\tXDELETE (ptr);\n+      return t;\n+    }\n+\n+  tree r = NULL_TREE;\n+  if (can_native_interpret_type_p (TREE_TYPE (t)))\n+    r = native_interpret_expr (TREE_TYPE (t), ptr, len);\n+  else if (TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE)\n+    {\n+      r = native_interpret_aggregate (TREE_TYPE (t), ptr, 0, len);\n+      if (r != NULL_TREE)\n+\tclear_type_padding_in_mask (TREE_TYPE (t), mask);\n+    }\n+\n+  if (r != NULL_TREE)\n+    {\n+      for (int i = 0; i < len; i++)\n+\tif (mask[i])\n+\t  {\n+\t    if (!ctx->quiet)\n+\t      error_at (loc, \"%qs accessing uninitialized byte at offset %d\",\n+\t\t\t     \"__builtin_bit_cast\", i);\n+\t    *non_constant_p = true;\n+\t    r = t;\n+\t    break;\n+\t  }\n+      if (ptr != buf)\n+\tXDELETE (ptr);\n+      return r;\n+    }\n+\n+  if (!ctx->quiet)\n+    sorry_at (loc, \"%qs cannot be constant evaluated because the \"\n+\t\t   \"argument cannot be interpreted\", \"__builtin_bit_cast\");\n+  *non_constant_p = true;\n+  if (ptr != buf)\n+    XDELETE (ptr);\n+  return t;\n+}\n+\n /* Subroutine of cxx_eval_constant_expression.\n    Evaluate a short-circuited logical expression T in the context\n    of a given constexpr CALL.  BAILOUT_VALUE is the value for\n@@ -6653,6 +6852,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       *non_constant_p = true;\n       return t;\n \n+    case BIT_CAST_EXPR:\n+      r = cxx_eval_bit_cast (ctx, t, non_constant_p, overflow_p);\n+      break;\n+\n     default:\n       if (STATEMENT_CODE_P (TREE_CODE (t)))\n \t{\n@@ -8442,6 +8645,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case ANNOTATE_EXPR:\n       return RECUR (TREE_OPERAND (t, 0), rval);\n \n+    case BIT_CAST_EXPR:\n+      return RECUR (TREE_OPERAND (t, 0), rval);\n+\n     /* Coroutine await, yield and return expressions are not.  */\n     case CO_AWAIT_EXPR:\n     case CO_YIELD_EXPR:"}, {"sha": "bafcaf5369d4f41e1ad577228dbd8d43894af095", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -1560,6 +1560,11 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t\t\t\t cp_genericize_r, cp_walk_subtrees);\n       break;\n \n+    case BIT_CAST_EXPR:\n+      *stmt_p = build1_loc (EXPR_LOCATION (stmt), VIEW_CONVERT_EXPR,\n+\t\t\t    TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n+      break;\n+\n     default:\n       if (IS_TYPE_OR_DECL_P (stmt))\n \t*walk_subtrees = 0;"}, {"sha": "7ff4d3951b63c860950a8ad74634d973f52ed8df", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -391,6 +391,7 @@ names_builtin_p (const char *name)\n     case RID_BUILTIN_HAS_ATTRIBUTE:\n     case RID_BUILTIN_SHUFFLE:\n     case RID_BUILTIN_LAUNDER:\n+    case RID_BUILTIN_BIT_CAST:\n     case RID_OFFSETOF:\n     case RID_HAS_NOTHROW_ASSIGN:\n     case RID_HAS_NOTHROW_CONSTRUCTOR:\n@@ -489,6 +490,7 @@ cp_common_init_ts (void)\n   MARK_TS_EXP (ALIGNOF_EXPR);\n   MARK_TS_EXP (ARROW_EXPR);\n   MARK_TS_EXP (AT_ENCODE_EXPR);\n+  MARK_TS_EXP (BIT_CAST_EXPR);\n   MARK_TS_EXP (CAST_EXPR);\n   MARK_TS_EXP (CONST_CAST_EXPR);\n   MARK_TS_EXP (CTOR_INITIALIZER);"}, {"sha": "c58b23383794bb71aa088242f2c9b4e41d751849", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -440,6 +440,9 @@ DEFTREECODE (UNARY_RIGHT_FOLD_EXPR, \"unary_right_fold_expr\", tcc_expression, 2)\n DEFTREECODE (BINARY_LEFT_FOLD_EXPR, \"binary_left_fold_expr\", tcc_expression, 3)\n DEFTREECODE (BINARY_RIGHT_FOLD_EXPR, \"binary_right_fold_expr\", tcc_expression, 3)\n \n+/* Represents the __builtin_bit_cast (type, expr) expression.\n+   The type is in TREE_TYPE, expression in TREE_OPERAND (bitcast, 0).  */\n+DEFTREECODE (BIT_CAST_EXPR, \"bit_cast_expr\", tcc_expression, 1)\n \n /** C++ extensions. */\n "}, {"sha": "de905dcf37cc6aa4ef5813876d44526c10468557", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -7372,6 +7372,8 @@ extern tree finish_builtin_launder\t\t(location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_build_vec_convert\t\t(tree, location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree cp_build_bit_cast\t\t\t(location_t, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern void start_lambda_scope\t\t\t(tree);\n extern void record_lambda_scope\t\t\t(tree);\n extern void record_null_lambda_scope\t\t(tree);"}, {"sha": "b97f70e2bd0e4e9fb44b01b942492e26ba623937", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -655,6 +655,15 @@ cxx_pretty_printer::postfix_expression (tree t)\n       pp_right_paren (this);\n       break;\n \n+    case BIT_CAST_EXPR:\n+      pp_cxx_ws_string (this, \"__builtin_bit_cast\");\n+      pp_left_paren (this);\n+      type_id (TREE_TYPE (t));\n+      pp_comma (this);\n+      expression (TREE_OPERAND (t, 0));\n+      pp_right_paren (this);\n+      break;\n+\n     case EMPTY_CLASS_EXPR:\n       type_id (TREE_TYPE (t));\n       pp_left_paren (this);"}, {"sha": "103567cd0046df75a0c0a222c3e2eacf0a8e2307", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -7250,6 +7250,32 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t\t     tf_warning_or_error);\n       }\n \n+    case RID_BUILTIN_BIT_CAST:\n+      {\n+\ttree expression;\n+\ttree type;\n+\t/* Consume the `__builtin_bit_cast' token.  */\n+\tcp_lexer_consume_token (parser->lexer);\n+\t/* Look for the opening `('.  */\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n+\tlocation_t type_location\n+\t  = cp_lexer_peek_token (parser->lexer)->location;\n+\t/* Parse the type-id.  */\n+\t{\n+\t  type_id_in_expr_sentinel s (parser);\n+\t  type = cp_parser_type_id (parser);\n+\t}\n+\t/* Look for the `,'.  */\n+\tcp_parser_require (parser, CPP_COMMA, RT_COMMA);\n+\t/* Now, parse the assignment-expression.  */\n+\texpression = cp_parser_assignment_expression (parser);\n+\t/* Look for the closing `)'.  */\n+\tparens.require_close (parser);\n+\treturn cp_build_bit_cast (type_location, type, expression,\n+\t\t\t\t  tf_warning_or_error);\n+      }\n+\n     default:\n       {\n \ttree type;"}, {"sha": "66ac6473983b97ebeb7ee5c7eb645a7404739ead", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -16731,6 +16731,13 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \treturn build1 (code, type, op0);\n       }\n \n+    case BIT_CAST_EXPR:\n+      {\n+\ttree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\ttree op0 = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n+\treturn cp_build_bit_cast (EXPR_LOCATION (t), type, op0, complain);\n+      }\n+\n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0))\n \t  || ARGUMENT_PACK_P (TREE_OPERAND (t, 0)))"}, {"sha": "d33ef4263486975b0047b7dff2aec1b15c57c966", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -10679,4 +10679,75 @@ cp_build_vec_convert (tree arg, location_t loc, tree type,\n   return build_call_expr_internal_loc (loc, IFN_VEC_CONVERT, type, 1, arg);\n }\n \n+/* Finish __builtin_bit_cast (type, arg).  */\n+\n+tree\n+cp_build_bit_cast (location_t loc, tree type, tree arg,\n+\t\t   tsubst_flags_t complain)\n+{\n+  if (error_operand_p (type))\n+    return error_mark_node;\n+  if (!dependent_type_p (type))\n+    {\n+      if (!complete_type_or_maybe_complain (type, NULL_TREE, complain))\n+\treturn error_mark_node;\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  /* std::bit_cast for destination ARRAY_TYPE is not possible,\n+\t     as functions may not return an array, so don't bother trying\n+\t     to support this (and then deal with VLAs etc.).  */\n+\t  error_at (loc, \"%<__builtin_bit_cast%> destination type %qT \"\n+\t\t\t \"is an array type\", type);\n+\t  return error_mark_node;\n+\t}\n+      if (!trivially_copyable_p (type))\n+\t{\n+\t  error_at (loc, \"%<__builtin_bit_cast%> destination type %qT \"\n+\t\t\t \"is not trivially copyable\", type);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (error_operand_p (arg))\n+    return error_mark_node;\n+\n+  if (!type_dependent_expression_p (arg))\n+    {\n+      if (TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n+\t{\n+\t  /* Don't perform array-to-pointer conversion.  */\n+\t  arg = mark_rvalue_use (arg, loc, true);\n+\t  if (!complete_type_or_maybe_complain (TREE_TYPE (arg), arg, complain))\n+\t    return error_mark_node;\n+\t}\n+      else\n+\targ = decay_conversion (arg, complain);\n+\n+      if (error_operand_p (arg))\n+\treturn error_mark_node;\n+\n+      if (!trivially_copyable_p (TREE_TYPE (arg)))\n+\t{\n+\t  error_at (cp_expr_loc_or_loc (arg, loc),\n+\t\t    \"%<__builtin_bit_cast%> source type %qT \"\n+\t\t    \"is not trivially copyable\", TREE_TYPE (arg));\n+\t  return error_mark_node;\n+\t}\n+      if (!dependent_type_p (type)\n+\t  && !cp_tree_equal (TYPE_SIZE_UNIT (type),\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (arg))))\n+\t{\n+\t  error_at (loc, \"%<__builtin_bit_cast%> source size %qE \"\n+\t\t\t \"not equal to destination type size %qE\",\n+\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (arg)),\n+\t\t\t TYPE_SIZE_UNIT (type));\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  tree ret = build_min (BIT_CAST_EXPR, type, arg);\n+  SET_EXPR_LOCATION (ret, loc);\n+  return ret;\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "2d97c86f83a1f59c34a20f7b499f3c1ea45e6318", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -3969,6 +3969,7 @@ cp_tree_equal (tree t1, tree t2)\n     CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n+    case BIT_CAST_EXPR:\n       if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n       /* Now compare operands as usual.  */\n@@ -5214,6 +5215,7 @@ cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n     case CONST_CAST_EXPR:\n     case DYNAMIC_CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n+    case BIT_CAST_EXPR:\n       if (TREE_TYPE (*tp))\n \tWALK_SUBTREE (TREE_TYPE (*tp));\n "}, {"sha": "195bb21068ad0fc9c344df7d67f738716b5f4beb", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -13574,6 +13574,21 @@ have intederminate values and the object representation needs to be\n bitwise compared to some other object, for example for atomic operations.\n @end deftypefn\n \n+@deftypefn {Built-in Function} @var{type} __builtin_bit_cast (@var{type}, @var{arg})\n+The @code{__builtin_bit_cast} function is available only\n+in C++.  The built-in is intended to be used by implementations of\n+the @code{std::bit_cast} C++ template function.  Programs should make\n+use of the latter function rather than invoking the built-in directly.\n+\n+This built-in function allows reinterpreting the bits of the @var{arg}\n+argument as if it had type @var{type}.  @var{type} and the type of the\n+@var{arg} argument need to be trivially copyable types with the same size.\n+When manifestly constant-evaluated, it performs extra diagnostics required\n+for @code{std::bit_cast} and returns a constant expression if @var{arg}\n+is a constant expression.  For more details\n+refer to the latest revision of the C++ standard.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} long __builtin_expect (long @var{exp}, long @var{c})\n @opindex fprofile-arcs\n You may use @code{__builtin_expect} to provide the compiler with"}, {"sha": "e77d74e40b06a68076a53dc2b9840ac0c640d69d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 396, "deletions": 44, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -7968,25 +7968,78 @@ native_encode_expr (const_tree expr, unsigned char *ptr, int len, int off)\n     }\n }\n \n+/* Try to find a type whose byte size is smaller or equal to LEN bytes larger\n+   or equal to FIELDSIZE bytes, with underlying mode precision/size multiple\n+   of BITS_PER_UNIT.  As native_{interpret,encode}_int works in term of\n+   machine modes, we can't just use build_nonstandard_integer_type.  */\n+\n+tree\n+find_bitfield_repr_type (int fieldsize, int len)\n+{\n+  machine_mode mode;\n+  for (int pass = 0; pass < 2; pass++)\n+    {\n+      enum mode_class mclass = pass ? MODE_PARTIAL_INT : MODE_INT;\n+      FOR_EACH_MODE_IN_CLASS (mode, mclass)\n+\tif (known_ge (GET_MODE_SIZE (mode), fieldsize)\n+\t    && known_eq (GET_MODE_PRECISION (mode),\n+\t\t\t GET_MODE_BITSIZE (mode))\n+\t    && known_le (GET_MODE_SIZE (mode), len))\n+\t  {\n+\t    tree ret = lang_hooks.types.type_for_mode (mode, 1);\n+\t    if (ret && TYPE_MODE (ret) == mode)\n+\t      return ret;\n+\t  }\n+    }\n+\n+  for (int i = 0; i < NUM_INT_N_ENTS; i ++)\n+    if (int_n_enabled_p[i]\n+\t&& int_n_data[i].bitsize >= (unsigned) (BITS_PER_UNIT * fieldsize)\n+\t&& int_n_trees[i].unsigned_type)\n+      {\n+\ttree ret = int_n_trees[i].unsigned_type;\n+\tmode = TYPE_MODE (ret);\n+\tif (known_ge (GET_MODE_SIZE (mode), fieldsize)\n+\t    && known_eq (GET_MODE_PRECISION (mode),\n+\t\t\t GET_MODE_BITSIZE (mode))\n+\t    && known_le (GET_MODE_SIZE (mode), len))\n+\t  return ret;\n+      }\n+\n+  return NULL_TREE;\n+}\n+\n /* Similar to native_encode_expr, but also handle CONSTRUCTORs, VCEs,\n-   NON_LVALUE_EXPRs and nops.  */\n+   NON_LVALUE_EXPRs and nops.  If MASK is non-NULL (then PTR has\n+   to be non-NULL and OFF zero), then in addition to filling the\n+   bytes pointed by PTR with the value also clear any bits pointed\n+   by MASK that are known to be initialized, keep them as is for\n+   e.g. uninitialized padding bits or uninitialized fields.  */\n \n int\n native_encode_initializer (tree init, unsigned char *ptr, int len,\n-\t\t\t   int off)\n+\t\t\t   int off, unsigned char *mask)\n {\n+  int r;\n+\n   /* We don't support starting at negative offset and -1 is special.  */\n   if (off < -1 || init == NULL_TREE)\n     return 0;\n \n+  gcc_assert (mask == NULL || (off == 0 && ptr));\n+\n   STRIP_NOPS (init);\n   switch (TREE_CODE (init))\n     {\n     case VIEW_CONVERT_EXPR:\n     case NON_LVALUE_EXPR:\n-      return native_encode_initializer (TREE_OPERAND (init, 0), ptr, len, off);\n+      return native_encode_initializer (TREE_OPERAND (init, 0), ptr, len, off,\n+\t\t\t\t\tmask);\n     default:\n-      return native_encode_expr (init, ptr, len, off);\n+      r = native_encode_expr (init, ptr, len, off);\n+      if (mask)\n+\tmemset (mask, 0, r);\n+      return r;\n     case CONSTRUCTOR:\n       tree type = TREE_TYPE (init);\n       HOST_WIDE_INT total_bytes = int_size_in_bytes (type);\n@@ -7999,7 +8052,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t{\n \t  HOST_WIDE_INT min_index;\n \t  unsigned HOST_WIDE_INT cnt;\n-\t  HOST_WIDE_INT curpos = 0, fieldsize;\n+\t  HOST_WIDE_INT curpos = 0, fieldsize, valueinit = -1;\n \t  constructor_elt *ce;\n \n \t  if (TYPE_DOMAIN (type) == NULL_TREE\n@@ -8014,12 +8067,22 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t  if (ptr != NULL)\n \t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n \n-\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t  for (cnt = 0; ; cnt++)\n \t    {\n-\t      tree val = ce->value;\n-\t      tree index = ce->index;\n+\t      tree val = NULL_TREE, index = NULL_TREE;\n \t      HOST_WIDE_INT pos = curpos, count = 0;\n \t      bool full = false;\n+\t      if (vec_safe_iterate (CONSTRUCTOR_ELTS (init), cnt, &ce))\n+\t\t{\n+\t\t  val = ce->value;\n+\t\t  index = ce->index;\n+\t\t}\n+\t      else if (mask == NULL\n+\t\t       || CONSTRUCTOR_NO_CLEARING (init)\n+\t\t       || curpos >= total_bytes)\n+\t\tbreak;\n+\t      else\n+\t\tpos = total_bytes;\n \t      if (index && TREE_CODE (index) == RANGE_EXPR)\n \t\t{\n \t\t  if (!tree_fits_shwi_p (TREE_OPERAND (index, 0))\n@@ -8037,6 +8100,28 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t  pos = (tree_to_shwi (index) - min_index) * fieldsize;\n \t\t}\n \n+\t      if (mask && !CONSTRUCTOR_NO_CLEARING (init) && curpos != pos)\n+\t\t{\n+\t\t  if (valueinit == -1)\n+\t\t    {\n+\t\t      tree zero = build_constructor (TREE_TYPE (type), NULL);\n+\t\t      r = native_encode_initializer (zero, ptr + curpos,\n+\t\t\t\t\t\t     fieldsize, 0,\n+\t\t\t\t\t\t     mask + curpos);\n+\t\t      ggc_free (zero);\n+\t\t      if (!r)\n+\t\t\treturn 0;\n+\t\t      valueinit = curpos;\n+\t\t      curpos += fieldsize;\n+\t\t    }\n+\t\t  while (curpos != pos)\n+\t\t    {\n+\t\t      memcpy (ptr + curpos, ptr + valueinit, fieldsize);\n+\t\t      memcpy (mask + curpos, mask + valueinit, fieldsize);\n+\t\t      curpos += fieldsize;\n+\t\t    }\n+\t\t}\n+\n \t      curpos = pos;\n \t      if (val)\n \t\tdo\n@@ -8051,14 +8136,19 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t\t    if (ptr)\n \t\t\t      memcpy (ptr + (curpos - o), ptr + (pos - o),\n \t\t\t\t      fieldsize);\n+\t\t\t    if (mask)\n+\t\t\t      memcpy (mask + curpos, mask + pos, fieldsize);\n \t\t\t  }\n \t\t\telse if (!native_encode_initializer (val,\n \t\t\t\t\t\t\t     ptr\n \t\t\t\t\t\t\t     ? ptr + curpos - o\n \t\t\t\t\t\t\t     : NULL,\n \t\t\t\t\t\t\t     fieldsize,\n \t\t\t\t\t\t\t     off == -1 ? -1\n-\t\t\t\t\t\t\t\t       : 0))\n+\t\t\t\t\t\t\t\t       : 0,\n+\t\t\t\t\t\t\t     mask\n+\t\t\t\t\t\t\t     ? mask + curpos\n+\t\t\t\t\t\t\t     : NULL))\n \t\t\t  return 0;\n \t\t\telse\n \t\t\t  {\n@@ -8073,6 +8163,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t\tunsigned char *p = NULL;\n \t\t\tint no = 0;\n \t\t\tint l;\n+\t\t\tgcc_assert (mask == NULL);\n \t\t\tif (curpos >= off)\n \t\t\t  {\n \t\t\t    if (ptr)\n@@ -8086,7 +8177,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t\t    no = off - curpos;\n \t\t\t    l = len;\n \t\t\t  }\n-\t\t\tif (!native_encode_initializer (val, p, l, no))\n+\t\t\tif (!native_encode_initializer (val, p, l, no, NULL))\n \t\t\t  return 0;\n \t\t      }\n \t\t    curpos += fieldsize;\n@@ -8100,22 +8191,74 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t{\n \t  unsigned HOST_WIDE_INT cnt;\n \t  constructor_elt *ce;\n+\t  tree fld_base = TYPE_FIELDS (type);\n+\t  tree to_free = NULL_TREE;\n \n+\t  gcc_assert (TREE_CODE (type) == RECORD_TYPE || mask == NULL);\n \t  if (ptr != NULL)\n \t    memset (ptr, '\\0', MIN (total_bytes - off, len));\n-\t  FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (init), cnt, ce)\n+\t  for (cnt = 0; ; cnt++)\n \t    {\n-\t      tree field = ce->index;\n-\t      tree val = ce->value;\n-\t      HOST_WIDE_INT pos, fieldsize;\n+\t      tree val = NULL_TREE, field = NULL_TREE;\n+\t      HOST_WIDE_INT pos = 0, fieldsize;\n \t      unsigned HOST_WIDE_INT bpos = 0, epos = 0;\n \n-\t      if (field == NULL_TREE)\n-\t\treturn 0;\n+\t      if (to_free)\n+\t\t{\n+\t\t  ggc_free (to_free);\n+\t\t  to_free = NULL_TREE;\n+\t\t}\n \n-\t      pos = int_byte_position (field);\n-\t      if (off != -1 && (HOST_WIDE_INT) off + len <= pos)\n-\t\tcontinue;\n+\t      if (vec_safe_iterate (CONSTRUCTOR_ELTS (init), cnt, &ce))\n+\t\t{\n+\t\t  val = ce->value;\n+\t\t  field = ce->index;\n+\t\t  if (field == NULL_TREE)\n+\t\t    return 0;\n+\n+\t\t  pos = int_byte_position (field);\n+\t\t  if (off != -1 && (HOST_WIDE_INT) off + len <= pos)\n+\t\t    continue;\n+\t\t}\n+\t      else if (mask == NULL\n+\t\t       || CONSTRUCTOR_NO_CLEARING (init))\n+\t\tbreak;\n+\t      else\n+\t\tpos = total_bytes;\n+\n+\t      if (mask && !CONSTRUCTOR_NO_CLEARING (init))\n+\t\t{\n+\t\t  tree fld;\n+\t\t  for (fld = fld_base; fld; fld = DECL_CHAIN (fld))\n+\t\t    {\n+\t\t      if (TREE_CODE (fld) != FIELD_DECL)\n+\t\t\tcontinue;\n+\t\t      if (fld == field)\n+\t\t\tbreak;\n+\t\t      if (DECL_PADDING_P (fld))\n+\t\t\tcontinue;\n+\t\t      if (DECL_SIZE_UNIT (fld) == NULL_TREE\n+\t\t\t  || !tree_fits_shwi_p (DECL_SIZE_UNIT (fld)))\n+\t\t\treturn 0;\n+\t\t      if (integer_zerop (DECL_SIZE_UNIT (fld)))\n+\t\t\tcontinue;\n+\t\t      break;\n+\t\t    }\n+\t\t  if (fld == NULL_TREE)\n+\t\t    {\n+\t\t      if (ce == NULL)\n+\t\t\tbreak;\n+\t\t      return 0;\n+\t\t    }\n+\t\t  fld_base = DECL_CHAIN (fld);\n+\t\t  if (fld != field)\n+\t\t    {\n+\t\t      cnt--;\n+\t\t      field = fld;\n+\t\t      val = build_constructor (TREE_TYPE (fld), NULL);\n+\t\t      to_free = val;\n+\t\t    }\n+\t\t}\n \n \t      if (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t\t  && TYPE_DOMAIN (TREE_TYPE (field))\n@@ -8156,30 +8299,49 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n \t\t    return 0;\n \n-\t\t  tree repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n-\t\t  if (repr == NULL_TREE\n-\t\t      || TREE_CODE (val) != INTEGER_CST\n-\t\t      || !INTEGRAL_TYPE_P (TREE_TYPE (repr)))\n+\t\t  if (TREE_CODE (val) != INTEGER_CST)\n \t\t    return 0;\n \n-\t\t  HOST_WIDE_INT rpos = int_byte_position (repr);\n+\t\t  tree repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+\t\t  tree repr_type = NULL_TREE;\n+\t\t  HOST_WIDE_INT rpos = 0;\n+\t\t  if (repr && INTEGRAL_TYPE_P (TREE_TYPE (repr)))\n+\t\t    {\n+\t\t      rpos = int_byte_position (repr);\n+\t\t      repr_type = TREE_TYPE (repr);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      repr_type = find_bitfield_repr_type (fieldsize, len);\n+\t\t      if (repr_type == NULL_TREE)\n+\t\t\treturn 0;\n+\t\t      HOST_WIDE_INT repr_size = int_size_in_bytes (repr_type);\n+\t\t      gcc_assert (repr_size > 0 && repr_size <= len);\n+\t\t      if (pos + repr_size <= len)\n+\t\t\trpos = pos;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  rpos = len - repr_size;\n+\t\t\t  gcc_assert (rpos <= pos);\n+\t\t\t}\n+\t\t    }\n+\n \t\t  if (rpos > pos)\n \t\t    return 0;\n-\t\t  wide_int w = wi::to_wide (val,\n-\t\t\t\t\t    TYPE_PRECISION (TREE_TYPE (repr)));\n-\t\t  int diff = (TYPE_PRECISION (TREE_TYPE (repr))\n+\t\t  wide_int w = wi::to_wide (val, TYPE_PRECISION (repr_type));\n+\t\t  int diff = (TYPE_PRECISION (repr_type)\n \t\t\t      - TYPE_PRECISION (TREE_TYPE (field)));\n \t\t  HOST_WIDE_INT bitoff = (pos - rpos) * BITS_PER_UNIT + bpos;\n \t\t  if (!BYTES_BIG_ENDIAN)\n \t\t    w = wi::lshift (w, bitoff);\n \t\t  else\n \t\t    w = wi::lshift (w, diff - bitoff);\n-\t\t  val = wide_int_to_tree (TREE_TYPE (repr), w);\n+\t\t  val = wide_int_to_tree (repr_type, w);\n \n \t\t  unsigned char buf[MAX_BITSIZE_MODE_ANY_INT\n \t\t\t\t    / BITS_PER_UNIT + 1];\n \t\t  int l = native_encode_int (val, buf, sizeof buf, 0);\n-\t\t  if (l * BITS_PER_UNIT != TYPE_PRECISION (TREE_TYPE (repr)))\n+\t\t  if (l * BITS_PER_UNIT != TYPE_PRECISION (repr_type))\n \t\t    return 0;\n \n \t\t  if (ptr == NULL)\n@@ -8192,15 +8354,31 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t    {\n \t\t      if (!BYTES_BIG_ENDIAN)\n \t\t\t{\n-\t\t\t  int mask = (1 << bpos) - 1;\n-\t\t\t  buf[pos - rpos] &= ~mask;\n-\t\t\t  buf[pos - rpos] |= ptr[pos - o] & mask;\n+\t\t\t  int msk = (1 << bpos) - 1;\n+\t\t\t  buf[pos - rpos] &= ~msk;\n+\t\t\t  buf[pos - rpos] |= ptr[pos - o] & msk;\n+\t\t\t  if (mask)\n+\t\t\t    {\n+\t\t\t      if (fieldsize > 1 || epos == 0)\n+\t\t\t\tmask[pos] &= msk;\n+\t\t\t      else\n+\t\t\t\tmask[pos] &= (msk | ~((1 << epos) - 1));\n+\t\t\t    }\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  int mask = (1 << (BITS_PER_UNIT - bpos)) - 1;\n-\t\t\t  buf[pos - rpos] &= mask;\n-\t\t\t  buf[pos - rpos] |= ptr[pos - o] & ~mask;\n+\t\t\t  int msk = (1 << (BITS_PER_UNIT - bpos)) - 1;\n+\t\t\t  buf[pos - rpos] &= msk;\n+\t\t\t  buf[pos - rpos] |= ptr[pos - o] & ~msk;\n+\t\t\t  if (mask)\n+\t\t\t    {\n+\t\t\t      if (fieldsize > 1 || epos == 0)\n+\t\t\t\tmask[pos] &= ~msk;\n+\t\t\t      else\n+\t\t\t\tmask[pos] &= (~msk\n+\t\t\t\t\t      | ((1 << (BITS_PER_UNIT - epos))\n+\t\t\t\t\t\t - 1));\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t  /* If the bitfield does not end at byte boundary, handle\n@@ -8211,27 +8389,37 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t    {\n \t\t      if (!BYTES_BIG_ENDIAN)\n \t\t\t{\n-\t\t\t  int mask = (1 << epos) - 1;\n-\t\t\t  buf[pos - rpos + fieldsize - 1] &= mask;\n+\t\t\t  int msk = (1 << epos) - 1;\n+\t\t\t  buf[pos - rpos + fieldsize - 1] &= msk;\n \t\t\t  buf[pos - rpos + fieldsize - 1]\n-\t\t\t    |= ptr[pos + fieldsize - 1 - o] & ~mask;\n+\t\t\t    |= ptr[pos + fieldsize - 1 - o] & ~msk;\n+\t\t\t  if (mask && (fieldsize > 1 || bpos == 0))\n+\t\t\t    mask[pos + fieldsize - 1] &= ~msk;\n \t\t\t}\n \t\t       else\n \t\t\t{\n-\t\t\t  int mask = (1 << (BITS_PER_UNIT - epos)) - 1;\n-\t\t\t  buf[pos - rpos + fieldsize - 1] &= ~mask;\n+\t\t\t  int msk = (1 << (BITS_PER_UNIT - epos)) - 1;\n+\t\t\t  buf[pos - rpos + fieldsize - 1] &= ~msk;\n \t\t\t  buf[pos - rpos + fieldsize - 1]\n-\t\t\t    |= ptr[pos + fieldsize - 1 - o] & mask;\n+\t\t\t    |= ptr[pos + fieldsize - 1 - o] & msk;\n+\t\t\t  if (mask && (fieldsize > 1 || bpos == 0))\n+\t\t\t    mask[pos + fieldsize - 1] &= msk;\n \t\t\t}\n \t\t    }\n \t\t  if (off == -1\n \t\t      || (pos >= off\n \t\t\t  && (pos + fieldsize <= (HOST_WIDE_INT) off + len)))\n-\t\t    memcpy (ptr + pos - o, buf + (pos - rpos), fieldsize);\n+\t\t    {\n+\t\t      memcpy (ptr + pos - o, buf + (pos - rpos), fieldsize);\n+\t\t      if (mask && (fieldsize > (bpos != 0) + (epos != 0)))\n+\t\t\tmemset (mask + pos + (bpos != 0), 0,\n+\t\t\t\tfieldsize - (bpos != 0) - (epos != 0));\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Partial overlap.  */\n \t\t      HOST_WIDE_INT fsz = fieldsize;\n+\t\t      gcc_assert (mask == NULL);\n \t\t      if (pos < off)\n \t\t\t{\n \t\t\t  fsz -= (off - pos);\n@@ -8251,7 +8439,8 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t  if (!native_encode_initializer (val, ptr ? ptr + pos - o\n \t\t\t\t\t\t\t   : NULL,\n \t\t\t\t\t\t  fieldsize,\n-\t\t\t\t\t\t  off == -1 ? -1 : 0))\n+\t\t\t\t\t\t  off == -1 ? -1 : 0,\n+\t\t\t\t\t\t  mask ? mask + pos : NULL))\n \t\t    return 0;\n \t\t}\n \t      else\n@@ -8260,6 +8449,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t  unsigned char *p = NULL;\n \t\t  int no = 0;\n \t\t  int l;\n+\t\t  gcc_assert (mask == NULL);\n \t\t  if (pos >= off)\n \t\t    {\n \t\t      if (ptr)\n@@ -8273,7 +8463,7 @@ native_encode_initializer (tree init, unsigned char *ptr, int len,\n \t\t      no = off - pos;\n \t\t      l = len;\n \t\t    }\n-\t\t  if (!native_encode_initializer (val, p, l, no))\n+\t\t  if (!native_encode_initializer (val, p, l, no, NULL))\n \t\t    return 0;\n \t\t}\n \t    }\n@@ -8549,6 +8739,168 @@ can_native_interpret_type_p (tree type)\n     }\n }\n \n+/* Attempt to interpret aggregate of TYPE from bytes encoded in target\n+   byte order at PTR + OFF with LEN bytes.  Does not handle unions.  */\n+\n+tree\n+native_interpret_aggregate (tree type, const unsigned char *ptr, int off,\n+\t\t\t    int len)\n+{\n+  vec<constructor_elt, va_gc> *elts = NULL;\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      HOST_WIDE_INT eltsz = int_size_in_bytes (TREE_TYPE (type));\n+      if (eltsz < 0 || eltsz > len || TYPE_DOMAIN (type) == NULL_TREE)\n+\treturn NULL_TREE;\n+\n+      HOST_WIDE_INT cnt = 0;\n+      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n+\t{\n+\t  if (!tree_fits_shwi_p (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\t    return NULL_TREE;\n+\t  cnt = tree_to_shwi (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) + 1;\n+\t}\n+      if (eltsz == 0)\n+\tcnt = 0;\n+      HOST_WIDE_INT pos = 0;\n+      for (HOST_WIDE_INT i = 0; i < cnt; i++, pos += eltsz)\n+\t{\n+\t  tree v = NULL_TREE;\n+\t  if (pos >= len || pos + eltsz > len)\n+\t    return NULL_TREE;\n+\t  if (can_native_interpret_type_p (TREE_TYPE (type)))\n+\t    {\n+\t      v = native_interpret_expr (TREE_TYPE (type),\n+\t\t\t\t\t ptr + off + pos, eltsz);\n+\t      if (v == NULL_TREE)\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t\t   || TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n+\t    v = native_interpret_aggregate (TREE_TYPE (type), ptr, off + pos,\n+\t\t\t\t\t    eltsz);\n+\t  if (v == NULL_TREE)\n+\t    return NULL_TREE;\n+\t  CONSTRUCTOR_APPEND_ELT (elts, size_int (i), v);\n+\t}\n+      return build_constructor (type, elts);\n+    }\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return NULL_TREE;\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL || DECL_PADDING_P (field))\n+\tcontinue;\n+      tree fld = field;\n+      HOST_WIDE_INT bitoff = 0, pos = 0, sz = 0;\n+      int diff = 0;\n+      tree v = NULL_TREE;\n+      if (DECL_BIT_FIELD (field))\n+\t{\n+\t  fld = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+\t  if (fld && INTEGRAL_TYPE_P (TREE_TYPE (fld)))\n+\t    {\n+\t      poly_int64 bitoffset;\n+\t      poly_uint64 field_offset, fld_offset;\n+\t      if (poly_int_tree_p (DECL_FIELD_OFFSET (field), &field_offset)\n+\t\t  && poly_int_tree_p (DECL_FIELD_OFFSET (fld), &fld_offset))\n+\t\tbitoffset = (field_offset - fld_offset) * BITS_PER_UNIT;\n+\t      else\n+\t\tbitoffset = 0;\n+\t      bitoffset += (tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field))\n+\t\t\t    - tree_to_uhwi (DECL_FIELD_BIT_OFFSET (fld)));\n+\t      diff = (TYPE_PRECISION (TREE_TYPE (fld))\n+\t\t      - TYPE_PRECISION (TREE_TYPE (field)));\n+\t      if (!bitoffset.is_constant (&bitoff)\n+\t\t  || bitoff < 0\n+\t\t  || bitoff > diff)\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!tree_fits_uhwi_p (DECL_FIELD_BIT_OFFSET (field)))\n+\t\treturn NULL_TREE;\n+\t      int fieldsize = TYPE_PRECISION (TREE_TYPE (field));\n+\t      int bpos = tree_to_uhwi (DECL_FIELD_BIT_OFFSET (field));\n+\t      bpos %= BITS_PER_UNIT;\n+\t      fieldsize += bpos;\n+\t      fieldsize += BITS_PER_UNIT - 1;\n+\t      fieldsize /= BITS_PER_UNIT;\n+\t      tree repr_type = find_bitfield_repr_type (fieldsize, len);\n+\t      if (repr_type == NULL_TREE)\n+\t\treturn NULL_TREE;\n+\t      sz = int_size_in_bytes (repr_type);\n+\t      if (sz < 0 || sz > len)\n+\t\treturn NULL_TREE;\n+\t      pos = int_byte_position (field);\n+\t      if (pos < 0 || pos > len || pos + fieldsize > len)\n+\t\treturn NULL_TREE;\n+\t      HOST_WIDE_INT rpos;\n+\t      if (pos + sz <= len)\n+\t\trpos = pos;\n+\t      else\n+\t\t{\n+\t\t  rpos = len - sz;\n+\t\t  gcc_assert (rpos <= pos);\n+\t\t}\n+\t      bitoff = (HOST_WIDE_INT) (pos - rpos) * BITS_PER_UNIT + bpos;\n+\t      pos = rpos;\n+\t      diff = (TYPE_PRECISION (repr_type)\n+\t\t      - TYPE_PRECISION (TREE_TYPE (field)));\n+\t      v = native_interpret_expr (repr_type, ptr + off + pos, sz);\n+\t      if (v == NULL_TREE)\n+\t\treturn NULL_TREE;\n+\t      fld = NULL_TREE;\n+\t    }\n+\t}\n+\n+      if (fld)\n+\t{\n+\t  sz = int_size_in_bytes (TREE_TYPE (fld));\n+\t  if (sz < 0 || sz > len)\n+\t    return NULL_TREE;\n+\t  tree byte_pos = byte_position (fld);\n+\t  if (!tree_fits_shwi_p (byte_pos))\n+\t    return NULL_TREE;\n+\t  pos = tree_to_shwi (byte_pos);\n+\t  if (pos < 0 || pos > len || pos + sz > len)\n+\t    return NULL_TREE;\n+\t}\n+      if (fld == NULL_TREE)\n+\t/* Already handled above.  */;\n+      else if (can_native_interpret_type_p (TREE_TYPE (fld)))\n+\t{\n+\t  v = native_interpret_expr (TREE_TYPE (fld),\n+\t\t\t\t     ptr + off + pos, sz);\n+\t  if (v == NULL_TREE)\n+\t    return NULL_TREE;\n+\t}\n+      else if (TREE_CODE (TREE_TYPE (fld)) == RECORD_TYPE\n+\t       || TREE_CODE (TREE_TYPE (fld)) == ARRAY_TYPE)\n+\tv = native_interpret_aggregate (TREE_TYPE (fld), ptr, off + pos, sz);\n+      if (v == NULL_TREE)\n+\treturn NULL_TREE;\n+      if (fld != field)\n+\t{\n+\t  if (TREE_CODE (v) != INTEGER_CST)\n+\t    return NULL_TREE;\n+\n+\t  /* FIXME: Figure out how to handle PDP endian bitfields.  */\n+\t  if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+\t    return NULL_TREE;\n+\t  if (!BYTES_BIG_ENDIAN)\n+\t    v = wide_int_to_tree (TREE_TYPE (field),\n+\t\t\t\t  wi::lrshift (wi::to_wide (v), bitoff));\n+\t  else\n+\t    v = wide_int_to_tree (TREE_TYPE (field),\n+\t\t\t\t  wi::lrshift (wi::to_wide (v),\n+\t\t\t\t\t       diff - bitoff));\n+\t}\n+      CONSTRUCTOR_APPEND_ELT (elts, field, v);\n+    }\n+  return build_constructor (type, elts);\n+}\n+\n /* Routines for manipulation of native_encode_expr encoded data if the encoded\n    or extracted constant positions and/or sizes aren't byte aligned.  */\n "}, {"sha": "818c3d54a49060d0ba2678f2a9e2bd8af860b253", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -27,9 +27,11 @@ extern int folding_initializer;\n /* Convert between trees and native memory representation.  */\n extern int native_encode_expr (const_tree, unsigned char *, int, int off = -1);\n extern int native_encode_initializer (tree, unsigned char *, int,\n-\t\t\t\t      int off = -1);\n+\t\t\t\t      int off = -1, unsigned char * = nullptr);\n extern tree native_interpret_expr (tree, const unsigned char *, int);\n extern bool can_native_interpret_type_p (tree);\n+extern tree native_interpret_aggregate (tree, const unsigned char *, int, int);\n+extern tree find_bitfield_repr_type (int, int);\n extern void shift_bytes_in_array_left (unsigned char *, unsigned int,\n \t\t\t\t       unsigned int);\n extern void shift_bytes_in_array_right (unsigned char *, unsigned int,"}, {"sha": "3148c6b84d9cf19ad501941a2278d31bc731e9bc", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -3958,6 +3958,10 @@ static const size_t clear_padding_buf_size = 32 * clear_padding_unit;\n /* Data passed through __builtin_clear_padding folding.  */\n struct clear_padding_struct {\n   location_t loc;\n+  /* 0 during __builtin_clear_padding folding, nonzero during\n+     clear_type_padding_in_mask.  In that case, instead of clearing the\n+     non-padding bits in union_ptr array clear the padding bits in there.  */\n+  bool clear_in_mask;\n   tree base;\n   tree alias_type;\n   gimple_stmt_iterator *gsi;\n@@ -4000,6 +4004,39 @@ clear_padding_flush (clear_padding_struct *buf, bool full)\n   size_t padding_bytes = buf->padding_bytes;\n   if (buf->union_ptr)\n     {\n+      if (buf->clear_in_mask)\n+\t{\n+\t  /* During clear_type_padding_in_mask, clear the padding\n+\t     bits set in buf->buf in the buf->union_ptr mask.  */\n+\t  for (size_t i = 0; i < end; i++)\n+\t    {\n+\t      if (buf->buf[i] == (unsigned char) ~0)\n+\t\tpadding_bytes++;\n+\t      else\n+\t\t{\n+\t\t  memset (&buf->union_ptr[buf->off + i - padding_bytes],\n+\t\t\t  0, padding_bytes);\n+\t\t  padding_bytes = 0;\n+\t\t  buf->union_ptr[buf->off + i] &= ~buf->buf[i];\n+\t\t}\n+\t    }\n+\t  if (full)\n+\t    {\n+\t      memset (&buf->union_ptr[buf->off + end - padding_bytes],\n+\t\t      0, padding_bytes);\n+\t      buf->off = 0;\n+\t      buf->size = 0;\n+\t      buf->padding_bytes = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      memmove (buf->buf, buf->buf + end, buf->size - end);\n+\t      buf->off += end;\n+\t      buf->size -= end;\n+\t      buf->padding_bytes = padding_bytes;\n+\t    }\n+\t  return;\n+\t}\n       /* Inside of a union, instead of emitting any code, instead\n \t clear all bits in the union_ptr buffer that are clear\n \t in buf.  Whole padding bytes don't clear anything.  */\n@@ -4311,6 +4348,7 @@ clear_padding_union (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n \tclear_padding_flush (buf, false);\n       union_buf = XALLOCA (clear_padding_struct);\n       union_buf->loc = buf->loc;\n+      union_buf->clear_in_mask = buf->clear_in_mask;\n       union_buf->base = NULL_TREE;\n       union_buf->alias_type = NULL_TREE;\n       union_buf->gsi = NULL;\n@@ -4335,9 +4373,10 @@ clear_padding_union (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n \t      continue;\n \t    gcc_assert (TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t\t\t&& !COMPLETE_TYPE_P (TREE_TYPE (field)));\n-\t    error_at (buf->loc, \"flexible array member %qD does not have \"\n-\t\t\t\t\"well defined padding bits for %qs\",\n-\t\t      field, \"__builtin_clear_padding\");\n+\t    if (!buf->clear_in_mask)\n+\t      error_at (buf->loc, \"flexible array member %qD does not have \"\n+\t\t\t\t  \"well defined padding bits for %qs\",\n+\t\t\tfield, \"__builtin_clear_padding\");\n \t    continue;\n \t  }\n \tHOST_WIDE_INT fldsz = tree_to_shwi (DECL_SIZE_UNIT (field));\n@@ -4529,9 +4568,10 @@ clear_padding_type (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n \t\t  continue;\n \t\tgcc_assert (TREE_CODE (ftype) == ARRAY_TYPE\n \t\t\t    && !COMPLETE_TYPE_P (ftype));\n-\t\terror_at (buf->loc, \"flexible array member %qD does not have \"\n-\t\t\t\t    \"well defined padding bits for %qs\",\n-\t\t\t  field, \"__builtin_clear_padding\");\n+\t\tif (!buf->clear_in_mask)\n+\t\t  error_at (buf->loc, \"flexible array member %qD does not \"\n+\t\t\t\t      \"have well defined padding bits for %qs\",\n+\t\t\t    field, \"__builtin_clear_padding\");\n \t      }\n \t    else if (is_empty_type (TREE_TYPE (field)))\n \t      continue;\n@@ -4645,6 +4685,27 @@ clear_padding_type (clear_padding_struct *buf, tree type, HOST_WIDE_INT sz)\n     }\n }\n \n+/* Clear padding bits of TYPE in MASK.  */\n+\n+void\n+clear_type_padding_in_mask (tree type, unsigned char *mask)\n+{\n+  clear_padding_struct buf;\n+  buf.loc = UNKNOWN_LOCATION;\n+  buf.clear_in_mask = true;\n+  buf.base = NULL_TREE;\n+  buf.alias_type = NULL_TREE;\n+  buf.gsi = NULL;\n+  buf.align = 0;\n+  buf.off = 0;\n+  buf.padding_bytes = 0;\n+  buf.sz = int_size_in_bytes (type);\n+  buf.size = 0;\n+  buf.union_ptr = mask;\n+  clear_padding_type (&buf, type, buf.sz);\n+  clear_padding_flush (&buf, true);\n+}\n+\n /* Fold __builtin_clear_padding builtin.  */\n \n static bool\n@@ -4664,6 +4725,7 @@ gimple_fold_builtin_clear_padding (gimple_stmt_iterator *gsi)\n   gsi_prev (&gsiprev);\n \n   buf.loc = loc;\n+  buf.clear_in_mask = false;\n   buf.base = ptr;\n   buf.alias_type = NULL_TREE;\n   buf.gsi = gsi;"}, {"sha": "f0f43f68dfacaa93b912df3248444fad36ab8295", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -35,6 +35,7 @@ extern tree maybe_fold_and_comparisons (tree, enum tree_code, tree, tree,\n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (tree, enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n+extern void clear_type_padding_in_mask (tree, unsigned char *);\n extern bool optimize_atomic_compare_exchange_p (gimple *);\n extern void fold_builtin_atomic_compare_exchange (gimple_stmt_iterator *);\n extern bool arith_overflowed_p (enum tree_code, const_tree, const_tree,"}, {"sha": "34cd1b93746ecbd40b56c3b192f9b698663ce872", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast1.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast1.C?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do compile }\n+\n+struct S { short a, b; };\n+struct T { float a[16]; };\n+struct U { int b[16]; };\n+\n+#if __SIZEOF_FLOAT__ == __SIZEOF_INT__\n+int\n+f1 (float x)\n+{\n+  return __builtin_bit_cast (int, x);\n+}\n+#endif\n+\n+#if 2 * __SIZEOF_SHORT__ == __SIZEOF_INT__\n+S\n+f2 (int x)\n+{\n+  return __builtin_bit_cast (S, x);\n+}\n+\n+int\n+f3 (S x)\n+{\n+  return __builtin_bit_cast (int, x);\n+}\n+#endif\n+\n+#if __SIZEOF_FLOAT__ == __SIZEOF_INT__\n+U\n+f4 (T &x)\n+{\n+  return __builtin_bit_cast (U, x);\n+}\n+\n+T\n+f5 (int (&x)[16])\n+{\n+  return __builtin_bit_cast (T, x);\n+}\n+#endif\n+\n+int\n+f6 ()\n+{\n+  return __builtin_bit_cast (unsigned char, (signed char) 0);\n+}"}, {"sha": "6bb1760e621600296ea4ac757412e204cd7c9d4b", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast2.C", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast2.C?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -0,0 +1,57 @@\n+// { dg-do compile }\n+\n+struct S { ~S (); int s; };\n+S s;\n+struct V;\t\t\t\t// { dg-message \"forward declaration of 'struct V'\" }\n+extern V v;\t\t\t\t// { dg-error \"'v' has incomplete type\" }\n+extern V *p;\n+struct U { int a, b; };\n+U u;\n+\n+void\n+foo (int *q)\n+{\n+  __builtin_bit_cast (int, s);\t\t// { dg-error \"'__builtin_bit_cast' source type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (S, 0);\t\t// { dg-error \"'__builtin_bit_cast' destination type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (int &, q);\t// { dg-error \"'__builtin_bit_cast' destination type 'int&' is not trivially copyable\" }\n+  __builtin_bit_cast (int [1], 0);\t// { dg-error \"'__builtin_bit_cast' destination type \\[^\\n\\r]* is an array type\" }\n+  __builtin_bit_cast (V, 0);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (int, v);\n+  __builtin_bit_cast (int, *p);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (U, 0);\t\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+  __builtin_bit_cast (int, u);\t\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+}\n+\n+template <int N>\n+void\n+bar (int *q)\n+{\n+  __builtin_bit_cast (int, s);\t\t// { dg-error \"'__builtin_bit_cast' source type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (S, 0);\t\t// { dg-error \"'__builtin_bit_cast' destination type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (int &, q);\t// { dg-error \"'__builtin_bit_cast' destination type 'int&' is not trivially copyable\" }\n+  __builtin_bit_cast (int [1], 0);\t// { dg-error \"'__builtin_bit_cast' destination type \\[^\\n\\r]* is an array type\" }\n+  __builtin_bit_cast (V, 0);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (int, *p);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (U, 0);\t\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+  __builtin_bit_cast (int, u);\t\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+}\n+\n+template <typename T1, typename T2, typename T3, typename T4>\n+void\n+baz (T3 s, T4 *p, T1 *q)\n+{\n+  __builtin_bit_cast (int, s);\t\t// { dg-error \"'__builtin_bit_cast' source type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (T3, 0);\t\t// { dg-error \"'__builtin_bit_cast' destination type 'S' is not trivially copyable\" }\n+  __builtin_bit_cast (T1 &, q);\t\t// { dg-error \"'__builtin_bit_cast' destination type 'int&' is not trivially copyable\" }\n+  __builtin_bit_cast (T2, 0);\t\t// { dg-error \"'__builtin_bit_cast' destination type \\[^\\n\\r]* is an array type\" }\n+  __builtin_bit_cast (T4, 0);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (int, *p);\t\t// { dg-error \"invalid use of incomplete type 'struct V'\" }\n+  __builtin_bit_cast (U, (T1) 0);\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+  __builtin_bit_cast (T1, u);\t\t// { dg-error \"'__builtin_bit_cast' source size '\\[0-9]*' not equal to destination type size '\\[0-9]*'\" }\n+}\n+\n+void\n+qux (int *q)\n+{\n+  baz <int, int [1], S, V> (s, p, q);\n+}"}, {"sha": "a3ff211420dfa8d25f344ac9d592a0d4c755219e", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast3.C", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast3.C?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -0,0 +1,229 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <typename To, typename From>\n+constexpr To\n+bit_cast (const From &from)\n+{\n+  return __builtin_bit_cast (To, from);\n+}\n+\n+template <typename To, typename From>\n+constexpr bool\n+check (const From &from)\n+{\n+  return bit_cast <From> (bit_cast <To> (from)) == from;\n+}\n+\n+struct A\n+{\n+  int a, b, c;\n+  constexpr bool operator == (const A &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c;\n+  }\n+};\n+\n+struct B\n+{\n+  unsigned a[3];\n+  constexpr bool operator == (const B &x) const\n+  {\n+    return x.a[0] == a[0] && x.a[1] == a[1] && x.a[2] == a[2];\n+  }\n+};\n+\n+struct C\n+{\n+  char a[2][3][2];\n+  constexpr bool operator == (const C &x) const\n+  {\n+    return x.a[0][0][0] == a[0][0][0]\n+\t   && x.a[0][0][1] == a[0][0][1]\n+\t   && x.a[0][1][0] == a[0][1][0]\n+\t   && x.a[0][1][1] == a[0][1][1]\n+\t   && x.a[0][2][0] == a[0][2][0]\n+\t   && x.a[0][2][1] == a[0][2][1]\n+\t   && x.a[1][0][0] == a[1][0][0]\n+\t   && x.a[1][0][1] == a[1][0][1]\n+\t   && x.a[1][1][0] == a[1][1][0]\n+\t   && x.a[1][1][1] == a[1][1][1]\n+\t   && x.a[1][2][0] == a[1][2][0]\n+\t   && x.a[1][2][1] == a[1][2][1];\n+  }\n+};\n+\n+struct D\n+{\n+  int a, b;\n+  constexpr bool operator == (const D &x) const\n+  {\n+    return x.a == a && x.b == b;\n+  }\n+};\n+\n+struct E {};\n+struct F { char c, d, e, f; };\n+struct G : public D, E, F\n+{\n+  int g;\n+  constexpr bool operator == (const G &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c && x.d == d\n+\t   && x.e == e && x.f == f && x.g == g;\n+  }\n+};\n+\n+struct H\n+{\n+  int a, b[2], c;\n+  constexpr bool operator == (const H &x) const\n+  {\n+    return x.a == a && x.b[0] == b[0] && x.b[1] == b[1] && x.c == c;\n+  }\n+};\n+\n+#if __SIZEOF_INT__ == 4\n+struct I\n+{\n+  int a;\n+  int b : 3;\n+  int c : 24;\n+  int d : 5;\n+  int e;\n+  constexpr bool operator == (const I &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c && x.d == d && x.e == e;\n+  }\n+};\n+#endif\n+\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+struct J\n+{\n+  long long int a, b : 11, c : 3, d : 37, e : 1, f : 10, g : 2, h;\n+  constexpr bool operator == (const J &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c && x.d == d && x.e == e\n+\t   && x.f == f && x.g == g && x.h == h;\n+  }\n+};\n+\n+struct K\n+{\n+  long long int a, b, c;\n+  constexpr bool operator == (const K &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c;\n+  }\n+};\n+\n+struct M\n+{\n+  signed a : 6, b : 7, c : 6, d : 5;\n+  unsigned char e;\n+  unsigned int f;\n+  long long int g;\n+  constexpr bool operator == (const M &x) const\n+  {\n+    return x.a == a && x.b == b && x.c == c && x.d == d && x.e == e\n+\t   && x.f == f && x.g == g;\n+  }\n+};\n+\n+struct N\n+{\n+  unsigned long long int a, b;\n+  constexpr bool operator == (const N &x) const\n+  {\n+    return x.a == a && x.b == b;\n+  }\n+};\n+#endif\n+\n+static_assert (check <unsigned int> (0), \"\");\n+static_assert (check <long long int> (0xdeadbeeffeedbac1ULL), \"\");\n+static_assert (check <signed char> ((unsigned char) 42), \"\");\n+static_assert (check <char> ((unsigned char) 42), \"\");\n+static_assert (check <unsigned char> ((unsigned char) 42), \"\");\n+static_assert (check <signed char> ((signed char) 42), \"\");\n+static_assert (check <char> ((signed char) 42), \"\");\n+static_assert (check <unsigned char> ((signed char) 42), \"\");\n+static_assert (check <signed char> ((char) 42), \"\");\n+static_assert (check <char> ((char) 42), \"\");\n+static_assert (check <unsigned char> ((char) 42), \"\");\n+#if __SIZEOF_INT__ == __SIZEOF_FLOAT__\n+static_assert (check <int> (2.5f), \"\");\n+static_assert (check <unsigned int> (136.5f), \"\");\n+#endif\n+#if __SIZEOF_LONG_LONG__ == __SIZEOF_DOUBLE__\n+static_assert (check <long long> (2.5), \"\");\n+static_assert (check <long long unsigned> (123456.75), \"\");\n+#endif\n+\n+static_assert (check <B> (A{ 1, 2, 3 }), \"\");\n+static_assert (check <A> (B{ 4, 5, 6 }), \"\");\n+\n+#if __SIZEOF_INT__ == 4\n+static_assert (check <C> (A{ 7, 8, 9 }), \"\");\n+static_assert (check <C> (B{ 10, 11, 12 }), \"\");\n+static_assert (check <A> (C{ { { { 13, 14 }, { 15, 16 }, { 17, 18 } },\n+\t\t\t       { { 19, 20 }, { 21, 22 }, { 23, 24 } } } }), \"\");\n+constexpr unsigned char c[] = { 1, 2, 3, 4 };\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+static_assert (bit_cast <unsigned int> (c) == 0x04030201U, \"\");\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+static_assert (bit_cast <unsigned int> (c) == 0x01020304U, \"\");\n+#endif\n+\n+#if __cplusplus >= 201703L\n+static_assert (check <G> (H { 0x12345678, { 0x23456789, 0x5a876543 }, 0x3ba78654 }), \"\");\n+#endif\n+constexpr int d[] = { 0x12345678, 0x23456789, 0x5a876543, 0x3ba78654 };\n+static_assert (bit_cast <G> (d) == bit_cast <G> (H { 0x12345678, { 0x23456789, 0x5a876543 }, 0x3ba78654 }), \"\");\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+static_assert (bit_cast <I> (A { 0x7efa3412, 0x5a876543, 0x1eeffeed })\n+\t       == I { 0x7efa3412, 3, 0x50eca8, 0xb, 0x1eeffeed }, \"\");\n+static_assert (bit_cast <A> (I { 0x7efa3412, 3, 0x50eca8, 0xb, 0x1eeffeed })\n+\t       == A { 0x7efa3412, 0x5a876543, 0x1eeffeed }, \"\");\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+static_assert (bit_cast <I> (A { 0x7efa3412, 0x5a876543, 0x1eeffeed })\n+\t       == I { 0x7efa3412, 2, -0x2bc4d6, 0x3, 0x1eeffeed }, \"\");\n+static_assert (bit_cast <A> (I { 0x7efa3412, 2, -0x2bc4d6, 0x3, 0x1eeffeed })\n+\t       == A { 0x7efa3412, 0x5a876543, 0x1eeffeed }, \"\");\n+#endif\n+#endif\n+\n+#if 2 * __SIZEOF_INT__ == __SIZEOF_LONG_LONG__ && __SIZEOF_INT__ >= 4\n+constexpr unsigned long long a = 0xdeadbeeffee1deadULL;\n+constexpr unsigned b[] = { 0xfeedbacU, 0xbeeffeedU };\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+static_assert (bit_cast <D> (a) == D { int (0xfee1deadU), int (0xdeadbeefU) }, \"\");\n+static_assert (bit_cast <unsigned long long> (b) == 0xbeeffeed0feedbacULL, \"\");\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+static_assert (bit_cast <D> (a) == D { int (0xdeadbeefU), int (0xfee1deadU) }, \"\");\n+static_assert (bit_cast <unsigned long long> (b) == 0x0feedbacbeeffeedULL, \"\");\n+#endif\n+#endif\n+\n+#if __SIZEOF_INT__ == 4 && __SIZEOF_LONG_LONG__ == 8\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+static_assert (bit_cast <J> (K { 0x0feedbacdeadbeefLL, 7862463375103529997LL, 0x0feedbacdeadbeefLL })\n+\t       == J { 0x0feedbacdeadbeefLL, -1011, 2, -0xbacdeadbeLL, -1, -303, 1, 0x0feedbacdeadbeefLL }, \"\");\n+static_assert (bit_cast <K> (J { 0x0feedbacdeadbeefLL, -1011, 2, -0xbacdeadbeLL, -1, -303, 1, 0x0feedbacdeadbeefLL })\n+\t       == K { 0x0feedbacdeadbeefLL, 7862463375103529997LL, 0x0feedbacdeadbeefLL }, \"\");\n+static_assert (bit_cast <M> (N { 0xfeedbacdeadbeef8ULL, 0x123456789abcde42ULL })\n+\t       == M { -8, 59, 31, -5, 234, 0xfeedbacdU, 0x123456789abcde42ULL }, \"\");\n+static_assert (bit_cast <N> (M { -8, 59, 31, -5, 234, 0xfeedbacdU, 0x123456789abcde42ULL })\n+\t       == N { 0xfeedbacdeadbeef8ULL, 0x123456789abcde42ULL }, \"\");\n+#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+static_assert (bit_cast <J> (K { 0x0feedbacdeadbeefLL, -9103311533965288635LL, 0x0feedbacdeadbeefLL })\n+\t       == J { 0x0feedbacdeadbeefLL, -1011, 2, -0xbacdeadbeLL, -1, -303, 1, 0x0feedbacdeadbeefLL }, \"\");\n+static_assert (bit_cast <K> (J { 0x0feedbacdeadbeefLL, -1011, 2, -0xbacdeadbeLL, -1, -303, 1, 0x0feedbacdeadbeefLL })\n+\t       == K { 0x0feedbacdeadbeefLL, -9103311533965288635LL, 0x0feedbacdeadbeefLL }, \"\");\n+static_assert (bit_cast <M> (N { 0xfeedbacdeadbeef8ULL, 0x123456789abcde42ULL })\n+\t       == M { -1, -35, -19, -6, 205, 0xeadbeef8U, 0x123456789abcde42ULL }, \"\");\n+static_assert (bit_cast <N> (M { -1, -35, -19, -6, 205, 0xeadbeef8U, 0x123456789abcde42ULL })\n+\t       == N { 0xfeedbacdeadbeef8ULL, 0x123456789abcde42ULL }, \"\");\n+#endif\n+#endif"}, {"sha": "9ffa2ff01a2d6af65f5732a5724da8d1e8989661", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast4.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast4.C?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <typename To, typename From>\n+constexpr To\n+bit_cast (const From &from)\n+{\n+  return __builtin_bit_cast (To, from);\n+}\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'U' is a union type\" \"U\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'const U' is a union type\" \"const U\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'B' contains a union type\" \"B\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'char\\\\\\*' is a pointer type\" \"char ptr\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'const int\\\\\\*' is a pointer type\" \"const int ptr\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'C' contains a pointer type\" \"C\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'const C' contains a pointer type\" \"const C\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'int D::\\\\\\*' is a pointer to member type\" \"ptrmem 1\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'int \\\\\\(D::\\\\\\*\\\\\\)\\\\\\(\\\\\\) const' is a pointer to member type\" \"ptrmem 2\" { target *-*-* } 7 }\n+// { dg-error \"'__builtin_bit_cast' is not a constant expression because 'int \\\\\\(D::\\\\\\*\\\\\\)\\\\\\(\\\\\\)' is a pointer to member type\" \"ptrmem 3\" { target *-*-* } 7 }\n+\n+union U { int u; };\n+struct A { int a; U b; };\n+struct B : public A { int c; };\n+struct C { const int *p; };\n+constexpr int a[] = { 1, 2, 3 };\n+constexpr const int *b = &a[0];\n+constexpr C c = { b };\n+struct D { int d; constexpr int foo () const { return 1; } };\n+constexpr int D::*d = &D::d;\n+constexpr int (D::*e) () const = &D::foo;\n+struct E { __INTPTR_TYPE__ e, f; };\n+constexpr E f = { 1, 2 };\n+constexpr U g { 0 };\n+\n+constexpr auto z = bit_cast <U> (0);\n+constexpr auto y = bit_cast <int> (g);\n+constexpr auto x = bit_cast <B> (a);\n+constexpr auto w = bit_cast <char *> ((__INTPTR_TYPE__) 0);\n+constexpr auto v = bit_cast <__UINTPTR_TYPE__> (b);\n+constexpr auto u = bit_cast <C> ((__INTPTR_TYPE__) 0);\n+constexpr auto t = bit_cast <__INTPTR_TYPE__> (c);\n+constexpr auto s = bit_cast <__INTPTR_TYPE__> (d);\n+constexpr auto r = bit_cast <E> (e);\n+constexpr auto q = bit_cast <int D::*> ((__INTPTR_TYPE__) 0);\n+constexpr auto p = bit_cast <int (D::*) ()> (f);"}, {"sha": "9d536d1598403bfa45b6308870ed35ca116a4504", "filename": "gcc/testsuite/g++.dg/cpp2a/bit-cast5.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896048cf43d5eb21ab7c16553bb9d13b0f890b81/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fbit-cast5.C?ref=896048cf43d5eb21ab7c16553bb9d13b0f890b81", "patch": "@@ -0,0 +1,69 @@\n+// { dg-do compile { target { c++20 && { ilp32 || lp64 } } } }\n+\n+struct A { signed char a, b, c, d, e, f; };\n+struct B {};\n+struct C { B a, b; short c; B d; };\n+struct D { int a : 4, b : 24, c : 4; };\n+struct E { B a, b; short c; };\n+struct F { B a; signed char b, c; B d; };\n+\n+constexpr bool\n+f1 ()\n+{\n+  A a;\n+  a.c = 23; a.d = 42;\n+  C b = __builtin_bit_cast (C, a); // OK\n+  return false;\n+}\n+\n+constexpr bool\n+f2 ()\n+{\n+  A a;\n+  a.a = 1; a.b = 2; a.c = 3; a.e = 4; a.f = 5;\n+  C b = __builtin_bit_cast (C, a);\t// { dg-error \"'__builtin_bit_cast' accessing uninitialized byte at offset 3\" }\n+  return false;\n+}\n+\n+constexpr bool\n+f3 ()\n+{\n+  D a;\n+  a.b = 1;\n+  F b = __builtin_bit_cast (F, a); // OK\n+  return false;\n+}\n+\n+constexpr bool\n+f4 ()\n+{\n+  D a;\n+  a.b = 1; a.c = 2;\n+  E b = __builtin_bit_cast (E, a); // OK\n+  return false;\n+}\n+\n+constexpr bool\n+f5 ()\n+{\n+  D a;\n+  a.b = 1;\n+  E b = __builtin_bit_cast (E, a);\t// { dg-error \"'__builtin_bit_cast' accessing uninitialized byte at offset 3\" }\n+  return false;\n+}\n+\n+constexpr bool\n+f6 ()\n+{\n+  D a;\n+  a.c = 1;\n+  E b = __builtin_bit_cast (E, a);\t// { dg-error \"'__builtin_bit_cast' accessing uninitialized byte at offset 2\" }\n+  return false;\n+}\n+\n+constexpr bool a = f1 ();\n+constexpr bool b = f2 ();\n+constexpr bool c = f3 ();\n+constexpr bool d = f4 ();\n+constexpr bool e = f5 ();\n+constexpr bool f = f6 ();"}]}