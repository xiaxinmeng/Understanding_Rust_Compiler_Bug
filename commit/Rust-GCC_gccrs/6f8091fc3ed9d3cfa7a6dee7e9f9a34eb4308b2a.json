{"sha": "6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY4MDkxZmMzZWQ5ZDNjZmE3YTZkZWU3ZTlmOWEzNGViNDMwOGIyYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-20T06:22:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-20T06:22:58Z"}, "message": "ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n\n\n\t* ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n\t(possible_polymorphic_call_targets, dump_possible_polymorphic_call_targets,\n\tpossible_polymorphic_call_target_p, possible_polymorphic_call_target_p): Simplify.\n\t(get_dynamic_type): Remove.\n\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Remove.\n\t(clear_speculation): Bring to ipa-deivrt.h\n\t(get_class_context): Rename to ...\n\t(ipa_polymorphic_call_context::restrict_to_inner_class): ... this one.\n\t(contains_type_p): Update.\n\t(get_dynamic_type): Rename to ...\n\tipa_polymorphic_call_context::get_dynamic_type(): ... this one.\n\t(possible_polymorphic_call_targets): UPdate.\n\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children): Update.\n\t* ipa-prop.c (ipa_analyze_call_uses): Update.\n\nFrom-SVN: r215418", "tree": {"sha": "369013d698ddb409805fffaae30510b6caa5d22f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/369013d698ddb409805fffaae30510b6caa5d22f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/comments", "author": null, "committer": null, "parents": [{"sha": "8e1ba78f1b8eedd6c65c6f0e6d6d09a801de5d3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1ba78f1b8eedd6c65c6f0e6d6d09a801de5d3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1ba78f1b8eedd6c65c6f0e6d6d09a801de5d3d"}], "stats": {"total": 412, "additions": 222, "deletions": 190}, "files": [{"sha": "87b5e00c50fc806e885eaf4502a626d38d4501f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -1,3 +1,20 @@\n+2014-09-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (ipa_polymorphic_call_context): Turn into class; add ctors.\n+\t(possible_polymorphic_call_targets, dump_possible_polymorphic_call_targets,\n+\tpossible_polymorphic_call_target_p, possible_polymorphic_call_target_p): Simplify.\n+\t(get_dynamic_type): Remove.\n+\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Remove.\n+\t(clear_speculation): Bring to ipa-deivrt.h\n+\t(get_class_context): Rename to ...\n+\t(ipa_polymorphic_call_context::restrict_to_inner_class): ... this one.\n+\t(contains_type_p): Update.\n+\t(get_dynamic_type): Rename to ...\n+\tipa_polymorphic_call_context::get_dynamic_type(): ... this one.\n+\t(possible_polymorphic_call_targets): UPdate.\n+\t* tree-ssa-pre.c (eliminate_dom_walker::before_dom_children): Update.\n+\t* ipa-prop.c (ipa_analyze_call_uses): Update.\n+\n 2014-09-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-visibility.c (varpool_node::externally_visible_p): Do not"}, {"sha": "8f04284863f5c509788c9478870502d69cce5291", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -884,21 +884,15 @@ cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n       && (target = gimple_call_fn (call_stmt))\n       && virtual_method_call_p (target))\n     {\n-      tree otr_type;\n-      HOST_WIDE_INT otr_token;\n-      ipa_polymorphic_call_context context;\n-\n-      get_polymorphic_call_info (decl,\n-\t\t\t\t target,\n-\t\t\t\t &otr_type, &otr_token,\n-\t\t\t\t &context, call_stmt);\n+      ipa_polymorphic_call_context context (decl, target, call_stmt);\n \n       /* Only record types can have virtual calls.  */\n-      gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n       edge->indirect_info->polymorphic = true;\n       edge->indirect_info->param_index = -1;\n-      edge->indirect_info->otr_token = otr_token;\n-      edge->indirect_info->otr_type = otr_type;\n+      edge->indirect_info->otr_token\n+\t = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n+      edge->indirect_info->otr_type = obj_type_ref_class (target);\n+      gcc_assert (TREE_CODE (edge->indirect_info->otr_type) == RECORD_TYPE);\n       edge->indirect_info->outer_type = context.outer_type;\n       edge->indirect_info->speculative_outer_type\n \t = context.speculative_outer_type;"}, {"sha": "dc2c9428893303823c58afb1f3f3dd9cfeae3068", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -2563,8 +2563,8 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t{\n           if (dump_file && virtual_method_call_p (callee)\n \t      && !possible_polymorphic_call_target_p\n-\t\t    (callee, cgraph_node::get (gimple_call_addr_fndecl\n-\t\t\t\t\t       (OBJ_TYPE_REF_EXPR (callee)))))\n+\t\t    (callee, stmt, cgraph_node::get (gimple_call_addr_fndecl\n+\t\t\t\t\t\t     (OBJ_TYPE_REF_EXPR (callee)))))\n \t    {\n \t      fprintf (dump_file,\n \t\t       \"Type inheritance inconsistent devirtualization of \");"}, {"sha": "2ff3b9c1e369f7bb5e519f04227ff7cc5c10c042", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -1618,14 +1618,11 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \n   if (TREE_CODE (t) != TREE_BINFO)\n     {\n-      ipa_polymorphic_call_context context;\n+      ipa_polymorphic_call_context context (t, ie->indirect_info->otr_type,\n+\t\t\t\t\t    anc_offset);\n       vec <cgraph_node *>targets;\n       bool final;\n \n-      if (!get_polymorphic_call_info_from_invariant\n-\t     (&context, t, ie->indirect_info->otr_type,\n-\t      anc_offset))\n-\treturn NULL_TREE;\n       targets = possible_polymorphic_call_targets\n \t\t (ie->indirect_info->otr_type,\n \t\t  ie->indirect_info->otr_token,"}, {"sha": "af42c6d6bffd925df320181751d587e5c094941c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 144, "deletions": 112, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -2400,41 +2400,43 @@ decl_maybe_in_construction_p (tree base, tree outer_type,\n }\n \n /* Proudce polymorphic call context for call method of instance\n-   that is located within BASE (that is assumed to be a decl) at OFFSET. */\n+   that is located within BASE (that is assumed to be a decl) at offset OFF. */\n \n-static void\n-get_polymorphic_call_info_for_decl (ipa_polymorphic_call_context *context,\n-\t\t\t\t    tree base, HOST_WIDE_INT offset)\n+void\n+ipa_polymorphic_call_context::set_by_decl (tree base, HOST_WIDE_INT off)\n {\n   gcc_assert (DECL_P (base));\n \n-  context->outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n-  context->offset = offset;\n-  context->speculative_outer_type = NULL;\n-  context->speculative_offset = 0;\n-  context->speculative_maybe_derived_type = true;\n+  outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n+  offset = off;\n+  clear_speculation ();\n   /* Make very conservative assumption that all objects\n      may be in construction. \n      TODO: ipa-prop already contains code to tell better. \n      merge it later.  */\n-  context->maybe_in_construction = true;\n-  context->maybe_derived_type = false;\n+  maybe_in_construction = true;\n+  maybe_derived_type = false;\n }\n \n /* CST is an invariant (address of decl), try to get meaningful\n    polymorphic call context for polymorphic call of method \n-   if instance of OTR_TYPE that is located at OFFSET of this invariant.\n+   if instance of OTR_TYPE that is located at offset OFF of this invariant.\n    Return FALSE if nothing meaningful can be found.  */\n \n bool\n-get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *context,\n-\t\t\t\t          tree cst,\n-\t\t\t\t          tree otr_type,\n-\t\t\t\t          HOST_WIDE_INT offset)\n+ipa_polymorphic_call_context::set_by_invariant (tree cst,\n+\t\t\t\t\t\ttree otr_type,\n+\t\t\t\t\t\tHOST_WIDE_INT off)\n {\n   HOST_WIDE_INT offset2, size, max_size;\n   tree base;\n \n+  invalid = false;\n+  off = 0;\n+  outer_type = NULL;\n+  maybe_in_construction = true;\n+  maybe_derived_type = true;\n+\n   if (TREE_CODE (cst) != ADDR_EXPR)\n     return false;\n \n@@ -2445,10 +2447,13 @@ get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *context,\n \n   /* Only type inconsistent programs can have otr_type that is\n      not part of outer type.  */\n-  if (!contains_type_p (TREE_TYPE (base), offset, otr_type))\n-    return false;\n+  if (otr_type && !contains_type_p (TREE_TYPE (base), off, otr_type))\n+    {\n+      invalid = true;\n+      return false;\n+    }\n \n-  get_polymorphic_call_info_for_decl (context, base, offset);\n+  set_by_decl (base, off);\n   return true;\n }\n \n@@ -2472,34 +2477,46 @@ walk_ssa_copies (tree op)\n   return op;\n }\n \n-/* Given REF call in FNDECL, determine class of the polymorphic\n-   call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n-   CALL is optional argument giving the actual statement (usually call) where\n-   the context is used.\n-   Return pointer to object described by the context or an declaration if\n-   we found the instance to be stored in the static storage.  */\n+/* Create polymorphic call context from IP invariant CST.\n+   This is typically &global_var.\n+   OTR_TYPE specify type of polymorphic call or NULL if unknown, OFF\n+   is offset of call.  */\n \n-tree\n-get_polymorphic_call_info (tree fndecl,\n-\t\t\t   tree ref,\n-\t\t\t   tree *otr_type,\n-\t\t\t   HOST_WIDE_INT *otr_token,\n-\t\t\t   ipa_polymorphic_call_context *context,\n-\t\t\t   gimple call)\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree cst,\n+\t\t\t\t\t\t\t    tree otr_type,\n+\t\t\t\t\t\t\t    HOST_WIDE_INT off)\n+{\n+  clear_speculation ();\n+  set_by_invariant (cst, otr_type, off);\n+}\n+\n+/* Build context for pointer REF contained in FNDECL at statement STMT.\n+   if INSTANCE is non-NULL, return pointer to the object described by\n+   the context or DECL where context is contained in.  */\n+\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n+\t\t\t\t\t\t\t    tree ref,\n+\t\t\t\t\t\t\t    gimple stmt,\n+\t\t\t\t\t\t\t    tree *instance)\n {\n+  tree otr_type = NULL;\n   tree base_pointer;\n-  *otr_type = obj_type_ref_class (ref);\n-  *otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (ref));\n+\n+  if (TREE_CODE (ref) == OBJ_TYPE_REF)\n+    {\n+      otr_type = obj_type_ref_class (ref);\n+      base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n+    }\n+  else\n+    base_pointer = ref;\n \n   /* Set up basic info in case we find nothing interesting in the analysis.  */\n-  context->speculative_outer_type = NULL;\n-  context->speculative_offset = 0;\n-  context->speculative_maybe_derived_type = true;\n-  context->outer_type = TYPE_MAIN_VARIANT (*otr_type);\n-  context->offset = 0;\n-  base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n-  context->maybe_derived_type = true;\n-  context->maybe_in_construction = true;\n+  clear_speculation ();\n+  outer_type = TYPE_MAIN_VARIANT (otr_type);\n+  offset = 0;\n+  maybe_derived_type = true;\n+  maybe_in_construction = true;\n+  invalid = false;\n \n   /* Walk SSA for outer object.  */\n   do \n@@ -2522,9 +2539,9 @@ get_polymorphic_call_info (tree fndecl,\n \t      if (TREE_CODE (base) == MEM_REF)\n \t\t{\n \t\t  base_pointer = TREE_OPERAND (base, 0);\n-\t\t  context->offset\n+\t\t  offset\n \t\t    += offset2 + mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n-\t\t  context->outer_type = NULL;\n+\t\t  outer_type = NULL;\n \t\t}\n \t      /* We found base object.  In this case the outer_type\n \t\t is known.  */\n@@ -2534,24 +2551,25 @@ get_polymorphic_call_info (tree fndecl,\n \n \t\t  /* Only type inconsistent programs can have otr_type that is\n \t\t     not part of outer type.  */\n-\t\t  if (!contains_type_p (TREE_TYPE (base),\n-\t\t\t\t\tcontext->offset + offset2, *otr_type))\n+\t\t  if (otr_type\n+\t\t      && !contains_type_p (TREE_TYPE (base),\n+\t\t\t\t\t   offset + offset2, otr_type))\n \t\t    {\n-\t\t      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n-\t\t\t code sequences; we arrange the calls to be builtin_unreachable\n-\t\t\t later.  */\n-\t\t      *otr_token = INT_MAX;\n-\t\t      return base_pointer;\n+\t\t      invalid = true;\n+\t\t      if (instance)\n+\t\t\t*instance = base_pointer;\n+\t\t      return;\n \t\t    }\n-\t\t  get_polymorphic_call_info_for_decl (context, base,\n-\t\t\t\t\t\t      context->offset + offset2);\n-\t\t  if (context->maybe_in_construction && call)\n-\t\t    context->maybe_in_construction\n+\t\t  set_by_decl (base, offset + offset2);\n+\t\t  if (maybe_in_construction && stmt)\n+\t\t    maybe_in_construction\n \t\t     = decl_maybe_in_construction_p (base,\n-\t\t\t\t\t\t     context->outer_type,\n-\t\t\t\t\t\t     call,\n+\t\t\t\t\t\t     outer_type,\n+\t\t\t\t\t\t     stmt,\n \t\t\t\t\t\t     fndecl);\n-\t\t  return base;\n+\t\t  if (instance)\n+\t\t    *instance = base;\n+\t\t  return;\n \t\t}\n \t      else\n \t\tbreak;\n@@ -2562,7 +2580,7 @@ get_polymorphic_call_info (tree fndecl,\n       else if (TREE_CODE (base_pointer) == POINTER_PLUS_EXPR\n \t       && tree_fits_uhwi_p (TREE_OPERAND (base_pointer, 1)))\n \t{\n-\t  context->offset += tree_to_shwi (TREE_OPERAND (base_pointer, 1))\n+\t  offset += tree_to_shwi (TREE_OPERAND (base_pointer, 1))\n \t\t    * BITS_PER_UNIT;\n \t  base_pointer = TREE_OPERAND (base_pointer, 0);\n \t}\n@@ -2580,19 +2598,22 @@ get_polymorphic_call_info (tree fndecl,\n       if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE\n \t  && SSA_NAME_VAR (base_pointer) == DECL_ARGUMENTS (fndecl))\n \t{\n-\t  context->outer_type\n+\t  outer_type\n \t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (TREE_CODE (context->outer_type) == RECORD_TYPE);\n+\t  gcc_assert (TREE_CODE (outer_type) == RECORD_TYPE);\n \n \t  /* Dynamic casting has possibly upcasted the type\n \t     in the hiearchy.  In this case outer type is less\n \t     informative than inner type and we should forget\n \t     about it.  */\n-\t  if (!contains_type_p (context->outer_type, context->offset,\n-\t\t\t\t*otr_type))\n+\t  if (otr_type\n+\t      && !contains_type_p (outer_type, offset,\n+\t\t\t\t   otr_type))\n \t    {\n-\t      context->outer_type = NULL;\n-\t      return base_pointer;\n+\t      outer_type = NULL;\n+\t      if (instance)\n+\t\t*instance = base_pointer;\n+\t      return;\n \t    }\n \n \t  /* If the function is constructor or destructor, then\n@@ -2601,38 +2622,41 @@ get_polymorphic_call_info (tree fndecl,\n \t  if (DECL_CXX_CONSTRUCTOR_P (fndecl)\n \t      || DECL_CXX_DESTRUCTOR_P (fndecl))\n \t    {\n-\t      context->maybe_in_construction = true;\n-\t      context->maybe_derived_type = false;\n+\t      maybe_in_construction = true;\n+\t      maybe_derived_type = false;\n \t    }\n \t  else\n \t    {\n-\t      context->maybe_derived_type = true;\n-\t      context->maybe_in_construction = false;\n+\t      maybe_derived_type = true;\n+\t      maybe_in_construction = false;\n \t    }\n-\t  return base_pointer;\n+\t  if (instance)\n+\t    *instance = base_pointer;\n+\t  return;\n \t}\n       /* Non-PODs passed by value are really passed by invisible\n \t reference.  In this case we also know the type of the\n \t object.  */\n       if (DECL_BY_REFERENCE (SSA_NAME_VAR (base_pointer)))\n \t{\n-\t  context->outer_type\n+\t  outer_type\n \t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (!POINTER_TYPE_P (context->outer_type));\n+\t  gcc_assert (!POINTER_TYPE_P (outer_type));\n \t  /* Only type inconsistent programs can have otr_type that is\n \t     not part of outer type.  */\n-\t  if (!contains_type_p (context->outer_type, context->offset,\n-\t\t\t        *otr_type))\n+\t  if (!contains_type_p (outer_type, offset,\n+\t\t\t        otr_type))\n \t    { \n-\t      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n-\t\t code sequences; we arrange the calls to be builtin_unreachable\n-\t\t later.  */\n-\t      *otr_token = INT_MAX;\n-\t      return base_pointer;\n+\t      invalid = true;\n+\t      if (instance)\n+\t\t*instance = base_pointer;\n+\t      return;\n \t    }\n-\t  context->maybe_derived_type = false;\n-\t  context->maybe_in_construction = false;\n-          return base_pointer;\n+\t  maybe_derived_type = false;\n+\t  maybe_in_construction = false;\n+\t  if (instance)\n+\t    *instance = base_pointer;\n+\t  return;\n \t}\n     }\n \n@@ -2642,11 +2666,10 @@ get_polymorphic_call_info (tree fndecl,\n       && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n       && TREE_CODE (SSA_NAME_VAR (base_pointer)) != PARM_DECL)\n     {\n-      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n-\t code sequences; we arrange the calls to be builtin_unreachable\n-\t later.  */\n-      *otr_token = INT_MAX;\n-      return base_pointer;\n+      invalid = true;\n+      if (instance)\n+\t*instance = base_pointer;\n+      return;\n     }\n   if (TREE_CODE (base_pointer) == SSA_NAME\n       && SSA_NAME_DEF_STMT (base_pointer)\n@@ -2655,19 +2678,22 @@ get_polymorphic_call_info (tree fndecl,\n \t\t\t    (SSA_NAME_DEF_STMT (base_pointer)));\n  \n   if (POINTER_TYPE_P (base_type)\n-      && contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n-\t\t\t  context->offset,\n-\t\t\t  *otr_type))\n+      && (otr_type\n+\t  || !contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n+\t\t\t       offset,\n+\t\t\t       otr_type)))\n     {\n-      context->speculative_outer_type = TYPE_MAIN_VARIANT\n+      speculative_outer_type = TYPE_MAIN_VARIANT\n \t\t\t\t\t  (TREE_TYPE (base_type));\n-      context->speculative_offset = context->offset;\n-      context->speculative_maybe_derived_type = true;\n+      speculative_offset = offset;\n+      speculative_maybe_derived_type = true;\n     }\n   /* TODO: There are multiple ways to derive a type.  For instance\n      if BASE_POINTER is passed to an constructor call prior our refernece.\n      We do not make this type of flow sensitive analysis yet.  */\n-  return base_pointer;\n+  if (instance)\n+    *instance = base_pointer;\n+  return;\n }\n \n /* Structure to be passed in between detect_type_change and\n@@ -3404,9 +3430,6 @@ struct final_warning_record *final_warning_records;\n    temporarily change to one of base types.  INCLUDE_DERIVER_TYPES make\n    us to walk the inheritance graph for all derivations.\n \n-   OTR_TOKEN == INT_MAX is used to mark calls that are provably\n-   undefined and should be redirected to unreachable.\n-\n    If COMPLETEP is non-NULL, store true if the list is complete. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n    in the target cache.  If user needs to visit every target list\n@@ -3443,23 +3466,12 @@ possible_polymorphic_call_targets (tree otr_type,\n \n   otr_type = TYPE_MAIN_VARIANT (otr_type);\n \n-  /* If ODR is not initialized, return empty incomplete list.  */\n-  if (!odr_hash)\n+  /* If ODR is not initialized or the constext is invalid, return empty\n+     incomplete list.  */\n+  if (!odr_hash || context.invalid)\n     {\n       if (completep)\n-\t*completep = false;\n-      if (cache_token)\n-\t*cache_token = NULL;\n-      if (speculative_targetsp)\n-\t*speculative_targetsp = 0;\n-      return nodes;\n-    }\n-\n-  /* If we hit type inconsistency, just return empty list of targets.  */\n-  if (otr_token == INT_MAX)\n-    {\n-      if (completep)\n-\t*completep = true;\n+\t*completep = context.invalid;\n       if (cache_token)\n \t*cache_token = NULL;\n       if (speculative_targetsp)\n@@ -3853,6 +3865,26 @@ possible_polymorphic_call_target_p (tree otr_type,\n }\n \n \n+\n+/* Return true if N can be possibly target of a polymorphic call of\n+   OBJ_TYPE_REF expression REF in STMT.  */\n+\n+bool\n+possible_polymorphic_call_target_p (tree ref,\n+\t\t\t\t    gimple stmt,\n+\t\t\t\t    struct cgraph_node *n)\n+{\n+  ipa_polymorphic_call_context context (current_function_decl, ref, stmt);\n+  tree call_fn = gimple_call_fn (stmt);\n+\n+  return possible_polymorphic_call_target_p (obj_type_ref_class (call_fn),\n+\t\t\t\t\t     tree_to_uhwi\n+\t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (call_fn)),\n+\t\t\t\t\t     context,\n+\t\t\t\t\t     n);\n+}\n+\n+\n /* After callgraph construction new external nodes may appear.\n    Add them into the graph.  */\n "}, {"sha": "9223f3a2f5802c77f41e1d5b67a2ffd47c42511e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -2347,14 +2347,13 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n     {\n       tree otr_type;\n       HOST_WIDE_INT otr_token;\n-      ipa_polymorphic_call_context context;\n       tree instance;\n       tree target = gimple_call_fn (call);\n+      ipa_polymorphic_call_context context (current_function_decl,\n+\t\t\t\t\t    target, call, &instance);\n \n-      instance = get_polymorphic_call_info (current_function_decl,\n-\t\t\t\t\t    target,\n-\t\t\t\t\t    &otr_type, &otr_token,\n-\t\t\t\t\t    &context, call);\n+      otr_type = obj_type_ref_class (target);\n+      otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n \n       if (context.get_dynamic_type (instance,\n \t\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n@@ -2609,7 +2608,7 @@ ipa_intraprocedural_devirtualization (gimple call)\n #ifdef ENABLE_CHECKING\n   if (fndecl)\n     gcc_assert (possible_polymorphic_call_target_p\n-\t\t  (otr, cgraph_node::get (fndecl)));\n+\t\t  (otr, call, cgraph_node::get (fndecl)));\n #endif\n   return fndecl;\n }\n@@ -3121,14 +3120,12 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \n   if (TREE_CODE (binfo) != TREE_BINFO)\n     {\n-      ipa_polymorphic_call_context context;\n+      ipa_polymorphic_call_context context (binfo,\n+\t\t\t\t\t    ie->indirect_info->otr_type,\n+\t\t\t\t\t    ie->indirect_info->offset);\n       vec <cgraph_node *>targets;\n       bool final;\n \n-      if (!get_polymorphic_call_info_from_invariant\n-\t     (&context, binfo, ie->indirect_info->otr_type,\n-\t      ie->indirect_info->offset))\n-\treturn NULL;\n       targets = possible_polymorphic_call_targets\n \t\t (ie->indirect_info->otr_type,\n \t\t  ie->indirect_info->otr_token,"}, {"sha": "c81232cfccee994e72114365de5931d2ff7d64e2", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -53,12 +53,28 @@ class ipa_polymorphic_call_context {\n   /* True if speculative outer object may be of derived type.  We always\n      speculate that construction does not happen.  */\n   bool speculative_maybe_derived_type;\n+  /* True if the context is invalid and all calls should be redirected\n+     to BUILTIN_UNREACHABLE.  */\n+  bool invalid;\n \n   /* Build empty \"I know nothing\" context.  */\n   ipa_polymorphic_call_context ();\n-\n   /* Build polymorphic call context for indirect call E.  */\n   ipa_polymorphic_call_context (cgraph_edge *e);\n+  /* Build polymorphic call context for IP invariant CST.\n+     If specified, OTR_TYPE specify the type of polymorphic call\n+     that takes CST+OFFSET as a prameter.  */\n+  ipa_polymorphic_call_context (tree cst, tree otr_type = NULL,\n+\t\t\t\tHOST_WIDE_INT offset = 0);\n+  /* Build context for pointer REF contained in FNDECL at statement STMT.\n+     if INSTANCE is non-NULL, return pointer to the object described by\n+     the context.  */\n+  ipa_polymorphic_call_context (tree fndecl, tree ref, gimple stmt,\n+\t\t\t\ttree *instance = NULL);\n+\n+  /* Look for vtable stores or constructor calls to work out dynamic type\n+     of memory location.  */\n+  bool get_dynamic_type (tree, tree, tree, gimple);\n \n   /* Make context non-speculative.  */\n   void clear_speculation ();\n@@ -67,33 +83,41 @@ class ipa_polymorphic_call_context {\n      containing EXPECTED_TYPE as base class.  */\n   bool restrict_to_inner_class (tree expected_type);\n \n-  /* Look for vtable stores or constructor calls to work out dynamic type\n-     of memory location.  */\n-  bool get_dynamic_type (tree, tree, tree, gimple);\n+private:\n+  void set_by_decl (tree, HOST_WIDE_INT);\n+  bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n };\n \n /* Build polymorphic call context for indirect call E.  */\n \n inline\n ipa_polymorphic_call_context::ipa_polymorphic_call_context (cgraph_edge *e)\n {\n+  gcc_checking_assert (e->indirect_info->polymorphic);\n+\n   offset = e->indirect_info->offset;\n   speculative_offset = e->indirect_info->speculative_offset;\n   outer_type = e->indirect_info->outer_type;\n   speculative_outer_type = e->indirect_info->speculative_outer_type;\n   maybe_in_construction = e->indirect_info->maybe_in_construction;\n   maybe_derived_type = e->indirect_info->maybe_derived_type;\n   speculative_maybe_derived_type = e->indirect_info->speculative_maybe_derived_type;\n+  invalid = false;\n }\n \n /* Build empty \"I know nothing\" context.  */\n \n inline\n ipa_polymorphic_call_context::ipa_polymorphic_call_context ()\n- : offset(0), speculative_offset(0), outer_type(NULL),\n-   speculative_outer_type(NULL), maybe_in_construction(false),\n-   maybe_derived_type(false), speculative_maybe_derived_type(false)\n {\n+  offset = 0;\n+  speculative_offset = 0;\n+  outer_type = NULL;\n+  speculative_outer_type = NULL;\n+  maybe_in_construction = true;\n+  maybe_derived_type = true;\n+  speculative_maybe_derived_type = false;\n+  invalid = false;\n }\n \n /* Make context non-speculative.  */\n@@ -131,22 +155,17 @@ void update_type_inheritance_graph (void);\n vec <cgraph_node *>\n possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   ipa_polymorphic_call_context,\n-\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   bool *copletep = NULL,\n \t\t\t\t   void **cache_token = NULL,\n \t\t\t\t   int *nonconstruction_targets = NULL);\n odr_type get_odr_type (tree, bool insert = false);\n+bool possible_polymorphic_call_target_p (tree ref, gimple stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n \t\t\t\t         const ipa_polymorphic_call_context &,\n \t\t\t\t\t struct cgraph_node *);\n tree method_class_type (const_tree);\n-tree get_polymorphic_call_info (tree, tree, tree *,\n-\t\t\t\tHOST_WIDE_INT *,\n-\t\t\t\tipa_polymorphic_call_context *,\n-\t\t\t\tgimple call = NULL);\n-bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n-\t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n@@ -155,7 +174,7 @@ bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n \n /* Return vector containing possible targets of polymorphic call E.\n-   If FINALP is non-NULL, store true if the list is complette. \n+   If COMPLETEP is non-NULL, store true if the list is complette. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them.\n@@ -166,16 +185,16 @@ void register_odr_type (tree);\n \n inline vec <cgraph_node *>\n possible_polymorphic_call_targets (struct cgraph_edge *e,\n-\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   bool *completep = NULL,\n \t\t\t\t   void **cache_token = NULL,\n \t\t\t\t   int *nonconstruction_targets = NULL)\n {\n-  gcc_checking_assert (e->indirect_info->polymorphic);\n   ipa_polymorphic_call_context context(e);\n+\n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n \t\t\t\t\t    context,\n-\t\t\t\t\t    final, cache_token,\n+\t\t\t\t\t    completep, cache_token,\n \t\t\t\t\t    nonconstruction_targets);\n }\n \n@@ -184,30 +203,25 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n inline vec <cgraph_node *>\n possible_polymorphic_call_targets (tree ref,\n \t\t\t\t   gimple call,\n-\t\t\t\t   bool *final = NULL,\n+\t\t\t\t   bool *completep = NULL,\n \t\t\t\t   void **cache_token = NULL)\n {\n-  tree otr_type;\n-  HOST_WIDE_INT otr_token;\n-  ipa_polymorphic_call_context context;\n+  ipa_polymorphic_call_context context (current_function_decl, ref, call);\n \n-  get_polymorphic_call_info (current_function_decl,\n-\t\t\t     ref,\n-\t\t\t     &otr_type, &otr_token, &context, call);\n   return possible_polymorphic_call_targets (obj_type_ref_class (ref),\n \t\t\t\t\t    tree_to_uhwi\n \t\t\t\t\t      (OBJ_TYPE_REF_TOKEN (ref)),\n \t\t\t\t\t    context,\n-\t\t\t\t\t    final, cache_token);\n+\t\t\t\t\t    completep, cache_token);\n }\n \n /* Dump possible targets of a polymorphic call E into F.  */\n \n inline void\n dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n {\n-  gcc_checking_assert (e->indirect_info->polymorphic);\n   ipa_polymorphic_call_context context(e);\n+\n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n \t\t\t\t\t  e->indirect_info->otr_token,\n \t\t\t\t\t  context);\n@@ -221,26 +235,12 @@ possible_polymorphic_call_target_p (struct cgraph_edge *e,\n \t\t\t\t    struct cgraph_node *n)\n {\n   ipa_polymorphic_call_context context(e);\n+\n   return possible_polymorphic_call_target_p (e->indirect_info->otr_type,\n \t\t\t\t\t     e->indirect_info->otr_token,\n \t\t\t\t\t     context, n);\n }\n \n-/* Return true if N can be possibly target of a polymorphic call of\n-   OBJ_TYPE_REF expression CALL.  */\n-\n-inline bool\n-possible_polymorphic_call_target_p (tree call,\n-\t\t\t\t    struct cgraph_node *n)\n-{\n-  ipa_polymorphic_call_context context;\n-  return possible_polymorphic_call_target_p (obj_type_ref_class (call),\n-\t\t\t\t\t     tree_to_uhwi\n-\t\t\t\t\t       (OBJ_TYPE_REF_TOKEN (call)),\n-\t\t\t\t\t     context,\n-\t\t\t\t\t     n);\n-}\n-\n /* Return true of T is type with One Definition Rule info attached. \n    It means that either it is anonymous type or it has assembler name\n    set.  */"}, {"sha": "235846ff927a6c017a26c8f439082b4866dd1bf2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6f8091fc3ed9d3cfa7a6dee7e9f9a34eb4308b2a", "patch": "@@ -4277,16 +4277,11 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      && flag_devirtualize\n \t      && virtual_method_call_p (fn))\n \t    {\n-\t      tree otr_type;\n-\t      HOST_WIDE_INT otr_token;\n-\t      ipa_polymorphic_call_context context;\n+\t      tree otr_type = obj_type_ref_class (fn);\n \t      tree instance;\n+\t      ipa_polymorphic_call_context context (current_function_decl, fn, stmt, &instance);\n \t      bool final;\n \n-\t      instance = get_polymorphic_call_info (current_function_decl,\n-\t\t\t\t\t\t    fn,\n-\t\t\t\t\t\t    &otr_type, &otr_token, &context, stmt);\n-\n \t      context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn), otr_type, stmt);\n \n \t      vec <cgraph_node *>targets"}]}