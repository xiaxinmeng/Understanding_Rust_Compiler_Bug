{"sha": "4bc0caddeb318b227247b79da3ce9a5c456a12d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjMGNhZGRlYjMxOGIyMjcyNDdiNzlkYTNjZTlhNWM0NTZhMTJkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:42:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:42:39Z"}, "message": "[multiple changes]\n\n2013-04-12  Doug Rupp  <rupp@adacore.com>\n\n\t* init.c (SS$_CONTROLC, SS$_CONTINUE) [VMS]: New macros.\n\t(__gnat_handle_vms_condition) [VMS]: Dispatch on the Crtl/C user\n\thandler if installed.\n\t* ctrl_c.c (__gnat_install_int_handler)\n\t[VMS]: Install a dummy sigaction handler to trigger the real\n\tuser handler dispatch in init.c/__gnat_handle_vms_condition.\n\t(__gnat_uninstall_int_handler) [VMS]: Likewise.\n\n2013-04-12  Vincent Celier  <celier@adacore.com>\n\n\t* clean.adb (Parse_Cmd_Line): Set Directories_Must_Exist_In_Projects\n\tto False if switch is specified.\n\t* makeutl.adb (Initialize_Source_Record): Do not look for the\n\tobject file if there is no object directory.\n\t* opt.ads (Directories_Must_Exist_In_Projects): New Boolean\n\tvariable, defaulted to True.\n\t* prj-nmsc.adb (Check_Library_Attributes): Do not fail if library\n\tdirectory does not exist when Directories_Must_Exist_In_Projects is\n\tFalse.\n\t(Get_Directories): Do not fail when the object or the exec directory\n\tdo not exist when Directories_Must_Exist_In_Projects is False.\n\nFrom-SVN: r197918", "tree": {"sha": "d71967352feccf0d8a131039933b470ed8386628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d71967352feccf0d8a131039933b470ed8386628"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bc0caddeb318b227247b79da3ce9a5c456a12d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc0caddeb318b227247b79da3ce9a5c456a12d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc0caddeb318b227247b79da3ce9a5c456a12d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc0caddeb318b227247b79da3ce9a5c456a12d0/comments", "author": null, "committer": null, "parents": [{"sha": "b69cd36a46e574d92de18e1ede3d31e951ccf30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b69cd36a46e574d92de18e1ede3d31e951ccf30e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b69cd36a46e574d92de18e1ede3d31e951ccf30e"}], "stats": {"total": 277, "additions": 188, "deletions": 89}, "files": [{"sha": "c6e9cdd0270110c515c48fa3c0e61a3e7f160cc9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -1,3 +1,27 @@\n+2013-04-12  Doug Rupp  <rupp@adacore.com>\n+\n+\t* init.c (SS$_CONTROLC, SS$_CONTINUE) [VMS]: New macros.\n+\t(__gnat_handle_vms_condition) [VMS]: Dispatch on the Crtl/C user\n+\thandler if installed.\n+\t* ctrl_c.c (__gnat_install_int_handler)\n+\t[VMS]: Install a dummy sigaction handler to trigger the real\n+\tuser handler dispatch in init.c/__gnat_handle_vms_condition.\n+\t(__gnat_uninstall_int_handler) [VMS]: Likewise.\n+\n+2013-04-12  Vincent Celier  <celier@adacore.com>\n+\n+\t* clean.adb (Parse_Cmd_Line): Set Directories_Must_Exist_In_Projects\n+\tto False if switch is specified.\n+\t* makeutl.adb (Initialize_Source_Record): Do not look for the\n+\tobject file if there is no object directory.\n+\t* opt.ads (Directories_Must_Exist_In_Projects): New Boolean\n+\tvariable, defaulted to True.\n+\t* prj-nmsc.adb (Check_Library_Attributes): Do not fail if library\n+\tdirectory does not exist when Directories_Must_Exist_In_Projects is\n+\tFalse.\n+\t(Get_Directories): Do not fail when the object or the exec directory\n+\tdo not exist when Directories_Must_Exist_In_Projects is False.\n+\n 2013-04-12  Robert Dewar  <dewar@adacore.com>\n \n \t* namet.adb, namet.ads: Minor addition (7 arg version of Nam_In)."}, {"sha": "aa95c8d9bf30c0c683aabe4eaf6f6c2839ef1b47", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -1729,6 +1729,7 @@ package body Clean is\n \n                      when 'f' =>\n                         Force_Deletions := True;\n+                        Directories_Must_Exist_In_Projects := False;\n \n                      when 'F' =>\n                         Full_Path_Name_For_Brief_Errors := True;"}, {"sha": "7f8d177d17c08533dc6793783e2c5cb1d51b00b7", "filename": "gcc/ada/ctrl_c.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fctrl_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fctrl_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fctrl_c.c?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *        Copyright (C) 2002-2009, Free Software Foundation, Inc.           *\n+ *        Copyright (C) 2002-2013, Free Software Foundation, Inc.           *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -50,7 +50,24 @@ void __gnat_uninstall_int_handler (void);\n /* POSIX implementation */\n \n #if (defined (__unix__) || defined (_AIX) || defined (__APPLE__)) \\\n- && !defined (__vxworks)\n+ || defined (VMS) && !defined (__vxworks)\n+\n+#ifdef VMS\n+/* On VMS _gnat_handle_vms_condition gets control first, and it has to\n+   resignal the Ctrl/C in order for sigaction to gain control and execute\n+   the user handler routine, but in doing so propagates the condition\n+   causing the program to terminate.   So instead we install a dummy handler\n+   routine and put the real user handler in a special global variable so\n+   that __gnat_handle_vms_condition  can declare an AST to asynchronously\n+   execute the Ctrl/C user handler at some future time and allow\n+   __gnat_handle_vms_condition to return and not be held up waiting for\n+   the potentially unbounded time required to execute the Crtl/C handler.  */\n+void\n+dummy_handler () {}\n+\n+/* Lives in init.c.  */\n+extern void (*__gnat_ctrl_c_handler) (void);\n+#endif\n \n #include <signal.h>\n \n@@ -75,8 +92,8 @@ __gnat_install_int_handler (void (*proc) (void))\n   if (sigint_intercepted == 0)\n     {\n       act.sa_handler = __gnat_int_handler;\n-#if defined (__Lynx__)\n-      /* LynxOS does not support SA_RESTART. */\n+#if defined (__Lynx__) || defined (VMS)\n+      /* LynxOS and VMS do not support SA_RESTART. */\n       act.sa_flags = 0;\n #else\n       act.sa_flags = SA_RESTART;\n@@ -85,7 +102,12 @@ __gnat_install_int_handler (void (*proc) (void))\n       sigaction (SIGINT, &act, &original_act);\n     }\n \n+#ifdef VMS\n+  sigint_intercepted = &dummy_handler;\n+  __gnat_ctrl_c_handler = proc;\n+#else\n   sigint_intercepted = proc;\n+#endif\n }\n \n /* Restore original handler */\n@@ -98,6 +120,10 @@ __gnat_uninstall_int_handler (void)\n      sigaction (SIGINT, &original_act, 0);\n      sigint_intercepted = 0;\n    }\n+#ifdef VMS\n+  if (__gnat_ctrl_c_handler)\n+    __gnat_ctrl_c_handler = 0;\n+#endif\n }\n \n /* Windows implementation */"}, {"sha": "8408225dd7b48a90a369a00bb12f7c185cf60868", "filename": "gcc/ada/init.c", "status": "modified", "additions": 63, "deletions": 34, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -804,6 +804,7 @@ __gnat_install_handler (void)\n /* Routine called from binder to override default feature values. */\n void __gnat_set_features (void);\n int __gnat_features_set = 0;\n+void (*__gnat_ctrl_c_handler) (void) = 0;\n \n #ifdef __IA64\n #define lib_get_curr_invo_context LIB$I64_GET_CURR_INVO_CONTEXT\n@@ -818,10 +819,12 @@ int __gnat_features_set = 0;\n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n    It would be better to just include <ssdef.h> */\n \n+#define SS$_CONTINUE           1\n #define SS$_ACCVIO            12\n #define SS$_HPARITH         1284\n #define SS$_INTDIV          1156\n #define SS$_STKOVF          1364\n+#define SS$_CONTROLC        1617\n #define SS$_RESIGNAL        2328\n \n #define MTH$_FLOOVEMAT   1475268       /* Some ACVC_21 CXA tests */\n@@ -841,24 +844,28 @@ extern int LIB$_ACTIMAGE;\n #define FDL$_UNPRIKW 11829410\n #define CMA$_EXIT_THREAD 4227492\n \n-struct cond_sigargs {\n+struct cond_sigargs\n+{\n   unsigned int sigarg;\n   unsigned int sigargval;\n };\n \n-struct cond_subtests {\n+struct cond_subtests\n+{\n   unsigned int num;\n   const struct cond_sigargs sigargs[];\n };\n \n-struct cond_except {\n+struct cond_except\n+{\n   unsigned int cond;\n   const struct Exception_Data *except;\n   unsigned int needs_adjust;  /* 1 = adjust PC,  0 = no adjust */\n   const struct cond_subtests *subtests;\n };\n \n-struct descriptor_s {\n+struct descriptor_s\n+{\n   unsigned short len, mbz;\n   __char_ptr32 adr;\n };\n@@ -907,7 +914,6 @@ extern Exception_Code Base_Code_In (Exception_Code);\n    must be declared.  */\n \n #define FAC_MASK  \t\t0x0fff0000\n-#define MSG_MASK  \t\t0x0000fff8\n #define DECADA_M_FACILITY\t0x00310000\n \n #define ADA$_ALREADY_OPEN\t0x0031a594\n@@ -938,7 +944,8 @@ extern Exception_Code Base_Code_In (Exception_Code);\n #define ADA$_USE_ERROR\t\t0x0031a8a4\n \n /* DEC Ada specific conditions.  */\n-static const struct cond_except dec_ada_cond_except_table [] = {\n+static const struct cond_except dec_ada_cond_except_table [] =\n+{\n   {ADA$_PROGRAM_ERROR,   &program_error, 0, 0},\n   {ADA$_USE_ERROR,       &Use_Error, 0, 0},\n   {ADA$_KEYSIZERR,       &program_error, 0, 0},\n@@ -986,18 +993,19 @@ static const struct cond_except dec_ada_cond_except_table [] = {\n    in hindsight should have just made ACCVIO == Storage_Error.  */\n #define ACCVIO_VIRTUAL_ADDR 3\n static const struct cond_subtests accvio_c_e =\n-  {1,  /* number of subtests below */\n-     {\n-       {ACCVIO_VIRTUAL_ADDR, 0}\n-      }\n-   };\n+{1,  /* number of subtests below */\n+  {\n+     { ACCVIO_VIRTUAL_ADDR, 0 }\n+   }\n+};\n \n /* Macro flag to adjust PC which gets off by one for some conditions,\n    not sure if this is reliably true, PC could be off by more for\n    HPARITH for example, unless a trapb is inserted. */\n #define NEEDS_ADJUST 1\n \n-static const struct cond_except system_cond_except_table [] = {\n+static const struct cond_except system_cond_except_table [] =\n+{\n   {MTH$_FLOOVEMAT, &constraint_error, 0, 0},\n   {SS$_INTDIV,     &constraint_error, 0, 0},\n   {SS$_HPARITH,    &constraint_error, NEEDS_ADJUST, 0},\n@@ -1039,7 +1047,8 @@ static const struct cond_except system_cond_except_table [] = {\n typedef int\n resignal_predicate (int code);\n \n-static const int * const cond_resignal_table [] = {\n+static const int * const cond_resignal_table [] =\n+{\n   &C$_SIGKILL,\n   (int *)CMA$_EXIT_THREAD,\n   &SS$_DEBUG,\n@@ -1050,7 +1059,8 @@ static const int * const cond_resignal_table [] = {\n   0\n };\n \n-static const int facility_resignal_table [] = {\n+static const int facility_resignal_table [] =\n+{\n   0x1380000, /* RDB */\n   0x2220000, /* SQL */\n   0\n@@ -1098,7 +1108,6 @@ __gnat_set_resignal_predicate (resignal_predicate *predicate)\n /* Action routine for SYS$PUTMSG. There may be multiple\n    conditions, each with text to be appended to MESSAGE\n    and separated by line termination.  */\n-\n static int\n copy_msg (struct descriptor_s *msgdesc, char *message)\n {\n@@ -1124,7 +1133,6 @@ copy_msg (struct descriptor_s *msgdesc, char *message)\n \n /* Scan TABLE for a match for the condition contained in SIGARGS,\n    and return the entry, or the empty entry if no match found.  */\n-\n static const struct cond_except *\n   scan_conditions ( int *sigargs, const struct cond_except *table [])\n {\n@@ -1173,6 +1181,8 @@ static const struct cond_except *\n     return &(*table) [i];\n }\n \n+/* __gnat_handle_vms_condtition is both a frame based handler\n+   for the runtime, and an exception vector for the compiler.  */\n long\n __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n {\n@@ -1210,6 +1220,19 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n       const struct cond_except *cond_tables [] = {dec_ada_cond_except_table,\n \t\t\t\t\t          system_cond_except_table,\n \t\t\t\t\t          0};\n+      unsigned int ctrlc = SS$_CONTROLC;\n+      int ctrlc_match = LIB$MATCH_COND (&sigargs [1], &ctrlc);\n+\n+      extern int SYS$DCLAST (void (*astadr)(), unsigned long long astprm,\n+\t                     unsigned int acmode);\n+\n+      /* If SS$_CONTROLC has been imported as an exception, it will take\n+\t priority over a a Ctrl/C handler.  See above.  */\n+      if (ctrlc_match && __gnat_ctrl_c_handler)\n+\t{\n+\t  SYS$DCLAST (__gnat_ctrl_c_handler, 0, 0);\n+\t  return SS$_CONTINUE;\n+\t}\n \n       i = 0;\n       while ((cond_table = cond_tables[i++]) && !exception)\n@@ -1236,12 +1259,16 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n   /* Subtract PC & PSL fields as per ABI for SYS$PUTMSG.  */\n   sigargs[0] -= 2;\n \n+  extern int SYS$PUTMSG (void *, int (*)(), void *, unsigned long long);\n+\n   /* If it was a DEC Ada specific condtiion, make it GNAT otherwise\n      keep the old facility.  */\n   if (sigargs [1] & FAC_MASK == DECADA_M_FACILITY)\n-    SYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n+    SYS$PUTMSG (sigargs, copy_msg, &gnat_facility,\n+\t        (unsigned long long ) message);\n   else\n-    SYS$PUTMSG (sigargs, copy_msg, 0, message);\n+    SYS$PUTMSG (sigargs, copy_msg, 0,\n+\t        (unsigned long long ) message);\n \n   /* Add back PC & PSL fields as per ABI for SYS$PUTMSG.  */\n   sigargs[0] += 2;\n@@ -1259,6 +1286,8 @@ __gnat_install_handler (void)\n   long prvhnd ATTRIBUTE_UNUSED;\n \n #if !defined (IN_RTS)\n+  extern int SYS$SETEXV (unsigned int vector, int (*addres)(),\n+\t                 unsigned int accmode, void *(*(prvhnd)));\n   SYS$SETEXV (1, __gnat_handle_vms_condition, 3, &prvhnd);\n #endif\n \n@@ -1384,15 +1413,14 @@ struct regsum\n };\n \n extern int SYS$GET_REGION_INFO (unsigned int, unsigned long long *,\n-                                void *, void *, unsigned int,\n-                                void *, unsigned int *);\n+\t                        void *, void *, unsigned int,\n+\t                        void *, unsigned int *);\n extern int SYS$EXPREG_64 (unsigned long long *, unsigned long long,\n-                          unsigned int, unsigned int, void **,\n-                          unsigned long long *);\n+\t                  unsigned int, unsigned int, void **,\n+\t                  unsigned long long *);\n extern int SYS$SETPRT_64 (void *, unsigned long long, unsigned int,\n-                          unsigned int, void **, unsigned long long *,\n-                          unsigned int *);\n-extern int SYS$PUTMSG (void *, int (*)(), void *, unsigned long long);\n+\t                  unsigned int, void **, unsigned long long *,\n+\t                  unsigned int *);\n \n /* Add a guard page in the memory region containing ADDR at ADDR +/- SIZE.\n    (The sign depends on the kind of the memory region).  */\n@@ -1418,7 +1446,7 @@ __gnat_set_stack_guard_page (void *addr, unsigned long size)\n \n   /* Extend the region.  */\n   status = SYS$EXPREG_64 (&buffer.q_region_id,\n-                          size, 0, 0, &start_va, &length);\n+\t                  size, 0, 0, &start_va, &length);\n \n   if ((status & 1) != 1)\n     return -1;\n@@ -1428,7 +1456,7 @@ __gnat_set_stack_guard_page (void *addr, unsigned long size)\n     start_va = (void *)((unsigned long long)start_va + length - VMS_PAGESIZE);\n \n   status = SYS$SETPRT_64 (start_va, VMS_PAGESIZE, PSL__C_USER, PRT__C_NA,\n-                          &ret_va, &ret_len, &ret_prot);\n+\t                  &ret_va, &ret_len, &ret_prot);\n \n   if ((status & 1) != 1)\n     return -1;\n@@ -1479,7 +1507,8 @@ struct feature {\n int __gl_heap_size = 64;\n \n /* Array feature logical names and global variable addresses.  */\n-static const struct feature features[] = {\n+static const struct feature features[] =\n+{\n   {\"GNAT$NO_MALLOC_64\", &__gl_heap_size},\n   {0, 0}\n };\n@@ -1496,13 +1525,13 @@ __gnat_set_features (void)\n       __gnat_vms_get_logical (features[i].name, buff, sizeof (buff));\n \n       if (strcmp (buff, \"ENABLE\") == 0\n-          || strcmp (buff, \"TRUE\") == 0\n-          || strcmp (buff, \"1\") == 0)\n-        *features[i].gl_addr = 32;\n+\t  || strcmp (buff, \"TRUE\") == 0\n+\t  || strcmp (buff, \"1\") == 0)\n+\t*features[i].gl_addr = 32;\n       else if (strcmp (buff, \"DISABLE\") == 0\n-               || strcmp (buff, \"FALSE\") == 0\n-               || strcmp (buff, \"0\") == 0)\n-        *features[i].gl_addr = 64;\n+\t       || strcmp (buff, \"FALSE\") == 0\n+\t       || strcmp (buff, \"0\") == 0)\n+\t*features[i].gl_addr = 64;\n     }\n \n   /* Features to artificially limit the stack size.  */"}, {"sha": "d81aa0a44f55a0282be8afe25cb470a40abbcafa", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -1256,43 +1256,46 @@ package body Makeutl is\n          Obj_Proj := Source.Project;\n \n          while Obj_Proj /= No_Project loop\n-            declare\n-               Dir  : constant String :=\n-                        Get_Name_String\n-                          (Obj_Proj.Object_Directory.Display_Name);\n+            if Obj_Proj.Object_Directory /= No_Path_Information then\n+               declare\n+                  Dir  : constant String :=\n+                    Get_Name_String\n+                      (Obj_Proj.Object_Directory.Display_Name);\n \n-               Object_Path : constant String :=\n-                               Normalize_Pathname\n-                                 (Name          =>\n-                                    Get_Name_String (Source.Object),\n-                                  Resolve_Links => Opt.Follow_Links_For_Files,\n-                                  Directory     => Dir);\n+                  Object_Path : constant String :=\n+                    Normalize_Pathname\n+                      (Name          =>\n+                           Get_Name_String (Source.Object),\n+                       Resolve_Links => Opt.Follow_Links_For_Files,\n+                       Directory     => Dir);\n \n-               Obj_Path : constant Path_Name_Type := Create_Name (Object_Path);\n-               Stamp    : Time_Stamp_Type := Empty_Time_Stamp;\n+                  Obj_Path : constant Path_Name_Type :=\n+                    Create_Name (Object_Path);\n+                  Stamp    : Time_Stamp_Type := Empty_Time_Stamp;\n \n-            begin\n-               --  For specs, we do not check object files if there is a body.\n-               --  This saves a system call. On the other hand, we do need to\n-               --  know the object_path, in case the user has passed the .ads\n-               --  on the command line to compile the spec only.\n-\n-               if Source.Kind /= Spec\n-                 or else Source.Unit = No_Unit_Index\n-                 or else Source.Unit.File_Names (Impl) = No_Source\n-               then\n-                  Stamp := File_Stamp (Obj_Path);\n-               end if;\n+               begin\n+                  --  For specs, we do not check object files if there is a\n+                  --  body. This saves a system call. On the other hand, we do\n+                  --  need to know the object_path, in case the user has passed\n+                  --  the .ads on the command line to compile the spec only.\n+\n+                  if Source.Kind /= Spec\n+                    or else Source.Unit = No_Unit_Index\n+                    or else Source.Unit.File_Names (Impl) = No_Source\n+                  then\n+                     Stamp := File_Stamp (Obj_Path);\n+                  end if;\n \n-               if Stamp /= Empty_Time_Stamp\n-                 or else (Obj_Proj.Extended_By = No_Project\n-                          and then Source.Object_Project = No_Project)\n-               then\n-                  Set_Object_Project (Dir, Obj_Proj, Obj_Path, Stamp);\n-               end if;\n+                  if Stamp /= Empty_Time_Stamp\n+                    or else (Obj_Proj.Extended_By = No_Project\n+                              and then Source.Object_Project = No_Project)\n+                  then\n+                     Set_Object_Project (Dir, Obj_Proj, Obj_Path, Stamp);\n+                  end if;\n+               end;\n+            end if;\n \n-               Obj_Proj := Obj_Proj.Extended_By;\n-            end;\n+            Obj_Proj := Obj_Proj.Extended_By;\n          end loop;\n \n       elsif Source.Language.Config.Dependency_Kind = Makefile then"}, {"sha": "bbf6e295270808b8026ef116326b94d0f57a5c4e", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -436,6 +436,10 @@ package Opt is\n    --  Set True to force the run time to raise Program_Error if calls to\n    --  potentially blocking operations are detected from protected actions.\n \n+   Directories_Must_Exist_In_Projects : Boolean := True;\n+   --  PROJECT MANAGER\n+   --  Set to False with switch -f of gnatclean and gprclean\n+\n    Display_Compilation_Progress : Boolean := False;\n    --  GNATMAKE, GPRMAKE, GPRBUILD\n    --  Set True (-d switch) to display information on progress while compiling"}, {"sha": "c3b6ed5a8b388cca4f0f765e38fddac46734dc61", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc0caddeb318b227247b79da3ce9a5c456a12d0/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=4bc0caddeb318b227247b79da3ce9a5c456a12d0", "patch": "@@ -3155,16 +3155,19 @@ package body Prj.Nmsc is\n             end if;\n \n             if not Dir_Exists then\n+               if Directories_Must_Exist_In_Projects then\n+                  --  Get the absolute name of the library directory that does\n+                  --  not exist, to report an error.\n \n-               --  Get the absolute name of the library directory that\n-               --  does not exist, to report an error.\n+                  Err_Vars.Error_Msg_File_1 :=\n+                    File_Name_Type (Project.Library_Dir.Display_Name);\n+                  Error_Msg\n+                    (Data.Flags,\n+                     \"library directory { does not exist\",\n+                     Lib_Dir.Location, Project);\n+               end if;\n \n-               Err_Vars.Error_Msg_File_1 :=\n-                 File_Name_Type (Project.Library_Dir.Display_Name);\n-               Error_Msg\n-                 (Data.Flags,\n-                  \"library directory { does not exist\",\n-                  Lib_Dir.Location, Project);\n+               Project.Library_Dir := No_Path_Information;\n \n             --  Checks for object/source directories\n \n@@ -5407,15 +5410,20 @@ package body Prj.Nmsc is\n                Externally_Built => Project.Externally_Built);\n \n             if not Dir_Exists and then not Project.Externally_Built then\n+               if Opt.Directories_Must_Exist_In_Projects then\n+                  --  The object directory does not exist, report an error if\n+                  --  the project is not externally built.\n \n-               --  The object directory does not exist, report an error if the\n-               --  project is not externally built.\n+                  Err_Vars.Error_Msg_File_1 :=\n+                    File_Name_Type (Object_Dir.Value);\n+                  Error_Or_Warning\n+                    (Data.Flags, Data.Flags.Require_Obj_Dirs,\n+                     \"object directory { not found\",\n+                     Project.Location, Project);\n+               end if;\n+\n+               Project.Object_Directory := No_Path_Information;\n \n-               Err_Vars.Error_Msg_File_1 :=\n-                 File_Name_Type (Object_Dir.Value);\n-               Error_Or_Warning\n-                 (Data.Flags, Data.Flags.Require_Obj_Dirs,\n-                  \"object directory { not found\", Project.Location, Project);\n             end if;\n          end if;\n \n@@ -5488,10 +5496,14 @@ package body Prj.Nmsc is\n                Externally_Built => Project.Externally_Built);\n \n             if not Dir_Exists then\n-               Err_Vars.Error_Msg_File_1 := File_Name_Type (Exec_Dir.Value);\n-               Error_Or_Warning\n-                 (Data.Flags, Data.Flags.Missing_Source_Files,\n-                  \"exec directory { not found\", Project.Location, Project);\n+               if Opt.Directories_Must_Exist_In_Projects then\n+                  Err_Vars.Error_Msg_File_1 := File_Name_Type (Exec_Dir.Value);\n+                  Error_Or_Warning\n+                    (Data.Flags, Data.Flags.Missing_Source_Files,\n+                     \"exec directory { not found\", Project.Location, Project);\n+               end if;\n+\n+               Project.Exec_Directory := No_Path_Information;\n             end if;\n          end if;\n       end if;"}]}