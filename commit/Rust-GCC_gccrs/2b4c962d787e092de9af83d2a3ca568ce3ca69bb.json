{"sha": "2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0Yzk2MmQ3ODdlMDkyZGU5YWY4M2QyYTNjYTU2OGNlM2NhNjliYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:29:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:29:05Z"}, "message": "[multiple changes]\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* clean.adb: Minor reformatting.\n\t* opt.ads: Minor fix to incorrect comment.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-chtgbo.ads, a-chtgbo.adb (Delete_Node_At_Index): New\n\tsubprogram, used by bounded hashed sets, to delete a node at\n\ta given index, whose element may have been improperly updated\n\tthrough a Reference_Preserving key.\n\t* a-cbhase.ads: Add Reference_Control_Type to package Generic_Keys.\n\t* a-cbhase.adb: Add Adjust and Finalize routines for\n\tReference_Control_Type.\n\t(Delete, Insert): Raise Program_Error, not Constraint_Error,\n\twhen operation is illegal.\n\t(Reference_Preserving_Key): Build aggregate for Reference_Control_Type\n\t* a-cmbutr.ads: Add Reference_Control_Type to detect tampering. Add\n\tprivate with_clause for Ada.Finalization.\n\t* a-cbmutr.adb: Add Adjust and Finalize routines for\n\tReference_Control_Type. Use it in the construction of Reference\n\tand Constant_Reference values.\n\nFrom-SVN: r213285", "tree": {"sha": "71cd8e1fabb3e180122c16f7f4247f629b720c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71cd8e1fabb3e180122c16f7f4247f629b720c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/comments", "author": null, "committer": null, "parents": [{"sha": "c98b825308a59e73598f30dd14827a8c57567369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98b825308a59e73598f30dd14827a8c57567369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98b825308a59e73598f30dd14827a8c57567369"}], "stats": {"total": 372, "additions": 286, "deletions": 86}, "files": [{"sha": "96e883dd9e590015c4d5369269cdef91d65205e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -1,3 +1,26 @@\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* clean.adb: Minor reformatting.\n+\t* opt.ads: Minor fix to incorrect comment.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-chtgbo.ads, a-chtgbo.adb (Delete_Node_At_Index): New\n+\tsubprogram, used by bounded hashed sets, to delete a node at\n+\ta given index, whose element may have been improperly updated\n+\tthrough a Reference_Preserving key.\n+\t* a-cbhase.ads: Add Reference_Control_Type to package Generic_Keys.\n+\t* a-cbhase.adb: Add Adjust and Finalize routines for\n+\tReference_Control_Type.\n+\t(Delete, Insert): Raise Program_Error, not Constraint_Error,\n+\twhen operation is illegal.\n+\t(Reference_Preserving_Key): Build aggregate for Reference_Control_Type\n+\t* a-cmbutr.ads: Add Reference_Control_Type to detect tampering. Add\n+\tprivate with_clause for Ada.Finalization.\n+\t* a-cbmutr.adb: Add Adjust and Finalize routines for\n+\tReference_Control_Type. Use it in the construction of Reference\n+\tand Constant_Reference values.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_ch3.ads: Minor code reorganization."}, {"sha": "65cf7f7d788115192c43e369d6c6e37b4a518f93", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -1,4 +1,4 @@\n-------------------------------------------------------------------------------\n+-------------------------------------------------------------------------------\n --                                                                          --\n --                         GNAT LIBRARY COMPONENTS                          --\n --                                                                          --\n@@ -313,7 +313,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Element_Keys.Delete_Key_Sans_Free (Container, Item, X);\n \n       if X = 0 then\n-         raise Constraint_Error with \"attempt to delete element not in set\";\n+         raise Program_Error with \"attempt to delete element not in set\";\n       end if;\n \n       HT_Ops.Free (Container, X);\n@@ -762,7 +762,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Insert (Container, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error with\n+         raise Program_Error with\n            \"attempt to insert element already in set\";\n       end if;\n    end Insert;\n@@ -1621,6 +1621,23 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       -- Local Subprograms --\n       -----------------------\n \n+      ------------\n+      -- Adjust --\n+      ------------\n+\n+      procedure Adjust (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               B : Natural renames Control.Container.Busy;\n+               L : Natural renames Control.Container.Lock;\n+            begin\n+               B := B + 1;\n+               L := L + 1;\n+            end;\n+         end if;\n+      end Adjust;\n+\n       function Equivalent_Key_Node\n         (Key  : Key_Type;\n          Node : Node_Type) return Boolean;\n@@ -1751,6 +1768,32 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          HT_Ops.Free (Container, X);\n       end Exclude;\n \n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               B : Natural renames Control.Container.Busy;\n+               L : Natural renames Control.Container.Lock;\n+            begin\n+               B := B - 1;\n+               L := L - 1;\n+            end;\n+\n+            if Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n+            then\n+               HT_Ops.Delete_Node_At_Index\n+                (Control.Container.all, Control.Index, Control.Old_Pos.Node);\n+               raise Program_Error with \"key not preserved in reference\";\n+            end if;\n+\n+            Control.Container := null;\n+         end if;\n+      end Finalize;\n+\n       ----------\n       -- Find --\n       ----------\n@@ -1815,14 +1858,25 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in function Reference_Preserving_Key\");\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Position has\n-         --  not changed.  ???\n-\n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n          begin\n-            return (Element => N.Element'Access);\n+            return R : constant Reference_Type :=\n+                (Element  => N.Element'Unrestricted_Access,\n+                  Control  =>\n+                    (Controlled with\n+                       Container'Unrestricted_Access,\n+                       Index  =>\n+                         Key_Keys.Index (Container, Key (Position)),\n+                       Old_Pos => Position,\n+                       Old_Hash => Hash (Key (Position))))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n          end;\n       end Reference_Preserving_Key;\n \n@@ -1838,9 +1892,23 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          end if;\n \n          declare\n-            N : Node_Type renames Container.Nodes (Node);\n+            P : constant Cursor := Find (Container, Key);\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n+\n          begin\n-            return (Element => N.Element'Access);\n+            return R : constant Reference_Type :=\n+               (Element  => Container.Nodes (Node).Element'Unrestricted_Access,\n+                  Control  =>\n+                    (Controlled with\n+                       Container'Unrestricted_Access,\n+                       Index  => Key_Keys.Index (Container, Key),\n+                       Old_Pos => P,\n+                       Old_Hash => Hash (Key)))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n          end;\n       end Reference_Preserving_Key;\n "}, {"sha": "551e84133c0403bc57d900d6559d25d94c3d9593", "filename": "gcc/ada/a-cbhase.ads", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.ads?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -444,8 +444,29 @@ package Ada.Containers.Bounded_Hashed_Sets is\n          Key       : Key_Type) return Reference_Type;\n \n    private\n-      type Reference_Type (Element : not null access Element_Type) is\n-        null record;\n+      type Set_Access is access all Set;\n+      for Set_Access'Storage_Size use 0;\n+\n+      type Reference_Control_Type is\n+         new Ada.Finalization.Controlled with\n+      record\n+         Container : Set_Access;\n+         Index     : Hash_Type;\n+         Old_Pos   : Cursor;\n+         Old_Hash  : Hash_Type;\n+      end record;\n+\n+      overriding procedure\n+         Adjust (Control : in out Reference_Control_Type);\n+      pragma Inline (Adjust);\n+\n+      overriding procedure\n+         Finalize (Control : in out Reference_Control_Type);\n+      pragma Inline (Finalize);\n+\n+      type Reference_Type (Element : not null access Element_Type) is record\n+         Control  : Reference_Control_Type;\n+      end record;\n \n       use Ada.Streams;\n "}, {"sha": "26b0085b648625ae3e956d6bacc2c5933528d45d", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -27,8 +27,6 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Finalization; use Ada.Finalization;\n-\n with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Multiway_Trees is\n@@ -236,6 +234,24 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n                 Right_Subtree => Root_Node (Right));\n    end \"=\";\n \n+   ------------\n+   -- Adjust --\n+   ------------\n+\n+   procedure Adjust (Control : in out Reference_Control_Type) is\n+   begin\n+      if Control.Container /= null then\n+         declare\n+            C : Tree renames Control.Container.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n+         begin\n+            B := B + 1;\n+            L := L + 1;\n+         end;\n+      end if;\n+   end Adjust;\n+\n    -------------------\n    -- Allocate_Node --\n    -------------------\n@@ -329,12 +345,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n          raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      --  Commented-out pending ruling by ARG.  ???\n-\n-      --  if Position.Container /= Container'Unrestricted_Access then\n-      --     raise Program_Error with \"Position cursor not in container\";\n-      --  end if;\n-\n       --  AI-0136 says to raise PE if Position equals the root node. This does\n       --  not seem correct, as this value is just the limiting condition of the\n       --  search. For now we omit this check, pending a ruling from the ARG.\n@@ -602,7 +612,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  pragma Assert (Vet (Position),\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n-      return (Element => Container.Elements (Position.Node)'Access);\n+      declare\n+         C : Tree renames Position.Container.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n+\n+      begin\n+         return R : constant Constant_Reference_Type :=\n+           (Element => Container.Elements (Position.Node)'Access,\n+            Control => (Controlled with Container'Unrestricted_Access))\n+         do\n+            B := B + 1;\n+            L := L + 1;\n+         end return;\n+      end;\n    end Constant_Reference;\n \n    --------------\n@@ -1270,6 +1293,22 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       B := B - 1;\n    end Finalize;\n \n+   procedure Finalize (Control : in out Reference_Control_Type) is\n+   begin\n+      if Control.Container /= null then\n+         declare\n+            C : Tree renames Control.Container.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n+         begin\n+            B := B - 1;\n+            L := L - 1;\n+         end;\n+\n+         Control.Container := null;\n+      end if;\n+   end Finalize;\n+\n    ----------\n    -- Find --\n    ----------\n@@ -2516,7 +2555,20 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  pragma Assert (Vet (Position),\n       --                 \"Position cursor in Constant_Reference is bad\");\n \n-      return (Element => Container.Elements (Position.Node)'Access);\n+      declare\n+         C : Tree renames Position.Container.all;\n+         B : Natural renames C.Busy;\n+         L : Natural renames C.Lock;\n+      begin\n+         return R : constant Reference_Type :=\n+           (Element => Container.Elements (Position.Node)'Access,\n+            Control => (Controlled with Position.Container))\n+         do\n+            B := B + 1;\n+            L := L + 1;\n+         end return;\n+      end;\n+\n    end Reference;\n \n    --------------------"}, {"sha": "7fe4b4e2ff532a68eeb18ffe12f8a017fc755443", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2011-2012, Free Software Foundation, Inc.      --\n+--             Copyright (C) 2014, Free Software Foundation, Inc.           --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,6 +33,7 @@\n \n with Ada.Iterator_Interfaces;\n private with Ada.Streams;\n+private with Ada.Finalization;\n \n generic\n    type Element_Type is private;\n@@ -137,34 +138,10 @@ package Ada.Containers.Bounded_Multiway_Trees is\n      (Container : Tree;\n       Item      : Element_Type) return Cursor;\n \n-   --  This version of the AI:\n-   --   10-06-02  AI05-0136-1/07\n-   --  declares Find_In_Subtree this way:\n-   --\n-   --  function Find_In_Subtree\n-   --    (Container : Tree;\n-   --     Item      : Element_Type;\n-   --     Position  : Cursor) return Cursor;\n-   --\n-   --  It seems that the Container parameter is there by mistake, but we need\n-   --  an official ruling from the ARG. ???\n-\n    function Find_In_Subtree\n      (Position : Cursor;\n       Item     : Element_Type) return Cursor;\n \n-   --  This version of the AI:\n-   --   10-06-02  AI05-0136-1/07\n-   --  declares Ancestor_Find this way:\n-   --\n-   --  function Ancestor_Find\n-   --    (Container : Tree;\n-   --     Item      : Element_Type;\n-   --     Position  : Cursor) return Cursor;\n-   --\n-   --  It seems that the Container parameter is there by mistake, but we need\n-   --  an official ruling from the ARG. ???\n-\n    function Ancestor_Find\n      (Position : Cursor;\n       Item     : Element_Type) return Cursor;\n@@ -284,20 +261,6 @@ package Ada.Containers.Bounded_Multiway_Trees is\n \n    procedure Previous_Sibling (Position : in out Cursor);\n \n-   --  This version of the AI:\n-\n-   --   10-06-02  AI05-0136-1/07\n-\n-   --  declares Iterate_Children this way:\n-\n-   --  procedure Iterate_Children\n-   --    (Container : Tree;\n-   --     Parent    : Cursor;\n-   --     Process   : not null access procedure (Position : Cursor));\n-\n-   --  It seems that the Container parameter is there by mistake, but we need\n-   --  an official ruling from the ARG. ???\n-\n    procedure Iterate_Children\n      (Parent  : Cursor;\n       Process : not null access procedure (Position : Cursor));\n@@ -308,6 +271,7 @@ package Ada.Containers.Bounded_Multiway_Trees is\n \n private\n    use Ada.Streams;\n+   use Ada.Finalization;\n \n    No_Node : constant Count_Type'Base := -1;\n    --  Need to document all global declarations such as this ???\n@@ -368,8 +332,22 @@ private\n       Position : Cursor);\n    for Cursor'Write use Write;\n \n+   type Reference_Control_Type is\n+      new Controlled with record\n+         Container : Tree_Access;\n+      end record;\n+\n+   overriding procedure Adjust (Control : in out Reference_Control_Type);\n+   pragma Inline (Adjust);\n+\n+   overriding procedure Finalize (Control : in out Reference_Control_Type);\n+   pragma Inline (Finalize);\n+\n    type Constant_Reference_Type\n-     (Element : not null access constant Element_Type) is null record;\n+     (Element : not null access constant Element_Type) is\n+      record\n+         Control : Reference_Control_Type;\n+      end record;\n \n    procedure Write\n      (Stream : not null access Root_Stream_Type'Class;\n@@ -382,7 +360,10 @@ private\n    for Constant_Reference_Type'Read use Read;\n \n    type Reference_Type\n-     (Element : not null access Element_Type) is null record;\n+     (Element : not null access Element_Type) is\n+      record\n+         Control : Reference_Control_Type;\n+      end record;\n \n    procedure Write\n      (Stream : not null access Root_Stream_Type'Class;"}, {"sha": "38f950022545d7dba5bace369f4823af093333ec", "filename": "gcc/ada/a-chtgbo.adb", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-chtgbo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-chtgbo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.adb?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,6 +81,48 @@ package body Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n       HT.Buckets := (others => 0);  -- optimize this somehow ???\n    end Clear;\n \n+   --------------------------\n+   -- Delete_Node_At_Index --\n+   --------------------------\n+\n+   procedure Delete_Node_At_Index\n+     (HT    : in out Hash_Table_Type'Class;\n+      Indx  : Hash_Type;\n+      X     : Count_Type)\n+   is\n+      Prev : Count_Type;\n+      Curr : Count_Type;\n+\n+   begin\n+      Prev := HT.Buckets (Indx);\n+\n+      if Prev = 0 then\n+         raise Program_Error with\n+           \"attempt to delete node from empty hash bucket\";\n+      end if;\n+\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (HT.Nodes (Prev));\n+         HT.Length := HT.Length - 1;\n+         return;\n+      end if;\n+      if HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (HT.Nodes (Prev));\n+\n+         if Curr = 0 then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         Prev := Curr;\n+      end loop;\n+   end Delete_Node_At_Index;\n+\n    ---------------------------\n    -- Delete_Node_Sans_Free --\n    ---------------------------"}, {"sha": "719fae94ef52de88004be782f1878782d5d4760a", "filename": "gcc/ada/a-chtgbo.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-chtgbo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fa-chtgbo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgbo.ads?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -84,6 +84,17 @@ package Ada.Containers.Hash_Tables.Generic_Bounded_Operations is\n    --  the nodes, not the buckets array.)  Program_Error is raised if the hash\n    --  table is busy.\n \n+   procedure Delete_Node_At_Index\n+     (HT    : in out Hash_Table_Type'Class;\n+      Indx  : Hash_Type;\n+      X     : Count_Type);\n+\n+   --  Delete a node whose bucket position is known. extracted from following\n+   --  subprogram, but also used directly to remove a node whose element has\n+   --  been modified through a key_preserving reference: in that case we cannot\n+   --  use the value of the element precisely because the current value does\n+   --  not correspond to the hash code that determines its bucket.\n+\n    procedure Delete_Node_Sans_Free\n      (HT : in out Hash_Table_Type'Class;\n       X  : Count_Type);"}, {"sha": "8b34433e1c952ee5fc94c1fcc271f0b31361f587", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -740,11 +740,12 @@ package body Clean is\n                      if Last > 4 and then Name (Last - 3 .. Last) = \".ali\" then\n                         declare\n                            Unit : Unit_Index;\n+\n                         begin\n                            --  Compare with ALI file names of the project\n \n-                           Unit := Units_Htable.Get_First\n-                             (Project_Tree.Units_HT);\n+                           Unit :=\n+                             Units_Htable.Get_First (Project_Tree.Units_HT);\n                            while Unit /= No_Unit_Index loop\n                               if Unit.File_Names (Impl) /= null\n                                 and then Unit.File_Names (Impl).Project /=\n@@ -756,9 +757,10 @@ package body Clean is\n                                  then\n                                     Get_Name_String\n                                       (Unit.File_Names (Impl).File);\n-                                    Name_Len := Name_Len -\n-                                      File_Extension\n-                                        (Name (1 .. Name_Len))'Length;\n+                                    Name_Len :=\n+                                      Name_Len -\n+                                        File_Extension\n+                                          (Name (1 .. Name_Len))'Length;\n                                     if Name_Buffer (1 .. Name_Len) =\n                                          Name (1 .. Last - 4)\n                                     then\n@@ -772,8 +774,7 @@ package body Clean is\n                                            (Unit.File_Names (Spec).Project) =\n                                                                     Project\n                               then\n-                                 Get_Name_String\n-                                   (Unit.File_Names (Spec).File);\n+                                 Get_Name_String (Unit.File_Names (Spec).File);\n                                  Name_Len :=\n                                    Name_Len -\n                                      File_Extension\n@@ -869,7 +870,7 @@ package body Clean is\n \n          if Project.Object_Directory /= No_Path_Information\n            and then Is_Directory\n-             (Get_Name_String (Project.Object_Directory.Display_Name))\n+                      (Get_Name_String (Project.Object_Directory.Display_Name))\n          then\n             declare\n                Obj_Dir : constant String :=\n@@ -904,8 +905,9 @@ package body Clean is\n                              (Unit.File_Names (Impl).Project, Project))\n                        or else\n                          (Unit.File_Names (Spec) /= null\n-                          and then In_Extension_Chain\n-                            (Unit.File_Names (Spec).Project, Project))\n+                           and then\n+                             In_Extension_Chain\n+                               (Unit.File_Names (Spec).Project, Project))\n                      then\n                         if Unit.File_Names (Impl) /= null then\n                            File_Name1 := Unit.File_Names (Impl).File;\n@@ -942,17 +944,17 @@ package body Clean is\n \n                         declare\n                            Asm : constant String :=\n-                             Assembly_File_Name (Lib_File);\n+                                   Assembly_File_Name (Lib_File);\n                            ALI : constant String :=\n-                             ALI_File_Name      (Lib_File);\n+                                   ALI_File_Name      (Lib_File);\n                            Obj : constant String :=\n-                             Object_File_Name   (Lib_File);\n+                                   Object_File_Name   (Lib_File);\n                            Adt : constant String :=\n-                             Tree_File_Name     (Lib_File);\n+                                   Tree_File_Name     (Lib_File);\n                            Deb : constant String :=\n-                             Debug_File_Name    (File_Name1);\n+                                   Debug_File_Name    (File_Name1);\n                            Rep : constant String :=\n-                             Repinfo_File_Name  (File_Name1);\n+                                   Repinfo_File_Name  (File_Name1);\n                            Del : Boolean := True;\n \n                         begin\n@@ -1199,8 +1201,9 @@ package body Clean is\n                end if;\n \n                if Project.Object_Directory /= No_Path_Information\n-                 and then Is_Directory\n-                   (Get_Name_String (Project.Object_Directory.Display_Name))\n+                 and then\n+                   Is_Directory\n+                     (Get_Name_String (Project.Object_Directory.Display_Name))\n                then\n                   Delete_Binder_Generated_Files\n                     (Get_Name_String (Project.Object_Directory.Display_Name),\n@@ -1811,8 +1814,7 @@ package body Clean is\n                            declare\n                               Prj : constant String := Arg (3 .. Arg'Last);\n                            begin\n-                              if Prj'Length > 1 and then\n-                                Prj (Prj'First) = '='\n+                              if Prj'Length > 1 and then Prj (Prj'First) = '='\n                               then\n                                  Project_File_Name :=\n                                    new String'"}, {"sha": "dfb2aac86c4508cf25d9297452028a28fb78492b", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b4c962d787e092de9af83d2a3ca568ce3ca69bb/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=2b4c962d787e092de9af83d2a3ca568ce3ca69bb", "patch": "@@ -224,7 +224,7 @@ package Opt is\n    --  GNAT Normally, in accordance with (RM 13.9.1 (9-11)) the front end\n    --  assumes that values could have invalid representations, unless it can\n    --  clearly prove that the values are valid. If this switch is set (by\n-   --  pragma Assume_No_Invalid_Values (Off)), then the compiler assumes values\n+   --  pragma Assume_No_Invalid_Values (On)), then the compiler assumes values\n    --  are valid and in range of their representations. This feature is now\n    --  fully enabled in the compiler.\n "}]}