{"sha": "dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM1OGZhOWYzMTQyMDk3YmJjZjJkNjAyMTIwNDFkMDhhYjE2Y2Q4ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-02-12T01:21:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-02-12T01:21:39Z"}, "message": "PR c++/84036 - ICE with variadic capture.\n\n\tHandle variadic capture proxies more like non-variadic.\n\t* lambda.c (build_capture_proxy): Remove workaround.\n\t* pt.c (find_parameter_packs_r): The proxy is a pack.\n\t(instantiate_class_template_1): Remove dead lambda code.\n\t(extract_fnparm_pack): Don't make_pack_expansion.\n\t(extract_locals_r): Don't strip a pack expansion.\n\t(tsubst_pack_expansion): Handle proxy packs.  Use\n\tPACK_EXPANSION_EXTRA_ARGS less.\n\t(tsubst_decl) [FIELD_DECL]: Don't register_specialization.\n\t(tsubst_copy) [FIELD_DECL]: Don't retrieve*_specialization.\n\t[VAR_DECL]: Handle ARGUMENT_PACK_SELECT.\n\t(tsubst_expr) [DECL_EXPR]: Handle proxy packs.\n\t(tsubst_copy_and_build) [VAR_DECL]: Handle proxy packs normally.\n\nFrom-SVN: r257575", "tree": {"sha": "6015b7020be9ee3d06dffafcd87f625e23b96749", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6015b7020be9ee3d06dffafcd87f625e23b96749"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1ea257f3cda1f04a64a4046f77013727693eb70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ea257f3cda1f04a64a4046f77013727693eb70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ea257f3cda1f04a64a4046f77013727693eb70"}], "stats": {"total": 200, "additions": 79, "deletions": 121}, "files": [{"sha": "9b8793751b987c0a5acf3c8cfb4bb0f605d7cd21", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "patch": "@@ -1,3 +1,20 @@\n+2018-02-09  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/84036 - ICE with variadic capture.\n+\tHandle variadic capture proxies more like non-variadic.\n+\t* lambda.c (build_capture_proxy): Remove workaround.\n+\t* pt.c (find_parameter_packs_r): The proxy is a pack.\n+\t(instantiate_class_template_1): Remove dead lambda code.\n+\t(extract_fnparm_pack): Don't make_pack_expansion.\n+\t(extract_locals_r): Don't strip a pack expansion.\n+\t(tsubst_pack_expansion): Handle proxy packs.  Use\n+\tPACK_EXPANSION_EXTRA_ARGS less.\n+\t(tsubst_decl) [FIELD_DECL]: Don't register_specialization.\n+\t(tsubst_copy) [FIELD_DECL]: Don't retrieve*_specialization.\n+\t[VAR_DECL]: Handle ARGUMENT_PACK_SELECT.\n+\t(tsubst_expr) [DECL_EXPR]: Handle proxy packs.\n+\t(tsubst_copy_and_build) [VAR_DECL]: Handle proxy packs normally.\n+\n 2018-02-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/83987"}, {"sha": "6b5bd8007418968f65b1de772172e2ccbe8b136c", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "patch": "@@ -455,19 +455,11 @@ build_capture_proxy (tree member, tree init)\n \t  STRIP_NOPS (init);\n \t}\n \n-      if (TREE_CODE (init) == COMPONENT_REF)\n-\t/* We're capturing a capture of a function parameter pack, and have\n-\t   lost track of the original variable.  It's not important to have\n-\t   DECL_CAPTURED_VARIABLE in this case, since a function parameter pack\n-\t   isn't a constant variable, so don't bother trying to set it.  */;\n-      else\n-\t{\n-\t  gcc_assert (VAR_P (init) || TREE_CODE (init) == PARM_DECL);\n-\t  while (is_normal_capture_proxy (init))\n-\t    init = DECL_CAPTURED_VARIABLE (init);\n-\t  retrofit_lang_decl (var);\n-\t  DECL_CAPTURED_VARIABLE (var) = init;\n-\t}\n+      gcc_assert (VAR_P (init) || TREE_CODE (init) == PARM_DECL);\n+      while (is_normal_capture_proxy (init))\n+\tinit = DECL_CAPTURED_VARIABLE (init);\n+      retrofit_lang_decl (var);\n+      DECL_CAPTURED_VARIABLE (var) = init;\n     }\n \n   if (name == this_identifier)"}, {"sha": "b58c60f0dcb0e563b6304d5e44527382ca5e95dd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 36, "deletions": 108, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "patch": "@@ -3561,14 +3561,13 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n \n       /* Look through a lambda capture proxy to the field pack.  */\n     case VAR_DECL:\n-      if (DECL_HAS_VALUE_EXPR_P (t))\n-\t{\n-\t  tree v = DECL_VALUE_EXPR (t);\n-\t  cp_walk_tree (&v,\n-\t\t\t&find_parameter_packs_r,\n-\t\t\tppd, ppd->visited);\n-\t  *walk_subtrees = 0;\n-\t}\n+      if (DECL_PACK_P (t))\n+        {\n+          /* We don't want to walk into the type of a variadic capture proxy,\n+             because we don't want to see the type parameter pack.  */\n+          *walk_subtrees = 0;\n+\t  parameter_pack_p = true;\n+        }\n       else if (variable_template_specialization_p (t))\n \t{\n \t  cp_walk_tree (&DECL_TI_ARGS (t),\n@@ -10838,42 +10837,6 @@ instantiate_class_template_1 (tree type)\n       c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n     }\n \n-  if (tree expr = CLASSTYPE_LAMBDA_EXPR (type))\n-    {\n-      tree decl = lambda_function (type);\n-      if (decl)\n-\t{\n-\t  if (cxx_dialect >= cxx17)\n-\t    CLASSTYPE_LITERAL_P (type) = true;\n-\n-\t  if (!DECL_TEMPLATE_INFO (decl)\n-\t      || DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (decl)) != decl)\n-\t    {\n-\t      /* Set function_depth to avoid garbage collection.  */\n-\t      ++function_depth;\n-\t      instantiate_decl (decl, /*defer_ok=*/false, false);\n-\t      --function_depth;\n-\t    }\n-\n-\t  /* We need to instantiate the capture list from the template\n-\t     after we've instantiated the closure members, but before we\n-\t     consider adding the conversion op.  Also keep any captures\n-\t     that may have been added during instantiation of the op().  */\n-\t  tree tmpl_expr = CLASSTYPE_LAMBDA_EXPR (pattern);\n-\t  tree tmpl_cap\n-\t    = tsubst_copy_and_build (LAMBDA_EXPR_CAPTURE_LIST (tmpl_expr),\n-\t\t\t\t     args, tf_warning_or_error, NULL_TREE,\n-\t\t\t\t     false, false);\n-\n-\t  LAMBDA_EXPR_CAPTURE_LIST (expr)\n-\t    = chainon (tmpl_cap, nreverse (LAMBDA_EXPR_CAPTURE_LIST (expr)));\n-\n-\t  maybe_add_lambda_conv_op (type);\n-\t}\n-      else\n-\tgcc_assert (errorcount);\n-    }\n-\n   /* Set the file and line number information to whatever is given for\n      the class itself.  This puts error messages involving generated\n      implicit functions at a predictable point, and the same point\n@@ -10970,12 +10933,7 @@ extract_fnparm_pack (tree tmpl_parm, tree *spec_p)\n   parmvec = make_tree_vec (len);\n   spec_parm = *spec_p;\n   for (i = 0; i < len; i++, spec_parm = DECL_CHAIN (spec_parm))\n-    {\n-      tree elt = spec_parm;\n-      if (DECL_PACK_P (elt))\n-\telt = make_pack_expansion (elt);\n-      TREE_VEC_ELT (parmvec, i) = elt;\n-    }\n+    TREE_VEC_ELT (parmvec, i) = spec_parm;\n \n   /* Build the argument packs.  */\n   SET_ARGUMENT_PACK_ARGS (argpack, parmvec);\n@@ -11125,6 +11083,7 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n \n       /* Select the Ith argument from the pack.  */\n       if (TREE_CODE (parm) == PARM_DECL\n+\t  || VAR_P (parm)\n \t  || TREE_CODE (parm) == FIELD_DECL)\n \t{\n \t  if (index == 0)\n@@ -11429,8 +11388,7 @@ extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data)\n \t  /* Pull out the actual PARM_DECL for the partial instantiation.  */\n \t  tree args = ARGUMENT_PACK_ARGS (spec);\n \t  gcc_assert (TREE_VEC_LENGTH (args) == 1);\n-\t  tree arg = TREE_VEC_ELT (args, 0);\n-\t  spec = PACK_EXPANSION_PATTERN (arg);\n+\t  spec = TREE_VEC_ELT (args, 0);\n \t}\n       *extra = tree_cons (*tp, spec, *extra);\n     }\n@@ -11551,8 +11509,12 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t       where it isn't expected).  */\n \t    unsubstituted_fn_pack = true;\n \t}\n-      else if (TREE_CODE (parm_pack) == FIELD_DECL)\n-\targ_pack = tsubst_copy (parm_pack, args, complain, in_decl);\n+      else if (is_normal_capture_proxy (parm_pack))\n+\t{\n+\t  arg_pack = retrieve_local_specialization (parm_pack);\n+\t  if (argument_pack_element_is_expansion_p (arg_pack, 0))\n+\t    unsubstituted_fn_pack = true;\n+\t}\n       else\n         {\n \t  int idx;\n@@ -11647,15 +11609,14 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \n   /* We cannot expand this expansion expression, because we don't have\n      all of the argument packs we need.  */\n-  if (use_pack_expansion_extra_args_p (packs, len, (unsubstituted_packs\n-\t\t\t\t\t\t    || unsubstituted_fn_pack)))\n+  if (use_pack_expansion_extra_args_p (packs, len, unsubstituted_packs))\n     {\n       /* We got some full packs, but we can't substitute them in until we\n \t have values for all the packs.  So remember these until then.  */\n \n       t = make_pack_expansion (pattern, complain);\n       tree extra = args;\n-      if (unsubstituted_fn_pack)\n+      if (local_specializations)\n \tif (tree locals = extract_local_specs (pattern))\n \t  extra = tree_cons (NULL_TREE, extra, locals);\n       PACK_EXPANSION_EXTRA_ARGS (t) = extra;\n@@ -11713,6 +11674,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       tree parm = TREE_PURPOSE (pack);\n \n       if (TREE_CODE (parm) == PARM_DECL\n+\t  || VAR_P (parm)\n \t  || TREE_CODE (parm) == FIELD_DECL)\n         register_local_specialization (TREE_TYPE (pack), parm);\n       else\n@@ -12866,9 +12828,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (PACK_EXPANSION_P (TREE_TYPE (t)))\n \t  {\n \t    /* This field is a lambda capture pack.  Return a TREE_VEC of\n-\t       the expanded fields to instantiate_class_template_1 and\n-\t       store them in the specializations hash table as a\n-\t       NONTYPE_ARGUMENT_PACK so that tsubst_copy can find them.  */\n+\t       the expanded fields to instantiate_class_template_1.  */\n             expanded_types = tsubst_pack_expansion (TREE_TYPE (t), args,\n \t\t\t\t\t\t    complain, in_decl);\n             if (TREE_CODE (expanded_types) == TREE_VEC)\n@@ -12930,12 +12890,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t  }\n \n \tif (vec)\n-\t  {\n-\t    r = vec;\n-\t    tree pack = make_node (NONTYPE_ARGUMENT_PACK);\n-\t    SET_ARGUMENT_PACK_ARGS (pack, vec);\n-\t    register_specialization (pack, t, args, false, 0);\n-\t  }\n+\t  r = vec;\n       }\n       break;\n \n@@ -14827,31 +14782,6 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       return t;\n \n     case FIELD_DECL:\n-      if (PACK_EXPANSION_P (TREE_TYPE (t)))\n-\t{\n-\t  /* Check for a local specialization set up by\n-\t     tsubst_pack_expansion.  */\n-\t  if (tree r = retrieve_local_specialization (t))\n-\t    {\n-\t      if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)\n-\t\tr = ARGUMENT_PACK_SELECT_ARG (r);\n-\t      return r;\n-\t    }\n-\n-\t  /* When retrieving a capture pack from a generic lambda, remove the\n-\t     lambda call op's own template argument list from ARGS.  Only the\n-\t     template arguments active for the closure type should be used to\n-\t     retrieve the pack specialization.  */\n-\t  if (LAMBDA_FUNCTION_P (current_function_decl)\n-\t      && (template_class_depth (DECL_CONTEXT (t))\n-\t\t  != TMPL_ARGS_DEPTH (args)))\n-\t    args = strip_innermost_template_args (args, 1);\n-\n-\t  /* Otherwise return the full NONTYPE_ARGUMENT_PACK that\n-\t     tsubst_decl put in the hash table.  */\n-\t  return retrieve_specialization (t, args, 0);\n-\t}\n-\n       if (DECL_CONTEXT (t))\n \t{\n \t  tree ctx;\n@@ -14935,6 +14865,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      if (local_specializations)\n \t\tregister_local_specialization (r, t);\n \t    }\n+\t  if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)\n+\t    r = ARGUMENT_PACK_SELECT_ARG (r);\n \t}\n       else\n \tr = t;\n@@ -16104,20 +16036,24 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    else\n \t      finish_local_using_decl (decl, scope, name);\n \t  }\n-\telse if (DECL_PACK_P (decl))\n-\t  {\n-\t    /* Don't build up decls for a variadic capture proxy, we'll\n-\t       instantiate the elements directly as needed.  */\n-\t    break;\n-\t  }\n \telse if (is_capture_proxy (decl)\n \t\t && !DECL_TEMPLATE_INSTANTIATION (current_function_decl))\n \t  {\n \t    /* We're in tsubst_lambda_expr, we've already inserted a new\n \t       capture proxy, so look it up and register it.  */\n-\t    tree inst = lookup_name_real (DECL_NAME (decl), 0, 0,\n-\t\t\t\t\t  /*block_p=*/true, 0, LOOKUP_HIDDEN);\n-\t    gcc_assert (inst != decl && is_capture_proxy (inst));\n+\t    tree inst;\n+\t    if (DECL_PACK_P (decl))\n+\t      {\n+\t\tinst = (retrieve_local_specialization\n+\t\t\t(DECL_CAPTURED_VARIABLE (decl)));\n+\t\tgcc_assert (TREE_CODE (inst) == NONTYPE_ARGUMENT_PACK);\n+\t      }\n+\t    else\n+\t      {\n+\t\tinst = lookup_name_real (DECL_NAME (decl), 0, 0,\n+\t\t\t\t\t /*block_p=*/true, 0, LOOKUP_HIDDEN);\n+\t\tgcc_assert (inst != decl && is_capture_proxy (inst));\n+\t      }\n \t    register_local_specialization (inst, decl);\n \t    break;\n \t  }\n@@ -18265,14 +18201,6 @@ tsubst_copy_and_build (tree t,\n     case VAR_DECL:\n       if (!args)\n \tRETURN (t);\n-      else if (DECL_PACK_P (t))\n-\t{\n-\t  /* We don't build decls for an instantiation of a\n-\t     variadic capture proxy, we instantiate the elements\n-\t     when needed.  */\n-\t  gcc_assert (DECL_HAS_VALUE_EXPR_P (t));\n-\t  return RECUR (DECL_VALUE_EXPR (t));\n-\t}\n       /* Fall through */\n \n     case PARM_DECL:"}, {"sha": "01ef7c6e22083035f86f0d97dd8fe365612f378a", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic11.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc58fa9f3142097bbcf2d60212041d08ab16cd8e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic11.C?ref=dc58fa9f3142097bbcf2d60212041d08ab16cd8e", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/84036\n+// { dg-do compile { target c++14 } }\n+\n+template < typename... T > void sink(T ...){}\n+\n+template < typename T >\n+auto f(T){\n+  auto l = [](auto ... i){\n+    [i ...]{\n+      sink(i...);\n+      [=]{ sink(i ...); }();\n+    }();\n+  };\n+  l();\n+  l(42);\n+  l(0.1,0.2);\n+}\n+\n+int main(){\n+    f(0);\n+}"}]}