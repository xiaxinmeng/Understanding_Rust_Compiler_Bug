{"sha": "5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI0Nzc0MmMyZDI3OGY4ZjhhNGIxZTAyYzZlMWY3ODYzNDBkYTM4Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2006-02-15T09:31:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:31:40Z"}, "message": "re PR ada/26096 (Ada bootstrap fails in g-alleve.adb)\n\n2006-02-13  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* ada-tree.h: (TYPE_UNCHECKED_UNION_P): Deleted.\n\t\n\t* gigi.h (value_factor_p): Add prototype and description, now public.\n\n\t* decl.c (gnat_to_gnu_field): Don't attempt BLKmode to integral type\n\tpromotion for field with rep clause if the associated size was proven\n\tto be in error.\n\tExpand comments describing attempts to use a packable type.\n\t(gnat_to_gnu_entity) <E_Signed_Integer_Subtype,\n\tE_Floating_Point_Subtype>: Inherit alias set of what we are making a\n\tsubtype of to ensure conflicts amongst all subtypes in a hierarchy,\n\tnecessary since these are not different types and pointers may\n\tactually designate any subtype in this hierarchy.\n\t(gnat_to_gnu_entity, case E_Record_Type): Always make fields for\n\tdiscriminants but put them into record only if not Unchecked_Union;\n\tpass flag to components_to_record showing Unchecked_Union.\n\t(make_dummy_type): Use UNION_TYPE only if Unchecked_Union and no\n\tcomponents before variants; don't set TYPE_UNCHECKED_UNION_P.\n\t(components_to_record): New argument UNCHECKED_UNION.\n\tRemove special case code for Unchecked_Union and instead use main code\n\twith small changes.\n\n\tPR ada/26096\n\t(gnat_to_gnu_entity) <E_Variable>: Do not initialize the\n\taligning variable with the expression being built, only its inner\n\tfield.\n\n\t* trans.c (Handled_Sequence_Of_Statements_to_gnu): Remove call to\n\temit_sequence_entry_statements.\n\t(emit_sequence_entry_statements, body_with_handlers_p): Delete.\n\t(establish_gnat_vms_condition_handler): Move before\n\tSubprogram_Body_to_gnu.\n\t(Subprogram_Body_to_gnu): On VMS, establish_gnat_vms_condition_handler\n\tfor a subprogram if it has a foreign convention or is exported.\n\t(Identifier_to_gnu): Manually unshare the DECL_INITIAL tree when it is\n\tsubstituted for a CONST_DECL.\n\t(tree_transform, case N_Aggregate): Remove code for UNION_TYPE and pass\n\tEtype to assoc_to_constructor.\n\t(assoc_to_constructor): New argument, GNAT_ENTITY; use it to ignore\n\tdiscriminants of Unchecked_Union.\n\t(TARGET_ABI_OPEN_VMS): Define to 0 if not defined, so that later uses\n\tdon't need cluttering preprocessor directives.\n\t(establish_gnat_vms_condition_handler): New function. Establish the GNAT\n\tcondition handler as current in the compiled function.\n\t(body_with_handlers_p): New function. Tell whether a given sequence of\n\tstatements node is attached to a package or subprogram body and involves\n\texception handlers possibly nested within inner block statements.\n\t(emit_sequence_entry_statements): New function, to emit special\n\tstatements on entry of sequences when necessary. Establish GNAT\n\tcondition handler in the proper cases for VMS.\n\t(Handled_Sequence_Of_Statements_to_gnu): Start block code with\n\temit_sequence_entry_statements.\n\n\t* utils2.c (find_common_type): If both input types are BLKmode and\n\thave a constant size, use the smaller one.\n\t(build_simple_component_ref): Also match if FIELD and NEW_FIELD are\n\tthe same.\n\n\t* utils.c (value_factor_p): Make public, to allow uses from other gigi\n\tunits.\n\t(create_type_decl): Do not set the flag DECL_IGNORED_P for dummy types.\n\t(convert, case UNION_TYPE): Remove special treatment for unchecked\n\tunions.\n\n\tPR ada/18659\n\t(update_pointer_to): Update variants of pointer types to\n\tunconstrained arrays by attaching the list of fields of the main\n\tvariant.\n\nFrom-SVN: r111030", "tree": {"sha": "1fd44711246a1ea895cf60b81987968b22bb417e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd44711246a1ea895cf60b81987968b22bb417e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/comments", "author": null, "committer": null, "parents": [{"sha": "0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0022d9e31d01f2a31808ff38f66dd3e3ac96927a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0022d9e31d01f2a31808ff38f66dd3e3ac96927a"}], "stats": {"total": 424, "additions": 284, "deletions": 140}, "files": [{"sha": "3a363a746d9f794cb564ead25b503b00719fc65e", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2006 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -160,9 +160,6 @@ struct lang_type GTY(()) {tree t; };\n    padding or alignment.  */\n #define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n \n-/* For a UNION_TYPE, nonzero if this is an unchecked union.  */\n-#define TYPE_UNCHECKED_UNION_P(NODE) TYPE_LANG_FLAG_6 (UNION_TYPE_CHECK (NODE))\n-\n /* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n    subprogram contains no parameters passed by copy in/copy out then this\n    field is 0. Otherwise it points to a list of nodes used to specify the"}, {"sha": "1a17c37540ebcbde7a7fc3a7712bfff532226155", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 147, "deletions": 71, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -91,7 +91,7 @@ static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n static tree make_packable_type (tree);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n-                                  bool, bool, bool);\n+                                  bool, bool, bool, bool);\n static int compare_field_bitpos (const PTR, const PTR);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n@@ -1058,7 +1058,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t    gnu_new_var\n \t      = create_var_decl (create_concat_name (gnat_entity, \"ALIGN\"),\n-\t\t\t\t NULL_TREE, gnu_new_type, gnu_expr, false,\n+\t\t\t\t NULL_TREE, gnu_new_type, NULL_TREE, false,\n \t\t\t\t false, false, false, NULL, gnat_entity);\n \n \t    if (gnu_expr)\n@@ -1416,6 +1416,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       layout_type (gnu_type);\n \n+      /* Inherit our alias set from what we're a subtype of.  Subtypes\n+\t are not different types and a pointer can designate any instance\n+\t within a subtype hierarchy.  */\n+      copy_alias_set (gnu_type, TREE_TYPE (gnu_type));\n+\n       /* If the type we are dealing with is to represent a packed array,\n \t we need to have the bits left justified on big-endian targets\n \t and right justified on little-endian targets.  We also need to\n@@ -1449,6 +1454,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  finish_record_type (gnu_type, gnu_field, false, false);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \t  SET_TYPE_ADA_SIZE (gnu_type, bitsize_int (esize));\n+\n+\t  copy_alias_set (gnu_type, gnu_field_type);\n \t}\n \n       break;\n@@ -1516,6 +1523,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \tlayout_type (gnu_type);\n+\n+\t/* Inherit our alias set from what we're a subtype of, as for\n+\t   integer subtypes.  */\n+\tcopy_alias_set (gnu_type, TREE_TYPE (gnu_type));\n       }\n     break;\n \n@@ -2463,9 +2474,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TREE_OPERAND (gnu_get_parent, 1) = gnu_field_list;\n \t  }\n \n-\t/* Add the fields for the discriminants into the record.  */\n-        if (!Is_Unchecked_Union (gnat_entity)\n-\t    && Has_Discriminants (gnat_entity))\n+\t/* Make the fields for the discriminants and put them into the record\n+\t   unless it's an Unchecked_Union.  */\n+        if (Has_Discriminants (gnat_entity))\n \t  for (gnat_field = First_Stored_Discriminant (gnat_entity);\n \t       Present (gnat_field);\n \t       gnat_field = Next_Stored_Discriminant (gnat_field))\n@@ -2491,8 +2502,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t     gnu_field, NULL_TREE),\n \t\t\t     true);\n \n-\t      TREE_CHAIN (gnu_field) = gnu_field_list;\n-\t      gnu_field_list = gnu_field;\n+\t      if (!Is_Unchecked_Union (gnat_entity))\n+\t\t{\n+\t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n+\t\t  gnu_field_list = gnu_field;\n+\t\t}\n \t    }\n \n \t/* Put the discriminants into the record (backwards), so we can\n@@ -2503,7 +2517,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Add the listed fields into the record and finish up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, NULL,\n-\t\t\t      false, all_rep, this_deferred);\n+\t\t\t      false, all_rep, this_deferred,\n+\t\t\t      Is_Unchecked_Union (gnat_entity));\n \n         if (this_deferred)\n \t  {\n@@ -4479,6 +4494,7 @@ make_dummy_type (Entity_Id gnat_type)\n {\n   Entity_Id gnat_underlying;\n   tree gnu_type;\n+  enum tree_code code;\n \n   /* Find a full type for GNAT_TYPE, taking into account any class wide\n      types.  */\n@@ -4498,17 +4514,31 @@ make_dummy_type (Entity_Id gnat_type)\n     return dummy_node_table[gnat_underlying];\n \n   /* If this is a record, make this a RECORD_TYPE or UNION_TYPE; else make\n-     it a VOID_TYPE.  */\n-  if (Is_Unchecked_Union (gnat_underlying))\n+     it an ENUMERAL_TYPE.  */\n+  if (Is_Record_Type (gnat_underlying))\n     {\n-      gnu_type = make_node (UNION_TYPE);\n-      TYPE_UNCHECKED_UNION_P (gnu_type) = 1;\n+      Node_Id component_list\n+\t= Component_List (Type_Definition\n+\t\t\t  (Declaration_Node\n+\t\t\t   (Implementation_Base_Type (gnat_underlying))));\n+      Node_Id component;\n+\n+      /* Make this a UNION_TYPE unless it's either not an Unchecked_Union or\n+\t we have a non-discriminant field outside a variant.  In either case,\n+\t it's a RECORD_TYPE.  */\n+      code = UNION_TYPE;\n+      if (!Is_Unchecked_Union (gnat_underlying))\n+\tcode = RECORD_TYPE;\n+      else\n+\tfor (component = First_Non_Pragma (Component_Items (component_list));\n+\t     Present (component); component = Next_Non_Pragma (component))\n+\t  if (Ekind (Defining_Entity (component)) == E_Component)\n+\t    code = RECORD_TYPE;\n     }\n-  else if (Is_Record_Type (gnat_underlying))\n-    gnu_type = make_node (RECORD_TYPE);\n   else\n-    gnu_type = make_node (ENUMERAL_TYPE);\n+    code = ENUMERAL_TYPE;\n \n+  gnu_type = make_node (code);\n   TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n   TYPE_DUMMY_P (gnu_type) = 1;\n   if (AGGREGATE_TYPE_P (gnu_type))\n@@ -5215,39 +5245,66 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n \n-  /* If we are packing this record, have a specified size that's smaller than\n-     that of the field type, or a position is specified, and the field type is\n-     also a record that's BLKmode and with a small constant size, see if we\n-     can get a better form of the type that allows more packing.  If we can,\n-     show a size was specified for it if there wasn't one so we know to make\n-     this a bitfield and avoid making things wider.  */\n+  /* If we have a specified size that's smaller than that of the field type,\n+     or a position is specified, and the field type is also a record that's\n+     BLKmode and with a small constant size, see if we can get an integral\n+     mode form of the type when appropriate.  If we can, show a size was\n+     specified for the field if there wasn't one already, so we know to make\n+     this a bitfield and avoid making things wider.\n+\n+     Doing this is first useful if the record is packed because we can then\n+     place the field at a non-byte-aligned position and so achieve tigther\n+     packing.\n+\n+     This is in addition *required* if the field shares a byte with another\n+     field and the front-end lets the back-end handle the references, because\n+     GCC does not handle BLKmode bitfields properly.\n+\n+     We avoid the transformation if it is not required or potentially useful,\n+     as it might entail an increase of the field's alignment and have ripple\n+     effects on the outer record type.  A typical case is a field known to be\n+     byte aligned and not to share a byte with another field.\n+\n+     Besides, we don't even look the possibility of a transformation in cases\n+     known to be in error already, for instance when an invalid size results\n+     from a component clause.  */\n+\n   if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n       && TYPE_MODE (gnu_field_type) == BLKmode\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n       && compare_tree_int (TYPE_SIZE (gnu_field_type), BIGGEST_ALIGNMENT) <= 0\n       && (packed == 1\n \t  || (gnu_size\n \t      && tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type)))\n-\t  || Present (Component_Clause (gnat_field))))\n+\t  || (Present (Component_Clause (gnat_field)) && gnu_size != 0)))\n     {\n       /* See what the alternate type and size would be.  */\n       tree gnu_packable_type = make_packable_type (gnu_field_type);\n \n+      bool has_byte_aligned_clause\n+\t= Present (Component_Clause (gnat_field))\n+\t  && (UI_To_Int (Component_Bit_Offset (gnat_field))\n+\t      % BITS_PER_UNIT == 0);\n+\n       /* Compute whether we should avoid the substitution.  */\n       int reject =\n         /* There is no point substituting if there is no change.  */\n         (gnu_packable_type == gnu_field_type\n          ||\n+\t /* ... nor when the field is known to be byte aligned and not to\n+\t    share a byte with another field.  */\n+\t (has_byte_aligned_clause\n+\t  && value_factor_p (gnu_size, BITS_PER_UNIT))\n+\t ||\n          /* The size of an aliased field must be an exact multiple of the\n             type's alignment, which the substitution might increase.  Reject\n             substitutions that would so invalidate a component clause when the\n             specified position is byte aligned, as the change would have no\n             real benefit from the packing standpoint anyway.  */\n          (Is_Aliased (gnat_field)\n-          && Present (Component_Clause (gnat_field))\n-          && UI_To_Int (Component_Bit_Offset (gnat_field)) % BITS_PER_UNIT == 0\n-          && tree_low_cst (gnu_size, 1) % TYPE_ALIGN (gnu_packable_type) != 0)\n-         );\n+          && has_byte_aligned_clause\n+          && ! value_factor_p (gnu_size, TYPE_ALIGN (gnu_packable_type)))\n+\t );\n \n       /* Substitute unless told otherwise.  */\n       if (!reject)\n@@ -5477,19 +5534,21 @@ is_variable_size (tree type)\n    DEFER_DEBUG, if true, means that the debugging routines should not be\n    called when finishing constructing the record type.\n \n+   UNCHECKED_UNION, if tree, means that we are building a type for a record\n+   with a Pragma Unchecked_Union.\n+\n    The processing of the component list fills in the chain with all of the\n    fields of the record and then the record type is finished.  */\n \n static void\n components_to_record (tree gnu_record_type, Node_Id component_list,\n                       tree gnu_field_list, int packed, bool definition,\n                       tree *p_gnu_rep_list, bool cancel_alignment,\n-\t\t      bool all_rep, bool defer_debug)\n+\t\t      bool all_rep, bool defer_debug, bool unchecked_union)\n {\n   Node_Id component_decl;\n   Entity_Id gnat_field;\n   Node_Id variant_part;\n-  Node_Id variant;\n   tree gnu_our_rep_list = NULL_TREE;\n   tree gnu_field, gnu_last;\n   bool layout_with_rep = false;\n@@ -5530,49 +5589,44 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n   /* At the end of the component list there may be a variant part.  */\n   variant_part = Variant_Part (component_list);\n \n-  /* If this is an unchecked union, each variant must have exactly one\n-     component, each of which becomes one component of this union.  */\n-  if (TREE_CODE (gnu_record_type) == UNION_TYPE\n-      && TYPE_UNCHECKED_UNION_P (gnu_record_type)\n-      && Present (variant_part))\n-    for (variant = First_Non_Pragma (Variants (variant_part));\n-\t Present (variant);\n-\t variant = Next_Non_Pragma (variant))\n-      {\n-\tcomponent_decl\n-\t  = First_Non_Pragma (Component_Items (Component_List (variant)));\n-\tgnat_field = Defining_Entity (component_decl);\n-\tgnu_field = gnat_to_gnu_field (gnat_field, gnu_record_type, packed,\n-\t\t\t\t       definition);\n-\tTREE_CHAIN (gnu_field) = gnu_field_list;\n-\tgnu_field_list = gnu_field;\n-\tsave_gnu_tree (gnat_field, gnu_field, false);\n-      }\n-\n   /* We create a QUAL_UNION_TYPE for the variant part since the variants are\n      mutually exclusive and should go in the same memory.  To do this we need\n      to treat each variant as a record whose elements are created from the\n      component list for the variant.  So here we create the records from the\n-     lists for the variants and put them all into the QUAL_UNION_TYPE.  */\n-  else if (Present (variant_part))\n+     lists for the variants and put them all into the QUAL_UNION_TYPE.\n+     If this is an Unchecked_Union, we make a UNION_TYPE instead or\n+     use GNU_RECORD_TYPE if there are no fields so far.  */\n+  if (Present (variant_part))\n     {\n       tree gnu_discriminant = gnat_to_gnu (Name (variant_part));\n       Node_Id variant;\n-      tree gnu_union_type = make_node (QUAL_UNION_TYPE);\n-      tree gnu_union_field;\n-      tree gnu_variant_list = NULL_TREE;\n       tree gnu_name = TYPE_NAME (gnu_record_type);\n       tree gnu_var_name\n-\t= concat_id_with_name\n-\t  (get_identifier (Get_Name_String (Chars (Name (variant_part)))),\n-\t   \"XVN\");\n+\t= concat_id_with_name (get_identifier (Get_Name_String\n+\t\t\t\t\t       (Chars (Name (variant_part)))),\n+\t\t\t       \"XVN\");\n+      tree gnu_union_type;\n+      tree gnu_union_name;\n+      tree gnu_union_field;\n+      tree gnu_variant_list = NULL_TREE;\n \n       if (TREE_CODE (gnu_name) == TYPE_DECL)\n \tgnu_name = DECL_NAME (gnu_name);\n \n-      TYPE_NAME (gnu_union_type)\n-\t= concat_id_with_name (gnu_name, IDENTIFIER_POINTER (gnu_var_name));\n-      TYPE_PACKED (gnu_union_type) = TYPE_PACKED (gnu_record_type);\n+      gnu_union_name = concat_id_with_name (gnu_name,\n+\t\t\t\t\t    IDENTIFIER_POINTER (gnu_var_name));\n+\n+      if (!gnu_field_list && TREE_CODE (gnu_record_type) == UNION_TYPE)\n+\tgnu_union_type = gnu_record_type;\n+      else\n+\t{\n+\n+\t  gnu_union_type\n+\t    = make_node (unchecked_union ? UNION_TYPE : QUAL_UNION_TYPE);\n+\n+\t  TYPE_NAME (gnu_union_type) = gnu_union_name;\n+\t  TYPE_PACKED (gnu_union_type) = TYPE_PACKED (gnu_record_type);\n+\t}\n \n       for (variant = First_Non_Pragma (Variants (variant_part));\n            Present (variant);\n@@ -5585,7 +5639,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  Get_Variant_Encoding (variant);\n \t  gnu_inner_name = get_identifier (Name_Buffer);\n \t  TYPE_NAME (gnu_variant_type)\n-\t    = concat_id_with_name (TYPE_NAME (gnu_union_type),\n+\t    = concat_id_with_name (gnu_union_name,\n \t\t\t\t   IDENTIFIER_POINTER (gnu_inner_name));\n \n \t  /* Set the alignment of the inner type in case we need to make\n@@ -5607,27 +5661,40 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n \t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n-\t\t\t\tfalse);\n+\t\t\t\tfalse, unchecked_union);\n \n \t  gnu_qual = choices_to_gnu (gnu_discriminant,\n \t\t\t\t     Discrete_Choices (variant));\n \n \t  Set_Present_Expr (variant, annotate_value (gnu_qual));\n-\t  gnu_field = create_field_decl (gnu_inner_name, gnu_variant_type,\n-\t\t\t\t\t gnu_union_type, 0,\n-\t\t\t\t\t (all_rep_and_size\n-\t\t\t\t\t  ? TYPE_SIZE (gnu_record_type) : 0),\n-\t\t\t\t\t (all_rep_and_size\n-\t\t\t\t\t  ? bitsize_zero_node : 0),\n-\t\t\t\t\t 0);\n \n-\t  DECL_INTERNAL_P (gnu_field) = 1;\n-\t  DECL_QUALIFIER (gnu_field) = gnu_qual;\n+\t  /* If this is an Unchecked_Union and we have exactly one field,\n+\t     use that field here.  */\n+\t  if (unchecked_union && TYPE_FIELDS (gnu_variant_type)\n+\t      && !TREE_CHAIN (TYPE_FIELDS (gnu_variant_type)))\n+\t    gnu_field = TYPE_FIELDS (gnu_variant_type);\n+\t  else\n+\t    {\n+\t      gnu_field = create_field_decl (gnu_inner_name, gnu_variant_type,\n+\t\t\t\t\t     gnu_union_type, 0,\n+\t\t\t\t\t     (all_rep_and_size\n+\t\t\t\t\t      ? TYPE_SIZE (gnu_record_type)\n+\t\t\t\t\t      : 0),\n+\t\t\t\t\t     (all_rep_and_size\n+\t\t\t\t\t      ? bitsize_zero_node : 0),\n+\t\t\t\t\t     0);\n+\n+\t      DECL_INTERNAL_P (gnu_field) = 1;\n+\n+\t      if (!unchecked_union)\n+\t\tDECL_QUALIFIER (gnu_field) = gnu_qual;\n+\t    }\n+\n \t  TREE_CHAIN (gnu_field) = gnu_variant_list;\n \t  gnu_variant_list = gnu_field;\n \t}\n \n-      /* We use to delete the empty variants from the end. However,\n+      /* We used to delete the empty variants from the end. However,\n          we no longer do that because we need them to generate complete\n          debugging information for the variant record.  Otherwise,\n          the union type definition will be missing the fields associated\n@@ -5646,6 +5713,15 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \t  finish_record_type (gnu_union_type, nreverse (gnu_variant_list),\n \t\t\t      all_rep_and_size, false);\n \n+\t  /* If GNU_UNION_TYPE is our record type, it means we must have an\n+\t     Unchecked_Union with no fields.  Verify that and, if so, just\n+\t     return.  */\n+\t  if (gnu_union_type == gnu_record_type)\n+\t    {\n+\t      gcc_assert (!gnu_field_list && unchecked_union);\n+\t      return;\n+\t    }\n+\n \t  gnu_union_field\n \t    = create_field_decl (gnu_var_name, gnu_union_type, gnu_record_type,\n \t\t\t\t packed,"}, {"sha": "bc7844c817760aced3895e4825e4e53cf1c1b873", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2006 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -680,6 +680,10 @@ extern tree get_ada_base_type (tree type);\n    in bits.  If we don't know anything about the alignment, return 0.  */\n extern unsigned int known_alignment (tree exp);\n \n+/* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n+   of 2. */\n+extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n+\n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0"}, {"sha": "1a9f3f4dc78834e6e39663cd33cc7d0517271eb9", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -57,6 +57,12 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n \n+/* Let code below know whether we are targetting VMS without need of\n+   intrusive preprocessor directives.  */\n+#ifndef TARGET_ABI_OPEN_VMS\n+#define TARGET_ABI_OPEN_VMS 0\n+#endif\n+\n int max_gnat_nodes;\n int number_names;\n struct Node *Nodes_Ptr;\n@@ -159,7 +165,7 @@ static tree emit_index_check (tree, tree, tree, tree);\n static tree emit_check (tree, tree, int);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n static bool addressable_p (tree);\n-static tree assoc_to_constructor (Node_Id, tree);\n+static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n@@ -446,7 +452,18 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t    == Attr_Unchecked_Access)\n \t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n \t\t\t   == Attr_Unrestricted_Access)))))\n-\tgnu_result = DECL_INITIAL (gnu_result);\n+\t{\n+\t  gnu_result = DECL_INITIAL (gnu_result);\n+\t  /* ??? The mark/unmark mechanism implemented in Gigi to prevent tree\n+\t     sharing between global level and subprogram level doesn't apply\n+\t     to elaboration routines.  As a result, the DECL_INITIAL tree may\n+\t     be shared between the static initializer of a global object and\n+\t     the elaboration routine, thus wreaking havoc if a local temporary\n+\t     is created in place during gimplification of the latter and the\n+\t     former is emitted afterwards.  Manually unshare for now.  */\n+\t  if (TREE_VISITED (gnu_result))\n+\t    gnu_result = unshare_expr (gnu_result);\n+\t}\n     }\n \n   *gnu_result_type_p = gnu_result_type;\n@@ -1340,6 +1357,57 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* Emit statements to establish __gnat_handle_vms_condition as a VMS condition\n+   handler for the current function.  */\n+\n+/* This is implemented by issuing a call to the appropriate VMS specific\n+   builtin.  To avoid having VMS specific sections in the global gigi decls\n+   array, we maintain the decls of interest here.  We can't declare them\n+   inside the function because we must mark them never to be GC'd, which we\n+   can only do at the global level.  */\n+\n+static GTY(()) tree vms_builtin_establish_handler_decl = NULL_TREE;\n+static GTY(()) tree gnat_vms_condition_handler_decl = NULL_TREE;\n+\n+static void\n+establish_gnat_vms_condition_handler (void)\n+{\n+  tree establish_stmt;\n+\n+  /* Elaborate the required decls on the first call.  Check on the decl for\n+     the gnat condition handler to decide, as this is one we create so we are\n+     sure that it will be non null on subsequent calls.  The builtin decl is\n+     looked up so remains null on targets where it is not implemented yet.  */\n+  if (gnat_vms_condition_handler_decl == NULL_TREE)\n+    {\n+      vms_builtin_establish_handler_decl\n+\t= builtin_decl_for\n+\t  (get_identifier (\"__builtin_establish_vms_condition_handler\"));\n+\n+      gnat_vms_condition_handler_decl\n+\t= create_subprog_decl (get_identifier (\"__gnat_handle_vms_condition\"),\n+\t\t\t       NULL_TREE,\n+\t\t\t       build_function_type_list (integer_type_node,\n+\t\t\t\t\t\t\t ptr_void_type_node,\n+\t\t\t\t\t\t\t ptr_void_type_node,\n+\t\t\t\t\t\t\t NULL_TREE),\n+\t\t\t       NULL_TREE, 0, 1, 1, 0, Empty);\n+    }\n+\n+  /* Do nothing if the establish builtin is not available, which might happen\n+     on targets where the facility is not implemented.  */\n+  if (vms_builtin_establish_handler_decl == NULL_TREE)\n+    return;\n+\n+  establish_stmt\n+    = build_call_1_expr (vms_builtin_establish_handler_decl,\n+\t\t\t build_unary_op\n+\t\t\t (ADDR_EXPR, NULL_TREE,\n+\t\t\t  gnat_vms_condition_handler_decl));\n+\n+  add_stmt (establish_stmt);\n+}\n+\f\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n    don't return anything.  */\n \n@@ -1433,6 +1501,22 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t\t     gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n       }\n \n+\n+  /* On VMS, establish our condition handler to possibly turn a condition into\n+     the corresponding exception if the subprogram has a foreign convention or\n+     is exported.\n+\n+     To ensure proper execution of local finalizations on condition instances,\n+     we must turn a condition into the corresponding exception even if there\n+     is no applicable Ada handler, and need at least one condition handler per\n+     possible call chain involving GNAT code.  OTOH, establishing the handler\n+     has a cost so we want to mimize the number of subprograms into which this\n+     happens.  The foreign or exported condition is expected to satisfy all\n+     the constraints.  */\n+  if (TARGET_ABI_OPEN_VMS\n+      && (Has_Foreign_Convention (gnat_node) || Is_Exported (gnat_node)))\n+    establish_gnat_vms_condition_handler ();\n+\n   process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n \n   /* Generate the code of the subprogram itself.  A return statement will be\n@@ -3082,25 +3166,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (Null_Record_Present (gnat_node))\n \t  gnu_result = gnat_build_constructor (gnu_aggr_type, NULL_TREE);\n \n-\telse if (TREE_CODE (gnu_aggr_type) == UNION_TYPE\n-\t\t && TYPE_UNCHECKED_UNION_P (gnu_aggr_type))\n-\t  {\n-\t    /* The first element is the discrimant, which we ignore.  The\n-\t       next is the field we're building.  Convert the expression\n-\t       to the type of the field and then to the union type.  */\n-\t    Node_Id gnat_assoc\n-\t      = Next (First (Component_Associations (gnat_node)));\n-\t    Entity_Id gnat_field = Entity (First (Choices (gnat_assoc)));\n-\t    tree gnu_field_type\n-\t      = TREE_TYPE (gnat_to_gnu_entity (gnat_field, NULL_TREE, 0));\n-\n-\t    gnu_result = convert (gnu_field_type,\n-\t\t\t\t  gnat_to_gnu (Expression (gnat_assoc)));\n-\t  }\n \telse if (TREE_CODE (gnu_aggr_type) == RECORD_TYPE\n \t\t || TREE_CODE (gnu_aggr_type) == UNION_TYPE)\n \t  gnu_result\n-\t    = assoc_to_constructor (First (Component_Associations (gnat_node)),\n+\t    = assoc_to_constructor (Etype (gnat_node),\n+\t\t\t\t    First (Component_Associations (gnat_node)),\n \t\t\t\t    gnu_aggr_type);\n \telse if (TREE_CODE (gnu_aggr_type) == ARRAY_TYPE)\n \t  gnu_result = pos_to_constructor (First (Expressions (gnat_node)),\n@@ -3996,7 +4066,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  if (Present (Actual_Designated_Subtype (gnat_node)))\n \t    {\n-\t      gnu_actual_obj_type = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n+\t      gnu_actual_obj_type\n+\t        = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n \n \t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n \t        gnu_actual_obj_type\n@@ -5582,13 +5653,14 @@ process_type (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* GNAT_ASSOC is the front of the Component_Associations of an N_Aggregate.\n-   GNU_TYPE is the GCC type of the corresponding record.\n+/* GNAT_ENTITY is the type of the resulting constructors,\n+   GNAT_ASSOC is the front of the Component_Associations of an N_Aggregate,\n+   and GNU_TYPE is the GCC type of the corresponding record.\n \n    Return a CONSTRUCTOR to build the record.  */\n \n static tree\n-assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n+assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n {\n   tree gnu_list, gnu_result;\n \n@@ -5614,6 +5686,11 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n \t  && Is_Tagged_Type (Scope (Entity (gnat_field))))\n \tcontinue;\n \n+      /* Also ignore discriminants of Unchecked_Unions.  */\n+      else if (Is_Unchecked_Union (gnat_entity)\n+\t       && Ekind (Entity (gnat_field)) == E_Discriminant)\n+\tcontinue;\n+\n       /* Before assigning a value in an aggregate make sure range checks\n \t are done if required.  Then convert to the type of the field.  */\n       if (Do_Range_Check (Expression (gnat_assoc)))"}, {"sha": "78c1237b08e48b1dc0eae3664585c2fc2e8d57f1", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -133,7 +133,6 @@ static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static tree convert_to_thin_pointer (tree, tree);\n static tree make_descriptor_field (const char *,tree, tree, tree);\n-static bool value_factor_p (tree, HOST_WIDE_INT);\n static bool potential_alignment_gap (tree, tree, tree);\n \f\n /* Initialize the association of GNAT nodes to GCC trees.  */\n@@ -1215,9 +1214,10 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \n   /* Pass type declaration information to the debugger unless this is an\n      UNCONSTRAINED_ARRAY_TYPE, which the debugger does not support,\n-     and ENUMERAL_TYPE or RECORD_TYPE which is handled separately,\n-     a dummy type, which will be completed later, or a type for which\n-     debugging information was not requested.  */\n+     and ENUMERAL_TYPE or RECORD_TYPE which is handled separately, or\n+     type for which debugging information was not requested.  */\n+  if (code == UNCONSTRAINED_ARRAY_TYPE || ! debug_info_p)\n+    DECL_IGNORED_P (type_decl) = 1;\n   if (code == UNCONSTRAINED_ARRAY_TYPE || TYPE_IS_DUMMY_P (type)\n       || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n@@ -1573,7 +1573,7 @@ process_attributes (tree decl, struct attrib *attr_list)\n /* Return true if VALUE is a known to be a multiple of FACTOR, which must be\n    a power of 2. */\n \n-static bool\n+bool\n value_factor_p (tree value, HOST_WIDE_INT factor)\n {\n   if (host_integerp (value, 1))\n@@ -2471,7 +2471,8 @@ build_unc_object_type (tree template_type, tree object_type, tree name)\n /* Same, taking a thin or fat pointer type instead of a template type. */\n \n tree\n-build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type, tree name)\n+build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type,\n+\t\t\t\ttree name)\n {\n   tree template_type;\n \n@@ -2592,7 +2593,13 @@ update_pointer_to (tree old_type, tree new_type)\n \t\t\t\t  TREE_CHAIN (TYPE_FIELDS (ptr)), new_ref));\n \n       for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n-\tSET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n+\t{\n+\t  SET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n+\n+\t  /* This may seem a bit gross, in particular wrt DECL_CONTEXT, but\n+\t     actually is in keeping with what build_qualified_type does.  */\n+\t  TYPE_FIELDS (var) = TYPE_FIELDS (ptr);\n+\t}\n \n       TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n \t= TREE_TYPE (new_type) = ptr;\n@@ -2722,7 +2729,6 @@ convert (tree type, tree expr)\n   enum tree_code code = TREE_CODE (type);\n   tree etype = TREE_TYPE (expr);\n   enum tree_code ecode = TREE_CODE (etype);\n-  tree tem;\n \n   /* If EXPR is already the right type, we are done.  */\n   if (type == etype)\n@@ -2892,11 +2898,9 @@ convert (tree type, tree expr)\n \t      return build1 (VIEW_CONVERT_EXPR, type, op0);\n \n \t    /* Otherwise, we may just bypass the input view conversion unless\n-\t       one of the types is a fat pointer, or we're converting to an\n-\t       unchecked union type.  Both are handled by specialized code\n-\t       below and the latter relies on exact type matching.  */\n-\t    else if (!TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype)\n-\t\t     && !(code == UNION_TYPE && TYPE_UNCHECKED_UNION_P (type)))\n+\t       one of the types is a fat pointer,  which is handled by\n+\t       specialized code below which relies on exact type matching.  */\n+\t    else if (!TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n \t      return convert (type, op0);\n \t  }\n       }\n@@ -3020,29 +3024,10 @@ convert (tree type, tree expr)\n       return unchecked_convert (type, expr, false);\n \n     case UNION_TYPE:\n-      /* For unchecked unions, just validate that the type is indeed that of\n-\t a field of the type.  Then make the simple conversion.  */\n-      if (TYPE_UNCHECKED_UNION_P (type))\n-\t{\n-\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n-\t    {\n-\t      if (TREE_TYPE (tem) == etype)\n-\t\treturn build1 (CONVERT_EXPR, type, expr);\n-\t      else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n-\t\t       && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n-\t\t\t   || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n-\t\t       && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n-\t\treturn build1 (CONVERT_EXPR, type,\n-\t\t\t       convert (TREE_TYPE (tem), expr));\n-\t    }\n-\n-\t  gcc_unreachable ();\n-\t}\n-      else\n-\t/* Otherwise, this is a conversion between a tagged type and some\n-\t   subtype, which we have to mark as a UNION_TYPE because of\n-\t   overlapping fields.  */\n-\treturn unchecked_convert (type, expr, false);\n+      /* This is a either a conversion between a tagged type and some\n+\t subtype, which we have to mark as a UNION_TYPE because of\n+\t overlapping fields or a conversion of an Unchecked_Union.  */\n+      return unchecked_convert (type, expr, false);\n \n     case UNCONSTRAINED_ARRAY_TYPE:\n       /* If EXPR is a constrained array, take its address, convert it to a"}, {"sha": "4f38e15fdf3e6d07a1926744d8e98fd9e770a8ac", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b47742c2d278f8f8a4b1e02c6e1f786340da38f/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=5b47742c2d278f8f8a4b1e02c6e1f786340da38f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -232,8 +232,12 @@ find_common_type (tree t1, tree t2)\n   else if (TYPE_MODE (t2) != BLKmode)\n     return t2;\n \n-  /* Otherwise, return the type that has a constant size.  */\n-  if (TREE_CONSTANT (TYPE_SIZE (t1)))\n+  /* If both types have constant size, use the smaller one.  */\n+  if (TREE_CONSTANT (TYPE_SIZE (t1)) && TREE_CONSTANT (TYPE_SIZE (t2)))\n+    return tree_int_cst_lt (TYPE_SIZE (t1), TYPE_SIZE (t2)) ? t1 : t2;\n+\n+  /* Otherwise, if either type has a constant size, use it.  */\n+  else if (TREE_CONSTANT (TYPE_SIZE (t1)))\n     return t1;\n   else if (TREE_CONSTANT (TYPE_SIZE (t2)))\n     return t2;\n@@ -1617,7 +1621,8 @@ build_simple_component_ref (tree record_variable, tree component,\n \n       for (new_field = TYPE_FIELDS (record_type); new_field;\n \t   new_field = TREE_CHAIN (new_field))\n-\tif (DECL_ORIGINAL_FIELD (new_field) == field\n+\tif (field == new_field\n+\t    || DECL_ORIGINAL_FIELD (new_field) == field\n \t    || new_field == DECL_ORIGINAL_FIELD (field)\n \t    || (DECL_ORIGINAL_FIELD (field)\n \t\t&& (DECL_ORIGINAL_FIELD (field)"}]}