{"sha": "0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5MGI5ODFjOTA1MWY5Yjk0ZDlhNDgxZGNmNWJmZDBkODBkMjMxMw==", "commit": {"author": {"name": "Andrew Pinski", "email": "andrew_pinski@playstation.sony.com", "date": "2006-12-12T22:33:06Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2006-12-12T22:33:06Z"}, "message": "re PR middle-end/28436 (accessing an element via a \"pointer\"  on a vector does not cause vec_extract to be used)\n\n2006-12-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        PR tree-opt/28436\n        * tree.h (DECL_COMPLEX_GIMPLE_REG_P): Rename to ...\n        (DECL_GIMPLE_REG_P): This.\n        * fold-const.c (fold_indirect_ref_1): Fold *(foo *)&vectorfoo into\n        using BIT_FIELD_REF.\n        * omp-low.c (omp_copy_decl_2): Use the renamed DECL_GIMPLE_REG_P.\n        * tree-gimple.c (is_gimple_reg): Use the renamed DECL_GIMPLE_REG_P\n        and check for VECTOR_TYPE.\n        * expr.c (get_inner_reference): Set the mode for BIT_FIELD_REF with\n        vector types.\n        * tree-flow-inline.h (var_can_have_subvars): Use the renamed\n        DECL_GIMPLE_REG_P.\n        * gimplify.c (internal_get_tmp_var): Use the renamed DECL_GIMPLE_REG_P\n        and check for VECTOR_TYPE.\n        (gimplify_bind_expr): Likewise.\n        (gimplify_function_tree): Likewise.\n        * expmed.c: Include target.h.\n        (extract_bit_field): For vector mode, try find a better mode first.\n        If that fails use gen_lowpart (for vectors only).\n        * tree-dfa.c (make_rename_temp): Use the renamed DECL_GIMPLE_REG_P\n        and check for VECTOR_TYPE.\n        * tree-ssa-pre.c (create_expressions_by_pieces): Likewise.\n        (insert_into_preds_of_block): Likewise.\n        (insert_fake_stores): Create gimple register store_tmps for\n        vector types.\n        * tree-sra.c (sra_elt): New field, is_vector_lhs.\n        (sra_walk_expr <case BIT_FIELD_REF>): For vector types that\n        are the left hand side, set the element's is_vector_lhs to true.\n        (instantiate_element): For vector types which were on the left         hand size, set DECL_GIMPLE_REG_P to false.\n        * tree-nested.c (create_tmp_var_for): Use the renamed DECL_GIMPLE_REG_P.        * tree-inline.c (declare_return_variable):  Use the renamed\n        DECL_GIMPLE_REG_P\n        and check for VECTOR_TYPE.         (copy_decl_to_var):  Use the renamed DECL_GIMPLE_REG_P.\n        (copy_result_decl_to_var): Likewise.\n        * tree-vect-transform.c (vect_get_new_vect_var): For vector types,         create a gimple register variable.\n        (vect_permute_store_chain): Set DECL_GIMPLE_REG_P to true for the\n        vect_inter_* temp variables.\n        * Makefile.in (expmed.o): Update dependencies.\n\n2006-12-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        PR tree-opt/28436\n        * gcc.c-torture/compile/vector-1.c: New test.\n        * gcc.c-torture/compile/vector-2.c: New test.\n        * gcc.c-torture/compile/vector-3.c: New test.\n\nFrom-SVN: r119801", "tree": {"sha": "eb4332185c9fbb34cb4009b24a4353d1811f0e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb4332185c9fbb34cb4009b24a4353d1811f0e0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/comments", "author": null, "committer": null, "parents": [{"sha": "4fbd315165988f3c75ed7734a4920aa95992d23d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fbd315165988f3c75ed7734a4920aa95992d23d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fbd315165988f3c75ed7734a4920aa95992d23d"}], "stats": {"total": 228, "additions": 193, "deletions": 35}, "files": [{"sha": "531a1f90889d7191447bdbfe70731c28e24cb7fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -1,3 +1,46 @@\n+2006-12-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/28436\n+\t* tree.h (DECL_COMPLEX_GIMPLE_REG_P): Rename to ...\n+\t(DECL_GIMPLE_REG_P): This.\n+\t* fold-const.c (fold_indirect_ref_1): Fold *(foo *)&vectorfoo into\n+\tusing BIT_FIELD_REF.\n+\t* omp-low.c (omp_copy_decl_2): Use the renamed DECL_GIMPLE_REG_P.\n+\t* tree-gimple.c (is_gimple_reg): Use the renamed DECL_GIMPLE_REG_P\n+\tand check for VECTOR_TYPE.\n+\t* expr.c (get_inner_reference): Set the mode for BIT_FIELD_REF with\n+\tvector types.\n+\t* tree-flow-inline.h (var_can_have_subvars): Use the renamed\n+\tDECL_GIMPLE_REG_P.\n+\t* gimplify.c (internal_get_tmp_var): Use the renamed DECL_GIMPLE_REG_P\n+\tand check for VECTOR_TYPE.\n+\t(gimplify_bind_expr): Likewise.\n+\t(gimplify_function_tree): Likewise.\n+\t* expmed.c: Include target.h.\n+\t(extract_bit_field): For vector mode, try find a better mode first.\n+\tIf that fails use gen_lowpart (for vectors only).\n+\t* tree-dfa.c (make_rename_temp): Use the renamed DECL_GIMPLE_REG_P\n+\tand check for VECTOR_TYPE.\n+\t* tree-ssa-pre.c (create_expressions_by_pieces): Likewise.\n+\t(insert_into_preds_of_block): Likewise.\n+\t(insert_fake_stores): Create gimple register store_tmps for\n+\tvector types.\n+\t* tree-sra.c (sra_elt): New field, is_vector_lhs.\n+\t(sra_walk_expr <case BIT_FIELD_REF>): For vector types that\n+\tare the left hand side, set the element's is_vector_lhs to true.\n+\t(instantiate_element): For vector types which were on the left\n+\thand size, set DECL_GIMPLE_REG_P to false.\n+\t* tree-nested.c (create_tmp_var_for): Use the renamed DECL_GIMPLE_REG_P.\t* tree-inline.c (declare_return_variable):  Use the renamed\n+\tDECL_GIMPLE_REG_P\n+\tand check for VECTOR_TYPE.\n+\t(copy_decl_to_var):  Use the renamed DECL_GIMPLE_REG_P.\n+\t(copy_result_decl_to_var): Likewise.\n+\t* tree-vect-transform.c (vect_get_new_vect_var): For vector types,\n+\tcreate a gimple register variable.\n+\t(vect_permute_store_chain): Set DECL_GIMPLE_REG_P to true for the\n+\tvect_inter_* temp variables.\n+\t* Makefile.in (expmed.o): Update dependencies.\n+\n 2006-12-12  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and"}, {"sha": "ab4f5b81d46999d75a4c1bcff87ad56019a95765", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -2230,7 +2230,7 @@ calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(CGRAPH_H) except.h sbitmap.h\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(REAL_H) \\\n-   toplev.h $(TM_P_H) langhooks.h\n+   toplev.h $(TM_P_H) langhooks.h $(TARGET_H)\n explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n    toplev.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \\"}, {"sha": "29440d1a5db224f3238b1d4acd6dc4d3715cbca4", "filename": "gcc/expmed.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"real.h\"\n #include \"recog.h\"\n #include \"langhooks.h\"\n+#include \"target.h\"\n \n static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n@@ -1126,6 +1127,28 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return op0;\n     }\n \n+  /* See if we can get a better vector mode before extracting.  */\n+  if (VECTOR_MODE_P (GET_MODE (op0))\n+      && !MEM_P (op0)\n+      && GET_MODE_INNER (GET_MODE (op0)) != tmode)\n+    {\n+      enum machine_mode new_mode;\n+      int nunits = GET_MODE_NUNITS (GET_MODE (op0));\n+\n+      if (GET_MODE_CLASS (tmode) == MODE_FLOAT)\n+\tnew_mode = MIN_MODE_VECTOR_FLOAT;\n+      else\n+\tnew_mode = MIN_MODE_VECTOR_INT;\n+\n+      for (; new_mode != VOIDmode ; new_mode = GET_MODE_WIDER_MODE (new_mode))\n+\tif (GET_MODE_NUNITS (new_mode) == nunits\n+\t    && GET_MODE_INNER (new_mode) == tmode\n+\t    && targetm.vector_mode_supported_p (new_mode))\n+\t  break;\n+      if (new_mode != VOIDmode)\n+\top0 = gen_lowpart (new_mode, op0);\n+    }\n+\n   /* Use vec_extract patterns for extracting parts of vectors whenever\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n@@ -1176,6 +1199,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  emit_insn (seq);\n \t  emit_insn (pat);\n+      \t  if (mode0 != mode)\n+\t    return gen_lowpart (tmode, dest);\n \t  return dest;\n \t}\n     }"}, {"sha": "943a4c44caa4040e7a215ec065184cd6ae31419e", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -5671,6 +5671,13 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n     {\n       size_tree = TREE_OPERAND (exp, 1);\n       *punsignedp = BIT_FIELD_REF_UNSIGNED (exp);\n+      \n+      /* For vector types, with the correct size of access, use the mode of\n+\t inner type.  */\n+      if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == VECTOR_TYPE\n+\t  && TREE_TYPE (exp) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t  && tree_int_cst_equal (size_tree, TYPE_SIZE (TREE_TYPE (exp))))\n+        mode = TYPE_MODE (TREE_TYPE (exp));\n     }\n   else\n     {"}, {"sha": "da1bfed173e820fbc1c1c09cbab992b8d9bf1888", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -13094,6 +13094,14 @@ fold_indirect_ref_1 (tree type, tree op0)\n       else if (TREE_CODE (optype) == COMPLEX_TYPE\n \t       && type == TREE_TYPE (optype))\n \treturn fold_build1 (REALPART_EXPR, type, op);\n+      /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n+      else if (TREE_CODE (optype) == VECTOR_TYPE\n+\t       && type == TREE_TYPE (optype))\n+\t{\n+\t  tree part_width = TYPE_SIZE (type);\n+\t  tree index = bitsize_int (0);\n+\t  return fold_build3 (BIT_FIELD_REF, type, op, part_width, index);\n+\t}\n     }\n \n   /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */"}, {"sha": "97745309e98f6d6db61ec9e2b4e7d7ec4e44fa44", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -606,8 +606,9 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n \t}\n     }\n \n-  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n-    DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (t) = 1;\n \n   mod = build2 (INIT_EXPR, TREE_TYPE (t), t, unshare_expr (val));\n \n@@ -1078,11 +1079,12 @@ gimplify_bind_expr (tree *expr_p, tree *pre_p)\n       /* Preliminarily mark non-addressed complex variables as eligible\n \t for promotion to gimple registers.  We'll transform their uses\n \t as we find them.  */\n-      if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      if ((TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+\t   || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n \t  && !TREE_THIS_VOLATILE (t)\n \t  && (TREE_CODE (t) == VAR_DECL && !DECL_HARD_REGISTER (t))\n \t  && !needs_to_live_in_memory (t))\n-\tDECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n+\tDECL_GIMPLE_REG_P (t) = 1;\n     }\n \n   gimple_push_bind_expr (bind_expr);\n@@ -3460,7 +3462,7 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \n /* Promote partial stores to COMPLEX variables to total stores.  *EXPR_P is\n    a MODIFY_EXPR with a lhs of a REAL/IMAGPART_EXPR of a variable with\n-   DECL_COMPLEX_GIMPLE_REG_P set.  */\n+   DECL_GIMPLE_REG_P set.  */\n \n static enum gimplify_status\n gimplify_modify_expr_complex_part (tree *expr_p, tree *pre_p, bool want_value)\n@@ -6372,16 +6374,18 @@ gimplify_function_tree (tree fndecl)\n       /* Preliminarily mark non-addressed complex variables as eligible\n          for promotion to gimple registers.  We'll transform their uses\n          as we find them.  */\n-      if (TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n+      if ((TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE\n+\t   || TREE_CODE (TREE_TYPE (parm)) == VECTOR_TYPE)\n           && !TREE_THIS_VOLATILE (parm)\n           && !needs_to_live_in_memory (parm))\n-        DECL_COMPLEX_GIMPLE_REG_P (parm) = 1;\n+        DECL_GIMPLE_REG_P (parm) = 1;\n     }\n \n   ret = DECL_RESULT (fndecl);\n-  if (TREE_CODE (TREE_TYPE (ret)) == COMPLEX_TYPE\n+  if ((TREE_CODE (TREE_TYPE (ret)) == COMPLEX_TYPE\n+\t   || TREE_CODE (TREE_TYPE (ret)) == VECTOR_TYPE)\n       && !needs_to_live_in_memory (ret))\n-    DECL_COMPLEX_GIMPLE_REG_P (ret) = 1;\n+    DECL_GIMPLE_REG_P (ret) = 1;\n \n   gimplify_body (&DECL_SAVED_TREE (fndecl), fndecl, true);\n "}, {"sha": "ca6aa3afc9274cd06d8977a77a937975614d97c8", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -514,7 +514,7 @@ omp_copy_decl_2 (tree var, tree name, tree type, omp_context *ctx)\n   tree copy = build_decl (VAR_DECL, name, type);\n \n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n-  DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (var);\n+  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n   TREE_USED (copy) = 1;"}, {"sha": "743412569178af8f3d121c4c4234b1b3a34bb3f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -1,3 +1,10 @@\n+2006-12-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/28436\n+\t* gcc.c-torture/compile/vector-1.c: New test.\n+\t* gcc.c-torture/compile/vector-2.c: New test.\n+\t* gcc.c-torture/compile/vector-3.c: New test.\n+\n 2006-12-12  Tobias Schl\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* lib/fortran-torture.exp: Update copyright years.  Remove"}, {"sha": "d22afd55df5593a485902aa8b2277a85c428e69b", "filename": "gcc/testsuite/gcc.c-torture/compile/vector-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-1.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -0,0 +1,11 @@\n+#define vector __attribute__((vector_size(16) ))\n+struct ss\n+{\n+ vector float mVec;\n+};\n+float getCapsule(vector int t)\n+{\n+ vector float t1 = (vector float)t;\n+ struct ss y = {t1};\n+ return *((float*)&y.mVec);\n+}"}, {"sha": "930a9c1f8707e5ad3a8abd52c7e6e67c0c3dcb3f", "filename": "gcc/testsuite/gcc.c-torture/compile/vector-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-2.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -0,0 +1,12 @@\n+#define vector __attribute__((vector_size(16) ))\n+struct ss\n+{\n+ vector float mVec;\n+};\n+vector float getCapsule(vector int t)\n+{\n+ vector float t1 = (vector float)t;\n+ struct ss y = {t1};\n+ *((float*)&y.mVec) = 1.0;\n+ return y.mVec;\n+}"}, {"sha": "6b731488163109fff6f6a351daebf6f77314b32b", "filename": "gcc/testsuite/gcc.c-torture/compile/vector-3.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fvector-3.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -0,0 +1,7 @@\n+#define vector __attribute__((vector_size(16) ))\n+vector float g(void)\n+{\n+  float t = 1.0f;\n+  return (vector float){0.0, 0.0, t, 0.0};\n+}\n+"}, {"sha": "0aabc80b7a7b9ea5a0524e85ca5f1421919cd861", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -206,8 +206,9 @@ make_rename_temp (tree type, const char *prefix)\n {\n   tree t = create_tmp_var (type, prefix);\n \n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    DECL_COMPLEX_GIMPLE_REG_P (t) = 1;\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (t) = 1;\n \n   if (gimple_referenced_vars (cfun))\n     {"}, {"sha": "e2b4f9791405cc2085c431999c5a25560aa6a149", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -1681,7 +1681,7 @@ var_can_have_subvars (tree v)\n   /* Complex types variables which are not also a gimple register can\n     have subvars. */\n   if (TREE_CODE (TREE_TYPE (v)) == COMPLEX_TYPE\n-      && !DECL_COMPLEX_GIMPLE_REG_P (v))\n+      && !DECL_GIMPLE_REG_P (v))\n     return true;\n \n   return false;"}, {"sha": "f3a5db7c2ed6ee295aacd94d88bec61614aa6e62", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -316,8 +316,9 @@ is_gimple_reg (tree t)\n \n   /* Complex values must have been put into ssa form.  That is, no \n      assignments to the individual components.  */\n-  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n-    return DECL_COMPLEX_GIMPLE_REG_P (t);\n+  if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (t)) == VECTOR_TYPE)\n+    return DECL_GIMPLE_REG_P (t);\n \n   return true;\n }"}, {"sha": "86485e576e543ddb3c8e7fc4b805754bbf801cf9", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -1204,10 +1204,11 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n \tvar = return_slot_addr;\n       else\n \tvar = build_fold_indirect_ref (return_slot_addr);\n-      if (TREE_CODE (TREE_TYPE (result)) == COMPLEX_TYPE\n-\t  && !DECL_COMPLEX_GIMPLE_REG_P (result)\n+      if ((TREE_CODE (TREE_TYPE (result)) == COMPLEX_TYPE\n+           || TREE_CODE (TREE_TYPE (result)) == VECTOR_TYPE)\n+\t  && !DECL_GIMPLE_REG_P (result)\n \t  && DECL_P (var))\n-\tDECL_COMPLEX_GIMPLE_REG_P (var) = 0;\n+\tDECL_GIMPLE_REG_P (var) = 0;\n       use = NULL;\n       goto done;\n     }\n@@ -1245,9 +1246,10 @@ declare_return_variable (copy_body_data *id, tree return_slot_addr,\n \t    use_it = false;\n \t  else if (is_global_var (base_m))\n \t    use_it = false;\n-\t  else if (TREE_CODE (TREE_TYPE (result)) == COMPLEX_TYPE\n-\t\t   && !DECL_COMPLEX_GIMPLE_REG_P (result)\n-\t\t   && DECL_COMPLEX_GIMPLE_REG_P (base_m))\n+\t  else if ((TREE_CODE (TREE_TYPE (result)) == COMPLEX_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (result)) == VECTOR_TYPE)\n+\t\t   && !DECL_GIMPLE_REG_P (result)\n+\t\t   && DECL_GIMPLE_REG_P (base_m))\n \t    use_it = false;\n \t  else if (!TREE_ADDRESSABLE (base_m))\n \t    use_it = true;\n@@ -2648,7 +2650,7 @@ copy_decl_to_var (tree decl, copy_body_data *id)\n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n-  DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n+  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n \n   return copy_decl_for_dup_finish (id, decl, copy);\n }\n@@ -2674,7 +2676,7 @@ copy_result_decl_to_var (tree decl, copy_body_data *id)\n   if (!DECL_BY_REFERENCE (decl))\n     {\n       TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n-      DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n+      DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (decl);\n     }\n \n   return copy_decl_for_dup_finish (id, decl, copy);"}, {"sha": "42aef32884193b47f76fd803f6e192a189b67afc", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -149,7 +149,7 @@ create_tmp_var_for (struct nesting_info *info, tree type, const char *prefix)\n   TREE_CHAIN (tmp_var) = info->new_local_var_chain;\n   DECL_SEEN_IN_BIND_EXPR_P (tmp_var) = 1;\n   if (TREE_CODE (type) == COMPLEX_TYPE)\n-    DECL_COMPLEX_GIMPLE_REG_P (tmp_var) = 1;\n+    DECL_GIMPLE_REG_P (tmp_var) = 1;\n \n   info->new_local_var_chain = tmp_var;\n "}, {"sha": "da338fc28fd8ea34d7e9a09379d14e1b9cd48f04", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -140,6 +140,9 @@ struct sra_elt\n \n   /* A flag for use with/after random access traversals.  */\n   bool visited;\n+\n+  /* True if there is BIT_FIELD_REF on the lhs with a vector. */\n+  bool is_vector_lhs;\n };\n \n #define IS_ELEMENT_FOR_GROUP(ELEMENT) (TREE_CODE (ELEMENT) == RANGE_EXPR)\n@@ -787,9 +790,18 @@ sra_walk_expr (tree *expr_p, block_stmt_iterator *bsi, bool is_output,\n \tbreak;\n \n       case BIT_FIELD_REF:\n+\t/* A bit field reference to a specific vector is scalarized but for\n+\t   ones for inputs need to be marked as used on the left hand size so\n+\t   when we scalarize it, we can mark that variable as non renamable.  */\n+\tif (is_output && TREE_CODE (TREE_TYPE (TREE_OPERAND (inner, 0))) == VECTOR_TYPE)\n+\t  {\n+\t    struct sra_elt *elt = maybe_lookup_element_for_expr (TREE_OPERAND (inner, 0));\n+\t    elt->is_vector_lhs = true;\n+\t  }\n \t/* A bit field reference (access to *multiple* fields simultaneously)\n \t   is not currently scalarized.  Consider this an access to the\n \t   complete outer element, to which walk_tree will bring us next.  */\n+\t  \n \tgoto use_all;\n \n       case VIEW_CONVERT_EXPR:\n@@ -1178,6 +1190,12 @@ instantiate_element (struct sra_elt *elt)\n   base = base_elt->element;\n \n   elt->replacement = var = make_rename_temp (elt->type, \"SR\");\n+\n+  /* For vectors, if used on the left hand side with BIT_FIELD_REF,\n+     they are not a gimple register.  */\n+  if (TREE_CODE (TREE_TYPE (var)) == VECTOR_TYPE && elt->is_vector_lhs)\n+    DECL_GIMPLE_REG_P (var) = 0;\n+\n   DECL_SOURCE_LOCATION (var) = DECL_SOURCE_LOCATION (base);\n   DECL_ARTIFICIAL (var) = 1;\n "}, {"sha": "871006dc232aea1113e3d38f42ef80c75601e053", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -2630,8 +2630,9 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   temp = pretemp;\n   add_referenced_var (temp);\n \n-  if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n-    DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n+  if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE\n+      || TREE_CODE (TREE_TYPE (expr)) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (temp) = 1;\n \n   newexpr = build2_gimple (GIMPLE_MODIFY_STMT, temp, newexpr);\n   name = make_ssa_name (temp, newexpr);\n@@ -2778,8 +2779,10 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   temp = prephitemp;\n   add_referenced_var (temp);\n \n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    DECL_COMPLEX_GIMPLE_REG_P (temp) = 1;\n+\n+  if (TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (temp) = 1;\n   temp = create_phi_node (temp, block);\n \n   NECESSARY (temp) = 0;\n@@ -3535,6 +3538,8 @@ insert_fake_stores (void)\n \t      if (!storetemp || TREE_TYPE (rhs) != TREE_TYPE (storetemp))\n \t\t{\n \t\t  storetemp = create_tmp_var (TREE_TYPE (rhs), \"storetmp\");\n+\t\t  if (TREE_CODE (TREE_TYPE (storetemp)) == VECTOR_TYPE)\n+\t\t    DECL_GIMPLE_REG_P (storetemp) = 1;\n \t\t  get_var_ann (storetemp);\n \t\t}\n "}, {"sha": "401e35871827509f4221358e62b3410a7f10a011", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -106,6 +106,10 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n   else\n     new_vect_var = create_tmp_var (type, prefix);\n \n+  /* Mark vector typed variable as a gimple register variable.  */\n+  if (TREE_CODE (type) == VECTOR_TYPE)\n+    DECL_GIMPLE_REG_P (new_vect_var) = true;\n+\n   return new_vect_var;\n }\n \n@@ -2598,6 +2602,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n              and in the case of little endian: \n                                 high = interleave_low (vect1, vect2).  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n+\t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n           if (BYTES_BIG_ENDIAN)\n \t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,\n@@ -2618,6 +2623,7 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n              and in the case of little endian:\n                                low  = interleave_high (vect1, vect2).  */     \n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n+\t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n \t  if (BYTES_BIG_ENDIAN)\n \t    perm_stmt = build2 (GIMPLE_MODIFY_STMT, void_type_node, perm_dest,"}, {"sha": "f88c244146f73dab6586b4f731e16a891556514e", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0890b981c9051f9b94d9a481dcf5bfd0d80d2313/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0890b981c9051f9b94d9a481dcf5bfd0d80d2313", "patch": "@@ -2598,12 +2598,13 @@ struct tree_memory_partition_tag GTY(())\n #define DECL_PRESERVE_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.preserve_flag\n \n-/* For function local variables of COMPLEX type, indicates that the\n-   variable is not aliased, and that all modifications to the variable\n-   have been adjusted so that they are killing assignments.  Thus the\n-   variable may now be treated as a GIMPLE register, and use real\n-   instead of virtual ops in SSA form.  */\n-#define DECL_COMPLEX_GIMPLE_REG_P(DECL) \\\n+/* For function local variables of COMPLEX and VECTOR types,\n+   indicates that the variable is not aliased, and that all\n+   modifications to the variable have been adjusted so that\n+   they are killing assignments.  Thus the variable may now\n+   be treated as a GIMPLE register, and use real instead of\n+   virtual ops in SSA form.  */\n+#define DECL_GIMPLE_REG_P(DECL) \\\n   DECL_COMMON_CHECK (DECL)->decl_common.gimple_reg_flag\n \n /* This is true if DECL is call clobbered in the current function."}]}