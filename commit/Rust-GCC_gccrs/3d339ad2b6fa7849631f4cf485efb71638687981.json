{"sha": "3d339ad2b6fa7849631f4cf485efb71638687981", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzMzlhZDJiNmZhNzg0OTYzMWY0Y2Y0ODVlZmI3MTYzODY4Nzk4MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-18T06:27:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-18T06:27:04Z"}, "message": "Initial revision\n\nFrom-SVN: r338", "tree": {"sha": "7745ff7ab5b5831846e6fecb866211867ce3b142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7745ff7ab5b5831846e6fecb866211867ce3b142"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d339ad2b6fa7849631f4cf485efb71638687981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d339ad2b6fa7849631f4cf485efb71638687981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d339ad2b6fa7849631f4cf485efb71638687981", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d339ad2b6fa7849631f4cf485efb71638687981/comments", "author": null, "committer": null, "parents": [{"sha": "1c0751d9b8647d2d3b3bee252e65d1bf0c16bc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c0751d9b8647d2d3b3bee252e65d1bf0c16bc36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c0751d9b8647d2d3b3bee252e65d1bf0c16bc36"}], "stats": {"total": 1726, "additions": 1726, "deletions": 0}, "files": [{"sha": "2fea1a12357cfc0ca2cce6fc3351cebc3c9429a8", "filename": "gcc/config/m68k/m68k.h", "status": "added", "additions": 1726, "deletions": 0, "changes": 1726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d339ad2b6fa7849631f4cf485efb71638687981/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d339ad2b6fa7849631f4cf485efb71638687981/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=3d339ad2b6fa7849631f4cf485efb71638687981", "patch": "@@ -0,0 +1,1726 @@\n+/* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+/* See sun3.h, sun2.h, isi.h for different CPP_PREDEFINES.  */\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#ifdef MOTOROLA\n+#define TARGET_VERSION fprintf (stderr, \" (68k, Motorola syntax)\");\n+#else\n+#define TARGET_VERSION fprintf (stderr, \" (68k, MIT syntax)\");\n+#endif\n+\n+/* Define SUPPORT_SUN_FPA to include support for generating code for\n+   the Sun Floating Point Accelerator, an optional product for Sun 3\n+   machines.  By default, it is not defined.  Avoid defining it unless\n+   you need to output code for the Sun3+FPA architecture, as it has the\n+   effect of slowing down the register set operations in hard-reg-set.h\n+   (total number of registers will exceed number of bits in a long,\n+   if defined, causing the set operations to expand to loops).\n+   SUPPORT_SUN_FPA is typically defined in sun3.h.  */\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Compile for a 68020 (not a 68000 or 68010).  */\n+#define TARGET_68020 (target_flags & 1)\n+\n+/* Compile 68881 insns for floating point (not library calls).  */\n+#define TARGET_68881 (target_flags & 2)\n+\n+/* Compile using 68020 bitfield insns.  */\n+#define TARGET_BITFIELD (target_flags & 4)\n+\n+/* Compile using rtd insn calling sequence.\n+   This will not work unless you use prototypes at least\n+   for all functions that can take varying numbers of args.  */\n+#define TARGET_RTD (target_flags & 8)\n+\n+/* Compile passing first two args in regs 0 and 1.\n+   This exists only to test compiler features that will\n+   be needed for RISC chips.  It is not usable\n+   and is not intended to be usable on this cpu.  */\n+#define TARGET_REGPARM (target_flags & 020)\n+\n+/* Compile with 16-bit `int'.  */\n+#define TARGET_SHORT (target_flags & 040)\n+\n+/* Compile with special insns for Sun FPA.  */\n+#ifdef SUPPORT_SUN_FPA\n+#define TARGET_FPA (target_flags & 0100)\n+#else\n+#define TARGET_FPA 0\n+#endif\n+\n+/* Compile (actually, link) for Sun SKY board.  */\n+#define TARGET_SKY (target_flags & 0200)\n+\n+/* Optimize for 68040.\n+   The 68040 will execute all 68030 and 68881/2 instrcutions, but some\n+   of them must be emulated in software by the OS.  When TARGET_68040 is\n+   turned on, these instructions won't be used.  This code will still\n+   run on a 68030 and 68881/2. */\n+#define TARGET_68040 (target_flags & 0400)\n+\n+/* Support 68040 fp instructions.  */\n+#define TARGET_68040_ONLY (target_flags & 01000)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"68020\", 5},\t\t\t\t\\\n+    { \"c68020\", 5},\t\t\t\t\\\n+    { \"68881\", 2},\t\t\t\t\\\n+    { \"bitfield\", 4},\t\t\t\t\\\n+    { \"68000\", -5},\t\t\t\t\\\n+    { \"c68000\", -5},\t\t\t\t\\\n+    { \"soft-float\", -0102},\t\t\t\\\n+    { \"nobitfield\", -4},\t\t\t\\\n+    { \"rtd\", 8},\t\t\t\t\\\n+    { \"nortd\", -8},\t\t\t\t\\\n+    { \"short\", 040},\t\t\t\t\\\n+    { \"noshort\", -040},\t\t\t\t\\\n+    { \"fpa\", 0100},\t\t\t\t\\\n+    { \"nofpa\", -0100},\t\t\t\t\\\n+    { \"sky\", 0200},\t\t\t\t\\\n+    { \"nosky\", -0200},\t\t\t\t\\\n+    { \"68040\", 0407},\t\t\t\t\\\n+    { \"68030\", -01400},\t\t\t\t\\\n+    { \"68030\", 7},\t\t\t\t\\\n+    { \"68040-only\", 01000},\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+/* TARGET_DEFAULT is defined in sun*.h and isi.h, etc.  */\n+\n+#ifdef SUPPORT_SUN_FPA\n+/* Blow away 68881 flag silently on TARGET_FPA (since we can't clear\n+   any bits in TARGET_SWITCHES above) */\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (TARGET_FPA) target_flags &= ~2;\t\\\n+  if (! TARGET_68020 && flag_pic == 2)\t\\\n+    error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\t\\\n+}\n+#else\n+#define OVERRIDE_OPTIONS\t\t\\\n+{\t\t\t\t\t\\\n+  if (! TARGET_68020 && flag_pic == 2)\t\\\n+    error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\t\\\n+}\n+#endif /* defined SUPPORT_SUN_FPA */\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is true for 68020 insns such as bfins and bfexts.\n+   We make it true always by avoiding using the single-bit insns\n+   except in special cases with constant bit numbers.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the 68000.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* For 68000 we can decide arbitrarily\n+   since there are no machine instructions for them.\n+   So let's be consistent.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY (TARGET_SHORT ? 16 : 32)\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 16\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 16\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 16\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\n+#define SELECT_RTX_SECTION(MODE, X)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!flag_pic)\t\t\t\t\t\t\t\\\n+    readonly_data_section();\t\t\t\t\t\t\\\n+  else if (LEGITIMATE_PIC_OPERAND_P (X))\t\t\t\t\\\n+    readonly_data_section();\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    data_section();\t\t\t\t\t\t\t\\\n+}\n+\n+/* Define number of bits in most basic integer type.\n+   (If undefined, default is BITS_PER_WORD).  */\n+\n+#define INT_TYPE_SIZE (TARGET_SHORT ? 16 : 32)\n+\n+/* Define these to avoid dependence on meaning of `int'.\n+   Note that WCHAR_TYPE_SIZE is used in cexp.y,\n+   where TARGET_SHORT is not available.  */\n+\n+#define WCHAR_TYPE \"long int\"\n+#define WCHAR_TYPE_SIZE 32\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+   For the 68000, we give the data registers numbers 0-7,\n+   the address registers numbers 010-017,\n+   and the 68881 floating point registers numbers 020-027.  */\n+#ifndef SUPPORT_SUN_FPA\n+#define FIRST_PSEUDO_REGISTER 24\n+#else\n+#define FIRST_PSEUDO_REGISTER 56\n+#endif\n+\n+/* This defines the register which is used to hold the offset table for PIC. */\n+#define PIC_OFFSET_TABLE_REGNUM 13\n+\n+/* Used to output a (use pic_offset_table_rtx) so that we \n+   always save/restore a5 in functions that use PIC relocation\n+   at *any* time during the compilation process. */\n+#define FINALIZE_PIC finalize_pic()\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the 68000, only the stack pointer is such.  */\n+\n+#define FIXED_REGISTERS        \\\n+ {/* Data registers.  */       \\\n+  0, 0, 0, 0, 0, 0, 0, 0,      \\\n+                               \\\n+  /* Address registers.  */    \\\n+  0, 0, 0, 0, 0, 0, 0, 1,      \\\n+                               \\\n+  /* Floating point registers  \\\n+     (if available).  */       \\\n+  0, 0, 0, 0, 0, 0, 0, 0 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 0, 0, 0, 0, 0, 0,   \\\n+  1, 1, 0, 0, 0, 0, 0, 1,   \\\n+  1, 1, 0, 0, 0, 0, 0, 0 }\n+\n+#else /* SUPPORT_SUN_FPA */\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the 68000, only the stack pointer is such.  */\n+\n+/* fpa0 is also reserved so that it can be used to move shit back and\n+   forth between high fpa regs and everything else. */\n+\n+#define FIXED_REGISTERS        \\\n+ {/* Data registers.  */       \\\n+  0, 0, 0, 0, 0, 0, 0, 0,      \\\n+                               \\\n+  /* Address registers.  */    \\\n+  0, 0, 0, 0, 0, 0, 0, 1,      \\\n+                               \\\n+  /* Floating point registers  \\\n+     (if available).  */       \\\n+  0, 0, 0, 0, 0, 0, 0, 0,      \\\n+                               \\\n+  /* Sun3 FPA registers.  */   \\\n+  1, 0, 0, 0, 0, 0, 0, 0,      \\\n+  0, 0, 0, 0, 0, 0, 0, 0,      \\\n+  0, 0, 0, 0, 0, 0, 0, 0,      \\\n+  0, 0, 0, 0, 0, 0, 0, 0 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+ {1, 1, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 0, 0, 0, 0, 0, 1, \\\n+  1, 1, 0, 0, 0, 0, 0, 0, \\\n+  /* FPA registers.  */   \\\n+  1, 1, 1, 1, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0  }\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+\n+/* Make sure everything's fine if we *don't* have a given processor.\n+   This assumes that putting a register in fixed_regs will keep the\n+   compiler's mitts completely off it.  We don't bother to zero it out\n+   of register classes.  If neither TARGET_FPA or TARGET_68881 is set,\n+   the compiler won't touch since no instructions that use these\n+   registers will be valid.  \n+\n+   Reserve PIC_OFFSET_TABLE_REGNUM (a5) for doing PIC relocation if\n+   position independent code is being generated by making it a \n+   fixed register */\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{                                               \\\n+  if (flag_pic)                                 \\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;    \\\n+}\n+\n+#else /* defined SUPPORT_SUN_FPA */\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{ \t\t\t\t\t\t\\\n+  int i; \t\t\t\t\t\\\n+  HARD_REG_SET x; \t\t\t\t\\\n+  if (!TARGET_FPA)\t\t\t\t\\\n+    { \t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FPA_REGS]); \\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    } \t\t\t\t\t\t\\\n+  if (TARGET_FPA)\t\t\t\t\\\n+    { \t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    } \t\t\t\t\t\t\\\n+  if (flag_pic)                                 \\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;    \\\n+}\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the 68000, ordinary registers hold 32 bits worth;\n+   for the 68881 registers, a single register is always enough for\n+   anything that can be stored in them at all.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((REGNO) >= 16 ? GET_MODE_NUNITS (MODE)\t\\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the 68000, the cpu registers can hold any mode but the 68881 registers\n+   can hold only SFmode or DFmode.  The 68881 registers can't hold anything\n+   if 68881 use is disabled.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  (((REGNO) < 16)                                       \\\n+   || ((REGNO) < 24\t\t\t\t        \\\n+       && TARGET_68881                                  \\\n+       && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+\t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)))\n+\n+#else /* defined SUPPORT_SUN_FPA */\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the 68000, the cpu registers can hold any mode but the 68881 registers\n+   can hold only SFmode or DFmode.  And the 68881 registers can't hold anything\n+   if 68881 use is disabled.  However, the Sun FPA register can\n+   (apparently) hold whatever you feel like putting in them.\n+   If using the fpa, don't put a double in d7/a0.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+(((REGNO) < 16\t\t\t\t\t\t\t\t\\\n+  && !(TARGET_FPA\t\t\t\t\t\t\t\\\n+       && GET_MODE_CLASS ((MODE)) != MODE_INT\t\t\t\t\\\n+       && GET_MODE_UNIT_SIZE ((MODE)) > 4\t\t\t\t\\\n+       && (REGNO) < 8 && (REGNO) + GET_MODE_SIZE ((MODE)) / 4 > 8\t\\\n+       && (REGNO) % (GET_MODE_UNIT_SIZE ((MODE)) / 4) != 0))\t\t\\\n+ || ((REGNO) < 24\t\t\t\t\t\t\t\\\n+     ? TARGET_68881 && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+\t\t\t|| GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n+     : ((REGNO) < 56 ? TARGET_FPA : 0)))\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n+  (! TARGET_68881\t\t\t\t\t\\\n+   || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+\t|| GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n+       == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n+\t   || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT)))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* m68000 pc isn't overloaded on a register.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 14\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 8\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 9\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The 68000 has three kinds of registers, so eight classes would be\n+   a complete set.  One of them is not needed.  */\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+enum reg_class {\n+  NO_REGS, DATA_REGS,\n+  ADDR_REGS, FP_REGS,\n+  GENERAL_REGS, DATA_OR_FP_REGS,\n+  ADDR_OR_FP_REGS, ALL_REGS,\n+  LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ { \"NO_REGS\", \"DATA_REGS\",              \\\n+   \"ADDR_REGS\", \"FP_REGS\",              \\\n+   \"GENERAL_REGS\", \"DATA_OR_FP_REGS\",   \\\n+   \"ADDR_OR_FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t\t\\\n+ 0x00000000,   \t/* NO_REGS */\t\t\\\n+ 0x000000ff,\t/* DATA_REGS */\t\t\\\n+ 0x0000ff00,\t/* ADDR_REGS */\t\t\\\n+ 0x00ff0000,\t/* FP_REGS */\t\t\\\n+ 0x0000ffff,\t/* GENERAL_REGS */\t\\\n+ 0x00ff00ff,\t/* DATA_OR_FP_REGS */\t\\\n+ 0x00ffff00,    /* ADDR_OR_FP_REGS */   \\\n+ 0x00ffffff,\t/* ALL_REGS */\t\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) (((REGNO)>>3)+1)\n+\n+#else /* defined SUPPORT_SUN_FPA */\n+\n+/*\n+ * Notes on final choices:\n+ *\n+ *   1) Didn't feel any need to union-ize LOW_FPA_REGS with anything\n+ * else.\n+ *   2) Removed all unions that involve address registers with\n+ * floating point registers (left in unions of address and data with\n+ * floating point).\n+ *   3) Defined GENERAL_REGS as ADDR_OR_DATA_REGS.\n+ *   4) Defined ALL_REGS as FPA_OR_FP_OR_GENERAL_REGS.\n+ *   4) Left in everything else.\n+ */\n+enum reg_class { NO_REGS, LO_FPA_REGS, FPA_REGS, FP_REGS,\n+  FP_OR_FPA_REGS, DATA_REGS, DATA_OR_FPA_REGS, DATA_OR_FP_REGS,\n+  DATA_OR_FP_OR_FPA_REGS, ADDR_REGS, GENERAL_REGS,\n+  GENERAL_OR_FPA_REGS, GENERAL_OR_FP_REGS, ALL_REGS,\n+  LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ { \"NO_REGS\", \"LO_FPA_REGS\", \"FPA_REGS\", \"FP_REGS\",  \\\n+   \"FP_OR_FPA_REGS\", \"DATA_REGS\", \"DATA_OR_FPA_REGS\", \"DATA_OR_FP_REGS\",  \\\n+   \"DATA_OR_FP_OR_FPA_REGS\", \"ADDR_REGS\", \"GENERAL_REGS\",  \\\n+   \"GENERAL_OR_FPA_REGS\", \"GENERAL_OR_FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t\t\t\t\\\n+ {0, 0},\t\t\t/* NO_REGS */\t\t\\\n+ {0xff000000, 0x000000ff},\t/* LO_FPA_REGS */\t\\\n+ {0xff000000, 0x00ffffff},\t/* FPA_REGS */\t\t\\\n+ {0x00ff0000, 0x00000000},\t/* FP_REGS */\t\t\\\n+ {0xffff0000, 0x00ffffff},\t/* FP_OR_FPA_REGS */\t\\\n+ {0x000000ff, 0x00000000},\t/* DATA_REGS */\t\t\\\n+ {0xff0000ff, 0x00ffffff},\t/* DATA_OR_FPA_REGS */\t\\\n+ {0x00ff00ff, 0x00000000},\t/* DATA_OR_FP_REGS */\t\\\n+ {0xffff00ff, 0x00ffffff},\t/* DATA_OR_FP_OR_FPA_REGS */\\\n+ {0x0000ff00, 0x00000000},\t/* ADDR_REGS */\t\t\\\n+ {0x0000ffff, 0x00000000},\t/* GENERAL_REGS */\t\\\n+ {0xff00ffff, 0x00ffffff},\t/* GENERAL_OR_FPA_REGS */\\\n+ {0x00ffffff, 0x00000000},\t/* GENERAL_OR_FP_REGS */\\\n+ {0xffffffff, 0x00ffffff},\t/* ALL_REGS */\t\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+extern enum reg_class regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)>>3])\n+\n+#endif /* SUPPORT_SUN_FPA */\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS ADDR_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.\n+   We do a trick here to modify the effective constraints on the\n+   machine description; we zorch the constraint letters that aren't\n+   appropriate for a specific target.  This allows us to guarantee\n+   that a specific kind of register will not be used for a given target\n+   without fiddling with the register classes above. */\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n+   ((C) == 'd' ? DATA_REGS :\t\t\t\\\n+    ((C) == 'f' ? (TARGET_68881 ? FP_REGS :\t\\\n+\t\t   NO_REGS) :\t\t\t\\\n+     NO_REGS)))\n+\n+#else /* defined SUPPORT_SUN_FPA */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n+   ((C) == 'd' ? DATA_REGS :\t\t\t\\\n+    ((C) == 'f' ? (TARGET_68881 ? FP_REGS :\t\\\n+\t\t   NO_REGS) :\t\t\t\\\n+     ((C) == 'x' ? (TARGET_FPA ? FPA_REGS :\t\\\n+\t\t    NO_REGS) :\t\t\t\\\n+      ((C) == 'y' ? (TARGET_FPA ? LO_FPA_REGS :\t\\\n+\t\t     NO_REGS) :\t\t\t\\\n+       NO_REGS)))))\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the 68000, `I' is used for the range 1 to 8\n+   allowed as immediate shift counts and in addq.\n+   `J' is used for the range of signed numbers that fit in 16 bits.\n+   `K' is for numbers that moveq can't handle.\n+   `L' is for range -8 to -1, range of values that can be added with subq.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? (VALUE) > 0 && (VALUE) <= 8 :    \\\n+   (C) == 'J' ? (VALUE) >= -0x8000 && (VALUE) <= 0x7FFF :\t\\\n+   (C) == 'K' ? (VALUE) < -0x80 || (VALUE) >= 0x80 :\t\\\n+   (C) == 'L' ? (VALUE) < 0 && (VALUE) >= -8 : 0)\n+\n+/*\n+ * A small bit of explanation:\n+ * \"G\" defines all of the floating constants that are *NOT* 68881\n+ * constants.  this is so 68881 constants get reloaded and the\n+ * fpmovecr is used.  \"H\" defines *only* the class of constants that\n+ * the fpa can use, because these can be gotten at in any fpa\n+ * instruction and there is no need to force reloads.\n+ */\n+#ifndef SUPPORT_SUN_FPA\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' ? ! (TARGET_68881 && standard_68881_constant_p (VALUE)) : 0 )\n+#else /* defined SUPPORT_SUN_FPA */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' ? ! (TARGET_68881 && standard_68881_constant_p (VALUE)) : \\\n+   (C) == 'H' ? (TARGET_FPA && standard_sun_fpa_constant_p (VALUE)) : 0)\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   On the 68000 series, use a data reg if possible when the\n+   value is a constant in the range where moveq could be used\n+   and we ensure that QImodes are reloaded into data regs.\n+   Also, if a floating constant needs reloading, put it in memory\n+   if possible.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n+  ((GET_CODE (X) == CONST_INT\t\t\t\\\n+    && (unsigned) (INTVAL (X) + 0x80) < 0x100\t\\\n+    && (CLASS) != ADDR_REGS)\t\t\t\\\n+   ? DATA_REGS\t\t\t\t\t\\\n+   : (GET_MODE (X) == QImode && (CLASS) != ADDR_REGS) \\\n+   ? DATA_REGS\t\t\t\t\t\\\n+   : (GET_CODE (X) == CONST_DOUBLE\t\t\\\n+      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT) \\\n+   ? NO_REGS\t\t\t\t\t\\\n+   : (CLASS))\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the 68000, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FP_REGS ? 1 \\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Moves between fp regs and other regs are two insns.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n+  (((CLASS1) == FP_REGS && (CLASS2) != FP_REGS)\t        \\\n+    || ((CLASS2) == FP_REGS && (CLASS1) != FP_REGS)\t\\\n+    ? 4 : 2)\n+\n+#else /* defined SUPPORT_SUN_FPA */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FP_REGS || (CLASS) == FPA_REGS || (CLASS) == LO_FPA_REGS ? 1 \\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Moves between fp regs and other regs are two insns.  */\n+/* Likewise for high fpa regs and other regs.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n+  ((((CLASS1) == FP_REGS && (CLASS2) != FP_REGS)\t\\\n+    || ((CLASS2) == FP_REGS && (CLASS1) != FP_REGS)\t\\\n+    || ((CLASS1) == FPA_REGS && (CLASS2) != FPA_REGS)\t\\\n+    || ((CLASS2) == FPA_REGS && (CLASS1) != FPA_REGS))\t\\\n+   ? 4 : 2)\n+\n+#endif /* define SUPPORT_SUN_FPA */\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Nonzero if we need to generate stack-probe insns.\n+   On most systems they are not needed.\n+   When they are needed, define this as the stack offset to probe at.  */\n+#define NEED_PROBE 0\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the 68000, sp@- in a byte insn really pushes a word.  */\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 8\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the 68000, the RTS insn cannot pop anything.\n+   On the 68010, the RTD insn may be used to pop them if the number\n+     of args is fixed, but if the number is variable then the caller\n+     must pop them all.  RTD can't be used for library calls now\n+     because the library is compiled with the Unix compiler.\n+   Use of RTD is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  ((TARGET_RTD && TREE_CODE (FUNTYPE) != IDENTIFIER_NODE\t\\\n+    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t    == void_type_node)))\t\t\t\t\\\n+   ? (SIZE) : 0)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the 68000 the return value is in D0 regardless.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the 68000 the return value is in D0 regardless.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the 68000, d0 is the only register thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the 68000, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the m68k, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the m68k, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the 68000 all args are pushed, except if -mregparm is specified\n+   then the first two words of arguments are passed in d0, d1.\n+   *NOTE* -mregparm does not work.\n+   It exists only to test register calling conventions.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n+  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n+\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n+\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n+ ? 2 - (CUM) / 4 : 0)\n+\n+/* Generate the assembly code for function entry. */\n+#define FUNCTION_PROLOGUE(FILE, SIZE) output_function_prologue(FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  asm_fprintf (FILE, \"\\tlea %LLP%d,%Ra0\\n\\tjsr mcount\\n\", (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  asm_fprintf (FILE, \"\\ttstl %LLPBX0\\n\\tbne %LLPI%d\\n\\tpea %LLPBX0\\n\\tjsr %U__bb_init_func\\n\\taddql %I4,%Rsp\\n%LLPI%d:\\n\",  \\\n+\t   LABELNO, LABELNO);\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+  asm_fprintf (FILE, \"\\taddql %I1,%LLPBX2+%d\\n\", 4 * BLOCKNO)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Generate the assembly code for function exit. */\n+#define FUNCTION_EPILOGUE(FILE, SIZE) output_function_epilogue (FILE, SIZE)\n+  \n+/* This is a hook for other tm files to change.  */\n+/* #define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE) */\n+\n+/* Determine if the epilogue should be output as RTL.\n+   You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n+#define USE_RETURN_INSN use_return_insn ()\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the 68k, if we have a frame, we must add one word to its length\n+   to allow for the place that a6 is stored when we do have a frame pointer.\n+   Otherwise, we would need to compute the offset from the frame pointer\n+   of a local variable as a function of frame_pointer_needed, which\n+   is hard.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n+{ int regno;\t\t\t\t\t\t\t\\\n+  int offset = -4;\t\t\t\t\t\t\\\n+  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 12;\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 4;\t\t\t\t\t\t\\\n+  (DEPTH) = (offset + ((get_frame_size () + 3) & -4)\t\t\\\n+\t     + (get_frame_size () == 0 ? 0 : 4));\t\t\\\n+}\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the 68k, the trampoline looks like this:\n+     mov  @#.,a0\n+     jsr  @#__trampoline\n+     jsr  @#__trampoline\n+     .long STATIC\n+     .long FUNCTION\n+The reason for having three jsr insns is so that an entire line\n+of the instruction cache is filled in a predictable way\n+that will always be the same.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x207c));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x4ef9));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (SYMBOL_REF, SImode, \"__trampoline\"));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x4ef9));\t\\\n+  ASM_OUTPUT_INT (FILE, gen_rtx (SYMBOL_REF, SImode, \"__trampoline\"));\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 26\n+\n+/* Alignment required for a trampoline.  16 is used to find the\n+   beginning of a line in the instruction cache.  */\n+\n+#define TRAMPOLINE_ALIGN 16\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 2)), TRAMP); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 18)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 22)), FNADDR); \\\n+}\n+\n+/* This is the library routine that is used\n+   to transfer control from the trampoline\n+   to the actual nested function.  */\n+\n+/* A colon is used with no explicit operands\n+   to cause the template string to be scanned for %-constructs.  */\n+/* The function name __transfer_from_trampoline is not actually used.\n+   The function definition just permits use of \"asm with operands\"\n+   (though the operand list is empty).  */\n+#define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+__transfer_from_trampoline ()\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  register char *a0 asm (\"%a0\");\t\t\t\t\\\n+  asm (\"___trampoline:\");\t\t\t\t\t\\\n+  asm volatile (\"mov%.l %0,%@\" : : \"m\" (a0[22]));\t\t\\\n+  asm volatile (\"mov%.l %1,%0\" : \"=a\" (a0) : \"m\" (a0[18]));\t\\\n+  asm (\"rts\":);\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+#define HAVE_POST_INCREMENT\n+/* #define HAVE_POST_DECREMENT */\n+\n+#define HAVE_PRE_DECREMENT\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+(((REGNO) ^ 010) < 8 || (unsigned) (reg_renumber[REGNO] ^ 010) < 8)\n+#define REGNO_OK_FOR_DATA_P(REGNO) \\\n+((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+(((REGNO) ^ 020) < 8 || (unsigned) (reg_renumber[REGNO] ^ 020) < 8)\n+#ifdef SUPPORT_SUN_FPA\n+#define REGNO_OK_FOR_FPA_P(REGNO) \\\n+(((REGNO) >= 24 && (REGNO) < 56) || (reg_renumber[REGNO] >= 24 && reg_renumber[REGNO] < 56))\n+#endif\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the 68000, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is a data register.  */\n+\n+#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\n+/* 1 if X is an address register  */\n+\n+#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n+\n+#ifdef SUPPORT_SUN_FPA\n+/* 1 if X is a register in the Sun FPA.  */\n+#define FPA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FPA_P (REGNO (X)))\n+#else\n+/* Answer must be no if we don't have an FPA.  */\n+#define FPA_REG_P(X) 0\n+#endif\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* Nonzero if the constant value X is a legitimate general operand\n+   when generating PIC code.  It is given that flag_pic is on and \n+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n+  (! symbolic_operand (X, VOIDmode))\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) ((REGNO (X) ^ 020) >= 8)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) ((REGNO (X) & ~027) != 0)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   When generating PIC, an address involving a SYMBOL_REF is legitimate\n+   if and only if it is the sum of pic_offset_table_rtx and the SYMBOL_REF.\n+   We use LEGITIMATE_PIC_OPERAND_P to throw out the illegitimate addresses,\n+   and we explicitly check for the sum of pic_offset_table_rtx and a SYMBOL_REF.\n+\n+   Likewise for a LABEL_REF when generating PIC.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+\n+#define INDIRECTABLE_1_ADDRESS_P(X)  \\\n+  ((CONSTANT_ADDRESS_P (X) && (!flag_pic || LEGITIMATE_PIC_OPERAND_P (X))) \\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n+       && REG_P (XEXP (X, 0))\t\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && REG_P (XEXP (X, 0)) && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\\\n+       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+       && ((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000)\t\t\\\n+   || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n+       && flag_pic && GET_CODE (XEXP (X, 1)) == SYMBOL_REF)\t\t\\\n+   || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n+       && flag_pic && GET_CODE (XEXP (X, 1)) == LABEL_REF))\t\t\\\n+\n+#if 0\n+/* This should replace the last two (non-pic) lines\n+   except that Sun's assembler does not seem to handle such operands.  */\n+       && (TARGET_68020 ? CONSTANT_ADDRESS_P (XEXP (X, 1))\t\t\\\n+\t   : (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t      && ((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000))))\n+#endif\n+\n+\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n+{ if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR; }\n+\n+#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\\\n+{ if (GET_CODE (X) == LABEL_REF) goto ADDR;\t\t\t\t\\\n+  if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR; }\n+\n+#define GO_IF_INDEXING(X, ADDR)\t\\\n+{ if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 0)))\t\t\\\n+    { GO_IF_INDEXABLE_BASE (XEXP (X, 1), ADDR); }\t\t\t\\\n+  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 1)))\t\t\\\n+    { GO_IF_INDEXABLE_BASE (XEXP (X, 0), ADDR); } }\n+\n+#define GO_IF_INDEXED_ADDRESS(X, ADDR)\t \\\n+{ GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+\t  && (unsigned) INTVAL (XEXP (X, 1)) + 0x80 < 0x100)\t\t\\\n+\t{ rtx go_temp = XEXP (X, 0); GO_IF_INDEXING (go_temp, ADDR); }\t\\\n+      if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\t\t\t\\\n+\t  && (unsigned) INTVAL (XEXP (X, 0)) + 0x80 < 0x100)\t\t\\\n+\t{ rtx go_temp = XEXP (X, 1); GO_IF_INDEXING (go_temp, ADDR); } } }\n+\n+#define LEGITIMATE_INDEX_REG_P(X)   \\\n+  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n+   || (GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+       && GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n+       && REG_OK_FOR_INDEX_P (XEXP (X, 0))))\n+\n+#define LEGITIMATE_INDEX_P(X)   \\\n+   (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n+    || (TARGET_68020 && GET_CODE (X) == MULT\t\t\\\n+\t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n+\t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n+\t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n+\t    || INTVAL (XEXP (X, 1)) == 8)))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\\\n+  GO_IF_INDEXED_ADDRESS (X, ADDR); }\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the 68000, we handle X+REG by loading X into a register R and\n+   using R+REG.  R will go in an address reg and indexing will be used.\n+   However, if REG is a broken-out memory address or multiplication,\n+   nothing needs to be done because REG can certainly go in an address reg.  */\n+\n+#define COPY_ONCE(Y) if (!copied) { Y = copy_rtx (Y); copied = ch = 1; }\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \\\n+{ register int ch = (X) != (OLDX);\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { int copied = 0;\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) == MULT)\t\t\t\t\\\n+\t{ COPY_ONCE (X); XEXP (X, 0) = force_operand (XEXP (X, 0), 0);}\t\\\n+      if (GET_CODE (XEXP (X, 1)) == MULT)\t\t\t\t\\\n+\t{ COPY_ONCE (X); XEXP (X, 1) = force_operand (XEXP (X, 1), 0);}\t\\\n+      if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+\t       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\\\n+\t\t   && GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode))\t\\\n+\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n+\t  register rtx val = force_operand (XEXP (X, 1), 0);\t\t\\\n+\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n+\t  COPY_ONCE (X);\t\t\t\t\t\t\\\n+\t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n+\t  goto WIN; }\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP (X, 1), 0)) == REG\t\t\\\n+\t\t   && GET_MODE (XEXP (XEXP (X, 1), 0)) == HImode))\t\\\n+\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n+\t  register rtx val = force_operand (XEXP (X, 0), 0);\t\t\\\n+\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n+\t  COPY_ONCE (X);\t\t\t\t\t\t\\\n+\t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n+\t  goto WIN; }}}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 68000, only predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand).  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC) goto LABEL\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE HImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Don't cse the address of the function being compiled.  */\n+#define NO_RECURSIVE_FUNCTION_CSE\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+#define SLOW_ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE -1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    /* Constant zero is super cheap due to clr instruction.  */\t\\\n+    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n+    /* Constants between -128 and 127 are cheap due to moveq */ \\\n+    if (INTVAL (RTX) >= -128 && INTVAL (RTX) <= 127) return 1;\t\\\n+    /* Constants between -136 and 254 are easily generated */\t\\\n+    /* by intelligent uses of moveq, add[q], and subq \t   */   \\\n+    if (INTVAL (RTX) >= -136 && INTVAL (RTX) <= 254) return 2;\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\n+/* Compute the cost of various arithmetic operations.\n+   These are vaguely right for a 68020.  */\n+/* The costs for long multiply have been adjusted to\n+   work properly in synth_mult on the 68020,\n+   relative to an average of the time for add and the time for shift,\n+   taking away a little more because sometimes move insns are needed.  */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\\\n+    /* An lea costs about three times as much as a simple add.  */  \\\n+    if (GET_MODE (X) == SImode\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == MULT\t\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (X, 1), 0)) == REG\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (X, 1), 1)) == CONST_INT\t\\\n+\t&& (INTVAL (XEXP (XEXP (X, 1), 1)) == 2\t\t\t\\\n+\t    || INTVAL (XEXP (XEXP (X, 1), 1)) == 4\t\t\\\n+\t    || INTVAL (XEXP (XEXP (X, 1), 1)) == 8))\t\t\\\n+      return COSTS_N_INSNS (3);\t /* lea an@(dx:l:i),am */\t\\\n+    break;\t\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\\\n+  case LSHIFT:\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\\\n+    /* A shift by a big integer takes an extra instruction.  */ \\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n+\t&& !(INTVAL (XEXP (X, 1)) > 0\t\t\t\t\\\n+\t     && INTVAL (XEXP (X, 1)) <= 8))\t\t\t\\\n+      return COSTS_N_INSNS (3);\t /* lsr #i,dn */\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (x, 1)) == CONST_INT\t\t\t\\\n+\t&& exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\t\t\\\n+      total = 2;\t\t\t\t\t\t\\\n+    else if (GET_MODE (X) == QImode || GET_MODE (X) == HImode)\t\\\n+      return COSTS_N_INSNS (8); /* mul.w */\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (13);\t /* mul.l */\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == QImode || GET_MODE (X) == HImode)\t\\\n+      return COSTS_N_INSNS (27); /* div.w */\t\t\t\\\n+    return COSTS_N_INSNS (43);\t /* div.l */\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* Set if the cc value is actually in the 68881, so a floating point\n+   conditional branch must be output.  */\n+#define CC_IN_68881 04000\n+\n+/* Store in cc_status the expressions that the condition codes will\n+   describe after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* On the 68000, all the insns to store in an address register fail to\n+   set the cc's.  However, in some cases these instructions can make it\n+   possibly invalid to use the saved cc's.  In those cases we clear out\n+   some or all of the saved cc's so they won't be used.  */\n+\n+#define NOTICE_UPDATE_CC(EXP,INSN) notice_update_cc (EXP, INSN)\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n+{ if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n+    return FLOAT;\t\t\t\t\t\t\\\n+  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\t\t\\\n+    return NO_OV;\t\t\t\t\t\t\\\n+  return NORMAL; }\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE)\t\\\n+  fprintf (FILE, \"#NO_APP\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Here are four prefixes that are used by asm_fprintf to\n+   facilitate customization for alternate assembler syntaxes.\n+   Machines with no likelihood of an alternate syntax need not\n+   define these and need not use asm_fprintf.  */\n+\n+/* The prefix for register names.  Note that REGISTER_NAMES\n+   is supposed to include this prefix.  */\n+\n+#define REGISTER_PREFIX \"\"\n+\n+/* The prefix for local labels.  You should be able to define this as\n+   an empty string, or any arbitrary string (such as \".\", \".L%\", etc)\n+   without having to make any other changes to account for the specific\n+   definition.  Note it is a string literal, not interpreted by printf\n+   and friends. */\n+\n+#define LOCAL_LABEL_PREFIX \"\"\n+\n+/* The prefix to add to user-visible assembler symbols.  */\n+\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* The prefix for immediate operands.  */\n+\n+#define IMMEDIATE_PREFIX \"#\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#ifndef SUPPORT_SUN_FPA\n+\n+#define REGISTER_NAMES \\\n+{\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n+ \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n+ \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\" }\n+\n+#else /* SUPPORTED_SUN_FPA */\n+\n+#define REGISTER_NAMES \\\n+{\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n+ \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n+ \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\", \\\n+ \"fpa0\", \"fpa1\", \"fpa2\", \"fpa3\", \"fpa4\", \"fpa5\", \"fpa6\", \"fpa7\", \\\n+ \"fpa8\", \"fpa9\", \"fpa10\", \"fpa11\", \"fpa12\", \"fpa13\", \"fpa14\", \"fpa15\", \\\n+ \"fpa16\", \"fpa17\", \"fpa18\", \"fpa19\", \"fpa20\", \"fpa21\", \"fpa22\", \"fpa23\", \\\n+ \"fpa24\", \"fpa25\", \"fpa26\", \"fpa27\", \"fpa28\", \"fpa29\", \"fpa30\", \"fpa31\" }\n+\n+#endif /* defined SUPPORT_SUN_FPA */\n+\n+/* How to renumber registers for dbx and gdb.\n+   On the Sun-3, the floating point registers have numbers\n+   18 to 25, not 16 to 23 as they do in the compiler.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 16 ? (REGNO) : (REGNO) + 2)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  asm_fprintf (FILE, \"%U%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  asm_fprintf (FILE, \"%L%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%s%d\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double 0r%.20g\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+/* Sun's assembler can't handle floating constants written as floating.\n+   However, when cross-compiling, always use that in case format differs.  */\n+\n+#ifdef CROSS_COMPILE\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float 0r%.10g\\n\", (VALUE))\n+\n+#else\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf (FILE, \"\\t.long 0x%x\\n\", tem.l);\t\\\n+   } while (0)\n+\n+#endif /* not CROSS_COMPILER */\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  asm_fprintf (FILE, \"\\tmovel %s,%Rsp@-\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  asm_fprintf (FILE, \"\\tmovel %Rsp@+,%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The 68000 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  asm_fprintf (FILE, \"\\t.long %LL%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) == 1)\t\t\t\\\n+    fprintf (FILE, \"\\t.even\\n\");\t\\\n+  else if ((LOG) != 0)\t\t\t\\\n+    abort ();\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.skip %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Output a float value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  asm_fprintf (FILE, \"%I0r%.9g\", (VALUE))\n+\n+/* Output a double value (represented as a C double) as an immediate operand.\n+   This macro is a 68k-specific macro.  */\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n+  asm_fprintf (FILE, \"%I0r%.20g\", (VALUE))\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   On the 68000, we use several CODE characters:\n+   '.' for dot needed in Motorola-style opcode names.\n+   '-' for an operand pushing on the stack:\n+       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n+   '+' for an operand pushing on the stack:\n+       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n+   '@' for a reference to the top word on the stack:\n+       sp@, (sp) or (%sp) depending on the style of syntax.\n+   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n+       but & in SGS syntax).\n+   '!' for the cc register (used in an `and to cc' insn).\n+   '$' for the letter `s' in an op code, but only on the 68040.\n+   '&' for the letter `d' in an op code, but only on the 68040.\n+\n+   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n+   'd' to force memory addressing to be absolute, not relative.\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n+       than directly).  Second part of 'y' below.\n+   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n+       or print pair of registers as rx:ry.\n+   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n+       CONST_DOUBLE's as SunFPA constant RAM registers if\n+       possible, so it should not be used except for the SunFPA. */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n+   || (CODE) == '+' || (CODE) == '@' || (CODE) == '!'\t\t\t\\\n+   || (CODE) == '$' || (CODE) == '&')\n+\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+#define PRINT_OPERAND_EXTRACT_FLOAT(X)\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\n+#else\n+#define PRINT_OPERAND_EXTRACT_FLOAT(X)\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_HIGH (X); u.i[1] = CONST_DOUBLE_LOW (X);\n+#endif\n+\n+#ifdef CROSS_COMPILER\n+#define PRINT_OPERAND_PRINT_FLOAT(CODE, FILE)   \\\n+  ASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\n+#else\n+#define PRINT_OPERAND_PRINT_FLOAT(CODE, FILE)   \\\n+{ if (CODE == 'f')\t\t\t\t\t\t\t\\\n+    ASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    asm_fprintf (FILE, \"%I0x%x\", u1.i); }\n+#endif\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  X is an RTL\n+   expression.\n+\n+   CODE is a value that can be used to specify one of several ways\n+   of printing the operand.  It is used when identical operands\n+   must be printed differently depending on the context.  CODE\n+   comes from the `%' specification that was used to request\n+   printing of the operand.  If the specification was just `%DIGIT'\n+   then CODE is 0; if the specification was `%LTR DIGIT' then CODE\n+   is the ASCII code for LTR.\n+\n+   If X is a register, this macro should print the register's name.\n+   The names can be found in an array `reg_names' whose type is\n+   `char *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n+\n+   When the machine description has a specification `%PUNCT' (a `%'\n+   followed by a punctuation character), this macro is called with\n+   a null pointer for X and the punctuation character for CODE.\n+\n+   See m68k.c for the m68k specific codes.  */\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on\n+   the section that the address refers to.  On these machines,\n+   define the macro `ENCODE_SECTION_INFO' to store the information\n+   into the `symbol_ref', and then check for it here.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+\n+/* Define functions defined in aux-output.c and used in templates.  */\n+\n+extern char *output_move_double ();\n+extern char *output_move_const_single ();\n+extern char *output_move_const_double ();\n+extern char *output_btst ();\n+\f\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}]}