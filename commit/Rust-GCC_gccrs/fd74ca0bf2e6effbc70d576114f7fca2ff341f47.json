{"sha": "fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3NGNhMGJmMmU2ZWZmYmM3MGQ1NzYxMTRmN2ZjYTJmZjM0MWY0Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-16T07:34:51Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-16T07:34:51Z"}, "message": "cp-tree.h (struct language_function): Remove x_base_init_list and x_member_init_list.\n\n\t* cp-tree.h (struct language_function): Remove x_base_init_list\n\tand x_member_init_list.\n\t(current_base_init_list): Remove.\n\t(current_member_init_list): Likewise.\n\t(setup_vtbl_ptr): Change prototype.\n\t(emit_base_init): Likewise.\n\t(expand_member_init): Likewise.\n\t(reinit_parse_for_function): Remove.\n\t* decl.c (save_function_data): Don't clear x_base_init_list and\n\tx_member_init_list.\n\t(mark_language_function): Don't mark them.\n\t* init.c (perform_member_init): Tweak comment.\n\t(sort_member_init): Take the list of initializers as an argument.\n\t(sort_base_init): Likewise.\n\t(emit_base_init): Likewise.\n\t(expand_member_init): Return the initializer.  Don't use global\n\tvariables.\n\t* lex.c (reinit_parse_for_function): Remove.\n\t* method.c (build_template_parm_names): Correct substitution.\n\t(do_build_copy_constructor): Don't use current_member_init_list\n\tand current_base_init_list.\n\t(synthesize_method): Likewise.\n\t* parse.y (base_init): Split mem-initializers into\n\tbase-initializers and field-initializers.\n\t(member_init_list): Build up the list here.\n\t(member_init): Return the initializer.\n\t(fn.depfn): Don't use reinit_parse_for_function.\n\t* parse.c: Regenerated.\n\t* pt.c (convert_nontype_argument): Don't make an ADDR_EXPR of the\n\tERROR_MARK.\n\t(tsubst_expr): Don't use current_member_init_list\n\tand current_base_init_list.\n\t(tsubst_expr_values): Rename to ...\n\t(tsubst_initializer_list): ... this.  Use convert_from_reference.\n\t* semantics.c (setup_vtbl_ptr): Don't use current_member_init_list\n\tand current_base_init_list.\n\t(begin_function_definition): Don't call reinit_parse_for_function.\n\n\t* dump.c (dequeue_and_dump): Use TREE_VEC_LENGTH with vectors.\n\n\t* error.c (dump_expr): Handle ADDR_EXPRs with REFERENCE_TYPE\n\tcorrectly.\n\nFrom-SVN: r34571", "tree": {"sha": "396b0aea2fa14d244a3fde9486d0ea106b5b7006", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/396b0aea2fa14d244a3fde9486d0ea106b5b7006"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/comments", "author": null, "committer": null, "parents": [{"sha": "ff1c0096a1cb412bed7d62e333dcd4020c90ca7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff1c0096a1cb412bed7d62e333dcd4020c90ca7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff1c0096a1cb412bed7d62e333dcd4020c90ca7c"}], "stats": {"total": 2123, "additions": 1146, "deletions": 977}, "files": [{"sha": "a6452ac47ceff97c60cc1556e76ad97da76ea1c3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -12,6 +12,49 @@\n \n 2000-06-15  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (struct language_function): Remove x_base_init_list\n+\tand x_member_init_list.\n+\t(current_base_init_list): Remove.\n+\t(current_member_init_list): Likewise.\n+\t(setup_vtbl_ptr): Change prototype.\n+\t(emit_base_init): Likewise.\n+\t(expand_member_init): Likewise.\n+\t(reinit_parse_for_function): Remove.\n+\t* decl.c (save_function_data): Don't clear x_base_init_list and\n+\tx_member_init_list.\n+\t(mark_language_function): Don't mark them.\n+\t* init.c (perform_member_init): Tweak comment.\n+\t(sort_member_init): Take the list of initializers as an argument.\n+\t(sort_base_init): Likewise.\n+\t(emit_base_init): Likewise.\n+\t(expand_member_init): Return the initializer.  Don't use global\n+\tvariables.\n+\t* lex.c (reinit_parse_for_function): Remove.\n+\t* method.c (build_template_parm_names): Correct substitution.\n+\t(do_build_copy_constructor): Don't use current_member_init_list\n+\tand current_base_init_list.\n+\t(synthesize_method): Likewise.\n+\t* parse.y (base_init): Split mem-initializers into\n+\tbase-initializers and field-initializers.\n+\t(member_init_list): Build up the list here.\n+\t(member_init): Return the initializer.\n+\t(fn.depfn): Don't use reinit_parse_for_function.\n+\t* parse.c: Regenerated.\n+\t* pt.c (convert_nontype_argument): Don't make an ADDR_EXPR of the\n+\tERROR_MARK.\n+\t(tsubst_expr): Don't use current_member_init_list\n+\tand current_base_init_list.\n+\t(tsubst_expr_values): Rename to ...\n+\t(tsubst_initializer_list): ... this.  Use convert_from_reference.\n+\t* semantics.c (setup_vtbl_ptr): Don't use current_member_init_list\n+\tand current_base_init_list.\n+\t(begin_function_definition): Don't call reinit_parse_for_function.\n+\t\n+\t* dump.c (dequeue_and_dump): Use TREE_VEC_LENGTH with vectors.\n+\n+\t* error.c (dump_expr): Handle ADDR_EXPRs with REFERENCE_TYPE\n+\tcorrectly.\n+\t\n \t* cp-tree.h (DECL_PENDING_INLINE_P): Relax checking.\n \n 2000-06-14  Benjamin Chelf  <chelf@cabriolet.stanford.edu>"}, {"sha": "79441dcf9b68a6cf0cba23f49a8dc9e36687a47b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -883,8 +883,6 @@ struct language_function\n {\n   tree x_ctor_label;\n   tree x_dtor_label;\n-  tree x_base_init_list;\n-  tree x_member_init_list;\n   tree x_current_class_ptr;\n   tree x_current_class_ref;\n   tree x_eh_spec_try_block;\n@@ -927,19 +925,6 @@ struct language_function\n \n #define ctor_label cp_function_chain->x_ctor_label\n \n-/* In C++, structures with well-defined constructors are initialized by\n-   those constructors, unasked.  CURRENT_BASE_INIT_LIST\n-   holds a list of stmts for a BASE_INIT term in the grammar.\n-   This list has one element for each base class which must be\n-   initialized.  The list elements are [basename, init], with\n-   type basetype.  This allows the possibly anachronistic form\n-   (assuming d : a, b, c) \"d (int a) : c(a+5), b (a-4), a (a+3)\"\n-   where each successive term can be handed down the constructor\n-   line.  Perhaps this was not intended.  */\n-\n-#define current_base_init_list cp_function_chain->x_base_init_list\n-#define current_member_init_list cp_function_chain->x_member_init_list\n-\n /* When we're processing a member function, current_class_ptr is the\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */\n@@ -4082,7 +4067,7 @@ extern int copy_assignment_arg_p\t\tPARAMS ((tree, int));\n extern void cplus_decl_attributes\t\tPARAMS ((tree, tree, tree)); \n extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));\n-extern void setup_vtbl_ptr\t\t\tPARAMS ((void));\n+extern void setup_vtbl_ptr\t\t\tPARAMS ((tree, tree));\n extern void defer_fn             \t\tPARAMS ((tree));\n extern tree get_temp_name\t\t\tPARAMS ((tree, int));\n extern void finish_anon_union\t\t\tPARAMS ((tree));\n@@ -4174,8 +4159,8 @@ extern tree do_friend\t\t\t\tPARAMS ((tree, tree, tree, tree, tree, enum overload_fl\n \n /* in init.c */\n extern void init_init_processing\t\tPARAMS ((void));\n-extern void emit_base_init\t\t\tPARAMS ((void));\n-extern void expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n+extern void emit_base_init\t\t\tPARAMS ((tree, tree));\n+extern tree expand_member_init\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_aggr_init\t\t\tPARAMS ((tree, tree, int));\n extern int is_aggr_type\t\t\t\tPARAMS ((tree, int));\n extern tree get_aggr_from_typedef\t\tPARAMS ((tree, int));\n@@ -4209,7 +4194,6 @@ extern void lang_finish\t\t\t\tPARAMS ((void));\n #if 0\n extern void reinit_lang_specific\t\tPARAMS ((void));\n #endif\n-extern void reinit_parse_for_function\t\tPARAMS ((void));\n extern void print_parse_statistics\t\tPARAMS ((void));\n extern void extract_interface_info\t\tPARAMS ((void));\n extern void do_pending_inlines\t\t\tPARAMS ((void));"}, {"sha": "72fb758a667d288b3cc9dad878d28ef6e203cfe2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -14090,8 +14090,6 @@ save_function_data (decl)\n   DECL_SAVED_FUNCTION_DATA (decl) = f;\n \n   /* Clear out the bits we don't need.  */\n-  f->x_base_init_list = NULL_TREE;\n-  f->x_member_init_list = NULL_TREE;\n   f->x_stmt_tree.x_last_stmt = NULL_TREE;\n   f->x_stmt_tree.x_last_expr_type = NULL_TREE;\n   f->x_result_rtx = NULL_RTX;\n@@ -14972,8 +14970,6 @@ mark_lang_function (p)\n \n   ggc_mark_tree (p->x_ctor_label);\n   ggc_mark_tree (p->x_dtor_label);\n-  ggc_mark_tree (p->x_base_init_list);\n-  ggc_mark_tree (p->x_member_init_list);\n   ggc_mark_tree (p->x_current_class_ptr);\n   ggc_mark_tree (p->x_current_class_ref);\n   ggc_mark_tree (p->x_eh_spec_try_block);"}, {"sha": "ca3baa0a3c220aae335e47802056c906ca6d663c", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -454,7 +454,7 @@ dequeue_and_dump (di)\n       break;\n \n     case TREE_VEC:\n-      dump_int (di, \"lngt\", IDENTIFIER_LENGTH (t));\n+      dump_int (di, \"lngt\", TREE_VEC_LENGTH (t));\n       for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n \t{\n \t  char buffer[32];"}, {"sha": "1d338d9f230b727c03560ac76b61610e952a001b", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -1741,7 +1741,12 @@ dump_expr (t, flags)\n \n     case ADDR_EXPR:\n       if (TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n-\t  || TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST)\n+\t  || TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST\n+\t  /* An ADDR_EXPR can have reference type.  In that case, we\n+\t     shouldn't print the `&' doing so indicates to the user\n+\t     that the expression has pointer type.  */\n+\t  || (TREE_TYPE (t) \n+\t      && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE))\n \tdump_expr (TREE_OPERAND (t, 0), flags | TS_EXPR_PARENS);\n       else\n \tdump_unary_op (\"&\", t, flags);"}, {"sha": "a7c8ebbdffb7030e0b33a5a7d94cba29acf49ba4", "filename": "gcc/cp/init.c", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -40,11 +40,11 @@ static void expand_aggr_init_1 PARAMS ((tree, tree, tree, tree, int));\n static void expand_default_init PARAMS ((tree, tree, tree, tree, int));\n static tree build_vec_delete_1 PARAMS ((tree, tree, tree, special_function_kind, int));\n static void perform_member_init PARAMS ((tree, tree, int));\n-static void sort_base_init PARAMS ((tree, tree *, tree *));\n+static void sort_base_init PARAMS ((tree, tree, tree *, tree *));\n static tree build_builtin_delete_call PARAMS ((tree));\n static int member_init_ok_or_else PARAMS ((tree, tree, const char *));\n static void expand_virtual_init PARAMS ((tree, tree));\n-static tree sort_member_init PARAMS ((tree));\n+static tree sort_member_init PARAMS ((tree, tree));\n static tree initializing_context PARAMS ((tree));\n static void expand_cleanup_for_base PARAMS ((tree, tree));\n static tree get_temp_regvar PARAMS ((tree, tree));\n@@ -213,7 +213,7 @@ perform_member_init (member, init, explicit)\n   else if (TYPE_NEEDS_CONSTRUCTING (type)\n \t   || (init && TYPE_HAS_CONSTRUCTOR (type)))\n     {\n-      /* Since `init' is already a TREE_LIST on the current_member_init_list,\n+      /* Since `init' is already a TREE_LIST on the member_init_list,\n \t only build it into one if we aren't already a list.  */\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n \tinit = build_tree_list (NULL_TREE, init);\n@@ -338,11 +338,17 @@ build_field_list (t, list, uses_unions_p)\n   return list;\n }\n \n-/* Subroutine of emit_member_init.  */\n+/* The MEMBER_INIT_LIST is a TREE_LIST.  The TREE_PURPOSE of each list\n+   gives a FIELD_DECL in T that needs initialization.  The TREE_VALUE\n+   gives the initializer, or list of initializer arguments.  Sort the\n+   MEMBER_INIT_LIST, returning a version that contains the same\n+   information but in the order that the fields should actually be\n+   initialized.  Perform error-checking in the process.  */\n \n static tree\n-sort_member_init (t)\n+sort_member_init (t, member_init_list)\n      tree t;\n+     tree member_init_list;\n {\n   tree init_list;\n   tree last_field;\n@@ -355,7 +361,7 @@ sort_member_init (t)\n   /* Go through the explicit initializers, adding them to the\n      INIT_LIST.  */\n   last_field = init_list;\n-  for (init = current_member_init_list; init; init = TREE_CHAIN (init))\n+  for (init = member_init_list; init; init = TREE_CHAIN (init))\n     {\n       tree f;\n       tree initialized_field;\n@@ -492,9 +498,15 @@ sort_member_init (t)\n   return init_list;\n }\n \n+/* Like sort_member_init, but used for initializers of base classes.\n+   *RBASE_PTR is filled in with the initializers for non-virtual bases;\n+   vbase_ptr gets the virtual bases.  */\n+\n static void\n-sort_base_init (t, rbase_ptr, vbase_ptr)\n-     tree t, *rbase_ptr, *vbase_ptr;\n+sort_base_init (t, base_init_list, rbase_ptr, vbase_ptr)\n+     tree t;\n+     tree base_init_list;\n+     tree *rbase_ptr, *vbase_ptr;\n {\n   tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n   int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n@@ -513,7 +525,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n   /* First walk through and splice out vbase and invalid initializers.\n      Also replace names with binfos.  */\n \n-  last = tree_cons (NULL_TREE, NULL_TREE, current_base_init_list);\n+  last = tree_cons (NULL_TREE, NULL_TREE, base_init_list);\n   for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n     {\n       tree basetype = TREE_PURPOSE (x);\n@@ -580,20 +592,24 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \n   for (i = 0; i < n_baseclasses; ++i)\n     {\n+      /* The base for which we're currently initializing.  */\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      /* The initializer for BASE_BINFO.  */\n+      tree init;\n       int pos;\n \n       if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n-      for (x = current_base_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n+      /* We haven't found the BASE_BINFO yet.  */\n+      init = NULL_TREE;\n+      /* Loop through all the explicitly initialized bases, looking\n+\t for an appropriate initializer.  */\n+      for (x = base_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n \t{\n \t  tree binfo = TREE_PURPOSE (x);\n \n-\t  if (binfo == NULL_TREE)\n-\t    continue;\n-\n-\t  if (binfo == base_binfo)\n+\t  if (binfo == base_binfo && !init)\n \t    {\n \t      if (warn_reorder)\n \t\t{\n@@ -609,28 +625,32 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \n \t      /* Make sure we won't try to work on this init again.  */\n \t      TREE_PURPOSE (x) = NULL_TREE;\n-\t      x = build_tree_list (binfo, TREE_VALUE (x));\n-\t      goto got_it;\n+\t      init = build_tree_list (binfo, TREE_VALUE (x));\n+\t    }\n+\t  else if (binfo == base_binfo)\n+\t    {\n+\t      cp_error (\"base class `%T' already initialized\", \n+\t\t\tBINFO_TYPE (binfo));\n+\t      break;\n \t    }\n \t}\n \n       /* If we didn't find BASE_BINFO in the list, create a dummy entry\n \t so the two lists (RBASES and the list of bases) will be\n \t symmetrical.  */\n-      x = build_tree_list (NULL_TREE, NULL_TREE);\n-    got_it:\n-      rbases = chainon (rbases, x);\n+      if (!init)\n+\tinit = build_tree_list (NULL_TREE, NULL_TREE);\n+      rbases = chainon (rbases, init);\n     }\n \n   *rbase_ptr = rbases;\n   *vbase_ptr = vbases;\n }\n \n /* Perform whatever initializations have yet to be done on the base\n-   class of the class variable.  These actions are in the global\n-   variable CURRENT_BASE_INIT_LIST.  Such an action could be\n-   NULL_TREE, meaning that the user has explicitly called the base\n-   class constructor with no arguments.\n+   class, and non-static data members, of the CURRENT_CLASS_TYPE.\n+   These actions are given by the BASE_INIT_LIST and MEM_INIT_LIST,\n+   respectively.\n \n    If there is a need for a call to a constructor, we must surround\n    that call with a pushlevel/poplevel pair, since we are technically\n@@ -640,22 +660,20 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    classes.  That is done specially, elsewhere.  */\n \n void\n-emit_base_init ()\n+emit_base_init (mem_init_list, base_init_list)\n+     tree mem_init_list;\n+     tree base_init_list;\n {\n   tree member;\n-  tree mem_init_list;\n   tree rbase_init_list, vbase_init_list;\n   tree t = current_class_type;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i;\n   int n_baseclasses = BINFO_N_BASETYPES (t_binfo);\n \n-  mem_init_list = sort_member_init (t);\n-  current_member_init_list = NULL_TREE;\n-\n-  sort_base_init (t, &rbase_init_list, &vbase_init_list);\n-  current_base_init_list = NULL_TREE;\n+  mem_init_list = sort_member_init (t, mem_init_list);\n+  sort_base_init (t, base_init_list, &rbase_init_list, &vbase_init_list);\n \n   /* First, initialize the virtual base classes, if we are\n      constructing the most-derived object.  */\n@@ -1004,21 +1022,17 @@ member_init_ok_or_else (field, type, member_name)\n \n    We do not yet have a fixed-point finder to instantiate types\n    being fed to overloaded constructors.  If there is a unique\n-   constructor, then argument types can be got from that one.\n+   constructor, then argument types can be got from that one.  */\n \n-   If INIT is non-NULL, then it the initialization should\n-   be placed in `current_base_init_list', where it will be processed\n-   by `emit_base_init'.  */\n-\n-void\n+tree\n expand_member_init (exp, name, init)\n      tree exp, name, init;\n {\n   tree basetype = NULL_TREE, field;\n   tree type;\n \n   if (exp == NULL_TREE)\n-    return;\t\t\t/* complain about this later */\n+    return NULL_TREE;\n \n   type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n@@ -1033,14 +1047,14 @@ expand_member_init (exp, name, init)\n       {\n       case 0:\n \terror (\"base class initializer specified, but no base class to initialize\");\n-\treturn;\n+\treturn NULL_TREE;\n       case 1:\n \tbasetype = TYPE_BINFO_BASETYPE (type, 0);\n \tbreak;\n       default:\n \terror (\"initializer for unnamed base class ambiguous\");\n \tcp_error (\"(type `%T' uses multiple inheritance)\", type);\n-\treturn;\n+\treturn NULL_TREE;\n       }\n \n   my_friendly_assert (init != NULL_TREE, 0);\n@@ -1056,8 +1070,6 @@ expand_member_init (exp, name, init)\n \n   if (name == NULL_TREE || basetype)\n     {\n-      tree base_init;\n-\n       if (name == NULL_TREE)\n \t{\n #if 0\n@@ -1084,43 +1096,23 @@ expand_member_init (exp, name, init)\n \t  else\n \t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n \t\t      basetype, type);\n-\t  return;\n+\t  return NULL_TREE;\n \t}\n \n-      if (purpose_member (basetype, current_base_init_list))\n-\t{\n-\t  cp_error (\"base class `%T' already initialized\", basetype);\n-\t  return;\n-\t}\n-\n-      if (warn_reorder && current_member_init_list)\n-\t{\n-\t  cp_warning (\"base initializer for `%T'\", basetype);\n-\t  warning (\"   will be re-ordered to precede member initializations\");\n-\t}\n-\n-      base_init = build_tree_list (basetype, init);\n-      current_base_init_list = chainon (current_base_init_list, base_init);\n+      init = build_tree_list (basetype, init);\n     }\n   else\n     {\n-      tree member_init;\n-\n     try_member:\n       field = lookup_field (type, name, 1, 0);\n \n       if (! member_init_ok_or_else (field, type, IDENTIFIER_POINTER (name)))\n-\treturn;\n-\n-      if (purpose_member (name, current_member_init_list))\n-\t{\n-\t  cp_error (\"field `%D' already initialized\", field);\n-\t  return;\n-\t}\n+\treturn NULL_TREE;\n \n-      member_init = build_tree_list (field, init);\n-      current_member_init_list = chainon (current_member_init_list, member_init);\n+      init = build_tree_list (field, init);\n     }\n+\n+  return init;\n }\n \n /* This is like `expand_member_init', only it stores one aggregate"}, {"sha": "c17a6ccc864861d9bd3eb8d86bbc7f3313e0277d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -730,13 +730,6 @@ finish_parse ()\n   fclose (finput);\n #endif\n }\n-\n-void\n-reinit_parse_for_function ()\n-{\n-  current_base_init_list = NULL_TREE;\n-  current_member_init_list = NULL_TREE;\n-}\n \f\n inline void\n yyprint (file, yychar, yylval)"}, {"sha": "cdf27719bf600552025e134419c51da1f629c4ae", "filename": "gcc/cp/method.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -987,7 +987,7 @@ build_template_parm_names (parmlist, arglist)\n \t}\n       else\n \t{\n-\t  parm = tsubst (parm, arglist, /*complain=*/1, NULL_TREE);\n+\t  parm = tsubst (parm, inner_args, /*complain=*/1, NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n \t  build_mangled_name_for_type (TREE_TYPE (parm));\n \t  build_overload_value (TREE_TYPE (parm), arg, \n@@ -2315,22 +2315,24 @@ do_build_copy_constructor (fndecl)\n       tree fields = TYPE_FIELDS (current_class_type);\n       int n_bases = CLASSTYPE_N_BASECLASSES (current_class_type);\n       tree binfos = TYPE_BINFO_BASETYPES (current_class_type);\n+      tree member_init_list = NULL_TREE;\n+      tree base_init_list = NULL_TREE;\n       int i;\n \n       /* Initialize all the base-classes.  */\n       for (t = CLASSTYPE_VBASECLASSES (current_class_type); t;\n \t   t = TREE_CHAIN (t))\n-\tcurrent_base_init_list \n+\tbase_init_list \n \t  = tree_cons (BINFO_TYPE (TREE_VALUE (t)), parm, \n-\t\t       current_base_init_list);\n+\t\t       base_init_list);\n       for (i = 0; i < n_bases; ++i)\n \t{\n \t  t = TREE_VEC_ELT (binfos, i);\n \t  if (TREE_VIA_VIRTUAL (t))\n \t    continue; \n \n-\t  current_base_init_list \n-\t    = tree_cons (BINFO_TYPE (t), parm, current_base_init_list);\n+\t  base_init_list \n+\t    = tree_cons (BINFO_TYPE (t), parm, base_init_list);\n \t}\n \n       for (; fields; fields = TREE_CHAIN (fields))\n@@ -2364,12 +2366,12 @@ do_build_copy_constructor (fndecl)\n \t  init = build (COMPONENT_REF, TREE_TYPE (field), init, field);\n \t  init = build_tree_list (NULL_TREE, init);\n \n-\t  current_member_init_list\n-\t    = tree_cons (field, init, current_member_init_list);\n+\t  member_init_list\n+\t    = tree_cons (field, init, member_init_list);\n \t}\n-      current_member_init_list = nreverse (current_member_init_list);\n-      current_base_init_list = nreverse (current_base_init_list);\n-      setup_vtbl_ptr ();\n+      member_init_list = nreverse (member_init_list);\n+      base_init_list = nreverse (base_init_list);\n+      setup_vtbl_ptr (member_init_list, base_init_list);\n     }\n }\n \n@@ -2512,7 +2514,7 @@ synthesize_method (fndecl)\n       need_body = 0;\n     }\n   else if (DECL_DESTRUCTOR_P (fndecl))\n-    setup_vtbl_ptr ();\n+    setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n   else\n     {\n       tree arg_chain = FUNCTION_ARG_CHAIN (fndecl);\n@@ -2521,7 +2523,7 @@ synthesize_method (fndecl)\n       if (arg_chain != void_list_node)\n \tdo_build_copy_constructor (fndecl);\n       else if (TYPE_NEEDS_CONSTRUCTING (current_class_type))\n-\tsetup_vtbl_ptr ();\n+\tsetup_vtbl_ptr (NULL_TREE, NULL_TREE);\n     }\n \n   /* If we haven't yet generated the body of the function, just"}, {"sha": "3a063f1f1fd9a26cbdb9072ad13faf7a46bd1db1", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 883, "deletions": 824, "changes": 1707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47"}, {"sha": "5d0ff0798729ce4baa333eb84d3b4a8a819955c7", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 73, "deletions": 19, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -389,7 +389,8 @@ cp_parse_init ()\n %type <itype> new delete\n /* %type <ttype> primary_no_id */\n %type <ttype> maybe_parmlist\n-%type <itype> member_init_list\n+%type <ttype> member_init\n+%type <ftype> member_init_list\n %type <ttype> template_header template_parm_list template_parm\n %type <ttype> template_type_parm template_template_parm\n %type <code>  template_close_bracket\n@@ -853,9 +854,40 @@ return_init:\n base_init:\n \t  ':' .set_base_init member_init_list\n \t\t{\n-\t\t  if ($3 == 0)\n-\t\t    error (\"no base initializers given following ':'\");\n-\t\t  setup_vtbl_ptr ();\n+\t\t  tree member_init_list = NULL_TREE;\n+\t\t  tree base_init_list = NULL_TREE;\n+\t\t  tree init;\n+\t\t  tree next;\n+\t\t  int seen_member_init_p;\n+\n+\t\t  if ($3.new_type_flag == 0)\n+\t\t    error (\"no base or member initializers given following ':'\");\n+\t\t  \n+\t\t  seen_member_init_p = 0;\n+\t\t  for (init = $3.t; init; init = next)\n+\t\t    {\n+\t\t      next = TREE_CHAIN (init);\n+\t\t      if (TREE_CODE (TREE_PURPOSE (init)) == FIELD_DECL)\n+\t\t\t{\n+\t\t\t  TREE_CHAIN (init) = member_init_list;\n+\t\t\t  member_init_list = init;\n+\t\t\t  seen_member_init_p = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (warn_reorder && seen_member_init_p)\n+\t\t\t    {\n+\t\t\t      cp_warning (\"base initializer for `%T'\",\n+\t\t\t\t\t  TREE_PURPOSE (init));\n+\t\t\t      warning (\"   will be re-ordered to precede member initializations\");\n+\t\t\t    }\n+\t\t\t    \n+\t\t\t  TREE_CHAIN (init) = base_init_list;\n+\t\t\t  base_init_list = init;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  setup_vtbl_ptr (member_init_list, base_init_list);\n \t\t}\n \t;\n \n@@ -877,10 +909,26 @@ base_init:\n \n member_init_list:\n \t  /* empty */\n-\t\t{ $$ = 0; }\n+\t\t{ \n+\t\t  $$.new_type_flag = 0; \n+\t\t  $$.t = NULL_TREE; \n+\t\t}\n \t| member_init\n-\t\t{ $$ = 1; }\n+\t\t{ \n+\t\t  $$.new_type_flag = 1; \n+\t\t  $$.t = $1; \n+\t\t}\n \t| member_init_list ',' member_init\n+                { \n+\t\t  if ($3) \n+\t\t    {\n+\t\t      $$.new_type_flag = 1; \n+\t\t      TREE_CHAIN ($3) = $1.t;\n+\t\t      $$.t = $3;\n+\t\t    }\n+\t\t  else\n+\t\t    $$ = $1;\n+\t\t}\n \t| member_init_list error\n \t;\n \n@@ -889,29 +937,36 @@ member_init:\n \t\t{\n \t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  expand_member_init (current_class_ref, NULL_TREE, $2);\n+\t\t  $$ = expand_member_init (current_class_ref, NULL_TREE, $2);\n \t\t}\n \t| LEFT_RIGHT\n \t\t{\n \t\t  if (current_class_name)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  expand_member_init (current_class_ref, NULL_TREE, void_type_node);\n+\t\t  $$ = expand_member_init (current_class_ref,\n+\t\t\t\t\t   NULL_TREE, \n+\t\t\t\t\t   void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (current_class_ref, $1, $3); }\n+\t\t{ $$ = expand_member_init (current_class_ref, $1, $3); }\n \t| notype_identifier LEFT_RIGHT\n-\t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n+\t\t{ $$ = expand_member_init (current_class_ref, $1,\n+\t\t\t\t\t   void_type_node); }\n \t| nonnested_type '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (current_class_ref, $1, $3); }\n+\t\t{ $$ = expand_member_init (current_class_ref, $1, $3); }\n \t| nonnested_type LEFT_RIGHT\n-\t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n+\t\t{ $$ = expand_member_init (current_class_ref, $1,\n+\t\t\t\t\t   void_type_node); }\n \t| typename_sub '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),\n-\t\t\t\t      $3); }\n+\t\t{ $$ = expand_member_init (current_class_ref,\n+\t\t\t\t\t   TYPE_MAIN_DECL ($1),\n+\t\t\t\t\t   $3); }\n \t| typename_sub LEFT_RIGHT\n-\t\t{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),\n-\t\t\t\t      void_type_node); }\n+\t\t{ $$ = expand_member_init (current_class_ref,\n+\t\t\t\t\t   TYPE_MAIN_DECL ($1),\n+\t\t\t\t\t   void_type_node); }\n         | error\n+                { $$ = NULL_TREE }\n \t;\n \n identifier:\n@@ -1654,7 +1709,7 @@ nodecls:\n \t\t{\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n-\t\t  setup_vtbl_ptr ();\n+\t\t  setup_vtbl_ptr (NULL_TREE, NULL_TREE);\n \t\t}\n \t;\n \n@@ -2096,8 +2151,7 @@ fn.defpen:\n \tPRE_PARSED_FUNCTION_DECL\n \t\t{ start_function (NULL_TREE, $1->fndecl, NULL_TREE, \n \t\t\t\t  (SF_DEFAULT | SF_PRE_PARSED \n-\t\t\t\t   | SF_INCLASS_INLINE));\n-\t\t  reinit_parse_for_function (); }\n+\t\t\t\t   | SF_INCLASS_INLINE)); }\n \n pending_inline:\n \t  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error"}, {"sha": "902ebc524e0aaade8c438936b4cf09b1744c0278", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -104,7 +104,7 @@ static int push_tinst_level PARAMS ((tree));\n static void reopen_tinst_level PARAMS ((tree));\n static tree classtype_mangled_name PARAMS ((tree));\n static char *mangle_class_name_for_template PARAMS ((char *, tree, tree));\n-static tree tsubst_expr_values PARAMS ((tree, tree));\n+static tree tsubst_initializer_list PARAMS ((tree, tree));\n static int list_eq PARAMS ((tree, tree));\n static tree get_class_bindings PARAMS ((tree, tree, tree));\n static tree coerce_template_parms PARAMS ((tree, tree, tree, int, int));\n@@ -3009,7 +3009,7 @@ convert_nontype_argument (type, expr)\n \t\t|| !at_least_as_qualified_p (type_referred_to,\n \t\t\t\t\t     expr_type)\n \t\t|| !real_lvalue_p (expr))\n-\t      expr = error_mark_node;\n+\t      return error_mark_node;\n \t  }\n \n \tmark_addressable (expr);\n@@ -7145,14 +7145,19 @@ tsubst_expr (t, args, complain, in_decl)\n       break;\n \n     case CTOR_INITIALIZER:\n-      prep_stmt (t);\n-      current_member_init_list\n-\t= tsubst_expr_values (TREE_OPERAND (t, 0), args);\n-      current_base_init_list\n-\t= tsubst_expr_values (TREE_OPERAND (t, 1), args);\n-      setup_vtbl_ptr ();\n-      tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n-      break;\n+      {\n+\ttree member_init_list;\n+\ttree base_init_list;\n+\n+\tprep_stmt (t);\n+\tmember_init_list\n+\t  = tsubst_initializer_list (TREE_OPERAND (t, 0), args);\n+\tbase_init_list\n+\t  = tsubst_initializer_list (TREE_OPERAND (t, 1), args);\n+\tsetup_vtbl_ptr (member_init_list, base_init_list);\n+\ttsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n+\tbreak;\n+      }\n \n     case RETURN_STMT:\n       prep_stmt (t);\n@@ -9837,24 +9842,38 @@ instantiate_pending_templates ()\n   return instantiated_something;\n }\n \n-/* Substitute ARGVEC into T, which is a TREE_LIST.  In particular, it\n-   is an initializer list: the TREE_PURPOSEs are DECLs, and the\n-   TREE_VALUEs are initializer values.  Used by instantiate_decl.  */\n+/* Substitute ARGVEC into T, which is a list of initializers for\n+   either base class or a non-static data member.  The TREE_PURPOSEs\n+   are DECLs, and the TREE_VALUEs are the initializer values.  Used by\n+   instantiate_decl.  */\n \n static tree\n-tsubst_expr_values (t, argvec)\n+tsubst_initializer_list (t, argvec)\n      tree t, argvec;\n {\n   tree first = NULL_TREE;\n   tree *p = &first;\n \n   for (; t; t = TREE_CHAIN (t))\n     {\n-      tree pur = tsubst_copy (TREE_PURPOSE (t), argvec,\n-\t\t\t      /*complain=*/1, NULL_TREE);\n-      tree val = tsubst_expr (TREE_VALUE (t), argvec, /*complain=*/1, \n-\t\t\t      NULL_TREE);\n-      *p = build_tree_list (pur, val);\n+      tree decl;\n+      tree init;\n+      tree val;\n+\n+      decl = tsubst_copy (TREE_PURPOSE (t), argvec, /*complain=*/1,\n+\t\t\t  NULL_TREE);\n+      init = tsubst_expr (TREE_VALUE (t), argvec, /*complain=*/1,\n+\t\t\t  NULL_TREE);\n+\n+      if (!init)\n+\t;\n+      else if (TREE_CODE (init) == TREE_LIST)\n+\tfor (val = init; val; val = TREE_CHAIN (val))\n+\t  TREE_VALUE (val) = convert_from_reference (TREE_VALUE (val));\n+      else\n+\tinit = convert_from_reference (init);\n+\n+      *p = build_tree_list (decl, init);\n       p = &TREE_CHAIN (*p);\n     }\n   return first;"}, {"sha": "2621b8b2452974722a9940a98792608fb6efdfe2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -1235,7 +1235,9 @@ finish_named_return_value (return_id, init)\n    more than one virtual function call is made this function.  */\n \n void\n-setup_vtbl_ptr ()\n+setup_vtbl_ptr (member_init_list, base_init_list)\n+     tree member_init_list;\n+     tree base_init_list;\n {\n   my_friendly_assert (doing_semantic_analysis_p (), 19990919);\n \n@@ -1248,7 +1250,7 @@ setup_vtbl_ptr ()\n       if (processing_template_decl)\n \tadd_tree (build_min_nt\n \t\t  (CTOR_INITIALIZER,\n-\t\t   current_member_init_list, current_base_init_list));\n+\t\t   member_init_list, base_init_list));\n       else\n \t{\n \t  tree ctor_stmt;\n@@ -1259,7 +1261,7 @@ setup_vtbl_ptr ()\n \t  add_tree (ctor_stmt);\n \t  \n \t  /* And actually initialize the base-classes and members.  */\n-\t  emit_base_init ();\n+\t  emit_base_init (member_init_list, base_init_list);\n \t}\n     }\n   else if (DECL_DESTRUCTOR_P (current_function_decl)\n@@ -1776,7 +1778,6 @@ begin_function_definition (decl_specs, declarator)\n   deferred_type_access_control ();\n   type_lookups = error_mark_node;\n \n-  reinit_parse_for_function ();\n   /* The things we're about to see are not directly qualified by any\n      template headers we've seen thus far.  */\n   reset_specialization ();"}, {"sha": "27f7cd2243de11cc76068ef57d770b50464838a5", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ref3.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd74ca0bf2e6effbc70d576114f7fca2ff341f47/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref3.C?ref=fd74ca0bf2e6effbc70d576114f7fca2ff341f47", "patch": "@@ -0,0 +1,21 @@\n+// Origin: John Wilkinson <jfw@sgi.com>\n+\n+template <class T, int& Size> \n+struct Base {\n+    Base() : obj(Size) {}\n+    T obj;\n+};\n+\n+int globalInt = 5;\n+\n+struct A {\n+    A(int arg) : ia(arg) {}\n+    int ia;\n+};\n+\n+int main()\n+{\n+  Base<A, globalInt> ob;\n+  if (ob.obj.ia != 5)\n+    return 1;\n+}"}]}