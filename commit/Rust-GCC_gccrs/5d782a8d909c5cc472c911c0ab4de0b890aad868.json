{"sha": "5d782a8d909c5cc472c911c0ab4de0b890aad868", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3ODJhOGQ5MDljNWNjNDcyYzkxMWMwYWI0ZGUwYjg5MGFhZDg2OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-24T21:49:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-01-24T21:49:51Z"}, "message": "i386: prefer vpermilpd over vpermpd [PR93395]\n\nIn Agner Fog's tables, vpermilp[sd] with immediates seem to be\nmuch faster than vpermpd with immediate, for a good reason,\nthe former only permute something within the lanes and don't do anything\nintra-lane, while vpermpd can.  So, functionality-wise, vpermilpd\nis more efficient subset of vpermpd.  We use the same RTL for those\nthough (and also for certain broadcast).\n\nNow, the problem was that the vpermpd pattern appeared first in sse.md,\nfollowed by the broadcast patterns, followed by the vpermilp[sd].\nWhich means unless -mavx -mno-avx2, we'd emit vpermpd instead of the\nmore efficient alternatives.\n\nThe following patch reorders them, so that vpermpd comes last, if we\ncan match a broadcast, we do, if we can match a vpermilp[sd] that is not a\nbroadcast, we will, otherwise fall back (of course only if -mavx2) to\nvpermpd.\n\n2020-01-24  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/93395\n\t* config/i386/sse.md (*avx_vperm_broadcast_v4sf,\n\t*avx_vperm_broadcast_<mode>,\n\t<sse2_avx_avx512f>_vpermil<mode><mask_name>,\n\t*<sse2_avx_avx512f>_vpermilp<mode><mask_name>):\n\tMove before avx2_perm<mode>/avx512f_perm<mode>.\n\n\t* gcc.target/i386/pr93395.c: New test.\n\t* gcc.target/i386/avx512vl-vpermilpdi-1.c: Remove xfail.", "tree": {"sha": "d6f339ea0122beaeebf6c00eb33965c150142c3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f339ea0122beaeebf6c00eb33965c150142c3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d782a8d909c5cc472c911c0ab4de0b890aad868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d782a8d909c5cc472c911c0ab4de0b890aad868", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d782a8d909c5cc472c911c0ab4de0b890aad868", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d782a8d909c5cc472c911c0ab4de0b890aad868/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e5881e37771f1f58123e77c558adb3b90c8764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14e5881e37771f1f58123e77c558adb3b90c8764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14e5881e37771f1f58123e77c558adb3b90c8764"}], "stats": {"total": 373, "additions": 217, "deletions": 156}, "files": [{"sha": "b1b4632630620b2f3031ebd7e32aa3dbc4205fa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d782a8d909c5cc472c911c0ab4de0b890aad868", "patch": "@@ -1,5 +1,12 @@\n 2020-01-24  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/93395\n+\t* config/i386/sse.md (*avx_vperm_broadcast_v4sf,\n+\t*avx_vperm_broadcast_<mode>,\n+\t<sse2_avx_avx512f>_vpermil<mode><mask_name>,\n+\t*<sse2_avx_avx512f>_vpermilp<mode><mask_name>):\n+\tMove before avx2_perm<mode>/avx512f_perm<mode>.\n+\n \tPR target/93376\n \t* simplify-rtx.c (simplify_const_unary_operation,\n \tsimplify_const_binary_operation): Punt for mode precision above"}, {"sha": "f2f4a4e15159a1f07885c92bcbefa6671aaf67ce", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 158, "deletions": 154, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=5d782a8d909c5cc472c911c0ab4de0b890aad868", "patch": "@@ -19875,6 +19875,164 @@\n    (set_attr \"prefix\" \"<mask_prefix2>\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+;; Recognize broadcast as a vec_select as produced by builtin_vec_perm.\n+;; If it so happens that the input is in memory, use vbroadcast.\n+;; Otherwise use vpermilp (and in the case of 256-bit modes, vperm2f128).\n+(define_insn \"*avx_vperm_broadcast_v4sf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v,v,v\")\n+\t(vec_select:V4SF\n+\t  (match_operand:V4SF 1 \"nonimmediate_operand\" \"m,o,v\")\n+\t  (match_parallel 2 \"avx_vbroadcast_operand\"\n+\t    [(match_operand 3 \"const_int_operand\" \"C,n,n\")])))]\n+  \"TARGET_AVX\"\n+{\n+  int elt = INTVAL (operands[3]);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      operands[1] = adjust_address_nv (operands[1], SFmode, elt * 4);\n+      return \"vbroadcastss\\t{%1, %0|%0, %k1}\";\n+    case 2:\n+      operands[2] = GEN_INT (elt * 0x55);\n+      return \"vpermilps\\t{%2, %1, %0|%0, %1, %2}\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\" \"ssemov,ssemov,sselog1\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"0,0,1\")\n+   (set_attr \"prefix\" \"maybe_evex\")\n+   (set_attr \"mode\" \"SF,SF,V4SF\")])\n+\n+(define_insn_and_split \"*avx_vperm_broadcast_<mode>\"\n+  [(set (match_operand:VF_256 0 \"register_operand\" \"=v,v,v\")\n+\t(vec_select:VF_256\n+\t  (match_operand:VF_256 1 \"nonimmediate_operand\" \"m,o,?v\")\n+\t  (match_parallel 2 \"avx_vbroadcast_operand\"\n+\t    [(match_operand 3 \"const_int_operand\" \"C,n,n\")])))]\n+  \"TARGET_AVX\"\n+  \"#\"\n+  \"&& reload_completed && (<MODE>mode != V4DFmode || !TARGET_AVX2)\"\n+  [(set (match_dup 0) (vec_duplicate:VF_256 (match_dup 1)))]\n+{\n+  rtx op0 = operands[0], op1 = operands[1];\n+  int elt = INTVAL (operands[3]);\n+\n+  if (REG_P (op1))\n+    {\n+      int mask;\n+\n+      if (TARGET_AVX2 && elt == 0)\n+\t{\n+\t  emit_insn (gen_vec_dup<mode> (op0, gen_lowpart (<ssescalarmode>mode,\n+\t\t\t\t\t\t\t  op1)));\n+\t  DONE;\n+\t}\n+\n+      /* Shuffle element we care about into all elements of the 128-bit lane.\n+\t The other lane gets shuffled too, but we don't care.  */\n+      if (<MODE>mode == V4DFmode)\n+\tmask = (elt & 1 ? 15 : 0);\n+      else\n+\tmask = (elt & 3) * 0x55;\n+      emit_insn (gen_avx_vpermil<mode> (op0, op1, GEN_INT (mask)));\n+\n+      /* Shuffle the lane we care about into both lanes of the dest.  */\n+      mask = (elt / (<ssescalarnum> / 2)) * 0x11;\n+      if (EXT_REX_SSE_REG_P (op0))\n+\t{\n+\t  /* There is no EVEX VPERM2F128, but we can use either VBROADCASTSS\n+\t     or VSHUFF128.  */\n+\t  gcc_assert (<MODE>mode == V8SFmode);\n+\t  if ((mask & 1) == 0)\n+\t    emit_insn (gen_avx2_vec_dupv8sf (op0,\n+\t\t\t\t\t     gen_lowpart (V4SFmode, op0)));\n+\t  else\n+\t    emit_insn (gen_avx512vl_shuf_f32x4_1 (op0, op0, op0,\n+\t\t\t\t\t\t  GEN_INT (4), GEN_INT (5),\n+\t\t\t\t\t\t  GEN_INT (6), GEN_INT (7),\n+\t\t\t\t\t\t  GEN_INT (12), GEN_INT (13),\n+\t\t\t\t\t\t  GEN_INT (14), GEN_INT (15)));\n+\t  DONE;\n+\t}\n+\n+      emit_insn (gen_avx_vperm2f128<mode>3 (op0, op0, op0, GEN_INT (mask)));\n+      DONE;\n+    }\n+\n+  operands[1] = adjust_address (op1, <ssescalarmode>mode,\n+\t\t\t\telt * GET_MODE_SIZE (<ssescalarmode>mode));\n+})\n+\n+(define_expand \"<sse2_avx_avx512f>_vpermil<mode><mask_name>\"\n+  [(set (match_operand:VF2 0 \"register_operand\")\n+\t(vec_select:VF2\n+\t  (match_operand:VF2 1 \"nonimmediate_operand\")\n+\t  (match_operand:SI 2 \"const_0_to_255_operand\")))]\n+  \"TARGET_AVX && <mask_mode512bit_condition>\"\n+{\n+  int mask = INTVAL (operands[2]);\n+  rtx perm[<ssescalarnum>];\n+\n+  int i;\n+  for (i = 0; i < <ssescalarnum>; i = i + 2)\n+    {\n+      perm[i]     = GEN_INT (((mask >> i)       & 1) + i);\n+      perm[i + 1] = GEN_INT (((mask >> (i + 1)) & 1) + i);\n+    }\n+\n+  operands[2]\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n+})\n+\n+(define_expand \"<sse2_avx_avx512f>_vpermil<mode><mask_name>\"\n+  [(set (match_operand:VF1 0 \"register_operand\")\n+\t(vec_select:VF1\n+\t  (match_operand:VF1 1 \"nonimmediate_operand\")\n+\t  (match_operand:SI 2 \"const_0_to_255_operand\")))]\n+  \"TARGET_AVX && <mask_mode512bit_condition>\"\n+{\n+  int mask = INTVAL (operands[2]);\n+  rtx perm[<ssescalarnum>];\n+\n+  int i;\n+  for (i = 0; i < <ssescalarnum>; i = i + 4)\n+    {\n+      perm[i]     = GEN_INT (((mask >> 0) & 3) + i);\n+      perm[i + 1] = GEN_INT (((mask >> 2) & 3) + i);\n+      perm[i + 2] = GEN_INT (((mask >> 4) & 3) + i);\n+      perm[i + 3] = GEN_INT (((mask >> 6) & 3) + i);\n+    }\n+\n+  operands[2]\n+    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n+})\n+\n+;; This pattern needs to come before the avx2_perm*/avx512f_perm*\n+;; patterns, as they have the same RTL representation (vpermilp*\n+;; being a subset of what vpermp* can do), but vpermilp* has shorter\n+;; latency as it never crosses lanes.\n+(define_insn \"*<sse2_avx_avx512f>_vpermilp<mode><mask_name>\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n+\t(vec_select:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"vm\")\n+\t  (match_parallel 2 \"\"\n+\t    [(match_operand 3 \"const_int_operand\")])))]\n+  \"TARGET_AVX && <mask_mode512bit_condition>\n+   && avx_vpermilp_parallel (operands[2], <MODE>mode)\"\n+{\n+  int mask = avx_vpermilp_parallel (operands[2], <MODE>mode) - 1;\n+  operands[2] = GEN_INT (mask);\n+  return \"vpermil<ssemodesuffix>\\t{%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"<mask_prefix>\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n (define_expand \"avx2_perm<mode>\"\n   [(match_operand:VI8F_256 0 \"register_operand\")\n    (match_operand:VI8F_256 1 \"nonimmediate_operand\")\n@@ -20376,160 +20534,6 @@\n    (set_attr \"prefix\" \"evex\")\n    (set_attr \"mode\" \"XI\")])\n \n-;; Recognize broadcast as a vec_select as produced by builtin_vec_perm.\n-;; If it so happens that the input is in memory, use vbroadcast.\n-;; Otherwise use vpermilp (and in the case of 256-bit modes, vperm2f128).\n-(define_insn \"*avx_vperm_broadcast_v4sf\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=v,v,v\")\n-\t(vec_select:V4SF\n-\t  (match_operand:V4SF 1 \"nonimmediate_operand\" \"m,o,v\")\n-\t  (match_parallel 2 \"avx_vbroadcast_operand\"\n-\t    [(match_operand 3 \"const_int_operand\" \"C,n,n\")])))]\n-  \"TARGET_AVX\"\n-{\n-  int elt = INTVAL (operands[3]);\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-      operands[1] = adjust_address_nv (operands[1], SFmode, elt * 4);\n-      return \"vbroadcastss\\t{%1, %0|%0, %k1}\";\n-    case 2:\n-      operands[2] = GEN_INT (elt * 0x55);\n-      return \"vpermilps\\t{%2, %1, %0|%0, %1, %2}\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"ssemov,ssemov,sselog1\")\n-   (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"length_immediate\" \"0,0,1\")\n-   (set_attr \"prefix\" \"maybe_evex\")\n-   (set_attr \"mode\" \"SF,SF,V4SF\")])\n-\n-(define_insn_and_split \"*avx_vperm_broadcast_<mode>\"\n-  [(set (match_operand:VF_256 0 \"register_operand\" \"=v,v,v\")\n-\t(vec_select:VF_256\n-\t  (match_operand:VF_256 1 \"nonimmediate_operand\" \"m,o,?v\")\n-\t  (match_parallel 2 \"avx_vbroadcast_operand\"\n-\t    [(match_operand 3 \"const_int_operand\" \"C,n,n\")])))]\n-  \"TARGET_AVX\"\n-  \"#\"\n-  \"&& reload_completed && (<MODE>mode != V4DFmode || !TARGET_AVX2)\"\n-  [(set (match_dup 0) (vec_duplicate:VF_256 (match_dup 1)))]\n-{\n-  rtx op0 = operands[0], op1 = operands[1];\n-  int elt = INTVAL (operands[3]);\n-\n-  if (REG_P (op1))\n-    {\n-      int mask;\n-\n-      if (TARGET_AVX2 && elt == 0)\n-\t{\n-\t  emit_insn (gen_vec_dup<mode> (op0, gen_lowpart (<ssescalarmode>mode,\n-\t\t\t\t\t\t\t  op1)));\n-\t  DONE;\n-\t}\n-\n-      /* Shuffle element we care about into all elements of the 128-bit lane.\n-\t The other lane gets shuffled too, but we don't care.  */\n-      if (<MODE>mode == V4DFmode)\n-\tmask = (elt & 1 ? 15 : 0);\n-      else\n-\tmask = (elt & 3) * 0x55;\n-      emit_insn (gen_avx_vpermil<mode> (op0, op1, GEN_INT (mask)));\n-\n-      /* Shuffle the lane we care about into both lanes of the dest.  */\n-      mask = (elt / (<ssescalarnum> / 2)) * 0x11;\n-      if (EXT_REX_SSE_REG_P (op0))\n-\t{\n-\t  /* There is no EVEX VPERM2F128, but we can use either VBROADCASTSS\n-\t     or VSHUFF128.  */\n-\t  gcc_assert (<MODE>mode == V8SFmode);\n-\t  if ((mask & 1) == 0)\n-\t    emit_insn (gen_avx2_vec_dupv8sf (op0,\n-\t\t\t\t\t     gen_lowpart (V4SFmode, op0)));\n-\t  else\n-\t    emit_insn (gen_avx512vl_shuf_f32x4_1 (op0, op0, op0,\n-\t\t\t\t\t\t  GEN_INT (4), GEN_INT (5),\n-\t\t\t\t\t\t  GEN_INT (6), GEN_INT (7),\n-\t\t\t\t\t\t  GEN_INT (12), GEN_INT (13),\n-\t\t\t\t\t\t  GEN_INT (14), GEN_INT (15)));\n-\t  DONE;\n-\t}\n-\n-      emit_insn (gen_avx_vperm2f128<mode>3 (op0, op0, op0, GEN_INT (mask)));\n-      DONE;\n-    }\n-\n-  operands[1] = adjust_address (op1, <ssescalarmode>mode,\n-\t\t\t\telt * GET_MODE_SIZE (<ssescalarmode>mode));\n-})\n-\n-(define_expand \"<sse2_avx_avx512f>_vpermil<mode><mask_name>\"\n-  [(set (match_operand:VF2 0 \"register_operand\")\n-\t(vec_select:VF2\n-\t  (match_operand:VF2 1 \"nonimmediate_operand\")\n-\t  (match_operand:SI 2 \"const_0_to_255_operand\")))]\n-  \"TARGET_AVX && <mask_mode512bit_condition>\"\n-{\n-  int mask = INTVAL (operands[2]);\n-  rtx perm[<ssescalarnum>];\n-\n-  int i;\n-  for (i = 0; i < <ssescalarnum>; i = i + 2)\n-    {\n-      perm[i]     = GEN_INT (((mask >> i)       & 1) + i);\n-      perm[i + 1] = GEN_INT (((mask >> (i + 1)) & 1) + i);\n-    }\n-\n-  operands[2]\n-    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n-})\n-\n-(define_expand \"<sse2_avx_avx512f>_vpermil<mode><mask_name>\"\n-  [(set (match_operand:VF1 0 \"register_operand\")\n-\t(vec_select:VF1\n-\t  (match_operand:VF1 1 \"nonimmediate_operand\")\n-\t  (match_operand:SI 2 \"const_0_to_255_operand\")))]\n-  \"TARGET_AVX && <mask_mode512bit_condition>\"\n-{\n-  int mask = INTVAL (operands[2]);\n-  rtx perm[<ssescalarnum>];\n-\n-  int i;\n-  for (i = 0; i < <ssescalarnum>; i = i + 4)\n-    {\n-      perm[i]     = GEN_INT (((mask >> 0) & 3) + i);\n-      perm[i + 1] = GEN_INT (((mask >> 2) & 3) + i);\n-      perm[i + 2] = GEN_INT (((mask >> 4) & 3) + i);\n-      perm[i + 3] = GEN_INT (((mask >> 6) & 3) + i);\n-    }\n-\n-  operands[2]\n-    = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (<ssescalarnum>, perm));\n-})\n-\n-(define_insn \"*<sse2_avx_avx512f>_vpermilp<mode><mask_name>\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n-\t(vec_select:VF\n-\t  (match_operand:VF 1 \"nonimmediate_operand\" \"vm\")\n-\t  (match_parallel 2 \"\"\n-\t    [(match_operand 3 \"const_int_operand\")])))]\n-  \"TARGET_AVX && <mask_mode512bit_condition>\n-   && avx_vpermilp_parallel (operands[2], <MODE>mode)\"\n-{\n-  int mask = avx_vpermilp_parallel (operands[2], <MODE>mode) - 1;\n-  operands[2] = GEN_INT (mask);\n-  return \"vpermil<ssemodesuffix>\\t{%2, %1, %0<mask_operand4>|%0<mask_operand4>, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"prefix\" \"<mask_prefix>\")\n-   (set_attr \"mode\" \"<sseinsnmode>\")])\n-\n (define_insn \"<sse2_avx_avx512f>_vpermilvar<mode>3<mask_name>\"\n   [(set (match_operand:VF 0 \"register_operand\" \"=v\")\n \t(unspec:VF"}, {"sha": "1fc95b334a84aa377b8498c6145af54c8d7250bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d782a8d909c5cc472c911c0ab4de0b890aad868", "patch": "@@ -1,3 +1,9 @@\n+2020-01-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/93395\n+\t* gcc.target/i386/pr93395.c: New test.\n+\t* gcc.target/i386/avx512vl-vpermilpdi-1.c: Remove xfail.\n+\n 2020-01-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/93299 - ICE in tsubst_copy with parenthesized expression."}, {"sha": "cbbec3a1849710ad273d9781c576d31f537c6e3e", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-vpermilpdi-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vpermilpdi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vpermilpdi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vpermilpdi-1.c?ref=5d782a8d909c5cc472c911c0ab4de0b890aad868", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-mavx512vl -O2\" } */\n-/* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*13\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 { xfail *-*-* } } } */\n-/* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*13\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*13\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*13\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*3\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpermilpd\\[ \\\\t\\]+\\[^\\{\\n\\]*3\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n "}, {"sha": "bdc3a5531edb52fbbd5c7d977671b976d999a485", "filename": "gcc/testsuite/gcc.target/i386/pr93395.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93395.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d782a8d909c5cc472c911c0ab4de0b890aad868/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93395.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr93395.c?ref=5d782a8d909c5cc472c911c0ab4de0b890aad868", "patch": "@@ -0,0 +1,44 @@\n+/* PR target/93395 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx512f -masm=att\" } */\n+/* { dg-final { scan-assembler-times \"vpermilpd\\t.5, %ymm\" 3 } } */\n+/* { dg-final { scan-assembler-times \"vpermilpd\\t.85, %zmm\" 3 } } */\n+/* { dg-final { scan-assembler-not \"vpermpd\\t\" } } */\n+\n+#include <immintrin.h>\n+\n+__m256d\n+foo1 (__m256d a)\n+{\n+  return _mm256_permute4x64_pd (a, 177);\n+}\n+\n+__m256d\n+foo2 (__m256d a)\n+{\n+  return _mm256_permute_pd (a, 5);\n+}\n+\n+__m256d\n+foo3 (__m256d a)\n+{\n+  return __builtin_shuffle (a, (__v4di) { 1, 0, 3, 2 });\n+}\n+\n+__m512d\n+foo4 (__m512d a)\n+{\n+  return _mm512_permutex_pd (a, 177);\n+}\n+\n+__m512d\n+foo5 (__m512d a)\n+{\n+  return _mm512_permute_pd (a, 85);\n+}\n+\n+__m512d\n+foo6 (__m512d a)\n+{\n+  return __builtin_shuffle (a, (__v8di) { 1, 0, 3, 2, 5, 4, 7, 6 });\n+}"}]}