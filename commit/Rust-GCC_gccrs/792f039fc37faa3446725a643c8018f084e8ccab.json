{"sha": "792f039fc37faa3446725a643c8018f084e8ccab", "node_id": "C_kwDOANBUbNoAKDc5MmYwMzlmYzM3ZmFhMzQ0NjcyNWE2NDNjODAxOGYwODRlOGNjYWI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-24T20:38:22Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-24T20:38:22Z"}, "message": "analyzer: handle \"pipe\" and \"pipe2\" [PR106300]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106300\n\t* engine.cc (impl_region_model_context::get_fd_map): New.\n\t* exploded-graph.h (impl_region_model_context::get_fd_map): New\n\tdecl.\n\t* region-model-impl-calls.cc (region_model::impl_call_pipe): New.\n\t* region-model.cc (region_model::update_for_int_cst_return): New,\n\tbased on...\n\t(region_model::update_for_zero_return): ...this.  Reimplement in\n\tterms of the former.\n\t(region_model::on_call_pre): Handle \"pipe\" and \"pipe2\".\n\t(region_model::on_call_post): Likewise.\n\t* region-model.h (region_model::impl_call_pipe): New decl.\n\t(region_model::update_for_int_cst_return): New decl.\n\t(region_model::mark_as_valid_fd): New decl.\n\t(region_model_context::get_fd_map): New pure virtual fn.\n\t(noop_region_model_context::get_fd_map): New.\n\t(region_model_context_decorator::get_fd_map): New.\n\t* sm-fd.cc: Include \"analyzer/program-state.h\".\n\t(fd_state_machine::describe_state_change): Handle transitions from\n\tstart state to valid states.\n\t(fd_state_machine::mark_as_valid_fd): New.\n\t(fd_state_machine::on_stmt): Add missing return for \"creat\".\n\t(region_model::mark_as_valid_fd): New.\n\ngcc/ChangeLog:\n\tPR analyzer/106300\n\t* doc/invoke.texi (Static Analyzer Options): Add \"pipe\" and\n\t\"pipe2\" to the list of functions the analyzer has hardcoded\n\tknowledge of.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106300\n\t* gcc.dg/analyzer/pipe-1.c: New test.\n\t* gcc.dg/analyzer/pipe-glibc.c: New test.\n\t* gcc.dg/analyzer/pipe-manpages.c: New test.\n\t* gcc.dg/analyzer/pipe2-1.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "d6f5bfae9af0528c090314d46b2c14859640d221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6f5bfae9af0528c090314d46b2c14859640d221"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792f039fc37faa3446725a643c8018f084e8ccab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792f039fc37faa3446725a643c8018f084e8ccab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792f039fc37faa3446725a643c8018f084e8ccab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792f039fc37faa3446725a643c8018f084e8ccab/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "244021b6c1a7bdeb777874ddc2ebcecb95610ef1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/244021b6c1a7bdeb777874ddc2ebcecb95610ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/244021b6c1a7bdeb777874ddc2ebcecb95610ef1"}], "stats": {"total": 429, "additions": 420, "deletions": 9}, "files": [{"sha": "a664a99eb78e8484bb4d7651193e2582f1432863", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -228,6 +228,21 @@ impl_region_model_context::get_malloc_map (sm_state_map **out_smap,\n   return true;\n }\n \n+bool\n+impl_region_model_context::get_fd_map (sm_state_map **out_smap,\n+\t\t\t\t       const state_machine **out_sm,\n+\t\t\t\t       unsigned *out_sm_idx)\n+{\n+  unsigned fd_sm_idx;\n+  if (!m_ext_state.get_sm_idx_by_name (\"file-descriptor\", &fd_sm_idx))\n+    return false;\n+\n+  *out_smap = m_new_state->m_checker_states[fd_sm_idx];\n+  *out_sm = &m_ext_state.get_sm (fd_sm_idx);\n+  *out_sm_idx = fd_sm_idx;\n+  return true;\n+}\n+\n bool\n impl_region_model_context::get_taint_map (sm_state_map **out_smap,\n \t\t\t\t\t  const state_machine **out_sm,"}, {"sha": "ad278e277dc0c8b72cd883034b9d21c136b7e14c", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -96,6 +96,9 @@ class impl_region_model_context : public region_model_context\n   {\n     return &m_ext_state;\n   }\n+  bool get_fd_map (sm_state_map **out_smap,\n+\t\t   const state_machine **out_sm,\n+\t\t   unsigned *out_sm_idx) final override;\n   bool get_malloc_map (sm_state_map **out_smap,\n \t\t       const state_machine **out_sm,\n \t\t       unsigned *out_sm_idx) final override;"}, {"sha": "52c4205cbeb52cb0cc54c984e15adafa81ab1309", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -563,6 +563,76 @@ region_model::impl_call_memset (const call_details &cd)\n   fill_region (sized_dest_reg, fill_value_u8);\n }\n \n+/* Handle the on_call_post part of \"pipe\".  */\n+\n+void\n+region_model::impl_call_pipe (const call_details &cd)\n+{\n+  class failure : public failed_call_info\n+  {\n+  public:\n+    failure (const call_details &cd) : failed_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      /* Return -1; everything else is unchanged.  */\n+      const call_details cd (get_call_details (model, ctxt));\n+      model->update_for_int_cst_return (cd, -1, true);\n+      return true;\n+    }\n+  };\n+\n+  class success : public success_call_info\n+  {\n+  public:\n+    success (const call_details &cd) : success_call_info (cd) {}\n+\n+    bool update_model (region_model *model,\n+\t\t       const exploded_edge *,\n+\t\t       region_model_context *ctxt) const final override\n+    {\n+      const call_details cd (get_call_details (model, ctxt));\n+\n+      /* Return 0.  */\n+      model->update_for_zero_return (cd, true);\n+\n+      /* Update fd array.  */\n+      region_model_manager *mgr = cd.get_manager ();\n+      tree arr_tree = cd.get_arg_tree (0);\n+      const svalue *arr_sval = cd.get_arg_svalue (0);\n+      for (int idx = 0; idx < 2; idx++)\n+\t{\n+\t  const region *arr_reg\n+\t    = model->deref_rvalue (arr_sval, arr_tree, cd.get_ctxt ());\n+\t  const svalue *idx_sval\n+\t    = mgr->get_or_create_int_cst (integer_type_node, idx);\n+\t  const region *element_reg\n+\t    = mgr->get_element_region (arr_reg, integer_type_node, idx_sval);\n+\t  conjured_purge p (model, cd.get_ctxt ());\n+\t  const svalue *fd_sval\n+\t    = mgr->get_or_create_conjured_svalue (integer_type_node,\n+\t\t\t\t\t\t  cd.get_call_stmt (),\n+\t\t\t\t\t\t  element_reg,\n+\t\t\t\t\t\t  p);\n+\t  model->set_value (element_reg, fd_sval, cd.get_ctxt ());\n+\t  model->mark_as_valid_fd (fd_sval, cd.get_ctxt ());\n+\n+\t}\n+      return true;\n+    }\n+  };\n+\n+  /* Body of region_model::impl_call_pipe.  */\n+  if (cd.get_ctxt ())\n+    {\n+      cd.get_ctxt ()->bifurcate (new failure (cd));\n+      cd.get_ctxt ()->bifurcate (new success (cd));\n+      cd.get_ctxt ()->terminate_path ();\n+    }\n+}\n+\n /* A subclass of pending_diagnostic for complaining about 'putenv'\n    called on an auto var.  */\n "}, {"sha": "608fcd58fab0e868b875e9119b4d04567e9ee31d", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -1976,23 +1976,36 @@ maybe_get_const_fn_result (const call_details &cd)\n   return sval;\n }\n \n-/* Update this model for an outcome of a call that returns zero.\n+/* Update this model for an outcome of a call that returns a specific\n+   integer constant.\n    If UNMERGEABLE, then make the result unmergeable, e.g. to prevent\n    the state-merger code from merging success and failure outcomes.  */\n \n void\n-region_model::update_for_zero_return (const call_details &cd,\n-\t\t\t\t      bool unmergeable)\n+region_model::update_for_int_cst_return (const call_details &cd,\n+\t\t\t\t\t int retval,\n+\t\t\t\t\t bool unmergeable)\n {\n   if (!cd.get_lhs_type ())\n     return;\n   const svalue *result\n-    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), 0);\n+    = m_mgr->get_or_create_int_cst (cd.get_lhs_type (), retval);\n   if (unmergeable)\n     result = m_mgr->get_or_create_unmergeable (result);\n   set_value (cd.get_lhs_region (), result, cd.get_ctxt ());\n }\n \n+/* Update this model for an outcome of a call that returns zero.\n+   If UNMERGEABLE, then make the result unmergeable, e.g. to prevent\n+   the state-merger code from merging success and failure outcomes.  */\n+\n+void\n+region_model::update_for_zero_return (const call_details &cd,\n+\t\t\t\t      bool unmergeable)\n+{\n+  update_for_int_cst_return (cd, 0, unmergeable);\n+}\n+\n /* Update this model for an outcome of a call that returns non-zero.  */\n \n void\n@@ -2302,6 +2315,14 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  impl_call_memset (cd);\n \t  return false;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"pipe\", call, 1)\n+\t       || is_named_call_p (callee_fndecl, \"pipe2\", call, 2))\n+\t{\n+\t  /* Handle in \"on_call_post\"; bail now so that fd array\n+\t     is left untouched so that we can detect use-of-uninit\n+\t     for the case where the call fails.  */\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"putenv\", call, 1)\n \t       && POINTER_TYPE_P (cd.get_arg_type (0)))\n \t{\n@@ -2382,6 +2403,12 @@ region_model::on_call_post (const gcall *call,\n \t  impl_call_operator_delete (cd);\n \t  return;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"pipe\", call, 1)\n+\t       || is_named_call_p (callee_fndecl, \"pipe2\", call, 2))\n+\t{\n+\t  impl_call_pipe (cd);\n+\t  return;\n+\t}\n       /* Was this fndecl referenced by\n \t __attribute__((malloc(FOO)))?  */\n       if (lookup_attribute (\"*dealloc\", DECL_ATTRIBUTES (callee_fndecl)))"}, {"sha": "d849e0d774b390978fbfadaeeb455fb0780a72e5", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -356,6 +356,7 @@ class region_model\n   void impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n   void impl_call_memset (const call_details &cd);\n+  void impl_call_pipe (const call_details &cd);\n   void impl_call_putenv (const call_details &cd);\n   void impl_call_realloc (const call_details &cd);\n   void impl_call_strchr (const call_details &cd);\n@@ -373,6 +374,9 @@ class region_model\n \n   const svalue *maybe_get_copy_bounds (const region *src_reg,\n \t\t\t\t       const svalue *num_bytes_sval);\n+  void update_for_int_cst_return (const call_details &cd,\n+\t\t\t\t  int retval,\n+\t\t\t\t  bool unmergeable);\n   void update_for_zero_return (const call_details &cd,\n \t\t\t       bool unmergeable);\n   void update_for_nonzero_return (const call_details &cd);\n@@ -539,6 +543,9 @@ class region_model\n \t\t\t\t      const region *src_reg,\n \t\t\t\t      region_model_context *ctxt);\n \n+  /* Implemented in sm-fd.cc  */\n+  void mark_as_valid_fd (const svalue *sval, region_model_context *ctxt);\n+\n   /* Implemented in sm-malloc.cc  */\n   void on_realloc_with_move (const call_details &cd,\n \t\t\t     const svalue *old_ptr_sval,\n@@ -730,8 +737,12 @@ class region_model_context\n \n   virtual const extrinsic_state *get_ext_state () const = 0;\n \n-  /* Hook for clients to access the \"malloc\" state machine in\n+  /* Hook for clients to access the \"fd\" state machine in\n      any underlying program_state.  */\n+  virtual bool get_fd_map (sm_state_map **out_smap,\n+\t\t\t   const state_machine **out_sm,\n+\t\t\t   unsigned *out_sm_idx) = 0;\n+  /* Likewise for the \"malloc\" state machine.  */\n   virtual bool get_malloc_map (sm_state_map **out_smap,\n \t\t\t       const state_machine **out_sm,\n \t\t\t       unsigned *out_sm_idx) = 0;\n@@ -785,6 +796,12 @@ class noop_region_model_context : public region_model_context\n \n   const extrinsic_state *get_ext_state () const override { return NULL; }\n \n+  bool get_fd_map (sm_state_map **,\n+\t\t   const state_machine **,\n+\t\t   unsigned *) override\n+  {\n+    return false;\n+  }\n   bool get_malloc_map (sm_state_map **,\n \t\t       const state_machine **,\n \t\t       unsigned *) override\n@@ -912,6 +929,13 @@ class region_model_context_decorator : public region_model_context\n     return m_inner->get_ext_state ();\n   }\n \n+  bool get_fd_map (sm_state_map **out_smap,\n+\t\t   const state_machine **out_sm,\n+\t\t   unsigned *out_sm_idx) override\n+  {\n+    return m_inner->get_fd_map (out_smap, out_sm, out_sm_idx);\n+  }\n+\n   bool get_malloc_map (sm_state_map **out_smap,\n \t\t       const state_machine **out_sm,\n \t\t       unsigned *out_sm_idx) override"}, {"sha": "8a4c2088c742a99ff07dcd83d18b76aca47d7f4d", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"bitmap.h\"\n+#include \"analyzer/program-state.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -121,6 +122,12 @@ class fd_state_machine : public state_machine\n   /* Function for one-to-one correspondence between valid\n      and unchecked states.  */\n   state_t valid_to_unchecked_state (state_t state) const;\n+\n+  void mark_as_valid_fd (region_model *model,\n+\t\t\t sm_state_map *smap,\n+\t\t\t const svalue *fd_sval,\n+\t\t\t const extrinsic_state &ext_state) const;\n+\n   /* State for a constant file descriptor (>= 0) */\n   state_t m_constant_fd;\n \n@@ -201,15 +208,19 @@ class fd_diagnostic : public pending_diagnostic\n   describe_state_change (const evdesc::state_change &change) override\n   {\n     if (change.m_old_state == m_sm.get_start_state ()\n-\t&& m_sm.is_unchecked_fd_p (change.m_new_state))\n+\t&& (m_sm.is_unchecked_fd_p (change.m_new_state)\n+\t    || m_sm.is_valid_fd_p (change.m_new_state)))\n       {\n-\tif (change.m_new_state == m_sm.m_unchecked_read_write)\n+\tif (change.m_new_state == m_sm.m_unchecked_read_write\n+\t    || change.m_new_state == m_sm.m_valid_read_write)\n \t  return change.formatted_print (\"opened here as read-write\");\n \n-\tif (change.m_new_state == m_sm.m_unchecked_read_only)\n+\tif (change.m_new_state == m_sm.m_unchecked_read_only\n+\t    || change.m_new_state == m_sm.m_valid_read_only)\n \t  return change.formatted_print (\"opened here as read-only\");\n \n-\tif (change.m_new_state == m_sm.m_unchecked_write_only)\n+\tif (change.m_new_state == m_sm.m_unchecked_write_only\n+\t    || change.m_new_state == m_sm.m_valid_write_only)\n \t  return change.formatted_print (\"opened here as write-only\");\n       }\n \n@@ -748,6 +759,15 @@ fd_state_machine::valid_to_unchecked_state (state_t state) const\n   return NULL;\n }\n \n+void\n+fd_state_machine::mark_as_valid_fd (region_model *model,\n+\t\t\t\t    sm_state_map *smap,\n+\t\t\t\t    const svalue *fd_sval,\n+\t\t\t\t    const extrinsic_state &ext_state) const\n+{\n+  smap->set_state (model, fd_sval, m_valid_read_write, NULL, ext_state);\n+}\n+\n bool\n fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \t\t\t   const gimple *stmt) const\n@@ -764,6 +784,7 @@ fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n \tif (is_named_call_p (callee_fndecl, \"creat\", call, 2))\n \t  {\n \t    on_creat (sm_ctxt, node, stmt, call);\n+\t    return true;\n \t  } // \"creat\"\n \n \tif (is_named_call_p (callee_fndecl, \"close\", call, 1))\n@@ -1186,6 +1207,33 @@ make_fd_state_machine (logger *logger)\n {\n   return new fd_state_machine (logger);\n }\n+\n+/* Specialcase hook for handling pipe, for use by\n+   region_model::impl_call_pipe::success::update_model.  */\n+\n+void\n+region_model::mark_as_valid_fd (const svalue *sval, region_model_context *ctxt)\n+{\n+  if (!ctxt)\n+    return;\n+  const extrinsic_state *ext_state = ctxt->get_ext_state ();\n+  if (!ext_state)\n+    return;\n+\n+  sm_state_map *smap;\n+  const state_machine *sm;\n+  unsigned sm_idx;\n+  if (!ctxt->get_fd_map (&smap, &sm, &sm_idx))\n+    return;\n+\n+  gcc_assert (smap);\n+  gcc_assert (sm);\n+\n+  const fd_state_machine &fd_sm = (const fd_state_machine &)*sm;\n+\n+  fd_sm.mark_as_valid_fd (this, smap, sval, *ext_state);\n+}\n+\n } // namespace ana\n \n #endif // ENABLE_ANALYZER"}, {"sha": "d49c1374d06bdde11066d2c94049581883cb6bda", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -10459,6 +10459,7 @@ of the following functions for working with file descriptors:\n @item @code{close}\n @item @code{creat}\n @item @code{dup}, @code{dup2} and @code{dup3}\n+@item @code{pipe}, and @code{pipe2}\n @item @code{read}\n @item @code{write}\n @end itemize"}, {"sha": "6b95442e3227b3852d6e40977a567c42ee8c818d", "filename": "gcc/testsuite/gcc.dg/analyzer/pipe-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-1.c?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -0,0 +1,38 @@\n+#include \"analyzer-decls.h\"\n+\n+extern int pipe(int pipefd[2]);\n+extern int close(int fd);\n+\n+void\n+test_leak (void)\n+{\n+  int fds[2];\n+  if (pipe (fds) == -1) /* { dg-message \"when 'pipe' succeeds\" } */\n+    /* { dg-message \"opened here as read-write\" \"sm msg\" { target *-*-* } .-1 }} */\n+    return;\n+} /* { dg-line leak } */\n+/* { dg-warning \"leak of file descriptor 'fds\\\\\\[0\\\\\\]'\" \"leak of 0\" { target *-*-* } leak } */\n+/* { dg-warning \"leak of file descriptor 'fds\\\\\\[1\\\\\\]'\" \"leak of 1\" { target *-*-* } leak } */\n+/* { dg-message \"'fds\\\\\\[0\\\\\\]' leaks here\" \"final msg 0\" { target *-*-* } leak }} */\n+/* { dg-message \"'fds\\\\\\[1\\\\\\]' leaks here\" \"final msg 1\" { target *-*-* } leak }} */\n+\n+void\n+test_close (void)\n+{\n+  int fds[2];\n+  if (pipe (fds) == -1)\n+    return;\n+  __analyzer_describe (0, fds[0]); /* { dg-warning \"CONJURED\" } */\n+  __analyzer_describe (0, fds[1]); /* { dg-warning \"CONJURED\" } */\n+  close (fds[0]);\n+  close (fds[1]);\n+}\n+\n+void\n+test_unchecked (void)\n+{\n+  int fds[2];\n+  pipe (fds); /* { dg-message \"when 'pipe' fails\" } */\n+  close (fds[0]); /* { dg-warning \"use of uninitialized value 'fds\\\\\\[0\\\\\\]'\" } */\n+  close (fds[1]); /* { dg-warning \"use of uninitialized value 'fds\\\\\\[1\\\\\\]'\" } */\n+}"}, {"sha": "a8546ea9549443da0f2250cfbe1635bd24784453", "filename": "gcc/testsuite/gcc.dg/analyzer/pipe-glibc.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-glibc.c?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -0,0 +1,71 @@\n+/* Example of pipe usage from glibc manual.  */\n+\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* Read characters from the pipe and echo them to stdout. */\n+\n+void\n+read_from_pipe (int file)\n+{\n+  FILE *stream;\n+  int c;\n+  stream = fdopen (file, \"r\");\n+  while ((c = fgetc (stream)) != EOF)\n+    putchar (c);\n+  fclose (stream);\n+}\n+\n+/* Write some random text to the pipe. */\n+\n+void\n+write_to_pipe (int file)\n+{\n+  FILE *stream;\n+  stream = fdopen (file, \"w\");\n+  fprintf (stream, \"hello, world!\\n\");\n+  fprintf (stream, \"goodbye, world!\\n\");\n+  fclose (stream);\n+}\n+\n+int\n+main (void)\n+{\n+  pid_t pid;\n+  int mypipe[2];\n+\n+  /* Create the pipe. */\n+  if (pipe (mypipe))\n+    {\n+      fprintf (stderr, \"Pipe failed.\\n\");\n+      return EXIT_FAILURE;\n+    }\n+\n+\n+  /* Create the child process. */\n+  pid = fork ();\n+  if (pid == (pid_t) 0)\n+    {\n+      /* This is the child process.\n+         Close other end first. */\n+      close (mypipe[1]);\n+      read_from_pipe (mypipe[0]);\n+      return EXIT_SUCCESS;\n+    }\n+  else if (pid < (pid_t) 0)\n+    {\n+      /* The fork failed. */\n+      fprintf (stderr, \"Fork failed.\\n\");\n+      return EXIT_FAILURE;\n+    }\n+  else\n+    {\n+      /* This is the parent process.\n+         Close other end first. */\n+      close (mypipe[0]);\n+      write_to_pipe (mypipe[1]);\n+      return EXIT_SUCCESS;\n+    }\n+}"}, {"sha": "6b9ae4d260281aa05beac90661f06bca59d0c7be", "filename": "gcc/testsuite/gcc.dg/analyzer/pipe-manpages.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-manpages.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-manpages.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe-manpages.c?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -0,0 +1,76 @@\n+/* Example of \"pipe\" from release 5.13 of the Linux man-pages project.\n+\n+Copyright (C) 2005, 2008, Michael Kerrisk <mtk.manpages@gmail.com>\n+(A few fragments remain from an earlier (1992) version by\n+Drew Eckhardt <drew@cs.colorado.edu>.)\n+\n+Permission is granted to make and distribute verbatim copies of this\n+manual provided the copyright notice and this permission notice are\n+preserved on all copies.\n+\n+Permission is granted to copy and distribute modified versions of this\n+manual under the conditions for verbatim copying, provided that the\n+entire resulting derived work is distributed under the terms of a\n+permission notice identical to this one.\n+\n+Since the Linux kernel and libraries are constantly changing, this\n+manual page may be incorrect or out-of-date.  The author(s) assume no\n+responsibility for errors or omissions, or for damages resulting from\n+the use of the information contained herein.  The author(s) may not\n+have taken the same level of care in the production of this manual,\n+which is licensed free of charge, as they might when working\n+professionally.\n+\n+Formatted or processed versions of this manual, if unaccompanied by\n+the source, must acknowledge the copyright and authors of this work.\n+\n+ */\n+\n+#include <sys/types.h>\n+#include <sys/wait.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <string.h>\n+\n+int\n+main(int argc, char *argv[])\n+{\n+  int pipefd[2];\n+  pid_t cpid;\n+  char buf;\n+\n+  if (argc != 2) {\n+    fprintf(stderr, \"Usage: %s <string>\\n\", argv[0]);\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  if (pipe(pipefd) == -1) {\n+    perror(\"pipe\");\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  cpid = fork();\n+  if (cpid == -1) {\n+    perror(\"fork\");\n+    exit(EXIT_FAILURE);\n+  }\n+\n+  if (cpid == 0) {    /* Child reads from pipe */\n+    close(pipefd[1]);          /* Close unused write end */\n+\n+    while (read(pipefd[0], &buf, 1) > 0)\n+      write(STDOUT_FILENO, &buf, 1);\n+\n+    write(STDOUT_FILENO, \"\\n\", 1);\n+    close(pipefd[0]);\n+    _exit(EXIT_SUCCESS);\n+\n+  } else {            /* Parent writes argv[1] to pipe */\n+    close(pipefd[0]);          /* Close unused read end */\n+    write(pipefd[1], argv[1], strlen(argv[1]));\n+    close(pipefd[1]);          /* Reader will see EOF */\n+    wait(NULL);                /* Wait for child */\n+    exit(EXIT_SUCCESS);\n+  }\n+}"}, {"sha": "d7afc9caaf959e2a7a5872ef6de354a648bb12db", "filename": "gcc/testsuite/gcc.dg/analyzer/pipe2-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe2-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792f039fc37faa3446725a643c8018f084e8ccab/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe2-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpipe2-1.c?ref=792f039fc37faa3446725a643c8018f084e8ccab", "patch": "@@ -0,0 +1,38 @@\n+#include \"analyzer-decls.h\"\n+\n+extern int pipe2(int pipefd[2], int flags);\n+extern int close(int fd);\n+\n+void\n+test_leak (void)\n+{\n+  int fds[2];\n+  if (pipe2 (fds, 0) == -1) /* { dg-message \"when 'pipe2' succeeds\" } */\n+    /* { dg-message \"opened here as read-write\" \"sm msg\" { target *-*-* } .-1 }} */\n+    return;\n+} /* { dg-line leak } */\n+/* { dg-warning \"leak of file descriptor 'fds\\\\\\[0\\\\\\]'\" \"leak of 0\" { target *-*-* } leak } */\n+/* { dg-warning \"leak of file descriptor 'fds\\\\\\[1\\\\\\]'\" \"leak of 1\" { target *-*-* } leak } */\n+/* { dg-message \"'fds\\\\\\[0\\\\\\]' leaks here\" \"final msg 0\" { target *-*-* } leak }} */\n+/* { dg-message \"'fds\\\\\\[1\\\\\\]' leaks here\" \"final msg 1\" { target *-*-* } leak }} */\n+\n+void\n+test_close (void)\n+{\n+  int fds[2];\n+  if (pipe2 (fds, 0) == -1)\n+    return;\n+  __analyzer_describe (0, fds[0]); /* { dg-warning \"CONJURED\" } */\n+  __analyzer_describe (0, fds[1]); /* { dg-warning \"CONJURED\" } */\n+  close (fds[0]);\n+  close (fds[1]);\n+}\n+\n+void\n+test_unchecked (void)\n+{\n+  int fds[2];\n+  pipe2 (fds, 0); /* { dg-message \"when 'pipe2' fails\" } */\n+  close (fds[0]); /* { dg-warning \"use of uninitialized value 'fds\\\\\\[0\\\\\\]'\" } */\n+  close (fds[1]); /* { dg-warning \"use of uninitialized value 'fds\\\\\\[1\\\\\\]'\" } */\n+}"}]}