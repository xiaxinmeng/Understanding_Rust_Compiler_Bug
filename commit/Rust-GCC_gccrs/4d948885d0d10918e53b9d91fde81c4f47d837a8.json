{"sha": "4d948885d0d10918e53b9d91fde81c4f47d837a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5NDg4ODVkMGQxMDkxOGU1M2I5ZDkxZmRlODFjNGY0N2Q4MzdhOA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-03T09:50:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-03T09:50:17Z"}, "message": "tree.def (TARGET_MEM_REF): Merge TMR_SYMBOL and TMR_BASE.\n\n2010-09-03  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.def (TARGET_MEM_REF): Merge TMR_SYMBOL and TMR_BASE.\n\tMove TMR_OFFSET to second operand.  Add TMR_INDEX2.\n\t* tree.h (TMR_SYMBOL): Remove.\n\t(TMR_BASE, TMR_OFFSET): Adjust.\n\t(TMR_INDEX2): New.\n\t* alias.c (ao_ref_from_mem): Use TMR_BASE.\n\t* builtins.c (get_object_alignment): Merge TMR_BASE and\n\tTMR_SYMBOL handling.\n\t* cfgexpand.c (expand_debug_expr): Use TMR_BASE.\n\t* gimple.c (get_base_address): Merge MEM_REF and TARGET_MEM_REF\n\thandling.  Also allow TARGET_MEM_REF as base address.\n\t(walk_stmt_load_store_addr_ops): TMR_BASE is always non-NULL.\n\t* gimplify.c (gimplify_expr): Gimplify TMR_BASE like MEM_REF\n\tbase.  Gimplify TMR_INDEX2.\n\t* tree-cfg.c (verify_types_in_gimple_reference): Adjust.\n\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n\t(get_addr_base_and_unit_offset): Likewise.\n\t* tree-eh.c (tree_could_trap_p): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-address.c (tree_mem_ref_addr): Simplify.  Handle\n\tTMR_INDEX2.\n\t(create_mem_ref_raw): Merge symbol and base.  Move 2ndary\n\tbase to index2.\n\t(get_address_description): Reconstruct addres description\n\tfrom merged TMR_BASE and TMR_INDEX2.\n\t(maybe_fold_tmr): Fold propagated addresses.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Merge\n\tMEM_REF and TARGET_MEM_REF paths.\n\t(indirect_refs_may_alias_p): Likewise.\n\t* tree-ssa-live.c (mark_all_vars_used_1): Handle TMR_INDEX2\n\tinstead of TMR_SYMBOL.\n\t* tree-ssa-operands.c (get_tmr_operands): Simplify.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Adjust\n\taccording to changes ...\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): ... here.\n\tSplit TARGET_MEM_REF into two fields plus the base.\n\t* tree.c (mem_ref_offset): Simplify.\n\t* tree-ssa-loop-im.c (for_each_index): Handle TMR_INDEX2.\n\t* tree-ssa-loop-ivopts.c (find_interesting_uses_address): Likewise.\n\tStrip NOPs when folding MEM_REF addresses.\n\t* tree-ssa-sink.c (is_hidden_global_store): Handle TARGET_MEM_REF.\n\t* gimple-fold.c (maybe_fold_reference): Fold TARGET_MEM_REF here ...\n\t(fold_gimple_assign): ... not here.\n\nFrom-SVN: r163802", "tree": {"sha": "906679b413fe977c9a6b6281ce7ba070a3cf8a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/906679b413fe977c9a6b6281ce7ba070a3cf8a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d948885d0d10918e53b9d91fde81c4f47d837a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d948885d0d10918e53b9d91fde81c4f47d837a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d948885d0d10918e53b9d91fde81c4f47d837a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d948885d0d10918e53b9d91fde81c4f47d837a8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3ec52d088106728c7c8acda2e736e09b6e70b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ec52d088106728c7c8acda2e736e09b6e70b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ec52d088106728c7c8acda2e736e09b6e70b4f"}], "stats": {"total": 420, "additions": 236, "deletions": 184}, "files": [{"sha": "9368985a8dd4e6ef76051f3d7c6c54665058c8d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -1,3 +1,49 @@\n+2010-09-03  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.def (TARGET_MEM_REF): Merge TMR_SYMBOL and TMR_BASE.\n+\tMove TMR_OFFSET to second operand.  Add TMR_INDEX2.\n+\t* tree.h (TMR_SYMBOL): Remove.\n+\t(TMR_BASE, TMR_OFFSET): Adjust.\n+\t(TMR_INDEX2): New.\n+\t* alias.c (ao_ref_from_mem): Use TMR_BASE.\n+\t* builtins.c (get_object_alignment): Merge TMR_BASE and\n+\tTMR_SYMBOL handling.\n+\t* cfgexpand.c (expand_debug_expr): Use TMR_BASE.\n+\t* gimple.c (get_base_address): Merge MEM_REF and TARGET_MEM_REF\n+\thandling.  Also allow TARGET_MEM_REF as base address.\n+\t(walk_stmt_load_store_addr_ops): TMR_BASE is always non-NULL.\n+\t* gimplify.c (gimplify_expr): Gimplify TMR_BASE like MEM_REF\n+\tbase.  Gimplify TMR_INDEX2.\n+\t* tree-cfg.c (verify_types_in_gimple_reference): Adjust.\n+\t* tree-dfa.c (get_ref_base_and_extent): Likewise.\n+\t(get_addr_base_and_unit_offset): Likewise.\n+\t* tree-eh.c (tree_could_trap_p): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-address.c (tree_mem_ref_addr): Simplify.  Handle\n+\tTMR_INDEX2.\n+\t(create_mem_ref_raw): Merge symbol and base.  Move 2ndary\n+\tbase to index2.\n+\t(get_address_description): Reconstruct addres description\n+\tfrom merged TMR_BASE and TMR_INDEX2.\n+\t(maybe_fold_tmr): Fold propagated addresses.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Merge\n+\tMEM_REF and TARGET_MEM_REF paths.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t* tree-ssa-live.c (mark_all_vars_used_1): Handle TMR_INDEX2\n+\tinstead of TMR_SYMBOL.\n+\t* tree-ssa-operands.c (get_tmr_operands): Simplify.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Adjust\n+\taccording to changes ...\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): ... here.\n+\tSplit TARGET_MEM_REF into two fields plus the base.\n+\t* tree.c (mem_ref_offset): Simplify.\n+\t* tree-ssa-loop-im.c (for_each_index): Handle TMR_INDEX2.\n+\t* tree-ssa-loop-ivopts.c (find_interesting_uses_address): Likewise.\n+\tStrip NOPs when folding MEM_REF addresses.\n+\t* tree-ssa-sink.c (is_hidden_global_store): Handle TARGET_MEM_REF.\n+\t* gimple-fold.c (maybe_fold_reference): Fold TARGET_MEM_REF here ...\n+\t(fold_gimple_assign): ... not here.\n+\n 2010-09-03  Mingjie Xing  <mingjie.xing@gmail.com>\n \n \t* config/mips/mips.h (SHIFT_COUNT_TRUNCATED): Change the definition."}, {"sha": "854ac27aa9df7c1fabc621fe0218e65ece0dadc0", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -301,14 +301,14 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n \tref->base = build_simple_mem_ref (*(tree *)namep);\n     }\n   else if (TREE_CODE (base) == TARGET_MEM_REF\n-\t   && TMR_SYMBOL (base)\n-\t   && TREE_CODE (TREE_OPERAND (TMR_SYMBOL (base), 0)) == VAR_DECL\n-\t   && ! TREE_STATIC (TREE_OPERAND (TMR_SYMBOL (base), 0))\n+\t   && TREE_CODE (TMR_BASE (base)) == ADDR_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (TMR_BASE (base), 0)) == VAR_DECL\n+\t   && ! TREE_STATIC (TREE_OPERAND (TMR_BASE (base), 0))\n \t   && cfun->gimple_df->decls_to_pointers != NULL)\n     {\n       void *namep;\n       namep = pointer_map_contains (cfun->gimple_df->decls_to_pointers,\n-\t\t\t\t    TREE_OPERAND (TMR_SYMBOL (base), 0));\n+\t\t\t\t    TREE_OPERAND (TMR_BASE (base), 0));\n       if (namep)\n \tref->base = build_simple_mem_ref (*(tree *)namep);\n     }"}, {"sha": "c2176d9aae3a73ce36a0007d97405915c7636402", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -331,9 +331,7 @@ get_object_alignment (tree exp, unsigned int max_align)\n \t\t\t\t\t\t  max_align));\n       bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n     }\n-  else if (TREE_CODE (exp) == TARGET_MEM_REF\n-\t   && TMR_BASE (exp)\n-\t   && POINTER_TYPE_P (TREE_TYPE (TMR_BASE (exp))))\n+  else if (TREE_CODE (exp) == TARGET_MEM_REF)\n     {\n       struct ptr_info_def *pi;\n       tree addr = TMR_BASE (exp);\n@@ -365,22 +363,7 @@ get_object_alignment (tree exp, unsigned int max_align)\n \t}\n       else if (TMR_INDEX (exp))\n \talign = BITS_PER_UNIT;\n-    }\n-  else if (TREE_CODE (exp) == TARGET_MEM_REF\n-\t   && TMR_SYMBOL (exp))\n-    {\n-      align = get_object_alignment (TREE_OPERAND (TMR_SYMBOL (exp), 0),\n-\t\t\t\t    max_align);\n-      if (TMR_OFFSET (exp))\n-        bitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n-      if (TMR_INDEX (exp) && TMR_STEP (exp))\n-\t{\n-\t  unsigned HOST_WIDE_INT step = TREE_INT_CST_LOW (TMR_STEP (exp));\n-\t  align = MIN (align, (step & -step) * BITS_PER_UNIT);\n-\t}\n-      else if (TMR_INDEX (exp))\n-\talign = BITS_PER_UNIT;\n-      if (TMR_BASE (exp))\n+      if (TMR_INDEX2 (exp))\n \talign = BITS_PER_UNIT;\n     }\n   else"}, {"sha": "a979d6f3c1ae2d6496191999046484df5b25a704", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -2468,8 +2468,8 @@ expand_debug_expr (tree exp)\n       return op0;\n \n     case TARGET_MEM_REF:\n-      if (TMR_SYMBOL (exp)\n-\t  && !DECL_RTL_SET_P (TREE_OPERAND (TMR_SYMBOL (exp), 0)))\n+      if (TREE_CODE (TMR_BASE (exp)) == ADDR_EXPR\n+\t  && !DECL_RTL_SET_P (TREE_OPERAND (TMR_BASE (exp), 0)))\n \treturn NULL;\n \n       op0 = expand_debug_expr"}, {"sha": "8a48316f00de3b26321e91bf799cdab9401e0129", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -528,6 +528,18 @@ maybe_fold_reference (tree expr, bool is_lhs)\n \t  return expr;\n \t}\n     }\n+  else if (TREE_CODE (*t) == TARGET_MEM_REF)\n+    {\n+      tree tem = maybe_fold_tmr (*t);\n+      if (tem)\n+\t{\n+\t  *t = tem;\n+\t  tem = maybe_fold_reference (expr, is_lhs);\n+\t  if (tem)\n+\t    return tem;\n+\t  return expr;\n+\t}\n+    }\n   else if (!is_lhs\n \t   && DECL_P (*t))\n     {\n@@ -602,9 +614,6 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t\t\t    COND_EXPR_THEN (rhs), COND_EXPR_ELSE (rhs));\n           }\n \n-\telse if (TREE_CODE (rhs) == TARGET_MEM_REF)\n-\t  return maybe_fold_tmr (rhs);\n-\n \telse if (REFERENCE_CLASS_P (rhs))\n \t  return maybe_fold_reference (rhs, false);\n "}, {"sha": "bb68be691adf2764eff261ae97076e6cdb2ae408", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -3004,18 +3004,17 @@ get_base_address (tree t)\n   while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n \n-  if (TREE_CODE (t) == MEM_REF\n+  if ((TREE_CODE (t) == MEM_REF\n+       || TREE_CODE (t) == TARGET_MEM_REF)\n       && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n     t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-  else if (TREE_CODE (t) == TARGET_MEM_REF\n-\t   && TMR_SYMBOL (t))\n-    t = TREE_OPERAND (TMR_SYMBOL (t), 0);\n \n   if (SSA_VAR_P (t)\n       || TREE_CODE (t) == STRING_CST\n       || TREE_CODE (t) == CONSTRUCTOR\n       || INDIRECT_REF_P (t)\n-      || TREE_CODE (t) == MEM_REF)\n+      || TREE_CODE (t) == MEM_REF\n+      || TREE_CODE (t) == TARGET_MEM_REF)\n     return t;\n   else\n     return NULL_TREE;\n@@ -4725,7 +4724,6 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t  if (TREE_CODE (rhs) == ADDR_EXPR)\n \t    ret |= visit_addr (stmt, TREE_OPERAND (rhs, 0), data);\n \t  else if (TREE_CODE (rhs) == TARGET_MEM_REF\n-                   && TMR_BASE (rhs) != NULL_TREE\n \t\t   && TREE_CODE (TMR_BASE (rhs)) == ADDR_EXPR)\n \t    ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (rhs), 0), data);\n \t  else if (TREE_CODE (rhs) == OBJ_TYPE_REF\n@@ -4734,7 +4732,6 @@ walk_stmt_load_store_addr_ops (gimple stmt, void *data,\n \t\t\t\t\t\t   0), data);\n           lhs = gimple_assign_lhs (stmt);\n \t  if (TREE_CODE (lhs) == TARGET_MEM_REF\n-              && TMR_BASE (lhs) != NULL_TREE\n               && TREE_CODE (TMR_BASE (lhs)) == ADDR_EXPR)\n             ret |= visit_addr (stmt, TREE_OPERAND (TMR_BASE (lhs), 0), data);\n \t}"}, {"sha": "1723f42d8a2e76b0d647a94fe5ebdc702f1873fa", "filename": "gcc/gimplify.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -6977,20 +6977,15 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  {\n \t    enum gimplify_status r0 = GS_ALL_DONE, r1 = GS_ALL_DONE;\n \n-\t    if (TMR_SYMBOL (*expr_p))\n-\t      /* We can't gimplify the symbol part.  Assert it is\n-\t\t already gimple instead.\n-\t\t ???  This isn't exactly the same as ADDR_EXPR\n-\t\t plus is_gimple_mem_ref_addr (), see fixed_address_object_p.  */\n-\t      gcc_assert (TREE_CODE (TMR_SYMBOL (*expr_p)) == ADDR_EXPR\n-\t\t\t  && (TREE_CODE (TREE_OPERAND (TMR_SYMBOL (*expr_p), 0))\n-\t\t\t      == VAR_DECL));\n \t    if (TMR_BASE (*expr_p))\n \t      r0 = gimplify_expr (&TMR_BASE (*expr_p), pre_p,\n-\t\t\t\t  post_p, is_gimple_val, fb_either);\n+\t\t\t\t  post_p, is_gimple_mem_ref_addr, fb_either);\n \t    if (TMR_INDEX (*expr_p))\n \t      r1 = gimplify_expr (&TMR_INDEX (*expr_p), pre_p,\n \t\t\t\t  post_p, is_gimple_val, fb_rvalue);\n+\t    if (TMR_INDEX2 (*expr_p))\n+\t      r1 = gimplify_expr (&TMR_INDEX2 (*expr_p), pre_p,\n+\t\t\t\t  post_p, is_gimple_val, fb_rvalue);\n \t    /* TMR_STEP and TMR_OFFSET are always integer constants.  */\n \t    ret = MIN (r0, r1);\n \t  }"}, {"sha": "14982ffa8498bd7fee14dc26244f1c98cb029589", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -2990,11 +2990,10 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n     }\n   else if (TREE_CODE (expr) == TARGET_MEM_REF)\n     {\n-      if (TMR_SYMBOL (expr)\n-\t  && TMR_BASE (expr)\n-\t  && !useless_type_conversion_p (sizetype, TREE_TYPE (TMR_BASE (expr))))\n+      if (!TMR_BASE (expr)\n+\t  || !is_gimple_mem_ref_addr (TMR_BASE (expr)))\n \t{\n-\t  error (\"Non-sizetype base in TARGET_MEM_REF with symbol\");\n+\t  error (\"Invalid address operand in in TARGET_MEM_REF.\");\n \t  return true;\n \t}\n       if (!TMR_OFFSET (expr)"}, {"sha": "0bc9f41755a90bdad5b8b84640ef4b9cba206a10", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -880,19 +880,19 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \n \tcase TARGET_MEM_REF:\n \t  /* Hand back the decl for MEM[&decl, off].  */\n-\t  if (TMR_SYMBOL (exp))\n+\t  if (TREE_CODE (TMR_BASE (exp)) == ADDR_EXPR)\n \t    {\n-\t      /* Via the variable index or base we can reach the\n+\t      /* Via the variable index or index2 we can reach the\n \t\t whole object.  */\n-\t      if (TMR_INDEX (exp) || TMR_BASE (exp))\n+\t      if (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n \t\t{\n-\t\t  exp = TREE_OPERAND (TMR_SYMBOL (exp), 0);\n+\t\t  exp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t\t  bit_offset = 0;\n \t\t  maxsize = -1;\n \t\t  goto done;\n \t\t}\n \t      if (integer_zerop (TMR_OFFSET (exp)))\n-\t\texp = TREE_OPERAND (TMR_SYMBOL (exp), 0);\n+\t\texp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t      else\n \t\t{\n \t\t  double_int off = mem_ref_offset (exp);\n@@ -904,7 +904,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \t\t  if (double_int_fits_in_shwi_p (off))\n \t\t    {\n \t\t      bit_offset = double_int_to_shwi (off);\n-\t\t      exp = TREE_OPERAND (TMR_SYMBOL (exp), 0);\n+\t\t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t\t    }\n \t\t}\n \t    }\n@@ -1044,17 +1044,17 @@ get_addr_base_and_unit_offset (tree exp, HOST_WIDE_INT *poffset)\n \n \tcase TARGET_MEM_REF:\n \t  /* Hand back the decl for MEM[&decl, off].  */\n-\t  if (TMR_SYMBOL (exp))\n+\t  if (TREE_CODE (TMR_BASE (exp)) == ADDR_EXPR)\n \t    {\n-\t      if (TMR_INDEX (exp) || TMR_BASE (exp))\n+\t      if (TMR_INDEX (exp) || TMR_INDEX2 (exp))\n \t\treturn NULL_TREE;\n \t      if (!integer_zerop (TMR_OFFSET (exp)))\n \t\t{\n \t\t  double_int off = mem_ref_offset (exp);\n \t\t  gcc_assert (off.high == -1 || off.high == 0);\n \t\t  byte_offset += double_int_to_shwi (off);\n \t\t}\n-\t      exp = TREE_OPERAND (TMR_SYMBOL (exp), 0);\n+\t      exp = TREE_OPERAND (TMR_BASE (exp), 0);\n \t    }\n \t  goto done;\n "}, {"sha": "1faa682fbd9ad4e8213177d122e507d6ee6f373a", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -2404,8 +2404,8 @@ tree_could_trap_p (tree expr)\n   switch (code)\n     {\n     case TARGET_MEM_REF:\n-      if (TMR_SYMBOL (expr)\n-\t  && !TMR_INDEX (expr) && !TMR_BASE (expr))\n+      if (TREE_CODE (TMR_BASE (expr)) == ADDR_EXPR\n+\t  && !TMR_INDEX (expr) && !TMR_INDEX2 (expr))\n \treturn false;\n       return !TREE_THIS_NOTRAP (expr);\n "}, {"sha": "2c697ec500dddda3399afb87118b96a484743aed", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -852,16 +852,22 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n \tpp_string (buffer, \"MEM[\");\n \n-\ttmp = TMR_SYMBOL (node);\n-\tif (tmp)\n+\tif (TREE_CODE (TMR_BASE (node)) == ADDR_EXPR)\n \t  {\n \t    pp_string (buffer, sep);\n \t    sep = \", \";\n \t    pp_string (buffer, \"symbol: \");\n-\t    dump_generic_node (buffer, TREE_OPERAND (tmp, 0),\n+\t    dump_generic_node (buffer, TREE_OPERAND (TMR_BASE (node), 0),\n \t\t\t       spc, flags, false);\n \t  }\n-\ttmp = TMR_BASE (node);\n+\telse\n+\t  {\n+\t    pp_string (buffer, sep);\n+\t    sep = \", \";\n+\t    pp_string (buffer, \"base: \");\n+\t    dump_generic_node (buffer, TMR_BASE (node), spc, flags, false);\n+\t  }\n+\ttmp = TMR_INDEX2 (node);\n \tif (tmp)\n \t  {\n \t    pp_string (buffer, sep);"}, {"sha": "99b87bbd198150b1cdc66373152dfe6b119ad6db", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 68, "deletions": 35, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -268,17 +268,9 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n   tree addr;\n   tree act_elem;\n   tree step = TMR_STEP (mem_ref), offset = TMR_OFFSET (mem_ref);\n-  tree sym = TMR_SYMBOL (mem_ref), base = TMR_BASE (mem_ref);\n   tree addr_base = NULL_TREE, addr_off = NULL_TREE;\n \n-  if (sym)\n-    addr_base = fold_convert (type, sym);\n-  else if (base)\n-    {\n-      gcc_assert (POINTER_TYPE_P (TREE_TYPE (base)));\n-      addr_base = fold_convert (type, base);\n-      base = NULL_TREE;\n-    }\n+  addr_base = fold_convert (type, TMR_BASE (mem_ref));\n \n   act_elem = TMR_INDEX (mem_ref);\n   if (act_elem)\n@@ -288,7 +280,7 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n       addr_off = act_elem;\n     }\n \n-  act_elem = base;\n+  act_elem = TMR_INDEX2 (mem_ref);\n   if (act_elem)\n     {\n       if (addr_off)\n@@ -307,16 +299,9 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n     }\n \n   if (addr_off)\n-    {\n-      if (addr_base)\n-\taddr = fold_build2 (POINTER_PLUS_EXPR, type, addr_base, addr_off);\n-      else\n-\taddr = fold_convert (type, addr_off);\n-    }\n-  else if (addr_base)\n-    addr = addr_base;\n+    addr = fold_build2 (POINTER_PLUS_EXPR, type, addr_base, addr_off);\n   else\n-    addr = build_int_cst (type, 0);\n+    addr = addr_base;\n \n   return addr;\n }\n@@ -344,6 +329,8 @@ valid_mem_ref_p (enum machine_mode mode, addr_space_t as,\n static tree\n create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr)\n {\n+  tree base, index2;\n+\n   if (!valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))\n     return NULL_TREE;\n \n@@ -355,23 +342,31 @@ create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr)\n   else\n     addr->offset = build_int_cst (alias_ptr_type, 0);\n \n-  /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.  */\n-  if (alias_ptr_type\n-      && (!addr->index || integer_zerop (addr->index))\n-      && (!addr->base || POINTER_TYPE_P (TREE_TYPE (addr->base))))\n+  if (addr->symbol)\n     {\n-      tree base;\n-      gcc_assert (!addr->symbol ^ !addr->base);\n-      if (addr->symbol)\n-\tbase = addr->symbol;\n-      else\n-\tbase = addr->base;\n-      return fold_build2 (MEM_REF, type, base, addr->offset);\n+      base = addr->symbol;\n+      index2 = addr->base;\n+    }\n+  else if (addr->base\n+\t   && POINTER_TYPE_P (TREE_TYPE (addr->base)))\n+    {\n+      base = addr->base;\n+      index2 = NULL_TREE;\n     }\n+  else\n+    {\n+      base = build_int_cst (ptr_type_node, 0);\n+      index2 = addr->base;\n+    }\n+\n+  /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.  */\n+  if (alias_ptr_type\n+      && (!index2 || integer_zerop (index2))\n+      && (!addr->index || integer_zerop (addr->index)))\n+    return fold_build2 (MEM_REF, type, base, addr->offset);\n \n   return build5 (TARGET_MEM_REF, type,\n-\t\t addr->symbol, addr->base, addr->index,\n-\t\t addr->step, addr->offset);\n+\t\t base, addr->offset, addr->index, addr->step, index2);\n }\n \n /* Returns true if OBJ is an object whose address is a link time constant.  */\n@@ -808,8 +803,22 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n void\n get_address_description (tree op, struct mem_address *addr)\n {\n-  addr->symbol = TMR_SYMBOL (op);\n-  addr->base = TMR_BASE (op);\n+  if (TREE_CODE (TMR_BASE (op)) == ADDR_EXPR)\n+    {\n+      addr->symbol = TMR_BASE (op);\n+      addr->base = TMR_INDEX2 (op);\n+    }\n+  else\n+    {\n+      addr->symbol = NULL_TREE;\n+      if (TMR_INDEX2 (op))\n+\t{\n+\t  gcc_assert (integer_zerop (TMR_BASE (op)));\n+\t  addr->base = TMR_INDEX2 (op);\n+\t}\n+      else\n+\taddr->base = TMR_BASE (op);\n+    }\n   addr->index = TMR_INDEX (op);\n   addr->step = TMR_STEP (op);\n   addr->offset = TMR_OFFSET (op);\n@@ -837,7 +846,9 @@ maybe_fold_tmr (tree ref)\n \n   get_address_description (ref, &addr);\n \n-  if (addr.base && TREE_CODE (addr.base) == INTEGER_CST)\n+  if (addr.base\n+      && TREE_CODE (addr.base) == INTEGER_CST\n+      && !integer_zerop (addr.base))\n     {\n       addr.offset = fold_binary_to_constant (PLUS_EXPR,\n \t\t\t\t\t     TREE_TYPE (addr.offset),\n@@ -846,6 +857,28 @@ maybe_fold_tmr (tree ref)\n       changed = true;\n     }\n \n+  if (addr.symbol\n+      && TREE_CODE (TREE_OPERAND (addr.symbol, 0)) == MEM_REF)\n+    {\n+      addr.offset = fold_binary_to_constant\n+\t\t\t(PLUS_EXPR, TREE_TYPE (addr.offset),\n+\t\t\t addr.offset,\n+\t\t\t TREE_OPERAND (TREE_OPERAND (addr.symbol, 0), 1));\n+      addr.symbol = TREE_OPERAND (TREE_OPERAND (addr.symbol, 0), 0);\n+      changed = true;\n+    }\n+  else if (addr.symbol\n+\t   && handled_component_p (TREE_OPERAND (addr.symbol, 0)))\n+    {\n+      HOST_WIDE_INT offset;\n+      addr.symbol = build_fold_addr_expr\n+\t\t      (get_addr_base_and_unit_offset\n+\t\t         (TREE_OPERAND (addr.symbol, 0), &offset));\n+      addr.offset = int_const_binop (PLUS_EXPR,\n+\t\t\t\t     addr.offset, size_int (offset), 0);\n+      changed = true;\n+    }\n+\n   if (addr.index && TREE_CODE (addr.index) == INTEGER_CST)\n     {\n       off = addr.index;"}, {"sha": "a9f1c19f7acb38903b4634b6135780c80720a083", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 3, "deletions": 46, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -670,21 +670,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   tree ptrtype1;\n   HOST_WIDE_INT offset1p = offset1, offset2p = offset2;\n \n-  if (TREE_CODE (base1) == TARGET_MEM_REF)\n-    {\n-      if (TMR_SYMBOL (base1))\n-\tptr1 = TMR_SYMBOL (base1);\n-      else if (TMR_BASE (base1))\n-\t{\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (TMR_BASE (base1))))\n-\t    return true;\n-\t  ptr1 = TMR_BASE (base1);\n-\t}\n-      else\n-\treturn true;\n-    }\n-  else\n-    ptr1 = TREE_OPERAND (base1, 0);\n+  ptr1 = TREE_OPERAND (base1, 0);\n \n   /* The offset embedded in MEM_REFs can be negative.  Bias them\n      so that the resulting offset adjustment is positive.  */\n@@ -812,37 +798,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   tree ptr2;\n   tree ptrtype1, ptrtype2;\n \n-  if (TREE_CODE (base1) == TARGET_MEM_REF)\n-    {\n-      if (TMR_SYMBOL (base1))\n-\tptr1 = TMR_SYMBOL (base1);\n-      else if (TMR_BASE (base1))\n-\t{\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (TMR_BASE (base1))))\n-\t    return true;\n-\t  ptr1 = TMR_BASE (base1);\n-\t}\n-      else\n-\treturn true;\n-    }\n-  else\n-    ptr1 = TREE_OPERAND (base1, 0);\n-\n-  if (TREE_CODE (base2) == TARGET_MEM_REF)\n-    {\n-      if (TMR_SYMBOL (base2))\n-\tptr2 = TMR_SYMBOL (base2);\n-      else if (TMR_BASE (base2))\n-\t{\n-\t  if (!POINTER_TYPE_P (TREE_TYPE (TMR_BASE (base2))))\n-\t    return true;\n-\t  ptr2 = TMR_BASE (base2);\n-\t}\n-      else\n-\treturn true;\n-    }\n-  else\n-    ptr2 = TREE_OPERAND (base2, 0);\n+  ptr1 = TREE_OPERAND (base1, 0);\n+  ptr2 = TREE_OPERAND (base2, 0);\n \n   /* If both bases are based on pointers they cannot alias if they may not\n      point to the same memory object or if they point to the same object"}, {"sha": "715b5a71c0744a35cac4aa4fc3722e5cbf8ad41b", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -362,13 +362,13 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees, void *data)\n       && (b = TREE_BLOCK (t)) != NULL)\n     TREE_USED (b) = true;\n \n-  /* Ignore TREE_ORIGINAL for TARGET_MEM_REFS, as well as other\n-     fields that do not contain vars.  */\n+  /* Ignore TMR_OFFSET and TMR_STEP for TARGET_MEM_REFS, as those\n+     fields do not contain vars.  */\n   if (TREE_CODE (t) == TARGET_MEM_REF)\n     {\n-      mark_all_vars_used (&TMR_SYMBOL (t), data);\n       mark_all_vars_used (&TMR_BASE (t), data);\n       mark_all_vars_used (&TMR_INDEX (t), data);\n+      mark_all_vars_used (&TMR_INDEX2 (t), data);\n       *walk_subtrees = 0;\n       return NULL;\n     }"}, {"sha": "3e71b5c19637e73e5167ef06b23e0551e3bae350", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -324,6 +324,10 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \t      && !cbck (*addr_p, idx, data))\n \t    return false;\n \t  idx = &TMR_INDEX (*addr_p);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\t  idx = &TMR_INDEX2 (*addr_p);\n \t  if (*idx\n \t      && !cbck (*addr_p, idx, data))\n \t    return false;"}, {"sha": "0a1c44ec964019df64a83079d2eb8151578ecfda", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -1722,6 +1722,16 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \t  TMR_BASE (base) = civ->base;\n \t  step = civ->step;\n \t}\n+      if (TMR_INDEX2 (base)\n+\t  && TREE_CODE (TMR_INDEX2 (base)) == SSA_NAME)\n+\t{\n+\t  civ = get_iv (data, TMR_INDEX2 (base));\n+\t  if (!civ)\n+\t    goto fail;\n+\n+\t  TMR_INDEX2 (base) = civ->base;\n+\t  step = civ->step;\n+\t}\n       if (TMR_INDEX (base)\n \t  && TREE_CODE (TMR_INDEX (base)) == SSA_NAME)\n \t{\n@@ -1778,9 +1788,14 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \t    ref = &TREE_OPERAND (*ref, 0);\n \t  if (TREE_CODE (*ref) == MEM_REF)\n \t    {\n-\t      tree tem = fold_binary (MEM_REF, TREE_TYPE (*ref),\n-\t\t\t\t      TREE_OPERAND (*ref, 0),\n-\t\t\t\t      TREE_OPERAND (*ref, 1));\n+\t      tree tem = TREE_OPERAND (*ref, 0);\n+\t      STRIP_NOPS (tem);\n+\t      if (tem != TREE_OPERAND (*ref, 0))\n+\t\ttem = fold_build2 (MEM_REF, TREE_TYPE (*ref),\n+\t\t\t\t   tem, TREE_OPERAND (*ref, 1));\n+\t      else\n+\t\ttem = fold_binary (MEM_REF, TREE_TYPE (*ref),\n+\t\t\t\t   tem, TREE_OPERAND (*ref, 1));\n \t      if (tem)\n \t\t*ref = tem;\n \t    }"}, {"sha": "09f12ef52ba5c4686fb5ced8ba3c45307452ece9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -754,9 +754,7 @@ get_tmr_operands (gimple stmt, tree expr, int flags)\n   /* First record the real operands.  */\n   get_expr_operands (stmt, &TMR_BASE (expr), opf_use | (flags & opf_no_vops));\n   get_expr_operands (stmt, &TMR_INDEX (expr), opf_use | (flags & opf_no_vops));\n-\n-  if (TMR_SYMBOL (expr))\n-    mark_address_taken (TREE_OPERAND (TMR_SYMBOL (expr), 0));\n+  get_expr_operands (stmt, &TMR_INDEX2 (expr), opf_use | (flags & opf_no_vops));\n \n   add_virtual_operand (stmt, flags);\n }"}, {"sha": "6e457208b5f178ff6b97191a75b39af1e379559a", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -2772,8 +2772,10 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       break;\n     case TARGET_MEM_REF:\n       {\n-\tpre_expr op0expr;\n-\ttree genop0 = NULL_TREE;\n+\tpre_expr op0expr, op1expr;\n+\ttree genop0 = NULL_TREE, genop1 = NULL_TREE;\n+\tvn_reference_op_t nextop = VEC_index (vn_reference_op_s, ref->operands,\n+\t\t\t\t\t      ++*operand);\n \ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n \t\t\t\t\t\t\tstmts, domstmt);\n \tif (!baseop)\n@@ -2786,14 +2788,16 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \t    if (!genop0)\n \t      return NULL_TREE;\n \t  }\n-\tif (DECL_P (baseop))\n-\t  return build5 (TARGET_MEM_REF, currop->type,\n-\t\t\t baseop, NULL_TREE,\n-\t\t\t genop0, currop->op1, currop->op2);\n-\telse\n-\t  return build5 (TARGET_MEM_REF, currop->type,\n-\t\t\t NULL_TREE, baseop,\n-\t\t\t genop0, currop->op1, currop->op2);\n+\tif (nextop->op0)\n+\t  {\n+\t    op1expr = get_or_alloc_expr_for (nextop->op0);\n+\t    genop1 = find_or_generate_expression (block, op1expr,\n+\t\t\t\t\t\t  stmts, domstmt);\n+\t    if (!genop1)\n+\t      return NULL_TREE;\n+\t  }\n+\treturn build5 (TARGET_MEM_REF, currop->type,\n+\t\t       baseop, currop->op2, genop0, currop->op1, genop1);\n       }\n       break;\n     case ADDR_EXPR:"}, {"sha": "c440a28f413cb3df76bf106f9f7e698adb3fd852", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -575,11 +575,6 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n   if (TREE_CODE (ref) == TARGET_MEM_REF)\n     {\n       vn_reference_op_s temp;\n-      tree base;\n-\n-      base = TMR_SYMBOL (ref) ? TMR_SYMBOL (ref) : TMR_BASE (ref);\n-      if (!base)\n-\tbase = null_pointer_node;\n \n       memset (&temp, 0, sizeof (temp));\n       /* We do not care for spurious type qualifications.  */\n@@ -593,8 +588,15 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \n       memset (&temp, 0, sizeof (temp));\n       temp.type = NULL_TREE;\n-      temp.opcode = TREE_CODE (base);\n-      temp.op0 = base;\n+      temp.opcode = ERROR_MARK;\n+      temp.op0 = TMR_INDEX2 (ref);\n+      temp.off = -1;\n+      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\n+      memset (&temp, 0, sizeof (temp));\n+      temp.type = NULL_TREE;\n+      temp.opcode = TREE_CODE (TMR_BASE (ref));\n+      temp.op0 = TMR_BASE (ref);\n       temp.off = -1;\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n       return;"}, {"sha": "436047b8e93f4d5cbf28a49752e8b08b7dd041d1", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -191,7 +191,8 @@ is_hidden_global_store (gimple stmt)\n \n \t}\n       else if (INDIRECT_REF_P (lhs)\n-\t       || TREE_CODE (lhs) == MEM_REF)\n+\t       || TREE_CODE (lhs) == MEM_REF\n+\t       || TREE_CODE (lhs) == TARGET_MEM_REF)\n \treturn ptr_deref_may_alias_global_p (TREE_OPERAND (lhs, 0));\n       else if (CONSTANT_CLASS_P (lhs))\n \treturn true;"}, {"sha": "4659a105d32b97368a91e5d6560a1d6e014a810e", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -3910,7 +3910,7 @@ build_simple_mem_ref_loc (location_t loc, tree ptr)\n double_int\n mem_ref_offset (const_tree t)\n {\n-  tree toff = TREE_CODE (t) == MEM_REF ? TREE_OPERAND (t, 1) : TMR_OFFSET (t);\n+  tree toff = TREE_OPERAND (t, 1);\n   return double_int_sext (tree_to_double_int (toff),\n \t\t\t  TYPE_PRECISION (TREE_TYPE (toff)));\n }"}, {"sha": "43bdd42ea9492297fb46c8bdd5e41083def977c4", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -952,14 +952,16 @@ DEFTREECODE (WITH_SIZE_EXPR, \"with_size_expr\", tcc_expression, 2)\n    generated by the builtin targetm.vectorize.mask_for_load_builtin_decl.  */\n DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n \n-/* Low-level memory addressing.  Operands are SYMBOL (address of static or\n-   global variable), BASE (register), INDEX (register), STEP (integer constant),\n-   OFFSET (integer constant).  Corresponding address is\n-   SYMBOL + BASE + STEP * INDEX + OFFSET.  Only variations and values valid on\n-   the target are allowed.\n-\n-   The type of STEP and INDEX is sizetype.  The type of BASE is\n-   sizetype or a pointer type (if SYMBOL is NULL).\n+/* Low-level memory addressing.  Operands are BASE (address of static or\n+   global variable or register), OFFSET (integer constant),\n+   INDEX (register), STEP (integer constant), INDEX2 (register),\n+   The corresponding address is BASE + STEP * INDEX + INDEX2 + OFFSET.\n+   Only variations and values valid on the target are allowed.\n+\n+   The type of STEP, INDEX and INDEX2 is sizetype.\n+\n+   The type of BASE is a pointer type.  If BASE is not an address of\n+   a static or global variable INDEX2 will be NULL.\n \n    The type of OFFSET is a pointer type and determines TBAA the same as\n    the constant offset operand in MEM_REF.  */"}, {"sha": "e667742c2bbba23fd7a749ce58a58eac686e2926", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d948885d0d10918e53b9d91fde81c4f47d837a8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4d948885d0d10918e53b9d91fde81c4f47d837a8", "patch": "@@ -1632,12 +1632,13 @@ extern void protected_set_expr_location (tree, location_t);\n #define CASE_HIGH(NODE)         \tTREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 1)\n #define CASE_LABEL(NODE)\t\tTREE_OPERAND (CASE_LABEL_EXPR_CHECK (NODE), 2)\n \n-/* The operands of a TARGET_MEM_REF.  */\n-#define TMR_SYMBOL(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 0))\n-#define TMR_BASE(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 1))\n+/* The operands of a TARGET_MEM_REF.  Operands 0 and 1 have to match\n+   corresponding MEM_REF operands.  */\n+#define TMR_BASE(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 0))\n+#define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 1))\n #define TMR_INDEX(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 2))\n #define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))\n-#define TMR_OFFSET(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))\n+#define TMR_INDEX2(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))\n \n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))"}]}