{"sha": "4269edf01cc14cd15853692d966daf2fb92e2adc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI2OWVkZjAxY2MxNGNkMTU4NTM2OTJkOTY2ZGFmMmZiOTJlMmFkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T12:58:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T12:58:27Z"}, "message": "[multiple changes]\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* checks.adb (Apply_Predicate_Check): If the expression is an\n\taggregate that is the RHS of an assignment, apply the check to\n\tthe LHS after the assignment, rather than to the aggregate. This\n\tis more efficient than creating a temporary for the aggregate,\n\tand prevents back-end crashes when the aggregate includes a\n\tdynamic \"others' association.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Instance_And_Renamings):\n\tSet variable to ignore SPARK_Mode in instance before the analysis\n\tof the generated package declaration.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_res.adb (Resolve_Call): Do not issue a\n\tmessage for calls inside expression function, unless body was\n\tseen and is candidate for inlining.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aux.adb (Is_Generic_Formal): Handle properly formal packages.\n\t* sem_ch3.adb (Analyze_Declarations): In a generic subprogram\n\tbody. do not freeze the formals of the generic unit.\n\n2017-09-06  Gary Dismukes  <dismukes@adacore.com>\n\n\t* errout.adb (Error_Msg): Separate the\n\ttreatment for warning vs. style messages in inlinings and\n\tinstantiations. Prevents blowups on calls to Warn_Insertion for\n\tstyle messages, which should not be called in that case because\n\tWarning_Msg_Char is not set.\n\n2017-09-06  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_prag.adb (Check_VFA_Conflicts): Created\n\tto group all Volatile_Full_Access checks relating to other\n\trepresentation pragmas (Mark_Component_Or_Object): Created\n\tto centeralize the flagging of attributes for the record type\n\tcomponent case, a pragma applied individually to a component, and\n\tthe object case.\n\t(Process_Atomic_Independent_Shared_Volatile):\n\tAdd propagation of certain pragmas to record components and move\n\tevaluation of VFA checks\n\nFrom-SVN: r251793", "tree": {"sha": "cd67f0e0b7d5946ac2544f0adc8065345274078b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd67f0e0b7d5946ac2544f0adc8065345274078b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4269edf01cc14cd15853692d966daf2fb92e2adc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4269edf01cc14cd15853692d966daf2fb92e2adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4269edf01cc14cd15853692d966daf2fb92e2adc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4269edf01cc14cd15853692d966daf2fb92e2adc/comments", "author": null, "committer": null, "parents": [{"sha": "f6bd5664755b207d5bbfedd95231dc62ccfaa1ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bd5664755b207d5bbfedd95231dc62ccfaa1ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bd5664755b207d5bbfedd95231dc62ccfaa1ed"}], "stats": {"total": 436, "additions": 315, "deletions": 121}, "files": [{"sha": "b746bff052792553f034aae96c8a994cd19440ea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -1,3 +1,50 @@\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* checks.adb (Apply_Predicate_Check): If the expression is an\n+\taggregate that is the RHS of an assignment, apply the check to\n+\tthe LHS after the assignment, rather than to the aggregate. This\n+\tis more efficient than creating a temporary for the aggregate,\n+\tand prevents back-end crashes when the aggregate includes a\n+\tdynamic \"others' association.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Instance_And_Renamings):\n+\tSet variable to ignore SPARK_Mode in instance before the analysis\n+\tof the generated package declaration.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Call): Do not issue a\n+\tmessage for calls inside expression function, unless body was\n+\tseen and is candidate for inlining.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aux.adb (Is_Generic_Formal): Handle properly formal packages.\n+\t* sem_ch3.adb (Analyze_Declarations): In a generic subprogram\n+\tbody. do not freeze the formals of the generic unit.\n+\n+2017-09-06  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* errout.adb (Error_Msg): Separate the\n+\ttreatment for warning vs. style messages in inlinings and\n+\tinstantiations. Prevents blowups on calls to Warn_Insertion for\n+\tstyle messages, which should not be called in that case because\n+\tWarning_Msg_Char is not set.\n+\n+2017-09-06  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_prag.adb (Check_VFA_Conflicts): Created\n+\tto group all Volatile_Full_Access checks relating to other\n+\trepresentation pragmas (Mark_Component_Or_Object): Created\n+\tto centeralize the flagging of attributes for the record type\n+\tcomponent case, a pragma applied individually to a component, and\n+\tthe object case.\n+\t(Process_Atomic_Independent_Shared_Volatile):\n+\tAdd propagation of certain pragmas to record components and move\n+\tevaluation of VFA checks\n+\n 2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Check_Postcondition_Use_In_Inlined_Subprogram):"}, {"sha": "7962b7b47dff957023a93a4aa56d6d6a93f52e79", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -2711,6 +2711,20 @@ package body Checks is\n             --  it. We disable checks during its analysis, to prevent an\n             --  infinite recursion.\n \n+            --  If the prefix is an aggregate in an assignment, apply the\n+            --  check to the LHS after assignment, rather than create a\n+            --  redundant temporary. This is only necessary in rare cases\n+            --  of array types (including strings) initialized with an\n+            --  aggregate with an \"others\" clause, either coming from source\n+            --  or generated by an Initialize_Scalars pragma.\n+\n+            elsif Nkind (N) = N_Aggregate\n+              and then Nkind (Parent (N)) = N_Assignment_Statement\n+            then\n+               Insert_Action_After (Parent (N),\n+                 Make_Predicate_Check\n+                   (Typ, Duplicate_Subexpr (Name (Parent (N)))));\n+\n             else\n                Insert_Action (N,\n                  Make_Predicate_Check"}, {"sha": "a83d0c9225e643de9b57fc1cf8db5025ad85ca61", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -503,11 +503,16 @@ package body Errout is\n                        (\"info: in inlined body #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n \n-                  elsif Is_Warning_Msg or Is_Style_Msg then\n+                  elsif Is_Warning_Msg then\n                      Error_Msg_Internal\n                        (Warn_Insertion & \"in inlined body #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n \n+                  elsif Is_Style_Msg then\n+                     Error_Msg_Internal\n+                       (\"style: in inlined body #\",\n+                        Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+\n                   else\n                      Error_Msg_Internal\n                        (\"error in inlined body #\",\n@@ -522,11 +527,16 @@ package body Errout is\n                        (\"info: in instantiation #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n \n-                  elsif Is_Warning_Msg or else Is_Style_Msg then\n+                  elsif Is_Warning_Msg then\n                      Error_Msg_Internal\n                        (Warn_Insertion & \"in instantiation #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n \n+                  elsif Is_Style_Msg then\n+                     Error_Msg_Internal\n+                       (\"style: in instantiation #\",\n+                        Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+\n                   else\n                      Error_Msg_Internal\n                        (\"instantiation error #\","}, {"sha": "7d0fe3babdb5d85ee5ca8c41d14a8520ebc64721", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -1053,9 +1053,13 @@ package body Sem_Aux is\n \n          return\n            Nkind_In (Kind, N_Formal_Object_Declaration,\n-                           N_Formal_Package_Declaration,\n                            N_Formal_Type_Declaration)\n-             or else Is_Formal_Subprogram (E);\n+             or else Is_Formal_Subprogram (E)\n+\n+             or else\n+               (Ekind (E) = E_Package\n+                 and then Nkind (Original_Node (Unit_Declaration_Node (E))) =\n+                    N_Formal_Package_Declaration);\n       end if;\n    end Is_Generic_Formal;\n "}, {"sha": "fdf45db0a92aeaae173bebe4031450ed8bdcf2f1", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -5089,6 +5089,15 @@ package body Sem_Ch12 is\n             Set_Parent_Spec (Pack_Decl, Parent_Spec (N));\n          end if;\n \n+         --  If the context of the instance is subject to SPARK_Mode \"off\" or\n+         --  the annotation is altogether missing, set the global flag which\n+         --  signals Analyze_Pragma to ignore all SPARK_Mode pragmas within\n+         --  the instance.\n+\n+         if SPARK_Mode /= On then\n+            Ignore_SPARK_Mode_Pragmas_In_Instance := True;\n+         end if;\n+\n          Analyze (Pack_Decl);\n          Check_Formal_Packages (Pack_Id);\n          Set_Is_Generic_Instance (Pack_Id, False);"}, {"sha": "958e733cf574a44a6ea1239c2e5790c01601e6bd", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -2649,8 +2649,26 @@ package body Sem_Ch3 is\n                --  in order to perform visibility checks on delayed aspects.\n \n                Adjust_Decl;\n-               Freeze_All (First_Entity (Current_Scope), Decl);\n-               Freeze_From := Last_Entity (Current_Scope);\n+\n+               --  If the current scope is a generic subprogram body. skip\n+               --  the generic formal parameters that are not frozen here.\n+\n+               if Is_Subprogram (Current_Scope)\n+                 and then Nkind (Unit_Declaration_Node (Current_Scope))\n+                   = N_Generic_Subprogram_Declaration\n+                 and then Present (First_Entity (Current_Scope))\n+               then\n+                  while Is_Generic_Formal (Freeze_From) loop\n+                     Freeze_From := Next_Entity (Freeze_From);\n+                  end loop;\n+\n+                  Freeze_All (Freeze_From, Decl);\n+                  Freeze_From := Last_Entity (Current_Scope);\n+\n+               else\n+                  Freeze_All (First_Entity (Current_Scope), Decl);\n+                  Freeze_From := Last_Entity (Current_Scope);\n+               end if;\n \n             --  Current scope is a package specification\n "}, {"sha": "692975b5fd76667b17023b2a7933729d02f6d8f2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 188, "deletions": 102, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -6873,26 +6873,193 @@ package body Sem_Prag is\n       ------------------------------------------------\n \n       procedure Process_Atomic_Independent_Shared_Volatile is\n-         procedure Set_Atomic_VFA (E : Entity_Id);\n+         procedure Check_VFA_Conflicts (Ent : Entity_Id);\n+         --  Apply additional checks for the GNAT pragma Volatile_Full_Access\n+\n+         procedure Mark_Component_Or_Object (Ent : Entity_Id);\n+         --  Appropriately set flags on the given entity (either an array or\n+         --  record component, or an object declaration) according to the\n+         --  current pragma.\n+\n+         procedure Set_Atomic_VFA (Ent : Entity_Id);\n          --  Set given type as Is_Atomic or Is_Volatile_Full_Access. Also, if\n          --  no explicit alignment was given, set alignment to unknown, since\n          --  back end knows what the alignment requirements are for atomic and\n          --  full access arrays. Note: this is necessary for derived types.\n \n+         -------------------------\n+         -- Check_VFA_Conflicts --\n+         -------------------------\n+\n+         procedure Check_VFA_Conflicts (Ent : Entity_Id) is\n+            Comp : Entity_Id;\n+            Typ  : Entity_Id;\n+\n+            VFA_And_Atomic : Boolean := False;\n+            --  Set True if atomic component present\n+\n+            VFA_And_Aliased : Boolean := False;\n+            --  Set True if aliased component present\n+\n+         begin\n+            --  Fetch the type in case we are dealing with an object or\n+            --  component.\n+\n+            if Is_Type (Ent) then\n+               Typ := Ent;\n+            else\n+               pragma Assert (Is_Object (Ent)\n+                 or else\n+                   Nkind (Declaration_Node (Ent)) = N_Component_Declaration);\n+\n+               Typ := Etype (Ent);\n+            end if;\n+\n+            --  Check Atomic and VFA used together\n+\n+            if Prag_Id = Pragma_Volatile_Full_Access\n+              or else Is_Volatile_Full_Access (Ent)\n+            then\n+               if Prag_Id = Pragma_Atomic\n+                 or else Prag_Id = Pragma_Shared\n+                 or else Is_Atomic (Ent)\n+               then\n+                  VFA_And_Atomic := True;\n+\n+               elsif Is_Array_Type (Typ) then\n+                  VFA_And_Atomic := Has_Atomic_Components (Typ);\n+\n+               --  Note: Has_Atomic_Components is not used below, as this flag\n+               --  represents the pragma of the same name, Atomic_Components,\n+               --  which only applies to arrays.\n+\n+               elsif Is_Record_Type (Typ) then\n+                  --  Attributes cannot be applied to discriminants, only\n+                  --  regular record components.\n+\n+                  Comp := First_Component (Typ);\n+                  while Present (Comp) loop\n+                     if Is_Atomic (Comp)\n+                       or else Is_Atomic (Typ)\n+                     then\n+                        VFA_And_Atomic := True;\n+\n+                        exit;\n+                     end if;\n+\n+                     Next_Component (Comp);\n+                  end loop;\n+               end if;\n+\n+               if VFA_And_Atomic then\n+                  Error_Pragma\n+                    (\"cannot have Volatile_Full_Access and Atomic for same \"\n+                     & \"entity\");\n+               end if;\n+            end if;\n+\n+            --  Check for the application of VFA to an entity that has aliased\n+            --  components.\n+\n+            if Prag_Id = Pragma_Volatile_Full_Access then\n+               if Is_Array_Type (Typ)\n+                 and then Has_Aliased_Components (Typ)\n+               then\n+                  VFA_And_Aliased := True;\n+\n+               --  Note: Has_Aliased_Components, like Has_Atomic_Components,\n+               --  and Has_Independent_Components, applies only to arrays.\n+               --  However, this flag does not have a corresponding pragma, so\n+               --  perhaps it should be possible to apply it to record types as\n+               --  well. Should this be done ???\n+\n+               elsif Is_Record_Type (Typ) then\n+                  --  It is possible to have an aliased discriminant, so they\n+                  --  must be checked along with normal components.\n+\n+                  Comp := First_Component_Or_Discriminant (Typ);\n+                  while Present (Comp) loop\n+                     if Is_Aliased (Comp)\n+                       or else Is_Aliased (Etype (Comp))\n+                     then\n+                        VFA_And_Aliased := True;\n+                        Check_SPARK_05_Restriction\n+                          (\"aliased is not allowed\", Comp);\n+\n+                        exit;\n+                     end if;\n+\n+                     Next_Component_Or_Discriminant (Comp);\n+                  end loop;\n+               end if;\n+\n+               if VFA_And_Aliased then\n+                  Error_Pragma\n+                    (\"cannot apply Volatile_Full_Access (aliased component \"\n+                     & \"present)\");\n+               end if;\n+            end if;\n+         end Check_VFA_Conflicts;\n+\n+         ------------------------------\n+         -- Mark_Component_Or_Object --\n+         ------------------------------\n+\n+         procedure Mark_Component_Or_Object (Ent : Entity_Id) is\n+         begin\n+            if Prag_Id = Pragma_Atomic\n+              or else Prag_Id = Pragma_Shared\n+              or else Prag_Id = Pragma_Volatile_Full_Access\n+            then\n+               if Prag_Id = Pragma_Volatile_Full_Access then\n+                  Set_Is_Volatile_Full_Access (Ent);\n+               else\n+                  Set_Is_Atomic (Ent);\n+               end if;\n+\n+               --  If the object declaration has an explicit initialization, a\n+               --  temporary may have to be created to hold the expression, to\n+               --  ensure that access to the object remains atomic.\n+\n+               if Nkind (Parent (Ent)) = N_Object_Declaration\n+                 and then Present (Expression (Parent (Ent)))\n+               then\n+                  Set_Has_Delayed_Freeze (Ent);\n+               end if;\n+            end if;\n+\n+            --  Atomic/Shared/Volatile_Full_Access imply Independent\n+\n+            if Prag_Id /= Pragma_Volatile then\n+               Set_Is_Independent (Ent);\n+\n+               if Prag_Id = Pragma_Independent then\n+                  Record_Independence_Check (N, Ent);\n+               end if;\n+            end if;\n+\n+            --  Atomic/Shared/Volatile_Full_Access imply Volatile\n+\n+            if Prag_Id /= Pragma_Independent then\n+               Set_Is_Volatile (Ent);\n+               Set_Treat_As_Volatile (Ent);\n+            end if;\n+         end Mark_Component_Or_Object;\n+\n          --------------------\n          -- Set_Atomic_VFA --\n          --------------------\n \n-         procedure Set_Atomic_VFA (E : Entity_Id) is\n+         procedure Set_Atomic_VFA (Ent : Entity_Id) is\n          begin\n             if Prag_Id = Pragma_Volatile_Full_Access then\n-               Set_Is_Volatile_Full_Access (E);\n+               Set_Is_Volatile_Full_Access (Ent);\n             else\n-               Set_Is_Atomic (E);\n+               Set_Is_Atomic (Ent);\n             end if;\n \n-            if not Has_Alignment_Clause (E) then\n-               Set_Alignment (E, Uint_0);\n+            if not Has_Alignment_Clause (Ent) then\n+               Set_Alignment (Ent, Uint_0);\n             end if;\n          end Set_Atomic_VFA;\n \n@@ -6926,63 +7093,15 @@ package body Sem_Prag is\n \n          Check_Duplicate_Pragma (E);\n \n-         --  Check Atomic and VFA used together\n-\n-         if (Is_Atomic (E) and then Prag_Id = Pragma_Volatile_Full_Access)\n-           or else (Is_Volatile_Full_Access (E)\n-                     and then (Prag_Id = Pragma_Atomic\n-                                 or else\n-                               Prag_Id = Pragma_Shared))\n-         then\n-            Error_Pragma\n-              (\"cannot have Volatile_Full_Access and Atomic for same entity\");\n-         end if;\n-\n-         --  Check for applying VFA to an entity which has aliased component\n-\n-         if Prag_Id = Pragma_Volatile_Full_Access then\n-            declare\n-               Comp         : Entity_Id;\n-               Aliased_Comp : Boolean := False;\n-               --  Set True if aliased component present\n-\n-            begin\n-               if Is_Array_Type (Etype (E)) then\n-                  Aliased_Comp := Has_Aliased_Components (Etype (E));\n-\n-               --  Record case, too bad Has_Aliased_Components is not also\n-               --  set for records, should it be ???\n-\n-               elsif Is_Record_Type (Etype (E)) then\n-                  Comp := First_Component_Or_Discriminant (Etype (E));\n-                  while Present (Comp) loop\n-                     if Is_Aliased (Comp)\n-                       or else Is_Aliased (Etype (Comp))\n-                     then\n-                        Aliased_Comp := True;\n-                        exit;\n-                     end if;\n-\n-                     Next_Component_Or_Discriminant (Comp);\n-                  end loop;\n-               end if;\n-\n-               if Aliased_Comp then\n-                  Error_Pragma\n-                    (\"cannot apply Volatile_Full_Access (aliased component \"\n-                     & \"present)\");\n-               end if;\n-            end;\n-         end if;\n-\n-         --  Now check appropriateness of the entity\n+         --  Check appropriateness of the entity\n \n          Decl := Declaration_Node (E);\n \n+         --  Deal with the case where the pragma/attribute is applied to a type\n+\n          if Is_Type (E) then\n             if Rep_Item_Too_Early (E, N)\n-                 or else\n-               Rep_Item_Too_Late (E, N)\n+              or else Rep_Item_Too_Late (E, N)\n             then\n                return;\n             else\n@@ -6993,10 +7112,8 @@ package body Sem_Prag is\n             --  currently private, it also belongs on the underlying type.\n \n             if Prag_Id = Pragma_Atomic\n-                 or else\n-               Prag_Id = Pragma_Shared\n-                 or else\n-               Prag_Id = Pragma_Volatile_Full_Access\n+              or else Prag_Id = Pragma_Shared\n+              or else Prag_Id = Pragma_Volatile_Full_Access\n             then\n                Set_Atomic_VFA (E);\n                Set_Atomic_VFA (Base_Type (E));\n@@ -7026,6 +7143,9 @@ package body Sem_Prag is\n                Set_Treat_As_Volatile (Underlying_Type (E));\n             end if;\n \n+         --  Deal with the case where the pragma/attribute applies to a\n+         --  component or object declaration.\n+\n          elsif Nkind (Decl) = N_Object_Declaration\n            or else (Nkind (Decl) = N_Component_Declaration\n                      and then Original_Record_Component (E) = E)\n@@ -7034,50 +7154,16 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            if Prag_Id = Pragma_Atomic\n-                 or else\n-               Prag_Id = Pragma_Shared\n-                 or else\n-               Prag_Id = Pragma_Volatile_Full_Access\n-            then\n-               if Prag_Id = Pragma_Volatile_Full_Access then\n-                  Set_Is_Volatile_Full_Access (E);\n-               else\n-                  Set_Is_Atomic (E);\n-               end if;\n-\n-               --  If the object declaration has an explicit initialization, a\n-               --  temporary may have to be created to hold the expression, to\n-               --  ensure that access to the object remain atomic.\n-\n-               if Nkind (Parent (E)) = N_Object_Declaration\n-                 and then Present (Expression (Parent (E)))\n-               then\n-                  Set_Has_Delayed_Freeze (E);\n-               end if;\n-            end if;\n-\n-            --  Atomic/Shared/Volatile_Full_Access imply Independent\n-\n-            if Prag_Id /= Pragma_Volatile then\n-               Set_Is_Independent (E);\n-\n-               if Prag_Id = Pragma_Independent then\n-                  Record_Independence_Check (N, E);\n-               end if;\n-            end if;\n-\n-            --  Atomic/Shared/Volatile_Full_Access imply Volatile\n-\n-            if Prag_Id /= Pragma_Independent then\n-               Set_Is_Volatile (E);\n-               Set_Treat_As_Volatile (E);\n-            end if;\n-\n+            Mark_Component_Or_Object (E);\n          else\n             Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n          end if;\n \n+         --  Perform the checks needed to assure the proper use of the GNAT\n+         --  pragma Volatile_Full_Access.\n+\n+         Check_VFA_Conflicts (E);\n+\n          --  The following check is only relevant when SPARK_Mode is on as\n          --  this is not a standard Ada legality rule. Pragma Volatile can\n          --  only apply to a full type declaration or an object declaration"}, {"sha": "eef4016ac7c99b2e384fdf070aae6301f12ba68e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269edf01cc14cd15853692d966daf2fb92e2adc/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4269edf01cc14cd15853692d966daf2fb92e2adc", "patch": "@@ -6657,10 +6657,28 @@ package body Sem_Res is\n \n             elsif Full_Analysis then\n \n+               --  Do not inline calls inside expression functions, as this\n+               --  would prevent interpreting them as logical formulas in\n+               --  GNATprove. Only issue a message when the body has been seen,\n+               --  otherwise this leads to spurious messages on callees that\n+               --  are themselves expression functions.\n+\n+               if Present (Current_Subprogram)\n+                    and then\n+                  Is_Expression_Function_Or_Completion (Current_Subprogram)\n+               then\n+                  if Present (Body_Id)\n+                    and then Present (Body_To_Inline (Nam_Decl))\n+                  then\n+                     Cannot_Inline\n+                       (\"cannot inline & (inside expression function)?\",\n+                        N, Nam_UA);\n+                  end if;\n+\n                --  With the one-pass inlining technique, a call cannot be\n                --  inlined if the corresponding body has not been seen yet.\n \n-               if No (Body_Id) then\n+               elsif No (Body_Id) then\n                   Cannot_Inline\n                     (\"cannot inline & (body not seen yet)?\", N, Nam_UA);\n \n@@ -6671,18 +6689,6 @@ package body Sem_Res is\n                elsif No (Body_To_Inline (Nam_Decl)) then\n                   null;\n \n-               --  Do not inline calls inside expression functions, as this\n-               --  would prevent interpreting them as logical formulas in\n-               --  GNATprove.\n-\n-               elsif Present (Current_Subprogram)\n-                       and then\n-                     Is_Expression_Function_Or_Completion (Current_Subprogram)\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (inside expression function)?\",\n-                     N, Nam_UA);\n-\n                --  Calls cannot be inlined inside potentially unevaluated\n                --  expressions, as this would create complex actions inside\n                --  expressions, that are not handled by GNATprove."}]}