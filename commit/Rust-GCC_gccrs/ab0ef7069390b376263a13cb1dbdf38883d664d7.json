{"sha": "ab0ef7069390b376263a13cb1dbdf38883d664d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwZWY3MDY5MzkwYjM3NjI2M2ExM2NiMWRiZGYzODg4M2Q2NjRkNw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-10-25T08:02:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-10-25T08:02:08Z"}, "message": "re PR tree-optimization/50596 (Problems in vectorization of condition expression)\n\n\tPR tree-optimization/50596\n\t* tree-vect-stmts.c (vect_mark_relevant): Only use\n\tFOR_EACH_IMM_USE_FAST if lhs is SSA_NAME.\n\t(vectorizable_store): If is_pattern_stmt_p look through\n\tVIEW_CONVERT_EXPR on lhs.\n\t* tree-vect-patterns.c (check_bool_pattern, adjust_bool_pattern):\n\tUse unsigned type instead of signed.\n\t(vect_recog_bool_pattern): Optimize also stores into bool memory in\n\taddition to casts from bool to integral types.\n\t(vect_mark_pattern_stmts): If pattern_stmt already has vinfo\n\tcreated, don't create it again.\n\n\t* gcc.dg/vect/vect-cond-10.c: New test.\n\nFrom-SVN: r180424", "tree": {"sha": "98fa7d9be8e8feb32d1a93e13c5d8bc78f7ac8b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98fa7d9be8e8feb32d1a93e13c5d8bc78f7ac8b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0ef7069390b376263a13cb1dbdf38883d664d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0ef7069390b376263a13cb1dbdf38883d664d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0ef7069390b376263a13cb1dbdf38883d664d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0ef7069390b376263a13cb1dbdf38883d664d7/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "db8543789305f6d56005bba91f784831d3745970", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db8543789305f6d56005bba91f784831d3745970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db8543789305f6d56005bba91f784831d3745970"}], "stats": {"total": 269, "additions": 249, "deletions": 20}, "files": [{"sha": "3f9af64907626d51c1e004249bb6a45cfabcd363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab0ef7069390b376263a13cb1dbdf38883d664d7", "patch": "@@ -1,3 +1,17 @@\n+2011-10-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* tree-vect-stmts.c (vect_mark_relevant): Only use\n+\tFOR_EACH_IMM_USE_FAST if lhs is SSA_NAME.\n+\t(vectorizable_store): If is_pattern_stmt_p look through\n+\tVIEW_CONVERT_EXPR on lhs.\n+\t* tree-vect-patterns.c (check_bool_pattern, adjust_bool_pattern):\n+\tUse unsigned type instead of signed.\n+\t(vect_recog_bool_pattern): Optimize also stores into bool memory in\n+\taddition to casts from bool to integral types.\n+\t(vect_mark_pattern_stmts): If pattern_stmt already has vinfo\n+\tcreated, don't create it again.\n+\n 2011-10-25  Kai Tietz  <ktietz@redhat.com>\n \n \t* config/i386/i386.c (ix86_frame_pointer_required): Require"}, {"sha": "7cf4d3f1aae0fda75ff153c521e0d3ef540fed96", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ab0ef7069390b376263a13cb1dbdf38883d664d7", "patch": "@@ -1,3 +1,8 @@\n+2011-10-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* gcc.dg/vect/vect-cond-10.c: New test.\n+\n 2011-10-24  Joey Ye  <joey.ye@arm.com>\n \n \t* gcc.target/arm/pr42575.c: Remove architecture option."}, {"sha": "687d42f0591572877253c05b39346b3249dd8ed3", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-10.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-10.c?ref=ab0ef7069390b376263a13cb1dbdf38883d664d7", "patch": "@@ -0,0 +1,165 @@\n+/* { dg-require-effective-target vect_cond_mixed } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+float a[N], b[N], c[N], d[N];\n+_Bool k[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      k[i] = x & y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = (a[i] < b[i]) & (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      k[i] = x | y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = (a[i] < b[i]) | (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (_Bool *p)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      p[i] = x & y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f6 (_Bool *p)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    p[i] = (a[i] < b[i]) & (c[i] < d[i]);\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f7 (_Bool *p)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int x = a[i] < b[i];\n+      int y = c[i] < d[i];\n+      p[i] = x | y;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (_Bool *p)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    p[i] = (a[i] < b[i]) | (c[i] < d[i]);\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); a[i] = - i - 1; b[i] = i + 1; break;\n+\tcase 1: a[i] = 0; b[i] = 0; break;\n+\tcase 2: a[i] = i + 1; b[i] = - i - 1; break;\n+\tcase 3: a[i] = i; b[i] = i + 7; break;\n+\tcase 4: a[i] = i; b[i] = i; break;\n+\tcase 5: a[i] = i + 16; b[i] = i + 3; break;\n+\tcase 6: a[i] = - i - 5; b[i] = - i; break;\n+\tcase 7: a[i] = - i; b[i] = - i; break;\n+\tcase 8: a[i] = - i; b[i] = - i - 7; break;\n+\t}\n+    }\n+  for (i = 0; i < N; i++)\n+    {\n+      switch ((i / 9) % 3)\n+\t{\n+\tcase 0: c[i] = a[i / 9]; d[i] = b[i / 9]; break;\n+\tcase 1: c[i] = a[i / 9 + 3]; d[i] = b[i / 9 + 3]; break;\n+\tcase 2: c[i] = a[i / 9 + 6]; d[i] = b[i / 9 + 6]; break;\n+\t}\n+    }\n+  f1 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f3 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f5 (k);\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f6 (k);\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 && ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f7 (k);\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+  f8 (k);\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 || ((i / 9) % 3) == 0))\n+      abort ();\n+  __builtin_memset (k, 0, sizeof (k));\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"note: vectorized 1 loops\" 8 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1386a747955de03d19e07c89a515235d67e9fcfc", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=ab0ef7069390b376263a13cb1dbdf38883d664d7", "patch": "@@ -1617,7 +1617,7 @@ check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n \t    {\n \t      enum machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n \t      tree itype\n-\t\t= build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 0);\n+\t\t= build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 1);\n \t      vecitype = get_vectype_for_scalar_type (itype);\n \t      if (vecitype == NULL_TREE)\n \t\treturn false;\n@@ -1813,11 +1813,11 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n     default:\n       gcc_assert (TREE_CODE_CLASS (rhs_code) == tcc_comparison);\n       if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n-\t  || TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n+\t  || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n \t{\n \t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n \t  itype\n-\t    = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 0);\n+\t    = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 1);\n \t}\n       else\n \titype = TREE_TYPE (rhs1);\n@@ -1933,6 +1933,44 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n       return pattern_stmt;\n     }\n+  else if (rhs_code == SSA_NAME\n+\t   && STMT_VINFO_DATA_REF (stmt_vinfo))\n+    {\n+      stmt_vec_info pattern_stmt_info;\n+      vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n+      gcc_assert (vectype != NULL_TREE);\n+      if (!check_bool_pattern (var, loop_vinfo))\n+\treturn NULL;\n+\n+      rhs = adjust_bool_pattern (var, TREE_TYPE (vectype), NULL_TREE, stmts);\n+      lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vectype), lhs);\n+      if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+\t{\n+\t  tree rhs2 = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+\t  gimple cast_stmt\n+\t    = gimple_build_assign_with_ops (NOP_EXPR, rhs2, rhs, NULL_TREE);\n+\t  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = cast_stmt;\n+\t  rhs = rhs2;\n+\t}\n+      pattern_stmt\n+\t= gimple_build_assign_with_ops (SSA_NAME, lhs, rhs, NULL_TREE);\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL);\n+      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+      STMT_VINFO_DATA_REF (pattern_stmt_info)\n+\t= STMT_VINFO_DATA_REF (stmt_vinfo);\n+      STMT_VINFO_DR_BASE_ADDRESS (pattern_stmt_info)\n+\t= STMT_VINFO_DR_BASE_ADDRESS (stmt_vinfo);\n+      STMT_VINFO_DR_INIT (pattern_stmt_info) = STMT_VINFO_DR_INIT (stmt_vinfo);\n+      STMT_VINFO_DR_OFFSET (pattern_stmt_info)\n+\t= STMT_VINFO_DR_OFFSET (stmt_vinfo);\n+      STMT_VINFO_DR_STEP (pattern_stmt_info) = STMT_VINFO_DR_STEP (stmt_vinfo);\n+      STMT_VINFO_DR_ALIGNED_TO (pattern_stmt_info)\n+\t= STMT_VINFO_DR_ALIGNED_TO (stmt_vinfo);\n+      *type_out = vectype;\n+      *type_in = vectype;\n+      VEC_safe_push (gimple, heap, *stmts, last_stmt);\n+      return pattern_stmt;\n+    }\n   else\n     return NULL;\n }\n@@ -1949,19 +1987,22 @@ vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (orig_stmt_info);\n   gimple def_stmt;\n \n-  set_vinfo_for_stmt (pattern_stmt,\n-                      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n-  gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n   pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n+  if (pattern_stmt_info == NULL)\n+    {\n+      pattern_stmt_info = new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL);\n+      set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+    }\n+  gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt));\n \n   STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt;\n   STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n-\t= STMT_VINFO_DEF_TYPE (orig_stmt_info);\n+    = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n   STMT_VINFO_VECTYPE (pattern_stmt_info) = pattern_vectype;\n   STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n   STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n   STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info)\n-\t= STMT_VINFO_PATTERN_DEF_STMT (orig_stmt_info);\n+    = STMT_VINFO_PATTERN_DEF_STMT (orig_stmt_info);\n   if (STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info))\n     {\n       def_stmt = STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info);"}, {"sha": "1aba74601c1bd07f4973f9a0c466d8786f37bead", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0ef7069390b376263a13cb1dbdf38883d664d7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ab0ef7069390b376263a13cb1dbdf38883d664d7", "patch": "@@ -159,19 +159,20 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n           /* This use is out of pattern use, if LHS has other uses that are\n              pattern uses, we should mark the stmt itself, and not the pattern\n              stmt.  */\n-          FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-            {\n-              if (is_gimple_debug (USE_STMT (use_p)))\n-                continue;\n-              use_stmt = USE_STMT (use_p);\n+\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t    FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+\t      {\n+\t\tif (is_gimple_debug (USE_STMT (use_p)))\n+\t\t  continue;\n+\t\tuse_stmt = USE_STMT (use_p);\n \n-              if (vinfo_for_stmt (use_stmt)\n-                  && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (use_stmt)))\n-                {\n-                  found = true;\n-                  break;\n-                }\n-            }\n+\t\tif (vinfo_for_stmt (use_stmt)\n+\t\t    && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (use_stmt)))\n+\t\t  {\n+\t\t    found = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n         }\n \n       if (!found)\n@@ -3722,6 +3723,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     return false;\n \n   scalar_dest = gimple_assign_lhs (stmt);\n+  if (TREE_CODE (scalar_dest) == VIEW_CONVERT_EXPR\n+      && is_pattern_stmt_p (stmt_info))\n+    scalar_dest = TREE_OPERAND (scalar_dest, 0);\n   if (TREE_CODE (scalar_dest) != ARRAY_REF\n       && TREE_CODE (scalar_dest) != INDIRECT_REF\n       && TREE_CODE (scalar_dest) != COMPONENT_REF"}]}