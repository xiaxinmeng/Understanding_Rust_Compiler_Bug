{"sha": "df04438806922874ac6372c4f3e990a9fc7dfd90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYwNDQzODgwNjkyMjg3NGFjNjM3MmM0ZjNlOTkwYTlmYzdkZmQ5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-04T15:29:52Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-04T15:29:52Z"}, "message": "gcj.texi: Fix a typo.\n\n\t* gcj.texi: Fix a typo.\n\t* lang.c: Fix a comment typo.\n\nFrom-SVN: r97551", "tree": {"sha": "8490d56079283c01075dcee78421b4ae9fcf7ea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8490d56079283c01075dcee78421b4ae9fcf7ea1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df04438806922874ac6372c4f3e990a9fc7dfd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df04438806922874ac6372c4f3e990a9fc7dfd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df04438806922874ac6372c4f3e990a9fc7dfd90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df04438806922874ac6372c4f3e990a9fc7dfd90/comments", "author": null, "committer": null, "parents": [{"sha": "5e77eb534bb84d6afdf489f007079ce90fcf8b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e77eb534bb84d6afdf489f007079ce90fcf8b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e77eb534bb84d6afdf489f007079ce90fcf8b9d"}], "stats": {"total": 9, "additions": 7, "deletions": 2}, "files": [{"sha": "6d4d4bfa314daacfde50ab648f983727a0b199c0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=df04438806922874ac6372c4f3e990a9fc7dfd90", "patch": "@@ -1,3 +1,8 @@\n+2005-04-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* gcj.texi: Fix a typo.\n+\t* lang.c: Fix a comment typo.\n+\n 2005-04-01  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* gcj.texi (Invoking gij): Add descriptions of new -X options."}, {"sha": "523a0b59b0256ec6d85658338cb4b30b3f68ef54", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=df04438806922874ac6372c4f3e990a9fc7dfd90", "patch": "@@ -1653,7 +1653,7 @@ java::util::Hashtable *ht = new java::util::Hashtable(120);\n @node Memory allocation\n @section Memory allocation\n \n-When allocting memory in @acronym{CNI} methods it is best to handle\n+When allocating memory in @acronym{CNI} methods it is best to handle\n out-of-memory conditions by throwing a Java exception.  These\n functions are provided for that purpose:\n "}, {"sha": "e0d2672b2a5d2f4f9500edda4cedf5a232a1af19", "filename": "gcc/java/lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df04438806922874ac6372c4f3e990a9fc7dfd90/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=df04438806922874ac6372c4f3e990a9fc7dfd90", "patch": "@@ -801,7 +801,7 @@ merge_init_test_initialization (void **entry, void *x)\n   does this by setting the DECL_INITIAL of the init_test_decl for that\n   class, and no initializations are emitted for that class.\n \n-  However, what if the method that is suppoed to do the initialization\n+  However, what if the method that is supposed to do the initialization\n   is itself inlined in the caller?  When expanding the called method\n   we'll assume that the class initialization has already been done,\n   because the DECL_INITIAL of the init_test_decl is set."}]}