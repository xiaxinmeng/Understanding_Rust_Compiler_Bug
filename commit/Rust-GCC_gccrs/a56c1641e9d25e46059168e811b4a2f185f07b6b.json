{"sha": "a56c1641e9d25e46059168e811b4a2f185f07b6b", "node_id": "C_kwDOANBUbNoAKGE1NmMxNjQxZTlkMjVlNDYwNTkxNjhlODExYjRhMmYxODVmMDdiNmI", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-09T17:59:55Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-08-09T18:02:44Z"}, "message": "Use PTEST to perform AND in TImode STV of (A & B) != 0 on x86_64.\n\nThis x86_64 backend patch allows TImode STV to take advantage of the\nfact that the PTEST instruction performs an AND operation.  Previously\nPTEST was (mostly) used for comparison against zero, by using the same\noperands.  The benefits are demonstrated by the new test case:\n\n__int128 a,b;\nint foo()\n{\n  return (a & b) != 0;\n}\n\nCurrently with -O2 -msse4 we generate:\n\n        movdqa  a(%rip), %xmm0\n        pand    b(%rip), %xmm0\n        xorl    %eax, %eax\n        ptest   %xmm0, %xmm0\n        setne   %al\n        ret\n\nwith this patch we now generate:\n\n        movdqa  a(%rip), %xmm0\n        xorl    %eax, %eax\n        ptest   b(%rip), %xmm0\n        setne   %al\n        ret\n\nTechnically, the magic happens using new define_insn_and_split patterns.\nUsing two patterns allows this transformation to performed independently\nof whether TImode STV is run before or after combine.  The one tricky\ncase is that immediate constant operands of the AND behave slightly\ndifferently between TImode and V1TImode: All V1TImode immediate operands\nbecomes loads, but for TImode only values that are not hilo_operands\nneed to be loaded.  Hence the new *testti_doubleword accepts any\ngeneral_operand, but internally during split calls force_reg whenever\nthe second operand is not x86_64_hilo_general_operand.  This required\n(benefits from) some tweaks to TImode STV to support CONST_WIDE_INT in\nmore places, using CONST_SCALAR_INT_P instead of just CONST_INT_P.\n\n2022-08-09  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386-features.cc (scalar_chain::convert_compare):\n\tCreate new pseudos only when/if needed.  Add support for TEST,\n\ti.e. (COMPARE (AND x y) (const_int 0)), using UNSPEC_PTEST.\n\tWhen broadcasting V2DImode and V4SImode use new pseudo register.\n\t(timode_scalar_chain::convert_op): Do nothing if operand is\n\talready V1TImode.  Avoid generating useless SUBREG conversions,\n\ti.e. (SUBREG:V1TImode (REG:V1TImode) 0).  Handle CONST_WIDE_INT\n\tin addition to CONST_INT by using CONST_SCALAR_INT_P.\n\t(convertible_comparison_p): Use CONST_SCALAR_INT_P to match both\n\tCONST_WIDE_INT and CONST_INT.  Recognize new *testti_doubleword\n\tpattern as an STV candidate.\n\t(timode_scalar_to_vector_candidate_p): Allow CONST_SCALAR_INT_P\n\toperands in binary logic operations.\n\n\t* config/i386/i386.cc (ix86_rtx_costs) <case UNSPEC>: Add costs\n\tfor UNSPEC_PTEST; a PTEST that performs an AND has the same cost\n\tas regular PTEST, i.e. cost->sse_op.\n\n\t* config/i386/i386.md (*testti_doubleword): New pre-reload\n\tdefine_insn_and_split that recognizes comparison of TI mode AND\n\tagainst zero.\n\t* config/i386/sse.md (*ptest<mode>_and): New pre-reload\n\tdefine_insn_and_split that recognizes UNSPEC_PTEST of identical\n\tAND operands.\n\ngcc/testsuite/ChangeLog\n\t* gcc.target/i386/sse4_1-stv-8.c: New test case.", "tree": {"sha": "bd0b6af060cf38ca5546b7466c96135c60096e16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd0b6af060cf38ca5546b7466c96135c60096e16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a56c1641e9d25e46059168e811b4a2f185f07b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56c1641e9d25e46059168e811b4a2f185f07b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56c1641e9d25e46059168e811b4a2f185f07b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56c1641e9d25e46059168e811b4a2f185f07b6b/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc14f1963dfefead588a4cd8902d641ed69255c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc14f1963dfefead588a4cd8902d641ed69255c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc14f1963dfefead588a4cd8902d641ed69255c"}], "stats": {"total": 156, "additions": 129, "deletions": 27}, "files": [{"sha": "effc2f24494766331ab9978eb15e707d1a9d4d90", "filename": "gcc/config/i386/i386-features.cc", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386-features.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.cc?ref=a56c1641e9d25e46059168e811b4a2f185f07b6b", "patch": "@@ -919,8 +919,7 @@ general_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n rtx\n scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n {\n-  rtx tmp = gen_reg_rtx (vmode);\n-  rtx src;\n+  rtx src, tmp;\n   /* Comparison against anything other than zero, requires an XOR.  */\n   if (op2 != const0_rtx)\n     {\n@@ -929,6 +928,7 @@ scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n       /* If both operands are MEMs, explicitly load the OP1 into TMP.  */\n       if (MEM_P (op1) && MEM_P (op2))\n \t{\n+\t  tmp = gen_reg_rtx (vmode);\n \t  emit_insn_before (gen_rtx_SET (tmp, op1), insn);\n \t  src = tmp;\n \t}\n@@ -943,34 +943,56 @@ scalar_chain::convert_compare (rtx op1, rtx op2, rtx_insn *insn)\n       rtx op12 = XEXP (op1, 1);\n       convert_op (&op11, insn);\n       convert_op (&op12, insn);\n-      if (MEM_P (op11))\n+      if (!REG_P (op11))\n \t{\n+\t  tmp = gen_reg_rtx (vmode);\n \t  emit_insn_before (gen_rtx_SET (tmp, op11), insn);\n \t  op11 = tmp;\n \t}\n       src = gen_rtx_AND (vmode, gen_rtx_NOT (vmode, op11), op12);\n     }\n+  else if (GET_CODE (op1) == AND)\n+    {\n+      rtx op11 = XEXP (op1, 0);\n+      rtx op12 = XEXP (op1, 1);\n+      convert_op (&op11, insn);\n+      convert_op (&op12, insn);\n+      if (!REG_P (op11))\n+\t{\n+\t  tmp = gen_reg_rtx (vmode);\n+\t  emit_insn_before (gen_rtx_SET (tmp, op11), insn);\n+\t  op11 = tmp;\n+\t}\n+      return gen_rtx_UNSPEC (CCmode, gen_rtvec (2, op11, op12),\n+\t\t\t     UNSPEC_PTEST);\n+    }\n   else\n     {\n       convert_op (&op1, insn);\n       src = op1;\n     }\n-  emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+\n+  if (!REG_P (src))\n+    {\n+      tmp = gen_reg_rtx (vmode);\n+      emit_insn_before (gen_rtx_SET (tmp, src), insn);\n+      src = tmp;\n+    }\n \n   if (vmode == V2DImode)\n-    emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (tmp),\n-\t\t\t\t\t\t  copy_rtx_if_shared (tmp),\n-\t\t\t\t\t\t  copy_rtx_if_shared (tmp)),\n-\t\t      insn);\n+    {\n+      tmp = gen_reg_rtx (vmode);\n+      emit_insn_before (gen_vec_interleave_lowv2di (tmp, src, src), insn);\n+      src = tmp;\n+    }\n   else if (vmode == V4SImode)\n-    emit_insn_before (gen_sse2_pshufd (copy_rtx_if_shared (tmp),\n-\t\t\t\t       copy_rtx_if_shared (tmp),\n-\t\t\t\t       const0_rtx),\n-\t\t      insn);\n-\n-  return gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (tmp),\n-\t\t\t\t\t       copy_rtx_if_shared (tmp)),\n-\t\t\t UNSPEC_PTEST);\n+    {\n+      tmp = gen_reg_rtx (vmode);\n+      emit_insn_before (gen_sse2_pshufd (tmp, src, const0_rtx), insn);\n+      src = tmp;\n+    }\n+\n+  return gen_rtx_UNSPEC (CCmode, gen_rtvec (2, src, src), UNSPEC_PTEST);\n }\n \n /* Helper function for converting INSN to vector mode.  */\n@@ -1289,26 +1311,29 @@ timode_scalar_chain::fix_debug_reg_uses (rtx reg)\n void\n timode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n {\n+  if (GET_MODE (*op) == V1TImode)\n+    return;\n+\n   *op = copy_rtx_if_shared (*op);\n \n   if (REG_P (*op))\n     *op = gen_rtx_SUBREG (V1TImode, *op, 0);\n   else if (MEM_P (*op))\n     {\n       rtx tmp = gen_reg_rtx (V1TImode);\n-      emit_insn_before (gen_rtx_SET (gen_rtx_SUBREG (V1TImode, tmp, 0),\n+      emit_insn_before (gen_rtx_SET (tmp,\n \t\t\t\t     gen_gpr_to_xmm_move_src (V1TImode, *op)),\n \t\t\tinsn);\n-      *op = gen_rtx_SUBREG (V1TImode, tmp, 0);\n+      *op = tmp;\n \n       if (dump_file)\n \tfprintf (dump_file, \"  Preloading operand for insn %d into r%d\\n\",\n \t\t INSN_UID (insn), REGNO (tmp));\n     }\n-  else if (CONST_INT_P (*op))\n+  else if (CONST_SCALAR_INT_P (*op))\n     {\n       rtx vec_cst;\n-      rtx tmp = gen_rtx_SUBREG (V1TImode, gen_reg_rtx (TImode), 0);\n+      rtx tmp = gen_reg_rtx (V1TImode);\n \n       /* Prefer all ones vector in case of -1.  */\n       if (constm1_operand (*op, TImode))\n@@ -1329,7 +1354,7 @@ timode_scalar_chain::convert_op (rtx *op, rtx_insn *insn)\n \t  emit_insn_before (seq, insn);\n \t}\n \n-      emit_insn_before (gen_move_insn (copy_rtx (tmp), vec_cst), insn);\n+      emit_insn_before (gen_move_insn (tmp, vec_cst), insn);\n       *op = tmp;\n     }\n   else\n@@ -1609,14 +1634,26 @@ convertible_comparison_p (rtx_insn *insn, enum machine_mode mode)\n   rtx op2 = XEXP (src, 1);\n \n   /* *cmp<dwi>_doubleword.  */\n-  if ((CONST_INT_P (op1)\n+  if ((CONST_SCALAR_INT_P (op1)\n        || ((REG_P (op1) || MEM_P (op1))\n \t   && GET_MODE (op1) == mode))\n-      && (CONST_INT_P (op2)\n+      && (CONST_SCALAR_INT_P (op2)\n \t  || ((REG_P (op2) || MEM_P (op2))\n \t      && GET_MODE (op2) == mode)))\n     return true;\n \n+  /* *testti_doubleword.  */\n+  if (op2 == const0_rtx\n+      && GET_CODE (op1) == AND\n+      && REG_P (XEXP (op1, 0)))\n+    {\n+      rtx op12 = XEXP (op1, 1);\n+      return GET_MODE (XEXP (op1, 0)) == TImode\n+\t     && (CONST_SCALAR_INT_P (op12)\n+\t\t || ((REG_P (op12) || MEM_P (op12))\n+\t\t     && GET_MODE (op12) == TImode));\n+    }\n+\n   /* *test<dwi>_not_doubleword.  */\n   if (op2 == const0_rtx\n       && GET_CODE (op1) == AND\n@@ -1803,15 +1840,21 @@ timode_scalar_to_vector_candidate_p (rtx_insn *insn)\n       if (!MEM_P (dst)\n \t  && GET_CODE (XEXP (src, 0)) == NOT\n \t  && REG_P (XEXP (XEXP (src, 0), 0))\n-\t  && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1))))\n+\t  && (REG_P (XEXP (src, 1))\n+\t      || CONST_SCALAR_INT_P (XEXP (src, 1))\n+\t      || timode_mem_p (XEXP (src, 1))))\n \treturn true;\n       return REG_P (XEXP (src, 0))\n-\t     && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1)));\n+\t     && (REG_P (XEXP (src, 1))\n+\t\t || CONST_SCALAR_INT_P (XEXP (src, 1))\n+\t\t || timode_mem_p (XEXP (src, 1)));\n \n     case IOR:\n     case XOR:\n       return REG_P (XEXP (src, 0))\n-\t     && (REG_P (XEXP (src, 1)) || timode_mem_p (XEXP (src, 1)));\n+\t     && (REG_P (XEXP (src, 1))\n+\t\t || CONST_SCALAR_INT_P (XEXP (src, 1))\n+\t\t || timode_mem_p (XEXP (src, 1)));\n \n     case NOT:\n       return REG_P (XEXP (src, 0)) || timode_mem_p (XEXP (src, 0));"}, {"sha": "5be76e1dd6ffb8288b31a15635b05e85cce245e1", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=a56c1641e9d25e46059168e811b4a2f185f07b6b", "patch": "@@ -21063,11 +21063,25 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case UNSPEC:\n       if (XINT (x, 1) == UNSPEC_TP)\n \t*total = 0;\n-      else if (XINT(x, 1) == UNSPEC_VTERNLOG)\n+      else if (XINT (x, 1) == UNSPEC_VTERNLOG)\n \t{\n \t  *total = cost->sse_op;\n \t  return true;\n \t}\n+      else if (XINT (x, 1) == UNSPEC_PTEST)\n+\t{\n+\t  *total = cost->sse_op;\n+\t  if (XVECLEN (x, 0) == 2\n+\t      && GET_CODE (XVECEXP (x, 0, 0)) == AND)\n+\t    {\n+\t      rtx andop = XVECEXP (x, 0, 0);\n+\t      *total += rtx_cost (XEXP (andop, 0), GET_MODE (andop),\n+\t\t\t\t  AND, opno, speed)\n+\t\t\t+ rtx_cost (XEXP (andop, 1), GET_MODE (andop),\n+\t\t\t\t    AND, opno, speed);\n+\t      return true;\n+\t    }\n+\t}\n       return false;\n \n     case VEC_SELECT:"}, {"sha": "2fde8cdf48b3b7afc1967ac111b7ab820be22408", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a56c1641e9d25e46059168e811b4a2f185f07b6b", "patch": "@@ -9756,6 +9756,27 @@\n   [(set_attr \"type\" \"test\")\n    (set_attr \"mode\" \"QI\")])\n \n+;; Provide a *testti instruction that STV can implement using ptest.\n+;; This pattern splits into *andti3_doubleword and *cmpti_doubleword.\n+(define_insn_and_split \"*testti_doubleword\"\n+  [(set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ\n+\t  (and:TI (match_operand:TI 0 \"register_operand\")\n+\t\t  (match_operand:TI 1 \"general_operand\"))\n+\t  (const_int 0)))]\n+  \"TARGET_64BIT\n+   && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(parallel [(set (match_dup 2) (and:TI (match_dup 0) (match_dup 1)))\n+              (clobber (reg:CC FLAGS_REG))])\n+   (set (reg:CCZ FLAGS_REG) (compare:CCZ (match_dup 2) (const_int 0)))]\n+{\n+  operands[2] = gen_reg_rtx (TImode);\n+  if (!x86_64_hilo_general_operand (operands[1], TImode))\n+    operands[1] = force_reg (TImode, operands[1]);\n+})\n+\n ;; Combine likes to form bit extractions for some tests.  Humor it.\n (define_insn_and_split \"*testqi_ext_3\"\n   [(set (match_operand 0 \"flags_reg_operand\")"}, {"sha": "ccd9d002e9315a0ed9f80c14cd1dd1abff79b0e0", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=a56c1641e9d25e46059168e811b4a2f185f07b6b", "patch": "@@ -23021,6 +23021,19 @@\n    (set_attr \"prefix\" \"orig,orig,vex\")\n    (set_attr \"mode\" \"TI\")])\n \n+(define_insn_and_split \"*ptest<mode>_and\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(unspec:CC [(and:V_AVX (match_operand:V_AVX 0 \"register_operand\")\n+\t\t\t       (match_operand:V_AVX 1 \"vector_operand\"))\n+\t\t    (and:V_AVX (match_dup 0) (match_dup 1))]\n+\t\t   UNSPEC_PTEST))]\n+  \"TARGET_SSE4_1\n+   && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(unspec:CC [(match_dup 0) (match_dup 1)] UNSPEC_PTEST))])\n+\n (define_expand \"nearbyint<mode>2\"\n   [(set (match_operand:VFH 0 \"register_operand\")\n \t(unspec:VFH"}, {"sha": "5c5d803797be9f784e8e2699ea0ac7af942dab35", "filename": "gcc/testsuite/gcc.target/i386/sse4_1-stv-8.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56c1641e9d25e46059168e811b4a2f185f07b6b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_1-stv-8.c?ref=a56c1641e9d25e46059168e811b4a2f185f07b6b", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -msse4.1 -mstv -mno-stackrealign\" } */\n+\n+__int128 a,b;\n+int foo()\n+{\n+  return (a & b) != 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"pand\" } } */\n+/* { dg-final { scan-assembler \"ptest\" } } */"}]}