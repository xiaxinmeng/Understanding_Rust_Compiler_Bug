{"sha": "e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVhNThmYWNhYTM3YWZmNTllYjQwZmM1OWIwY2Y4Y2RjNzI0Y2I2Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T10:01:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T10:01:41Z"}, "message": "[multiple changes]\n\n2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb: Improve error message on untagged equality.\n\t* sem.adb (Semantics): Include subprogram bodies that act as spec.\n\n2010-09-09  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch13.adb, exp_ch13.adb: Undo previous change, unneeded.\n\nFrom-SVN: r164062", "tree": {"sha": "4ed6d679523b783db5bcc6bfabe3a90e928c7c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ed6d679523b783db5bcc6bfabe3a90e928c7c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/comments", "author": null, "committer": null, "parents": [{"sha": "7a963087d4ac84018143595d1a61c008453b70bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a963087d4ac84018143595d1a61c008453b70bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a963087d4ac84018143595d1a61c008453b70bd"}], "stats": {"total": 327, "additions": 180, "deletions": 147}, "files": [{"sha": "c6e3b6213ea6408053d615c1bc149b35e6d9dc55", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "patch": "@@ -1,3 +1,12 @@\n+2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Improve error message on untagged equality.\n+\t* sem.adb (Semantics): Include subprogram bodies that act as spec.\n+\n+2010-09-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch13.adb, exp_ch13.adb: Undo previous change, unneeded.\n+\n 2010-09-09  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch13.adb, sem_ch6.adb, exp_ch3.adb: Minor reformatting."}, {"sha": "93303f9a21c209237a97ae15051461b14357a129", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "patch": "@@ -312,6 +312,12 @@ package body Exp_Ch3 is\n    --  invoking the inherited subprogram's parent subprogram and extended\n    --  with a null association list.\n \n+   function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id;\n+   --  Ada 2005 (AI-251): Makes specs for null procedures associated with any\n+   --  null procedures inherited from an interface type that have not been\n+   --  overridden. Only one null procedure will be created for a given set of\n+   --  inherited null procedures with homographic profiles.\n+\n    function Predef_Spec_Or_Body\n      (Loc      : Source_Ptr;\n       Tag_Typ  : Entity_Id;\n@@ -5882,8 +5888,8 @@ package body Exp_Ch3 is\n       --  user-defined equality function). Used to pass this entity from\n       --  Make_Predefined_Primitive_Specs to Predefined_Primitive_Bodies.\n \n-      Wrapper_Decl_List   : List_Id := No_List;\n-      Wrapper_Body_List   : List_Id := No_List;\n+      Wrapper_Decl_List : List_Id := No_List;\n+      Wrapper_Body_List : List_Id := No_List;\n \n    --  Start of processing for Expand_Freeze_Record_Type\n \n@@ -6086,6 +6092,20 @@ package body Exp_Ch3 is\n                Insert_List_Before_And_Analyze (N, Wrapper_Decl_List);\n             end if;\n \n+            --  Ada 2005 (AI-251): For a nonabstract type extension, build\n+            --  null procedure declarations for each set of homographic null\n+            --  procedures that are inherited from interface types but not\n+            --  overridden. This is done to ensure that the dispatch table\n+            --  entry associated with such null primitives are properly filled.\n+\n+            if Ada_Version >= Ada_05\n+              and then Etype (Def_Id) /= Def_Id\n+              and then not Is_Abstract_Type (Def_Id)\n+              and then Has_Interfaces (Def_Id)\n+            then\n+               Insert_Actions (N, Make_Null_Procedure_Specs (Def_Id));\n+            end if;\n+\n             Set_Is_Frozen (Def_Id);\n             Set_All_DT_Position (Def_Id);\n \n@@ -8004,6 +8024,95 @@ package body Exp_Ch3 is\n       end if;\n    end Make_Eq_If;\n \n+   -------------------------------\n+   -- Make_Null_Procedure_Specs --\n+   -------------------------------\n+\n+   function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id is\n+      Decl_List      : constant List_Id    := New_List;\n+      Loc            : constant Source_Ptr := Sloc (Tag_Typ);\n+      Formal         : Entity_Id;\n+      Formal_List    : List_Id;\n+      New_Param_Spec : Node_Id;\n+      Parent_Subp    : Entity_Id;\n+      Prim_Elmt      : Elmt_Id;\n+      Subp           : Entity_Id;\n+\n+   begin\n+      Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+      while Present (Prim_Elmt) loop\n+         Subp := Node (Prim_Elmt);\n+\n+         --  If a null procedure inherited from an interface has not been\n+         --  overridden, then we build a null procedure declaration to\n+         --  override the inherited procedure.\n+\n+         Parent_Subp := Alias (Subp);\n+\n+         if Present (Parent_Subp)\n+           and then Is_Null_Interface_Primitive (Parent_Subp)\n+         then\n+            Formal_List := No_List;\n+            Formal := First_Formal (Subp);\n+\n+            if Present (Formal) then\n+               Formal_List := New_List;\n+\n+               while Present (Formal) loop\n+\n+                  --  Copy the parameter spec including default expressions\n+\n+                  New_Param_Spec :=\n+                    New_Copy_Tree (Parent (Formal), New_Sloc => Loc);\n+\n+                  --  Generate a new defining identifier for the new formal.\n+                  --  required because New_Copy_Tree does not duplicate\n+                  --  semantic fields (except itypes).\n+\n+                  Set_Defining_Identifier (New_Param_Spec,\n+                    Make_Defining_Identifier (Sloc (Formal),\n+                      Chars => Chars (Formal)));\n+\n+                  --  For controlling arguments we must change their\n+                  --  parameter type to reference the tagged type (instead\n+                  --  of the interface type)\n+\n+                  if Is_Controlling_Formal (Formal) then\n+                     if Nkind (Parameter_Type (Parent (Formal)))\n+                       = N_Identifier\n+                     then\n+                        Set_Parameter_Type (New_Param_Spec,\n+                          New_Occurrence_Of (Tag_Typ, Loc));\n+\n+                     else pragma Assert\n+                            (Nkind (Parameter_Type (Parent (Formal)))\n+                               = N_Access_Definition);\n+                        Set_Subtype_Mark (Parameter_Type (New_Param_Spec),\n+                          New_Occurrence_Of (Tag_Typ, Loc));\n+                     end if;\n+                  end if;\n+\n+                  Append (New_Param_Spec, Formal_List);\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end if;\n+\n+            Append_To (Decl_List,\n+              Make_Subprogram_Declaration (Loc,\n+                Make_Procedure_Specification (Loc,\n+                  Defining_Unit_Name =>\n+                    Make_Defining_Identifier (Loc, Chars (Subp)),\n+                  Parameter_Specifications => Formal_List,\n+                  Null_Present => True)));\n+         end if;\n+\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n+\n+      return Decl_List;\n+   end Make_Null_Procedure_Specs;\n+\n    -------------------------------------\n    -- Make_Predefined_Primitive_Specs --\n    -------------------------------------"}, {"sha": "45f7216a5ca2662cefe45eabd5bcc7efdce51570", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "patch": "@@ -1454,14 +1454,16 @@ package body Sem is\n          --  Do analysis, and then append the compilation unit onto the\n          --  Comp_Unit_List, if appropriate. This is done after analysis, so\n          --  if this unit depends on some others, they have already been\n-         --  appended. We ignore bodies, except for the main unit itself. We\n-         --  have also to guard against ill-formed subunits that have an\n-         --  improper context.\n+         --  appended. We ignore bodies, except for the main unit itself, and\n+         --   for subprogram bodies that act as specs. We have also to guard\n+         --   against ill-formed subunits that have an improper context.\n \n          Do_Analyze;\n \n          if Present (Comp_Unit)\n            and then Nkind (Unit (Comp_Unit)) in N_Proper_Body\n+           and then (Nkind (Unit (Comp_Unit)) /= N_Subprogram_Body\n+             or else not Acts_As_Spec (Comp_Unit))\n            and then not In_Extended_Main_Source_Unit (Comp_Unit)\n          then\n             null;"}, {"sha": "5f067ccc261601defee269042cc938f5a9618665", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "patch": "@@ -44,7 +44,6 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -2357,106 +2356,6 @@ package body Sem_Ch13 is\n    procedure Analyze_Freeze_Entity (N : Node_Id) is\n       E : constant Entity_Id := Entity (N);\n \n-      function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id;\n-      --  Ada 2005 (AI-251): Makes specs for null procedures associated with\n-      --  null procedures inherited from interface types that have not been\n-      --  overridden. Only one null procedure will be created for a given set\n-      --  of inherited null procedures with homographic profiles.\n-\n-      -------------------------------\n-      -- Make_Null_Procedure_Specs --\n-      -------------------------------\n-\n-      function Make_Null_Procedure_Specs (Tag_Typ : Entity_Id) return List_Id\n-      is\n-         Decl_List      : constant List_Id    := New_List;\n-         Loc            : constant Source_Ptr := Sloc (Tag_Typ);\n-         Formal         : Entity_Id;\n-         Formal_List    : List_Id;\n-         New_Param_Spec : Node_Id;\n-         Parent_Subp    : Entity_Id;\n-         Prim_Elmt      : Elmt_Id;\n-         Proc_Decl      : Node_Id;\n-         Subp           : Entity_Id;\n-\n-      begin\n-         Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n-         while Present (Prim_Elmt) loop\n-            Subp := Node (Prim_Elmt);\n-\n-            --  If a null procedure inherited from an interface has not been\n-            --  overridden, then we build a null procedure declaration to\n-            --  override the inherited procedure.\n-\n-            Parent_Subp := Alias (Subp);\n-\n-            if Present (Parent_Subp)\n-              and then Is_Null_Interface_Primitive (Parent_Subp)\n-            then\n-               Formal_List := No_List;\n-               Formal := First_Formal (Subp);\n-\n-               if Present (Formal) then\n-                  Formal_List := New_List;\n-\n-                  while Present (Formal) loop\n-\n-                     --  Copy the parameter spec including default expressions\n-\n-                     New_Param_Spec :=\n-                       New_Copy_Tree (Parent (Formal), New_Sloc => Loc);\n-\n-                     --  Generate a new defining identifier for the new formal.\n-                     --  required because New_Copy_Tree does not duplicate\n-                     --  semantic fields (except itypes).\n-\n-                     Set_Defining_Identifier (New_Param_Spec,\n-                       Make_Defining_Identifier (Sloc (Formal),\n-                         Chars => Chars (Formal)));\n-\n-                     --  For controlling arguments we must change their\n-                     --  parameter type to reference the tagged type (instead\n-                     --  of the interface type)\n-\n-                     if Is_Controlling_Formal (Formal) then\n-                        if Nkind (Parameter_Type (Parent (Formal))) =\n-                                                              N_Identifier\n-                        then\n-                           Set_Parameter_Type (New_Param_Spec,\n-                             New_Occurrence_Of (Tag_Typ, Loc));\n-\n-                        else pragma Assert\n-                               (Nkind (Parameter_Type (Parent (Formal)))\n-                                  = N_Access_Definition);\n-                           Set_Subtype_Mark (Parameter_Type (New_Param_Spec),\n-                             New_Occurrence_Of (Tag_Typ, Loc));\n-                        end if;\n-                     end if;\n-\n-                     Append (New_Param_Spec, Formal_List);\n-\n-                     Next_Formal (Formal);\n-                  end loop;\n-               end if;\n-\n-               Proc_Decl :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Make_Procedure_Specification (Loc,\n-                     Defining_Unit_Name =>\n-                       Make_Defining_Identifier (Loc, Chars (Subp)),\n-                     Parameter_Specifications => Formal_List,\n-                     Null_Present => True));\n-               Append_To (Decl_List, Proc_Decl);\n-            end if;\n-\n-            Next_Elmt (Prim_Elmt);\n-         end loop;\n-\n-         return Decl_List;\n-      end Make_Null_Procedure_Specs;\n-\n-   --  Start of processing for Analyze_Freeze_Entity\n-\n    begin\n       --  For tagged types covering interfaces add internal entities that link\n       --  the primitives of the interfaces with the primitives that cover them.\n@@ -2475,21 +2374,6 @@ package body Sem_Ch13 is\n         and then not Is_Interface (E)\n         and then Has_Interfaces (E)\n       then\n-         --  Add specs of non-overridden null interface primitives. During\n-         --  semantic analysis this is required to ensure consistency of the\n-         --  contents of the list of primitives of the tagged type. Routine\n-         --  Add_Internal_Interface_Entities will take care of adding to such\n-         --  list the internal entities that link each interface primitive with\n-         --  the primitive of Tagged_Type that covers it; hence these specs\n-         --  must be added before invoking Add_Internal_Interface_Entities.\n-         --  In the expansion this consistency is required to ensure that the\n-         --  dispatch table slots associated with non-overridden null interface\n-         --  primitives are properly filled.\n-\n-         if not Is_Abstract_Type (E) then\n-            Insert_Actions (N, Make_Null_Procedure_Specs (E));\n-         end if;\n-\n          --  This would be a good common place to call the routine that checks\n          --  overriding of interface primitives (and thus factorize calls to\n          --  Check_Abstract_Overriding located at different contexts in the"}, {"sha": "95ee36fe6fc82909d89ec5db92a4aa88216e4cad", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e5a58facaa37aff59eb40fc59b0cf8cdc724cb6f", "patch": "@@ -166,6 +166,13 @@ package body Sem_Ch6 is\n    --  True otherwise. Proc is the entity for the procedure case and is used\n    --  in posting the warning message.\n \n+   procedure Check_Untagged_Equality (Eq_Op : Entity_Id);\n+   --  In Ada 2012, a primitive equality operator on an untagged record type\n+   --  must appear before the type is frozen, and have the same visibility as\n+   --  that of the type. This procedure checks that this rule is met, and\n+   --  otherwise emits an error on the subprogram declaration and a warning\n+   --  on the earlier freeze point if it is easy to locate.\n+\n    procedure Enter_Overloaded_Entity (S : Entity_Id);\n    --  This procedure makes S, a new overloaded entity, into the first visible\n    --  entity with that name.\n@@ -5789,6 +5796,51 @@ package body Sem_Ch6 is\n       end if;\n    end Enter_Overloaded_Entity;\n \n+   -----------------------------\n+   -- Check_Untagged_Equality --\n+   -----------------------------\n+\n+   procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n+      Typ      : constant Entity_Id := Etype (First_Formal (Eq_Op));\n+      Decl     : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n+      Obj_Decl : Node_Id;\n+\n+   begin\n+      if Nkind (Decl) = N_Subprogram_Declaration\n+        and then Is_Record_Type (Typ)\n+        and then not Is_Tagged_Type (Typ)\n+      then\n+         if Is_Frozen (Typ) then\n+            Error_Msg_NE\n+              (\"equality operator must be declared \"\n+                & \"before type& is frozen\", Eq_Op, Typ);\n+\n+            Obj_Decl := Next (Parent (Typ));\n+            while Present (Obj_Decl)\n+              and then Obj_Decl /= Decl\n+            loop\n+               if Nkind (Obj_Decl) = N_Object_Declaration\n+                 and then Etype (Defining_Identifier (Obj_Decl)) = Typ\n+               then\n+                  Error_Msg_NE (\"type& is frozen by declaration?\",\n+                     Obj_Decl, Typ);\n+                  Error_Msg_N\n+                    (\"\\an equality operator cannot be declared after this \"\n+                      & \"point ('R'M 4.5.2 (9.8)) (Ada2012))?\", Obj_Decl);\n+                  exit;\n+               end if;\n+\n+               Next (Obj_Decl);\n+            end loop;\n+\n+         elsif not In_Same_List (Parent (Typ), Decl)\n+           and then not Is_Limited_Type (Typ)\n+         then\n+            Error_Msg_N (\"equality operator appears too late\", Eq_Op);\n+         end if;\n+      end if;\n+   end Check_Untagged_Equality;\n+\n    -----------------------------\n    -- Find_Corresponding_Spec --\n    -----------------------------\n@@ -7975,32 +8027,9 @@ package body Sem_Ch6 is\n          then\n             Make_Inequality_Operator (S);\n \n-            --  In Ada 2012, a primitive equality operator on a record type\n-            --  must appear before the type is frozen, and have the same\n-            --  visibility as the type.\n-\n-            declare\n-               Typ  : constant Entity_Id := Etype (First_Formal (S));\n-               Decl : constant Node_Id   := Unit_Declaration_Node (S);\n-\n-            begin\n-               if Ada_Version >= Ada_12\n-                 and then Nkind (Decl) = N_Subprogram_Declaration\n-                 and then Is_Record_Type (Typ)\n-               then\n-                  if Is_Frozen (Typ) then\n-                     Error_Msg_NE\n-                       (\"equality operator must be declared \"\n-                         & \"before type& is frozen\", S, Typ);\n-\n-                  elsif not In_Same_List (Parent (Typ), Decl)\n-                    and then not Is_Limited_Type (Typ)\n-                  then\n-                     Error_Msg_N\n-                       (\"equality operator appears too late\", S);\n-                  end if;\n-               end if;\n-            end;\n+            if Ada_Version >= Ada_12 then\n+               Check_Untagged_Equality (S);\n+            end if;\n          end if;\n    end New_Overloaded_Entity;\n "}]}