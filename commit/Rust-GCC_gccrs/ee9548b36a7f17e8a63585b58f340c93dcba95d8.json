{"sha": "ee9548b36a7f17e8a63585b58f340c93dcba95d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5NTQ4YjM2YTdmMTdlOGE2MzU4NWI1OGYzNDBjOTNkY2JhOTVkOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-04T14:59:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-06-04T14:59:38Z"}, "message": "libstdc++: Fix value categories used by ranges access CPOs [PR 100824]\n\nThe implementation of P2091R0 was incomplete, so that some range access\nCPOs used perfect forwarding where they should not. This fixes it by\nconsistently operating on lvalues.\n\nSome additional changes that are not necessary to fix the bug:\n\nModify the __as_const helper to simplify its usage. Instead of deducing\nthe value category from its argument, and requiring callers to forward\nthe argument as the correct category, add a non-deduced template\nparameter which is used for the value category and accept the argument\nas an lvalue. This means callers say __as_const<T>(t) instead of\n__as_const(std::forward<T>(t)).\n\nAlways use an lvalue reference type as the template argument for the\n_S_noexcept helpers, so that we only instantiate one specialization for\nlvalues and rvalues of the same type.\n\nMove some helper concepts and functions from namespace std::__detail\nto ranges::__cust_access, to be consistent with the ranges::begin CPO.\nThis ensures that the __adl_begin concept and the _Begin::operator()\nfunction are in the same namespace, so unqualified lookup is consistent\nand the poison pills for begin are visible to both.\n\nSimplified static assertions for arrays, because the expression a+0 is\nalready ill-formed for an array of incomplete type.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/100824\n\t* include/bits/iterator_concepts.h (__detail::__decay_copy)\n\t(__detail::__member_begin, __detail::__adl_begin): Move to\n\tnamespace ranges::__cust_access.\n\t(__detail::__ranges_begin): Likewise, and rename to __begin.\n\tRemove redundant static assertion.\n\t* include/bits/ranges_base.h (_Begin, _End, _RBegin, _REnd):\n\tUse lvalue in noexcept specifier.\n\t(__as_const): Add non-deduced parameter for value category.\n\t(_CBegin, _CEnd, _CRBegin, _CREnd, _CData): Adjust uses of\n\t__as_const.\n\t(__member_size, __adl_size, __member_empty, __size0_empty):\n\t(__eq_iter_empty, __adl_data): Use lvalue objects in\n\trequirements.\n\t(__sentinel_size): Likewise. Add check for conversion to\n\tunsigned-like.\n\t(__member_data): Allow non-lvalue types to satisfy the concept,\n\tbut use lvalue object in requirements.\n\t(_Size, _SSize): Remove forwarding to always use an lvalue.\n\t(_Data): Likewise. Add static assertion for arrays.\n\t* testsuite/std/ranges/access/cdata.cc: Adjust expected\n\tbehaviour for rvalues. Add negative tests for ill-formed\n\texpressions.\n\t* testsuite/std/ranges/access/data.cc: Likewise.\n\t* testsuite/std/ranges/access/empty.cc: Adjust expected\n\tbehaviour for rvalues.\n\t* testsuite/std/ranges/access/size.cc: Likewise.", "tree": {"sha": "b0dcc1e6d69e4b44e76f89617633cc88e12188ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0dcc1e6d69e4b44e76f89617633cc88e12188ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee9548b36a7f17e8a63585b58f340c93dcba95d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9548b36a7f17e8a63585b58f340c93dcba95d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9548b36a7f17e8a63585b58f340c93dcba95d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9548b36a7f17e8a63585b58f340c93dcba95d8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6bb145c0bff19767931d37733be11c8acc6fa00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bb145c0bff19767931d37733be11c8acc6fa00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bb145c0bff19767931d37733be11c8acc6fa00"}], "stats": {"total": 313, "additions": 188, "deletions": 125}, "files": [{"sha": "f4e94a6263be729cdb212ebbef276500e6b297ac", "filename": "libstdc++-v3/include/bits/iterator_concepts.h", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -925,8 +925,11 @@ namespace ranges\n   struct default_sentinel_t { };\n   inline constexpr default_sentinel_t default_sentinel{};\n \n-  namespace __detail\n+  // This is the namespace for [range.access] CPOs.\n+  namespace ranges::__cust_access\n   {\n+    using std::__detail::__class_or_enum;\n+\n     template<typename _Tp>\n       constexpr decay_t<_Tp>\n       __decay_copy(_Tp&& __t)\n@@ -936,42 +939,44 @@ namespace ranges\n     template<typename _Tp>\n       concept __member_begin = requires(_Tp& __t)\n \t{\n-\t  { __detail::__decay_copy(__t.begin()) } -> input_or_output_iterator;\n+\t  { __cust_access::__decay_copy(__t.begin()) }\n+\t    -> input_or_output_iterator;\n \t};\n \n+    // Poison pills so that unqualified lookup doesn't find std::begin.\n     void begin(auto&) = delete;\n     void begin(const auto&) = delete;\n \n     template<typename _Tp>\n       concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>\n \t&& requires(_Tp& __t)\n \t{\n-\t  { __detail::__decay_copy(begin(__t)) } -> input_or_output_iterator;\n+\t  { __cust_access::__decay_copy(begin(__t)) }\n+\t    -> input_or_output_iterator;\n \t};\n \n     // Simplified version of std::ranges::begin that only supports lvalues,\n     // for use by __range_iter_t below.\n     template<typename _Tp>\n       requires is_array_v<_Tp> || __member_begin<_Tp&> || __adl_begin<_Tp&>\n       auto\n-      __ranges_begin(_Tp& __t)\n+      __begin(_Tp& __t)\n       {\n \tif constexpr (is_array_v<_Tp>)\n-\t  {\n-\t    static_assert(sizeof(remove_all_extents_t<_Tp>) != 0,\n-\t\t\t  \"not array of incomplete type\");\n-\t    return __t + 0;\n-\t  }\n+\t  return __t + 0;\n \telse if constexpr (__member_begin<_Tp&>)\n \t  return __t.begin();\n \telse\n \t  return begin(__t);\n       }\n+  } // namespace ranges::__cust_access\n \n+  namespace __detail\n+  {\n     // Implementation of std::ranges::iterator_t, without using ranges::begin.\n     template<typename _Tp>\n       using __range_iter_t\n-\t= decltype(__detail::__ranges_begin(std::declval<_Tp&>()));\n+\t= decltype(ranges::__cust_access::__begin(std::declval<_Tp&>()));\n \n   } // namespace __detail\n "}, {"sha": "17a421a492799c1397fd14236dbafdbb458a694a", "filename": "libstdc++-v3/include/bits/ranges_base.h", "status": "modified", "additions": 75, "deletions": 90, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_base.h?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -89,10 +89,6 @@ namespace ranges\n   namespace __cust_access\n   {\n     using std::ranges::__detail::__maybe_borrowed_range;\n-    using std::__detail::__class_or_enum;\n-    using std::__detail::__decay_copy;\n-    using std::__detail::__member_begin;\n-    using std::__detail::__adl_begin;\n \n     struct _Begin\n     {\n@@ -114,13 +110,11 @@ namespace ranges\n \trequires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>\n \t  || __adl_begin<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n \t    {\n \t      static_assert(is_lvalue_reference_v<_Tp>);\n-\t      using _Up = remove_all_extents_t<remove_reference_t<_Tp>>;\n-\t      static_assert(sizeof(_Up) != 0, \"not array of incomplete type\");\n \t      return __t + 0;\n \t    }\n \t  else if constexpr (__member_begin<_Tp>)\n@@ -137,6 +131,7 @@ namespace ranges\n \t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n \t};\n \n+    // Poison pills so that unqualified lookup doesn't find std::end.\n     void end(auto&) = delete;\n     void end(const auto&) = delete;\n \n@@ -165,10 +160,10 @@ namespace ranges\n \n     public:\n       template<__maybe_borrowed_range _Tp>\n-\trequires is_bounded_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>\n-\t|| __adl_end<_Tp>\n+\trequires is_bounded_array_v<remove_reference_t<_Tp>>\n+\t  || __member_end<_Tp> || __adl_end<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n \t    {\n@@ -182,12 +177,15 @@ namespace ranges\n \t}\n     };\n \n-    template<typename _Tp>\n+    // If _To is an lvalue-reference, return const _Tp&, otherwise const _Tp&&.\n+    template<typename _To, typename _Tp>\n       constexpr decltype(auto)\n-      __as_const(_Tp&& __t) noexcept\n+      __as_const(_Tp& __t) noexcept\n       {\n-\tif constexpr (is_lvalue_reference_v<_Tp>)\n-\t  return static_cast<const remove_reference_t<_Tp>&>(__t);\n+\tstatic_assert(std::is_same_v<_To&, _Tp&>);\n+\n+\tif constexpr (is_lvalue_reference_v<_To>)\n+\t  return const_cast<const _Tp&>(__t);\n \telse\n \t  return static_cast<const _Tp&&>(__t);\n       }\n@@ -197,10 +195,10 @@ namespace ranges\n       template<typename _Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Begin{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _Begin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\tnoexcept(noexcept(_Begin{}(__cust_access::__as_const<_Tp>(__e))))\n+\trequires requires { _Begin{}(__cust_access::__as_const<_Tp>(__e)); }\n \t{\n-\t  return _Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t  return _Begin{}(__cust_access::__as_const<_Tp>(__e));\n \t}\n     };\n \n@@ -209,10 +207,10 @@ namespace ranges\n       template<typename _Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_End{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _End{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\tnoexcept(noexcept(_End{}(__cust_access::__as_const<_Tp>(__e))))\n+\trequires requires { _End{}(__cust_access::__as_const<_Tp>(__e)); }\n \t{\n-\t  return _End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t  return _End{}(__cust_access::__as_const<_Tp>(__e));\n \t}\n     };\n \n@@ -268,7 +266,7 @@ namespace ranges\n \trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __t) const\n-\tnoexcept(_S_noexcept<_Tp>())\n+\tnoexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (__member_rbegin<_Tp>)\n \t    return __t.rbegin();\n@@ -326,7 +324,7 @@ namespace ranges\n \trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __t) const\n-\tnoexcept(_S_noexcept<_Tp>())\n+\tnoexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (__member_rend<_Tp>)\n \t    return __t.rend();\n@@ -342,10 +340,10 @@ namespace ranges\n       template<typename _Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_RBegin{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _RBegin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\tnoexcept(noexcept(_RBegin{}(__cust_access::__as_const<_Tp>(__e))))\n+\trequires requires { _RBegin{}(__cust_access::__as_const<_Tp>(__e)); }\n \t{\n-\t  return _RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t  return _RBegin{}(__cust_access::__as_const<_Tp>(__e));\n \t}\n     };\n \n@@ -354,19 +352,18 @@ namespace ranges\n       template<typename _Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_REnd{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _REnd{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\tnoexcept(noexcept(_REnd{}(__cust_access::__as_const<_Tp>(__e))))\n+\trequires requires { _REnd{}(__cust_access::__as_const<_Tp>(__e)); }\n \t{\n-\t  return _REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t  return _REnd{}(__cust_access::__as_const<_Tp>(__e));\n \t}\n     };\n \n     template<typename _Tp>\n       concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(std::forward<_Tp>(__t).size()) }\n-\t    -> __detail::__is_integer_like;\n+\t  { __decay_copy(__t.size()) } -> __detail::__is_integer_like;\n \t};\n \n     void size(auto&) = delete;\n@@ -375,19 +372,19 @@ namespace ranges\n     template<typename _Tp>\n       concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>\n \t&& !disable_sized_range<remove_cvref_t<_Tp>>\n-\t&& requires(_Tp&& __t)\n+\t&& requires(_Tp& __t)\n \t{\n-\t  { __decay_copy(size(std::forward<_Tp>(__t))) }\n-\t    -> __detail::__is_integer_like;\n+\t  { __decay_copy(size(__t)) } -> __detail::__is_integer_like;\n \t};\n \n     template<typename _Tp>\n-      concept __sentinel_size = requires(_Tp&& __t)\n+      concept __sentinel_size = requires(_Tp& __t)\n \t{\n-\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n+\t  { _Begin{}(__t) } -> forward_iterator;\n+\n+\t  { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;\n \n-\t  { _End{}(std::forward<_Tp>(__t)) }\n-\t    -> sized_sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t  __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));\n \t};\n \n     struct _Size\n@@ -400,52 +397,43 @@ namespace ranges\n \t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n \t    return true;\n \t  else if constexpr (__member_size<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().size()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().size()));\n \t  else if constexpr (__adl_size<_Tp>)\n-\t    return noexcept(__decay_copy(size(std::declval<_Tp>())));\n+\t    return noexcept(__decay_copy(size(std::declval<_Tp&>())));\n \t  else if constexpr (__sentinel_size<_Tp>)\n-\t    return noexcept(_End{}(std::declval<_Tp>())\n-\t\t\t    - _Begin{}(std::declval<_Tp>()));\n+\t    return noexcept(_End{}(std::declval<_Tp&>())\n+\t\t\t    - _Begin{}(std::declval<_Tp&>()));\n \t}\n \n     public:\n       template<typename _Tp>\n \trequires is_bounded_array_v<remove_reference_t<_Tp>>\n \t  || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n-\t    {\n-\t      return extent_v<remove_reference_t<_Tp>>;\n-\t    }\n+\t    return extent_v<remove_reference_t<_Tp>>;\n \t  else if constexpr (__member_size<_Tp>)\n-\t    return std::forward<_Tp>(__e).size();\n+\t    return __t.size();\n \t  else if constexpr (__adl_size<_Tp>)\n-\t    return size(std::forward<_Tp>(__e));\n+\t    return size(__t);\n \t  else if constexpr (__sentinel_size<_Tp>)\n-\t    return __detail::__to_unsigned_like(\n-\t\t_End{}(std::forward<_Tp>(__e))\n-\t\t- _Begin{}(std::forward<_Tp>(__e)));\n+\t    return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));\n \t}\n     };\n \n     struct _SSize\n     {\n       template<typename _Tp>\n-\trequires requires (_Tp&& __e)\n-\t  {\n-\t    _Begin{}(std::forward<_Tp>(__e));\n-\t    _Size{}(std::forward<_Tp>(__e));\n-\t  }\n+\trequires requires (_Tp& __t) { _Size{}(__t); }\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Size{}(std::forward<_Tp>(__e))))\n+\toperator()(_Tp&& __t) const noexcept(noexcept(_Size{}(__t)))\n \t{\n-\t  using __iter_type = decltype(_Begin{}(std::forward<_Tp>(__e)));\n+\t  using __iter_type = decltype(_Begin{}(__t));\n \t  using __diff_type = iter_difference_t<__iter_type>;\n \t  using __gnu_cxx::__int_traits;\n-\t  auto __size = _Size{}(std::forward<_Tp>(__e));\n+\t  auto __size = _Size{}(__t);\n \t  if constexpr (integral<__diff_type>)\n \t    {\n \t      if constexpr (__int_traits<__diff_type>::__digits\n@@ -457,19 +445,17 @@ namespace ranges\n     };\n \n     template<typename _Tp>\n-      concept __member_empty = requires(_Tp&& __t)\n-\t{ bool(std::forward<_Tp>(__t).empty()); };\n+      concept __member_empty = requires(_Tp& __t) { bool(__t.empty()); };\n \n     template<typename _Tp>\n-      concept __size0_empty = requires(_Tp&& __t)\n-\t{ _Size{}(std::forward<_Tp>(__t)) == 0; };\n+      concept __size0_empty = requires(_Tp& __t) { _Size{}(__t) == 0; };\n \n     template<typename _Tp>\n-      concept __eq_iter_empty = requires(_Tp&& __t)\n+      concept __eq_iter_empty = requires(_Tp& __t)\n \t{\n-\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n-\t  bool(_Begin{}(std::forward<_Tp>(__t))\n-\t      == _End{}(std::forward<_Tp>(__t)));\n+\t  { _Begin{}(__t) } -> forward_iterator;\n+\n+\t  bool(_Begin{}(__t) == _End{}(__t));\n \t};\n \n     struct _Empty\n@@ -480,28 +466,27 @@ namespace ranges\n \t_S_noexcept()\n \t{\n \t  if constexpr (__member_empty<_Tp>)\n-\t    return noexcept(std::declval<_Tp>().empty());\n+\t    return noexcept(std::declval<_Tp&>().empty());\n \t  else if constexpr (__size0_empty<_Tp>)\n-\t    return noexcept(_Size{}(std::declval<_Tp>()) == 0);\n+\t    return noexcept(_Size{}(std::declval<_Tp&>()) == 0);\n \t  else\n-\t    return noexcept(bool(_Begin{}(std::declval<_Tp>())\n-\t\t== _End{}(std::declval<_Tp>())));\n+\t    return noexcept(bool(_Begin{}(std::declval<_Tp&>())\n+\t\t== _End{}(std::declval<_Tp&>())));\n \t}\n \n     public:\n       template<typename _Tp>\n \trequires __member_empty<_Tp> || __size0_empty<_Tp>\n-\t|| __eq_iter_empty<_Tp>\n+\t  || __eq_iter_empty<_Tp>\n \tconstexpr bool\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n \t{\n \t  if constexpr (__member_empty<_Tp>)\n-\t    return bool(std::forward<_Tp>(__e).empty());\n+\t    return bool(__t.empty());\n \t  else if constexpr (__size0_empty<_Tp>)\n-\t    return _Size{}(std::forward<_Tp>(__e)) == 0;\n+\t    return _Size{}(__t) == 0;\n \t  else\n-\t    return bool(_Begin{}(std::forward<_Tp>(__e))\n-\t\t== _End{}(std::forward<_Tp>(__e)));\n+\t    return bool(_Begin{}(__t) == _End{}(__t));\n \t}\n     };\n \n@@ -510,12 +495,12 @@ namespace ranges\n \t\t\t\t    && is_object_v<remove_pointer_t<_Tp>>;\n \n     template<typename _Tp>\n-      concept __member_data = is_lvalue_reference_v<_Tp>\n-\t&& requires(_Tp __t) { { __t.data() } -> __pointer_to_object; };\n+      concept __member_data\n+\t= requires(_Tp& __t) { { __t.data() } -> __pointer_to_object; };\n \n     template<typename _Tp>\n-      concept __begin_data = requires(_Tp&& __t)\n-\t{ { _Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };\n+      concept __begin_data = requires(_Tp& __t)\n+\t{ { _Begin{}(__t) } -> contiguous_iterator; };\n \n     struct _Data\n     {\n@@ -525,21 +510,21 @@ namespace ranges\n \t_S_noexcept()\n \t{\n \t  if constexpr (__member_data<_Tp>)\n-\t    return noexcept(__decay_copy(std::declval<_Tp>().data()));\n+\t    return noexcept(__decay_copy(std::declval<_Tp&>().data()));\n \t  else\n-\t    return noexcept(_Begin{}(std::declval<_Tp>()));\n+\t    return noexcept(_Begin{}(std::declval<_Tp&>()));\n \t}\n \n     public:\n       template<__maybe_borrowed_range _Tp>\n \trequires __member_data<_Tp> || __begin_data<_Tp>\n \tconstexpr auto\n-\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\toperator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n \t{\n \t  if constexpr (__member_data<_Tp>)\n-\t    return __e.data();\n+\t    return __t.data();\n \t  else\n-\t    return std::to_address(_Begin{}(std::forward<_Tp>(__e)));\n+\t    return std::to_address(_Begin{}(__t));\n \t}\n     };\n \n@@ -548,10 +533,10 @@ namespace ranges\n       template<typename _Tp>\n \tconstexpr auto\n \toperator()(_Tp&& __e) const\n-\tnoexcept(noexcept(_Data{}(__cust_access::__as_const((_Tp&&)__e))))\n-\trequires requires { _Data{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\tnoexcept(noexcept(_Data{}(__cust_access::__as_const<_Tp>(__e))))\n+\trequires requires { _Data{}(__cust_access::__as_const<_Tp>(__e)); }\n \t{\n-\t  return _Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t  return _Data{}(__cust_access::__as_const<_Tp>(__e));\n \t}\n     };\n "}, {"sha": "2dfb68307892498cef3c1ea5d734826156b7a619", "filename": "libstdc++-v3/testsuite/std/ranges/access/cdata.cc", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -21,6 +21,10 @@\n #include <ranges>\n #include <testsuite_hooks.h>\n \n+template<typename T>\n+  concept has_cdata\n+    = requires (T&& t) { std::ranges::cdata(std::forward<T>(t)); };\n+\n void\n test01()\n {\n@@ -31,41 +35,55 @@ test01()\n     int* data() { return &j; }\n     const R* data() const noexcept { return nullptr; }\n   };\n+  static_assert( has_cdata<R&> );\n+  static_assert( has_cdata<const R&> );\n   R r;\n   const R& c = r;\n   VERIFY( std::ranges::cdata(r) == (R*)nullptr );\n   static_assert( noexcept(std::ranges::cdata(r)) );\n   VERIFY( std::ranges::cdata(c) == (R*)nullptr );\n   static_assert( noexcept(std::ranges::cdata(c)) );\n+\n+  // not lvalues and not borrowed ranges\n+  static_assert( !has_cdata<R> );\n+  static_assert( !has_cdata<const R> );\n }\n \n void\n test02()\n {\n   int a[] = { 0, 1 };\n   VERIFY( std::ranges::cdata(a) == a + 0 );\n+\n+  static_assert( has_cdata<int(&)[2]> );\n+  static_assert( !has_cdata<int(&&)[2]> );\n }\n \n-struct R\n+struct R3\n {\n-  long l = 0;\n+  static inline int i = 0;\n+  static inline long l = 0;\n \n-  int* data() const { return nullptr; }\n-  friend long* begin(R&& r); // this function is not defined\n-  friend const long* begin(const R& r) { return &r.l; }\n-  friend const short* begin(const R&&); // not defined\n+  int* data() &; // this function is not defined\n+  friend long* begin(R3&& r); // not defined\n+  friend const long* begin(const R3& r) { return &r.l; }\n+  friend const short* begin(const R3&&); // not defined\n };\n \n-// This is a lie, ranges::begin(R&&) returns a dangling iterator.\n-template<> constexpr bool std::ranges::enable_borrowed_range<R> = true;\n+template<> constexpr bool std::ranges::enable_borrowed_range<R3> = true;\n \n void\n test03()\n {\n-  R r;\n-  const R& c = r;\n+  static_assert( has_cdata<R3&> );\n+  static_assert( has_cdata<R3> );  // borrowed range\n+  static_assert( has_cdata<const R3&> );\n+  static_assert( has_cdata<const R3> );  // borrowed range\n+\n+  R3 r;\n+  const R3& c = r;\n   VERIFY( std::ranges::cdata(r) == std::ranges::data(c) );\n-  VERIFY( std::ranges::cdata(std::move(r)) == std::ranges::begin(c) );\n+  VERIFY( std::ranges::cdata(std::move(r)) == std::ranges::data(c) );\n   VERIFY( std::ranges::cdata(std::move(c)) == std::ranges::begin(c) );\n }\n "}, {"sha": "237bbcc76c57d5c2652d39c7bda0d4336254fd72", "filename": "libstdc++-v3/testsuite/std/ranges/access/data.cc", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -22,6 +22,10 @@\n #include <testsuite_hooks.h>\n #include <testsuite_iterators.h>\n \n+template<typename T>\n+  concept has_data\n+    = requires (T&& t) { std::ranges::data(std::forward<T>(t)); };\n+\n void\n test01()\n {\n@@ -32,12 +36,18 @@ test01()\n     int* data() { return &j; }\n     const R* data() const noexcept { return nullptr; }\n   };\n+  static_assert( has_data<R&> );\n+  static_assert( has_data<const R&> );\n   R r;\n   const R& c = r;\n   VERIFY( std::ranges::data(r) == &r.j );\n   static_assert( !noexcept(std::ranges::data(r)) );\n   VERIFY( std::ranges::data(c) == (R*)nullptr );\n   static_assert( noexcept(std::ranges::data(c)) );\n+\n+  // not lvalues and not borrowed ranges\n+  static_assert( !has_data<R> );\n+  static_assert( !has_data<const R> );\n }\n \n \n@@ -49,31 +59,42 @@ test02()\n \n   __gnu_test::test_range<int, __gnu_test::contiguous_iterator_wrapper> r(a);\n   VERIFY( std::ranges::data(r) == std::to_address(std::ranges::begin(r)) );\n+\n+  static_assert( has_data<int(&)[2]> );\n+  static_assert( has_data<decltype(r)&> );\n+  static_assert( !has_data<int(&&)[2]> );\n+  static_assert( !has_data<decltype(r)&&> );\n }\n \n struct R3\n {\n-  long l = 0;\n+  static inline int i;\n+  static inline long l;\n \n-  int* data() const { return nullptr; }\n-  friend long* begin(R3& r) { return &r.l; }\n-  friend const long* begin(const R3& r) { return &r.l + 1; }\n+  int* data() & { return &i; }\n+  friend long* begin(const R3& r) { return &l; }\n+  friend const short* begin(const R3&&); // not defined\n };\n \n-// N.B. this is a lie, begin on an R3 rvalue will return a dangling pointer.\n template<> constexpr bool std::ranges::enable_borrowed_range<R3> = true;\n \n void\n test03()\n {\n+  static_assert( has_data<R3&> );\n+  static_assert( has_data<R3> );  // borrowed range\n+  static_assert( has_data<const R3&> );\n+  static_assert( has_data<const R3> );  // borrowed range\n+\n   R3 r;\n   const R3& c = r;\n-  // r.data() can only be used on an lvalue, but ranges::begin(R3&&) is OK\n-  // because R3 satisfies ranges::borrowed_range.\n-  VERIFY( std::ranges::data(std::move(r)) == std::to_address(std::ranges::begin(std::move(r))) );\n-  VERIFY( std::ranges::data(std::move(c)) == std::to_address(std::ranges::begin(std::move(c))) );\n+  // PR libstdc++/100824\n+  // ranges::data should treat the subexpression as an lvalue\n+  VERIFY( std::ranges::data(std::move(r)) == &R3::i );\n+  VERIFY( std::ranges::data(std::move(c)) == &R3::l );\n }\n \n+\n int\n main()\n {"}, {"sha": "9044dd155da6d1c4fdecdfe0a2ef8ebdf0cc97a3", "filename": "libstdc++-v3/testsuite/std/ranges/access/empty.cc", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -35,7 +35,9 @@ test01()\n   constexpr R r;\n   static_assert( !std::ranges::empty(r) );\n   static_assert( same_as<decltype(std::ranges::empty(r)), bool> );\n-  static_assert( std::ranges::empty(std::move(r)) );\n+  // PR libstdc++/100824\n+  // ranges::empty should treat the subexpression as an lvalue\n+  static_assert( !std::ranges::empty(std::move(r)) );\n   static_assert( same_as<decltype(std::ranges::empty(std::move(r))), bool> );\n }\n \n@@ -68,9 +70,29 @@ test02()\n   VERIFY( !std::ranges::empty(so) );\n }\n \n+void\n+test03()\n+{\n+  // PR libstdc++/100824\n+  // ranges::empty should treat the subexpression as an lvalue\n+\n+  struct R\n+  {\n+    constexpr bool empty() & { return true; }\n+  };\n+  static_assert( std::ranges::empty(R{}) );\n+\n+  struct R2\n+  {\n+    constexpr unsigned size() & { return 0; }\n+  };\n+  static_assert( std::ranges::empty(R2{}) );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n+  test03();\n }"}, {"sha": "f25a1cb9ddb62a47623f92e19babdbd4219767a1", "filename": "libstdc++-v3/testsuite/std/ranges/access/size.cc", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9548b36a7f17e8a63585b58f340c93dcba95d8/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc?ref=ee9548b36a7f17e8a63585b58f340c93dcba95d8", "patch": "@@ -76,12 +76,14 @@ test03()\n   const R3& c = r;\n   VERIFY( std::ranges::size(r) == 1 );\n   static_assert( noexcept(std::ranges::size(r)) );\n-  VERIFY( std::ranges::size(std::move(r)) == 3U );\n-  static_assert( !noexcept(std::ranges::size(std::move(r))) );\n+  // PR libstdc++/100824\n+  // ranges::size should treat the subexpression as an lvalue\n+  VERIFY( std::ranges::size(std::move(r)) == 1 );\n+  static_assert( noexcept(std::ranges::size(std::move(r))) );\n   VERIFY( std::ranges::size(c) == 2L );\n   static_assert( !noexcept(std::ranges::size(c)) );\n-  VERIFY( std::ranges::size(std::move(c)) == 4UL );\n-  static_assert( noexcept(std::ranges::size(std::move(c))) );\n+  VERIFY( std::ranges::size(std::move(c)) == 2L );\n+  static_assert( !noexcept(std::ranges::size(std::move(c))) );\n }\n \n void\n@@ -109,6 +111,15 @@ test05()\n   VERIFY( std::ranges::size(r) == 1 );\n }\n \n+void\n+test06()\n+{\n+  // PR libstdc++/100824\n+  // ranges::size should treat the subexpression as an lvalue\n+  struct R { constexpr int size() & { return 42; } };\n+  static_assert( std::ranges::size(R{}) == 42 );\n+}\n+\n int\n main()\n {\n@@ -117,4 +128,5 @@ main()\n   test03();\n   test04();\n   test05();\n+  test06();\n }"}]}