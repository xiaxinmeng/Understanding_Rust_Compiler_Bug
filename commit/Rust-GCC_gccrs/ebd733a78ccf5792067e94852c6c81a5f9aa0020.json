{"sha": "ebd733a78ccf5792067e94852c6c81a5f9aa0020", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJkNzMzYTc4Y2NmNTc5MjA2N2U5NDg1MmM2YzgxYTVmOWFhMDAyMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-05-20T10:33:54Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-05-20T10:33:54Z"}, "message": "gimple-match-head.c: Include vec-perm-indices.h.\n\n2019-05-20  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-match-head.c: Include vec-perm-indices.h.\n\t* generic-match-head.c: Likewise.\n\t* fold-const.h (fold_vec_perm): Declare when vec-perm-indices.h\n\tis included.\n\t* fold-const.c (fold_vec_perm): Export.\n\t(fold_ternary_loc): Move non-constant folding of VEC_PERM_EXPR...\n\t(match.pd): ...here.\n\nFrom-SVN: r271404", "tree": {"sha": "1879ede8a51660683068c0a909702bb2649889bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1879ede8a51660683068c0a909702bb2649889bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebd733a78ccf5792067e94852c6c81a5f9aa0020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd733a78ccf5792067e94852c6c81a5f9aa0020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebd733a78ccf5792067e94852c6c81a5f9aa0020", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd733a78ccf5792067e94852c6c81a5f9aa0020/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f63445e56c265757ebd50dc12fcd01773341b49f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f63445e56c265757ebd50dc12fcd01773341b49f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f63445e56c265757ebd50dc12fcd01773341b49f"}], "stats": {"total": 161, "additions": 104, "deletions": 57}, "files": [{"sha": "920ea6ffa6594feecd680c78dcccdb9d1e196e64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -1,3 +1,13 @@\n+2019-05-20  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-match-head.c: Include vec-perm-indices.h.\n+\t* generic-match-head.c: Likewise.\n+\t* fold-const.h (fold_vec_perm): Declare when vec-perm-indices.h\n+\tis included.\n+\t* fold-const.c (fold_vec_perm): Export.\n+\t(fold_ternary_loc): Move non-constant folding of VEC_PERM_EXPR...\n+\t(match.pd): ...here.\n+\n 2019-05-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cfgloop.h (struct loop): Add simdlen member."}, {"sha": "34448524050431cbbabde75093c37ed5693f9cec", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 57, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -9015,7 +9015,7 @@ vec_cst_ctor_to_array (tree arg, unsigned int nelts, tree *elts)\n    selector.  Return the folded VECTOR_CST or CONSTRUCTOR if successful,\n    NULL_TREE otherwise.  */\n \n-static tree\n+tree\n fold_vec_perm (tree type, tree arg0, tree arg1, const vec_perm_indices &sel)\n {\n   unsigned int i;\n@@ -11763,7 +11763,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       return NULL_TREE;\n \n     case VEC_PERM_EXPR:\n-      if (TREE_CODE (arg2) == VECTOR_CST)\n+      /* Perform constant folding of BIT_INSERT_EXPR.  */\n+      if (TREE_CODE (arg2) == VECTOR_CST\n+\t  && TREE_CODE (op0) == VECTOR_CST\n+\t  && TREE_CODE (op1) == VECTOR_CST)\n \t{\n \t  /* Build a vector of integers from the tree mask.  */\n \t  vec_perm_builder builder;\n@@ -11774,61 +11777,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n \t  bool single_arg = (op0 == op1);\n \t  vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n-\n-\t  /* Check for cases that fold to OP0 or OP1 in their original\n-\t     element order.  */\n-\t  if (sel.series_p (0, 1, 0, 1))\n-\t    return op0;\n-\t  if (sel.series_p (0, 1, nelts, 1))\n-\t    return op1;\n-\n-\t  if (!single_arg)\n-\t    {\n-\t      if (sel.all_from_input_p (0))\n-\t\top1 = op0;\n-\t      else if (sel.all_from_input_p (1))\n-\t\t{\n-\t\t  op0 = op1;\n-\t\t  sel.rotate_inputs (1);\n-\t\t}\n-\t    }\n-\n-\t  if ((TREE_CODE (op0) == VECTOR_CST\n-\t       || TREE_CODE (op0) == CONSTRUCTOR)\n-\t      && (TREE_CODE (op1) == VECTOR_CST\n-\t\t  || TREE_CODE (op1) == CONSTRUCTOR))\n-\t    {\n-\t      tree t = fold_vec_perm (type, op0, op1, sel);\n-\t      if (t != NULL_TREE)\n-\t\treturn t;\n-\t    }\n-\n-\t  bool changed = (op0 == op1 && !single_arg);\n-\n-\t  /* Generate a canonical form of the selector.  */\n-\t  if (arg2 == op2 && sel.encoding () != builder)\n-\t    {\n-\t      /* Some targets are deficient and fail to expand a single\n-\t\t argument permutation while still allowing an equivalent\n-\t\t 2-argument version.  */\n-\t      if (sel.ninputs () == 2\n-\t\t  || can_vec_perm_const_p (TYPE_MODE (type), sel, false))\n-\t\top2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel);\n-\t      else\n-\t\t{\n-\t\t  vec_perm_indices sel2 (builder, 2, nelts);\n-\t\t  if (can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n-\t\t    op2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel2);\n-\t\t  else\n-\t\t    /* Not directly supported with either encoding,\n-\t\t       so use the preferred form.  */\n-\t\t    op2 = vec_perm_indices_to_tree (TREE_TYPE (arg2), sel);\n-\t\t}\n-\t      changed = true;\n-\t    }\n-\n-\t  if (changed)\n-\t    return build3_loc (loc, VEC_PERM_EXPR, type, op0, op1, op2);\n+\t  return fold_vec_perm (type, op0, op1, sel);\n \t}\n       return NULL_TREE;\n "}, {"sha": "c4b7cbfbdba8805aa471b5e01e06949d87964066", "filename": "gcc/fold-const.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -100,6 +100,9 @@ extern tree fold_bit_and_mask (tree, tree, enum tree_code,\n \t\t\t       tree, enum tree_code, tree, tree,\n \t\t\t       tree, enum tree_code, tree, tree, tree *);\n extern tree fold_read_from_constant_string (tree);\n+#if GCC_VEC_PERN_INDICES_H\n+extern tree fold_vec_perm (tree, tree, tree, const vec_perm_indices &);\n+#endif\n extern bool wide_int_binop (wide_int &res, enum tree_code,\n \t\t\t    const wide_int &arg1, const wide_int &arg2,\n \t\t\t    signop, wi::overflow_type *);"}, {"sha": "76fc99934816af0b1c6f303bb2fee0895b6ae842", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"ssa.h\"\n #include \"cgraph.h\"\n+#include \"vec-perm-indices.h\"\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n #include \"tree-dfa.h\""}, {"sha": "f83f225617889c1cf8e6fe3f6f6f57d71f216f81", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"ssa.h\"\n #include \"cgraph.h\"\n+#include \"vec-perm-indices.h\"\n #include \"fold-const.h\"\n #include \"fold-const-call.h\"\n #include \"stor-layout.h\""}, {"sha": "9ff52123cd9b93b171ec2b2297fa909c648e56ab", "filename": "gcc/match.pd", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd733a78ccf5792067e94852c6c81a5f9aa0020/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=ebd733a78ccf5792067e94852c6c81a5f9aa0020", "patch": "@@ -5374,3 +5374,86 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n       (bit_and:elt_type\n        (BIT_FIELD_REF:elt_type @0 { size; } { pos; })\n        { elt; })))))))\n+\n+(simplify\n+ (vec_perm @0 @1 VECTOR_CST@2)\n+ (with\n+  {\n+    tree op0 = @0, op1 = @1, op2 = @2;\n+\n+    /* Build a vector of integers from the tree mask.  */\n+    vec_perm_builder builder;\n+    if (!tree_to_vec_perm_builder (&builder, op2))\n+      return NULL_TREE;\n+\n+    /* Create a vec_perm_indices for the integer vector.  */\n+    poly_uint64 nelts = TYPE_VECTOR_SUBPARTS (type);\n+    bool single_arg = (op0 == op1);\n+    vec_perm_indices sel (builder, single_arg ? 1 : 2, nelts);\n+  }\n+  (if (sel.series_p (0, 1, 0, 1))\n+   { op0; }\n+   (if (sel.series_p (0, 1, nelts, 1))\n+    { op1; }\n+    (with\n+     {\n+       if (!single_arg)\n+         {\n+\t   if (sel.all_from_input_p (0))\n+\t     op1 = op0;\n+\t   else if (sel.all_from_input_p (1))\n+\t     {\n+\t       op0 = op1;\n+\t       sel.rotate_inputs (1);\n+\t     }\n+         }\n+       gassign *def;\n+       tree cop0 = op0, cop1 = op1;\n+       if (TREE_CODE (op0) == SSA_NAME\n+           && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op0)))\n+\t   && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n+\t cop0 = gimple_assign_rhs1 (def);\n+       if (TREE_CODE (op1) == SSA_NAME\n+           && (def = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (op1)))\n+\t   && gimple_assign_rhs_code (def) == CONSTRUCTOR)\n+\t cop1 = gimple_assign_rhs1 (def);\n+\n+       tree t;\n+    }\n+    (if ((TREE_CODE (cop0) == VECTOR_CST\n+\t  || TREE_CODE (cop0) == CONSTRUCTOR)\n+\t && (TREE_CODE (cop1) == VECTOR_CST\n+\t     || TREE_CODE (cop1) == CONSTRUCTOR)\n+\t && (t = fold_vec_perm (type, cop0, cop1, sel)))\n+     { t; }\n+     (with\n+      {\n+\tbool changed = (op0 == op1 && !single_arg);\n+\n+\t/* Generate a canonical form of the selector.  */\n+\tif (sel.encoding () != builder)\n+\t  {\n+\t    /* Some targets are deficient and fail to expand a single\n+\t       argument permutation while still allowing an equivalent\n+\t       2-argument version.  */\n+\t    tree oldop2 = op2;\n+\t    if (sel.ninputs () == 2\n+\t       || can_vec_perm_const_p (TYPE_MODE (type), sel, false))\n+\t      op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n+\t    else\n+\t      {\n+\t        vec_perm_indices sel2 (builder, 2, nelts);\n+\t        if (can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n+\t          op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel2);\n+\t        else\n+\t          /* Not directly supported with either encoding,\n+\t\t     so use the preferred form.  */\n+\t\t  op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n+\t      }\n+\t    /* Differences in the encoder do not necessarily mean\n+\t       differences in the resulting vector.  */\n+\t    changed = !operand_equal_p (op2, oldop2, 0);\n+\t  }\n+      }\n+      (if (changed)\n+       (vec_perm { op0; } { op1; } { op2; })))))))))"}]}