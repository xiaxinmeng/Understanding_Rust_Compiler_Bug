{"sha": "c56e3d82fc9090d1580ca8dc02a6add848629d0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU2ZTNkODJmYzkwOTBkMTU4MGNhOGRjMDJhNmFkZDg0ODYyOWQwYw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-09-13T22:21:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-09-13T22:21:34Z"}, "message": "re PR libstdc++/11722 ([3.4 only] Unbuffered filebuf::sgetn is slow)\n\n2004-09-13  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/11722\n\t* include/std/std_fstream.h (xsgetn): Declare only.\n\t* include/bits/fstream.tcc (xsgetn): Define, optimize for the\n\talways_noconv() case: when __n > __buflen, copy the available\n\tbuffer and issue a direct read.\n\t* testsuite/performance/27_io/filebuf_sgetn_unbuf.cc: New.\n\n\t* include/bits/fstream.tcc (xsputn): Minor tweak, reorder a\n\tconditional.\n\nFrom-SVN: r87453", "tree": {"sha": "8997f3bc677ca038f84fb3bcc2ce4cfd4abbc203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8997f3bc677ca038f84fb3bcc2ce4cfd4abbc203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c56e3d82fc9090d1580ca8dc02a6add848629d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56e3d82fc9090d1580ca8dc02a6add848629d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56e3d82fc9090d1580ca8dc02a6add848629d0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56e3d82fc9090d1580ca8dc02a6add848629d0c/comments", "author": null, "committer": null, "parents": [{"sha": "90c609e51aab3794230d1eae447a9dac825d6a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c609e51aab3794230d1eae447a9dac825d6a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90c609e51aab3794230d1eae447a9dac825d6a57"}], "stats": {"total": 187, "additions": 166, "deletions": 21}, "files": [{"sha": "16faad2e92c9e648071f6d59d0634ebe90916e07", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c56e3d82fc9090d1580ca8dc02a6add848629d0c", "patch": "@@ -1,4 +1,16 @@\n-2004-09-14  Hans-Peter Nilsson  <hp@bitrange.com>\n+2004-09-13  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/11722\n+\t* include/std/std_fstream.h (xsgetn): Declare only.\n+\t* include/bits/fstream.tcc (xsgetn): Define, optimize for the\n+\talways_noconv() case: when __n > __buflen, copy the available\n+\tbuffer and issue a direct read.\n+\t* testsuite/performance/27_io/filebuf_sgetn_unbuf.cc: New.\n+\n+\t* include/bits/fstream.tcc (xsputn): Minor tweak, reorder a\n+\tconditional.\n+\n+2004-09-13  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* testsuite/lib/libstdc++.exp: Use gcc wrapper.exp and call\n \tlibstdc++_maybe_build_wrapper instead of using local code."}, {"sha": "542dc6e8bc4ff3ee86220725dca514c9eddf3486", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=c56e3d82fc9090d1580ca8dc02a6add848629d0c", "patch": "@@ -494,6 +494,71 @@ namespace std\n       return __elen == __plen;\n     }\n \n+   template<typename _CharT, typename _Traits>\n+     streamsize\n+     basic_filebuf<_CharT, _Traits>::\n+     xsgetn(_CharT* __s, streamsize __n)\n+     {\n+       // Clear out pback buffer before going on to the real deal...\n+       streamsize __ret = 0;\n+       if (this->_M_pback_init)\n+\t {\n+\t   if (__n > 0 && this->gptr() == this->eback())\n+\t     {\n+\t       *__s++ = *this->gptr();\n+\t       this->gbump(1);\n+\t       __ret = 1;\n+\t       --__n;\n+\t     }\n+\t   _M_destroy_pback();\n+\t }\n+       \n+       // Optimization in the always_noconv() case, to be generalized in the\n+       // future: when __n > __buflen we read directly instead of using the\n+       // buffer repeatedly.\n+       const bool __testin = this->_M_mode & ios_base::in;\n+       const streamsize __buflen = this->_M_buf_size > 1 ? this->_M_buf_size - 1\n+\t                                                 : 1;\n+       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()\n+\t   && __testin && !_M_writing)\n+\t {\n+\t   // First, copy the chars already present in the buffer.\n+\t   const streamsize __avail = this->egptr() - this->gptr();\n+\t   if (__avail == 1)\n+\t     *__s = *this->gptr();\n+\t   else if (__avail > 1)\n+\t     traits_type::move(__s, this->gptr(), __avail);\n+\t   __s += __avail;\n+\t   this->gbump(__avail);\n+\t   __ret += __avail;\n+\t   __n -= __avail;\n+\n+\t   const streamsize __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),\n+\t\t\t\t\t\t   __n);\n+\t   if (__len == -1)\n+\t     __throw_ios_failure(__N(\"basic_filebuf::xsgetn \"\n+\t\t\t\t     \"error reading the file\"));\n+\t   __ret += __len;\n+\t   if (__len == __n)\n+\t     {\n+\t       _M_set_buffer(0);\n+\t       _M_reading = true;\n+\t     }\n+\t   else if (__len == 0)\n+\t     {\n+\t       // If end of file is reached, set 'uncommitted'\n+\t       // mode, thus allowing an immediate write without\n+\t       // an intervening seek.\n+\t       _M_set_buffer(-1);\n+\t       _M_reading = false;\n+\t     }\n+\t }\n+       else\n+\t __ret += __streambuf_type::xsgetn(__s, __n);\n+\n+       return __ret;\n+     }\n+\n    template<typename _CharT, typename _Traits>\n      streamsize\n      basic_filebuf<_CharT, _Traits>::\n@@ -504,8 +569,8 @@ namespace std\n        // using the buffer.\n        streamsize __ret = 0;\n        const bool __testout = this->_M_mode & ios_base::out;\n-       if (__testout && !_M_reading\n-\t   && __check_facet(_M_codecvt).always_noconv())\n+       if (__check_facet(_M_codecvt).always_noconv()\n+\t   && __testout && !_M_reading)\n \t{\n \t  // Measurement would reveal the best choice.\n \t  const streamsize __chunk = 1ul << 10;"}, {"sha": "f962a2b202acfa98847888895a148856f7cce1b1", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=c56e3d82fc9090d1580ca8dc02a6add848629d0c", "patch": "@@ -419,24 +419,7 @@ namespace std\n \n       // [documentation is inherited]\n       virtual streamsize\n-      xsgetn(char_type* __s, streamsize __n)\n-      {\n-\t// Clear out pback buffer before going on to the real deal...\n-\tstreamsize __ret = 0;\n-\tif (this->_M_pback_init)\n-\t  {\n-\t    if (__n && this->gptr() == this->eback())\n-\t      {\n-\t\t*__s++ = *this->gptr();\n-\t\tthis->gbump(1);\n-\t\t__ret = 1;\n-\t      }\n-\t    _M_destroy_pback();\n-\t  }\n-\tif (__ret < __n)\n-\t  __ret += __streambuf_type::xsgetn(__s, __n - __ret);\n-\treturn __ret;\n-      }\n+      xsgetn(char_type* __s, streamsize __n);\n \n       // [documentation is inherited]\n       virtual streamsize"}, {"sha": "5741ab308bbabe3a28f8233a57092acb9531d057", "filename": "libstdc++-v3/testsuite/performance/27_io/filebuf_sgetn_unbuf.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F27_io%2Ffilebuf_sgetn_unbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c56e3d82fc9090d1580ca8dc02a6add848629d0c/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F27_io%2Ffilebuf_sgetn_unbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F27_io%2Ffilebuf_sgetn_unbuf.cc?ref=c56e3d82fc9090d1580ca8dc02a6add848629d0c", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstdio>\n+#include <fstream>\n+#include <testsuite_performance.h>\n+\n+// libstdc++/11722\n+int main()\n+{\n+  using namespace std;\n+  using namespace __gnu_test;\n+\n+  time_counter time;\n+  resource_counter resource;\n+\n+  const int iterations = 500000;\n+  const int chunksize = 100;\n+\n+  char* chunk = new char[chunksize];\n+  const char* name = \"/usr/share/dict/linux.words\";\n+\n+  // C\n+  FILE* file = fopen(name, \"r\");\n+  setvbuf(file, 0, _IONBF, 0);\n+  start_counters(time, resource);\n+  for (int i = 0; i < iterations; ++i)\n+    if (fread(chunk, 1, chunksize, file) < chunksize)\n+      fseek(file, 0, SEEK_SET);\n+  stop_counters(time, resource);\n+  fclose(file);\n+  report_performance(__FILE__, \"C\", time, resource);\n+  clear_counters(time, resource);\n+\n+  // C unlocked\n+  file = fopen(name, \"r\");\n+  setvbuf(file, 0, _IONBF, 0);\n+  start_counters(time, resource);\n+  for (int i = 0; i < iterations; ++i)\n+    if (fread_unlocked(chunk, 1, chunksize, file) < chunksize)\n+      fseek(file, 0, SEEK_SET);\n+  stop_counters(time, resource);\n+  fclose(file);\n+  report_performance(__FILE__, \"C unlocked\", time, resource);\n+  clear_counters(time, resource);\n+  \n+  // C++\n+  filebuf buf;\n+  buf.pubsetbuf(0, 0);\n+  buf.open(name, ios_base::in);\n+  start_counters(time, resource);\n+  for (int i = 0; i < iterations; ++i)\n+    if (buf.sgetn(chunk, chunksize) < chunksize)\n+      buf.pubseekoff(0, ios::beg);\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"C++\", time, resource);\n+\n+  delete [] chunk;\n+\n+  return 0;\n+}"}]}