{"sha": "1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFiMjQxOTJkNWU4ZTRmY2VlMzUzYmI1YzAyNDk5NWU1NDM5ZjVlMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-17T10:53:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-17T10:53:22Z"}, "message": "cgraph.c (cgraph_hash, [...]): Remove.\n\n\n\t* cgraph.c (cgraph_hash, assembler_name_hash): Remove.\n\t(hash_node, eq_node): Remove.\n\t(cgraph_create_node): Do not handle hashtable.\n\t(cgraph_get_node): Remove.\n\t(cgraph_insert_node_to_hashtable): Remove.\n\t(hash_node_by_assembler_name): Remove.\n\t(eq_assembler_name): Remove.\n\t(cgraph_node_for_asm): Rewrite.\n\t(cgraph_find_replacement_node): Break out from ...\n\t(cgraph_remove_node): ... here; do not maintain hashtables.\n\t(change_decl_assembler_name): Remove.\n\t(cgraph_clone_node): Do not maintain hashtables.\n\t* cgraph.h (const_symtab_node): New typedef.\n\t(cgraph_insert_node_to_hashtable): Remove.\n\t(symtab_get_node, symtab_node_for_asm,\n\tsymtab_insert_node_to_hashtable): Declare.\n\t(cgraph_find_replacement_node): Declare.\n\t(cgraph_get_node, varpool_get_node): Turn into inlines.\n\t(cgraph, varpool): Work sanely on NULL pointers.\n\t(FOR_EACH_SYMBOL): New walker.\n\t* ipa-inline-transform.c (save_inline_function_body): Use\n\tsymtab_insert_node_to_hashtable.\n\t* symtab.c: Include ggc.h and diagnostics.h\n\t(symtab_hash, assembler_name_hash): New static vars;\n\t(hash_node, eq_node, hash_node_by_assembler_name,\n\teq_assembler_name, insert_to_assembler_name_hash,\n\tunlink_from_assembler_name_hash): New.\n\t(symtab_register_node): Update hashtables.\n\t(symtab_insert_node_to_hashtable): New.\n\t(symtab_unregister_node): Update hashtables.\n\t(symtab_get_node): New.\n\t(symtab_node_for_asm): New.\n\t(change_decl_assembler_name): New.\n\t* Makefile.in (symtab.o): Needs GTY.\n\t* varpool.c (varpool_hash): Remove.\n\t(hash_varpool_node, eq_varpool_node, varpool_get_node): Remove.\n\t(varpool_node): Rewrite using varpool_get_node.\n\t(varpool_remove_node): DO not maintain hashtables.\n\t(varpool_node_for_asm); Rewrite.\n\nFrom-SVN: r186525", "tree": {"sha": "74a135bcf142920c4746545d97004d6d4f499f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74a135bcf142920c4746545d97004d6d4f499f76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/comments", "author": null, "committer": null, "parents": [{"sha": "332781bba582208a138ae93c2f20e45d202fc3e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/332781bba582208a138ae93c2f20e45d202fc3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/332781bba582208a138ae93c2f20e45d202fc3e5"}], "stats": {"total": 799, "additions": 420, "deletions": 379}, "files": [{"sha": "024ffcb13a3fa37e51904d9688ff8f379e53e448", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -1,3 +1,45 @@\n+2012-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_hash, assembler_name_hash): Remove.\n+\t(hash_node, eq_node): Remove.\n+\t(cgraph_create_node): Do not handle hashtable.\n+\t(cgraph_get_node): Remove.\n+\t(cgraph_insert_node_to_hashtable): Remove.\n+\t(hash_node_by_assembler_name): Remove.\n+\t(eq_assembler_name): Remove.\n+\t(cgraph_node_for_asm): Rewrite.\n+\t(cgraph_find_replacement_node): Break out from ...\n+\t(cgraph_remove_node): ... here; do not maintain hashtables.\n+\t(change_decl_assembler_name): Remove.\n+\t(cgraph_clone_node): Do not maintain hashtables.\n+\t* cgraph.h (const_symtab_node): New typedef.\n+\t(cgraph_insert_node_to_hashtable): Remove.\n+\t(symtab_get_node, symtab_node_for_asm,\n+\tsymtab_insert_node_to_hashtable): Declare.\n+\t(cgraph_find_replacement_node): Declare.\n+\t(cgraph_get_node, varpool_get_node): Turn into inlines.\n+\t(cgraph, varpool): Work sanely on NULL pointers.\n+\t(FOR_EACH_SYMBOL): New walker.\n+\t* ipa-inline-transform.c (save_inline_function_body): Use\n+\tsymtab_insert_node_to_hashtable.\n+\t* symtab.c: Include ggc.h and diagnostics.h\n+\t(symtab_hash, assembler_name_hash): New static vars;\n+\t(hash_node, eq_node, hash_node_by_assembler_name,\n+\teq_assembler_name, insert_to_assembler_name_hash,\n+\tunlink_from_assembler_name_hash): New.\n+\t(symtab_register_node): Update hashtables.\n+\t(symtab_insert_node_to_hashtable): New.\n+\t(symtab_unregister_node): Update hashtables.\n+\t(symtab_get_node): New.\n+\t(symtab_node_for_asm): New.\n+\t(change_decl_assembler_name): New.\n+\t* Makefile.in (symtab.o): Needs GTY.\n+\t* varpool.c (varpool_hash): Remove.\n+\t(hash_varpool_node, eq_varpool_node, varpool_get_node): Remove.\n+\t(varpool_node): Rewrite using varpool_get_node.\n+\t(varpool_remove_node): DO not maintain hashtables.\n+\t(varpool_node_for_asm); Rewrite.\n+\n 2012-04-16  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi:  Copy-edit to put verbs in the present tense"}, {"sha": "0070ceaea14666e41fdd18696962acb9a8874d82", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -2912,7 +2912,7 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(TARGET_H)\n symtab.o : symtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n-   $(HASHTAB_H) \n+   $(HASHTAB_H) gt-symtab.h\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n@@ -3690,7 +3690,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/fixed-value.h \\\n   $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n-  $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n+  $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/matrix-reorg.c \\\n   $(srcdir)/dbxout.c \\"}, {"sha": "f5f662ccbc87ce9c918f0b4d3e638f7e2c926d79", "filename": "gcc/cgraph.c", "status": "modified", "additions": 98, "deletions": 309, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -119,11 +119,6 @@ static void cgraph_node_remove_callers (struct cgraph_node *node);\n static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n \n-/* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (union symtab_node_def))) htab_t cgraph_hash;\n-/* Hash table used to convert assembler names into nodes.  */\n-static GTY((param_is (union symtab_node_def))) htab_t assembler_name_hash;\n-\n /* Queue of cgraph nodes scheduled to be lowered.  */\n symtab_node x_cgraph_nodes_queue;\n #define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n@@ -419,26 +414,6 @@ cgraph_call_node_duplication_hooks (struct cgraph_node *node1,\n   }\n }\n \n-/* Returns a hash code for P.  */\n-\n-static hashval_t\n-hash_node (const void *p)\n-{\n-  const struct cgraph_node *n = (const struct cgraph_node *) p;\n-  return (hashval_t) DECL_UID (n->symbol.decl);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_node (const void *p1, const void *p2)\n-{\n-  const struct cgraph_node *n1 = (const struct cgraph_node *) p1;\n-  const struct cgraph_node *n2 = (const struct cgraph_node *) p2;\n-  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n-}\n-\n /* Allocate new callgraph node.  */\n \n static inline struct cgraph_node *\n@@ -479,42 +454,18 @@ cgraph_create_node_1 (void)\n struct cgraph_node *\n cgraph_create_node (tree decl)\n {\n-  struct cgraph_node key, *node, **slot;\n-\n+  struct cgraph_node *node = cgraph_create_node_1 ();\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n-  if (!cgraph_hash)\n-    cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n-\n-  key.symbol.decl = decl;\n-  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n-  gcc_assert (!*slot);\n-\n-  node = cgraph_create_node_1 ();\n   node->symbol.decl = decl;\n-  symtab_register_node ((symtab_node)node);\n-  *slot = node;\n+  symtab_register_node ((symtab_node) node);\n+\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n       node->origin = cgraph_get_create_node (DECL_CONTEXT (decl));\n       node->next_nested = node->origin->nested;\n       node->origin->nested = node;\n     }\n-  if (assembler_name_hash)\n-    {\n-      void **aslot;\n-      tree name = DECL_ASSEMBLER_NAME (decl);\n-\n-      aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\tdecl_assembler_name_hash (name),\n-\t\t\t\t\tINSERT);\n-      /* We can have multiple declarations with same assembler name. For C++\n-\t it is __builtin_strlen and strlen, for instance.  Do we need to\n-\t record them all?  Original implementation marked just first one\n-\t so lets hope for the best.  */\n-      if (*aslot == NULL)\n-\t*aslot = node;\n-    }\n   return node;\n }\n \n@@ -629,100 +580,18 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n   return node;\n }\n \n-/* Returns the cgraph node assigned to DECL or NULL if no cgraph node\n-   is assigned.  */\n-\n-struct cgraph_node *\n-cgraph_get_node (const_tree decl)\n-{\n-  struct cgraph_node key, *node = NULL, **slot;\n-\n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n-\n-  if (!cgraph_hash)\n-    return NULL;\n-\n-  key.symbol.decl = CONST_CAST2 (tree, const_tree, decl);\n-\n-  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key,\n-\t\t\t\t\t\t NO_INSERT);\n-\n-  if (slot && *slot)\n-    node = *slot;\n-  return node;\n-}\n-\n-/* Insert already constructed node into hashtable.  */\n-\n-void\n-cgraph_insert_node_to_hashtable (struct cgraph_node *node)\n-{\n-  struct cgraph_node **slot;\n-\n-  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, node, INSERT);\n-\n-  gcc_assert (!*slot);\n-  *slot = node;\n-}\n-\n-/* Returns a hash code for P.  */\n-\n-static hashval_t\n-hash_node_by_assembler_name (const void *p)\n-{\n-  const struct cgraph_node *n = (const struct cgraph_node *) p;\n-  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->symbol.decl));\n-}\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_assembler_name (const void *p1, const void *p2)\n-{\n-  const struct cgraph_node *n1 = (const struct cgraph_node *) p1;\n-  const_tree name = (const_tree)p2;\n-  return (decl_assembler_name_equal (n1->symbol.decl, name));\n-}\n-\n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n    Return NULL if there's no such node.  */\n \n struct cgraph_node *\n cgraph_node_for_asm (tree asmname)\n {\n-  struct cgraph_node *node;\n-  void **slot;\n-\n-  if (!assembler_name_hash)\n-    {\n-      assembler_name_hash =\n-\thtab_create_ggc (10, hash_node_by_assembler_name, eq_assembler_name,\n-\t\t\t NULL);\n-      FOR_EACH_FUNCTION (node)\n-        if (!node->global.inlined_to)\n-\t  {\n-\t    tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n-\t    slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\t     decl_assembler_name_hash (name),\n-\t\t\t\t\t     INSERT);\n-\t    /* We can have multiple declarations with same assembler name. For C++\n-\t       it is __builtin_strlen and strlen, for instance.  Do we need to\n-\t       record them all?  Original implementation marked just first one\n-\t       so lets hope for the best.  */\n-\t    if (!*slot)\n-\t      *slot = node;\n-\t  }\n-    }\n-\n-  slot = htab_find_slot_with_hash (assembler_name_hash, asmname,\n-\t\t\t\t   decl_assembler_name_hash (asmname),\n-\t\t\t\t   NO_INSERT);\n+  symtab_node node = symtab_node_for_asm (asmname);\n \n-  if (slot)\n-    {\n-      node = (struct cgraph_node *) *slot;\n-      return node;\n-    }\n+  /* We do not want to look at inline clones.  */\n+  for (node = symtab_node_for_asm (asmname); node; node = node->symbol.next_sharing_asm_name)\n+    if (symtab_function_p (node) && !cgraph(node)->global.inlined_to)\n+      return cgraph (node);\n   return NULL;\n }\n \n@@ -1392,13 +1261,96 @@ cgraph_release_function_body (struct cgraph_node *node)\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n }\n \n+/* NODE is being removed from symbol table; see if its entry can be replaced by\n+   other inline clone.  */\n+struct cgraph_node *\n+cgraph_find_replacement_node (struct cgraph_node *node)\n+{\n+  struct cgraph_node *next_inline_clone, *replacement;\n+\n+  for (next_inline_clone = node->clones;\n+       next_inline_clone\n+       && next_inline_clone->symbol.decl != node->symbol.decl;\n+       next_inline_clone = next_inline_clone->next_sibling_clone)\n+    ;\n+\n+  /* If there is inline clone of the node being removed, we need\n+     to put it into the position of removed node and reorganize all\n+     other clones to be based on it.  */\n+  if (next_inline_clone)\n+    {\n+      struct cgraph_node *n;\n+      struct cgraph_node *new_clones;\n+\n+      replacement = next_inline_clone;\n+\n+      /* Unlink inline clone from the list of clones of removed node.  */\n+      if (next_inline_clone->next_sibling_clone)\n+\tnext_inline_clone->next_sibling_clone->prev_sibling_clone\n+\t  = next_inline_clone->prev_sibling_clone;\n+      if (next_inline_clone->prev_sibling_clone)\n+\t{\n+\t  gcc_assert (node->clones != next_inline_clone);\n+\t  next_inline_clone->prev_sibling_clone->next_sibling_clone\n+\t    = next_inline_clone->next_sibling_clone;\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (node->clones == next_inline_clone);\n+\t  node->clones = next_inline_clone->next_sibling_clone;\n+\t}\n+\n+      new_clones = node->clones;\n+      node->clones = NULL;\n+\n+      /* Copy clone info.  */\n+      next_inline_clone->clone = node->clone;\n+\n+      /* Now place it into clone tree at same level at NODE.  */\n+      next_inline_clone->clone_of = node->clone_of;\n+      next_inline_clone->prev_sibling_clone = NULL;\n+      next_inline_clone->next_sibling_clone = NULL;\n+      if (node->clone_of)\n+\t{\n+\t  if (node->clone_of->clones)\n+\t    node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n+\t  next_inline_clone->next_sibling_clone = node->clone_of->clones;\n+\t  node->clone_of->clones = next_inline_clone;\n+\t}\n+\n+      /* Merge the clone list.  */\n+      if (new_clones)\n+\t{\n+\t  if (!next_inline_clone->clones)\n+\t    next_inline_clone->clones = new_clones;\n+\t  else\n+\t    {\n+\t      n = next_inline_clone->clones;\n+\t      while (n->next_sibling_clone)\n+\t\tn =  n->next_sibling_clone;\n+\t      n->next_sibling_clone = new_clones;\n+\t      new_clones->prev_sibling_clone = n;\n+\t    }\n+\t}\n+\n+      /* Update clone_of pointers.  */\n+      n = new_clones;\n+      while (n)\n+\t{\n+\t  n->clone_of = next_inline_clone;\n+\t  n = n->next_sibling_clone;\n+\t}\n+      return replacement;\n+    }\n+  else\n+    return NULL;\n+}\n+\n /* Remove the node from cgraph.  */\n \n void\n cgraph_remove_node (struct cgraph_node *node)\n {\n-  void **slot;\n-  bool kill_body = false;\n   struct cgraph_node *n;\n   int uid = node->uid;\n \n@@ -1423,91 +1375,6 @@ cgraph_remove_node (struct cgraph_node *node)\n       *node2 = node->next_nested;\n     }\n   symtab_unregister_node ((symtab_node)node);\n-  slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n-  if (*slot == node)\n-    {\n-      struct cgraph_node *next_inline_clone;\n-\n-      for (next_inline_clone = node->clones;\n-      \t   next_inline_clone\n-\t   && next_inline_clone->symbol.decl != node->symbol.decl;\n-\t   next_inline_clone = next_inline_clone->next_sibling_clone)\n-\t;\n-\n-      /* If there is inline clone of the node being removed, we need\n-         to put it into the position of removed node and reorganize all\n-\t other clones to be based on it.  */\n-      if (next_inline_clone)\n-\t{\n-\t  struct cgraph_node *n;\n-\t  struct cgraph_node *new_clones;\n-\n-\t  *slot = next_inline_clone;\n-\n-\t  /* Unlink inline clone from the list of clones of removed node.  */\n-\t  if (next_inline_clone->next_sibling_clone)\n-\t    next_inline_clone->next_sibling_clone->prev_sibling_clone\n-\t      = next_inline_clone->prev_sibling_clone;\n-\t  if (next_inline_clone->prev_sibling_clone)\n-\t    {\n-\t      gcc_assert (node->clones != next_inline_clone);\n-\t      next_inline_clone->prev_sibling_clone->next_sibling_clone\n-\t        = next_inline_clone->next_sibling_clone;\n-\t    }\n-\t  else\n-\t    {\n-\t      gcc_assert (node->clones == next_inline_clone);\n-\t      node->clones = next_inline_clone->next_sibling_clone;\n-\t    }\n-\n-\t  new_clones = node->clones;\n-\t  node->clones = NULL;\n-\n-\t  /* Copy clone info.  */\n-\t  next_inline_clone->clone = node->clone;\n-\n-\t  /* Now place it into clone tree at same level at NODE.  */\n-\t  next_inline_clone->clone_of = node->clone_of;\n-\t  next_inline_clone->prev_sibling_clone = NULL;\n-\t  next_inline_clone->next_sibling_clone = NULL;\n-\t  if (node->clone_of)\n-\t    {\n-\t      if (node->clone_of->clones)\n-\t        node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n-\t      next_inline_clone->next_sibling_clone = node->clone_of->clones;\n-\t      node->clone_of->clones = next_inline_clone;\n-\t    }\n-\n-\t  /* Merge the clone list.  */\n-\t  if (new_clones)\n-\t    {\n-\t      if (!next_inline_clone->clones)\n-\t\tnext_inline_clone->clones = new_clones;\n-\t      else\n-\t\t{\n-\t\t  n = next_inline_clone->clones;\n-\t\t  while (n->next_sibling_clone)\n-\t\t    n =  n->next_sibling_clone;\n-\t\t  n->next_sibling_clone = new_clones;\n-\t\t  new_clones->prev_sibling_clone = n;\n-\t\t}\n-\t    }\n-\n-\t  /* Update clone_of pointers.  */\n-\t  n = new_clones;\n-\t  while (n)\n-\t    {\n-\t      n->clone_of = next_inline_clone;\n-\t      n = n->next_sibling_clone;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  htab_clear_slot (cgraph_hash, slot);\n-\t  kill_body = true;\n-\t}\n-\n-    }\n   if (node->prev_sibling_clone)\n     node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n   else if (node->clone_of)\n@@ -1549,29 +1416,15 @@ cgraph_remove_node (struct cgraph_node *node)\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n      */\n-  if (!kill_body && *slot)\n-    {\n-      struct cgraph_node *n = (struct cgraph_node *) *slot;\n-      if (!n->clones && !n->clone_of && !n->global.inlined_to\n+  n = cgraph_get_node (node->symbol.decl);\n+  if (!n\n+      || (!n->clones && !n->clone_of && !n->global.inlined_to\n \t  && (cgraph_global_info_ready\n \t      && (TREE_ASM_WRITTEN (n->symbol.decl)\n \t\t  || DECL_EXTERNAL (n->symbol.decl)\n-\t\t  || n->symbol.in_other_partition)))\n-\tkill_body = true;\n-    }\n-  if (assembler_name_hash)\n-    {\n-      tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n-      slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t       decl_assembler_name_hash (name),\n-\t\t\t\t       NO_INSERT);\n-      /* Inline clones are not hashed.  */\n-      if (slot && *slot == node)\n-        htab_clear_slot (assembler_name_hash, slot);\n-    }\n-\n-  if (kill_body)\n+\t\t  || n->symbol.in_other_partition))))\n     cgraph_release_function_body (node);\n+\n   node->symbol.decl = NULL;\n   if (node->call_site_hash)\n     {\n@@ -1939,51 +1792,6 @@ debug_cgraph (void)\n   dump_cgraph (stderr);\n }\n \n-\n-/* Set the DECL_ASSEMBLER_NAME and update cgraph hashtables.  */\n-\n-void\n-change_decl_assembler_name (tree decl, tree name)\n-{\n-  struct cgraph_node *node;\n-  void **slot;\n-  if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n-    SET_DECL_ASSEMBLER_NAME (decl, name);\n-  else\n-    {\n-      if (name == DECL_ASSEMBLER_NAME (decl))\n-\treturn;\n-\n-      if (assembler_name_hash\n-\t  && TREE_CODE (decl) == FUNCTION_DECL\n-\t  && (node = cgraph_get_node (decl)) != NULL)\n-\t{\n-\t  tree old_name = DECL_ASSEMBLER_NAME (decl);\n-\t  slot = htab_find_slot_with_hash (assembler_name_hash, old_name,\n-\t\t\t\t\t   decl_assembler_name_hash (old_name),\n-\t\t\t\t\t   NO_INSERT);\n-\t  /* Inline clones are not hashed.  */\n-\t  if (slot && *slot == node)\n-\t    htab_clear_slot (assembler_name_hash, slot);\n-\t}\n-      if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t  && DECL_RTL_SET_P (decl))\n-\twarning (0, \"%D renamed after being referenced in assembly\", decl);\n-\n-      SET_DECL_ASSEMBLER_NAME (decl, name);\n-    }\n-  if (assembler_name_hash\n-      && TREE_CODE (decl) == FUNCTION_DECL\n-      && (node = cgraph_get_node (decl)) != NULL)\n-    {\n-      slot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t       decl_assembler_name_hash (name),\n-\t\t\t\t       INSERT);\n-      gcc_assert (!*slot);\n-      *slot = node;\n-    }\n-}\n-\n /* Add a top-level asm statement to the list.  */\n \n struct cgraph_asm_node *\n@@ -2154,25 +1962,6 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   n->clones = new_node;\n   new_node->clone_of = n;\n \n-  if (n->symbol.decl != decl)\n-    {\n-      struct cgraph_node **slot;\n-      slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, new_node, INSERT);\n-      gcc_assert (!*slot);\n-      *slot = new_node;\n-      if (assembler_name_hash)\n-\t{\n-\t  void **aslot;\n-\t  tree name = DECL_ASSEMBLER_NAME (decl);\n-\n-\t  aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n-\t\t\t\t\t    decl_assembler_name_hash (name),\n-\t\t\t\t\t    INSERT);\n-\t  gcc_assert (!*aslot);\n-\t  *aslot = new_node;\n-\t}\n-    }\n-\n   if (call_duplication_hook)\n     cgraph_call_node_duplication_hooks (n, new_node);\n   return new_node;"}, {"sha": "39372f1be980399dbf76cc2211141253f2017cfe", "filename": "gcc/cgraph.h", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -40,6 +40,7 @@ enum symtab_type\n \n union symtab_node_def;\n typedef union symtab_node_def *symtab_node;\n+typedef const union symtab_node_def *const_symtab_node;\n \n /* Base of all entries in the symbol table.\n    The symtab_node is inherited by cgraph and varpol nodes.  */\n@@ -60,6 +61,12 @@ struct GTY(()) symtab_node_base\n   /* Linked list of symbol table entries starting with symtab_nodes.  */\n   symtab_node next;\n   symtab_node previous;\n+  /* Linked list of symbols with the same asm name.  There may be multiple\n+     entries for single symbol name in the case of LTO resolutions,\n+     existence of inline clones, or duplicated declaration. The last case\n+     is a long standing bug frontends and builtin handling. */\n+  symtab_node next_sharing_asm_name;\n+  symtab_node previous_sharing_asm_name;\n \n   PTR GTY ((skip)) aux;\n \n@@ -499,15 +506,18 @@ extern bool same_body_aliases_done;\n void symtab_register_node (symtab_node);\n void symtab_unregister_node (symtab_node);\n void symtab_remove_node (symtab_node);\n+symtab_node symtab_get_node (const_tree);\n+symtab_node symtab_node_for_asm (const_tree asmname);\n+void symtab_insert_node_to_hashtable (symtab_node);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n void debug_cgraph (void);\n void dump_cgraph_node (FILE *, struct cgraph_node *);\n void debug_cgraph_node (struct cgraph_node *);\n-void cgraph_insert_node_to_hashtable (struct cgraph_node *node);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n+struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n void cgraph_add_to_same_comdat_group (struct cgraph_node *, struct cgraph_node *);\n bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n void cgraph_release_function_body (struct cgraph_node *);\n@@ -518,7 +528,6 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n \t\t\t\t\t\t int, gcov_type, int);\n struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n-struct cgraph_node * cgraph_get_node (const_tree);\n struct cgraph_node * cgraph_create_node (tree);\n struct cgraph_node * cgraph_get_create_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n@@ -697,7 +706,6 @@ void cgraph_make_node_local (struct cgraph_node *);\n bool cgraph_node_can_be_local_p (struct cgraph_node *);\n \n \n-struct varpool_node * varpool_get_node (const_tree decl);\n void varpool_remove_node (struct varpool_node *node);\n void varpool_finalize_named_section_flags (struct varpool_node *node);\n bool varpool_assemble_pending_decls (void);\n@@ -734,17 +742,36 @@ static inline struct cgraph_node *\n cgraph (symtab_node node)\n {\n   gcc_checking_assert (!node || node->symbol.type == SYMTAB_FUNCTION);\n-  return &node->x_function;\n+  return (struct cgraph_node *)node;\n }\n \n /* Return varpool node for given symbol and check it is a variable.  */\n static inline struct varpool_node *\n varpool (symtab_node node)\n {\n   gcc_checking_assert (!node || node->symbol.type == SYMTAB_VARIABLE);\n-  return &node->x_variable;\n+  return (struct varpool_node *)node;\n }\n \n+/* Return callgraph node for given symbol and check it is a function. */\n+static inline struct cgraph_node *\n+cgraph_get_node (const_tree decl)\n+{\n+  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  return cgraph (symtab_get_node (decl));\n+}\n+\n+/* Return varpool node for given symbol and check it is a function. */\n+static inline struct varpool_node *\n+varpool_get_node (const_tree decl)\n+{\n+  gcc_checking_assert (TREE_CODE (decl) == VAR_DECL);\n+  return varpool (symtab_get_node (decl));\n+}\n+\n+/* Walk all symbols.  */\n+#define FOR_EACH_SYMBOL(node) \\\n+   for ((node) = symtab_nodes; (node); (node) = (node)->symbol.next)\n \n /* Return first reachable static variable with initializer.  */\n static inline struct varpool_node *"}, {"sha": "c6cbd015c3322d583a6771f500477af7def4946a", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -278,7 +278,7 @@ save_inline_function_body (struct cgraph_node *node)\n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n   first_clone->symbol.decl = copy_node (node->symbol.decl);\n-  cgraph_insert_node_to_hashtable (first_clone);\n+  symtab_insert_node_to_hashtable ((symtab_node) first_clone);\n   gcc_assert (first_clone == cgraph_get_node (first_clone->symbol.decl));\n \n   /* Now reshape the clone tree, so all other clones descends from"}, {"sha": "9e7c4df83e94e7084ed4b0baf5b768141d3fb4bb", "filename": "gcc/symtab.c", "status": "modified", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -25,7 +25,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"tree-inline.h\"\n #include \"hashtab.h\"\n+#include \"ggc.h\"\n #include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+\n+/* Hash table used to convert declarations into nodes.  */\n+static GTY((param_is (union symtab_node_def))) htab_t symtab_hash;\n+/* Hash table used to convert assembler names into nodes.  */\n+static GTY((param_is (union symtab_node_def))) htab_t assembler_name_hash;\n \n /* Linked list of symbol table nodes.  */\n symtab_node symtab_nodes;\n@@ -35,29 +42,153 @@ symtab_node symtab_nodes;\n    them, to support -fno-toplevel-reorder.  */\n int symtab_order;\n \n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_node (const void *p)\n+{\n+  const_symtab_node n = (const_symtab_node ) p;\n+  return (hashval_t) DECL_UID (n->symbol.decl);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_node (const void *p1, const void *p2)\n+{\n+  const_symtab_node n1 = (const_symtab_node) p1;\n+  const_symtab_node n2 = (const_symtab_node) p2;\n+  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n+}\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_node_by_assembler_name (const void *p)\n+{\n+  const_symtab_node n = (const_symtab_node) p;\n+  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->symbol.decl));\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_assembler_name (const void *p1, const void *p2)\n+{\n+  const_symtab_node n1 = (const_symtab_node) p1;\n+  const_tree name = (const_tree)p2;\n+  return (decl_assembler_name_equal (n1->symbol.decl, name));\n+}\n+\n+/* Insert NODE to assembler name hash.  */\n+\n+static void\n+insert_to_assembler_name_hash (symtab_node node)\n+{\n+  gcc_checking_assert (!node->symbol.previous_sharing_asm_name\n+\t\t       && !node->symbol.next_sharing_asm_name);\n+  if (assembler_name_hash)\n+    {\n+      void **aslot;\n+      tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n+\n+      aslot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\tdecl_assembler_name_hash (name),\n+\t\t\t\t\tINSERT);\n+      gcc_assert (*aslot != node);\n+      node->symbol.next_sharing_asm_name = (symtab_node)*aslot;\n+      if (*aslot != NULL)\n+\t((symtab_node)*aslot)->symbol.previous_sharing_asm_name = node;\n+      *aslot = node;\n+    }\n+\n+}\n+\n+/* Remove NODE from assembler name hash.  */\n+\n+static void\n+unlink_from_assembler_name_hash (symtab_node node)\n+{\n+  if (assembler_name_hash)\n+    {\n+      if (node->symbol.next_sharing_asm_name)\n+\tnode->symbol.next_sharing_asm_name->symbol.previous_sharing_asm_name\n+\t  = node->symbol.previous_sharing_asm_name;\n+      if (node->symbol.previous_sharing_asm_name)\n+\t{\n+\t  node->symbol.previous_sharing_asm_name->symbol.next_sharing_asm_name\n+\t    = node->symbol.next_sharing_asm_name;\n+\t}\n+      else\n+\t{\n+\t  tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n+          void **slot;\n+\t  slot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\t   decl_assembler_name_hash (name),\n+\t\t\t\t\t   NO_INSERT);\n+\t  gcc_assert (*slot == node);\n+\t  if (!node->symbol.next_sharing_asm_name)\n+\t    htab_clear_slot (assembler_name_hash, slot);\n+\t  else\n+\t    *slot = node->symbol.next_sharing_asm_name;\n+\t}\n+    }\n+}\n+\n+\n /* Add node into symbol table.  This function is not used directly, but via\n    cgraph/varpool node creation routines.  */\n \n void\n symtab_register_node (symtab_node node)\n {\n+  struct symtab_node_base key;\n+  symtab_node *slot;\n+\n   node->symbol.next = symtab_nodes;\n   node->symbol.previous = NULL;\n   if (symtab_nodes)\n     symtab_nodes->symbol.previous = node;\n   symtab_nodes = node;\n \n+  if (!symtab_hash)\n+    symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n+  key.decl = node->symbol.decl;\n+  slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n+  if (*slot == NULL)\n+    *slot = node;\n+\n+  insert_to_assembler_name_hash (node);\n+\n   node->symbol.order = symtab_order++;\n \n   ipa_empty_ref_list (&node->symbol.ref_list);\n }\n \n+/* Make NODE to be the one symtab hash is pointing to.  Used when reshaping tree\n+   of inline clones.  */\n+\n+void\n+symtab_insert_node_to_hashtable (symtab_node node)\n+{\n+  struct symtab_node_base key;\n+  symtab_node *slot;\n+\n+  if (!symtab_hash)\n+    symtab_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n+  key.decl = node->symbol.decl;\n+  slot = (symtab_node *) htab_find_slot (symtab_hash, &key, INSERT);\n+  *slot = node;\n+}\n+\n /* Remove node from symbol table.  This function is not used directly, but via\n    cgraph/varpool node removal routines.  */\n \n void\n symtab_unregister_node (symtab_node node)\n {\n+  void **slot;\n   ipa_remove_all_references (&node->symbol.ref_list);\n   ipa_remove_all_refering (&node->symbol.ref_list);\n \n@@ -83,6 +214,46 @@ symtab_unregister_node (symtab_node node)\n     node->symbol.next->symbol.previous = node->symbol.previous;\n   node->symbol.next = NULL;\n   node->symbol.previous = NULL;\n+\n+  slot = htab_find_slot (symtab_hash, node, NO_INSERT);\n+  if (*slot == node)\n+    {\n+      symtab_node replacement_node = NULL;\n+      if (symtab_function_p (node))\n+\treplacement_node = (symtab_node)cgraph_find_replacement_node (cgraph (node));\n+      if (!replacement_node)\n+\thtab_clear_slot (symtab_hash, slot);\n+      else\n+\t*slot = replacement_node;\n+    }\n+  unlink_from_assembler_name_hash (node);\n+}\n+\n+/* Return symbol table node associated with DECL, if any,\n+   and NULL otherwise.  */\n+\n+symtab_node\n+symtab_get_node (const_tree decl)\n+{\n+  symtab_node *slot;\n+  struct symtab_node_base key;\n+\n+  gcc_checking_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t       || (TREE_CODE (decl) == VAR_DECL\n+\t\t\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)\n+\t\t\t       || in_lto_p)));\n+\n+  if (!symtab_hash)\n+    return NULL;\n+\n+  key.decl = CONST_CAST2 (tree, const_tree, decl);\n+\n+  slot = (symtab_node *) htab_find_slot (symtab_hash, &key,\n+\t\t\t\t\t NO_INSERT);\n+\n+  if (slot)\n+    return *slot;\n+  return NULL;\n }\n \n /* Remove symtab NODE from the symbol table.  */\n@@ -95,3 +266,71 @@ symtab_remove_node (symtab_node node)\n   else if (symtab_variable_p (node))\n     varpool_remove_node (varpool (node));\n }\n+\n+/* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n+   Return NULL if there's no such node.  */\n+\n+symtab_node\n+symtab_node_for_asm (const_tree asmname)\n+{\n+  symtab_node node;\n+  void **slot;\n+\n+  if (!assembler_name_hash)\n+    {\n+      assembler_name_hash =\n+\thtab_create_ggc (10, hash_node_by_assembler_name, eq_assembler_name,\n+\t\t\t NULL);\n+      FOR_EACH_SYMBOL (node)\n+\tinsert_to_assembler_name_hash (node);\n+    }\n+\n+  slot = htab_find_slot_with_hash (assembler_name_hash, asmname,\n+\t\t\t\t   decl_assembler_name_hash (asmname),\n+\t\t\t\t   NO_INSERT);\n+\n+  if (slot)\n+    {\n+      node = (symtab_node) *slot;\n+      return node;\n+    }\n+  return NULL;\n+}\n+\n+/* Set the DECL_ASSEMBLER_NAME and update symtab hashtables.  */\n+\n+void\n+change_decl_assembler_name (tree decl, tree name)\n+{\n+  symtab_node node = NULL;\n+\n+  /* We can have user ASM names on things, like global register variables, that\n+     are not in the symbol table.  */\n+  if ((TREE_CODE (decl) == VAR_DECL\n+       && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    node = symtab_get_node (decl);\n+  if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n+    {\n+      SET_DECL_ASSEMBLER_NAME (decl, name);\n+      if (node)\n+\tinsert_to_assembler_name_hash (node);\n+    }\n+  else\n+    {\n+      if (name == DECL_ASSEMBLER_NAME (decl))\n+\treturn;\n+\n+      if (node)\n+\tunlink_from_assembler_name_hash (node);\n+      if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n+\t  && DECL_RTL_SET_P (decl))\n+\twarning (0, \"%D renamed after being referenced in assembly\", decl);\n+\n+      SET_DECL_ASSEMBLER_NAME (decl, name);\n+      if (node)\n+\tinsert_to_assembler_name_hash (node);\n+    }\n+}\n+\n+#include \"gt-symtab.h\""}, {"sha": "e41a780fec3bc9c79be3e9c83564ce94680e6a30", "filename": "gcc/varpool.c", "status": "modified", "additions": 6, "deletions": 62, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ab24192d5e8e4fcee353bb5c024995e5439f5e3/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=1ab24192d5e8e4fcee353bb5c024995e5439f5e3", "patch": "@@ -48,9 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n     All variables supposed to be output into final file needs to be\n     explicitly marked by frontend via VARPOOL_FINALIZE_DECL function.  */\n \n-/* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (union symtab_node_def))) htab_t varpool_hash;\n-\n /* Queue of cgraph nodes scheduled to be lowered and output.\n    The queue is maintained via mark_needed_node, linked via node->next_needed\n    pointer.\n@@ -84,77 +81,27 @@ varpool_node_name (struct varpool_node *node)\n   return lang_hooks.decl_printable_name (node->symbol.decl, 2);\n }\n \n-/* Returns a hash code for P.  */\n-static hashval_t\n-hash_varpool_node (const void *p)\n-{\n-  const struct varpool_node *n = (const struct varpool_node *) p;\n-  return (hashval_t) DECL_UID (n->symbol.decl);\n-}\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-static int\n-eq_varpool_node (const void *p1, const void *p2)\n-{\n-  const struct varpool_node *n1 =\n-    (const struct varpool_node *) p1;\n-  const struct varpool_node *n2 =\n-    (const struct varpool_node *) p2;\n-  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n-}\n-\n-/* Return varpool node assigned to DECL without creating new one.  */\n-struct varpool_node *\n-varpool_get_node (const_tree decl)\n-{\n-  struct varpool_node key, **slot;\n-\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)));\n-\n-  if (!varpool_hash)\n-    return NULL;\n-  key.symbol.decl = CONST_CAST2 (tree, const_tree, decl);\n-  slot = (struct varpool_node **)\n-    htab_find_slot (varpool_hash, &key, NO_INSERT);\n-  if (!slot)\n-    return NULL;\n-  return *slot;\n-}\n-\n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n varpool_node (tree decl)\n {\n-  struct varpool_node key, *node, **slot;\n-\n+  struct varpool_node *node = varpool_get_node (decl);\n   gcc_assert (TREE_CODE (decl) == VAR_DECL\n \t      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl) || in_lto_p));\n+  if (node)\n+    return node;\n \n-  if (!varpool_hash)\n-    varpool_hash = htab_create_ggc (10, hash_varpool_node,\n-\t\t\t\t\t   eq_varpool_node, NULL);\n-  key.symbol.decl = decl;\n-  slot = (struct varpool_node **)\n-    htab_find_slot (varpool_hash, &key, INSERT);\n-  if (*slot)\n-    return *slot;\n   node = ggc_alloc_cleared_varpool_node ();\n   node->symbol.type = SYMTAB_VARIABLE;\n   node->symbol.decl = decl;\n   symtab_register_node ((symtab_node)node);\n-  *slot = node;\n   return node;\n }\n \n /* Remove node from the varpool.  */\n void\n varpool_remove_node (struct varpool_node *node)\n {\n-  void **slot;\n-  slot = htab_find_slot (varpool_hash, node, NO_INSERT);\n-  gcc_assert (*slot == node);\n-  htab_clear_slot (varpool_hash, slot);\n   gcc_assert (!varpool_assembled_nodes_queue);\n   symtab_unregister_node ((symtab_node)node);\n   if (varpool_first_unanalyzed_node == node)\n@@ -238,12 +185,9 @@ debug_varpool (void)\n struct varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n-  struct varpool_node *node;\n-\n-  FOR_EACH_VARIABLE (node)\n-    if (decl_assembler_name_equal (node->symbol.decl, asmname))\n-      return node;\n-\n+  symtab_node node = symtab_node_for_asm (asmname);\n+  if (node && symtab_variable_p (node))\n+    return varpool (node);\n   return NULL;\n }\n "}]}