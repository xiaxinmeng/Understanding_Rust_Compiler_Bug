{"sha": "8fe0ca0c076f46ba45448b3254597844475eee30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZlMGNhMGMwNzZmNDZiYTQ1NDQ4YjMyNTQ1OTc4NDQ0NzVlZWUzMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-14T09:37:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-14T09:37:31Z"}, "message": "genrecog.c (special_mode_pred_table): New.\n\n        * genrecog.c (special_mode_pred_table): New.\n        (NUM_SPECIAL_MODE_PREDS): New.\n        (find_operand): New.\n        (validate_pattern): New argument `insn'.  Warn for assignment to\n        any predicate accepting non-lvalues.  Conditionaly warn for\n        match_operand without a mode.  Try much harder to match source\n        and destination modes on a set.\n        * tm.texi (SPECIAL_MODE_PREDICATES): Document.\n\nFrom-SVN: r29967", "tree": {"sha": "1796e42498ad521d8d7c76c8890bd5c76139a8cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1796e42498ad521d8d7c76c8890bd5c76139a8cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fe0ca0c076f46ba45448b3254597844475eee30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe0ca0c076f46ba45448b3254597844475eee30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fe0ca0c076f46ba45448b3254597844475eee30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe0ca0c076f46ba45448b3254597844475eee30/comments", "author": null, "committer": null, "parents": [{"sha": "03e0a65f6e0a4bd3e292e1e6a8328a591ec86f58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e0a65f6e0a4bd3e292e1e6a8328a591ec86f58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e0a65f6e0a4bd3e292e1e6a8328a591ec86f58"}], "stats": {"total": 292, "additions": 235, "deletions": 57}, "files": [{"sha": "82d762ad9d5de6e6a69cd1f8acd90b103a516c4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fe0ca0c076f46ba45448b3254597844475eee30", "patch": "@@ -1,3 +1,14 @@\n+Thu Oct 14 01:49:54 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genrecog.c (special_mode_pred_table): New.\n+\t(NUM_SPECIAL_MODE_PREDS): New.\n+\t(find_operand): New.\n+\t(validate_pattern): New argument `insn'.  Warn for assignment to\n+\tany predicate accepting non-lvalues.  Conditionaly warn for\n+\tmatch_operand without a mode.  Try much harder to match source\n+\tand destination modes on a set.\n+\t* tm.texi (SPECIAL_MODE_PREDICATES): Document.\n+\n Thu Oct 14 02:54:13 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* fold-const.c (fold): Detect rotates built from BIT_XOR_EXPRs."}, {"sha": "f36e8796576808fa0ef7f8f9e6c0db50b9564e38", "filename": "gcc/genrecog.c", "status": "modified", "additions": 207, "deletions": 57, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=8fe0ca0c076f46ba45448b3254597844475eee30", "patch": "@@ -216,12 +216,24 @@ static struct pred_table\n \n #define NUM_KNOWN_PREDS (sizeof preds / sizeof preds[0])\n \n+static const char * special_mode_pred_table[] = {\n+#ifdef SPECIAL_MODE_PREDICATES\n+  SPECIAL_MODE_PREDICATES\n+#endif\n+  NULL\n+};\n+\n+#define NUM_SPECIAL_MODE_PREDS \\\n+  (sizeof (special_mode_pred_table) / sizeof (const char *) - 1)\n+\n static struct decision *new_decision\n   PROTO((const char *, struct decision_head *));\n static struct decision_test *new_decision_test\n   PROTO((enum decision_type, struct decision_test ***));\n-static void validate_pattern\n+static rtx find_operand\n   PROTO((rtx, int));\n+static void validate_pattern\n+  PROTO((rtx, rtx, int));\n static struct decision *add_to_sequence\n   PROTO((rtx, struct decision_head *, const char *, enum routine_type, int));\n \n@@ -356,103 +368,242 @@ new_decision_test (type, pplace)\n   return test;\n }\n \n+/* Search for and return operand N.  */\n+\n+static rtx\n+find_operand (pattern, n)\n+     rtx pattern;\n+     int n;\n+{\n+  const char *fmt;\n+  RTX_CODE code;\n+  int i, j, len;\n+  rtx r;\n+\n+  code = GET_CODE (pattern);\n+  if ((code == MATCH_SCRATCH\n+       || code == MATCH_INSN\n+       || code == MATCH_OPERAND\n+       || code == MATCH_OPERATOR\n+       || code == MATCH_PARALLEL)\n+      && XINT (pattern, 0) == n)\n+    return pattern;\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  len = GET_RTX_LENGTH (code);\n+  for (i = 0; i < len; i++)\n+    {\n+      switch (fmt[i])\n+\t{\n+\tcase 'e': case 'u':\n+\t  if ((r = find_operand (XEXP (pattern, i), n)) != NULL_RTX)\n+\t    return r;\n+\t  break;\n+\n+\tcase 'E':\n+\t  for (j = 0; j < XVECLEN (pattern, i); j++)\n+\t    if ((r = find_operand (XVECEXP (pattern, i, j), n)) != NULL_RTX)\n+\t      return r;\n+\t  break;\n+\n+\tcase 'i': case 'w': case '0': case 's':\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n /* Check for various errors in patterns.  */\n \n static void\n-validate_pattern (pattern, set_dest)\n+validate_pattern (pattern, insn, set_dest)\n      rtx pattern;\n+     rtx insn;\n      int set_dest;\n {\n   const char *fmt;\n   RTX_CODE code;\n-  int i, j, len;\n+  size_t i, len;\n+  int j;\n \n   code = GET_CODE (pattern);\n   switch (code)\n     {\n     case MATCH_SCRATCH:\n-    case MATCH_INSN:\n       return;\n \n+    case MATCH_INSN:\n     case MATCH_OPERAND:\n+    case MATCH_OPERATOR:\n       {\n \tconst char *pred_name = XSTR (pattern, 1);\n+\tint allows_non_lvalue = 1, allows_non_const = 1;\n+\tint special_mode_pred = 0;\n+\tconst char *c_test;\n+\n+\tif (GET_CODE (insn) == DEFINE_INSN)\n+\t  c_test = XSTR (insn, 2);\n+\telse\n+\t  c_test = XSTR (insn, 1);\n \n \tif (pred_name[0] != 0)\n \t  {\n-\t    /* See if we know about this predicate and save its number.  If\n-\t       we do, and it only accepts one code, note that fact.  The\n-\t       predicate `const_int_operand' only tests for a CONST_INT, so\n-\t       if we do so we can avoid calling it at all.\n-\n-\t       Finally, if we know that the predicate does not allow\n-\t       CONST_INT, we know that the only way the predicate can match\n-\t       is if the modes match (here we use the kludge of relying on\n-\t       the fact that \"address_operand\" accepts CONST_INT; otherwise,\n-\t       it would have to be a special case), so we can test the mode\n-\t       (but we need not).  This fact should considerably simplify the\n-\t       generated code.  */\n-\n-\t    for (i = 0; i < (int) NUM_KNOWN_PREDS; i++)\n+\t    for (i = 0; i < NUM_KNOWN_PREDS; i++)\n \t      if (! strcmp (preds[i].name, pred_name))\n \t\tbreak;\n \n-\t    if (i < (int) NUM_KNOWN_PREDS)\n+\t    if (i < NUM_KNOWN_PREDS)\n \t      {\n-\t\tint j, allows_const_int;\n+\t\tint j;\n \n-\t\tallows_const_int = 0;\n+\t\tallows_non_lvalue = allows_non_const = 0;\n \t\tfor (j = 0; preds[i].codes[j] != 0; j++)\n-\t\t  if (preds[i].codes[j] == CONST_INT)\n-\t\t    {\n-\t\t      allows_const_int = 1;\n-\t\t      break;\n-\t\t    }\n-\n-\t\tif (allows_const_int && set_dest)\n \t\t  {\n-\t\t    message_with_line (pattern_lineno,\n-\t\t\t\t       \"warning: `%s' accepts const_int,\",\n-\t\t\t\t       pred_name);\n-\t\t    message_with_line (pattern_lineno,\n-\t\t\t\t       \"  and used as destination of a set\");\n+\t\t    RTX_CODE c = preds[i].codes[j];\n+\t\t    if (c != LABEL_REF\n+\t\t\t&& c != SYMBOL_REF\n+\t\t\t&& c != CONST_INT\n+\t\t\t&& c != CONST_DOUBLE\n+\t\t\t&& c != CONST\n+\t\t\t&& c != HIGH\n+\t\t\t&& c != CONSTANT_P_RTX)\n+\t\t      allows_non_const = 1;\n+\n+\t\t    if (c != REG\n+\t\t\t&& c != SUBREG\n+\t\t\t&& c != MEM\n+\t\t\t&& c != CONCAT\n+\t\t\t&& c != PARALLEL\n+\t\t\t&& c != STRICT_LOW_PART)\n+\t\t      allows_non_lvalue = 1;\n \t\t  }\n \t      }\n \t    else\n \t      {\n #ifdef PREDICATE_CODES\n \t\t/* If the port has a list of the predicates it uses but\n \t\t   omits one, warn.  */\n-\t\tmessage_with_line (pattern_lineno, \"warning: `%s' not in PREDICATE_CODES\", pred_name);\n+\t\tmessage_with_line (pattern_lineno,\n+\t\t\t\t   \"warning: `%s' not in PREDICATE_CODES\",\n+\t\t\t\t   pred_name);\n #endif\n \t      }\n+\n+\t    for (i = 0; i < NUM_SPECIAL_MODE_PREDS; ++i)\n+\t      if (strcmp (pred_name, special_mode_pred_table[i]) == 0)\n+\t\t{\n+\t\t  special_mode_pred = 1;\n+\t\t  break;\n+\t\t}\n+\t  }\n+\n+\t/* Allowing non-lvalues in destinations -- particularly CONST_INT --\n+\t   while not likely to occur at runtime, results in less efficient\n+\t   code from insn-recog.c.  */\n+\tif (set_dest\n+\t    && pred_name[0] != '\\0'\n+\t    && allows_non_lvalue)\n+\t  {\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"warning: `%s' allows non-lvalue,\",\n+\t\t\t       pred_name);\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"  and used as destination of a set\");\n+\t  }\n+\n+\t/* A modeless MATCH_OPERAND can be handy when we can\n+\t   check for multiple modes in the c_test.  In most other cases,\n+\t   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT\n+\t   and PEEP2 can FAIL within the output pattern.  */\n+\n+\tif (GET_MODE (pattern) == VOIDmode\n+\t    && code == MATCH_OPERAND\n+\t    && pred_name[0] != '\\0'\n+\t    && allows_non_const\n+\t    && ! special_mode_pred\n+\t    && strstr (c_test, \"operands\") != NULL\n+\t    && GET_CODE (insn) == DEFINE_INSN)\n+\t  {\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"warning: operand %d missing mode?\",\n+\t\t\t       XINT (pattern, 0));\n \t  }\n \n \treturn;\n       }\n \n     case SET:\n-      /* The operands of a SET must have the same mode unless one\n-\t is VOIDmode.  */\n-      if (GET_MODE (SET_SRC (pattern)) != VOIDmode\n-\t  && GET_MODE (SET_DEST (pattern)) != VOIDmode\n-\t  && GET_MODE (SET_SRC (pattern)) != GET_MODE (SET_DEST (pattern))\n-\t  /* The mode of an ADDRESS_OPERAND is the mode of the memory\n-\t     reference, not the mode of the address.  */\n-\t  && ! (GET_CODE (SET_SRC (pattern)) == MATCH_OPERAND\n-\t\t&& ! strcmp (XSTR (SET_SRC (pattern), 1), \"address_operand\")))\n-\t{\n-\t  message_with_line (pattern_lineno,\n-\t\t\t     \"mode mismatch in set: %smode vs %smode\",\n-\t\t\t     GET_MODE_NAME (GET_MODE (SET_DEST (pattern))),\n-\t\t\t     GET_MODE_NAME (GET_MODE (SET_SRC (pattern))));\n-\t  error_count++;\n-\t}\n+      {\n+\tenum machine_mode dmode, smode;\n+\trtx dest, src;\n+\n+\tdest = SET_DEST (pattern);\n+\tsrc = SET_SRC (pattern);\n+\n+\t/* Find the referant for a DUP.  */\n+\n+\tif (GET_CODE (dest) == MATCH_DUP\n+\t    || GET_CODE (dest) == MATCH_OP_DUP\n+\t    || GET_CODE (dest) == MATCH_PAR_DUP)\n+\t  dest = find_operand (insn, XINT (dest, 0));\n+\n+\tif (GET_CODE (src) == MATCH_DUP\n+\t    || GET_CODE (src) == MATCH_OP_DUP\n+\t    || GET_CODE (src) == MATCH_PAR_DUP)\n+\t  src = find_operand (insn, XINT (src, 0));\n+\n+\t/* STRICT_LOW_PART is a wrapper.  Its argument is the real\n+\t   destination, and it's mode should match the source.  */\n+\tif (GET_CODE (dest) == STRICT_LOW_PART)\n+\t  dest = XEXP (dest, 0);\n+\n+\tdmode = GET_MODE (dest);\n+\tsmode = GET_MODE (src);\n \n-      validate_pattern (SET_DEST (pattern), 1);\n-      validate_pattern (SET_SRC (pattern), 0);\n+\t/* The mode of an ADDRESS_OPERAND is the mode of the memory\n+\t   reference, not the mode of the address.  */\n+\tif (GET_CODE (src) == MATCH_OPERAND\n+\t    && ! strcmp (XSTR (src, 1), \"address_operand\"))\n+\t  ;\n+\n+        /* The operands of a SET must have the same mode unless one\n+\t   is VOIDmode.  */\n+        else if (dmode != VOIDmode && smode != VOIDmode && dmode != smode)\n+\t  {\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"mode mismatch in set: %smode vs %smode\",\n+\t\t\t       GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n+\t    error_count++;\n+\t  }\n+\n+\t/* If only one of the operands is VOIDmode, and PC or CC0 is \n+\t   not involved, it's probably a mistake.  */\n+\telse if (dmode != smode\n+\t\t && GET_CODE (dest) != PC\n+\t\t && GET_CODE (dest) != CC0\n+\t\t && GET_CODE (src) != CONST_INT)\n+\t  {\n+\t    const char *which;\n+\t    which = (dmode == VOIDmode ? \"destination\" : \"source\");\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"warning: %s missing a mode?\", which);\n+\t  }\n+\n+\tif (dest != SET_DEST (pattern))\n+\t  validate_pattern (dest, insn, 1);\n+\tvalidate_pattern (SET_DEST (pattern), insn, 1);\n+        validate_pattern (SET_SRC (pattern), insn, 0);\n+        return;\n+      }\n+\n+    case CLOBBER:\n+      validate_pattern (SET_DEST (pattern), insn, 1);\n       return;\n-      \n+\n     case LABEL_REF:\n       if (GET_MODE (XEXP (pattern, 0)) != VOIDmode)\n \t{\n@@ -474,12 +625,12 @@ validate_pattern (pattern, set_dest)\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  validate_pattern (XEXP (pattern, i), 0);\n+\t  validate_pattern (XEXP (pattern, i), insn, 0);\n \t  break;\n \n \tcase 'E':\n \t  for (j = 0; j < XVECLEN (pattern, i); j++)\n-\t    validate_pattern (XVECEXP (pattern, i, j), 0);\n+\t    validate_pattern (XVECEXP (pattern, i, j), insn, 0);\n \t  break;\n \n \tcase 'i': case 'w': case '0': case 's':\n@@ -489,7 +640,6 @@ validate_pattern (pattern, set_dest)\n \t  abort ();\n \t}\n     }\n-\n }\n \n /* Create a chain of nodes to verify that an rtl expression matches\n@@ -2148,7 +2298,7 @@ make_insn_sequence (insn, type)\n       PUT_MODE (x, VOIDmode);\n     }\n \n-  validate_pattern (x, 0);\n+  validate_pattern (x, insn, 0);\n \n   memset(&head, 0, sizeof(head));\n   last = add_to_sequence (x, &head, \"\", type, 1);"}, {"sha": "c11a354995fbd69f5e82588b45175e91e9d56c62", "filename": "gcc/tm.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe0ca0c076f46ba45448b3254597844475eee30/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=8fe0ca0c076f46ba45448b3254597844475eee30", "patch": "@@ -7224,6 +7224,23 @@ thus speeding up the compiler.  The most important predicates to include\n in the list specified by this macro are those used in the most insn\n patterns.\n \n+@item SPECIAL_MODE_PREDICATES\n+@findex SPECIAL_MODE_PREDICATES\n+Define this if you have special predicates that know special things\n+about modes.  Genrecog will warn about certain forms of \n+@code{match_operand} without a mode; if the operand predicate is\n+listed in @code{SPECIAL_MODE_PREDICATES}, the warning will be \n+suppressed.\n+\n+Here is an example from the IA-32 port (@code{ext_register_operand}\n+specially checks for @code{HImode} or @code{SImode} in preparation\n+for a byte extraction from @code{%ah} etc.).\n+\n+@smallexample\n+#define SPECIAL_MODE_PREDICATES \\\n+  \"ext_register_operand\",\n+@end smallexample\n+\n @findex CASE_VECTOR_MODE\n @item CASE_VECTOR_MODE\n An alias for a machine mode name.  This is the machine mode that"}]}