{"sha": "74fa0285457b8a4eaad7425f59c93b12334bc392", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRmYTAyODU0NTdiOGE0ZWFhZDc0MjVmNTljOTNiMTIzMzRiYzM5Mg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@cs.tamu.edu", "date": "2006-01-28T22:56:31Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2006-01-28T22:56:31Z"}, "message": "class.c (check_bases): Likewise.\n\n        * class.c (check_bases): Likewise.\n        (maybe_warn_about_overly_private_class): Likewise.\n        (check_field_decls): Likewise.\n        (layout_empty_base): Likewise.\n        (layout_virtual_bases): Likewise.\n        (layout_class_type): Likewise.\n\n        * call.c (joust): Pass option code to warning.  Use inform for\n        explanation.\n\nFrom-SVN: r110342", "tree": {"sha": "5cec6efa51cbb5b7115e88b2f3121e5e2de70997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cec6efa51cbb5b7115e88b2f3121e5e2de70997"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74fa0285457b8a4eaad7425f59c93b12334bc392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fa0285457b8a4eaad7425f59c93b12334bc392", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74fa0285457b8a4eaad7425f59c93b12334bc392", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74fa0285457b8a4eaad7425f59c93b12334bc392/comments", "author": null, "committer": null, "parents": [{"sha": "2ef06beb77833e951ce436d9b0b954090e4248b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef06beb77833e951ce436d9b0b954090e4248b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef06beb77833e951ce436d9b0b954090e4248b6"}], "stats": {"total": 75, "additions": 49, "deletions": 26}, "files": [{"sha": "f2e245b2230627c959a04ada1af326fbaeb6b09a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74fa0285457b8a4eaad7425f59c93b12334bc392", "patch": "@@ -1,3 +1,15 @@\n+2006-01-28  Gabriel Dos Reis  <gdr@cs.tamu.edu>\n+\n+\t* class.c (check_bases): Likewise.\n+\t(maybe_warn_about_overly_private_class): Likewise.\n+\t(check_field_decls): Likewise.\n+\t(layout_empty_base): Likewise.\n+\t(layout_virtual_bases): Likewise.\n+\t(layout_class_type): Likewise.\n+\n+\t* call.c (joust): Pass option code to warning.  Use inform for\n+\texplanation. \n+\n 2006-01-28  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/25999"}, {"sha": "2fc5c5762917218ebe6186920be8d8431c653a11", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=74fa0285457b8a4eaad7425f59c93b12334bc392", "patch": "@@ -6029,9 +6029,9 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \n \t      if (warn)\n \t\t{\n-\t\t  warning (0, \"passing %qT chooses %qT over %qT\",\n-\t\t\t      type, type1, type2);\n-\t\t  warning (0, \"  in call to %qD\", w->fn);\n+\t\t  warning (OPT_Wsign_promo, \"passing %qT chooses %qT over %qT\",\n+                           type, type1, type2);\n+\t\t  warning (OPT_Wsign_promo, \"  in call to %qD\", w->fn);\n \t\t}\n \t      else\n \t\tadd_warning (w, l);\n@@ -6088,10 +6088,10 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t  tree source = source_type (w->convs[0]);\n \t  if (! DECL_CONSTRUCTOR_P (w->fn))\n \t    source = TREE_TYPE (source);\n-\t  warning (0, \"choosing %qD over %qD\", w->fn, l->fn);\n-\t  warning (0, \"  for conversion from %qT to %qT\",\n+\t  warning (OPT_Wconversion, \"choosing %qD over %qD\", w->fn, l->fn);\n+\t  warning (OPT_Wconversion, \"  for conversion from %qT to %qT\",\n \t\t   source, w->second_conv->type);\n-\t  warning (0, \"  because conversion sequence for the argument is better\");\n+\t  inform (\"  because conversion sequence for the argument is better\");\n \t}\n       else\n \tadd_warning (w, l);"}, {"sha": "275cbced9c9d3726dfe343c245630e01301b758c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74fa0285457b8a4eaad7425f59c93b12334bc392/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=74fa0285457b8a4eaad7425f59c93b12334bc392", "patch": "@@ -1227,8 +1227,9 @@ check_bases (tree t,\n       /* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P\n \t here because the case of virtual functions but non-virtual\n \t dtor is handled in finish_struct_1.  */\n-      if (warn_ecpp && ! TYPE_POLYMORPHIC_P (basetype))\n-\twarning (0, \"base class %q#T has a non-virtual destructor\", basetype);\n+      if (!TYPE_POLYMORPHIC_P (basetype))\n+\twarning (OPT_Weffc__,\n+                 \"base class %q#T has a non-virtual destructor\", basetype);\n \n       /* If the base class doesn't have copy constructors or\n \t assignment operators that take const references, then the\n@@ -1542,7 +1543,8 @@ maybe_warn_about_overly_private_class (tree t)\n \t  }\n       if (!has_nonprivate_method)\n \t{\n-\t  warning (0, \"all member functions in class %qT are private\", t);\n+\t  warning (OPT_Wctor_dtor_privacy,\n+                   \"all member functions in class %qT are private\", t);\n \t  return;\n \t}\n     }\n@@ -1553,7 +1555,8 @@ maybe_warn_about_overly_private_class (tree t)\n   fn = CLASSTYPE_DESTRUCTORS (t);\n   if (fn && TREE_PRIVATE (fn))\n     {\n-      warning (0, \"%q#T only defines a private destructor and has no friends\",\n+      warning (OPT_Wctor_dtor_privacy,\n+               \"%q#T only defines a private destructor and has no friends\",\n \t       t);\n       return;\n     }\n@@ -1596,7 +1599,8 @@ maybe_warn_about_overly_private_class (tree t)\n \n       if (nonprivate_ctor == 0)\n \t{\n-\t  warning (0, \"%q#T only defines private constructors and has no friends\",\n+\t  warning (OPT_Wctor_dtor_privacy,\n+                   \"%q#T only defines private constructors and has no friends\",\n \t\t   t);\n \t  return;\n \t}\n@@ -3032,12 +3036,14 @@ check_field_decls (tree t, tree *access_decls,\n \n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n-\t  warning (0, \"  but does not override %<%T(const %T&)%>\", t, t);\n-\t  if (! TYPE_HAS_ASSIGN_REF (t))\n-\t    warning (0, \"  or %<operator=(const %T&)%>\", t);\n+\t  warning (OPT_Weffc__,\n+                   \"  but does not override %<%T(const %T&)%>\", t, t);\n+\t  if (!TYPE_HAS_ASSIGN_REF (t))\n+\t    warning (OPT_Weffc__, \"  or %<operator=(const %T&)%>\", t);\n \t}\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n-\twarning (0, \"  but does not override %<operator=(const %T&)%>\", t);\n+\twarning (OPT_Weffc__,\n+                 \"  but does not override %<operator=(const %T&)%>\", t);\n     }\n \n \n@@ -3492,8 +3498,9 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n       if (abi_version_at_least (2))\n \tpropagate_binfo_offsets\n \t  (binfo, size_diffop (size_zero_node, BINFO_OFFSET (binfo)));\n-      else if (warn_abi)\n-\twarning (0, \"offset of empty base %qT may not be ABI-compliant and may\"\n+      else\n+\twarning (OPT_Wabi,\n+                 \"offset of empty base %qT may not be ABI-compliant and may\"\n \t\t \"change in a future version of GCC\",\n \t\t BINFO_TYPE (binfo));\n     }\n@@ -3604,8 +3611,9 @@ build_base_field (record_layout_info rli, tree binfo,\n \t    {\n \t      if (abi_version_at_least (2))\n \t\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n-\t      else if (warn_abi)\n-\t\twarning (0, \"class %qT will be considered nearly empty in a \"\n+\t      else\n+\t\twarning (OPT_Wabi,\n+                         \"class %qT will be considered nearly empty in a \"\n \t\t\t \"future version of GCC\", t);\n \t    }\n \t}\n@@ -4349,7 +4357,8 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n \t\t\t       bitsize_unit_node),\n \t\t   BINFO_OFFSET (vbase))))\n-\t    warning (0, \"offset of virtual base %qT is not ABI-compliant and \"\n+\t    warning (OPT_Wabi,\n+                     \"offset of virtual base %qT is not ABI-compliant and \"\n \t\t     \"may change in a future version of GCC\",\n \t\t     basetype);\n \n@@ -4636,8 +4645,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\tpadding = DECL_SIZE (field);\n \t      else\n \t\t{\n-\t\t  if (warn_abi && TREE_CODE (t) == UNION_TYPE)\n-\t\t    warning (0, \"size assigned to %qT may not be \"\n+\t\t  if (TREE_CODE (t) == UNION_TYPE)\n+\t\t    warning (OPT_Wabi, \"size assigned to %qT may not be \"\n \t\t\t     \"ABI-compliant and may change in a future \"\n \t\t\t     \"version of GCC\",\n \t\t\t     t);\n@@ -4676,7 +4685,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t   && DECL_MODE (field) != TYPE_MODE (type))\n \t    /* Versions of G++ before G++ 3.4 did not reset the\n \t       DECL_MODE.  */\n-\t    warning (0, \"the offset of %qD may not be ABI-compliant and may \"\n+\t    warning (OPT_Wabi,\n+                     \"the offset of %qD may not be ABI-compliant and may \"\n \t\t     \"change in a future version of GCC\", field);\n \t}\n       else\n@@ -4704,7 +4714,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !integer_zerop (size_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n-\twarning (0, \"offset of %q+D is not ABI-compliant and may \"\n+\twarning (OPT_Wabi, \"offset of %q+D is not ABI-compliant and may \"\n \t\t \"change in a future version of GCC\", field);\n \n       /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n@@ -4713,7 +4723,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n \t\t\t\t  byte_position (field))\n \t  && contains_empty_class_p (TREE_TYPE (field)))\n-\twarning (0, \"%q+D contains empty classes which may cause base \"\n+\twarning (OPT_Wabi, \"%q+D contains empty classes which may cause base \"\n \t\t \"classes to be placed at different locations in a \"\n \t\t \"future version of GCC\", field);\n \n@@ -4772,7 +4782,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  TYPE_SIZE (base_t) = bitsize_zero_node;\n \t  TYPE_SIZE_UNIT (base_t) = size_zero_node;\n \t  if (warn_abi && !integer_zerop (rli_size_unit_so_far (rli)))\n-\t    warning (0, \"layout of classes derived from empty class %qT \"\n+\t    warning (OPT_Wabi,\n+                     \"layout of classes derived from empty class %qT \"\n \t\t     \"may change in a future version of GCC\",\n \t\t     t);\n \t}"}]}