{"sha": "85e693aa55c220da35b8b205eded6c4ef42093bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVlNjkzYWE1NWMyMjBkYTM1YjhiMjA1ZWRlZDZjNGVmNDIwOTNiYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-07-09T19:40:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-07-09T19:40:03Z"}, "message": "re PR tree-optimization/28632 (VRP should understand bitwise OR and AND)\n\n\tPR tree-optimization/28632\n\t* tree-vrp.c (zero_nonzero_bits_from_vr): New function.\n\t(extract_range_from_binary_expr): Further optimize\n\tBIT_AND_EXPR and BIT_IOR_EXPR.\n\n\t* gcc.dg/tree-ssa/vrp51.c: New test.\n\t* gcc.dg/tree-ssa/vrp52.c: New test.\n\nCo-Authored-By: Bernhard Reutner-Fischer <aldot@gcc.gnu.org>\nCo-Authored-By: Denys Vlasenko <dvlasenk@redhat.com>\n\nFrom-SVN: r162009", "tree": {"sha": "9ee1bad5b45f063327a09f35800a76d83344fa62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ee1bad5b45f063327a09f35800a76d83344fa62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85e693aa55c220da35b8b205eded6c4ef42093bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85e693aa55c220da35b8b205eded6c4ef42093bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85e693aa55c220da35b8b205eded6c4ef42093bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85e693aa55c220da35b8b205eded6c4ef42093bc/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02dea3ffc6e0f26963db8255ea003d0ede0918cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02dea3ffc6e0f26963db8255ea003d0ede0918cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02dea3ffc6e0f26963db8255ea003d0ede0918cc"}], "stats": {"total": 292, "additions": 198, "deletions": 94}, "files": [{"sha": "5ed0c14ec128415c8fb88831d35c61bf5e8b5345", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85e693aa55c220da35b8b205eded6c4ef42093bc", "patch": "@@ -1,3 +1,12 @@\n+2010-07-09  Jakub Jelinek  <jakub@redhat.com>\n+\t    Denys Vlasenko  <dvlasenk@redhat.com>\n+\t    Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+\n+\tPR tree-optimization/28632\n+\t* tree-vrp.c (zero_nonzero_bits_from_vr): New function.\n+\t(extract_range_from_binary_expr): Further optimize\n+\tBIT_AND_EXPR and BIT_IOR_EXPR.\n+\n 2010-07-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c (fold_or_predicates): New."}, {"sha": "13363df4a7c9dc4f81948873ce893ef53550ff06", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85e693aa55c220da35b8b205eded6c4ef42093bc", "patch": "@@ -1,3 +1,11 @@\n+2010-07-09  Jakub Jelinek  <jakub@redhat.com>\n+\t    Denys Vlasenko  <dvlasenk@redhat.com>\n+\t    Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+\n+\tPR tree-optimization/28632\n+\t* gcc.dg/tree-ssa/vrp51.c: New test.\n+\t* gcc.dg/tree-ssa/vrp52.c: New test.\n+\n 2010-07-09  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/abi/covariant6.C: New."}, {"sha": "66aa5ed6d6b69b25af7d02bb9685dabf964fc07d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp51.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp51.c?ref=85e693aa55c220da35b8b205eded6c4ef42093bc", "patch": "@@ -0,0 +1,58 @@\n+/* PR tree-optimization/28632 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vrp\" } */\n+\n+void\n+v4 (unsigned a, unsigned b)\n+{\n+  if (a < 0x1000) return;\n+  if (a > 0x1000) return;\n+  if (b < 0x0110) return;\n+  /* constant true.  */\n+  if (!__builtin_constant_p ((a|b) >= 0x01000))\n+    __asm__(\"bug.always.true\");\n+  /* VRP must not think that this is constant.  */\n+  if (__builtin_constant_p ((a|b) >= 0x10000))\n+    __asm__(\"bug.not.always.true\");\n+}\n+\n+void\n+u4 (unsigned n)\n+{\n+  if (n > 0x10111) return;\n+  if (n < 0x10101) return;\n+  /* always true.  */\n+  if (!__builtin_constant_p (n & 0x00100))\n+    __asm__(\"bug.always.true\");\n+  /* VRP must not think that this is constant true.  */\n+  if (__builtin_constant_p (n & 0x00001))\n+    __asm__(\"bug.not.always.true\");\n+  /* Out of range, always evaluates to constant false.  */\n+  if (!__builtin_constant_p (n & 0x01000))\n+    __asm__(\"bug.always.false\");\n+}\n+\n+void\n+u5 (unsigned n)\n+{\n+  struct s {unsigned exp:8;} x;\n+  x.exp = n;\n+  if (__builtin_constant_p(((n + 1) & 255) > 1))\n+    __asm__(\"bug.not.always.true\");\n+}\n+\n+void\n+v5 (int a, int b)\n+{\n+  if (a < 0x1000) return;\n+  if (a > 0x1000) return;\n+  if (b < 0x0110) return;\n+  /* constant true.  */\n+  if (!__builtin_constant_p ((a|b) >= 0x01000))\n+    __asm__(\"bug.always.true\");\n+  /* VRP must not think that this is always true.  */\n+  if (__builtin_constant_p ((a|b) >= 0x10000))\n+    __asm__(\"bug.not.always.true\");\n+}\n+\n+/* { dg-final { scan-assembler-not \"bug\\.\" } } */"}, {"sha": "7d530e246886b0e956c911fd8bb43844ea82c4e6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp52.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp52.c?ref=85e693aa55c220da35b8b205eded6c4ef42093bc", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int\n+foo (unsigned int i, unsigned int j)\n+{\n+  i &= 15;\n+  j &= 15;\n+  i += 1024;\n+  j += 2048;\n+  i |= j;\n+  return i >= 1024 + 2048;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Folding predicate i_\\[^\\n\\r\\]* to 1\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "c8555110a592f904cdd30e2631f1ea5a460c3941", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 107, "deletions": 94, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85e693aa55c220da35b8b205eded6c4ef42093bc/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=85e693aa55c220da35b8b205eded6c4ef42093bc", "patch": "@@ -2064,6 +2064,60 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n }\n \n \n+/* For range VR compute two double_int bitmasks.  In *MAY_BE_NONZERO\n+   bitmask if some bit is unset, it means for all numbers in the range\n+   the bit is 0, otherwise it might be 0 or 1.  In *MUST_BE_NONZERO\n+   bitmask if some bit is set, it means for all numbers in the range\n+   the bit is 1, otherwise it might be 0 or 1.  */\n+\n+static bool\n+zero_nonzero_bits_from_vr (value_range_t *vr, double_int *may_be_nonzero,\n+\t\t\t   double_int *must_be_nonzero)\n+{\n+  if (range_int_cst_p (vr))\n+    {\n+      if (range_int_cst_singleton_p (vr))\n+\t{\n+\t  *may_be_nonzero = tree_to_double_int (vr->min);\n+\t  *must_be_nonzero = *may_be_nonzero;\n+\t  return true;\n+\t}\n+      if (tree_int_cst_sgn (vr->min) >= 0)\n+\t{\n+\t  double_int dmin = tree_to_double_int (vr->min);\n+\t  double_int dmax = tree_to_double_int (vr->max);\n+\t  double_int xor_mask = double_int_xor (dmin, dmax);\n+\t  *may_be_nonzero = double_int_ior (dmin, dmax);\n+\t  *must_be_nonzero = double_int_and (dmin, dmax);\n+\t  if (xor_mask.high != 0)\n+\t    {\n+\t      unsigned HOST_WIDE_INT mask\n+\t\t= ((unsigned HOST_WIDE_INT) 1\n+\t\t   << floor_log2 (xor_mask.high)) - 1;\n+\t      may_be_nonzero->low = ALL_ONES;\n+\t      may_be_nonzero->high |= mask;\n+\t      must_be_nonzero->low = 0;\n+\t      must_be_nonzero->high &= ~mask;\n+\t    }\n+\t  else if (xor_mask.low != 0)\n+\t    {\n+\t      unsigned HOST_WIDE_INT mask\n+\t\t= ((unsigned HOST_WIDE_INT) 1\n+\t\t   << floor_log2 (xor_mask.low)) - 1;\n+\t      may_be_nonzero->low |= mask;\n+\t      must_be_nonzero->low &= ~mask;\n+\t    }\n+\t  return true;\n+\t}\n+    }\n+  may_be_nonzero->low = ALL_ONES;\n+  may_be_nonzero->high = ALL_ONES;\n+  must_be_nonzero->low = 0;\n+  must_be_nonzero->high = 0;\n+  return false;\n+}\n+\n+\n /* Extract range information from a binary expression EXPR based on\n    the ranges of each of its operands and the expression code.  */\n \n@@ -2569,120 +2623,79 @@ extract_range_from_binary_expr (value_range_t *vr,\n       min = vrp_int_const_binop (code, vr0.min, vr1.max);\n       max = vrp_int_const_binop (code, vr0.max, vr1.min);\n     }\n-  else if (code == BIT_AND_EXPR)\n+  else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n     {\n       bool vr0_int_cst_singleton_p, vr1_int_cst_singleton_p;\n+      bool int_cst_range0, int_cst_range1;\n+      double_int may_be_nonzero0, may_be_nonzero1;\n+      double_int must_be_nonzero0, must_be_nonzero1;\n \n       vr0_int_cst_singleton_p = range_int_cst_singleton_p (&vr0);\n       vr1_int_cst_singleton_p = range_int_cst_singleton_p (&vr1);\n+      int_cst_range0 = zero_nonzero_bits_from_vr (&vr0, &may_be_nonzero0,\n+\t\t\t\t\t\t  &must_be_nonzero0);\n+      int_cst_range1 = zero_nonzero_bits_from_vr (&vr1, &may_be_nonzero1,\n+\t\t\t\t\t\t  &must_be_nonzero1);\n \n+      type = VR_RANGE;\n       if (vr0_int_cst_singleton_p && vr1_int_cst_singleton_p)\n \tmin = max = int_const_binop (code, vr0.max, vr1.max, 0);\n-      else if (range_int_cst_p (&vr0)\n-\t       && range_int_cst_p (&vr1)\n-\t       && tree_int_cst_sgn (vr0.min) >= 0\n-\t       && tree_int_cst_sgn (vr1.min) >= 0)\n-\t{\n-\t  double_int vr0_mask = tree_to_double_int (vr0.min);\n-\t  double_int vr1_mask = tree_to_double_int (vr1.min);\n-\t  double_int maxd, diff;\n-\t  tree mask;\n-\n-\t  min = build_int_cst (expr_type, 0);\n-\t  /* Compute non-zero bits mask from both ranges.  */\n-\t  if (!vr0_int_cst_singleton_p)\n-\t    {\n-\t      maxd = tree_to_double_int (vr0.max);\n-\t      diff = double_int_sub (maxd, vr0_mask);\n-\t      if (diff.high)\n-\t\t{\n-\t\t  diff.low = ~(unsigned HOST_WIDE_INT)0;\n-\t\t  diff.high = ((HOST_WIDE_INT) 2\n-\t\t\t       << floor_log2 (diff.high)) - 1;\n-\t\t}\n-\t      else\n-\t\tdiff.low = ((HOST_WIDE_INT) 2 << floor_log2 (diff.low)) - 1;\n-\t      vr0_mask = double_int_ior (vr0_mask,\n-\t\t\t\t\t double_int_ior (maxd, diff));\n-\t    }\n-\t  if (!vr1_int_cst_singleton_p)\n-\t    {\n-\t      maxd = tree_to_double_int (vr1.max);\n-\t      diff = double_int_sub (maxd, vr1_mask);\n-\t      if (diff.high)\n-\t\t{\n-\t\t  diff.low = ~(unsigned HOST_WIDE_INT)0;\n-\t\t  diff.high = ((HOST_WIDE_INT) 2\n-\t\t\t       << floor_log2 (diff.high)) - 1;\n-\t\t}\n-\t      else\n-\t\tdiff.low = ((HOST_WIDE_INT) 2 << floor_log2 (diff.low)) - 1;\n-\t      vr1_mask = double_int_ior (vr1_mask,\n-\t\t\t\t\t double_int_ior (maxd, diff));\n-\t    }\n-\t  mask = double_int_to_tree (expr_type,\n-\t\t\t\t     double_int_and (vr0_mask, vr1_mask));\n-\t  max = vr0.max;\n-\t  if (tree_int_cst_lt (vr1.max, max))\n-\t    max = vr1.max;\n-\t  if (!TREE_OVERFLOW (mask)\n-\t      && tree_int_cst_lt (mask, max)\n-\t      && tree_int_cst_sgn (mask) >= 0)\n-\t    max = mask;\n-\t}\n-      else if (vr0_int_cst_singleton_p\n-\t       && tree_int_cst_sgn (vr0.max) >= 0)\n-\t{\n-\t  min = build_int_cst (expr_type, 0);\n-\t  max = vr0.max;\n-\t}\n-      else if (vr1_int_cst_singleton_p\n-\t       && tree_int_cst_sgn (vr1.max) >= 0)\n-\t{\n-\t  type = VR_RANGE;\n-\t  min = build_int_cst (expr_type, 0);\n-\t  max = vr1.max;\n-\t}\n-      else\n+      else if (!int_cst_range0 && !int_cst_range1)\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n-    }\n-  else if (code == BIT_IOR_EXPR)\n-    {\n-      if (range_int_cst_p (&vr0)\n-\t  && range_int_cst_p (&vr1)\n-\t  && tree_int_cst_sgn (vr0.min) >= 0\n-\t  && tree_int_cst_sgn (vr1.min) >= 0)\n+      else if (code == BIT_AND_EXPR)\n \t{\n-\t  double_int vr0_max = tree_to_double_int (vr0.max);\n-\t  double_int vr1_max = tree_to_double_int (vr1.max);\n-\t  double_int ior_max;\n-\n-\t  /* Set all bits to the right of the most significant one to 1.\n-\t     For example, [0, 4] | [4, 4] = [4, 7]. */\n-\t  ior_max.low = vr0_max.low | vr1_max.low;\n-\t  ior_max.high = vr0_max.high | vr1_max.high;\n-\t  if (ior_max.high != 0)\n+\t  min = double_int_to_tree (expr_type,\n+\t\t\t\t    double_int_and (must_be_nonzero0,\n+\t\t\t\t\t\t    must_be_nonzero1));\n+\t  max = double_int_to_tree (expr_type,\n+\t\t\t\t    double_int_and (may_be_nonzero0,\n+\t\t\t\t\t\t    may_be_nonzero1));\n+\t  if (TREE_OVERFLOW (min) || tree_int_cst_sgn (min) < 0)\n+\t    min = NULL_TREE;\n+\t  if (TREE_OVERFLOW (max) || tree_int_cst_sgn (max) < 0)\n+\t    max = NULL_TREE;\n+\t  if (int_cst_range0 && tree_int_cst_sgn (vr0.min) >= 0)\n+\t    {\n+\t      if (min == NULL_TREE)\n+\t\tmin = build_int_cst (expr_type, 0);\n+\t      if (max == NULL_TREE || tree_int_cst_lt (vr0.max, max))\n+\t\tmax = vr0.max;\n+\t    }\n+\t  if (int_cst_range1 && tree_int_cst_sgn (vr1.min) >= 0)\n \t    {\n-\t      ior_max.low = ~(unsigned HOST_WIDE_INT)0u;\n-\t      ior_max.high |= ((HOST_WIDE_INT) 1\n-\t\t\t       << floor_log2 (ior_max.high)) - 1;\n+\t      if (min == NULL_TREE)\n+\t\tmin = build_int_cst (expr_type, 0);\n+\t      if (max == NULL_TREE || tree_int_cst_lt (vr1.max, max))\n+\t\tmax = vr1.max;\n \t    }\n-\t  else if (ior_max.low != 0)\n-\t    ior_max.low |= ((unsigned HOST_WIDE_INT) 1u\n-\t\t\t    << floor_log2 (ior_max.low)) - 1;\n-\n-\t  /* Both of these endpoints are conservative.  */\n-          min = vrp_int_const_binop (MAX_EXPR, vr0.min, vr1.min);\n-          max = double_int_to_tree (expr_type, ior_max);\n \t}\n-      else\n+      else if (!int_cst_range0\n+\t       || !int_cst_range1\n+\t       || tree_int_cst_sgn (vr0.min) < 0\n+\t       || tree_int_cst_sgn (vr1.min) < 0)\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n+      else\n+\t{\n+\t  min = double_int_to_tree (expr_type,\n+\t\t\t\t    double_int_ior (must_be_nonzero0,\n+\t\t\t\t\t\t    must_be_nonzero1));\n+\t  max = double_int_to_tree (expr_type,\n+\t\t\t\t    double_int_ior (may_be_nonzero0,\n+\t\t\t\t\t\t    may_be_nonzero1));\n+\t  if (TREE_OVERFLOW (min) || tree_int_cst_sgn (min) < 0)\n+\t    min = vr0.min;\n+\t  else\n+\t    min = vrp_int_const_binop (MAX_EXPR, min, vr0.min);\n+\t  if (TREE_OVERFLOW (max) || tree_int_cst_sgn (max) < 0)\n+\t    max = NULL_TREE;\n+\t  min = vrp_int_const_binop (MAX_EXPR, min, vr1.min);\n+\t}\n     }\n   else\n     gcc_unreachable ();"}]}