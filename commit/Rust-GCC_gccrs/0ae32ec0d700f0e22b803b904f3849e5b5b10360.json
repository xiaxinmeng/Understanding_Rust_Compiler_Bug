{"sha": "0ae32ec0d700f0e22b803b904f3849e5b5b10360", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFlMzJlYzBkNzAwZjBlMjJiODAzYjkwNGYzODQ5ZTViNWIxMDM2MA==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2003-04-12T21:22:49Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2003-04-12T21:22:49Z"}, "message": "m68hc11.md (\"decrement_and_branch_until_zero\"): New pattern for dbcc/ibcc generation for 68HC12.\n\n\t* config/m68hc11/m68hc11.md (\"decrement_and_branch_until_zero\"): New\n\tpattern for dbcc/ibcc generation for 68HC12.\n\t(\"doloop_end\"): New pattern.\n\t(\"m68hc12_dbcc_dec_hi\"): New pattern for dbeq/dbne.\n\t(\"m68hc12_dbcc_inc_hi\"): New pattern for ibeq/ibne.\n\t(\"m68hc12_dbcc_dec_qi\"): New pattern.\n\t(\"m68hc12_dbcc_inc_qi\"): New pattern.\n\t(split): Add split for the above when we can't use dbcc/ibcc due to\n\treloading.\n\t(peephole2): Add peephole2 to generate the above when possible.\n\nFrom-SVN: r65527", "tree": {"sha": "2b567101eee78ff1ed4ed3568ac4f0bc050a8a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b567101eee78ff1ed4ed3568ac4f0bc050a8a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ae32ec0d700f0e22b803b904f3849e5b5b10360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae32ec0d700f0e22b803b904f3849e5b5b10360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae32ec0d700f0e22b803b904f3849e5b5b10360", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae32ec0d700f0e22b803b904f3849e5b5b10360/comments", "author": null, "committer": null, "parents": [{"sha": "4440f5b597e8f08058628b15a585c363179b5f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4440f5b597e8f08058628b15a585c363179b5f71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4440f5b597e8f08058628b15a585c363179b5f71"}], "stats": {"total": 273, "additions": 273, "deletions": 0}, "files": [{"sha": "4f73a65c7363ea4f53d02578619551288b4eae76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae32ec0d700f0e22b803b904f3849e5b5b10360/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae32ec0d700f0e22b803b904f3849e5b5b10360/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ae32ec0d700f0e22b803b904f3849e5b5b10360", "patch": "@@ -1,3 +1,16 @@\n+2003-04-12  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.md (\"decrement_and_branch_until_zero\"): New\n+\tpattern for dbcc/ibcc generation for 68HC12.\n+\t(\"doloop_end\"): New pattern.\n+\t(\"m68hc12_dbcc_dec_hi\"): New pattern for dbeq/dbne.\n+\t(\"m68hc12_dbcc_inc_hi\"): New pattern for ibeq/ibne.\n+\t(\"m68hc12_dbcc_dec_qi\"): New pattern.\n+\t(\"m68hc12_dbcc_inc_qi\"): New pattern.\n+\t(split): Add split for the above when we can't use dbcc/ibcc due to\n+\treloading.\n+\t(peephole2): Add peephole2 to generate the above when possible.\n+\n 2003-04-12  Stephane Carrez  <stcarrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.md (\"bitcmpqi\" split): No need to test the"}, {"sha": "1fb5a5e8ad8f61e2acafeaed435de8f15ba0c12c", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae32ec0d700f0e22b803b904f3849e5b5b10360/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae32ec0d700f0e22b803b904f3849e5b5b10360/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=0ae32ec0d700f0e22b803b904f3849e5b5b10360", "patch": "@@ -5936,6 +5936,210 @@\n               (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\")\n \n+;;--------------------------------------------------------------------\n+;;-  68HC12 Decrement/Increment and branch\n+;;--------------------------------------------------------------------\n+;; These patterns are used by loop optimization as well as peephole2\n+;; They must handle reloading themselves and the scratch register\n+;; is used for that.  Even if we accept memory operand, we must not\n+;; accept them on the predicate because it might create too many reloads.\n+;; (specially on HC12 due to its auto-incdec addressing modes).\n+;;\n+(define_expand \"decrement_and_branch_until_zero\"\n+  [(parallel [(set (pc)\n+\t\t   (if_then_else\n+\t\t    (ne (plus:HI (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t\t\t (const_int 0))\n+\t\t\t(const_int 1))\n+\t\t    (label_ref (match_operand 1 \"\" \"\"))\n+\t\t    (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:HI (match_dup 0)\n+\t\t\t    (const_int -1)))\n+\t      (clobber (match_scratch:HI 2 \"\"))])]\n+  \"TARGET_M6812\"\n+  \"\")\n+\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))\t; max iterations\n+   (use (match_operand 3 \"\" \"\"))\t; loop level\n+   (use (match_operand 4 \"\" \"\"))]\t; label\n+  \"TARGET_M6812\"\n+  \"\n+{\n+  /* Reject non-constant loops as it generates bigger code due to\n+     the handling of the loop register.  We can do better by using\n+     the peephole2 dbcc/ibcc patterns.  */\n+  if (INTVAL (operands[1]) == 0)\n+    {\n+      FAIL;\n+    }\n+  if (GET_MODE (operands[0]) == HImode)\n+    {\n+      emit_jump_insn (gen_m68hc12_dbcc_dec_hi (operands[0],\n+\t\t\t\t\t       gen_rtx (NE, HImode),\n+\t\t\t\t\t       operands[4]));\n+      DONE;\n+    }\n+  if (GET_MODE (operands[0]) == QImode)\n+    {\n+      emit_jump_insn (gen_m68hc12_dbcc_dec_qi (operands[0],\n+\t\t\t\t\t       gen_rtx (NE, QImode),\n+\t\t\t\t\t       operands[4]));\n+      DONE;\n+    }\n+\n+  FAIL;\n+}\")\n+\n+;; Decrement-and-branch insns.\n+(define_insn \"m68hc12_dbcc_dec_hi\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 1 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:HI 0 \"register_operand\" \"+dxy,m*u*z\")\n+\t      (const_int 1)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0) (const_int -1)))\n+   (clobber (match_scratch:HI 3 \"=X,dxy\"))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  if (!H_REG_P (operands[0]))\n+    return \\\"#\\\";\n+\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \\\"dbeq\\\\t%0,%l2\\\";\n+  else\n+    return \\\"dbne\\\\t%0,%l2\\\";\n+}\")\n+\n+;; Decrement-and-branch insns.\n+(define_insn \"m68hc12_dbcc_inc_hi\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 1 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:HI 0 \"register_operand\" \"+dxy,m*u*z\")\n+\t      (const_int -1)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0) (const_int 1)))\n+   (clobber (match_scratch:HI 3 \"=X,dxy\"))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  if (!H_REG_P (operands[0]))\n+    return \\\"#\\\";\n+\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \\\"ibeq\\\\t%0,%l2\\\";\n+  else\n+    return \\\"ibeq\\\\t%0,%l2\\\";\n+}\")\n+\n+;; Decrement-and-branch (QImode).\n+(define_insn \"m68hc12_dbcc_dec_qi\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 1 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:QI 0 \"register_operand\" \"+d,m*u*A\")\n+\t      (const_int 1)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:QI (match_dup 0) (const_int -1)))\n+   (clobber (match_scratch:QI 3 \"=X,d\"))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  if (!D_REG_P (operands[0]))\n+    return \\\"#\\\";\n+\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \\\"dbeq\\\\tb,%l2\\\";\n+  else\n+    return \\\"dbne\\\\tb,%l2\\\";\n+}\")\n+\n+;; Increment-and-branch (QImode).\n+(define_insn \"m68hc12_dbcc_inc_qi\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 1 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:QI 0 \"register_operand\" \"+d,m*u*A\")\n+\t      (const_int -1)])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:QI (match_dup 0) (const_int 1)))\n+   (clobber (match_scratch:QI 3 \"=X,d\"))]\n+  \"TARGET_M6812\"\n+  \"*\n+{\n+  if (!D_REG_P (operands[0]))\n+    return \\\"#\\\";\n+\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == EQ)\n+    return \\\"ibeq\\\\tb,%l2\\\";\n+  else\n+    return \\\"ibeq\\\\tb,%l2\\\";\n+}\")\n+\n+;; Split the above to handle the case where operand 0 is in memory\n+;; (a register that couldn't get a hard register)\n+(define_split\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 3 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:HI 0 \"general_operand\" \"\")\n+\t      (match_operand:HI 1 \"const_int_operand\" \"\")])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0) (match_operand 2 \"const_int_operand\" \"\")))\n+   (clobber (match_operand:HI 5 \"hard_reg_operand\" \"\"))]\n+  \"TARGET_M6812 && reload_completed\"\n+  [(set (match_dup 5) (match_dup 0))\n+   (set (match_dup 5) (plus:HI (match_dup 5) (match_dup 2)))\n+   (set (match_dup 0) (match_dup 5))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3\n+\t\t\t    [(match_dup 5) (const_int 0)])\n+\t\t      (label_ref (match_dup 4)) (pc)))]\n+  \"\")\n+\n+;; Split the above to handle the case where operand 0 is in memory\n+;; (a register that couldn't get a hard register)\n+(define_split\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 3 \"m68hc11_eq_compare_operator\"\n+\t     [(match_operand:QI 0 \"general_operand\" \"\")\n+\t      (match_operand:QI 1 \"const_int_operand\" \"\")])\n+\t (label_ref (match_operand 4 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:QI (match_dup 0) (match_operand 2 \"const_int_operand\" \"\")))\n+   (clobber (match_operand:QI 5 \"hard_reg_operand\" \"\"))]\n+  \"TARGET_M6812 && reload_completed\"\n+  [(set (match_dup 5) (match_dup 0))\n+   (set (match_dup 5) (plus:QI (match_dup 5) (match_dup 2)))\n+   (set (match_dup 0) (match_dup 5))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 3\n+\t\t\t    [(match_dup 5) (const_int 0)])\n+\t\t      (label_ref (match_dup 4)) (pc)))]\n+  \"\")\n+\n ;;--------------------------------------------------------------------\n ;;-  Jumps and transfers\n ;;--------------------------------------------------------------------\n@@ -6665,6 +6869,62 @@\n ;;- Peepholes\n ;;--------------------------------------------------------------------\n \n+;;--------------------------------------------------------------------\n+;;- 68HC12 dbcc/ibcc peepholes\n+;;--------------------------------------------------------------------\n+;;\n+;; Replace: \"addd #-1; bne L1\" into \"dbne d,L1\"\n+;;          \"addd #-1; beq L1\" into \"dbeq d,L1\"\n+;;          \"addd #1; bne L1\" into \"ibne d,L1\"\n+;;          \"addd #1; beq L1\" into \"ibeq d,L1\"\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (match_operator 2 \"m68hc11_eq_compare_operator\"\n+\t\t         [(match_dup 0)\n+\t\t\t  (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\")) (pc)))]\n+  \"TARGET_M6812 && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\"\n+  [(parallel [\n+      (set (pc) (if_then_else (match_op_dup 2 [(match_dup 0) (match_dup 5)])\n+\t\t\t      (label_ref (match_dup 3)) (pc)))\n+      (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))\n+      (clobber (match_dup 4))])]\n+  \"operands[4] = gen_rtx_SCRATCH(HImode);\n+   operands[5] = GEN_INT (-INTVAL (operands[1]));\")\n+\n+\n+;;\n+;; Replace: \"addb #-1; bne L1\" into \"dbne b,L1\"\n+;;          \"addb #-1; beq L1\" into \"dbeq b,L1\"\n+;;\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"hard_reg_operand\" \"\")\n+\t(plus:QI (match_dup 0)\n+\t         (match_operand:QI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+        (if_then_else (match_operator 2 \"m68hc11_eq_compare_operator\"\n+\t\t         [(match_dup 0)\n+\t\t\t  (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\")) (pc)))]\n+  \"TARGET_M6812 && D_REG_P (operands[0])\n+   && (INTVAL (operands[1]) == 1 || INTVAL (operands[1]) == -1)\"\n+  [(parallel [\n+      (set (pc) (if_then_else (match_op_dup 2 [(match_dup 0) (match_dup 5)])\n+\t\t\t      (label_ref (match_dup 3)) (pc)))\n+      (set (match_dup 0) (plus:QI (match_dup 0) (match_dup 1)))\n+      (clobber (match_dup 4))])]\n+  \"operands[4] = gen_rtx_SCRATCH(QImode);\n+   operands[5] = GEN_INT (-INTVAL (operands[1]));\")\n+\n+\n+;;--------------------------------------------------------------------\n+;;- Move peephole2\n+;;--------------------------------------------------------------------\n+\n ;;\n ;; Replace \"leas 2,sp\" with a \"pulx\" or a \"puly\".\n ;; On 68HC12, this is one cycle slower but one byte smaller."}]}