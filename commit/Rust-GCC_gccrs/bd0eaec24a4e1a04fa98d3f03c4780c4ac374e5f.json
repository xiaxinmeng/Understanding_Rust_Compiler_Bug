{"sha": "bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQwZWFlYzI0YTRlMWEwNGZhOThkM2YwM2M0NzgwYzRhYzM3NGU1Zg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-11T06:38:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-11T06:38:15Z"}, "message": "basic-block.h (compute_available): Returns a void now.\n\n        * basic-block.h (compute_available): Returns a void now.\n        * gcse.c (one_classic_gcse_pass): Do not expect compute_available\n        to return a value anymore.\n        * lcm.c (compute_available, compute_antinout_edge): Revamp to use\n        worklists.  Fix boundary cases. Compute maximal solutions.\n        (compute_laterin, compute_nearerout): Similarly.\n\nFrom-SVN: r30482", "tree": {"sha": "6185ebb16ca81e902c67605443eefce90ab097fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6185ebb16ca81e902c67605443eefce90ab097fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/comments", "author": null, "committer": null, "parents": [{"sha": "2a2ea744a9ff0d68d57fed4fbd93a5ee39d261ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2ea744a9ff0d68d57fed4fbd93a5ee39d261ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2ea744a9ff0d68d57fed4fbd93a5ee39d261ce"}], "stats": {"total": 478, "additions": 289, "deletions": 189}, "files": [{"sha": "d22e0683432c4465eb8c73b6a11a83138b80889c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "patch": "@@ -4,6 +4,13 @@ Wed Nov 10 21:24:19 1999  Jason Eckhardt  <jle@cygnus.com>\n \n Wed Nov 10 15:56:16 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* basic-block.h (compute_available): Returns a void now.\n+\t* gcse.c (one_classic_gcse_pass): Do not expect compute_available\n+\tto return a value anymore.\n+\t* lcm.c (compute_available, compute_antinout_edge): Revamp to use\n+\tworklists.  Fix boundary cases. Compute maximal solutions.\n+\t(compute_laterin, compute_nearerout): Similarly.\n+\n         * dwarf2out.c (add_AT_location_description): Allow\n         (mem (plus (pseudo) (...)) too.\n "}, {"sha": "c5ea81c36b81c4ea9a5624d8d007687e6b3c0518", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "patch": "@@ -328,7 +328,7 @@ extern struct edge_list *pre_edge_rev_lcm PROTO ((FILE *, int, sbitmap *,\n \t\t\t\t\t\t  sbitmap *, sbitmap *, \n \t\t\t\t\t\t  sbitmap *, sbitmap **, \n \t\t\t\t\t\t  sbitmap **));\n-extern int compute_available\t\tPROTO ((sbitmap *, sbitmap *,\n+extern void compute_available\t\tPROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t\tsbitmap *, sbitmap *));\n \n /* In emit-rtl.c.  */"}, {"sha": "7a01902e517b0fe6f802ceb7df1422bdeb1ae183", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "patch": "@@ -3404,15 +3404,12 @@ one_classic_gcse_pass (pass)\n \t\t     expr_hash_table_size, n_exprs);\n   if (n_exprs > 0)\n     {\n-      int passes;\n       compute_kill_rd ();\n       compute_rd ();\n       alloc_avail_expr_mem (n_basic_blocks, n_exprs);\n       compute_ae_gen ();\n       compute_ae_kill (ae_gen, ae_kill);\n-      passes = compute_available (ae_gen, ae_kill, ae_out, ae_in);\n-      if (gcse_file)\n-\tfprintf (gcse_file, \"avail expr computation: %d passes\\n\", passes);\n+      compute_available (ae_gen, ae_kill, ae_out, ae_in);\n       changed = classic_gcse ();\n       free_avail_expr_mem ();\n     }"}, {"sha": "4df804060aff5e8f2a08b236420b3c8aea8548fd", "filename": "gcc/lcm.c", "status": "modified", "additions": 280, "deletions": 184, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=bd0eaec24a4e1a04fa98d3f03c4780c4ac374e5f", "patch": "@@ -68,8 +68,8 @@ static void compute_antinout_edge  PROTO ((sbitmap *, sbitmap *,\n static void compute_earliest  PROTO((struct edge_list *, int, sbitmap *,\n \t\t\t\t     sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t     sbitmap *));\n-static void compute_laterin  PROTO((struct edge_list *, int, sbitmap *,\n-\t\t\t\t     sbitmap *, sbitmap *, sbitmap *));\n+static void compute_laterin  PROTO((struct edge_list *, sbitmap *,\n+\t\t\t\t    sbitmap *, sbitmap *, sbitmap *));\n static void compute_insert_delete  PROTO ((struct edge_list *edge_list,\n \t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *));\n@@ -78,7 +78,7 @@ static void compute_insert_delete  PROTO ((struct edge_list *edge_list,\n static void compute_farthest\tPROTO  ((struct edge_list *, int, sbitmap *,\n \t\t\t\t\t sbitmap *, sbitmap*, sbitmap *,\n \t\t\t\t\t sbitmap *));\n-static void compute_nearerout\tPROTO((struct edge_list *, int, sbitmap *,\n+static void compute_nearerout\tPROTO((struct edge_list *, sbitmap *,\n \t\t\t\t       sbitmap *, sbitmap *, sbitmap *));\n static void compute_rev_insert_delete  PROTO ((struct edge_list *edge_list,\n \t\t\t\t\t       sbitmap *, sbitmap *, sbitmap *,\n@@ -98,70 +98,69 @@ compute_antinout_edge (antloc, transp, antin, antout)\n      sbitmap *antin;\n      sbitmap *antout;\n {\n-  int i, changed, passes;\n-  sbitmap old_changed, new_changed;\n+  int bb;\n   edge e;\n+  basic_block *worklist, *tos;\n \n-  sbitmap_vector_zero (antout, n_basic_blocks);\n-  sbitmap_vector_ones (antin, n_basic_blocks);\n+  /* Allocate a worklist array/queue.  Entries are only added to the\n+     list if they were not already on the list.  So the size is\n+     bounded by the number of basic blocks.  */\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n+\t\t\t\t\t    * n_basic_blocks);\n \n-  old_changed = sbitmap_alloc (n_basic_blocks);\n-  new_changed = sbitmap_alloc (n_basic_blocks);\n-  sbitmap_ones (old_changed);\n+  /* We want a maximal solution, so make an optimistic initialization of\n+     ANTIN.  */\n+  sbitmap_vector_ones (antin, n_basic_blocks);\n \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  /* Put the predecessors of the exit block on the worklist.  */\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n     {\n-      changed = 0;\n-      sbitmap_zero (new_changed);\n-\n-      /* We scan the blocks in the reverse order to speed up\n-\t the convergence.  */\n-      for (i = n_basic_blocks - 1; i >= 0; i--)\n-\t{\n-\t  basic_block bb = BASIC_BLOCK (i);\n-\t  /* If none of the successors of this block have changed,\n-\t     then this block is not going to change.  */\n-\t  for (e = bb->succ ; e; e = e->succ_next)\n-\t    {\n-\t      if (e->dest == EXIT_BLOCK_PTR)\n-\t\tbreak;\n+      *tos++ = e->src;\n \n-\t      if (TEST_BIT (old_changed, e->dest->index)\n-\t\t  || TEST_BIT (new_changed, e->dest->index))\n-\t\tbreak;\n-\t    }\n+      /* We use the block's aux field to track blocks which are in\n+\t the worklist; we also use it to quickly determine which blocks\n+\t are predecessors of the EXIT block.  */\n+      e->src->aux = EXIT_BLOCK_PTR;\n+    }\n \n-\t  if (!e)\n-\t    continue;\n+  /* Iterate until the worklist is empty.  */\n+  while (tos != worklist)\n+    {\n+      /* Take the first entry off the worklist.  */\n+      basic_block b = *--tos;\n+      bb = b->index;\n \n-          /* If an Exit blocks is the ONLY successor, its has a zero ANTIN, \n-\t     which is the opposite of the default definition for an \n-\t     intersection of succs definition.  */\n-\t  if (e->dest == EXIT_BLOCK_PTR && e->succ_next == NULL \n-\t      && e->src->succ == e)\n-\t    sbitmap_zero (antout[bb->index]);\n-\t  else\n-\t    {\n-\t      sbitmap_intersection_of_succs (antout[bb->index],\n-\t\t\t\t\t     antin, \n-\t\t\t\t\t     bb->index);\n-\t    }\n+      if (b->aux == EXIT_BLOCK_PTR)\n+\t{\n+\t  /* Do not clear the aux field for blocks which are\n+\t     predecessors of the EXIT block.  That way we never\n+\t     add then to the worklist again.  */\n+\t  sbitmap_zero (antout[bb]);\n+\t}\n+      else\n+\t{\n+\t  /* Clear the aux field of this block so that it can be added to\n+\t     the worklist again if necessary.  */\n+\t  b->aux = NULL;\n+\t  sbitmap_intersection_of_succs (antout[bb], antin, bb);\n+\t}\n \n- \t  if (sbitmap_a_or_b_and_c (antin[bb->index], antloc[bb->index],\n-\t\t\t\t    transp[bb->index], antout[bb->index]))\n+      if (sbitmap_a_or_b_and_c (antin[bb], antloc[bb], transp[bb], antout[bb]))\n+\t{\n+\t  /* If the in state of this block changed, then we need\n+\t     to add the predecessors of this block to the worklist\n+\t     if they are not already on the worklist.  */\n+          for (e = b->pred; e; e = e->pred_next)\n \t    {\n-\t      changed = 1;\n-\t      SET_BIT (new_changed, bb->index);\n+\t      if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n+\t        {\n+\t          *tos++ = e->src;\n+\t          e->src->aux = e;\n+\t        }\n \t    }\n \t}\n-      sbitmap_copy (old_changed, new_changed);\n-      passes++;\n     }\n-\n-  free (old_changed);\n-  free (new_changed);\n+  free (tos);\n }\n \n /* Compute the earliest vector for edge based lcm.  */\n@@ -206,76 +205,119 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n   free (difference);\n }\n \n-/* Compute later and laterin vectors for edge based lcm.  */\n+/* later(p,s) is dependent on the calculation of laterin(p).\n+   laterin(p) is dependent on the calculation of later(p2,p).\n+\n+     laterin(ENTRY) is defined as all 0's\n+     later(ENTRY, succs(ENTRY)) are defined using laterin(ENTRY)\n+     laterin(succs(ENTRY)) is defined by later(ENTRY, succs(ENTRY)).\n+\n+   If we progress in this manner, starting with all basic blocks\n+   in the work list, anytime we change later(bb), we need to add\n+   succs(bb) to the worklist if they are not already on the worklist.\n+\n+   Boundary conditions:\n+\n+     We prime the worklist all the normal basic blocks.   The ENTRY block can\n+     never be added to the worklist since it is never the successor of any\n+     block.  We explicitly prevent the EXIT block from being added to the\n+     worklist.\n+\n+     We optimistically initialize LATER.  That is the only time this routine\n+     will compute LATER for an edge out of the entry block since the entry\n+     block is never on the worklist.  Thus, LATERIN is neither used nor\n+     computed for the ENTRY block.\n+\n+     Since the EXIT block is never added to the worklist, we will neither\n+     use nor compute LATERIN for the exit block.  Edges which reach the\n+     EXIT block are handled in the normal fashion inside the loop.  However,\n+     the insertion/deletion computation needs LATERIN(EXIT), so we have\n+     to compute it.  */\n+ \n static void\n-compute_laterin (edge_list, n_exprs,\n-\t\t earliest, antloc, later, laterin)\n+compute_laterin (edge_list, earliest, antloc, later, laterin)\n      struct edge_list *edge_list;\n-     int n_exprs;\n      sbitmap *earliest, *antloc, *later, *laterin;\n {\n-  sbitmap difference;\n-  int x, num_edges; \n-  basic_block pred, succ;\n-  int done = 0;\n+  int bb, num_edges, i;\n+  edge e;\n+  basic_block *worklist, *tos;\n \n   num_edges = NUM_EDGES (edge_list);\n \n-  /* Laterin has an extra block allocated for the exit block.  */\n-  sbitmap_vector_ones (laterin, n_basic_blocks + 1);\n-  sbitmap_vector_zero (later, num_edges);\n-\n-  /* Initialize laterin to the intersection of EARLIEST for all edges\n-     from predecessors to this block. */\n-\n-  for (x = 0; x < num_edges; x++)\n+  /* Allocate a worklist array/queue.  Entries are only added to the\n+     list if they were not already on the list.  So the size is\n+     bounded by the number of basic blocks.  */\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n+\t\t\t\t\t    * (n_basic_blocks + 1));\n+\n+  /* Initialize a mapping from each edge to its index.  */\n+  for (i = 0; i < num_edges; i++)\n+    INDEX_EDGE (edge_list, i)->aux = (void *)i;\n+\n+  /* We want a maximal solution, so initially consider LATER true for\n+     all edges.  This allows propagation through a loop since the incoming\n+     loop edge will have LATER set, so if all the other incoming edges\n+     to the loop are set, then LATERIN will be set for the head of the\n+     loop.\n+\n+     If the optimistic setting of LATER on that edge was incorrect (for\n+     example the expression is ANTLOC in a block within the loop) then\n+     this algorithm will detect it when we process the block at the head\n+     of the optimistic edge.  That will requeue the affected blocks.  */\n+  sbitmap_vector_ones (later, num_edges);\n+\n+  /* Add all the blocks to the worklist.  This prevents an early exit from\n+     the loop given our optimistic initialization of LATER above.  */\n+  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n     {\n-      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n-      if (succ != EXIT_BLOCK_PTR)\n-\tsbitmap_a_and_b (laterin[succ->index], laterin[succ->index], \n-\t\t\t earliest[x]);\n-      /* We already know the correct value of later for edges from\n-         the entry node, so set it now.  */\n-      if (pred == ENTRY_BLOCK_PTR)\n-\tsbitmap_copy (later[x], earliest[x]);\n+      basic_block b = BASIC_BLOCK (bb);\n+      *tos++ = b;\n+      b->aux = b;\n     }\n \n-  difference = sbitmap_alloc (n_exprs);\n-\n-  while (!done)\n+  /* Iterate until the worklist is empty.  */\n+  while (tos != worklist)\n     {\n-      done = 1;\n-      for (x = 0; x < num_edges; x++)\n+      /* Take the first entry off the worklist.  */\n+      basic_block b = *--tos;\n+      b->aux = NULL;\n+\n+      /* Compute the intersection of LATERIN for each incoming edge to B.  */\n+      bb = b->index;\n+      sbitmap_ones (laterin[bb]);\n+      for (e = b->pred; e != NULL; e = e->pred_next)\n+\tsbitmap_a_and_b (laterin[bb], laterin[bb], later[(int)e->aux]);\n+\n+      /* Calculate LATER for all outgoing edges.  */\n+      for (e = b->succ; e != NULL; e = e->succ_next)\n \t{\n-          pred = INDEX_EDGE_PRED_BB (edge_list, x);\n-\t  if (pred != ENTRY_BLOCK_PTR)\n+\t  if (sbitmap_union_of_diff (later[(int)e->aux],\n+\t\t\t\t     earliest[(int)e->aux],\n+\t\t\t\t     laterin[e->src->index],\n+\t\t\t\t     antloc[e->src->index]))\n \t    {\n-\t      sbitmap_difference (difference, laterin[pred->index], \n-\t      \t\t\t  antloc[pred->index]);\n-\t      if (sbitmap_a_or_b (later[x], difference, earliest[x]))\n-\t\tdone = 0;\n+\t      /* If LATER for an outgoing edge was changed, then we need\n+\t\t to add the target of the outgoing edge to the worklist.  */\n+\t      if (e->dest != EXIT_BLOCK_PTR && e->dest->aux == 0)\n+\t\t{\n+\t\t  *tos++ = e->dest;\n+\t\t  e->dest->aux = e;\n+\t\t}\n \t    }\n-\t}\n-      if (done)\n-        break;\n-\n-      sbitmap_vector_ones (laterin, n_basic_blocks);\n-\n-      for (x = 0; x < num_edges; x++)\n-\t{\n-\t  succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-\t  if (succ != EXIT_BLOCK_PTR)\n-\t    sbitmap_a_and_b (laterin[succ->index], laterin[succ->index], \n-\t    \t\t     later[x]);\n-\t  else\n-\t    /* We allocated an extra block for the exit node.  */\n-\t    sbitmap_a_and_b (laterin[n_basic_blocks], laterin[n_basic_blocks], \n-\t    \t\t     later[x]);\n-\t}\n+        }\n     }\n \n-  free (difference);\n+  /* Computation of insertion and deletion points requires computing LATERIN\n+     for the EXIT block.  We allocated an extra entry in the LATERIN array\n+     for just this purpose.  */\n+  sbitmap_ones (laterin[n_basic_blocks]);\n+  for (e = EXIT_BLOCK_PTR->pred; e != NULL; e = e->pred_next)\n+    sbitmap_a_and_b (laterin[n_basic_blocks],\n+\t\t     laterin[n_basic_blocks],\n+\t\t     later[(int)e->aux]);\n+\n+  free (tos);\n }\n \n /* Compute the insertion and deletion points for edge based LCM.  */\n@@ -343,6 +385,7 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n   compute_available (avloc, kill, avout, avin);\n \n+\n   free (avin);\n \n   /* Compute global anticipatability.  */\n@@ -374,7 +417,8 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   later = sbitmap_vector_alloc (num_edges, n_exprs);\n   /* Allocate an extra element for the exit block in the laterin vector.  */\n   laterin = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n-  compute_laterin (edge_list, n_exprs, earliest, antloc, later, laterin);\n+  compute_laterin (edge_list, earliest, antloc, later, laterin);\n+\n \n #ifdef LCM_DEBUG_INFO\n   if (file)\n@@ -406,32 +450,75 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n \n /* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.\n    Return the number of passes we performed to iterate to a solution.  */\n-int\n+void\n compute_available (avloc, kill, avout, avin)\n      sbitmap *avloc, *kill, *avout, *avin;  \n {\n-  int bb, changed, passes;\n+  int bb;\n+  edge e;\n+  basic_block *worklist, *tos;\n \n-  sbitmap_zero (avin[0]);\n-  sbitmap_copy (avout[0] /*dst*/, avloc[0] /*src*/);\n+  /* Allocate a worklist array/queue.  Entries are only added to the\n+     list if they were not already on the list.  So the size is\n+     bounded by the number of basic blocks.  */\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n+\t\t\t\t\t    * n_basic_blocks);\n \n-  for (bb = 1; bb < n_basic_blocks; bb++)\n-    sbitmap_not (avout[bb], kill[bb]);\n-    \n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n+  /* We want a maximal solution.  */\n+  sbitmap_vector_ones (avout, n_basic_blocks);\n+\n+  /* Put the successors of the entry block on the worklist.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     {\n-      changed = 0;\n-      for (bb = 1; bb < n_basic_blocks; bb++)\n-        {\n-          sbitmap_intersection_of_preds (avin[bb], avout, bb);\n-          changed |= sbitmap_union_of_diff (avout[bb], avloc[bb],\n-                                            avin[bb], kill[bb]);\n-        }\n-      passes++;\n+      *tos++ = e->dest;\n+\n+      /* We use the block's aux field to track blocks which are in\n+\t the worklist; we also use it to quickly determine which blocks\n+\t are successors of the ENTRY block.  */\n+      e->dest->aux = ENTRY_BLOCK_PTR;\n     }\n-  return passes;\n+\n+  /* Iterate until the worklist is empty.  */\n+  while (tos != worklist)\n+    {\n+      /* Take the first entry off the worklist.  */\n+      basic_block b = *--tos;\n+      bb = b->index;\n+\n+      /* If one of the predecessor blocks is the ENTRY block, then the\n+\t intersection of avouts is the null set.  We can identify such blocks\n+\t by the special value in the AUX field in the block structure.  */\n+      if (b->aux == ENTRY_BLOCK_PTR)\n+\t{\n+\t  /* Do not clear the aux field for blocks which are\n+\t     successors of the ENTRY block.  That way we never\n+\t     add then to the worklist again.  */\n+\t  sbitmap_zero (avin[bb]);\n+\t}\n+      else\n+\t{\n+\t  /* Clear the aux field of this block so that it can be added to\n+\t     the worklist again if necessary.  */\n+\t  b->aux = NULL;\n+\t  sbitmap_intersection_of_preds (avin[bb], avout, bb);\n+\t}\n+\n+      if (sbitmap_union_of_diff (avout[bb], avloc[bb], avin[bb], kill[bb]))\n+\t{\n+\t  /* If the out state of this block changed, then we need\n+\t     to add the successors of this block to the worklist\n+\t     if they are not already on the worklist.  */\n+          for (e = b->succ; e; e = e->succ_next)\n+\t    {\n+\t      if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n+\t        {\n+\t          *tos++ = e->dest;\n+\t          e->dest->aux = e;\n+\t        }\n+\t    }\n+\t}\n+    }\n+  free (tos);\n }\n \n /* Compute the farthest vector for edge based lcm.  */\n@@ -477,78 +564,87 @@ compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n   free (difference);\n }\n \n-/* Compute nearer and nearerout vectors for edge based lcm.  */\n+/* Compute nearer and nearerout vectors for edge based lcm.\n+\n+   This is the mirror of compute_laterin, additional comments on the\n+   implementation can be found before compute_laterin.  */\n+\n static void\n-compute_nearerout (edge_list, n_exprs,\n-\t\t   farthest, st_avloc, nearer, nearerout)\n+compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n      struct edge_list *edge_list;\n-     int n_exprs;\n      sbitmap *farthest, *st_avloc, *nearer, *nearerout;\n {\n-  sbitmap difference;\n-  int x, num_edges; \n-  basic_block pred, succ;\n-  int done = 0;\n+  int bb, num_edges, i;\n+  edge e;\n+  basic_block *worklist, *tos;\n \n   num_edges = NUM_EDGES (edge_list);\n \n-  /* nearout has an extra block allocated for the entry block.  */\n-  sbitmap_vector_ones (nearerout, n_basic_blocks + 1);\n-  sbitmap_vector_zero (nearer, num_edges);\n+  /* Allocate a worklist array/queue.  Entries are only added to the\n+     list if they were not already on the list.  So the size is\n+     bounded by the number of basic blocks.  */\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n+\t\t\t\t\t    * (n_basic_blocks + 1));\n \n-  /* Initialize nearerout to the intersection of FARTHEST for all edges\n-     from predecessors to this block. */\n+  /* Initialize NEARER for each edge and build a mapping from an edge to\n+     its index.  */\n+  for (i = 0; i < num_edges; i++)\n+    INDEX_EDGE (edge_list, i)->aux = (void *)i;\n \n-  for (x = 0; x < num_edges; x++)\n+  /* We want a maximal solution.  */\n+  sbitmap_vector_ones (nearer, num_edges);\n+\n+  /* Add all the blocks to the worklist.  This prevents an early exit\n+     from the loop given our optimistic initialization of NEARER.  */\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n-      succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-      pred = INDEX_EDGE_PRED_BB (edge_list, x);\n-      if (pred != ENTRY_BLOCK_PTR)\n-        {\n-\t  sbitmap_a_and_b (nearerout[pred->index], nearerout[pred->index], \n-\t\t\t   farthest[x]);\n-\t}\n-      /* We already know the correct value of nearer for edges to \n-         the exit node.  */\n-      if (succ == EXIT_BLOCK_PTR)\n-\tsbitmap_copy (nearer[x], farthest[x]);\n+      basic_block b = BASIC_BLOCK (bb);\n+      *tos++ = b;\n+      b->aux = b;\n     }\n-\n-  difference = sbitmap_alloc (n_exprs);\n-\n-  while (!done)\n+ \n+  /* Iterate until the worklist is empty.  */\n+  while (tos != worklist)\n     {\n-      done = 1;\n-      for (x = 0; x < num_edges; x++)\n+      /* Take the first entry off the worklist.  */\n+      basic_block b = *--tos;\n+      b->aux = NULL;\n+\n+      /* Compute the intersection of NEARER for each outgoing edge from B.  */\n+      bb = b->index;\n+      sbitmap_ones (nearerout[bb]);\n+      for (e = b->succ; e != NULL; e = e->succ_next)\n+\tsbitmap_a_and_b (nearerout[bb], nearerout[bb], nearer[(int)e->aux]);\n+\n+      /* Calculate NEARER for all incoming edges.  */\n+      for (e = b->pred; e != NULL; e = e->pred_next)\n \t{\n-          succ = INDEX_EDGE_SUCC_BB (edge_list, x);\n-\t  if (succ != EXIT_BLOCK_PTR)\n+\t  if (sbitmap_union_of_diff (nearer[(int)e->aux],\n+\t\t\t\t     farthest[(int)e->aux],\n+\t\t\t\t     nearerout[e->dest->index],\n+\t\t\t\t     st_avloc[e->dest->index]))\n \t    {\n-\t      sbitmap_difference (difference, nearerout[succ->index], \n-\t\t\t\t  st_avloc[succ->index]);\n-\t      if (sbitmap_a_or_b (nearer[x], difference, farthest[x]))\n-\t\tdone = 0;\n+\t      /* If NEARER for an incoming edge was changed, then we need\n+\t\t to add the source of the incoming edge to the worklist.  */\n+\t      if (e->src != ENTRY_BLOCK_PTR && e->src->aux == 0)\n+\t\t{\n+\t\t  *tos++ = e->src;\n+\t\t  e->src->aux = e;\n+\t\t}\n \t    }\n-\t}\n-\n-      if (done)\n-        break;\n-\n-      sbitmap_vector_zero (nearerout, n_basic_blocks);\n-\n-      for (x = 0; x < num_edges; x++)\n-\t{\n-\t  pred = INDEX_EDGE_PRED_BB (edge_list, x);\n-\t  if (pred != ENTRY_BLOCK_PTR)\n-\t      sbitmap_a_and_b (nearerout[pred->index], \n-\t\t\t       nearerout[pred->index], nearer[x]);\n-\t    else\n-\t      sbitmap_a_and_b (nearerout[n_basic_blocks], \n-\t\t\t       nearerout[n_basic_blocks], nearer[x]);\n-\t}\n+        }\n     }\n \n-  free (difference);\n+  /* Computation of insertion and deletion points requires computing NEAREROUT\n+     for the ENTRY block.  We allocated an extra entry in the NEAREROUT array\n+     for just this purpose.  */\n+  sbitmap_ones (nearerout[n_basic_blocks]);\n+  for (e = ENTRY_BLOCK_PTR->succ; e != NULL; e = e->succ_next)\n+    sbitmap_a_and_b (nearerout[n_basic_blocks],\n+\t\t     nearerout[n_basic_blocks],\n+\t\t     nearer[(int)e->aux]);\n+\n+  free (tos);\n }\n \n /* Compute the insertion and deletion points for edge based LCM.  */\n@@ -649,7 +745,7 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n   nearer = sbitmap_vector_alloc (num_edges, n_exprs);\n   /* Allocate an extra element for the entry block.  */\n   nearerout = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n-  compute_nearerout (edge_list, n_exprs, farthest, st_avloc, nearer, nearerout);\n+  compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);\n \n #ifdef LCM_DEBUG_INFO\n   if (file)"}]}