{"sha": "39c0aa5f74be114ec472a97a12409067b74ac0dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljMGFhNWY3NGJlMTE0ZWM0NzJhOTdhMTI0MDkwNjdiNzRhYzBkYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-03T23:37:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-03T23:37:04Z"}, "message": "compiler, runtime, reflect: generate unique type descriptors\n    \n    Currently, the compiler already generates common symbols for type\n    descriptors, so the type descriptors are unique. However, when a\n    type is created through reflection, it is not deduplicated with\n    compiler-generated types. As a consequence, we cannot assume type\n    descriptors are unique, and cannot use pointer equality to\n    compare them. Also, when constructing a reflect.Type, it has to\n    go through a canonicalization map, which introduces overhead to\n    reflect.TypeOf, and lock contentions in concurrent programs.\n    \n    In order for the reflect package to deduplicate types with\n    compiler-created types, we register all the compiler-created type\n    descriptors at startup time. The reflect package, when it needs\n    to create a type, looks up the registry of compiler-created types\n    before creates a new one. There is no lock contention since the\n    registry is read-only after initialization.\n    \n    This lets us get rid of the canonicalization map, and also makes\n    it possible to compare type descriptors with pointer equality.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/179598\n\nFrom-SVN: r271894", "tree": {"sha": "19c16f5db5a78699200253d35ce390c429f76126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19c16f5db5a78699200253d35ce390c429f76126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39c0aa5f74be114ec472a97a12409067b74ac0dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c0aa5f74be114ec472a97a12409067b74ac0dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c0aa5f74be114ec472a97a12409067b74ac0dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c0aa5f74be114ec472a97a12409067b74ac0dc/comments", "author": null, "committer": null, "parents": [{"sha": "8535d5aa16a895ba54ddb9c9453f093ad42f505e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8535d5aa16a895ba54ddb9c9453f093ad42f505e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8535d5aa16a895ba54ddb9c9453f093ad42f505e"}], "stats": {"total": 430, "additions": 349, "deletions": 81}, "files": [{"sha": "167f3d3aa47eed181a10c0cda9fce511e7cc59fe", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -1,4 +1,4 @@\n-951c83af46375019b2fe262635746368a6b9c4ba\n+e4d8ccaed06f81683e79774ede6c61949f6df8b8\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ce9bffbfda2a8d8eda86ab3cdc82f73152e1ca76", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 150, "deletions": 1, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -64,6 +64,7 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n     named_types_are_converted_(false),\n     analysis_sets_(),\n     gc_roots_(),\n+    type_descriptors_(),\n     imported_inlinable_functions_(),\n     imported_inline_functions_()\n {\n@@ -903,6 +904,139 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n   init_stmts.push_back(this->backend()->expression_statement(init_bfn, bcall));\n }\n \n+// Build the list of type descriptors defined in this package. This is to help\n+// the reflect package to find compiler-generated types.\n+\n+// type typeDescriptorList struct {\n+// \t count int\n+// \t types [...]unsafe.Pointer\n+// }\n+\n+static Struct_type*\n+type_descriptor_list_type(unsigned long len)\n+{\n+  Location builtin_loc = Linemap::predeclared_location();\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Type* ptr_type = Type::make_pointer_type(Type::make_void_type());\n+  // Avoid creating zero-length type.\n+  unsigned long nelems = (len != 0 ? len : 1);\n+  Expression* len_expr = Expression::make_integer_ul(nelems, NULL,\n+                                                     builtin_loc);\n+  Array_type* array_type = Type::make_array_type(ptr_type, len_expr);\n+  array_type->set_is_array_incomparable();\n+  Struct_type* list_type =\n+    Type::make_builtin_struct_type(2, \"count\", int_type,\n+                                   \"types\", array_type);\n+  return list_type;\n+}\n+\n+void\n+Gogo::build_type_descriptor_list()\n+{\n+  // Create the list type\n+  Location builtin_loc = Linemap::predeclared_location();\n+  unsigned long len = this->type_descriptors_.size();\n+  Struct_type* list_type = type_descriptor_list_type(len);\n+  Btype* bt = list_type->get_backend(this);\n+  Btype* bat = list_type->field(1)->type()->get_backend(this);\n+\n+  // Create the variable\n+  std::string name = this->type_descriptor_list_symbol(this->package_);\n+  Bvariable* bv = this->backend()->implicit_variable(name, name, bt,\n+                                                     false, true, false,\n+                                                     0);\n+\n+  // Build the initializer\n+  std::vector<unsigned long> indexes;\n+  std::vector<Bexpression*> vals;\n+  std::vector<Type*>::iterator p = this->type_descriptors_.begin();\n+  for (unsigned long i = 0; i < len; ++i, ++p)\n+    {\n+      Bexpression* bexpr = (*p)->type_descriptor_pointer(this,\n+                                                         builtin_loc);\n+      indexes.push_back(i);\n+      vals.push_back(bexpr);\n+    }\n+  Bexpression* barray =\n+    this->backend()->array_constructor_expression(bat, indexes, vals,\n+                                                  builtin_loc);\n+\n+  Translate_context context(this, NULL, NULL, NULL);\n+  std::vector<Bexpression*> fields;\n+  Expression* len_expr = Expression::make_integer_ul(len, NULL,\n+                                                     builtin_loc);\n+  fields.push_back(len_expr->get_backend(&context));\n+  fields.push_back(barray);\n+  Bexpression* binit =\n+    this->backend()->constructor_expression(bt, fields, builtin_loc);\n+\n+  this->backend()->implicit_variable_set_init(bv, name, bt, false,\n+                                              true, false, binit);\n+}\n+\n+// Register the type descriptors with the runtime.  This is to help\n+// the reflect package to find compiler-generated types.\n+\n+void\n+Gogo::register_type_descriptors(std::vector<Bstatement*>& init_stmts,\n+                                Bfunction* init_bfn)\n+{\n+  // Create the list type\n+  Location builtin_loc = Linemap::predeclared_location();\n+  Struct_type* list_type = type_descriptor_list_type(1);\n+  Btype* bt = list_type->get_backend(this);\n+\n+  // Build a list of lists.\n+  std::vector<unsigned long> indexes;\n+  std::vector<Bexpression*> vals;\n+  unsigned long i = 0;\n+  for (Packages::iterator it = this->packages_.begin();\n+       it != this->packages_.end();\n+       ++it)\n+    {\n+      if (it->second->pkgpath() == \"unsafe\")\n+        continue;\n+\n+      std::string name = this->type_descriptor_list_symbol(it->second);\n+      Bvariable* bv =\n+        this->backend()->implicit_variable_reference(name, name, bt);\n+      Bexpression* bexpr = this->backend()->var_expression(bv, builtin_loc);\n+      bexpr = this->backend()->address_expression(bexpr, builtin_loc);\n+\n+      indexes.push_back(i);\n+      vals.push_back(bexpr);\n+      i++;\n+    }\n+  Expression* len_expr = Expression::make_integer_ul(i, NULL, builtin_loc);\n+  Type* list_ptr_type = Type::make_pointer_type(list_type);\n+  Type* list_array_type = Type::make_array_type(list_ptr_type, len_expr);\n+  Btype* bat = list_array_type->get_backend(this);\n+  Bexpression* barray =\n+    this->backend()->array_constructor_expression(bat, indexes, vals,\n+                                                  builtin_loc);\n+\n+  // Create a variable holding the list.\n+  std::string name = this->typelists_symbol();\n+  Bvariable* bv = this->backend()->implicit_variable(name, name, bat,\n+                                                     true, true, false,\n+                                                     0);\n+  this->backend()->implicit_variable_set_init(bv, name, bat, true, true,\n+                                              false, barray);\n+\n+  // Build the call in main package's init function.\n+  Translate_context context(this, NULL, NULL, NULL);\n+  Bexpression* bexpr = this->backend()->var_expression(bv, builtin_loc);\n+  bexpr = this->backend()->address_expression(bexpr, builtin_loc);\n+  Type* array_ptr_type = Type::make_pointer_type(list_array_type);\n+  Expression* expr = Expression::make_backend(bexpr, array_ptr_type,\n+                                              builtin_loc);\n+  expr = Runtime::make_call(Runtime::REGISTER_TYPE_DESCRIPTORS,\n+                            builtin_loc, 2, len_expr->copy(), expr);\n+  Bexpression* bcall = expr->get_backend(&context);\n+  init_stmts.push_back(this->backend()->expression_statement(init_bfn,\n+                                                             bcall));\n+}\n+\n // Build the decl for the initialization function.\n \n Named_object*\n@@ -1411,7 +1545,6 @@ Gogo::write_globals()\n     {\n       init_fndecl = this->initialization_function_decl();\n       init_bfn = init_fndecl->func_value()->get_or_make_decl(this, init_fndecl);\n-      this->init_imports(init_stmts, init_bfn);\n     }\n \n   // A list of variable initializations.\n@@ -1585,6 +1718,22 @@ Gogo::write_globals()\n        ++p)\n     (*p)->get_backend(this, const_decls, type_decls, func_decls);\n \n+  // Build the list of type descriptors.\n+  this->build_type_descriptor_list();\n+\n+  if (this->is_main_package())\n+    {\n+      // Register the type descriptor lists, so that at run time\n+      // the reflect package can find compiler-created types, and\n+      // deduplicate if the same type is created with reflection.\n+      // This needs to be done before calling any package's init\n+      // function, as it may create type through reflection.\n+      this->register_type_descriptors(init_stmts, init_bfn);\n+\n+      // Initialize imported packages.\n+      this->init_imports(init_stmts, init_bfn);\n+    }\n+\n   // Register global variables with the garbage collector.\n   this->register_gc_vars(var_gc, init_stmts, init_bfn);\n "}, {"sha": "91e3bdfd198015cbdbe638475378d632066b8f42", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -617,6 +617,11 @@ class Gogo\n     this->gc_roots_.push_back(expr);\n   }\n \n+  // Add a type to the descriptor list.\n+  void\n+  add_type_descriptor(Type* type)\n+  { this->type_descriptors_.push_back(type); }\n+\n   // Traverse the tree.  See the Traverse class.\n   void\n   traverse(Traverse*);\n@@ -901,6 +906,14 @@ class Gogo\n   std::string\n   type_descriptor_name(Type*, Named_type*);\n \n+  // Return the name of the type descriptor list symbol of a package.\n+  std::string\n+  type_descriptor_list_symbol(Package*);\n+\n+  // Return the name of the list of all type descriptor lists.\n+  std::string\n+  typelists_symbol();\n+\n   // Return the assembler name for the GC symbol for a type.\n   std::string\n   gc_symbol_name(Type*);\n@@ -967,6 +980,15 @@ class Gogo\n                    std::vector<Bstatement*>&,\n                    Bfunction* init_bfunction);\n \n+  // Build the list of type descriptors.\n+  void\n+  build_type_descriptor_list();\n+\n+  // Register the type descriptors with the runtime.\n+  void\n+  register_type_descriptors(std::vector<Bstatement*>&,\n+                            Bfunction* init_bfunction);\n+\n   void\n   propagate_writebarrierrec();\n \n@@ -1108,6 +1130,8 @@ class Gogo\n   std::vector<Analysis_set> analysis_sets_;\n   // A list of objects to add to the GC roots.\n   std::vector<Expression*> gc_roots_;\n+  // A list of type descriptors that we need to register.\n+  std::vector<Type*> type_descriptors_;\n   // A list of function declarations with imported bodies that we may\n   // want to inline.\n   std::vector<Named_object*> imported_inlinable_functions_;"}, {"sha": "e109cfc6e88e85bbf31dc8bd56a5bb2cd3be4ae2", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -146,6 +146,12 @@\n // and is named __go_init_main.  For other packages it is\n // PKGPATH..import.\n //\n+// In each pacakge there is a list of all the type descriptors defined\n+// in this package.  The name of the list is PKGPATH..types.\n+//\n+// In the main package it gathers all the type descriptor lists in a\n+// single list, named go..typelists.\n+//\n // The type literal encoding is essentially a single line version of\n // the type literal, such as \"struct { pkgpath.i int; J int }\".  In\n // this representation unexported names use their pkgpath, exported\n@@ -985,6 +991,23 @@ Gogo::type_descriptor_name(Type* type, Named_type* nt)\n   return ret;\n }\n \n+// Return the name of the type descriptor list symbol of a package.\n+\n+std::string\n+Gogo::type_descriptor_list_symbol(Package* pkg)\n+{\n+  return pkg->pkgpath_symbol() + \"..types\";\n+}\n+\n+// Return the name of the list of all type descriptor lists.  This is\n+// only used in the main package.\n+\n+std::string\n+Gogo::typelists_symbol()\n+{\n+  return \"go..typelists\";\n+}\n+\n // Return the name for the GC symbol for a type.  This is used to\n // initialize the gcdata field of a type descriptor.  This is a local\n // name never referenced outside of this assembly file.  (Note that"}, {"sha": "b0e686161fe157d16ac41f6c952092502d408e84", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -212,6 +212,10 @@ DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\",\n // Register roots (global variables) for the garbage collector.\n DEF_GO_RUNTIME(REGISTER_GC_ROOTS, \"runtime.registerGCRoots\", P1(POINTER), R0())\n \n+// Register type descriptors.\n+DEF_GO_RUNTIME(REGISTER_TYPE_DESCRIPTORS, \"runtime.registerTypeDescriptors\",\n+               P2(INT, POINTER), R0())\n+\n \n // Allocate memory.\n DEF_GO_RUNTIME(NEW, \"runtime.newobject\", P1(TYPE), R1(POINTER))"}, {"sha": "011a7afe54d1c3f79b00e0dded2d364bbe838db9", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -1413,6 +1413,23 @@ Type::make_type_descriptor_var(Gogo* gogo)\n \t\t\t\t\t     var_name, false, is_common,\n \t\t\t\t\t     initializer_btype, loc,\n \t\t\t\t\t     binitializer);\n+\n+  // For types that may be created by reflection, add it to the\n+  // list of which we will register the type descriptor to the\n+  // runtime.\n+  // Do not add generated incomparable array/struct types, see\n+  // issue #22605.\n+  if (is_common\n+      && (this->points_to() != NULL\n+          || this->channel_type() != NULL\n+          || this->map_type() != NULL\n+          || this->function_type() != NULL\n+          || this->is_slice_type()\n+          || (this->struct_type() != NULL\n+              && !this->struct_type()->is_struct_incomparable())\n+          || (this->array_type() != NULL\n+              && !this->array_type()->is_array_incomparable())))\n+  gogo->add_type_descriptor(this);\n }\n \n // Return true if this type descriptor is defined in a different"}, {"sha": "8493d87f802336ba00a0128bdb45cb9738c0b32d", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -1105,15 +1105,14 @@ func (t *rtype) ptrTo() *rtype {\n \t\treturn &pi.(*ptrType).rtype\n \t}\n \n+\t// Look in known types.\n \ts := \"*\" + *t.string\n-\n-\tcanonicalTypeLock.RLock()\n-\tr, ok := canonicalType[s]\n-\tcanonicalTypeLock.RUnlock()\n-\tif ok {\n-\t\tp := (*ptrType)(unsafe.Pointer(r.(*rtype)))\n-\t\tpi, _ := ptrMap.LoadOrStore(t, p)\n-\t\treturn &pi.(*ptrType).rtype\n+\tif tt := lookupType(s); tt != nil {\n+\t\tp := (*ptrType)(unsafe.Pointer(tt))\n+\t\tif p.elem == t {\n+\t\t\tpi, _ := ptrMap.LoadOrStore(t, p)\n+\t\t\treturn &pi.(*ptrType).rtype\n+\t\t}\n \t}\n \n \t// Create a new ptrType starting with the description\n@@ -1138,10 +1137,7 @@ func (t *rtype) ptrTo() *rtype {\n \tpp.ptrToThis = nil\n \tpp.elem = t\n \n-\tq := canonicalize(&pp.rtype)\n-\tp := (*ptrType)(unsafe.Pointer(q.(*rtype)))\n-\n-\tpi, _ := ptrMap.LoadOrStore(t, p)\n+\tpi, _ := ptrMap.LoadOrStore(t, &pp)\n \treturn &pi.(*ptrType).rtype\n }\n \n@@ -1447,6 +1443,13 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tcase BothDir:\n \t\ts = \"chan \" + *typ.string\n \t}\n+\tif tt := lookupType(s); tt != nil {\n+\t\tch := (*chanType)(unsafe.Pointer(tt))\n+\t\tif ch.elem == typ && ch.dir == uintptr(dir) {\n+\t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n+\t\t\treturn ti.(Type)\n+\t\t}\n+\t}\n \n \t// Make a channel type.\n \tvar ichan interface{} = (chan unsafe.Pointer)(nil)\n@@ -1472,10 +1475,8 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tch.uncommonType = nil\n \tch.ptrToThis = nil\n \n-\t// Canonicalize before storing in lookupCache\n-\tti := toType(&ch.rtype)\n-\tlookupCache.Store(ckey, ti.(*rtype))\n-\treturn ti\n+\tti, _ := lookupCache.LoadOrStore(ckey, &ch.rtype)\n+\treturn ti.(Type)\n }\n \n func ismapkey(*rtype) bool // implemented in runtime\n@@ -1502,6 +1503,13 @@ func MapOf(key, elem Type) Type {\n \n \t// Look in known types.\n \ts := \"map[\" + *ktyp.string + \"]\" + *etyp.string\n+\tif tt := lookupType(s); tt != nil {\n+\t\tmt := (*mapType)(unsafe.Pointer(tt))\n+\t\tif mt.key == ktyp && mt.elem == etyp {\n+\t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n+\t\t\treturn ti.(Type)\n+\t\t}\n+\t}\n \n \t// Make a map type.\n \t// Note: flag values must match those used in the TMAP case\n@@ -1544,10 +1552,8 @@ func MapOf(key, elem Type) Type {\n \t\tmt.flags |= 16\n \t}\n \n-\t// Canonicalize before storing in lookupCache\n-\tti := toType(&mt.rtype)\n-\tlookupCache.Store(ckey, ti.(*rtype))\n-\treturn ti\n+\tti, _ := lookupCache.LoadOrStore(ckey, &mt.rtype)\n+\treturn ti.(Type)\n }\n \n // FuncOf returns the function type with the given argument and result types.\n@@ -1625,15 +1631,17 @@ func FuncOf(in, out []Type, variadic bool) Type {\n \t}\n \n \tstr := funcStr(ft)\n+\tif tt := lookupType(str); tt != nil {\n+\t\tif haveIdenticalUnderlyingType(&ft.rtype, tt, true) {\n+\t\t\treturn addToCache(tt)\n+\t\t}\n+\t}\n \n \t// Populate the remaining fields of ft and store in cache.\n \tft.string = &str\n \tft.uncommonType = nil\n \tft.ptrToThis = nil\n-\n-\t// Canonicalize before storing in funcLookupCache\n-\ttc := toType(&ft.rtype)\n-\treturn addToCache(tc.(*rtype))\n+\treturn addToCache(&ft.rtype)\n }\n \n // funcStr builds a string representation of a funcType.\n@@ -1873,6 +1881,13 @@ func SliceOf(t Type) Type {\n \n \t// Look in known types.\n \ts := \"[]\" + *typ.string\n+\tif tt := lookupType(s); tt != nil {\n+\t\tslice := (*sliceType)(unsafe.Pointer(tt))\n+\t\tif slice.elem == typ {\n+\t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n+\t\t\treturn ti.(Type)\n+\t\t}\n+\t}\n \n \t// Make a slice type.\n \tvar islice interface{} = ([]unsafe.Pointer)(nil)\n@@ -1888,10 +1903,8 @@ func SliceOf(t Type) Type {\n \tslice.uncommonType = nil\n \tslice.ptrToThis = nil\n \n-\t// Canonicalize before storing in lookupCache\n-\tti := toType(&slice.rtype)\n-\tlookupCache.Store(ckey, ti.(*rtype))\n-\treturn ti\n+\tti, _ := lookupCache.LoadOrStore(ckey, &slice.rtype)\n+\treturn ti.(Type)\n }\n \n // The structLookupCache caches StructOf lookups.\n@@ -2106,6 +2119,13 @@ func StructOf(fields []StructField) Type {\n \t\treturn t\n \t}\n \n+\t// Look in known types.\n+\tif tt := lookupType(str); tt != nil {\n+\t\tif haveIdenticalUnderlyingType(&typ.rtype, tt, true) {\n+\t\t\treturn addToCache(tt)\n+\t\t}\n+\t}\n+\n \ttyp.string = &str\n \ttyp.hash = hash\n \ttyp.size = size\n@@ -2214,10 +2234,7 @@ func StructOf(fields []StructField) Type {\n \n \ttyp.uncommonType = nil\n \ttyp.ptrToThis = nil\n-\n-\t// Canonicalize before storing in structLookupCache\n-\tti := toType(&typ.rtype)\n-\treturn addToCache(ti.(*rtype))\n+\treturn addToCache(&typ.rtype)\n }\n \n func runtimeStructField(field StructField) structField {\n@@ -2300,6 +2317,13 @@ func ArrayOf(count int, elem Type) Type {\n \n \t// Look in known types.\n \ts := \"[\" + strconv.Itoa(count) + \"]\" + *typ.string\n+\tif tt := lookupType(s); tt != nil {\n+\t\tarray := (*arrayType)(unsafe.Pointer(tt))\n+\t\tif array.elem == typ {\n+\t\t\tti, _ := lookupCache.LoadOrStore(ckey, tt)\n+\t\t\treturn ti.(Type)\n+\t\t}\n+\t}\n \n \t// Make an array type.\n \tvar iarray interface{} = [1]unsafe.Pointer{}\n@@ -2451,10 +2475,8 @@ func ArrayOf(count int, elem Type) Type {\n \t\t}\n \t}\n \n-\t// Canonicalize before storing in lookupCache\n-\tti := toType(&array.rtype)\n-\tlookupCache.Store(ckey, ti.(*rtype))\n-\treturn ti\n+\tti, _ := lookupCache.LoadOrStore(ckey, &array.rtype)\n+\treturn ti.(Type)\n }\n \n func appendVarint(x []byte, v uintptr) []byte {\n@@ -2466,42 +2488,19 @@ func appendVarint(x []byte, v uintptr) []byte {\n }\n \n // toType converts from a *rtype to a Type that can be returned\n-// to the client of package reflect. In gc, the only concern is that\n-// a nil *rtype must be replaced by a nil Type, but in gccgo this\n-// function takes care of ensuring that multiple *rtype for the same\n-// type are coalesced into a single Type.\n-var canonicalType = make(map[string]Type)\n-\n-var canonicalTypeLock sync.RWMutex\n-\n-func canonicalize(t Type) Type {\n-\tif t == nil {\n-\t\treturn nil\n-\t}\n-\ts := t.rawString()\n-\tcanonicalTypeLock.RLock()\n-\tif r, ok := canonicalType[s]; ok {\n-\t\tcanonicalTypeLock.RUnlock()\n-\t\treturn r\n-\t}\n-\tcanonicalTypeLock.RUnlock()\n-\tcanonicalTypeLock.Lock()\n-\tif r, ok := canonicalType[s]; ok {\n-\t\tcanonicalTypeLock.Unlock()\n-\t\treturn r\n-\t}\n-\tcanonicalType[s] = t\n-\tcanonicalTypeLock.Unlock()\n-\treturn t\n-}\n-\n+// to the client of package reflect. The only concern is that\n+// a nil *rtype must be replaced by a nil Type.\n func toType(p *rtype) Type {\n \tif p == nil {\n \t\treturn nil\n \t}\n-\treturn canonicalize(p)\n+\treturn p\n }\n \n+// Look up a compiler-generated type descriptor.\n+// Implemented in runtime.\n+func lookupType(s string) *rtype\n+\n // ifaceIndir reports whether t is stored indirectly in an interface value.\n func ifaceIndir(t *rtype) bool {\n \treturn t.kind&kindDirectIface == 0"}, {"sha": "3bdb8f1493ff3351508d12077f72b3ef1ecc9fc7", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c0aa5f74be114ec472a97a12409067b74ac0dc/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c0aa5f74be114ec472a97a12409067b74ac0dc/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=39c0aa5f74be114ec472a97a12409067b74ac0dc", "patch": "@@ -6,7 +6,11 @@\n \n package runtime\n \n-import \"unsafe\"\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n \n type _type struct {\n \tsize       uintptr\n@@ -45,19 +49,8 @@ func (t *_type) pkgpath() string {\n }\n \n // Return whether two type descriptors are equal.\n-// This is gccgo-specific, as gccgo, unlike gc, permits multiple\n-// independent descriptors for a single type.\n func eqtype(t1, t2 *_type) bool {\n-\tswitch {\n-\tcase t1 == t2:\n-\t\treturn true\n-\tcase t1 == nil || t2 == nil:\n-\t\treturn false\n-\tcase t1.kind != t2.kind || t1.hash != t2.hash:\n-\t\treturn false\n-\tdefault:\n-\t\treturn t1.string() == t2.string()\n-\t}\n+\treturn t1 == t2\n }\n \n type method struct {\n@@ -164,3 +157,62 @@ type structtype struct {\n \ttyp    _type\n \tfields []structfield\n }\n+\n+// typeDescriptorList holds a list of type descriptors generated\n+// by the compiler. This is used for the compiler to register\n+// type descriptors to the runtime.\n+// The layout is known to the compiler.\n+//go:notinheap\n+type typeDescriptorList struct {\n+\tcount int\n+\ttypes [1]uintptr // variable length\n+}\n+\n+// typelist holds all type descriptors generated by the comiler.\n+// This is for the reflect package to deduplicate type descriptors\n+// when it creates a type that is also a compiler-generated type.\n+var typelist struct {\n+\tinitialized uint32\n+\tlists       []*typeDescriptorList // one element per package\n+\ttypes       map[string]uintptr    // map from a type's string to *_type, lazily populated\n+\t// TODO: use a sorted array instead?\n+}\n+var typelistLock mutex\n+\n+// The compiler generates a call of this function in the main\n+// package's init function, to register compiler-generated\n+// type descriptors.\n+// p points to a list of *typeDescriptorList, n is the length\n+// of the list.\n+//go:linkname registerTypeDescriptors runtime.registerTypeDescriptors\n+func registerTypeDescriptors(n int, p unsafe.Pointer) {\n+\t*(*slice)(unsafe.Pointer(&typelist.lists)) = slice{p, n, n}\n+}\n+\n+// The reflect package uses this function to look up a compiler-\n+// generated type descriptor.\n+//go:linkname reflect_lookupType reflect.lookupType\n+func reflect_lookupType(s string) *_type {\n+\t// Lazy initialization. We don't need to do this if we never create\n+\t// types through reflection.\n+\tif atomic.Load(&typelist.initialized) == 0 {\n+\t\tlock(&typelistLock)\n+\t\tif atomic.Load(&typelist.initialized) == 0 {\n+\t\t\tn := 0\n+\t\t\tfor _, list := range typelist.lists {\n+\t\t\t\tn += list.count\n+\t\t\t}\n+\t\t\ttypelist.types = make(map[string]uintptr, n)\n+\t\t\tfor _, list := range typelist.lists {\n+\t\t\t\tfor i := 0; i < list.count; i++ {\n+\t\t\t\t\ttyp := *(**_type)(add(unsafe.Pointer(&list.types), uintptr(i)*sys.PtrSize))\n+\t\t\t\t\ttypelist.types[typ.string()] = uintptr(unsafe.Pointer(typ))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tatomic.Store(&typelist.initialized, 1)\n+\t\t}\n+\t\tunlock(&typelistLock)\n+\t}\n+\n+\treturn (*_type)(unsafe.Pointer(typelist.types[s]))\n+}"}]}