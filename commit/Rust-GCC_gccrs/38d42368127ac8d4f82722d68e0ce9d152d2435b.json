{"sha": "38d42368127ac8d4f82722d68e0ce9d152d2435b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhkNDIzNjgxMjdhYzhkNGY4MjcyMmQ2OGUwY2U5ZDE1MmQyNDM1Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-21T18:58:10Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-12-21T18:58:10Z"}, "message": "(sched_analyze): For CALL_INSN followed by NOTE_INSN_SETJMP note...\n\n(sched_analyze): For CALL_INSN followed by\nNOTE_INSN_SETJMP note, make it depend on all registers not just\nhard registers, and add a REG_DEAD -1 note.\n(unlink_notes): Don't save away NOTE_INSN_SETJMP notes.\n(schedule_block): After scheduling CALL_INSN, check for REG_DEAD\n-1 note.  If find it, delete it, and output a NOTE_INSN_SETJMP note.\n\nFrom-SVN: r6254", "tree": {"sha": "87b6ef465511480d1e1e3821701ae84a2ba221f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87b6ef465511480d1e1e3821701ae84a2ba221f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38d42368127ac8d4f82722d68e0ce9d152d2435b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d42368127ac8d4f82722d68e0ce9d152d2435b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d42368127ac8d4f82722d68e0ce9d152d2435b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d42368127ac8d4f82722d68e0ce9d152d2435b/comments", "author": null, "committer": null, "parents": [{"sha": "3eb8f14cbc240ac542ac954dccf0fe8569cc1c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb8f14cbc240ac542ac954dccf0fe8569cc1c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb8f14cbc240ac542ac954dccf0fe8569cc1c30"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "78af990d796681969427afaaa540593db831ee29", "filename": "gcc/sched.c", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38d42368127ac8d4f82722d68e0ce9d152d2435b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38d42368127ac8d4f82722d68e0ce9d152d2435b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=38d42368127ac8d4f82722d68e0ce9d152d2435b", "patch": "@@ -2098,18 +2098,45 @@ sched_analyze (head, tail)\n \t     past a void call (i.e. it does not explicitly set the hard\n \t     return reg).  */\n \n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (call_used_regs[i] || global_regs[i])\n-\t      {\n-\t\tfor (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n-\t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\treg_last_uses[i] = 0;\n-\t\tif (reg_last_sets[i])\n-\t\t  add_dependence (insn, reg_last_sets[i], REG_DEP_ANTI);\n-\t\treg_last_sets[i] = insn;\n-\t\t/* Insn, being a CALL_INSN, magically depends on\n-\t\t   `last_function_call' already.  */\n-\t      }\n+\t  /* If this call is followed by a NOTE_INSN_SETJMP, then assume that\n+\t     all registers, not just hard registers, may be clobbered by this\n+\t     call.  */\n+\n+\t  /* Insn, being a CALL_INSN, magically depends on\n+\t     `last_function_call' already.  */\n+\n+\t  if (NEXT_INSN (insn) && GET_CODE (NEXT_INSN (insn)) == NOTE\n+\t      && NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n+\t    {\n+\t      int max_reg = max_reg_num ();\n+\t      for (i = 0; i < max_reg; i++)\n+\t\t{\n+\t\t  for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t\t  reg_last_uses[i] = 0;\n+\t\t  if (reg_last_sets[i])\n+\t\t    add_dependence (insn, reg_last_sets[i], 0);\n+\t\t  reg_last_sets[i] = insn;\n+\t\t}\n+\n+\t      /* Add a fake REG_NOTE which we will later convert\n+\t\t back into a NOTE_INSN_SETJMP note.  */\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, constm1_rtx,\n+\t\t\t\t\t  REG_NOTES (insn));\n+\t    }\n+\t  else\n+\t    {\n+\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t\tif (call_used_regs[i] || global_regs[i])\n+\t\t  {\n+\t\t    for (u = reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t\t      add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t\t    reg_last_uses[i] = 0;\n+\t\t    if (reg_last_sets[i])\n+\t\t      add_dependence (insn, reg_last_sets[i], REG_DEP_ANTI);\n+\t\t    reg_last_sets[i] = insn;\n+\t\t  }\n+\t    }\n \n \t  /* For each insn which shouldn't cross a call, add a dependence\n \t     between that insn and this call insn.  */\n@@ -2885,7 +2912,11 @@ unlink_notes (insn, tail)\n       if (write_symbols != NO_DEBUG && NOTE_LINE_NUMBER (insn) > 0)\n \t/* Record line-number notes so they can be reused.  */\n \tLINE_NOTE (insn) = insn;\n-      else\n+\n+      /* Don't save away NOTE_INSN_SETJMPs, because they must remain\n+\t immediately after the call they follow.  We use a fake\n+\t (REG_DEAD (const_int -1)) note to remember them.  */\n+      else if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_SETJMP)\n \t{\n \t  /* Insert the note at the end of the notes list.  */\n \t  PREV_INSN (insn) = note_list;\n@@ -3702,6 +3733,18 @@ schedule_block (b, file)\n       PREV_INSN (last) = insn;\n       last = insn;\n \n+      /* Check to see if we need to re-emit a NOTE_INSN_SETJMP here.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx note = find_reg_note (insn, REG_DEAD, constm1_rtx);\n+\n+\t  if (note)\n+\t    {\n+\t      emit_note_after (NOTE_INSN_SETJMP, insn);\n+\t      remove_note (insn, note);\n+\t    }\n+\t}\n+\n       /* Everything that precedes INSN now either becomes \"ready\", if\n \t it can execute immediately before INSN, or \"pending\", if\n \t there must be a delay.  Give INSN high enough priority that"}]}