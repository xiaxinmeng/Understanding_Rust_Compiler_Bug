{"sha": "befd756626fa71b89c1cd6563d97c968618103f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVmZDc1NjYyNmZhNzFiODljMWNkNjU2M2Q5N2M5Njg2MTgxMDNmNA==", "commit": {"author": {"name": "Keith Seitz", "email": "keiths@redhat.com", "date": "2007-05-04T01:04:11Z"}, "committer": {"name": "Keith Seitz", "email": "kseitz@gcc.gnu.org", "date": "2007-05-04T01:04:11Z"}, "message": "jvmti-int.h (_Jv_ReportJVMTIExceptionThrow): Declare.\n\n        * include/jvmti-int.h (_Jv_ReportJVMTIExceptionThrow):\n        Declare.\n        * interpret.cc (_Jv_ReportJVMTIExceptionThrow): New function.\n        (find_catch_location): New function.\n        (REPORT_EXCEPTION): New macro.\n        (throw_internal_error): Use REPORT_EXCEPTION.\n        (throw_incompatible_class_change_error): Likewise.\n        (throw_null_pointer_exception): Likewise.\n        (throw_class_format_error): Likewise.\n        * interpret-run.cc (INTERP_REPORT_EXCEPTION)[DEBUG]: Set\n        to REPORT_EXCEPTION.\n        (INTERP_REPORT_EXCEPTION)[!DEBUG]: Make nop.\n        (insn_new): Use INTERP_REPORT_EXCEPTION.\n        (insn_athrow): Likewise.\n        Remove previous JVMTI exception notifications.\n        Add JVMTI ExceptionCatch notificatin.\n        * jni.cc (_Jv_PopSystemFrame): Notify JVMTI clients of\n        exception throw.\n        * gnu/gcj/jvmti/ExceptionEvent.java: Removed.\n        * gnu/gcj/jvmti/ExceptionEvent.h: Removed.\n        * classpath/lib/gnu/gcj/jvmti/ExceptionEvent.class: Removed.\n        * gnu/classpath/jdwp/natVMVirtualMachine.cc\n        (jdwpExceptionCB): New function.\n        (jdwpVMInitCB): Set Exception event handler and enable.\n        * sources.am: Regenerated.\n        * Makefile.in: Regenerated.\n\nFrom-SVN: r124406", "tree": {"sha": "a8f4058c8d5dc274f095fb50893c2f74cfe875a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8f4058c8d5dc274f095fb50893c2f74cfe875a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/befd756626fa71b89c1cd6563d97c968618103f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befd756626fa71b89c1cd6563d97c968618103f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befd756626fa71b89c1cd6563d97c968618103f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befd756626fa71b89c1cd6563d97c968618103f4/comments", "author": {"login": "shtiek", "id": 107581324, "node_id": "U_kgDOBmmPjA", "avatar_url": "https://avatars.githubusercontent.com/u/107581324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtiek", "html_url": "https://github.com/shtiek", "followers_url": "https://api.github.com/users/shtiek/followers", "following_url": "https://api.github.com/users/shtiek/following{/other_user}", "gists_url": "https://api.github.com/users/shtiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtiek/subscriptions", "organizations_url": "https://api.github.com/users/shtiek/orgs", "repos_url": "https://api.github.com/users/shtiek/repos", "events_url": "https://api.github.com/users/shtiek/events{/privacy}", "received_events_url": "https://api.github.com/users/shtiek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "820b51ae16ab41233ef12a8918df61937cfdd8b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820b51ae16ab41233ef12a8918df61937cfdd8b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820b51ae16ab41233ef12a8918df61937cfdd8b4"}], "stats": {"total": 367, "additions": 198, "deletions": 169}, "files": [{"sha": "ccaf00b72381d4a02972e01bf238247ff132270d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -1,3 +1,32 @@\n+2007-05-03  Keith Seitz  <keiths@redhat.com>\n+\n+\t* include/jvmti-int.h (_Jv_ReportJVMTIExceptionThrow):\n+\tDeclare.\n+\t* interpret.cc (_Jv_ReportJVMTIExceptionThrow): New function.\n+\t(find_catch_location): New function.\n+\t(REPORT_EXCEPTION): New macro.\n+\t(throw_internal_error): Use REPORT_EXCEPTION.\n+\t(throw_incompatible_class_change_error): Likewise.\n+\t(throw_null_pointer_exception): Likewise.\n+\t(throw_class_format_error): Likewise.\n+\t* interpret-run.cc (INTERP_REPORT_EXCEPTION)[DEBUG]: Set\n+\tto REPORT_EXCEPTION.\n+\t(INTERP_REPORT_EXCEPTION)[!DEBUG]: Make nop.\n+\t(insn_new): Use INTERP_REPORT_EXCEPTION.\n+\t(insn_athrow): Likewise.\n+\tRemove previous JVMTI exception notifications.\n+\tAdd JVMTI ExceptionCatch notificatin.\n+\t* jni.cc (_Jv_PopSystemFrame): Notify JVMTI clients of\n+\texception throw.\n+\t* gnu/gcj/jvmti/ExceptionEvent.java: Removed.\n+\t* gnu/gcj/jvmti/ExceptionEvent.h: Removed. \n+\t* classpath/lib/gnu/gcj/jvmti/ExceptionEvent.class: Removed.\n+\t* gnu/classpath/jdwp/natVMVirtualMachine.cc\n+\t(jdwpExceptionCB): New function.\n+\t(jdwpVMInitCB): Set Exception event handler and enable.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n 2007-05-03  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \thttps://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=237304"}, {"sha": "48ae71b30baca7ad642eea3e595221ff8db8d1c0", "filename": "libjava/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -1349,7 +1349,6 @@ gnu_gcj_io_header_files = $(patsubst %.java,%.h,$(gnu_gcj_io_source_files))\n gnu_gcj_jvmti_source_files = \\\n gnu/gcj/jvmti/Breakpoint.java \\\n gnu/gcj/jvmti/BreakpointManager.java \\\n-gnu/gcj/jvmti/ExceptionEvent.java \\\n gnu/gcj/jvmti/Location.java\n \n gnu_gcj_jvmti_header_files = $(patsubst %.java,%.h,$(gnu_gcj_jvmti_source_files))"}, {"sha": "bfdedd08155ab3bcff6f939f20d7337c8be87c84", "filename": "libjava/classpath/lib/gnu/gcj/jvmti/ExceptionEvent.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.class?ref=820b51ae16ab41233ef12a8918df61937cfdd8b4"}, {"sha": "d6edf345437021b7296b2abe80edb79b57950850", "filename": "libjava/gnu/classpath/jdwp/natVMVirtualMachine.cc", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fclasspath%2Fjdwp%2FnatVMVirtualMachine.cc?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -21,6 +21,7 @@ details. */\n #include <java/lang/String.h>\n #include <java/lang/StringBuilder.h>\n #include <java/lang/Thread.h>\n+#include <java/lang/Throwable.h>\n #include <java/nio/ByteBuffer.h>\n #include <java/nio/ByteBufferImpl.h>\n #include <java/util/ArrayList.h>\n@@ -37,6 +38,7 @@ details. */\n #include <gnu/classpath/jdwp/VMVirtualMachine.h>\n #include <gnu/classpath/jdwp/event/BreakpointEvent.h>\n #include <gnu/classpath/jdwp/event/ClassPrepareEvent.h>\n+#include <gnu/classpath/jdwp/event/ExceptionEvent.h>\n #include <gnu/classpath/jdwp/event/EventManager.h>\n #include <gnu/classpath/jdwp/event/EventRequest.h>\n #include <gnu/classpath/jdwp/event/SingleStepEvent.h>\n@@ -82,6 +84,9 @@ static void handle_single_step (jvmtiEnv *, struct step_info *, jthread,\n static void JNICALL jdwpBreakpointCB (jvmtiEnv *, JNIEnv *, jthread,\n \t\t\t\t      jmethodID, jlocation);\n static void JNICALL jdwpClassPrepareCB (jvmtiEnv *, JNIEnv *, jthread, jclass);\n+static void JNICALL jdwpExceptionCB (jvmtiEnv *, JNIEnv *jni_env, jthread,\n+\t\t\t\t     jmethodID, jlocation, jobject,\n+\t\t\t\t     jmethodID, jlocation);\n static void JNICALL jdwpSingleStepCB (jvmtiEnv *, JNIEnv *, jthread,\n \t\t\t\t      jmethodID, jlocation);\n static void JNICALL jdwpThreadEndCB (jvmtiEnv *, JNIEnv *, jthread);\n@@ -932,6 +937,56 @@ jdwpClassPrepareCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   Jdwp::notify (event);\n }\n \n+static void JNICALL\n+jdwpExceptionCB (jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env, jthread thread,\n+\t\t jmethodID method, jlocation location, jobject exception,\n+\t\t jmethodID catch_method, jlocation catch_location)\n+{\n+  using namespace gnu::classpath::jdwp;\n+  jclass throw_klass;\n+  jvmtiError err = env->GetMethodDeclaringClass (method, &throw_klass);\n+  if (err != JVMTI_ERROR_NONE)\n+    {\n+      fprintf (stderr, \"libgcj: internal error: could not find class for \");\n+      fprintf (stderr, \"method throwing exception -- continuing\\n\");\n+      return;\n+    }\n+\n+  VMMethod *vmmethod = new VMMethod (throw_klass,\n+\t\t\t\t     reinterpret_cast<jlong> (method));\n+  Location *throw_loc = new Location (vmmethod, location);  \n+  Location *catch_loc = NULL;\n+  if (catch_method == 0)\n+    catch_loc = Location::getEmptyLocation ();\n+  else\n+    {\n+      jclass catch_klass;\n+      err = env->GetMethodDeclaringClass (catch_method, &catch_klass);\n+      if (err != JVMTI_ERROR_NONE)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"libgcj: internal error: could not find class for \");\n+\t  fprintf (stderr,\n+\t\t   \"method catching exception -- ignoring\\n\");\n+\t}\n+      else\n+\t{\n+\t  vmmethod = new VMMethod (catch_klass,\n+\t\t\t\t   reinterpret_cast<jlong> (catch_method));\n+\t  catch_loc = new Location (vmmethod, catch_location);\n+\t}\n+    }\n+\n+  _Jv_InterpFrame *iframe\n+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);\n+  jobject instance = (iframe == NULL) ? NULL : iframe->get_this_ptr ();\n+  Throwable *throwable = reinterpret_cast<Throwable *> (exception);\n+  event::ExceptionEvent *e = new ExceptionEvent (throwable, thread,\n+\t\t\t\t\t\t throw_loc, catch_loc,\n+\t\t\t\t\t\t throw_klass, instance);\n+  Jdwp::notify (e);\n+}\n+\n static void JNICALL\n jdwpSingleStepCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n \t\t  jmethodID method, jlocation location)\n@@ -1034,6 +1089,7 @@ jdwpVMInitCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   jvmtiEventCallbacks callbacks;\n   DEFINE_CALLBACK (callbacks, Breakpoint);\n   DEFINE_CALLBACK (callbacks, ClassPrepare);\n+  DEFINE_CALLBACK (callbacks, Exception);\n   DEFINE_CALLBACK (callbacks, SingleStep);\n   DEFINE_CALLBACK (callbacks, ThreadEnd);\n   DEFINE_CALLBACK (callbacks, ThreadStart);\n@@ -1043,6 +1099,7 @@ jdwpVMInitCB (MAYBE_UNUSED jvmtiEnv *env, MAYBE_UNUSED JNIEnv *jni_env,\n   // Enable callbacks\n   ENABLE_EVENT (BREAKPOINT, NULL);\n   ENABLE_EVENT (CLASS_PREPARE, NULL);\n+  ENABLE_EVENT (EXCEPTION, NULL);\n   // SingleStep is enabled only when needed\n   ENABLE_EVENT (THREAD_END, NULL);\n   ENABLE_EVENT (THREAD_START, NULL);"}, {"sha": "825c33951d73ed2594055f9d5d242bb1f810dfdf", "filename": "libjava/gnu/gcj/jvmti/ExceptionEvent.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.h?ref=820b51ae16ab41233ef12a8918df61937cfdd8b4", "patch": "@@ -1,44 +0,0 @@\n-\n-// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n-\n-#ifndef __gnu_gcj_jvmti_ExceptionEvent__\n-#define __gnu_gcj_jvmti_ExceptionEvent__\n-\n-#pragma interface\n-\n-#include <java/lang/Object.h>\n-extern \"Java\"\n-{\n-  namespace gnu\n-  {\n-    namespace gcj\n-    {\n-      namespace jvmti\n-      {\n-          class ExceptionEvent;\n-      }\n-    }\n-  }\n-}\n-\n-class gnu::gcj::jvmti::ExceptionEvent : public ::java::lang::Object\n-{\n-\n-  ExceptionEvent(::java::lang::Thread *, jlong, jlong, ::java::lang::Throwable *, jlong, jlong);\n-public:\n-  static void postExceptionEvent(::java::lang::Thread *, jlong, jlong, ::java::lang::Throwable *, jlong, jlong);\n-  virtual void sendEvent();\n-  virtual void checkCatch();\n-private:\n-  jlong __attribute__((aligned(__alignof__( ::java::lang::Object)))) _throwMeth;\n-  jlong _throwLoc;\n-  jlong _catchMeth;\n-  jlong _catchLoc;\n-  ::java::lang::Thread * _thread;\n-  ::java::lang::Throwable * _ex;\n-  static ::java::util::WeakHashMap * _exMap;\n-public:\n-  static ::java::lang::Class class$;\n-};\n-\n-#endif // __gnu_gcj_jvmti_ExceptionEvent__"}, {"sha": "26ddec213f9b0299c2e1ca5a1dfbc3cd4b318358", "filename": "libjava/gnu/gcj/jvmti/ExceptionEvent.java", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820b51ae16ab41233ef12a8918df61937cfdd8b4/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjvmti%2FExceptionEvent.java?ref=820b51ae16ab41233ef12a8918df61937cfdd8b4", "patch": "@@ -1,96 +0,0 @@\n-// ExceptionEvent - an exception event for JVMTI\n-\n-/* Copyright (C) 2007  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-package gnu.gcj.jvmti;\n-\n-import java.util.WeakHashMap;\n-\n-/**\n- * Class to create and send JVMTI Exception events\n- *\n- * @author Kyle Galloway (kgallowa@redhat.com)\n- */\n-public class ExceptionEvent\n-{\n-  // Information about where the exception was thrown\n-  private long _throwMeth, _throwLoc;\n-  \n-  // Information about where the exception was or can be caught\n-  private long _catchMeth, _catchLoc;\n-  \n-  // Thread where the exception occurred\n-  private Thread _thread;\n-  \n-  // The exception\n-  private Throwable _ex;\n-  \n-  // A hash map of the exceptions we've already seen in a thread's call stack\n-  private static WeakHashMap<Thread, Throwable> _exMap = new WeakHashMap<Thread, Throwable>();\n-  \n-  /**\n-   * Constructs a new ExceptionEvent and sends it.  If it is not caught\n-   * within the frame where it was thrown (catchMeth and catchLoc are null),\n-   * check_catch will check for a possible catch further up the call stack \n-   * before marking it uncaught.\n-   * \n-   * @param thr the thread where the exception occurred\n-   * @param throwMeth the method of the throw (a jmethodID)\n-   * @param throwLoc the location of the throw (a jlocation)\n-   * @param ex the exception\n-   * @param catchMeth the method of the catch (a jmethodID), null indicates\n-   * that the exception was not caught in the frame where it was thrown\n-   * @param catchLoc the location of the catch (a jlocation), null indicates\n-   * that the exception was not caught in the frame where it was thrown\n-   */\n-  private ExceptionEvent(Thread thr, long throwMeth, long throwLoc,\n-\t\t                 Throwable ex, long catchMeth, long catchLoc)\n-  {\n-    this._thread = thr;\n-    this._ex = ex;\n-    this._throwMeth = throwMeth;\n-    this._throwLoc = throwLoc;\n-    this._catchMeth = catchMeth;\n-    this._catchLoc = catchLoc;\n-  }\n-  \n-  public static void postExceptionEvent(Thread thr, long throwMeth,\n-\t\t                                long throwLoc, Throwable ex,\n-\t\t                                long catchMeth, long catchLoc)\n-  {\n-    // Check to see if there is an entry for this Thread thr in the has map.\n-\t// If not, add the thread to the hash map and send an ExceptionEvent.\n-\tif (_exMap.containsKey(thr))\n-\t  {\n-\t\t// Check to see if we are receiving events for the same exception, or a\n-\t\t// new one.  If it is not the same exception beign rethrown, send a new\n-\t\t// event.\n-\t    if (!(_exMap.get(thr) == ex))\n-\t      {\n-            _exMap.put(thr, ex);\n-            ExceptionEvent event = new ExceptionEvent(thr, throwMeth,\n-            \t\t                                  throwLoc, ex, catchMeth,\n-            \t\t                                  catchLoc);  \n-            event.sendEvent ();\n-          }\n-\t  }\n-\telse\n-\t  {\n-\t    _exMap.put(thr, ex);\n-\t    ExceptionEvent event = new ExceptionEvent(thr, throwMeth,\n-                                                  throwLoc, ex, catchMeth,\n-                                                  catchLoc);\n-\t    event.sendEvent();\n-\t  }\n-  }\n-  \n-  public native void sendEvent();\n-  \n-  public native void checkCatch();\n-}"}, {"sha": "6b09c8376591b2a02bab16c62b441eaf0b297033", "filename": "libjava/include/jvmti-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finclude%2Fjvmti-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finclude%2Fjvmti-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvmti-int.h?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -89,4 +89,6 @@ extern void _Jv_JVMTI_PostEvent (jvmtiEvent type, jthread event_thread,\t\t\t\t ...)\n // Returns the jvmtiEnv used by the JDWP backend\n extern jvmtiEnv *_Jv_GetJDWP_JVMTIEnv (void);\n \n+// Reports JVMTI excpetions\n+extern void _Jv_ReportJVMTIExceptionThrow (jthrowable);\n #endif /* __GCJ_JVMTI_INT_H__ */"}, {"sha": "9be08df488b42b7d1675e466d7ea1ea0319d82c9", "filename": "libjava/interpret-run.cc", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finterpret-run.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finterpret-run.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret-run.cc?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -377,7 +377,9 @@ details.  */\n   }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-#else\n+#undef INTERP_REPORT_EXCEPTION\n+#define INTERP_REPORT_EXCEPTION(Jthrowable) REPORT_EXCEPTION (Jthrowable)\n+#else // !DEBUG\n #undef NEXT_INSN\n #define NEXT_INSN goto *((pc++)->insn)\n #define REWRITE_INSN(INSN,SLOT,VALUE)\t\t\\\n@@ -386,7 +388,10 @@ details.  */\n     pc[-1].SLOT = VALUE;\t\t\t\\\n   }\t\t\t\t\t\t\\\n   while (0)\n-#endif\n+\n+#undef INTERP_REPORT_EXCEPTION\n+#define INTERP_REPORT_EXCEPTION(Jthrowable) /* not needed when not debugging */\n+#endif // !DEBUG\n \n #define INTVAL() ((pc++)->int_val)\n #define AVAL() ((pc++)->datum)\n@@ -2355,7 +2360,11 @@ details.  */\n \t/* VM spec, section 3.11.5 */\n \tif ((klass->getModifiers() & Modifier::ABSTRACT)\n \t    || klass->isInterface())\n-\t  throw new java::lang::InstantiationException;\n+\t  {\n+\t    jthrowable t = new java::lang::InstantiationException;\n+\t    INTERP_REPORT_EXCEPTION (t);\n+\t    throw t;\n+\t  }\n \tjobject res = _Jv_AllocObject (klass);\n \tPUSHA (res);\n \n@@ -2422,7 +2431,9 @@ details.  */\n     insn_athrow:\n       {\n \tjobject value = POPA();\n-\tthrow static_cast<jthrowable>(value);\n+\tjthrowable t = static_cast<jthrowable> (value);\n+\tINTERP_REPORT_EXCEPTION (t);\n+\tthrow t;\n       }\n       NEXT_INSN;\n \n@@ -2639,38 +2650,26 @@ details.  */\n     }\n   catch (java::lang::Throwable *ex)\n     {\n-#ifdef DEBUG\n-       // This needs to be done before the pc is changed.\n-       jlong throw_loc = meth->insn_index (pc);\n-#endif\n       // Check if the exception is handled and, if so, set the pc to the start\n       // of the appropriate catch block.\n       if (meth->check_handler (&pc, meth, ex))\n         {\n           sp = stack;\n           sp++->o = ex; // Push exception.\n #ifdef DEBUG\n-          if (JVMTI_REQUESTED_EVENT (Exception))\n+          if (JVMTI_REQUESTED_EVENT (ExceptionCatch))\n             {\n               using namespace gnu::gcj::jvmti;\n-              jlong throw_meth = reinterpret_cast<jlong> (meth->get_method ());\n+              jlong catch_meth = reinterpret_cast<jlong> (meth->get_method ());\n               jlong catch_loc = meth->insn_index (pc);\n-              ExceptionEvent::postExceptionEvent (thread, throw_meth,\n-                                                  throw_loc, ex, throw_meth,\n-                                                  catch_loc);\n+\t      _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION_CATCH, thread,\n+\t\t\t\t   _Jv_GetCurrentJNIEnv (), catch_meth,\n+\t\t\t\t   catch_loc, ex);\n             }\n #endif\n           NEXT_INSN;\n         }\n-#ifdef DEBUG\n-      if (JVMTI_REQUESTED_EVENT (Exception))\n-        {\n-          using namespace gnu::gcj::jvmti;\n-          jlong throw_meth = reinterpret_cast<jlong> (meth->get_method ());\n-          ExceptionEvent::postExceptionEvent (thread, throw_meth, throw_loc,\n-                                              ex, NULL, NULL);\n-        }\n-#endif\n+\n       // No handler, so re-throw.\n       throw ex;\n     }"}, {"sha": "9209688d25216654fdfe34799cc1fd1e62b0ac88", "filename": "libjava/interpret.cc", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -40,7 +40,6 @@ details.  */\n #include <jvmti.h>\n #include \"jvmti-int.h\"\n \n-#include <gnu/classpath/jdwp/Jdwp.h>\n #include <gnu/gcj/jvmti/Breakpoint.h>\n #include <gnu/gcj/jvmti/BreakpointManager.h>\n #include <gnu/gcj/jvmti/ExceptionEvent.h>\n@@ -66,6 +65,16 @@ static void throw_class_format_error (jstring msg)\n static void throw_class_format_error (const char *msg)\n \t__attribute__ ((__noreturn__));\n \n+static void find_catch_location (jthrowable, jthread, jmethodID *, jlong *);\n+\n+// A macro to facilitate JVMTI exception reporting\n+#define REPORT_EXCEPTION(Jthrowable)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (JVMTI_REQUESTED_EVENT (Exception))\t\t\\\n+      _Jv_ReportJVMTIExceptionThrow (Jthrowable);\t\\\n+  }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n #ifdef DIRECT_THREADED\n // Lock to ensure that methods are not compiled concurrently.\n // We could use a finer-grained lock here, however it is not safe to use\n@@ -956,19 +965,25 @@ _Jv_InterpMethod::run_debug (void *retp, ffi_raw *args, _Jv_InterpMethod *meth)\n static void\n throw_internal_error (const char *msg)\n {\n-  throw new java::lang::InternalError (JvNewStringLatin1 (msg));\n+  jthrowable t = new java::lang::InternalError (JvNewStringLatin1 (msg));\n+  REPORT_EXCEPTION (t);\n+  throw t;\n }\n \n static void \n throw_incompatible_class_change_error (jstring msg)\n {\n-  throw new java::lang::IncompatibleClassChangeError (msg);\n+  jthrowable t = new java::lang::IncompatibleClassChangeError (msg);\n+  REPORT_EXCEPTION (t);\n+  throw t;\n }\n \n static void \n throw_null_pointer_exception ()\n {\n-  throw new java::lang::NullPointerException;\n+  jthrowable t = new java::lang::NullPointerException;\n+  REPORT_EXCEPTION (t);\n+  throw t;\n }\n \n /* Look up source code line number for given bytecode (or direct threaded\n@@ -1613,9 +1628,11 @@ _Jv_JNIMethod::ncode (jclass klass)\n static void\n throw_class_format_error (jstring msg)\n {\n-  throw (msg\n+  jthrowable t = (msg\n \t ? new java::lang::ClassFormatError (msg)\n \t : new java::lang::ClassFormatError);\n+  REPORT_EXCEPTION (t);\n+  throw t;\n }\n \n static void\n@@ -1624,6 +1641,70 @@ throw_class_format_error (const char *msg)\n   throw_class_format_error (JvNewStringLatin1 (msg));\n }\n \n+/* This function finds the method and location where the exception EXC\n+   is caught in the stack frame. On return, it sets CATCH_METHOD and\n+   CATCH_LOCATION with the method and location where the catch will\n+   occur. If the exception is not caught, these are set to 0.\n+\n+   This function should only be used with the DEBUG interpreter. */\n+static void\n+find_catch_location (::java::lang::Throwable *exc, jthread thread,\n+\t\t     jmethodID *catch_method, jlong *catch_loc)\n+{\n+  *catch_method = 0;\n+  *catch_loc = 0;\n+\n+  _Jv_InterpFrame *frame\n+    = reinterpret_cast<_Jv_InterpFrame *> (thread->interp_frame);\n+  while (frame != NULL)\n+    {\n+      pc_t pc = frame->get_pc ();\n+      _Jv_InterpMethod *imeth\n+\t= reinterpret_cast<_Jv_InterpMethod *> (frame->self);\n+      if (imeth->check_handler (&pc, imeth, exc))\n+\t{\n+\t  // This method handles the exception.\n+\t  *catch_method = imeth->get_method ();\n+\t  *catch_loc = imeth->insn_index (pc);\n+\t  return;\n+\t}\n+\n+      frame = frame->next_interp;\n+    }\n+}\n+\n+/* This method handles JVMTI notifications of thrown exceptions. It\n+   calls find_catch_location to figure out where the exception is\n+   caught (if it is caught).\n+   \n+   Like find_catch_location, this should only be called with the\n+   DEBUG interpreter. Since a few exceptions occur outside the\n+   interpreter proper, it is important to not call this function\n+   without checking JVMTI_REQUESTED_EVENT(Exception) first. */\n+void\n+_Jv_ReportJVMTIExceptionThrow (jthrowable ex)\n+{\n+  jthread thread = ::java::lang::Thread::currentThread ();\n+  _Jv_Frame *frame = reinterpret_cast<_Jv_Frame *> (thread->frame);\n+  jmethodID throw_meth = frame->self->get_method ();\n+  jlocation throw_loc = -1;\n+  if (frame->frame_type == frame_interpreter)\n+    {\n+      _Jv_InterpFrame * iframe\n+\t= reinterpret_cast<_Jv_InterpFrame *> (frame);\n+      _Jv_InterpMethod *imeth\n+\t= reinterpret_cast<_Jv_InterpMethod *> (frame->self);\n+      throw_loc = imeth->insn_index (iframe->get_pc ());\n+    }\n+\n+  jlong catch_loc;\n+  jmethodID catch_method;\n+  find_catch_location (ex, thread, &catch_method, &catch_loc);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION, thread,\n+\t\t       _Jv_GetCurrentJNIEnv (), throw_meth, throw_loc,\n+\t\t       ex, catch_method, catch_loc);\n+}\n+\n \f\n \n void"}, {"sha": "549d4fb06d397d46d1f04db09be2f95e1593c062", "filename": "libjava/jni.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -23,6 +23,7 @@ details.  */\n #include <jvmpi.h>\n #endif\n #include <jvmti.h>\n+#include \"jvmti-int.h\"\n \n #include <java/lang/Class.h>\n #include <java/lang/ClassLoader.h>\n@@ -456,6 +457,8 @@ _Jv_JNI_PopSystemFrame (JNIEnv *env)\n     {\n       jthrowable t = env->ex;\n       env->ex = NULL;\n+      if (JVMTI_REQUESTED_EVENT (Exception))\n+\t_Jv_ReportJVMTIExceptionThrow (t);\n       throw t;\n     }\n }"}, {"sha": "caba875f87ee7947c8d536bdf2aac5dffd379e63", "filename": "libjava/sources.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/befd756626fa71b89c1cd6563d97c968618103f4/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=befd756626fa71b89c1cd6563d97c968618103f4", "patch": "@@ -538,7 +538,6 @@ gnu/gcj/io.list: $(gnu_gcj_io_source_files)\n gnu_gcj_jvmti_source_files = \\\n gnu/gcj/jvmti/Breakpoint.java \\\n gnu/gcj/jvmti/BreakpointManager.java \\\n-gnu/gcj/jvmti/ExceptionEvent.java \\\n gnu/gcj/jvmti/Location.java\n \n gnu_gcj_jvmti_header_files = $(patsubst %.java,%.h,$(gnu_gcj_jvmti_source_files))"}]}