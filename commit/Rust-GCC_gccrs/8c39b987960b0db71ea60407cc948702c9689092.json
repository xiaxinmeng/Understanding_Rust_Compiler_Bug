{"sha": "8c39b987960b0db71ea60407cc948702c9689092", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzOWI5ODc5NjBiMGRiNzFlYTYwNDA3Y2M5NDg3MDJjOTY4OTA5Mg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-08-25T17:05:10Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-08-25T17:05:10Z"}, "message": "re PR libfortran/34670 (bounds checking for array intrinsics)\n\n2009-08-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\t* runtime/bounds.c (count_0):  New function.\n\t* intrinsics/unpack_generic (unpack_bounds):  New function.\n\t(unpack_internal):  Remove zero stride checks.\n\t(unpack1):  Use unpack_bounds.\n\t(unpack1_char):  Likeweise.\n\t(unpack1_char4):  Likewise\n\t(unpack0):  Likewise.\n\t(unpack0_char):  Likewise.\n\t(unpack0_char4):  Likewise.\n\n2009-08-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/34670\n\t* gfortran.dg/unpack_bounds_1.f90:  New test.\n\t* gfortran.dg/unpack_bounds_2.f90:  New test.\n\t* gfortran.dg/unpack_bounds_3.f90:  New test.\n\nFrom-SVN: r151085", "tree": {"sha": "f829815ebbd78c2cba3d70da5c55d9d5439b5f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f829815ebbd78c2cba3d70da5c55d9d5439b5f9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c39b987960b0db71ea60407cc948702c9689092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c39b987960b0db71ea60407cc948702c9689092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c39b987960b0db71ea60407cc948702c9689092", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c39b987960b0db71ea60407cc948702c9689092/comments", "author": null, "committer": null, "parents": [{"sha": "f76d6e6f37b2411477583ecf6f878241883ef7d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f76d6e6f37b2411477583ecf6f878241883ef7d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f76d6e6f37b2411477583ecf6f878241883ef7d0"}], "stats": {"total": 209, "additions": 200, "deletions": 9}, "files": [{"sha": "702fb685ceb53a89c12f9d6d6a1c8d8c45828408", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -1,3 +1,10 @@\n+2009-08-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\t* gfortran.dg/unpack_bounds_1.f90:  New test.\n+\t* gfortran.dg/unpack_bounds_2.f90:  New test.\n+\t* gfortran.dg/unpack_bounds_3.f90:  New test.\n+\n 2009-08-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/slice7.adb: New test."}, {"sha": "360790b570510f5ce5fd214c1407ca5df7898334", "filename": "gcc/testsuite/gfortran.dg/unpack_bounds_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_1.f90?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect extent in return value of UNPACK intrinsic in dimension 2: is 1, should be 2\" }\n+program main\n+  integer, allocatable, dimension(:) :: vector\n+  integer, allocatable, dimension(:,:) :: res\n+  logical, allocatable, dimension(:,:) :: mask\n+\n+  allocate (vector(2))\n+  allocate (mask(2,2))\n+  allocate (res(2,1))\n+\n+  vector = 1\n+  mask = reshape((/ .TRUE., .FALSE., .FALSE., .TRUE. /),(/2,2/))\n+  res = unpack(vector, mask, 0)\n+  print *,res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in return value of UNPACK intrinsic in dimension 2: is 1, should be 2\" }"}, {"sha": "fd049f5abbb90a9fa3f190667dc8d98848aa752f", "filename": "gcc/testsuite/gfortran.dg/unpack_bounds_2.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_2.f90?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect size of return value in UNPACK intrinsic: should be at least 3, is 2\" }\n+program main\n+  integer, allocatable, dimension(:) :: vector\n+  integer, allocatable, dimension(:,:) :: res\n+  logical, allocatable, dimension(:,:) :: mask\n+\n+  allocate (vector(2))\n+  allocate (mask(2,2))\n+  allocate (res(2,2))\n+\n+  vector = 1\n+  mask = reshape((/ .TRUE., .TRUE., .FALSE., .TRUE. /),(/2,2/))\n+  res = unpack(vector, mask, 0)\n+  print *,res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect size of return value in UNPACK intrinsic: should be at least 3, is 2\" }"}, {"sha": "c6734b14c1fe0e4e9b1f6f87d036583a5b06f9d9", "filename": "gcc/testsuite/gfortran.dg/unpack_bounds_3.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funpack_bounds_3.f90?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Incorrect size of return value in UNPACK intrinsic: should be at least 3, is 2\" }\n+program main\n+  integer, allocatable, dimension(:) :: vector\n+  integer, allocatable, dimension(:,:) :: res\n+  integer, allocatable, dimension(:,:) :: field\n+  logical, allocatable, dimension(:,:) :: mask\n+\n+  allocate (vector(3))\n+  allocate (mask(2,2))\n+  allocate (res(2,2))\n+  allocate (field(3,2))\n+\n+  vector = 1\n+  field = 0\n+  mask = reshape((/ .TRUE., .TRUE., .FALSE., .TRUE. /),(/2,2/))\n+  res = unpack(vector, mask, field)\n+  print *,res\n+end program main\n+! { dg-output \"Fortran runtime error: Incorrect extent in FIELD of UNPACK intrinsic in dimension 1: is 3, should be 2\" }"}, {"sha": "8ef88c0d02558d262845136fefce977c83aee762", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -1,3 +1,16 @@\n+2009-08-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/34670\n+\t* runtime/bounds.c (count_0):  New function.\n+\t* intrinsics/unpack_generic (unpack_bounds):  New function.\n+\t(unpack_internal):  Remove zero stride checks.\n+\t(unpack1):  Use unpack_bounds.\n+\t(unpack1_char):  Likeweise.\n+\t(unpack1_char4):  Likewise\n+\t(unpack0):  Likewise.\n+\t(unpack0_char):  Likewise.\n+\t(unpack0_char4):  Likewise.\n+\n 2009-08-24  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/41157"}, {"sha": "4a4c2192e9d49fef0c2fa07ce5396a6ebda95971", "filename": "libgfortran/intrinsics/unpack_generic.c", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Fintrinsics%2Funpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Fintrinsics%2Funpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Funpack_generic.c?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -28,6 +28,32 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <assert.h>\n #include <string.h>\n \n+/* All the bounds checking for unpack in one function.  If field is NULL,\n+   we don't check it, for the unpack0 functions.  */\n+\n+static void\n+unpack_bounds (gfc_array_char *ret, const gfc_array_char *vector,\n+\t const gfc_array_l1 *mask, const gfc_array_char *field)\n+{\n+  index_type vec_size, mask_count;\n+  vec_size = size0 ((array_t *) vector);\n+  mask_count = count_0 (mask);\n+  if (vec_size < mask_count)\n+    runtime_error (\"Incorrect size of return value in UNPACK\"\n+\t\t   \" intrinsic: should be at least %ld, is\"\n+\t\t   \" %ld\", (long int) mask_count,\n+\t\t   (long int) vec_size);\n+\n+  if (field != NULL)\n+    bounds_equal_extents ((array_t *) field, (array_t *) mask,\n+\t\t\t  \"FIELD\", \"UNPACK\");\n+\n+  if (ret->data != NULL)\n+    bounds_equal_extents ((array_t *) ret, (array_t *) mask,\n+\t\t\t  \"return value\", \"UNPACK\");\n+\n+}\n+\n static void\n unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n \t\t const gfc_array_l1 *mask, const gfc_array_char *field,\n@@ -113,21 +139,12 @@ unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n \t  fstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(field, n);\n \t  mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n);\n \t}\n-      if (rstride[0] == 0)\n-\trstride[0] = size;\n     }\n \n   if (empty)\n     return;\n \n-  if (fstride[0] == 0)\n-    fstride[0] = fsize;\n-  if (mstride[0] == 0)\n-    mstride[0] = 1;\n-\n   vstride0 = GFC_DESCRIPTOR_STRIDE_BYTES(vector,0);\n-  if (vstride0 == 0)\n-    vstride0 = size;\n   rstride0 = rstride[0];\n   fstride0 = fstride[0];\n   mstride0 = mstride[0];\n@@ -193,6 +210,9 @@ unpack1 (gfc_array_char *ret, const gfc_array_char *vector,\n   index_type type_size;\n   index_type size;\n \n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, field);\n+\n   type_size = GFC_DTYPE_TYPE_SIZE (vector);\n   size = GFC_DESCRIPTOR_SIZE (vector);\n \n@@ -343,6 +363,10 @@ unpack1_char (gfc_array_char *ret,\n \t      const gfc_array_char *field, GFC_INTEGER_4 vector_length,\n \t      GFC_INTEGER_4 field_length)\n {\n+\n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, field);\n+\n   unpack_internal (ret, vector, mask, field, vector_length, field_length);\n }\n \n@@ -360,6 +384,10 @@ unpack1_char4 (gfc_array_char *ret,\n \t       const gfc_array_char *field, GFC_INTEGER_4 vector_length,\n \t       GFC_INTEGER_4 field_length)\n {\n+\n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, field);\n+\n   unpack_internal (ret, vector, mask, field,\n \t\t   vector_length * sizeof (gfc_char4_t),\n \t\t   field_length * sizeof (gfc_char4_t));\n@@ -379,6 +407,9 @@ unpack0 (gfc_array_char *ret, const gfc_array_char *vector,\n   index_type type_size;\n   index_type size;\n \n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, NULL);\n+\n   type_size = GFC_DTYPE_TYPE_SIZE (vector);\n   size = GFC_DESCRIPTOR_SIZE (vector);\n \n@@ -530,6 +561,9 @@ unpack0_char (gfc_array_char *ret,\n {\n   gfc_array_char tmp;\n \n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, NULL);\n+\n   memset (&tmp, 0, sizeof (tmp));\n   tmp.dtype = 0;\n   tmp.data = field;\n@@ -551,6 +585,9 @@ unpack0_char4 (gfc_array_char *ret,\n {\n   gfc_array_char tmp;\n \n+  if (unlikely(compile_options.bounds_check))\n+    unpack_bounds (ret, vector, mask, NULL);\n+\n   memset (&tmp, 0, sizeof (tmp));\n   tmp.dtype = 0;\n   tmp.data = field;"}, {"sha": "40cb080a78c1fa355c9ea0027d9cc30f92f9a06f", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -1282,6 +1282,10 @@ extern void bounds_ifunction_return (array_t *, const index_type *,\n \t\t\t\t     const char *, const char *);\n internal_proto(bounds_ifunction_return);\n \n+extern index_type count_0 (const gfc_array_l1 *);\n+\n+internal_proto(count_0);\n+\n /* Internal auxiliary functions for cshift */\n \n void cshift0_i1 (gfc_array_i1 *, const gfc_array_i1 *, ssize_t, int);"}, {"sha": "2d2ed76e6b833b48665b42b6e1129b238d91b426", "filename": "libgfortran/runtime/bounds.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Fruntime%2Fbounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c39b987960b0db71ea60407cc948702c9689092/libgfortran%2Fruntime%2Fbounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbounds.c?ref=8c39b987960b0db71ea60407cc948702c9689092", "patch": "@@ -197,3 +197,76 @@ bounds_reduced_extents (array_t *a, array_t *b, int which, const char *a_name,\n \t}\n     }\n }\n+\n+/* count_0 - count all the true elements in an array.  The front\n+   end usually inlines this, we need this for bounds checking\n+   for unpack.  */\n+\n+index_type count_0 (const gfc_array_l1 * array)\n+{\n+  const GFC_LOGICAL_1 * restrict base;\n+  index_type rank;\n+  int kind;\n+  int continue_loop;\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type result;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  kind = GFC_DESCRIPTOR_SIZE (array);\n+\n+  base = array->data;\n+\n+  if (kind == 1 || kind == 2 || kind == 4 || kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || kind == 16\n+#endif\n+    )\n+    {\n+      if (base)\n+\tbase = GFOR_POINTER_TO_L1 (base, kind);\n+    }\n+  else\n+    internal_error (NULL, \"Funny sized logical array in count_0\");\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+\n+      if (extent[n] < 0)\n+\treturn 0;\n+    }\n+\n+  result = 0;\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      if (*base)\n+\tresult ++;\n+\n+      count[0]++;\n+      base += sstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n == rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+    }\n+  return result;\n+}"}]}