{"sha": "992c31e62304ed5d34247dbdef2db276d08fac05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkyYzMxZTYyMzA0ZWQ1ZDM0MjQ3ZGJkZWYyZGIyNzZkMDhmYWMwNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-11-11T16:13:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-11T16:13:09Z"}, "message": "* predict.c (predict_loops): Kill RTL variant.\n\nFrom-SVN: r118694", "tree": {"sha": "bbdbf1ae0477844fd089677fc5179f0bef0aa1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbdbf1ae0477844fd089677fc5179f0bef0aa1ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/992c31e62304ed5d34247dbdef2db276d08fac05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992c31e62304ed5d34247dbdef2db276d08fac05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/992c31e62304ed5d34247dbdef2db276d08fac05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/992c31e62304ed5d34247dbdef2db276d08fac05/comments", "author": null, "committer": null, "parents": [{"sha": "6039a0c74a90a4a344e2c000115acfa46293ef8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6039a0c74a90a4a344e2c000115acfa46293ef8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6039a0c74a90a4a344e2c000115acfa46293ef8f"}], "stats": {"total": 96, "additions": 32, "deletions": 64}, "files": [{"sha": "37922a1ff5d016c585ec31723336deaa292079b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992c31e62304ed5d34247dbdef2db276d08fac05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992c31e62304ed5d34247dbdef2db276d08fac05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=992c31e62304ed5d34247dbdef2db276d08fac05", "patch": "@@ -1,3 +1,7 @@\n+2006-11-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* predict.c (predict_loops): Kill RTL variant.\n+\n 2006-11-11  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-pass.h (pass_purge_lineno_notes): Remove declaration.\n@@ -98,7 +102,7 @@\n \t* local-alloc.c (update_equiv_regs): Copy the memory RTX to be used\n \tin REG_EQUIV notes.\n \t* gcse.c (try_replace_reg): Copy the replacement.\n-\t* i386.c (emit_i387_cw_initialization): Copy stored_mode\n+\t* i386.c (emit_i387_cw_initialization): Copy stored_mode.\n \t(assign_386_stack_local): Always return copied memory expression\n \t* function.c (instantiate_virtual_regs_in_insn): Copy the operand\n \tduplicates."}, {"sha": "966132293c550692edb9811ab57e41941beb6c94", "filename": "gcc/predict.c", "status": "modified", "additions": 27, "deletions": 63, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/992c31e62304ed5d34247dbdef2db276d08fac05/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/992c31e62304ed5d34247dbdef2db276d08fac05/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=992c31e62304ed5d34247dbdef2db276d08fac05", "patch": "@@ -631,12 +631,11 @@ combine_predictions_for_bb (basic_block bb)\n    When RTLSIMPLELOOPS is set, attempt to count number of iterations by analyzing\n    RTL otherwise use tree based approach.  */\n static void\n-predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n+predict_loops (struct loops *loops_info)\n {\n   unsigned i;\n \n-  if (!rtlsimpleloops)\n-    scev_initialize (loops_info);\n+  scev_initialize (loops_info);\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n@@ -646,69 +645,38 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n       unsigned j;\n       unsigned n_exits;\n       struct loop *loop = loops_info->parray[i];\n-      struct niter_desc desc;\n-      unsigned HOST_WIDE_INT niter;\n       edge *exits;\n+      struct tree_niter_desc niter_desc;\n \n       exits = get_loop_exit_edges (loop, &n_exits);\n \n-      if (rtlsimpleloops)\n-\t{\n-\t  iv_analysis_loop_init (loop);\n-\t  find_simple_exit (loop, &desc);\n \n-\t  if (desc.simple_p && desc.const_iter)\n-\t    {\n-\t      int prob;\n-\t      niter = desc.niter + 1;\n-\t      if (niter == 0)        /* We might overflow here.  */\n-\t\tniter = desc.niter;\n-\t      if (niter\n-\t\t  > (unsigned int) PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS))\n-\t\tniter = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n-\n-\t      prob = (REG_BR_PROB_BASE\n-\t\t      - (REG_BR_PROB_BASE + niter /2) / niter);\n-\t      /* Branch prediction algorithm gives 0 frequency for everything\n-\t\t after the end of loop for loop having 0 probability to finish.  */\n-\t      if (prob == REG_BR_PROB_BASE)\n-\t\tprob = REG_BR_PROB_BASE - 1;\n-\t      predict_edge (desc.in_edge, PRED_LOOP_ITERATIONS,\n-\t\t\t    prob);\n-\t    }\n-\t}\n-      else\n+      for (j = 0; j < n_exits; j++)\n \t{\n-\t  struct tree_niter_desc niter_desc;\n-\n-\t  for (j = 0; j < n_exits; j++)\n-\t    {\n-\t      tree niter = NULL;\n+\t  tree niter = NULL;\n \n-\t      if (number_of_iterations_exit (loop, exits[j], &niter_desc, false))\n-\t\tniter = niter_desc.niter;\n-\t      if (!niter || TREE_CODE (niter_desc.niter) != INTEGER_CST)\n-\t        niter = loop_niter_by_eval (loop, exits[j]);\n+\t  if (number_of_iterations_exit (loop, exits[j], &niter_desc, false))\n+\t    niter = niter_desc.niter;\n+\t  if (!niter || TREE_CODE (niter_desc.niter) != INTEGER_CST)\n+\t    niter = loop_niter_by_eval (loop, exits[j]);\n \n-\t      if (TREE_CODE (niter) == INTEGER_CST)\n+\t  if (TREE_CODE (niter) == INTEGER_CST)\n+\t    {\n+\t      int probability;\n+\t      int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n+\t      if (host_integerp (niter, 1)\n+\t\t  && tree_int_cst_lt (niter,\n+\t\t\t\t      build_int_cstu (NULL_TREE, max - 1)))\n \t\t{\n-\t\t  int probability;\n-\t\t  int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n-\t\t  if (host_integerp (niter, 1)\n-\t\t      && tree_int_cst_lt (niter,\n-\t\t\t\t          build_int_cstu (NULL_TREE, max - 1)))\n-\t\t    {\n-\t\t      HOST_WIDE_INT nitercst = tree_low_cst (niter, 1) + 1;\n-\t\t      probability = ((REG_BR_PROB_BASE + nitercst / 2)\n-\t\t\t\t     / nitercst);\n-\t\t    }\n-\t\t  else\n-\t\t    probability = ((REG_BR_PROB_BASE + max / 2) / max);\n-\n-\t\t  predict_edge (exits[j], PRED_LOOP_ITERATIONS, probability);\n+\t\t  HOST_WIDE_INT nitercst = tree_low_cst (niter, 1) + 1;\n+\t\t  probability = ((REG_BR_PROB_BASE + nitercst / 2)\n+\t\t\t\t / nitercst);\n \t\t}\n-\t    }\n+\t      else\n+\t\tprobability = ((REG_BR_PROB_BASE + max / 2) / max);\n \n+\t      predict_edge (exits[j], PRED_LOOP_ITERATIONS, probability);\n+\t    }\n \t}\n       free (exits);\n \n@@ -726,8 +694,7 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n \t     statements construct loops via \"non-loop\" constructs\n \t     in the source language and are better to be handled\n \t     separately.  */\n-\t  if ((rtlsimpleloops && !can_predict_insn_p (BB_END (bb)))\n-\t      || predicted_by_p (bb, PRED_CONTINUE))\n+\t  if (predicted_by_p (bb, PRED_CONTINUE))\n \t    continue;\n \n \t  /* Loop branch heuristics - predict an edge back to a\n@@ -776,11 +743,8 @@ predict_loops (struct loops *loops_info, bool rtlsimpleloops)\n       free (bbs);\n     }\n \n-  if (!rtlsimpleloops)\n-    {\n-      scev_finalize ();\n-      current_loops = NULL;\n-    }\n+  scev_finalize ();\n+  current_loops = NULL;\n }\n \n /* Attempt to predict probabilities of BB outgoing edges using local\n@@ -1303,7 +1267,7 @@ tree_estimate_probability (void)\n   tree_bb_level_predictions ();\n \n   mark_irreducible_loops (&loops_info);\n-  predict_loops (&loops_info, false);\n+  predict_loops (&loops_info);\n \n   FOR_EACH_BB (bb)\n     {"}]}