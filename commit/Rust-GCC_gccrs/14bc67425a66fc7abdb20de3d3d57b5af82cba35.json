{"sha": "14bc67425a66fc7abdb20de3d3d57b5af82cba35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiYzY3NDI1YTY2ZmM3YWJkYjIwZGUzZDNkNTdiNWFmODJjYmEzNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-11T08:15:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-11T08:15:34Z"}, "message": "lib1.asm: Fix comment formatting.\n\n\t* config/mcore/lib1.asm: Fix comment formatting.\n\t* config/mcore/mcore-elf.h: Likewise.\n\t* config/mcore/mcore.c: Likewise.\n\t* config/mcore/mcore.h: Likewise.\n\t* config/mcore/mcore.md: Likewise.\n\nFrom-SVN: r75668", "tree": {"sha": "57d7d129dc85190ec464a9b370cd8384b61c2edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57d7d129dc85190ec464a9b370cd8384b61c2edc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14bc67425a66fc7abdb20de3d3d57b5af82cba35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14bc67425a66fc7abdb20de3d3d57b5af82cba35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14bc67425a66fc7abdb20de3d3d57b5af82cba35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14bc67425a66fc7abdb20de3d3d57b5af82cba35/comments", "author": null, "committer": null, "parents": [{"sha": "3c6e6fbf11745d2c583c15a18f53f63cd889d301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c6e6fbf11745d2c583c15a18f53f63cd889d301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c6e6fbf11745d2c583c15a18f53f63cd889d301"}], "stats": {"total": 72, "additions": 40, "deletions": 32}, "files": [{"sha": "0f1a8f50ff30e6875cc521486be5407f9b530b0a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -1,3 +1,11 @@\n+2004-01-11  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/mcore/lib1.asm: Fix comment formatting.\n+\t* config/mcore/mcore-elf.h: Likewise.\n+\t* config/mcore/mcore.c: Likewise.\n+\t* config/mcore/mcore.h: Likewise.\n+\t* config/mcore/mcore.md: Likewise.\n+\n 2004-01-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* c-decl.c (duplicate_decls): Break apart into..."}, {"sha": "3eca5abbd97aed8e280e78568b88530f923e969a", "filename": "gcc/config/mcore/lib1.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Flib1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Flib1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Flib1.asm?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -241,7 +241,7 @@ FUNC_END modsi3\n    jump on to __cmpdf2 and __cmpsf2.\n  \n    All of these shortcircuit the return path so that __cmp{sd}f2\n-   will go directly back to the caller. */\n+   will go directly back to the caller.  */\n \n .macro  COMPARE_DF_JUMP name\n \t.import SYM (cmpdf2)"}, {"sha": "2234e7d1957e466ddafe4714a431923a53a9cf9e", "filename": "gcc/config/mcore/mcore-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -139,7 +139,7 @@ exports_section ()\t\t\t\t\t\t\\\n #define ENDFILE_SPEC  \"%{!mno-lsim:-lsim} crtend.o%s crtn.o%s\"\n \n /* The subroutine calls in the .init and .fini sections create literal\n-   pools which must be jumped around...  */\n+   pools which must be jumped around....  */\n #define FORCE_CODE_SECTION_ALIGN\tasm (\"br 1f ; .literals ; 1:\");\n \n #undef  CTORS_SECTION_ASM_OP"}, {"sha": "53ceea3d55430907a3ffca28ba1196905b6d7694", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -582,7 +582,7 @@ mcore_gen_compare_reg (enum rtx_code code)\n       code = LEU;\n       /* Drop through.  */\n       \n-    case LEU:\t/* Use normal condition, reversed cmphs. */\n+    case LEU:\t/* Use normal condition, reversed cmphs.  */\n       if (GET_CODE (op1) == CONST_INT && INTVAL (op1) != 0)\n \top1 = force_reg (SImode, op1);\n       break;\n@@ -681,7 +681,7 @@ const_ok_for_mcore (int value)\n   if ((value & (value - 1)) == 0)\n     return 1;\n   \n-  /* Try exact power of two - 1. */\n+  /* Try exact power of two - 1.  */\n   if ((value & (value + 1)) == 0)\n     return 1;\n   \n@@ -1383,7 +1383,7 @@ mcore_general_movsrc_operand (rtx op, enum machine_mode mode)\n   return general_operand (op, mode);\n }\n \n-/* Nonzero if OP can be destination of a simple move operation. */\n+/* Nonzero if OP can be destination of a simple move operation.  */\n \n int\n mcore_general_movdst_operand (rtx op, enum machine_mode mode)\n@@ -1961,7 +1961,7 @@ layout_mcore_frame (struct mcore_frame * infp)\n   infp->reg_mask = calc_live_regs (& n);\n   infp->reg_size = n * 4;\n \n-  /* And the rest of it... locals and space for overflowed outbounds. */\n+  /* And the rest of it... locals and space for overflowed outbounds.  */\n   infp->local_size = get_frame_size ();\n   infp->outbound_size = current_function_outgoing_args_size;\n \n@@ -2570,7 +2570,7 @@ is_cond_candidate (rtx insn)\n                GET_MODE (XEXP (src, 0)) == SImode)\n \treturn COND_DEC_INSN;\n \n-      /* some insns that we don't bother with:\n+      /* Some insns that we don't bother with:\n \t (set (rx:DI) (ry:DI))\n \t (set (rx:DI) (const_int 0))\n       */            \n@@ -2757,7 +2757,7 @@ conditionalize_block (rtx first)\n       \n       code = GET_CODE (insn);\n \n-      /* Look for the label at the start of block 3. */\n+      /* Look for the label at the start of block 3.  */\n       if (code == CODE_LABEL && CODE_LABEL_NUMBER (insn) == br_lab_num)\n \tbreak;\n \n@@ -2805,7 +2805,7 @@ conditionalize_block (rtx first)\n       if (INSN_DELETED_P (insn))\n \tcontinue;\n       \n-      /* Try to form a conditional variant of the instruction and emit it. */\n+      /* Try to form a conditional variant of the instruction and emit it.  */\n       if ((newinsn = emit_new_cond_insn (insn, cond)))\n \t{\n \t  if (end_blk_2_insn == insn)\n@@ -2945,7 +2945,7 @@ mcore_reload_class (rtx x, enum reg_class class)\n int\n mcore_is_same_reg (rtx x, rtx y)\n {\n-  /* Strip any and all of the subreg wrappers. */\n+  /* Strip any and all of the subreg wrappers.  */\n   while (GET_CODE (x) == SUBREG)\n     x = SUBREG_REG (x);\n   \n@@ -3288,7 +3288,7 @@ mcore_dllimport_p (tree decl)\n }\n \n /* We must mark dll symbols specially.  Definitions of dllexport'd objects\n-   install some info in the .drective (PE) or .exports (ELF) sections.   */\n+   install some info in the .drective (PE) or .exports (ELF) sections.  */\n \n static void\n mcore_encode_section_info (tree decl, rtx rtl ATTRIBUTE_UNUSED, int first ATTRIBUTE_UNUSED)"}, {"sha": "b19104f9cf17f80698ea95ce7795eaf8fb84284c", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -367,7 +367,7 @@ extern int mcore_stack_increment;\n    Aside from that, you can include as many other registers as you like.  */\n \n /* RBE: r15 {link register} not available across calls,\n-   But we don't mark it that way here...  */\n+   But we don't mark it that way here....  */\n #define CALL_USED_REGISTERS \\\n  /*  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15 ap  c   fp x19 */ \\\n    { 1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1, 1}\n@@ -474,7 +474,7 @@ enum reg_class\n \n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n #define REG_CLASS_NAMES  \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n@@ -959,7 +959,7 @@ extern const enum reg_class reg_class_from_letter[];\n    shouldn't be put through pseudo regs where they can be cse'd.\n    Desirable on machines where ordinary constants are expensive\n    but a CALL with constant address is cheap.  */\n-/* why is this defined??? -- dac */\n+/* Why is this defined??? -- dac */\n #define NO_FUNCTION_CSE 1\n \n /* Chars and shorts should be passed as ints.  */\n@@ -1177,7 +1177,7 @@ extern long mcore_current_compilation_timestamp;\n \n \n /* This says how to output an assembler line\n-   to define a local common symbol...  */\n+   to define a local common symbol....  */\n #undef  ASM_OUTPUT_LOCAL\n #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n   (fputs (\"\\t.lcomm\\t\", FILE),\t\t\t\t\\"}, {"sha": "e1e598b7ddd80693c44dbcc7cc70e0b6fac1e8e2", "filename": "gcc/config/mcore/mcore.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14bc67425a66fc7abdb20de3d3d57b5af82cba35/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=14bc67425a66fc7abdb20de3d3d57b5af82cba35", "patch": "@@ -2650,8 +2650,8 @@\n {\n   if (INTVAL (operands[2]) == 8 && INTVAL (operands[3]) % 8 == 0)\n     {\n-       /* 8 bit field, aligned properly, use the xtrb[0123]+sext sequence */\n-       /* not DONE, not FAIL, but let the RTL get generated... */\n+       /* 8 bit field, aligned properly, use the xtrb[0123]+sext sequence.  */\n+       /* not DONE, not FAIL, but let the RTL get generated....  */\n     }\n   else if (TARGET_W_FIELD)\n     {\n@@ -2671,7 +2671,7 @@\n     }\n   else\n     {\n-      /* let the caller choose an alternate sequence */\n+      /* Let the caller choose an alternate sequence.  */\n       FAIL;\n     }\n }\")\n@@ -2687,14 +2687,14 @@\n {\n   if (INTVAL (operands[2]) == 8 && INTVAL (operands[3]) % 8 == 0)\n     {\n-       /* 8 bit field, aligned properly, use the xtrb[0123] sequence */\n-       /* let the template generate some RTL.... */\n+       /* 8 bit field, aligned properly, use the xtrb[0123] sequence.  */\n+       /* Let the template generate some RTL....  */\n     }\n   else if (CONST_OK_FOR_K ((1 << INTVAL (operands[2])) - 1))\n     {\n       /* A narrow bit-field (<=5 bits) means we can do a shift to put\n          it in place and then use an andi to extract it.\n-         This is as good as a shiftleft/shiftright. */\n+         This is as good as a shiftleft/shiftright.  */\n \n       rtx shifted;\n       rtx mask = GEN_INT ((1 << INTVAL (operands[2])) - 1);\n@@ -2829,7 +2829,7 @@\n   \"xtrb2\t%0,%1\"\n   [(set_attr \"type\" \"shift\")])\n \n-;; this can be peepholed if it follows a ldb ...\n+;; This can be peepholed if it follows a ldb ...\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"=r,b\")\n \t(zero_extract:SI (match_operand:SI 1 \"mcore_arith_reg_operand\" \"0,r\") (const_int 8) (const_int 0)))]\n@@ -3006,7 +3006,7 @@\n     output_asm_insn (\\\"mov\\\\t%2,%3\\\", operands);\n   return mcore_output_bclri (operands[2], INTVAL (operands[1]) | 0xffffff00);\")\n \n-/* do not fold these together -- mode is lost at final output phase */\n+/* Do not fold these together -- mode is lost at final output phase.  */\n \n (define_peephole\n   [(set (match_operand:SI 0 \"mcore_arith_reg_operand\" \"\")\n@@ -3263,21 +3263,21 @@\n   \"\"\n   \"\n {\n-  /* if he wants no probing, just do it for him. */\n+  /* If he wants no probing, just do it for him.  */\n   if (mcore_stack_increment == 0)\n     {\n       emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,operands[1]));\n ;;      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n       DONE;\n     }\n \n-  /* for small constant growth, we unroll the code */\n+  /* For small constant growth, we unroll the code.  */\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) < 8 * STACK_UNITS_MAXSTEP)\n     {\n       int left = INTVAL(operands[1]);\n \n-      /* if it's a long way, get close enough for a last shot */\n+      /* If it's a long way, get close enough for a last shot.  */\n       if (left >= STACK_UNITS_MAXSTEP)\n \t{\n \t  rtx tmp = gen_reg_rtx (Pmode);\n@@ -3293,7 +3293,7 @@\n \t    }\n \t  while (left > STACK_UNITS_MAXSTEP);\n \t}\n-      /* performs the final adjustment */\n+      /* Perform the final adjustment.  */\n       emit_insn (gen_addsi3 (stack_pointer_rtx,stack_pointer_rtx,GEN_INT(-left)));\n ;;      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n       DONE;\n@@ -3317,30 +3317,30 @@\n \t  emit_jump_insn (gen_bgeu (out_label));\n \t}\n \n-      /* run a loop that steps it incrementally */\n+      /* Run a loop that steps it incrementally.  */\n       emit_label (loop_label);\n \n-      /* extend a step, probe, and adjust remaining count */\n+      /* Extend a step, probe, and adjust remaining count.  */\n       emit_insn(gen_subsi3(stack_pointer_rtx, stack_pointer_rtx, step));\n       memref = gen_rtx (MEM, SImode, stack_pointer_rtx);\n       MEM_VOLATILE_P (memref) = 1;\n       emit_insn(gen_movsi(memref, stack_pointer_rtx));\n       emit_insn(gen_subsi3(tmp, tmp, step));\n \n-      /* loop condition -- going back up */\n+      /* Loop condition -- going back up.  */\n       emit_insn (gen_cmpsi (step, tmp));\n       emit_jump_insn (gen_bltu (loop_label));\n \n       if (out_label)\n \temit_label (out_label);\n \n-      /* bump the residual */\n+      /* Bump the residual.  */\n       emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n ;;      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n       DONE;\n #else\n       /* simple one-shot -- ensure register and do a subtract.\n-       * this does NOT comply with the ABI. */\n+       * This does NOT comply with the ABI.  */\n       emit_insn (gen_movsi (tmp, operands[1]));\n       emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, tmp));\n ;;      emit_move_insn (operands[0], virtual_stack_dynamic_rtx);"}]}