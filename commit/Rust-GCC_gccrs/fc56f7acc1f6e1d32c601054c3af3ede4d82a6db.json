{"sha": "fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM1NmY3YWNjMWY2ZTFkMzJjNjAxMDU0YzNhZjNlZGU0ZDgyYTZkYg==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-26T19:59:56Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-26T19:59:56Z"}, "message": "[multiple changes]\n\n2003-09-26  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/image/SinglePixelPackedSampleModel.java (createDataBuffer):\n\tSave space for some pixels at the buffer end.  Added Javadoc.\n\n2003-09-26  Tom Tromey  <tromey@redhat.com>\n\n\t* java/io/ObjectOutputStream.java (writeFields): Fixed\n\tindentation.\n\t(putFields): Likewise.\n\nFrom-SVN: r71829", "tree": {"sha": "8052669bcc18adae7ef9f0eb86a5e740e8fd05b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8052669bcc18adae7ef9f0eb86a5e740e8fd05b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/comments", "author": null, "committer": null, "parents": [{"sha": "8aa43dd09b78afbb4b2c7b08f7f4b3f1fe68517e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa43dd09b78afbb4b2c7b08f7f4b3f1fe68517e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa43dd09b78afbb4b2c7b08f7f4b3f1fe68517e"}], "stats": {"total": 303, "additions": 162, "deletions": 141}, "files": [{"sha": "a3ebdb33c48298308b5b377edabc08f10474881b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "patch": "@@ -1,3 +1,14 @@\n+2003-09-26  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/image/SinglePixelPackedSampleModel.java (createDataBuffer): \n+\tSave space for some pixels at the buffer end.  Added Javadoc.\n+\n+2003-09-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/ObjectOutputStream.java (writeFields): Fixed\n+\tindentation.\n+\t(putFields): Likewise.\n+\n 2003-09-26  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/ByteBufferHelper.java:"}, {"sha": "e67353c46151fa4869ed20a4e6342c2b6b448f55", "filename": "libjava/java/awt/image/SinglePixelPackedSampleModel.java", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FSinglePixelPackedSampleModel.java?ref=fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000, 2002  Free Software Foundation\n+/* Copyright (C) 2000, 2002, 2003  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -88,13 +88,25 @@ public SampleModel createCompatibleSampleModel(int w, int h)\n     return new SinglePixelPackedSampleModel(dataType, w, h, bitMasks);\n   }\n \n+\n+  /**\n+   * Creates a DataBuffer for holding pixel data in the format and\n+   * layout described by this SampleModel. The returned buffer will\n+   * consist of one single bank.\n+   */\n   public DataBuffer createDataBuffer()\n   {\n-    // Important: use scanlineStride here, not width!\n-    int size = scanlineStride*height;\n+    int size;\n+\n+    // We can save (scanlineStride - width) pixels at the very end of\n+    // the buffer. The Sun reference implementation (J2SE 1.3.1 and\n+    // 1.4.1_01) seems to do this; tested with Mauve test code.\n+    size = scanlineStride * (height - 1) + width;\n+\n     return Buffers.createBuffer(getDataType(), size);\n   }\n \n+\n   public int[] getSampleSize()\n   {\n     return sampleSize;"}, {"sha": "f79ac3e4d8a590969456cac9b40d447be0be2ab8", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 136, "deletions": 138, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc56f7acc1f6e1d32c601054c3af3ede4d82a6db/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=fc56f7acc1f6e1d32c601054c3af3ede4d82a6db", "patch": "@@ -868,140 +868,139 @@ public PutField putFields () throws IOException\n   {\n     if (currentPutField == null)\n       {\n-    currentPutField = new PutField ()\n-      {\n-\tprivate byte[] prim_field_data\n-\t= new byte[currentObjectStreamClass.primFieldSize];\n-\tprivate Object[] objs\n-\t= new Object[currentObjectStreamClass.objectFieldCount];\n-\n-\tpublic void put (String name, boolean value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'Z');\n-\t  prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n-\t}\n-\n-\tpublic void put (String name, byte value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'B');\n-\t  prim_field_data[field.getOffset ()] = value;\n-\t}\n-\n-\tpublic void put (String name, char value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'C');\n-\t  int off = field.getOffset ();\n-\t  prim_field_data[off++] = (byte)(value >>> 8);\n-\t  prim_field_data[off] = (byte)value;\n-\t}\n-\n-\tpublic void put (String name, double value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'D');\n-\t  int off = field.getOffset ();\n-\t  long l_value = Double.doubleToLongBits (value);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 52);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 48);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 40);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 32);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 24);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 16);\n-\t  prim_field_data[off++] = (byte)(l_value >>> 8);\n-\t  prim_field_data[off] = (byte)l_value;\n-\t}\n-\n-\tpublic void put (String name, float value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'F');\n-\t  int off = field.getOffset ();\n-\t  int i_value = Float.floatToIntBits (value);\n-\t  prim_field_data[off++] = (byte)(i_value >>> 24);\n-\t  prim_field_data[off++] = (byte)(i_value >>> 16);\n-\t  prim_field_data[off++] = (byte)(i_value >>> 8);\n-\t  prim_field_data[off] = (byte)i_value;\n-\t}\n-\n-\tpublic void put (String name, int value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'I');\n-\t  int off = field.getOffset ();\n-\t  prim_field_data[off++] = (byte)(value >>> 24);\n-\t  prim_field_data[off++] = (byte)(value >>> 16);\n-\t  prim_field_data[off++] = (byte)(value >>> 8);\n-\t  prim_field_data[off] = (byte)value;\n-\t}\n-\n-\tpublic void put (String name, long value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'J');\n-\t  int off = field.getOffset ();\n-\t  prim_field_data[off++] = (byte)(value >>> 52);\n-\t  prim_field_data[off++] = (byte)(value >>> 48);\n-\t  prim_field_data[off++] = (byte)(value >>> 40);\n-\t  prim_field_data[off++] = (byte)(value >>> 32);\n-\t  prim_field_data[off++] = (byte)(value >>> 24);\n-\t  prim_field_data[off++] = (byte)(value >>> 16);\n-\t  prim_field_data[off++] = (byte)(value >>> 8);\n-\t  prim_field_data[off] = (byte)value;\n-\t}\n-\n-\tpublic void put (String name, short value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  checkType (field, 'S');\n-\t  int off = field.getOffset ();\n-\t  prim_field_data[off++] = (byte)(value >>> 8);\n-\t  prim_field_data[off] = (byte)value;\n-\t}\n-\n-\tpublic void put (String name, Object value)\n-\t{\n-\t  ObjectStreamField field\n-\t    = currentObjectStreamClass.getField (name);\n-\t  if (field == null)\n-\t    throw new IllegalArgumentException ();\n-\t  if (value != null &&\n-\t      ! field.getType ().isAssignableFrom (value.getClass ()))\n-\t    throw new IllegalArgumentException ();\n-\t  objs[field.getOffset ()] = value;\n-\t}\n-\n-\tpublic void write (ObjectOutput out) throws IOException\n-\t{\n-\t  // Apparently Block data is not used with PutField as per\n-\t  // empirical evidence against JDK 1.2.  Also see Mauve test\n-\t  // java.io.ObjectInputOutput.Test.GetPutField.\n-\t  boolean oldmode = setBlockDataMode (false);\n-\t  out.write (prim_field_data);\n-\t  for (int i = 0; i < objs.length; ++ i)\n-\t    out.writeObject (objs[i]);\n-\t  setBlockDataMode (oldmode);\n-\t}\n-\n-\tprivate void checkType (ObjectStreamField field, char type)\n-\t  throws IllegalArgumentException\n-\t{\n-\t  if (TypeSignature.getEncodingOfClass (field.getType ()).charAt (0)\n-\t      != type)\n-\t    throw new IllegalArgumentException ();\n-\t}\n-      };\n-    // end PutFieldImpl\n+\tcurrentPutField = new PutField ()\n+\t  {\n+\t    private byte[] prim_field_data =\n+\t      new byte[currentObjectStreamClass.primFieldSize];\n+\t    private Object[] objs =\n+\t      new Object[currentObjectStreamClass.objectFieldCount];\n+\n+\t    public void put (String name, boolean value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'Z');\n+\t      prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n+\t    }\n+\n+\t    public void put (String name, byte value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'B');\n+\t      prim_field_data[field.getOffset ()] = value;\n+\t    }\n+\n+\t    public void put (String name, char value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'C');\n+\t      int off = field.getOffset ();\n+\t      prim_field_data[off++] = (byte)(value >>> 8);\n+\t      prim_field_data[off] = (byte)value;\n+\t    }\n+\n+\t    public void put (String name, double value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'D');\n+\t      int off = field.getOffset ();\n+\t      long l_value = Double.doubleToLongBits (value);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 52);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 48);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 40);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 32);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 24);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 16);\n+\t      prim_field_data[off++] = (byte)(l_value >>> 8);\n+\t      prim_field_data[off] = (byte)l_value;\n+\t    }\n+\n+\t    public void put (String name, float value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'F');\n+\t      int off = field.getOffset ();\n+\t      int i_value = Float.floatToIntBits (value);\n+\t      prim_field_data[off++] = (byte)(i_value >>> 24);\n+\t      prim_field_data[off++] = (byte)(i_value >>> 16);\n+\t      prim_field_data[off++] = (byte)(i_value >>> 8);\n+\t      prim_field_data[off] = (byte)i_value;\n+\t    }\n+\n+\t    public void put (String name, int value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'I');\n+\t      int off = field.getOffset ();\n+\t      prim_field_data[off++] = (byte)(value >>> 24);\n+\t      prim_field_data[off++] = (byte)(value >>> 16);\n+\t      prim_field_data[off++] = (byte)(value >>> 8);\n+\t      prim_field_data[off] = (byte)value;\n+\t    }\n+\n+\t    public void put (String name, long value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'J');\n+\t      int off = field.getOffset ();\n+\t      prim_field_data[off++] = (byte)(value >>> 52);\n+\t      prim_field_data[off++] = (byte)(value >>> 48);\n+\t      prim_field_data[off++] = (byte)(value >>> 40);\n+\t      prim_field_data[off++] = (byte)(value >>> 32);\n+\t      prim_field_data[off++] = (byte)(value >>> 24);\n+\t      prim_field_data[off++] = (byte)(value >>> 16);\n+\t      prim_field_data[off++] = (byte)(value >>> 8);\n+\t      prim_field_data[off] = (byte)value;\n+\t    }\n+\n+\t    public void put (String name, short value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      checkType (field, 'S');\n+\t      int off = field.getOffset ();\n+\t      prim_field_data[off++] = (byte)(value >>> 8);\n+\t      prim_field_data[off] = (byte)value;\n+\t    }\n+\n+\t    public void put (String name, Object value)\n+\t    {\n+\t      ObjectStreamField field\n+\t\t= currentObjectStreamClass.getField (name);\n+\t      if (field == null)\n+\t\tthrow new IllegalArgumentException ();\n+\t      if (value != null &&\n+\t\t  ! field.getType ().isAssignableFrom (value.getClass ()))\n+\t\tthrow new IllegalArgumentException ();\n+\t      objs[field.getOffset ()] = value;\n+\t    }\n+\n+\t    public void write (ObjectOutput out) throws IOException\n+\t    {\n+\t      // Apparently Block data is not used with PutField as per\n+\t      // empirical evidence against JDK 1.2.  Also see Mauve test\n+\t      // java.io.ObjectInputOutput.Test.GetPutField.\n+\t      boolean oldmode = setBlockDataMode (false);\n+\t      out.write (prim_field_data);\n+\t      for (int i = 0; i < objs.length; ++ i)\n+\t\tout.writeObject (objs[i]);\n+\t      setBlockDataMode (oldmode);\n+\t    }\n+\n+\t    private void checkType (ObjectStreamField field, char type)\n+\t      throws IllegalArgumentException\n+\t    {\n+\t      if (TypeSignature.getEncodingOfClass(field.getType ()).charAt(0)\n+\t\t  != type)\n+\t\tthrow new IllegalArgumentException ();\n+\t    }\n+\t  };\n       }\n \n     return currentPutField;\n@@ -1013,10 +1012,9 @@ public void writeFields () throws IOException\n     if (currentPutField == null)\n       throw new NotActiveException (\"writeFields can only be called after putFields has been called\");\n \n-\t// moved here from putFields since putFields \n-\t// may be called more than once, but not writeFields\n-\tmarkFieldsWritten();\n-\t\n+    // putFields may be called more than once, but not writeFields.\n+    markFieldsWritten();\n+\n     currentPutField.write (this);\n     currentPutField = null;\n   }"}]}