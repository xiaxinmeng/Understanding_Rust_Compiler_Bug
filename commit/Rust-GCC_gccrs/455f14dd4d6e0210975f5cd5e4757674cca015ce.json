{"sha": "455f14dd4d6e0210975f5cd5e4757674cca015ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1ZjE0ZGQ0ZDZlMDIxMDk3NWY1Y2Q1ZTQ3NTc2NzRjY2EwMTVjZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-11T16:03:10Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-11T16:03:10Z"}, "message": "builtins.c (expand_builtin_pow, [...]): Replace uses of the macro TREE_CONSTANT_OVERFLOW with TREE_OVERFLOW.\n\n\n\t* builtins.c (expand_builtin_pow, expand_builtin_powi,\n\tfold_builtin_cabs, fold_builtin_sqrt, fold_builtin_trunc,\n\tfold_builtin_floor, fold_builtin_ceil, fold_builtin_round,\n\tfold_builtin_int_int_roundingfn, fold_builtin_bitop,\n\tfold_builtin_bswap, real_constp, fold_builtin_pow,\n\tfold_builtin_powi, fold_builtin_signbit, fold_builtin_copysign,\n\tdo_mpfr_arg1, do_mpfr_arg2, do_mpfr_arg3, do_mpfr_sincos): Replace\n\tuses of the macro TREE_CONSTANT_OVERFLOW with TREE_OVERFLOW.\n\t* convert.c (convert_to_pointer): Likewise.\n\t* expr.c (highest_pow2_factor, expand_expr_real_1): Likewise.\n\t* fold-const.c (force_fit_type, fold_negate_expr, int_const_binop,\n\tconst_binop, fold_convert_const_int_from_int,\n\tfold_convert_const_int_from_real,\n\tfold_convert_const_real_from_real, sign_bit_p,\n\toptimize_minmax_comparison, extract_muldiv_1, fold_div_compare,\n\tfold_sign_changed_comparison, fold_unary, fold_comparison,\n\tfold_binary, multiple_of_p, tree_Expr_non_zero_p,\n\tfold_negate_const, fold_abs_const, fold_not_const): Likewise.\n\t* print-tree.c (print_node_brief, print_node): Likewise.\n\t* stor-layout.c (place_field, layout_type): Likewise.\n\t* tree-chrec.c (keep_cast): Likewise.\n\t* tree.c (build_vector, build_real, build_real_from_int_cst,\n\tbuild_complex): Likewise.\n\nFrom-SVN: r120678", "tree": {"sha": "5157a9420ebb815f559803d5e9c4eaba6cd46d9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5157a9420ebb815f559803d5e9c4eaba6cd46d9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455f14dd4d6e0210975f5cd5e4757674cca015ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f14dd4d6e0210975f5cd5e4757674cca015ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455f14dd4d6e0210975f5cd5e4757674cca015ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f14dd4d6e0210975f5cd5e4757674cca015ce/comments", "author": null, "committer": null, "parents": [{"sha": "95fd24b6415774f9517b4b5c5d989e535e54e724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95fd24b6415774f9517b4b5c5d989e535e54e724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95fd24b6415774f9517b4b5c5d989e535e54e724"}], "stats": {"total": 231, "additions": 110, "deletions": 121}, "files": [{"sha": "7b7a60a6c8d0351079b791a81feda322441fb64d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,3 +1,29 @@\n+2007-01-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin_pow, expand_builtin_powi,\n+\tfold_builtin_cabs, fold_builtin_sqrt, fold_builtin_trunc,\n+\tfold_builtin_floor, fold_builtin_ceil, fold_builtin_round,\n+\tfold_builtin_int_int_roundingfn, fold_builtin_bitop,\n+\tfold_builtin_bswap, real_constp, fold_builtin_pow,\n+\tfold_builtin_powi, fold_builtin_signbit, fold_builtin_copysign,\n+\tdo_mpfr_arg1, do_mpfr_arg2, do_mpfr_arg3, do_mpfr_sincos): Replace\n+\tuses of the macro TREE_CONSTANT_OVERFLOW with TREE_OVERFLOW.\n+\t* convert.c (convert_to_pointer): Likewise.\n+\t* expr.c (highest_pow2_factor, expand_expr_real_1): Likewise.\n+\t* fold-const.c (force_fit_type, fold_negate_expr, int_const_binop,\n+\tconst_binop, fold_convert_const_int_from_int,\n+\tfold_convert_const_int_from_real,\n+\tfold_convert_const_real_from_real, sign_bit_p,\n+\toptimize_minmax_comparison, extract_muldiv_1, fold_div_compare,\n+\tfold_sign_changed_comparison, fold_unary, fold_comparison,\n+\tfold_binary, multiple_of_p, tree_Expr_non_zero_p,\n+\tfold_negate_const, fold_abs_const, fold_not_const): Likewise.\n+\t* print-tree.c (print_node_brief, print_node): Likewise.\n+\t* stor-layout.c (place_field, layout_type): Likewise.\n+\t* tree-chrec.c (keep_cast): Likewise.\n+\t* tree.c (build_vector, build_real, build_real_from_int_cst,\n+\tbuild_complex): Likewise.\n+\n 2007-01-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.h (TREE_CONSTANT_OVERFLOW): Obsolete.  For the time being,"}, {"sha": "a823c6ab74adcaa458de4b70ca90bfaa538fb3d1", "filename": "gcc/builtins.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,6 +1,7 @@\n /* Expand builtin functions.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2688,7 +2689,7 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n \n   if (TREE_CODE (arg1) != REAL_CST\n-      || TREE_CONSTANT_OVERFLOW (arg1))\n+      || TREE_OVERFLOW (arg1))\n     return expand_builtin_mathfn_2 (exp, target, subtarget);\n \n   /* Handle constant exponents.  */\n@@ -2821,7 +2822,7 @@ expand_builtin_powi (tree exp, rtx target, rtx subtarget)\n   /* Handle constant power.  */\n \n   if (TREE_CODE (arg1) == INTEGER_CST\n-      && ! TREE_CONSTANT_OVERFLOW (arg1))\n+      && !TREE_OVERFLOW (arg1))\n     {\n       HOST_WIDE_INT n = TREE_INT_CST_LOW (arg1);\n \n@@ -7013,8 +7014,8 @@ fold_builtin_cabs (tree arglist, tree type, tree fndecl)\n       && TREE_CODE (arg) == COMPLEX_CST\n       && TREE_CODE (TREE_REALPART (arg)) == REAL_CST\n       && TREE_CODE (TREE_IMAGPART (arg)) == REAL_CST\n-      && ! TREE_CONSTANT_OVERFLOW (TREE_REALPART (arg))\n-      && ! TREE_CONSTANT_OVERFLOW (TREE_IMAGPART (arg)))\n+      && !TREE_OVERFLOW (TREE_REALPART (arg))\n+      && !TREE_OVERFLOW (TREE_IMAGPART (arg)))\n     {\n       REAL_VALUE_TYPE r, i;\n \n@@ -7092,7 +7093,7 @@ fold_builtin_sqrt (tree arglist, tree type)\n \n   /* Optimize sqrt of constant value.  */\n   if (TREE_CODE (arg) == REAL_CST\n-      && ! TREE_CONSTANT_OVERFLOW (arg))\n+      && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE r, x;\n \n@@ -7441,7 +7442,7 @@ fold_builtin_trunc (tree fndecl, tree arglist)\n \n   /* Optimize trunc of constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE r, x;\n       tree type = TREE_TYPE (TREE_TYPE (fndecl));\n@@ -7467,7 +7468,7 @@ fold_builtin_floor (tree fndecl, tree arglist)\n \n   /* Optimize floor of constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE x;\n \n@@ -7506,7 +7507,7 @@ fold_builtin_ceil (tree fndecl, tree arglist)\n \n   /* Optimize ceil of constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE x;\n \n@@ -7537,7 +7538,7 @@ fold_builtin_round (tree fndecl, tree arglist)\n \n   /* Optimize round of constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE x;\n \n@@ -7569,7 +7570,7 @@ fold_builtin_int_roundingfn (tree fndecl, tree arglist)\n \n   /* Optimize lround of constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       const REAL_VALUE_TYPE x = TREE_REAL_CST (arg);\n \n@@ -7637,7 +7638,7 @@ fold_builtin_bitop (tree fndecl, tree arglist)\n \n   /* Optimize for constant argument.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == INTEGER_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == INTEGER_CST && !TREE_OVERFLOW (arg))\n     {\n       HOST_WIDE_INT hi, width, result;\n       unsigned HOST_WIDE_INT lo;\n@@ -7729,7 +7730,7 @@ fold_builtin_bswap (tree fndecl, tree arglist)\n \n   /* Optimize constant value.  */\n   arg = TREE_VALUE (arglist);\n-  if (TREE_CODE (arg) == INTEGER_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+  if (TREE_CODE (arg) == INTEGER_CST && !TREE_OVERFLOW (arg))\n     {\n       HOST_WIDE_INT hi, width, r_hi = 0;\n       unsigned HOST_WIDE_INT lo, r_lo = 0;\n@@ -7786,7 +7787,7 @@ real_dconstp (tree expr, const REAL_VALUE_TYPE *value)\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-\t   && ! TREE_CONSTANT_OVERFLOW (expr)\n+\t   && !TREE_OVERFLOW (expr)\n \t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), *value))\n \t  || (TREE_CODE (expr) == COMPLEX_CST\n \t      && real_dconstp (TREE_REALPART (expr), value)\n@@ -7968,7 +7969,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n     return omit_one_operand (type, build_real (type, dconst1), arg1);\n \n   if (TREE_CODE (arg1) == REAL_CST\n-      && ! TREE_CONSTANT_OVERFLOW (arg1))\n+      && !TREE_OVERFLOW (arg1))\n     {\n       REAL_VALUE_TYPE cint;\n       REAL_VALUE_TYPE c;\n@@ -8027,7 +8028,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \t{\n \t  /* Attempt to evaluate pow at compile-time.  */\n \t  if (TREE_CODE (arg0) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg0))\n+\t      && !TREE_OVERFLOW (arg0))\n \t    {\n \t      REAL_VALUE_TYPE x;\n \t      bool inexact;\n@@ -8131,7 +8132,7 @@ fold_builtin_powi (tree fndecl ATTRIBUTE_UNUSED, tree arglist, tree type)\n \n       /* Evaluate powi at compile-time.  */\n       if (TREE_CODE (arg0) == REAL_CST\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg0))\n+\t  && !TREE_OVERFLOW (arg0))\n \t{\n \t  REAL_VALUE_TYPE x;\n \t  x = TREE_REAL_CST (arg0);\n@@ -8819,7 +8820,7 @@ fold_builtin_signbit (tree fndecl, tree arglist)\n \n   /* If ARG is a compile-time constant, determine the result.  */\n   if (TREE_CODE (arg) == REAL_CST\n-      && !TREE_CONSTANT_OVERFLOW (arg))\n+      && !TREE_OVERFLOW (arg))\n     {\n       REAL_VALUE_TYPE c;\n \n@@ -8861,8 +8862,8 @@ fold_builtin_copysign (tree fndecl, tree arglist, tree type)\n   /* If ARG1 and ARG2 are compile-time constants, determine the result.  */\n   if (TREE_CODE (arg1) == REAL_CST\n       && TREE_CODE (arg2) == REAL_CST\n-      && !TREE_CONSTANT_OVERFLOW (arg1)\n-      && !TREE_CONSTANT_OVERFLOW (arg2))\n+      && !TREE_OVERFLOW (arg1)\n+      && !TREE_OVERFLOW (arg2))\n     {\n       REAL_VALUE_TYPE c1, c2;\n \n@@ -11739,7 +11740,7 @@ do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t),\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+      && TREE_CODE (arg) == REAL_CST && !TREE_OVERFLOW (arg))\n     {\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n \n@@ -11781,8 +11782,8 @@ do_mpfr_arg2 (tree arg1, tree arg2, tree type,\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg1) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg1)\n-      && TREE_CODE (arg2) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg2))\n+      && TREE_CODE (arg1) == REAL_CST && !TREE_OVERFLOW (arg1)\n+      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2))\n     {\n       const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n       const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n@@ -11826,9 +11827,9 @@ do_mpfr_arg3 (tree arg1, tree arg2, tree arg3, tree type,\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg1) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg1)\n-      && TREE_CODE (arg2) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg2)\n-      && TREE_CODE (arg3) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg3))\n+      && TREE_CODE (arg1) == REAL_CST && !TREE_OVERFLOW (arg1)\n+      && TREE_CODE (arg2) == REAL_CST && !TREE_OVERFLOW (arg2)\n+      && TREE_CODE (arg3) == REAL_CST && !TREE_OVERFLOW (arg3))\n     {\n       const REAL_VALUE_TYPE *const ra1 = &TREE_REAL_CST (arg1);\n       const REAL_VALUE_TYPE *const ra2 = &TREE_REAL_CST (arg2);\n@@ -11874,7 +11875,8 @@ do_mpfr_sincos (tree arg, tree arg_sinp, tree arg_cosp)\n   /* To proceed, MPFR must exactly represent the target floating point\n      format, which only happens when the target base equals two.  */\n   if (REAL_MODE_FORMAT (TYPE_MODE (type))->b == 2\n-      && TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+      && TREE_CODE (arg) == REAL_CST\n+      && !TREE_OVERFLOW (arg))\n     {\n       const REAL_VALUE_TYPE *const ra = &TREE_REAL_CST (arg);\n "}, {"sha": "771401ead2d478276653c92d0b48b3a9f699e585", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,6 +1,7 @@\n /* Utility routines for data type conversion for GCC.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1997, 1998,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -47,7 +48,7 @@ convert_to_pointer (tree type, tree expr)\n   /* Propagate overflow to the NULL pointer.  */\n   if (integer_zerop (expr))\n     return force_fit_type_double (type, 0, 0, 0, TREE_OVERFLOW (expr),\n-\t\t\t\t  TREE_CONSTANT_OVERFLOW (expr));\n+\t\t\t\t  false);\n \n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {"}, {"sha": "ec0306fa32d42571d07f50e42c86c135e3994cea", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,7 +1,7 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n-   Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -6301,7 +6301,7 @@ highest_pow2_factor (tree exp)\n \t a MIN_EXPR, or a MAX_EXPR.  If the constant overflows, we have an\n \t erroneous program, so return BIGGEST_ALIGNMENT to avoid any\n \t later ICE.  */\n-      if (TREE_CONSTANT_OVERFLOW (exp))\n+      if (TREE_OVERFLOW (exp))\n \treturn BIGGEST_ALIGNMENT;\n       else\n \t{\n@@ -6969,7 +6969,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t simplified by validate_replace_rtx during virtual register\n \t instantiation, which can result in unrecognizable insns.\n \t Avoid this by forcing all overflows into registers.  */\n-      if (TREE_CONSTANT_OVERFLOW (exp)\n+      if (TREE_OVERFLOW (exp)\n \t  && modifier != EXPAND_INITIALIZER)\n \ttemp = force_reg (mode, temp);\n "}, {"sha": "3a3fe36211632734bf423cc57f1d17a2f1c4d0e4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 35, "deletions": 66, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    force_fit_type takes a constant, an overflowable flag and prior\n    overflow indicators.  It forces the value to fit the type and sets\n-   TREE_OVERFLOW and TREE_CONSTANT_OVERFLOW as appropriate.\n+   TREE_OVERFLOW as appropriate.\n    \n    Note: Since the folders get called on non-gimple code as well as\n    gimple code, we need to handle GIMPLE tuples as well as their\n@@ -275,9 +275,6 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   \tOVERFLOWED is nonzero,\n \tor OVERFLOWABLE is >0 and signed overflow occurs\n \tor OVERFLOWABLE is <0 and any overflow occurs\n-   We set TREE_CONSTANT_OVERFLOWED if,\n-        CONST_OVERFLOWED is nonzero\n-\tor we set TREE_OVERFLOWED.\n    We return a new tree node for the extended double-int.  The node\n    is shared if no overflow flags are set.  */\n \n@@ -308,18 +305,6 @@ force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n           TREE_INT_CST_HIGH (t) = high;\n           TREE_TYPE (t) = type;\n \t  TREE_OVERFLOW (t) = 1;\n-\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n-\n-\t  return t;\n-\t}\n-      else if (overflowed_const)\n-\t{\n-          tree t = make_node (INTEGER_CST);\n-          TREE_INT_CST_LOW (t) = low;\n-          TREE_INT_CST_HIGH (t) = high;\n-          TREE_TYPE (t) = type;\n-\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n-\n \t  return t;\n \t}\n     }\n@@ -1115,16 +1100,16 @@ fold_negate_expr (tree t)\n       \n     case INTEGER_CST:\n       tem = fold_negate_const (t, type);\n-      if (! TREE_OVERFLOW (tem)\n+      if (!TREE_OVERFLOW (tem)\n \t  || TYPE_UNSIGNED (type)\n-\t  || ! flag_trapv)\n+\t  || !flag_trapv)\n \treturn tem;\n       break;\n \n     case REAL_CST:\n       tem = fold_negate_const (t, type);\n       /* Two's complement FP formats, such as c4x, may overflow.  */\n-      if (! TREE_OVERFLOW (tem) || ! flag_trapping_math)\n+      if (!TREE_OVERFLOW (tem) || !flag_trapping_math)\n \treturn tem;\n       break;\n \n@@ -1530,8 +1515,8 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n     case EXACT_DIV_EXPR:\n       /* This is a shortcut for a common special case.  */\n       if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t  && !TREE_OVERFLOW (arg1)\n+\t  && !TREE_OVERFLOW (arg2)\n \t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n \t{\n \t  if (code == CEIL_DIV_EXPR)\n@@ -1565,8 +1550,8 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n     case FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n       /* This is a shortcut for a common special case.  */\n       if (int2h == 0 && (HOST_WIDE_INT) int2l > 0\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t  && !TREE_OVERFLOW (arg1)\n+\t  && !TREE_OVERFLOW (arg2)\n \t  && int1h == 0 && (HOST_WIDE_INT) int1l >= 0)\n \t{\n \t  if (code == CEIL_MOD_EXPR)\n@@ -1617,20 +1602,13 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t{\n \t  t = copy_node (t);\n \t  TREE_OVERFLOW (t) = 1;\n-\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n-\t}\n-      else if (TREE_CONSTANT_OVERFLOW (arg1) | TREE_CONSTANT_OVERFLOW (arg2))\n-\t{\n-\t  t = copy_node (t);\n-\t  TREE_CONSTANT_OVERFLOW (t) = 1;\n \t}\n     }\n   else\n     t = force_fit_type_double (TREE_TYPE (arg1), low, hi, 1,\n \t\t\t       ((!uns || is_sizetype) && overflow)\n \t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n-\t\t\t       TREE_CONSTANT_OVERFLOW (arg1)\n-\t\t\t       | TREE_CONSTANT_OVERFLOW (arg2));\n+\t\t\t       false);\n \n   return t;\n }\n@@ -1731,10 +1709,6 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       t = build_real (type, result);\n \n       TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2);\n-      TREE_CONSTANT_OVERFLOW (t)\n-\t= TREE_OVERFLOW (t)\n-\t  | TREE_CONSTANT_OVERFLOW (arg1)\n-\t  | TREE_CONSTANT_OVERFLOW (arg2);\n       return t;\n     }\n \n@@ -1911,7 +1885,7 @@ fold_convert_const_int_from_int (tree type, tree arg1)\n \t\t \t      && (TYPE_UNSIGNED (type)\n \t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n \t\t\t     | TREE_OVERFLOW (arg1),\n-\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n+\t\t\t     false);\n \n   return t;\n }\n@@ -1991,7 +1965,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n \n   t = force_fit_type_double (type, low, high, -1,\n \t\t\t     overflow | TREE_OVERFLOW (arg1),\n-\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n+\t\t\t     false);\n   return t;\n }\n \n@@ -2008,8 +1982,6 @@ fold_convert_const_real_from_real (tree type, tree arg1)\n   t = build_real (type, value);\n \n   TREE_OVERFLOW (t) = TREE_OVERFLOW (arg1);\n-  TREE_CONSTANT_OVERFLOW (t)\n-    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n   return t;\n }\n \n@@ -3696,7 +3668,7 @@ sign_bit_p (tree exp, tree val)\n \n   /* Tree VAL must be an integer constant.  */\n   if (TREE_CODE (val) != INTEGER_CST\n-      || TREE_CONSTANT_OVERFLOW (val))\n+      || TREE_OVERFLOW (val))\n     return NULL_TREE;\n \n   width = TYPE_PRECISION (t);\n@@ -5347,9 +5319,9 @@ optimize_minmax_comparison (enum tree_code code, tree type, tree op0, tree op1)\n   /* If something does not permit us to optimize, return the original tree.  */\n   if ((op_code != MIN_EXPR && op_code != MAX_EXPR)\n       || TREE_CODE (comp_const) != INTEGER_CST\n-      || TREE_CONSTANT_OVERFLOW (comp_const)\n+      || TREE_OVERFLOW (comp_const)\n       || TREE_CODE (minmax_const) != INTEGER_CST\n-      || TREE_CONSTANT_OVERFLOW (minmax_const))\n+      || TREE_OVERFLOW (minmax_const))\n     return NULL_TREE;\n \n   /* Now handle all the various comparison codes.  We only handle EQ_EXPR\n@@ -5526,7 +5498,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t possible later conversion to our or some other type.  */\n       if ((t2 = fold_convert (TREE_TYPE (op0), c)) != 0\n \t  && TREE_CODE (t2) == INTEGER_CST\n-\t  && ! TREE_CONSTANT_OVERFLOW (t2)\n+\t  && !TREE_OVERFLOW (t2)\n \t  && (0 != (t1 = extract_muldiv (op0, t2, code,\n \t\t\t\t\t code == MULT_EXPR\n \t\t\t\t\t ? ctype : NULL_TREE))))\n@@ -5587,7 +5559,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t\t\t      const_binop (LSHIFT_EXPR,\n \t\t\t\t\t\t   size_one_node,\n \t\t\t\t\t\t   op1, 0)))\n-\t  && ! TREE_OVERFLOW (t1))\n+\t  && !TREE_OVERFLOW (t1))\n \treturn extract_muldiv (build2 (tcode == LSHIFT_EXPR\n \t\t\t\t       ? MULT_EXPR : FLOOR_DIV_EXPR,\n \t\t\t\t       ctype, fold_convert (ctype, op0), t1),\n@@ -5704,7 +5676,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       if (tcode == code\n \t  && 0 != (t1 = const_binop (MULT_EXPR, fold_convert (ctype, op1),\n \t\t\t\t     fold_convert (ctype, c), 0))\n-\t  && ! TREE_OVERFLOW (t1))\n+\t  && !TREE_OVERFLOW (t1))\n \treturn fold_build2 (tcode, ctype, fold_convert (ctype, op0), t1);\n \n       /* If these operations \"cancel\" each other, we have the main\n@@ -6188,7 +6160,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t       &lpart, &hpart, unsigned_p);\n       hi = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n \t\t\t\t  -1, overflow | TREE_OVERFLOW (prod),\n-\t\t\t\t  TREE_CONSTANT_OVERFLOW (prod));\n+\t\t\t\t  false);\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n@@ -6625,7 +6597,7 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n     arg1 = force_fit_type_double (inner_type, TREE_INT_CST_LOW (arg1),\n \t\t\t\t  TREE_INT_CST_HIGH (arg1), 0,\n \t\t\t\t  TREE_OVERFLOW (arg1),\n-\t\t\t\t  TREE_CONSTANT_OVERFLOW (arg1));\n+\t\t\t\t  false);\n   else\n     arg1 = fold_convert (inner_type, arg1);\n \n@@ -7560,7 +7532,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t      tem = force_fit_type_double (type, TREE_INT_CST_LOW (and1),\n \t\t\t\t\t   TREE_INT_CST_HIGH (and1), 0,\n \t\t\t\t\t   TREE_OVERFLOW (and1),\n-\t\t\t\t\t   TREE_CONSTANT_OVERFLOW (and1));\n+\t\t\t\t\t   false);\n \t      return fold_build2 (BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert (type, and0), tem);\n \t    }\n@@ -8285,7 +8257,7 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n \t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       /* Likewise, we can simplify a comparison of a real constant with\n@@ -8297,7 +8269,7 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n \t  && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n \t\t\t\t      arg1, 0))\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2 (swap_tree_comparison (code), type,\n \t\t\t    TREE_OPERAND (arg0, 1), tem);\n \n@@ -9541,7 +9513,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n \t\t\t\t\t\t\t\t     1)));\n \t\t  if (TREE_CODE (arg11) == REAL_CST\n-\t\t      && ! TREE_CONSTANT_OVERFLOW (arg11)\n+\t\t      && !TREE_OVERFLOW (arg11)\n \t\t      && operand_equal_p (arg0, arg10, 0))\n \t\t    {\n \t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n@@ -9566,7 +9538,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n \t\t\t\t\t\t\t\t     1)));\n \t\t  if (TREE_CODE (arg01) == REAL_CST\n-\t\t      && ! TREE_CONSTANT_OVERFLOW (arg01)\n+\t\t      && !TREE_OVERFLOW (arg01)\n \t\t      && operand_equal_p (arg1, arg00, 0))\n \t\t    {\n \t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n@@ -10208,7 +10180,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n \t      if (TREE_CODE (arg01) == REAL_CST\n-\t\t  && ! TREE_CONSTANT_OVERFLOW (arg01)\n+\t\t  && !TREE_OVERFLOW (arg01)\n \t\t  && operand_equal_p (arg1, arg00, 0))\n \t\t{\n \t\t  tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n@@ -10367,7 +10339,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (code == TRUNC_MOD_EXPR\n \t  && !TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && !TREE_CONSTANT_OVERFLOW (arg1)\n+\t  && !TREE_OVERFLOW (arg1)\n \t  && TREE_INT_CST_HIGH (arg1) < 0\n \t  && !flag_trapv\n \t  /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n@@ -10781,15 +10753,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t\t      fold_convert (TREE_TYPE (arg0), arg1),\n \t\t\t\t      TREE_OPERAND (arg0, 1), 0))\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       /* Similarly for a NEGATE_EXPR.  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && 0 != (tem = negate_expr (arg1))\n \t  && TREE_CODE (tem) == INTEGER_CST\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0), tem);\n \n       /* Similarly for a BIT_XOR_EXPR;  X ^ C1 == C2 is X == (C1 ^ C2).  */\n@@ -11293,7 +11265,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \tunsigned int width = TYPE_PRECISION (arg1_type);\n \n \tif (TREE_CODE (arg1) == INTEGER_CST\n-\t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t    && !TREE_OVERFLOW (arg1)\n \t    && width <= 2 * HOST_BITS_PER_WIDE_INT\n \t    && (INTEGRAL_TYPE_P (arg1_type) || POINTER_TYPE_P (arg1_type)))\n \t  {\n@@ -11452,7 +11424,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && ! TREE_SIDE_EFFECTS (arg0)\n \t  && (0 != (tem = negate_expr (arg1)))\n \t  && TREE_CODE (tem) == INTEGER_CST\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n+\t  && !TREE_OVERFLOW (tem))\n \treturn fold_build2 (TRUTH_ANDIF_EXPR, type,\n \t\t\t    build2 (GE_EXPR, type,\n \t\t\t\t    TREE_OPERAND (arg0, 0), tem),\n@@ -12516,7 +12488,7 @@ multiple_of_p (tree type, tree top, tree bottom)\n \t\t\t\t\t  const_binop (LSHIFT_EXPR,\n \t\t\t\t\t\t       size_one_node,\n \t\t\t\t\t\t       op1, 0)))\n-\t      && ! TREE_OVERFLOW (t1))\n+\t      && !TREE_OVERFLOW (t1))\n \t    return multiple_of_p (type, t1, bottom);\n \t}\n       return 0;\n@@ -12872,10 +12844,7 @@ tree_expr_nonzero_p (tree t)\n       return tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n \n     case INTEGER_CST:\n-      /* We used to test for !integer_zerop here.  This does not work correctly\n-\t if TREE_CONSTANT_OVERFLOW (t).  */\n-      return (TREE_INT_CST_LOW (t) != 0\n-\t      || TREE_INT_CST_HIGH (t) != 0);\n+      return !integer_zerop (t);\n \n     case PLUS_EXPR:\n       if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n@@ -13077,7 +13046,7 @@ fold_negate_const (tree arg0, tree type)\n \tt = force_fit_type_double (type, low, high, 1,\n \t\t\t\t   (overflow | TREE_OVERFLOW (arg0))\n \t\t\t\t   && !TYPE_UNSIGNED (type),\n-\t\t\t\t   TREE_CONSTANT_OVERFLOW (arg0));\n+\t\t\t\t   false);\n \tbreak;\n       }\n \n@@ -13123,7 +13092,7 @@ fold_abs_const (tree arg0, tree type)\n \t\t\t\t     &low, &high);\n \t  t = force_fit_type_double (type, low, high, -1,\n \t\t\t\t     overflow | TREE_OVERFLOW (arg0),\n-\t\t\t\t     TREE_CONSTANT_OVERFLOW (arg0));\n+\t\t\t\t     false);\n \t}\n       break;\n \n@@ -13154,7 +13123,7 @@ fold_not_const (tree arg0, tree type)\n   t = force_fit_type_double (type, ~TREE_INT_CST_LOW (arg0),\n \t\t\t     ~TREE_INT_CST_HIGH (arg0), 0,\n \t\t\t     TREE_OVERFLOW (arg0),\n-\t\t\t     TREE_CONSTANT_OVERFLOW (arg0));\n+\t\t\t     false);\n \n   return t;\n }"}, {"sha": "ab4ae608209261149319d18b611a29f033ff7cab", "filename": "gcc/print-tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,6 +1,6 @@\n /* Prints out tree in human readable form - GCC\n    Copyright (C) 1990, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -115,7 +115,7 @@ print_node_brief (FILE *file, const char *prefix, tree node, int indent)\n   /* We might as well always print the value of an integer or real.  */\n   if (TREE_CODE (node) == INTEGER_CST)\n     {\n-      if (TREE_CONSTANT_OVERFLOW (node))\n+      if (TREE_OVERFLOW (node))\n \tfprintf (file, \" overflow\");\n \n       fprintf (file, \" \");\n@@ -701,7 +701,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       switch (TREE_CODE (node))\n \t{\n \tcase INTEGER_CST:\n-\t  if (TREE_CONSTANT_OVERFLOW (node))\n+\t  if (TREE_OVERFLOW (node))\n \t    fprintf (file, \" overflow\");\n \n \t  fprintf (file, \" \");"}, {"sha": "313d1694b56985968f54f2f4033e74ec47c92f3a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,6 +1,6 @@\n /* C-compiler utilities for types and variables storage layout\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1996, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1195,7 +1195,7 @@ place_field (record_layout_info rli, tree field)\n   if (DECL_SIZE (field) == 0)\n     /* Do nothing.  */;\n   else if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST\n-\t   || TREE_CONSTANT_OVERFLOW (DECL_SIZE (field)))\n+\t   || TREE_OVERFLOW (DECL_SIZE (field)))\n     {\n       rli->offset\n \t= size_binop (PLUS_EXPR, rli->offset,\n@@ -1821,7 +1821,7 @@ layout_type (tree type)\n \t    && TREE_CODE (TYPE_SIZE_UNIT (element)) == INTEGER_CST\n \t    /* If TYPE_SIZE_UNIT overflowed, then it is certainly larger than\n \t       TYPE_ALIGN_UNIT.  */\n-\t    && !TREE_CONSTANT_OVERFLOW (TYPE_SIZE_UNIT (element))\n+\t    && !TREE_OVERFLOW (TYPE_SIZE_UNIT (element))\n \t    && !integer_zerop (TYPE_SIZE_UNIT (element))\n \t    && compare_tree_int (TYPE_SIZE_UNIT (element),\n \t\t\t  \t TYPE_ALIGN_UNIT (element)) < 0)"}, {"sha": "66738d35d09ade6f2415ae24ed12d419eea6fdee", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,5 +1,5 @@\n /* Chains of recurrences.\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <pop@cri.ensmp.fr>\n \n This file is part of GCC.\n@@ -1293,10 +1293,7 @@ chrec_convert_1 (tree type, tree chrec, tree at_stmt,\n \n   /* Don't propagate overflows.  */\n   if (CONSTANT_CLASS_P (res))\n-    {\n-      TREE_CONSTANT_OVERFLOW (res) = 0;\n-      TREE_OVERFLOW (res) = 0;\n-    }\n+    TREE_OVERFLOW (res) = 0;\n \n   /* But reject constants that don't fit in their type after conversion.\n      This can happen if TYPE_MIN_VALUE or TYPE_MAX_VALUE are not the"}, {"sha": "ea462f027d398e80d37418436a43fc2774fc4182", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f14dd4d6e0210975f5cd5e4757674cca015ce/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=455f14dd4d6e0210975f5cd5e4757674cca015ce", "patch": "@@ -1,6 +1,6 @@\n /* Language-independent node constructors for parse phase of GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -997,7 +997,7 @@ tree\n build_vector (tree type, tree vals)\n {\n   tree v = make_node (VECTOR_CST);\n-  int over1 = 0, over2 = 0;\n+  int over = 0;\n   tree link;\n \n   TREE_VECTOR_CST_ELTS (v) = vals;\n@@ -1012,13 +1012,10 @@ build_vector (tree type, tree vals)\n       if (!CONSTANT_CLASS_P (value))\n \tcontinue;\n \n-      over1 |= TREE_OVERFLOW (value);\n-      over2 |= TREE_CONSTANT_OVERFLOW (value);\n+      over |= TREE_OVERFLOW (value);\n     }\n \n-  TREE_OVERFLOW (v) = over1;\n-  TREE_CONSTANT_OVERFLOW (v) = over2;\n-\n+  TREE_OVERFLOW (v) = over;\n   return v;\n }\n \n@@ -1115,7 +1112,7 @@ build_real (tree type, REAL_VALUE_TYPE d)\n \n   TREE_TYPE (v) = type;\n   TREE_REAL_CST_PTR (v) = dp;\n-  TREE_OVERFLOW (v) = TREE_CONSTANT_OVERFLOW (v) = overflow;\n+  TREE_OVERFLOW (v) = overflow;\n   return v;\n }\n \n@@ -1149,7 +1146,6 @@ build_real_from_int_cst (tree type, tree i)\n   v = build_real (type, real_value_from_int_cst (type, i));\n \n   TREE_OVERFLOW (v) |= overflow;\n-  TREE_CONSTANT_OVERFLOW (v) |= overflow;\n   return v;\n }\n \n@@ -1198,8 +1194,6 @@ build_complex (tree type, tree real, tree imag)\n   TREE_IMAGPART (t) = imag;\n   TREE_TYPE (t) = type ? type : build_complex_type (TREE_TYPE (real));\n   TREE_OVERFLOW (t) = TREE_OVERFLOW (real) | TREE_OVERFLOW (imag);\n-  TREE_CONSTANT_OVERFLOW (t)\n-    = TREE_CONSTANT_OVERFLOW (real) | TREE_CONSTANT_OVERFLOW (imag);\n   return t;\n }\n "}]}