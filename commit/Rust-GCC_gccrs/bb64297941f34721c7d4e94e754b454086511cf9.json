{"sha": "bb64297941f34721c7d4e94e754b454086511cf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2NDI5Nzk0MWYzNDcyMWM3ZDRlOTRlNzU0YjQ1NDA4NjUxMWNmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-03T13:36:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-03T13:36:55Z"}, "message": "Add DR_BASE_ALIGNMENT and DR_BASE_MISALIGNMENT\n\nThis patch records the base alignment and misalignment in\ninnermost_loop_behavior, to avoid the second-guessing that was\npreviously done in vect_compute_data_ref_alignment.  It also makes\nvect_analyze_data_refs use dr_analyze_innermost, instead of having an\nalmost-copy of the same code.\n\nI wasn't sure whether the alignments should be measured in bits\n(for consistency with most other interfaces) or in bytes (for consistency\nwith DR_ALIGNED_TO, now DR_OFFSET_ALIGNMENT, and with *_ptr_info_alignment).\nI went for bytes because:\n\n- I think in practice most consumers are going to want bytes.\n  E.g. using bytes avoids having to mix TYPE_ALIGN and TYPE_ALIGN_UNIT\n  in vect_compute_data_ref_alignment.\n\n- It means that any bit-level paranoia is dealt with when building\n  the innermost_loop_behavior and doesn't get pushed down to consumers.\n\n2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-data-ref.h (innermost_loop_behavior): Add base_alignment\n\tand base_misalignment fields.\n\t(DR_BASE_ALIGNMENT, DR_BASE_MISALIGNMENT): New macros.\n\t* tree-data-ref.c: Include builtins.h.\n\t(dr_analyze_innermost): Set up the new innmost_loop_behavior fields.\n\t* tree-vectorizer.h (STMT_VINFO_DR_BASE_ALIGNMENT): New macro.\n\t(STMT_VINFO_DR_BASE_MISALIGNMENT): Likewise.\n\t* tree-vect-data-refs.c: Include tree-cfg.h.\n\t(vect_compute_data_ref_alignment): Use the new innermost_loop_behavior\n\tfields instead of calculating an alignment here.\n\t(vect_analyze_data_refs): Use dr_analyze_innermost.  Dump the new\n\tinnermost_loop_behavior fields.\n\nFrom-SVN: r249916", "tree": {"sha": "aa95ccdabebcc6989fd1aaff624bf8dbfafbd39b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa95ccdabebcc6989fd1aaff624bf8dbfafbd39b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb64297941f34721c7d4e94e754b454086511cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb64297941f34721c7d4e94e754b454086511cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb64297941f34721c7d4e94e754b454086511cf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb64297941f34721c7d4e94e754b454086511cf9/comments", "author": null, "committer": null, "parents": [{"sha": "832b4117d4068670cc9ed496a7ab06104a12dc00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832b4117d4068670cc9ed496a7ab06104a12dc00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832b4117d4068670cc9ed496a7ab06104a12dc00"}], "stats": {"total": 288, "additions": 143, "deletions": 145}, "files": [{"sha": "c116fccbc6032076cd16d48669cab12197360d5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb64297941f34721c7d4e94e754b454086511cf9", "patch": "@@ -1,3 +1,18 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-data-ref.h (innermost_loop_behavior): Add base_alignment\n+\tand base_misalignment fields.\n+\t(DR_BASE_ALIGNMENT, DR_BASE_MISALIGNMENT): New macros.\n+\t* tree-data-ref.c: Include builtins.h.\n+\t(dr_analyze_innermost): Set up the new innmost_loop_behavior fields.\n+\t* tree-vectorizer.h (STMT_VINFO_DR_BASE_ALIGNMENT): New macro.\n+\t(STMT_VINFO_DR_BASE_MISALIGNMENT): Likewise.\n+\t* tree-vect-data-refs.c: Include tree-cfg.h.\n+\t(vect_compute_data_ref_alignment): Use the new innermost_loop_behavior\n+\tfields instead of calculating an alignment here.\n+\t(vect_analyze_data_refs): Use dr_analyze_innermost.  Dump the new\n+\tinnermost_loop_behavior fields.\n+\n 2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-data-ref.h (innermost_loop_behavior): Add a step_alignment"}, {"sha": "ab768535bf837338b53799f806c8f99f3e7bbe06", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=bb64297941f34721c7d4e94e754b454086511cf9", "patch": "@@ -94,6 +94,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"tree-affine.h\"\n #include \"params.h\"\n+#include \"builtins.h\"\n \n static struct datadep_stats\n {\n@@ -802,11 +803,26 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n       return false;\n     }\n \n+  /* Calculate the alignment and misalignment for the inner reference.  */\n+  unsigned int HOST_WIDE_INT base_misalignment;\n+  unsigned int base_alignment;\n+  get_object_alignment_1 (base, &base_alignment, &base_misalignment);\n+\n+  /* There are no bitfield references remaining in BASE, so the values\n+     we got back must be whole bytes.  */\n+  gcc_assert (base_alignment % BITS_PER_UNIT == 0\n+\t      && base_misalignment % BITS_PER_UNIT == 0);\n+  base_alignment /= BITS_PER_UNIT;\n+  base_misalignment /= BITS_PER_UNIT;\n+\n   if (TREE_CODE (base) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (base, 1)))\n \t{\n+\t  /* Subtract MOFF from the base and add it to POFFSET instead.\n+\t     Adjust the misalignment to reflect the amount we subtracted.  */\n \t  offset_int moff = mem_ref_offset (base);\n+\t  base_misalignment -= moff.to_short_addr ();\n \t  tree mofft = wide_int_to_tree (sizetype, moff);\n \t  if (!poffset)\n \t    poffset = mofft;\n@@ -855,20 +871,46 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n     }\n \n   init = ssize_int (pbitpos / BITS_PER_UNIT);\n+\n+  /* Subtract any constant component from the base and add it to INIT instead.\n+     Adjust the misalignment to reflect the amount we subtracted.  */\n   split_constant_offset (base_iv.base, &base_iv.base, &dinit);\n-  init =  size_binop (PLUS_EXPR, init, dinit);\n+  init = size_binop (PLUS_EXPR, init, dinit);\n+  base_misalignment -= TREE_INT_CST_LOW (dinit);\n+\n   split_constant_offset (offset_iv.base, &offset_iv.base, &dinit);\n-  init =  size_binop (PLUS_EXPR, init, dinit);\n+  init = size_binop (PLUS_EXPR, init, dinit);\n \n   step = size_binop (PLUS_EXPR,\n \t\t     fold_convert (ssizetype, base_iv.step),\n \t\t     fold_convert (ssizetype, offset_iv.step));\n \n-  drb->base_address = canonicalize_base_object_address (base_iv.base);\n+  base = canonicalize_base_object_address (base_iv.base);\n+\n+  /* See if get_pointer_alignment can guarantee a higher alignment than\n+     the one we calculated above.  */\n+  unsigned int HOST_WIDE_INT alt_misalignment;\n+  unsigned int alt_alignment;\n+  get_pointer_alignment_1 (base, &alt_alignment, &alt_misalignment);\n+\n+  /* As above, these values must be whole bytes.  */\n+  gcc_assert (alt_alignment % BITS_PER_UNIT == 0\n+\t      && alt_misalignment % BITS_PER_UNIT == 0);\n+  alt_alignment /= BITS_PER_UNIT;\n+  alt_misalignment /= BITS_PER_UNIT;\n+\n+  if (base_alignment < alt_alignment)\n+    {\n+      base_alignment = alt_alignment;\n+      base_misalignment = alt_misalignment;\n+    }\n \n+  drb->base_address = base;\n   drb->offset = fold_convert (ssizetype, offset_iv.base);\n   drb->init = init;\n   drb->step = step;\n+  drb->base_alignment = base_alignment;\n+  drb->base_misalignment = base_misalignment & (base_alignment - 1);\n   drb->offset_alignment = highest_pow2_factor (offset_iv.base);\n   drb->step_alignment = highest_pow2_factor (step);\n \n@@ -1085,6 +1127,9 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n       print_generic_expr (dump_file, DR_INIT (dr), TDF_SLIM);\n       fprintf (dump_file, \"\\n\\tstep: \");\n       print_generic_expr (dump_file, DR_STEP (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tbase alignment: %d\", DR_BASE_ALIGNMENT (dr));\n+      fprintf (dump_file, \"\\n\\tbase misalignment: %d\",\n+\t       DR_BASE_MISALIGNMENT (dr));\n       fprintf (dump_file, \"\\n\\toffset alignment: %d\",\n \t       DR_OFFSET_ALIGNMENT (dr));\n       fprintf (dump_file, \"\\n\\tstep alignment: %d\", DR_STEP_ALIGNMENT (dr));"}, {"sha": "72c68d0fdab7c96553cbd26a9be6b59e3cb3eb07", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=bb64297941f34721c7d4e94e754b454086511cf9", "patch": "@@ -52,6 +52,42 @@ struct innermost_loop_behavior\n   tree init;\n   tree step;\n \n+  /* BASE_ADDRESS is known to be misaligned by BASE_MISALIGNMENT bytes\n+     from an alignment boundary of BASE_ALIGNMENT bytes.  For example,\n+     if we had:\n+\n+       struct S __attribute__((aligned(16))) { ... };\n+\n+       char *ptr;\n+       ... *(struct S *) (ptr - 4) ...;\n+\n+     the information would be:\n+\n+       base_address:      ptr\n+       base_aligment:      16\n+       base_misalignment:   4\n+       init:               -4\n+\n+     where init cancels the base misalignment.  If instead we had a\n+     reference to a particular field:\n+\n+       struct S __attribute__((aligned(16))) { ... int f; ... };\n+\n+       char *ptr;\n+       ... ((struct S *) (ptr - 4))->f ...;\n+\n+     the information would be:\n+\n+       base_address:      ptr\n+       base_aligment:      16\n+       base_misalignment:   4\n+       init:               -4 + offsetof (S, f)\n+\n+     where base_address + init might also be misaligned, and by a different\n+     amount from base_address.  */\n+  unsigned int base_alignment;\n+  unsigned int base_misalignment;\n+\n   /* The largest power of two that divides OFFSET, capped to a suitably\n      high value if the offset is zero.  This is a byte rather than a bit\n      quantity.  */\n@@ -147,6 +183,8 @@ struct data_reference\n #define DR_INIT(DR)                (DR)->innermost.init\n #define DR_STEP(DR)                (DR)->innermost.step\n #define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n+#define DR_BASE_ALIGNMENT(DR)      (DR)->innermost.base_alignment\n+#define DR_BASE_MISALIGNMENT(DR)   (DR)->innermost.base_misalignment\n #define DR_OFFSET_ALIGNMENT(DR)    (DR)->innermost.offset_alignment\n #define DR_STEP_ALIGNMENT(DR)      (DR)->innermost.step_alignment\n #define DR_INNERMOST(DR)           (DR)->innermost"}, {"sha": "3db408c274d2cd20b6a2922fdbd532eb6efce66c", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 39, "deletions": 142, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bb64297941f34721c7d4e94e754b454086511cf9", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"builtins.h\"\n #include \"params.h\"\n+#include \"tree-cfg.h\"\n \n /* Return true if load- or store-lanes optab OPTAB is implemented for\n    COUNT vectors of type VECTYPE.  NAME is the name of OPTAB.  */\n@@ -667,8 +668,6 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   struct loop *loop = NULL;\n   tree ref = DR_REF (dr);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  tree base;\n-  unsigned HOST_WIDE_INT alignment;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -728,48 +727,18 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"step doesn't divide the vector-size.\\n\");\n     }\n-  tree base_addr = drb->base_address;\n-\n-  /* To look at alignment of the base we have to preserve an inner MEM_REF\n-     as that carries alignment information of the actual access.  */\n-  base = ref;\n-  while (handled_component_p (base))\n-    base = TREE_OPERAND (base, 0);\n-  unsigned int base_alignment = 0;\n-  unsigned HOST_WIDE_INT base_bitpos;\n-  get_object_alignment_1 (base, &base_alignment, &base_bitpos);\n-  /* As data-ref analysis strips the MEM_REF down to its base operand\n-     to form DR_BASE_ADDRESS and adds the offset to DR_INIT we have to\n-     adjust things to make base_alignment valid as the alignment of\n-     DR_BASE_ADDRESS.  */\n-  if (TREE_CODE (base) == MEM_REF)\n-    {\n-      /* Note all this only works if DR_BASE_ADDRESS is the same as\n-\t MEM_REF operand zero, otherwise DR/SCEV analysis might have factored\n-\t in other offsets.  We need to rework DR to compute the alingment\n-\t of DR_BASE_ADDRESS as long as all information is still available.  */\n-      if (operand_equal_p (TREE_OPERAND (base, 0), base_addr, 0))\n-\t{\n-\t  base_bitpos -= mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n-\t  base_bitpos &= (base_alignment - 1);\n-\t}\n-      else\n-\tbase_bitpos = BITS_PER_UNIT;\n-    }\n-  if (base_bitpos != 0)\n-    base_alignment = base_bitpos & -base_bitpos;\n-  /* Also look at the alignment of the base address DR analysis\n-     computed.  */\n-  unsigned int base_addr_alignment = get_pointer_alignment (base_addr);\n-  if (base_addr_alignment > base_alignment)\n-    base_alignment = base_addr_alignment;\n-\n-  if (base_alignment >= TYPE_ALIGN (TREE_TYPE (vectype)))\n-    DR_VECT_AUX (dr)->base_element_aligned = true;\n \n-  alignment = TYPE_ALIGN_UNIT (vectype);\n+  unsigned int base_alignment = drb->base_alignment;\n+  unsigned int base_misalignment = drb->base_misalignment;\n+  unsigned HOST_WIDE_INT vector_alignment = TYPE_ALIGN_UNIT (vectype);\n+  unsigned HOST_WIDE_INT element_alignment\n+    = TYPE_ALIGN_UNIT (TREE_TYPE (vectype));\n+\n+  if (base_alignment >= element_alignment\n+      && (base_misalignment & (element_alignment - 1)) == 0)\n+    DR_VECT_AUX (dr)->base_element_aligned = true;\n \n-  if (drb->offset_alignment < alignment\n+  if (drb->offset_alignment < vector_alignment\n       || !step_preserves_misalignment_p\n       /* We need to know whether the step wrt the vectorized loop is\n \t negative when computing the starting misalignment below.  */\n@@ -785,12 +754,13 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       return true;\n     }\n \n-  if (base_alignment < TYPE_ALIGN (vectype))\n+  if (base_alignment < vector_alignment)\n     {\n-      base = base_addr;\n+      tree base = drb->base_address;\n       if (TREE_CODE (base) == ADDR_EXPR)\n \tbase = TREE_OPERAND (base, 0);\n-      if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n+      if (!vect_can_force_dr_alignment_p (base,\n+\t\t\t\t\t  vector_alignment * BITS_PER_UNIT))\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n@@ -828,24 +798,20 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       DR_VECT_AUX (dr)->base_decl = base;\n       DR_VECT_AUX (dr)->base_misaligned = true;\n       DR_VECT_AUX (dr)->base_element_aligned = true;\n+      base_misalignment = 0;\n     }\n+  unsigned int misalignment = (base_misalignment\n+\t\t\t       + TREE_INT_CST_LOW (drb->init));\n \n   /* If this is a backward running DR then first access in the larger\n      vectype actually is N-1 elements before the address in the DR.\n      Adjust misalign accordingly.  */\n-  tree misalign = drb->init;\n   if (tree_int_cst_sgn (drb->step) < 0)\n-    {\n-      tree offset = ssize_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n-      /* DR_STEP(dr) is the same as -TYPE_SIZE of the scalar type,\n-\t otherwise we wouldn't be here.  */\n-      offset = fold_build2 (MULT_EXPR, ssizetype, offset, drb->step);\n-      /* PLUS because STEP was negative.  */\n-      misalign = size_binop (PLUS_EXPR, misalign, offset);\n-    }\n+    /* PLUS because STEP is negative.  */\n+    misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+\t\t     * TREE_INT_CST_LOW (drb->step));\n \n-  SET_DR_MISALIGNMENT (dr,\n-\t\t       wi::mod_floor (misalign, alignment, SIGNED).to_uhwi ());\n+  SET_DR_MISALIGNMENT (dr, misalignment & (vector_alignment - 1));\n \n   if (dump_enabled_p ())\n     {\n@@ -3554,100 +3520,27 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t the outer-loop.  */\n       if (loop && nested_in_vect_loop_p (loop, stmt))\n \t{\n-\t  tree outer_step, outer_base, outer_init;\n-\t  HOST_WIDE_INT pbitsize, pbitpos;\n-\t  tree poffset;\n-\t  machine_mode pmode;\n-\t  int punsignedp, preversep, pvolatilep;\n-\t  affine_iv base_iv, offset_iv;\n-\t  tree dinit;\n-\n \t  /* Build a reference to the first location accessed by the\n-\t     inner-loop: *(BASE+INIT).  (The first location is actually\n-\t     BASE+INIT+OFFSET, but we add OFFSET separately later).  */\n-          tree inner_base = build_fold_indirect_ref\n-                                (fold_build_pointer_plus (base, init));\n+\t     inner loop: *(BASE + INIT + OFFSET).  By construction,\n+\t     this address must be invariant in the inner loop, so we\n+\t     can consider it as being used in the outer loop.  */\n+\t  tree init_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset),\n+\t\t\t\t\t  init, offset);\n+\t  tree init_addr = fold_build_pointer_plus (base, init_offset);\n+\t  tree init_ref = build_fold_indirect_ref (init_addr);\n \n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"analyze in outer-loop: \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, inner_base);\n+                               \"analyze in outer loop: \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, init_ref);\n \t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n-\t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos,\n-\t\t\t\t\t    &poffset, &pmode, &punsignedp,\n-\t\t\t\t\t    &preversep, &pvolatilep);\n-\t  gcc_assert (outer_base != NULL_TREE);\n-\n-\t  if (pbitpos % BITS_PER_UNIT != 0)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"failed: bit offset alignment.\\n\");\n-\t      return false;\n-\t    }\n-\n-\t  if (preversep)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"failed: reverse storage order.\\n\");\n-\t      return false;\n-\t    }\n-\n-\t  outer_base = build_fold_addr_expr (outer_base);\n-\t  if (!simple_iv (loop, loop_containing_stmt (stmt), outer_base,\n-                          &base_iv, false))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"failed: evolution of base is not affine.\\n\");\n-\t      return false;\n-\t    }\n-\n-\t  if (offset)\n-\t    {\n-\t      if (poffset)\n-\t\tpoffset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset,\n-                                       poffset);\n-\t      else\n-\t\tpoffset = offset;\n-\t    }\n-\n-\t  if (!poffset)\n-\t    {\n-\t      offset_iv.base = ssize_int (0);\n-\t      offset_iv.step = ssize_int (0);\n-\t    }\n-\t  else if (!simple_iv (loop, loop_containing_stmt (stmt), poffset,\n-                               &offset_iv, false))\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"evolution of offset is not affine.\\n\");\n-\t      return false;\n-\t    }\n-\n-\t  outer_init = ssize_int (pbitpos / BITS_PER_UNIT);\n-\t  split_constant_offset (base_iv.base, &base_iv.base, &dinit);\n-\t  outer_init =  size_binop (PLUS_EXPR, outer_init, dinit);\n-\t  split_constant_offset (offset_iv.base, &offset_iv.base, &dinit);\n-\t  outer_init =  size_binop (PLUS_EXPR, outer_init, dinit);\n-\n-\t  outer_step = size_binop (PLUS_EXPR,\n-\t\t\t\tfold_convert (ssizetype, base_iv.step),\n-\t\t\t\tfold_convert (ssizetype, offset_iv.step));\n-\n-\t  STMT_VINFO_DR_STEP (stmt_info) = outer_step;\n-\t  /* FIXME: Use canonicalize_base_object_address (base_iv.base); */\n-\t  STMT_VINFO_DR_BASE_ADDRESS (stmt_info) = base_iv.base;\n-\t  STMT_VINFO_DR_INIT (stmt_info) = outer_init;\n-\t  STMT_VINFO_DR_OFFSET (stmt_info) =\n-\t\t\t\tfold_convert (ssizetype, offset_iv.base);\n-\t  STMT_VINFO_DR_OFFSET_ALIGNMENT (stmt_info)\n-\t    = highest_pow2_factor (offset_iv.base);\n+\t  if (!dr_analyze_innermost (&STMT_VINFO_DR_WRT_VEC_LOOP (stmt_info),\n+\t\t\t\t     init_ref, loop))\n+\t    /* dr_analyze_innermost already explained the failure.  */\n+\t    return false;\n \n           if (dump_enabled_p ())\n \t    {\n@@ -3665,6 +3558,10 @@ vect_analyze_data_refs (vec_info *vinfo, int *min_vf)\n \t      dump_printf (MSG_NOTE, \"\\n\\touter step: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n                                  STMT_VINFO_DR_STEP (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter base alignment: %d\\n\",\n+\t\t\t   STMT_VINFO_DR_BASE_ALIGNMENT (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\\touter base misalignment: %d\\n\",\n+\t\t\t   STMT_VINFO_DR_BASE_MISALIGNMENT (stmt_info));\n \t      dump_printf (MSG_NOTE, \"\\n\\touter offset alignment: %d\\n\",\n \t\t\t   STMT_VINFO_DR_OFFSET_ALIGNMENT (stmt_info));\n \t      dump_printf (MSG_NOTE, \"\\n\\touter step alignment: %d\\n\","}, {"sha": "058b7f4d48e1c3eb3f119481eb7ff334acf3e046", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb64297941f34721c7d4e94e754b454086511cf9/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bb64297941f34721c7d4e94e754b454086511cf9", "patch": "@@ -709,6 +709,9 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_DR_INIT(S)              (S)->dr_wrt_vec_loop.init\n #define STMT_VINFO_DR_OFFSET(S)            (S)->dr_wrt_vec_loop.offset\n #define STMT_VINFO_DR_STEP(S)              (S)->dr_wrt_vec_loop.step\n+#define STMT_VINFO_DR_BASE_ALIGNMENT(S)    (S)->dr_wrt_vec_loop.base_alignment\n+#define STMT_VINFO_DR_BASE_MISALIGNMENT(S) \\\n+  (S)->dr_wrt_vec_loop.base_misalignment\n #define STMT_VINFO_DR_OFFSET_ALIGNMENT(S) \\\n   (S)->dr_wrt_vec_loop.offset_alignment\n #define STMT_VINFO_DR_STEP_ALIGNMENT(S) \\"}]}