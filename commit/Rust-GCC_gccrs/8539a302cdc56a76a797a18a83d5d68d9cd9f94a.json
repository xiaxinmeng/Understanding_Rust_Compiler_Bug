{"sha": "8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzOWEzMDJjZGM1NmE3NmE3OTdhMThhODNkNWQ2OGQ5Y2Q5Zjk0YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-01-23T15:59:19Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-01-23T15:59:19Z"}, "message": "re PR tree-optimization/70754 (ICE during predictive commoning)\n\n\tPR tree-optimization/70754\n\t* tree-predcom.c (stmt_combining_refs): New parameter INSERT_BEFORE.\n\t(reassociate_to_the_same_stmt): New parameter INSERT_BEFORE.  Insert\n\tcombined stmt before it if not NULL.\n\t(combine_chains): Process refs reversely and compute dominance point\n\tfor root ref.\n\n\tgcc/testsuite\n\tPR tree-optimization/70754\n\t* gfortran.dg/pr70754.f90: New test.\n\nFrom-SVN: r244815", "tree": {"sha": "e54ee2726df9d979df31710b46829d4d7191a097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e54ee2726df9d979df31710b46829d4d7191a097"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/comments", "author": null, "committer": null, "parents": [{"sha": "61ad58f3aa6aac0e9b91e175dd821388c5fdf320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ad58f3aa6aac0e9b91e175dd821388c5fdf320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ad58f3aa6aac0e9b91e175dd821388c5fdf320"}], "stats": {"total": 106, "additions": 94, "deletions": 12}, "files": [{"sha": "bd716492ec1958e5316c02d15e9e639072f2e863", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "patch": "@@ -1,3 +1,12 @@\n+2017-01-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/70754\n+\t* tree-predcom.c (stmt_combining_refs): New parameter INSERT_BEFORE.\n+\t(reassociate_to_the_same_stmt): New parameter INSERT_BEFORE.  Insert\n+\tcombined stmt before it if not NULL.\n+\t(combine_chains): Process refs reversely and compute dominance point\n+\tfor root ref.\n+\n 2017-01-23  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/79196"}, {"sha": "de1f24b5e035604028c3905a249b6da9df56b983", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "patch": "@@ -1,3 +1,8 @@\n+2017-01-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/70754\n+\t* gfortran.dg/pr70754.f90: New test.\n+\n 2017-01-23  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/79196"}, {"sha": "d7e790cc036dd182098e47dbca53d95f16646feb", "filename": "gcc/testsuite/gfortran.dg/pr70754.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70754.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70754.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr70754.f90?ref=8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+! { dg-options \"-Ofast\" }\n+module m\n+  implicit none\n+  private\n+  save\n+\n+  integer, parameter, public :: &\n+    ii4          = selected_int_kind(6), &\n+    rr8          = selected_real_kind(13)\n+\n+  integer (ii4), dimension(40,40,199), public :: xyz\n+  public :: foo\n+contains\n+  subroutine foo(a)\n+    real (rr8), dimension(40,40), intent(out) :: a\n+    real (rr8), dimension(40,40) :: b\n+    integer (ii4), dimension(40,40) :: c\n+    integer  i, j\n+\n+    do i=1,20\n+      b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &\n+             + 34 * a(i,j-1) + a(i+1,j+1) &\n+             + a(i+1,j-1) + a(i-1,j+1) &\n+             + a(i-1,j-1)\n+      c(i,j) = 123\n+    end do\n+\n+    where ((xyz(:,:,2) /= 0) .and. (c /= 0))\n+      a = b/real(c)\n+    elsewhere\n+      a = 456\n+    endwhere\n+ end subroutine foo\n+end module m"}, {"sha": "9723e9c406692cda99b2a54a53b64c5c0a7697f4", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8539a302cdc56a76a797a18a83d5d68d9cd9f94a/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=8539a302cdc56a76a797a18a83d5d68d9cd9f94a", "patch": "@@ -2164,10 +2164,11 @@ remove_name_from_operation (gimple *stmt, tree op)\n }\n \n /* Reassociates the expression in that NAME1 and NAME2 are used so that they\n-   are combined in a single statement, and returns this statement.  */\n+   are combined in a single statement, and returns this statement.  Note the\n+   statement is inserted before INSERT_BEFORE if it's not NULL.  */\n \n static gimple *\n-reassociate_to_the_same_stmt (tree name1, tree name2)\n+reassociate_to_the_same_stmt (tree name1, tree name2, gimple *insert_before)\n {\n   gimple *stmt1, *stmt2, *root1, *root2, *s1, *s2;\n   gassign *new_stmt, *tmp_stmt;\n@@ -2224,6 +2225,12 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n   var = create_tmp_reg (type, \"predreastmp\");\n   new_name = make_ssa_name (var);\n   new_stmt = gimple_build_assign (new_name, code, name1, name2);\n+  if (insert_before && stmt_dominates_stmt_p (insert_before, s1))\n+    bsi = gsi_for_stmt (insert_before);\n+  else\n+    bsi = gsi_for_stmt (s1);\n+\n+  gsi_insert_before (&bsi, new_stmt, GSI_SAME_STMT);\n \n   var = create_tmp_reg (type, \"predreastmp\");\n   tmp_name = make_ssa_name (var);\n@@ -2240,7 +2247,6 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n   s1 = gsi_stmt (bsi);\n   update_stmt (s1);\n \n-  gsi_insert_before (&bsi, new_stmt, GSI_SAME_STMT);\n   gsi_insert_before (&bsi, tmp_stmt, GSI_SAME_STMT);\n \n   return new_stmt;\n@@ -2249,10 +2255,11 @@ reassociate_to_the_same_stmt (tree name1, tree name2)\n /* Returns the statement that combines references R1 and R2.  In case R1\n    and R2 are not used in the same statement, but they are used with an\n    associative and commutative operation in the same expression, reassociate\n-   the expression so that they are used in the same statement.  */\n+   the expression so that they are used in the same statement.  The combined\n+   statement is inserted before INSERT_BEFORE if it's not NULL.  */\n \n static gimple *\n-stmt_combining_refs (dref r1, dref r2)\n+stmt_combining_refs (dref r1, dref r2, gimple *insert_before)\n {\n   gimple *stmt1, *stmt2;\n   tree name1 = name_for_ref (r1);\n@@ -2263,7 +2270,7 @@ stmt_combining_refs (dref r1, dref r2)\n   if (stmt1 == stmt2)\n     return stmt1;\n \n-  return reassociate_to_the_same_stmt (name1, name2);\n+  return reassociate_to_the_same_stmt (name1, name2, insert_before);\n }\n \n /* Tries to combine chains CH1 and CH2 together.  If this succeeds, the\n@@ -2309,14 +2316,42 @@ combine_chains (chain_p ch1, chain_p ch2)\n   new_chain->rslt_type = rslt_type;\n   new_chain->length = ch1->length;\n \n-  for (i = 0; (ch1->refs.iterate (i, &r1)\n-\t       && ch2->refs.iterate (i, &r2)); i++)\n+  gimple *insert = NULL;\n+  auto_vec<dref> tmp_refs;\n+  gcc_assert (ch1->refs.length () == ch2->refs.length ());\n+  /* Process in reverse order so dominance point is ready when it comes\n+     to the root ref.  */\n+  for (i = ch1->refs.length (); i > 0; i--)\n     {\n+      r1 = ch1->refs[i - 1];\n+      r2 = ch2->refs[i - 1];\n       nw = XCNEW (struct dref_d);\n-      nw->stmt = stmt_combining_refs (r1, r2);\n       nw->distance = r1->distance;\n+      nw->stmt = stmt_combining_refs (r1, r2, i == 1 ? insert : NULL);\n+\n+      /* Record dominance point where root combined stmt should be inserted\n+\t for chains with 0 length.  Though all root refs dominate following\n+\t refs, it's possible the combined stmt doesn't.  See PR70754.  */\n+      if (ch1->length == 0\n+\t  && (insert == NULL || stmt_dominates_stmt_p (nw->stmt, insert)))\n+\tinsert = nw->stmt;\n+\n+      tmp_refs.safe_push (nw);\n+    }\n+\n+  /* Restore the order for new chain's refs.  */\n+  for (i = tmp_refs.length (); i > 0; i--)\n+    new_chain->refs.safe_push (tmp_refs[i - 1]);\n+\n+  ch1->combined = true;\n+  ch2->combined = true;\n \n-      new_chain->refs.safe_push (nw);\n+  /* For chains with 0 length, has_max_use_after must be true since root\n+     combined stmt must dominates others.  */\n+  if (new_chain->length == 0)\n+    {\n+      new_chain->has_max_use_after = true;\n+      return new_chain;\n     }\n \n   new_chain->has_max_use_after = false;\n@@ -2331,8 +2366,6 @@ combine_chains (chain_p ch1, chain_p ch2)\n \t}\n     }\n \n-  ch1->combined = true;\n-  ch2->combined = true;\n   return new_chain;\n }\n "}]}