{"sha": "c0ecf7f1cb60961adeb05cac3de981ec1587d302", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlY2Y3ZjFjYjYwOTYxYWRlYjA1Y2FjM2RlOTgxZWMxNTg3ZDMwMg==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2013-09-13T07:51:07Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2013-09-13T07:51:07Z"}, "message": "re PR target/58314 (SH4 error: 'asm' operand requires impossible reload)\n\n2013-09-13  Christian Bruel  <christian.bruel@st.com>\n\n        PR target/58314\n        * config/sh/sh.md (mov<mode>_reg_reg): Allow memory reloads.\n\nFrom-SVN: r202557", "tree": {"sha": "4a688419ae29cfcb0fd661bfc7be8b93374ac9cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a688419ae29cfcb0fd661bfc7be8b93374ac9cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0ecf7f1cb60961adeb05cac3de981ec1587d302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ecf7f1cb60961adeb05cac3de981ec1587d302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ecf7f1cb60961adeb05cac3de981ec1587d302", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ecf7f1cb60961adeb05cac3de981ec1587d302/comments", "author": null, "committer": null, "parents": [{"sha": "740f2bf37a9200035de31055449acf2a5dc6f2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740f2bf37a9200035de31055449acf2a5dc6f2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740f2bf37a9200035de31055449acf2a5dc6f2a9"}], "stats": {"total": 132, "additions": 124, "deletions": 8}, "files": [{"sha": "781743d31b68a427b14af9a854deb95f71f0f650", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0ecf7f1cb60961adeb05cac3de981ec1587d302", "patch": "@@ -1,3 +1,8 @@\n+2013-09-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/58314\n+\t* config/sh/sh.md (mov<mode>_reg_reg): Allow memory reloads.\n+\n 2013-09-13  Kai Tietz  <ktietz@redhat.com>\n \n \t* config.gcc: Separate cases for mingw and cygwin targets,"}, {"sha": "2c20d3868a45c60a0c55fa66df4f0eb7fc67e86c", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=c0ecf7f1cb60961adeb05cac3de981ec1587d302", "patch": "@@ -6878,10 +6878,11 @@ label:\n ;; If movqi_reg_reg is specified as an alternative of movqi, movqi will be\n ;; selected to copy QImode regs.  If one of them happens to be allocated\n ;; on the stack, reload will stick to movqi insn and generate wrong\n-;; displacement addressing because of the generic m alternatives.  \n-;; With the movqi_reg_reg being specified before movqi it will be initially \n-;; picked to load/store regs.  If the regs regs are on the stack reload will\n-;; try other insns and not stick to movqi_reg_reg.\n+;; displacement addressing because of the generic m alternatives.\n+;; With the movqi_reg_reg being specified before movqi it will be initially\n+;; picked to load/store regs.  If the regs regs are on the stack reload\n+;; try other insns and not stick to movqi_reg_reg, unless there were spilled\n+;; pseudos in which case 'm' constraints pertain.\n ;; The same applies to the movhi variants.\n ;;\n ;; Notice, that T bit is not allowed as a mov src operand here.  This is to\n@@ -6893,11 +6894,14 @@ label:\n ;; reloading MAC subregs otherwise.  For that probably special patterns\n ;; would be required.\n (define_insn \"*mov<mode>_reg_reg\"\n-  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=r\")\n-\t(match_operand:QIHI 1 \"register_operand\" \"r\"))]\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=r,m,*z\")\n+\t(match_operand:QIHI 1 \"register_operand\" \"r,*z,m\"))]\n   \"TARGET_SH1 && !t_reg_operand (operands[1], VOIDmode)\"\n-  \"mov\t%1,%0\"\n-  [(set_attr \"type\" \"move\")])\n+  \"@\n+    mov\t\t%1,%0\n+    mov.<bw>\t%1,%0\n+    mov.<bw>\t%1,%0\"\n+  [(set_attr \"type\" \"move,store,load\")])\n \n ;; FIXME: The non-SH2A and SH2A variants should be combined by adding\n ;; \"enabled\" attribute as it is done in other targets."}, {"sha": "66e00d3c739d0f9a611d06d95561398abe00cff7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c0ecf7f1cb60961adeb05cac3de981ec1587d302", "patch": "@@ -1,3 +1,8 @@\n+2013-09-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/58314\n+\t* gcc.target/sh/torture/pr58314.c: New test.\n+\n 2013-09-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/torture/pr58380.C: Suppress warnings with \"-w\"."}, {"sha": "61447d84ff9e55141d11cd3a2028aafc0c754cf8", "filename": "gcc/testsuite/gcc.target/sh/torture/pr58314.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr58314.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ecf7f1cb60961adeb05cac3de981ec1587d302/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr58314.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr58314.c?ref=c0ecf7f1cb60961adeb05cac3de981ec1587d302", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-Os\" } */\n+\n+typedef unsigned short __u16;\n+typedef unsigned int __u32;\n+\n+typedef signed short s16;\n+\n+\n+static inline __attribute__((always_inline)) __attribute__((__const__)) __u16 __arch_swab16(__u16 x)\n+{\n+ __asm__(\n+  \"swap.b\t\t%1, %0\"\n+  : \"=r\" (x)\n+  : \"r\" (x));\n+ return x;\n+}\n+\n+void u16_add_cpu(__u16 *var)\n+{\n+  *var = __arch_swab16(*var);\n+}\n+\n+typedef struct xfs_mount {\n+ int m_attr_magicpct;\n+} xfs_mount_t;\n+\n+typedef struct xfs_da_args {\n+ struct xfs_mount *t_mountp;\n+ int index;\n+} xfs_da_args_t;\n+\n+typedef struct xfs_dabuf {\n+ void *data;\n+} xfs_dabuf_t;\n+\n+typedef struct xfs_attr_leaf_map {\n+ __u16 base;\n+ __u16 size;\n+} xfs_attr_leaf_map_t;\n+typedef struct xfs_attr_leaf_hdr {\n+ __u16 count;\n+ xfs_attr_leaf_map_t freemap[3];\n+} xfs_attr_leaf_hdr_t;\n+\n+typedef struct xfs_attr_leaf_entry {\n+  __u16 nameidx;\n+} xfs_attr_leaf_entry_t;\n+\n+typedef struct xfs_attr_leafblock {\n+ xfs_attr_leaf_hdr_t hdr;\n+ xfs_attr_leaf_entry_t entries[1];\n+} xfs_attr_leafblock_t;\n+\n+int\n+xfs_attr_leaf_remove(xfs_attr_leafblock_t *leaf, xfs_da_args_t *args)\n+{\n+ xfs_attr_leaf_hdr_t *hdr;\n+ xfs_attr_leaf_map_t *map;\n+ xfs_attr_leaf_entry_t *entry;\n+ int before, after, smallest, entsize;\n+ int tablesize, tmp, i;\n+ xfs_mount_t *mp;\n+ hdr = &leaf->hdr;\n+ mp = args->t_mountp;\n+\n+ entry = &leaf->entries[args->index];\n+\n+ tablesize = __arch_swab16(hdr->count);\n+\n+ map = &hdr->freemap[0];\n+ tmp = map->size;\n+ before = after = -1;\n+ smallest = 3 - 1;\n+ entsize = xfs_attr_leaf_entsize(leaf, args->index);\n+\n+ for (i = 0; i < 2; map++, i++) {\n+\n+  if (map->base == tablesize)\n+    u16_add_cpu(&map->base);\n+\n+  if (__arch_swab16(map->base)  + __arch_swab16(map->size)  == __arch_swab16(entry->nameidx))\n+   before = i;\n+  else if (map->base == entsize)\n+   after = i;\n+  else if (__arch_swab16(map->size) < tmp)\n+   smallest = i;\n+ }\n+\n+ if (before >= 0)\n+  {\n+   map = &hdr->freemap[after];\n+   map->base = entry->nameidx;\n+\n+  }\n+\n+  map = &hdr->freemap[smallest];\n+\n+  map->base = __arch_swab16(entry->nameidx);\n+\n+ return(tmp < mp->m_attr_magicpct);\n+}"}]}