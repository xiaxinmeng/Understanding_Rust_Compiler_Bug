{"sha": "460b171de54de807c8d139da4803bd0fae500622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYwYjE3MWRlNTRkZTgwN2M4ZDEzOWRhNDgwM2JkMGZhZTUwMDYyMg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2011-08-01T12:34:15Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2011-08-01T12:34:15Z"}, "message": "calls.c (emit_library_call_value_1): Support padding for libcall arguments and return values.\n\n\tgcc/\n\t* calls.c (emit_library_call_value_1): Support padding for libcall\n\targuments and return values.\n\t* config/arm/arm.c (arm_pad_arg_upward): Pad half-float values\n\tdownwards in big-endian mode.\n\nFrom-SVN: r177022", "tree": {"sha": "891354cf2cb68748e3ddbae9a66feb3fffe87e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/891354cf2cb68748e3ddbae9a66feb3fffe87e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/460b171de54de807c8d139da4803bd0fae500622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460b171de54de807c8d139da4803bd0fae500622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460b171de54de807c8d139da4803bd0fae500622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460b171de54de807c8d139da4803bd0fae500622/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c228a0698654628c25704330a123c58c4a5380b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c228a0698654628c25704330a123c58c4a5380b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c228a0698654628c25704330a123c58c4a5380b4"}], "stats": {"total": 57, "additions": 55, "deletions": 2}, "files": [{"sha": "417807a970b180775c3f1bcfdee1a9c80637d440", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460b171de54de807c8d139da4803bd0fae500622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460b171de54de807c8d139da4803bd0fae500622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=460b171de54de807c8d139da4803bd0fae500622", "patch": "@@ -1,3 +1,10 @@\n+2011-08-01  Julian Brown  <julian@codesourcery.com>\n+\n+\t* calls.c (emit_library_call_value_1): Support padding for libcall\n+\targuments and return values.\n+\t* config/arm/arm.c (arm_pad_arg_upward): Pad half-float values\n+\tdownwards in big-endian mode.\n+\n 2011-08-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR debug/49887"}, {"sha": "7ad30b4245c135f6f90772d2930d144db3f44305", "filename": "gcc/calls.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460b171de54de807c8d139da4803bd0fae500622/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460b171de54de807c8d139da4803bd0fae500622/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=460b171de54de807c8d139da4803bd0fae500622", "patch": "@@ -3829,13 +3829,41 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n-\n+      int size = 0;\n+      \n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The PA64 has examples of this for library calls.  */\n       if (reg != 0 && GET_CODE (reg) == PARALLEL)\n \temit_group_load (reg, val, NULL_TREE, GET_MODE_SIZE (mode));\n       else if (reg != 0 && partial == 0)\n-\temit_move_insn (reg, val);\n+        {\n+\t  emit_move_insn (reg, val);\n+#ifdef BLOCK_REG_PADDING\n+\t  size = GET_MODE_SIZE (argvec[argnum].mode);\n+\n+\t  /* Copied from load_register_parameters.  */\n+\n+\t  /* Handle case where we have a value that needs shifting\n+\t     up to the msb.  eg. a QImode value and we're padding\n+\t     upward on a BYTES_BIG_ENDIAN machine.  */\n+\t  if (size < UNITS_PER_WORD\n+\t      && (argvec[argnum].locate.where_pad\n+\t\t  == (BYTES_BIG_ENDIAN ? upward : downward)))\n+\t    {\n+\t      rtx x;\n+\t      int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\n+\t      /* Assigning REG here rather than a temp makes CALL_FUSAGE\n+\t\t report the whole reg as used.  Strictly speaking, the\n+\t\t call only uses SIZE bytes at the msb end, but it doesn't\n+\t\t seem worth generating rtl to say that.  */\n+\t      reg = gen_rtx_REG (word_mode, REGNO (reg));\n+\t      x = expand_shift (LSHIFT_EXPR, word_mode, reg, shift, reg, 1);\n+\t      if (x != reg)\n+\t\temit_move_insn (reg, x);\n+\t    }\n+#endif\n+\t}\n \n       NO_DEFER_POP;\n     }\n@@ -3901,6 +3929,15 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t       valreg,\n \t       old_inhibit_defer_pop + 1, call_fusage, flags, args_so_far);\n \n+  /* Right-shift returned value if necessary.  */\n+  if (!pcc_struct_value\n+      && TYPE_MODE (tfom) != BLKmode\n+      && targetm.calls.return_in_msb (tfom))\n+    {\n+      shift_return_value (TYPE_MODE (tfom), false, valreg);\n+      valreg = gen_rtx_REG (TYPE_MODE (tfom), REGNO (valreg));\n+    }\n+\n   /* For calls to `setjmp', etc., inform function.c:setjmp_warnings\n      that it should complain if nonvolatile values are live.  For\n      functions that cannot return, inform flow that control does not"}, {"sha": "e0b8c3dd4a03cae6d23edbafc63e715790eedf0e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460b171de54de807c8d139da4803bd0fae500622/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460b171de54de807c8d139da4803bd0fae500622/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=460b171de54de807c8d139da4803bd0fae500622", "patch": "@@ -11261,6 +11261,15 @@ arm_pad_arg_upward (enum machine_mode mode, const_tree type)\n   if (type && BYTES_BIG_ENDIAN && INTEGRAL_TYPE_P (type))\n     return false;\n \n+  /* Half-float values are only passed to libcalls, not regular functions.\n+     They should be passed and returned as \"short\"s (see RTABI).  To achieve\n+     that effect in big-endian mode, pad downwards so the value is passed in\n+     the least-significant end of the register.  ??? This needs to be here\n+     rather than in arm_pad_reg_upward due to peculiarity in the handling of\n+     libcall arguments.  */\n+  if (BYTES_BIG_ENDIAN && mode == HFmode)\n+    return false;\n+\n   return true;\n }\n "}]}