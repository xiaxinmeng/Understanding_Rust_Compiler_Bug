{"sha": "b24718388c6e66ef6a3713fd56bf6158fe57134d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI0NzE4Mzg4YzZlNjZlZjZhMzcxM2ZkNTZiZjYxNThmZTU3MTM0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-06-18T11:23:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-06-18T11:23:41Z"}, "message": "mips-protos.h (mips_initial_elimination_offset): Declare.\n\n\t* config/mips/mips-protos.h (mips_initial_elimination_offset): Declare.\n\t(mips_set_return_address, mips_restore_gp): Declare.\n\t* config/mips/mips.h (struct mips_frame_info): Move to mips.c\n\t(current_frame_info): Remove.\n\t(INITIAL_ELIMINATION_OFFSET): Use mips_initial_elimination_offset.\n\t* config/mips/mips.c: Remove uses of current_frame_info.\n\t(struct mips_frame_info): Moved from mips.h.  Remove 'insns_len'.\n\t(struct machine_function): Add 'frame' and 'insns_len'.\n\t(current_frame_info, zero_frame_info): Remove.\n\t(mips_restore_gp, mips_set_return_address): New.\n\t(mips_initial_elimination_offset): New.\n\t* config/mips/mips.md (exception_receiver): Use mips_restore_gp.\n\t(eh_return define_split): Use mips_set_return_address.\n\nFrom-SVN: r54738", "tree": {"sha": "3ca0d5b94778933990bd94d819520cd16fc21a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ca0d5b94778933990bd94d819520cd16fc21a0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b24718388c6e66ef6a3713fd56bf6158fe57134d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24718388c6e66ef6a3713fd56bf6158fe57134d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b24718388c6e66ef6a3713fd56bf6158fe57134d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b24718388c6e66ef6a3713fd56bf6158fe57134d/comments", "author": null, "committer": null, "parents": [{"sha": "d3beaf0a30177a8c12db67b9edbff0e7e621792c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3beaf0a30177a8c12db67b9edbff0e7e621792c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3beaf0a30177a8c12db67b9edbff0e7e621792c"}], "stats": {"total": 381, "additions": 208, "deletions": 173}, "files": [{"sha": "cf4718fdebe644a28bcd68085afe89a8e352f618", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b24718388c6e66ef6a3713fd56bf6158fe57134d", "patch": "@@ -1,3 +1,19 @@\n+2002-06-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (mips_initial_elimination_offset): Declare.\n+\t(mips_set_return_address, mips_restore_gp): Declare.\n+\t* config/mips/mips.h (struct mips_frame_info): Move to mips.c\n+\t(current_frame_info): Remove.\n+\t(INITIAL_ELIMINATION_OFFSET): Use mips_initial_elimination_offset.\n+\t* config/mips/mips.c: Remove uses of current_frame_info.\n+\t(struct mips_frame_info): Moved from mips.h.  Remove 'insns_len'.\n+\t(struct machine_function): Add 'frame' and 'insns_len'.\n+\t(current_frame_info, zero_frame_info): Remove.\n+\t(mips_restore_gp, mips_set_return_address): New.\n+\t(mips_initial_elimination_offset): New.\n+\t* config/mips/mips.md (exception_receiver): Use mips_restore_gp.\n+\t(eh_return define_split): Use mips_set_return_address.\n+\n 2002-06-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cpplib.c (dtable): Update."}, {"sha": "674db93841b41ccd65b7ba06aaf7e22f1e40f7d5", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=b24718388c6e66ef6a3713fd56bf6158fe57134d", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_MIPS_PROTOS_H\n \n extern HOST_WIDE_INT\tcompute_frame_size PARAMS ((HOST_WIDE_INT));\n+extern int\t\tmips_initial_elimination_offset PARAMS ((int, int));\n extern void\t\tmips_asm_file_end PARAMS ((FILE *));\n extern void\t\tmips_asm_file_start PARAMS ((FILE *));\n extern void\t\tiris6_asm_file_start PARAMS ((FILE *));\n@@ -86,6 +87,7 @@ extern void\t\tinit_cumulative_args PARAMS ((CUMULATIVE_ARGS *,\n \t\t\t\t\t\t      tree, rtx));\n extern void\t\tgen_conditional_move PARAMS ((rtx *));\n extern void\t\tmips_gen_conditional_trap PARAMS ((rtx *));\n+extern void\t\tmips_set_return_address PARAMS ((rtx, rtx));\n extern void\t\tmachine_dependent_reorg PARAMS ((rtx));\n extern int\t\tmips_address_cost PARAMS ((rtx));\n extern void\t\tmips_count_memory_refs PARAMS ((rtx, int));\n@@ -96,6 +98,7 @@ extern const char      *mips_fill_delay_slot PARAMS ((const char *,\n \t\t\t\t\t\t      rtx));\n extern const char      *mips_move_1word PARAMS ((rtx *, rtx, int));\n extern const char      *mips_move_2words PARAMS ((rtx *, rtx));\n+extern const char      *mips_restore_gp PARAMS ((rtx *, rtx));\n extern const char      *output_block_move PARAMS ((rtx, rtx *, int,\n \t\t\t\t\t\t   enum block_move_type));\n extern void\t\toverride_options PARAMS ((void));"}, {"sha": "fd166e83e637ba50e782a20a3d4e5ffb05605349", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 185, "deletions": 70, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b24718388c6e66ef6a3713fd56bf6158fe57134d", "patch": "@@ -147,6 +147,28 @@ static void mips_select_rtx_section PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t     unsigned HOST_WIDE_INT));\n static void mips_encode_section_info\t\tPARAMS ((tree, int));\n \n+/* Structure to be filled in by compute_frame_size with register\n+   save masks, and offsets for the current function.  */\n+\n+struct mips_frame_info GTY(())\n+{\n+  long total_size;\t\t/* # bytes that the entire frame takes up */\n+  long var_size;\t\t/* # bytes that variables take up */\n+  long args_size;\t\t/* # bytes that outgoing arguments take up */\n+  long extra_size;\t\t/* # bytes of extra gunk */\n+  int  gp_reg_size;\t\t/* # bytes needed to store gp regs */\n+  int  fp_reg_size;\t\t/* # bytes needed to store fp regs */\n+  long mask;\t\t\t/* mask of saved gp registers */\n+  long fmask;\t\t\t/* mask of saved fp registers */\n+  long gp_save_offset;\t\t/* offset from vfp to store gp registers */\n+  long fp_save_offset;\t\t/* offset from vfp to store fp registers */\n+  long gp_sp_offset;\t\t/* offset from new sp to store gp registers */\n+  long fp_sp_offset;\t\t/* offset from new sp to store fp registers */\n+  int  initialized;\t\t/* != 0 if frame size already calculated */\n+  int  num_gp;\t\t\t/* number of gp registers saved */\n+  int  num_fp;\t\t\t/* number of fp registers saved */\n+};\n+\n struct machine_function GTY(()) {\n   /* Pseudo-reg holding the address of the current function when\n      generating embedded PIC code.  Created by LEGITIMIZE_ADDRESS,\n@@ -156,6 +178,12 @@ struct machine_function GTY(()) {\n   /* Pseudo-reg holding the value of $28 in a mips16 function which\n      refers to GP relative global variables.  */\n   rtx mips16_gp_pseudo_rtx;\n+\n+  /* Current frame information, calculated by compute_frame_size.  */\n+  struct mips_frame_info frame;\n+\n+  /* Length of instructions in function; mips16 only.  */\n+  long insns_len;\n };\n \n /* Information about a single argument.  */\n@@ -335,12 +363,6 @@ static enum machine_mode gpr_mode;\n    can support a given mode.  */\n char mips_hard_regno_mode_ok[(int)MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n \n-/* Current frame information calculated by compute_frame_size.  */\n-struct mips_frame_info current_frame_info;\n-\n-/* Zero structure to initialize current_frame_info.  */\n-struct mips_frame_info zero_frame_info;\n-\n /* The length of all strings seen when compiling for the mips16.  This\n    is used to tell how many strings are in the constant pool, so that\n    we can see if we may have an overflow.  This is reset each time the\n@@ -929,18 +951,18 @@ simple_memory_operand (op, mode)\n          getting this right is during delayed branch scheduling, so\n          don't need to check until then.  The machine_dependent_reorg\n          function will set the total length of the instructions used\n-         in the function in current_frame_info.  If that is small\n+         in the function (cfun->machine->insns_len).  If that is small\n          enough, we know for sure that this is a small offset.  It\n          would be better if we could take into account the location of\n          the instruction within the function, but we can't, because we\n          don't know where we are.  */\n       if (TARGET_MIPS16\n \t  && CONSTANT_POOL_ADDRESS_P (addr)\n-\t  && current_frame_info.insns_len > 0)\n+\t  && cfun->machine->insns_len > 0)\n \t{\n \t  long size;\n \n-\t  size = current_frame_info.insns_len + get_pool_size ();\n+\t  size = cfun->machine->insns_len + get_pool_size ();\n \t  if (GET_MODE_SIZE (mode) == 4)\n \t    return size < 4 * 0x100;\n \t  else if (GET_MODE_SIZE (mode) == 8)\n@@ -1695,11 +1717,11 @@ m16_usym8_4 (op, mode)\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n-      && current_frame_info.insns_len > 0\n+      && cfun->machine->insns_len > 0\n       && XSTR (op, 0)[0] == '*'\n       && strncmp (XSTR (op, 0) + 1, LOCAL_LABEL_PREFIX,\n \t\t  sizeof LOCAL_LABEL_PREFIX - 1) == 0\n-      && (current_frame_info.insns_len + get_pool_size () + mips_string_length\n+      && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n \t  < 4 * 0x100))\n     {\n       struct string_constant *l;\n@@ -1722,11 +1744,11 @@ m16_usym5_4 (op, mode)\n {\n   if (GET_CODE (op) == SYMBOL_REF\n       && SYMBOL_REF_FLAG (op)\n-      && current_frame_info.insns_len > 0\n+      && cfun->machine->insns_len > 0\n       && XSTR (op, 0)[0] == '*'\n       && strncmp (XSTR (op, 0) + 1, LOCAL_LABEL_PREFIX,\n \t\t  sizeof LOCAL_LABEL_PREFIX - 1) == 0\n-      && (current_frame_info.insns_len + get_pool_size () + mips_string_length\n+      && (cfun->machine->insns_len + get_pool_size () + mips_string_length\n \t  < 4 * 0x20))\n     {\n       struct string_constant *l;\n@@ -2399,7 +2421,30 @@ mips_move_1word (operands, insn, unsignedp)\n \n   return ret;\n }\n+\f\n+/* Return instructions to restore the global pointer from the stack,\n+   assuming TARGET_ABICALLS.  Used by exception_receiver to set up\n+   the GP for exception handlers.\n+\n+   OPERANDS is an array of operands whose contents are undefined\n+   on entry.  INSN is the exception_handler instruction.  */\n+\n+const char *\n+mips_restore_gp (operands, insn)\n+     rtx *operands, insn;\n+{\n+  rtx loc;\n+\n+  operands[0] = pic_offset_table_rtx;\n+  if (frame_pointer_needed)\n+    loc = hard_frame_pointer_rtx;\n+  else\n+    loc = stack_pointer_rtx;\n+  loc = plus_constant (loc, cfun->machine->frame.args_size);\n+  operands[1] = gen_rtx_MEM (Pmode, loc);\n \n+  return mips_move_1word (operands, insn, 0);\n+}\n \f\n /* Return the appropriate instructions to move 2 words */\n \n@@ -3444,6 +3489,36 @@ mips_gen_conditional_trap (operands)\n \t\t\t      operands[1]));\n }\n \f\n+/* Emit code to change the current function's return address to\n+   ADDRESS.  SCRATCH is available as a scratch register, if needed.\n+   ADDRESS and SCRATCH are both word-mode GPRs.  */\n+\n+void\n+mips_set_return_address (address, scratch)\n+     rtx address, scratch;\n+{\n+  HOST_WIDE_INT gp_offset;\n+\n+  compute_frame_size (get_frame_size ());\n+  if (((cfun->machine->frame.mask >> 31) & 1) == 0)\n+    abort ();\n+  gp_offset = cfun->machine->frame.gp_sp_offset;\n+\n+  /* Reduce SP + GP_OFSET to a legitimate address and put it in SCRATCH.  */\n+  if (gp_offset < 32768)\n+    scratch = plus_constant (stack_pointer_rtx, gp_offset);\n+  else\n+    {\n+      emit_move_insn (scratch, GEN_INT (gp_offset));\n+      if (Pmode == DImode)\n+\temit_insn (gen_adddi3 (scratch, scratch, stack_pointer_rtx));\n+      else\n+\temit_insn (gen_addsi3 (scratch, scratch, stack_pointer_rtx));\n+    }\n+\n+  emit_move_insn (gen_rtx_MEM (GET_MODE (address), scratch), address);\n+}\n+\f\n /* Write a loop to move a constant number of bytes.\n    Generate load/stores as follows:\n \n@@ -5442,9 +5517,9 @@ mips_debugger_offset (addr, offset)\n   if (reg == stack_pointer_rtx || reg == frame_pointer_rtx\n       || reg == hard_frame_pointer_rtx)\n     {\n-      HOST_WIDE_INT frame_size = (!current_frame_info.initialized)\n+      HOST_WIDE_INT frame_size = (!cfun->machine->frame.initialized)\n \t\t\t\t  ? compute_frame_size (get_frame_size ())\n-\t\t\t\t  : current_frame_info.total_size;\n+\t\t\t\t  : cfun->machine->frame.total_size;\n \n       /* MIPS16 frame is smaller */\n       if (frame_pointer_needed && TARGET_MIPS16)\n@@ -6584,17 +6659,17 @@ compute_frame_size (size)\n     total_size = 32;\n \n   /* Save other computed information.  */\n-  current_frame_info.total_size = total_size;\n-  current_frame_info.var_size = var_size;\n-  current_frame_info.args_size = args_size;\n-  current_frame_info.extra_size = extra_size;\n-  current_frame_info.gp_reg_size = gp_reg_size;\n-  current_frame_info.fp_reg_size = fp_reg_size;\n-  current_frame_info.mask = mask;\n-  current_frame_info.fmask = fmask;\n-  current_frame_info.initialized = reload_completed;\n-  current_frame_info.num_gp = gp_reg_size / UNITS_PER_WORD;\n-  current_frame_info.num_fp = fp_reg_size / (FP_INC * UNITS_PER_FPREG);\n+  cfun->machine->frame.total_size = total_size;\n+  cfun->machine->frame.var_size = var_size;\n+  cfun->machine->frame.args_size = args_size;\n+  cfun->machine->frame.extra_size = extra_size;\n+  cfun->machine->frame.gp_reg_size = gp_reg_size;\n+  cfun->machine->frame.fp_reg_size = fp_reg_size;\n+  cfun->machine->frame.mask = mask;\n+  cfun->machine->frame.fmask = fmask;\n+  cfun->machine->frame.initialized = reload_completed;\n+  cfun->machine->frame.num_gp = gp_reg_size / UNITS_PER_WORD;\n+  cfun->machine->frame.num_fp = fp_reg_size / (FP_INC * UNITS_PER_FPREG);\n \n   if (mask)\n     {\n@@ -6608,33 +6683,74 @@ compute_frame_size (size)\n       else\n \toffset = total_size - GET_MODE_SIZE (gpr_mode);\n \n-      current_frame_info.gp_sp_offset = offset;\n-      current_frame_info.gp_save_offset = offset - total_size;\n+      cfun->machine->frame.gp_sp_offset = offset;\n+      cfun->machine->frame.gp_save_offset = offset - total_size;\n     }\n   else\n     {\n-      current_frame_info.gp_sp_offset = 0;\n-      current_frame_info.gp_save_offset = 0;\n+      cfun->machine->frame.gp_sp_offset = 0;\n+      cfun->machine->frame.gp_save_offset = 0;\n     }\n \n   if (fmask)\n     {\n       unsigned long offset = (args_size + extra_size + var_size\n \t\t\t      + gp_reg_rounded + fp_reg_size\n \t\t\t      - FP_INC * UNITS_PER_FPREG);\n-      current_frame_info.fp_sp_offset = offset;\n-      current_frame_info.fp_save_offset = offset - total_size;\n+      cfun->machine->frame.fp_sp_offset = offset;\n+      cfun->machine->frame.fp_save_offset = offset - total_size;\n     }\n   else\n     {\n-      current_frame_info.fp_sp_offset = 0;\n-      current_frame_info.fp_save_offset = 0;\n+      cfun->machine->frame.fp_sp_offset = 0;\n+      cfun->machine->frame.fp_save_offset = 0;\n     }\n \n   /* Ok, we're done.  */\n   return total_size;\n }\n \f\n+/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n+   pointer, argument pointer, or return address pointer.  TO is either\n+   the stack pointer or hard frame pointer.  */\n+\n+int\n+mips_initial_elimination_offset (from, to)\n+     int from, to;\n+{\n+  int offset;\n+\n+  /* Set OFFSET to the offset from the stack pointer.  */\n+  switch (from)\n+    {\n+    case FRAME_POINTER_REGNUM:\n+      offset = 0;\n+      break;\n+\n+    case ARG_POINTER_REGNUM:\n+      compute_frame_size (get_frame_size ());\n+      offset = cfun->machine->frame.total_size;\n+      if (mips_abi == ABI_N32 || mips_abi == ABI_64 || mips_abi == ABI_MEABI)\n+\toffset -= current_function_pretend_args_size;\n+      break;\n+\n+    case RETURN_ADDRESS_POINTER_REGNUM:\n+      compute_frame_size (get_frame_size ());\n+      offset = cfun->machine->frame.gp_sp_offset;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset += UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (TARGET_MIPS16 && to == HARD_FRAME_POINTER_REGNUM)\n+    offset -= current_function_outgoing_args_size;\n+\n+  return offset;\n+}\n+\f\n /* Common code to emit the insns (or to write the instructions to a file)\n    to save/restore registers.\n \n@@ -6731,8 +6847,8 @@ save_restore_insns (store_p, large_reg, large_offset)\n      rtx large_reg;\t/* register holding large offset constant or NULL */\n      long large_offset;\t/* large constant offset value */\n {\n-  long mask = current_frame_info.mask;\n-  long fmask = current_frame_info.fmask;\n+  long mask = cfun->machine->frame.mask;\n+  long fmask = cfun->machine->frame.fmask;\n   long real_mask = mask;\n   int regno;\n   rtx base_reg_rtx;\n@@ -6769,9 +6885,9 @@ save_restore_insns (store_p, large_reg, large_offset)\n \t the constant created in the prologue/epilogue to adjust the stack\n \t frame.  */\n \n-      gp_offset = current_frame_info.gp_sp_offset;\n+      gp_offset = cfun->machine->frame.gp_sp_offset;\n       end_offset\n-\t= gp_offset - (current_frame_info.gp_reg_size\n+\t= gp_offset - (cfun->machine->frame.gp_reg_size\n \t\t       - GET_MODE_SIZE (gpr_mode));\n \n       if (gp_offset < 0 || end_offset < 0)\n@@ -6879,8 +6995,8 @@ save_restore_insns (store_p, large_reg, large_offset)\n   if (fmask)\n     {\n       /* Pick which pointer to use as a base register.  */\n-      fp_offset = current_frame_info.fp_sp_offset;\n-      end_offset = fp_offset - (current_frame_info.fp_reg_size\n+      fp_offset = cfun->machine->frame.fp_sp_offset;\n+      end_offset = fp_offset - (cfun->machine->frame.fp_reg_size\n \t\t\t\t- UNITS_PER_FPVALUE);\n \n       if (fp_offset < 0 || end_offset < 0)\n@@ -6951,7 +7067,7 @@ mips_output_function_prologue (file, size)\n #ifndef FUNCTION_NAME_ALREADY_DECLARED\n   const char *fnname;\n #endif\n-  HOST_WIDE_INT tsize = current_frame_info.total_size;\n+  HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n \n   /* ??? When is this really needed?  At least the GNU assembler does not\n      need the source filename more than once in the file, beyond what is\n@@ -7002,18 +7118,18 @@ mips_output_function_prologue (file, size)\n \t\t? ((long) tsize - current_function_outgoing_args_size)\n \t\t: (long) tsize),\n \t       reg_names[GP_REG_FIRST + 31],\n-\t       current_frame_info.var_size,\n-\t       current_frame_info.num_gp,\n-\t       current_frame_info.num_fp,\n+\t       cfun->machine->frame.var_size,\n+\t       cfun->machine->frame.num_gp,\n+\t       cfun->machine->frame.num_fp,\n \t       current_function_outgoing_args_size,\n-\t       current_frame_info.extra_size);\n+\t       cfun->machine->frame.extra_size);\n \n       /* .mask MASK, GPOFFSET; .fmask FPOFFSET */\n       fprintf (file, \"\\t.mask\\t0x%08lx,%ld\\n\\t.fmask\\t0x%08lx,%ld\\n\",\n-\t       current_frame_info.mask,\n-\t       current_frame_info.gp_save_offset,\n-\t       current_frame_info.fmask,\n-\t       current_frame_info.fp_save_offset);\n+\t       cfun->machine->frame.mask,\n+\t       cfun->machine->frame.gp_save_offset,\n+\t       cfun->machine->frame.fmask,\n+\t       cfun->machine->frame.fp_save_offset);\n \n       /* Require:\n \t OLD_SP == *FRAMEREG + FRAMESIZE => can find old_sp from nominated FP reg.\n@@ -7022,9 +7138,9 @@ mips_output_function_prologue (file, size)\n \n   if (mips_entry && ! mips_can_use_return_insn ())\n     {\n-      int save16 = BITSET_P (current_frame_info.mask, 16);\n-      int save17 = BITSET_P (current_frame_info.mask, 17);\n-      int save31 = BITSET_P (current_frame_info.mask, 31);\n+      int save16 = BITSET_P (cfun->machine->frame.mask, 16);\n+      int save17 = BITSET_P (cfun->machine->frame.mask, 17);\n+      int save31 = BITSET_P (cfun->machine->frame.mask, 31);\n       int savearg = 0;\n       rtx insn;\n \n@@ -7146,7 +7262,7 @@ mips_output_function_prologue (file, size)\n \t  fprintf (file, \"\\t%s\\t%s,%s,%ld\\n\",\n \t\t   (Pmode == DImode ? \"dsubu\" : \"subu\"),\n \t\t   sp_str, sp_str, (long) tsize);\n-\t  fprintf (file, \"\\t.cprestore %ld\\n\", current_frame_info.args_size);\n+\t  fprintf (file, \"\\t.cprestore %ld\\n\", cfun->machine->frame.args_size);\n \t}\n \n       if (dwarf2out_do_frame ())\n@@ -7355,17 +7471,17 @@ mips_expand_prologue ()\n \t which may return a floating point value.  Set up a sequence\n \t of instructions to do so.  Later on we emit them at the right\n \t moment.  */\n-      if (TARGET_MIPS16 && BITSET_P (current_frame_info.mask, 18))\n+      if (TARGET_MIPS16 && BITSET_P (cfun->machine->frame.mask, 18))\n \t{\n \t  rtx reg_rtx = gen_rtx (REG, gpr_mode, GP_REG_FIRST + 3);\n \t  long gp_offset, base_offset;\n \n-\t  gp_offset = current_frame_info.gp_sp_offset;\n-\t  if (BITSET_P (current_frame_info.mask, 16))\n+\t  gp_offset = cfun->machine->frame.gp_sp_offset;\n+\t  if (BITSET_P (cfun->machine->frame.mask, 16))\n \t    gp_offset -= UNITS_PER_WORD;\n-\t  if (BITSET_P (current_frame_info.mask, 17))\n+\t  if (BITSET_P (cfun->machine->frame.mask, 17))\n \t    gp_offset -= UNITS_PER_WORD;\n-\t  if (BITSET_P (current_frame_info.mask, 31))\n+\t  if (BITSET_P (cfun->machine->frame.mask, 31))\n \t    gp_offset -= UNITS_PER_WORD;\n \t  if (tsize > 32767)\n \t    base_offset = tsize;\n@@ -7547,8 +7663,8 @@ mips_output_function_epilogue (file, size)\n \n   if (TARGET_STATS)\n     {\n-      int num_gp_regs = current_frame_info.gp_reg_size / 4;\n-      int num_fp_regs = current_frame_info.fp_reg_size / 8;\n+      int num_gp_regs = cfun->machine->frame.gp_reg_size / 4;\n+      int num_fp_regs = cfun->machine->frame.fp_reg_size / 8;\n       int num_regs = num_gp_regs + num_fp_regs;\n       const char *name = fnname;\n \n@@ -7560,10 +7676,10 @@ mips_output_function_epilogue (file, size)\n       fprintf (stderr,\n \t       \"%-20s fp=%c leaf=%c alloca=%c setjmp=%c stack=%4ld arg=%3d reg=%2d/%d delay=%3d/%3dL %3d/%3dJ refs=%3d/%3d/%3d\",\n \t       name, frame_pointer_needed ? 'y' : 'n',\n-\t       (current_frame_info.mask & RA_MASK) != 0 ? 'n' : 'y',\n+\t       (cfun->machine->frame.mask & RA_MASK) != 0 ? 'n' : 'y',\n \t       current_function_calls_alloca ? 'y' : 'n',\n \t       current_function_calls_setjmp ? 'y' : 'n',\n-\t       current_frame_info.total_size,\n+\t       cfun->machine->frame.total_size,\n \t       current_function_outgoing_args_size, num_gp_regs, num_fp_regs,\n \t       dslots_load_total, dslots_load_filled,\n \t       dslots_jump_total, dslots_jump_filled,\n@@ -7584,7 +7700,6 @@ mips_output_function_epilogue (file, size)\n   num_refs[2] = 0;\n   mips_load_reg = 0;\n   mips_load_reg2 = 0;\n-  current_frame_info = zero_frame_info;\n \n   while (string_constants != NULL)\n     {\n@@ -7610,7 +7725,7 @@ mips_output_function_epilogue (file, size)\n void\n mips_expand_epilogue ()\n {\n-  HOST_WIDE_INT tsize = current_frame_info.total_size;\n+  HOST_WIDE_INT tsize = cfun->machine->frame.total_size;\n   rtx tsize_rtx = GEN_INT (tsize);\n   rtx tmp_rtx = (rtx)0;\n \n@@ -7679,7 +7794,7 @@ mips_expand_epilogue ()\n \t are going to restore it, then we must emit a blockage insn to\n \t prevent the scheduler from moving the restore out of the epilogue.  */\n       else if (TARGET_ABICALLS && mips_abi != ABI_32 && mips_abi != ABI_O64\n-\t       && (current_frame_info.mask\n+\t       && (cfun->machine->frame.mask\n \t\t   & (1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))))\n \temit_insn (gen_blockage ());\n \n@@ -7741,7 +7856,7 @@ mips_expand_epilogue ()\n     }\n \n   /* The mips16 loads the return address into $7, not $31.  */\n-  if (TARGET_MIPS16 && (current_frame_info.mask & RA_MASK) != 0)\n+  if (TARGET_MIPS16 && (cfun->machine->frame.mask & RA_MASK) != 0)\n     emit_jump_insn (gen_return_internal (gen_rtx (REG, Pmode,\n \t\t\t\t\t\t  GP_REG_FIRST + 7)));\n   else\n@@ -7776,8 +7891,8 @@ mips_can_use_return_insn ()\n       && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n     return 0;\n \n-  if (current_frame_info.initialized)\n-    return current_frame_info.total_size == 0;\n+  if (cfun->machine->frame.initialized)\n+    return cfun->machine->frame.total_size == 0;\n \n   return compute_frame_size (get_frame_size ()) == 0;\n }\n@@ -9457,9 +9572,9 @@ machine_dependent_reorg (first)\n \t}\n     }\n \n-  /* Store the original value of insns_len in current_frame_info, so\n+  /* Store the original value of insns_len in cfun->machine, so\n      that simple_memory_operand can look at it.  */\n-  current_frame_info.insns_len = insns_len;\n+  cfun->machine->insns_len = insns_len;\n \n   pool_size = get_pool_size ();\n   if (insns_len + pool_size + mips_string_length < 0x8000)"}, {"sha": "7db331be976b3c4515df073e9aebf12f14c0f0b0", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 66, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=b24718388c6e66ef6a3713fd56bf6158fe57134d", "patch": "@@ -2346,31 +2346,6 @@ extern enum reg_class mips_char_to_class[256];\n \n #define TARGET_PTRMEMFUNC_VBIT_LOCATION ptrmemfunc_vbit_in_delta\n \n-/* Structure to be filled in by compute_frame_size with register\n-   save masks, and offsets for the current function.  */\n-\n-struct mips_frame_info\n-{\n-  long total_size;\t\t/* # bytes that the entire frame takes up */\n-  long var_size;\t\t/* # bytes that variables take up */\n-  long args_size;\t\t/* # bytes that outgoing arguments take up */\n-  long extra_size;\t\t/* # bytes of extra gunk */\n-  int  gp_reg_size;\t\t/* # bytes needed to store gp regs */\n-  int  fp_reg_size;\t\t/* # bytes needed to store fp regs */\n-  long mask;\t\t\t/* mask of saved gp registers */\n-  long fmask;\t\t\t/* mask of saved fp registers */\n-  long gp_save_offset;\t\t/* offset from vfp to store gp registers */\n-  long fp_save_offset;\t\t/* offset from vfp to store fp registers */\n-  long gp_sp_offset;\t\t/* offset from new sp to store gp registers */\n-  long fp_sp_offset;\t\t/* offset from new sp to store fp registers */\n-  int  initialized;\t\t/* != 0 if frame size already calculated */\n-  int  num_gp;\t\t\t/* number of gp registers saved */\n-  int  num_fp;\t\t\t/* number of fp registers saved */\n-  long insns_len;\t\t/* length of insns; mips16 only */\n-};\n-\n-extern struct mips_frame_info current_frame_info;\n-\n /* If defined, this macro specifies a table of register pairs used to\n    eliminate unneeded registers that point into the stack frame.  If\n    it is not defined, the only elimination attempted by the compiler\n@@ -2442,47 +2417,8 @@ extern struct mips_frame_info current_frame_info;\n \t      && (! TARGET_MIPS16\t\t\t\t\t\\\n \t          || compute_frame_size (get_frame_size ()) < 32768)))))\n \n-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n-   specifies the initial difference between the specified pair of\n-   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n-   defined.  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n-{  compute_frame_size (get_frame_size ());\t\t\t\t \\\n-  if (TARGET_MIPS16 && (FROM) == FRAME_POINTER_REGNUM\t\t\t \\\n-      && (TO) == HARD_FRAME_POINTER_REGNUM)\t\t\t\t \\\n-    (OFFSET) = - current_function_outgoing_args_size;\t\t\t \\\n-  else if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t \\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t \\\n-  else if (TARGET_MIPS16 && (FROM) == ARG_POINTER_REGNUM\t\t \\\n-\t   && (TO) == HARD_FRAME_POINTER_REGNUM)\t\t\t \\\n-    (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n-\t\t- current_function_outgoing_args_size\t\t\t \\\n-\t\t- ((mips_abi != ABI_32 \t\t\t\t\t \\\n-\t\t    && mips_abi != ABI_O64\t\t\t\t \\\n-\t\t    && mips_abi != ABI_EABI)\t\t\t\t \\\n-\t\t   ? current_function_pretend_args_size\t\t\t \\\n-\t\t   : 0));\t\t\t\t\t\t \\\n-  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t \\\n-    (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n-\t\t- ((mips_abi != ABI_32 \t\t\t\t\t \\\n-\t\t    && mips_abi != ABI_O64\t\t\t\t \\\n-\t\t    && mips_abi != ABI_EABI)\t\t\t\t \\\n-\t\t   ? current_function_pretend_args_size\t\t\t \\\n-\t\t   : 0));\t\t\t\t\t\t \\\n-  /* Some ABIs store 64 bits to the stack, but Pmode is 32 bits,\t \\\n-     so we must add 4 bytes to the offset to get the right value.  */\t \\\n-  else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM)\t\t\t \\\n-  {\t\t\t\t\t\t\t\t\t \\\n-    (OFFSET) = current_frame_info.gp_sp_offset\t\t\t \t \\\n-      + ((UNITS_PER_WORD - (POINTER_SIZE / BITS_PER_UNIT))\t\t \\\n-\t * (BYTES_BIG_ENDIAN != 0));\t\t\t\t\t \\\n-    if (TARGET_MIPS16 && (TO) != STACK_POINTER_REGNUM)\t\t\t \\\n-      (OFFSET) -= current_function_outgoing_args_size;\t\t\t \\\n-  }\t\t\t\t\t\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    abort();\t\t\t\t\t\t\t\t \\\n-}\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+\t(OFFSET) = mips_initial_elimination_offset ((FROM), (TO))\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by."}, {"sha": "7335da0e47cb51203a1f8c36ad0f305b6e484032", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b24718388c6e66ef6a3713fd56bf6158fe57134d/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=b24718388c6e66ef6a3713fd56bf6158fe57134d", "patch": "@@ -10022,49 +10022,14 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n   [(const_int 0)]\n   \"\n {\n-  HOST_WIDE_INT gp_offset;\n-  rtx base;\n-\n-  compute_frame_size (get_frame_size ());\n-  if (((current_frame_info.mask >> 31) & 1) == 0)\n-    abort ();\n-  gp_offset = current_frame_info.gp_sp_offset;\n-\n-  if (gp_offset < 32768)\n-    base = stack_pointer_rtx;\n-  else\n-    {\n-      base = operands[1];\n-      emit_move_insn (base, GEN_INT (gp_offset));\n-      if (Pmode == DImode)\n-\temit_insn (gen_adddi3 (base, base, stack_pointer_rtx));\n-      else\n-\temit_insn (gen_addsi3 (base, base, stack_pointer_rtx));\n-      gp_offset = 0;\n-    }\n-  emit_move_insn (gen_rtx_MEM (GET_MODE (operands[0]),\n-\t\t\t       plus_constant (base, gp_offset)),\n-\t\t  operands[0]);\n+  mips_set_return_address (operands[0], operands[1]);\n   DONE;\n }\")\n \n (define_insn \"exception_receiver\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_EH_RECEIVER)]\n   \"TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64)\"\n-  \"*\n-{\n-  rtx loc;\n-\n-  operands[0] = pic_offset_table_rtx;\n-  if (frame_pointer_needed)\n-    loc = hard_frame_pointer_rtx;\n-  else\n-    loc = stack_pointer_rtx;\n-  loc = plus_constant (loc, current_frame_info.args_size);\n-  operands[1] = gen_rtx_MEM (Pmode, loc);\n-\n-  return mips_move_1word (operands, insn, 0);\n-}\"\n+  \"* return mips_restore_gp (operands, insn);\"\n   [(set_attr \"type\"   \"load\")\n    (set_attr \"length\" \"8\")])\n \f"}]}