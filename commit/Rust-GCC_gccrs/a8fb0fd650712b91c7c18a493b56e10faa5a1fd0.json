{"sha": "a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThmYjBmZDY1MDcxMmI5MWM3YzE4YTQ5M2I1NmUxMGZhYTVhMWZkMA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-08T16:30:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-09T08:54:09Z"}, "message": "Add builting block for simple intrinsics\n\nWe need a way to be able to turn intrinsic function prototypes and\nassociated function calls into the GCC builtin. The GCC wrapper was\nreused from GO and the math builtin's don't seem to be correct, here\nI changed __builtin_sin to __builtin_sinf to get the float version.\n\nSee builtins.def for the other builtins.", "tree": {"sha": "89a413835cffd57a000a26f899a30da857cc00c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89a413835cffd57a000a26f899a30da857cc00c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "782cbcdee4047e47ed122d082f51c37db9fdeda2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782cbcdee4047e47ed122d082f51c37db9fdeda2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782cbcdee4047e47ed122d082f51c37db9fdeda2"}], "stats": {"total": 699, "additions": 414, "deletions": 285}, "files": [{"sha": "d2d74e3933607e254c4969f98e37c10f1c046fd5", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -86,6 +86,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n+    rust/rust-compile-intrinsic.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "5a268629581435c09293a66ec518b1268757974c", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -1,5 +1,3 @@\n-\n-\n // This file is part of GCC.\n \n // GCC is free software; you can redistribute it and/or modify it under"}, {"sha": "d78a56613e8b02a1927618834cf0eb88a5dc46c5", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -20,6 +20,7 @@\n #define RUST_COMPILE_EXTERN_ITEM\n \n #include \"rust-compile-base.h\"\n+#include \"rust-compile-intrinsic.h\"\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-compile-var-decl.h\"\n@@ -118,6 +119,15 @@ class CompileExternItem : public HIRCompileBase\n \tfntype->override_context ();\n       }\n \n+    if (fntype->get_abi () == TyTy::FnType::ABI::INTRINSIC)\n+      {\n+\tIntrinsics compile (ctx);\n+\tBfunction *fndecl = compile.compile (fntype);\n+\tctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+\treturn;\n+      }\n+\n+    rust_assert (fntype->get_abi () == TyTy::FnType::ABI::C);\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     const unsigned int flags"}, {"sha": "4068a7a62ddb47795f1e15d90b6cbfe8c201c008", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -0,0 +1,91 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-intrinsic.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n+\n+Bfunction *\n+Intrinsics::compile (TyTy::FnType *fntype)\n+{\n+  rust_assert (fntype->get_abi () == TyTy::FnType::ABI::INTRINSIC);\n+\n+  // https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+  // https://github.com/Rust-GCC/gccrs/issues/658\n+\n+  //   let llvm_name = match name {\n+  //     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+  //     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+  //     sym::powif32 => \"llvm.powi.f32\",\n+  //     sym::powif64 => \"llvm.powi.f64\",\n+  //     sym::sinf32 => \"llvm.sin.f32\",\n+  //     sym::sinf64 => \"llvm.sin.f64\",\n+  //     sym::cosf32 => \"llvm.cos.f32\",\n+  //     sym::cosf64 => \"llvm.cos.f64\",\n+  //     sym::powf32 => \"llvm.pow.f32\",\n+  //     sym::powf64 => \"llvm.pow.f64\",\n+  //     sym::expf32 => \"llvm.exp.f32\",\n+  //     sym::expf64 => \"llvm.exp.f64\",\n+  //     sym::exp2f32 => \"llvm.exp2.f32\",\n+  //     sym::exp2f64 => \"llvm.exp2.f64\",\n+  //     sym::logf32 => \"llvm.log.f32\",\n+  //     sym::logf64 => \"llvm.log.f64\",\n+  //     sym::log10f32 => \"llvm.log10.f32\",\n+  //     sym::log10f64 => \"llvm.log10.f64\",\n+  //     sym::log2f32 => \"llvm.log2.f32\",\n+  //     sym::log2f64 => \"llvm.log2.f64\",\n+  //     sym::fmaf32 => \"llvm.fma.f32\",\n+  //     sym::fmaf64 => \"llvm.fma.f64\",\n+  //     sym::fabsf32 => \"llvm.fabs.f32\",\n+  //     sym::fabsf64 => \"llvm.fabs.f64\",\n+  //     sym::minnumf32 => \"llvm.minnum.f32\",\n+  //     sym::minnumf64 => \"llvm.minnum.f64\",\n+  //     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+  //     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+  //     sym::copysignf32 => \"llvm.copysign.f32\",\n+  //     sym::copysignf64 => \"llvm.copysign.f64\",\n+  //     sym::floorf32 => \"llvm.floor.f32\",\n+  //     sym::floorf64 => \"llvm.floor.f64\",\n+  //     sym::ceilf32 => \"llvm.ceil.f32\",\n+  //     sym::ceilf64 => \"llvm.ceil.f64\",\n+  //     sym::truncf32 => \"llvm.trunc.f32\",\n+  //     sym::truncf64 => \"llvm.trunc.f64\",\n+  //     sym::rintf32 => \"llvm.rint.f32\",\n+  //     sym::rintf64 => \"llvm.rint.f64\",\n+  //     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+  //     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+  //     sym::roundf32 => \"llvm.round.f32\",\n+  //     sym::roundf64 => \"llvm.round.f64\",\n+  //     _ => return None,\n+  // };\n+  // Some(cx.get_intrinsic(&llvm_name))\n+\n+  Bfunction *builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n+    fntype->get_identifier ());\n+  if (builtin != nullptr)\n+    return builtin;\n+\n+  Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n+  rust_error_at (locus, \"unknown builtin\");\n+\n+  return ctx->get_backend ()->error_function ();\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "25e298aa57b813e9198991e1b664d6fda83fa1d6", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -0,0 +1,39 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_INTRINSIC\n+#define RUST_COMPILE_INTRINSIC\n+\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class Intrinsics\n+{\n+public:\n+  Intrinsics (Context *ctx);\n+\n+  Bfunction *compile (TyTy::FnType *fntype);\n+\n+private:\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_INTRINSIC"}, {"sha": "105b2eae2880a0bbae1b4fc3afe413ae73e715e9", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -842,7 +842,9 @@ class Backend\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction *lookup_builtin (const std::string &) = 0;\n+  virtual Bfunction *lookup_gcc_builtin (const std::string &) = 0;\n+\n+  virtual Bfunction *lookup_builtin_by_rust_name (const std::string &) = 0;\n \n   // Utility.\n "}, {"sha": "453481ed37be2fcc76fbafd661e7091793ba21c6", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 226, "deletions": 282, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -512,7 +512,9 @@ class Gcc_backend : public Backend\n \n   bool function_set_body (Bfunction *function, Bstatement *code_stmt);\n \n-  Bfunction *lookup_builtin (const std::string &);\n+  Bfunction *lookup_gcc_builtin (const std::string &);\n+\n+  Bfunction *lookup_builtin_by_rust_name (const std::string &);\n \n   void write_global_definitions (const std::vector<Btype *> &,\n \t\t\t\t const std::vector<Bexpression *> &,\n@@ -546,11 +548,13 @@ class Gcc_backend : public Backend\n   static const int builtin_noreturn = 1 << 1;\n   static const int builtin_novops = 1 << 2;\n \n-  void define_builtin (built_in_function bcode, const char *name,\n-\t\t       const char *libname, tree fntype, int flags);\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n   std::map<std::string, Bfunction *> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n // A helper function to create a GCC identifier from a C++ string.\n@@ -567,303 +571,230 @@ Gcc_backend::Gcc_backend ()\n {\n   /* We need to define the fetch_and_add functions, since we use them\n      for ++ and --.  */\n-  tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n-  tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  // We use __builtin_expect for magic import functions.\n-  this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n-\t\t\tbuild_function_type_list (long_integer_type_node,\n-\t\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-\n-  // We use __builtin_memcmp for struct comparisons.\n-  this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // We use __builtin_memmove for copying data.\n-  this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n-\t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // We use __builtin_memset for zeroing data.\n-  this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n-\t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t\t  integer_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // Used by runtime/internal/sys and math/bits.\n-  this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n-\t\t\t\"popcountll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n-\t\t\tbuild_function_type_list (uint16_type_node,\n-\t\t\t\t\t\t  uint16_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n-\t\t\tbuild_function_type_list (uint32_type_node,\n-\t\t\t\t\t\t  uint32_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n-\t\t\tbuild_function_type_list (uint64_type_node,\n-\t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n+  // tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n+  // tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1,\n+  // \"__sync_fetch_and_add_1\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2,\n+  // \"__sync_fetch_and_add_2\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4,\n+  // \"__sync_fetch_and_add_4\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8,\n+  // \"__sync_fetch_and_add_8\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // // We use __builtin_expect for magic import functions.\n+  // this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n+  //       \t\tbuild_function_type_list (long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+\n+  // // We use __builtin_memcmp for struct comparisons.\n+  // this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memmove for copying data.\n+  // this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memset for zeroing data.\n+  // this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  integer_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // Used by runtime/internal/sys and math/bits.\n+  // this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n+  //       \t\t\"popcountll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n+  //       \t\tbuild_function_type_list (uint16_type_node,\n+  //       \t\t\t\t\t  uint16_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n+  //       \t\tbuild_function_type_list (uint32_type_node,\n+  //       \t\t\t\t\t  uint32_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n+  //       \t\tbuild_function_type_list (uint64_type_node,\n+  //       \t\t\t\t\t  uint64_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n \n   // We provide some functions for the math library.\n-  tree math_function_type\n-    = build_function_type_list (double_type_node, double_type_node, NULL_TREE);\n-  tree math_function_type_long\n-    = build_function_type_list (long_double_type_node, long_double_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree math_function_type_two\n-    = build_function_type_list (double_type_node, double_type_node,\n-\t\t\t\tdouble_type_node, NULL_TREE);\n-  tree math_function_type_long_two\n-    = build_function_type_list (long_double_type_node, long_double_type_node,\n-\t\t\t\tlong_double_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n-\t\t\tmath_function_type_two, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n-\t\t\tmath_function_type_long_two, builtin_const);\n-  this->define_builtin (BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n-\t\t\tmath_function_type_two, builtin_const);\n-  this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n-\t\t\tmath_function_type_long_two, builtin_const);\n-  this->define_builtin (BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n-\t\t\tbuild_function_type_list (double_type_node,\n-\t\t\t\t\t\t  double_type_node,\n-\t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n-\t\t\tbuild_function_type_list (long_double_type_node,\n-\t\t\t\t\t\t  long_double_type_node,\n-\t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n-\t\t\tmath_function_type_long, builtin_const);\n+  tree math_function_type_f32\n+    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+  this->define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t\tmath_function_type_f32, builtin_const);\n+\n+  this->define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t\tmath_function_type_f32, builtin_const);\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n-  t = build_function_type_list (ptr_type_node, unsigned_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n-\t\t\tNULL, t, 0);\n+  // t = build_function_type_list (ptr_type_node, unsigned_type_node,\n+  // NULL_TREE); this->define_builtin (BUILT_IN_RETURN_ADDRESS,\n+  // \"__builtin_return_address\",\n+  //       \t\tNULL, t, 0);\n \n   // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n-  t = build_function_type_list (ptr_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t, 0);\n+  // t = build_function_type_list (ptr_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t,\n+  // 0);\n \n   // The runtime calls __builtin_extract_return_addr when recording\n   // the address to which a function returns.\n-  this->define_builtin (\n-    BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n-    build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n+  // this->define_builtin (\n+  //   BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n+  //   build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n \n   // The compiler uses __builtin_trap for some exception handling\n   // cases.\n-  this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n-\t\t\tbuild_function_type (void_type_node, void_list_node),\n-\t\t\tbuiltin_noreturn);\n+  // this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_noreturn);\n \n   // The runtime uses __builtin_prefetch.\n-  this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n-\t\t\tbuild_varargs_function_type_list (void_type_node,\n-\t\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_novops);\n+  // this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n+  //       \t\tbuild_varargs_function_type_list (void_type_node,\n+  //       \t\t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_novops);\n \n   // The compiler uses __builtin_unreachable for cases that cannot\n   // occur.\n-  this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n-\t\t\tbuild_function_type (void_type_node, void_list_node),\n-\t\t\tbuiltin_const | builtin_noreturn);\n+  // this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_const | builtin_noreturn);\n \n   // We provide some atomic functions.\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t, 0);\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, uint32_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n-\t\t\t0);\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, uint64_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n-\t\t\t0);\n-\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\", NULL,\n-\t\t\tt, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\", NULL,\n-\t\t\tt, 0);\n-\n-  t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, boolean_type_node,\n-\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n-\t\t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n-\n-  t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, boolean_type_node,\n-\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n-\t\t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n-\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n-\t\t\t\tunsigned_char_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n-\t\t\tNULL, t, 0);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n-\t\t\t\tunsigned_char_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\", NULL,\n-\t\t\tt, 0);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n-\t\t\tt, 0);\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint32_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint64_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint32_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n+  //       \t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint64_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n+  //       \t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n+  //       \t\tNULL, t, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n }\n \n // Get an unnamed integer type.\n@@ -3490,13 +3421,23 @@ Gcc_backend::function_set_body (Bfunction *function, Bstatement *code_stmt)\n // Returns NULL if no built-in function by that name exists.\n \n Bfunction *\n-Gcc_backend::lookup_builtin (const std::string &name)\n+Gcc_backend::lookup_gcc_builtin (const std::string &name)\n {\n   if (this->builtin_functions_.count (name) != 0)\n     return this->builtin_functions_[name];\n   return NULL;\n }\n \n+Bfunction *\n+Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n+{\n+  auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+  if (it == rust_intrinsic_to_gcc_builtin.end ())\n+    return NULL;\n+\n+  return lookup_gcc_builtin (it->second);\n+}\n+\n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n // FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n // emit early debugging information.\n@@ -3586,7 +3527,8 @@ Gcc_backend::write_export_data (const char *bytes, unsigned int size)\n // NORETURN_P is true if the function has the noreturn attribute.\n \n void\n-Gcc_backend::define_builtin (built_in_function bcode, const char *name,\n+Gcc_backend::define_builtin (const std::string rust_name,\n+\t\t\t     built_in_function bcode, const char *name,\n \t\t\t     const char *libname, tree fntype, int flags)\n {\n   tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n@@ -3611,6 +3553,8 @@ Gcc_backend::define_builtin (built_in_function bcode, const char *name,\n \tDECL_IS_NOVOPS (decl) = 1;\n       this->builtin_functions_[libname] = this->make_function (decl);\n     }\n+\n+  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n }\n \n // Return the backend generator."}, {"sha": "fa825ae0f5ee5dd67771b60314171b54931065f9", "filename": "gcc/testsuite/rust/execute/torture/sinf32.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsinf32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsinf32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsinf32.rs?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-output \"0.893\" }*/\n+extern \"rust-intrinsic\" {\n+    pub fn sinf32(x: f32) -> f32;\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn main() -> i32 {\n+    unsafe {\n+        let res;\n+        res = sinf32(90f32);\n+\n+        let a = \"%f\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res as f64);\n+    }\n+    0\n+}"}, {"sha": "3a53a7ce398843b8b7fbfc639c313bd16167da78", "filename": "gcc/testsuite/rust/execute/torture/sqrtf32.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsqrtf32.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8fb0fd650712b91c7c18a493b56e10faa5a1fd0/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsqrtf32.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fsqrtf32.rs?ref=a8fb0fd650712b91c7c18a493b56e10faa5a1fd0", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-output \"6\" }*/\n+extern \"rust-intrinsic\" {\n+    pub fn sqrtf32(x: f32) -> f32;\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn main() -> i32 {\n+    unsafe {\n+        let res;\n+        res = sqrtf32(36f32);\n+\n+        let a = \"%f\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, res as f64);\n+    }\n+    0\n+}"}]}