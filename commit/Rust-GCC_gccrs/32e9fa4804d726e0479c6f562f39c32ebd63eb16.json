{"sha": "32e9fa4804d726e0479c6f562f39c32ebd63eb16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJlOWZhNDgwNGQ3MjZlMDQ3OWM2ZjU2MmYzOWMzMmViZDYzZWIxNg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-15T17:34:40Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-15T17:34:40Z"}, "message": "bt-load.c (add_btr_def, [...]): Avoid C++ keywords.\n\n\t* bt-load.c (add_btr_def, migrate_btr_def,\n\tbranch_target_load_optimize): Avoid C++ keywords.\n\t* caller-save.c (insert_restore, insert_save, insert_one_insn):\n\tLikewise.\n\t* combine.c (subst, simplify_set, make_extraction,\n\tmake_compound_operation, known_cond, simplify_shift_const_1):\n\tLikewise.\n\t* cse.c (make_regs_eqv, merge_equiv_classes, validate_canon_reg,\n\tfold_rtx, equiv_constant, cse_insn, cse_process_notes_1):\n\tLikewise.\n\nFrom-SVN: r137847", "tree": {"sha": "02e1704b0fbbce8c765fe4c17eb43c0e05c6cb11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02e1704b0fbbce8c765fe4c17eb43c0e05c6cb11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32e9fa4804d726e0479c6f562f39c32ebd63eb16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e9fa4804d726e0479c6f562f39c32ebd63eb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e9fa4804d726e0479c6f562f39c32ebd63eb16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e9fa4804d726e0479c6f562f39c32ebd63eb16/comments", "author": null, "committer": null, "parents": [{"sha": "ac7ee6adbe648bf0144976989030fac57798f6f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7ee6adbe648bf0144976989030fac57798f6f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7ee6adbe648bf0144976989030fac57798f6f9"}], "stats": {"total": 476, "additions": 244, "deletions": 232}, "files": [{"sha": "8876f59be44207ad39efb520d0ab52cc3efad2ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32e9fa4804d726e0479c6f562f39c32ebd63eb16", "patch": "@@ -1,3 +1,16 @@\n+2008-07-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* bt-load.c (add_btr_def, migrate_btr_def,\n+\tbranch_target_load_optimize): Avoid C++ keywords.\n+\t* caller-save.c (insert_restore, insert_save, insert_one_insn):\n+\tLikewise.\n+\t* combine.c (subst, simplify_set, make_extraction,\n+\tmake_compound_operation, known_cond, simplify_shift_const_1):\n+\tLikewise.\n+\t* cse.c (make_regs_eqv, merge_equiv_classes, validate_canon_reg,\n+\tfold_rtx, equiv_constant, cse_insn, cse_process_notes_1):\n+\tLikewise.\n+\n 2008-07-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/36369"}, {"sha": "2d4b3e0ad3eeaf0a014a7da5f4aad8def50ae8c6", "filename": "gcc/bt-load.c", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=32e9fa4804d726e0479c6f562f39c32ebd63eb16", "patch": "@@ -301,31 +301,30 @@ add_btr_def (fibheap_t all_btr_defs, basic_block bb, int insn_luid, rtx insn,\n \t     unsigned int dest_reg, int other_btr_uses_before_def,\n \t     btr_def_group *all_btr_def_groups)\n {\n-  btr_def this\n-    = XOBNEW (&migrate_btrl_obstack, struct btr_def_s);\n-  this->bb = bb;\n-  this->luid = insn_luid;\n-  this->insn = insn;\n-  this->btr = dest_reg;\n-  this->cost = basic_block_freq (bb);\n-  this->has_ambiguous_use = 0;\n-  this->other_btr_uses_before_def = other_btr_uses_before_def;\n-  this->other_btr_uses_after_use = 0;\n-  this->next_this_bb = NULL;\n-  this->next_this_group = NULL;\n-  this->uses = NULL;\n-  this->live_range = NULL;\n-  find_btr_def_group (all_btr_def_groups, this);\n-\n-  fibheap_insert (all_btr_defs, -this->cost, this);\n+  btr_def this_def = XOBNEW (&migrate_btrl_obstack, struct btr_def_s);\n+  this_def->bb = bb;\n+  this_def->luid = insn_luid;\n+  this_def->insn = insn;\n+  this_def->btr = dest_reg;\n+  this_def->cost = basic_block_freq (bb);\n+  this_def->has_ambiguous_use = 0;\n+  this_def->other_btr_uses_before_def = other_btr_uses_before_def;\n+  this_def->other_btr_uses_after_use = 0;\n+  this_def->next_this_bb = NULL;\n+  this_def->next_this_group = NULL;\n+  this_def->uses = NULL;\n+  this_def->live_range = NULL;\n+  find_btr_def_group (all_btr_def_groups, this_def);\n+\n+  fibheap_insert (all_btr_defs, -this_def->cost, this_def);\n \n   if (dump_file)\n     fprintf (dump_file,\n       \"Found target reg definition: sets %u { bb %d, insn %d }%s priority %d\\n\",\n-      dest_reg, bb->index, INSN_UID (insn), (this->group ? \"\" : \":not const\"),\n-      this->cost);\n+\t     dest_reg, bb->index, INSN_UID (insn),\n+\t     (this_def->group ? \"\" : \":not const\"), this_def->cost);\n \n-  return this;\n+  return this_def;\n }\n \n /* Create a new target register user structure, for a use in block BB,\n@@ -1274,7 +1273,7 @@ migrate_btr_def (btr_def def, int min_cost)\n   HARD_REG_SET btrs_live_in_range;\n   int btr_used_near_def = 0;\n   int def_basic_block_freq;\n-  basic_block try;\n+  basic_block attempt;\n   int give_up = 0;\n   int def_moved = 0;\n   btr_user user;\n@@ -1328,31 +1327,31 @@ migrate_btr_def (btr_def def, int min_cost)\n \n   def_basic_block_freq = basic_block_freq (def->bb);\n \n-  for (try = get_immediate_dominator (CDI_DOMINATORS, def->bb);\n-       !give_up && try && try != ENTRY_BLOCK_PTR && def->cost >= min_cost;\n-       try = get_immediate_dominator (CDI_DOMINATORS, try))\n+  for (attempt = get_immediate_dominator (CDI_DOMINATORS, def->bb);\n+       !give_up && attempt && attempt != ENTRY_BLOCK_PTR && def->cost >= min_cost;\n+       attempt = get_immediate_dominator (CDI_DOMINATORS, attempt))\n     {\n       /* Try to move the instruction that sets the target register into\n-\t basic block TRY.  */\n-      int try_freq = basic_block_freq (try);\n+\t basic block ATTEMPT.  */\n+      int try_freq = basic_block_freq (attempt);\n       edge_iterator ei;\n       edge e;\n \n-      /* If TRY has abnormal edges, skip it.  */\n-      FOR_EACH_EDGE (e, ei, try->succs)\n+      /* If ATTEMPT has abnormal edges, skip it.  */\n+      FOR_EACH_EDGE (e, ei, attempt->succs)\n \tif (e->flags & EDGE_COMPLEX)\n \t  break;\n       if (e)\n \tcontinue;\n \n       if (dump_file)\n-\tfprintf (dump_file, \"trying block %d ...\", try->index);\n+\tfprintf (dump_file, \"trying block %d ...\", attempt->index);\n \n       if (try_freq < def_basic_block_freq\n \t  || (try_freq == def_basic_block_freq && btr_used_near_def))\n \t{\n \t  int btr;\n-\t  augment_live_range (live_range, &btrs_live_in_range, def->bb, try,\n+\t  augment_live_range (live_range, &btrs_live_in_range, def->bb, attempt,\n \t\t\t      flag_btr_bb_exclusive);\n \t  if (dump_file)\n \t    {\n@@ -1363,7 +1362,7 @@ migrate_btr_def (btr_def def, int min_cost)\n \t  btr = choose_btr (btrs_live_in_range);\n \t  if (btr != -1)\n \t    {\n-\t      move_btr_def (try, btr, def, live_range, &btrs_live_in_range);\n+\t      move_btr_def (attempt, btr, def, live_range, &btrs_live_in_range);\n \t      bitmap_copy(live_range, def->live_range);\n \t      btr_used_near_def = 0;\n \t      def_moved = 1;\n@@ -1459,8 +1458,8 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n static void\n branch_target_load_optimize (bool after_prologue_epilogue_gen)\n {\n-  enum reg_class class = targetm.branch_target_register_class ();\n-  if (class != NO_REGS)\n+  enum reg_class klass = targetm.branch_target_register_class ();\n+  if (klass != NO_REGS)\n     {\n       /* Initialize issue_rate.  */\n       if (targetm.sched.issue_rate)\n@@ -1482,7 +1481,7 @@ branch_target_load_optimize (bool after_prologue_epilogue_gen)\n \n       /* Dominator info is also needed for migrate_btr_def.  */\n       calculate_dominance_info (CDI_DOMINATORS);\n-      migrate_btr_defs (class,\n+      migrate_btr_defs (klass,\n \t\t       (targetm.branch_target_register_callee_saved\n \t\t\t(after_prologue_epilogue_gen)));\n "}, {"sha": "233caca74f220ad2e7f5febccdf7c8e4ce614929", "filename": "gcc/caller-save.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=32e9fa4804d726e0479c6f562f39c32ebd63eb16", "patch": "@@ -660,7 +660,7 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n   rtx pat = NULL_RTX;\n   int code;\n   unsigned int numregs = 0;\n-  struct insn_chain *new;\n+  struct insn_chain *new_chain;\n   rtx mem;\n \n   /* A common failure mode if register status is not correct in the\n@@ -713,13 +713,13 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno), mem);\n   code = reg_restore_code (regno, GET_MODE (mem));\n-  new = insert_one_insn (chain, before_p, code, pat);\n+  new_chain = insert_one_insn (chain, before_p, code, pat);\n \n   /* Clear status for all registers we restored.  */\n   for (k = 0; k < i; k++)\n     {\n       CLEAR_HARD_REG_BIT (hard_regs_saved, regno + k);\n-      SET_REGNO_REG_SET (&new->dead_or_set, regno + k);\n+      SET_REGNO_REG_SET (&new_chain->dead_or_set, regno + k);\n       n_regs_saved--;\n     }\n \n@@ -738,7 +738,7 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n   rtx pat = NULL_RTX;\n   int code;\n   unsigned int numregs = 0;\n-  struct insn_chain *new;\n+  struct insn_chain *new_chain;\n   rtx mem;\n \n   /* A common failure mode if register status is not correct in the\n@@ -790,13 +790,13 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno));\n   code = reg_save_code (regno, GET_MODE (mem));\n-  new = insert_one_insn (chain, before_p, code, pat);\n+  new_chain = insert_one_insn (chain, before_p, code, pat);\n \n   /* Set hard_regs_saved and dead_or_set for all the registers we saved.  */\n   for (k = 0; k < numregs; k++)\n     {\n       SET_HARD_REG_BIT (hard_regs_saved, regno + k);\n-      SET_REGNO_REG_SET (&new->dead_or_set, regno + k);\n+      SET_REGNO_REG_SET (&new_chain->dead_or_set, regno + k);\n       n_regs_saved++;\n     }\n \n@@ -809,7 +809,7 @@ static struct insn_chain *\n insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n {\n   rtx insn = chain->insn;\n-  struct insn_chain *new;\n+  struct insn_chain *new_chain;\n \n #ifdef HAVE_cc0\n   /* If INSN references CC0, put our insns in front of the insn that sets\n@@ -824,23 +824,23 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n     chain = chain->prev, insn = chain->insn;\n #endif\n \n-  new = new_insn_chain ();\n+  new_chain = new_insn_chain ();\n   if (before_p)\n     {\n       rtx link;\n \n-      new->prev = chain->prev;\n-      if (new->prev != 0)\n-\tnew->prev->next = new;\n+      new_chain->prev = chain->prev;\n+      if (new_chain->prev != 0)\n+\tnew_chain->prev->next = new_chain;\n       else\n-\treload_insn_chain = new;\n+\treload_insn_chain = new_chain;\n \n-      chain->prev = new;\n-      new->next = chain;\n-      new->insn = emit_insn_before (pat, insn);\n+      chain->prev = new_chain;\n+      new_chain->next = chain;\n+      new_chain->insn = emit_insn_before (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets.  */\n-      COPY_REG_SET (&new->live_throughout, &chain->live_throughout);\n+      COPY_REG_SET (&new_chain->live_throughout, &chain->live_throughout);\n       /* Registers that die in CHAIN->INSN still live in the new insn.  */\n       for (link = REG_NOTES (chain->insn); link; link = XEXP (link, 1))\n \t{\n@@ -857,7 +857,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t\tcontinue;\n \t      for (i = hard_regno_nregs[regno][GET_MODE (reg)] - 1;\n \t\t   i >= 0; i--)\n-\t\tSET_REGNO_REG_SET (&new->live_throughout, regno + i);\n+\t\tSET_REGNO_REG_SET (&new_chain->live_throughout, regno + i);\n \t    }\n \t}\n \n@@ -885,41 +885,41 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \n \t\t      for (i = hard_regno_nregs[regno][GET_MODE (reg)] - 1;\n \t\t\t   i >= 0; i--)\n-\t\t\tSET_REGNO_REG_SET (&new->live_throughout, regno + i);\n+\t\t\tSET_REGNO_REG_SET (&new_chain->live_throughout, regno + i);\n \t\t    }\n \t\t}\n \t    }\n \t  \n \t}\n \n-      CLEAR_REG_SET (&new->dead_or_set);\n+      CLEAR_REG_SET (&new_chain->dead_or_set);\n       if (chain->insn == BB_HEAD (BASIC_BLOCK (chain->block)))\n-\tBB_HEAD (BASIC_BLOCK (chain->block)) = new->insn;\n+\tBB_HEAD (BASIC_BLOCK (chain->block)) = new_chain->insn;\n     }\n   else\n     {\n-      new->next = chain->next;\n-      if (new->next != 0)\n-\tnew->next->prev = new;\n-      chain->next = new;\n-      new->prev = chain;\n-      new->insn = emit_insn_after (pat, insn);\n+      new_chain->next = chain->next;\n+      if (new_chain->next != 0)\n+\tnew_chain->next->prev = new_chain;\n+      chain->next = new_chain;\n+      new_chain->prev = chain;\n+      new_chain->insn = emit_insn_after (pat, insn);\n       /* ??? It would be nice if we could exclude the already / still saved\n \t registers from the live sets, and observe REG_UNUSED notes.  */\n-      COPY_REG_SET (&new->live_throughout, &chain->live_throughout);\n+      COPY_REG_SET (&new_chain->live_throughout, &chain->live_throughout);\n       /* Registers that are set in CHAIN->INSN live in the new insn.\n \t (Unless there is a REG_UNUSED note for them, but we don't\n \t  look for them here.) */\n       note_stores (PATTERN (chain->insn), add_stored_regs,\n-\t\t   &new->live_throughout);\n-      CLEAR_REG_SET (&new->dead_or_set);\n+\t\t   &new_chain->live_throughout);\n+      CLEAR_REG_SET (&new_chain->dead_or_set);\n       if (chain->insn == BB_END (BASIC_BLOCK (chain->block)))\n-\tBB_END (BASIC_BLOCK (chain->block)) = new->insn;\n+\tBB_END (BASIC_BLOCK (chain->block)) = new_chain->insn;\n     }\n-  new->block = chain->block;\n-  new->is_caller_save_insn = 1;\n+  new_chain->block = chain->block;\n+  new_chain->is_caller_save_insn = 1;\n \n-  INSN_CODE (new->insn) = code;\n-  return new;\n+  INSN_CODE (new_chain->insn) = code;\n+  return new_chain;\n }\n #include \"gt-caller-save.h\""}, {"sha": "706ee0689f3bd0f500c852523325d74c68035117", "filename": "gcc/combine.c", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=32e9fa4804d726e0479c6f562f39c32ebd63eb16", "patch": "@@ -4278,7 +4278,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n   enum machine_mode op0_mode = VOIDmode;\n   const char *fmt;\n   int len, i;\n-  rtx new;\n+  rtx new_rtx;\n \n /* Two expressions are equal if they are identical copies of a shared\n    RTX or if they are both registers with the same register number\n@@ -4333,14 +4333,14 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n       && GET_CODE (XVECEXP (x, 0, 0)) == SET\n       && GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == ASM_OPERANDS)\n     {\n-      new = subst (XVECEXP (x, 0, 0), from, to, 0, unique_copy);\n+      new_rtx = subst (XVECEXP (x, 0, 0), from, to, 0, unique_copy);\n \n       /* If this substitution failed, this whole thing fails.  */\n-      if (GET_CODE (new) == CLOBBER\n-\t  && XEXP (new, 0) == const0_rtx)\n-\treturn new;\n+      if (GET_CODE (new_rtx) == CLOBBER\n+\t  && XEXP (new_rtx, 0) == const0_rtx)\n+\treturn new_rtx;\n \n-      SUBST (XVECEXP (x, 0, 0), new);\n+      SUBST (XVECEXP (x, 0, 0), new_rtx);\n \n       for (i = XVECLEN (x, 0) - 1; i >= 1; i--)\n \t{\n@@ -4350,14 +4350,14 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t      && GET_CODE (dest) != CC0\n \t      && GET_CODE (dest) != PC)\n \t    {\n-\t      new = subst (dest, from, to, 0, unique_copy);\n+\t      new_rtx = subst (dest, from, to, 0, unique_copy);\n \n \t      /* If this substitution failed, this whole thing fails.  */\n-\t      if (GET_CODE (new) == CLOBBER\n-\t\t  && XEXP (new, 0) == const0_rtx)\n-\t\treturn new;\n+\t      if (GET_CODE (new_rtx) == CLOBBER\n+\t\t  && XEXP (new_rtx, 0) == const0_rtx)\n+\t\treturn new_rtx;\n \n-\t      SUBST (SET_DEST (XVECEXP (x, 0, i)), new);\n+\t      SUBST (SET_DEST (XVECEXP (x, 0, i)), new_rtx);\n \t    }\n \t}\n     }\n@@ -4390,33 +4390,33 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t{\n \t\t  if (COMBINE_RTX_EQUAL_P (XVECEXP (x, i, j), from))\n \t\t    {\n-\t\t      new = (unique_copy && n_occurrences\n+\t\t      new_rtx = (unique_copy && n_occurrences\n \t\t\t     ? copy_rtx (to) : to);\n \t\t      n_occurrences++;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      new = subst (XVECEXP (x, i, j), from, to, 0,\n+\t\t      new_rtx = subst (XVECEXP (x, i, j), from, to, 0,\n \t\t\t\t   unique_copy);\n \n \t\t      /* If this substitution failed, this whole thing\n \t\t\t fails.  */\n-\t\t      if (GET_CODE (new) == CLOBBER\n-\t\t\t  && XEXP (new, 0) == const0_rtx)\n-\t\t\treturn new;\n+\t\t      if (GET_CODE (new_rtx) == CLOBBER\n+\t\t\t  && XEXP (new_rtx, 0) == const0_rtx)\n+\t\t\treturn new_rtx;\n \t\t    }\n \n-\t\t  SUBST (XVECEXP (x, i, j), new);\n+\t\t  SUBST (XVECEXP (x, i, j), new_rtx);\n \t\t}\n \t    }\n \t  else if (fmt[i] == 'e')\n \t    {\n \t      /* If this is a register being set, ignore it.  */\n-\t      new = XEXP (x, i);\n+\t      new_rtx = XEXP (x, i);\n \t      if (in_dest\n \t\t  && i == 0\n \t\t  && (((code == SUBREG || code == ZERO_EXTRACT)\n-\t\t       && REG_P (new))\n+\t\t       && REG_P (new_rtx))\n \t\t      || code == STRICT_LOW_PART))\n \t\t;\n \n@@ -4457,7 +4457,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n #endif\n \n-\t\t  new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n+\t\t  new_rtx = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n \t\t  n_occurrences++;\n \t\t}\n \t      else\n@@ -4469,7 +4469,7 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t   STRICT_LOW_PART, and ZERO_EXTRACT, which are the only\n \t\t   things aside from REG and MEM that should appear in a\n \t\t   SET_DEST.  */\n-\t\tnew = subst (XEXP (x, i), from, to,\n+\t\tnew_rtx = subst (XEXP (x, i), from, to,\n \t\t\t     (((in_dest\n \t\t\t\t&& (code == SUBREG || code == STRICT_LOW_PART\n \t\t\t\t    || code == ZERO_EXTRACT))\n@@ -4482,30 +4482,30 @@ subst (rtx x, rtx from, rtx to, int in_dest, int unique_copy)\n \t\t well as prevent accidents where two CLOBBERs are considered\n \t\t to be equal, thus producing an incorrect simplification.  */\n \n-\t      if (GET_CODE (new) == CLOBBER && XEXP (new, 0) == const0_rtx)\n-\t\treturn new;\n+\t      if (GET_CODE (new_rtx) == CLOBBER && XEXP (new_rtx, 0) == const0_rtx)\n+\t\treturn new_rtx;\n \n \t      if (GET_CODE (x) == SUBREG\n-\t\t  && (GET_CODE (new) == CONST_INT\n-\t\t      || GET_CODE (new) == CONST_DOUBLE))\n+\t\t  && (GET_CODE (new_rtx) == CONST_INT\n+\t\t      || GET_CODE (new_rtx) == CONST_DOUBLE))\n \t\t{\n \t\t  enum machine_mode mode = GET_MODE (x);\n \n-\t\t  x = simplify_subreg (GET_MODE (x), new,\n+\t\t  x = simplify_subreg (GET_MODE (x), new_rtx,\n \t\t\t\t       GET_MODE (SUBREG_REG (x)),\n \t\t\t\t       SUBREG_BYTE (x));\n \t\t  if (! x)\n \t\t    x = gen_rtx_CLOBBER (mode, const0_rtx);\n \t\t}\n-\t      else if (GET_CODE (new) == CONST_INT\n+\t      else if (GET_CODE (new_rtx) == CONST_INT\n \t\t       && GET_CODE (x) == ZERO_EXTEND)\n \t\t{\n \t\t  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n-\t\t\t\t\t\tnew, GET_MODE (XEXP (x, 0)));\n+\t\t\t\t\t\tnew_rtx, GET_MODE (XEXP (x, 0)));\n \t\t  gcc_assert (x);\n \t\t}\n \t      else\n-\t\tSUBST (XEXP (x, i), new);\n+\t\tSUBST (XEXP (x, i), new_rtx);\n \t    }\n \t}\n     }\n@@ -5638,9 +5638,9 @@ simplify_set (rtx x)\n \t  /* Attempt to simplify CC user.  */\n \t  if (GET_CODE (pat) == SET)\n \t    {\n-\t      rtx new = simplify_rtx (SET_SRC (pat));\n-\t      if (new != NULL_RTX)\n-\t\tSUBST (SET_SRC (pat), new);\n+\t      rtx new_rtx = simplify_rtx (SET_SRC (pat));\n+\t      if (new_rtx != NULL_RTX)\n+\t\tSUBST (SET_SRC (pat), new_rtx);\n \t    }\n \n \t  /* Convert X into a no-op move.  */\n@@ -6373,7 +6373,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   enum machine_mode pos_mode = word_mode;\n   enum machine_mode extraction_mode = word_mode;\n   enum machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n-  rtx new = 0;\n+  rtx new_rtx = 0;\n   rtx orig_pos_rtx = pos_rtx;\n   HOST_WIDE_INT orig_pos;\n \n@@ -6397,11 +6397,11 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t (ashift X (const_int C)), where LEN > C.  Extract the\n \t least significant (LEN - C) bits of X, giving an rtx\n \t whose mode is MODE, then shift it left C times.  */\n-      new = make_extraction (mode, XEXP (inner, 0),\n+      new_rtx = make_extraction (mode, XEXP (inner, 0),\n \t\t\t     0, 0, len - INTVAL (XEXP (inner, 1)),\n \t\t\t     unsignedp, in_dest, in_compare);\n-      if (new != 0)\n-\treturn gen_rtx_ASHIFT (mode, new, XEXP (inner, 1));\n+      if (new_rtx != 0)\n+\treturn gen_rtx_ASHIFT (mode, new_rtx, XEXP (inner, 1));\n     }\n \n   inner_mode = GET_MODE (inner);\n@@ -6457,7 +6457,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t  else\n \t    offset = pos / BITS_PER_UNIT;\n \n-\t  new = adjust_address_nv (inner, tmode, offset);\n+\t  new_rtx = adjust_address_nv (inner, tmode, offset);\n \t}\n       else if (REG_P (inner))\n \t{\n@@ -6487,16 +6487,16 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t  if (!validate_subreg (tmode, inner_mode, inner, final_word))\n \t\t    return NULL_RTX;\n \n-\t\t  new = gen_rtx_SUBREG (tmode, inner, final_word);\n+\t\t  new_rtx = gen_rtx_SUBREG (tmode, inner, final_word);\n \t\t}\n \t      else\n-\t\tnew = gen_lowpart (tmode, inner);\n+\t\tnew_rtx = gen_lowpart (tmode, inner);\n \t    }\n \t  else\n-\t    new = inner;\n+\t    new_rtx = inner;\n \t}\n       else\n-\tnew = force_to_mode (inner, tmode,\n+\tnew_rtx = force_to_mode (inner, tmode,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? ~(unsigned HOST_WIDE_INT) 0\n \t\t\t     : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n@@ -6506,30 +6506,30 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t make a STRICT_LOW_PART unless we made a MEM.  */\n \n       if (in_dest)\n-\treturn (MEM_P (new) ? new\n-\t\t: (GET_CODE (new) != SUBREG\n+\treturn (MEM_P (new_rtx) ? new_rtx\n+\t\t: (GET_CODE (new_rtx) != SUBREG\n \t\t   ? gen_rtx_CLOBBER (tmode, const0_rtx)\n-\t\t   : gen_rtx_STRICT_LOW_PART (VOIDmode, new)));\n+\t\t   : gen_rtx_STRICT_LOW_PART (VOIDmode, new_rtx)));\n \n       if (mode == tmode)\n-\treturn new;\n+\treturn new_rtx;\n \n-      if (GET_CODE (new) == CONST_INT)\n-\treturn gen_int_mode (INTVAL (new), mode);\n+      if (GET_CODE (new_rtx) == CONST_INT)\n+\treturn gen_int_mode (INTVAL (new_rtx), mode);\n \n       /* If we know that no extraneous bits are set, and that the high\n \t bit is not set, convert the extraction to the cheaper of\n \t sign and zero extension, that are equivalent in these cases.  */\n       if (flag_expensive_optimizations\n \t  && (GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT\n-\t      && ((nonzero_bits (new, tmode)\n+\t      && ((nonzero_bits (new_rtx, tmode)\n \t\t   & ~(((unsigned HOST_WIDE_INT)\n \t\t\tGET_MODE_MASK (tmode))\n \t\t       >> 1))\n \t\t  == 0)))\n \t{\n-\t  rtx temp = gen_rtx_ZERO_EXTEND (mode, new);\n-\t  rtx temp1 = gen_rtx_SIGN_EXTEND (mode, new);\n+\t  rtx temp = gen_rtx_ZERO_EXTEND (mode, new_rtx);\n+\t  rtx temp1 = gen_rtx_SIGN_EXTEND (mode, new_rtx);\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n@@ -6542,7 +6542,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t proper mode.  */\n \n       return (gen_rtx_fmt_e (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n-\t\t\t     mode, new));\n+\t\t\t     mode, new_rtx));\n     }\n \n   /* Unless this is a COMPARE or we have a funny memory reference,\n@@ -6746,12 +6746,12 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n     pos_rtx = GEN_INT (pos);\n \n   /* Make the required operation.  See if we can use existing rtx.  */\n-  new = gen_rtx_fmt_eee (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n+  new_rtx = gen_rtx_fmt_eee (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n \t\t\t extraction_mode, inner, GEN_INT (len), pos_rtx);\n   if (! in_dest)\n-    new = gen_lowpart (mode, new);\n+    new_rtx = gen_lowpart (mode, new_rtx);\n \n-  return new;\n+  return new_rtx;\n }\n \f\n /* See if X contains an ASHIFT of COUNT or more bits that can be commuted\n@@ -6827,7 +6827,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n   rtx rhs, lhs;\n   enum rtx_code next_code;\n   int i;\n-  rtx new = 0;\n+  rtx new_rtx = 0;\n   rtx tem;\n   const char *fmt;\n \n@@ -6852,8 +6852,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n \t{\n-\t  new = make_compound_operation (XEXP (x, 0), next_code);\n-\t  new = gen_rtx_MULT (mode, new,\n+\t  new_rtx = make_compound_operation (XEXP (x, 0), next_code);\n+\t  new_rtx = gen_rtx_MULT (mode, new_rtx,\n \t\t\t      GEN_INT ((HOST_WIDE_INT) 1\n \t\t\t\t       << INTVAL (XEXP (x, 1))));\n \t}\n@@ -6870,8 +6870,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t  && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n-\t  new = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n-\t  new = make_extraction (mode, new, 0, XEXP (XEXP (x, 0), 1), i, 1,\n+\t  new_rtx = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n+\t  new_rtx = make_extraction (mode, new_rtx, 0, XEXP (XEXP (x, 0), 1), i, 1,\n \t\t\t\t 0, in_code == COMPARE);\n \t}\n \n@@ -6881,9 +6881,9 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t       && GET_CODE (SUBREG_REG (XEXP (x, 0))) == LSHIFTRT\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n-\t  new = make_compound_operation (XEXP (SUBREG_REG (XEXP (x, 0)), 0),\n+\t  new_rtx = make_compound_operation (XEXP (SUBREG_REG (XEXP (x, 0)), 0),\n \t\t\t\t\t next_code);\n-\t  new = make_extraction (GET_MODE (SUBREG_REG (XEXP (x, 0))), new, 0,\n+\t  new_rtx = make_extraction (GET_MODE (SUBREG_REG (XEXP (x, 0))), new_rtx, 0,\n \t\t\t\t XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n \t\t\t\t 0, in_code == COMPARE);\n \t}\n@@ -6895,12 +6895,12 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  /* Apply the distributive law, and then try to make extractions.  */\n-\t  new = gen_rtx_fmt_ee (GET_CODE (XEXP (x, 0)), mode,\n+\t  new_rtx = gen_rtx_fmt_ee (GET_CODE (XEXP (x, 0)), mode,\n \t\t\t\tgen_rtx_AND (mode, XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t     XEXP (x, 1)),\n \t\t\t\tgen_rtx_AND (mode, XEXP (XEXP (x, 0), 1),\n \t\t\t\t\t     XEXP (x, 1)));\n-\t  new = make_compound_operation (new, in_code);\n+\t  new_rtx = make_compound_operation (new_rtx, in_code);\n \t}\n \n       /* If we are have (and (rotate X C) M) and C is larger than the number\n@@ -6911,8 +6911,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0\n \t       && i <= INTVAL (XEXP (XEXP (x, 0), 1)))\n \t{\n-\t  new = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n-\t  new = make_extraction (mode, new,\n+\t  new_rtx = make_compound_operation (XEXP (XEXP (x, 0), 0), next_code);\n+\t  new_rtx = make_extraction (mode, new_rtx,\n \t\t\t\t (GET_MODE_BITSIZE (mode)\n \t\t\t\t  - INTVAL (XEXP (XEXP (x, 0), 1))),\n \t\t\t\t NULL_RTX, i, 1, 0, in_code == COMPARE);\n@@ -6945,7 +6945,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t If it doesn't end up being a ZERO_EXTEND, we will ignore it unless\n \t we are in a COMPARE.  */\n       else if ((i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (mode,\n+\tnew_rtx = make_extraction (mode,\n \t\t\t       make_compound_operation (XEXP (x, 0),\n \t\t\t\t\t\t\tnext_code),\n \t\t\t       0, NULL_RTX, i, 1, 0, in_code == COMPARE);\n@@ -6954,7 +6954,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t convert this into the appropriate bit extract.  */\n       else if (in_code == COMPARE\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n-\tnew = make_extraction (mode,\n+\tnew_rtx = make_extraction (mode,\n \t\t\t       make_compound_operation (XEXP (x, 0),\n \t\t\t\t\t\t\tnext_code),\n \t\t\t       i, NULL_RTX, 1, 1, 0, 1);\n@@ -6969,7 +6969,7 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (x, 0), mode) & (1 << (mode_width - 1))) == 0)\n \t{\n-\t  new = gen_rtx_ASHIFTRT (mode,\n+\t  new_rtx = gen_rtx_ASHIFTRT (mode,\n \t\t\t\t  make_compound_operation (XEXP (x, 0),\n \t\t\t\t\t\t\t   next_code),\n \t\t\t\t  XEXP (x, 1));\n@@ -6989,8 +6989,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n \t  && INTVAL (rhs) >= INTVAL (XEXP (lhs, 1)))\n \t{\n-\t  new = make_compound_operation (XEXP (lhs, 0), next_code);\n-\t  new = make_extraction (mode, new,\n+\t  new_rtx = make_compound_operation (XEXP (lhs, 0), next_code);\n+\t  new_rtx = make_extraction (mode, new_rtx,\n \t\t\t\t INTVAL (rhs) - INTVAL (XEXP (lhs, 1)),\n \t\t\t\t NULL_RTX, mode_width - INTVAL (rhs),\n \t\t\t\t code == LSHIFTRT, 0, in_code == COMPARE);\n@@ -7007,8 +7007,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t\t&& (OBJECT_P (SUBREG_REG (lhs))))\n \t  && GET_CODE (rhs) == CONST_INT\n \t  && INTVAL (rhs) < HOST_BITS_PER_WIDE_INT\n-\t  && (new = extract_left_shift (lhs, INTVAL (rhs))) != 0)\n-\tnew = make_extraction (mode, make_compound_operation (new, next_code),\n+\t  && (new_rtx = extract_left_shift (lhs, INTVAL (rhs))) != 0)\n+\tnew_rtx = make_extraction (mode, make_compound_operation (new_rtx, next_code),\n \t\t\t       0, NULL_RTX, mode_width - INTVAL (rhs),\n \t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n \n@@ -7053,9 +7053,9 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n       break;\n     }\n \n-  if (new)\n+  if (new_rtx)\n     {\n-      x = gen_lowpart (mode, new);\n+      x = gen_lowpart (mode, new_rtx);\n       code = GET_CODE (x);\n     }\n \n@@ -7064,8 +7064,8 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n   for (i = 0; i < GET_RTX_LENGTH (code); i++)\n     if (fmt[i] == 'e')\n       {\n-\tnew = make_compound_operation (XEXP (x, i), next_code);\n-\tSUBST (XEXP (x, i), new);\n+\tnew_rtx = make_compound_operation (XEXP (x, i), next_code);\n+\tSUBST (XEXP (x, i), new_rtx);\n       }\n \n   /* If this is a commutative operation, the changes to the operands\n@@ -8074,16 +8074,16 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n   else if (code == SUBREG)\n     {\n       enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n-      rtx new, r = known_cond (SUBREG_REG (x), cond, reg, val);\n+      rtx new_rtx, r = known_cond (SUBREG_REG (x), cond, reg, val);\n \n       if (SUBREG_REG (x) != r)\n \t{\n \t  /* We must simplify subreg here, before we lose track of the\n \t     original inner_mode.  */\n-\t  new = simplify_subreg (GET_MODE (x), r,\n+\t  new_rtx = simplify_subreg (GET_MODE (x), r,\n \t\t\t\t inner_mode, SUBREG_BYTE (x));\n-\t  if (new)\n-\t    return new;\n+\t  if (new_rtx)\n+\t    return new_rtx;\n \t  else\n \t    SUBST (SUBREG_REG (x), r);\n \t}\n@@ -8099,16 +8099,16 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n   else if (code == ZERO_EXTEND)\n     {\n       enum machine_mode inner_mode = GET_MODE (XEXP (x, 0));\n-      rtx new, r = known_cond (XEXP (x, 0), cond, reg, val);\n+      rtx new_rtx, r = known_cond (XEXP (x, 0), cond, reg, val);\n \n       if (XEXP (x, 0) != r)\n \t{\n \t  /* We must simplify the zero_extend here, before we lose\n \t     track of the original inner_mode.  */\n-\t  new = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n+\t  new_rtx = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\t  r, inner_mode);\n-\t  if (new)\n-\t    return new;\n+\t  if (new_rtx)\n+\t    return new_rtx;\n \t  else\n \t    SUBST (XEXP (x, 0), r);\n \t}\n@@ -8961,7 +8961,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n   enum rtx_code outer_op = UNKNOWN;\n   HOST_WIDE_INT outer_const = 0;\n   int complement_p = 0;\n-  rtx new, x;\n+  rtx new_rtx, x;\n \n   /* Make sure and truncate the \"natural\" shift on the way in.  We don't\n      want to do this inside the loop as it makes it more difficult to\n@@ -9083,10 +9083,10 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \tcase ZERO_EXTEND:\n \tcase SIGN_EXTRACT:\n \tcase ZERO_EXTRACT:\n-\t  new = expand_compound_operation (varop);\n-\t  if (new != varop)\n+\t  new_rtx = expand_compound_operation (varop);\n+\t  if (new_rtx != varop)\n \t    {\n-\t      varop = new;\n+\t      varop = new_rtx;\n \t      continue;\n \t    }\n \t  break;\n@@ -9101,12 +9101,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && (tmode = mode_for_size (GET_MODE_BITSIZE (mode) - count,\n \t\t\t\t\t MODE_INT, 1)) != BLKmode)\n \t    {\n-\t      new = adjust_address_nv (varop, tmode,\n+\t      new_rtx = adjust_address_nv (varop, tmode,\n \t\t\t\t       BYTES_BIG_ENDIAN ? 0\n \t\t\t\t       : count / BITS_PER_UNIT);\n \n \t      varop = gen_rtx_fmt_e (code == ASHIFTRT ? SIGN_EXTEND\n-\t\t\t\t     : ZERO_EXTEND, mode, new);\n+\t\t\t\t     : ZERO_EXTEND, mode, new_rtx);\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -9327,10 +9327,10 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t\t   && GET_CODE (XEXP (varop, 0)) == CONST_INT\n \t\t   && GET_CODE (XEXP (varop, 1)) != CONST_INT)\n \t    {\n-\t      rtx new = simplify_const_binary_operation (code, mode,\n+\t      rtx new_rtx = simplify_const_binary_operation (code, mode,\n \t\t\t\t\t\t\t XEXP (varop, 0),\n \t\t\t\t\t\t\t GEN_INT (count));\n-\t      varop = gen_rtx_fmt_ee (code, mode, new, XEXP (varop, 1));\n+\t      varop = gen_rtx_fmt_ee (code, mode, new_rtx, XEXP (varop, 1));\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -9384,12 +9384,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n \t\t   && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t      shift_mode))\n-\t      && (new = simplify_const_binary_operation (code, result_mode,\n+\t      && (new_rtx = simplify_const_binary_operation (code, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new) == CONST_INT\n+\t      && GET_CODE (new_rtx) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n-\t\t\t\t  INTVAL (new), result_mode, &complement_p))\n+\t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -9512,12 +9512,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t  /* (ashift (plus foo C) N) is (plus (ashift foo N) C').  */\n \t  if (code == ASHIFT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n-\t      && (new = simplify_const_binary_operation (ASHIFT, result_mode,\n+\t      && (new_rtx = simplify_const_binary_operation (ASHIFT, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new) == CONST_INT\n+\t      && GET_CODE (new_rtx) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n-\t\t\t\t  INTVAL (new), result_mode, &complement_p))\n+\t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -9531,12 +9531,12 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t  if (code == LSHIFTRT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && mode_signbit_p (result_mode, XEXP (varop, 1))\n-\t      && (new = simplify_const_binary_operation (code, result_mode,\n+\t      && (new_rtx = simplify_const_binary_operation (code, result_mode,\n \t\t\t\t\t\t\t XEXP (varop, 1),\n \t\t\t\t\t\t\t GEN_INT (count))) != 0\n-\t      && GET_CODE (new) == CONST_INT\n+\t      && GET_CODE (new_rtx) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n-\t\t\t\t  INTVAL (new), result_mode, &complement_p))\n+\t\t\t\t  INTVAL (new_rtx), result_mode, &complement_p))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;"}, {"sha": "273e590323b3907e43e7d94bf46213c20ab227a5", "filename": "gcc/cse.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32e9fa4804d726e0479c6f562f39c32ebd63eb16/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=32e9fa4804d726e0479c6f562f39c32ebd63eb16", "patch": "@@ -913,18 +913,18 @@ make_new_qty (unsigned int reg, enum machine_mode mode)\n    OLD is not changing; NEW is.  */\n \n static void\n-make_regs_eqv (unsigned int new, unsigned int old)\n+make_regs_eqv (unsigned int new_reg, unsigned int old_reg)\n {\n   unsigned int lastr, firstr;\n-  int q = REG_QTY (old);\n+  int q = REG_QTY (old_reg);\n   struct qty_table_elem *ent;\n \n   ent = &qty_table[q];\n \n   /* Nothing should become eqv until it has a \"non-invalid\" qty number.  */\n-  gcc_assert (REGNO_QTY_VALID_P (old));\n+  gcc_assert (REGNO_QTY_VALID_P (old_reg));\n \n-  REG_QTY (new) = q;\n+  REG_QTY (new_reg) = q;\n   firstr = ent->first_reg;\n   lastr = ent->last_reg;\n \n@@ -937,19 +937,19 @@ make_regs_eqv (unsigned int new, unsigned int old)\n \t that not only can they not be allocated by the compiler, but\n \t they cannot be used in substitutions or canonicalizations\n \t either.  */\n-      && (new >= FIRST_PSEUDO_REGISTER || REGNO_REG_CLASS (new) != NO_REGS)\n-      && ((new < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (new))\n-\t  || (new >= FIRST_PSEUDO_REGISTER\n+      && (new_reg >= FIRST_PSEUDO_REGISTER || REGNO_REG_CLASS (new_reg) != NO_REGS)\n+      && ((new_reg < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (new_reg))\n+\t  || (new_reg >= FIRST_PSEUDO_REGISTER\n \t      && (firstr < FIRST_PSEUDO_REGISTER\n-\t\t  || (bitmap_bit_p (cse_ebb_live_out, new)\n+\t\t  || (bitmap_bit_p (cse_ebb_live_out, new_reg)\n \t\t      && !bitmap_bit_p (cse_ebb_live_out, firstr))\n-\t\t  || (bitmap_bit_p (cse_ebb_live_in, new)\n+\t\t  || (bitmap_bit_p (cse_ebb_live_in, new_reg)\n \t\t      && !bitmap_bit_p (cse_ebb_live_in, firstr))))))\n     {\n-      reg_eqv_table[firstr].prev = new;\n-      reg_eqv_table[new].next = firstr;\n-      reg_eqv_table[new].prev = -1;\n-      ent->first_reg = new;\n+      reg_eqv_table[firstr].prev = new_reg;\n+      reg_eqv_table[new_reg].next = firstr;\n+      reg_eqv_table[new_reg].prev = -1;\n+      ent->first_reg = new_reg;\n     }\n   else\n     {\n@@ -959,15 +959,15 @@ make_regs_eqv (unsigned int new, unsigned int old)\n \t equivalent for anything.  */\n       while (lastr < FIRST_PSEUDO_REGISTER && reg_eqv_table[lastr].prev >= 0\n \t     && (REGNO_REG_CLASS (lastr) == NO_REGS || ! FIXED_REGNO_P (lastr))\n-\t     && new >= FIRST_PSEUDO_REGISTER)\n+\t     && new_reg >= FIRST_PSEUDO_REGISTER)\n \tlastr = reg_eqv_table[lastr].prev;\n-      reg_eqv_table[new].next = reg_eqv_table[lastr].next;\n+      reg_eqv_table[new_reg].next = reg_eqv_table[lastr].next;\n       if (reg_eqv_table[lastr].next >= 0)\n-\treg_eqv_table[reg_eqv_table[lastr].next].prev = new;\n+\treg_eqv_table[reg_eqv_table[lastr].next].prev = new_reg;\n       else\n-\tqty_table[q].last_reg = new;\n-      reg_eqv_table[lastr].next = new;\n-      reg_eqv_table[new].prev = lastr;\n+\tqty_table[q].last_reg = new_reg;\n+      reg_eqv_table[lastr].next = new_reg;\n+      reg_eqv_table[new_reg].prev = lastr;\n     }\n }\n \n@@ -1584,7 +1584,7 @@ insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mo\n static void\n merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)\n {\n-  struct table_elt *elt, *next, *new;\n+  struct table_elt *elt, *next, *new_elt;\n \n   /* Ensure we start with the head of the classes.  */\n   class1 = class1->first_same_value;\n@@ -1628,8 +1628,8 @@ merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)\n \t      rehash_using_reg (exp);\n \t      hash = HASH (exp, mode);\n \t    }\n-\t  new = insert (exp, class1, hash, mode);\n-\t  new->in_memory = hash_arg_in_memory;\n+\t  new_elt = insert (exp, class1, hash, mode);\n+\t  new_elt->in_memory = hash_arg_in_memory;\n \t}\n     }\n }\n@@ -2648,12 +2648,12 @@ validate_canon_reg (rtx *xloc, rtx insn)\n {\n   if (*xloc)\n     {\n-      rtx new = canon_reg (*xloc, insn);\n+      rtx new_rtx = canon_reg (*xloc, insn);\n \n       /* If replacing pseudo with hard reg or vice versa, ensure the\n          insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n-      gcc_assert (insn && new);\n-      validate_change (insn, xloc, new, 1);\n+      gcc_assert (insn && new_rtx);\n+      validate_change (insn, xloc, new_rtx, 1);\n     }\n }\n \n@@ -2948,7 +2948,7 @@ fold_rtx (rtx x, rtx insn)\n   enum machine_mode mode;\n   const char *fmt;\n   int i;\n-  rtx new = 0;\n+  rtx new_rtx = 0;\n   int changed = 0;\n \n   /* Operands of X.  */\n@@ -2974,8 +2974,8 @@ fold_rtx (rtx x, rtx insn)\n     {\n     case MEM:\n     case SUBREG:\n-      if ((new = equiv_constant (x)) != NULL_RTX)\n-        return new;\n+      if ((new_rtx = equiv_constant (x)) != NULL_RTX)\n+        return new_rtx;\n       return x;\n \n     case CONST:\n@@ -3150,20 +3150,20 @@ fold_rtx (rtx x, rtx insn)\n \tif (const_arg0 != 0 && GET_CODE (const_arg0) == CONST)\n \t  is_const = 1, const_arg0 = XEXP (const_arg0, 0);\n \n-\tnew = simplify_unary_operation (code, mode,\n+\tnew_rtx = simplify_unary_operation (code, mode,\n \t\t\t\t\tconst_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t\tmode_arg0);\n \t/* NEG of PLUS could be converted into MINUS, but that causes\n \t   expressions of the form\n \t   (CONST (MINUS (CONST_INT) (SYMBOL_REF)))\n \t   which many ports mistakenly treat as LEGITIMATE_CONSTANT_P.\n \t   FIXME: those ports should be fixed.  */\n-\tif (new != 0 && is_const\n-\t    && GET_CODE (new) == PLUS\n-\t    && (GET_CODE (XEXP (new, 0)) == SYMBOL_REF\n-\t\t|| GET_CODE (XEXP (new, 0)) == LABEL_REF)\n-\t    && GET_CODE (XEXP (new, 1)) == CONST_INT)\n-\t  new = gen_rtx_CONST (mode, new);\n+\tif (new_rtx != 0 && is_const\n+\t    && GET_CODE (new_rtx) == PLUS\n+\t    && (GET_CODE (XEXP (new_rtx, 0)) == SYMBOL_REF\n+\t\t|| GET_CODE (XEXP (new_rtx, 0)) == LABEL_REF)\n+\t    && GET_CODE (XEXP (new_rtx, 1)) == CONST_INT)\n+\t  new_rtx = gen_rtx_CONST (mode, new_rtx);\n       }\n       break;\n \n@@ -3324,7 +3324,7 @@ fold_rtx (rtx x, rtx insn)\n       {\n \trtx op0 = const_arg0 ? const_arg0 : folded_arg0;\n \trtx op1 = const_arg1 ? const_arg1 : folded_arg1;\n-        new = simplify_relational_operation (code, mode, mode_arg0, op0, op1);\n+        new_rtx = simplify_relational_operation (code, mode, mode_arg0, op0, op1);\n       }\n       break;\n \n@@ -3560,7 +3560,7 @@ fold_rtx (rtx x, rtx insn)\n \t  break;\n \t}\n \n-      new = simplify_binary_operation (code, mode,\n+      new_rtx = simplify_binary_operation (code, mode,\n \t\t\t\t       const_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t       const_arg1 ? const_arg1 : folded_arg1);\n       break;\n@@ -3575,7 +3575,7 @@ fold_rtx (rtx x, rtx insn)\n \n     case RTX_TERNARY:\n     case RTX_BITFIELD_OPS:\n-      new = simplify_ternary_operation (code, mode, mode_arg0,\n+      new_rtx = simplify_ternary_operation (code, mode, mode_arg0,\n \t\t\t\t\tconst_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t\tconst_arg1 ? const_arg1 : folded_arg1,\n \t\t\t\t\tconst_arg2 ? const_arg2 : XEXP (x, 2));\n@@ -3585,7 +3585,7 @@ fold_rtx (rtx x, rtx insn)\n       break;\n     }\n \n-  return new ? new : x;\n+  return new_rtx ? new_rtx : x;\n }\n \f\n /* Return a constant value currently equivalent to X.\n@@ -3609,16 +3609,16 @@ equiv_constant (rtx x)\n \n   if (GET_CODE (x) == SUBREG)\n     {\n-      rtx new;\n+      rtx new_rtx;\n \n       /* See if we previously assigned a constant value to this SUBREG.  */\n-      if ((new = lookup_as_function (x, CONST_INT)) != 0\n-          || (new = lookup_as_function (x, CONST_DOUBLE)) != 0\n-          || (new = lookup_as_function (x, CONST_FIXED)) != 0)\n-        return new;\n+      if ((new_rtx = lookup_as_function (x, CONST_INT)) != 0\n+          || (new_rtx = lookup_as_function (x, CONST_DOUBLE)) != 0\n+          || (new_rtx = lookup_as_function (x, CONST_FIXED)) != 0)\n+        return new_rtx;\n \n       if (REG_P (SUBREG_REG (x))\n-\t  && (new = equiv_constant (SUBREG_REG (x))) != 0)\n+\t  && (new_rtx = equiv_constant (SUBREG_REG (x))) != 0)\n         return simplify_subreg (GET_MODE (x), SUBREG_REG (x),\n \t\t\t\tGET_MODE (SUBREG_REG (x)), SUBREG_BYTE (x));\n \n@@ -4161,9 +4161,9 @@ cse_insn (rtx insn)\n     {\n       rtx dest = SET_DEST (sets[i].rtl);\n       rtx src = SET_SRC (sets[i].rtl);\n-      rtx new = canon_reg (src, insn);\n+      rtx new_rtx = canon_reg (src, insn);\n \n-      validate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n+      validate_change (insn, &SET_SRC (sets[i].rtl), new_rtx, 1);\n \n       if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n@@ -4811,12 +4811,12 @@ cse_insn (rtx insn)\n \t  else if (validate_unshare_change\n \t\t     (insn, &SET_SRC (sets[i].rtl), trial, 0))\n \t    {\n-\t      rtx new = canon_reg (SET_SRC (sets[i].rtl), insn);\n+\t      rtx new_rtx = canon_reg (SET_SRC (sets[i].rtl), insn);\n \n \t      /* The result of apply_change_group can be ignored; see\n \t\t canon_reg.  */\n \n-\t      validate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n+\t      validate_change (insn, &SET_SRC (sets[i].rtl), new_rtx, 1);\n \t      apply_change_group ();\n \n \t      break;\n@@ -5016,22 +5016,22 @@ cse_insn (rtx insn)\n \t     and hope for the best.  */\n \t  if (n_sets == 1)\n \t    {\n-\t      rtx new, note;\n+\t      rtx new_rtx, note;\n \n-\t      new = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n-\t      JUMP_LABEL (new) = XEXP (src, 0);\n+\t      new_rtx = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n+\t      JUMP_LABEL (new_rtx) = XEXP (src, 0);\n \t      LABEL_NUSES (XEXP (src, 0))++;\n \n \t      /* Make sure to copy over REG_NON_LOCAL_GOTO.  */\n \t      note = find_reg_note (insn, REG_NON_LOCAL_GOTO, 0);\n \t      if (note)\n \t\t{\n \t\t  XEXP (note, 1) = NULL_RTX;\n-\t\t  REG_NOTES (new) = note;\n+\t\t  REG_NOTES (new_rtx) = note;\n \t\t}\n \n \t      delete_insn_and_edges (insn);\n-\t      insn = new;\n+\t      insn = new_rtx;\n \t    }\n \t  else\n \t    INSN_CODE (insn) = -1;\n@@ -5674,11 +5674,11 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)\n     case ZERO_EXTEND:\n     case SUBREG:\n       {\n-\trtx new = cse_process_notes (XEXP (x, 0), object, changed);\n+\trtx new_rtx = cse_process_notes (XEXP (x, 0), object, changed);\n \t/* We don't substitute VOIDmode constants into these rtx,\n \t   since they would impede folding.  */\n-\tif (GET_MODE (new) != VOIDmode)\n-\t  validate_change (object, &XEXP (x, 0), new, 0);\n+\tif (GET_MODE (new_rtx) != VOIDmode)\n+\t  validate_change (object, &XEXP (x, 0), new_rtx, 0);\n \treturn x;\n       }\n \n@@ -5694,9 +5694,9 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)\n \t      && (CONSTANT_P (ent->const_rtx)\n \t\t  || REG_P (ent->const_rtx)))\n \t    {\n-\t      rtx new = gen_lowpart (GET_MODE (x), ent->const_rtx);\n-\t      if (new)\n-\t\treturn copy_rtx (new);\n+\t      rtx new_rtx = gen_lowpart (GET_MODE (x), ent->const_rtx);\n+\t      if (new_rtx)\n+\t\treturn copy_rtx (new_rtx);\n \t    }\n \t}\n \n@@ -5718,10 +5718,10 @@ cse_process_notes_1 (rtx x, rtx object, bool *changed)\n static rtx\n cse_process_notes (rtx x, rtx object, bool *changed)\n {\n-  rtx new = cse_process_notes_1 (x, object, changed);\n-  if (new != x)\n+  rtx new_rtx = cse_process_notes_1 (x, object, changed);\n+  if (new_rtx != x)\n     *changed = true;\n-  return new;\n+  return new_rtx;\n }\n \n \f"}]}