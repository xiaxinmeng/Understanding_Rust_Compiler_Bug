{"sha": "74bf76ed78a14069969e94233f05e7840806aed8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRiZjc2ZWQ3OGExNDA2OTk2OWU5NDIzM2YwNWU3ODQwODA2YWVkOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-08-27T18:38:00Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2013-08-27T18:38:00Z"}, "message": "Makefile.in (omp-low.o): Depend on $(TARGET_H).\n\n\t* Makefile.in (omp-low.o): Depend on $(TARGET_H).\n\t* cfgloop.h (struct loop): Add safelen, force_vect, simduid.\n\t* function.h (struct function): Add has_force_vect_loops and\n\thas_simduid_loops.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n\tGF_OMP_FOR_KIND*.\n\t* gimple.c (gimple_build_omp_critical): Add KIND argument and\n\thandle it.\n\t* gimple.def: Update CLAUSES comments.\n\t* gimple.h (enum gf_mask): Add GF_OMP_FOR_KIND_{FOR,SIMD}.\n\t(gimple_build_omp_for): Add argument to prototype.\n\t(gimple_omp_for_kind): New.\n\t(gimple_omp_for_set_kind): New.\n\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_LINEAR to\n\tGOVD_DATA_SHARE_CLASS.\n\t(enum omp_region_type): Add ORT_SIMD.\n\t(gimple_add_tmp_var): Handle ORT_SIMD.\n\t(gimplify_var_or_parm_decl): Same.\n\t(is_gimple_stmt): Same.\n\t(omp_firstprivatize_variable): Same.\n\t(omp_add_variable): Only use splay_tree_insert if lookup failed.\n\t(omp_notice_variable): Handle ORT_SIMD.\n\t(omp_is_private): Add SIMD argument and handle it as well as\n\tORT_SIMD.\n\t(omp_check_private): Handle ORT_SIMD.\n\t(gimplify_scan_omp_clauses): Handle OMP_CLAUSE_LINEAR and\n\tOMP_CLAUSE_SAFELEN.\n\t(gimplify_adjust_omp_clauses_1): Handle GOVD_LINEAR.\n\tHandle OMP_CLAUSE_LASTPRIVATE.\n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_LINEAR and\n\tOMP_CLAUSE_SAFELEN.\n\t(gimplify_omp_for): Handle OMP_SIMD and OMP_CLAUSE_LINEAR.\n\t(gimplify_expr): Handle OMP_SIMD.\n\t* internal-fn.c (expand_GOMP_SIMD_LANE): New.\n\t(expand_GOMP_SIMD_VF): New.\n\t(expand_GOMP_SIMD_LAST_LANE): New.\n\t* internal-fn.def (GOMP_SIMD_LANE): New.\n\t(GOMP_SIMD_VF): New.\n\t(GOMP_SIMD_LAST_LANE): New.\n\t* omp-low.c: Include target.h.\n\t(extract_omp_for_data): Handle OMP_SIMD, OMP_CLAUSE_LINEAR,\n\tOMP_CLAUSE_SAFELEN.\n\t(check_omp_nesting_restrictions): Same.\n\t(omp_max_vf): New.\n\t(lower_rec_simd_input_clauses): New.\n\t(lower_rec_input_clauses): Handle OMP_SIMD, GF_OMP_FOR_KIND_SIMD,\n\tOMP_CLAUSE_LINEAR.\n\t(lower_lastprivate_clauses): Handle OMP_CLAUSE_LINEAR,\n\tGF_OMP_FOR_KIND_SIMD, OMP_SIMD.\n\t(expand_omp_build_assign): New.\n\t(expand_omp_for_init_counts): New.\n\t(expand_omp_for_init_vars): New.\n\t(extract_omp_for_update_vars): New.\n\t(expand_omp_for_generic): Use expand_omp_for_{init,update}_vars\n\tand rewrite accordingly.\n\t(expand_omp_simd): New.\n\t(expand_omp_for): Use expand_omp_simd.\n\t(lower_omp_for_lastprivate): Unshare vinit when appropriate.\n\t(lower_omp_for): Do not lower the body.\n\t* tree-data-ref (get_references_in_stmt): Allow IFN_GOMP_SIMD_LANE\n\tin their own loops.\n\t* tree-flow.h (find_omp_clause): Remove prototype.\n\t* tree-if-conv.c (main_tree_if_conversion): Run if doing if\n\tconversion, forcing vectorization of the loop, or if\n\tflag_tree_vectorize.\n\t(gate_tree_if_conversion): Similarly.\n\t* tree-inline.c (remap_gimple_stmt): Pass for kind argument to\n\tgimple_build_omp_for.\n\t(copy_cfg_body): set has_force_vect_loops and has_simduid_loops.\n\t* tree-parloops (create_parallel_loop): Pass kind argument to\n\tgimple_build_omp_for.\n\t* tree-pretty-print.c (dump_omp_clause): Add cases for\n\tOMP_CLAUSE_UNIFORM, OMP_CLAUSE_LINEAR, OMP_CLAUSE_SAFELEN,\n\tOMP_CLAUSE__SIMDUID_.\n\t(dump_generic_node): Handle OMP_SIMD.\n\t* tree-ssa-ccp.c (likely_value): Handle IFN_GOMP_SIMD*.\n\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely_1): Do not\n\tunroll OMP_SIMD loops here.\n\t* tree-ssa-loop.c (gate_tree_vectorize): Run if\n\thas_force_vect_loops.\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Handle\n\tloop->safelen\n\t(vect_analyze_data_refs): Handle simd loops.\n\t* tree-vect-loop.c (vectorizable_live_operation): Handle\n\tIFN_GOMP_SIMD*.\n\t* tree-vect-stmts.c (vectorizable_call): Handle\n\tIFN_GOMP_SIMD_LANE.\n\t(vectorizable_store): Handle STMT_VINFO_SIMD_LANE_ACCESS_P.\n\t(vectorizable_load): Same.\n\t* tree-vectorizer.c: Include hash-table.h and\n\ttree-ssa-propagate.h.\n\t(struct simduid_to_vf): New.\n\t(simduid_to_vf::hash): New.\n\t(simduid_to-vf::equal): New.\n\t(struct simd_array_to_simduid): New.\n\t(simd_array_to_simduid::hash): New.\n\t(simd_array_to_simduid::equal): New.\n\t(adjust_simduid_builtins): New.\n\t(struct note_simd_array_uses_struct): New.\n\t(note_simd_array_uses_cb): New.\n\t(note_simd_array_uses): New.\n\t(vectorize_loops): Handle simd hints and adjust simd builtins\n\taccordingly.\n\t* tree-vectorizer.h (struct _stmt_vec_info): Add\n\tsimd_lane_access_p field.\n\t(STMT_VINFO_SIMD_LANE_ACCESS_P): New macro.\n\t* tree.c (omp_clause_num_ops): Add entries for OMP_CLAUSE_LINEAR,\n\tOMP_CLAUSE_SAFELEN, OMP_CLAUSE__SIMDUID_, OMP_CLAUSE_UNIFORM.\n\t(omp_clause_code_name): Same.\n\t(walk_tree_1): Handle OMP_CLAUSE_UNIFORM, OMP_CLAUSE_SAFELEN,\n\tOMP_CLAUSE__SIMDUID_, OMP_CLAUSE_LINEAR.\n\t* tree.def (OMP_SIMD): New entry.\n\t* tree.h (enum omp_clause_code): Add entries for\n\tOMP_CLAUSE_LINEAR, OMP_CLAUSE_UNIFORM, OMP_CLAUSE_SAFELEN,\n\tOMP_CLAUSE__SIMDUID_.\n\t(OMP_CLAUSE_DECL): Adjust range for new clauses.\n\t(OMP_CLAUSE_LINEAR_NO_COPYIN): New.\n\t(OMP_CLAUSE_LINEAR_NO_COPYOUT): New.\n\t(OMP_CLAUSE_LINEAR_STEP): New.\n\t(OMP_CLAUSE_SAFELEN_EXPR): New.\n\t(OMP_CLAUSE__SIMDUID__DECL): New.\n\t(find_omp_clause): New prototype.\ncp/\n\t* cp-tree.h (CP_OMP_CLAUSE_INFO): Adjust range for new clauses.\n\nCo-Authored-By: Aldy Hernandez <aldyh@redhat.com>\n\nFrom-SVN: r202029", "tree": {"sha": "c96afad81f1d970413ba047262aa9f9765da99e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c96afad81f1d970413ba047262aa9f9765da99e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74bf76ed78a14069969e94233f05e7840806aed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74bf76ed78a14069969e94233f05e7840806aed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74bf76ed78a14069969e94233f05e7840806aed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74bf76ed78a14069969e94233f05e7840806aed8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d0cf4e841d8ab907811943e04102d9765660c003", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cf4e841d8ab907811943e04102d9765660c003", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cf4e841d8ab907811943e04102d9765660c003"}], "stats": {"total": 2490, "additions": 2154, "deletions": 336}, "files": [{"sha": "9c043ccef7cfe497208ff710be12baaf0710173c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1,3 +1,129 @@\n+2013-08-27  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (omp-low.o): Depend on $(TARGET_H).\n+\t* cfgloop.h (struct loop): Add safelen, force_vect, simduid.\n+\t* function.h (struct function): Add has_force_vect_loops and\n+\thas_simduid_loops.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n+\tGF_OMP_FOR_KIND*.\n+\t* gimple.c (gimple_build_omp_critical): Add KIND argument and\n+\thandle it.\n+\t* gimple.def: Update CLAUSES comments.\n+\t* gimple.h (enum gf_mask): Add GF_OMP_FOR_KIND_{FOR,SIMD}.\n+\t(gimple_build_omp_for): Add argument to prototype.\n+\t(gimple_omp_for_kind): New.\n+\t(gimple_omp_for_set_kind): New.\n+\t* gimplify.c (enum gimplify_omp_var_data): Add GOVD_LINEAR to\n+\tGOVD_DATA_SHARE_CLASS.\n+\t(enum omp_region_type): Add ORT_SIMD.\n+\t(gimple_add_tmp_var): Handle ORT_SIMD.\n+\t(gimplify_var_or_parm_decl): Same.\n+\t(is_gimple_stmt): Same.\n+\t(omp_firstprivatize_variable): Same.\n+\t(omp_add_variable): Only use splay_tree_insert if lookup failed.\n+\t(omp_notice_variable): Handle ORT_SIMD.\n+\t(omp_is_private): Add SIMD argument and handle it as well as\n+\tORT_SIMD.\n+\t(omp_check_private): Handle ORT_SIMD.\n+\t(gimplify_scan_omp_clauses): Handle OMP_CLAUSE_LINEAR and\n+\tOMP_CLAUSE_SAFELEN.\n+\t(gimplify_adjust_omp_clauses_1): Handle GOVD_LINEAR.\n+\tHandle OMP_CLAUSE_LASTPRIVATE.\n+\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_LINEAR and\n+\tOMP_CLAUSE_SAFELEN.\n+\t(gimplify_omp_for): Handle OMP_SIMD and OMP_CLAUSE_LINEAR.\n+\t(gimplify_expr): Handle OMP_SIMD.\n+\t* internal-fn.c (expand_GOMP_SIMD_LANE): New.\n+\t(expand_GOMP_SIMD_VF): New.\n+\t(expand_GOMP_SIMD_LAST_LANE): New.\n+\t* internal-fn.def (GOMP_SIMD_LANE): New.\n+\t(GOMP_SIMD_VF): New.\n+\t(GOMP_SIMD_LAST_LANE): New.\n+\t* omp-low.c: Include target.h.\n+\t(extract_omp_for_data): Handle OMP_SIMD, OMP_CLAUSE_LINEAR,\n+\tOMP_CLAUSE_SAFELEN.\n+\t(check_omp_nesting_restrictions): Same.\n+\t(omp_max_vf): New.\n+\t(lower_rec_simd_input_clauses): New.\n+\t(lower_rec_input_clauses): Handle OMP_SIMD, GF_OMP_FOR_KIND_SIMD,\n+\tOMP_CLAUSE_LINEAR.\n+\t(lower_lastprivate_clauses): Handle OMP_CLAUSE_LINEAR,\n+\tGF_OMP_FOR_KIND_SIMD, OMP_SIMD.\n+\t(expand_omp_build_assign): New.\n+\t(expand_omp_for_init_counts): New.\n+\t(expand_omp_for_init_vars): New.\n+\t(extract_omp_for_update_vars): New.\n+\t(expand_omp_for_generic): Use expand_omp_for_{init,update}_vars\n+\tand rewrite accordingly.\n+\t(expand_omp_simd): New.\n+\t(expand_omp_for): Use expand_omp_simd.\n+\t(lower_omp_for_lastprivate): Unshare vinit when appropriate.\n+\t(lower_omp_for): Do not lower the body.\n+\t* tree-data-ref (get_references_in_stmt): Allow IFN_GOMP_SIMD_LANE\n+\tin their own loops.\n+\t* tree-flow.h (find_omp_clause): Remove prototype.\n+\t* tree-if-conv.c (main_tree_if_conversion): Run if doing if\n+\tconversion, forcing vectorization of the loop, or if\n+\tflag_tree_vectorize.\n+\t(gate_tree_if_conversion): Similarly.\n+\t* tree-inline.c (remap_gimple_stmt): Pass for kind argument to\n+\tgimple_build_omp_for.\n+\t(copy_cfg_body): set has_force_vect_loops and has_simduid_loops.\n+\t* tree-parloops (create_parallel_loop): Pass kind argument to\n+\tgimple_build_omp_for.\n+\t* tree-pretty-print.c (dump_omp_clause): Add cases for\n+\tOMP_CLAUSE_UNIFORM, OMP_CLAUSE_LINEAR, OMP_CLAUSE_SAFELEN,\n+\tOMP_CLAUSE__SIMDUID_.\n+\t(dump_generic_node): Handle OMP_SIMD.\n+\t* tree-ssa-ccp.c (likely_value): Handle IFN_GOMP_SIMD*.\n+\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely_1): Do not\n+\tunroll OMP_SIMD loops here.\n+\t* tree-ssa-loop.c (gate_tree_vectorize): Run if\n+\thas_force_vect_loops.\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Handle\n+\tloop->safelen\n+\t(vect_analyze_data_refs): Handle simd loops.\n+\t* tree-vect-loop.c (vectorizable_live_operation): Handle\n+\tIFN_GOMP_SIMD*.\n+\t* tree-vect-stmts.c (vectorizable_call): Handle\n+\tIFN_GOMP_SIMD_LANE.\n+\t(vectorizable_store): Handle STMT_VINFO_SIMD_LANE_ACCESS_P.\n+\t(vectorizable_load): Same.\n+\t* tree-vectorizer.c: Include hash-table.h and\n+\ttree-ssa-propagate.h.\n+\t(struct simduid_to_vf): New.\n+\t(simduid_to_vf::hash): New.\n+\t(simduid_to-vf::equal): New.\n+\t(struct simd_array_to_simduid): New.\n+\t(simd_array_to_simduid::hash): New.\n+\t(simd_array_to_simduid::equal): New.\n+\t(adjust_simduid_builtins): New.\n+\t(struct note_simd_array_uses_struct): New.\n+\t(note_simd_array_uses_cb): New.\n+\t(note_simd_array_uses): New.\n+\t(vectorize_loops): Handle simd hints and adjust simd builtins\n+\taccordingly.\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add\n+\tsimd_lane_access_p field.\n+\t(STMT_VINFO_SIMD_LANE_ACCESS_P): New macro.\n+\t* tree.c (omp_clause_num_ops): Add entries for OMP_CLAUSE_LINEAR,\n+\tOMP_CLAUSE_SAFELEN, OMP_CLAUSE__SIMDUID_, OMP_CLAUSE_UNIFORM.\n+\t(omp_clause_code_name): Same.\n+\t(walk_tree_1): Handle OMP_CLAUSE_UNIFORM, OMP_CLAUSE_SAFELEN,\n+\tOMP_CLAUSE__SIMDUID_, OMP_CLAUSE_LINEAR.\n+\t* tree.def (OMP_SIMD): New entry.\n+\t* tree.h (enum omp_clause_code): Add entries for\n+\tOMP_CLAUSE_LINEAR, OMP_CLAUSE_UNIFORM, OMP_CLAUSE_SAFELEN,\n+\tOMP_CLAUSE__SIMDUID_.\n+\t(OMP_CLAUSE_DECL): Adjust range for new clauses.\n+\t(OMP_CLAUSE_LINEAR_NO_COPYIN): New.\n+\t(OMP_CLAUSE_LINEAR_NO_COPYOUT): New.\n+\t(OMP_CLAUSE_LINEAR_STEP): New.\n+\t(OMP_CLAUSE_SAFELEN_EXPR): New.\n+\t(OMP_CLAUSE__SIMDUID__DECL): New.\n+\t(find_omp_clause): New prototype.\n+\n 2013-08-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/driver-i386.c (host_detect_local_cpu): Update"}, {"sha": "387b60f1ecff310d4b621a3f455719dbee09d264", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -2565,7 +2565,7 @@ omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_FLOW_H) $(FLAGS_H) $(EXPR_H) $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_PASS_H) $(GGC_H) $(EXCEPT_H) $(SPLAY_TREE_H) $(OPTABS_H) \\\n-   $(CFGLOOP_H) tree-iterator.h gt-omp-low.h\n+   $(CFGLOOP_H) tree-iterator.h $(TARGET_H) gt-omp-low.h\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(HASH_TABLE_H) $(TREE_H) $(TREE_PRETTY_PRINT_H)\n omega.o : omega.c $(OMEGA_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\"}, {"sha": "cd2f527bb471043b0bb26502b0f9edb3f5da98ea", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -168,6 +168,20 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n      describes what is the state of the estimation.  */\n   enum loop_estimation estimate_state;\n \n+  /* If > 0, an integer, where the user asserted that for any\n+     I in [ 0, nb_iterations ) and for any J in\n+     [ I, min ( I + safelen, nb_iterations ) ), the Ith and Jth iterations\n+     of the loop can be safely evaluated concurrently.  */\n+  int safelen;\n+\n+  /* True if we should try harder to vectorize this loop.  */\n+  bool force_vect;\n+\n+  /* For SIMD loops, this is a unique identifier of the loop, referenced\n+     by IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LANE and IFN_GOMP_SIMD_LAST_LANE\n+     builtins.  */\n+  tree simduid;\n+\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n "}, {"sha": "f4f8b14f7294a97e2e431a4e7ad34be5408fb429", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1,3 +1,8 @@\n+2013-08-27  Jakub Jelinek  <jakub@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* cp-tree.h (CP_OMP_CLAUSE_INFO): Adjust range for new clauses.\n+\n 2013-08-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grokfndecl): Remove old bison hack."}, {"sha": "876a72aafede4a3a4ad23d81852d22cd0ca11f3c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -4020,7 +4020,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    See semantics.c for details.  */\n #define CP_OMP_CLAUSE_INFO(NODE) \\\n   TREE_TYPE (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n-\t\t\t\t     OMP_CLAUSE_COPYPRIVATE))\n+\t\t\t\t     OMP_CLAUSE_LINEAR))\n \n /* Nonzero if this transaction expression's body contains statements.  */\n #define TRANSACTION_EXPR_IS_STMT(NODE) \\"}, {"sha": "d1f4ffc1fd4ccf7fce03bb0fe8adf2836c9a3621", "filename": "gcc/function.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -650,6 +650,14 @@ struct GTY(()) function {\n      adjusts one of its arguments and forwards to another\n      function.  */\n   unsigned int is_thunk : 1;\n+\n+  /* Nonzero if the current function contains any loops with\n+     loop->force_vect set.  */\n+  unsigned int has_force_vect_loops : 1;\n+\n+  /* Nonzero if the current function contains any loops with\n+     nonzero value in loop->simduid.  */\n+  unsigned int has_simduid_loops : 1;\n };\n \n /* Add the decl D to the local_decls list of FUN.  */"}, {"sha": "3ab558cae38fa996daf509f5be9b71a10ae6b5bd", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1088,8 +1088,20 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n   if (flags & TDF_RAW)\n     {\n-      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n-                       gimple_omp_body (gs));\n+      const char *kind;\n+      switch (gimple_omp_for_kind (gs))\n+\t{\n+\tcase GF_OMP_FOR_KIND_FOR:\n+\t  kind = \"\";\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_SIMD:\n+\t  kind = \" simd\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      dump_gimple_fmt (buffer, spc, flags, \"%G%s <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       kind, gimple_omp_body (gs));\n       dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n       dump_gimple_fmt (buffer, spc, flags, \" >,\");\n       for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n@@ -1105,7 +1117,17 @@ dump_gimple_omp_for (pretty_printer *buffer, gimple gs, int spc, int flags)\n     }\n   else\n     {\n-      pp_string (buffer, \"#pragma omp for\");\n+      switch (gimple_omp_for_kind (gs))\n+\t{\n+\tcase GF_OMP_FOR_KIND_FOR:\n+\t  pp_string (buffer, \"#pragma omp for\");\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_SIMD:\n+\t  pp_string (buffer, \"#pragma omp simd\");\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n       for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n \t{"}, {"sha": "4dbcdda31b9087825e965dd81cdb31d314593c68", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -902,19 +902,21 @@ gimple_build_omp_critical (gimple_seq body, tree name)\n /* Build a GIMPLE_OMP_FOR statement.\n \n    BODY is sequence of statements inside the for loop.\n+   KIND is the `for' variant.\n    CLAUSES, are any of the OMP loop construct's clauses: private, firstprivate,\n    lastprivate, reductions, ordered, schedule, and nowait.\n    COLLAPSE is the collapse count.\n    PRE_BODY is the sequence of statements that are loop invariant.  */\n \n gimple\n-gimple_build_omp_for (gimple_seq body, tree clauses, size_t collapse,\n+gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n \t\t      gimple_seq pre_body)\n {\n   gimple p = gimple_alloc (GIMPLE_OMP_FOR, 0);\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_for_set_clauses (p, clauses);\n+  gimple_omp_for_set_kind (p, kind);\n   p->gimple_omp_for.collapse = collapse;\n   p->gimple_omp_for.iter\n       = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);"}, {"sha": "f3652f4e78f79d713533e93139ae07eae053d660", "filename": "gcc/gimple.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -287,7 +287,7 @@ DEFGSCODE(GIMPLE_OMP_ORDERED, \"gimple_omp_ordered\", GSS_OMP)\n \n    BODY is a the sequence of statements to be executed by all threads.\n \n-   CLAUSES is a TREE_LIST node with all the clauses.\n+   CLAUSES is an OMP_CLAUSE chain with all the clauses.\n \n    CHILD_FN is set when outlining the body of the parallel region.\n    All the statements in BODY are moved into this newly created\n@@ -306,7 +306,7 @@ DEFGSCODE(GIMPLE_OMP_PARALLEL, \"gimple_omp_parallel\", GSS_OMP_PARALLEL)\n \n    BODY is a the sequence of statements to be executed by all threads.\n \n-   CLAUSES is a TREE_LIST node with all the clauses.\n+   CLAUSES is an OMP_CLAUSE chain with all the clauses.\n \n    CHILD_FN is set when outlining the body of the explicit task region.\n    All the statements in BODY are moved into this newly created\n@@ -334,7 +334,7 @@ DEFGSCODE(GIMPLE_OMP_SECTION, \"gimple_omp_section\", GSS_OMP)\n /* OMP_SECTIONS <BODY, CLAUSES, CONTROL> represents #pragma omp sections.\n \n    BODY is the sequence of statements in the sections body.\n-   CLAUSES is a TREE_LIST node holding the list of associated clauses.\n+   CLAUSES is an OMP_CLAUSE chain holding the list of associated clauses.\n    CONTROL is a VAR_DECL used for deciding which of the sections\n    to execute.  */\n DEFGSCODE(GIMPLE_OMP_SECTIONS, \"gimple_omp_sections\", GSS_OMP_SECTIONS)\n@@ -346,7 +346,7 @@ DEFGSCODE(GIMPLE_OMP_SECTIONS_SWITCH, \"gimple_omp_sections_switch\", GSS_BASE)\n \n /* GIMPLE_OMP_SINGLE <BODY, CLAUSES> represents #pragma omp single\n    BODY is the sequence of statements inside the single section.\n-   CLAUSES is a TREE_LIST node holding the associated clauses.  */\n+   CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */\n DEFGSCODE(GIMPLE_OMP_SINGLE, \"gimple_omp_single\", GSS_OMP_SINGLE)\n \n /* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction."}, {"sha": "9f29561eb3787a9cc11b30da6139b4086f6e5065", "filename": "gcc/gimple.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -110,6 +110,9 @@ enum gf_mask {\n     GF_CALL_ALLOCA_FOR_VAR\t= 1 << 5,\n     GF_CALL_INTERNAL\t\t= 1 << 6,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n+    GF_OMP_FOR_KIND_MASK\t= 3 << 0,\n+    GF_OMP_FOR_KIND_FOR\t\t= 0 << 0,\n+    GF_OMP_FOR_KIND_SIMD\t= 1 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -799,7 +802,7 @@ gimple gimple_build_switch_nlabels (unsigned, tree, tree);\n gimple gimple_build_switch (tree, tree, vec<tree> );\n gimple gimple_build_omp_parallel (gimple_seq, tree, tree, tree);\n gimple gimple_build_omp_task (gimple_seq, tree, tree, tree, tree, tree, tree);\n-gimple gimple_build_omp_for (gimple_seq, tree, size_t, gimple_seq);\n+gimple gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gimple gimple_build_omp_critical (gimple_seq, tree);\n gimple gimple_build_omp_section (gimple_seq);\n gimple gimple_build_omp_continue (tree, tree);\n@@ -3948,6 +3951,27 @@ gimple_omp_critical_set_name (gimple gs, tree name)\n }\n \n \n+/* Return the kind of OMP for statemement.  */\n+\n+static inline int\n+gimple_omp_for_kind (const_gimple g)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  return (gimple_omp_subcode (g) & GF_OMP_FOR_KIND_MASK);\n+}\n+\n+\n+/* Set the OMP for kind.  */\n+\n+static inline void\n+gimple_omp_for_set_kind (gimple g, int kind)\n+{\n+  GIMPLE_CHECK (g, GIMPLE_OMP_FOR);\n+  g->gsbase.subcode = (g->gsbase.subcode & ~GF_OMP_FOR_KIND_MASK)\n+\t\t      | (kind & GF_OMP_FOR_KIND_MASK);\n+}\n+\n+\n /* Return the clauses associated with OMP_FOR GS.  */\n \n static inline tree"}, {"sha": "3b3adb34317b53377171b150b5280dc3a4688147", "filename": "gcc/gimplify.c", "status": "modified", "additions": 182, "deletions": 18, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -58,14 +58,17 @@ enum gimplify_omp_var_data\n   GOVD_LOCAL = 128,\n   GOVD_DEBUG_PRIVATE = 256,\n   GOVD_PRIVATE_OUTER_REF = 512,\n+  GOVD_LINEAR = 2048,\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n-\t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LOCAL)\n+\t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n+\t\t\t   | GOVD_LOCAL)\n };\n \n \n enum omp_region_type\n {\n   ORT_WORKSHARE = 0,\n+  ORT_SIMD = 1,\n   ORT_PARALLEL = 2,\n   ORT_COMBINED_PARALLEL = 3,\n   ORT_TASK = 4,\n@@ -710,7 +713,9 @@ gimple_add_tmp_var (tree tmp)\n       if (gimplify_omp_ctxp)\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n-\t  while (ctx && ctx->region_type == ORT_WORKSHARE)\n+\t  while (ctx\n+\t\t && (ctx->region_type == ORT_WORKSHARE\n+\t\t     || ctx->region_type == ORT_SIMD))\n \t    ctx = ctx->outer_context;\n \t  if (ctx)\n \t    omp_add_variable (ctx, tmp, GOVD_LOCAL | GOVD_SEEN);\n@@ -2061,7 +2066,9 @@ gimplify_var_or_parm_decl (tree *expr_p)\n \t  && decl_function_context (decl) != current_function_decl)\n \t{\n \t  struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n-\t  while (ctx && ctx->region_type == ORT_WORKSHARE)\n+\t  while (ctx\n+\t\t && (ctx->region_type == ORT_WORKSHARE\n+\t\t     || ctx->region_type == ORT_SIMD))\n \t    ctx = ctx->outer_context;\n \t  if (!ctx && !pointer_set_insert (nonlocal_vlas, decl))\n \t    {\n@@ -4702,6 +4709,7 @@ is_gimple_stmt (tree t)\n     case STATEMENT_LIST:\n     case OMP_PARALLEL:\n     case OMP_FOR:\n+    case OMP_SIMD:\n     case OMP_SECTIONS:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n@@ -5714,7 +5722,8 @@ omp_firstprivatize_variable (struct gimplify_omp_ctx *ctx, tree decl)\n \t  else\n \t    return;\n \t}\n-      else if (ctx->region_type != ORT_WORKSHARE)\n+      else if (ctx->region_type != ORT_WORKSHARE\n+\t       && ctx->region_type != ORT_SIMD)\n \tomp_add_variable (ctx, decl, GOVD_FIRSTPRIVATE);\n \n       ctx = ctx->outer_context;\n@@ -5806,7 +5815,8 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t FIRSTPRIVATE and LASTPRIVATE.  */\n       nflags = n->value | flags;\n       gcc_assert ((nflags & GOVD_DATA_SHARE_CLASS)\n-\t\t  == (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE));\n+\t\t  == (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE)\n+\t\t  || (flags & GOVD_DATA_SHARE_CLASS) == 0);\n       n->value = nflags;\n       return;\n     }\n@@ -5870,7 +5880,10 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t}\n     }\n \n-  splay_tree_insert (ctx->variables, (splay_tree_key)decl, flags);\n+  if (n != NULL)\n+    n->value |= flags;\n+  else\n+    splay_tree_insert (ctx->variables, (splay_tree_key)decl, flags);\n }\n \n /* Notice a threadprivate variable DECL used in OpenMP context CTX.\n@@ -5936,7 +5949,8 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n       enum omp_clause_default_kind default_kind, kind;\n       struct gimplify_omp_ctx *octx;\n \n-      if (ctx->region_type == ORT_WORKSHARE)\n+      if (ctx->region_type == ORT_WORKSHARE\n+\t  || ctx->region_type == ORT_SIMD)\n \tgoto do_outer;\n \n       /* ??? Some compiler-generated variables (like SAVE_EXPRs) could be\n@@ -6049,7 +6063,7 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n    to the contrary in the innermost scope, generate an error.  */\n \n static bool\n-omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n+omp_is_private (struct gimplify_omp_ctx *ctx, tree decl, bool simd)\n {\n   splay_tree_node n;\n \n@@ -6060,8 +6074,12 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n \t{\n \t  if (ctx == gimplify_omp_ctxp)\n \t    {\n-\t      error (\"iteration variable %qE should be private\",\n-\t\t     DECL_NAME (decl));\n+\t      if (simd)\n+\t\terror (\"iteration variable %qE is predetermined linear\",\n+\t\t       DECL_NAME (decl));\n+\t      else\n+\t\terror (\"iteration variable %qE should be private\",\n+\t\t       DECL_NAME (decl));\n \t      n->value = GOVD_PRIVATE;\n \t      return true;\n \t    }\n@@ -6079,16 +6097,26 @@ omp_is_private (struct gimplify_omp_ctx *ctx, tree decl)\n \t  else if ((n->value & GOVD_REDUCTION) != 0)\n \t    error (\"iteration variable %qE should not be reduction\",\n \t\t   DECL_NAME (decl));\n+\t  else if (simd && (n->value & GOVD_LASTPRIVATE) != 0)\n+\t    error (\"iteration variable %qE should not be lastprivate\",\n+\t\t   DECL_NAME (decl));\n+\t  else if (simd && (n->value & GOVD_PRIVATE) != 0)\n+\t    error (\"iteration variable %qE should not be private\",\n+\t\t   DECL_NAME (decl));\n+\t  else if (simd && (n->value & GOVD_LINEAR) != 0)\n+\t    error (\"iteration variable %qE is predetermined linear\",\n+\t\t   DECL_NAME (decl));\n \t}\n       return (ctx == gimplify_omp_ctxp\n \t      || (ctx->region_type == ORT_COMBINED_PARALLEL\n \t\t  && gimplify_omp_ctxp->outer_context == ctx));\n     }\n \n-  if (ctx->region_type != ORT_WORKSHARE)\n+  if (ctx->region_type != ORT_WORKSHARE\n+      && ctx->region_type != ORT_SIMD)\n     return false;\n   else if (ctx->outer_context)\n-    return omp_is_private (ctx->outer_context, decl);\n+    return omp_is_private (ctx->outer_context, decl, simd);\n   return false;\n }\n \n@@ -6113,7 +6141,8 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl)\n       if (n != NULL)\n \treturn (n->value & GOVD_SHARED) == 0;\n     }\n-  while (ctx->region_type == ORT_WORKSHARE);\n+  while (ctx->region_type == ORT_WORKSHARE\n+\t || ctx->region_type == ORT_SIMD);\n   return false;\n }\n \n@@ -6166,6 +6195,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  flags = GOVD_REDUCTION | GOVD_SEEN | GOVD_EXPLICIT;\n \t  check_non_private = \"reduction\";\n \t  goto do_add;\n+       case OMP_CLAUSE_LINEAR:\n+\t if (gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c), pre_p, NULL,\n+\t\t\t    is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t   {\n+\t     remove = true;\n+\t     break;\n+\t   }\n+\t flags = GOVD_LINEAR | GOVD_EXPLICIT;\n+\t goto do_add;\n \n \tdo_add:\n \t  decl = OMP_CLAUSE_DECL (c);\n@@ -6264,6 +6302,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  break;\n \n \tcase OMP_CLAUSE_DEFAULT:\n@@ -6321,7 +6360,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t      splay_tree_node on\n \t\t= splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n \t      if (on && (on->value & (GOVD_FIRSTPRIVATE | GOVD_LASTPRIVATE\n-\t\t\t\t      | GOVD_PRIVATE | GOVD_REDUCTION)) != 0)\n+\t\t\t\t      | GOVD_PRIVATE | GOVD_REDUCTION\n+\t\t\t\t      | GOVD_LINEAR)) != 0)\n \t\tbreak;\n \t      ctx = ctx->outer_context;\n \t    }\n@@ -6334,6 +6374,8 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     code = OMP_CLAUSE_PRIVATE;\n   else if (flags & GOVD_FIRSTPRIVATE)\n     code = OMP_CLAUSE_FIRSTPRIVATE;\n+  else if (flags & GOVD_LASTPRIVATE)\n+    code = OMP_CLAUSE_LASTPRIVATE;\n   else\n     gcc_unreachable ();\n \n@@ -6366,6 +6408,7 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  n = splay_tree_lookup (ctx->variables, (splay_tree_key) decl);\n \t  remove = !(n->value & GOVD_SEEN);\n@@ -6381,6 +6424,31 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \t\t  OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_PRIVATE);\n \t\t  OMP_CLAUSE_PRIVATE_DEBUG (c) = 1;\n \t\t}\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t\t  && ctx->outer_context\n+\t\t  && !(OMP_CLAUSE_LINEAR_NO_COPYIN (c)\n+\t\t       && OMP_CLAUSE_LINEAR_NO_COPYOUT (c))\n+\t\t  && !is_global_var (decl))\n+\t\t{\n+\t\t  if (ctx->outer_context->region_type == ORT_COMBINED_PARALLEL)\n+\t\t    {\n+\t\t      n = splay_tree_lookup (ctx->outer_context->variables,\n+\t\t\t\t\t     (splay_tree_key) decl);\n+\t\t      if (n == NULL\n+\t\t\t  || (n->value & GOVD_DATA_SHARE_CLASS) == 0)\n+\t\t\t{\n+\t\t\t  int flags = OMP_CLAUSE_LINEAR_NO_COPYIN (c)\n+\t\t\t\t      ? GOVD_LASTPRIVATE : GOVD_SHARED;\n+\t\t\t  if (n == NULL)\n+\t\t\t    omp_add_variable (ctx->outer_context, decl,\n+\t\t\t\t\t      flags | GOVD_SEEN);\n+\t\t\t  else\n+\t\t\t    n->value |= flags | GOVD_SEEN;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    omp_notice_variable (ctx->outer_context, decl, true);\n+\t\t}\n \t    }\n \t  break;\n \n@@ -6406,6 +6474,7 @@ gimplify_adjust_omp_clauses (tree *list_p)\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  break;\n \n \tdefault:\n@@ -6509,14 +6578,40 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   gimple gfor;\n   gimple_seq for_body, for_pre_body;\n   int i;\n+  bool simd;\n+  bitmap has_decl_expr = NULL;\n \n   for_stmt = *expr_p;\n \n+  simd = TREE_CODE (for_stmt) == OMP_SIMD; \n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n-\t\t\t     ORT_WORKSHARE);\n+\t\t\t     simd ? ORT_SIMD : ORT_WORKSHARE);\n \n   /* Handle OMP_FOR_INIT.  */\n   for_pre_body = NULL;\n+  if (simd && OMP_FOR_PRE_BODY (for_stmt))\n+    {\n+      has_decl_expr = BITMAP_ALLOC (NULL);\n+      if (TREE_CODE (OMP_FOR_PRE_BODY (for_stmt)) == DECL_EXPR\n+\t  && TREE_CODE (DECL_EXPR_DECL (OMP_FOR_PRE_BODY (for_stmt)))\n+\t  == VAR_DECL)\n+\t{\n+\t  t = OMP_FOR_PRE_BODY (for_stmt);\n+\t  bitmap_set_bit (has_decl_expr, DECL_UID (DECL_EXPR_DECL (t)));\n+\t}\n+      else if (TREE_CODE (OMP_FOR_PRE_BODY (for_stmt)) == STATEMENT_LIST)\n+\t{\n+\t  tree_stmt_iterator si;\n+\t  for (si = tsi_start (OMP_FOR_PRE_BODY (for_stmt)); !tsi_end_p (si);\n+\t       tsi_next (&si))\n+\t    {\n+\t      t = tsi_stmt (si);\n+\t      if (TREE_CODE (t) == DECL_EXPR\n+\t\t  && TREE_CODE (DECL_EXPR_DECL (t)) == VAR_DECL)\n+\t\tbitmap_set_bit (has_decl_expr, DECL_UID (DECL_EXPR_DECL (t)));\n+\t    }\n+\t}\n+    }\n   gimplify_and_add (OMP_FOR_PRE_BODY (for_stmt), &for_pre_body);\n   OMP_FOR_PRE_BODY (for_stmt) = NULL_TREE;\n \n@@ -6535,7 +6630,44 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t  || POINTER_TYPE_P (TREE_TYPE (decl)));\n \n       /* Make sure the iteration variable is private.  */\n-      if (omp_is_private (gimplify_omp_ctxp, decl))\n+      tree c = NULL_TREE;\n+      if (simd)\n+\t{\n+\t  splay_tree_node n = splay_tree_lookup (gimplify_omp_ctxp->variables,\n+\t\t\t\t\t\t (splay_tree_key)decl);\n+\t  omp_is_private (gimplify_omp_ctxp, decl, simd);\n+\t  if (n != NULL && (n->value & GOVD_DATA_SHARE_CLASS) != 0)\n+\t    omp_notice_variable (gimplify_omp_ctxp, decl, true);\n+\t  else if (TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)) == 1)\n+\t    {\n+\t      c = build_omp_clause (input_location, OMP_CLAUSE_LINEAR);\n+\t      OMP_CLAUSE_LINEAR_NO_COPYIN (c) = 1;\n+\t      if (has_decl_expr\n+\t\t  && bitmap_bit_p (has_decl_expr, DECL_UID (decl)))\n+\t\tOMP_CLAUSE_LINEAR_NO_COPYOUT (c) = 1;\n+\t      OMP_CLAUSE_DECL (c) = decl;\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (for_stmt);\n+\t      OMP_FOR_CLAUSES (for_stmt) = c;\n+\t      omp_add_variable (gimplify_omp_ctxp, decl,\n+\t\t\t\tGOVD_LINEAR | GOVD_EXPLICIT | GOVD_SEEN);\n+\t    }\n+\t  else\n+\t    {\n+\t      bool lastprivate\n+\t\t= (!has_decl_expr\n+\t\t   || !bitmap_bit_p (has_decl_expr, DECL_UID (decl)));\n+\t      c = build_omp_clause (input_location,\n+\t\t\t\t    lastprivate ? OMP_CLAUSE_LASTPRIVATE\n+\t\t\t\t\t\t: OMP_CLAUSE_PRIVATE);\n+\t      OMP_CLAUSE_DECL (c) = decl;\n+\t      OMP_CLAUSE_CHAIN (c) = OMP_FOR_CLAUSES (for_stmt);\n+\t      omp_add_variable (gimplify_omp_ctxp, decl,\n+\t\t\t\t(lastprivate ? GOVD_LASTPRIVATE : GOVD_PRIVATE)\n+\t\t\t\t| GOVD_SEEN);\n+\t      c = NULL_TREE;\n+\t    }\n+\t}\n+      else if (omp_is_private (gimplify_omp_ctxp, decl, simd))\n \tomp_notice_variable (gimplify_omp_ctxp, decl, true);\n       else\n \tomp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n@@ -6577,6 +6709,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tcase PREINCREMENT_EXPR:\n \tcase POSTINCREMENT_EXPR:\n \t  t = build_int_cst (TREE_TYPE (decl), 1);\n+\t  if (c)\n+\t    OMP_CLAUSE_LINEAR_STEP (c) = t;\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (var), var, t);\n \t  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n@@ -6585,6 +6719,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tcase PREDECREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n \t  t = build_int_cst (TREE_TYPE (decl), -1);\n+\t  if (c)\n+\t    OMP_CLAUSE_LINEAR_STEP (c) = t;\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (var), var, t);\n \t  TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i) = t;\n@@ -6618,6 +6754,20 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n \t\t\t\tis_gimple_val, fb_rvalue);\n \t  ret = MIN (ret, tret);\n+\t  if (c)\n+\t    {\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = TREE_OPERAND (t, 1);\n+\t      if (TREE_CODE (t) == MINUS_EXPR)\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 1);\n+\t\t  OMP_CLAUSE_LINEAR_STEP (c)\n+\t\t    = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n+\t\t  tret = gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c),\n+\t\t\t\t\t&for_pre_body, NULL,\n+\t\t\t\t\tis_gimple_val, fb_rvalue);\n+\t\t  ret = MIN (ret, tret);\n+\t\t}\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -6648,11 +6798,21 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t}\n     }\n \n+  BITMAP_FREE (has_decl_expr);\n+\n   gimplify_and_add (OMP_FOR_BODY (for_stmt), &for_body);\n \n   gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (for_stmt));\n \n-  gfor = gimple_build_omp_for (for_body, OMP_FOR_CLAUSES (for_stmt),\n+  int kind;\n+  switch (TREE_CODE (for_stmt))\n+    {\n+    case OMP_FOR: kind = GF_OMP_FOR_KIND_FOR; break;\n+    case OMP_SIMD: kind = GF_OMP_FOR_KIND_SIMD; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gfor = gimple_build_omp_for (for_body, kind, OMP_FOR_CLAUSES (for_stmt),\n \t\t\t       TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)),\n \t\t\t       for_pre_body);\n \n@@ -6669,7 +6829,10 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     }\n \n   gimplify_seq_add_stmt (pre_p, gfor);\n-  return ret == GS_ALL_DONE ? GS_ALL_DONE : GS_ERROR;\n+  if (ret != GS_ALL_DONE)\n+    return GS_ERROR;\n+  *expr_p = NULL_TREE;\n+  return GS_ALL_DONE;\n }\n \n /* Gimplify the gross structure of other OpenMP worksharing constructs.\n@@ -7587,6 +7750,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  break;\n \n \tcase OMP_FOR:\n+\tcase OMP_SIMD:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n "}, {"sha": "983efeb751b33f03f562bb01383a579c297d334f", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -109,6 +109,30 @@ expand_STORE_LANES (gimple stmt)\n   expand_insn (get_multi_vector_move (type, vec_store_lanes_optab), 2, ops);\n }\n \n+/* This should get expanded in adjust_simduid_builtins.  */\n+\n+static void\n+expand_GOMP_SIMD_LANE (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in adjust_simduid_builtins.  */\n+\n+static void\n+expand_GOMP_SIMD_VF (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n+/* This should get expanded in adjust_simduid_builtins.  */\n+\n+static void\n+expand_GOMP_SIMD_LAST_LANE (gimple stmt ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "5427664b8e3c5c2bfe1efe2c7f608e733de8b552", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -40,3 +40,6 @@ along with GCC; see the file COPYING3.  If not see\n \n DEF_INTERNAL_FN (LOAD_LANES, ECF_CONST | ECF_LEAF)\n DEF_INTERNAL_FN (STORE_LANES, ECF_CONST | ECF_LEAF)\n+DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW)"}, {"sha": "d24270f97a85bb30ff853054dce98573c06ae6e6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1069, "deletions": 250, "changes": 1319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"optabs.h\"\n #include \"cfgloop.h\"\n+#include \"target.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two\n@@ -222,6 +223,7 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n   int i;\n   struct omp_for_data_loop dummy_loop;\n   location_t loc = gimple_location (for_stmt);\n+  bool simd = gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_SIMD;\n \n   fd->for_stmt = for_stmt;\n   fd->pre = NULL;\n@@ -349,7 +351,18 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t  gcc_unreachable ();\n \t}\n \n-      if (iter_type != long_long_unsigned_type_node)\n+      if (simd)\n+\t{\n+\t  if (fd->collapse == 1)\n+\t    iter_type = TREE_TYPE (loop->v);\n+\t  else if (i == 0\n+\t\t   || TYPE_PRECISION (iter_type)\n+\t\t      < TYPE_PRECISION (TREE_TYPE (loop->v)))\n+\t    iter_type\n+\t      = build_nonstandard_integer_type\n+\t      (TYPE_PRECISION (TREE_TYPE (loop->v)), 1);\n+\t}\n+      else if (iter_type != long_long_unsigned_type_node)\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->v)))\n \t    iter_type = long_long_unsigned_type_node;\n@@ -445,7 +458,8 @@ extract_omp_for_data (gimple for_stmt, struct omp_for_data *fd,\n \t}\n     }\n \n-  if (count)\n+  if (count\n+      && !simd)\n     {\n       if (!tree_int_cst_lt (count, TYPE_MAX_VALUE (long_integer_type_node)))\n \titer_type = long_long_unsigned_type_node;\n@@ -918,6 +932,19 @@ build_outer_var_ref (tree var, omp_context *ctx)\n       bool by_ref = use_pointer_for_field (var, NULL);\n       x = build_receiver_ref (var, by_ref, ctx);\n     }\n+  else if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t   && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+    {\n+      /* #pragma omp simd isn't a worksharing construct, and can reference even\n+\t private vars in its linear etc. clauses.  */\n+      x = NULL_TREE;\n+      if (ctx->outer && is_taskreg_ctx (ctx))\n+\tx = lookup_decl (var, ctx->outer);\n+      else if (ctx->outer)\n+\tx = maybe_lookup_decl (var, ctx->outer);\n+      if (x == NULL_TREE)\n+\tx = var;\n+    }\n   else if (ctx->outer)\n     x = lookup_decl (var, ctx->outer);\n   else if (is_reference (var))\n@@ -1423,6 +1450,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \tdo_private:\n \t  if (is_variable_sized (decl))\n@@ -1474,6 +1502,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_COLLAPSE:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  break;\n \n \tdefault:\n@@ -1497,6 +1526,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_REDUCTION:\n+\tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (is_variable_sized (decl))\n \t    install_var_local (decl, ctx);\n@@ -1526,6 +1556,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_FINAL:\n \tcase OMP_CLAUSE_MERGEABLE:\n+\tcase OMP_CLAUSE_SAFELEN:\n \t  break;\n \n \tdefault:\n@@ -1631,7 +1662,6 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   pop_cfun ();\n }\n \n-\n /* Scan an OpenMP parallel directive.  */\n \n static void\n@@ -1831,9 +1861,22 @@ scan_omp_single (gimple stmt, omp_context *outer_ctx)\n static bool\n check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n {\n+  if (ctx != NULL)\n+    {\n+      if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+\t{\n+\t  error_at (gimple_location (stmt),\n+\t\t    \"OpenMP constructs may not be nested inside simd region\");\n+\t  return false;\n+\t}\n+    }\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_OMP_FOR:\n+      if (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_SIMD)\n+\treturn true;\n+      /* FALLTHRU */\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_CALL:\n@@ -2254,6 +2297,73 @@ omp_reduction_init (tree clause, tree type)\n     }\n }\n \n+/* Return maximum possible vectorization factor for the target.  */\n+\n+static int\n+omp_max_vf (void)\n+{\n+  if (!optimize\n+      || optimize_debug\n+      || (!flag_tree_vectorize\n+\t  && global_options_set.x_flag_tree_vectorize))\n+    return 1;\n+\n+  int vs = targetm.vectorize.autovectorize_vector_sizes ();\n+  if (vs)\n+    {\n+      vs = 1 << floor_log2 (vs);\n+      return vs;\n+    }\n+  enum machine_mode vqimode = targetm.vectorize.preferred_simd_mode (QImode);\n+  if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n+    return GET_MODE_NUNITS (vqimode);\n+  return 1;\n+}\n+\n+/* Helper function of lower_rec_input_clauses, used for #pragma omp simd\n+   privatization.  */\n+\n+static bool\n+lower_rec_simd_input_clauses (tree new_var, omp_context *ctx, int &max_vf,\n+\t\t\t      tree &idx, tree &lane, tree &ivar, tree &lvar)\n+{\n+  if (max_vf == 0)\n+    {\n+      max_vf = omp_max_vf ();\n+      if (max_vf > 1)\n+\t{\n+\t  tree c = find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n+\t\t\t\t    OMP_CLAUSE_SAFELEN);\n+\t  if (c\n+\t      && compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c), max_vf) == -1)\n+\t    max_vf = tree_low_cst (OMP_CLAUSE_SAFELEN_EXPR (c), 0);\n+\t}\n+      if (max_vf > 1)\n+\t{\n+\t  idx = create_tmp_var (unsigned_type_node, NULL);\n+\t  lane = create_tmp_var (unsigned_type_node, NULL);\n+\t}\n+    }\n+  if (max_vf == 1)\n+    return false;\n+\n+  tree atype = build_array_type_nelts (TREE_TYPE (new_var), max_vf);\n+  tree avar = create_tmp_var_raw (atype, NULL);\n+  if (TREE_ADDRESSABLE (new_var))\n+    TREE_ADDRESSABLE (avar) = 1;\n+  DECL_ATTRIBUTES (avar)\n+    = tree_cons (get_identifier (\"omp simd array\"), NULL,\n+\t\t DECL_ATTRIBUTES (avar));\n+  gimple_add_tmp_var (avar);\n+  ivar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, idx,\n+\t\t NULL_TREE, NULL_TREE);\n+  lvar = build4 (ARRAY_REF, TREE_TYPE (new_var), avar, lane,\n+\t\t NULL_TREE, NULL_TREE);\n+  SET_DECL_VALUE_EXPR (new_var, lvar);\n+  DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n+  return true;\n+}\n+\n /* Generate code to implement the input clauses, FIRSTPRIVATE and COPYIN,\n    from the receiver (aka child) side and initializers for REFERENCE_TYPE\n    private variables.  Initialization statements go in ILIST, while calls\n@@ -2267,9 +2377,38 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n   bool copyin_by_ref = false;\n   bool lastprivate_firstprivate = false;\n   int pass;\n+  bool is_simd = (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+\t\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD);\n+  int max_vf = 0;\n+  tree lane = NULL_TREE, idx = NULL_TREE;\n+  tree ivar = NULL_TREE, lvar = NULL_TREE;\n+  gimple_seq llist[2] = { NULL, NULL };\n \n   copyin_seq = NULL;\n \n+  /* Set max_vf=1 (which will later enforce safelen=1) in simd loops\n+     with data sharing clauses referencing variable sized vars.  That\n+     is unnecessarily hard to support and very unlikely to result in\n+     vectorized code anyway.  */\n+  if (is_simd)\n+    for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n+      switch (OMP_CLAUSE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+\t    max_vf = 1;\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_PRIVATE:\n+\tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\tcase OMP_CLAUSE_LASTPRIVATE:\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  if (is_variable_sized (OMP_CLAUSE_DECL (c)))\n+\t    max_vf = 1;\n+\t  break;\n+\tdefault:\n+\t  continue;\n+\t}\n+\n   /* Do all the fixed sized types in the first pass, and the variable sized\n      types in the second pass.  This makes sure that the scalar arguments to\n      the variable sized types are processed before we use them in the\n@@ -2299,6 +2438,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t    case OMP_CLAUSE_COPYIN:\n \t    case OMP_CLAUSE_REDUCTION:\n \t      break;\n+\t    case OMP_CLAUSE_LINEAR:\n+\t      break;\n \t    case OMP_CLAUSE_LASTPRIVATE:\n \t      if (OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE (c))\n \t\t{\n@@ -2443,7 +2584,36 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t}\n \t      else\n \t\tx = NULL;\n+\t    do_private:\n \t      x = lang_hooks.decls.omp_clause_default_ctor (c, new_var, x);\n+\t      if (is_simd)\n+\t\t{\n+\t\t  tree y = lang_hooks.decls.omp_clause_dtor (c, new_var);\n+\t\t  if ((TREE_ADDRESSABLE (new_var) || x || y\n+\t\t       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n+\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t    {\n+\t\t      if (x)\n+\t\t\tx = lang_hooks.decls.omp_clause_default_ctor\n+\t\t\t\t\t\t(c, unshare_expr (ivar), x);\n+\t\t      if (x)\n+\t\t\tgimplify_and_add (x, &llist[0]);\n+\t\t      if (y)\n+\t\t\t{\n+\t\t\t  y = lang_hooks.decls.omp_clause_dtor (c, ivar);\n+\t\t\t  if (y)\n+\t\t\t    {\n+\t\t\t      gimple_seq tseq = NULL;\n+\n+\t\t\t      dtor = y;\n+\t\t\t      gimplify_stmt (&dtor, &tseq);\n+\t\t\t      gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      if (x)\n \t\tgimplify_and_add (x, ilist);\n \t      /* FALLTHRU */\n@@ -2460,6 +2630,15 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t}\n \t      break;\n \n+\t    case OMP_CLAUSE_LINEAR:\n+\t      if (!OMP_CLAUSE_LINEAR_NO_COPYIN (c))\n+\t\tgoto do_firstprivate;\n+\t      if (OMP_CLAUSE_LINEAR_NO_COPYOUT (c))\n+\t\tx = NULL;\n+\t      else\n+\t\tx = build_outer_var_ref (var, ctx);\n+\t      goto do_private;\n+\n \t    case OMP_CLAUSE_FIRSTPRIVATE:\n \t      if (is_task_ctx (ctx))\n \t\t{\n@@ -2475,11 +2654,56 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      goto do_dtor;\n \t\t    }\n \t\t}\n+\t    do_firstprivate:\n \t      x = build_outer_var_ref (var, ctx);\n+\t      if (is_simd)\n+\t\t{\n+\t\t  if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_LINEAR\n+\t\t       || TREE_ADDRESSABLE (new_var))\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n+\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t    {\n+\t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR)\n+\t\t\t{\n+\t\t\t  tree iv = create_tmp_var (TREE_TYPE (new_var), NULL);\n+\t\t\t  x = lang_hooks.decls.omp_clause_copy_ctor (c, iv, x);\n+\t\t\t  gimplify_and_add (x, ilist);\n+\t\t\t  gimple_stmt_iterator gsi\n+\t\t\t    = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n+\t\t\t  gimple g\n+\t\t\t    = gimple_build_assign (unshare_expr (lvar), iv);\n+\t\t\t  gsi_insert_before_without_update (&gsi, g,\n+\t\t\t\t\t\t\t    GSI_SAME_STMT);\n+\t\t\t  tree stept = POINTER_TYPE_P (TREE_TYPE (x))\n+\t\t\t\t       ? sizetype : TREE_TYPE (x);\n+\t\t\t  tree t = fold_convert (stept,\n+\t\t\t\t\t\t OMP_CLAUSE_LINEAR_STEP (c));\n+\t\t\t  enum tree_code code = PLUS_EXPR;\n+\t\t\t  if (POINTER_TYPE_P (TREE_TYPE (new_var)))\n+\t\t\t    code = POINTER_PLUS_EXPR;\n+\t\t\t  g = gimple_build_assign_with_ops (code, iv, iv, t);\n+\t\t\t  gsi_insert_before_without_update (&gsi, g,\n+\t\t\t\t\t\t\t    GSI_SAME_STMT);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      x = lang_hooks.decls.omp_clause_copy_ctor\n+\t\t\t\t\t\t(c, unshare_expr (ivar), x);\n+\t\t      gimplify_and_add (x, &llist[0]);\n+\t\t      x = lang_hooks.decls.omp_clause_dtor (c, ivar);\n+\t\t      if (x)\n+\t\t\t{\n+\t\t\t  gimple_seq tseq = NULL;\n+\n+\t\t\t  dtor = x;\n+\t\t\t  gimplify_stmt (&dtor, &tseq);\n+\t\t\t  gimple_seq_add_seq (&llist[1], tseq);\n+\t\t\t}\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      x = lang_hooks.decls.omp_clause_copy_ctor (c, new_var, x);\n \t      gimplify_and_add (x, ilist);\n \t      goto do_dtor;\n-\t      break;\n \n \t    case OMP_CLAUSE_COPYIN:\n \t      by_ref = use_pointer_for_field (var, NULL);\n@@ -2495,6 +2719,8 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n \t\t  x = build_outer_var_ref (var, ctx);\n \n+\t\t  /* FIXME: Not handled yet.  */\n+\t\t  gcc_assert (!is_simd);\n \t\t  if (is_reference (var))\n \t\t    x = build_fold_addr_expr_loc (clause_loc, x);\n \t\t  SET_DECL_VALUE_EXPR (placeholder, x);\n@@ -2509,7 +2735,31 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t{\n \t\t  x = omp_reduction_init (c, TREE_TYPE (new_var));\n \t\t  gcc_assert (TREE_CODE (TREE_TYPE (new_var)) != ARRAY_TYPE);\n-\t\t  gimplify_assign (new_var, x, ilist);\n+\t\t  if (is_simd\n+\t\t      && lower_rec_simd_input_clauses (new_var, ctx, max_vf,\n+\t\t\t\t\t\t       idx, lane, ivar, lvar))\n+\t\t    {\n+\t\t      enum tree_code code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\t\t      tree ref = build_outer_var_ref (var, ctx);\n+\n+\t\t      gimplify_assign (unshare_expr (ivar), x, &llist[0]);\n+\n+\t\t      /* reduction(-:var) sums up the partial results, so it\n+\t\t\t acts identically to reduction(+:var).  */\n+\t\t      if (code == MINUS_EXPR)\n+\t\t\tcode = PLUS_EXPR;\n+\n+\t\t      x = build2 (code, TREE_TYPE (ref), ref, ivar);\n+\t\t      ref = build_outer_var_ref (var, ctx);\n+\t\t      gimplify_assign (ref, x, &llist[1]);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gimplify_assign (new_var, x, ilist);\n+\t\t      if (is_simd)\n+\t\t\tgimplify_assign (build_outer_var_ref (var, ctx),\n+\t\t\t\t\t new_var, dlist);\n+\t\t    }\n \t\t}\n \t      break;\n \n@@ -2519,6 +2769,49 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t}\n     }\n \n+  if (lane)\n+    {\n+      tree uid = create_tmp_var (ptr_type_node, \"simduid\");\n+      gimple g\n+\t= gimple_build_call_internal (IFN_GOMP_SIMD_LANE, 1, uid);\n+      gimple_call_set_lhs (g, lane);\n+      gimple_stmt_iterator gsi = gsi_start_1 (gimple_omp_body_ptr (ctx->stmt));\n+      gsi_insert_before_without_update (&gsi, g, GSI_SAME_STMT);\n+      c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__SIMDUID_);\n+      OMP_CLAUSE__SIMDUID__DECL (c) = uid;\n+      OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n+      gimple_omp_for_set_clauses (ctx->stmt, c);\n+      g = gimple_build_assign_with_ops (INTEGER_CST, lane,\n+\t\t\t\t\tbuild_int_cst (unsigned_type_node, 0),\n+\t\t\t\t\tNULL_TREE);\n+      gimple_seq_add_stmt (ilist, g);\n+      for (int i = 0; i < 2; i++)\n+\tif (llist[i])\n+\t  {\n+\t    tree vf = create_tmp_var (unsigned_type_node, NULL);\n+\t    g = gimple_build_call_internal (IFN_GOMP_SIMD_VF, 1, uid);\n+\t    gimple_call_set_lhs (g, vf);\n+\t    gimple_seq *seq = i == 0 ? ilist : dlist;\n+\t    gimple_seq_add_stmt (seq, g);\n+\t    tree t = build_int_cst (unsigned_type_node, 0);\n+\t    g = gimple_build_assign_with_ops (INTEGER_CST, idx, t, NULL_TREE);\n+\t    gimple_seq_add_stmt (seq, g);\n+\t    tree body = create_artificial_label (UNKNOWN_LOCATION);\n+\t    tree header = create_artificial_label (UNKNOWN_LOCATION);\n+\t    tree end = create_artificial_label (UNKNOWN_LOCATION);\n+\t    gimple_seq_add_stmt (seq, gimple_build_goto (header));\n+\t    gimple_seq_add_stmt (seq, gimple_build_label (body));\n+\t    gimple_seq_add_seq (seq, llist[i]);\n+\t    t = build_int_cst (unsigned_type_node, 1);\n+\t    g = gimple_build_assign_with_ops (PLUS_EXPR, idx, idx, t);\n+\t    gimple_seq_add_stmt (seq, g);\n+\t    gimple_seq_add_stmt (seq, gimple_build_label (header));\n+\t    g = gimple_build_cond (LT_EXPR, idx, vf, body, end);\n+\t    gimple_seq_add_stmt (seq, g);\n+\t    gimple_seq_add_stmt (seq, gimple_build_label (end));\n+\t  }\n+    }\n+\n   /* The copyin sequence is not to be executed by the main thread, since\n      that would result in self-copies.  Perhaps not visible to scalars,\n      but it certainly is to C++ operator=.  */\n@@ -2538,7 +2831,31 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n      lastprivate clauses we need to ensure the lastprivate copying\n      happens after firstprivate copying in all threads.  */\n   if (copyin_by_ref || lastprivate_firstprivate)\n-    gimplify_and_add (build_omp_barrier (), ilist);\n+    {\n+      /* Don't add any barrier for #pragma omp simd or\n+\t #pragma omp distribute.  */\n+      if (gimple_code (ctx->stmt) != GIMPLE_OMP_FOR\n+\t  || gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_FOR)\n+\tgimplify_and_add (build_omp_barrier (), ilist);\n+    }\n+\n+  /* If max_vf is non-zero, then we can use only a vectorization factor\n+     up to the max_vf we chose.  So stick it into the safelen clause.  */\n+  if (max_vf)\n+    {\n+      tree c = find_omp_clause (gimple_omp_for_clauses (ctx->stmt),\n+\t\t\t\tOMP_CLAUSE_SAFELEN);\n+      if (c == NULL_TREE\n+\t  || compare_tree_int (OMP_CLAUSE_SAFELEN_EXPR (c),\n+\t\t\t       max_vf) == 1)\n+\t{\n+\t  c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n+\t  OMP_CLAUSE_SAFELEN_EXPR (c) = build_int_cst (integer_type_node,\n+\t\t\t\t\t\t       max_vf);\n+\t  OMP_CLAUSE_CHAIN (c) = gimple_omp_for_clauses (ctx->stmt);\n+\t  gimple_omp_for_set_clauses (ctx->stmt, c);\n+\t}\n+    }\n }\n \n \n@@ -2550,11 +2867,16 @@ static void\n lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t\t    omp_context *ctx)\n {\n-  tree x, c, label = NULL;\n+  tree x, c, label = NULL, orig_clauses = clauses;\n   bool par_clauses = false;\n+  tree simduid = NULL, lastlane = NULL;\n \n-  /* Early exit if there are no lastprivate clauses.  */\n-  clauses = find_omp_clause (clauses, OMP_CLAUSE_LASTPRIVATE);\n+  /* Early exit if there are no lastprivate or linear clauses.  */\n+  for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n+    if (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_LASTPRIVATE\n+\t|| (OMP_CLAUSE_CODE (clauses) == OMP_CLAUSE_LINEAR\n+\t    && !OMP_CLAUSE_LINEAR_NO_COPYOUT (clauses)))\n+      break;\n   if (clauses == NULL)\n     {\n       /* If this was a workshare clause, see if it had been combined\n@@ -2591,23 +2913,59 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n       gimple_seq_add_stmt (stmt_list, gimple_build_label (label_true));\n     }\n \n+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+    {\n+      simduid = find_omp_clause (orig_clauses, OMP_CLAUSE__SIMDUID_);\n+      if (simduid)\n+\tsimduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n+    }\n+\n   for (c = clauses; c ;)\n     {\n       tree var, new_var;\n       location_t clause_loc = OMP_CLAUSE_LOCATION (c);\n \n-      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t  || (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t      && !OMP_CLAUSE_LINEAR_NO_COPYOUT (c)))\n \t{\n \t  var = OMP_CLAUSE_DECL (c);\n \t  new_var = lookup_decl (var, ctx);\n \n-\t  if (OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c))\n+\t  if (simduid && DECL_HAS_VALUE_EXPR_P (new_var))\n+\t    {\n+\t      tree val = DECL_VALUE_EXPR (new_var);\n+\t      if (TREE_CODE (val) == ARRAY_REF\n+\t\t  && VAR_P (TREE_OPERAND (val, 0))\n+\t\t  && lookup_attribute (\"omp simd array\",\n+\t\t\t\t       DECL_ATTRIBUTES (TREE_OPERAND (val,\n+\t\t\t\t\t\t\t\t      0))))\n+\t\t{\n+\t\t  if (lastlane == NULL)\n+\t\t    {\n+\t\t      lastlane = create_tmp_var (unsigned_type_node, NULL);\n+\t\t      gimple g\n+\t\t\t= gimple_build_call_internal (IFN_GOMP_SIMD_LAST_LANE,\n+\t\t\t\t\t\t      2, simduid,\n+\t\t\t\t\t\t      TREE_OPERAND (val, 1));\n+\t\t      gimple_call_set_lhs (g, lastlane);\n+\t\t      gimple_seq_add_stmt (stmt_list, g);\n+\t\t    }\n+\t\t  new_var = build4 (ARRAY_REF, TREE_TYPE (val),\n+\t\t\t\t    TREE_OPERAND (val, 0), lastlane,\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t\t}\n+\t    }\n+\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t      && OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c))\n \t    {\n \t      lower_omp (&OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c), ctx);\n \t      gimple_seq_add_seq (stmt_list,\n \t\t\t\t  OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c));\n+\t      OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c) = NULL;\n \t    }\n-\t  OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c) = NULL;\n \n \t  x = build_outer_var_ref (var, ctx);\n \t  if (is_reference (var))\n@@ -2649,6 +3007,11 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n   tree x, c;\n   int count = 0;\n \n+  /* SIMD reductions are handled in lower_rec_input_clauses.  */\n+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n+      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n+    return;\n+\n   /* First see if there is exactly one reduction clause.  Use OMP_ATOMIC\n      update in that case, otherwise use a lock.  */\n   for (c = clauses; c && count < 2; c = OMP_CLAUSE_CHAIN (c))\n@@ -3411,6 +3774,24 @@ expand_omp_regimplify_p (tree *tp, int *walk_subtrees, void *)\n   return NULL_TREE;\n }\n \n+/* Prepend TO = FROM assignment before *GSI_P.  */\n+\n+static void\n+expand_omp_build_assign (gimple_stmt_iterator *gsi_p, tree to, tree from)\n+{\n+  bool simple_p = DECL_P (to) && TREE_ADDRESSABLE (to);\n+  from = force_gimple_operand_gsi (gsi_p, from, simple_p, NULL_TREE,\n+\t\t\t\t   true, GSI_SAME_STMT);\n+  gimple stmt = gimple_build_assign (to, from);\n+  gsi_insert_before (gsi_p, stmt, GSI_SAME_STMT);\n+  if (walk_tree (&from, expand_omp_regimplify_p, NULL, NULL)\n+      || walk_tree (&to, expand_omp_regimplify_p, NULL, NULL))\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      gimple_regimplify_operands (stmt, &gsi);\n+    }\n+}\n+\n /* Expand the OpenMP parallel or task directive starting at REGION.  */\n \n static void\n@@ -3654,6 +4035,311 @@ expand_omp_taskreg (struct omp_region *region)\n }\n \n \n+/* Helper function for expand_omp_{for_*,simd}.  If this is the outermost\n+   of the combined collapse > 1 loop constructs, generate code like:\n+\tif (__builtin_expect (N32 cond3 N31, 0)) goto ZERO_ITER_BB;\n+\tif (cond3 is <)\n+\t  adj = STEP3 - 1;\n+\telse\n+\t  adj = STEP3 + 1;\n+\tcount3 = (adj + N32 - N31) / STEP3;\n+\tif (__builtin_expect (N22 cond2 N21, 0)) goto ZERO_ITER_BB;\n+\tif (cond2 is <)\n+\t  adj = STEP2 - 1;\n+\telse\n+\t  adj = STEP2 + 1;\n+\tcount2 = (adj + N22 - N21) / STEP2;\n+\tif (__builtin_expect (N12 cond1 N11, 0)) goto ZERO_ITER_BB;\n+\tif (cond1 is <)\n+\t  adj = STEP1 - 1;\n+\telse\n+\t  adj = STEP1 + 1;\n+\tcount1 = (adj + N12 - N11) / STEP1;\n+\tcount = count1 * count2 * count3;\n+   Furthermore, if ZERO_ITER_BB is NULL, create a BB which does:\n+\tcount = 0;\n+   and set ZERO_ITER_BB to that bb.  */\n+\n+/* NOTE: It *could* be better to moosh all of the BBs together,\n+   creating one larger BB with all the computation and the unexpected\n+   jump at the end.  I.e.\n+\n+   bool zero3, zero2, zero1, zero;\n+\n+   zero3 = N32 c3 N31;\n+   count3 = (N32 - N31) /[cl] STEP3;\n+   zero2 = N22 c2 N21;\n+   count2 = (N22 - N21) /[cl] STEP2;\n+   zero1 = N12 c1 N11;\n+   count1 = (N12 - N11) /[cl] STEP1;\n+   zero = zero3 || zero2 || zero1;\n+   count = count1 * count2 * count3;\n+   if (__builtin_expect(zero, false)) goto zero_iter_bb;\n+\n+   After all, we expect the zero=false, and thus we expect to have to\n+   evaluate all of the comparison expressions, so short-circuiting\n+   oughtn't be a win.  Since the condition isn't protecting a\n+   denominator, we're not concerned about divide-by-zero, so we can\n+   fully evaluate count even if a numerator turned out to be wrong.\n+\n+   It seems like putting this all together would create much better\n+   scheduling opportunities, and less pressure on the chip's branch\n+   predictor.  */\n+\n+static void\n+expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n+\t\t\t    basic_block &entry_bb, tree *counts,\n+\t\t\t    basic_block &zero_iter_bb, int &first_zero_iter,\n+\t\t\t    basic_block &l2_dom_bb)\n+{\n+  tree t, type = TREE_TYPE (fd->loop.v);\n+  gimple stmt;\n+  edge e, ne;\n+  int i;\n+\n+  /* Collapsed loops need work for expansion into SSA form.  */\n+  gcc_assert (!gimple_in_ssa_p (cfun));\n+\n+  for (i = 0; i < fd->collapse; i++)\n+    {\n+      tree itype = TREE_TYPE (fd->loops[i].v);\n+\n+      if (SSA_VAR_P (fd->loop.n2)\n+\t  && ((t = fold_binary (fd->loops[i].cond_code, boolean_type_node,\n+\t\t\t\tfold_convert (itype, fd->loops[i].n1),\n+\t\t\t\tfold_convert (itype, fd->loops[i].n2)))\n+\t      == NULL_TREE || !integer_onep (t)))\n+\t{\n+\t  tree n1, n2;\n+\t  n1 = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n+\t  n1 = force_gimple_operand_gsi (gsi, n1, true, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+\t  n2 = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n+\t  n2 = force_gimple_operand_gsi (gsi, n2, true, NULL_TREE,\n+\t\t\t\t\t true, GSI_SAME_STMT);\n+\t  stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n+\t\t\t\t    NULL_TREE, NULL_TREE);\n+\t  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t  if (walk_tree (gimple_cond_lhs_ptr (stmt),\n+\t\t\t expand_omp_regimplify_p, NULL, NULL)\n+\t      || walk_tree (gimple_cond_rhs_ptr (stmt),\n+\t\t\t    expand_omp_regimplify_p, NULL, NULL))\n+\t    {\n+\t      *gsi = gsi_for_stmt (stmt);\n+\t      gimple_regimplify_operands (stmt, gsi);\n+\t    }\n+\t  e = split_block (entry_bb, stmt);\n+\t  if (zero_iter_bb == NULL)\n+\t    {\n+\t      first_zero_iter = i;\n+\t      zero_iter_bb = create_empty_bb (entry_bb);\n+\t      if (current_loops)\n+\t\tadd_bb_to_loop (zero_iter_bb, entry_bb->loop_father);\n+\t      *gsi = gsi_after_labels (zero_iter_bb);\n+\t      stmt = gimple_build_assign (fd->loop.n2,\n+\t\t\t\t\t  build_zero_cst (type));\n+\t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t      set_immediate_dominator (CDI_DOMINATORS, zero_iter_bb,\n+\t\t\t\t       entry_bb);\n+\t    }\n+\t  ne = make_edge (entry_bb, zero_iter_bb, EDGE_FALSE_VALUE);\n+\t  ne->probability = REG_BR_PROB_BASE / 2000 - 1;\n+\t  e->flags = EDGE_TRUE_VALUE;\n+\t  e->probability = REG_BR_PROB_BASE - ne->probability;\n+\t  if (l2_dom_bb == NULL)\n+\t    l2_dom_bb = entry_bb;\n+\t  entry_bb = e->dest;\n+\t  *gsi = gsi_last_bb (entry_bb);\n+\t}\n+\n+      if (POINTER_TYPE_P (itype))\n+\titype = signed_type_for (itype);\n+      t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n+\t\t\t\t ? -1 : 1));\n+      t = fold_build2 (PLUS_EXPR, itype,\n+\t\t       fold_convert (itype, fd->loops[i].step), t);\n+      t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t       fold_convert (itype, fd->loops[i].n2));\n+      t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t       fold_convert (itype, fd->loops[i].n1));\n+      /* ?? We could probably use CEIL_DIV_EXPR instead of\n+\t TRUNC_DIV_EXPR and adjusting by hand.  Unless we can't\n+\t generate the same code in the end because generically we\n+\t don't know that the values involved must be negative for\n+\t GT??  */\n+      if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t fold_build1 (NEGATE_EXPR, itype,\n+\t\t\t\t      fold_convert (itype,\n+\t\t\t\t\t\t    fd->loops[i].step)));\n+      else\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n+\t\t\t fold_convert (itype, fd->loops[i].step));\n+      t = fold_convert (type, t);\n+      if (TREE_CODE (t) == INTEGER_CST)\n+\tcounts[i] = t;\n+      else\n+\t{\n+\t  counts[i] = create_tmp_reg (type, \".count\");\n+\t  expand_omp_build_assign (gsi, counts[i], t);\n+\t}\n+      if (SSA_VAR_P (fd->loop.n2))\n+\t{\n+\t  if (i == 0)\n+\t    t = counts[0];\n+\t  else\n+\t    t = fold_build2 (MULT_EXPR, type, fd->loop.n2, counts[i]);\n+\t  expand_omp_build_assign (gsi, fd->loop.n2, t);\n+\t}\n+    }\n+}\n+\n+\n+/* Helper function for expand_omp_{for_*,simd}.  Generate code like:\n+\tT = V;\n+\tV3 = N31 + (T % count3) * STEP3;\n+\tT = T / count3;\n+\tV2 = N21 + (T % count2) * STEP2;\n+\tT = T / count2;\n+\tV1 = N11 + T * STEP1;\n+   if this loop doesn't have an inner loop construct combined with it.  */\n+\n+static void\n+expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n+\t\t\t  tree *counts, tree startvar)\n+{\n+  int i;\n+  tree type = TREE_TYPE (fd->loop.v);\n+  tree tem = create_tmp_reg (type, \".tem\");\n+  gimple stmt = gimple_build_assign (tem, startvar);\n+  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+  for (i = fd->collapse - 1; i >= 0; i--)\n+    {\n+      tree vtype = TREE_TYPE (fd->loops[i].v), itype, t;\n+      itype = vtype;\n+      if (POINTER_TYPE_P (vtype))\n+\titype = signed_type_for (vtype);\n+      if (i != 0)\n+\tt = fold_build2 (TRUNC_MOD_EXPR, type, tem, counts[i]);\n+      else\n+\tt = tem;\n+      t = fold_convert (itype, t);\n+      t = fold_build2 (MULT_EXPR, itype, t,\n+\t\t       fold_convert (itype, fd->loops[i].step));\n+      if (POINTER_TYPE_P (vtype))\n+\tt = fold_build_pointer_plus (fd->loops[i].n1, t);\n+      else\n+\tt = fold_build2 (PLUS_EXPR, itype, fd->loops[i].n1, t);\n+      t = force_gimple_operand_gsi (gsi, t,\n+\t\t\t\t    DECL_P (fd->loops[i].v)\n+\t\t\t\t    && TREE_ADDRESSABLE (fd->loops[i].v),\n+\t\t\t\t    NULL_TREE, false,\n+\t\t\t\t    GSI_CONTINUE_LINKING);\n+      stmt = gimple_build_assign (fd->loops[i].v, t);\n+      gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+      if (i != 0)\n+\t{\n+\t  t = fold_build2 (TRUNC_DIV_EXPR, type, tem, counts[i]);\n+\t  t = force_gimple_operand_gsi (gsi, t, false, NULL_TREE,\n+\t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n+\t  stmt = gimple_build_assign (tem, t);\n+\t  gsi_insert_after (gsi, stmt, GSI_CONTINUE_LINKING);\n+\t}\n+    }\n+}\n+\n+\n+/* Helper function for expand_omp_for_*.  Generate code like:\n+    L10:\n+\tV3 += STEP3;\n+\tif (V3 cond3 N32) goto BODY_BB; else goto L11;\n+    L11:\n+\tV3 = N31;\n+\tV2 += STEP2;\n+\tif (V2 cond2 N22) goto BODY_BB; else goto L12;\n+    L12:\n+\tV2 = N21;\n+\tV1 += STEP1;\n+\tgoto BODY_BB;  */\n+\n+static basic_block\n+extract_omp_for_update_vars (struct omp_for_data *fd, basic_block cont_bb,\n+\t\t\t     basic_block body_bb)\n+{\n+  basic_block last_bb, bb, collapse_bb = NULL;\n+  int i;\n+  gimple_stmt_iterator gsi;\n+  edge e;\n+  tree t;\n+  gimple stmt;\n+\n+  last_bb = cont_bb;\n+  for (i = fd->collapse - 1; i >= 0; i--)\n+    {\n+      tree vtype = TREE_TYPE (fd->loops[i].v);\n+\n+      bb = create_empty_bb (last_bb);\n+      if (current_loops)\n+\tadd_bb_to_loop (bb, last_bb->loop_father);\n+      gsi = gsi_start_bb (bb);\n+\n+      if (i < fd->collapse - 1)\n+\t{\n+\t  e = make_edge (last_bb, bb, EDGE_FALSE_VALUE);\n+\t  e->probability = REG_BR_PROB_BASE / 8;\n+\n+\t  t = fd->loops[i + 1].n1;\n+\t  t = force_gimple_operand_gsi (&gsi, t,\n+\t\t\t\t\tDECL_P (fd->loops[i + 1].v)\n+\t\t\t\t\t&& TREE_ADDRESSABLE (fd->loops[i\n+\t\t\t\t\t\t\t\t       + 1].v),\n+\t\t\t\t\tNULL_TREE, false,\n+\t\t\t\t\tGSI_CONTINUE_LINKING);\n+\t  stmt = gimple_build_assign (fd->loops[i + 1].v, t);\n+\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\t}\n+      else\n+\tcollapse_bb = bb;\n+\n+      set_immediate_dominator (CDI_DOMINATORS, bb, last_bb);\n+\n+      if (POINTER_TYPE_P (vtype))\n+\tt = fold_build_pointer_plus (fd->loops[i].v, fd->loops[i].step);\n+      else\n+\tt = fold_build2 (PLUS_EXPR, vtype, fd->loops[i].v, fd->loops[i].step);\n+      t = force_gimple_operand_gsi (&gsi, t,\n+\t\t\t\t    DECL_P (fd->loops[i].v)\n+\t\t\t\t    && TREE_ADDRESSABLE (fd->loops[i].v),\n+\t\t\t\t    NULL_TREE, false, GSI_CONTINUE_LINKING);\n+      stmt = gimple_build_assign (fd->loops[i].v, t);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      if (i > 0)\n+\t{\n+\t  t = fd->loops[i].n2;\n+\t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n+\t  tree v = fd->loops[i].v;\n+\t  if (DECL_P (v) && TREE_ADDRESSABLE (v))\n+\t    v = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n+\t\t\t\t\t  false, GSI_CONTINUE_LINKING);\n+\t  t = fold_build2 (fd->loops[i].cond_code, boolean_type_node, v, t);\n+\t  stmt = gimple_build_cond_empty (t);\n+\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\t  e = make_edge (bb, body_bb, EDGE_TRUE_VALUE);\n+\t  e->probability = REG_BR_PROB_BASE * 7 / 8;\n+\t}\n+      else\n+\tmake_edge (bb, body_bb, EDGE_FALLTHRU);\n+      last_bb = bb;\n+    }\n+\n+  return collapse_bb;\n+}\n+\n+\n /* A subroutine of expand_omp_for.  Generate code for a parallel\n    loop with any schedule.  Given parameters:\n \n@@ -3816,105 +4502,14 @@ expand_omp_for_generic (struct omp_region *region,\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n   if (fd->collapse > 1)\n     {\n-      basic_block zero_iter_bb = NULL;\n       int first_zero_iter = -1;\n+      basic_block zero_iter_bb = NULL, l2_dom_bb = NULL;\n \n-      /* collapsed loops need work for expansion in SSA form.  */\n-      gcc_assert (!gimple_in_ssa_p (cfun));\n-      counts = (tree *) alloca (fd->collapse * sizeof (tree));\n-      for (i = 0; i < fd->collapse; i++)\n-\t{\n-\t  tree itype = TREE_TYPE (fd->loops[i].v);\n+      counts = XALLOCAVEC (tree, fd->collapse);\n+      expand_omp_for_init_counts (fd, &gsi, entry_bb, counts,\n+\t\t\t\t  zero_iter_bb, first_zero_iter,\n+\t\t\t\t  l2_dom_bb);\n \n-\t  if (SSA_VAR_P (fd->loop.n2)\n-\t      && ((t = fold_binary (fd->loops[i].cond_code, boolean_type_node,\n-\t\t\t\t    fold_convert (itype, fd->loops[i].n1),\n-\t\t\t\t    fold_convert (itype, fd->loops[i].n2)))\n-\t\t  == NULL_TREE || !integer_onep (t)))\n-\t    {\n-\t      tree n1, n2;\n-\t      n1 = fold_convert (itype, unshare_expr (fd->loops[i].n1));\n-\t      n1 = force_gimple_operand_gsi (&gsi, n1, true, NULL_TREE,\n-\t\t\t\t\t     true, GSI_SAME_STMT);\n-\t      n2 = fold_convert (itype, unshare_expr (fd->loops[i].n2));\n-\t      n2 = force_gimple_operand_gsi (&gsi, n2, true, NULL_TREE,\n-\t\t\t\t\t     true, GSI_SAME_STMT);\n-\t      stmt = gimple_build_cond (fd->loops[i].cond_code, n1, n2,\n-\t\t\t\t\tNULL_TREE, NULL_TREE);\n-\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t      if (walk_tree (gimple_cond_lhs_ptr (stmt),\n-\t\t\t     expand_omp_regimplify_p, NULL, NULL)\n-\t\t  || walk_tree (gimple_cond_rhs_ptr (stmt),\n-\t\t\t\texpand_omp_regimplify_p, NULL, NULL))\n-\t\t{\n-\t\t  gsi = gsi_for_stmt (stmt);\n-\t\t  gimple_regimplify_operands (stmt, &gsi);\n-\t\t}\n-\t      e = split_block (entry_bb, stmt);\n-\t      if (zero_iter_bb == NULL)\n-\t\t{\n-\t\t  first_zero_iter = i;\n-\t\t  zero_iter_bb = create_empty_bb (entry_bb);\n-\t\t  if (current_loops)\n-\t\t    add_bb_to_loop (zero_iter_bb, entry_bb->loop_father);\n-\t\t  gsi = gsi_after_labels (zero_iter_bb);\n-\t\t  stmt = gimple_build_assign (fd->loop.n2,\n-\t\t\t\t\t      build_zero_cst (type));\n-\t\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t\t  set_immediate_dominator (CDI_DOMINATORS, zero_iter_bb,\n-\t\t\t\t\t   entry_bb);\n-\t\t}\n-\t      ne = make_edge (entry_bb, zero_iter_bb, EDGE_FALSE_VALUE);\n-\t      ne->probability = REG_BR_PROB_BASE / 2000 - 1;\n-\t      e->flags = EDGE_TRUE_VALUE;\n-\t      e->probability = REG_BR_PROB_BASE - ne->probability;\n-\t      entry_bb = e->dest;\n-\t      gsi = gsi_last_bb (entry_bb);\n-\t    }\n-\t  if (POINTER_TYPE_P (itype))\n-\t    itype = signed_type_for (itype);\n-\t  t = build_int_cst (itype, (fd->loops[i].cond_code == LT_EXPR\n-\t\t\t\t     ? -1 : 1));\n-\t  t = fold_build2 (PLUS_EXPR, itype,\n-\t\t\t   fold_convert (itype, fd->loops[i].step), t);\n-\t  t = fold_build2 (PLUS_EXPR, itype, t,\n-\t\t\t   fold_convert (itype, fd->loops[i].n2));\n-\t  t = fold_build2 (MINUS_EXPR, itype, t,\n-\t\t\t   fold_convert (itype, fd->loops[i].n1));\n-\t  if (TYPE_UNSIGNED (itype) && fd->loops[i].cond_code == GT_EXPR)\n-\t    t = fold_build2 (TRUNC_DIV_EXPR, itype,\n-\t\t\t     fold_build1 (NEGATE_EXPR, itype, t),\n-\t\t\t     fold_build1 (NEGATE_EXPR, itype,\n-\t\t\t\t\t  fold_convert (itype,\n-\t\t\t\t\t\t\tfd->loops[i].step)));\n-\t  else\n-\t    t = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n-\t\t\t     fold_convert (itype, fd->loops[i].step));\n-\t  t = fold_convert (type, t);\n-\t  if (TREE_CODE (t) == INTEGER_CST)\n-\t    counts[i] = t;\n-\t  else\n-\t    {\n-\t      counts[i] = create_tmp_reg (type, \".count\");\n-\t      t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE,\n-\t\t\t\t\t    true, GSI_SAME_STMT);\n-\t      stmt = gimple_build_assign (counts[i], t);\n-\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t    }\n-\t  if (SSA_VAR_P (fd->loop.n2))\n-\t    {\n-\t      if (i == 0)\n-\t\tt = counts[0];\n-\t      else\n-\t\t{\n-\t\t  t = fold_build2 (MULT_EXPR, type, fd->loop.n2, counts[i]);\n-\t\t  t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE,\n-\t\t\t\t\t\ttrue, GSI_SAME_STMT);\n-\t\t}\n-\t      stmt = gimple_build_assign (fd->loop.n2, t);\n-\t      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\t    }\n-\t}\n       if (zero_iter_bb)\n \t{\n \t  /* Some counts[i] vars might be uninitialized if\n@@ -3949,18 +4544,21 @@ expand_omp_for_generic (struct omp_region *region,\n       t4 = build_fold_addr_expr (iend0);\n       t3 = build_fold_addr_expr (istart0);\n       t2 = fold_convert (fd->iter_type, fd->loop.step);\n-      if (POINTER_TYPE_P (type)\n-\t  && TYPE_PRECISION (type) != TYPE_PRECISION (fd->iter_type))\n+      t1 = fd->loop.n2;\n+      t0 = fd->loop.n1;\n+      if (POINTER_TYPE_P (TREE_TYPE (t0))\n+\t  && TYPE_PRECISION (TREE_TYPE (t0))\n+\t     != TYPE_PRECISION (fd->iter_type))\n \t{\n \t  /* Avoid casting pointers to integer of a different size.  */\n \t  tree itype = signed_type_for (type);\n-\t  t1 = fold_convert (fd->iter_type, fold_convert (itype, fd->loop.n2));\n-\t  t0 = fold_convert (fd->iter_type, fold_convert (itype, fd->loop.n1));\n+\t  t1 = fold_convert (fd->iter_type, fold_convert (itype, t1));\n+\t  t0 = fold_convert (fd->iter_type, fold_convert (itype, t0));\n \t}\n       else\n \t{\n-\t  t1 = fold_convert (fd->iter_type, fd->loop.n2);\n-\t  t0 = fold_convert (fd->iter_type, fd->loop.n1);\n+\t  t1 = fold_convert (fd->iter_type, t1);\n+\t  t0 = fold_convert (fd->iter_type, t0);\n \t}\n       if (bias)\n \t{\n@@ -4015,64 +4613,38 @@ expand_omp_for_generic (struct omp_region *region,\n   gsi_remove (&gsi, true);\n \n   /* Iteration setup for sequential loop goes in L0_BB.  */\n+  tree startvar = fd->loop.v;\n+  tree endvar = NULL_TREE;\n+\n   gsi = gsi_start_bb (l0_bb);\n   t = istart0;\n   if (bias)\n     t = fold_build2 (MINUS_EXPR, fd->iter_type, t, bias);\n-  if (POINTER_TYPE_P (type))\n-    t = fold_convert (signed_type_for (type), t);\n-  t = fold_convert (type, t);\n+  if (POINTER_TYPE_P (TREE_TYPE (startvar)))\n+    t = fold_convert (signed_type_for (TREE_TYPE (startvar)), t);\n+  t = fold_convert (TREE_TYPE (startvar), t);\n   t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\tDECL_P (fd->loop.v)\n-\t\t\t\t&& TREE_ADDRESSABLE (fd->loop.v),\n+\t\t\t\tDECL_P (startvar)\n+\t\t\t\t&& TREE_ADDRESSABLE (startvar),\n \t\t\t\tNULL_TREE, false, GSI_CONTINUE_LINKING);\n-  stmt = gimple_build_assign (fd->loop.v, t);\n+  stmt = gimple_build_assign (startvar, t);\n   gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n   t = iend0;\n   if (bias)\n     t = fold_build2 (MINUS_EXPR, fd->iter_type, t, bias);\n-  if (POINTER_TYPE_P (type))\n-    t = fold_convert (signed_type_for (type), t);\n-  t = fold_convert (type, t);\n+  if (POINTER_TYPE_P (TREE_TYPE (startvar)))\n+    t = fold_convert (signed_type_for (TREE_TYPE (startvar)), t);\n+  t = fold_convert (TREE_TYPE (startvar), t);\n   iend = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n \t\t\t\t   false, GSI_CONTINUE_LINKING);\n-  if (fd->collapse > 1)\n+  if (endvar)\n     {\n-      tree tem = create_tmp_reg (type, \".tem\");\n-      stmt = gimple_build_assign (tem, fd->loop.v);\n+      stmt = gimple_build_assign (endvar, iend);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-      for (i = fd->collapse - 1; i >= 0; i--)\n-\t{\n-\t  tree vtype = TREE_TYPE (fd->loops[i].v), itype;\n-\t  itype = vtype;\n-\t  if (POINTER_TYPE_P (vtype))\n-\t    itype = signed_type_for (vtype);\n-\t  t = fold_build2 (TRUNC_MOD_EXPR, type, tem, counts[i]);\n-\t  t = fold_convert (itype, t);\n-\t  t = fold_build2 (MULT_EXPR, itype, t,\n-\t\t\t   fold_convert (itype, fd->loops[i].step));\n-\t  if (POINTER_TYPE_P (vtype))\n-\t    t = fold_build_pointer_plus (fd->loops[i].n1, t);\n-\t  else\n-\t    t = fold_build2 (PLUS_EXPR, itype, fd->loops[i].n1, t);\n-\t  t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t\tDECL_P (fd->loops[i].v)\n-\t\t\t\t\t&& TREE_ADDRESSABLE (fd->loops[i].v),\n-\t\t\t\t\tNULL_TREE, false,\n-\t\t\t\t\tGSI_CONTINUE_LINKING);\n-\t  stmt = gimple_build_assign (fd->loops[i].v, t);\n-\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\t  if (i != 0)\n-\t    {\n-\t      t = fold_build2 (TRUNC_DIV_EXPR, type, tem, counts[i]);\n-\t      t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE,\n-\t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n-\t      stmt = gimple_build_assign (tem, t);\n-\t      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\t    }\n-\t}\n     }\n+  if (fd->collapse > 1)\n+    expand_omp_for_init_vars (fd, &gsi, counts, startvar);\n \n   if (!broken_loop)\n     {\n@@ -4084,93 +4656,32 @@ expand_omp_for_generic (struct omp_region *region,\n       vmain = gimple_omp_continue_control_use (stmt);\n       vback = gimple_omp_continue_control_def (stmt);\n \n-      if (POINTER_TYPE_P (type))\n-\tt = fold_build_pointer_plus (vmain, fd->loop.step);\n-      else\n-\tt = fold_build2 (PLUS_EXPR, type, vmain, fd->loop.step);\n-      t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t    DECL_P (vback) && TREE_ADDRESSABLE (vback),\n-\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n-      stmt = gimple_build_assign (vback, t);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\n-      t = build2 (fd->loop.cond_code, boolean_type_node,\n-\t\t  DECL_P (vback) && TREE_ADDRESSABLE (vback) ? t : vback,\n-\t\t  iend);\n-      stmt = gimple_build_cond_empty (t);\n-      gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+      /* OMP4 placeholder: if (!gimple_omp_for_combined_p (fd->for_stmt)).  */\n+      if (1)\n+\t{\n+\t  if (POINTER_TYPE_P (type))\n+\t    t = fold_build_pointer_plus (vmain, fd->loop.step);\n+\t  else\n+\t    t = fold_build2 (PLUS_EXPR, type, vmain, fd->loop.step);\n+\t  t = force_gimple_operand_gsi (&gsi, t,\n+\t\t\t\t\tDECL_P (vback)\n+\t\t\t\t\t&& TREE_ADDRESSABLE (vback),\n+\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n+\t  stmt = gimple_build_assign (vback, t);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\n+\t  t = build2 (fd->loop.cond_code, boolean_type_node,\n+\t\t      DECL_P (vback) && TREE_ADDRESSABLE (vback) ? t : vback,\n+\t\t      iend);\n+\t  stmt = gimple_build_cond_empty (t);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t}\n \n       /* Remove GIMPLE_OMP_CONTINUE.  */\n       gsi_remove (&gsi, true);\n \n       if (fd->collapse > 1)\n-\t{\n-\t  basic_block last_bb, bb;\n-\n-\t  last_bb = cont_bb;\n-\t  for (i = fd->collapse - 1; i >= 0; i--)\n-\t    {\n-\t      tree vtype = TREE_TYPE (fd->loops[i].v);\n-\n-\t      bb = create_empty_bb (last_bb);\n-\t      if (current_loops)\n-\t\tadd_bb_to_loop (bb, last_bb->loop_father);\n-\t      gsi = gsi_start_bb (bb);\n-\n-\t      if (i < fd->collapse - 1)\n-\t\t{\n-\t\t  e = make_edge (last_bb, bb, EDGE_FALSE_VALUE);\n-\t\t  e->probability = REG_BR_PROB_BASE / 8;\n-\n-\t\t  t = fd->loops[i + 1].n1;\n-\t\t  t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t\t\tDECL_P (fd->loops[i + 1].v)\n-\t\t\t\t\t\t&& TREE_ADDRESSABLE\n-\t\t\t\t\t\t\t(fd->loops[i + 1].v),\n-\t\t\t\t\t\tNULL_TREE, false,\n-\t\t\t\t\t\tGSI_CONTINUE_LINKING);\n-\t\t  stmt = gimple_build_assign (fd->loops[i + 1].v, t);\n-\t\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\t\t}\n-\t      else\n-\t\tcollapse_bb = bb;\n-\n-\t      set_immediate_dominator (CDI_DOMINATORS, bb, last_bb);\n-\n-\t      if (POINTER_TYPE_P (vtype))\n-\t\tt = fold_build_pointer_plus (fd->loops[i].v, fd->loops[i].step);\n-\t      else\n-\t\tt = fold_build2 (PLUS_EXPR, vtype, fd->loops[i].v,\n-\t\t\t\t fd->loops[i].step);\n-\t      t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\t\t    DECL_P (fd->loops[i].v)\n-\t\t\t\t\t    && TREE_ADDRESSABLE (fd->loops[i].v),\n-\t\t\t\t\t    NULL_TREE, false,\n-\t\t\t\t\t    GSI_CONTINUE_LINKING);\n-\t      stmt = gimple_build_assign (fd->loops[i].v, t);\n-\t      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\n-\t      if (i > 0)\n-\t\t{\n-\t\t  t = fd->loops[i].n2;\n-\t\t  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n-\t\t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n-\t\t  tree v = fd->loops[i].v;\n-\t\t  if (DECL_P (v) && TREE_ADDRESSABLE (v))\n-\t\t    v = force_gimple_operand_gsi (&gsi, v, true, NULL_TREE,\n-\t\t\t\t\t\t  false, GSI_CONTINUE_LINKING);\n-\t\t  t = fold_build2 (fd->loops[i].cond_code, boolean_type_node,\n-\t\t\t\t   v, t);\n-\t\t  stmt = gimple_build_cond_empty (t);\n-\t\t  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n-\t\t  e = make_edge (bb, l1_bb, EDGE_TRUE_VALUE);\n-\t\t  e->probability = REG_BR_PROB_BASE * 7 / 8;\n-\t\t}\n-\t      else\n-\t\tmake_edge (bb, l1_bb, EDGE_FALLTHRU);\n-\t      last_bb = bb;\n-\t    }\n-\t}\n+\tcollapse_bb = extract_omp_for_update_vars (fd, cont_bb, l1_bb);\n \n       /* Emit code to get the next parallel iteration in L2_BB.  */\n       gsi = gsi_start_bb (l2_bb);\n@@ -4220,19 +4731,27 @@ expand_omp_for_generic (struct omp_region *region,\n       make_edge (cont_bb, l2_bb, EDGE_FALSE_VALUE);\n       if (current_loops)\n \tadd_bb_to_loop (l2_bb, cont_bb->loop_father);\n-      if (fd->collapse > 1)\n+      e = find_edge (cont_bb, l1_bb);\n+      /* OMP4 placeholder for gimple_omp_for_combined_p (fd->for_stmt).  */\n+      if (0)\n+\t;\n+      else if (fd->collapse > 1)\n \t{\n-\t  e = find_edge (cont_bb, l1_bb);\n \t  remove_edge (e);\n \t  e = make_edge (cont_bb, collapse_bb, EDGE_TRUE_VALUE);\n \t}\n       else\n+\te->flags = EDGE_TRUE_VALUE;\n+      if (e)\n \t{\n-\t  e = find_edge (cont_bb, l1_bb);\n-\t  e->flags = EDGE_TRUE_VALUE;\n+\t  e->probability = REG_BR_PROB_BASE * 7 / 8;\n+\t  find_edge (cont_bb, l2_bb)->probability = REG_BR_PROB_BASE / 8;\n+\t}\n+      else\n+\t{\n+\t  e = find_edge (cont_bb, l2_bb);\n+\t  e->flags = EDGE_FALLTHRU;\n \t}\n-      e->probability = REG_BR_PROB_BASE * 7 / 8;\n-      find_edge (cont_bb, l2_bb)->probability = REG_BR_PROB_BASE / 8;\n       make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n \n       set_immediate_dominator (CDI_DOMINATORS, l2_bb,\n@@ -4249,10 +4768,14 @@ expand_omp_for_generic (struct omp_region *region,\n       outer_loop->latch = l2_bb;\n       add_loop (outer_loop, l0_bb->loop_father);\n \n-      struct loop *loop = alloc_loop ();\n-      loop->header = l1_bb;\n-      /* The loop may have multiple latches.  */\n-      add_loop (loop, outer_loop);\n+      /* OMP4 placeholder: if (!gimple_omp_for_combined_p (fd->for_stmt)).  */\n+      if (1)\n+\t{\n+\t  struct loop *loop = alloc_loop ();\n+\t  loop->header = l1_bb;\n+\t  /* The loop may have multiple latches.  */\n+\t  add_loop (loop, outer_loop);\n+\t}\n     }\n }\n \n@@ -4883,6 +5406,295 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   add_loop (loop, trip_loop);\n }\n \n+/* A subroutine of expand_omp_for.  Generate code for a simd non-worksharing\n+   loop.  Given parameters:\n+\n+\tfor (V = N1; V cond N2; V += STEP) BODY;\n+\n+   where COND is \"<\" or \">\", we generate pseudocode\n+\n+\tV = N1;\n+\tgoto L1;\n+    L0:\n+\tBODY;\n+\tV += STEP;\n+    L1:\n+\tif (V cond N2) goto L0; else goto L2;\n+    L2:\n+\n+    For collapsed loops, given parameters:\n+      collapse(3)\n+      for (V1 = N11; V1 cond1 N12; V1 += STEP1)\n+\tfor (V2 = N21; V2 cond2 N22; V2 += STEP2)\n+\t  for (V3 = N31; V3 cond3 N32; V3 += STEP3)\n+\t    BODY;\n+\n+    we generate pseudocode\n+\n+\tif (cond3 is <)\n+\t  adj = STEP3 - 1;\n+\telse\n+\t  adj = STEP3 + 1;\n+\tcount3 = (adj + N32 - N31) / STEP3;\n+\tif (cond2 is <)\n+\t  adj = STEP2 - 1;\n+\telse\n+\t  adj = STEP2 + 1;\n+\tcount2 = (adj + N22 - N21) / STEP2;\n+\tif (cond1 is <)\n+\t  adj = STEP1 - 1;\n+\telse\n+\t  adj = STEP1 + 1;\n+\tcount1 = (adj + N12 - N11) / STEP1;\n+\tcount = count1 * count2 * count3;\n+\tV = 0;\n+\tV1 = N11;\n+\tV2 = N21;\n+\tV3 = N31;\n+\tgoto L1;\n+    L0:\n+\tBODY;\n+\tV += 1;\n+\tV3 += STEP3;\n+\tV2 += (V3 cond3 N32) ? 0 : STEP2;\n+\tV3 = (V3 cond3 N32) ? V3 : N31;\n+\tV1 += (V2 cond2 N22) ? 0 : STEP1;\n+\tV2 = (V2 cond2 N22) ? V2 : N21;\n+    L1:\n+\tif (V < count) goto L0; else goto L2;\n+    L2:\n+\n+      */\n+\n+static void\n+expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n+{\n+  tree type, t;\n+  basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb, l2_bb, l2_dom_bb;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  bool broken_loop = region->cont == NULL;\n+  edge e, ne;\n+  tree *counts = NULL;\n+  int i;\n+  tree safelen = find_omp_clause (gimple_omp_for_clauses (fd->for_stmt),\n+\t\t\t\t  OMP_CLAUSE_SAFELEN);\n+  tree simduid = find_omp_clause (gimple_omp_for_clauses (fd->for_stmt),\n+\t\t\t\t  OMP_CLAUSE__SIMDUID_);\n+  tree n2;\n+\n+  type = TREE_TYPE (fd->loop.v);\n+  entry_bb = region->entry;\n+  cont_bb = region->cont;\n+  gcc_assert (EDGE_COUNT (entry_bb->succs) == 2);\n+  gcc_assert (broken_loop\n+\t      || BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n+  l0_bb = FALLTHRU_EDGE (entry_bb)->dest;\n+  if (!broken_loop)\n+    {\n+      gcc_assert (BRANCH_EDGE (cont_bb)->dest == l0_bb);\n+      gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n+      l1_bb = split_block (cont_bb, last_stmt (cont_bb))->dest;\n+      l2_bb = BRANCH_EDGE (entry_bb)->dest;\n+    }\n+  else\n+    {\n+      BRANCH_EDGE (entry_bb)->flags &= ~EDGE_ABNORMAL;\n+      l1_bb = split_edge (BRANCH_EDGE (entry_bb));\n+      l2_bb = single_succ (l1_bb);\n+    }\n+  exit_bb = region->exit;\n+  l2_dom_bb = NULL;\n+\n+  gsi = gsi_last_bb (entry_bb);\n+\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+  /* Not needed in SSA form right now.  */\n+  gcc_assert (!gimple_in_ssa_p (cfun));\n+  if (fd->collapse > 1)\n+    {\n+      int first_zero_iter = -1;\n+      basic_block zero_iter_bb = l2_bb;\n+\n+      counts = XALLOCAVEC (tree, fd->collapse);\n+      expand_omp_for_init_counts (fd, &gsi, entry_bb, counts,\n+\t\t\t\t  zero_iter_bb, first_zero_iter,\n+\t\t\t\t  l2_dom_bb);\n+    }\n+  if (l2_dom_bb == NULL)\n+    l2_dom_bb = l1_bb;\n+\n+  n2 = fd->loop.n2;\n+  if (0)\n+    /* Place holder for gimple_omp_for_combined_into_p() in\n+       the upcoming gomp-4_0-branch merge.  */;\n+  else\n+    {\n+      expand_omp_build_assign (&gsi, fd->loop.v,\n+\t\t\t       fold_convert (type, fd->loop.n1));\n+      if (fd->collapse > 1)\n+\tfor (i = 0; i < fd->collapse; i++)\n+\t  {\n+\t    tree itype = TREE_TYPE (fd->loops[i].v);\n+\t    if (POINTER_TYPE_P (itype))\n+\t      itype = signed_type_for (itype);\n+\t    t = fold_convert (TREE_TYPE (fd->loops[i].v), fd->loops[i].n1);\n+\t    expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n+\t  }\n+      }\n+\n+  /* Remove the GIMPLE_OMP_FOR statement.  */\n+  gsi_remove (&gsi, true);\n+\n+  if (!broken_loop)\n+    {\n+      /* Code to control the increment goes in the CONT_BB.  */\n+      gsi = gsi_last_bb (cont_bb);\n+      stmt = gsi_stmt (gsi);\n+      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n+\n+      if (POINTER_TYPE_P (type))\n+\tt = fold_build_pointer_plus (fd->loop.v, fd->loop.step);\n+      else\n+\tt = fold_build2 (PLUS_EXPR, type, fd->loop.v, fd->loop.step);\n+      expand_omp_build_assign (&gsi, fd->loop.v, t);\n+\n+      if (fd->collapse > 1)\n+\t{\n+\t  i = fd->collapse - 1;\n+\t  if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i].v)))\n+\t    {\n+\t      t = fold_convert (sizetype, fd->loops[i].step);\n+\t      t = fold_build_pointer_plus (fd->loops[i].v, t);\n+\t    }\n+\t  else\n+\t    {\n+\t      t = fold_convert (TREE_TYPE (fd->loops[i].v),\n+\t\t\t\tfd->loops[i].step);\n+\t      t = fold_build2 (PLUS_EXPR, TREE_TYPE (fd->loops[i].v),\n+\t\t\t       fd->loops[i].v, t);\n+\t    }\n+\t  expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n+\n+\t  for (i = fd->collapse - 1; i > 0; i--)\n+\t    {\n+\t      tree itype = TREE_TYPE (fd->loops[i].v);\n+\t      tree itype2 = TREE_TYPE (fd->loops[i - 1].v);\n+\t      if (POINTER_TYPE_P (itype2))\n+\t\titype2 = signed_type_for (itype2);\n+\t      t = build3 (COND_EXPR, itype2,\n+\t\t\t  build2 (fd->loops[i].cond_code, boolean_type_node,\n+\t\t\t\t  fd->loops[i].v,\n+\t\t\t\t  fold_convert (itype, fd->loops[i].n2)),\n+\t\t\t  build_int_cst (itype2, 0),\n+\t\t\t  fold_convert (itype2, fd->loops[i - 1].step));\n+\t      if (POINTER_TYPE_P (TREE_TYPE (fd->loops[i - 1].v)))\n+\t\tt = fold_build_pointer_plus (fd->loops[i - 1].v, t);\n+\t      else\n+\t\tt = fold_build2 (PLUS_EXPR, itype2, fd->loops[i - 1].v, t);\n+\t      expand_omp_build_assign (&gsi, fd->loops[i - 1].v, t);\n+\n+\t      t = build3 (COND_EXPR, itype,\n+\t\t\t  build2 (fd->loops[i].cond_code, boolean_type_node,\n+\t\t\t\t  fd->loops[i].v,\n+\t\t\t\t  fold_convert (itype, fd->loops[i].n2)),\n+\t\t\t  fd->loops[i].v,\n+\t\t\t  fold_convert (itype, fd->loops[i].n1));\n+\t      expand_omp_build_assign (&gsi, fd->loops[i].v, t);\n+\t    }\n+\t}\n+\n+      /* Remove GIMPLE_OMP_CONTINUE.  */\n+      gsi_remove (&gsi, true);\n+    }\n+\n+  /* Emit the condition in L1_BB.  */\n+  gsi = gsi_start_bb (l1_bb);\n+\n+  t = fold_convert (type, n2);\n+  t = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n+  t = build2 (fd->loop.cond_code, boolean_type_node, fd->loop.v, t);\n+  stmt = gimple_build_cond_empty (t);\n+  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+  if (walk_tree (gimple_cond_lhs_ptr (stmt), expand_omp_regimplify_p,\n+\t\t NULL, NULL)\n+      || walk_tree (gimple_cond_rhs_ptr (stmt), expand_omp_regimplify_p,\n+\t\t    NULL, NULL))\n+    {\n+      gsi = gsi_for_stmt (stmt);\n+      gimple_regimplify_operands (stmt, &gsi);\n+    }\n+\n+  /* Remove GIMPLE_OMP_RETURN.  */\n+  gsi = gsi_last_bb (exit_bb);\n+  gsi_remove (&gsi, true);\n+\n+  /* Connect the new blocks.  */\n+  remove_edge (FALLTHRU_EDGE (entry_bb));\n+\n+  if (!broken_loop)\n+    {\n+      remove_edge (BRANCH_EDGE (entry_bb));\n+      make_edge (entry_bb, l1_bb, EDGE_FALLTHRU);\n+\n+      e = BRANCH_EDGE (l1_bb);\n+      ne = FALLTHRU_EDGE (l1_bb);\n+      e->flags = EDGE_TRUE_VALUE;\n+    }\n+  else\n+    {\n+      single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n+\n+      ne = single_succ_edge (l1_bb);\n+      e = make_edge (l1_bb, l0_bb, EDGE_TRUE_VALUE);\n+\n+    }\n+  ne->flags = EDGE_FALSE_VALUE;\n+  e->probability = REG_BR_PROB_BASE * 7 / 8;\n+  ne->probability = REG_BR_PROB_BASE / 8;\n+\n+  set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, l0_bb, l1_bb);\n+\n+  if (!broken_loop)\n+    {\n+      struct loop *loop = alloc_loop ();\n+      loop->header = l1_bb;\n+      loop->latch = e->dest;\n+      add_loop (loop, l1_bb->loop_father);\n+      if (safelen == NULL_TREE)\n+\tloop->safelen = INT_MAX;\n+      else\n+\t{\n+\t  safelen = OMP_CLAUSE_SAFELEN_EXPR (safelen);\n+\t  if (!host_integerp (safelen, 1)\n+\t      || (unsigned HOST_WIDE_INT) tree_low_cst (safelen, 1)\n+\t\t > INT_MAX)\n+\t    loop->safelen = INT_MAX;\n+\t  else\n+\t    loop->safelen = tree_low_cst (safelen, 1);\n+\t  if (loop->safelen == 1)\n+\t    loop->safelen = 0;\n+\t}\n+      if (simduid)\n+\t{\n+\t  loop->simduid = OMP_CLAUSE__SIMDUID__DECL (simduid);\n+\t  cfun->has_simduid_loops = true;\n+\t}\n+      /* If not -fno-tree-vectorize, hint that we want to vectorize\n+\t the loop.  */\n+      if ((flag_tree_vectorize\n+\t   || !global_options_set.x_flag_tree_vectorize)\n+\t  && loop->safelen > 1)\n+\t{\n+\t  loop->force_vect = true;\n+\t  cfun->has_force_vect_loops = true;\n+\t}\n+    }\n+}\n+\n \n /* Expand the OpenMP loop defined by REGION.  */\n \n@@ -4914,7 +5726,9 @@ expand_omp_for (struct omp_region *region)\n        original loops from being detected.  Fix that up.  */\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n-  if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n+  if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_SIMD)\n+    expand_omp_simd (region, &fd);\n+  else if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n       && !fd.have_ordered\n       && fd.collapse == 1\n       && region->cont != NULL)\n@@ -4928,6 +5742,8 @@ expand_omp_for (struct omp_region *region)\n     {\n       int fn_index, start_ix, next_ix;\n \n+      gcc_assert (gimple_omp_for_kind (fd.for_stmt)\n+\t\t  == GF_OMP_FOR_KIND_FOR);\n       if (fd.chunk_size == NULL\n \t  && fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC)\n \tfd.chunk_size = integer_zero_node;\n@@ -6534,6 +7350,8 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \t  && host_integerp (fd->loop.n2, 0)\n \t  && ! integer_zerop (fd->loop.n2))\n \tvinit = build_int_cst (TREE_TYPE (fd->loop.v), 0);\n+      else\n+\tvinit = unshare_expr (vinit);\n \n       /* Initialize the iterator variable, so that threads that don't execute\n \t any iterations don't execute the lastprivate clauses by accident.  */\n@@ -6557,7 +7375,6 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   push_gimplify_context (&gctx);\n \n   lower_omp (gimple_omp_for_pre_body_ptr (stmt), ctx);\n-  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n   block = make_node (BLOCK);\n   new_stmt = gimple_build_bind (NULL, NULL, block);\n@@ -6582,6 +7399,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   lower_rec_input_clauses (gimple_omp_for_clauses (stmt), &body, &dlist, ctx);\n   gimple_seq_add_seq (&body, gimple_omp_for_pre_body (stmt));\n \n+  lower_omp (gimple_omp_body_ptr (stmt), ctx);\n+\n   /* Lower the header expressions.  At this point, we can assume that\n      the header is of the form:\n "}, {"sha": "5bd7719516b335b408b16ef166640c8be0886646", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -4331,10 +4331,25 @@ get_references_in_stmt (gimple stmt, vec<data_ref_loc, va_stack> *references)\n   /* ASM_EXPR and CALL_EXPR may embed arbitrary side effects.\n      As we cannot model data-references to not spelled out\n      accesses give up if they may occur.  */\n-  if ((stmt_code == GIMPLE_CALL\n-       && !(gimple_call_flags (stmt) & ECF_CONST))\n-      || (stmt_code == GIMPLE_ASM\n-\t  && (gimple_asm_volatile_p (stmt) || gimple_vuse (stmt))))\n+  if (stmt_code == GIMPLE_CALL\n+      && !(gimple_call_flags (stmt) & ECF_CONST))\n+    {\n+      /* Allow IFN_GOMP_SIMD_LANE in their own loops.  */\n+      if (gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n+\t{\n+\t  struct loop *loop = gimple_bb (stmt)->loop_father;\n+\t  tree uid = gimple_call_arg (stmt, 0);\n+\t  gcc_assert (TREE_CODE (uid) == SSA_NAME);\n+\t  if (loop == NULL\n+\t      || loop->simduid != SSA_NAME_VAR (uid))\n+\t    clobbers_memory = true;\n+\t}\n+      else\n+\tclobbers_memory = true;\n+    }\n+  else if (stmt_code == GIMPLE_ASM\n+\t   && (gimple_asm_volatile_p (stmt) || gimple_vuse (stmt)))\n     clobbers_memory = true;\n \n   if (!gimple_vuse (stmt))"}, {"sha": "ab42470f19af613c70e15459281191f14aa5eee7", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -344,7 +344,6 @@ extern struct omp_region *new_omp_region (basic_block, enum gimple_code,\n \t\t\t\t\t  struct omp_region *);\n extern void free_omp_regions (void);\n void omp_expand_local (basic_block);\n-extern tree find_omp_clause (tree, enum omp_clause_code);\n tree copy_var_decl (tree, tree, tree);\n \n /*---------------------------------------------------------------------------"}, {"sha": "3ef356a0ac7dd976c4a6211f688742e0a76f33db", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1787,6 +1787,10 @@ main_tree_if_conversion (void)\n     return 0;\n \n   FOR_EACH_LOOP (li, loop, 0)\n+    if (flag_tree_loop_if_convert == 1\n+\t|| flag_tree_loop_if_convert_stores == 1\n+\t|| flag_tree_vectorize\n+\t|| loop->force_vect)\n     changed |= tree_if_conversion (loop);\n \n   if (changed)\n@@ -1811,7 +1815,8 @@ main_tree_if_conversion (void)\n static bool\n gate_tree_if_conversion (void)\n {\n-  return ((flag_tree_vectorize && flag_tree_loop_if_convert != 0)\n+  return (((flag_tree_vectorize || cfun->has_force_vect_loops)\n+\t   && flag_tree_loop_if_convert != 0)\n \t  || flag_tree_loop_if_convert == 1\n \t  || flag_tree_loop_if_convert_stores == 1);\n }"}, {"sha": "af26c85150d2984e1172e9a760d6927c77faf8a1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1298,7 +1298,8 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \tcase GIMPLE_OMP_FOR:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n \t  s2 = remap_gimple_seq (gimple_omp_for_pre_body (stmt), id);\n-\t  copy = gimple_build_omp_for (s1, gimple_omp_for_clauses (stmt),\n+\t  copy = gimple_build_omp_for (s1, gimple_omp_for_kind (stmt),\n+\t\t\t\t       gimple_omp_for_clauses (stmt),\n \t\t\t\t       gimple_omp_for_collapse (stmt), s2);\n \t  {\n \t    size_t i;\n@@ -2399,6 +2400,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \t\t  get_loop (src_cfun, 0));\n       /* Defer to cfgcleanup to update loop-father fields of basic-blocks.  */\n       loops_state_set (LOOPS_NEED_FIXUP);\n+      cfun->has_force_vect_loops |= src_cfun->has_force_vect_loops;\n+      cfun->has_simduid_loops |= src_cfun->has_simduid_loops;\n     }\n \n   /* If the loop tree in the source function needed fixup, mark the"}, {"sha": "9d413c7fb422a1ef309abf6c7dfddec0f4672e2a", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1695,7 +1695,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   t = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n   OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n \n-  for_stmt = gimple_build_omp_for (NULL, t, 1, NULL);\n+  for_stmt = gimple_build_omp_for (NULL, GF_OMP_FOR_KIND_FOR, t, 1, NULL);\n   gimple_set_location (for_stmt, loc);\n   gimple_omp_for_set_index (for_stmt, 0, initvar);\n   gimple_omp_for_set_initial (for_stmt, 0, cvar_init);"}, {"sha": "69e400607271d459f6f5769492be13d9d76cb985", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -316,11 +316,14 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n     case OMP_CLAUSE_COPYPRIVATE:\n       name = \"copyprivate\";\n       goto print_remap;\n+    case OMP_CLAUSE_UNIFORM:\n+      name = \"uniform\";\n+      goto print_remap;\n   print_remap:\n       pp_string (buffer, name);\n       pp_left_paren (buffer);\n       dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n-\t  spc, flags, false);\n+\t\t\t spc, flags, false);\n       pp_right_paren (buffer);\n       break;\n \n@@ -433,6 +436,30 @@ dump_omp_clause (pretty_printer *buffer, tree clause, int spc, int flags)\n       pp_string (buffer, \"mergeable\");\n       break;\n \n+    case OMP_CLAUSE_LINEAR:\n+      pp_string (buffer, \"linear(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      pp_character (buffer, ':');\n+      dump_generic_node (buffer, OMP_CLAUSE_LINEAR_STEP (clause),\n+\t\t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+      break;\n+\n+    case OMP_CLAUSE_SAFELEN:\n+      pp_string (buffer, \"safelen(\");\n+      dump_generic_node (buffer, OMP_CLAUSE_SAFELEN_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+      break;\n+\n+    case OMP_CLAUSE__SIMDUID_:\n+      pp_string (buffer, \"_simduid_(\");\n+      dump_generic_node (buffer, OMP_CLAUSE__SIMDUID__DECL (clause),\n+\t\t\t spc, flags, false);\n+      pp_character (buffer, ')');\n+      break;\n+\n     default:\n       /* Should never happen.  */\n       dump_generic_node (buffer, clause, spc, flags, false);\n@@ -2179,6 +2206,13 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case OMP_FOR:\n       pp_string (buffer, \"#pragma omp for\");\n+      goto dump_omp_loop;\n+\n+    case OMP_SIMD:\n+      pp_string (buffer, \"#pragma omp simd\");\n+      goto dump_omp_loop;\n+\n+    dump_omp_loop:\n       dump_omp_clauses (buffer, OMP_FOR_CLAUSES (node), spc, flags);\n \n       if (!(flags & TDF_SLIM))"}, {"sha": "3ba321d61815cf5c1ece37092668ab49794a6a54", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -631,6 +631,22 @@ likely_value (gimple stmt)\n   if (has_constant_operand)\n     all_undefined_operands = false;\n \n+  if (has_undefined_operand\n+      && code == GIMPLE_CALL\n+      && gimple_call_internal_p (stmt))\n+    switch (gimple_call_internal_fn (stmt))\n+      {\n+\t/* These 3 builtins use the first argument just as a magic\n+\t   way how to find out a decl uid.  */\n+      case IFN_GOMP_SIMD_LANE:\n+      case IFN_GOMP_SIMD_VF:\n+      case IFN_GOMP_SIMD_LAST_LANE:\n+\thas_undefined_operand = false;\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n   /* If the operation combines operands like COMPLEX_EXPR make sure to\n      not mark the result UNDEFINED if only one part of the result is\n      undefined.  */"}, {"sha": "64abb0d059cb4edc19520f2040d0102b4c2706fe", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1125,6 +1125,11 @@ tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n   if (changed)\n     return true;\n \n+  /* Don't unroll #pragma omp simd loops until the vectorizer\n+     attempts to vectorize those.  */\n+  if (loop->force_vect)\n+    return false;\n+\n   /* Try to unroll this loop.  */\n   loop_father = loop_outer (loop);\n   if (!loop_father)"}, {"sha": "8bcfd060e60550552ed6972b23876126528c84ff", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -314,7 +314,7 @@ tree_vectorize (void)\n static bool\n gate_tree_vectorize (void)\n {\n-  return flag_tree_vectorize;\n+  return flag_tree_vectorize || cfun->has_force_vect_loops;\n }\n \n namespace {"}, {"sha": "3f375109df73112720430690cf5e8d9c6b952f09", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 89, "deletions": 15, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -255,6 +255,15 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   /* Unknown data dependence.  */\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n+      /* If user asserted safelen consecutive iterations can be\n+\t executed concurrently, assume independence.  */\n+      if (loop->safelen >= 2)\n+\t{\n+\t  if (loop->safelen < *max_vf)\n+\t    *max_vf = loop->safelen;\n+\t  return false;\n+\t}\n+\n       if (STMT_VINFO_GATHER_P (stmtinfo_a)\n \t  || STMT_VINFO_GATHER_P (stmtinfo_b))\n \t{\n@@ -291,6 +300,15 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   /* Known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n+      /* If user asserted safelen consecutive iterations can be\n+\t executed concurrently, assume independence.  */\n+      if (loop->safelen >= 2)\n+\t{\n+\t  if (loop->safelen < *max_vf)\n+\t    *max_vf = loop->safelen;\n+\t  return false;\n+\t}\n+\n       if (STMT_VINFO_GATHER_P (stmtinfo_a)\n \t  || STMT_VINFO_GATHER_P (stmtinfo_b))\n \t{\n@@ -2930,6 +2948,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       stmt_vec_info stmt_info;\n       tree base, offset, init;\n       bool gather = false;\n+      bool simd_lane_access = false;\n       int vf;\n \n again:\n@@ -2961,12 +2980,17 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n \t  || !DR_STEP (dr))\n         {\n-\t  /* If target supports vector gather loads, see if they can't\n-\t     be used.  */\n-\t  if (loop_vinfo\n-\t      && DR_IS_READ (dr)\n+\t  bool maybe_gather\n+\t    = DR_IS_READ (dr)\n \t      && !TREE_THIS_VOLATILE (DR_REF (dr))\n-\t      && targetm.vectorize.builtin_gather != NULL\n+\t      && targetm.vectorize.builtin_gather != NULL;\n+\t  bool maybe_simd_lane_access\n+\t    = loop_vinfo && loop->simduid;\n+\n+\t  /* If target supports vector gather loads, or if this might be\n+\t     a SIMD lane access, see if they can't be used.  */\n+\t  if (loop_vinfo\n+\t      && (maybe_gather || maybe_simd_lane_access)\n \t      && !nested_in_vect_loop_p (loop, stmt))\n \t    {\n \t      struct data_reference *newdr\n@@ -2979,14 +3003,59 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t  && DR_STEP (newdr)\n \t\t  && integer_zerop (DR_STEP (newdr)))\n \t\t{\n-\t\t  dr = newdr;\n-\t\t  gather = true;\n+\t\t  if (maybe_simd_lane_access)\n+\t\t    {\n+\t\t      tree off = DR_OFFSET (newdr);\n+\t\t      STRIP_NOPS (off);\n+\t\t      if (TREE_CODE (DR_INIT (newdr)) == INTEGER_CST\n+\t\t\t  && TREE_CODE (off) == MULT_EXPR\n+\t\t\t  && host_integerp (TREE_OPERAND (off, 1), 1))\n+\t\t\t{\n+\t\t\t  tree step = TREE_OPERAND (off, 1);\n+\t\t\t  off = TREE_OPERAND (off, 0);\n+\t\t\t  STRIP_NOPS (off);\n+\t\t\t  if (CONVERT_EXPR_P (off)\n+\t\t\t      && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (off,\n+\t\t\t\t\t\t\t\t\t  0)))\n+\t\t\t\t < TYPE_PRECISION (TREE_TYPE (off)))\n+\t\t\t    off = TREE_OPERAND (off, 0);\n+\t\t\t  if (TREE_CODE (off) == SSA_NAME)\n+\t\t\t    {\n+\t\t\t      gimple def = SSA_NAME_DEF_STMT (off);\n+\t\t\t      tree reft = TREE_TYPE (DR_REF (newdr));\n+\t\t\t      if (gimple_call_internal_p (def)\n+\t\t\t\t  && gimple_call_internal_fn (def)\n+\t\t\t\t  == IFN_GOMP_SIMD_LANE)\n+\t\t\t\t{\n+\t\t\t\t  tree arg = gimple_call_arg (def, 0);\n+\t\t\t\t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n+\t\t\t\t  arg = SSA_NAME_VAR (arg);\n+\t\t\t\t  if (arg == loop->simduid\n+\t\t\t\t      /* For now.  */\n+\t\t\t\t      && tree_int_cst_equal\n+\t\t\t\t\t   (TYPE_SIZE_UNIT (reft),\n+\t\t\t\t\t    step))\n+\t\t\t\t    {\n+\t\t\t\t      DR_OFFSET (newdr) = ssize_int (0);\n+\t\t\t\t      DR_STEP (newdr) = step;\n+\t\t\t\t      dr = newdr;\n+\t\t\t\t      simd_lane_access = true;\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (!simd_lane_access && maybe_gather)\n+\t\t    {\n+\t\t      dr = newdr;\n+\t\t      gather = true;\n+\t\t    }\n \t\t}\n-\t      else\n+\t      if (!gather && !simd_lane_access)\n \t\tfree_data_ref (newdr);\n \t    }\n \n-\t  if (!gather)\n+\t  if (!gather && !simd_lane_access)\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -3013,7 +3082,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    free_data_ref (dr);\n \t  return false;\n         }\n@@ -3046,7 +3115,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n         }\n@@ -3065,7 +3134,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n \t}\n@@ -3086,7 +3155,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    free_data_ref (dr);\n \t  return false;\n \t}\n@@ -3221,12 +3290,17 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    free_data_ref (dr);\n           return false;\n         }\n \n       STMT_VINFO_DATA_REF (stmt_info) = dr;\n+      if (simd_lane_access)\n+\t{\n+\t  STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info) = true;\n+\t  datarefs[i] = dr;\n+\t}\n \n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n@@ -3247,7 +3321,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (bb_vinfo)\n \t    break;\n \n-\t  if (gather)\n+\t  if (gather || simd_lane_access)\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n \t      free_data_ref (dr);"}, {"sha": "3e1cbb19bfd6e9eaac4bf2343a988abec1297d6e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -5378,7 +5378,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n bool\n vectorizable_live_operation (gimple stmt,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\t     gimple *vec_stmt ATTRIBUTE_UNUSED)\n+\t\t\t     gimple *vec_stmt)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -5398,7 +5398,41 @@ vectorizable_live_operation (gimple stmt,\n     return false;\n \n   if (!is_gimple_assign (stmt))\n-    return false;\n+    {\n+      if (gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n+\t  && gimple_call_lhs (stmt)\n+\t  && loop->simduid\n+\t  && TREE_CODE (gimple_call_arg (stmt, 0)) == SSA_NAME\n+\t  && loop->simduid\n+\t     == SSA_NAME_VAR (gimple_call_arg (stmt, 0)))\n+\t{\n+\t  edge e = single_exit (loop);\n+\t  basic_block merge_bb = e->dest;\n+\t  imm_use_iterator imm_iter;\n+\t  use_operand_p use_p;\n+\t  tree lhs = gimple_call_lhs (stmt);\n+\n+\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n+\t    {\n+\t      gimple use_stmt = USE_STMT (use_p);\n+\t      if (gimple_code (use_stmt) == GIMPLE_PHI\n+\t\t  || gimple_bb (use_stmt) == merge_bb)\n+\t\t{\n+\t\t  if (vec_stmt)\n+\t\t    {\n+\t\t      tree vfm1\n+\t\t\t= build_int_cst (unsigned_type_node,\n+\t\t\t\t\t loop_vinfo->vectorization_factor - 1);\n+\t\t      SET_PHI_ARG_DEF (use_stmt, e->dest_idx, vfm1);\n+\t\t    }\n+\t\t  return true;\n+\t\t}\n+\t    }\n+\t}\n+\n+      return false;\n+    }\n \n   if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n     return false;"}, {"sha": "3768dcd114bc0fbf61226d1672df4d5ef5bb8e5a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 121, "deletions": 24, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1755,6 +1755,14 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (nargs == 0 || nargs > 3)\n     return false;\n \n+  /* Ignore the argument of IFN_GOMP_SIMD_LANE, it is magic.  */\n+  if (gimple_call_internal_p (stmt)\n+      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n+    {\n+      nargs = 0;\n+      rhs_type = unsigned_type_node;\n+    }\n+\n   for (i = 0; i < nargs; i++)\n     {\n       tree opvectype;\n@@ -1830,11 +1838,26 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   fndecl = vectorizable_function (stmt, vectype_out, vectype_in);\n   if (fndecl == NULL_TREE)\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"function is not vectorizable.\");\n-\n-      return false;\n+      if (gimple_call_internal_p (stmt)\n+\t  && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n+\t  && !slp_node\n+\t  && loop_vinfo\n+\t  && LOOP_VINFO_LOOP (loop_vinfo)->simduid\n+\t  && TREE_CODE (gimple_call_arg (stmt, 0)) == SSA_NAME\n+\t  && LOOP_VINFO_LOOP (loop_vinfo)->simduid\n+\t     == SSA_NAME_VAR (gimple_call_arg (stmt, 0)))\n+\t{\n+\t  /* We can handle IFN_GOMP_SIMD_LANE by returning a\n+\t     { 0, 1, 2, ... vf - 1 } vector.  */\n+\t  gcc_assert (nargs == 0);\n+\t}\n+      else\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"function is not vectorizable.\");\n+\t  return false;\n+\t}\n     }\n \n   gcc_assert (!gimple_vuse (stmt));\n@@ -1932,9 +1955,30 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      vargs.quick_push (vec_oprnd0);\n \t    }\n \n-\t  new_stmt = gimple_build_call_vec (fndecl, vargs);\n-\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n-\t  gimple_call_set_lhs (new_stmt, new_temp);\n+\t  if (gimple_call_internal_p (stmt)\n+\t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n+\t    {\n+\t      tree *v = XALLOCAVEC (tree, nunits_out);\n+\t      int k;\n+\t      for (k = 0; k < nunits_out; ++k)\n+\t\tv[k] = build_int_cst (unsigned_type_node, j * nunits_out + k);\n+\t      tree cst = build_vector (vectype_out, v);\n+\t      tree new_var\n+\t\t= vect_get_new_vect_var (vectype_out, vect_simple_var, \"cst_\");\n+\t      gimple init_stmt = gimple_build_assign (new_var, cst);\n+\t      new_temp = make_ssa_name (new_var, init_stmt);\n+\t      gimple_assign_set_lhs (init_stmt, new_temp);\n+\t      vect_init_vector_1 (stmt, init_stmt, NULL);\n+\t      new_temp = make_ssa_name (vec_dest, NULL);\n+\t      new_stmt = gimple_build_assign (new_temp,\n+\t\t\t\t\t      gimple_assign_lhs (init_stmt));\n+\t    }\n+\t  else\n+\t    {\n+\t      new_stmt = gimple_build_call_vec (fndecl, vargs);\n+\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      gimple_call_set_lhs (new_stmt, new_temp);\n+\t    }\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \n \t  if (j == 0)\n@@ -3796,6 +3840,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   enum vect_def_type dt;\n   stmt_vec_info prev_stmt_info = NULL;\n   tree dataref_ptr = NULL_TREE;\n+  tree dataref_offset = NULL_TREE;\n   gimple ptr_incr = NULL;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n@@ -4085,9 +4130,26 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  /* We should have catched mismatched types earlier.  */\n \t  gcc_assert (useless_type_conversion_p (vectype,\n \t\t\t\t\t\t TREE_TYPE (vec_oprnd)));\n-\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, aggr_type, NULL,\n-\t\t\t\t\t\t  NULL_TREE, &dummy, gsi,\n-\t\t\t\t\t\t  &ptr_incr, false, &inv_p);\n+\t  bool simd_lane_access_p\n+\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info);\n+\t  if (simd_lane_access_p\n+\t      && TREE_CODE (DR_BASE_ADDRESS (first_dr)) == ADDR_EXPR\n+\t      && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (first_dr), 0))\n+\t      && integer_zerop (DR_OFFSET (first_dr))\n+\t      && integer_zerop (DR_INIT (first_dr))\n+\t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n+\t\t\t\t\tget_alias_set (DR_REF (first_dr))))\n+\t    {\n+\t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr));\n+\t      dataref_offset = build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t      (DR_REF (first_dr)), 0);\n+\t    }\n+\t  else\n+\t    dataref_ptr\n+\t      = vect_create_data_ref_ptr (first_stmt, aggr_type,\n+\t\t\t\t\t  simd_lane_access_p ? loop : NULL,\n+\t\t\t\t\t  NULL_TREE, &dummy, gsi, &ptr_incr,\n+\t\t\t\t\t  simd_lane_access_p, &inv_p);\n \t  gcc_assert (bb_vinfo || !inv_p);\n \t}\n       else\n@@ -4108,8 +4170,13 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      dr_chain[i] = vec_oprnd;\n \t      oprnds[i] = vec_oprnd;\n \t    }\n-\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n-\t\t\t\t\t TYPE_SIZE_UNIT (aggr_type));\n+\t  if (dataref_offset)\n+\t    dataref_offset\n+\t      = int_const_binop (PLUS_EXPR, dataref_offset,\n+\t\t\t\t TYPE_SIZE_UNIT (aggr_type));\n+\t  else\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n+\t\t\t\t\t   TYPE_SIZE_UNIT (aggr_type));\n \t}\n \n       if (store_lanes_p)\n@@ -4161,8 +4228,10 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\tvec_oprnd = result_chain[i];\n \n \t      data_ref = build2 (MEM_REF, TREE_TYPE (vec_oprnd), dataref_ptr,\n-\t\t\t\t build_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t\t(DR_REF (first_dr)), 0));\n+\t\t\t\t dataref_offset\n+\t\t\t\t ? dataref_offset\n+\t\t\t\t : build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t\t  (DR_REF (first_dr)), 0));\n \t      align = TYPE_ALIGN_UNIT (vectype);\n \t      if (aligned_access_p (first_dr))\n \t\tmisalign = 0;\n@@ -4181,8 +4250,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t  TYPE_ALIGN (elem_type));\n \t\t  misalign = DR_MISALIGNMENT (first_dr);\n \t\t}\n-\t      set_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n-\t\t\t\t      misalign);\n+\t      if (dataref_offset == NULL_TREE)\n+\t\tset_ptr_info_alignment (get_ptr_info (dataref_ptr), align,\n+\t\t\t\t\tmisalign);\n \n \t      /* Arguments are ready.  Create the new vector stmt.  */\n \t      new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n@@ -4314,6 +4384,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n   tree dataref_ptr = NULL_TREE;\n+  tree dataref_offset = NULL_TREE;\n   gimple ptr_incr = NULL;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n@@ -4947,9 +5018,32 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       /* 1. Create the vector or array pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,\n-\t\t\t\t\t\toffset, &dummy, gsi,\n-\t\t\t\t\t\t&ptr_incr, false, &inv_p);\n+\t{\n+\t  bool simd_lane_access_p\n+\t    = STMT_VINFO_SIMD_LANE_ACCESS_P (stmt_info);\n+\t  if (simd_lane_access_p\n+\t      && TREE_CODE (DR_BASE_ADDRESS (first_dr)) == ADDR_EXPR\n+\t      && VAR_P (TREE_OPERAND (DR_BASE_ADDRESS (first_dr), 0))\n+\t      && integer_zerop (DR_OFFSET (first_dr))\n+\t      && integer_zerop (DR_INIT (first_dr))\n+\t      && alias_sets_conflict_p (get_alias_set (aggr_type),\n+\t\t\t\t\tget_alias_set (DR_REF (first_dr)))\n+\t      && (alignment_support_scheme == dr_aligned\n+\t\t  || alignment_support_scheme == dr_unaligned_supported))\n+\t    {\n+\t      dataref_ptr = unshare_expr (DR_BASE_ADDRESS (first_dr));\n+\t      dataref_offset = build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t      (DR_REF (first_dr)), 0);\n+\t    }\n+\t  else\n+\t    dataref_ptr\n+\t      = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,\n+\t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n+\t\t\t\t\t  simd_lane_access_p, &inv_p);\n+\t}\n+      else if (dataref_offset)\n+\tdataref_offset = int_const_binop (PLUS_EXPR, dataref_offset,\n+\t\t\t\t\t  TYPE_SIZE_UNIT (aggr_type));\n       else\n         dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt,\n \t\t\t\t       TYPE_SIZE_UNIT (aggr_type));\n@@ -4999,8 +5093,10 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t\t    data_ref\n \t\t      = build2 (MEM_REF, vectype, dataref_ptr,\n-\t\t\t\tbuild_int_cst (reference_alias_ptr_type\n-\t\t\t\t\t       (DR_REF (first_dr)), 0));\n+\t\t\t\tdataref_offset\n+\t\t\t\t? dataref_offset\n+\t\t\t\t: build_int_cst (reference_alias_ptr_type\n+\t\t\t\t\t\t (DR_REF (first_dr)), 0));\n \t\t    align = TYPE_ALIGN_UNIT (vectype);\n \t\t    if (alignment_support_scheme == dr_aligned)\n \t\t      {\n@@ -5022,8 +5118,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t\t\tTYPE_ALIGN (elem_type));\n \t\t\tmisalign = DR_MISALIGNMENT (first_dr);\n \t\t      }\n-\t\t    set_ptr_info_alignment (get_ptr_info (dataref_ptr),\n-\t\t\t\t\t    align, misalign);\n+\t\t    if (dataref_offset == NULL_TREE)\n+\t\t      set_ptr_info_alignment (get_ptr_info (dataref_ptr),\n+\t\t\t\t\t      align, misalign);\n \t\t    break;\n \t\t  }\n \t\tcase dr_explicit_realign:"}, {"sha": "5501479e7f9ab64233b666fbdee18491097491fd", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 265, "deletions": 2, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -66,13 +66,218 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n+#include \"hash-table.h\"\n+#include \"tree-ssa-propagate.h\"\n \n /* Loop or bb location.  */\n LOC vect_location;\n \n /* Vector mapping GIMPLE stmt to stmt_vec_info. */\n vec<vec_void_p> stmt_vec_info_vec;\n+\f\n+/* For mapping simduid to vectorization factor.  */\n+\n+struct simduid_to_vf : typed_free_remove<simduid_to_vf>\n+{\n+  unsigned int simduid;\n+  int vf;\n+\n+  /* hash_table support.  */\n+  typedef simduid_to_vf value_type;\n+  typedef simduid_to_vf compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+simduid_to_vf::hash (const value_type *p)\n+{\n+  return p->simduid;\n+}\n+\n+inline int\n+simduid_to_vf::equal (const value_type *p1, const value_type *p2)\n+{\n+  return p1->simduid == p2->simduid;\n+}\n+\n+/* This hash maps the OMP simd array to the corresponding simduid used\n+   to index into it.  Like thus,\n+\n+        _7 = GOMP_SIMD_LANE (simduid.0)\n+        ...\n+        ...\n+        D.1737[_7] = stuff;\n+\n+\n+   This hash maps from the simduid.0 to OMP simd array (D.1737[]).  */\n+\n+struct simd_array_to_simduid : typed_free_remove<simd_array_to_simduid>\n+{\n+  tree decl;\n+  unsigned int simduid;\n+\n+  /* hash_table support.  */\n+  typedef simd_array_to_simduid value_type;\n+  typedef simd_array_to_simduid compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline int equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+simd_array_to_simduid::hash (const value_type *p)\n+{\n+  return DECL_UID (p->decl);\n+}\n+\n+inline int\n+simd_array_to_simduid::equal (const value_type *p1, const value_type *p2)\n+{\n+  return p1->decl == p2->decl;\n+}\n+\n+/* Fold IFN_GOMP_SIMD_LANE, IFN_GOMP_SIMD_VF and IFN_GOMP_SIMD_LAST_LANE\n+   into their corresponding constants.  */\n+\n+static void\n+adjust_simduid_builtins (hash_table <simduid_to_vf> &htab)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator i;\n+\n+      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n+\t{\n+\t  unsigned int vf = 1;\n+\t  enum internal_fn ifn;\n+\t  gimple stmt = gsi_stmt (i);\n+\t  tree t;\n+\t  if (!is_gimple_call (stmt)\n+\t      || !gimple_call_internal_p (stmt))\n+\t    continue;\n+\t  ifn = gimple_call_internal_fn (stmt);\n+\t  switch (ifn)\n+\t    {\n+\t    case IFN_GOMP_SIMD_LANE:\n+\t    case IFN_GOMP_SIMD_VF:\n+\t    case IFN_GOMP_SIMD_LAST_LANE:\n+\t      break;\n+\t    default:\n+\t      continue;\n+\t    }\n+\t  tree arg = gimple_call_arg (stmt, 0);\n+\t  gcc_assert (arg != NULL_TREE);\n+\t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n+\t  simduid_to_vf *p = NULL, data;\n+\t  data.simduid = DECL_UID (SSA_NAME_VAR (arg));\n+\t  if (htab.is_created ())\n+\t    p = htab.find (&data);\n+\t  if (p)\n+\t    vf = p->vf;\n+\t  switch (ifn)\n+\t    {\n+\t    case IFN_GOMP_SIMD_VF:\n+\t      t = build_int_cst (unsigned_type_node, vf);\n+\t      break;\n+\t    case IFN_GOMP_SIMD_LANE:\n+\t      t = build_int_cst (unsigned_type_node, 0);\n+\t      break;\n+\t    case IFN_GOMP_SIMD_LAST_LANE:\n+\t      t = gimple_call_arg (stmt, 1);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  update_call_from_tree (&i, t);\n+\t}\n+    }\n+}\n+\n+/* Helper structure for note_simd_array_uses.  */\n+\n+struct note_simd_array_uses_struct\n+{\n+  hash_table <simd_array_to_simduid> *htab;\n+  unsigned int simduid;\n+};\n+\n+/* Callback for note_simd_array_uses, called through walk_gimple_op.  */\n+\n+static tree\n+note_simd_array_uses_cb (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  struct note_simd_array_uses_struct *ns\n+    = (struct note_simd_array_uses_struct *) wi->info;\n+\n+  if (TYPE_P (*tp))\n+    *walk_subtrees = 0;\n+  else if (VAR_P (*tp)\n+\t   && lookup_attribute (\"omp simd array\", DECL_ATTRIBUTES (*tp))\n+\t   && DECL_CONTEXT (*tp) == current_function_decl)\n+    {\n+      simd_array_to_simduid data;\n+      if (!ns->htab->is_created ())\n+\tns->htab->create (15);\n+      data.decl = *tp;\n+      data.simduid = ns->simduid;\n+      simd_array_to_simduid **slot = ns->htab->find_slot (&data, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  simd_array_to_simduid *p = XNEW (simd_array_to_simduid);\n+\t  *p = data;\n+\t  *slot = p;\n+\t}\n+      else if ((*slot)->simduid != ns->simduid)\n+\t(*slot)->simduid = -1U;\n+      *walk_subtrees = 0;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Find \"omp simd array\" temporaries and map them to corresponding\n+   simduid.  */\n+\n+static void\n+note_simd_array_uses (hash_table <simd_array_to_simduid> *htab)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  struct walk_stmt_info wi;\n+  struct note_simd_array_uses_struct ns;\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = &ns;\n+  ns.htab = htab;\n \n+  FOR_EACH_BB (bb)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple stmt = gsi_stmt (gsi);\n+\tif (!is_gimple_call (stmt) || !gimple_call_internal_p (stmt))\n+\t  continue;\n+\tswitch (gimple_call_internal_fn (stmt))\n+\t  {\n+\t  case IFN_GOMP_SIMD_LANE:\n+\t  case IFN_GOMP_SIMD_VF:\n+\t  case IFN_GOMP_SIMD_LAST_LANE:\n+\t    break;\n+\t  default:\n+\t    continue;\n+\t  }\n+\ttree lhs = gimple_call_lhs (stmt);\n+\tif (lhs == NULL_TREE)\n+\t  continue;\n+\timm_use_iterator use_iter;\n+\tgimple use_stmt;\n+\tns.simduid = DECL_UID (SSA_NAME_VAR (gimple_call_arg (stmt, 0)));\n+\tFOR_EACH_IMM_USE_STMT (use_stmt, use_iter, lhs)\n+\t  if (!is_gimple_debug (use_stmt))\n+\t    walk_gimple_op (use_stmt, note_simd_array_uses_cb, &wi);\n+      }\n+}\n \f\n /* Function vectorize_loops.\n \n@@ -86,12 +291,21 @@ vectorize_loops (void)\n   unsigned int vect_loops_num;\n   loop_iterator li;\n   struct loop *loop;\n+  hash_table <simduid_to_vf> simduid_to_vf_htab;\n+  hash_table <simd_array_to_simduid> simd_array_to_simduid_htab;\n \n   vect_loops_num = number_of_loops (cfun);\n \n   /* Bail out if there are no loops.  */\n   if (vect_loops_num <= 1)\n-    return 0;\n+    {\n+      if (cfun->has_simduid_loops)\n+\tadjust_simduid_builtins (simduid_to_vf_htab);\n+      return 0;\n+    }\n+\n+  if (cfun->has_simduid_loops)\n+    note_simd_array_uses (&simd_array_to_simduid_htab);\n \n   init_stmt_vec_info_vec ();\n \n@@ -101,7 +315,8 @@ vectorize_loops (void)\n      than all previously defined loops.  This fact allows us to run\n      only over initial loops skipping newly generated ones.  */\n   FOR_EACH_LOOP (li, loop, 0)\n-    if (optimize_loop_nest_for_speed_p (loop))\n+    if ((flag_tree_vectorize && optimize_loop_nest_for_speed_p (loop))\n+\t|| loop->force_vect)\n       {\n \tloop_vec_info loop_vinfo;\n \tvect_location = find_loop_location (loop);\n@@ -122,6 +337,20 @@ vectorize_loops (void)\n                            \"Vectorized loop\\n\");\n \tvect_transform_loop (loop_vinfo);\n \tnum_vectorized_loops++;\n+\t/* Now that the loop has been vectorized, allow it to be unrolled\n+\t   etc.  */\n+\tloop->force_vect = false;\n+\n+\tif (loop->simduid)\n+\t  {\n+\t    simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n+\t    if (!simduid_to_vf_htab.is_created ())\n+\t      simduid_to_vf_htab.create (15);\n+\t    simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n+\t    simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n+\t    *simduid_to_vf_htab.find_slot (simduid_to_vf_data, INSERT)\n+\t      = simduid_to_vf_data;\n+\t  }\n       }\n \n   vect_location = UNKNOWN_LOC;\n@@ -149,6 +378,40 @@ vectorize_loops (void)\n \n   free_stmt_vec_info_vec ();\n \n+  /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE} builtins.  */\n+  if (cfun->has_simduid_loops)\n+    adjust_simduid_builtins (simduid_to_vf_htab);\n+\n+  /* Shrink any \"omp array simd\" temporary arrays to the\n+     actual vectorization factors.  */\n+  if (simd_array_to_simduid_htab.is_created ())\n+    {\n+      for (hash_table <simd_array_to_simduid>::iterator iter\n+\t   = simd_array_to_simduid_htab.begin ();\n+\t   iter != simd_array_to_simduid_htab.end (); ++iter)\n+\tif ((*iter).simduid != -1U)\n+\t  {\n+\t    tree decl = (*iter).decl;\n+\t    int vf = 1;\n+\t    if (simduid_to_vf_htab.is_created ())\n+\t      {\n+\t\tsimduid_to_vf *p = NULL, data;\n+\t\tdata.simduid = (*iter).simduid;\n+\t\tp = simduid_to_vf_htab.find (&data);\n+\t\tif (p)\n+\t\t  vf = p->vf;\n+\t      }\n+\t    tree atype\n+\t      = build_array_type_nelts (TREE_TYPE (TREE_TYPE (decl)), vf);\n+\t    TREE_TYPE (decl) = atype;\n+\t    relayout_decl (decl);\n+\t  }\n+\n+      simd_array_to_simduid_htab.dispose ();\n+    }\n+  if (simduid_to_vf_htab.is_created ())\n+    simduid_to_vf_htab.dispose ();\n+\n   if (num_vectorized_loops > 0)\n     {\n       /* If we vectorized any loop only virtual SSA form needs to be updated."}, {"sha": "3570dc9d76adbbe5e45b8f3508831d1537b5a89c", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -576,6 +576,9 @@ typedef struct _stmt_vec_info {\n   /* For loads only, true if this is a gather load.  */\n   bool gather_p;\n   bool stride_load_p;\n+\n+  /* For both loads and stores.  */\n+  bool simd_lane_access_p;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -591,6 +594,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n #define STMT_VINFO_GATHER_P(S)\t\t   (S)->gather_p\n #define STMT_VINFO_STRIDE_LOAD_P(S)\t   (S)->stride_load_p\n+#define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n \n #define STMT_VINFO_DR_BASE_ADDRESS(S)      (S)->dr_base_address\n #define STMT_VINFO_DR_INIT(S)              (S)->dr_init"}, {"sha": "f0ee3098e664ea0a9daebd7eefe1679581ad1077", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -236,6 +236,8 @@ unsigned const char omp_clause_num_ops[] =\n   4, /* OMP_CLAUSE_REDUCTION  */\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n+  2, /* OMP_CLAUSE_LINEAR  */\n+  1, /* OMP_CLAUSE_UNIFORM  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n   1, /* OMP_CLAUSE_SCHEDULE  */\n@@ -245,7 +247,9 @@ unsigned const char omp_clause_num_ops[] =\n   3, /* OMP_CLAUSE_COLLAPSE  */\n   0, /* OMP_CLAUSE_UNTIED   */\n   1, /* OMP_CLAUSE_FINAL  */\n-  0  /* OMP_CLAUSE_MERGEABLE  */\n+  0, /* OMP_CLAUSE_MERGEABLE  */\n+  1, /* OMP_CLAUSE_SAFELEN  */\n+  1, /* OMP_CLAUSE__SIMDUID_  */\n };\n \n const char * const omp_clause_code_name[] =\n@@ -258,6 +262,8 @@ const char * const omp_clause_code_name[] =\n   \"reduction\",\n   \"copyin\",\n   \"copyprivate\",\n+  \"linear\",\n+  \"uniform\",\n   \"if\",\n   \"num_threads\",\n   \"schedule\",\n@@ -267,7 +273,9 @@ const char * const omp_clause_code_name[] =\n   \"collapse\",\n   \"untied\",\n   \"final\",\n-  \"mergeable\"\n+  \"mergeable\",\n+  \"safelen\",\n+  \"_simduid_\"\n };\n \n \n@@ -11064,6 +11072,9 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \tcase OMP_CLAUSE_SCHEDULE:\n+\tcase OMP_CLAUSE_UNIFORM:\n+\tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE__SIMDUID_:\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */\n \n@@ -11087,6 +11098,11 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t    WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \t  }\n \n+\tcase OMP_CLAUSE_LINEAR:\n+\t  WALK_SUBTREE (OMP_CLAUSE_DECL (*tp));\n+\t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n+\t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n+\n \tcase OMP_CLAUSE_REDUCTION:\n \t  {\n \t    int i;"}, {"sha": "f825aad5355ea08bdff013dfe39f255dad821ecc", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -1030,6 +1030,10 @@ DEFTREECODE (OMP_TASK, \"omp_task\", tcc_statement, 2)\n    unspecified by the standard.  */\n DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n \n+/* OpenMP - #pragma omp simd [clause1 ... clauseN]\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OMP_SIMD, \"omp_simd\", tcc_statement, 6)\n+\n /* OpenMP - #pragma omp sections [clause1 ... clauseN]\n    Operand 0: OMP_SECTIONS_BODY: Sections body.\n    Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */"}, {"sha": "eb017e57f06990759f632973647d8607ca3e8a1d", "filename": "gcc/tree.h", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74bf76ed78a14069969e94233f05e7840806aed8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=74bf76ed78a14069969e94233f05e7840806aed8", "patch": "@@ -365,6 +365,12 @@ enum omp_clause_code\n   /* OpenMP clause: copyprivate (variable_list).  */\n   OMP_CLAUSE_COPYPRIVATE,\n \n+  /* OpenMP clause: linear (variable-list[:linear-step]).  */\n+  OMP_CLAUSE_LINEAR,\n+\n+  /* OpenMP clause: uniform (argument-list).  */\n+  OMP_CLAUSE_UNIFORM,\n+\n   /* OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n \n@@ -393,7 +399,13 @@ enum omp_clause_code\n   OMP_CLAUSE_FINAL,\n \n   /* OpenMP clause: mergeable.  */\n-  OMP_CLAUSE_MERGEABLE\n+  OMP_CLAUSE_MERGEABLE,\n+\n+  /* OpenMP clause: safelen (constant-integer-expression).  */\n+  OMP_CLAUSE_SAFELEN,\n+\n+  /* Internally used only clause, holding SIMD uid.  */\n+  OMP_CLAUSE__SIMDUID_\n };\n \f\n /* The definition of tree nodes fills the next several pages.  */\n@@ -560,6 +572,9 @@ struct GTY(()) tree_base {\n        OMP_CLAUSE_PRIVATE_DEBUG in\n            OMP_CLAUSE_PRIVATE\n \n+       OMP_CLAUSE_LINEAR_NO_COPYIN in\n+\t   OMP_CLAUSE_LINEAR\n+\n        TRANSACTION_EXPR_RELAXED in\n \t   TRANSACTION_EXPR\n \n@@ -580,6 +595,9 @@ struct GTY(()) tree_base {\n        OMP_CLAUSE_PRIVATE_OUTER_REF in\n \t   OMP_CLAUSE_PRIVATE\n \n+       OMP_CLAUSE_LINEAR_NO_COPYOUT in\n+\t   OMP_CLAUSE_LINEAR\n+\n        TYPE_REF_IS_RVALUE in\n \t   REFERENCE_TYPE\n \n@@ -1803,7 +1821,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n-\t                                      OMP_CLAUSE_COPYPRIVATE), 0)\n+\t                                      OMP_CLAUSE_UNIFORM), 0)\n #define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n   (LOCATION_LOCUS ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus)\t\t\\\n   != UNKNOWN_LOCATION)\n@@ -1870,6 +1888,25 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_REDUCTION_PLACEHOLDER(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_REDUCTION), 3)\n \n+/* True if a LINEAR clause doesn't need copy in.  True for iterator vars which\n+   are always initialized inside of the loop construct, false otherwise.  */\n+#define OMP_CLAUSE_LINEAR_NO_COPYIN(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->base.public_flag)\n+\n+/* True if a LINEAR clause doesn't need copy out.  True for iterator vars which\n+   are declared inside of the simd construct.  */\n+#define OMP_CLAUSE_LINEAR_NO_COPYOUT(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))\n+\n+#define OMP_CLAUSE_LINEAR_STEP(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)\n+\n+#define OMP_CLAUSE_SAFELEN_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SAFELEN), 0)\n+\n+#define OMP_CLAUSE__SIMDUID__DECL(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE__SIMDUID_), 0)\n+\n enum omp_clause_schedule_kind\n {\n   OMP_CLAUSE_SCHEDULE_STATIC,\n@@ -4813,6 +4850,7 @@ extern tree build_translation_unit_decl (tree);\n extern tree build_block (tree, tree, tree, tree);\n extern tree build_empty_stmt (location_t);\n extern tree build_omp_clause (location_t, enum omp_clause_code);\n+extern tree find_omp_clause (tree, enum omp_clause_code);\n \n extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n #define build_vl_exp(c,n) build_vl_exp_stat (c,n MEM_STAT_INFO)"}]}