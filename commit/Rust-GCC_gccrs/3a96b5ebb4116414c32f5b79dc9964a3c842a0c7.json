{"sha": "3a96b5ebb4116414c32f5b79dc9964a3c842a0c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E5NmI1ZWJiNDExNjQxNGMzMmY1Yjc5ZGM5OTY0YTNjODQyYTBjNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T00:16:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-01-14T00:16:09Z"}, "message": "(fold, case COND_EXPR): Properly swap args 1 and 2.\n\nStrip nops from ARG2, just like ARG1.\nMake {MIN,MAX}_EXPR properly when type of result different than args.\n\nFrom-SVN: r8745", "tree": {"sha": "d7f660b2ca608366bad4b5712c535050b1965e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7f660b2ca608366bad4b5712c535050b1965e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7/comments", "author": null, "committer": null, "parents": [{"sha": "4013a709018d4579b052a7a19322b2e969aa96a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4013a709018d4579b052a7a19322b2e969aa96a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4013a709018d4579b052a7a19322b2e969aa96a9"}], "stats": {"total": 54, "additions": 33, "deletions": 21}, "files": [{"sha": "9d40401ffa699aa415ac36adab8cc431c56e2c63", "filename": "gcc/fold-const.c", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a96b5ebb4116414c32f5b79dc9964a3c842a0c7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3a96b5ebb4116414c32f5b79dc9964a3c842a0c7", "patch": "@@ -4730,9 +4730,10 @@ fold (expr)\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n \t    {\n \t      arg0 = TREE_OPERAND (t, 0) = tem;\n-\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 2);\n-\t      TREE_OPERAND (t, 2) = arg1;\n-\t      arg1 = TREE_OPERAND (t, 1);\n+\t      arg1 = TREE_OPERAND (t, 2);\n+\t      TREE_OPERAND (t, 2) = TREE_OPERAND (t, 1);\n+\t      TREE_OPERAND (t, 1) = arg1;\n+\t      STRIP_NOPS (arg1);\n \t    }\n \t}\n \n@@ -4751,6 +4752,8 @@ fold (expr)\n \t  tree arg2 = TREE_OPERAND (t, 2);\n \t  enum tree_code comp_code = TREE_CODE (arg0);\n \n+\t  STRIP_NOPS (arg2);\n+\n \t  /* If we have A op 0 ? A : -A, this is A, -A, abs (A), or abs (-A),\n \t     depending on the comparison operation.  */\n \t  if ((FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 1)))\n@@ -4792,21 +4795,29 @@ fold (expr)\n \n \t  if (operand_equal_for_comparison_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t\t      arg2, TREE_OPERAND (arg0, 0)))\n-\t    switch (comp_code)\n-\t      {\n-\t      case EQ_EXPR:\n-\t\treturn pedantic_non_lvalue (convert (type, arg2));\n-\t      case NE_EXPR:\n-\t\treturn pedantic_non_lvalue (convert (type, arg1));\n-\t      case LE_EXPR:\n-\t      case LT_EXPR:\n-\t\treturn pedantic_non_lvalue\n-\t\t  (fold (build (MIN_EXPR, type, arg1, arg2)));\n-\t      case GE_EXPR:\n-\t      case GT_EXPR:\n-\t\treturn pedantic_non_lvalue\n-\t\t  (fold (build (MAX_EXPR, type, arg1, arg2)));\n-\t      }\n+\t    {\n+\t      tree comp_op0 = TREE_OPERAND (arg0, 0);\n+\t      tree comp_op1 = TREE_OPERAND (arg0, 1);\n+\t      tree comp_type = TREE_TYPE (comp_op0);\n+\n+\t      switch (comp_code)\n+\t\t{\n+\t\tcase EQ_EXPR:\n+\t\t  return pedantic_non_lvalue (convert (type, arg2));\n+\t\tcase NE_EXPR:\n+\t\t  return pedantic_non_lvalue (convert (type, arg1));\n+\t\tcase LE_EXPR:\n+\t\tcase LT_EXPR:\n+\t\t  return pedantic_non_lvalue\n+\t\t    (convert (type, (fold (build (MIN_EXPR, comp_type,\n+\t\t\t\t\t\t  comp_op0, comp_op1)))));\n+\t\tcase GE_EXPR:\n+\t\tcase GT_EXPR:\n+\t\t  return pedantic_non_lvalue\n+\t\t    (convert (type, fold (build (MAX_EXPR, comp_type,\n+\t\t\t\t\t\t comp_op0, comp_op1))));\n+\t\t}\n+\t    }\n \n \t  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n \t     we might still be able to simplify this.  For example,\n@@ -4883,9 +4894,10 @@ fold (expr)\n \t  if (TREE_CODE (tem) != TRUTH_NOT_EXPR)\n \t    {\n \t      arg0 = TREE_OPERAND (t, 0) = tem;\n-\t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 2);\n-\t      TREE_OPERAND (t, 2) = arg1;\n-\t      arg1 = TREE_OPERAND (t, 1);\n+\t      arg1 = TREE_OPERAND (t, 2);\n+\t      TREE_OPERAND (t, 2) = TREE_OPERAND (t, 1);\n+\t      TREE_OPERAND (t, 1) = arg1;\n+\t      STRIP_NOPS (arg1);\n \t    }\n \t}\n "}]}