{"sha": "07417085a14349cde788c5cc10663815da40c26f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc0MTcwODVhMTQzNDljZGU3ODhjNWNjMTA2NjM4MTVkYTQwYzI2Zg==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@cygnus.com", "date": "1998-07-30T10:38:22Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1998-07-30T10:38:22Z"}, "message": "Function entry/exit profiling instrumentation:\n\n* expr.h (profile_function_entry_libfunc, profile_function_exit_libfunc):\nDeclare new variables.\n* optabs.c: Define them here.\n(init_optabs): Initialize them.\n* tree.h (struct tree_decl): New flag no_instrument_function_entry_exit.\n(DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT): New accessor macro.\n* c-decl.c (duplicate_decls): Merge it.\n* c-common.c (enum attrs): New value A_NO_INSTRUMENT_FUNCTION.\n(init_attributes): Use it for \"no_instrument_function\".\n(decl_attributes): Handle it, for functions that have not yet been compiled.\nSet decl flag.\n* flags.h (flag_instrument_function_entry_exit): Declare new variable.\n* toplev.c (flag_instrument_function_entry_exit): Define it here.\n(f_options): New option \"instrument-functions\".\n* function.h (struct function): New field instrument_entry_exit.\n* function.c (current_function_instrument_entry_exit): New variable.\n(push_function_context_to, pop_function_context_from): Save and restore.\n(expand_function_start): Set current_ variable, maybe emit return label and\nentry profile call.\n(expand_function_end): Maybe emit exit profile call.\nTestsuite:\n* gcc.c-torture/special/eeprof-1.c: New test, for -finstrument-functions.\n* gcc.c-torture/special/special.exp: Run it.\n\nFrom-SVN: r21495", "tree": {"sha": "026e48c190a03450b58622639d6f3e00ed5ec047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/026e48c190a03450b58622639d6f3e00ed5ec047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07417085a14349cde788c5cc10663815da40c26f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07417085a14349cde788c5cc10663815da40c26f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07417085a14349cde788c5cc10663815da40c26f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07417085a14349cde788c5cc10663815da40c26f/comments", "author": null, "committer": null, "parents": [{"sha": "6bcf8e5a040d2ce78eba4b4a143a216e2cea4ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bcf8e5a040d2ce78eba4b4a143a216e2cea4ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bcf8e5a040d2ce78eba4b4a143a216e2cea4ab5"}], "stats": {"total": 244, "additions": 239, "deletions": 5}, "files": [{"sha": "88fb4937ce591c821030110e310ae4d66e09151a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -1,3 +1,31 @@\n+Thu Jul 30 13:08:07 1998  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\tFunction entry/exit profiling instrumentation:\n+\t* expr.h (profile_function_entry_libfunc,\n+\tprofile_function_exit_libfunc): Declare new variables.\n+\t* optabs.c: Define them here.\n+\t(init_optabs): Initialize them.\n+\t* tree.h (struct tree_decl): New flag\n+\tno_instrument_function_entry_exit.\n+\t(DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT): New accessor macro.\n+\t* c-decl.c (duplicate_decls): Merge it.\n+\t* c-common.c (enum attrs): New value A_NO_INSTRUMENT_FUNCTION.\n+\t(init_attributes): Use it for \"no_instrument_function\".\n+\t(decl_attributes): Handle it, for functions that have not yet been\n+\tcompiled.  Set decl flag.\n+\t* flags.h (flag_instrument_function_entry_exit): Declare new\n+\tvariable.\n+\t* toplev.c (flag_instrument_function_entry_exit): Define it here.\n+\t(f_options): New option \"instrument-functions\".\n+\t* function.h (struct function): New field instrument_entry_exit.\n+\t* function.c (current_function_instrument_entry_exit): New\n+\tvariable.\n+\t(push_function_context_to, pop_function_context_from): Save and\n+\trestore.\n+\t(expand_function_start): Set current_ variable, maybe emit return\n+\tlabel and entry profile call.\n+\t(expand_function_end): Maybe emit exit profile call.\n+\n Thu Jul 30 00:58:34 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386.md (movqi): When optimizing a load of (const_int 1) into a"}, {"sha": "8405a41a2c911a6aa7fe8f9c6c81e8e095b7bc4a", "filename": "gcc/c-common.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -50,6 +50,7 @@ extern struct obstack permanent_obstack;\n int skip_evaluation;\n \n enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n+\t    A_NO_INSTRUMENT_FUNCTION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS};\n \n@@ -382,6 +383,7 @@ init_attributes ()\n   add_attribute (A_FORMAT_ARG, \"format_arg\", 1, 1, 1);\n   add_attribute (A_WEAK, \"weak\", 0, 0, 1);\n   add_attribute (A_ALIAS, \"alias\", 1, 1, 1);\n+  add_attribute (A_NO_INSTRUMENT_FUNCTION, \"no_instrument_function\", 0, 0, 1);\n }\n \f\n /* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES\n@@ -856,6 +858,23 @@ decl_attributes (node, attributes, prefix_attributes)\n \t  else\n \t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n \t  break;\n+\n+\tcase A_NO_INSTRUMENT_FUNCTION:\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"`%s' attribute applies only to functions\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else if (DECL_INITIAL (decl))\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"can't set `%s' attribute after definition\",\n+\t\t\t       IDENTIFIER_POINTER (name));\n+\t    }\n+\t  else\n+\t    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n+\t  break;\n \t}\n     }\n }"}, {"sha": "a4b87860e66d44a63091b8c07116204fa84c9e9b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -1931,6 +1931,9 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t{\n \t  DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n \t  DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n+\n+\t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)\n+\t    |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);\n \t}\n \n       pop_obstacks ();"}, {"sha": "9e43741f26ecc95b226311a520e1fcd079fabc06", "filename": "gcc/expr.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -532,6 +532,10 @@ extern rtx chkr_set_right_libfunc;\n extern rtx chkr_copy_bitmap_libfunc;\n extern rtx chkr_check_exec_libfunc;\n extern rtx chkr_check_str_libfunc;\n+\n+/* For instrument-functions.  */\n+extern rtx profile_function_entry_libfunc;\n+extern rtx profile_function_exit_libfunc;\n \f\n typedef rtx (*rtxfun) PROTO ((rtx));\n "}, {"sha": "0fb01f444f55ef53957053efb632f6ee8c3328fa", "filename": "gcc/extend.texi", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -1286,8 +1286,9 @@ carefully.\n \n The keyword @code{__attribute__} allows you to specify special\n attributes when making a declaration.  This keyword is followed by an\n-attribute specification inside double parentheses.  Eight attributes,\n-@code{noreturn}, @code{const}, @code{format}, @code{section},\n+attribute specification inside double parentheses.  Nine attributes,\n+@code{noreturn}, @code{const}, @code{format},\n+@code{no_instrument_function}, @code{section},\n @code{constructor}, @code{destructor}, @code{unused} and @code{weak} are\n currently defined for functions.  Other attributes, including\n @code{section} are supported for variables declarations (@pxref{Variable\n@@ -1447,6 +1448,12 @@ operands are a call to one of your own function.  The compiler always\n treats @code{gettext}, @code{dgettext}, and @code{dcgettext} in this\n manner.\n \n+@item no_instrument_function\n+@cindex @code{no_instrument_function} function attribute\n+If @samp{-finstrument-functions} is given, profiling function calls will\n+be generated at entry and exit of most user-compiled functions.\n+Functions with this attribute will not be so instrumented.\n+\n @item section (\"section-name\")\n @cindex @code{section} function attribute\n Normally, the compiler places the code it generates in the @code{text} section."}, {"sha": "cfb4ee628c968f52b7ac253b1b1700c3f9a85a67", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -444,6 +444,9 @@ extern int flag_stack_check;\n \n /* Do the full regmove optimization pass.  */\n extern int flag_regmove;\n+\n+/* Instrument functions with calls at entry and exit, for profiling.  */\n+extern int flag_instrument_function_entry_exit;\n \f\n /* Other basic status info about current function.  */\n "}, {"sha": "5bd012fc1356c8aa8f5f51ccfe583dbcfa590684", "filename": "gcc/function.c", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -217,6 +217,10 @@ rtx current_function_internal_arg_pointer;\n /* Language-specific reason why the current function cannot be made inline.  */\n char *current_function_cannot_inline;\n \n+/* Nonzero if instrumentation calls for function entry and exit should be\n+   generated.  */\n+int current_function_instrument_entry_exit;\n+\n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n tree inline_function_decl;\n \n@@ -539,6 +543,7 @@ push_function_context_to (context)\n   p->fixup_var_refs_queue = 0;\n   p->epilogue_delay_list = current_function_epilogue_delay_list;\n   p->args_info = current_function_args_info;\n+  p->instrument_entry_exit = current_function_instrument_entry_exit;\n \n   save_tree_status (p, context);\n   save_storage_status (p);\n@@ -621,6 +626,7 @@ pop_function_context_from (context)\n   current_function_epilogue_delay_list = p->epilogue_delay_list;\n   reg_renumber = 0;\n   current_function_args_info = p->args_info;\n+  current_function_instrument_entry_exit = p->instrument_entry_exit;\n \n   restore_tree_status (p, context);\n   restore_storage_status (p);\n@@ -5458,6 +5464,10 @@ expand_function_start (subr, parms_have_cleanups)\n      valid operands of arithmetic insns.  */\n   init_recog_no_volatile ();\n \n+  current_function_instrument_entry_exit\n+    = (flag_instrument_function_entry_exit\n+       && ! DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (subr));\n+\n   /* If function gets a static chain arg, store it in the stack frame.\n      Do this first, so it gets the first stack slot offset.  */\n   if (current_function_needs_context)\n@@ -5484,6 +5494,7 @@ expand_function_start (subr, parms_have_cleanups)\n      or if it returns a structure, or if it has parm cleanups.  */\n #ifdef HAVE_return\n   if (cleanup_label == 0 && HAVE_return\n+      && ! current_function_instrument_entry_exit\n       && ! current_function_returns_pcc_struct\n       && ! (current_function_returns_struct && ! optimize))\n     return_label = 0;\n@@ -5532,7 +5543,7 @@ expand_function_start (subr, parms_have_cleanups)\n   else if (DECL_MODE (DECL_RESULT (subr)) == VOIDmode)\n     /* If return mode is void, this decl rtl should not be used.  */\n     DECL_RTL (DECL_RESULT (subr)) = 0;\n-  else if (parms_have_cleanups)\n+  else if (parms_have_cleanups || current_function_instrument_entry_exit)\n     {\n       /* If function will end with cleanup code for parms,\n \t compute the return values into a pseudo reg,\n@@ -5650,6 +5661,21 @@ expand_function_start (subr, parms_have_cleanups)\n \t}\n     }\n \n+  if (current_function_instrument_entry_exit)\n+    {\n+      rtx fun = DECL_RTL (current_function_decl);\n+      if (GET_CODE (fun) == MEM)\n+\tfun = XEXP (fun, 0);\n+      else\n+\tabort ();\n+      emit_library_call (profile_function_entry_libfunc, 0, VOIDmode, 2,\n+\t\t\t fun, Pmode,\n+\t\t\t expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     hard_frame_pointer_rtx),\n+\t\t\t Pmode);\n+    }\n+\n   /* After the display initializations is where the tail-recursion label\n      should go, if we end up needing one.   Ensure we have a NOTE here\n      since some things (like trampolines) get placed before this.  */\n@@ -5863,6 +5889,21 @@ expand_function_end (filename, line, end_bindings)\n       }\n   }\n \n+  if (current_function_instrument_entry_exit)\n+    {\n+      rtx fun = DECL_RTL (current_function_decl);\n+      if (GET_CODE (fun) == MEM)\n+\tfun = XEXP (fun, 0);\n+      else\n+\tabort ();\n+      emit_library_call (profile_function_exit_libfunc, 0, VOIDmode, 2,\n+\t\t\t fun, Pmode,\n+\t\t\t expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     hard_frame_pointer_rtx),\n+\t\t\t Pmode);\n+    }\n+\n   /* If we had calls to alloca, and this machine needs\n      an accurate stack pointer to exit the function,\n      insert some code to save and restore the stack pointer.  */"}, {"sha": "06e90dc88aa34b759d7a097090b52922059e1c6f", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -113,6 +113,7 @@ struct function\n   int temp_slot_level;\n   int target_temp_slot_level;\n   int var_temp_slot_level;\n+  int instrument_entry_exit;\n   /* This slot is initialized as 0 and is added to\n      during the nested function.  */\n   struct var_refs_queue *fixup_var_refs_queue;"}, {"sha": "67c7392258fdb8fe0cc3c4ff4e5a4ad1f53ce0e4", "filename": "gcc/invoke.texi", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -5907,6 +5907,41 @@ prefix_foo (int a)\n @end example\n This option is designed to be used with @samp{-fcheck-memory-usage}.\n \n+@item -finstrument-functions\n+Generate instrumentation calls for entry and exit to functions.  Just\n+after function entry and just before function exit, the following\n+profiling functions will be called with the address of the current\n+function and its call site.  (On some platforms,\n+@code{__builtin_return_address} does not work beyond the current\n+function, so the call site information may not be available to the\n+profiling functions otherwise.)\n+\n+@example\n+void __cyg_profile_func_enter (void *this_fn, void *call_site);\n+void __cyg_profile_func_exit  (void *this_fn, void *call_site);\n+@end example\n+\n+The first argument is the address of the start of the current function,\n+which may be looked up exactly in the symbol table.\n+\n+This instrumentation is also done for functions expanded inline in other\n+functions.  The profiling calls will indicate where, conceptually, the\n+inline function is entered and exited.  This means that addressable\n+versions of such functions must be available.  If all your uses of a\n+function are expanded inline, this may mean an additional expansion of\n+code size.  If you use @samp{extern inline} in your C code, an\n+addressable version of such functions must be provided.  (This is\n+normally the case anyways, but if you get lucky and the optimizer always\n+expands the functions inline, you might have gotten away without\n+providing static copies.)\n+\n+A function may be given the attribute @code{no_instrument_function}, in\n+which case this instrumentation will not be done.  This can be used, for\n+example, for the profiling functions listed above, high-priority\n+interrupt routines, and any functions from which the profiling functions\n+cannot safely be called (perhaps signal handlers, if the profiling\n+routines generate output or allocate memory).\n+\n @item -fstack-check\n Generate code to verify that you do not go beyond the boundary of the\n stack.  You should specify this flag if you are running in an"}, {"sha": "95c963ee040a9658d3a32d9f1c1fe9000c52fb88", "filename": "gcc/optabs.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -214,6 +214,9 @@ rtx chkr_copy_bitmap_libfunc;\n rtx chkr_check_exec_libfunc;\n rtx chkr_check_str_libfunc;\n \n+rtx profile_function_entry_libfunc;\n+rtx profile_function_exit_libfunc;\n+\n /* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n \n@@ -4391,6 +4394,12 @@ init_optabs ()\n   chkr_check_exec_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_exec\");\n   chkr_check_str_libfunc = gen_rtx_SYMBOL_REF (VOIDmode, \"chkr_check_str\");\n \n+  /* For function entry/exit instrumentation.  */\n+  profile_function_entry_libfunc\n+    = gen_rtx_SYMBOL_REF (VOIDmode, \"__cyg_profile_func_enter\");\n+  profile_function_exit_libfunc\n+    = gen_rtx_SYMBOL_REF (VOIDmode, \"__cyg_profile_func_exit\");\n+\n #ifdef HAVE_conditional_trap\n   init_traps ();\n #endif"}, {"sha": "aced868b959ccf9798701932937fbaf0b46a11c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -1,3 +1,9 @@\n+1998-07-30  Ken Raeburn  <raeburn@cygnus.com>\n+\n+\t* gcc.c-torture/special/eeprof-1.c: New test, for\n+\t-finstrument-functions.\n+\t* gcc.c-torture/special/special.exp: Run it.\n+\n Wed Jul 29 00:17:18 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcc.c-torture/compile/980729-1.c: New test."}, {"sha": "6dad7ec5a73404d5486ebe00653607d93571f5fd", "filename": "gcc/testsuite/gcc.c-torture/special/eeprof-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Feeprof-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Feeprof-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Feeprof-1.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -0,0 +1,67 @@\n+#define ASSERT(X)\tif (!(X)) abort ();\n+#define NOCHK __attribute__ ((no_instrument_function))\n+\n+int entry_calls, exit_calls;\n+void (*last_fn_entered)();\n+void (*last_fn_exited)();\n+\n+int main () NOCHK;\n+\n+void foo ()\n+{\n+  ASSERT (last_fn_entered == foo);\n+}\n+\n+static void foo2 ()\n+{\n+  ASSERT (entry_calls == 1 && exit_calls == 0);\n+  ASSERT (last_fn_entered == foo2);\n+  foo ();\n+  ASSERT (entry_calls == 2 && exit_calls == 1);\n+  ASSERT (last_fn_entered == foo);\n+  ASSERT (last_fn_exited == foo);\n+}\n+\n+void nfoo (void) NOCHK;\n+void nfoo ()\n+{\n+  ASSERT (entry_calls == 2 && exit_calls == 2);\n+  ASSERT (last_fn_entered == foo);\n+  ASSERT (last_fn_exited == foo2);\n+  foo ();\n+  ASSERT (entry_calls == 3 && exit_calls == 3);\n+  ASSERT (last_fn_entered == foo);\n+  ASSERT (last_fn_exited == foo);\n+}\n+\n+int main ()\n+{\n+  ASSERT (entry_calls == 0 && exit_calls == 0);\n+\n+  foo2 ();\n+\n+  ASSERT (entry_calls == 2 && exit_calls == 2);\n+  ASSERT (last_fn_entered == foo);\n+  ASSERT (last_fn_exited == foo2);\n+\n+  nfoo ();\n+\n+  ASSERT (entry_calls == 3 && exit_calls == 3);\n+  ASSERT (last_fn_entered == foo);\n+\n+  return 0;\n+}\n+\n+void __cyg_profile_func_enter (void (*fn)(), void (*parent)()) NOCHK;\n+void __cyg_profile_func_exit (void (*fn)(), void (*parent)()) NOCHK;\n+\n+void __cyg_profile_func_enter (void (*fn)(), void (*parent)())\n+{\n+  entry_calls++;\n+  last_fn_entered = fn;\n+}\n+void __cyg_profile_func_exit (void (*fn)(), void (*parent)())\n+{\n+  exit_calls++;\n+  last_fn_exited = fn;\n+}"}, {"sha": "ac215a39f5bfb765c0563a3c62769019e401966f", "filename": "gcc/testsuite/gcc.c-torture/special/special.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Fspecial.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Fspecial.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fspecial%2Fspecial.exp?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -98,3 +98,5 @@ c-torture 960224-1.c \"-E -ansi -pedantic-errors\"\n \n # 960224-2\n #c-torture 960224-2.c \"-E -ansi -pedantic-errors\"\n+\n+c-torture-execute $srcdir/$subdir/eeprof-1.c \"-finstrument-functions\""}, {"sha": "9ab6435ab308312040033a9c4cd49dbc1b9dbd24", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -723,6 +723,9 @@ int flag_strict_aliasing = 0;\n \n extern int flag_dump_unnumbered;\n \n+/* Instrument functions with calls at entry and exit, for profiling.  */\n+int flag_instrument_function_entry_exit = 0;\n+\n \n /* Table of supported debugging formats.  */\n static struct\n@@ -908,7 +911,9 @@ lang_independent_options f_options[] =\n    \"Generate code to check every memory access\" },\n   {\"prefix-function-name\", &flag_prefix_function_name, 1,\n    \"Add a prefix to all function names\" },\n-  {\"dump-unnumbered\", &flag_dump_unnumbered, 1}\n+  {\"dump-unnumbered\", &flag_dump_unnumbered, 1},\n+  {\"instrument-functions\", &flag_instrument_function_entry_exit, 1,\n+   \"Instrument function entry/exit with profiling calls\"},\n };\n \n #define NUM_ELEM(a)  (sizeof (a) / sizeof ((a)[0]))"}, {"sha": "401e5ee4b924c1f67207125141912cd7d42e3f62", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07417085a14349cde788c5cc10663815da40c26f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=07417085a14349cde788c5cc10663815da40c26f", "patch": "@@ -1201,6 +1201,10 @@ struct tree_type\n    multiple translation units should be merged.  */\n #define DECL_ONE_ONLY(NODE) (DECL_CHECK (NODE)->decl.transparent_union)\n \n+/* Used in FUNCTION_DECLs to indicate that function entry and exit should\n+   be instrumented with calls to support routines.  */\n+#define DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT(NODE) ((NODE)->decl.no_instrument_function_entry_exit)\n+\n /* Additional flags for language-specific uses.  */\n #define DECL_LANG_FLAG_0(NODE) (DECL_CHECK (NODE)->decl.lang_flag_0)\n #define DECL_LANG_FLAG_1(NODE) (DECL_CHECK (NODE)->decl.lang_flag_1)\n@@ -1245,7 +1249,6 @@ struct tree_decl\n   unsigned static_dtor_flag : 1;\n   unsigned artificial_flag : 1;\n   unsigned weak_flag : 1;\n-  /* room for no more */\n \n   unsigned lang_flag_0 : 1;\n   unsigned lang_flag_1 : 1;\n@@ -1257,6 +1260,7 @@ struct tree_decl\n   unsigned lang_flag_7 : 1;\n \n   unsigned non_addr_const_p : 1;\n+  unsigned no_instrument_function_entry_exit : 1;\n \n   /* For a FUNCTION_DECL, if inline, this is the size of frame needed.\n      If built-in, this is the code for which built-in function."}]}