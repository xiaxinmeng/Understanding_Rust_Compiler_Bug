{"sha": "7bf911b58345771e3be025a0b132912df4f566bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JmOTExYjU4MzQ1NzcxZTNiZTAyNWEwYjEzMjkxMmRmNGY1NjZiZA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-11-18T10:30:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-18T10:30:12Z"}, "message": "re PR ada/66242 (Front-end error if exception propagation disabled)\n\n2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\tPR ada/66242\n\n\t* exp_ch3.adb (Default_Initialize_Object): Reimplemented. Abort\n\tdefer / undefer pairs are now encapsulated in a block with\n\tan AT END handler. Partial finalization now takes restriction\n\tNo_Exception_Propagation into account when generating blocks.\n\t* exp_ch7.adb Various reformattings.\n\t(Create_Finalizer): Change\n\tthe generation of abort defer / undefer pairs and explain the\n\tlack of an AT END handler.\n\t(Process_Transient_Objects): Add generation of abort defer/undefer\n\tpairs.\n\t* exp_ch9.adb Various reformattings.\n\t(Build_Protected_Subprogram_Body): Use\n\tBuild_Runtime_Call to construct a call to Abort_Defer.\n\t(Build_Protected_Subprogram_Call_Cleanup): Use\n\tBuild_Runtime_Call to construct a call to Abort_Undefer.\n\t(Expand_N_Asynchronous_Select): Use Build_Runtime_Call to\n\tconstruct a call to Abort_Defer.\n\t* exp_intr.adb (Expand_Unc_Deallocation): Abort defer\n\t/ undefer pairs are now encapsulated in a block with\n\tan AT END handler. Finalization now takes restriction\n\tNo_Exception_Propagation into account when generating blocks.\n\t* exp_util.ads, exp_util.adb (Wrap_Cleanup_Procedure): Removed.\n\nFrom-SVN: r230531", "tree": {"sha": "7ad401950698ded421af216bdcf5077c24dbb5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad401950698ded421af216bdcf5077c24dbb5a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bf911b58345771e3be025a0b132912df4f566bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf911b58345771e3be025a0b132912df4f566bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf911b58345771e3be025a0b132912df4f566bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf911b58345771e3be025a0b132912df4f566bd/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ebcad86e6aa747d9ca8a077ab1127a04d0d91d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ebcad86e6aa747d9ca8a077ab1127a04d0d91d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ebcad86e6aa747d9ca8a077ab1127a04d0d91d3"}], "stats": {"total": 641, "additions": 286, "deletions": 355}, "files": [{"sha": "af245ec637f3f93e9ca204c60620742dae4df49d", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 110, "deletions": 117, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -201,9 +201,9 @@ package body Exp_Ch3 is\n    --  subprogram they rename is not frozen when the type is frozen.\n \n    procedure Insert_Component_Invariant_Checks\n-     (N   : Node_Id;\n-     Typ  : Entity_Id;\n-     Proc : Node_Id);\n+     (N    : Node_Id;\n+      Typ  : Entity_Id;\n+      Proc : Node_Id);\n    --  If a composite type has invariants and also has components with defined\n    --  invariants. the component invariant procedure is inserted into the user-\n    --  defined invariant procedure and added to the checks to be performed.\n@@ -5197,8 +5197,8 @@ package body Exp_Ch3 is\n                if Ekind (Comp) = E_Component\n                  and then Chars (Comp) = Chars (Old_Comp)\n                then\n-                  Set_Discriminant_Checking_Func (Comp,\n-                    Discriminant_Checking_Func (Old_Comp));\n+                  Set_Discriminant_Checking_Func\n+                    (Comp, Discriminant_Checking_Func (Old_Comp));\n                end if;\n \n                Next_Component (Old_Comp);\n@@ -6083,20 +6083,19 @@ package body Exp_Ch3 is\n \n          --  Local variables\n \n-         Abrt_Blk   : Node_Id;\n-         Abrt_HSS   : Node_Id;\n-         Abrt_Id    : Entity_Id;\n-         Abrt_Stmts : List_Id;\n-         Aggr_Init  : Node_Id;\n-         Comp_Init  : List_Id := No_List;\n-         Fin_Call   : Node_Id;\n-         Fin_Stmts  : List_Id := No_List;\n-         Obj_Init   : Node_Id := Empty;\n-         Obj_Ref    : Node_Id;\n-\n-         Dummy : Entity_Id;\n-         --  This variable captures a dummy internal entity, see the comment\n-         --  associated with its use.\n+         Exceptions_OK : constant Boolean :=\n+                           not Restriction_Active (No_Exception_Propagation);\n+\n+         Abrt_Blk    : Node_Id;\n+         Abrt_Blk_Id : Entity_Id;\n+         Abrt_HSS    : Node_Id;\n+         Aggr_Init   : Node_Id;\n+         AUD         : Entity_Id;\n+         Comp_Init   : List_Id := No_List;\n+         Fin_Call    : Node_Id;\n+         Init_Stmts  : List_Id := No_List;\n+         Obj_Init    : Node_Id := Empty;\n+         Obj_Ref     : Node_Id;\n \n       --  Start of processing for Default_Initialize_Object\n \n@@ -6112,19 +6111,25 @@ package body Exp_Ch3 is\n             return;\n          end if;\n \n-         --  Step 1: Initialize the object\n+         --  The expansion performed by this routine is as follows:\n \n-         if Needs_Finalization (Typ) and then not No_Initialization (N) then\n-            Obj_Init :=\n-              Make_Init_Call\n-                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n-                 Typ     => Typ);\n-         end if;\n-\n-         --  Step 2: Initialize the components of the object\n+         --    begin\n+         --       Abort_Defer;\n+         --       Type_Init_Proc (Obj);\n+\n+         --       begin\n+         --          [Deep_]Initialize (Obj);\n+\n+         --       exception\n+         --          when others =>\n+         --             [Deep_]Finalize (Obj, Self => False);\n+         --             raise;\n+         --       end;\n+         --    at end\n+         --       Abort_Undefer_Direct;\n+         --    end;\n \n-         --  Do not initialize the components if their initialization is\n-         --  prohibited.\n+         --  Initialize the components of the object\n \n          if Has_Non_Null_Base_Init_Proc (Typ)\n            and then not No_Initialization (N)\n@@ -6154,7 +6159,8 @@ package body Exp_Ch3 is\n                elsif Build_Equivalent_Aggregate then\n                   null;\n \n-               --  Otherwise invoke the type init proc\n+               --  Otherwise invoke the type init proc, generate:\n+               --    Type_Init_Proc (Obj);\n \n                else\n                   Obj_Ref := New_Object_Reference;\n@@ -6182,41 +6188,35 @@ package body Exp_Ch3 is\n             Analyze_And_Resolve (Expression (N), Typ);\n          end if;\n \n-         --  Step 3: Add partial finalization and abort actions, generate:\n+         --  Initialize the object, generate:\n+         --    [Deep_]Initialize (Obj);\n+\n+         if Needs_Finalization (Typ) and then not No_Initialization (N) then\n+            Obj_Init :=\n+              Make_Init_Call\n+                (Obj_Ref => New_Occurrence_Of (Def_Id, Loc),\n+                 Typ     => Typ);\n+         end if;\n+\n+         --  Build a special finalization block when both the object and its\n+         --  controlled components are to be initialized. The block finalizes\n+         --  the components if the object initialization fails. Generate:\n \n-         --    Type_Init_Proc (Obj);\n          --    begin\n-         --       Deep_Initialize (Obj);\n+         --       <Obj_Init>\n+\n          --    exception\n          --       when others =>\n-         --          Deep_Finalize (Obj, Self => False);\n+         --          <Fin_Call>\n          --          raise;\n          --    end;\n \n-         --  Step 3a: Build the finalization block (if applicable)\n-\n-         --  The finalization block is required when both the object and its\n-         --  controlled components are to be initialized. The block finalizes\n-         --  the components if the object initialization fails.\n-\n          if Has_Controlled_Component (Typ)\n            and then Present (Comp_Init)\n            and then Present (Obj_Init)\n-           and then not Restriction_Active (No_Exception_Propagation)\n+           and then Exceptions_OK\n          then\n-            --  Generate:\n-            --    Type_Init_Proc (Obj);\n-\n-            Fin_Stmts := Comp_Init;\n-\n-            --  Generate:\n-            --    begin\n-            --       Deep_Initialize (Obj);\n-            --    exception\n-            --       when others =>\n-            --          Deep_Finalize (Obj, Self => False);\n-            --          raise;\n-            --    end;\n+            Init_Stmts := Comp_Init;\n \n             Fin_Call :=\n               Make_Final_Call\n@@ -6232,7 +6232,7 @@ package body Exp_Ch3 is\n \n                Set_No_Elaboration_Check (Fin_Call);\n \n-               Append_To (Fin_Stmts,\n+               Append_To (Init_Stmts,\n                  Make_Block_Statement (Loc,\n                    Declarations               => No_List,\n \n@@ -6250,100 +6250,93 @@ package body Exp_Ch3 is\n                              Make_Raise_Statement (Loc)))))));\n             end if;\n \n-         --  Finalization is not required, the initialization calls are passed\n-         --  to the abort block building circuitry, generate:\n+         --  Otherwise finalization is not required, the initialization calls\n+         --  are passed to the abort block building circuitry, generate:\n \n          --    Type_Init_Proc (Obj);\n-         --    Deep_Initialize (Obj);\n+         --    [Deep_]Initialize (Obj);\n \n          else\n             if Present (Comp_Init) then\n-               Fin_Stmts := Comp_Init;\n+               Init_Stmts := Comp_Init;\n             end if;\n \n             if Present (Obj_Init) then\n-               if No (Fin_Stmts) then\n-                  Fin_Stmts := New_List;\n+               if No (Init_Stmts) then\n+                  Init_Stmts := New_List;\n                end if;\n \n-               Append_To (Fin_Stmts, Obj_Init);\n+               Append_To (Init_Stmts, Obj_Init);\n             end if;\n          end if;\n \n-         --  Step 3b: Build the abort block (if applicable)\n-\n-         --  The abort block is required when aborts are allowed in order to\n-         --  protect both initialization calls.\n-\n-         if Present (Comp_Init) and then Present (Obj_Init) then\n-            if Abort_Allowed then\n-\n-               --  Generate:\n-               --    Abort_Defer;\n+         --  Build an abort block to protect the initialization calls\n \n-               Prepend_To\n-                 (Fin_Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n+         if Abort_Allowed\n+           and then Present (Comp_Init)\n+           and then Present (Obj_Init)\n+         then\n+            --  Generate:\n+            --    Abort_Defer;\n \n-               --  Generate:\n-               --    begin\n-               --       Abort_Defer;\n-               --       <finalization statements>\n-               --    at end\n-               --       Abort_Undefer_Direct;\n-               --    end;\n+            Prepend_To (Init_Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n \n-               declare\n-                  AUD : constant Entity_Id := RTE (RE_Abort_Undefer_Direct);\n+            --  When exceptions are propagated, abort deferral must take place\n+            --  in the presence of initialization or finalization exceptions.\n+            --  Generate:\n \n-               begin\n-                  Abrt_HSS :=\n-                    Make_Handled_Sequence_Of_Statements (Loc,\n-                      Statements  => Fin_Stmts,\n-                      At_End_Proc => New_Occurrence_Of (AUD, Loc));\n+            --    begin\n+            --       Abort_Defer;\n+            --       <Init_Stmts>\n+            --    at end\n+            --       Abort_Undefer_Direct;\n+            --    end;\n \n-                  --  Present the Abort_Undefer_Direct function to the backend\n-                  --  so that it can inline the call to the function.\n+            if Exceptions_OK then\n+               AUD := RTE (RE_Abort_Undefer_Direct);\n \n-                  Add_Inlined_Body (AUD, N);\n-               end;\n+               Abrt_HSS :=\n+                 Make_Handled_Sequence_Of_Statements (Loc,\n+                   Statements  => Init_Stmts,\n+                   At_End_Proc => New_Occurrence_Of (AUD, Loc));\n \n                Abrt_Blk :=\n                  Make_Block_Statement (Loc,\n-                   Declarations               => No_List,\n                    Handled_Statement_Sequence => Abrt_HSS);\n \n-               Add_Block_Identifier (Abrt_Blk, Abrt_Id);\n-               Expand_At_End_Handler (Abrt_HSS, Abrt_Id);\n+               Add_Block_Identifier  (Abrt_Blk, Abrt_Blk_Id);\n+               Expand_At_End_Handler (Abrt_HSS, Abrt_Blk_Id);\n \n-               Abrt_Stmts := New_List (Abrt_Blk);\n+               --  Present the Abort_Undefer_Direct function to the backend so\n+               --  that it can inline the call to the function.\n \n-            --  Abort is not required\n+               Add_Inlined_Body (AUD, N);\n \n-            else\n-               --  Generate a dummy entity to ensure that the internal symbols\n-               --  are in sync when a unit is compiled with and without aborts.\n-               --  The entity is a block with proper scope and type.\n+               Init_Stmts := New_List (Abrt_Blk);\n \n-               Dummy := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n-               Set_Etype (Dummy, Standard_Void_Type);\n-               Abrt_Stmts := Fin_Stmts;\n-            end if;\n+            --  Otherwise exceptions are not propagated. Generate:\n \n-         --  No initialization calls present\n+            --    Abort_Defer;\n+            --    <Init_Stmts>\n+            --    Abort_Undefer;\n \n-         else\n-            Abrt_Stmts := Fin_Stmts;\n+            else\n+               Append_To (Init_Stmts,\n+                 Build_Runtime_Call (Loc, RE_Abort_Undefer));\n+            end if;\n          end if;\n \n-         --  Step 4: Insert the whole initialization sequence into the tree\n-         --  If the object has a delayed freeze, as will be the case when\n-         --  it has aspect specifications, the initialization sequence is\n-         --  part of the freeze actions.\n+         --  Insert the whole initialization sequence into the tree. If the\n+         --  object has a delayed freeze, as will be the case when it has\n+         --  aspect specifications, the initialization sequence is part of\n+         --  the freeze actions.\n \n-         if Has_Delayed_Freeze (Def_Id) then\n-            Append_Freeze_Actions (Def_Id, Abrt_Stmts);\n-         else\n-            Insert_Actions_After (After, Abrt_Stmts);\n+         if Present (Init_Stmts) then\n+            if Has_Delayed_Freeze (Def_Id) then\n+               Append_Freeze_Actions (Def_Id, Init_Stmts);\n+            else\n+               Insert_Actions_After (After, Init_Stmts);\n+            end if;\n          end if;\n       end Default_Initialize_Object;\n "}, {"sha": "f5b97e2340cde40ffedb35f87b7d8dc45342acfa", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 79, "deletions": 92, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -1323,13 +1323,6 @@ package body Exp_Ch7 is\n       ----------------------\n \n       procedure Create_Finalizer is\n-         Body_Id    : Entity_Id;\n-         Fin_Body   : Node_Id;\n-         Fin_Spec   : Node_Id;\n-         Jump_Block : Node_Id;\n-         Label      : Node_Id;\n-         Label_Id   : Entity_Id;\n-\n          function New_Finalizer_Name return Name_Id;\n          --  Create a fully qualified name of a package spec or body finalizer.\n          --  The generated name is of the form: xx__yy__finalize_[spec|body].\n@@ -1380,6 +1373,15 @@ package body Exp_Ch7 is\n             return Name_Find;\n          end New_Finalizer_Name;\n \n+         --  Local variables\n+\n+         Body_Id    : Entity_Id;\n+         Fin_Body   : Node_Id;\n+         Fin_Spec   : Node_Id;\n+         Jump_Block : Node_Id;\n+         Label      : Node_Id;\n+         Label_Id   : Entity_Id;\n+\n       --  Start of processing for Create_Finalizer\n \n       begin\n@@ -1532,16 +1534,17 @@ package body Exp_Ch7 is\n \n          --  Protect the statements with abort defer/undefer. This is only when\n          --  aborts are allowed and the clean up statements require deferral or\n-         --  there are controlled objects to be finalized.\n+         --  there are controlled objects to be finalized. Note that the abort\n+         --  defer/undefer pair does not require an extra block because each\n+         --  finalization exception is caught in its corresponding finalization\n+         --  block. As a result, the call to Abort_Defer always takes place.\n \n          if Abort_Allowed and then (Defer_Abort or Has_Ctrl_Objs) then\n             Prepend_To (Finalizer_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Abort_Defer), Loc)));\n+              Build_Runtime_Call (Loc, RE_Abort_Defer));\n \n             Append_To (Finalizer_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc)));\n+              Build_Runtime_Call (Loc, RE_Abort_Undefer));\n          end if;\n \n          --  The local exception does not need to be reraised for library-level\n@@ -1596,7 +1599,8 @@ package body Exp_Ch7 is\n                  Defining_Unit_Name => Body_Id),\n              Declarations               => Finalizer_Decls,\n              Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc, Finalizer_Stmts));\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Finalizer_Stmts));\n \n          --  Step 4: Spec and body insertion, analysis\n \n@@ -2806,9 +2810,7 @@ package body Exp_Ch7 is\n \n          else\n             --  Generate:\n-            --    [Deep_]Finalize (Obj);  --  No_Exception_Propagation\n-\n-            --    begin                   --  Exception handlers allowed\n+            --    begin\n             --       [Deep_]Finalize (Obj);\n \n             --    exception\n@@ -4727,6 +4729,8 @@ package body Exp_Ch7 is\n          --       Raised : Boolean := False;\n \n          --    begin\n+         --       Abort_Defer;\n+\n          --       begin\n          --          Hook_N := null;\n          --          [Deep_]Finalize (Ctrl_Trans_Obj_N);\n@@ -4752,26 +4756,8 @@ package body Exp_Ch7 is\n          --       if Raised and not Abrt then\n          --          Raise_From_Controlled_Operation (Ex);\n          --       end if;\n-         --    end;\n-\n-         --  When restriction No_Exception_Propagation is active, the expansion\n-         --  is as follows:\n \n-         --    type Ptr_Typ_1 is access all Ctrl_Trans_Obj_1_Typ;\n-         --    Hook_1 : Ptr_Typ_1 := null;\n-         --    Ctrl_Trans_Obj_1 : ...;\n-         --    Hook_1 := Ctrl_Trans_Obj_1'Unrestricted_Access;\n-         --    . . .\n-         --    type Ptr_Typ_N is access all Ctrl_Trans_Obj_N_Typ;\n-         --    Hook_N : Ptr_Typ_N := null;\n-         --    Ctrl_Trans_Obj_N : ...;\n-         --    Hook_N := Ctrl_Trans_Obj_N'Unrestricted_Access;\n-\n-         --    begin\n-         --       Hook_N := null;\n-         --       [Deep_]Finalize (Ctrl_Trans_Obj_N);\n-         --       Hook_1 := null;\n-         --       [Deep_]Finalize (Ctrl_Trans_Obj_1);\n+         --       Abort_Undefer_Direct;\n          --    end;\n \n          --  Recognize a scenario where the transient context is an object\n@@ -4983,6 +4969,7 @@ package body Exp_Ch7 is\n                --  When exception propagation is enabled wrap the hook clear\n                --  statement and the finalization call into a block to catch\n                --  potential exceptions raised during finalization. Generate:\n+\n                --    begin\n                --       [Temp := null;]\n                --       [Deep_]Finalize (Obj_Ref);\n@@ -5037,6 +5024,20 @@ package body Exp_Ch7 is\n          end loop;\n \n          if Present (Blk_Decl) then\n+\n+            --  Note that the abort defer / undefer pair does not require an\n+            --  extra block because each finalization exception is caught in\n+            --  its corresponding finalization block. As a result, the call to\n+            --  Abort_Defer always takes place.\n+\n+            if Abort_Allowed then\n+               Prepend_To (Blk_Stmts,\n+                 Build_Runtime_Call (Loc, RE_Abort_Defer));\n+\n+               Append_To (Blk_Stmts,\n+                 Build_Runtime_Call (Loc, RE_Abort_Undefer));\n+            end if;\n+\n             Insert_After_And_Analyze (Blk_Ins, Blk_Decl);\n          end if;\n       end Process_Transient_Objects;\n@@ -5428,10 +5429,13 @@ package body Exp_Ch7 is\n       function Build_Adjust_Or_Finalize_Statements\n         (Typ : Entity_Id) return List_Id\n       is\n-         Comp_Typ        : constant Entity_Id  := Component_Type (Typ);\n-         Index_List      : constant List_Id    := New_List;\n-         Loc             : constant Source_Ptr := Sloc (Typ);\n-         Num_Dims        : constant Int        := Number_Dimensions (Typ);\n+         Comp_Typ       : constant Entity_Id  := Component_Type (Typ);\n+         Exceptions_OK  : constant Boolean    :=\n+                            not Restriction_Active (No_Exception_Propagation);\n+         Index_List     : constant List_Id    := New_List;\n+         Loc            : constant Source_Ptr := Sloc (Typ);\n+         Num_Dims       : constant Int        := Number_Dimensions (Typ);\n+\n          Finalizer_Decls : List_Id := No_List;\n          Finalizer_Data  : Finalization_Exception_Data;\n          Call            : Node_Id;\n@@ -5442,9 +5446,6 @@ package body Exp_Ch7 is\n          Loop_Id         : Entity_Id;\n          Stmts           : List_Id;\n \n-         Exceptions_OK : constant Boolean :=\n-                           not Restriction_Active (No_Exception_Propagation);\n-\n          procedure Build_Indexes;\n          --  Generate the indexes used in the dimension loops\n \n@@ -5492,9 +5493,7 @@ package body Exp_Ch7 is\n \n          --  Generate the block which houses the adjust or finalize call:\n \n-         --    <adjust or finalize call>;  --  No_Exception_Propagation\n-\n-         --    begin                       --  Exception handlers allowed\n+         --    begin\n          --       <adjust or finalize call>\n \n          --    exception\n@@ -5567,16 +5566,15 @@ package body Exp_Ch7 is\n          --    begin\n          --       <core loop>\n \n-         --       if Raised and then not Abort then  --  Expection handlers OK\n+         --       if Raised and then not Abort then\n          --          Raise_From_Controlled_Operation (E);\n          --       end if;\n          --    end;\n \n          Stmts := New_List (Core_Loop);\n \n          if Exceptions_OK then\n-            Append_To (Stmts,\n-              Build_Raise_Statement (Finalizer_Data));\n+            Append_To (Stmts, Build_Raise_Statement (Finalizer_Data));\n          end if;\n \n          return\n@@ -5593,11 +5591,14 @@ package body Exp_Ch7 is\n       ---------------------------------\n \n       function Build_Initialize_Statements (Typ : Entity_Id) return List_Id is\n-         Comp_Typ        : constant Entity_Id  := Component_Type (Typ);\n-         Final_List      : constant List_Id    := New_List;\n-         Index_List      : constant List_Id    := New_List;\n-         Loc             : constant Source_Ptr := Sloc (Typ);\n-         Num_Dims        : constant Int        := Number_Dimensions (Typ);\n+         Comp_Typ       : constant Entity_Id  := Component_Type (Typ);\n+         Exceptions_OK  : constant Boolean    :=\n+                            not Restriction_Active (No_Exception_Propagation);\n+         Final_List     : constant List_Id    := New_List;\n+         Index_List     : constant List_Id    := New_List;\n+         Loc            : constant Source_Ptr := Sloc (Typ);\n+         Num_Dims       : constant Int        := Number_Dimensions (Typ);\n+\n          Counter_Id      : Entity_Id;\n          Dim             : Int;\n          F               : Node_Id;\n@@ -5611,9 +5612,6 @@ package body Exp_Ch7 is\n          Loop_Id         : Node_Id;\n          Stmts           : List_Id;\n \n-         Exceptions_OK : constant Boolean :=\n-                           not Restriction_Active (No_Exception_Propagation);\n-\n          function Build_Counter_Assignment return Node_Id;\n          --  Generate the following assignment:\n          --    Counter := V'Length (1) *\n@@ -5751,9 +5749,7 @@ package body Exp_Ch7 is\n          --    if Counter > 0 then\n          --       Counter := Counter - 1;\n          --    else\n-         --       [Deep_]Finalize (V (F1, ..., FN));  --  No_Except_Propagation\n-\n-         --       begin                               --  Exceptions allowed\n+         --       begin\n          --          [Deep_]Finalize (V (F1, ..., FN));\n          --       exception\n          --          when others =>\n@@ -5852,18 +5848,17 @@ package body Exp_Ch7 is\n \n          --       <final loop>\n \n-         --       if Raised and then not Abort then  --  Exception handlers OK\n+         --       if Raised and then not Abort then\n          --          Raise_From_Controlled_Operation (E);\n          --       end if;\n \n-         --       raise;  --  Exception handlers OK\n+         --       raise;\n          --    end;\n \n          Stmts := New_List (Build_Counter_Assignment, Final_Loop);\n \n          if Exceptions_OK then\n-            Append_To (Stmts,\n-              Build_Raise_Statement (Finalizer_Data));\n+            Append_To (Stmts, Build_Raise_Statement (Finalizer_Data));\n             Append_To (Stmts, Make_Raise_Statement (Loc));\n          end if;\n \n@@ -6243,17 +6238,17 @@ package body Exp_Ch7 is\n       -----------------------------\n \n       function Build_Adjust_Statements (Typ : Entity_Id) return List_Id is\n-         Loc             : constant Source_Ptr := Sloc (Typ);\n-         Typ_Def         : constant Node_Id := Type_Definition (Parent (Typ));\n+         Exceptions_OK  : constant Boolean    :=\n+                            not Restriction_Active (No_Exception_Propagation);\n+         Loc            : constant Source_Ptr := Sloc (Typ);\n+         Typ_Def        : constant Node_Id := Type_Definition (Parent (Typ));\n+\n          Bod_Stmts       : List_Id;\n          Finalizer_Data  : Finalization_Exception_Data;\n          Finalizer_Decls : List_Id := No_List;\n          Rec_Def         : Node_Id;\n          Var_Case        : Node_Id;\n \n-         Exceptions_OK : constant Boolean :=\n-                           not Restriction_Active (No_Exception_Propagation);\n-\n          function Process_Component_List_For_Adjust\n            (Comps : Node_Id) return List_Id;\n          --  Build all necessary adjust statements for a single component list\n@@ -6285,11 +6280,9 @@ package body Exp_Ch7 is\n                Adj_Stmt : Node_Id;\n \n             begin\n-               --  Generate:\n-               --    [Deep_]Adjust (V.Id);  --  No_Exception_Propagation\n-\n-               --    begin                  --  Exception handlers allowed\n+               --    begin\n                --       [Deep_]Adjust (V.Id);\n+\n                --    exception\n                --       when others =>\n                --          if not Raised then\n@@ -6523,10 +6516,9 @@ package body Exp_Ch7 is\n                        Skip_Self => True);\n \n                   --  Generate:\n-                  --    Deep_Adjust (V._parent, False);  --  No_Except_Propagat\n-\n-                  --    begin                            --  Exceptions OK\n+                  --    begin\n                   --       Deep_Adjust (V._parent, False);\n+\n                   --    exception\n                   --       when Id : others =>\n                   --          if not Raised then\n@@ -6568,10 +6560,9 @@ package body Exp_Ch7 is\n \n                --  Generate:\n                --    if F then\n-               --       Adjust (V);  --  No_Exception_Propagation\n-\n-               --       begin        --  Exception handlers allowed\n+               --       begin\n                --          Adjust (V);\n+\n                --       exception\n                --          when others =>\n                --             if not Raised then\n@@ -6635,8 +6626,7 @@ package body Exp_Ch7 is\n \n          else\n             if Exceptions_OK then\n-               Append_To (Bod_Stmts,\n-                 Build_Raise_Statement (Finalizer_Data));\n+               Append_To (Bod_Stmts, Build_Raise_Statement (Finalizer_Data));\n             end if;\n \n             return\n@@ -6654,18 +6644,18 @@ package body Exp_Ch7 is\n       -------------------------------\n \n       function Build_Finalize_Statements (Typ : Entity_Id) return List_Id is\n-         Loc             : constant Source_Ptr := Sloc (Typ);\n-         Typ_Def         : constant Node_Id := Type_Definition (Parent (Typ));\n+         Exceptions_OK  : constant Boolean    :=\n+                            not Restriction_Active (No_Exception_Propagation);\n+         Loc            : constant Source_Ptr := Sloc (Typ);\n+         Typ_Def        : constant Node_Id := Type_Definition (Parent (Typ));\n+\n          Bod_Stmts       : List_Id;\n          Counter         : Int := 0;\n          Finalizer_Data  : Finalization_Exception_Data;\n          Finalizer_Decls : List_Id := No_List;\n          Rec_Def         : Node_Id;\n          Var_Case        : Node_Id;\n \n-         Exceptions_OK : constant Boolean :=\n-                           not Restriction_Active (No_Exception_Propagation);\n-\n          function Process_Component_List_For_Finalize\n            (Comps : Node_Id) return List_Id;\n          --  Build all necessary finalization statements for a single component\n@@ -7096,10 +7086,9 @@ package body Exp_Ch7 is\n                        Skip_Self => True);\n \n                   --  Generate:\n-                  --    Deep_Finalize (V._parent, False);  --  No_Except_Propag\n-\n-                  --    begin                              --  Exceptions OK\n+                  --    begin\n                   --       Deep_Finalize (V._parent, False);\n+\n                   --    exception\n                   --       when Id : others =>\n                   --          if not Raised then\n@@ -7142,10 +7131,9 @@ package body Exp_Ch7 is\n \n                --  Generate:\n                --    if F then\n-               --       Finalize (V);  --  No_Exception_Propagation\n-\n                --       begin\n                --          Finalize (V);\n+\n                --       exception\n                --          when others =>\n                --             if not Raised then\n@@ -7207,8 +7195,7 @@ package body Exp_Ch7 is\n \n          else\n             if Exceptions_OK then\n-               Append_To (Bod_Stmts,\n-                 Build_Raise_Statement (Finalizer_Data));\n+               Append_To (Bod_Stmts, Build_Raise_Statement (Finalizer_Data));\n             end if;\n \n             return"}, {"sha": "07dfb9bdc3e0753c9290f95c57463c0196f54615", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 59, "deletions": 73, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -4315,36 +4315,41 @@ package body Exp_Ch9 is\n       if Nkind (Op_Spec) = N_Function_Specification then\n          if Exc_Safe then\n             R := Make_Temporary (Loc, 'R');\n+\n             Unprot_Call :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => R,\n-                Constant_Present => True,\n-                Object_Definition => New_Copy (Result_Definition (N_Op_Spec)),\n-                Expression =>\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Copy (Result_Definition (N_Op_Spec)),\n+                Expression          =>\n                   Make_Function_Call (Loc,\n-                    Name => Make_Identifier (Loc,\n-                      Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                    Name                   =>\n+                      Make_Identifier (Loc,\n+                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n                     Parameter_Associations => Uactuals));\n \n             Return_Stmt :=\n               Make_Simple_Return_Statement (Loc,\n                 Expression => New_Occurrence_Of (R, Loc));\n \n          else\n-            Unprot_Call := Make_Simple_Return_Statement (Loc,\n-              Expression => Make_Function_Call (Loc,\n-                Name =>\n-                  Make_Identifier (Loc,\n-                    Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n-                Parameter_Associations => Uactuals));\n+            Unprot_Call :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name                   =>\n+                      Make_Identifier (Loc,\n+                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                    Parameter_Associations => Uactuals));\n          end if;\n \n          Lock_Kind := RE_Lock_Read_Only;\n \n       else\n          Unprot_Call :=\n            Make_Procedure_Call_Statement (Loc,\n-             Name =>\n+             Name                   =>\n                Make_Identifier (Loc, Chars (Defining_Unit_Name (N_Op_Spec))),\n              Parameter_Associations => Uactuals);\n \n@@ -4354,10 +4359,11 @@ package body Exp_Ch9 is\n       --  Wrap call in block that will be covered by an at_end handler\n \n       if not Exc_Safe then\n-         Unprot_Call := Make_Block_Statement (Loc,\n-           Handled_Statement_Sequence =>\n-             Make_Handled_Sequence_Of_Statements (Loc,\n-               Statements => New_List (Unprot_Call)));\n+         Unprot_Call :=\n+           Make_Block_Statement (Loc,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Unprot_Call)));\n       end if;\n \n       --  Make the protected subprogram body. This locks the protected\n@@ -4379,21 +4385,20 @@ package body Exp_Ch9 is\n \n       Object_Parm :=\n         Make_Attribute_Reference (Loc,\n-           Prefix =>\n+           Prefix         =>\n              Make_Selected_Component (Loc,\n                Prefix        => Make_Identifier (Loc, Name_uObject),\n                Selector_Name => Make_Identifier (Loc, Name_uObject)),\n            Attribute_Name => Name_Unchecked_Access);\n \n-      Lock_Stmt := Make_Procedure_Call_Statement (Loc,\n-        Name => Lock_Name,\n-        Parameter_Associations => New_List (Object_Parm));\n+      Lock_Stmt :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => Lock_Name,\n+          Parameter_Associations => New_List (Object_Parm));\n \n       if Abort_Allowed then\n          Stmts := New_List (\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Abort_Defer), Loc),\n-             Parameter_Associations => Empty_List),\n+           Build_Runtime_Call (Loc, RE_Abort_Defer),\n            Lock_Stmt);\n \n       else\n@@ -4417,20 +4422,21 @@ package body Exp_Ch9 is\n          Build_Protected_Subprogram_Call_Cleanup (Op_Spec, Pid, Loc, Stmts);\n \n          if Nkind (Op_Spec) = N_Function_Specification then\n-            Append (Return_Stmt, Stmts);\n-            Append (Make_Block_Statement (Loc,\n-              Declarations => New_List (Unprot_Call),\n-              Handled_Statement_Sequence =>\n-                Make_Handled_Sequence_Of_Statements (Loc,\n-                  Statements => Stmts)), Pre_Stmts);\n+            Append_To (Stmts, Return_Stmt);\n+            Append_To (Pre_Stmts,\n+              Make_Block_Statement (Loc,\n+                Declarations               => New_List (Unprot_Call),\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => Stmts)));\n             Stmts := Pre_Stmts;\n          end if;\n       end if;\n \n       Sub_Body :=\n         Make_Subprogram_Body (Loc,\n-          Declarations => Empty_List,\n-          Specification => P_Op_Spec,\n+          Declarations               => Empty_List,\n+          Specification              => P_Op_Spec,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts));\n \n@@ -4594,11 +4600,7 @@ package body Exp_Ch9 is\n       --    Abort_Undefer;\n \n       if Abort_Allowed then\n-         Append_To (Stmts,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc),\n-             Parameter_Associations => Empty_List));\n+         Append_To (Stmts, Build_Runtime_Call (Loc, RE_Abort_Undefer));\n       end if;\n    end Build_Protected_Subprogram_Call_Cleanup;\n \n@@ -7169,6 +7171,8 @@ package body Exp_Ch9 is\n                Name => New_Occurrence_Of (Proc, Loc)));\n       end Rewrite_Abortable_Part;\n \n+   --  Start of processing for Expand_N_Asynchronous_Select\n+\n    begin\n       Process_Statements_For_Controlled_Objects (Trig);\n       Process_Statements_For_Controlled_Objects (Abrt);\n@@ -7426,34 +7430,28 @@ package body Exp_Ch9 is\n                       Name_uDisp_Asynchronous_Select),\n                     Loc),\n \n-                Parameter_Associations =>\n-                  New_List (\n-                    New_Copy_Tree (Obj),             --  <object>\n-                    New_Occurrence_Of (S, Loc),       --  S\n-                    Make_Attribute_Reference (Loc,   --  P'Address\n-                      Prefix         => New_Occurrence_Of (P, Loc),\n-                      Attribute_Name => Name_Address),\n-                    Make_Identifier (Loc, Name_uD),  --  D\n-                    New_Occurrence_Of (B, Loc))));    --  B\n+                Parameter_Associations => New_List (\n+                  New_Copy_Tree (Obj),             --  <object>\n+                  New_Occurrence_Of (S, Loc),      --  S\n+                  Make_Attribute_Reference (Loc,   --  P'Address\n+                    Prefix         => New_Occurrence_Of (P, Loc),\n+                    Attribute_Name => Name_Address),\n+                  Make_Identifier (Loc, Name_uD),  --  D\n+                  New_Occurrence_Of (B, Loc))));   --  B\n \n             --  Generate:\n             --    Abort_Defer;\n \n-            Prepend_To (TaskE_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Abort_Defer), Loc),\n-                Parameter_Associations => No_List));\n+            Prepend_To (TaskE_Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n \n             --  Generate:\n             --    Abort_Undefer;\n             --    <abortable-statements>\n \n             Cleanup_Stmts := New_Copy_List_Tree (Astats);\n \n-            Prepend_To (Cleanup_Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc),\n-                Parameter_Associations => No_List));\n+            Prepend_To\n+              (Cleanup_Stmts, Build_Runtime_Call (Loc, RE_Abort_Undefer));\n \n             --  Wrap the statements in a block. Exp_Ch7.Expand_Cleanup_Actions\n             --  will generate a _clean for the additional status flag.\n@@ -7640,9 +7638,7 @@ package body Exp_Ch9 is\n \n             Hdle := New_List (Build_Abort_Block_Handler (Loc));\n \n-            Prepend_To (Astats,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc)));\n+            Prepend_To (Astats, Build_Runtime_Call (Loc, RE_Abort_Undefer));\n \n             Abortable_Block :=\n               Make_Block_Statement (Loc,\n@@ -7788,17 +7784,14 @@ package body Exp_Ch9 is\n              Has_Created_Identifier => True,\n              Is_Asynchronous_Call_Block => True);\n \n-         if Exception_Mechanism = Back_End_Exceptions then\n-\n-            --  Aborts are not deferred at beginning of exception handlers\n-            --  in ZCX.\n+         --  Aborts are not deferred at beginning of exception handlers in\n+         --  ZCX.\n \n+         if Exception_Mechanism = Back_End_Exceptions then\n             Handler_Stmt := Make_Null_Statement (Loc);\n \n          else\n-            Handler_Stmt := Make_Procedure_Call_Statement (Loc,\n-              Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc),\n-              Parameter_Associations => No_List);\n+            Handler_Stmt := Build_Runtime_Call (Loc, RE_Abort_Undefer);\n          end if;\n \n          Stmts := New_List (\n@@ -7881,9 +7874,7 @@ package body Exp_Ch9 is\n \n          Hdle := New_List (Build_Abort_Block_Handler (Loc));\n \n-         Prepend_To (Astats,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Loc)));\n+         Prepend_To (Astats, Build_Runtime_Call (Loc, RE_Abort_Undefer));\n \n          Abortable_Block :=\n            Make_Block_Statement (Loc,\n@@ -7927,10 +7918,7 @@ package body Exp_Ch9 is\n \n          --  Protected the call against abort\n \n-         Prepend_To (Stmts,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Abort_Defer), Loc),\n-             Parameter_Associations => Empty_List));\n+         Prepend_To (Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n       end if;\n \n       Set_Entry_Cancel_Parameter (Blk_Ent, Cancel_Param);\n@@ -10762,9 +10750,7 @@ package body Exp_Ch9 is\n             --  analysis with unknown calls, so don't do it.\n \n             if not CodePeer_Mode then\n-               Call :=\n-                 Make_Procedure_Call_Statement (Eloc,\n-                   Name => New_Occurrence_Of (RTE (RE_Abort_Undefer), Eloc));\n+               Call := Build_Runtime_Call (Loc, RE_Abort_Undefer);\n                Insert_Before\n                  (First (Statements (Handled_Statement_Sequence\n                                        (Accept_Statement (Alt)))),"}, {"sha": "ab30c1f6a056f8237812ca1031ff9d967c998d30", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -1022,6 +1022,7 @@ package body Exp_Intr is\n \n       Abrt_Blk    : Node_Id := Empty;\n       Abrt_Blk_Id : Entity_Id;\n+      Abrt_HSS    : Node_Id;\n       AUD         : Entity_Id;\n       Fin_Blk     : Node_Id;\n       Fin_Call    : Node_Id;\n@@ -1031,10 +1032,6 @@ package body Exp_Intr is\n       Gen_Code    : Node_Id;\n       Obj_Ref     : Node_Id;\n \n-      Dummy : Entity_Id;\n-      --  This variable captures an unused dummy internal entity, see the\n-      --  comment associated with its use.\n-\n    begin\n       --  Nothing to do if we know the argument is null\n \n@@ -1048,10 +1045,10 @@ package body Exp_Intr is\n       --    Ex     : Exception_Occurrence;\n       --    Raised : Boolean := False;\n \n-      --    begin                             --  aborts allowed\n+      --    begin\n       --       Abort_Defer;\n \n-      --       begin                          --  exception propagation allowed\n+      --       begin\n       --          [Deep_]Finalize (Obj_Ref);\n \n       --       exception\n@@ -1121,50 +1118,51 @@ package body Exp_Intr is\n                     Exception_Handlers => New_List (\n                       Build_Exception_Handler (Fin_Data))));\n \n-            --  The finalization action must be protected by an abort defer\n-            --  undefer pair when aborts are allowed. Generate:\n+         --  Otherwise exception propagation is not allowed\n \n-            --    begin\n-            --       Abort_Defer;\n-            --       <Fin_Blk>\n-            --    at end\n-            --       Abort_Undefer_Direct;\n-            --    end;\n+         else\n+            Fin_Blk := Fin_Call;\n+         end if;\n \n-            if Abort_Allowed then\n-               AUD := RTE (RE_Abort_Undefer_Direct);\n+         --  The finalization action must be protected by an abort defer and\n+         --  undefer pair when aborts are allowed. Generate:\n \n-               Abrt_Blk :=\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements  => New_List (\n-                         Build_Runtime_Call (Loc, RE_Abort_Defer),\n-                         Fin_Blk),\n-                       At_End_Proc => New_Occurrence_Of (AUD, Loc)));\n+         --    begin\n+         --       Abort_Defer;\n+         --       <Fin_Blk>\n+         --    at end\n+         --       Abort_Undefer_Direct;\n+         --    end;\n \n-               Add_Block_Identifier (Abrt_Blk, Abrt_Blk_Id);\n+         if Abort_Allowed then\n+            AUD := RTE (RE_Abort_Undefer_Direct);\n \n-               --  Present the Abort_Undefer_Direct function to the backend so\n-               --  that it can inline the call to the function.\n+            Abrt_HSS :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements  => New_List (\n+                  Build_Runtime_Call (Loc, RE_Abort_Defer),\n+                  Fin_Blk),\n+                At_End_Proc => New_Occurrence_Of (AUD, Loc));\n \n-               Add_Inlined_Body (AUD, N);\n-               Append_To (Stmts, Abrt_Blk);\n+            Abrt_Blk :=\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence => Abrt_HSS);\n \n-            --  Otherwise aborts are not allowed. Generate a dummy entity to\n-            --  ensure that the internal symbols are in sync when a unit is\n-            --  compiled with and without aborts.\n+            Add_Block_Identifier  (Abrt_Blk, Abrt_Blk_Id);\n+            Expand_At_End_Handler (Abrt_HSS, Abrt_Blk_Id);\n \n-            else\n-               Dummy := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n-               Append_To (Stmts, Fin_Blk);\n-            end if;\n+            --  Present the Abort_Undefer_Direct function to the backend so\n+            --  that it can inline the call to the function.\n \n-         --  Otherwise exception propagation is not allowed\n+            Add_Inlined_Body (AUD, N);\n+\n+         --  Otherwise aborts are not allowed\n \n          else\n-            Append_To (Stmts, Fin_Call);\n+            Abrt_Blk := Fin_Blk;\n          end if;\n+\n+         Append_To (Stmts, Abrt_Blk);\n       end if;\n \n       --  For a task type, call Free_Task before freeing the ATCB. We used to\n@@ -1174,8 +1172,8 @@ package body Exp_Intr is\n       --  (the task will be freed once it terminates).\n \n       if Is_Task_Type (Desig_Typ) then\n-         Append_To\n-           (Stmts, Cleanup_Task (N, Duplicate_Subexpr_No_Checks (Arg)));\n+         Append_To (Stmts,\n+           Cleanup_Task (N, Duplicate_Subexpr_No_Checks (Arg)));\n \n       --  For composite types that contain tasks, recurse over the structure\n       --  to build the selectors for the task subcomponents.\n@@ -1411,15 +1409,6 @@ package body Exp_Intr is\n \n       Rewrite (N, Gen_Code);\n       Analyze (N);\n-\n-      --  If we generated a block with an At_End_Proc, expand the exception\n-      --  handler. We need to wait until after everything else is analyzed.\n-\n-      if Present (Abrt_Blk) then\n-         Expand_At_End_Handler\n-           (HSS    => Handled_Statement_Sequence (Abrt_Blk),\n-            Blk_Id => Entity (Identifier (Abrt_Blk)));\n-      end if;\n    end Expand_Unc_Deallocation;\n \n    -----------------------"}, {"sha": "3d534bdcec51a6fc5897e78b9986054d27317ee5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -9453,19 +9453,4 @@ package body Exp_Util is\n         and then not Is_Predicate_Function_M (S);\n    end Within_Internal_Subprogram;\n \n-   ----------------------------\n-   -- Wrap_Cleanup_Procedure --\n-   ----------------------------\n-\n-   procedure Wrap_Cleanup_Procedure (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Stseq : constant Node_Id    := Handled_Statement_Sequence (N);\n-      Stmts : constant List_Id    := Statements (Stseq);\n-   begin\n-      if Abort_Allowed then\n-         Prepend_To (Stmts, Build_Runtime_Call (Loc, RE_Abort_Defer));\n-         Append_To  (Stmts, Build_Runtime_Call (Loc, RE_Abort_Undefer));\n-      end if;\n-   end Wrap_Cleanup_Procedure;\n-\n end Exp_Util;"}, {"sha": "1357b3b1a97ba0db8f98f40c6f6b37d11c91742a", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf911b58345771e3be025a0b132912df4f566bd/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=7bf911b58345771e3be025a0b132912df4f566bd", "patch": "@@ -1020,15 +1020,6 @@ package Exp_Util is\n    --  predefined primitive operation. Some expansion activity (e.g. predicate\n    --  checks) is disabled in such.\n \n-   procedure Wrap_Cleanup_Procedure (N : Node_Id);\n-   --  Given an N_Subprogram_Body node, this procedure adds an Abort_Defer call\n-   --  at the start of the statement sequence, and an Abort_Undefer call at the\n-   --  end of the statement sequence. All cleanup routines (i.e. those that are\n-   --  called from \"at end\" handlers) must defer abort on entry and undefer\n-   --  abort on exit. Note that it is assumed that the code for the procedure\n-   --  does not contain any return statements which would allow the flow of\n-   --  control to escape doing the undefer call.\n-\n private\n    pragma Inline (Duplicate_Subexpr);\n    pragma Inline (Force_Evaluation);"}]}