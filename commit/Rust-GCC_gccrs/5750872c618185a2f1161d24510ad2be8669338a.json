{"sha": "5750872c618185a2f1161d24510ad2be8669338a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1MDg3MmM2MTgxODVhMmYxMTYxZDI0NTEwYWQyYmU4NjY5MzM4YQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-24T17:00:19Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-24T17:00:19Z"}, "message": "In libobjc/: 2010-12-24 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc/runtime.h (sel_getType): Renamed to sel_getTypeEncoding to\n\tbe consistent with method_getTypeEncoding and\n\tivar_getTypeEncoding.\n\t(sel_copyTypedSelectorList, sel_getTypedSelector): New.\n\t* selector.c (sel_getType): Renamed to sel_getTypeEncoding.\n\t(sel_copyTypedSelectorList, sel_getTypedSelector): New.\n\t(sel_get_type): Updated call to sel_getType.\n\t\nIn gcc/testsuite/:\n2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/gnu-api-2-sel.m: Updated for renaming of sel_getType to\n\tsel_getTypeEncoding.  Test that sel_getTypeEncoding returns NULL\n\twhen called with a NULL argument.  Added test for\n\tsel_copyTypedSelectorList and sel_getTypedSelector.\n\t* obj-c++.dg/gnu-api-2-sel.mm: Same changes.\n\nFrom-SVN: r168229", "tree": {"sha": "ee1e4e206c47305a511d45251f60fad046dd3233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee1e4e206c47305a511d45251f60fad046dd3233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5750872c618185a2f1161d24510ad2be8669338a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5750872c618185a2f1161d24510ad2be8669338a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5750872c618185a2f1161d24510ad2be8669338a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5750872c618185a2f1161d24510ad2be8669338a/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e66d38fe0510d448d35968205fdb79a6a1b2f675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66d38fe0510d448d35968205fdb79a6a1b2f675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66d38fe0510d448d35968205fdb79a6a1b2f675"}], "stats": {"total": 300, "additions": 285, "deletions": 15}, "files": [{"sha": "0140ced82d4f1cdbab0b3dd3bb1021f140300357", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -1,3 +1,11 @@\n+2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/gnu-api-2-sel.m: Updated for renaming of sel_getType to\n+\tsel_getTypeEncoding.  Test that sel_getTypeEncoding returns NULL\n+\twhen called with a NULL argument.  Added test for\n+\tsel_copyTypedSelectorList and sel_getTypedSelector.\n+\t* obj-c++.dg/gnu-api-2-sel.mm: Same changes.\n+\t\n 2010-12-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt13_pkg.ad[sb]: Fix line ending."}, {"sha": "956ba29ca838e8ea7f1a46ed536c0197923ed453", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-sel.mm", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-sel.mm?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -35,18 +35,44 @@ @interface MySubClass : MyRootClass <MyProtocol>\n { id variable_ivar; }\n - (void) setVariable: (id)value;\n - (id) variable;\n+- (void) method;\n @end\n \n @implementation MySubClass\n - (void) setVariable: (id)value { variable_ivar = value; }\n - (id) variable { return variable_ivar; }\n+- (void) method { return; }\n @end\n \n \n int main ()\n {\n   /* Functions are tested in alphabetical order.  */\n \n+  std::cout << \"Testing sel_copyTypedSelectorList ()...\\n\";\n+  {\n+    unsigned int count;\n+    SEL * list = sel_copyTypedSelectorList (\"method\", &count);\n+\n+    /* There should only be two, since 'method' is referenced twice,\n+       once with types and once without (in this very test).  */\n+    if (count != 2)\n+      abort ();\n+\n+    /* Check that both selectors are not-NULL, and have the correct\n+       name.  We use @selector() here, which wouldn't really be\n+       needed, just to register a second, untyped selector with name\n+       'method'.  */\n+    if (std::strcmp (sel_getName (list[0]), sel_getName (@selector (method))) != 0)\n+      abort ();\n+\n+    if (std::strcmp (sel_getName (list[1]), sel_getName (@selector (method))) != 0)\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n   std::cout << \"Testing sel_getName () ...\\n\";\n   {\n     if (std::strcmp (sel_getName (@selector (variable)), \"variable\") != 0)\n@@ -56,14 +82,50 @@ int main ()\n       abort ();\n   }\n \n-  std::cout << \"Testing sel_getType () ...\\n\";\n+  std::cout << \"Testing sel_getTypeEncoding () ...\\n\";\n   {\n     /* Get a selector from a real class, so it has interesting\n        types.  */\n     Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n \t\t\t\t\t     @selector (variable));\n     \n-    if (std::strcmp (sel_getType (method_getName (method)), method_getTypeEncoding (method)) != 0)\n+    if (std::strcmp (sel_getTypeEncoding (method_getName (method)),\n+\t\tmethod_getTypeEncoding (method)) != 0)\n+      abort ();\n+\n+    if (sel_getTypeEncoding (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  std::cout << \"Testing sel_getTypedSelector () ...\\n\";\n+  {\n+    /* First try with a selector where we know that a typed one has\n+       been registered.  */\n+    SEL selector = sel_getTypedSelector (\"variable\");\n+\n+    if (selector == NULL)\n+      abort ();\n+\n+    if (sel_getTypeEncoding (selector) == NULL)\n+      abort ();\n+\n+    /* Now try a selector which was never registered.  */\n+    selector = sel_getTypedSelector (\"not_registered\");\n+\n+    if (selector != NULL)\n+      abort ();\n+\n+    /* Now try registering a selector with no types.  The following\n+       line is just a way to have an unused '@selector()' expression\n+       without the compiler complaining.  */\n+    if (@selector (registered_with_no_types) == NULL)\n+      abort ();\n+\n+    /* Try getting it.  Nothing should be returned because it is\n+       untyped.  */\n+    selector = sel_getTypedSelector (\"registered_with_no_types\");\n+\n+    if (selector != NULL)\n       abort ();\n   }\n \n@@ -91,11 +153,11 @@ int main ()\n \t\t\t\t\t\t(objc_getClass (\"MySubClass\"),\n \t\t\t\t\t\t @selector (variable)));\n     SEL selector = sel_registerTypedName (\"aMethod\", types);\n-\t    \n+    \n     if (std::strcmp (sel_getName (selector), \"aMethod\") != 0)\n       abort ();\n \n-    if (std::strcmp (sel_getType (selector), types) != 0)\n+    if (std::strcmp (sel_getTypeEncoding (selector), types) != 0)\n       abort ();\n   }\n "}, {"sha": "db2dcd3ec28b59d30a54c26fac6815a8d55ec725", "filename": "gcc/testsuite/objc.dg/gnu-api-2-sel.m", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-sel.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-sel.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-sel.m?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -35,18 +35,44 @@ @interface MySubClass : MyRootClass <MyProtocol>\n { id variable_ivar; }\n - (void) setVariable: (id)value;\n - (id) variable;\n+- (void) method;\n @end\n \n @implementation MySubClass\n - (void) setVariable: (id)value { variable_ivar = value; }\n - (id) variable { return variable_ivar; }\n+- (void) method { return; }\n @end\n \n \n int main(int argc, void **args)\n {\n   /* Functions are tested in alphabetical order.  */\n \n+  printf (\"Testing sel_copyTypedSelectorList ()...\\n\");\n+  {\n+    unsigned int count;\n+    SEL * list = sel_copyTypedSelectorList (\"method\", &count);\n+\n+    /* There should only be two, since 'method' is referenced twice,\n+       once with types and once without (in this very test).  */\n+    if (count != 2)\n+      abort ();\n+\n+    /* Check that both selectors are not-NULL, and have the correct\n+       name.  We use @selector() here, which wouldn't really be\n+       needed, just to register a second, untyped selector with name\n+       'method'.  */\n+    if (strcmp (sel_getName (list[0]), sel_getName (@selector (method))) != 0)\n+      abort ();\n+\n+    if (strcmp (sel_getName (list[1]), sel_getName (@selector (method))) != 0)\n+      abort ();\n+    \n+    if (list[2] != NULL)\n+      abort ();\n+  }\n+\n   printf (\"Testing sel_getName () ...\\n\");\n   {\n     if (strcmp (sel_getName (@selector (variable)), \"variable\") != 0)\n@@ -56,14 +82,50 @@ int main(int argc, void **args)\n       abort ();\n   }\n \n-  printf (\"Testing sel_getType () ...\\n\");\n+  printf (\"Testing sel_getTypeEncoding () ...\\n\");\n   {\n     /* Get a selector from a real class, so it has interesting\n        types.  */\n     Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n \t\t\t\t\t     @selector (variable));\n     \n-    if (strcmp (sel_getType (method_getName (method)), method_getTypeEncoding (method)) != 0)\n+    if (strcmp (sel_getTypeEncoding (method_getName (method)),\n+\t\tmethod_getTypeEncoding (method)) != 0)\n+      abort ();\n+\n+    if (sel_getTypeEncoding (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing sel_getTypedSelector () ...\\n\");\n+  {\n+    /* First try with a selector where we know that a typed one has\n+       been registered.  */\n+    SEL selector = sel_getTypedSelector (\"variable\");\n+\n+    if (selector == NULL)\n+      abort ();\n+\n+    if (sel_getTypeEncoding (selector) == NULL)\n+      abort ();\n+\n+    /* Now try a selector which was never registered.  */\n+    selector = sel_getTypedSelector (\"not_registered\");\n+\n+    if (selector != NULL)\n+      abort ();\n+\n+    /* Now try registering a selector with no types.  The following\n+       line is just a way to have an unused '@selector()' expression\n+       without the compiler complaining.  */\n+    if (@selector (registered_with_no_types) == NULL)\n+      abort ();\n+\n+    /* Try getting it.  Nothing should be returned because it is\n+       untyped.  */\n+    selector = sel_getTypedSelector (\"registered_with_no_types\");\n+\n+    if (selector != NULL)\n       abort ();\n   }\n \n@@ -95,7 +157,7 @@ int main(int argc, void **args)\n     if (strcmp (sel_getName (selector), \"aMethod\") != 0)\n       abort ();\n \n-    if (strcmp (sel_getType (selector), types) != 0)\n+    if (strcmp (sel_getTypeEncoding (selector), types) != 0)\n       abort ();\n   }\n "}, {"sha": "e028b58fc234f11fb5f5b8f10ec03c85b6fd9594", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -1,3 +1,13 @@\n+2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc/runtime.h (sel_getType): Renamed to sel_getTypeEncoding to\n+\tbe consistent with method_getTypeEncoding and\n+\tivar_getTypeEncoding.\n+\t(sel_copyTypedSelectorList, sel_getTypedSelector): New.\n+\t* selector.c (sel_getType): Renamed to sel_getTypeEncoding.\n+\t(sel_copyTypedSelectorList, sel_getTypedSelector): New.\n+\t(sel_get_type): Updated call to sel_getType.\n+\t\n 2010-12-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc/runtime.h (class_conformsToProtocol,"}, {"sha": "18fc8726dc4242e6a5f44dfdb6711eea7b78647b", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -175,24 +175,30 @@ object_getClass (id object)\n    \"<null selector>\".  */\n objc_EXPORT const char *sel_getName (SEL selector);\n \n-/* Return the type of a given selector.\n+/* Return the type of a given selector.  Return NULL if selector is\n+   NULL.\n \n    Compatibility Note: the Apple/NeXT runtime has untyped selectors,\n    so it does not have this function, which is specific to the GNU\n    Runtime.  */\n-objc_EXPORT const char *sel_getType (SEL selector);\n+objc_EXPORT const char *sel_getTypeEncoding (SEL selector);\n \n /* This is the same as sel_registerName ().  Please use\n    sel_registerName () instead.  */\n objc_EXPORT SEL sel_getUid (const char *name);\n \n /* Register a selector with a given name (but unspecified types).  If\n    you know the types, it is better to call sel_registerTypedName().\n-   If a selector with this name already exists, it is returned.  */\n+   If a selector with this name and no types already exists, it is\n+   returned.  Note that this function should really be called\n+   'objc_registerSelector'.  */\n objc_EXPORT SEL sel_registerName (const char *name);\n \n /* Register a selector with a given name and types.  If a selector\n-   with this name and types already exists, it is returned.\n+   with this name and types already exists, it is returned.  Note that\n+   this function should really be called 'objc_registerTypedSelector',\n+   and it's called 'sel_registerTypedName' only for consistency with\n+   'sel_registerName'.\n \n    Compatibility Note: the Apple/NeXT runtime has untyped selectors,\n    so it does not have this function, which is specific to the GNU\n@@ -203,6 +209,37 @@ objc_EXPORT SEL sel_registerTypedName (const char *name, const char *type);\n    if not.  */\n objc_EXPORT BOOL sel_isEqual (SEL first_selector, SEL second_selector);\n \n+/* Return all the selectors with the supplied name.  In the GNU\n+   runtime, selectors are typed and there may be multiple selectors\n+   with the same name but a different type.  The return value of the\n+   function is a pointer to an area, allocated with malloc(), that\n+   contains all the selectors with the supplier name known to the\n+   runtime.  The list is terminated by NULL.  Optionally, if you pass\n+   a non-NULL 'numberOfReturnedSelectors' pointer, the unsigned int\n+   that it points to will be filled with the number of selectors\n+   returned.\n+\n+   Compatibility Note: the Apple/NeXT runtime has untyped selectors,\n+   so it does not have this function, which is specific to the GNU\n+   Runtime.  */\n+objc_EXPORT SEL * sel_copyTypedSelectorList (const char *name,\n+\t\t\t\t\t     unsigned int *numberOfReturnedSelectors);\n+\n+/* Return a selector with name 'name' and a non-zero type encoding, if\n+   any such selector is registered with the runtime.  If there is no\n+   such selector, NULL is returned.\n+\n+   This is useful if you have the name of the selector, and would\n+   really like to get a selector for it that includes the type\n+   encoding.  Unfortunately, if the program contains multiple selector\n+   with the same name but different types, sel_getTypedSelector\n+   returns a random one of them, which may not be the right one.\n+\n+   Compatibility Note: the Apple/NeXT runtime has untyped selectors,\n+   so it does not have this function, which is specific to the GNU\n+   Runtime.  */\n+objc_EXPORT SEL sel_getTypedSelector (const char *name);\n+\n \n /** Implementation: the following functions are in objects.c.  */\n "}, {"sha": "f8a7f14fdb16ad0266f05d48ea330ddadd8c7e38", "filename": "libobjc/selector.c", "status": "modified", "additions": 95, "deletions": 4, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5750872c618185a2f1161d24510ad2be8669338a/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=5750872c618185a2f1161d24510ad2be8669338a", "patch": "@@ -31,6 +31,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc-private/runtime.h\"\n #include \"objc-private/sarray.h\"\n #include \"objc-private/selector.h\"\n+#include <stdlib.h>                    /* For malloc.  */\n \n /* Initial selector hash table size. Value doesn't matter much.  */\n #define SELECTOR_HASH_SIZE 128\n@@ -250,7 +251,11 @@ sel_types_match (const char *t1, const char *t2)\n   return NO;\n }\n \n-/* Return selector representing name.  */\n+/* Return selector representing name.  In the Modern API, you'd\n+   normally use sel_registerTypedName() for this, which does the same\n+   but would register the selector with the runtime if not registered\n+   yet (if you only want to check for selectors without registering,\n+   use sel_copyTypedSelectorList()).  */\n SEL\n sel_get_typed_uid (const char *name, const char *types)\n {\n@@ -290,7 +295,8 @@ sel_get_typed_uid (const char *name, const char *types)\n }\n \n /* Return selector representing name; prefer a selector with non-NULL\n-   type.  */\n+   type.  In the Modern API, sel_getTypedSelector() is similar but\n+   returns NULL if a typed selector couldn't be found.  */\n SEL\n sel_get_any_typed_uid (const char *name)\n {\n@@ -347,6 +353,91 @@ sel_get_any_uid (const char *name)\n   return (SEL) l->head;\n }\n \n+SEL\n+sel_getTypedSelector (const char *name)\n+{\n+  sidx i;\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Look for a typed selector.  */\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n+  if (i != 0)\n+    {\n+      struct objc_list *l;\n+\n+      for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n+\t   l; l = l->tail)\n+\t{\n+\t  SEL s = (SEL) l->head;\n+\t  if (s->sel_types)\n+\t    {\n+\t      objc_mutex_unlock (__objc_runtime_mutex);\n+\t      return s;\n+\t    }\n+\t}\n+    }\n+\n+  /* No typed selector found.  Return NULL.  */\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+  return 0;\n+}\n+\n+SEL *\n+sel_copyTypedSelectorList (const char *name, unsigned int *numberOfReturnedSelectors)\n+{\n+  unsigned int count = 0;\n+  SEL *returnValue = NULL;\n+  sidx i;\n+  \n+  if (name == NULL)\n+    {\n+      if (numberOfReturnedSelectors)\n+\t*numberOfReturnedSelectors = 0;\n+      return NULL;\n+    }\n+\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Count how many selectors we have.  */\n+  i = (sidx) objc_hash_value_for_key (__objc_selector_hash, name);\n+  if (i != 0)\n+    {\n+      struct objc_list *selector_list = NULL;\n+      selector_list = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n+\n+      /* Count how many selectors we have.  */\n+      {\n+\tstruct objc_list *l;\n+\tfor (l = selector_list; l; l = l->tail)\n+\t  count++;\n+      }\n+\n+      if (count != 0)\n+\t{\n+\t  /* Allocate enough memory to hold them.  */\n+\t  returnValue = (SEL *)(malloc (sizeof (SEL) * (count + 1)));\n+\t  \n+\t  /* Copy the selectors.  */\n+\t  {\n+\t    unsigned int j;\n+\t    for (j = 0; j < count; j++)\n+\t      {\n+\t\treturnValue[j] = (SEL)(selector_list->head);\n+\t\tselector_list = selector_list->tail;\n+\t      }\n+\t    returnValue[j] = NULL;\n+\t  }\n+\t}\n+    }      \n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+  \n+  if (numberOfReturnedSelectors)\n+    *numberOfReturnedSelectors = count;\n+  \n+  return returnValue;\n+}\n+\n /* Get the name of a selector.  If the selector is unknown, the empty\n    string \"\" is returned.  */ \n const char *sel_getName (SEL selector)\n@@ -382,7 +473,7 @@ sel_is_mapped (SEL selector)\n   return ((idx > 0) && (idx <= __objc_selector_max_index));\n }\n \n-const char *sel_getType (SEL selector)\n+const char *sel_getTypeEncoding (SEL selector)\n {\n   if (selector)\n     return selector->sel_types;\n@@ -393,7 +484,7 @@ const char *sel_getType (SEL selector)\n /* Traditional GNU Objective-C Runtime API.  */\n const char *sel_get_type (SEL selector)\n {\n-  return sel_getType (selector);\n+  return sel_getTypeEncoding (selector);\n }\n \n /* The uninstalled dispatch table.  */"}]}