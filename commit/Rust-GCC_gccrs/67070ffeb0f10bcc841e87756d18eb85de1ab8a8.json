{"sha": "67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcwNzBmZmViMGYxMGJjYzg0MWU4Nzc1NmQxOGViODVkZTFhYjhhOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2001-08-10T13:08:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2001-08-10T13:08:16Z"}, "message": "mips.c (mips_add_large_offset_to_sp): New function.\n\n\t* config/mips/mips.c (mips_add_large_offset_to_sp): New function.\n\t(mips_annotate_frame_insn): New function.\n\t(mips_emit_frame_related_store): New function.\n\t(save_restore_insns): Don't mark instructions that set up the base\n\tregisters as frame-related.  Add REG_FRAME_RELATED_EXPR notes to\n\tthe store instructions instead.\n\t(mips_expand_prologue): If the stack size is moved into a temporary\n\tregister, do not mark that move as frame-related.  Add a\n\tREG_FRAME_RELATED_EXPR note to the stack adjustment instruction.\n\nFrom-SVN: r44761", "tree": {"sha": "dbed25d8882c9ff756cc85d3b8076f7b534a4bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbed25d8882c9ff756cc85d3b8076f7b534a4bda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67070ffeb0f10bcc841e87756d18eb85de1ab8a8/comments", "author": null, "committer": null, "parents": [{"sha": "a8205f032908c8d821e92aac477cf60804ca2d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8205f032908c8d821e92aac477cf60804ca2d2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8205f032908c8d821e92aac477cf60804ca2d2e"}], "stats": {"total": 246, "additions": 100, "deletions": 146}, "files": [{"sha": "dbbe9d1583541002c1f88a298ddafab9b634c889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67070ffeb0f10bcc841e87756d18eb85de1ab8a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67070ffeb0f10bcc841e87756d18eb85de1ab8a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "patch": "@@ -1,3 +1,15 @@\n+2001-08-10  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_add_large_offset_to_sp): New function.\n+\t(mips_annotate_frame_insn): New function.\n+\t(mips_emit_frame_related_store): New function.\n+\t(save_restore_insns): Don't mark instructions that set up the base\n+\tregisters as frame-related.  Add REG_FRAME_RELATED_EXPR notes to\n+\tthe store instructions instead.\n+\t(mips_expand_prologue): If the stack size is moved into a temporary\n+\tregister, do not mark that move as frame-related.  Add a\n+\tREG_FRAME_RELATED_EXPR note to the stack adjustment instruction.\n+\n 2001-08-10  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (save_restore_insns): Don't mark the RA's"}, {"sha": "59c7e25d36fdb69feaaab25bccee7ab3e04ce306", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 88, "deletions": 146, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67070ffeb0f10bcc841e87756d18eb85de1ab8a8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67070ffeb0f10bcc841e87756d18eb85de1ab8a8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=67070ffeb0f10bcc841e87756d18eb85de1ab8a8", "patch": "@@ -91,6 +91,11 @@ static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t rtx, rtx));\n static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n static FILE *mips_make_temp_file\t\tPARAMS ((void));\n+static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT,\n+\t\t\t\t\t\t\t FILE *));\n+static void mips_annotate_frame_insn\t\tPARAMS ((rtx, rtx));\n+static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n+\t\t\t\t\t\t\t HOST_WIDE_INT));\n static void save_restore_insns\t\t\tPARAMS ((int, rtx,\n \t\t\t\t\t\t\tlong, FILE *));\n static void mips16_output_gp_offset\t\tPARAMS ((FILE *, rtx));\n@@ -6447,6 +6452,73 @@ compute_frame_size (size)\n \n #define BITSET_P(VALUE,BIT) (((VALUE) & (1L << (BIT))) != 0)\n \n+/* Emit instructions to load the value (SP + OFFSET) into MIPS_TEMP2_REGNUM\n+   and return an rtl expression for the register.  Write the assembly\n+   instructions directly to FILE if it is not null, otherwise emit them as\n+   rtl.\n+\n+   This function is a subroutine of save_restore_insns.  It is used when\n+   OFFSET is too large to add in a single instruction.  */\n+\n+static rtx\n+mips_add_large_offset_to_sp (offset, file)\n+     HOST_WIDE_INT offset;\n+     FILE *file;\n+{\n+  rtx reg = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n+  if (file == 0)\n+    {\n+      rtx offset_rtx = GEN_INT (offset);\n+\n+      emit_move_insn (reg, offset_rtx);\n+      if (Pmode == DImode)\n+\temit_insn (gen_adddi3 (reg, reg, stack_pointer_rtx));\n+      else\n+\temit_insn (gen_addsi3 (reg, reg, stack_pointer_rtx));\n+    }\n+  else\n+    {\n+      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n+\t       reg_names[MIPS_TEMP2_REGNUM], (long) offset);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, offset);\n+      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n+\t       Pmode == DImode ? \"daddu\" : \"addu\",\n+\t       reg_names[MIPS_TEMP2_REGNUM],\n+\t       reg_names[MIPS_TEMP2_REGNUM],\n+\t       reg_names[STACK_POINTER_REGNUM]);\n+    }\n+  return reg;\n+}\n+\n+/* Make INSN frame related and note that it performs the frame-related\n+   operation DWARF_PATTERN.  */\n+\n+static void\n+mips_annotate_frame_insn (insn, dwarf_pattern)\n+     rtx insn, dwarf_pattern;\n+{\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  REG_NOTES (insn) = alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t      dwarf_pattern,\n+\t\t\t\t      REG_NOTES (insn));\n+}\n+\n+/* Emit a move instruction that stores REG in MEM.  Make the instruction\n+   frame related and note that it stores REG at (SP + OFFSET).  */\n+\n+static void\n+mips_emit_frame_related_store (mem, reg, offset)\n+     rtx mem;\n+     rtx reg;\n+     HOST_WIDE_INT offset;\n+{\n+  rtx dwarf_address = plus_constant (stack_pointer_rtx, offset);\n+  rtx dwarf_mem = gen_rtx_MEM (GET_MODE (reg), dwarf_address);\n+\n+  mips_annotate_frame_insn (emit_move_insn (mem, reg),\n+\t\t\t    gen_rtx_SET (GET_MODE (reg), dwarf_mem, reg));\n+}\n+\n static void\n save_restore_insns (store_p, large_reg, large_offset, file)\n      int store_p;\t/* true if this is prologue */\n@@ -6517,8 +6589,6 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t      else\n \t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n \t\t\t\t\t      stack_pointer_rtx));\n-\t      if (store_p)\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \t  else\n \t    fprintf (file, \"\\t%s\\t%s,%s,%s\\n\",\n@@ -6527,61 +6597,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t     reg_names[REGNO (large_reg)],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n \t}\n-\n       else\n \t{\n-\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = gp_offset;\n-\t  if (file == 0)\n-\t    {\n-\t      rtx gp_offset_rtx = GEN_INT (gp_offset);\n-\n-\t      /* Instruction splitting doesn't preserve the RTX_FRAME_RELATED_P\n-\t\t bit, so make sure that we don't emit anything that can be\n-\t\t split.  */\n-\t      /* ??? There is no DImode ori immediate pattern, so we can only\n-\t\t do this for 32 bit code.  */\n-\t      if (large_int (gp_offset_rtx, GET_MODE (gp_offset_rtx))\n-\t\t  && GET_MODE (base_reg_rtx) == SImode)\n-\t\t{\n-\t\t  insn = emit_move_insn (base_reg_rtx,\n-\t\t\t\t\t GEN_INT (gp_offset & BITMASK_UPPER16));\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  insn\n-\t\t    = emit_insn (gen_iorsi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t\t     GEN_INT (gp_offset\n-\t\t\t\t\t\t      & BITMASK_LOWER16)));\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  insn = emit_move_insn (base_reg_rtx, gp_offset_rtx);\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t \t      stack_pointer_rtx));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t      if (store_p)\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM], (long) base_offset);\n-\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, base_offset);\n-\t      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n-\t\t       Pmode == DImode ? \"daddu\" : \"addu\",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t\t       reg_names[STACK_POINTER_REGNUM]);\n-\t    }\n+\t  base_reg_rtx = mips_add_large_offset_to_sp (base_offset, file);\n \t}\n \n       /* When we restore the registers in MIPS16 mode, then if we are\n@@ -6635,10 +6654,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  reg_rtx = gen_rtx (REG, gpr_mode, regno);\n \n \t\tif (store_p)\n-\t\t  {\n-\t\t    insn = emit_move_insn (mem_rtx, reg_rtx);\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  }\n+\t\t  mips_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n \t\telse if (!TARGET_ABICALLS\n \t\t\t || (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \t\t\t || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n@@ -6738,8 +6754,6 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t      else\n \t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, large_reg,\n \t\t\t\t\t      stack_pointer_rtx));\n-\t      if (store_p)\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n \t    }\n \n \t  else\n@@ -6749,62 +6763,10 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t     reg_names[REGNO (large_reg)],\n \t\t     reg_names[STACK_POINTER_REGNUM]);\n \t}\n-\n       else\n \t{\n-\t  base_reg_rtx = gen_rtx_REG (Pmode, MIPS_TEMP2_REGNUM);\n \t  base_offset = fp_offset;\n-\t  if (file == 0)\n-\t    {\n-\t      rtx fp_offset_rtx = GEN_INT (fp_offset);\n-\n-\t      /* Instruction splitting doesn't preserve the RTX_FRAME_RELATED_P\n-\t\t bit, so make sure that we don't emit anything that can be\n-\t\t split.  */\n-\t      /* ??? There is no DImode ori immediate pattern, so we can only\n-\t\t do this for 32 bit code.  */\n-\t      if (large_int (fp_offset_rtx, GET_MODE (fp_offset_rtx))\n-\t\t  && GET_MODE (base_reg_rtx) == SImode)\n-\t\t{\n-\t\t  insn = emit_move_insn (base_reg_rtx,\n-\t\t\t\t\t GEN_INT (fp_offset & BITMASK_UPPER16));\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  insn = emit_insn (gen_iorsi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t\t\tGEN_INT (fp_offset\n-\t\t\t\t\t\t\t & BITMASK_LOWER16)));\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  insn = emit_move_insn (base_reg_rtx, fp_offset_rtx);\n-\t\t  if (store_p)\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\n-\t      if (store_p)\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t      if (Pmode == DImode)\n-\t\tinsn = emit_insn (gen_adddi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t      else\n-\t\tinsn = emit_insn (gen_addsi3 (base_reg_rtx, base_reg_rtx,\n-\t\t\t\t\t      stack_pointer_rtx));\n-\t      if (store_p)\n-\t\tRTX_FRAME_RELATED_P (insn) = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (file, \"\\tli\\t%s,0x%.08lx\\t# \",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM], (long) base_offset);\n-\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, base_offset);\n-\t      fprintf (file, \"\\n\\t%s\\t%s,%s,%s\\n\",\n-\t\t       Pmode == DImode ? \"daddu\" : \"addu\",\n-\t\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t\t       reg_names[MIPS_TEMP2_REGNUM],\n-\t\t       reg_names[STACK_POINTER_REGNUM]);\n-\t    }\n+\t  base_reg_rtx = mips_add_large_offset_to_sp (fp_offset, file);\n \t}\n \n       /* This loop must iterate over the same space as its companion in\n@@ -6826,10 +6788,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\tRTX_UNCHANGING_P (mem_rtx) = 1;\n \n \t\tif (store_p)\n-\t\t  {\n-\t\t    insn = emit_move_insn (mem_rtx, reg_rtx);\n-\t\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  }\n+\t\t  mips_emit_frame_related_store (mem_rtx, reg_rtx, gp_offset);\n \t\telse\n \t\t  emit_move_insn (reg_rtx, mem_rtx);\n \t      }\n@@ -7305,45 +7264,28 @@ mips_expand_prologue ()\n       if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \t  && (!TARGET_MIPS16 || tsize <= 32767))\n \t{\n-\t  rtx insn;\n+\t  rtx adjustment_rtx, insn, dwarf_pattern;\n \n \t  if (tsize > 32767)\n \t    {\n-\t      tmp_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n-\n-\t      /* Instruction splitting doesn't preserve the RTX_FRAME_RELATED_P\n-\t\t bit, so make sure that we don't emit anything that can be\n-\t\t split.  */\n-\t      /* ??? There is no DImode ori immediate pattern, so we can only\n-\t\t do this for 32 bit code.  */\n-\t      if (large_int (tsize_rtx, GET_MODE (tsize_rtx))\n-\t\t  && GET_MODE (tmp_rtx) == SImode)\n-\t\t{\n-\t\t  insn = emit_move_insn (tmp_rtx,\n-\t\t\t\t\t GEN_INT (tsize & BITMASK_UPPER16));\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  insn = emit_insn (gen_iorsi3 (tmp_rtx, tmp_rtx,\n-\t\t\t\t\t\tGEN_INT (tsize\n-\t\t\t\t\t\t\t & BITMASK_LOWER16)));\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  insn = emit_move_insn (tmp_rtx, tsize_rtx);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t}\n-\n-\t      tsize_rtx = tmp_rtx;\n+\t      adjustment_rtx = gen_rtx (REG, Pmode, MIPS_TEMP1_REGNUM);\n+\t      emit_move_insn (adjustment_rtx, tsize_rtx);\n \t    }\n+\t  else\n+\t    adjustment_rtx = tsize_rtx;\n \n \t  if (Pmode == DImode)\n \t    insn = emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t  tsize_rtx));\n+\t\t\t\t\t  adjustment_rtx));\n \t  else\n \t    insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t  tsize_rtx));\n+\t\t\t\t\t  adjustment_rtx));\n+\n+\t  dwarf_pattern = gen_rtx_SET (Pmode, stack_pointer_rtx,\n+\t\t\t\t       plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t      -tsize));\n \n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  mips_annotate_frame_insn (insn, dwarf_pattern);\n \t}\n \n       if (! mips_entry)"}]}