{"sha": "ddd2d57e722237230da8eea70a2fcecb11bd0f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRkMmQ1N2U3MjIyMzcyMzBkYThlZWE3MGEyZmNlY2IxMWJkMGY4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-09-21T05:07:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-09-21T05:07:20Z"}, "message": "c-format.c (gcc_diag_char_table): Add %J.\n\n        * c-format.c (gcc_diag_char_table): Add %J.\n        (gcc_cdiag_char_table, gcc_cxxdiag_char_table): Likewise.\n        (check_format_types): Fix wanted_type name lookup.\n        (init_dynamic_diag_info): Setup %J.\n        * diagnostic.c (text_specifies_location): Implement %J.\n        * c-common.c, c-decl.c, c-objc-common.c, c-pragma.c, calls.c,\n        dwarfout.c, expr.c, function.c, stmt.c, stor-layout.c, toplev.c,\n        tree-inline.c, tree-optimize.c, varasm.c, config/arm/pe.c,\n        config/i386/winnt.c, config/ia64/ia64.c, config/mcore/mcore.c,\n        config/v850/v850.c, objc/objc-act.c: Use %J in diagnostics.\n\n        * tree-inline.c: Include intl.h\n        (inline_forbidden_p_1): Fix i18n of inline_forbidden_reason.\n        * Makefile.in (tree-inline.o): Update.\ncp/\n        * decl.c, decl2.c, pt.c: Use %J in diagnostics.\njava/\n        * check-init.c, class.c, decl.c, expr.c: Use %J in diagnostics.\ntestsuite/\n        * gcc.dg/format/gcc_diag-1.c: Add tests for %J.\n\nFrom-SVN: r71619", "tree": {"sha": "28f355780724c452ad42bb81a3672b2e8010c989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28f355780724c452ad42bb81a3672b2e8010c989"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddd2d57e722237230da8eea70a2fcecb11bd0f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd2d57e722237230da8eea70a2fcecb11bd0f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd2d57e722237230da8eea70a2fcecb11bd0f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd2d57e722237230da8eea70a2fcecb11bd0f81/comments", "author": null, "committer": null, "parents": [{"sha": "ccea753c0563b847b42d9ca5fc1b8afaee49f343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccea753c0563b847b42d9ca5fc1b8afaee49f343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccea753c0563b847b42d9ca5fc1b8afaee49f343"}], "stats": {"total": 886, "additions": 411, "deletions": 475}, "files": [{"sha": "35f2fba3a617401b034c1001a668702da6354988", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1,3 +1,20 @@\n+2003-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-format.c (gcc_diag_char_table): Add %J.\n+\t(gcc_cdiag_char_table, gcc_cxxdiag_char_table): Likewise.\n+\t(check_format_types): Fix wanted_type name lookup.\n+\t(init_dynamic_diag_info): Setup %J.\n+\t* diagnostic.c (text_specifies_location): Implement %J.\n+\t* c-common.c, c-decl.c, c-objc-common.c, c-pragma.c, calls.c,\n+\tdwarfout.c, expr.c, function.c, stmt.c, stor-layout.c, toplev.c,\n+\ttree-inline.c, tree-optimize.c, varasm.c, config/arm/pe.c,\n+\tconfig/i386/winnt.c, config/ia64/ia64.c, config/mcore/mcore.c,\n+\tconfig/v850/v850.c, objc/objc-act.c: Use %J in diagnostics.\n+\n+\t* tree-inline.c: Include intl.h\n+\t(inline_forbidden_p_1): Fix i18n of inline_forbidden_reason.\n+\t* Makefile.in (tree-inline.o): Update.\n+\n 2003-09-20  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.c (ix86_expand_carry_flag_compare): Fix"}, {"sha": "768646ca26d8035708d3d2620384adc18ec1153c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1471,7 +1471,7 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h \\\n    $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n-   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h\n+   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h\n tree-optimize.o : tree-optimize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) toplev.h langhooks.h cgraph.h $(TIMEVAR_H) function.h $(GGC_H)\n "}, {"sha": "39c6a5741b5dccf45115ac3e5fadb703c72bf2cc", "filename": "gcc/c-common.c", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1140,8 +1140,7 @@ fname_decl (unsigned int rid, tree id)\n       input_line = saved_lineno;\n     }\n   if (!ix && !current_function_decl)\n-    pedwarn (\"%H'%D' is not defined outside of function scope\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+    pedwarn (\"%J'%D' is not defined outside of function scope\", decl, decl);\n \n   return decl;\n }\n@@ -3936,19 +3935,17 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n       if (high_value)\n \t{\n \t  error (\"duplicate (or overlapping) case value\");\n-\t  error (\"%Hthis is the first entry overlapping that value\",\n-                 &DECL_SOURCE_LOCATION (duplicate));\n+\t  error (\"%Jthis is the first entry overlapping that value\", duplicate);\n \t}\n       else if (low_value)\n \t{\n \t  error (\"duplicate case value\") ;\n-\t  error (\"%Hpreviously used here\", &DECL_SOURCE_LOCATION (duplicate));\n+\t  error (\"%Jpreviously used here\", duplicate);\n \t}\n       else\n \t{\n \t  error (\"multiple default labels in one switch\");\n-\t  error (\"%Hthis is the first default label\",\n-                 &DECL_SOURCE_LOCATION (duplicate));\n+\t  error (\"%Jthis is the first default label\", duplicate);\n \t}\n       if (!cases->root)\n \tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n@@ -4249,7 +4246,7 @@ shadow_warning (enum sw_kind msgcode, const char *name, tree decl)\n   };\n \n   warning (msgs[msgcode], name);\n-  warning (\"%Hshadowed declaration is here\", &DECL_SOURCE_LOCATION (decl));\n+  warning (\"%Jshadowed declaration is here\", decl);\n }\n \n /* Attribute handlers common to C front ends.  */\n@@ -4690,8 +4687,8 @@ handle_section_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n \t      && current_function_decl != NULL_TREE\n \t      && ! TREE_STATIC (decl))\n \t    {\n-\t      error (\"%Hsection attribute cannot be specified for \"\n-                     \"local variables\", &DECL_SOURCE_LOCATION (decl));\n+\t      error (\"%Jsection attribute cannot be specified for \"\n+                     \"local variables\", decl);\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -4701,24 +4698,22 @@ handle_section_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n \t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n \t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n \t    {\n-\t      error (\"%Hsection of '%D' conflicts with previous declaration\",\n-                     &DECL_SOURCE_LOCATION (*node), *node);\n+\t      error (\"%Jsection of '%D' conflicts with previous declaration\",\n+                     *node, *node);\n \t      *no_add_attrs = true;\n \t    }\n \t  else\n \t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n \t}\n       else\n \t{\n-\t  error (\"%Hsection attribute not allowed for '%D'\",\n-                 &DECL_SOURCE_LOCATION (*node), *node);\n+\t  error (\"%Jsection attribute not allowed for '%D'\", *node, *node);\n \t  *no_add_attrs = true;\n \t}\n     }\n   else\n     {\n-      error (\"%Hsection attributes are not supported for this target\",\n-             &DECL_SOURCE_LOCATION (*node));\n+      error (\"%Jsection attributes are not supported for this target\", *node);\n       *no_add_attrs = true;\n     }\n \n@@ -4792,8 +4787,7 @@ handle_aligned_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n   else if (TREE_CODE (decl) != VAR_DECL\n \t   && TREE_CODE (decl) != FIELD_DECL)\n     {\n-      error (\"%Halignment may not be specified for '%D'\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jalignment may not be specified for '%D'\", decl, decl);\n       *no_add_attrs = true;\n     }\n   else\n@@ -4831,8 +4825,7 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n       || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n     {\n-      error (\"%H'%D' defined both normally and as an alias\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%J'%D' defined both normally and as an alias\", decl, decl);\n       *no_add_attrs = true;\n     }\n   else if (decl_function_context (decl) == 0)\n@@ -4956,14 +4949,12 @@ handle_no_instrument_function_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%H'%E' attribute applies only to functions\",\n-             &DECL_SOURCE_LOCATION (decl), name);\n+      error (\"%J'%E' attribute applies only to functions\", decl, name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Hcan't set '%E' attribute after definition\",\n-             &DECL_SOURCE_LOCATION (decl), name);\n+      error (\"%Jcan't set '%E' attribute after definition\", decl, name);\n       *no_add_attrs = true;\n     }\n   else\n@@ -5004,14 +4995,12 @@ handle_no_limit_stack_attribute (tree *node, tree name,\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"%H'%E' attribute applies only to functions\",\n-             &DECL_SOURCE_LOCATION (decl), name);\n+      error (\"%J'%E' attribute applies only to functions\", decl, name);\n       *no_add_attrs = true;\n     }\n   else if (DECL_INITIAL (decl))\n     {\n-      error (\"%Hcan't set '%E' attribute after definition\",\n-             &DECL_SOURCE_LOCATION (decl), name);\n+      error (\"%Jcan't set '%E' attribute after definition\", decl, name);\n       *no_add_attrs = true;\n     }\n   else"}, {"sha": "db35f9a9ea9cf127f400d724fc450ea4b57cdb11", "filename": "gcc/c-decl.c", "status": "modified", "additions": 133, "deletions": 198, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -367,8 +367,7 @@ c_finish_incomplete_decl (tree decl)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n-\t  warning (\"%Harray '%D' assumed to have one element\",\n-                   &DECL_SOURCE_LOCATION (decl), decl);\n+\t  warning (\"%Jarray '%D' assumed to have one element\", decl, decl);\n \n \t  complete_array_type (type, NULL_TREE, 1);\n \n@@ -539,22 +538,20 @@ poplevel (int keep, int dummy ATTRIBUTE_UNUSED, int functionbody)\n \n   for (p = scope->names; p; p = TREE_CHAIN (p))\n     {\n-      const location_t *locus = &DECL_SOURCE_LOCATION (p);\n-\n       switch (TREE_CODE (p))\n \t{\n \tcase LABEL_DECL:\n \t  if (TREE_USED (p) && !DECL_INITIAL (p))\n \t    {\n-\t      error (\"%Hlabel `%D' used but not defined\", locus, p);\n+\t      error (\"%Jlabel `%D' used but not defined\", p, p);\n \t      DECL_INITIAL (p) = error_mark_node;\n \t    }\n \t  else if (!TREE_USED (p) && warn_unused_label)\n \t    {\n \t      if (DECL_INITIAL (p))\n-\t\twarning (\"%Hlabel `%D' defined but not used\", locus, p);\n+\t\twarning (\"%Jlabel `%D' defined but not used\", p, p);\n \t      else\n-\t\twarning (\"%Hlabel `%D' declared but not defined\", locus, p);\n+\t\twarning (\"%Jlabel `%D' declared but not defined\", p, p);\n \t    }\n \n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (p)) = 0;\n@@ -579,7 +576,7 @@ poplevel (int keep, int dummy ATTRIBUTE_UNUSED, int functionbody)\n \t      && !DECL_IN_SYSTEM_HEADER (p)\n \t      && DECL_NAME (p)\n \t      && !DECL_ARTIFICIAL (p))\n-\t    warning (\"%Hunused variable `%D'\", locus, p);\n+\t    warning (\"%Junused variable `%D'\", p, p);\n \t  /* fall through */\n \n \tdefault:\n@@ -803,20 +800,19 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t   && DECL_UNINLINABLE (olddecl)\n \t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t    {\n-\t      warning (\"%Hfunction '%D' redeclared as inline\",\n-                       &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-\t      warning (\"%Hprevious declaration of function '%D' \"\n-                       \"with attribute noinline\",\n-                       &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\t      warning (\"%Jfunction '%D' redeclared as inline\",\n+\t\t       newdecl, newdecl);\n+\t      warning (\"%Jprevious declaration of function '%D' \"\n+                       \"with attribute noinline\", olddecl, olddecl);\n \t    }\n \t  else if (DECL_DECLARED_INLINE_P (olddecl)\n \t\t   && DECL_UNINLINABLE (newdecl)\n \t\t   && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t    {\n-\t      warning (\"%Hfunction '%D' redeclared with attribute noinline\",\n-                       &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-\t      warning (\"%Hprevious declaration of function '%D' was inline\",\n-                       &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\t      warning (\"%Jfunction '%D' redeclared with attribute noinline\",\n+                       newdecl, newdecl);\n+\t      warning (\"%Jprevious declaration of function '%D' was inline\",\n+                       olddecl, olddecl);\n \t    }\n \t}\n \n@@ -842,19 +838,18 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t  if (!TREE_PUBLIC (newdecl))\n \t    {\n \t      if (warn_shadow)\n-\t\twarning (\"%Hshadowing built-in function '%D'\",\n-                         &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t\twarning (\"%Jshadowing built-in function '%D'\",\n+\t\t\t newdecl, newdecl);\n \t    }\n \t  else\n-\t    warning (\"%Hbuilt-in function '%D' declared as non-function\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t    warning (\"%Jbuilt-in function '%D' declared as non-function\",\n+                     newdecl, newdecl);\n \t}\n       else\n \t{\n-\t  error (\"%H'%D' redeclared as different kind of symbol\",\n-                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-\t  error (\"%Hprevious declaration of '%D'\",\n-                 &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\t  error (\"%J'%D' redeclared as different kind of symbol\",\n+\t\t newdecl, newdecl);\n+\t  error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n \t}\n \n       return 0;\n@@ -883,8 +878,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t     built-in definition is overridden,\n \t     but optionally warn this was a bad choice of name.  */\n \t  if (warn_shadow)\n-\t    warning (\"%Hshadowing built-in function '%D'\",\n-                     &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t    warning (\"%Jshadowing built-in function '%D'\", newdecl, newdecl);\n \t  /* Discard the old built-in function.  */\n \t  return 0;\n \t}\n@@ -906,8 +900,8 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       if (!types_match)\n \t{\n \t  /* If types don't match for a built-in, throw away the built-in.  */\n-\t  warning (\"%Hconflicting types for built-in function '%D'\",\n-                   &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\t  warning (\"%Jconflicting types for built-in function '%D'\",\n+\t\t   newdecl, newdecl);\n \t  return 0;\n \t}\n     }\n@@ -950,8 +944,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t&& TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)))\n     {\n       if (pedantic)\n-\tpedwarn (\"%Hconflicting types for '%D'\",\n-                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\tpedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n       /* Make sure we keep void * as ret type, not char *.  */\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (oldtype))) == void_type_node)\n \tTREE_TYPE (newdecl) = newtype = oldtype;\n@@ -969,8 +962,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t   && TYPE_MAIN_VARIANT (TREE_TYPE (newtype)) == integer_type_node\n \t   && C_FUNCTION_IMPLICIT_INT (newdecl))\n     {\n-      pedwarn (\"%Hconflicting types for '%D'\",\n-               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+      pedwarn (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n       /* Make sure we keep void as the return type.  */\n       TREE_TYPE (newdecl) = newtype = oldtype;\n       C_FUNCTION_IMPLICIT_INT (newdecl) = 0;\n@@ -985,8 +977,7 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t\t\t       TREE_TYPE (newtype), COMPARE_STRICT)\n \t\t && TYPE_ARG_TYPES (newtype) == 0))\n     {\n-      error (\"%Hconflicting types for '%D'\",\n-             &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+      error (\"%Jconflicting types for '%D'\", newdecl, newdecl);\n       /* Check for function type mismatch\n \t involving an empty arglist vs a nonempty one.  */\n       if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1021,11 +1012,9 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t    }\n \t}\n       if (C_DECL_IMPLICIT (olddecl))\n-\terror (\"%Hprevious implicit declaration of '%D'\",\n-               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\terror (\"%Jprevious implicit declaration of '%D'\", olddecl, olddecl);\n       else\n-\terror (\"%Hprevious declaration of '%D'\",\n-               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\terror (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n \n       /* This is safer because the initializer might contain references\n \t to variables that were declared between olddecl and newdecl. This\n@@ -1038,62 +1027,54 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n   else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n \t   && !DECL_THREAD_LOCAL (olddecl) && DECL_THREAD_LOCAL (newdecl))\n     {\n-      error (\"%Hthread-local declaration of '%D' follows non thread-local \"\n-             \"declaration\", &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-      error (\"%Hprevious declaration of '%D'\",\n-             &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+      error (\"%Jthread-local declaration of '%D' follows non thread-local \"\n+             \"declaration\", newdecl, newdecl);\n+      error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n     }\n   /* non-TLS declaration cannot follow TLS declaration.  */\n   else if (TREE_CODE (olddecl) == VAR_DECL && TREE_CODE (newdecl) == VAR_DECL\n \t   && DECL_THREAD_LOCAL (olddecl) && !DECL_THREAD_LOCAL (newdecl))\n     {\n-      error (\"%Hnon thread-local declaration of '%D' follows \"\n-             \"thread-local declaration\",\n-             &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-      error (\"%Hprevious declaration of '%D'\",\n-             &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+      error (\"%Jnon thread-local declaration of '%D' follows \"\n+             \"thread-local declaration\", newdecl, newdecl);\n+      error (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n     }\n   else\n     {\n       errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n \t  switch (errmsg)\n \t    {\n \t    case 1:\n-\t      error (\"%Hredefinition of '%D'\", locus, newdecl);\n+\t      error (\"%Jredefinition of '%D'\", newdecl, newdecl);\n \t      break;\n \t    case 2:\n-\t      error (\"%Hredeclaration of '%D'\", locus, newdecl);\n+\t      error (\"%Jredeclaration of '%D'\", newdecl, newdecl);\n \t      break;\n \t    case 3:\n-\t      error (\"%Hconflicting declarations of '%D'\", locus, newdecl);\n+\t      error (\"%Jconflicting declarations of '%D'\", newdecl, newdecl);\n \t      break;\n \t    default:\n \t      abort ();\n \t    }\n \n-          locus = &DECL_SOURCE_LOCATION (olddecl);\n           if (DECL_INITIAL (olddecl)\n               && current_scope == global_scope)\n-            error (\"%H'%D' previously defined here\", locus, olddecl);\n+            error (\"%J'%D' previously defined here\", olddecl, olddecl);\n           else\n-            error (\"%H'%D' previously declared here\", locus, olddecl);\n+            error (\"%J'%D' previously declared here\", olddecl, olddecl);\n \t  return 0;\n \t}\n       else if (TREE_CODE (newdecl) == TYPE_DECL\n                && (DECL_IN_SYSTEM_HEADER (olddecl)\n                    || DECL_IN_SYSTEM_HEADER (newdecl)))\n \t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n-\t  warning (\"%Hredefinition of '%D'\", locus, newdecl);\n-          locus = &DECL_SOURCE_LOCATION (olddecl);\n-          if (DECL_INITIAL (olddecl)\n-              && current_scope == global_scope)\n-            warning (\"%H'%D' previously defined here\", locus, olddecl);\n+\t  warning (\"%Jredefinition of '%D'\", newdecl, newdecl);\n+          if (DECL_INITIAL (olddecl) && current_scope == global_scope)\n+            warning (\"%J'%D' previously defined here\", olddecl, olddecl);\n           else\n-            warning (\"%H'%D' previously declared here\", locus, olddecl);\n+            warning (\"%J'%D' previously declared here\", olddecl, olddecl);\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_INITIAL (olddecl) != 0\n@@ -1114,20 +1095,16 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  && TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n-\t\t  warning (\"%Hprototype for '%D' follows\", locus, newdecl);\n-                  locus = &DECL_SOURCE_LOCATION (olddecl);\n-\t\t  warning (\"%Hnon-prototype definition here\", locus);\n+\t\t  warning (\"%Jprototype for '%D' follows\", newdecl, newdecl);\n+\t\t  warning (\"%Jnon-prototype definition here\", olddecl);\n \t\t  break;\n \t\t}\n \t      if (TYPE_MAIN_VARIANT (TREE_VALUE (parm)) == void_type_node\n \t\t  || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t\t{\n-                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n-\t\t  error (\"%Hprototype for '%D' follows and number of \"\n-                         \"arguments doesn't match\", locus, newdecl);\n-                  locus = &DECL_SOURCE_LOCATION (olddecl);\n-\t\t  error (\"%Hnon-prototype definition here\", locus);\n+\t\t  error (\"%Jprototype for '%D' follows and number of \"\n+                         \"arguments doesn't match\", newdecl, newdecl);\n+\t\t  error (\"%Jnon-prototype definition here\", olddecl);\n \t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n@@ -1136,11 +1113,9 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n \t      if (! comptypes (TREE_VALUE (parm), TREE_VALUE (type),\n \t\t\t       COMPARE_STRICT))\n \t\t{\n-                  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n-\t\t  error (\"%Hprototype for '%D' follows and argument %d \"\n-                         \"doesn't match\", locus, newdecl, nargs);\n-                  locus = &DECL_SOURCE_LOCATION (olddecl);\n-\t\t  error (\"%Hnon-prototype definition here\", locus);\n+\t\t  error (\"%Jprototype for '%D' follows and argument %d \"\n+                         \"doesn't match\", newdecl, newdecl, nargs);\n+\t\t  error (\"%Jnon-prototype definition here\", olddecl);\n \t\t  errmsg = 1;\n \t\t  break;\n \t\t}\n@@ -1149,55 +1124,53 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       /* Warn about mismatches in various flags.  */\n       else\n \t{\n-\t  const location_t *locus = &DECL_SOURCE_LOCATION (newdecl);\n-\n \t  /* Warn if function is now inline\n \t     but was previously declared not inline and has been called.  */\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && TREE_USED (olddecl))\n-\t    warning (\"%H'%D' declared inline after being called\",\n-\t\t     locus, newdecl);\n+\t    warning (\"%J'%D' declared inline after being called\",\n+\t\t     newdecl, newdecl);\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && DECL_DECLARED_INLINE_P (newdecl)\n \t      && DECL_INITIAL (olddecl) != 0)\n-\t    warning (\"%H'%D' declared inline after its definition\",\n-\t\t     locus, newdecl);\n+\t    warning (\"%J'%D' declared inline after its definition\",\n+\t\t     newdecl, newdecl);\n \n \t  /* If pedantic, warn when static declaration follows a non-static\n \t     declaration.  Otherwise, do so only for functions.\t */\n \t  if ((pedantic || TREE_CODE (olddecl) == FUNCTION_DECL)\n \t      && TREE_PUBLIC (olddecl)\n \t      && !TREE_PUBLIC (newdecl))\n-\t    warning (\"%Hstatic declaration for '%D' follows non-static\",\n-\t\t     locus, newdecl);\n+\t    warning (\"%Jstatic declaration for '%D' follows non-static\",\n+\t\t     newdecl, newdecl);\n \n \t  /* If warn_traditional, warn when a non-static function\n \t     declaration follows a static one.\t*/\n \t  if (warn_traditional && !in_system_header\n \t      && TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && !TREE_PUBLIC (olddecl)\n \t      && TREE_PUBLIC (newdecl))\n-\t    warning (\"%Hnon-static declaration for '%D' follows static\",\n-\t\t     locus, newdecl);\n+\t    warning (\"%Jnon-static declaration for '%D' follows static\",\n+\t\t     newdecl, newdecl);\n \n \t  /* Warn when const declaration follows a non-const\n \t     declaration, but not for functions.  */\n \t  if (TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && !TREE_READONLY (olddecl)\n \t      && TREE_READONLY (newdecl))\n-\t    warning (\"%Hconst declaration for '%D' follows non-const\",\n-\t\t     locus, newdecl);\n+\t    warning (\"%Jconst declaration for '%D' follows non-const\",\n+\t\t     newdecl, newdecl);\n \t  /* These bits are logically part of the type, for variables.\n \t     But not for functions\n \t     (where qualifiers are not valid ANSI anyway).  */\n \t  else if (pedantic && TREE_CODE (olddecl) != FUNCTION_DECL\n \t      && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n \t\t  || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n-\t    pedwarn (\"%Htype qualifiers for '%D' conflict with previous \"\n-\t\t     \"declaration\", locus, newdecl);\n+\t    pedwarn (\"%Jtype qualifiers for '%D' conflict with previous \"\n+\t\t     \"declaration\", newdecl, newdecl);\n \t}\n     }\n \n@@ -1210,10 +1183,9 @@ duplicate_decls (tree newdecl, tree olddecl, int different_binding_level,\n       /* Don't warn about extern decl followed by (tentative) definition.  */\n       && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl)))\n     {\n-      warning (\"%Hredundant redeclaration of '%D' in same scope\",\n-               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-      warning (\"%Hprevious declaration of '%D'\",\n-               &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+      warning (\"%Jredundant redeclaration of '%D' in same scope\",\n+\t       newdecl, newdecl);\n+      warning (\"%Jprevious declaration of '%D'\", olddecl, olddecl);\n     }\n \n   /* Copy all the DECL_... slots specified in the new decl\n@@ -1820,8 +1792,7 @@ implicitly_declare (tree functionid)\n \t{\n \t  implicit_decl_warning (DECL_NAME (decl));\n \t  if (! DECL_FILE_SCOPE_P (decl))\n-\t    warning (\"%Hprevious declaration of '%D'\",\n-                     &DECL_SOURCE_LOCATION (decl), decl);\n+\t    warning (\"%Jprevious declaration of '%D'\", decl, decl);\n \t  C_DECL_IMPLICIT (decl) = 1;\n \t}\n       /* If this function is global, then it must already be in the\n@@ -2056,8 +2027,7 @@ declare_label (tree name)\n     if (dup == label)\n       {\n \terror (\"duplicate label declaration `%s'\", IDENTIFIER_POINTER (name));\n-\terror (\"%Hthis is a previous declaration\",\n-\t       &DECL_SOURCE_LOCATION (dup));\n+\terror (\"%Jthis is a previous declaration\", dup);\n \n \t/* Just use the previous declaration.  */\n \treturn dup;\n@@ -2092,12 +2062,11 @@ define_label (location_t location, tree name)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n-      location_t *prev_loc = &DECL_SOURCE_LOCATION (label);\n       error (\"%Hduplicate label `%D'\", &location, label);\n       if (DECL_INITIAL (label))\n-\terror (\"%H`%D' previously defined here\", prev_loc, label);\n+\terror (\"%J`%D' previously defined here\", label, label);\n       else\n-\terror (\"%H`%D' previously declared here\", prev_loc, label);\n+\terror (\"%J`%D' previously declared here\", label, label);\n       return 0;\n     }\n   else if (label && DECL_CONTEXT (label) == current_function_decl)\n@@ -2573,8 +2542,7 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n-    warning (\"%H'%D' is usually a function\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+    warning (\"%J'%D' is usually a function\", decl, decl);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -2697,8 +2665,7 @@ start_decl (tree declarator, tree declspecs, int initialized, tree attributes)\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (\"%Hinline function '%D' given attribute noinline\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+    warning (\"%Jinline function '%D' given attribute noinline\", decl, decl);\n \n   /* Add this decl to the current scope.\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n@@ -2769,14 +2736,12 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       type = TREE_TYPE (decl);\n \n       if (failure == 1)\n-\terror (\"%Hinitializer fails to determine size of '%D'\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jinitializer fails to determine size of '%D'\", decl, decl);\n \n       else if (failure == 2)\n \t{\n \t  if (do_default)\n-\t    error (\"%Harray size missing in '%D'\",\n-                   &DECL_SOURCE_LOCATION (decl), decl);\n+\t    error (\"%Jarray size missing in '%D'\", decl, decl);\n \t  /* If a `static' var's size isn't known,\n \t     make it extern as well as static, so it does not get\n \t     allocated.\n@@ -2792,8 +2757,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t warn only if the value is less than zero.  */\n       else if (pedantic && TYPE_DOMAIN (type) != 0\n \t      && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n-\terror (\"%Hzero or negative size array '%D'\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jzero or negative size array '%D'\", decl, decl);\n \n       layout_decl (decl, 0);\n     }\n@@ -2821,8 +2785,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t   is an error.  */\n \t\t!DECL_EXTERNAL (decl)))\n \t{\n-\t  error (\"%Hstorage size of '%D' isn't known\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jstorage size of '%D' isn't known\", decl, decl);\n \t  TREE_TYPE (decl) = error_mark_node;\n \t}\n \n@@ -2832,8 +2795,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \t    constant_expression_warning (DECL_SIZE (decl));\n \t  else\n-\t    error (\"%Hstorage size of '%D' isn't constant\",\n-                   &DECL_SOURCE_LOCATION (decl), decl);\n+\t    error (\"%Jstorage size of '%D' isn't constant\", decl, decl);\n \t}\n \n       if (TREE_USED (type))\n@@ -2916,8 +2878,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      if (TREE_CODE (decl) == VAR_DECL\n \t\t  && !DECL_REGISTER (decl)\n \t\t  && !TREE_STATIC (decl))\n-\t\twarning (\"%Hignoring asm-specifier for non-static local \"\n-                         \"variable '%D'\", &DECL_SOURCE_LOCATION (decl), decl);\n+\t\twarning (\"%Jignoring asm-specifier for non-static local \"\n+                         \"variable '%D'\", decl, decl);\n \t      else\n \t\tSET_DECL_ASSEMBLER_NAME (decl, get_identifier (asmspec));\n \t    }\n@@ -4402,8 +4364,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (inlinep)\n-\t  pedwarn (\"%Hvariable '%D' declared `inline'\",\n-                   &DECL_SOURCE_LOCATION (decl), decl);\n+\t  pedwarn (\"%Jvariable '%D' declared `inline'\", decl, decl);\n \n \tDECL_EXTERNAL (decl) = extern_ref;\n \n@@ -4616,8 +4577,8 @@ get_parm_info (int void_at_end)\n \tif (!TREE_ASM_WRITTEN (decl))\n \t  abort ();\n \n-\t  error (\"%Hparameter \\\"%D\\\" has just a forward declaration\",\n-\t\t &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jparameter \\\"%D\\\" has just a forward declaration\",\n+\t\t decl, decl);\n       }\n \n   /* Warn about any struct, union or enum tags defined within this\n@@ -4853,8 +4814,7 @@ detect_field_duplicates (tree fieldlist)\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n \t      if (DECL_NAME (y) == DECL_NAME (x))\n \t\t{\n-\t\t  error (\"%Hduplicate member '%D'\",\n-                         &DECL_SOURCE_LOCATION (x), x);\n+\t\t  error (\"%Jduplicate member '%D'\", x, x);\n \t\t  DECL_NAME (x) = NULL_TREE;\n \t\t}\n \t  }\n@@ -4870,8 +4830,7 @@ detect_field_duplicates (tree fieldlist)\n \t    slot = htab_find_slot (htab, y, INSERT);\n \t    if (*slot)\n \t      {\n-\t\terror (\"%Hduplicate member '%D'\",\n-                       &DECL_SOURCE_LOCATION (x), x);\n+\t\terror (\"%Jduplicate member '%D'\", x, x);\n \t\tDECL_NAME (x) = NULL_TREE;\n \t      }\n \t    *slot = y;\n@@ -4972,8 +4931,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t    constant_expression_warning (DECL_INITIAL (x));\n \t  else\n \t    {\n-\t      error (\"%Hbit-field '%D' width not an integer constant\",\n-                     &DECL_SOURCE_LOCATION (x), x);\n+\t      error (\"%Jbit-field '%D' width not an integer constant\", x, x);\n \t      DECL_INITIAL (x) = NULL;\n \t    }\n \t}\n@@ -4984,8 +4942,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE\n \t  && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n \t{\n-\t  error (\"%Hbit-field '%D' has invalid type\",\n-                 &DECL_SOURCE_LOCATION (x), x);\n+\t  error (\"%Jbit-field '%D' has invalid type\", x, x);\n \t  DECL_INITIAL (x) = NULL;\n \t}\n \n@@ -4997,8 +4954,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && !(TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n \t       && (TYPE_PRECISION (TREE_TYPE (x))\n \t\t   == TYPE_PRECISION (integer_type_node))))\n-\tpedwarn (\"%Hbit-field '%D' type invalid in ISO C\",\n-                 &DECL_SOURCE_LOCATION (x), x);\n+\tpedwarn (\"%Jbit-field '%D' type invalid in ISO C\", x, x);\n \n       /* Detect and ignore out of range field width and process valid\n \t field widths.  */\n@@ -5009,14 +4965,11 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t       ? CHAR_TYPE_SIZE : TYPE_PRECISION (TREE_TYPE (x)));\n \n \t  if (tree_int_cst_sgn (DECL_INITIAL (x)) < 0)\n-\t    error (\"%Hnegative width in bit-field '%D'\",\n-                   &DECL_SOURCE_LOCATION (x), x);\n+\t    error (\"%Jnegative width in bit-field '%D'\", x, x);\n \t  else if (0 < compare_tree_int (DECL_INITIAL (x), max_width))\n-\t    pedwarn (\"%Hwidth of '%D' exceeds its type\",\n-                     &DECL_SOURCE_LOCATION (x), x);\n+\t    pedwarn (\"%Jwidth of '%D' exceeds its type\", x, x);\n \t  else if (integer_zerop (DECL_INITIAL (x)) && DECL_NAME (x) != 0)\n-\t    error (\"%Hzero width for bit-field '%D'\",\n-                   &DECL_SOURCE_LOCATION (x), x);\n+\t    error (\"%Jzero width for bit-field '%D'\", x, x);\n \t  else\n \t    {\n \t      /* The test above has assured us that TREE_INT_CST_HIGH is 0.  */\n@@ -5029,8 +4982,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t\t      || (width\n \t\t\t  < min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n \t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))))))\n-\t\twarning (\"%H'%D' is narrower than values of its type\",\n-                         &DECL_SOURCE_LOCATION (x), x);\n+\t\twarning (\"%J'%D' is narrower than values of its type\", x, x);\n \n \t      DECL_SIZE (x) = bitsize_int (width);\n \t      DECL_BIT_FIELD (x) = 1;\n@@ -5047,20 +4999,16 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  && TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (x))) == NULL_TREE)\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n-\t    error (\"%Hflexible array member in union\",\n-                   &DECL_SOURCE_LOCATION (x));\n+\t    error (\"%Jflexible array member in union\", x);\n \t  else if (TREE_CHAIN (x) != NULL_TREE)\n-\t    error (\"%Hflexible array member not at end of struct\",\n-                   &DECL_SOURCE_LOCATION (x));\n+\t    error (\"%Jflexible array member not at end of struct\", x);\n \t  else if (! saw_named_field)\n-\t    error (\"%Hflexible array member in otherwise empty struct\",\n-                   &DECL_SOURCE_LOCATION (x));\n+\t    error (\"%Jflexible array member in otherwise empty struct\", x);\n \t}\n \n       if (pedantic && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (\"%Hinvalid use of structure with flexible array member\",\n-                 &DECL_SOURCE_LOCATION (x));\n+\tpedwarn (\"%Jinvalid use of structure with flexible array member\", x);\n \n       if (DECL_NAME (x))\n \tsaw_named_field = 1;\n@@ -5477,8 +5425,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n-    warning (\"%Hinline function '%D' given attribute noinline\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%Jinline function '%D' given attribute noinline\", decl1, decl1);\n \n   announce_function (decl1);\n \n@@ -5528,29 +5475,27 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t   && TREE_PUBLIC (decl1)\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (\"%Hno previous prototype for '%D'\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%Jno previous prototype for '%D'\", decl1, decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n-    warning (\"%H'%D' was used with no prototype before its definition\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%J'%D' was used with no prototype before its definition\",\n+\t     decl1, decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && ! MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning (\"%Hno previous declaration for '%D'\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%Jno previous declaration for '%D'\", decl1, decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0 && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n-    warning (\"%H`%D' was used with no declaration before its definition\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%J`%D' was used with no declaration before its definition\",\n+\t     decl1, decl1);\n \n   /* This is a definition, not a reference.\n      So normally clear DECL_EXTERNAL.\n@@ -5582,11 +5527,10 @@ start_function (tree declspecs, tree declarator, tree attributes)\n     {\n       tree args;\n       int argct = 0;\n-      const location_t *locus = &DECL_SOURCE_LOCATION (decl1);\n \n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (\"%Hreturn type of '%D' is not `int'\", locus, decl1);\n+\tpedwarn (\"%Jreturn type of '%D' is not `int'\", decl1, decl1);\n \n       for (args = TYPE_ARG_TYPES (TREE_TYPE (decl1)); args;\n \t   args = TREE_CHAIN (args))\n@@ -5601,26 +5545,26 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t    {\n \t    case 1:\n \t      if (TYPE_MAIN_VARIANT (type) != integer_type_node)\n-\t\tpedwarn (\"%Hfirst argument of '%D' should be `int'\",\n-                         locus, decl1);\n+\t\tpedwarn (\"%Jfirst argument of '%D' should be `int'\",\n+\t\t\t decl1, decl1);\n \t      break;\n \n \t    case 2:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Hsecond argument of '%D' should be 'char **'\",\n-                         locus, decl1);\n+\t\tpedwarn (\"%Jsecond argument of '%D' should be 'char **'\",\n+                         decl1, decl1);\n \t      break;\n \n \t    case 3:\n \t      if (TREE_CODE (type) != POINTER_TYPE\n \t\t  || TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n-\t\tpedwarn (\"%Hthird argument of '%D' should probably be \"\n-                         \"'char **'\", locus, decl1);\n+\t\tpedwarn (\"%Jthird argument of '%D' should probably be \"\n+                         \"'char **'\", decl1, decl1);\n \t      break;\n \t    }\n \t}\n@@ -5629,10 +5573,10 @@ start_function (tree declspecs, tree declarator, tree attributes)\n \t argument because it's only mentioned in an appendix of the\n \t standard.  */\n       if (argct > 0 && (argct < 2 || argct > 3))\n-\tpedwarn (\"%H'%D' takes only zero or two arguments\", locus, decl1);\n+\tpedwarn (\"%J'%D' takes only zero or two arguments\", decl1, decl1);\n \n       if (! TREE_PUBLIC (decl1))\n-\tpedwarn (\"%H'%D' is normally a non-static function\", locus, decl1);\n+\tpedwarn (\"%J'%D' is normally a non-static function\", decl1, decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -5688,8 +5632,8 @@ store_parm_decls_newstyle (void)\n \n   if (current_scope->parms || current_scope->names || current_scope->tags)\n     {\n-      error (\"%Hold-style parameter declarations in prototyped \"\n-\t     \"function definition\", &DECL_SOURCE_LOCATION (fndecl));\n+      error (\"%Jold-style parameter declarations in prototyped \"\n+\t     \"function definition\", fndecl);\n \n       /* Get rid of the old-style declarations.  */\n       poplevel (0, 0, 0);\n@@ -5702,7 +5646,7 @@ store_parm_decls_newstyle (void)\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl) == 0)\n-\terror (\"%Hparameter name omitted\", &DECL_SOURCE_LOCATION (decl));\n+\terror (\"%Jparameter name omitted\", decl);\n       else\n \t{\n \t  if (IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)))\n@@ -5777,32 +5721,30 @@ store_parm_decls_oldstyle (void)\n     {\n       if (TREE_VALUE (parm) == 0)\n \t{\n-\t  error (\"%Hparameter name missing from parameter list\",\n-\t\t &DECL_SOURCE_LOCATION (fndecl));\n+\t  error (\"%Jparameter name missing from parameter list\", fndecl);\n \t  TREE_PURPOSE (parm) = 0;\n \t  continue;\n \t}\n \n       decl = IDENTIFIER_SYMBOL_VALUE (TREE_VALUE (parm));\n       if (decl && DECL_CONTEXT (decl) == fndecl)\n \t{\n-\t  const location_t *locus = &DECL_SOURCE_LOCATION (decl);\n \t  /* If we got something other than a PARM_DECL it is an error.  */\n \t  if (TREE_CODE (decl) != PARM_DECL)\n-\t    error (\"%H\\\"%D\\\" declared as a non-parameter\", locus, decl);\n+\t    error (\"%J\\\"%D\\\" declared as a non-parameter\", decl, decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n \t  else if (DECL_WEAK (decl))\n \t    {\n-\t      error (\"%Hmultiple parameters named \\\"%D\\\"\", locus, decl);\n+\t      error (\"%Jmultiple parameters named \\\"%D\\\"\", decl, decl);\n \t      TREE_PURPOSE (parm) = 0;\n \t      continue;\n \t    }\n \t  /* If the declaration says \"void\", complain and turn it into\n \t     an int.  */\n \t  else if (VOID_TYPE_P (TREE_TYPE (decl)))\n \t    {\n-\t      error (\"%Hparameter \\\"%D\\\" declared void\", locus, decl);\n+\t      error (\"%Jparameter \\\"%D\\\" declared void\", decl, decl);\n \t      TREE_TYPE (decl) = integer_type_node;\n \t      DECL_ARG_TYPE (decl) = integer_type_node;\n \t      layout_decl (decl, 0);\n@@ -5811,16 +5753,15 @@ store_parm_decls_oldstyle (void)\n       /* If no declaration found, default to int.  */\n       else\n \t{\n-\t  const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n \t  decl = build_decl (PARM_DECL, TREE_VALUE (parm), integer_type_node);\n \t  DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n-\t  DECL_SOURCE_LOCATION (decl) = *locus;\n+\t  DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (fndecl);\n \t  pushdecl (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (\"%Htype of \\\"%D\\\" defaults to \\\"int\\\"\", locus, decl);\n+\t    pedwarn (\"%Jtype of \\\"%D\\\" defaults to \\\"int\\\"\", decl, decl);\n \t  else if (extra_warnings)\n-\t    warning (\"%Htype of \\\"%D\\\" defaults to \\\"int\\\"\", locus, decl);\n+\t    warning (\"%Jtype of \\\"%D\\\" defaults to \\\"int\\\"\", decl, decl);\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n@@ -5832,18 +5773,16 @@ store_parm_decls_oldstyle (void)\n \n   for (parm = current_scope->parms; parm; parm = TREE_CHAIN (parm))\n     {\n-      const location_t *locus = &DECL_SOURCE_LOCATION (parm);\n-\n       if (!COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n-\t  error (\"%Hparameter \\\"%D\\\" has incomplete type\", locus, parm);\n+\t  error (\"%Jparameter \\\"%D\\\" has incomplete type\", parm, parm);\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n       if (! DECL_WEAK (parm))\n \t{\n-\t  error (\"%Hdeclaration for parameter \\\"%D\\\" but no such parameter\",\n-\t\t locus, parm);\n+\t  error (\"%Jdeclaration for parameter \\\"%D\\\" but no such parameter\",\n+\t\t parm, parm);\n \n \t  /* Pretend the parameter was not missing.\n \t     This gets us to a standard state and minimizes\n@@ -6095,8 +6034,7 @@ finish_function ()\n \t  /* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned.\n \t     If warn_main is -1 (-Wno-main) we don't want to be warned.  */\n \t  if (!warn_main)\n-\t    pedwarn (\"%Hreturn type of '%D' is not `int'\",\n-                     &DECL_SOURCE_LOCATION (fndecl), fndecl);\n+\t    pedwarn (\"%Jreturn type of '%D' is not `int'\", fndecl, fndecl);\n \t}\n       else\n \t{\n@@ -6269,16 +6207,15 @@ check_for_loop_decls (void)\n \n   for (t = getdecls (); t; t = TREE_CHAIN (t))\n     {\n-      const location_t *locus = &DECL_SOURCE_LOCATION (t);\n       if (TREE_CODE (t) != VAR_DECL && DECL_NAME (t))\n-\terror (\"%Hdeclaration of non-variable '%D' in 'for' loop \"\n-               \"initial declaration\", locus, t);\n+\terror (\"%Jdeclaration of non-variable '%D' in 'for' loop \"\n+               \"initial declaration\", t, t);\n       else if (TREE_STATIC (t))\n-\terror (\"%Hdeclaration of static variable '%D' in 'for' loop \"\n-\t       \"initial declaration\", locus, t);\n+\terror (\"%Jdeclaration of static variable '%D' in 'for' loop \"\n+\t       \"initial declaration\", t, t);\n       else if (DECL_EXTERNAL (t))\n-\terror (\"%Hdeclaration of 'extern' variable '%D' in 'for' loop \"\n-               \"initial declaration\", locus, t);\n+\terror (\"%Jdeclaration of 'extern' variable '%D' in 'for' loop \"\n+               \"initial declaration\", t, t);\n     }\n }\n \f\n@@ -6600,10 +6537,8 @@ merge_translation_unit_decls (void)\n \t\t}\n \t      else\n \t\t{\n-\t\t  error (\"%Hredefinition of global '%D'\",\n-                         &DECL_SOURCE_LOCATION (decl), decl);\n-\t\t  error (\"%H'%D' previously defined here\",\n-                         &DECL_SOURCE_LOCATION (old_decl), old_decl);\n+\t\t  error (\"%Jredefinition of global '%D'\", decl, decl);\n+\t\t  error (\"%J'%D' previously defined here\", old_decl, old_decl);\n \t\t}\n \t    }\n \t  else"}, {"sha": "82fb593f440fc78efb7eb6486eee1216ab126ddc", "filename": "gcc/c-format.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -810,6 +810,9 @@ static const format_char_info gcc_diag_char_table[] =\n   /* %H will require \"location_t\" at runtime.  */\n   { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n \n+  /* These will require a \"tree\" at runtime.  */\n+  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+\n   { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n@@ -830,7 +833,7 @@ static const format_char_info gcc_cdiag_char_table[] =\n   { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n \n   { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n@@ -852,7 +855,7 @@ static const format_char_info gcc_cxxdiag_char_table[] =\n   { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADEFTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"+#\",   \"\"   },\n+  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"+#\",   \"\"   },\n \n   /* These accept either an `int' or an `enum tree_code' (which is handled as an `int'.)  */\n   { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n@@ -2401,19 +2404,24 @@ check_format_types (int *status, format_wanted_type *types)\n       {\n \tconst char *this;\n \tconst char *that;\n+\ttree tmp;\n+\n+\ttmp = TYPE_NAME (wanted_type);\n+\tif (TREE_CODE (tmp) == TYPE_DECL)\n+\t  tmp = DECL_NAME (tmp);\n+\tthis = IDENTIFIER_POINTER (tmp);\n \n-\tthis = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n \tthat = 0;\n \tif (TYPE_NAME (orig_cur_type) != 0\n \t    && TREE_CODE (orig_cur_type) != INTEGER_TYPE\n \t    && !(TREE_CODE (orig_cur_type) == POINTER_TYPE\n \t\t && TREE_CODE (TREE_TYPE (orig_cur_type)) == INTEGER_TYPE))\n \t  {\n-\t    if (TREE_CODE (TYPE_NAME (orig_cur_type)) == TYPE_DECL\n-\t\t&& DECL_NAME (TYPE_NAME (orig_cur_type)) != 0)\n-\t      that = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (orig_cur_type)));\n-\t    else\n-\t      that = IDENTIFIER_POINTER (TYPE_NAME (orig_cur_type));\n+\t    tmp = TYPE_NAME (orig_cur_type);\n+\t    if (TREE_CODE (tmp) == TYPE_DECL)\n+\t      tmp = DECL_NAME (tmp);\n+\t    if (tmp)\n+\t      that = IDENTIFIER_POINTER (tmp);\n \t  }\n \n \t/* A nameless type can't possibly match what the format wants.\n@@ -2471,7 +2479,6 @@ find_char_info_specifier_index (const format_char_info *fci, int c)\n   \n   /* We shouldn't be looking for a non-existent specifier.  */\n   abort ();\n-  \n }\n \n /* Given a format_length_info array FLI, and a character C, this\n@@ -2604,6 +2611,12 @@ init_dynamic_diag_info (void)\n \t  diag_fci[i].types[0].type = &loc;\n \t  diag_fci[i].pointer_count = 1;\n \t}\n+      if (t)\n+        {\n+\t  i = find_char_info_specifier_index (diag_fci, 'J');\n+\t  diag_fci[i].types[0].type = &t;\n+\t  diag_fci[i].pointer_count = 1;\n+\t}\n \n       /* Handle the __gcc_cdiag__ format specifics.  */\n       if (! cdiag_fci)\n@@ -2623,6 +2636,9 @@ init_dynamic_diag_info (void)\n \t  i = find_char_info_specifier_index (cdiag_fci, 'D');\n \t  cdiag_fci[i].types[0].type = &t;\n \t  cdiag_fci[i].pointer_count = 1;\n+\t  i = find_char_info_specifier_index (cdiag_fci, 'J');\n+\t  cdiag_fci[i].types[0].type = &t;\n+\t  cdiag_fci[i].pointer_count = 1;\n \t}\n \n       /* Handle the __gcc_cxxdiag__ format specifics.  */\n@@ -2643,6 +2659,9 @@ init_dynamic_diag_info (void)\n \t  i = find_char_info_specifier_index (cxxdiag_fci, 'D');\n \t  cxxdiag_fci[i].types[0].type = &t;\n \t  cxxdiag_fci[i].pointer_count = 1;\n+\t  i = find_char_info_specifier_index (cxxdiag_fci, 'J');\n+\t  cxxdiag_fci[i].types[0].type = &t;\n+\t  cxxdiag_fci[i].pointer_count = 1;\n \t}\n     }\n }"}, {"sha": "287cf300232f257f88e67e0bc19e9428df8dcbce", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -78,9 +78,8 @@ c_cannot_inline_tree_fn (tree *fnp)\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n     {\n       if (do_warning)\n-\twarning (\"%Hfunction '%F' can never be inlined because it \"\n-\t\t \"is supressed using -fno-inline\",\n-\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+\twarning (\"%Jfunction '%F' can never be inlined because it \"\n+\t\t \"is supressed using -fno-inline\", fn, fn);\n       goto cannot_inline;\n     }\n \n@@ -89,18 +88,16 @@ c_cannot_inline_tree_fn (tree *fnp)\n   if (!DECL_DECLARED_INLINE_P (fn) && !(*targetm.binds_local_p) (fn))\n     {\n       if (do_warning)\n-\twarning (\"%Hfunction '%F' can never be inlined because it might not \"\n-\t\t \"be bound within this unit of translation\",\n-\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+\twarning (\"%Jfunction '%F' can never be inlined because it might not \"\n+\t\t \"be bound within this unit of translation\", fn, fn);\n       goto cannot_inline;\n     }\n \n   if (! function_attribute_inlinable_p (fn))\n     {\n       if (do_warning)\n-\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n-\t\t \"attributes conflicting with inlining\",\n-\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+\twarning (\"%Jfunction '%F' can never be inlined because it uses \"\n+\t\t \"attributes conflicting with inlining\", fn, fn);\n       goto cannot_inline;\n     }\n \n@@ -114,9 +111,8 @@ c_cannot_inline_tree_fn (tree *fnp)\n       if (t)\n \t{\n \t  if (do_warning)\n-\t    warning (\"%Hfunction '%F' can never be inlined because it has \"\n-\t\t     \"pending sizes\",\n-\t\t     &DECL_SOURCE_LOCATION (fn), fn);\n+\t    warning (\"%Jfunction '%F' can never be inlined because it has \"\n+\t\t     \"pending sizes\", fn, fn);\n \t  goto cannot_inline;\n \t}\n     }\n@@ -128,9 +124,8 @@ c_cannot_inline_tree_fn (tree *fnp)\n       if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n \t{\n \t  if (do_warning)\n-\t    warning (\"%Hnested function '%F' can never be inlined because it \"\n-\t\t     \"has possibly saved pending sizes\",\n-\t\t     &DECL_SOURCE_LOCATION (fn), fn);\n+\t    warning (\"%Jnested function '%F' can never be inlined because it \"\n+\t\t     \"has possibly saved pending sizes\", fn, fn);\n \t  goto cannot_inline;\n \t}\n     }"}, {"sha": "141b9061cef2f201aebad7bf0c0f30f274c70f45", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -275,8 +275,8 @@ apply_pragma_weak (tree decl, tree value)\n   if (SUPPORTS_WEAK && DECL_EXTERNAL (decl) && TREE_USED (decl)\n       && !DECL_WEAK (decl) /* don't complain about a redundant #pragma */\n       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-    warning (\"%Happlying #pragma weak '%D' after first use results \"\n-             \"in unspecified behavior\", &DECL_SOURCE_LOCATION (decl), decl);\n+    warning (\"%Japplying #pragma weak '%D' after first use results \"\n+             \"in unspecified behavior\", decl, decl);\n \n   declare_weak (decl);\n }"}, {"sha": "fa4f93473c53061f80fe602352e6939c3da679bb", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1819,8 +1819,7 @@ try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n   if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n       && optimize > 0 && !TREE_ADDRESSABLE (fndecl))\n     {\n-      warning (\"%Hinlining failed in call to '%F'\",\n-               &DECL_SOURCE_LOCATION (fndecl), fndecl);\n+      warning (\"%Jinlining failed in call to '%F'\", fndecl, fndecl);\n       warning (\"called from here\");\n     }\n   (*lang_hooks.mark_addressable) (fndecl);\n@@ -2160,8 +2159,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n \t      && optimize > 0)\n \t    {\n-\t      warning (\"%Hcan't inline call to '%F'\",\n-                       &DECL_SOURCE_LOCATION (fndecl), fndecl);\n+\t      warning (\"%Jcan't inline call to '%F'\", fndecl, fndecl);\n \t      warning (\"called from here\");\n \t    }\n \t  (*lang_hooks.mark_addressable) (fndecl);"}, {"sha": "d25fd0da977f0189d7a757b23efe47bfba8a7dd9", "filename": "gcc/config/arm/pe.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Farm%2Fpe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Farm%2Fpe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -167,8 +167,7 @@ arm_mark_dllimport (decl)\n       && !DECL_VIRTUAL_P (decl)\n       && DECL_INITIAL (decl))\n     {\n-      error (\"%Hinitialized variable '%D' is marked dllimport\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jinitialized variable '%D' is marked dllimport\", decl, decl);\n       return;\n     }\n   /* Nor can they be static.  */\n@@ -177,8 +176,7 @@ arm_mark_dllimport (decl)\n       && !DECL_VIRTUAL_P (decl)\n       && 0 /*???*/)\n     {\n-      error (\"%Hstatic variable '%D' is marked dllimport\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jstatic variable '%D' is marked dllimport\", decl, decl);\n       return;\n     }\n "}, {"sha": "f376bc4c71086e81a2461efe3536fcf692d2b008", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -101,17 +101,16 @@ ix86_handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       if (TREE_CODE (node) == FUNCTION_DECL  && DECL_INITIAL (node)\n           && !DECL_INLINE (node))\n \t{\n-\t  error (\"%Hfunction `%D' definition is marked dllimport.\",\n-\t\t &DECL_SOURCE_LOCATION (node), node);\n+\t  error (\"%Jfunction `%D' definition is marked dllimport.\", node, node);\n \t  *no_add_attrs = true;\n \t}\n \n       else if (TREE_CODE (node) == VAR_DECL)\n \t{\n \t  if (DECL_INITIAL (node))\n \t    {\n-\t      error (\"%Hvariable `%D' definition is marked dllimport.\",\n-\t\t     &DECL_SOURCE_LOCATION (node), node);\n+\t      error (\"%Jvariable `%D' definition is marked dllimport.\",\n+\t\t     node, node);\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -130,8 +129,8 @@ ix86_handle_dll_attribute (tree * pnode, tree name, tree args, int flags,\n       && (TREE_CODE (node) == VAR_DECL\n \t  || TREE_CODE (node) == FUNCTION_DECL))\n     {\n-      error (\"%Hexternal linkage required for symbol '%D' because of '%s' attribute.\",\n-\t       &DECL_SOURCE_LOCATION (node), node, IDENTIFIER_POINTER (name));\n+      error (\"%Jexternal linkage required for symbol '%D' because of \"\n+\t     \"'%s' attribute.\", node, node, IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n \n@@ -245,8 +244,8 @@ i386_pe_dllimport_p (tree decl)\n \t{\n \t   /* Don't warn about artificial methods.  */\n \t  if (!DECL_ARTIFICIAL (decl))\n-\t    warning (\"%H function '%D' is defined after prior declaration as dllimport: attribute ignored\",\n-\t\t     &DECL_SOURCE_LOCATION (decl), decl);\n+\t    warning (\"%Jfunction '%D' is defined after prior declaration \"\n+\t\t     \"as dllimport: attribute ignored\", decl, decl);\n \t  return 0;\n \t}\n \n@@ -256,8 +255,8 @@ i386_pe_dllimport_p (tree decl)\n       else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))\n         {\n \t  if (extra_warnings)\n-\t    warning (\"%Hinline function '%D' is declared as dllimport: attribute ignored.\",\n-\t\t     &DECL_SOURCE_LOCATION (decl), decl);\n+\t    warning (\"%Jinline function '%D' is declared as dllimport: \"\n+\t\t     \"attribute ignored.\", decl, decl);\n \t  return 0;\n \t}\n \n@@ -268,8 +267,9 @@ i386_pe_dllimport_p (tree decl)\n \t       && !DECL_EXTERNAL (decl) && context_imp)\n \t{\n \t  if (!DECL_VIRTUAL_P (decl))\n-            error (\"%Hdefinition of static data member '%D' of dllimport'd class.\",\n-\t\t   &DECL_SOURCE_LOCATION (decl), decl);           return 0;\n+            error (\"%Jdefinition of static data member '%D' of \"\n+\t\t   \"dllimport'd class.\", decl, decl);\n+\t  return 0;\n \t}\n \n       /* Since we can't treat a pointer to a dllimport'd symbol as a\n@@ -326,8 +326,8 @@ i386_pe_mark_dllexport (tree decl)\n     abort ();\n   if (i386_pe_dllimport_name_p (oldname))\n     {\n-      warning (\"%Hinconsistent dll linkage for '%D', dllexport assumed.\",\n-\t       &DECL_SOURCE_LOCATION (decl), decl);\n+      warning (\"%Jinconsistent dll linkage for '%D', dllexport assumed.\",\n+\t       decl, decl);\n      /* Remove DLL_IMPORT_PREFIX.  */\n       oldname += strlen (DLL_IMPORT_PREFIX);\n       DECL_NON_ADDR_CONST_P (decl) = 0;\n@@ -377,8 +377,8 @@ i386_pe_mark_dllimport (tree decl)\n       /* Already done, but do a sanity check to prevent assembler errors. */\n       if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n \t{\n-\t  error (\"%Hfailure in redeclaration of '%D': dllimport'd symbol lacks external linkage.\",\n-\t\t &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jfailure in redeclaration of '%D': dllimport'd \"\n+\t\t \"symbol lacks external linkage.\", decl, decl);\n \t  abort();\n \t}\n       return;\n@@ -521,15 +521,17 @@ i386_pe_encode_section_info (tree decl, rtx rtl, int first)\n \t   && i386_pe_dllimport_name_p (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n     {\n       const char *oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n+\n       /* Remove DLL_IMPORT_PREFIX.  */\n       tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n       rtx newrtl = gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (idp));\n \n-      warning (\"%H%s '%D' %s after being referenced with dllimport linkage.\",\n-\t         &DECL_SOURCE_LOCATION (decl),\n-\t         TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n-\t         decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n-\t\t\t? \"defined locally\" : \"redeclared without dllimport attribute\");\n+      if (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n+\twarning (\"%J'%D' defined locally after being \"\n+\t\t \"referenced with dllimport linkage\", decl, decl);\n+      else\n+\twarning (\"%J'%D' redeclared without dllimport attribute \"\n+\t\t \"after being referenced with dllimport linkage\", decl, decl);\n \n       XEXP (DECL_RTL (decl), 0) = newrtl;\n \n@@ -699,8 +701,7 @@ i386_pe_section_type_flags (tree decl, const char *name, int reloc)\n   else\n     {\n       if (decl && **slot != flags)\n-\terror (\"%H'%D' causes a section type conflict\",\n-\t        &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%J'%D' causes a section type conflict\", decl, decl);\n     }\n \n   return flags;"}, {"sha": "f82981b07bff812f6541791b50b1ecbc779b66ce", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1030,22 +1030,22 @@ ia64_handle_model_attribute (tree *node, tree name, tree args, int flags ATTRIBU\n \t   == FUNCTION_DECL)\n \t  && !TREE_STATIC (decl))\n \t{\n-\t  error (\"%Ha an address area attribute cannot be specified for \"\n-\t\t \"local variables\", &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jan address area attribute cannot be specified for \"\n+\t\t \"local variables\", decl, decl);\n \t  *no_add_attrs = true;\n \t}\n       area = ia64_get_addr_area (decl);\n       if (area != ADDR_AREA_NORMAL && addr_area != area)\n \t{\n-\t  error (\"%Ha address area of '%s' conflicts with previous \"\n-\t\t \"declaration\", &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jaddress area of '%s' conflicts with previous \"\n+\t\t \"declaration\", decl, decl);\n \t  *no_add_attrs = true;\n \t}\n       break;\n \n     case FUNCTION_DECL:\n-      error (\"%Ha address area attribute cannot be specified for functions\",\n-\t     &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jaddress area attribute cannot be specified for functions\",\n+\t     decl, decl);\n       *no_add_attrs = true;\n       break;\n "}, {"sha": "fe44a1ee7fc0cca9b6660360d3756afa9e9878bc", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -3358,8 +3358,7 @@ mcore_mark_dllimport (decl)\n       && !DECL_VIRTUAL_P (decl)\n       && DECL_INITIAL (decl))\n     {\n-      error (\"%Hinitialized variable '%D' is marked dllimport\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jinitialized variable '%D' is marked dllimport\", decl, decl);\n       return;\n     }\n   "}, {"sha": "3c40da1815c3475e66fbd5072bb568ef1baf055d", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2257,8 +2257,8 @@ v850_handle_data_area_attribute (node, name, args, flags, no_add_attrs)\n     case VAR_DECL:\n       if (current_function_decl != NULL_TREE)\n \t{\n-          error (\"%Ha data area attribute cannot be specified for \"\n-                 \"local variables\", &DECL_SOURCE_LOCATION (decl), decl);\n+          error (\"%Jdata area attributes cannot be specified for \"\n+                 \"local variables\", decl, decl);\n \t  *no_add_attrs = true;\n \t}\n \n@@ -2268,8 +2268,8 @@ v850_handle_data_area_attribute (node, name, args, flags, no_add_attrs)\n       area = v850_get_data_area (decl);\n       if (area != DATA_AREA_NORMAL && data_area != area)\n \t{\n-\t  error (\"%Hdata area of '%D' conflicts with previous declaration\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jdata area of '%D' conflicts with previous declaration\",\n+                 decl, decl);\n \t  *no_add_attrs = true;\n \t}\n       break;"}, {"sha": "2734bf6f4d4fddc9eb360f3690808cf133cc4233", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1,3 +1,7 @@\n+2003-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c, decl2.c, pt.c: Use %J in diagnostics.\n+\n 2003-09-20  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/157"}, {"sha": "424ec8d37285de2e4b7502ad74af0112bf323541", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2362,11 +2362,9 @@ print_z_candidate (const char *msgstr, struct z_candidate *candidate)\n   else if (TYPE_P (candidate->fn))\n     inform (\"%s %T <conversion>\", msgstr, candidate->fn);\n   else if (candidate->viable == -1)\n-    inform (\"%H%s %+#D <near match>\",\n-\t    &DECL_SOURCE_LOCATION (candidate->fn), msgstr, candidate->fn);\n+    inform (\"%J%s %+#D <near match>\", candidate->fn, msgstr, candidate->fn);\n   else\n-    inform (\"%H%s %+#D\",\n-\t    &DECL_SOURCE_LOCATION (candidate->fn), msgstr, candidate->fn);\n+    inform (\"%J%s %+#D\", candidate->fn, msgstr, candidate->fn);\n }\n \n static void"}, {"sha": "892affacc82092635fe32b51ef8a69f034d6f085", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2755,19 +2755,18 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t       && DECL_UNINLINABLE (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warning (\"%Hfunction '%D' redeclared as inline\",\n-                   &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-\t  warning (\"%Hprevious declaration of '%D' with attribute noinline\",\n-                   &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\t  warning (\"%Jfunction '%D' redeclared as inline\", newdecl, newdecl);\n+\t  warning (\"%Jprevious declaration of '%D' with attribute noinline\",\n+                   olddecl, olddecl);\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && DECL_UNINLINABLE (newdecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (\"%Hfunction '%D' redeclared with attribute noinline\",\n-                   &DECL_SOURCE_LOCATION (newdecl), newdecl);\n-\t  warning (\"%Hprevious declaration of '%D' was inline\",\n-                   &DECL_SOURCE_LOCATION (olddecl), olddecl);\n+\t  warning (\"%Jfunction '%D' redeclared with attribute noinline\",\n+\t\t   newdecl, newdecl);\n+\t  warning (\"%Jprevious declaration of '%D' was inline\",\n+\t\t   olddecl, olddecl);\n \t}\n     }\n \n@@ -3009,8 +3008,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n \t  /* Prototype decl follows defn w/o prototype.  */\n \t  cp_warning_at (\"prototype for `%#D'\", newdecl);\n-\t  warning (\"%Hfollows non-prototype definition here\",\n-\t\t   &DECL_SOURCE_LOCATION (olddecl));\n+\t  warning (\"%Jfollows non-prototype definition here\", olddecl);\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl))\n@@ -3065,10 +3063,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && TREE_ADDRESSABLE (olddecl) && warn_inline)\n \t    {\n-\t      warning (\"`%#D' was used before it was declared inline\",\n-\t\t\t  newdecl);\n-\t      warning (\"%Hprevious non-inline declaration here\",\n-\t\t       &DECL_SOURCE_LOCATION (olddecl));\n+\t      warning (\"`%#D' was used before it was declared inline\", newdecl);\n+\t      warning (\"%Jprevious non-inline declaration here\", olddecl);\n \t    }\n \t}\n     }\n@@ -4790,7 +4786,7 @@ check_goto (tree decl)\n \n       if (u > 1 && DECL_ARTIFICIAL (b))\n \t/* Can't skip init of __exception_info.  */\n-\terror (\"%H  enters catch block\", &DECL_SOURCE_LOCATION (b));\n+\terror (\"%J  enters catch block\", b);\n       else if (u > 1)\n \tcp_error_at (\"  skips initialization of `%#D'\", b);\n       else\n@@ -6577,8 +6573,8 @@ fixup_anonymous_aggr (tree t)\n \n   /* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */\n   if (TYPE_METHODS (t))\n-    error (\"%Han anonymous union cannot have function members\",\n-\t   &DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (t)));\n+    error (\"%Jan anonymous union cannot have function members\",\n+\t   TYPE_MAIN_DECL (t));\n \n   /* Anonymous aggregates cannot have fields with ctors, dtors or complex\n      assignment operators (because they cannot have these methods themselves).\n@@ -6911,8 +6907,7 @@ start_decl (tree declarator,\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (\"%Hinline function '%D' given attribute noinline\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+    warning (\"%Jinline function '%D' given attribute noinline\", decl, decl);\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n@@ -7281,8 +7276,8 @@ maybe_commonize_var (tree decl)\n \t      TREE_PUBLIC (decl) = 0;\n \t      DECL_COMMON (decl) = 0;\n \t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n-\t      warning (\"%H  you can work around this by removing the initializer\",\n-\t\t       &DECL_SOURCE_LOCATION (decl));\n+\t      warning (\"%J  you can work around this by removing the initializer\",\n+\t\t       decl);\n \t    }\n \t}\n     }\n@@ -11019,8 +11014,7 @@ grokdeclarator (tree declarator,\n \t{\n \t  decl = build_decl (TYPE_DECL, declarator, type);\n \t  if (in_namespace || ctype)\n-\t    error (\"%Htypedef name may not be a nested-name-specifier\",\n-\t\t   &DECL_SOURCE_LOCATION (decl));\n+\t    error (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n \t  if (!current_function_decl)\n \t    DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);\n \t}\n@@ -11066,8 +11060,8 @@ grokdeclarator (tree declarator,\n \t  if (ctype == NULL_TREE)\n \t    {\n \t      if (TREE_CODE (type) != METHOD_TYPE)\n-\t\terror (\"%Hinvalid type qualifier for non-member function type\",\n-\t\t       &DECL_SOURCE_LOCATION (decl));\n+\t\terror (\"%Jinvalid type qualifier for non-member function type\",\n+\t\t       decl);\n \t      else\n \t\tctype = TYPE_METHOD_BASETYPE (type);\n \t    }\n@@ -12903,8 +12897,7 @@ start_enum (tree name)\n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n       error (\"multiple definition of `%#T'\", enumtype);\n-      error (\"%Hprevious definition here\",\n-\t     &DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)));\n+      error (\"%Jprevious definition here\", TYPE_MAIN_DECL (enumtype));\n       /* Clear out TYPE_VALUES, and start again.  */\n       TYPE_VALUES (enumtype) = NULL_TREE;\n     }\n@@ -13346,8 +13339,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n       && lookup_attribute (\"noinline\", attrs))\n-    warning (\"%Hinline function '%D' given attribute noinline\",\n-             &DECL_SOURCE_LOCATION (decl1), decl1);\n+    warning (\"%Jinline function '%D' given attribute noinline\", decl1, decl1);\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))\n     /* This is a constructor, we must ensure that any default args"}, {"sha": "b1ee970464e0c59c07619cac162e39147a1b817e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -3224,10 +3224,8 @@ ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n       if (flags & LOOKUP_COMPLAIN)\n         {\n           error (\"`%D' denotes an ambiguous type\",name);\n-          error (\"%H  first type here\",\n-\t\t &DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (BINDING_TYPE (old))));\n-          error (\"%H  other type here\",\n-\t\t &DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)));\n+          error (\"%J  first type here\", TYPE_MAIN_DECL (BINDING_TYPE (old)));\n+          error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n         }\n     }\n   return old;"}, {"sha": "12baea14a33b0711ba565fdcbfd462f1b6447f29", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2946,8 +2946,7 @@ redeclare_class_template (tree type, tree parms)\n \t     A template-parameter may not be given default arguments\n \t     by two different declarations in the same scope.  */\n \t  error (\"redefinition of default argument for `%#D'\", parm);\n-\t  error (\"%H  original definition appeared here\",\n-\t\t &DECL_SOURCE_LOCATION (tmpl_parm));\n+\t  error (\"%J  original definition appeared here\", tmpl_parm);\n \t  return;\n \t}\n "}, {"sha": "c29867a60b3546644e62c4fb7f9e6bb294b538ea", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -130,10 +130,17 @@ text_specifies_location (text_info *text, location_t *locus)\n     ;\n \n   /* Extract the location information if any.  */\n-  if (*p == '%' && *++p == 'H')\n+  if (p[0] == '%' && p[1] == 'H')\n     {\n       *locus = *va_arg (*text->args_ptr, location_t *);\n-      text->format_spec = p + 1;\n+      text->format_spec = p + 2;\n+      return true;\n+    }\n+  else if (p[0] == '%' && p[1] == 'J')\n+    {\n+      tree t = va_arg (*text->args_ptr, tree);\n+      *locus = DECL_SOURCE_LOCATION (t);\n+      text->format_spec = p + 2;\n       return true;\n     }\n "}, {"sha": "dfd1f0b57e1c6e4402b6cedd2fe7669f9278ab77", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2036,9 +2036,8 @@ output_reg_number (rtx rtl)\n \n   if (regno >= DWARF_FRAME_REGISTERS)\n     {\n-      warning (\"%Hinternal regno botch: '%D' has regno = %d\\n\",\n-               &DECL_SOURCE_LOCATION (dwarf_last_decl), dwarf_last_decl,\n-               regno);\n+      warning (\"%Jinternal regno botch: '%D' has regno = %d\\n\",\n+\t       dwarf_last_decl, dwarf_last_decl, regno);\n       regno = 0;\n     }\n   dw2_assemble_integer (4, GEN_INT (DBX_REGISTER_NUMBER (regno)));"}, {"sha": "633f4a755379699060abded00b9001cf91b1f38a", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -6757,8 +6757,7 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode,\n     case PARM_DECL:\n       if (!DECL_RTL_SET_P (exp))\n \t{\n-\t  error (\"%Hprior parameter's size depends on '%D'\",\n-                 &DECL_SOURCE_LOCATION (exp), exp);\n+\t  error (\"%Jprior parameter's size depends on '%D'\", exp, exp);\n \t  return CONST0_RTX (mode);\n \t}\n "}, {"sha": "baec4ab3048a3c337a2e54a0583d022abd3eeb83", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -880,8 +880,7 @@ assign_temp (tree type_or_decl, int keep, int memory_required,\n       if (decl && size == -1\n \t  && TREE_CODE (TYPE_SIZE_UNIT (type)) == INTEGER_CST)\n \t{\n-\t  error (\"%Hsize of variable '%D' is too large\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\t  error (\"%Jsize of variable '%D' is too large\", decl, decl);\n \t  size = 1;\n \t}\n \n@@ -5610,15 +5609,15 @@ uninitialized_vars_warning (tree block)\n \t     if we want to warn.  */\n \t  && (DECL_INITIAL (decl) == NULL_TREE || lang_hooks.decl_uninit (decl))\n \t  && regno_uninitialized (REGNO (DECL_RTL (decl))))\n-\twarning (\"%H'%D' might be used uninitialized in this function\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\twarning (\"%J'%D' might be used uninitialized in this function\",\n+\t\t decl, decl);\n       if (extra_warnings\n \t  && TREE_CODE (decl) == VAR_DECL\n \t  && DECL_RTL (decl) != 0\n \t  && GET_CODE (DECL_RTL (decl)) == REG\n \t  && regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-\twarning (\"%Hvariable '%D' might be clobbered by `longjmp' or `vfork'\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\twarning (\"%Jvariable '%D' might be clobbered by `longjmp' or `vfork'\",\n+\t\t decl, decl);\n     }\n   for (sub = BLOCK_SUBBLOCKS (block); sub; sub = TREE_CHAIN (sub))\n     uninitialized_vars_warning (sub);\n@@ -5636,8 +5635,8 @@ setjmp_args_warning (void)\n     if (DECL_RTL (decl) != 0\n \t&& GET_CODE (DECL_RTL (decl)) == REG\n \t&& regno_clobbered_at_setjmp (REGNO (DECL_RTL (decl))))\n-      warning (\"%Hargument '%D' might be clobbered by `longjmp' or `vfork'\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+      warning (\"%Jargument '%D' might be clobbered by `longjmp' or `vfork'\",\n+\t       decl, decl);\n }\n \n /* If this function call setjmp, put all vars into the stack\n@@ -6895,8 +6894,7 @@ expand_function_end (void)\n \t   decl; decl = TREE_CHAIN (decl))\n \tif (! TREE_USED (decl) && TREE_CODE (decl) == PARM_DECL\n \t    && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-          warning (\"%Hunused parameter '%D'\",\n-                   &DECL_SOURCE_LOCATION (decl), decl);\n+          warning (\"%Junused parameter '%D'\", decl, decl);\n     }\n \n   /* Delete handlers for nonlocal gotos if nothing uses them.  */"}, {"sha": "a14c1db559734ae9b396c15aaaaa7e0863c66cdf", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1,3 +1,7 @@\n+2003-09-20  Richard Henderson  <rth@redhat.com>\n+\n+        * check-init.c, class.c, decl.c, expr.c: Use %J in diagnostics.\n+\n 2003-09-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* expr.c (java_truthvalue_conversion): Remove FFS_EXPR case."}, {"sha": "03af2faf1cfd4313d7cc62c982ae7b741cb8be71", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -976,8 +976,8 @@ check_for_initialization (tree body, tree mdecl)\n \t      if (index >= 0 && ! ASSIGNED_P (before, index))\n \t\t{\n \t\t  if (! is_finit_method)\n-\t\t    error (\"%Hfinal field '%D' may not have been initialized\",\n-                           &DECL_SOURCE_LOCATION (decl), decl);\n+\t\t    error (\"%Jfinal field '%D' may not have been initialized\",\n+                           decl, decl);\n \t\t}\n \t      else if (is_finit_method)\n \t\tDECL_FIELD_FINAL_IUD (decl) = 1;"}, {"sha": "e3e6cc36e586b5f6b65a3cf5d0b45c8496e08a50", "filename": "gcc/java/class.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1211,8 +1211,7 @@ get_dispatch_table (tree type, tree this_class_addr)\n       if (METHOD_ABSTRACT (method))\n \t{\n \t  if (! abstract_p)\n-\t    warning (\"%Habstract method in non-abstract class\",\n-                     &DECL_SOURCE_FILE (method));\n+\t    warning (\"%Jabstract method in non-abstract class\", method);\n \n \t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n \t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n@@ -1986,8 +1985,8 @@ layout_class_method (tree this_class, tree super_class,\n \t  DECL_VINDEX (method_decl) = DECL_VINDEX (super_method);\n \t  if (DECL_VINDEX (method_decl) == NULL_TREE \n \t      && !CLASS_FROM_SOURCE_P (this_class))\n-\t    error (\"%Hnon-static method '%D' overrides static method\",\n-                   &DECL_SOURCE_LOCATION (method_decl), method_decl);\n+\t    error (\"%Jnon-static method '%D' overrides static method\",\n+                   method_decl, method_decl);\n \t}\n       else if (! METHOD_FINAL (method_decl)\n \t       && ! METHOD_PRIVATE (method_decl)"}, {"sha": "7ddf704efad777761819a36d89d122accde601cf", "filename": "gcc/java/decl.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1019,8 +1019,7 @@ pushdecl (tree x)\n \t/* error_mark_node is 0 for a while during initialization!  */\n \t{\n \t  t = 0;\n-\t  error (\"%H'%D' used prior to declaration\",\n-                 &DECL_SOURCE_LOCATION (x), x);\n+\t  error (\"%J'%D' used prior to declaration\", x, x);\n \t}\n \n       /* If we're naming a hitherto-unnamed type, set its TYPE_NAME\n@@ -1356,14 +1355,12 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t  if (DECL_INITIAL (label) == 0)\n \t    {\n-\t      error (\"%Hlabel '%D' used but not defined\",\n-                     &DECL_SOURCE_LOCATION (label), label);\n+\t      error (\"%Jlabel '%D' used but not defined\", label, label);\n \t      /* Avoid crashing later.  */\n \t      define_label (input_location, DECL_NAME (label));\n \t    }\n \t  else if (warn_unused[UNUSED_LABEL] && !TREE_USED (label))\n-\t    warning (\"%Hlabel '%D' defined but not used\",\n-                     &DECL_SOURCE_LOCATION (label), label);\n+\t    warning (\"%Jlabel '%D' defined but not used\", label, label);\n \t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n \n \t  /* Put the labels into the \"variables\" of the\n@@ -1491,9 +1488,9 @@ force_poplevels (int start_pc)\n   while (current_binding_level->start_pc > start_pc)\n     {\n       if (pedantic && current_binding_level->start_pc > start_pc)\n-\twarning (\"%HIn %D: overlapped variable and exception ranges at %d\",\n-                 &DECL_SOURCE_LOCATION (current_function_decl),\n-                 current_function_decl, current_binding_level->start_pc);\n+\twarning (\"%JIn %D: overlapped variable and exception ranges at %d\",\n+                 current_function_decl, current_function_decl,\n+\t\t current_binding_level->start_pc);\n       expand_end_bindings (getdecls (), 1, 0);\n       poplevel (1, 0, 0);\n     }\n@@ -1578,8 +1575,8 @@ give_name_to_locals (JCF *jcf)\n \t  tree decl = build_decl (VAR_DECL, name, type);\n \t  if (end_pc > DECL_CODE_LENGTH (current_function_decl))\n \t    {\n-\t      warning (\"%Hbad PC range for debug info for local '%D'\",\n-                       &DECL_SOURCE_LOCATION (decl), decl);\n+\t      warning (\"%Jbad PC range for debug info for local '%D'\",\n+\t\t       decl, decl);\n \t      end_pc = DECL_CODE_LENGTH (current_function_decl);\n \t    }\n "}, {"sha": "803c2deff83da818f335eb23c6335e1626460b15", "filename": "gcc/java/expr.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -2335,22 +2335,21 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n       if (FIELD_FINAL (field_decl))\n \t{\n \t  if (DECL_CONTEXT (field_decl) != current_class)\n-            error (\"%Hassignment to final field '%D' not in field's class\",\n-                   &DECL_SOURCE_LOCATION (field_decl), field_decl);\n+            error (\"%Jassignment to final field '%D' not in field's class\",\n+\t\t   field_decl, field_decl);\n \t  else if (FIELD_STATIC (field_decl))\n \t    {\n \t      if (!DECL_CLINIT_P (current_function_decl))\n-\t\twarning (\"assignment to final static field `%s' not in \"\n-                         \"class initializer\",\n-                         &DECL_SOURCE_LOCATION (field_decl), field_decl);\n+\t\twarning (\"%Jassignment to final static field `%D' not in \"\n+                         \"class initializer\", field_decl, field_decl);\n \t    }\n \t  else\n \t    {\n \t      tree cfndecl_name = DECL_NAME (current_function_decl);\n \t      if (! DECL_CONSTRUCTOR_P (current_function_decl)\n \t\t  && !ID_FINIT_P (cfndecl_name))\n-                warning (\"%Hassignment to final field '%D' not in constructor\",\n-                         &DECL_SOURCE_LOCATION (field_decl),  field_decl);\n+                warning (\"%Jassignment to final field '%D' not in constructor\",\n+\t\t\t field_decl, field_decl);\n \t    }\n \t}\n       expand_assignment (field_ref, new_value, 0);"}, {"sha": "0c07543050204b744e1cf147a8560186529f07a9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -890,8 +890,7 @@ objc_check_decl (tree decl)\n   if (TREE_CODE (type) == RECORD_TYPE\n       && TREE_STATIC_TEMPLATE (type)\n       && type != constant_string_type)\n-    error (\"%H'%D' cannot be statically allocated\",\n-           &DECL_SOURCE_LOCATION (decl), decl);\n+    error (\"%J'%D' cannot be statically allocated\", decl, decl);\n }\n \n /* Implement static typing.  At this point, we know we have an interface.  */\n@@ -2314,9 +2313,8 @@ objc_declare_class (tree ident_list)\n       if ((decl = lookup_name (ident)))\n \t{\n \t  error (\"`%s' redeclared as different kind of symbol\",\n-\t\t  IDENTIFIER_POINTER (ident));\n-\t  error (\"%Hprevious declaration of '%D'\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\t\t IDENTIFIER_POINTER (ident));\n+\t  error (\"%Jprevious declaration of '%D'\", decl, decl);\n \t}\n \n       if (! is_class_name (ident))\n@@ -3414,9 +3412,7 @@ synth_forward_declarations (void)\n static void\n error_with_ivar (const char *message, tree decl, tree rawdecl)\n {\n-  error (\"%H%s `%s'\", &DECL_SOURCE_LOCATION (decl),\n-         message, gen_declaration (rawdecl, errbuf));\n-\n+  error (\"%J%s `%s'\", decl, message, gen_declaration (rawdecl, errbuf));\n }\n \n static void\n@@ -5934,8 +5930,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n     {\n       error (\"`%s' redeclared as different kind of symbol\",\n \t     IDENTIFIER_POINTER (class_name));\n-      error (\"%Hprevious declaration of '%D'\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jprevious declaration of '%D'\", decl, decl);\n     }\n \n   if (code == CLASS_IMPLEMENTATION_TYPE)\n@@ -6825,8 +6820,8 @@ static void\n warn_with_method (const char *message, int mtype, tree method)\n {\n   /* Add a readable method name to the warning.  */\n-  warning (\"%H%s `%c%s'\", &DECL_SOURCE_LOCATION (method),\n-           message, mtype, gen_method_decl (method, errbuf));\n+  warning (\"%J%s `%c%s'\", method, message, mtype,\n+\t   gen_method_decl (method, errbuf));\n }\n \n /* Return 1 if METHOD is consistent with PROTO.  */"}, {"sha": "9d5553f2517263fb996b4223acb0dda00d0b1687", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -966,8 +966,8 @@ fixup_gotos (struct nesting *thisblock, rtx stack_level,\n \t      && INSN_UID (first_insn) > INSN_UID (f->before_jump)\n \t      && ! DECL_ERROR_ISSUED (f->target))\n \t    {\n-\t      error (\"%Hlabel '%D' used before containing binding contour\",\n-                     &DECL_SOURCE_LOCATION (f->target), f->target);\n+\t      error (\"%Jlabel '%D' used before containing binding contour\",\n+\t\t     f->target, f->target);\n \t      /* Prevent multiple errors for one label.  */\n \t      DECL_ERROR_ISSUED (f->target) = 1;\n \t    }\n@@ -3631,7 +3631,7 @@ warn_about_unused_variables (tree vars)\n \t  && ! TREE_USED (decl)\n \t  && ! DECL_IN_SYSTEM_HEADER (decl)\n \t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\twarning (\"%Hunused variable '%D'\", &DECL_SOURCE_LOCATION (decl), decl);\n+\twarning (\"%Junused variable '%D'\", decl, decl);\n }\n \n /* Generate RTL code to terminate a binding contour.\n@@ -3691,8 +3691,8 @@ expand_end_bindings (tree vars, int mark_ends, int dont_jump_in)\n \t     that must be an error, because gotos without fixups\n \t     come from outside all saved stack-levels.  */\n \t  if (TREE_ADDRESSABLE (chain->label))\n-\t    error (\"%Hlabel '%D' used before containing binding contour\",\n-                   &DECL_SOURCE_LOCATION (chain->label), chain->label);\n+\t    error (\"%Jlabel '%D' used before containing binding contour\",\n+\t\t   chain->label, chain->label);\n \t}\n     }\n "}, {"sha": "728b70bf9c6bfdd1d11f4148e0fe836d1ee2553a", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -516,11 +516,10 @@ layout_decl (tree decl, unsigned int known_align)\n \t  int size_as_int = TREE_INT_CST_LOW (size);\n \n \t  if (compare_tree_int (size, size_as_int) == 0)\n-\t    warning (\"%Hsize of '%D' is %d bytes\",\n-                     &DECL_SOURCE_LOCATION (decl), decl, size_as_int);\n+\t    warning (\"%Jsize of '%D' is %d bytes\", decl, decl, size_as_int);\n \t  else\n-\t    warning (\"size of '%D' is larger than %d bytes\",\n-                     &DECL_SOURCE_LOCATION (decl), decl, larger_than_size);\n+\t    warning (\"%Jsize of '%D' is larger than %d bytes\",\n+                     decl, decl, larger_than_size);\n \t}\n     }\n \n@@ -885,11 +884,11 @@ place_field (record_layout_info rli, tree field)\n \t  if (TYPE_ALIGN (type) > desired_align)\n \t    {\n \t      if (STRICT_ALIGNMENT)\n-\t\twarning (\"%Hpacked attribute causes inefficient alignment \"\n-                         \"for '%D'\", &DECL_SOURCE_LOCATION (field), field);\n+\t\twarning (\"%Jpacked attribute causes inefficient alignment \"\n+                         \"for '%D'\", field, field);\n \t      else\n-\t\twarning (\"%Hpacked attribute is unnecessary for '%D'\",\n-                         &DECL_SOURCE_LOCATION (field), field);\n+\t\twarning (\"%Jpacked attribute is unnecessary for '%D'\",\n+\t\t\t field, field);\n \t    }\n \t}\n       else\n@@ -904,8 +903,7 @@ place_field (record_layout_info rli, tree field)\n \t Bump the cumulative size to multiple of field alignment.  */\n \n       if (warn_padded)\n-\twarning (\"%Hpadding struct to align '%D'\",\n-                 &DECL_SOURCE_LOCATION (field), field);\n+\twarning (\"%Jpadding struct to align '%D'\", field, field);\n \n       /* If the alignment is still within offset_align, just align\n \t the bit position.  */"}, {"sha": "a65e623fd40f95ceee7ea439b9015b013fe97aae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1,3 +1,7 @@\n+2003-09-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/format/gcc_diag-1.c: Add tests for %J.\n+\n 2003-09-20  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.c-torture/execute/20030920-1.c: New test case."}, {"sha": "69e572e73853371b0b3c6bd39428e5c9707f60c8", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-1.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-1.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -60,6 +60,9 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   diag (\"%H\", loc);\n   cdiag (\"%H\", loc);\n   cxxdiag (\"%H\", loc);\n+  diag (\"%J\", t1);\n+  cdiag (\"%J\", t1);\n+  cxxdiag (\"%J\", t1);\n \n   cdiag (\"%D%F%T\", t1, t1, t1);\n   cdiag (\"%D%D%D%D\", t1, t2, *t3, t4[5]);\n@@ -83,12 +86,18 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   diag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n   cdiag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n   cxxdiag (\"%H\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  diag (\"%J\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cdiag (\"%J\"); /* { dg-warning \"format\" \"missing arg\" } */\n+  cxxdiag (\"%J\"); /* { dg-warning \"format\" \"missing arg\" } */\n   diag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n   cdiag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n   cxxdiag (\"%H\", i); /* { dg-warning \"format\" \"wrong arg\" } */\n   diag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n   cdiag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n   cxxdiag (\"%H\", p); /* { dg-warning \"format\" \"wrong arg\" } */\n+  diag (\"%J\", loc); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cdiag (\"%J\", loc); /* { dg-warning \"format\" \"wrong arg\" } */\n+  cxxdiag (\"%J\", loc); /* { dg-warning \"format\" \"wrong arg\" } */\n   diag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cdiag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */\n   cxxdiag (\"%#H\", loc); /* { dg-warning \"format\" \"bogus modifier\" } */"}, {"sha": "03485bc8aed04ff4117ca955eafec4b7a32c13a3", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -1663,11 +1663,9 @@ check_global_declarations (tree *vec, int len)\n \t  && ! TREE_PUBLIC (decl))\n \t{\n \t  if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t    pedwarn (\"%H'%F' used but never defined\",\n-                     &DECL_SOURCE_LOCATION (decl), decl);\n+\t    pedwarn (\"%J'%F' used but never defined\", decl, decl);\n \t  else\n-\t    warning (\"%H'%F' declared `static' but never defined\",\n-                     &DECL_SOURCE_LOCATION (decl), decl);\n+\t    warning (\"%J'%F' declared `static' but never defined\", decl, decl);\n \t  /* This symbol is effectively an \"extern\" declaration now.  */\n \t  TREE_PUBLIC (decl) = 1;\n \t  assemble_external (decl);\n@@ -1688,8 +1686,7 @@ check_global_declarations (tree *vec, int len)\n \t  && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n \t  /* Otherwise, ask the language.  */\n \t  && (*lang_hooks.decls.warn_unused_global) (decl))\n-\twarning (\"%H'%D' defined but not used\",\n-                 &DECL_SOURCE_LOCATION (decl), decl);\n+\twarning (\"%J'%D' defined but not used\", decl, decl);\n \n       /* Avoid confusing the debug information machinery when there are\n \t errors.  */\n@@ -2575,11 +2572,8 @@ rest_of_handle_inlining (tree decl)\n \t{\n \t  if (warn_inline && lose && DECL_INLINE (decl))\n             {\n-              char *msg = xmalloc (2 + strlen (lose) + 1);\n-              msg[0] = '%';\n-              msg[1] = 'H';\n-              strcpy(msg + 2, lose);\n-              warning (msg, &DECL_SOURCE_LOCATION (decl));\n+              char *msg = concat (\"%J\", lose, NULL);\n+              warning (msg, decl);\n               free (msg);\n             }\n \t  DECL_ABSTRACT_ORIGIN (decl) = 0;"}, {"sha": "e4e24b2b3b27e6a7a6c1f22c3784b96ecb28cce7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -38,6 +38,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"splay-tree.h\"\n #include \"langhooks.h\"\n #include \"cgraph.h\"\n+#include \"intl.h\"\n+\n \n /* This should be eventually be generalized to other languages, but\n    this would require a shared function-as-trees infrastructure.  */\n@@ -896,9 +898,9 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (alloca_call_p (node)\n \t  && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n \t{\n-\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t    \"because it uses alloca (override using \"\n-\t\t\t\t    \"the always_inline attribute)\";\n+\t  inline_forbidden_reason\n+\t    = N_(\"%Jfunction '%F' can never be inlined because it uses \"\n+\t\t \"alloca (override using the always_inline attribute)\");\n \t  return node;\n \t}\n       t = get_callee_fndecl (node);\n@@ -909,8 +911,8 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       /* We cannot inline functions that call setjmp.  */\n       if (setjmp_call_p (t))\n \t{\n-\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined\"\n-\t\t\t\t    \" because it uses setjmp\";\n+\t  inline_forbidden_reason\n+\t    = N_(\"%Jfunction '%F' can never be inlined because it uses setjmp\");\n \t  return node;\n \t}\n \n@@ -921,8 +923,9 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \tcase BUILT_IN_VA_START:\n \tcase BUILT_IN_STDARG_START:\n \t  {\n-\t    inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t      \"because it uses variable argument lists\";\n+\t    inline_forbidden_reason\n+\t      = N_(\"%Jfunction '%F' can never be inlined because it \"\n+\t\t   \"uses variable argument lists\");\n \t    return node;\n \t  }\n \tcase BUILT_IN_LONGJMP:\n@@ -935,9 +938,9 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t    /* ??? Need front end help to identify \"regular\" non-local goto.  */\n             if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL)\n \t      {\n-\t\tinline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t\t  \"because it uses setjmp-longjmp \"\n-\t\t\t\t\t  \"exception handling\";\n+\t\tinline_forbidden_reason\n+\t\t  = N_(\"%Jfunction '%F' can never be inlined \"\n+\t\t       \"because it uses setjmp-longjmp exception handling\");\n \t        return node;\n \t      }\n \t  }\n@@ -953,8 +956,9 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n \t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n \t{\n-\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t    \"because it contains a nested function\";\n+\t  inline_forbidden_reason\n+\t    = N_(\"%Jfunction '%F' can never be inlined \"\n+\t\t \"because it contains a nested function\");\n \t  return node;\n \t}\n       break;\n@@ -969,17 +973,19 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t instantiations, which causes unexpected behavior.  */\n       if (TREE_CODE (t) != LABEL_DECL)\n \t{\n-\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t    \"because it contains a nonlocal label\";\n+\t  inline_forbidden_reason\n+\t    = N_(\"%Jfunction '%F' can never be inlined \"\n+\t\t \"because it contains a computed goto\");\n \t  return node;\n \t}\n \n       /* We cannot inline a nested function that jumps to a nonlocal\n          label.  */\n       if (TREE_CODE (t) == LABEL_DECL && DECL_CONTEXT (t) != fn)\n \t{\n-\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t    \"because it contains a nonlocal goto\";\n+\t  inline_forbidden_reason\n+\t    = N_(\"%Jfunction '%F' can never be inlined \"\n+\t\t \"because it contains a nonlocal goto\");\n \t  return node;\n \t}\n \n@@ -1000,8 +1006,9 @@ inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n       for (t = TYPE_FIELDS (node); t; t = TREE_CHAIN (t))\n \tif (variably_modified_type_p (TREE_TYPE (t)))\n \t  {\n-\t    inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n-\t\t\t\t      \"because it uses variable sized variables\";\n+\t    inline_forbidden_reason\n+\t      = N_(\"%Jfunction '%F' can never be inlined \"\n+\t\t   \"because it uses variable sized variables\");\n \t    return node;\n \t  }\n #endif\n@@ -1089,8 +1096,7 @@ inlinable_function_p (tree fn)\n \t\t\t && !DECL_IN_SYSTEM_HEADER (fn));\n \n       if (do_warning)\n-\twarning (inline_forbidden_reason,\n-\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+\twarning (inline_forbidden_reason, fn, fn);\n \n       inlinable = false;\n     }\n@@ -1302,8 +1308,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       if (warn_inline && DECL_INLINE (fn) && DECL_DECLARED_INLINE_P (fn)\n \t  && !DECL_IN_SYSTEM_HEADER (fn))\n \t{\n-\t  warning (\"%Hinlining failed in call to '%F'\",\n-                   &DECL_SOURCE_LOCATION (fn), fn);\n+\t  warning (\"%Jinlining failed in call to '%F'\", fn, fn);\n \t  warning (\"called from here\");\n \t}\n       return NULL_TREE;"}, {"sha": "e6049cb2b29c6300418a0a1e314690e6cf23ac93", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -183,16 +183,15 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n \t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n \t\t\t\t   larger_than_size))\n \t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n \t  unsigned int size_as_int\n \t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n \n \t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n-\t    warning (\"%Hsize of return value of '%D' is %u bytes\",\n-                     locus, fndecl, size_as_int);\n+\t    warning (\"%Jsize of return value of '%D' is %u bytes\",\n+                     fndecl, fndecl, size_as_int);\n \t  else\n-\t    warning (\"%Hsize of return value of '%D' is larger than %wd bytes\",\n-                     locus, fndecl, larger_than_size);\n+\t    warning (\"%Jsize of return value of '%D' is larger than %wd bytes\",\n+                     fndecl, fndecl, larger_than_size);\n \t}\n     }\n "}, {"sha": "d0bdbc15bdcf1f12ffd049cce50a09b1e586bda5", "filename": "gcc/varasm.c", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd2d57e722237230da8eea70a2fcecb11bd0f81/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ddd2d57e722237230da8eea70a2fcecb11bd0f81", "patch": "@@ -432,8 +432,7 @@ named_section (tree decl, const char *name, int reloc)\n     {\n       flags = get_named_section_flags (name);\n       if ((flags & SECTION_OVERRIDE) == 0)\n-\terror (\"%H%D causes a section type conflict\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%J%D causes a section type conflict\", decl, decl);\n     }\n \n   named_section_flags (name, flags);\n@@ -803,17 +802,15 @@ make_decl_rtl (tree decl, const char *asmspec)\n     {\n       /* First detect errors in declaring global registers.  */\n       if (reg_number == -1)\n-\terror (\"%Hregister name not specified for '%D'\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jregister name not specified for '%D'\", decl, decl);\n       else if (reg_number < 0)\n-\terror (\"%Hinvalid register name for '%D'\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jinvalid register name for '%D'\", decl, decl);\n       else if (TYPE_MODE (TREE_TYPE (decl)) == BLKmode)\n-\terror (\"%Hdata type of '%D' isn't suitable for a register\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jdata type of '%D' isn't suitable for a register\",\n+\t       decl, decl);\n       else if (! HARD_REGNO_MODE_OK (reg_number, TYPE_MODE (TREE_TYPE (decl))))\n-\terror (\"%Hregister specified for '%D' isn't suitable for data type\",\n-               &DECL_SOURCE_LOCATION (decl), decl);\n+\terror (\"%Jregister specified for '%D' isn't suitable for data type\",\n+               decl, decl);\n       /* Now handle properly declared static register variables.  */\n       else\n \t{\n@@ -857,8 +854,7 @@ make_decl_rtl (tree decl, const char *asmspec)\n      Also handle vars declared register invalidly.  */\n \n   if (reg_number >= 0 || reg_number == -3)\n-    error (\"%Hregister name given for non-register variable '%D'\",\n-           &DECL_SOURCE_LOCATION (decl), decl);\n+    error (\"%Jregister name given for non-register variable '%D'\", decl, decl);\n \n   /* Specifying a section attribute on a variable forces it into a\n      non-.bss section, and thus it cannot be common.  */\n@@ -1380,9 +1376,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   if (!dont_output_data && DECL_SIZE (decl) == 0)\n     {\n-      error (\"%Hstorage size of `%s' isn't known\",\n-             &DECL_SOURCE_LOCATION (decl),\n-             IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      error (\"%Jstorage size of `%D' isn't known\", decl, decl);\n       TREE_ASM_WRITTEN (decl) = 1;\n       return;\n     }\n@@ -1410,8 +1404,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   if (! dont_output_data\n       && ! host_integerp (DECL_SIZE_UNIT (decl), 1))\n     {\n-      error (\"%Hsize of variable '%D' is too large\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+      error (\"%Jsize of variable '%D' is too large\", decl, decl);\n       return;\n     }\n \n@@ -1437,9 +1430,9 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n #endif\n   if (align > MAX_OFILE_ALIGNMENT)\n     {\n-      warning (\"%Halignment of '%D' is greater than maximum object \"\n-               \"file alignment.  Using %d\", &DECL_SOURCE_LOCATION (decl),\n-               decl, MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n+      warning (\"%Jalignment of '%D' is greater than maximum object \"\n+               \"file alignment.  Using %d\", decl, decl,\n+\t       MAX_OFILE_ALIGNMENT/BITS_PER_UNIT);\n       align = MAX_OFILE_ALIGNMENT;\n     }\n \n@@ -1505,9 +1498,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n #if !defined(ASM_OUTPUT_ALIGNED_COMMON) && !defined(ASM_OUTPUT_ALIGNED_DECL_COMMON) && !defined(ASM_OUTPUT_ALIGNED_BSS)\n       if ((unsigned HOST_WIDE_INT) DECL_ALIGN (decl) / BITS_PER_UNIT > rounded)\n-\twarning (\"%Hrequested alignment for '%D' is greater than \"\n-                 \"implemented alignment of %d\", &DECL_SOURCE_LOCATION (decl),\n-                 decl, rounded);\n+\twarning (\"%Jrequested alignment for '%D' is greater than \"\n+                 \"implemented alignment of %d\", decl, decl, rounded);\n #endif\n \n       /* If the target cannot output uninitialized but not common global data\n@@ -4213,17 +4205,16 @@ merge_weak (tree newdecl, tree olddecl)\n \t declare_weak because the NEWDECL and OLDDECL was not yet\n \t been merged; therefore, TREE_ASM_WRITTEN was not set.  */\n       if (TREE_ASM_WRITTEN (olddecl))\n-\terror (\"%Hweak declaration of '%D' must precede definition\",\n-               &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\terror (\"%Jweak declaration of '%D' must precede definition\",\n+\t       newdecl, newdecl);\n \n       /* If we've already generated rtl referencing OLDDECL, we may\n \t have done so in a way that will not function properly with\n \t a weak symbol.  */\n       else if (TREE_USED (olddecl)\n \t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (olddecl)))\n-\twarning (\"%Hweak declaration of '%D' after first use results \"\n-                 \"in unspecified behavior\",\n-                 &DECL_SOURCE_LOCATION (newdecl), newdecl);\n+\twarning (\"%Jweak declaration of '%D' after first use results \"\n+                 \"in unspecified behavior\", newdecl, newdecl);\n \n       if (SUPPORTS_WEAK)\n \t{\n@@ -4256,19 +4247,16 @@ void\n declare_weak (tree decl)\n {\n   if (! TREE_PUBLIC (decl))\n-    error (\"%Hweak declaration of '%D' must be public\",\n-           &DECL_SOURCE_LOCATION (decl), decl);\n+    error (\"%Jweak declaration of '%D' must be public\", decl, decl);\n   else if (TREE_CODE (decl) == FUNCTION_DECL && TREE_ASM_WRITTEN (decl))\n-    error (\"%Hweak declaration of '%D' must precede definition\",\n-           &DECL_SOURCE_LOCATION (decl), decl);\n+    error (\"%Jweak declaration of '%D' must precede definition\", decl, decl);\n   else if (SUPPORTS_WEAK)\n     {\n       if (! DECL_WEAK (decl))\n \tweak_decls = tree_cons (NULL, decl, weak_decls);\n     }\n   else\n-    warning (\"%Hweak declaration of '%D' not supported\",\n-             &DECL_SOURCE_LOCATION (decl), decl);\n+    warning (\"%Jweak declaration of '%D' not supported\", decl, decl);\n \n   mark_weak (decl);\n }"}]}