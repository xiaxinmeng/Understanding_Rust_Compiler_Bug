{"sha": "5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhYjhkOTI0YzlmYTlmZjgyZDNlOWFjNWM4ZDg2MzNmZjdmNzZmNw==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@rice.edu", "date": "2003-08-23T04:20:02Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2003-08-23T04:20:02Z"}, "message": "i860.c (i860_build_va_list): Create the va_decl declaration.\n\n2003-08-22  Jason Eckhardt  <jle@rice.edu>\n\n\t* config/i860/i860.c (i860_build_va_list): Create the va_decl\n\tdeclaration.  Document the va_list structure.\n\t(i860_va_start): Initialize the va_list structure.\n\t(i860_va_arg): Rewrite completely.\n\t* config/i860/i860.h (LIBGCC_NEEDS_DOUBLE): Don't define.\n\t* config/i860/varargs.asm: Do not allocate or initialize\n\ta va_list.  Return the address of the register save area.\n\nFrom-SVN: r70729", "tree": {"sha": "cf9b0ee56a6f8e098e7449ffca7e0704d5dc3e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf9b0ee56a6f8e098e7449ffca7e0704d5dc3e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/comments", "author": null, "committer": null, "parents": [{"sha": "415d7ef97db005dadb5df081610fb647753e560a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415d7ef97db005dadb5df081610fb647753e560a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415d7ef97db005dadb5df081610fb647753e560a"}], "stats": {"total": 353, "additions": 210, "deletions": 143}, "files": [{"sha": "a86131c96c15620fde2bafa1c46510eb1acf6100", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "patch": "@@ -1,3 +1,13 @@\n+2003-08-22  Jason Eckhardt  <jle@rice.edu>\n+\n+\t* config/i860/i860.c (i860_build_va_list): Create the va_decl\n+\tdeclaration.  Document the va_list structure.\n+\t(i860_va_start): Initialize the va_list structure.\n+\t(i860_va_arg): Rewrite completely.\n+\t* config/i860/i860.h (LIBGCC_NEEDS_DOUBLE): Don't define.\n+\t* config/i860/varargs.asm: Do not allocate or initialize\n+\ta va_list.  Return the address of the register save area.\n+\n 2003-08-22  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/iq2000/iq2000.c: Fix comment typos."}, {"sha": "5bc32edb3c5dd78df31be293e512f8e2731ab4b1", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 188, "deletions": 142, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"langhooks.h\"\n \n static rtx find_addr_reg (rtx);\n \n@@ -1772,6 +1773,7 @@ i860_output_function_epilogue (FILE *asm_file, HOST_WIDE_INT local_bytes)\n \f\n \n /* Expand a library call to __builtin_saveregs.  */\n+\n rtx\n i860_saveregs (void)\n {\n@@ -1791,94 +1793,118 @@ i860_saveregs (void)\n   return ret;\n }\n \n+/* Create the va_list data type.\n+   The SVR4 ABI requires the following structure:\n+        typedef struct {\n+            unsigned long  ireg_used;\n+            unsigned long  freg_used;\n+            long          *reg_base;\n+            long          *mem_ptr;\n+        } va_list;\n+\n+   Otherwise, this structure is used:\n+        typedef struct {\n+            long          *reg_base;\n+            long          *mem_ptr;\n+            unsigned long  ireg_used;\n+            unsigned long  freg_used;\n+        } va_list;\n+\n+   The tree representing the va_list declaration is returned.  */\n+\n tree\n i860_build_va_list (void)\n {\n-  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n-  tree record;\n+  tree f_gpr, f_fpr, f_mem, f_sav, record, type_decl;\n+\n+  record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n-  record = make_node (RECORD_TYPE);\n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"__ireg_used\"),\n+\t\t      unsigned_type_node);\n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"__freg_used\"),\n+\t\t      unsigned_type_node);\n+  f_sav = build_decl (FIELD_DECL, get_identifier (\"__reg_base\"),\n+\t\t      ptr_type_node);\n+  f_mem = build_decl (FIELD_DECL, get_identifier (\"__mem_ptr\"),\n+\t\t      ptr_type_node);\n \n-  field_ireg_used = build_decl (FIELD_DECL, get_identifier (\"__ireg_used\"),\n-\t\t\t\tunsigned_type_node);\n-  field_freg_used = build_decl (FIELD_DECL, get_identifier (\"__freg_used\"),\n-\t\t\t\tunsigned_type_node);\n-  field_reg_base = build_decl (FIELD_DECL, get_identifier (\"__reg_base\"),\n-\t\t\t       ptr_type_node);\n-  field_mem_ptr = build_decl (FIELD_DECL, get_identifier (\"__mem_ptr\"),\n-\t\t\t      ptr_type_node);\n+  DECL_FIELD_CONTEXT (f_gpr) = record;\n+  DECL_FIELD_CONTEXT (f_fpr) = record;\n+  DECL_FIELD_CONTEXT (f_sav) = record;\n+  DECL_FIELD_CONTEXT (f_mem) = record;\n \n-  DECL_FIELD_CONTEXT (field_ireg_used) = record;\n-  DECL_FIELD_CONTEXT (field_freg_used) = record;\n-  DECL_FIELD_CONTEXT (field_reg_base) = record;\n-  DECL_FIELD_CONTEXT (field_mem_ptr) = record;\n+  TREE_CHAIN (record) = type_decl;\n+  TYPE_NAME (record) = type_decl;\n \n #ifdef I860_SVR4_VA_LIST\n-  TYPE_FIELDS (record) = field_ireg_used;\n-  TREE_CHAIN (field_ireg_used) = field_freg_used;\n-  TREE_CHAIN (field_freg_used) = field_reg_base;\n-  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n+  TYPE_FIELDS (record) = f_gpr;\n+  TREE_CHAIN (f_gpr) = f_fpr;\n+  TREE_CHAIN (f_fpr) = f_sav;\n+  TREE_CHAIN (f_sav) = f_mem;\n #else\n-  TYPE_FIELDS (record) = field_reg_base;\n-  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n-  TREE_CHAIN (field_mem_ptr) = field_ireg_used;\n-  TREE_CHAIN (field_ireg_used) = field_freg_used;\n+  TYPE_FIELDS (record) = f_sav;\n+  TREE_CHAIN (f_sav) = f_mem;\n+  TREE_CHAIN (f_mem) = f_gpr;\n+  TREE_CHAIN (f_gpr) = f_fpr;\n #endif\n \n   layout_type (record);\n   return record;\n }\n \n+/* Initialize the va_list structure.  */\n+\n void\n-i860_va_start (tree valist, rtx nextarg)\n+i860_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n {\n   tree saveregs, t;\n-  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n-  tree ireg_used, freg_used, reg_base, mem_ptr;\n-\n-  saveregs = make_tree (build_pointer_type (va_list_type_node),\n-\t\t\texpand_builtin_saveregs ());\n-  saveregs = build1 (INDIRECT_REF, va_list_type_node, saveregs);\n+  tree f_gpr, f_fpr, f_mem, f_sav;\n+  tree gpr, fpr, mem, sav;\n+  int off = 0;\n+  saveregs = make_tree (ptr_type_node, expand_builtin_saveregs ());\n \n #ifdef I860_SVR4_VA_LIST\n-  field_ireg_used = TYPE_FIELDS (va_list_type_node);\n-  field_freg_used = TREE_CHAIN (field_ireg_used);\n-  field_reg_base = TREE_CHAIN (field_freg_used);\n-  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  f_gpr = TYPE_FIELDS (va_list_type_node);\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_sav = TREE_CHAIN (f_fpr);\n+  f_mem = TREE_CHAIN (f_sav);\n #else\n-  field_reg_base = TYPE_FIELDS (va_list_type_node);\n-  field_mem_ptr = TREE_CHAIN (field_reg_base);\n-  field_ireg_used = TREE_CHAIN (field_mem_ptr);\n-  field_freg_used = TREE_CHAIN (field_ireg_used);\n+  f_sav = TYPE_FIELDS (va_list_type_node);\n+  f_mem = TREE_CHAIN (f_sav);\n+  f_gpr = TREE_CHAIN (f_mem);\n+  f_fpr = TREE_CHAIN (f_gpr);\n #endif\n \n-  ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n-\t\t     valist, field_ireg_used);\n-  freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n-\t\t     valist, field_freg_used);\n-  reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n-\t\t    valist, field_reg_base);\n-  mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n-\t\t   valist, field_mem_ptr);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem);\n+\n+  /* Initialize the `mem_ptr' field to the address of the first anonymous\n+     stack argument.  */\n+  t = make_tree (TREE_TYPE (mem), virtual_incoming_args_rtx);\n+  off = INTVAL (current_function_arg_offset_rtx);\n+  off = off < 0 ? 0 : off;\n+  t = build (PLUS_EXPR, TREE_TYPE (mem), t, build_int_2 (off, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (mem), mem, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n+  /* Initialize the `ireg_used' field.  */\n   t = build_int_2 (current_function_args_info.ints / UNITS_PER_WORD, 0);\n-  t = build (MODIFY_EXPR, TREE_TYPE (ireg_used), ireg_used, t);\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      \n-  t = build_int_2 (ROUNDUP ((current_function_args_info.floats / UNITS_PER_WORD), 8), 0);\n-  t = build (MODIFY_EXPR, TREE_TYPE (freg_used), freg_used, t);\n+     \n+  /* Initialize the `freg_used' field.  */\n+  t = build_int_2 (current_function_args_info.floats / UNITS_PER_WORD, 0);\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n       \n-  t = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n-\t     saveregs, field_reg_base);\n-  t = build (MODIFY_EXPR, TREE_TYPE (reg_base), reg_base, t);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  t = make_tree (ptr_type_node, nextarg);\n-  t = build (MODIFY_EXPR, TREE_TYPE (mem_ptr), mem_ptr, t);\n+  /* Initialize the `reg_base' field.  */\n+  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, saveregs);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }\n@@ -1893,116 +1919,136 @@ i860_va_start (tree valist, rtx nextarg)\n #define IREG_OFFSET 0\n #endif\n \n+/* Update the VALIST structure as necessary for an\n+   argument of the given TYPE, and return the argument.  */\n+\n rtx\n i860_va_arg (tree valist, tree type)\n {\n-  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n-  tree type_ptr_node, t;\n-  rtx lab_over = NULL_RTX;\n-  rtx ret, val;\n-  HOST_WIDE_INT align;\n+  tree f_gpr, f_fpr, f_mem, f_sav;\n+  tree gpr, fpr, mem, sav, reg, t, u;\n+  int size, n_reg, sav_ofs, sav_scale, max_reg;\n+  rtx lab_false, lab_over, addr_rtx, r;\n \n #ifdef I860_SVR4_VA_LIST\n-  field_ireg_used = TYPE_FIELDS (va_list_type_node);\n-  field_freg_used = TREE_CHAIN (field_ireg_used);\n-  field_reg_base = TREE_CHAIN (field_freg_used);\n-  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  f_gpr = TYPE_FIELDS (va_list_type_node);\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_sav = TREE_CHAIN (f_fpr);\n+  f_mem = TREE_CHAIN (f_sav);\n #else\n-  field_reg_base = TYPE_FIELDS (va_list_type_node);\n-  field_mem_ptr = TREE_CHAIN (field_reg_base);\n-  field_ireg_used = TREE_CHAIN (field_mem_ptr);\n-  field_freg_used = TREE_CHAIN (field_ireg_used);\n+  f_sav = TYPE_FIELDS (va_list_type_node);\n+  f_mem = TREE_CHAIN (f_sav);\n+  f_gpr = TREE_CHAIN (f_mem);\n+  f_fpr = TREE_CHAIN (f_gpr);\n #endif\n \n-  field_ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n-\t\t\t   valist, field_ireg_used);\n-  field_freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n-\t\t\t   valist, field_freg_used);\n-  field_reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n-\t\t\t  valist, field_reg_base);\n-  field_mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n-\t\t\t valist, field_mem_ptr);\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  mem = build (COMPONENT_REF, TREE_TYPE (f_mem), valist, f_mem);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n \n-  ret = gen_reg_rtx (Pmode);\n-  type_ptr_node = build_pointer_type (type);\n+  size = int_size_in_bytes (type);\n \n-  if (! AGGREGATE_TYPE_P (type))\n+  if (AGGREGATE_TYPE_P (type))\n     {\n-      int nparm, incr, ofs;\n-      tree field;\n-      rtx lab_false;\n+      /* Aggregates are passed on the stack.  */\n+      HOST_WIDE_INT align;\n+\n+      align = TYPE_ALIGN (type);\n+      if (align < BITS_PER_WORD)\n+        align = BITS_PER_WORD;\n+      align /= BITS_PER_UNIT;\n+\n+      addr_rtx = gen_reg_rtx (Pmode);\n+      t = build (PLUS_EXPR, ptr_type_node, mem, build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, ptr_type_node, t, build_int_2 (-align, -1));\n+      r = expand_expr (t, addr_rtx, VOIDmode /* Pmode */, EXPAND_NORMAL);\n+      if (r != addr_rtx)\n+        emit_move_insn (addr_rtx, r);\n+\n+      t = fold (build (PLUS_EXPR, ptr_type_node, \n+\t\tmake_tree (ptr_type_node, addr_rtx),\n+\t\tbuild_int_2 (size, 0)));\n+      t = build (MODIFY_EXPR, ptr_type_node, mem, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-      if (FLOAT_TYPE_P (type))\n-\t{\n-\t  field = field_freg_used;\n-\t  nparm = NUM_PARM_FREGS;\n-\t  incr = 2;\n-\t  ofs = FREG_OFFSET;\n-\t}\n-      else\n-\t{\n-\t  field = field_ireg_used;\n-\t  nparm = NUM_PARM_IREGS;\n-\t  incr = int_size_in_bytes (type) / UNITS_PER_WORD;\n-\t  ofs = IREG_OFFSET;\n-\t}\n+      return addr_rtx;\n+    }\n+  else if (FLOAT_TYPE_P (type) || (INTEGRAL_TYPE_P (type) && size == 8))\n+    {\n+      /* Floats and long longs are passed in the floating-point registers.  */\n+      reg = fpr;\n+      n_reg = size / UNITS_PER_WORD;\n+      sav_ofs = FREG_OFFSET;\n+      sav_scale = UNITS_PER_WORD;\n+      max_reg = NUM_PARM_FREGS;\n+    }\n+  else\n+    {\n+      /* Everything else is passed in general registers.  */\n+      reg = gpr;\n+      n_reg = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+      sav_ofs = IREG_OFFSET;\n+      sav_scale = UNITS_PER_WORD;\n+      max_reg = NUM_PARM_IREGS;\n+      if (n_reg > 1)\n+        abort ();\n+    }\n \n-      lab_false = gen_label_rtx ();\n-      lab_over = gen_label_rtx ();\n+  /* The value was passed in a register, so read it from the register\n+     save area initialized by __builtin_saveregs.  */\n \n-      emit_cmp_and_jump_insns (expand_expr (field, NULL_RTX, 0, 0),\n-\t\t\t       GEN_INT (nparm - incr), GT, const0_rtx,\n-\t\t\t       TYPE_MODE (TREE_TYPE (field)),\n-\t\t\t       TREE_UNSIGNED (field), lab_false);\n+  lab_false = gen_label_rtx ();\n+  lab_over = gen_label_rtx ();\n+  addr_rtx = gen_reg_rtx (Pmode);\n \n-      t = fold (build (POSTINCREMENT_EXPR, TREE_TYPE (field), field,\n-\t\t       build_int_2 (incr, 0)));\n-      TREE_SIDE_EFFECTS (t) = 1;\n+  emit_cmp_and_jump_insns (expand_expr (reg, NULL_RTX, Pmode, EXPAND_NORMAL),\n+\t\t\t   GEN_INT (max_reg - n_reg),\n+\t\t\t   GT, const1_rtx, Pmode, 0, lab_false);\n \n-      t = fold (build (MULT_EXPR, TREE_TYPE (field), t /* field */,\n-\t\t       build_int_2 (UNITS_PER_WORD, 0)));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      \n-      t = fold (build (PLUS_EXPR, ptr_type_node, field_reg_base,\n-\t\t       fold (build (PLUS_EXPR, TREE_TYPE (field), t,\n-\t\t\t\t    build_int_2 (ofs, 0)))));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      \n-      val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n-      if (val != ret)\n-\temit_move_insn (ret, val);\n+  if (sav_ofs)\n+    t = build (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n+  else\n+    t = sav;\n \n-      emit_jump_insn (gen_jump (lab_over));\n-      emit_barrier ();\n-      emit_label (lab_false);\n-    }\n+  u = build (MULT_EXPR, long_integer_type_node,\n+\t     reg, build_int_2 (sav_scale, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n+\n+  t = build (PLUS_EXPR, ptr_type_node, t, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n \n-  align = TYPE_ALIGN (type);\n-  if (align < BITS_PER_WORD)\n-    align = BITS_PER_WORD;\n-  align /= BITS_PER_UNIT;\n+  emit_jump_insn (gen_jump (lab_over));\n+  emit_barrier ();\n+  emit_label (lab_false);\n \n-  t = build (PLUS_EXPR, ptr_type_node, field_mem_ptr,\n-\t     build_int_2 (align - 1, 0));\n-  t = build (BIT_AND_EXPR, ptr_type_node, t, build_int_2 (-align, -1));\n+  /* The value was passed in memory, so read it from the overflow area.  */\n \n-  val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n-  if (val != ret)\n-    emit_move_insn (ret, val);\n+  t = save_expr (mem);\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n \n-  t = fold (build (PLUS_EXPR, ptr_type_node,\n-\t\t   make_tree (ptr_type_node, ret),\n-\t\t   build_int_2 (int_size_in_bytes (type), 0)));\n-  t = build (MODIFY_EXPR, ptr_type_node, field_mem_ptr, t);\n+  t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (size, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (mem), mem, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  if (lab_over)\n-    emit_label (lab_over);\n+  emit_label (lab_over);\n \n-  return ret;\n-}\n+  /* Increment either the ireg_used or freg_used field.  */\n \n+  u = build (PREINCREMENT_EXPR, TREE_TYPE (reg), reg, build_int_2 (n_reg, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n+  expand_expr (u, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  return addr_rtx;\n+}\n \n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be"}, {"sha": "38ddc1c75c11dd9e814bc53c8ace3a7f64352878", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "patch": "@@ -836,7 +836,7 @@ struct cumulative_args { int ints, floats; };\n /* #define CASE_VECTOR_PC_RELATIVE 1 */\n \n /* Must pass floats to libgcc functions as doubles.  */\n-#define LIBGCC_NEEDS_DOUBLE 1\n+/* #define LIBGCC_NEEDS_DOUBLE 1 */\n \n #define DIVSI3_LIBCALL \"*.div\"\n #define UDIVSI3_LIBCALL \"*.udiv\""}, {"sha": "ff58d7325b0fca5acf012c6b80defd9a054c0df7", "filename": "gcc/config/i860/varargs.asm", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fvarargs.asm?ref=5dab8d924c9fa9ff82d3e9ac5c8d8633ff7f76f7", "patch": "@@ -38,9 +38,13 @@ __builtin_saveregs:\n ___builtin_saveregs:\n \n \tandnot\t0x0f,%sp,%sp\t/* round down to 16-byte boundary */\n+#if 0\n \tadds\t-96,%sp,%sp  /* allocate stack space for reg save\n \t\t\t   area and also for a new va_list\n \t\t\t   structure */\n+#else\n+\tadds\t-80,%sp,%sp  /* allocate stack space for reg save area */\n+#endif\n \t/* Save all argument registers in the arg reg save area.  The\n \t   arg reg save area must have the following layout (according\n \t   to the svr4 ABI):\n@@ -70,10 +74,12 @@ ___builtin_saveregs:\n \tst.l\t%r26,72(%sp)\n \tst.l\t%r27,76(%sp)\n \n+#if 0\n \tadds\t80,%sp,%r16  /* compute the address of the new\n \t\t\t   va_list structure.  Put in into\n \t\t\t   r16 so that it will be returned\n \t\t\t   to the caller.  */\n+#endif\n \n \t/* Initialize all fields of the new va_list structure.  This\n \t   structure looks like:\n@@ -86,11 +92,16 @@ ___builtin_saveregs:\n \t} va_list;\n \t*/\n \n+#if 0\n \tst.l\t%r0, 0(%r16) /* nfixed */\n \tst.l\t%r0, 4(%r16) /* nfloating */\n \tst.l    %sp, 8(%r16) /* __va_ctl points to __va_struct.  */\n \tbri\t%r1\t/* delayed return */\n \tst.l\t%r28,12(%r16) /* pointer to overflow args */\n+#else\n+\tbri\t%r1\t/* delayed return */\n+\tor\t%sp,%r0,%r16  /* Return the address of the reg save area.  */\n+#endif\n \n #else /* not __svr4__ */\n #if defined(__PARAGON__)"}]}