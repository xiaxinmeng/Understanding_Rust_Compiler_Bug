{"sha": "a32034654e77ec19b8c0245d6dbebb06082f0612", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMyMDM0NjU0ZTc3ZWMxOWI4YzAyNDVkNmRiZWJiMDYwODJmMDYxMg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-24T00:54:38Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-24T00:54:38Z"}, "message": "41st Cygnus<->FSF merge\n\nFrom-SVN: r7553", "tree": {"sha": "a3da66c1be0dac89fa0edc6c83d4cb0b0798930c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3da66c1be0dac89fa0edc6c83d4cb0b0798930c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a32034654e77ec19b8c0245d6dbebb06082f0612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32034654e77ec19b8c0245d6dbebb06082f0612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32034654e77ec19b8c0245d6dbebb06082f0612", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32034654e77ec19b8c0245d6dbebb06082f0612/comments", "author": null, "committer": null, "parents": [{"sha": "f6ba0600ffc9a3035a121b50fffcf90754a342f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ba0600ffc9a3035a121b50fffcf90754a342f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ba0600ffc9a3035a121b50fffcf90754a342f5"}], "stats": {"total": 547, "additions": 253, "deletions": 294}, "files": [{"sha": "e894e635cfa1ebe71827b078dcd85e115f097267", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -1,3 +1,91 @@\n+Thu Jun 23 00:22:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Set explicit_int for decls that just\n+\tspecify, say, 'long'.\n+\n+\t* init.c (do_friend): Do overload C functions (or call pushdecl,\n+        anyaway).\n+\n+Wed Jun 22 13:40:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (build_up_reference): Don't call readonly_error.\n+\t(convert_to_reference): Propagate const and volatile from expr to\n+\tits type.\n+\n+\t* tree.c (lvalue_p): Random CALL_EXPRs are not lvalues.\n+\n+\t* cvt.c (build_up_reference): Break out WITH_CLEANUP_EXPR when\n+\tcreating a temporary.\n+\t(convert_to_reference): Lose excessive and incorrect trickiness.\n+\t(cp_convert): Call build_cplus_new with with_cleanup_p set.\n+\n+\t* typeck2.c (build_functional_cast): Ditto.\n+\n+Tue Jun 21 17:38:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): signed, unsigned, long and short all\n+\timply 'int'.\n+\n+\t* decl.c (grokdeclarator): Allow \"this is a type\" syntax.\n+\t(grok_reference_init): Simplify and fix.\n+\n+Sun Jun 19 17:08:48 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): pedwarn about a typedef that specifies no\n+\ttype.\n+\n+Sat Jun 18 04:16:50 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (start_function): Move TREE_PUBLIC and DECL_EXTERNAL\n+\ttinkering to after call to pushdecl.\n+\n+Fri Jun 17 14:48:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Handle destructors for non-aggregate\n+\ttypes properly.\n+\n+Thu Jun 16 16:48:05 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Make sure that the name given for the\n+\tdestructor matches the constructor_name of the instance.\n+\n+\t* pt.c (do_function_instantiation): A non-extern instantiation\n+\toverrides a later extern one.\n+\t(do_type_instantiation): Ditto.\n+\n+Wed Jun 15 19:34:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* init.c (expand_aggr_init): Use TYPE_MAIN_VARIANT to get the\n+\tunqualified array type.\n+\n+\t* cp-tree.h (EMPTY_CONSTRUCTOR_P): Tests whether NODE is a\n+\tCONSTRUCTOR with no elements.\n+\n+\t* decl.c (various): Lose empty_init_node.\n+\t(finish_decl): Use EMPTY_CONSTRUCTOR_P, do the empty CONSTRUCTOR\n+\tthing depending on the value of DECL_COMMON instead of\n+\tflag_conserve_space, do the empty CONSTRUCTOR thing for types that\n+\tdon't have constructors, don't treat a real empty CONSTRUCTOR\n+\tspecially.\n+\n+\t* typeck2.c (process_init_constructor): Don't treat empty_init_node\n+\tspecially.\n+\n+Wed Jun 15 19:05:25 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (override_one_vtable): Don't forget to merge in an old\n+\toverrider when we wanted to reuse a vtable, but couldn't.\n+\n+Wed Jun 15 15:03:16 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (start_decl): Put statics in common again.\n+\n+\t* decl.c (grokdeclarator): Return NULL_TREE for an error rather than\n+\tsetting the type to error_mark_node.\n+\n+\t* typeck.c (build_modify_expr): Build up a COMPOUND_EXPR for enum\n+\tbitfield assignments.\n+\n Tue Jun 14 12:23:38 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (grok_op_properties): Const objects can be passed by value."}, {"sha": "75c5635954ea96c8812bb5b685b59e6a2665489a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -1603,14 +1603,22 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       name = TREE_OPERAND (name, 0);\n       if (parms)\n \terror (\"destructors take no parameters\");\n-      basetype = get_type_value (name);\n-      if (basetype == NULL_TREE)\n+      basetype = TREE_TYPE (instance);\n+      if (IS_AGGR_TYPE (basetype))\n+\t{\n+\t  if (name == constructor_name (basetype))\n+\t    goto huzzah;\n+\t}\n+      else\n \t{\n-\t  cp_error (\"call to destructor for non-type `%D'\", name);\n-\t  return void_zero_node;\n+\t  if (basetype == get_type_value (name))\n+\t    goto huzzah;\n \t}\n-      if (basetype != TREE_TYPE(instance))\n-\tbasetype = TREE_TYPE(instance);\n+      cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n+\t\tname, basetype);\n+      return void_zero_node;\n+\n+    huzzah:\n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n \treturn void_zero_node;\n       instance = default_conversion (instance);"}, {"sha": "62eff53dd3a0cdc6d42811cfa4c862c253abd49e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -2400,6 +2400,10 @@ override_one_vtable (binfo, old, t)\n \t\t}\n \t      TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n \t    }\n+\t  else if (choose == NEITHER)\n+\t    {\n+\t      TREE_VALUE (virtuals) = TREE_VALUE (old_virtuals);\n+\t    }  \n \t}\n       else\n \t{"}, {"sha": "5a7c35337d9705a425a985d408a5910c383bc4d7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -1167,6 +1167,9 @@ struct lang_decl\n    has been duly initialized in its constructor.  */\n #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4(NODE))\n \n+#define EMPTY_CONSTRUCTOR_P(NODE) (TREE_CODE (NODE) == CONSTRUCTOR \\\n+\t\t\t\t   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE)\n+\n /* Indicates that a NON_LVALUE_EXPR came from a C++ reference.\n    Used to generate more helpful error message in case somebody\n    tries to take its address.  */"}, {"sha": "0b08f05bb662d889b2a3ddc3f346a7d188b09d68", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -337,7 +337,20 @@ build_up_reference (type, arg, flags, checkconst)\n \t  TREE_READONLY (arg) = 0;\n \t}\n \n+#if 0\n+      if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n+\t{\n+\t  rval = copy_node (arg);\n+\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n+\t}\n+      else\n+\trval = arg;\n+\n+      rval = convert (build_pointer_type (TREE_TYPE (type)), rval);\n+      TREE_TYPE (rval) = type;\n+#else\n       rval = build1 (CONVERT_EXPR, type, arg);\n+#endif\n       TREE_REFERENCE_EXPR (rval) = 1;\n \n       /* propagate the const flag on something like:\n@@ -372,7 +385,7 @@ build_up_reference (type, arg, flags, checkconst)\n \t}\n       literal_flag = TREE_CONSTANT (arg);\n \n-      goto done_but_maybe_warn;\n+      goto done;\n \n       /* Get this out of a register if we happened to be in one by accident.\n \t Also, build up references to non-lvalues it we must.  */\n@@ -409,7 +422,7 @@ build_up_reference (type, arg, flags, checkconst)\n       TREE_TYPE (rval) = type;\n       literal_flag = staticp (TREE_OPERAND (targ, 0));\n \n-      goto done_but_maybe_warn;\n+      goto done;\n \n       /* Anything not already handled and not a true memory reference\n \t needs to have a reference built up.  Do so silently for\n@@ -537,7 +550,12 @@ build_up_reference (type, arg, flags, checkconst)\n       if (TREE_CODE (targ) == CALL_EXPR && IS_AGGR_TYPE (argtype))\n \t{\n \t  temp = build_cplus_new (argtype, targ, 1);\n-\t  rval = build1 (ADDR_EXPR, type, temp);\n+\t  if (TREE_CODE (temp) == WITH_CLEANUP_EXPR)\n+\t    rval = build (WITH_CLEANUP_EXPR, type,\n+\t\t\t  build1 (ADDR_EXPR, type, TREE_OPERAND (temp, 0)),\n+\t\t\t  0, TREE_OPERAND (temp, 2));\n+\t  else\n+\t    rval = build1 (ADDR_EXPR, type, temp);\n \t  goto done;\n \t}\n       else\n@@ -572,10 +590,6 @@ build_up_reference (type, arg, flags, checkconst)\n   else\n     rval = build1 (ADDR_EXPR, type, arg);\n \n- done_but_maybe_warn:\n-  if (checkconst && TREE_READONLY (arg) && ! TYPE_READONLY (target_type))\n-    readonly_error (arg, \"conversion to reference\", 1);\n-\n  done:\n   if (TYPE_USES_COMPLEX_INHERITANCE (argtype))\n     {\n@@ -636,7 +650,11 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  if (form == REFERENCE_TYPE)\n \t    ttr = TREE_TYPE (TREE_TYPE (expr));\n \t  else\n-\t    ttr = TREE_TYPE (expr);\n+\t    {\n+\t      int r = TREE_READONLY (expr);\n+\t      int v = TREE_THIS_VOLATILE (expr);\n+\t      ttr = c_build_type_variant (TREE_TYPE (expr), r, v);\n+\t    }\n \n \t  if (! lvalue_p (expr) &&\n \t      (decl == NULL_TREE || ! TYPE_READONLY (ttl)))\n@@ -653,46 +671,20 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    {\n \t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\tcp_pedwarn (\"conversion from `%T' to `%T' discards const\",\n-\t\t\t    TREE_TYPE (expr), reftype);\n+\t\t\t    ttr, reftype);\n \t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\tcp_pedwarn (\"conversion from `%T' to `%T' discards volatile\",\n-\t\t\t    TREE_TYPE (expr), reftype);\n-\t    }\n-\t}\n-      \n-      /* If EXPR is of aggregate type, and is really a CALL_EXPR,\n-\t then we don't need to convert it to reference type if\n-\t it is only being used to initialize DECL which is also\n-\t of the same aggregate type.  */\n-      if (decl != NULL_TREE && decl != error_mark_node\n-\t  && IS_AGGR_TYPE (type)\n-\t  && TREE_CODE (expr) == CALL_EXPR\n-\t  && TYPE_MAIN_VARIANT (type) == intype)\n-\t{\n-\t  tree e1 = build (INIT_EXPR, void_type_node, decl, expr);\n-\t  tree e2;\n-\n-\t  TREE_SIDE_EFFECTS (e1) = 1;\n-\t  if (form == REFERENCE_TYPE)\n-\t    e2 = build1 (NOP_EXPR, reftype, decl);\n-\t  else\n-\t    {\n-\t      e2 = build_unary_op (ADDR_EXPR, decl, 0);\n-\t      TREE_TYPE (e2) = reftype;\n-\t      TREE_REFERENCE_EXPR (e2) = 1;\n+\t\t\t    ttr, reftype);\n \t    }\n-\t  return build_compound_expr\n-\t    (tree_cons (NULL_TREE, e1, build_tree_list (NULL_TREE, e2)));\n \t}\n \n-      else if (form == REFERENCE_TYPE)\n+      if (form == REFERENCE_TYPE)\n \t{\n-\t  rval = build1 (NOP_EXPR,\n-\t\t\t build_pointer_type (TREE_TYPE (TREE_TYPE (expr))),\n-\t\t\t expr);\n+\t  rval = copy_node (expr);\n+\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n \t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), rval,\n \t\t\t     convtype, flags);\n-\t  rval = build1 (NOP_EXPR, reftype, rval);\n+\t  TREE_TYPE (rval) = reftype;\n \t  return rval;\n \t}\n \n@@ -1364,7 +1356,7 @@ cp_convert (type, expr, convtype, flags)\n \t\t      return error_mark_node;\n \t\t    }\n \t\t  /* call to constructor successful.  */\n-\t\t  rval = build_cplus_new (type, rval, 0);\n+\t\t  rval = build_cplus_new (type, rval, 1);\n \t\t  return rval;\n \t\t}\n \t    }\n@@ -1415,7 +1407,7 @@ cp_convert (type, expr, convtype, flags)\n \t      cp_error (\"in conversion to type `%T'\", type);\n \t      return error_mark_node;\n \t    }\n-\t  rval = build_cplus_new (type, init, 0);\n+\t  rval = build_cplus_new (type, init, 1);\n \t  return rval;\n \t}\n     }"}, {"sha": "5a209530da7fb089148b01fcfb3064cd0db211ba", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 92, "deletions": 193, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -244,15 +244,6 @@ tree maybe_gc_cleanup;\n /* Array type `vtable_entry_type[]' */\n tree vtbl_type_node;\n \n-/* Static decls which do not have static initializers have no\n-   initializers as far as GNU C is concerned.  EMPTY_INIT_NODE\n-   is a static initializer which makes varasm code place the decl\n-   in data rather than in bss space.  Such gymnastics are necessary\n-   to avoid the problem that the linker will not include a library\n-   file if all the library appears to contribute are bss variables.  */\n-\n-tree empty_init_node;\n-\n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n \n@@ -4376,7 +4367,6 @@ init_decl_processing ()\n   TREE_TYPE (integer_two_node) = integer_type_node;\n   integer_three_node = build_int_2 (3, 0);\n   TREE_TYPE (integer_three_node) = integer_type_node;\n-  empty_init_node = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n \n   bool_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n   TREE_SET_CODE (bool_type_node, BOOLEAN_TYPE);\n@@ -5385,8 +5375,14 @@ start_decl (declarator, declspecs, initialized, raises)\n   else\n     tem = pushdecl (decl);\n \t     \n-  /* Tell the back-end to use or not use .common as appropriate.  */\n-  DECL_COMMON (tem) = flag_conserve_space;\n+  /* Tell the back-end to use or not use .common as appropriate.  If we say\n+     -fconserve-space, we want this to save space, at the expense of wrong\n+     semantics.  If we say -fno-conserve-space, we want this to produce\n+     errors about redefs; to do this we force variables into the data\n+     segment.  Common storage is okay for non-public uninitialized data;\n+     the linker can't match it with storage from other files, and we may\n+     save some disk space.  */\n+  DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n \n #if 0\n   /* We don't do this yet for GNU C++.  */\n@@ -5556,10 +5552,7 @@ grok_reference_init (decl, type, init, cleanupp)\n      tree decl, type, init;\n      tree *cleanupp;\n {\n-  char *errstr = NULL;\n-  int is_reference;\n   tree tmp;\n-  tree this_ptr_type, actual_init = NULL_TREE;\n \n   if (init == NULL_TREE)\n     {\n@@ -5585,56 +5578,22 @@ grok_reference_init (decl, type, init, cleanupp)\n \n   if (TREE_CODE (init) == TREE_LIST)\n     init = build_compound_expr (init);\n-  is_reference = TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE;\n-  tmp = is_reference ? convert_from_reference (init) : init;\n \n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n     {\n-      /* Note: default conversion is only called in very\n-\t special cases.  */\n+      /* Note: default conversion is only called in very special cases.  */\n       init = default_conversion (init);\n     }\n \n-  /* Can we just enreference this lvalue?  */\n-  if ((is_reference || lvalue_p (init)\n-       || (actual_init = unary_complex_lvalue (ADDR_EXPR, init)))\n-      && comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n-\t\t    TYPE_MAIN_VARIANT (TREE_TYPE (tmp)), 0))\n-    {\n-      /* This section implements ANSI C++ June 5 1992 WP 8.4.3.5. */\n+  tmp = convert_to_reference\n+    (type, init, CONV_IMPLICIT, LOOKUP_SPECULATIVELY|LOOKUP_NORMAL, decl);\n \n-      /* A reference to a volatile T cannot be initialized with\n-\t a const T, and vice-versa.  */\n-      if (TYPE_VOLATILE (TREE_TYPE (type)) && TREE_READONLY (init))\n-\terrstr = \"cannot initialize a reference to a volatile `%T' with a const `%T'\";\n-      else if (TYPE_READONLY (TREE_TYPE (type)) && TREE_THIS_VOLATILE (init))\n-\terrstr = \"cannot initialize a reference to a const `%T' with a volatile `%T'\";\n-      /* A reference to a plain T can be initialized only with a plain T. */\n-      else if (!TYPE_VOLATILE (TREE_TYPE (type))\n-\t       && !TYPE_READONLY (TREE_TYPE (type)))\n-\t{\n-\t  if (TREE_READONLY (init))\n-\t    errstr = \"cannot initialize a reference to `%T' with a const `%T'\";\n-\t  else if (TREE_THIS_VOLATILE (init))\n-\t    errstr = \"cannot initialize a reference to `%T' with a volatile `%T'\";\n-\t}\n-      if (errstr)\n-\t{\n-\t  cp_error (errstr, TREE_TYPE (type), TREE_TYPE (tmp));\n-\t  goto fail;\n-\t}\n-    }\n-  /* OK, can we generate a reference then?  */\n-  else if ((actual_init = convert_to_reference\n-\t    (type, init, CONV_IMPLICIT,\n-\t     LOOKUP_SPECULATIVELY|LOOKUP_NORMAL, decl)))\n+  if (tmp == error_mark_node)\n+    goto fail;\n+  else if (tmp != NULL_TREE)\n     {\n-      if (actual_init == error_mark_node)\n-\tgoto fail;\n-\n-      init = actual_init;\n-      is_reference = 1;\n+      init = tmp;\n \n       if (TREE_CODE (init) == WITH_CLEANUP_EXPR)\n \t{\n@@ -5643,61 +5602,17 @@ grok_reference_init (decl, type, init, cleanupp)\n \t  *cleanupp = TREE_OPERAND (init, 2);\n \t  TREE_OPERAND (init, 2) = error_mark_node;\n \t}\n-    }\n-  else\n-    {\n-      cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n-      goto fail;\n-    }\n \n-  /* In the case of initialization, it is permissible\n-     to assign one reference to another.  */\n-  this_ptr_type = build_pointer_type (TREE_TYPE (type));\n-\n-  if (is_reference)\n-    {\n       if (TREE_SIDE_EFFECTS (init))\n \tDECL_INITIAL (decl) = save_expr (init);\n       else\n \tDECL_INITIAL (decl) = init;\n     }\n-  else if (lvalue_p (init))\n+  else\n     {\n-      tmp = build_unary_op (ADDR_EXPR, init, 0);\n-      if (TREE_CODE (tmp) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (tmp, 0)) == WITH_CLEANUP_EXPR)\n-\t{\n-\t  if (*cleanupp) my_friendly_abort (1);\n-\t  *cleanupp = TREE_OPERAND (TREE_OPERAND (tmp, 0), 2);\n-\t  TREE_OPERAND (TREE_OPERAND (tmp, 0), 2) = error_mark_node;\n-\t}\n-      if (IS_AGGR_TYPE (TREE_TYPE (this_ptr_type)))\n-\tDECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type),\n-\t\t\t\t\t\t  tmp);\n-      else\n-\tDECL_INITIAL (decl) = convert (this_ptr_type, tmp);\n-\n-      DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n-      if (DECL_INITIAL (decl) == current_class_decl)\n-\tDECL_INITIAL (decl) = copy_node (current_class_decl);\n-      TREE_TYPE (DECL_INITIAL (decl)) = type;\n-    }\n-  /* If actual_init is set here, it is set from the first check above.  */\n-  else if (actual_init)\n-    {\n-      /* The initializer for this decl goes into its\n-\t DECL_REFERENCE_SLOT.  Make sure that we can handle\n-\t multiple evaluations without ill effect.  */\n-      if (TREE_CODE (actual_init) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (actual_init, 0)) == TARGET_EXPR)\n-\tactual_init = save_expr (actual_init);\n-      DECL_INITIAL (decl) = convert_pointer_to (TREE_TYPE (this_ptr_type),\n-\t\t\t\t\t\tactual_init);\n-      DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n-      TREE_TYPE (DECL_INITIAL (decl)) = type;\n+      cp_error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n+      goto fail;\n     }\n-  else\n-    my_friendly_abort (1);\n \n   /* ?? Can this be optimized in some cases to\n      hand back the DECL_INITIAL slot??  */\n@@ -5892,8 +5807,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t{\n \t  if (TREE_CODE (type) == ARRAY_TYPE)\n \t    init = digest_init (type, init, (tree *) 0);\n-\t  else if (TREE_CODE (init) == CONSTRUCTOR\n-\t\t   && CONSTRUCTOR_ELTS (init) != NULL_TREE)\n+\t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n \t      if (TYPE_NEEDS_CONSTRUCTING (type))\n \t\t{\n@@ -5951,16 +5865,11 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  if (current_binding_level == global_binding_level)\n \t    {\n \t      tree value;\n-\t      if (flag_conserve_space)\n-\t\t/* If we say -fconserve-space, we want this to save\n-\t\t   space, at the expense of wrong semantics. */\n+\t      if (DECL_COMMON (decl))\n \t\t/* Should this be a NULL_TREE? */\n \t\tvalue = error_mark_node;\n \t      else\n-\t\t/* If we say -fno-conserve-space, we want this to\n-\t\t   produce errors about redefs, to do this we make it\n-\t\t   go in the data space */\n-\t\tvalue = digest_init (type, empty_init_node, (tree *) 0);\n+\t\tvalue = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n \t      DECL_INITIAL (decl) = value;\n \t    }\n \t  else\n@@ -5972,10 +5881,17 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  if (TREE_CODE (init) != TREE_VEC)\n \t    init = store_init_value (decl, init);\n \n+\t  /* Don't let anyone try to initialize this variable\n+\t     until we are ready to do so.  */\n \t  if (init)\n-\t    /* Don't let anyone try to initialize this variable\n-\t       until we are ready to do so.  */\n-\t    DECL_INITIAL (decl) = error_mark_node;\n+\t    {\n+\t      tree value;\n+\t      if (DECL_COMMON (decl))\n+\t\tvalue = error_mark_node;\n+\t      else\n+\t\tvalue = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+\t      DECL_INITIAL (decl) = value;\n+\t    }\n \t}\n     }\n   else if (DECL_EXTERNAL (decl))\n@@ -6002,27 +5918,19 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \tcp_error (\"uninitialized const `%D'\", decl);\n \n       /* Initialize variables in need of static initialization with\n-\t `empty_init_node' to keep assemble_variable from putting them in\n-\t the wrong program space.  Common storage is okay for non-public\n-\t uninitialized data; the linker can't match it with storage from\n-\t other files, and we may save some disk space.  Consts have to go\n-\t into data, though, since the backend would put them in text\n-\t otherwise.  */\n+\t an empty CONSTRUCTOR to keep assemble_variable from putting them in\n+\t the wrong program space.  */\n       if (flag_pic == 0\n \t  && TREE_STATIC (decl)\n-\t  && (TREE_PUBLIC (decl) || was_readonly)\n+\t  && TREE_PUBLIC (decl)\n \t  && ! DECL_EXTERNAL (decl)\n \t  && TREE_CODE (decl) == VAR_DECL\n \t  && TYPE_NEEDS_CONSTRUCTING (type)\n \t  && (DECL_INITIAL (decl) == NULL_TREE\n \t      || DECL_INITIAL (decl) == error_mark_node)\n-\t  /* If we say -fconserve-space, we want this to save space,\n-\t     at the expense of wrong semantics. */\n-\t  && ! flag_conserve_space)\n-\t{\n-\t  tree value = digest_init (type, empty_init_node, (tree *) 0);\n-\t  DECL_INITIAL (decl) = value;\n-\t}\n+\t  && ! DECL_COMMON (decl))\n+\tDECL_INITIAL (decl) = build (CONSTRUCTOR, type, NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL\n \t   && TREE_CODE (type) != REFERENCE_TYPE\n@@ -6182,7 +6090,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t       && TREE_READONLY (decl)\n \t       && DECL_INITIAL (decl) != NULL_TREE\n \t       && DECL_INITIAL (decl) != error_mark_node\n-\t       && DECL_INITIAL (decl) != empty_init_node)\n+\t       && ! EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl)))\n \t{\n \t  DECL_INITIAL (decl) = save_expr (DECL_INITIAL (decl));\n \n@@ -6889,9 +6797,8 @@ grokvardecl (type, declarator, specbits, initialized)\n \t  if (initialized && DECL_INITIAL (decl)\n \t      /* Complain about multiply-initialized\n \t\t member variables, but don't be faked\n-\t\t out if initializer is faked up from `empty_init_node'.  */\n-\t      && (TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR\n-\t\t  || CONSTRUCTOR_ELTS (DECL_INITIAL (decl)) != NULL_TREE))\n+\t\t out if initializer is empty.  */\n+\t      && ! EMPTY_CONSTRUCTOR_P (DECL_INITIAL (decl)))\n \t    error_with_aggr_type (DECL_CONTEXT (decl),\n \t\t\t\t  \"multiple initializations of static member `%s::%s'\",\n \t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (decl)));\n@@ -7358,44 +7265,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n       if (TREE_CODE (id) == IDENTIFIER_NODE)\n \t{\n-\t  if (id == ridpointers[(int) RID_INT])\n-\t    {\n-\t      if (type)\n-\t\terror (\"extraneous `int' ignored\");\n-\t      else\n-\t\t{\n-\t\t  explicit_int = 1;\n-\t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n-\t\t}\n-\t      goto found;\n-\t    }\n-\t  if (id == ridpointers[(int) RID_CHAR])\n-\t    {\n-\t      if (type)\n-\t\terror (\"extraneous `char' ignored\");\n-\t      else\n-\t\t{\n-\t\t  explicit_char = 1;\n-\t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n-\t\t}\n-\t      goto found;\n-\t    }\n-\t  if (id == ridpointers[(int) RID_BOOL])\n-\t    {\n-\t      if (type)\n-\t\terror (\"extraneous `bool' ignored\");\n-\t      else\n-\t\t{\n-\t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n-\t\t}\n-\t      goto found;\n-\t    }\n-\t  if (id == ridpointers[(int) RID_WCHAR])\n+\t  if (id == ridpointers[(int) RID_INT]\n+\t      || id == ridpointers[(int) RID_CHAR]\n+\t      || id == ridpointers[(int) RID_BOOL]\n+\t      || id == ridpointers[(int) RID_WCHAR])\n \t    {\n \t      if (type)\n-\t\terror (\"extraneous `__wchar_t' ignored\");\n+\t\terror (\"extraneous `%T' ignored\", id);\n \t      else\n \t\t{\n+\t\t  if (id == ridpointers[(int) RID_INT])\n+\t\t    explicit_int = 1;\n+\t\t  else if (id == ridpointers[(int) RID_CHAR])\n+\t\t    explicit_char = 1;\n \t\t  type = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (id));\n \t\t}\n \t      goto found;\n@@ -7459,6 +7341,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n      which case the type defaults to `unknown type' and is\n      instantiated when assigning to a signature pointer or ref.  */\n \n+  if (type == NULL_TREE\n+      && (RIDBIT_SETP (RID_SIGNED, specbits)\n+\t  || RIDBIT_SETP (RID_UNSIGNED, specbits)\n+\t  || RIDBIT_SETP (RID_LONG, specbits)\n+\t  || RIDBIT_SETP (RID_SHORT, specbits)))\n+    {\n+      /* These imply 'int'.  */\n+      type = integer_type_node;\n+      explicit_int = 1;\n+    }\n+\n   if (type == NULL_TREE)\n     {\n       explicit_int = -1;\n@@ -7478,22 +7371,21 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  opaque_typedef = 1;\n \t  type = copy_node (opaque_type_node);\n \t}\n+      /* access declaration */\n+      else if (decl_context == FIELD && declarator\n+\t       && TREE_CODE (declarator) == SCOPE_REF)\n+\ttype = void_type_node;\n       else\n \t{\n \t  if (funcdef_flag)\n \t    {\n \t      if (warn_return_type\n-\t\t  && return_type == return_normal\n-\t\t  && ! (RIDBIT_SETP (RID_SIGNED, specbits)\n-\t\t\t|| RIDBIT_SETP (RID_UNSIGNED, specbits)\n-\t\t\t|| RIDBIT_SETP (RID_LONG, specbits)\n-\t\t\t|| RIDBIT_SETP (RID_SHORT, specbits)))\n+\t\t  && return_type == return_normal)\n \t\t/* Save warning until we know what is really going on.  */\n \t\twarn_about_return_type = 1;\n \t    }\n-\t  else if (decl_context == FIELD && declarator\n-\t\t   && TREE_CODE (declarator) == SCOPE_REF)\n-\t    /* OK -- access declaration */;\n+\t  else if (RIDBIT_SETP (RID_TYPEDEF, specbits))\n+\t    pedwarn (\"ANSI C++ forbids typedef which does not specify a type\");\n \t  else if (declspecs == NULL_TREE &&\n \t\t   (innermost_code != CALL_EXPR || pedantic))\n \t    cp_pedwarn (\"ANSI C++ forbids declaration `%D' with no type or storage class\",\n@@ -7522,6 +7414,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n       type = ctor_return_type;\n     }\n+  /* Catch typedefs that only specify a type, like 'typedef int;'.  */\n+  else if (RIDBIT_SETP (RID_TYPEDEF, specbits) && declarator == NULL_TREE)\n+    {\n+      /* Template \"this is a type\" syntax; just ignore for now.  */\n+      if (processing_template_defn)\n+\treturn void_type_node;\n+    }\n \n   ctype = NULL_TREE;\n \n@@ -8481,16 +8380,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t\t\t\t      TREE_TYPE (type), TYPE_ARG_TYPES (type));\n \t\t    else\n \t\t      {\n-\t\t\terror (\"cannot declare member function `%s::%s' within this class\",\n-\t\t\t       TYPE_NAME_STRING (ctype), name);\n+\t\t\tcp_error (\"cannot declare member function `%T::%D' within `%T'\",\n+\t\t\t\t  ctype, name, current_class_type);\n \t\t\treturn void_type_node;\n \t\t      }\n \t\t  }\n \t\telse if (TYPE_MAIN_VARIANT (ctype) == current_class_type)\n \t\t  {\n \t\t    if (extra_warnings)\n-\t\t      warning (\"extra qualification `%s' on member `%s' ignored\",\n-\t\t\t       TYPE_NAME_STRING (ctype), name);\n+\t\t      cp_warning (\"redundant qualification `%T' on member `%D' ignored\",\n+\t\t\t\t  ctype, name);\n \t\t    type = build_offset_type (ctype, type);\n \t\t  }\n \t\telse if (TYPE_SIZE (ctype) != NULL_TREE\n@@ -8659,7 +8558,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       if (TREE_CODE (type) == OFFSET_TYPE || TREE_CODE (type) == METHOD_TYPE)\n \t{\n \t  cp_error_at (\"typedef name may not be class-qualified\", decl);\n-\t  TREE_TYPE (decl) = error_mark_node;\n+\t  return NULL_TREE;\n \t}\n       else if (quals)\n \t{\n@@ -10773,6 +10672,19 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n \n+  /* Record the decl so that the function name is defined.\n+     If we already have a decl for this name, and it is a FUNCTION_DECL,\n+     use the old decl.  */\n+\n+  if (pre_parsed_p == 0)\n+    {\n+      current_function_decl = decl1 = pushdecl (decl1);\n+      DECL_MAIN_VARIANT (decl1) = decl1;\n+      fntype = TREE_TYPE (decl1);\n+    }\n+  else\n+    current_function_decl = decl1;\n+\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      It doesn't matter whether it's inline or not.  */\n@@ -10800,19 +10712,6 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n #endif\n     }\n \n-  /* Record the decl so that the function name is defined.\n-     If we already have a decl for this name, and it is a FUNCTION_DECL,\n-     use the old decl.  */\n-\n-  if (pre_parsed_p == 0)\n-    {\n-      current_function_decl = decl1 = pushdecl (decl1);\n-      DECL_MAIN_VARIANT (decl1) = decl1;\n-      fntype = TREE_TYPE (decl1);\n-    }\n-  else\n-    current_function_decl = decl1;\n-\n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n     {\n       if (TREE_CODE (fntype) == METHOD_TYPE)"}, {"sha": "35d408bc3cf59fd50963228ccb1c8ddb23dd1926", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -215,7 +215,7 @@ int warn_extern_inline;\n #endif\n int dollars_in_ident = DOLLARS_IN_IDENTIFIERS;\n \n-/* Nonzero for -no-strict-prototype switch: do not consider empty\n+/* Nonzero for -fno-strict-prototype switch: do not consider empty\n    argument prototype to mean function takes no arguments.  */\n \n int strict_prototype = 1;"}, {"sha": "5e5d5808a5ad5c993dd29a13fffe7b07bf452d6d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -1117,13 +1117,7 @@ expand_aggr_init (exp, init, alias_this)\n       int was_const_elts = TYPE_READONLY (TREE_TYPE (type));\n       tree itype = init ? TREE_TYPE (init) : NULL_TREE;\n       if (was_const_elts)\n-\t{\n-\t  tree atype = build_cplus_array_type (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n-\t\t\t\t\t       TYPE_DOMAIN (type));\n-\t  if (init && (TREE_TYPE (exp) == TREE_TYPE (init)))\n-\t    TREE_TYPE (init) = atype;\n-\t  TREE_TYPE (exp) = atype;\n-\t}\n+\tTREE_TYPE (exp) = TYPE_MAIN_VARIANT (type);\n       if (init && TREE_TYPE (init) == NULL_TREE)\n \t{\n \t  /* Handle bad initializers like:\n@@ -2613,40 +2607,9 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n      enum overload_flags flags;\n      tree quals;\n {\n-  /* first, lets find out if what we are making a friend needs overloading */\n-  tree previous_decl;\n-  int was_c_linkage = 0;\n-\n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;\n \n-  /* If we find something in scope, let see if it has extern \"C\" linkage.  */\n-  /* This code is pretty general and should be ripped out and reused\n-     as a separate function. */\n-  if (DECL_NAME (decl))\n-    {\n-      previous_decl = lookup_name (DECL_NAME (decl), 0);\n-      if (previous_decl && TREE_CODE (previous_decl) == TREE_LIST)\n-\t{\n-\t  do\n-\t    {\n-\t      if (TREE_TYPE (TREE_VALUE (previous_decl)) == TREE_TYPE (decl))\n-\t\t{\n-\t\t  previous_decl = TREE_VALUE (previous_decl);\n-\t\t  break;\n-\t\t}\n-\t      previous_decl = TREE_CHAIN (previous_decl);\n-\t    }\n-\t  while (previous_decl);\n-\t}\n-\n-      /* It had extern \"C\" linkage, so don't overload this.  */\n-      if (previous_decl && TREE_CODE (previous_decl) == FUNCTION_DECL\n-\t  && TREE_TYPE (decl) == TREE_TYPE (previous_decl)\n-\t  && DECL_LANGUAGE (previous_decl) == lang_c)\n-\twas_c_linkage = 1;\n-    }\n-\t  \n   if (ctype)\n     {\n       tree cname = TYPE_NAME (ctype);\n@@ -2711,7 +2674,6 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \t  decl = void_type_node;\n \t}\n     }\n-  /* never overload C functions */\n   else if (TREE_CODE (decl) == FUNCTION_DECL\n \t   && ((IDENTIFIER_LENGTH (declarator) == 4\n \t\t&& IDENTIFIER_POINTER (declarator)[0] == 'm'\n@@ -2720,8 +2682,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals)\n \t\t   && IDENTIFIER_POINTER (declarator)[0] == '_'\n \t\t   && IDENTIFIER_POINTER (declarator)[1] == '_'\n \t\t   && strncmp (IDENTIFIER_POINTER (declarator)+2,\n-\t\t\t       \"builtin_\", 8) == 0)\n-\t       || was_c_linkage))\n+\t\t\t       \"builtin_\", 8) == 0)))\n     {\n       /* raw \"main\", and builtin functions never gets overloaded,\n \t but they can become friends.  */"}, {"sha": "827ee35619acbf460a325ea210302429ef1777a6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -2377,6 +2377,9 @@ do_function_instantiation (declspecs, declarator, storage)\n   if (flag_external_templates)\n     return;\n \n+  if (DECL_EXPLICIT_INSTANTIATION (result) && ! DECL_EXTERNAL (result))\n+    return;\n+\n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n   TREE_PUBLIC (result) = 1;\n \n@@ -2399,6 +2402,9 @@ do_type_instantiation (name, storage)\n   if (flag_external_templates)\n     return;\n \n+  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t))\n+    return;\n+\n   if (TYPE_SIZE (t) == NULL_TREE)\n     {\n       cp_error (\"explicit instantiation of `%#T' before definition of template\","}, {"sha": "832d9653e95ea43d46c894f61e04b226b575146e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -74,12 +74,6 @@ lvalue_p (ref)\n \tcase WITH_CLEANUP_EXPR:\n \t  return 1;\n \n-\tcase CALL_EXPR:\n-\t  /* unary_complex_lvalue knows how to deal with this case.  */\n-\t  if (TREE_ADDRESSABLE (TREE_TYPE (ref)))\n-\t    return 1;\n-\t  break;\n-\n \t  /* A currently unresolved scope ref.  */\n \tcase SCOPE_REF:\n \t  my_friendly_abort (103);"}, {"sha": "840abe646dafe34610c5e0de9bb8d877ce122157", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -5336,6 +5336,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   tree newrhs = rhs;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n+  tree olhs = lhs;\n \n   /* Types that aren't fully specified cannot be used in assignments.  */\n   lhs = require_complete_type (lhs);\n@@ -5933,7 +5934,11 @@ build_modify_expr (lhs, modifycode, rhs)\n      for enum bit fields. */\n   if (TREE_CODE (TREE_TYPE (result)) == INTEGER_TYPE\n       && TREE_CODE (olhstype) == ENUMERAL_TYPE)\n-    return convert_force (olhstype, result);\n+    {\n+      result = build (COMPOUND_EXPR, olhstype, result, olhs);\n+      TREE_NO_UNUSED_WARNING (result) = 1;\n+      return result;\n+    }\n   return convert_for_assignment (olhstype, result, \"assignment\",\n \t\t\t\t NULL_TREE, 0);\n }"}, {"sha": "df76845befac7644e64ec2d229de3fc12d3936ef", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a32034654e77ec19b8c0245d6dbebb06082f0612/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=a32034654e77ec19b8c0245d6dbebb06082f0612", "patch": "@@ -844,7 +844,6 @@ static tree\n process_init_constructor (type, init, elts)\n      tree type, init, *elts;\n {\n-  extern tree empty_init_node;\n   register tree tail;\n   /* List of the elements of the result constructor,\n      in reverse order.  */\n@@ -917,7 +916,7 @@ process_init_constructor (type, init, elts)\n \t  members = tree_cons (NULL_TREE, next1, members);\n \t}\n     }\n-  if (TREE_CODE (type) == RECORD_TYPE && init != empty_init_node)\n+  if (TREE_CODE (type) == RECORD_TYPE)\n     {\n       register tree field;\n \n@@ -1010,7 +1009,7 @@ process_init_constructor (type, init, elts)\n \t}\n     }\n \n-  if (TREE_CODE (type) == UNION_TYPE && init != empty_init_node)\n+  if (TREE_CODE (type) == UNION_TYPE)\n     {\n       register tree field = TYPE_FIELDS (type);\n       register tree next1;\n@@ -1438,7 +1437,7 @@ build_functional_cast (exp, parms)\n     return error_mark_node;\n \n   if (current_function_decl)\n-    return build_cplus_new (type, expr_as_ctor, 0);\n+    return build_cplus_new (type, expr_as_ctor, 1);\n \n   {\n     register tree parm = TREE_OPERAND (expr_as_ctor, 1);"}]}