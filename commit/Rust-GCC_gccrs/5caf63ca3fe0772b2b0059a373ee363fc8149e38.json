{"sha": "5caf63ca3fe0772b2b0059a373ee363fc8149e38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNhZjYzY2EzZmUwNzcyYjJiMDA1OWEzNzNlZTM2M2ZjODE0OWUzOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-28T21:27:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-03-28T21:27:28Z"}, "message": "compiler: Rewrite handling of untyped numeric constants.\n\nFixes various bugs when, e.g., using float or complex\nconstants in integer contexts.\n\nFrom-SVN: r185925", "tree": {"sha": "959c57c6e83eac4a05be250aa2752daca0cd50fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/959c57c6e83eac4a05be250aa2752daca0cd50fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5caf63ca3fe0772b2b0059a373ee363fc8149e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5caf63ca3fe0772b2b0059a373ee363fc8149e38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5caf63ca3fe0772b2b0059a373ee363fc8149e38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5caf63ca3fe0772b2b0059a373ee363fc8149e38/comments", "author": null, "committer": null, "parents": [{"sha": "b59e90711fdd29e707a9a071f14efdaee7d70d1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59e90711fdd29e707a9a071f14efdaee7d70d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59e90711fdd29e707a9a071f14efdaee7d70d1a"}], "stats": {"total": 3721, "additions": 1667, "deletions": 2054}, "files": [{"sha": "4c493f8766505552b5ad195f194e4749723de512", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1366, "deletions": 1877, "changes": 3243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5caf63ca3fe0772b2b0059a373ee363fc8149e38"}, {"sha": "090e893f25ee5f90356e4cd2ccc817c7a1f9d324", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 221, "deletions": 78, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5caf63ca3fe0772b2b0059a373ee363fc8149e38", "patch": "@@ -18,6 +18,9 @@ class Traverse;\n class Statement_inserter;\n class Type;\n struct Type_context;\n+class Integer_type;\n+class Float_type;\n+class Complex_type;\n class Function_type;\n class Map_type;\n class Struct_type;\n@@ -38,6 +41,7 @@ class Field_reference_expression;\n class Interface_field_reference_expression;\n class Type_guard_expression;\n class Receive_expression;\n+class Numeric_constant;\n class Named_object;\n class Export;\n class Import;\n@@ -342,30 +346,11 @@ class Expression\n   is_constant() const\n   { return this->do_is_constant(); }\n \n-  // If this is not a constant expression with integral type, return\n-  // false.  If it is one, return true, and set VAL to the value.  VAL\n-  // should already be initialized.  If this returns true, it sets\n-  // *PTYPE to the type of the value, or NULL for an abstract type.\n-  // If IOTA_IS_CONSTANT is true, then an iota expression is assumed\n-  // to have its final value.\n+  // If this is not a numeric constant, return false.  If it is one,\n+  // return true, and set VAL to hold the value.\n   bool\n-  integer_constant_value(bool iota_is_constant, mpz_t val, Type** ptype) const;\n-\n-  // If this is not a constant expression with floating point type,\n-  // return false.  If it is one, return true, and set VAL to the\n-  // value.  VAL should already be initialized.  If this returns true,\n-  // it sets *PTYPE to the type of the value, or NULL for an abstract\n-  // type.\n-  bool\n-  float_constant_value(mpfr_t val, Type** ptype) const;\n-\n-  // If this is not a constant expression with complex type, return\n-  // false.  If it is one, return true, and set REAL and IMAG to the\n-  // value.  REAL and IMAG should already be initialized.  If this\n-  // return strue, it sets *PTYPE to the type of the value, or NULL\n-  // for an abstract type.\n-  bool\n-  complex_constant_value(mpfr_t real, mpfr_t imag, Type** ptype) const;\n+  numeric_constant_value(Numeric_constant* val) const\n+  { return this->do_numeric_constant_value(val); }\n \n   // If this is not a constant expression with string type, return\n   // false.  If it is one, return true, and set VAL to the value.\n@@ -691,22 +676,10 @@ class Expression\n   do_is_constant() const\n   { return false; }\n \n-  // Return whether this is a constant expression of integral type,\n-  // and set VAL to the value.\n-  virtual bool\n-  do_integer_constant_value(bool, mpz_t, Type**) const\n-  { return false; }\n-\n-  // Return whether this is a constant expression of floating point\n-  // type, and set VAL to the value.\n+  // Return whether this is a constant expression of numeric type, and\n+  // set the Numeric_constant to the value.\n   virtual bool\n-  do_float_constant_value(mpfr_t, Type**) const\n-  { return false; }\n-\n-  // Return whether this is a constant expression of complex type, and\n-  // set REAL and IMAGE to the value.\n-  virtual bool\n-  do_complex_constant_value(mpfr_t, mpfr_t, Type**) const\n+  do_numeric_constant_value(Numeric_constant*) const\n   { return false; }\n \n   // Return whether this is a constant expression of string type, and\n@@ -1189,42 +1162,21 @@ class Binary_expression : public Expression\n   right()\n   { return this->right_; }\n \n-  // Apply binary opcode OP to LEFT_VAL and RIGHT_VAL, setting VAL.\n-  // LEFT_TYPE is the type of LEFT_VAL, RIGHT_TYPE is the type of\n-  // RIGHT_VAL; LEFT_TYPE and/or RIGHT_TYPE may be NULL.  Return true\n-  // if this could be done, false if not.\n+  // Apply binary opcode OP to LEFT_NC and RIGHT_NC, setting NC.\n+  // Return true if this could be done, false if not.  Issue errors at\n+  // LOCATION as appropriate.\n   static bool\n-  eval_integer(Operator op, Type* left_type, mpz_t left_val,\n-\t       Type* right_type, mpz_t right_val, Location,\n-\t       mpz_t val);\n+  eval_constant(Operator op, Numeric_constant* left_nc,\n+\t\tNumeric_constant* right_nc, Location location,\n+\t\tNumeric_constant* nc);\n \n-  // Apply binary opcode OP to LEFT_VAL and RIGHT_VAL, setting VAL.\n-  // Return true if this could be done, false if not.\n+  // Compare constants LEFT_NC and RIGHT_NC according to OP, setting\n+  // *RESULT.  Return true if this could be done, false if not.  Issue\n+  // errors at LOCATION as appropriate.\n   static bool\n-  eval_float(Operator op, Type* left_type, mpfr_t left_val,\n-\t     Type* right_type, mpfr_t right_val, mpfr_t val,\n-\t     Location);\n-\n-  // Apply binary opcode OP to LEFT_REAL/LEFT_IMAG and\n-  // RIGHT_REAL/RIGHT_IMAG, setting REAL/IMAG.  Return true if this\n-  // could be done, false if not.\n-  static bool\n-  eval_complex(Operator op, Type* left_type, mpfr_t left_real,\n-\t       mpfr_t left_imag, Type* right_type, mpfr_t right_real,\n-\t       mpfr_t right_imag, mpfr_t real, mpfr_t imag, Location);\n-\n-  // Compare integer constants according to OP.\n-  static bool\n-  compare_integer(Operator op, mpz_t left_val, mpz_t right_val);\n-\n-  // Compare floating point constants according to OP.\n-  static bool\n-  compare_float(Operator op, Type* type, mpfr_t left_val, mpfr_t right_val);\n-\n-  // Compare complex constants according to OP.\n-  static bool\n-  compare_complex(Operator op, Type* type, mpfr_t left_real, mpfr_t left_imag,\n-\t\t  mpfr_t right_val, mpfr_t right_imag);\n+  compare_constant(Operator op, Numeric_constant* left_nc,\n+\t\t   Numeric_constant* right_nc, Location location,\n+\t\t   bool* result);\n \n   static Expression*\n   do_import(Import*);\n@@ -1246,13 +1198,7 @@ class Binary_expression : public Expression\n   { return this->left_->is_constant() && this->right_->is_constant(); }\n \n   bool\n-  do_integer_constant_value(bool, mpz_t val, Type**) const;\n-\n-  bool\n-  do_float_constant_value(mpfr_t val, Type**) const;\n-\n-  bool\n-  do_complex_constant_value(mpfr_t real, mpfr_t imag, Type**) const;\n+  do_numeric_constant_value(Numeric_constant*) const;\n \n   void\n   do_discarding_value();\n@@ -1283,6 +1229,34 @@ class Binary_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n \n  private:\n+  static bool\n+  operation_type(Operator op, Type* left_type, Type* right_type,\n+\t\t Type** result_type);\n+\n+  static bool\n+  cmp_to_bool(Operator op, int cmp);\n+\n+  static bool\n+  eval_integer(Operator op, const Numeric_constant*, const Numeric_constant*,\n+\t       Location, Numeric_constant*);\n+\n+  static bool\n+  eval_float(Operator op, const Numeric_constant*, const Numeric_constant*,\n+\t     Location, Numeric_constant*);\n+\n+  static bool\n+  eval_complex(Operator op, const Numeric_constant*, const Numeric_constant*,\n+\t       Location, Numeric_constant*);\n+\n+  static bool\n+  compare_integer(const Numeric_constant*, const Numeric_constant*, int*);\n+\n+  static bool\n+  compare_float(const Numeric_constant*, const Numeric_constant *, int*);\n+\n+  static bool\n+  compare_complex(const Numeric_constant*, const Numeric_constant*, int*);\n+\n   Expression*\n   lower_struct_comparison(Gogo*, Statement_inserter*);\n \n@@ -2101,4 +2075,173 @@ class Receive_expression : public Expression\n   Expression* channel_;\n };\n \n+// A numeric constant.  This is used both for untyped constants and\n+// for constants that have a type.\n+\n+class Numeric_constant\n+{\n+ public:\n+  Numeric_constant()\n+    : classification_(NC_INVALID), type_(NULL)\n+  { }\n+\n+  ~Numeric_constant();\n+\n+  Numeric_constant(const Numeric_constant&);\n+\n+  Numeric_constant& operator=(const Numeric_constant&);\n+\n+  // Set to an unsigned long value.\n+  void\n+  set_unsigned_long(Type*, unsigned long);\n+\n+  // Set to an integer value.\n+  void\n+  set_int(Type*, const mpz_t);\n+\n+  // Set to a rune value.\n+  void\n+  set_rune(Type*, const mpz_t);\n+\n+  // Set to a floating point value.\n+  void\n+  set_float(Type*, const mpfr_t);\n+\n+  // Set to a complex value.\n+  void\n+  set_complex(Type*, const mpfr_t, const mpfr_t);\n+\n+  // Classifiers.\n+  bool\n+  is_int() const\n+  { return this->classification_ == Numeric_constant::NC_INT; }\n+\n+  bool\n+  is_rune() const\n+  { return this->classification_ == Numeric_constant::NC_RUNE; }\n+\n+  bool\n+  is_float() const\n+  { return this->classification_ == Numeric_constant::NC_FLOAT; }\n+\n+  bool\n+  is_complex() const\n+  { return this->classification_ == Numeric_constant::NC_COMPLEX; }\n+\n+  // Value retrievers.  These will initialize the values as well as\n+  // set them.  GET_INT is only valid if IS_INT returns true, and\n+  // likewise respectively.\n+  void\n+  get_int(mpz_t*) const;\n+\n+  void\n+  get_rune(mpz_t*) const;\n+\n+  void\n+  get_float(mpfr_t*) const;\n+\n+  void\n+  get_complex(mpfr_t*, mpfr_t*) const;\n+\n+  // Codes returned by to_unsigned_long.\n+  enum To_unsigned_long\n+  {\n+    // Value is integer and fits in unsigned long.\n+    NC_UL_VALID,\n+    // Value is not integer.\n+    NC_UL_NOTINT,\n+    // Value is integer but is negative.\n+    NC_UL_NEGATIVE,\n+    // Value is non-negative integer but does not fit in unsigned\n+    // long.\n+    NC_UL_BIG\n+  };\n+\n+  // If the value can be expressed as an integer that fits in an\n+  // unsigned long, set *VAL and return NC_UL_VALID.  Otherwise return\n+  // one of the other To_unsigned_long codes.\n+  To_unsigned_long\n+  to_unsigned_long(unsigned long* val) const;\n+\n+  // If the value can be expressed as an int, return true and\n+  // initialize and set VAL.  This will return false for a value with\n+  // an explicit float or complex type, even if the value is integral.\n+  bool\n+  to_int(mpz_t* val) const;\n+\n+  // If the value can be expressed as a float, return true and\n+  // initialize and set VAL.\n+  bool\n+  to_float(mpfr_t* val) const;\n+\n+  // If the value can be expressed as a complex, return true and\n+  // initialize and set VR and VI.\n+  bool\n+  to_complex(mpfr_t* vr, mpfr_t* vi) const;\n+\n+  // Get the type.\n+  Type*\n+  type() const;\n+\n+  // If the constant can be expressed in TYPE, then set the type of\n+  // the constant to TYPE and return true.  Otherwise return false,\n+  // and, if ISSUE_ERROR is true, issue an error message.  LOCATION is\n+  // the location to use for the error.\n+  bool\n+  set_type(Type* type, bool issue_error, Location location);\n+\n+  // Return an Expression for this value.\n+  Expression*\n+  expression(Location) const;\n+\n+ private:\n+  void\n+  clear();\n+\n+  To_unsigned_long\n+  mpz_to_unsigned_long(const mpz_t ival, unsigned long *val) const;\n+\n+  To_unsigned_long\n+  mpfr_to_unsigned_long(const mpfr_t fval, unsigned long *val) const;\n+\n+  bool\n+  check_int_type(Integer_type*, bool, Location) const;\n+\n+  bool\n+  check_float_type(Float_type*, bool, Location) const;\n+\n+  bool\n+  check_complex_type(Complex_type*, bool, Location) const;\n+\n+  // The kinds of constants.\n+  enum Classification\n+  {\n+    NC_INVALID,\n+    NC_RUNE,\n+    NC_INT,\n+    NC_FLOAT,\n+    NC_COMPLEX\n+  };\n+\n+  // The kind of constant.\n+  Classification classification_;\n+  // The value.\n+  union\n+  {\n+    // If NC_INT or NC_RUNE.\n+    mpz_t int_val;\n+    // If NC_FLOAT.\n+    mpfr_t float_val;\n+    // If NC_COMPLEX.\n+    struct\n+    {\n+      mpfr_t real;\n+      mpfr_t imag;\n+    } complex_val;\n+  } u_;\n+  // The type if there is one.  This will be NULL for an untyped\n+  // constant.\n+  Type* type_;\n+};\n+\n #endif // !defined(GO_EXPRESSIONS_H)"}, {"sha": "7f91e553a4d5500dd3f4e0ec909350ab33d9f85b", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=5caf63ca3fe0772b2b0059a373ee363fc8149e38", "patch": "@@ -3214,10 +3214,9 @@ class Case_clauses::Hash_integer_value\n size_t\n Case_clauses::Hash_integer_value::operator()(Expression* pe) const\n {\n-  Type* itype;\n+  Numeric_constant nc;\n   mpz_t ival;\n-  mpz_init(ival);\n-  if (!pe->integer_constant_value(true, ival, &itype))\n+  if (!pe->numeric_constant_value(&nc) || !nc.to_int(&ival))\n     go_unreachable();\n   size_t ret = mpz_get_ui(ival);\n   mpz_clear(ival);\n@@ -3236,14 +3235,14 @@ class Case_clauses::Eq_integer_value\n bool\n Case_clauses::Eq_integer_value::operator()(Expression* a, Expression* b) const\n {\n-  Type* atype;\n-  Type* btype;\n+  Numeric_constant anc;\n   mpz_t aval;\n+  Numeric_constant bnc;\n   mpz_t bval;\n-  mpz_init(aval);\n-  mpz_init(bval);\n-  if (!a->integer_constant_value(true, aval, &atype)\n-      || !b->integer_constant_value(true, bval, &btype))\n+  if (!a->numeric_constant_value(&anc)\n+      || !anc.to_int(&aval)\n+      || !b->numeric_constant_value(&bnc)\n+      || !bnc.to_int(&bval))\n     go_unreachable();\n   bool ret = mpz_cmp(aval, bval) == 0;\n   mpz_clear(aval);\n@@ -3431,18 +3430,17 @@ Case_clauses::Case_clause::get_backend(Translate_context* context,\n \t  Expression* e = *p;\n \t  if (e->classification() != Expression::EXPRESSION_INTEGER)\n \t    {\n-\t      Type* itype;\n+\t      Numeric_constant nc;\n \t      mpz_t ival;\n-\t      mpz_init(ival);\n-\t      if (!(*p)->integer_constant_value(true, ival, &itype))\n+\t      if (!(*p)->numeric_constant_value(&nc) || !nc.to_int(&ival))\n \t\t{\n \t\t  // Something went wrong.  This can happen with a\n \t\t  // negative constant and an unsigned switch value.\n \t\t  go_assert(saw_errors());\n \t\t  continue;\n \t\t}\n-\t      go_assert(itype != NULL);\n-\t      e = Expression::make_integer(&ival, itype, e->location());\n+\t      go_assert(nc.type() != NULL);\n+\t      e = Expression::make_integer(&ival, nc.type(), e->location());\n \t      mpz_clear(ival);\n \t    }\n "}, {"sha": "9e64a6ac84a176d5614d9ab370a3be61796c1b9a", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 60, "deletions": 85, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=5caf63ca3fe0772b2b0059a373ee363fc8149e38", "patch": "@@ -2230,15 +2230,13 @@ Type::is_backend_type_size_known(Gogo* gogo)\n \t  return true;\n \telse\n \t  {\n+\t    Numeric_constant nc;\n+\t    if (!at->length()->numeric_constant_value(&nc))\n+\t      return false;\n \t    mpz_t ival;\n-\t    mpz_init(ival);\n-\t    Type* dummy;\n-\t    bool length_known = at->length()->integer_constant_value(true,\n-\t\t\t\t\t\t\t\t     ival,\n-\t\t\t\t\t\t\t\t     &dummy);\n-\t    mpz_clear(ival);\n-\t    if (!length_known)\n+\t    if (!nc.to_int(&ival))\n \t      return false;\n+\t    mpz_clear(ival);\n \t    return at->element_type()->is_backend_type_size_known(gogo);\n \t  }\n       }\n@@ -5106,17 +5104,22 @@ Array_type::is_identical(const Array_type* t, bool errors_are_identical) const\n       // Try to determine the lengths.  If we can't, assume the arrays\n       // are not identical.\n       bool ret = false;\n-      mpz_t v1;\n-      mpz_init(v1);\n-      Type* type1;\n-      mpz_t v2;\n-      mpz_init(v2);\n-      Type* type2;\n-      if (l1->integer_constant_value(true, v1, &type1)\n-\t  && l2->integer_constant_value(true, v2, &type2))\n-\tret = mpz_cmp(v1, v2) == 0;\n-      mpz_clear(v1);\n-      mpz_clear(v2);\n+      Numeric_constant nc1, nc2;\n+      if (l1->numeric_constant_value(&nc1)\n+\t  && l2->numeric_constant_value(&nc2))\n+\t{\n+\t  mpz_t v1;\n+\t  if (nc1.to_int(&v1))\n+\t    {\n+\t      mpz_t v2;\n+\t      if (nc2.to_int(&v2))\n+\t\t{\n+\t\t  ret = mpz_cmp(v1, v2) == 0;\n+\t\t  mpz_clear(v2);\n+\t\t}\n+\t      mpz_clear(v1);\n+\t    }\n+\t}\n       return ret;\n     }\n \n@@ -5154,58 +5157,44 @@ Array_type::verify_length()\n       return false;\n     }\n \n-  mpz_t val;\n-  mpz_init(val);\n-  Type* vt;\n-  if (!this->length_->integer_constant_value(true, val, &vt))\n+  Numeric_constant nc;\n+  if (!this->length_->numeric_constant_value(&nc))\n     {\n-      mpfr_t fval;\n-      mpfr_init(fval);\n-      if (!this->length_->float_constant_value(fval, &vt))\n-\t{\n-\t  if (this->length_->type()->integer_type() != NULL\n-\t      || this->length_->type()->float_type() != NULL)\n-\t    error_at(this->length_->location(),\n-\t\t     \"array bound is not constant\");\n-\t  else\n-\t    error_at(this->length_->location(),\n-\t\t     \"array bound is not numeric\");\n-\t  mpfr_clear(fval);\n-\t  mpz_clear(val);\n-\t  return false;\n-\t}\n-      if (!mpfr_integer_p(fval))\n-\t{\n-\t  error_at(this->length_->location(),\n-\t\t   \"array bound truncated to integer\");\n-\t  mpfr_clear(fval);\n-\t  mpz_clear(val);\n-\t  return false;\n-\t}\n-      mpz_init(val);\n-      mpfr_get_z(val, fval, GMP_RNDN);\n-      mpfr_clear(fval);\n+      if (this->length_->type()->integer_type() != NULL\n+\t  || this->length_->type()->float_type() != NULL)\n+\terror_at(this->length_->location(), \"array bound is not constant\");\n+      else\n+\terror_at(this->length_->location(), \"array bound is not numeric\");\n+      return false;\n     }\n \n-  if (mpz_sgn(val) < 0)\n+  unsigned long val;\n+  switch (nc.to_unsigned_long(&val))\n     {\n+    case Numeric_constant::NC_UL_VALID:\n+      break;\n+    case Numeric_constant::NC_UL_NOTINT:\n+      error_at(this->length_->location(), \"array bound truncated to integer\");\n+      return false;\n+    case Numeric_constant::NC_UL_NEGATIVE:\n       error_at(this->length_->location(), \"negative array bound\");\n-      mpz_clear(val);\n       return false;\n+    case Numeric_constant::NC_UL_BIG:\n+      error_at(this->length_->location(), \"array bound overflows\");\n+      return false;\n+    default:\n+      go_unreachable();\n     }\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n-  int tbits = int_type->integer_type()->bits();\n-  int vbits = mpz_sizeinbase(val, 2);\n-  if (vbits + 1 > tbits)\n+  unsigned int tbits = int_type->integer_type()->bits();\n+  if (sizeof(val) <= tbits * 8\n+      && val >> (tbits - 1) != 0)\n     {\n       error_at(this->length_->location(), \"array bound overflows\");\n-      mpz_clear(val);\n       return false;\n     }\n \n-  mpz_clear(val);\n-\n   return true;\n }\n \n@@ -5457,11 +5446,11 @@ Array_type::get_length_tree(Gogo* gogo)\n   go_assert(this->length_ != NULL);\n   if (this->length_tree_ == NULL_TREE)\n     {\n+      Numeric_constant nc;\n       mpz_t val;\n-      mpz_init(val);\n-      Type* t;\n-      if (this->length_->integer_constant_value(true, val, &t))\n+      if (this->length_->numeric_constant_value(&nc) && nc.to_int(&val))\n \t{\n+\t  Type* t = nc.type();\n \t  if (t == NULL)\n \t    t = Type::lookup_integer_type(\"int\");\n \t  else if (t->is_abstract())\n@@ -5472,8 +5461,6 @@ Array_type::get_length_tree(Gogo* gogo)\n \t}\n       else\n \t{\n-\t  mpz_clear(val);\n-\n \t  // Make up a translation context for the array length\n \t  // expression.  FIXME: This won't work in general.\n \t  Translate_context context(gogo, NULL, NULL, NULL);\n@@ -5824,23 +5811,17 @@ Array_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->push_back('[');\n   if (this->length_ != NULL)\n     {\n-      mpz_t val;\n-      mpz_init(val);\n-      Type* type;\n-      if (!this->length_->integer_constant_value(true, val, &type))\n-\terror_at(this->length_->location(),\n-\t\t \"array length must be integer constant expression\");\n-      else if (mpz_cmp_si(val, 0) < 0)\n-\terror_at(this->length_->location(), \"array length is negative\");\n-      else if (mpz_cmp_ui(val, mpz_get_ui(val)) != 0)\n-\terror_at(this->length_->location(), \"array length is too large\");\n+      Numeric_constant nc;\n+      unsigned long val;\n+      if (!this->length_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&val) != Numeric_constant::NC_UL_VALID)\n+\terror_at(this->length_->location(), \"invalid array length\");\n       else\n \t{\n \t  char buf[50];\n-\t  snprintf(buf, sizeof buf, \"%lu\", mpz_get_ui(val));\n+\t  snprintf(buf, sizeof buf, \"%lu\", val);\n \t  ret->append(buf);\n \t}\n-      mpz_clear(val);\n     }\n   ret->push_back(']');\n \n@@ -5856,23 +5837,17 @@ Array_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n   this->append_mangled_name(this->element_type_, gogo, ret);\n   if (this->length_ != NULL)\n     {\n-      mpz_t val;\n-      mpz_init(val);\n-      Type* type;\n-      if (!this->length_->integer_constant_value(true, val, &type))\n-\terror_at(this->length_->location(),\n-\t\t \"array length must be integer constant expression\");\n-      else if (mpz_cmp_si(val, 0) < 0)\n-\terror_at(this->length_->location(), \"array length is negative\");\n-      else if (mpz_cmp_ui(val, mpz_get_ui(val)) != 0)\n-\terror_at(this->length_->location(), \"array size is too large\");\n+      Numeric_constant nc;\n+      unsigned long val;\n+      if (!this->length_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&val) != Numeric_constant::NC_UL_VALID)\n+\terror_at(this->length_->location(), \"invalid array length\");\n       else\n \t{\n \t  char buf[50];\n-\t  snprintf(buf, sizeof buf, \"%lu\", mpz_get_ui(val));\n+\t  snprintf(buf, sizeof buf, \"%lu\", val);\n \t  ret->append(buf);\n \t}\n-      mpz_clear(val);\n     }\n   ret->push_back('e');\n }"}, {"sha": "edc46b720738dbf2a26caf9865e11b1d6415c20e", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5caf63ca3fe0772b2b0059a373ee363fc8149e38/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=5caf63ca3fe0772b2b0059a373ee363fc8149e38", "patch": "@@ -680,6 +680,14 @@ class Type\n   complex_type() const\n   { return this->convert<const Complex_type, TYPE_COMPLEX>(); }\n \n+  // Return whether this is a numeric type.\n+  bool\n+  is_numeric_type() const\n+  {\n+    Type_classification tc = this->base()->classification_;\n+    return tc == TYPE_INTEGER || tc == TYPE_FLOAT || tc == TYPE_COMPLEX;\n+  }\n+\n   // Return true if this is a boolean type.\n   bool\n   is_boolean_type() const"}]}