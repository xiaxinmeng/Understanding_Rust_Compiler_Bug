{"sha": "390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkwZjRlOWE3ZDZiNWE3NTk0MjhmYzRjYmU4OWQyYWRkMDU0N2ZhYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-05T01:00:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-05T01:00:28Z"}, "message": "optimize.c (inline_data): Remove fns_top.\n\n\t* optimize.c (inline_data): Remove fns_top.  Add scope_stmt.  Add\n\tin_target_cleanup_p.\n\t(remap_decl): New function.\n\t(remap_block): Likewise.\n\t(copy_scope_stmt): Likewise.\n\t(copy_body_r): Use remap_decl and copy_scope_stmt.\n\t(copy_body): Use VARRAY_TOP_TREE.\n\t(initialize_inlined_parameters): Likewise.\n\t(declare_return_variable): Likewise.\n\t(inlinable_function_p): Check flag_inline_trees.\n\t(expand_call_inline): Handle SCOPE_STMTs and TARGET_EXPRs\n\tspecially.  Use VARRAY_PUSH_TREE.  Create a BLOCK for the\n\tparameters of the inlined function.\n\t(optimize_function): Prevent recursion into partially complete\n\tfunctions.\n\nFrom-SVN: r30781", "tree": {"sha": "9dcf3ffcd939e2d7d41d2a953ca75d1aae0dcb14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dcf3ffcd939e2d7d41d2a953ca75d1aae0dcb14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/390f4e9a7d6b5a759428fc4cbe89d2add0547faa/comments", "author": null, "committer": null, "parents": [{"sha": "5a586e5083a67ae56ee5e2f5fc251dfabd1f31c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a586e5083a67ae56ee5e2f5fc251dfabd1f31c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a586e5083a67ae56ee5e2f5fc251dfabd1f31c1"}], "stats": {"total": 318, "additions": 277, "deletions": 41}, "files": [{"sha": "a5e7dd9a92d2d500e6138e70c163bae438155f68", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390f4e9a7d6b5a759428fc4cbe89d2add0547faa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390f4e9a7d6b5a759428fc4cbe89d2add0547faa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "patch": "@@ -1,5 +1,21 @@\n 1999-12-04  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* optimize.c (inline_data): Remove fns_top.  Add scope_stmt.  Add\n+\tin_target_cleanup_p.\n+\t(remap_decl): New function.\n+\t(remap_block): Likewise.\n+\t(copy_scope_stmt): Likewise.\n+\t(copy_body_r): Use remap_decl and copy_scope_stmt.\n+\t(copy_body): Use VARRAY_TOP_TREE.\n+\t(initialize_inlined_parameters): Likewise.\n+\t(declare_return_variable): Likewise.\n+\t(inlinable_function_p): Check flag_inline_trees.\n+\t(expand_call_inline): Handle SCOPE_STMTs and TARGET_EXPRs\n+\tspecially.  Use VARRAY_PUSH_TREE.  Create a BLOCK for the\n+\tparameters of the inlined function.\n+\t(optimize_function): Prevent recursion into partially complete\n+\tfunctions.\n+\t\n \t* cp-tree.def (SCOPE_STMT): Take one operand.\n \t* cp-tree.h (SCOPE_STMT_BLOCK): New macro.\n \t(SCOPE_NULLIFIED_P): Redefine."}, {"sha": "57161661d1ea5f3cea89c5cf3f95ed83024ca46e", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 261, "deletions": 41, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/390f4e9a7d6b5a759428fc4cbe89d2add0547faa/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/390f4e9a7d6b5a759428fc4cbe89d2add0547faa/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=390f4e9a7d6b5a759428fc4cbe89d2add0547faa", "patch": "@@ -31,8 +31,6 @@\n \n /* To Do:\n \n-   o Provide debugging information for inlined function bodies.  \n-\n    o In order to make inlining-on-trees work, we pessimized\n      function-local static constants.  In particular, they are now\n      always output, even when not addressed.  Fix this by treating\n@@ -41,7 +39,10 @@\n      are not needed.\n      \n    o Provide heuristics to clamp inlining of recursive template\n-     calls?  */\n+     calls?  \n+\n+   o It looks like the return label is not being placed in the optimal\n+     place.  Shouldn't it come before the returned value?  */\n    \n /* Data required for function inlining.  */\n \n@@ -52,13 +53,16 @@ typedef struct inline_data\n      inlining the body of `h', the stack will contain, `h', followed\n      by `g', followed by `f'.  */\n   varray_type fns;\n-  /* The top of the FNS stack.  */\n-  size_t fns_top;\n+  /* The last SCOPE_STMT we have encountered.  */\n+  tree scope_stmt;\n   /* The label to jump to when a return statement is encountered.  */\n   tree ret_label;\n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n   splay_tree decl_map;\n+  /* Nonzero if we are currently within the cleanup for a\n+     TARGET_EXPR.  */\n+  int in_target_cleanup_p;\n } inline_data;\n \n /* Prototypes.  */\n@@ -70,6 +74,163 @@ static tree copy_body PROTO((inline_data *));\n static tree expand_call_inline PROTO((tree *, int *, void *));\n static void expand_calls_inline PROTO((tree *, inline_data *));\n static int inlinable_function_p PROTO((tree, inline_data *));\n+static tree remap_decl PROTO((tree, inline_data *));\n+static void remap_block PROTO((tree, tree, inline_data *));\n+static void copy_scope_stmt PROTO((tree *, int *, inline_data *));\n+\n+/* Remap DECL during the copying of the BLOCK tree for the function.\n+   DATA is really an `inline_data *'.  */\n+\n+static tree\n+remap_decl (decl, id)\n+     tree decl;\n+     inline_data *id;\n+{\n+  splay_tree_node n;\n+  tree fn;\n+\n+  /* We only remap local variables in the current function.  */\n+  fn = VARRAY_TOP_TREE (id->fns);\n+  if (!nonstatic_local_decl_p (decl) || DECL_CONTEXT (decl) != fn)\n+    return NULL_TREE;\n+\n+  /* See if we have remapped this declaration.  */\n+  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+  /* If we didn't already have an equivalent for this declaration,\n+     create one now.  */\n+  if (!n)\n+    {\n+      tree t;\n+      \n+      /* Make a copy of the variable or label.  */\n+      t = copy_decl_for_inlining (decl, fn, \n+\t\t\t\t  VARRAY_TREE (id->fns, 0));\n+      /* Remember it, so that if we encounter this local entity\n+\t again we can reuse this copy.  */\n+      n = splay_tree_insert (id->decl_map, \n+\t\t\t     (splay_tree_key) decl, \n+\t\t\t     (splay_tree_value) t);\n+    }\n+ \n+  return (tree) n->value;\n+}\n+\n+/* Copy the SCOPE_STMT_BLOCK associated with SCOPE_STMT to contain\n+   remapped versions of the variables therein.  And hook the new block\n+   into the block-tree.  If non-NULL, the DECLS are declarations to\n+   add to use instead of the BLOCK_VARS in the old block.  */\n+\n+static void\n+remap_block (scope_stmt, decls, id)\n+     tree scope_stmt;\n+     tree decls;\n+     inline_data *id;\n+{\n+  /* We cannot do this in the cleanup for a TARGET_EXPR since we do\n+     not know whether or not expand_expr will actually write out the\n+     code we put there.  If it does not, then we'll have more BLOCKs\n+     than block-notes, and things will go awry.  At some point, we\n+     should make the back-end handle BLOCK notes in a tidier way,\n+     without requiring a strict correspondence to the block-tree; then\n+     this check can go.  */\n+  if (id->in_target_cleanup_p)\n+    {\n+      SCOPE_STMT_BLOCK (scope_stmt) = NULL_TREE;\n+      return;\n+    }\n+\n+  /* If this is the beginning of a scope, remap the associated BLOCK.  */\n+  if (SCOPE_BEGIN_P (scope_stmt) && SCOPE_STMT_BLOCK (scope_stmt))\n+    {\n+      tree old_block;\n+      tree new_block;\n+      tree old_var;\n+\n+      /* Make the new block.  */\n+      old_block = SCOPE_STMT_BLOCK (scope_stmt);\n+      new_block = make_node (BLOCK);\n+      TREE_USED (new_block) = TREE_USED (old_block);\n+      BLOCK_ABSTRACT_ORIGIN (new_block) = old_block;\n+      SCOPE_STMT_BLOCK (scope_stmt) = new_block;\n+\n+      /* Remap its variables.  */\n+      for (old_var = decls ? decls : BLOCK_VARS (old_block); \n+\t   old_var; \n+\t   old_var = TREE_CHAIN (old_var))\n+\t{\n+\t  tree new_var;\n+\n+\t  /* Remap the variable.  */\n+\t  new_var = remap_decl (old_var, id);\n+\t  if (!new_var)\n+\t    /* We didn't remap this variable, so we can't mess with\n+\t       its TREE_CHAIN.  */\n+\t    ;\n+\t  else\n+\t    {\n+\t      TREE_CHAIN (new_var) = BLOCK_VARS (new_block);\n+\t      BLOCK_VARS (new_block) = new_var;\n+\t    }\n+\t}\n+      /* We put the BLOCK_VARS in reverse order; fix that now.  */\n+      BLOCK_VARS (new_block) = nreverse (BLOCK_VARS (new_block));\n+      /* Graft the new block into the tree.  */\n+      insert_block_after_note (new_block, \n+\t\t\t       (id->scope_stmt \n+\t\t\t\t? SCOPE_STMT_BLOCK (id->scope_stmt)\n+\t\t\t\t: NULL_TREE),\n+\t\t\t       (id->scope_stmt\n+\t\t\t\t? SCOPE_BEGIN_P (id->scope_stmt) : 1),\n+\t\t\t       VARRAY_TREE (id->fns, 0));\n+      /* Remember that this is now the last scope statement with\n+\t an associated block.  */\n+      id->scope_stmt = scope_stmt;\n+      /* Remember the remapped block.  */\n+      splay_tree_insert (id->decl_map,\n+\t\t\t (splay_tree_key) old_block,\n+\t\t\t (splay_tree_value) new_block);\n+    }\n+  /* If this is the end of a scope, set the SCOPE_STMT_BLOCK to be the\n+     remapped block.  */\n+  else if (SCOPE_END_P (scope_stmt) && SCOPE_STMT_BLOCK (scope_stmt))\n+    {\n+      splay_tree_node n;\n+\n+      /* Find this block in the table of remapped things.  */\n+      n = splay_tree_lookup (id->decl_map, \n+\t\t\t     (splay_tree_key) SCOPE_STMT_BLOCK (scope_stmt));\n+      my_friendly_assert (n != NULL, 19991203);\n+      SCOPE_STMT_BLOCK (scope_stmt) = (tree) n->value;\n+\n+      /* Remember that this is now the last scope statement with an\n+\t associated block.  */\n+      id->scope_stmt = scope_stmt;\n+    }\n+}\n+\n+/* Copy the SCOPE_STMT pointed to by TP.  */\n+\n+static void\n+copy_scope_stmt (tp, walk_subtrees, id)\n+     tree *tp;\n+     int *walk_subtrees;\n+     inline_data *id;\n+{\n+  tree block;\n+\n+  /* Remember whether or not this statement was nullified.  When\n+     making a copy, copy_tree_r always sets SCOPE_NULLIFIED_P (and\n+     doesn't copy the SCOPE_STMT_BLOCK) to free callers from having to\n+     deal with copying BLOCKs if they do not wish to do so.  */\n+  block = SCOPE_STMT_BLOCK (*tp);\n+  /* Copy (and replace) the statement.  */\n+  copy_tree_r (tp, walk_subtrees, NULL);\n+  /* Restore the SCOPE_STMT_BLOCK.  */\n+  SCOPE_STMT_BLOCK (*tp) = block;\n+\n+  /* Remap the associated block.  */\n+  remap_block (*tp, NULL_TREE, id);\n+}\n \n /* Called from copy_body via walk_tree.  DATA is really an\n    `inline_data *'.  */\n@@ -85,7 +246,7 @@ copy_body_r (tp, walk_subtrees, data)\n \n   /* Set up.  */\n   id = (inline_data *) data;\n-  fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+  fn = VARRAY_TOP_TREE (id->fns);\n \n   /* All automatic variables should have a DECL_CONTEXT indicating\n      what function they come from.  */\n@@ -125,34 +286,22 @@ copy_body_r (tp, walk_subtrees, data)\n      function.  */\n   else if (nonstatic_local_decl_p (*tp) && DECL_CONTEXT (*tp) == fn)\n     {\n-      splay_tree_node n;\n-\n-      /* Look up the declaration.  */\n-      n = splay_tree_lookup (id->decl_map, (splay_tree_key) *tp);\n-\n-      /* If we didn't already have an equivalent for this declaration,\n-\t create one now.  */\n-      if (!n)\n-\t{\n-\t  tree t;\n-\n-\t  /* Make a copy of the variable or label.  */\n-\t  t = copy_decl_for_inlining (*tp, fn, \n-\t\t\t\t      VARRAY_TREE (id->fns, 0));\n-\t  /* Remember it, so that if we encounter this local entity\n-\t     again we can reuse this copy.  */\n-\t  n = splay_tree_insert (id->decl_map, \n-\t\t\t\t (splay_tree_key) *tp, \n-\t\t\t\t (splay_tree_value) t);\n-\t}\n+      tree new_decl;\n \n+      /* Remap the declaration.  */\n+      new_decl = remap_decl (*tp, id);\n+      my_friendly_assert (new_decl != NULL_TREE, 19991203);\n       /* Replace this variable with the copy.  */\n-      *tp = (tree) n->value;\n+      *tp = new_decl;\n     }\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n     remap_save_expr (tp, id->decl_map, VARRAY_TREE (id->fns, 0));\n   else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n     my_friendly_abort (19991113);\n+  /* For a SCOPE_STMT, we must copy the associated block so that we\n+     can write out debugging information for the inlined variables.  */\n+  else if (TREE_CODE (*tp) == SCOPE_STMT && !id->in_target_cleanup_p)\n+    copy_scope_stmt (tp, walk_subtrees, id);\n   /* Otherwise, just copy the node.  Note that copy_tree_r already\n      knows not to copy VAR_DECLs, etc., so this is safe.  */\n   else\n@@ -182,7 +331,7 @@ copy_body (id)\n {\n   tree body;\n \n-  body = DECL_SAVED_TREE (VARRAY_TREE (id->fns, id->fns_top - 1));\n+  body = DECL_SAVED_TREE (VARRAY_TOP_TREE (id->fns));\n   walk_tree (&body, copy_body_r, id);\n \n   return body;\n@@ -203,7 +352,7 @@ initialize_inlined_parameters (id, args)\n   tree p;\n \n   /* Figure out what the parameters are.  */\n-  fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+  fn = VARRAY_TOP_TREE (id->fns);\n   parms = DECL_ARGUMENTS (fn);\n \n   /* Start with no initializations whatsoever.  */\n@@ -256,7 +405,7 @@ declare_return_variable (id, use_stmt)\n      struct inline_data *id;\n      tree *use_stmt;\n {\n-  tree fn = VARRAY_TREE (id->fns, id->fns_top - 1);\n+  tree fn = VARRAY_TOP_TREE (id->fns);\n   tree result = DECL_RESULT (fn);\n   tree var;\n \n@@ -302,9 +451,12 @@ inlinable_function_p (fn, id)\n   /* Assume it is not inlinable.  */\n   inlinable = 0;\n \n+  /* If we're not inlining things, then nothing is inlinable.  */\n+  if (!flag_inline_trees)\n+    ;\n   /* If the function was not declared `inline', then we don't inline\n      it.  */\n-  if (!DECL_INLINE (fn))\n+  else if (!DECL_INLINE (fn))\n     ;\n   /* If we don't have the function body available, we can't inline\n      it.  */\n@@ -330,7 +482,7 @@ inlinable_function_p (fn, id)\n     {\n       size_t i;\n \n-      for (i = 0; i < id->fns_top; ++i)\n+      for (i = 0; i < id->fns->elements_used; ++i)\n \tif (VARRAY_TREE (id->fns, i) == fn)\n \t  inlinable = 0;\n     }\n@@ -362,11 +514,47 @@ expand_call_inline (tp, walk_subtrees, data)\n   tree expr;\n   tree chain;\n   tree fn;\n+  tree scope_stmt;\n   tree use_stmt;\n   splay_tree st;\n \n-  /* We're only interested in CALL_EXPRs.  */\n-  t = *tp;\n+  /* See what we've got.  */\n+  id = (inline_data *) data;\n+  t = *tp;  \n+\n+  /* Keep track of the last SCOPE_STMT we've seen.  */\n+  if (TREE_CODE (t) == SCOPE_STMT)\n+    {\n+      if (SCOPE_STMT_BLOCK (t) && !id->in_target_cleanup_p)\n+\tid->scope_stmt = t;\n+      return NULL_TREE;\n+    }\n+\n+  /* Recurse, but letting recursive invocations know that we are\n+     inside the body of a TARGET_EXPR.  */\n+  if (TREE_CODE (*tp) == TARGET_EXPR)\n+    {\n+      int i;\n+\n+      /* We're walking our own subtrees.  */\n+      *walk_subtrees = 0;\n+\n+      /* Actually walk over them.  This loop is the body of\n+\t walk_trees, omitting the case where the TARGET_EXPR\n+\t itself is handled.  */\n+      for (i = first_rtl_op (TARGET_EXPR) - 1; i >= 0; --i)\n+\t{\n+\t  if (i == 2)\n+\t    ++id->in_target_cleanup_p;\n+\t  walk_tree (&TREE_OPERAND (*tp, i), expand_call_inline, data);\n+\t  if (i == 2)\n+\t    --id->in_target_cleanup_p;\n+\t}\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* From here on, we're only interested in CALL_EXPRs.  */\n   if (TREE_CODE (t) != CALL_EXPR)\n     return NULL_TREE;\n \n@@ -378,7 +566,6 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Don't try to inline functions that are not well-suited to\n      inlining.  */\n-  id = (inline_data *) data;\n   if (!inlinable_function_p (fn, id))\n     return NULL_TREE;\n \n@@ -396,9 +583,7 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Record the function we are about to inline so that we can avoid\n      recursing into it.  */\n-  if (id->fns_top > id->fns->num_elements)\n-    VARRAY_GROW (id->fns, 2 * id->fns->num_elements);\n-  VARRAY_TREE (id->fns, id->fns_top++) = fn;\n+  VARRAY_PUSH_TREE (id->fns, fn);\n \n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n@@ -409,6 +594,17 @@ expand_call_inline (tp, walk_subtrees, data)\n   /* Initialize the parameters.  */\n   STMT_EXPR_STMT (expr) \n     = initialize_inlined_parameters (id, TREE_OPERAND (t, 1));\n+    \n+  /* Create a block to put the parameters in.  We have to do this\n+     after the parameters have been remapped because remapping\n+     parameters is different from remapping ordinary variables.  */\n+  scope_stmt = build_min_nt (SCOPE_STMT, DECL_INITIAL (fn));\n+  SCOPE_BEGIN_P (scope_stmt) = 1;\n+  SCOPE_NO_CLEANUPS_P (scope_stmt) = 1;\n+  remap_block (scope_stmt, DECL_ARGUMENTS (fn), id);\n+  TREE_CHAIN (scope_stmt) = STMT_EXPR_STMT (expr);\n+  STMT_EXPR_STMT (expr) = scope_stmt;\n+  id->scope_stmt = scope_stmt;\n \n   /* Declare the return variable for the function.  */\n   STMT_EXPR_STMT (expr)\n@@ -420,6 +616,16 @@ expand_call_inline (tp, walk_subtrees, data)\n   STMT_EXPR_STMT (expr)\n     = chainon (STMT_EXPR_STMT (expr), copy_body (id));\n \n+  /* Close the block for the parameters.  */\n+  scope_stmt = build_min_nt (SCOPE_STMT, DECL_INITIAL (fn));\n+  SCOPE_NO_CLEANUPS_P (scope_stmt) = 1;\n+  my_friendly_assert (DECL_INITIAL (fn) \n+\t\t      && TREE_CODE (DECL_INITIAL (fn)) == BLOCK,\n+\t\t      19991203);\n+  remap_block (scope_stmt, NULL_TREE, id);\n+  STMT_EXPR_STMT (expr)\n+    = chainon (STMT_EXPR_STMT (expr), scope_stmt);\n+\n   /* Finally, mention the returned value so that the value of the\n      statement-expression is the returned value of the function.  */\n   STMT_EXPR_STMT (expr) = chainon (STMT_EXPR_STMT (expr), use_stmt);\n@@ -447,7 +653,7 @@ expand_call_inline (tp, walk_subtrees, data)\n \n   /* Recurse into the body of the just inlined function.  */\n   expand_calls_inline (tp, id);\n-  --id->fns_top;\n+  VARRAY_POP (id->fns);\n \n   /* Don't walk into subtrees.  We've already handled them above.  */\n   *walk_subtrees = 0;\n@@ -479,14 +685,28 @@ optimize_function (fn)\n   if (flag_inline_trees)\n     {\n       inline_data id;\n+      tree prev_fn;\n+      struct saved_scope *s;\n \n       /* Clear out ID.  */\n       bzero (&id, sizeof (id));\n \n       /* Don't allow recursion into FN.  */\n       VARRAY_TREE_INIT (id.fns, 32, \"fns\");\n-      VARRAY_TREE (id.fns, id.fns_top++) = fn;\n-\n+      VARRAY_PUSH_TREE (id.fns, fn);\n+      /* Or any functions that aren't finished yet.  */\n+      prev_fn = NULL_TREE;\n+      if (current_function_decl)\n+\t{\n+\t  VARRAY_PUSH_TREE (id.fns, current_function_decl);\n+\t  prev_fn = current_function_decl;\n+\t}\n+      for (s = scope_chain; s; s = s->prev)\n+\tif (s->function_decl && s->function_decl != prev_fn)\n+\t  {\n+\t    VARRAY_PUSH_TREE (id.fns, s->function_decl);\n+\t    prev_fn = s->function_decl;\n+\t  }\n       /* Replace all calls to inline functions with the bodies of those\n \t functions.  */\n       expand_calls_inline (&DECL_SAVED_TREE (fn), &id);"}]}