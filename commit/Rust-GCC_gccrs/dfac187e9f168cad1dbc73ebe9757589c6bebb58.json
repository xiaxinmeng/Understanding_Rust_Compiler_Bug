{"sha": "dfac187e9f168cad1dbc73ebe9757589c6bebb58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhYzE4N2U5ZjE2OGNhZDFkYmM3M2ViZTk3NTc1ODljNmJlYmI1OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-10-22T22:02:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-10-22T22:02:17Z"}, "message": "Fix register elimination problem\n\nFrom-SVN: r30134", "tree": {"sha": "05a9402e85f3a88d76359f09b6da2679f852994e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05a9402e85f3a88d76359f09b6da2679f852994e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfac187e9f168cad1dbc73ebe9757589c6bebb58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfac187e9f168cad1dbc73ebe9757589c6bebb58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfac187e9f168cad1dbc73ebe9757589c6bebb58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfac187e9f168cad1dbc73ebe9757589c6bebb58/comments", "author": null, "committer": null, "parents": [{"sha": "b8c3c4f0146f82c900a995c8e98b83a2147115fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c3c4f0146f82c900a995c8e98b83a2147115fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c3c4f0146f82c900a995c8e98b83a2147115fd"}], "stats": {"total": 602, "additions": 382, "deletions": 220}, "files": [{"sha": "128dadc416a3e8c30b56cf84590f33a1cb3bb1f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfac187e9f168cad1dbc73ebe9757589c6bebb58", "patch": "@@ -1,3 +1,24 @@\n+Fri Oct 22 23:46:50 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* genoutput.c (struct operand_data): New elt eliminable.\n+\t(output_operand_data): Write it.\n+\t(scan_operands): Set it for MATCH_OPERAND, clear for other matchers.\n+\t(compare_operands): Take it into account.\n+\t* recog.h (struct insn_operand_data): New elt eliminable.\n+\t* reload1.c (check_eliminable_occurrences, elimination_effects): New\n+\tfunctions.\n+\t(old_asm_operands_vec, new_asm_operands_vec): Delete.\n+\t(eliminate_regs): Move code that detects changes to elimination\n+\ttarget regs into new function elimination_effects.\n+\tDelete one #if 0 block.\n+\tAbort for USE, CLOBBER, ASM_OPERANDS and SET. \n+\t(eliminate_regs_in_insn): Return immediately for USEs, CLOBBERs,\n+\tADDR_VECs, ADDR_DIFF_VECs and ASM_INPUTs.\n+\tOnly call eliminate_regs for real operands of the insn, not for parts\n+\tof its structure or parts matched by things like match_operator.\n+\tUse elimination_effects and check_eliminable_occurrences.  Use\n+\tcopy_insn to duplicate the pattern when not in the final pass.\n+\n Fri Oct 22 09:03:44 1999  Mark Mitchell  <mark@codesourcery.com>\n \n \t* i386.md: Add missing `y' modifiers to uses of fst, fstp, fld,"}, {"sha": "bc0ac4529b31265b0c08519f23bd1667974e59ab", "filename": "gcc/genoutput.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=dfac187e9f168cad1dbc73ebe9757589c6bebb58", "patch": "@@ -65,6 +65,10 @@ Boston, MA 02111-1307, USA.  */\n \n      e. `strict_low', is nonzero for operands contained in a STRICT_LOW_PART.\n \n+     f. `eliminable', is nonzero for operands that are matched normally by\n+     MATCH_OPERAND; it is zero for operands that should not be changed during\n+     register elimination such as MATCH_OPERATORs.\n+\n   The code number of an insn is simply its position in the machine\n   description; code numbers are assigned sequentially to entries in\n   the description, starting with code number 0.\n@@ -128,6 +132,7 @@ struct operand_data\n   unsigned char n_alternatives;\n   char address_p;\n   char strict_low;\n+  char eliminable;\n   char seen;\n };\n \n@@ -287,7 +292,9 @@ output_operand_data ()\n \n       printf (\"    %smode,\\n\", GET_MODE_NAME (d->mode));\n \n-      printf (\"    %d\\n\", d->strict_low);\n+      printf (\"    %d,\\n\", d->strict_low);\n+\n+      printf (\"    %d\\n\", d->eliminable);\n \n       printf(\"  },\\n\");\n     }\n@@ -436,6 +443,7 @@ scan_operands (d, part, this_address_p, this_strict_low)\n \td->operand[opno].n_alternatives\n \t  = n_occurrences (',', XSTR (part, 2)) + 1;\n       d->operand[opno].address_p = this_address_p;\n+      d->operand[opno].eliminable = 1;\n       return;\n \n     case MATCH_SCRATCH:\n@@ -460,6 +468,7 @@ scan_operands (d, part, this_address_p, this_strict_low)\n \td->operand[opno].n_alternatives\n \t  = n_occurrences (',', XSTR (part, 1)) + 1;\n       d->operand[opno].address_p = 0;\n+      d->operand[opno].eliminable = 0;\n       return;\n \n     case MATCH_OPERATOR:\n@@ -482,6 +491,7 @@ scan_operands (d, part, this_address_p, this_strict_low)\n       d->operand[opno].predicate = XSTR (part, 1);\n       d->operand[opno].constraint = 0;\n       d->operand[opno].address_p = 0;\n+      d->operand[opno].eliminable = 0;\n       for (i = 0; i < XVECLEN (part, 2); i++)\n \tscan_operands (d, XVECEXP (part, 2, i), 0, 0);\n       return;\n@@ -553,6 +563,9 @@ compare_operands (d0, d1)\n   if (d0->strict_low != d1->strict_low)\n     return 0;\n \n+  if (d0->eliminable != d1->eliminable)\n+    return 0;\n+\n   return 1;\n }\n "}, {"sha": "37c9c4f002dd0683b7761f5986c6b251a9a4ac37", "filename": "gcc/recog.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=dfac187e9f168cad1dbc73ebe9757589c6bebb58", "patch": "@@ -209,6 +209,8 @@ struct insn_operand_data\n   enum machine_mode mode;\n \n   char strict_low;\n+\n+  char eliminable;\n };\n \n /* Legal values for insn_data.output_format.  Indicate what type of data"}, {"sha": "cad122155640d03650ced96108dbf2cf40d6add8", "filename": "gcc/reload1.c", "status": "modified", "additions": 345, "deletions": 219, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfac187e9f168cad1dbc73ebe9757589c6bebb58/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=dfac187e9f168cad1dbc73ebe9757589c6bebb58", "patch": "@@ -394,6 +394,8 @@ static void maybe_mark_pseudo_spilled\tPROTO((int));\n static void delete_dead_insn\t\tPROTO((rtx));\n static void alter_reg  \t\t\tPROTO((int, int));\n static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n+static void check_eliminable_occurrences\tPROTO((rtx));\n+static void elimination_effects\t\tPROTO((rtx, enum machine_mode));\n static int eliminate_regs_in_insn\tPROTO((rtx, int));\n static void update_eliminable_offsets\tPROTO((void));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n@@ -2633,11 +2635,6 @@ set_label_offsets (x, insn, initial_p)\n     }\n }\n \f\n-/* Used for communication between the next two function to properly share\n-   the vector for an ASM_OPERANDS.  */\n-\n-static struct rtvec_def *old_asm_operands_vec, *new_asm_operands_vec;\n-\n /* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.\n \n@@ -2657,9 +2654,6 @@ static struct rtvec_def *old_asm_operands_vec, *new_asm_operands_vec;\n    This means, do not set ref_outside_mem even if the reference\n    is outside of MEMs.\n \n-   If we see a modification to a register we know about, take the\n-   appropriate action (see case SET, below).\n-\n    REG_EQUIV_MEM and REG_EQUIV_ADDRESS contain address that have had\n    replacements done assuming all offsets are at their initial values.  If\n    they are not, or if REG_EQUIV_ADDRESS is nonzero for a pseudo we\n@@ -2717,14 +2711,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n \t       ep++)\n \t    if (ep->from_rtx == x && ep->can_eliminate)\n-\t      {\n-\t\tif (! mem_mode\n-\t\t    /* Refs inside notes don't count for this purpose.  */\n-\t\t    && ! (insn != 0 && (GET_CODE (insn) == EXPR_LIST\n-\t\t\t\t\t|| GET_CODE (insn) == INSN_LIST)))\n-\t\t  ep->ref_outside_mem = 1;\n-\t\treturn plus_constant (ep->to_rtx, ep->previous_offset);\n-\t      }\n+\t      return plus_constant (ep->to_rtx, ep->previous_offset);\n \n \t}\n       else if (reg_renumber[regno] < 0 && reg_equiv_constant\n@@ -2759,12 +2746,6 @@ eliminate_regs (x, mem_mode, insn)\n \t       ep++)\n \t    if (ep->from_rtx == XEXP (x, 0) && ep->can_eliminate)\n \t      {\n-\t\tif (! mem_mode\n-\t\t    /* Refs inside notes don't count for this purpose.  */\n-\t\t    && ! (insn != 0 && (GET_CODE (insn) == EXPR_LIST\n-\t\t\t\t\t|| GET_CODE (insn) == INSN_LIST)))\n-\t\t  ep->ref_outside_mem = 1;\n-\n \t\t/* The only time we want to replace a PLUS with a REG (this\n \t\t   occurs when the constant operand of the PLUS is the negative\n \t\t   of the offset) is when we are inside a MEM.  We won't want\n@@ -2791,14 +2772,10 @@ eliminate_regs (x, mem_mode, insn)\n \t outermost PLUS.  We will do this by doing register replacement in\n \t our operands and seeing if a constant shows up in one of them.\n \n-\t We assume here this is part of an address (or a \"load address\" insn)\n-\t since an eliminable register is not likely to appear in any other\n-\t context.\n-\n-\t If we have (plus (eliminable) (reg)), we want to produce\n-\t (plus (plus (replacement) (reg) (const))).  If this was part of a\n-\t normal add insn, (plus (replacement) (reg)) will be pushed as a\n-\t reload.  This is the desired action.  */\n+\t Note that there is no risk of modifying the structure of the insn,\n+\t since we only get called for its operands, thus we are either\n+\t modifying the address inside a MEM, or something like an address\n+\t operand of a load-address insn.  */\n \n       {\n \trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n@@ -2920,23 +2897,6 @@ eliminate_regs (x, mem_mode, insn)\n     case POST_INC:\n     case PRE_DEC:\n     case POST_DEC:\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->to_rtx == XEXP (x, 0))\n-\t  {\n-\t    int size = GET_MODE_SIZE (mem_mode);\n-\n-\t    /* If more bytes than MEM_MODE are pushed, account for them.  */\n-#ifdef PUSH_ROUNDING\n-\t    if (ep->to_rtx == stack_pointer_rtx)\n-\t      size = PUSH_ROUNDING (size);\n-#endif\n-\t    if (code == PRE_DEC || code == POST_DEC)\n-\t      ep->offset += size;\n-\t    else\n-\t      ep->offset -= size;\n-\t  }\n-\n-      /* Fall through to generic unary operation case.  */\n     case STRICT_LOW_PART:\n     case NEG:          case NOT:\n     case SIGN_EXTEND:  case ZERO_EXTEND:\n@@ -2964,30 +2924,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  && reg_equiv_memory_loc != 0\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n-#if 0\n-\t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n-\t\t\t\tmem_mode, insn);\n-\n-\t  /* If we didn't change anything, we must retain the pseudo.  */\n-\t  if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))])\n-\t    new = SUBREG_REG (x);\n-\t  else\n-\t    {\n-\t      /* In this case, we must show that the pseudo is used in this\n-\t\t insn so that delete_output_reload will do the right thing.  */\n-\t      if (insn != 0 && GET_CODE (insn) != EXPR_LIST\n-\t\t  && GET_CODE (insn) != INSN_LIST)\n-\t\tREG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\t  SUBREG_REG (x)),\n-\t\t\t\t\t     insn))\n-\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);\n-\n-\t      /* Ensure NEW isn't shared in case we have to reload it.  */\n-\t      new = copy_rtx (new);\n-\t    }\n-#else\n \t  new = SUBREG_REG (x);\n-#endif\n \t}\n       else\n \tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n@@ -3031,133 +2968,6 @@ eliminate_regs (x, mem_mode, insn)\n \n       return x;\n \n-    case USE:\n-      /* If using a register that is the source of an eliminate we still\n-\t think can be performed, note it cannot be performed since we don't\n-\t know how this register is used.  */\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->from_rtx == XEXP (x, 0))\n-\t  ep->can_eliminate = 0;\n-\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n-      if (new != XEXP (x, 0))\n-\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n-      return x;\n-\n-    case CLOBBER:\n-      /* If clobbering a register that is the replacement register for an\n-\t elimination we still think can be performed, note that it cannot\n-\t be performed.  Otherwise, we need not be concerned about it.  */\n-      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n-\tif (ep->to_rtx == XEXP (x, 0))\n-\t  ep->can_eliminate = 0;\n-\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n-      if (new != XEXP (x, 0))\n-\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n-      return x;\n-\n-    case ASM_OPERANDS:\n-      {\n-\trtx *temp_vec;\n-\t/* Properly handle sharing input and constraint vectors.  */\n-\tif (ASM_OPERANDS_INPUT_VEC (x) != old_asm_operands_vec)\n-\t  {\n-\t    /* When we come to a new vector not seen before,\n-\t       scan all its elements; keep the old vector if none\n-\t       of them changes; otherwise, make a copy.  */\n-\t    old_asm_operands_vec = ASM_OPERANDS_INPUT_VEC (x);\n-\t    temp_vec = (rtx *) alloca (XVECLEN (x, 3) * sizeof (rtx));\n-\t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n-\t      temp_vec[i] = eliminate_regs (ASM_OPERANDS_INPUT (x, i),\n-\t\t\t\t\t    mem_mode, insn);\n-\n-\t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n-\t      if (temp_vec[i] != ASM_OPERANDS_INPUT (x, i))\n-\t\tbreak;\n-\n-\t    if (i == ASM_OPERANDS_INPUT_LENGTH (x))\n-\t      new_asm_operands_vec = old_asm_operands_vec;\n-\t    else\n-\t      new_asm_operands_vec\n-\t\t= gen_rtvec_v (ASM_OPERANDS_INPUT_LENGTH (x), temp_vec);\n-\t  }\n-\n-\t/* If we had to copy the vector, copy the entire ASM_OPERANDS.  */\n-\tif (new_asm_operands_vec == old_asm_operands_vec)\n-\t  return x;\n-\n-\tnew = gen_rtx_ASM_OPERANDS (VOIDmode, ASM_OPERANDS_TEMPLATE (x),\n-\t\t\t\t    ASM_OPERANDS_OUTPUT_CONSTRAINT (x),\n-\t\t\t\t    ASM_OPERANDS_OUTPUT_IDX (x),\n-\t\t\t\t    new_asm_operands_vec,\n-\t\t\t\t    ASM_OPERANDS_INPUT_CONSTRAINT_VEC (x),\n-\t\t\t\t    ASM_OPERANDS_SOURCE_FILE (x),\n-\t\t\t\t    ASM_OPERANDS_SOURCE_LINE (x));\n-\tnew->volatil = x->volatil;\n-\treturn new;\n-      }\n-\n-    case SET:\n-      /* Check for setting a register that we know about.  */\n-      if (GET_CODE (SET_DEST (x)) == REG)\n-\t{\n-\t  /* See if this is setting the replacement register for an\n-\t     elimination.\n-\n-\t     If DEST is the hard frame pointer, we do nothing because we\n-\t     assume that all assignments to the frame pointer are for\n-\t     non-local gotos and are being done at a time when they are valid\n-\t     and do not disturb anything else.  Some machines want to\n-\t     eliminate a fake argument pointer (or even a fake frame pointer)\n-\t     with either the real frame or the stack pointer.  Assignments to\n-\t     the hard frame pointer must not prevent this elimination.  */\n-\n-\t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n-\t       ep++)\n-\t    if (ep->to_rtx == SET_DEST (x)\n-\t\t&& SET_DEST (x) != hard_frame_pointer_rtx)\n-\t      {\n-\t\t/* If it is being incremented, adjust the offset.  Otherwise,\n-\t\t   this elimination can't be done.  */\n-\t\trtx src = SET_SRC (x);\n-\n-\t\tif (GET_CODE (src) == PLUS\n-\t\t    && XEXP (src, 0) == SET_DEST (x)\n-\t\t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t\t  ep->offset -= INTVAL (XEXP (src, 1));\n-\t\telse\n-\t\t  ep->can_eliminate = 0;\n-\t      }\n-\n-\t  /* Now check to see we are assigning to a register that can be\n-\t     eliminated.  If so, it must be as part of a PARALLEL, since we\n-\t     will not have been called if this is a single SET.  So indicate\n-\t     that we can no longer eliminate this reg.  */\n-\t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n-\t       ep++)\n-\t    if (ep->from_rtx == SET_DEST (x) && ep->can_eliminate)\n-\t      ep->can_eliminate = 0;\n-\t}\n-\n-      /* Now avoid the loop below in this common case.  */\n-      {\n-\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn);\n-\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn);\n-\n-\t/* If SET_DEST changed from a REG to a MEM and INSN is an insn,\n-\t   write a CLOBBER insn.  */\n-\tif (GET_CODE (SET_DEST (x)) == REG && GET_CODE (new0) == MEM\n-\t    && insn != 0 && GET_CODE (insn) != EXPR_LIST\n-\t    && GET_CODE (insn) != INSN_LIST)\n-\t  emit_insn_after (gen_rtx_CLOBBER (VOIDmode, SET_DEST (x)), insn);\n-\n-\tif (new0 != SET_DEST (x) || new1 != SET_SRC (x))\n-\t  return gen_rtx_SET (VOIDmode, new0, new1);\n-      }\n-\n-      return x;\n-\n     case MEM:\n       /* This is only for the benefit of the debugging backends, which call\n \t eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are\n@@ -3180,6 +2990,12 @@ eliminate_regs (x, mem_mode, insn)\n       else\n \treturn x;\n \n+    case USE:\n+    case CLOBBER:\n+    case ASM_OPERANDS:\n+    case SET:\n+      abort ();\n+\n     default:\n       break;\n     }\n@@ -3233,6 +3049,230 @@ eliminate_regs (x, mem_mode, insn)\n \n   return x;\n }\n+\n+/* Scan rtx X for modifications of elimination target registers.  Update\n+   the table of eliminables to reflect the changed state.  MEM_MODE is\n+   the mode of an enclosing MEM rtx, or VOIDmode if not within a MEM.  */\n+\n+static void\n+elimination_effects (x, mem_mode)\n+     rtx x;\n+     enum machine_mode mem_mode;\n+\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  struct elim_table *ep;\n+  int regno;\n+  int i, j;\n+  const char *fmt;\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+    case PC:\n+    case CC0:\n+    case ASM_INPUT:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+    case RETURN:\n+      return;\n+\n+    case ADDRESSOF:\n+      abort ();\n+\n+    case REG:\n+      regno = REGNO (x);\n+\n+      /* First handle the case where we encounter a bare register that\n+\t is eliminable.  Replace it with a PLUS.  */\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+\t       ep++)\n+\t    if (ep->from_rtx == x && ep->can_eliminate)\n+\t      {\n+\t\tif (! mem_mode)\n+\t\t  ep->ref_outside_mem = 1;\n+\t\treturn;\n+\t      }\n+\n+\t}\n+      else if (reg_renumber[regno] < 0 && reg_equiv_constant\n+\t       && reg_equiv_constant[regno]\n+\t       && ! CONSTANT_P (reg_equiv_constant[regno]))\n+\telimination_effects (reg_equiv_constant[regno], mem_mode);\n+      return;\n+\n+    case PRE_INC:\n+    case POST_INC:\n+    case PRE_DEC:\n+    case POST_DEC:\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->to_rtx == XEXP (x, 0))\n+\t  {\n+\t    int size = GET_MODE_SIZE (mem_mode);\n+\n+\t    /* If more bytes than MEM_MODE are pushed, account for them.  */\n+#ifdef PUSH_ROUNDING\n+\t    if (ep->to_rtx == stack_pointer_rtx)\n+\t      size = PUSH_ROUNDING (size);\n+#endif\n+\t    if (code == PRE_DEC || code == POST_DEC)\n+\t      ep->offset += size;\n+\t    else\n+\t      ep->offset -= size;\n+\t  }\n+\n+      /* Fall through to generic unary operation case.  */\n+    case STRICT_LOW_PART:\n+    case NEG:          case NOT:\n+    case SIGN_EXTEND:  case ZERO_EXTEND:\n+    case TRUNCATE:     case FLOAT_EXTEND: case FLOAT_TRUNCATE:\n+    case FLOAT:        case FIX:\n+    case UNSIGNED_FIX: case UNSIGNED_FLOAT:\n+    case ABS:\n+    case SQRT:\n+    case FFS:\n+      elimination_effects (XEXP (x, 0), mem_mode);\n+      return;\n+\n+    case SUBREG:\n+      if (GET_CODE (SUBREG_REG (x)) == REG\n+\t  && (GET_MODE_SIZE (GET_MODE (x))\n+\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t  && reg_equiv_memory_loc != 0\n+\t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n+\treturn;\n+\n+      elimination_effects (SUBREG_REG (x), mem_mode);\n+      return;\n+\n+    case USE:\n+      /* If using a register that is the source of an eliminate we still\n+\t think can be performed, note it cannot be performed since we don't\n+\t know how this register is used.  */\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == XEXP (x, 0))\n+\t  ep->can_eliminate = 0;\n+\n+      elimination_effects (XEXP (x, 0), mem_mode);\n+      return;\n+\n+    case CLOBBER:\n+      /* If clobbering a register that is the replacement register for an\n+\t elimination we still think can be performed, note that it cannot\n+\t be performed.  Otherwise, we need not be concerned about it.  */\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->to_rtx == XEXP (x, 0))\n+\t  ep->can_eliminate = 0;\n+\n+      elimination_effects (XEXP (x, 0), mem_mode);\n+      return;\n+\n+    case SET:\n+      /* Check for setting a register that we know about.  */\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  /* See if this is setting the replacement register for an\n+\t     elimination.\n+\n+\t     If DEST is the hard frame pointer, we do nothing because we\n+\t     assume that all assignments to the frame pointer are for\n+\t     non-local gotos and are being done at a time when they are valid\n+\t     and do not disturb anything else.  Some machines want to\n+\t     eliminate a fake argument pointer (or even a fake frame pointer)\n+\t     with either the real frame or the stack pointer.  Assignments to\n+\t     the hard frame pointer must not prevent this elimination.  */\n+\n+\t  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+\t       ep++)\n+\t    if (ep->to_rtx == SET_DEST (x)\n+\t\t&& SET_DEST (x) != hard_frame_pointer_rtx)\n+\t      {\n+\t\t/* If it is being incremented, adjust the offset.  Otherwise,\n+\t\t   this elimination can't be done.  */\n+\t\trtx src = SET_SRC (x);\n+\n+\t\tif (GET_CODE (src) == PLUS\n+\t\t    && XEXP (src, 0) == SET_DEST (x)\n+\t\t    && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t\t  ep->offset -= INTVAL (XEXP (src, 1));\n+\t\telse\n+\t\t  ep->can_eliminate = 0;\n+\t      }\n+\t}\n+\n+      elimination_effects (SET_DEST (x), 0);\n+      elimination_effects (SET_SRC (x), 0);\n+      return;\n+\n+    case MEM:\n+      if (GET_CODE (XEXP (x, 0)) == ADDRESSOF)\n+\tabort ();\n+\n+      /* Our only special processing is to pass the mode of the MEM to our\n+\t recursive call.  */\n+      elimination_effects (XEXP (x, 0), GET_MODE (x));\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n+    {\n+      if (*fmt == 'e')\n+\telimination_effects (XEXP (x, i), mem_mode);\n+      else if (*fmt == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  elimination_effects (XVECEXP (x, i, j), mem_mode);\n+    }\n+}\n+\n+/* Descend through rtx X and verify that no references to eliminable registers\n+   remain.  If any do remain, mark the involved register as not\n+   eliminable.  */\n+static void\n+check_eliminable_occurrences (x)\n+     rtx x;\n+{\n+  const char *fmt;\n+  int i;\n+  enum rtx_code code;\n+\n+  if (x == 0)\n+    return;\n+  \n+  code = GET_CODE (x);\n+\n+  if (code == REG && REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    {\n+      struct elim_table *ep;\n+\n+      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+\tif (ep->from_rtx == x && ep->can_eliminate)\n+\t  ep->can_eliminate = 0;\n+      return;\n+    }\n+  \n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n+    {\n+      if (*fmt == 'e')\n+\tcheck_eliminable_occurrences (XEXP (x, i));\n+      else if (*fmt == 'E')\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    check_eliminable_occurrences (XVECEXP (x, i, j));\n+\t}\n+    }\n+}\n \f\n /* Scan INSN and eliminate all eliminable registers in it.\n \n@@ -3252,12 +3292,28 @@ eliminate_regs_in_insn (insn, replace)\n      rtx insn;\n      int replace;\n {\n+  int icode = recog_memoized (insn);\n   rtx old_body = PATTERN (insn);\n+  int insn_is_asm = asm_noperands (old_body) >= 0;\n   rtx old_set = single_set (insn);\n   rtx new_body;\n   int val = 0;\n+  int i, any_changes;\n+  rtx substed_operand[MAX_RECOG_OPERANDS];\n+  rtx orig_operand[MAX_RECOG_OPERANDS];\n   struct elim_table *ep;\n \n+  if (! insn_is_asm && icode < 0)\n+    {\n+      if (GET_CODE (PATTERN (insn)) == USE\n+\t  || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT)\n+\treturn 0;\n+      abort ();\n+    }\n+\n   if (! replace)\n     push_obstacks (&reload_obstack, &reload_obstack);\n \n@@ -3385,35 +3441,97 @@ eliminate_regs_in_insn (insn, replace)\n \t    }\n     }\n \n-  old_asm_operands_vec = 0;\n+  /* Determine the effects of this insn on elimination offsets.  */\n+  elimination_effects (old_body, 0);\n \n-  /* Replace the body of this insn with a substituted form.  If we changed\n-     something, return non-zero.\n+  /* Eliminate all eliminable registers occurring in operands that\n+     can be handled by reload.  */\n+  extract_insn (insn);\n+  any_changes = 0;\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      orig_operand[i] = recog_data.operand[i];\n+      substed_operand[i] = recog_data.operand[i];\n \n-     If we are replacing a body that was a (set X (plus Y Z)), try to\n+      /* For an asm statement, every operand is eliminable.  */\n+      if (insn_is_asm || insn_data[icode].operand[i].eliminable)\n+\t{\n+\t  /* Check for setting a register that we know about.  */\n+\t  if (recog_data.operand_type[i] != OP_IN\n+\t      && GET_CODE (orig_operand[i]) == REG)\n+\t    {\n+\t      /* If we are assigning to a register that can be eliminated, it\n+\t\t must be as part of a PARALLEL, since the code above handles\n+\t\t single SETs.  We must indicate that we can no longer\n+\t\t eliminate this reg.  */\n+\t      for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+\t\t   ep++)\n+\t\tif (ep->from_rtx == orig_operand[i] && ep->can_eliminate)\n+\t\t  ep->can_eliminate = 0;\n+\t    }\n+\n+\t  substed_operand[i] = eliminate_regs (recog_data.operand[i], 0,\n+\t\t\t\t\t       replace ? insn : NULL_RTX);\n+\t  if (substed_operand[i] != orig_operand[i])\n+\t    val = any_changes = 1;\n+\t  /* Terminate the search in check_eliminable_occurrences at\n+\t     this point.  */\n+\t  *recog_data.operand_loc[i] = 0;\n+\n+\t/* If an output operand changed from a REG to a MEM and INSN is an\n+\t   insn, write a CLOBBER insn.  */\n+\t  if (recog_data.operand_type[i] != OP_IN\n+\t      && GET_CODE (orig_operand[i]) == REG\n+\t      && GET_CODE (substed_operand[i]) == MEM\n+\t      && replace)\n+\t    emit_insn_after (gen_rtx_CLOBBER (VOIDmode, orig_operand[i]),\n+\t\t\t     insn);\n+\t}\n+    }\n+\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    *recog_data.dup_loc[i]\n+\t= *recog_data.operand_loc[(int)recog_data.dup_num[i]];\n+\n+  /* If any eliminable remain, they aren't eliminable anymore.  */\n+  check_eliminable_occurrences (old_body);\n+\n+  /* Substitute the operands; the new values are in the substed_operand\n+     array.  */\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    *recog_data.operand_loc[i] = substed_operand[i];\n+  for (i = 0; i < recog_data.n_dups; i++)\n+    *recog_data.dup_loc[i] = substed_operand[(int)recog_data.dup_num[i]];\n+\n+  /* If we are replacing a body that was a (set X (plus Y Z)), try to\n      re-recognize the insn.  We do this in case we had a simple addition\n      but now can do this as a load-address.  This saves an insn in this\n-     common case.  */\n+     common case.\n+     If re-recognition fails, the old insn code number will still be used,\n+     and some register operands may have changed into PLUS expressions.\n+     These will be handled by find_reloads by loading them into a register\n+     again.*/\n \n-  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n-  if (new_body != old_body)\n+  if (val)\n     {\n       /* If we aren't replacing things permanently and we changed something,\n \t make another copy to ensure that all the RTL is new.  Otherwise\n \t things can go wrong if find_reload swaps commutative operands\n \t and one is inside RTL that has been copied while the other is not.  */\n-\n-      /* Don't copy an asm_operands because (1) there's no need and (2)\n-\t copy_rtx can't do it properly when there are multiple outputs.  */\n-      if (! replace && asm_noperands (old_body) < 0)\n-\tnew_body = copy_rtx (new_body);\n+      new_body = old_body;\n+      if (! replace)\n+\tnew_body = copy_insn (old_body);\n+      PATTERN (insn) = new_body;\n \n       /* If we had a move insn but now we don't, rerecognize it.  This will\n \t cause spurious re-recognition if the old move had a PARALLEL since\n \t the new one still will, but we can't call single_set without\n \t having put NEW_BODY into the insn and the re-recognition won't\n \t hurt in this rare case.  */\n-      if (old_set != 0\n+      /* ??? Why this huge if statement - why don't we just rerecognize the\n+\t thing always?  */\n+      if (! insn_is_asm\n+\t  && old_set != 0\n \t  && ((GET_CODE (SET_SRC (old_set)) == REG\n \t       && (GET_CODE (new_body) != SET\n \t\t   || GET_CODE (SET_SRC (new_body)) != REG))\n@@ -3428,19 +3546,27 @@ eliminate_regs_in_insn (insn, replace)\n \t      /* If this was an add insn before, rerecognize.  */\n \t      || GET_CODE (SET_SRC (old_set)) == PLUS))\n \t{\n-\t  if (! validate_change (insn, &PATTERN (insn), new_body, 0))\n-\t    /* If recognition fails, store the new body anyway.\n-\t       It's normal to have recognition failures here\n-\t       due to bizarre memory addresses; reloading will fix them.  */\n-\t    PATTERN (insn) = new_body;\n+\t  int new_icode = recog (PATTERN (insn), insn, 0);\n+\t  if (new_icode < 0)\n+\t    INSN_CODE (insn) = icode;\n \t}\n-      else\n-\tPATTERN (insn) = new_body;\n+    }\n \n-      val = 1;\n+  /* Restore the old body.  If there were any changes to it, we made a copy\n+     of it while the changes were still in place, so we'll correctly return\n+     a modified insn below.  */\n+  if (! replace)\n+    {\n+      /* Restore the old body.  */\n+      for (i = 0; i < recog_data.n_operands; i++)\n+\t*recog_data.operand_loc[i] = orig_operand[i];\n+      for (i = 0; i < recog_data.n_dups; i++)\n+\t*recog_data.dup_loc[i] = orig_operand[(int)recog_data.dup_num[i]];\n     }\n \n-  /* Loop through all elimination pairs.  See if any have changed.\n+  /* Update all elimination pairs to reflect the status after the current\n+     insn.  The changes we make were determined by the earlier call to\n+     elimination_effects.\n \n      We also detect a cases where register elimination cannot be done,\n      namely, if a register would be both changed and referenced outside a MEM"}]}