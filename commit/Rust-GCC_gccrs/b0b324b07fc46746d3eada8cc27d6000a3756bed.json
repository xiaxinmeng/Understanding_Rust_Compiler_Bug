{"sha": "b0b324b07fc46746d3eada8cc27d6000a3756bed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBiMzI0YjA3ZmM0Njc0NmQzZWFkYThjYzI3ZDYwMDBhMzc1NmJlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-28T22:55:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-09-28T22:55:04Z"}, "message": "re PR tree-optimization/17531 ([ivopts] ICE compiling gzip deflate.c)\n\n        PR 17531\n        * expr.c (expand_expr_addr_expr_1): Only assemble_external for decls.\n        Don't check VOIDmode here.  Force PLUS operands to common type.\n        (expand_expr_addr_expr): Do VOIDmode check earlier.  Force use of\n        Pmode if given a non pointer type.\n\n        PR 17531\n        * optabs.c (expand_binop): Force constants to the correct mode.\n\nFrom-SVN: r88257", "tree": {"sha": "657a3287fd0f4515ef8192966bb543603c33c6ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/657a3287fd0f4515ef8192966bb543603c33c6ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0b324b07fc46746d3eada8cc27d6000a3756bed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0b324b07fc46746d3eada8cc27d6000a3756bed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0b324b07fc46746d3eada8cc27d6000a3756bed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0b324b07fc46746d3eada8cc27d6000a3756bed/comments", "author": null, "committer": null, "parents": [{"sha": "078208ebefcad46f0fd8e0c559d8c6b411ee4726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/078208ebefcad46f0fd8e0c559d8c6b411ee4726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/078208ebefcad46f0fd8e0c559d8c6b411ee4726"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "69229c2d13c7c2a55d0f67d1570af477673c6b14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0b324b07fc46746d3eada8cc27d6000a3756bed", "patch": "@@ -1,3 +1,16 @@\n+2004-09-28  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 17531\n+\t* expr.c (expand_expr_addr_expr_1): Only assemble_external for decls.\n+\tDon't check VOIDmode here.  Force PLUS operands to common type.\n+\t(expand_expr_addr_expr): Do VOIDmode check earlier.  Force use of\n+\tPmode if given a non pointer type.\n+\n+2004-09-28  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\tPR 17531\n+\t* optabs.c (expand_binop): Force constants to the correct mode.\n+\n 2004-09-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_adjust_cost): Remove."}, {"sha": "5db2c2800381b8becc50018587697dba8714bf15", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b0b324b07fc46746d3eada8cc27d6000a3756bed", "patch": "@@ -6088,7 +6088,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n     case CONST_DECL:\n       /* Recurse and make the output_constant_def clause above handle this.  */\n       return expand_expr_addr_expr_1 (DECL_INITIAL (exp), target,\n-\t\t\t\t    tmode, modifier);\n+\t\t\t\t      tmode, modifier);\n \n     case REALPART_EXPR:\n       /* The real part of the complex number is always first, therefore\n@@ -6126,7 +6126,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  result = XEXP (result, 0);\n \n \t  /* ??? Is this needed anymore?  */\n-\t  if (!TREE_USED (exp) == 0)\n+\t  if (DECL_P (exp) && !TREE_USED (exp) == 0)\n \t    {\n \t      assemble_external (exp);\n \t      TREE_USED (exp) = 1;\n@@ -6149,13 +6149,6 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n   subtarget = offset || bitpos ? NULL_RTX : target;\n   result = expand_expr_addr_expr_1 (inner, subtarget, tmode, modifier);\n \n-  if (tmode == VOIDmode)\n-    {\n-      tmode = GET_MODE (result);\n-      if (tmode == VOIDmode)\n-\ttmode = Pmode;\n-    }\n-\n   if (offset)\n     {\n       rtx tmp;\n@@ -6164,6 +6157,9 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n \tresult = force_operand (result, NULL);\n       tmp = expand_expr (offset, NULL, tmode, EXPAND_NORMAL);\n \n+      result = convert_memory_address (tmode, result);\n+      tmp = convert_memory_address (tmode, tmp);\n+\n       if (modifier == EXPAND_SUM)\n \tresult = gen_rtx_PLUS (tmode, result, tmp);\n       else\n@@ -6178,7 +6174,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n     {\n       /* Someone beforehand should have rejected taking the address\n \t of such an object.  */\n-      gcc_assert (!(bitpos % BITS_PER_UNIT));\n+      gcc_assert ((bitpos % BITS_PER_UNIT) == 0);\n \n       result = plus_constant (result, bitpos / BITS_PER_UNIT);\n       if (modifier < EXPAND_SUM)\n@@ -6198,19 +6194,28 @@ expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,\n   enum machine_mode rmode;\n   rtx result;\n \n+  /* Target mode of VOIDmode says \"whatever's natural\".  */\n+  if (tmode == VOIDmode)\n+    tmode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* We can get called with some Weird Things if the user does silliness\n+     like \"(short) &a\".  In that case, convert_memory_address won't do\n+     the right thing, so ignore the given target mode.  */\n+  if (!targetm.valid_pointer_mode (tmode))\n+    tmode = Pmode;\n+\n   result = expand_expr_addr_expr_1 (TREE_OPERAND (exp, 0), target,\n \t\t\t\t    tmode, modifier);\n \n   /* Despite expand_expr claims concerning ignoring TMODE when not\n-     strictly convenient, stuff breaks if we don't honor it.  */\n-  if (tmode == VOIDmode)\n-    tmode = TYPE_MODE (TREE_TYPE (exp));\n+     strictly convenient, stuff breaks if we don't honor it.  Note\n+     that combined with the above, we only do this for pointer modes.  */\n   rmode = GET_MODE (result);\n   if (rmode == VOIDmode)\n     rmode = tmode;\n   if (rmode != tmode)\n     result = convert_memory_address (tmode, result);\n- \n+\n   return result;\n }\n "}, {"sha": "cc0627b1240b4f284bfef45c6f3680cf3167df9f", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0b324b07fc46746d3eada8cc27d6000a3756bed/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b0b324b07fc46746d3eada8cc27d6000a3756bed", "patch": "@@ -834,11 +834,19 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      force expensive constants into a register.  */\n   if (CONSTANT_P (op0) && optimize\n       && rtx_cost (op0, binoptab->code) > COSTS_N_INSNS (1))\n-    op0 = force_reg (mode, op0);\n+    {\n+      if (GET_MODE (op0) != VOIDmode)\n+\top0 = convert_modes (mode, VOIDmode, op0, unsignedp);\n+      op0 = force_reg (mode, op0);\n+    }\n \n   if (CONSTANT_P (op1) && optimize\n       && ! shift_op && rtx_cost (op1, binoptab->code) > COSTS_N_INSNS (1))\n-    op1 = force_reg (mode, op1);\n+    {\n+      if (GET_MODE (op1) != VOIDmode)\n+\top1 = convert_modes (mode, VOIDmode, op1, unsignedp);\n+      op1 = force_reg (mode, op1);\n+    }\n \n   /* Record where to delete back to if we backtrack.  */\n   last = get_last_insn ();"}]}