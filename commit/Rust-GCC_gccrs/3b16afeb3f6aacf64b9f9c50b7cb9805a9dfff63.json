{"sha": "3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "node_id": "C_kwDOANBUbNoAKDNiMTZhZmViM2Y2YWFjZjY0YjlmOWM1MGI3Y2I5ODA1YTlkZmZmNjM", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2022-11-28T14:14:06Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-12-01T16:13:45Z"}, "message": "RISC-V: Add attributes for VSETVL PASS\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-protos.h (enum vlmul_type): New enum.\n\t(get_vlmul): New function.\n\t(get_ratio): Ditto.\n\t* config/riscv/riscv-v.cc (struct mode_vtype_group): New struct.\n\t(ENTRY): Adapt for attributes.\n\t(enum vlmul_type): New enum.\n\t(get_vlmul): New function.\n\t(get_ratio): New function.\n\t* config/riscv/riscv-vector-switch.def (ENTRY): Adapt for attributes.\n\t* config/riscv/riscv.cc (ENTRY): Ditto.\n\t* config/riscv/vector.md (false,true): Add attributes.", "tree": {"sha": "a851cff4c65fa0a404dc17a9167b9f98fa7adf94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a851cff4c65fa0a404dc17a9167b9f98fa7adf94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa144175c9ccaa10d7021d00f97aaa9eac59afec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa144175c9ccaa10d7021d00f97aaa9eac59afec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa144175c9ccaa10d7021d00f97aaa9eac59afec"}], "stats": {"total": 338, "additions": 290, "deletions": 48}, "files": [{"sha": "e17e003f8e2b7dc90ae146f3a29315f5e6c260a5", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "patch": "@@ -120,6 +120,17 @@ extern void riscv_run_selftests (void);\n \n namespace riscv_vector {\n #define RVV_VLMAX gen_rtx_REG (Pmode, X0_REGNUM)\n+enum vlmul_type\n+{\n+  LMUL_1 = 0,\n+  LMUL_2 = 1,\n+  LMUL_4 = 2,\n+  LMUL_8 = 3,\n+  LMUL_RESERVED = 4,\n+  LMUL_F8 = 5,\n+  LMUL_F4 = 6,\n+  LMUL_F2 = 7,\n+};\n /* Routines implemented in riscv-vector-builtins.cc.  */\n extern void init_builtins (void);\n extern const char *mangle_builtin_type (const_tree);\n@@ -132,6 +143,8 @@ extern rtx expand_builtin (unsigned int, tree, rtx);\n extern bool const_vec_all_same_in_range_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n extern bool legitimize_move (rtx, rtx, machine_mode);\n extern void emit_pred_op (unsigned, rtx, rtx, machine_mode);\n+extern enum vlmul_type get_vlmul (machine_mode);\n+extern unsigned int get_ratio (machine_mode);\n enum tail_policy\n {\n   TAIL_UNDISTURBED = 0,"}, {"sha": "d54795694f1a03d4ff1e61a2b190b3671e121e7e", "filename": "gcc/config/riscv/riscv-v.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "patch": "@@ -214,4 +214,45 @@ legitimize_move (rtx dest, rtx src, machine_mode mask_mode)\n   return true;\n }\n \n+/* VTYPE information for machine_mode.  */\n+struct mode_vtype_group\n+{\n+  enum vlmul_type vlmul_for_min_vlen32[NUM_MACHINE_MODES];\n+  uint8_t ratio_for_min_vlen32[NUM_MACHINE_MODES];\n+  enum vlmul_type vlmul_for_min_vlen64[NUM_MACHINE_MODES];\n+  uint8_t ratio_for_min_vlen64[NUM_MACHINE_MODES];\n+  mode_vtype_group ()\n+  {\n+#define ENTRY(MODE, REQUIREMENT, VLMUL_FOR_MIN_VLEN32, RATIO_FOR_MIN_VLEN32,   \\\n+\t      VLMUL_FOR_MIN_VLEN64, RATIO_FOR_MIN_VLEN64)                      \\\n+  vlmul_for_min_vlen32[MODE##mode] = VLMUL_FOR_MIN_VLEN32;                     \\\n+  ratio_for_min_vlen32[MODE##mode] = RATIO_FOR_MIN_VLEN32;                     \\\n+  vlmul_for_min_vlen64[MODE##mode] = VLMUL_FOR_MIN_VLEN64;                     \\\n+  ratio_for_min_vlen64[MODE##mode] = RATIO_FOR_MIN_VLEN64;\n+#include \"riscv-vector-switch.def\"\n+  }\n+};\n+\n+static mode_vtype_group mode_vtype_infos;\n+\n+/* Get vlmul field value by comparing LMUL with BYTES_PER_RISCV_VECTOR.  */\n+enum vlmul_type\n+get_vlmul (machine_mode mode)\n+{\n+  if (TARGET_MIN_VLEN == 32)\n+    return mode_vtype_infos.vlmul_for_min_vlen32[mode];\n+  else\n+    return mode_vtype_infos.vlmul_for_min_vlen64[mode];\n+}\n+\n+/* Get ratio according to machine mode.  */\n+unsigned int\n+get_ratio (machine_mode mode)\n+{\n+  if (TARGET_MIN_VLEN == 32)\n+    return mode_vtype_infos.ratio_for_min_vlen32[mode];\n+  else\n+    return mode_vtype_infos.ratio_for_min_vlen64[mode];\n+}\n+\n } // namespace riscv_vector"}, {"sha": "a51f45be4875971599d233237960c67ef82f3964", "filename": "gcc/config/riscv/riscv-vector-switch.def", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-switch.def?ref=3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "patch": "@@ -80,7 +80,8 @@ TODO: FP16 vector needs support of 'zvfh', we don't support it yet.  */\n /* Return 'REQUIREMENT' for machine_mode 'MODE'.\n    For example: 'MODE' = VNx64BImode needs TARGET_MIN_VLEN > 32.  */\n #ifndef ENTRY\n-#define ENTRY(MODE, REQUIREMENT)\n+#define ENTRY(MODE, REQUIREMENT, VLMUL_FOR_MIN_VLEN32, RATIO_FOR_MIN_VLEN32,   \\\n+\t      VLMUL_FOR_MIN_VLEN64, RATIO_FOR_MIN_VLEN64)\n #endif\n /* Flag of FP32 vector.  */\n #ifndef TARGET_VECTOR_FP32\n@@ -94,66 +95,68 @@ TODO: FP16 vector needs support of 'zvfh', we don't support it yet.  */\n #endif\n \n /* Mask modes. Disable VNx64BImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx64BI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx32BI, true)\n-ENTRY (VNx16BI, true)\n-ENTRY (VNx8BI, true)\n-ENTRY (VNx4BI, true)\n-ENTRY (VNx2BI, true)\n-ENTRY (VNx1BI, true)\n+ENTRY (VNx64BI, TARGET_MIN_VLEN > 32, LMUL_F8, 64, LMUL_RESERVED, 0)\n+ENTRY (VNx32BI, true, LMUL_F4, 32, LMUL_RESERVED, 0)\n+ENTRY (VNx16BI, true, LMUL_F2, 16, LMUL_RESERVED, 0)\n+ENTRY (VNx8BI, true, LMUL_1, 8, LMUL_RESERVED, 0)\n+ENTRY (VNx4BI, true, LMUL_2, 4, LMUL_RESERVED, 0)\n+ENTRY (VNx2BI, true, LMUL_4, 2, LMUL_RESERVED, 0)\n+ENTRY (VNx1BI, true, LMUL_8, 1, LMUL_RESERVED, 0)\n \n /* SEW = 8. Disable VNx64QImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx64QI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx32QI, true)\n-ENTRY (VNx16QI, true)\n-ENTRY (VNx8QI, true)\n-ENTRY (VNx4QI, true)\n-ENTRY (VNx2QI, true)\n-ENTRY (VNx1QI, true)\n+ENTRY (VNx64QI, TARGET_MIN_VLEN > 32, LMUL_8, 1, LMUL_RESERVED, 0)\n+ENTRY (VNx32QI, true, LMUL_8, 1, LMUL_4, 2)\n+ENTRY (VNx16QI, true, LMUL_4, 2, LMUL_2, 4)\n+ENTRY (VNx8QI, true, LMUL_2, 4, LMUL_1, 8)\n+ENTRY (VNx4QI, true, LMUL_1, 8, LMUL_F2, 16)\n+ENTRY (VNx2QI, true, LMUL_F2, 16, LMUL_F4, 32)\n+ENTRY (VNx1QI, true, LMUL_F4, 32, LMUL_F8, 64)\n \n /* SEW = 16. Disable VNx32HImode when TARGET_MIN_VLEN == 32.  */\n-ENTRY (VNx32HI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx16HI, true)\n-ENTRY (VNx8HI, true)\n-ENTRY (VNx4HI, true)\n-ENTRY (VNx2HI, true)\n-ENTRY (VNx1HI, true)\n+ENTRY (VNx32HI, TARGET_MIN_VLEN > 32, LMUL_8, 2, LMUL_RESERVED, 0)\n+ENTRY (VNx16HI, true, LMUL_8, 2, LMUL_4, 4)\n+ENTRY (VNx8HI, true, LMUL_4, 4, LMUL_2, 8)\n+ENTRY (VNx4HI, true, LMUL_2, 8, LMUL_1, 16)\n+ENTRY (VNx2HI, true, LMUL_1, 16, LMUL_F2, 32)\n+ENTRY (VNx1HI, true, LMUL_F2, 32, LMUL_F4, 64)\n \n /* TODO:Disable all FP16 vector, enable them when 'zvfh' is supported.  */\n-ENTRY (VNx32HF, false)\n-ENTRY (VNx16HF, false)\n-ENTRY (VNx8HF, false)\n-ENTRY (VNx4HF, false)\n-ENTRY (VNx2HF, false)\n-ENTRY (VNx1HF, false)\n+ENTRY (VNx32HF, false, LMUL_8, 2, LMUL_RESERVED, 0)\n+ENTRY (VNx16HF, false, LMUL_8, 2, LMUL_4, 4)\n+ENTRY (VNx8HF, false, LMUL_4, 4, LMUL_2, 8)\n+ENTRY (VNx4HF, false, LMUL_2, 8, LMUL_1, 16)\n+ENTRY (VNx2HF, false, LMUL_1, 16, LMUL_F2, 32)\n+ENTRY (VNx1HF, false, LMUL_F2, 32, LMUL_F4, 64)\n \n /* SEW = 32. Disable VNx16SImode when TARGET_MIN_VLEN == 32.\n    For single-precision floating-point, we need TARGET_VECTOR_FP32 ==\n    RVV_ENABLE.  */\n-ENTRY (VNx16SI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx8SI, true)\n-ENTRY (VNx4SI, true)\n-ENTRY (VNx2SI, true)\n-ENTRY (VNx1SI, true)\n-\n-ENTRY (VNx16SF, TARGET_VECTOR_FP32 && (TARGET_MIN_VLEN > 32))\n-ENTRY (VNx8SF, TARGET_VECTOR_FP32)\n-ENTRY (VNx4SF, TARGET_VECTOR_FP32)\n-ENTRY (VNx2SF, TARGET_VECTOR_FP32)\n-ENTRY (VNx1SF, TARGET_VECTOR_FP32)\n+ENTRY (VNx16SI, TARGET_MIN_VLEN > 32, LMUL_8, 4, LMUL_RESERVED, 0)\n+ENTRY (VNx8SI, true, LMUL_8, 4, LMUL_4, 8)\n+ENTRY (VNx4SI, true, LMUL_4, 8, LMUL_2, 4)\n+ENTRY (VNx2SI, true, LMUL_2, 16, LMUL_1, 2)\n+ENTRY (VNx1SI, true, LMUL_1, 32, LMUL_F2, 1)\n+\n+ENTRY (VNx16SF, TARGET_VECTOR_FP32 && (TARGET_MIN_VLEN > 32), LMUL_8, 4,\n+       LMUL_RESERVED, 0)\n+ENTRY (VNx8SF, TARGET_VECTOR_FP32, LMUL_8, 4, LMUL_4, 8)\n+ENTRY (VNx4SF, TARGET_VECTOR_FP32, LMUL_4, 8, LMUL_2, 4)\n+ENTRY (VNx2SF, TARGET_VECTOR_FP32, LMUL_2, 16, LMUL_1, 2)\n+ENTRY (VNx1SF, TARGET_VECTOR_FP32, LMUL_1, 32, LMUL_F2, 1)\n \n /* SEW = 64. Enable when TARGET_MIN_VLEN > 32.\n    For double-precision floating-point, we need TARGET_VECTOR_FP64 ==\n    RVV_ENABLE.  */\n-ENTRY (VNx8DI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx4DI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx2DI, TARGET_MIN_VLEN > 32)\n-ENTRY (VNx1DI, TARGET_MIN_VLEN > 32)\n-\n-ENTRY (VNx8DF, TARGET_VECTOR_FP64 && (TARGET_MIN_VLEN > 32))\n-ENTRY (VNx4DF, TARGET_VECTOR_FP64)\n-ENTRY (VNx2DF, TARGET_VECTOR_FP64)\n-ENTRY (VNx1DF, TARGET_VECTOR_FP64)\n+ENTRY (VNx8DI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_8, 8)\n+ENTRY (VNx4DI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_4, 16)\n+ENTRY (VNx2DI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_2, 32)\n+ENTRY (VNx1DI, TARGET_MIN_VLEN > 32, LMUL_RESERVED, 0, LMUL_1, 64)\n+\n+ENTRY (VNx8DF, TARGET_VECTOR_FP64 && (TARGET_MIN_VLEN > 32), LMUL_RESERVED, 0,\n+       LMUL_8, 8)\n+ENTRY (VNx4DF, TARGET_VECTOR_FP64, LMUL_RESERVED, 0, LMUL_4, 16)\n+ENTRY (VNx2DF, TARGET_VECTOR_FP64, LMUL_RESERVED, 0, LMUL_2, 32)\n+ENTRY (VNx1DF, TARGET_VECTOR_FP64, LMUL_RESERVED, 0, LMUL_1, 64)\n \n #undef TARGET_VECTOR_FP32\n #undef TARGET_VECTOR_FP64"}, {"sha": "1f85391fc8e4a39d01bf9b88b5c5f3dcd0ce2b6d", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "patch": "@@ -979,7 +979,7 @@ riscv_valid_lo_sum_p (enum riscv_symbol_type sym_type, machine_mode mode,\n bool\n riscv_v_ext_vector_mode_p (machine_mode mode)\n {\n-#define ENTRY(MODE, REQUIREMENT)                                               \\\n+#define ENTRY(MODE, REQUIREMENT, ...)                                          \\\n   case MODE##mode:                                                             \\\n     return REQUIREMENT;\n   switch (mode)"}, {"sha": "a2f5a3eb69c6fc59b65bf7f41a4117d6d98092cd", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=3b16afeb3f6aacf64b9f9c50b7cb9805a9dfff63", "patch": "@@ -34,6 +34,191 @@\n   UNSPEC_VPREDICATE\n ])\n \n+(define_constants [\n+   (INVALID_ATTRIBUTE            255)\n+])\n+\n+;; True if the type is RVV instructions that include VTYPE\n+;; global status register in the use op list.\n+;; We known VTYPE has 4 fields: SEW, LMUL, TA, MA.\n+;; The instruction need any of VTYPE field is set as true\n+;; in this attribute.\n+(define_attr \"has_vtype_op\" \"false,true\"\n+  (cond [(eq_attr \"type\" \"vlde,vste,vldm,vstm,vlds,vsts,\\\n+\t\t\t  vldux,vldox,vstux,vstox,vldff,\\\n+\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\\\n+\t\t\t  vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\\\n+\t\t\t  vsalu,vaalu,vsmul,vsshift,vnclip,\\\n+\t\t\t  vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\\\n+\t\t\t  vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\\\n+\t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\\\n+\t\t\t  vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n+\t\t\t  vired,viwred,vfred,vfredo,vfwred,vfwredo,\\\n+\t\t\t  vmalu,vmpop,vmffs,vmsfs,vmiota,vmidx,vimovvx,vimovxv,vfmovvf,vfmovfv,\\\n+\t\t\t  vislide,vislide1,vfslide1,vgather,vcompress\")\n+\t (const_string \"true\")]\n+\t(const_string \"false\")))\n+\n+;; True if the type is RVV instructions that include VL\n+;; global status register in the use op list.\n+;; The instruction need vector length to be specified is set\n+;; in this attribute.\n+(define_attr \"has_vl_op\" \"false,true\"\n+  (cond [(eq_attr \"type\" \"vlde,vste,vldm,vstm,vlds,vsts,\\\n+\t\t\t  vldux,vldox,vstux,vstox,vldff,\\\n+\t\t\t  vialu,viwalu,vext,vicalu,vshift,vnshift,vicmp,\\\n+\t\t\t  vimul,vidiv,viwmul,vimuladd,viwmuladd,vimerge,vimov,\\\n+\t\t\t  vsalu,vaalu,vsmul,vsshift,vnclip,\\\n+\t\t\t  vfalu,vfwalu,vfmul,vfdiv,vfwmul,vfmuladd,vfwmuladd,vfsqrt,vfrecp,\\\n+\t\t\t  vfcmp,vfsgnj,vfclass,vfmerge,vfmov,\\\n+\t\t\t  vfcvtitof,vfcvtftoi,vfwcvtitof,vfwcvtftoi,\\\n+\t\t\t  vfwcvtftof,vfncvtitof,vfncvtftoi,vfncvtftof,\\\n+\t\t\t  vired,viwred,vfred,vfredo,vfwred,vfwredo,\\\n+\t\t\t  vmalu,vmpop,vmffs,vmsfs,vmiota,vmidx,vimovxv,vfmovfv,\\\n+\t\t\t  vislide,vislide1,vfslide1,vgather,vcompress\")\n+\t (const_string \"true\")]\n+\t(const_string \"false\")))\n+\n+;; The default SEW of RVV instruction. This attribute doesn't mean the instruction\n+;; is necessary to require SEW check for example vlm.v which require ratio to\n+;; check. However, we need default value of SEW for vsetvl instruction since there\n+;; is no field for ratio in the vsetvl instruction encoding.\n+(define_attr \"sew\" \"\"\n+  (cond [(eq_attr \"mode\" \"VNx1QI,VNx2QI,VNx4QI,VNx8QI,VNx16QI,VNx32QI,VNx64QI,\\\n+\t\t\t  VNx1BI,VNx2BI,VNx4BI,VNx8BI,VNx16BI,VNx32BI,VNx64BI\")\n+\t (const_int 8)\n+\t (eq_attr \"mode\" \"VNx1HI,VNx2HI,VNx4HI,VNx8HI,VNx16HI,VNx32HI\")\n+\t (const_int 16)\n+\t (eq_attr \"mode\" \"VNx1SI,VNx2SI,VNx4SI,VNx8SI,VNx16SI,\\\n+\t\t\t  VNx1SF,VNx2SF,VNx4SF,VNx8SF,VNx16SF\")\n+\t (const_int 32)\n+\t (eq_attr \"mode\" \"VNx1DI,VNx2DI,VNx4DI,VNx8DI,\\\n+\t\t\t  VNx1DF,VNx2DF,VNx4DF,VNx8DF\")\n+\t (const_int 64)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; Ditto to LMUL.\n+(define_attr \"vlmul\" \"\"\n+  (cond [(eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx1QImode)\")\n+\t (eq_attr \"mode\" \"VNx2QI,VNx2BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx2QImode)\")\n+\t (eq_attr \"mode\" \"VNx4QI,VNx4BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4QImode)\")\n+\t (eq_attr \"mode\" \"VNx8QI,VNx8BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8QImode)\")\n+\t (eq_attr \"mode\" \"VNx16QI,VNx16BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx16QImode)\")\n+\t (eq_attr \"mode\" \"VNx32QI,VNx32BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx32QImode)\")\n+\t (eq_attr \"mode\" \"VNx64QI,VNx64BI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx64QImode)\")\n+\t (eq_attr \"mode\" \"VNx1HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx1HImode)\")\n+\t (eq_attr \"mode\" \"VNx2HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx2HImode)\")\n+\t (eq_attr \"mode\" \"VNx4HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4HImode)\")\n+\t (eq_attr \"mode\" \"VNx8HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8HImode)\")\n+\t (eq_attr \"mode\" \"VNx16HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx16HImode)\")\n+\t (eq_attr \"mode\" \"VNx32HI\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx32HImode)\")\n+\t (eq_attr \"mode\" \"VNx1SI,VNx1SF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx1SImode)\")\n+\t (eq_attr \"mode\" \"VNx2SI,VNx2SF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx2SImode)\")\n+\t (eq_attr \"mode\" \"VNx4SI,VNx4SF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4SImode)\")\n+\t (eq_attr \"mode\" \"VNx8SI,VNx8SF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8SImode)\")\n+\t (eq_attr \"mode\" \"VNx16SI,VNx16SF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx16SImode)\")\n+\t (eq_attr \"mode\" \"VNx1DI,VNx1DF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx1DImode)\")\n+\t (eq_attr \"mode\" \"VNx2DI,VNx2DF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx2DImode)\")\n+\t (eq_attr \"mode\" \"VNx4DI,VNx4DF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx4DImode)\")\n+\t (eq_attr \"mode\" \"VNx8DI,VNx8DF\")\n+\t   (symbol_ref \"riscv_vector::get_vlmul(E_VNx8DImode)\")]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; It is valid for instruction that require sew/lmul ratio.\n+(define_attr \"ratio\" \"\"\n+  (cond [(eq_attr \"type\" \"vimov,vfmov\")\n+\t   (const_int INVALID_ATTRIBUTE)\n+\t (eq_attr \"mode\" \"VNx1QI,VNx1BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1QImode)\")\n+\t (eq_attr \"mode\" \"VNx2QI,VNx2BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx2QImode)\")\n+\t (eq_attr \"mode\" \"VNx4QI,VNx4BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx4QImode)\")\n+\t (eq_attr \"mode\" \"VNx8QI,VNx8BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx8QImode)\")\n+\t (eq_attr \"mode\" \"VNx16QI,VNx16BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx16QImode)\")\n+\t (eq_attr \"mode\" \"VNx32QI,VNx32BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx32QImode)\")\n+\t (eq_attr \"mode\" \"VNx64QI,VNx64BI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx64QImode)\")\n+\t (eq_attr \"mode\" \"VNx1HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1HImode)\")\n+\t (eq_attr \"mode\" \"VNx2HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx2HImode)\")\n+\t (eq_attr \"mode\" \"VNx4HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx4HImode)\")\n+\t (eq_attr \"mode\" \"VNx8HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx8HImode)\")\n+\t (eq_attr \"mode\" \"VNx16HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx16HImode)\")\n+\t (eq_attr \"mode\" \"VNx32HI\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx32HImode)\")\n+\t (eq_attr \"mode\" \"VNx1SI,VNx1SF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1SImode)\")\n+\t (eq_attr \"mode\" \"VNx2SI,VNx2SF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx2SImode)\")\n+\t (eq_attr \"mode\" \"VNx4SI,VNx4SF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx4SImode)\")\n+\t (eq_attr \"mode\" \"VNx8SI,VNx8SF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx8SImode)\")\n+\t (eq_attr \"mode\" \"VNx16SI,VNx16SF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx16SImode)\")\n+\t (eq_attr \"mode\" \"VNx1DI,VNx1DF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx1DImode)\")\n+\t (eq_attr \"mode\" \"VNx2DI,VNx2DF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx2DImode)\")\n+\t (eq_attr \"mode\" \"VNx4DI,VNx4DF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx4DImode)\")\n+\t (eq_attr \"mode\" \"VNx8DI,VNx8DF\")\n+\t   (symbol_ref \"riscv_vector::get_ratio(E_VNx8DImode)\")]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The index of operand[] to get the merge op.\n+(define_attr \"merge_op_idx\" \"\"\n+\t(cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vlds,vmalu\")\n+\t (const_int 2)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The index of operand[] to get the avl op.\n+(define_attr \"vl_op_idx\" \"\"\n+\t(cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vldm,vstm,vlds,vmalu\")\n+\t (const_int 4)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The index of operand[] to get the tail policy op.\n+(define_attr \"tail_policy_op_idx\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vste,vimov,vfmov,vlds\")\n+\t (const_int 5)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n+;; The index of operand[] to get the mask policy op.\n+(define_attr \"mask_policy_op_idx\" \"\"\n+  (cond [(eq_attr \"type\" \"vlde,vste,vlds\")\n+\t (const_int 6)]\n+\t(const_int INVALID_ATTRIBUTE)))\n+\n ;; -----------------------------------------------------------------\n ;; ---- Miscellaneous Operations\n ;; -----------------------------------------------------------------"}]}