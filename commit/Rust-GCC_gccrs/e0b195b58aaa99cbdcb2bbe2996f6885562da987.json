{"sha": "e0b195b58aaa99cbdcb2bbe2996f6885562da987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiMTk1YjU4YWFhOTljYmRjYjJiYmUyOTk2ZjY4ODU1NjJkYTk4Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-05T20:23:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-06-05T20:23:40Z"}, "message": "reflect: canonicalize types returned by StructOf() and friends\n    \n    Background: since gccgo does not currently merge identical types at link time,\n    the reflect function canonicalize() exists to choose a canonical specimen\n    for each set of identical types.\n    In this way, user code has the guarantee that identical types\n    will always compare as ==\n    \n    Change: arrange reflect functions MapOf(), SliceOf(), StructOf() etc.\n    to call canonicalize() on the types they create, before storing the types\n    in internal lookup caches and returning them.\n    \n    This fixes known cases where canonicalize() is needed but was missing.\n    Supersedes https://golang.org/cl/112575 and mostly fixes issue 25284.\n    \n    Updates golang/go#25284\n    \n    Reviewed-on: https://go-review.googlesource.com/115577\n\nFrom-SVN: r261216", "tree": {"sha": "20115a17b149bdd5fa407deec538f86505eadb6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20115a17b149bdd5fa407deec538f86505eadb6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0b195b58aaa99cbdcb2bbe2996f6885562da987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b195b58aaa99cbdcb2bbe2996f6885562da987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b195b58aaa99cbdcb2bbe2996f6885562da987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b195b58aaa99cbdcb2bbe2996f6885562da987/comments", "author": null, "committer": null, "parents": [{"sha": "6d02e2d96029dfddfc4a37cd82791503f5a1fd88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d02e2d96029dfddfc4a37cd82791503f5a1fd88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d02e2d96029dfddfc4a37cd82791503f5a1fd88"}], "stats": {"total": 55, "additions": 34, "deletions": 21}, "files": [{"sha": "d2fde0778514586e8ec01f8ba1d6cff3750f1005", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b195b58aaa99cbdcb2bbe2996f6885562da987/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b195b58aaa99cbdcb2bbe2996f6885562da987/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e0b195b58aaa99cbdcb2bbe2996f6885562da987", "patch": "@@ -1,4 +1,4 @@\n-8e74a218e11ef6eaaf7014a3ad1cd0b13359c607\n+8b6c7f3f9762366bab96ea95b966e93e2593be13\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3378640e7e93ac71fc6b407ed0647640bd96a1e5", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b195b58aaa99cbdcb2bbe2996f6885562da987/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b195b58aaa99cbdcb2bbe2996f6885562da987/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=e0b195b58aaa99cbdcb2bbe2996f6885562da987", "patch": "@@ -3928,8 +3928,8 @@ func TestOverflow(t *testing.T) {\n \t}\n }\n \n-func checkSameType(t *testing.T, x, y interface{}) {\n-\tif TypeOf(x) != TypeOf(y) {\n+func checkSameType(t *testing.T, x Type, y interface{}) {\n+\tif x != TypeOf(y) || TypeOf(Zero(x).Interface()) != TypeOf(y) {\n \t\tt.Errorf(\"did not find preexisting type for %s (vs %s)\", TypeOf(x), TypeOf(y))\n \t}\n }\n@@ -4058,7 +4058,7 @@ func TestArrayOf(t *testing.T) {\n \n \t// check that type already in binary is found\n \ttype T int\n-\tcheckSameType(t, Zero(ArrayOf(5, TypeOf(T(1)))).Interface(), [5]T{})\n+\tcheckSameType(t, ArrayOf(5, TypeOf(T(1))), [5]T{})\n }\n \n func TestArrayOfGC(t *testing.T) {\n@@ -4195,7 +4195,7 @@ func TestSliceOf(t *testing.T) {\n \n \t// check that type already in binary is found\n \ttype T1 int\n-\tcheckSameType(t, Zero(SliceOf(TypeOf(T1(1)))).Interface(), []T1{})\n+\tcheckSameType(t, SliceOf(TypeOf(T1(1))), []T1{})\n }\n \n func TestSliceOverflow(t *testing.T) {\n@@ -4410,7 +4410,7 @@ func TestStructOf(t *testing.T) {\n \t\t})\n \t})\n \t// check that type already in binary is found\n-\tcheckSameType(t, Zero(StructOf(fields[2:3])).Interface(), struct{ Y uint64 }{})\n+\tcheckSameType(t, StructOf(fields[2:3]), struct{ Y uint64 }{})\n }\n \n func TestStructOfExportRules(t *testing.T) {\n@@ -4963,7 +4963,7 @@ func TestChanOf(t *testing.T) {\n \n \t// check that type already in binary is found\n \ttype T1 int\n-\tcheckSameType(t, Zero(ChanOf(BothDir, TypeOf(T1(1)))).Interface(), (chan T1)(nil))\n+\tcheckSameType(t, ChanOf(BothDir, TypeOf(T1(1))), (chan T1)(nil))\n }\n \n func TestChanOfDir(t *testing.T) {\n@@ -4974,8 +4974,8 @@ func TestChanOfDir(t *testing.T) {\n \n \t// check that type already in binary is found\n \ttype T1 int\n-\tcheckSameType(t, Zero(ChanOf(RecvDir, TypeOf(T1(1)))).Interface(), (<-chan T1)(nil))\n-\tcheckSameType(t, Zero(ChanOf(SendDir, TypeOf(T1(1)))).Interface(), (chan<- T1)(nil))\n+\tcheckSameType(t, ChanOf(RecvDir, TypeOf(T1(1))), (<-chan T1)(nil))\n+\tcheckSameType(t, ChanOf(SendDir, TypeOf(T1(1))), (chan<- T1)(nil))\n \n \t// check String form of ChanDir\n \tif crt.ChanDir().String() != \"<-chan\" {\n@@ -5051,7 +5051,7 @@ func TestMapOf(t *testing.T) {\n \t}\n \n \t// check that type already in binary is found\n-\tcheckSameType(t, Zero(MapOf(TypeOf(V(0)), TypeOf(K(\"\")))).Interface(), map[V]K(nil))\n+\tcheckSameType(t, MapOf(TypeOf(V(0)), TypeOf(K(\"\"))), map[V]K(nil))\n \n \t// check that invalid key type panics\n \tshouldPanic(func() { MapOf(TypeOf((func())(nil)), TypeOf(false)) })\n@@ -5181,7 +5181,7 @@ func TestFuncOf(t *testing.T) {\n \t\t{in: []Type{TypeOf(int(0))}, out: []Type{TypeOf(false), TypeOf(\"\")}, want: (func(int) (bool, string))(nil)},\n \t}\n \tfor _, tt := range testCases {\n-\t\tcheckSameType(t, Zero(FuncOf(tt.in, tt.out, tt.variadic)).Interface(), tt.want)\n+\t\tcheckSameType(t, FuncOf(tt.in, tt.out, tt.variadic), tt.want)\n \t}\n \n \t// check that variadic requires last element be a slice."}, {"sha": "458c45638f864e30d825076cab4c298c9726c473", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b195b58aaa99cbdcb2bbe2996f6885562da987/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b195b58aaa99cbdcb2bbe2996f6885562da987/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=e0b195b58aaa99cbdcb2bbe2996f6885562da987", "patch": "@@ -1475,8 +1475,10 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tch.uncommonType = nil\n \tch.ptrToThis = nil\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &ch.rtype)\n-\treturn ti.(Type)\n+\t// Canonicalize before storing in lookupCache\n+\tti := toType(&ch.rtype)\n+\tlookupCache.Store(ckey, ti.(*rtype))\n+\treturn ti\n }\n \n func ismapkey(*rtype) bool // implemented in runtime\n@@ -1537,8 +1539,10 @@ func MapOf(key, elem Type) Type {\n \tmt.reflexivekey = isReflexive(ktyp)\n \tmt.needkeyupdate = needKeyUpdate(ktyp)\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &mt.rtype)\n-\treturn ti.(Type)\n+\t// Canonicalize before storing in lookupCache\n+\tti := toType(&mt.rtype)\n+\tlookupCache.Store(ckey, ti.(*rtype))\n+\treturn ti\n }\n \n // FuncOf returns the function type with the given argument and result types.\n@@ -1621,7 +1625,10 @@ func FuncOf(in, out []Type, variadic bool) Type {\n \tft.string = &str\n \tft.uncommonType = nil\n \tft.ptrToThis = nil\n-\treturn addToCache(&ft.rtype)\n+\n+\t// Canonicalize before storing in funcLookupCache\n+\ttc := toType(&ft.rtype)\n+\treturn addToCache(tc.(*rtype))\n }\n \n // funcStr builds a string representation of a funcType.\n@@ -1855,8 +1862,10 @@ func SliceOf(t Type) Type {\n \tslice.uncommonType = nil\n \tslice.ptrToThis = nil\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &slice.rtype)\n-\treturn ti.(Type)\n+\t// Canonicalize before storing in lookupCache\n+\tti := toType(&slice.rtype)\n+\tlookupCache.Store(ckey, ti.(*rtype))\n+\treturn ti\n }\n \n // The structLookupCache caches StructOf lookups.\n@@ -2172,7 +2181,9 @@ func StructOf(fields []StructField) Type {\n \ttyp.uncommonType = nil\n \ttyp.ptrToThis = nil\n \n-\treturn addToCache(&typ.rtype)\n+\t// Canonicalize before storing in structLookupCache\n+\tti := toType(&typ.rtype)\n+\treturn addToCache(ti.(*rtype))\n }\n \n func runtimeStructField(field StructField) structField {\n@@ -2400,8 +2411,10 @@ func ArrayOf(count int, elem Type) Type {\n \t\t}\n \t}\n \n-\tti, _ := lookupCache.LoadOrStore(ckey, &array.rtype)\n-\treturn ti.(Type)\n+\t// Canonicalize before storing in lookupCache\n+\tti := toType(&array.rtype)\n+\tlookupCache.Store(ckey, ti.(*rtype))\n+\treturn ti\n }\n \n func appendVarint(x []byte, v uintptr) []byte {"}]}