{"sha": "bcf684c7a5ef5e899562a0a3621d51ed6b673265", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNmNjg0YzdhNWVmNWU4OTk1NjJhMGEzNjIxZDUxZWQ2YjY3MzI2NQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2001-11-03T22:14:57Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2001-11-03T22:14:57Z"}, "message": "config.gcc (mmix-*-*): New target.\n\n\t* config.gcc (mmix-*-*): New target.\n\t* doc/invoke.texi: Document MMIX options.\n\t* doc/contrib.texi: Add note about MMIX port to my entry.\n\t* config/mmix/t-mmix: New file.\n\t* config/mmix/mmix.h: New file.\n\t* config/mmix/mmix-protos.h: New file.\n\t* config/mmix/mmix.c: New file.\n\t* config/mmix/mmix.md: New file.\n\t* config/mmix/crti.asm: New file.\n\t* config/mmix/crtn.asm: New file.\n\nFrom-SVN: r46746", "tree": {"sha": "a31a17d816f6cf1f4efcbcb68438f15e6bfd5c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a31a17d816f6cf1f4efcbcb68438f15e6bfd5c06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcf684c7a5ef5e899562a0a3621d51ed6b673265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf684c7a5ef5e899562a0a3621d51ed6b673265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcf684c7a5ef5e899562a0a3621d51ed6b673265", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcf684c7a5ef5e899562a0a3621d51ed6b673265/comments", "author": null, "committer": null, "parents": [{"sha": "d344dce955f64380488a2e7242faacff4521e7d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d344dce955f64380488a2e7242faacff4521e7d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d344dce955f64380488a2e7242faacff4521e7d1"}], "stats": {"total": 6082, "additions": 6080, "deletions": 2}, "files": [{"sha": "16ac91cceead9c1a389be6de33fd1ead6ba67bc1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -1,3 +1,16 @@\n+2001-11-03  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* config.gcc (mmix-*-*): New target.\n+\t* doc/invoke.texi: Document MMIX options.\n+\t* doc/contrib.texi: Add note about MMIX port to my entry.\n+\t* config/mmix/t-mmix: New file.\n+\t* config/mmix/mmix.h: New file.\n+\t* config/mmix/mmix-protos.h: New file.\n+\t* config/mmix/mmix.c: New file.\n+\t* config/mmix/mmix.md: New file.\n+\t* config/mmix/crti.asm: New file.\n+\t* config/mmix/crtn.asm: New file.\n+\n 2001-11-03  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/sparc/linux-aout.h: Fix comment formatting."}, {"sha": "583b3ac6543c51feb8820fc88597bb090a81c438", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -2554,6 +2554,8 @@ mips-*-*)\t\t\t\t# Default MIPS RISC-OS 4.0.\n \t\tuse_collect2=yes\n \tfi\n \t;;\n+mmix-knuth-mmixware)\n+\t;;\n mn10200-*-*)\n \tfloat_format=i32\n \ttm_file=\"elfos.h svr4.h ${tm_file}\""}, {"sha": "7cbb948e2124b54a1c6e7d9dc7cbd1196fd84ba6", "filename": "gcc/config/mmix/crti.asm", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fcrti.asm?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,111 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Hans-Peter Nilsson <hp@bitrange.com>\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+% This is crt0 for mmix-knuth-mmixware, for setting up things for\n+% compiler-generated assembler and for setting up things between where the\n+% simulator calls and main, and shutting things down on the way back.\n+\n+% This file and the GCC output are supposed to be *reasonably*\n+% mmixal-compatible to enable people to re-use output with Knuth's mmixal.\n+% However, forward references are used more freely: we are using the\n+% binutils tools.  Users of mmixal beware; you will sometimes have to\n+% re-order things or use temporary variables.\n+\n+% Users of mmixal will want to set up 8H and 9H to be .text and .data\n+% respectively, so the compiler can switch between them pretending they're\n+% segments.\n+\n+% This little treasure is here so the 32 lowest address bits of user data\n+% will not be zero.  Because of truncation, that would cause test-case\n+% gcc.c-torture/execute/980701-1.c to incorrectly fail.\n+\t.data\t! mmixal:= 8H LOC Data_Segment\n+\t.p2align 3\n+\tLOC @+(8-@)@7\n+\tOCTA 2009\n+\n+\t.text\t! mmixal:= 9H LOC 8B; LOC #100\n+\t.global Main\n+\n+% The __Stack_start symbol is provided by the link script.\n+stackpp\tOCTA __Stack_start\n+\n+% \"Main\" is the magic symbol the simulator jumps to.  We want to go\n+% on to \"main\".\n+% We need to set rG explicitly to avoid hard-to-debug situations.\n+Main\tSETL\t$255,32\n+\tPUT\trG,$255\n+\n+% Initialize the stack pointer.  It is supposedly made a global\n+% zero-initialized (allowed to change) register in crtn.asm; we use the\n+% explicit number.\n+\tGETA\t$255,stackpp\n+\tLDOU\t$254,$255,0\n+\n+% Make sure we get more than one mem, to simplify counting cycles.\n+\tLDBU\t$255,$1,0\n+\tLDBU\t$255,$1,1\n+\n+\tPUSHJ\t$2,_init\n+\n+#ifdef __MMIX_ABI_GNU__\n+% Copy argc and argv from their initial position to argument registers\n+% where necessary.\n+\tSET\t$232,$0\n+\tSET\t$233,$1\n+#else\n+% For the mmixware ABI, we need to move arguments.  The return value will\n+% appear in $0.\n+\tSET\t$2,$1\n+\tSET\t$1,$0\n+#endif\n+\n+\tPUSHJ\t$0,main\n+\tJMP\texit\n+\n+% Provide first part of _init and _fini.  Save the return address on the\n+% register stack.  We eventually ignore the return address of these\n+% PUSHJ:s, so it doesn't matter that whether .init and .fini code calls\n+% functions or where they store rJ.  We shouldn't get there, so abort if\n+% that happens\n+\n+\t.section .init,\"ax\",@progbits\n+\t.global\t_init\n+_init:\n+\tGET\t$0,:rJ\n+\tPUSHJ\t$1,0F\n+\tSETL\t$255,255\n+\tTRAP\t0,0,0\n+0H\tIS\t@\n+\n+\t.section .fini,\"ax\",@progbits\n+\t.global\t_fini\n+_fini:\n+\tGET\t$0,:rJ\n+\tPUSHJ\t$1,0F\n+\tSETL\t$255,255\n+\tTRAP\t0,0,0\n+0H\tIS\t@"}, {"sha": "265d926b592f0c2357c1e3e3d23e3f93ad589b83", "filename": "gcc/config/mmix/crtn.asm", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fcrtn.asm?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,91 @@\n+/* Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Hans-Peter Nilsson <hp@bitrange.com>\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+% This must be the last file on the link-line, allocating global registers\n+% from the top.\n+\n+% Register $254 is the stack-pointer.\n+sp GREG\n+\n+% Register $253 is frame-pointer.  It's not supposed to be used in most\n+% functions.\n+fp GREG\n+\n+% $252 is the static chain register; nested functions receive the\n+% context of the surrounding function through a pointer passed in this\n+% register.\n+static_chain GREG\n+struct_value_reg GREG\n+\n+% These registers are used to pass state at an exceptional return (C++).\n+eh_state_3 GREG\n+eh_state_2 GREG\n+eh_state_1 GREG\n+eh_state_0 GREG\n+\n+#ifdef __MMIX_ABI_GNU__\n+\n+% Allocate global registers used by the GNU ABI.\n+gnu_parm_reg_16 GREG\n+gnu_parm_reg_15 GREG\n+gnu_parm_reg_14 GREG\n+gnu_parm_reg_13 GREG\n+gnu_parm_reg_12 GREG\n+gnu_parm_reg_11 GREG\n+gnu_parm_reg_10 GREG\n+gnu_parm_reg_9 GREG\n+gnu_parm_reg_8 GREG\n+gnu_parm_reg_7 GREG\n+gnu_parm_reg_6 GREG\n+gnu_parm_reg_5 GREG\n+gnu_parm_reg_4 GREG\n+gnu_parm_reg_3 GREG\n+gnu_parm_reg_2 GREG\n+gnu_parm_reg_1 GREG\n+\n+#endif /* __MMIX_ABI_GNU__ */\n+\n+% Provide last part of _init and _fini.\n+\n+% The return address is stored in the topmost stored register in the\n+% register-stack.  We ignore the current value in rJ.  It is probably\n+% garbage because each fragment of _init and _fini may have their own idea\n+% of the current stack frame, if they're cut out from a \"real\" function\n+% like in gcc/crtstuff.c.\n+\n+\t.section .init,\"ax\",@progbits\n+\tGETA\t$255,0F\n+\tPUT\trJ,$255\n+\tPOP\t0,0\n+0H\tPUT\trJ,$0\n+\tPOP\t0,0\n+\t\n+\t.section .fini,\"ax\",@progbits\n+\tGETA\t$255,0F\n+\tPUT\trJ,$255\n+0H\tPUT\trJ,$0\n+\tPOP\t0,0"}, {"sha": "f746c7b0fca956ea240295bb6659eb1b9f72c251", "filename": "gcc/config/mmix/mmix-protos.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,149 @@\n+/* Prototypes for exported functions defined in mmix.c\n+   Copyright (C) 2000, 2001  Free Software Foundation, Inc.\n+   Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+extern void mmix_override_options PARAMS ((void));\n+extern void mmix_init_expanders PARAMS ((void));\n+extern int mmix_eh_return_data_regno PARAMS ((int));\n+extern int mmix_initial_elimination_offset PARAMS ((int, int));\n+extern int mmix_starting_frame_offset PARAMS ((void));\n+extern int mmix_function_arg_regno_p PARAMS ((int, int));\n+extern void mmix_function_profiler PARAMS ((FILE *, int));\n+extern void mmix_function_block_profiler PARAMS ((FILE *, int));\n+extern void mmix_block_profiler PARAMS ((FILE *, int));\n+extern void mmix_function_block_profiler_exit PARAMS ((FILE *));\n+extern void mmix_trampoline_template PARAMS ((FILE *));\n+extern int mmix_trampoline_size;\n+extern int mmix_reversible_cc_mode PARAMS ((enum machine_mode));\n+extern int mmix_register_move_cost\n+  PARAMS ((enum machine_mode, enum reg_class, enum reg_class));\n+extern const char *mmix_text_section_asm_op PARAMS ((void));\n+extern const char *mmix_data_section_asm_op PARAMS ((void));\n+extern const char *mmix_strip_name_encoding PARAMS ((const char *));\n+extern void mmix_asm_file_start PARAMS ((FILE *));\n+extern void mmix_asm_file_end PARAMS ((FILE *));\n+extern void mmix_asm_identify_gcc PARAMS ((FILE *));\n+extern void mmix_asm_output_source_filename PARAMS ((FILE *, const char *));\n+extern void mmix_output_quoted_string PARAMS ((FILE *, const char *, int));\n+extern void mmix_asm_output_source_line  PARAMS ((FILE *, int));\n+extern void mmix_asm_output_ascii PARAMS ((FILE *, const char *, int));\n+extern void mmix_asm_output_label PARAMS ((FILE *, const char *));\n+extern void mmix_asm_globalize_label PARAMS ((FILE *, const char *));\n+extern void mmix_asm_weaken_label PARAMS ((FILE *, const char *));\n+extern void mmix_asm_output_labelref PARAMS ((FILE *, const char *));\n+extern void mmix_asm_output_internal_label\n+  PARAMS ((FILE *, const char *, int));\n+extern void mmix_asm_output_def PARAMS ((FILE *, const char *, const char *));\n+extern void mmix_asm_output_define_label_difference_symbol\n+  PARAMS ((FILE *, const char *, const char *, const char *));\n+extern int mmix_print_operand_punct_valid_p PARAMS ((int));\n+extern void mmix_asm_output_reg_push PARAMS ((FILE *, int));\n+extern void mmix_asm_output_reg_pop PARAMS ((FILE *, int));\n+extern void mmix_asm_output_skip PARAMS ((FILE *, int));\n+extern void mmix_asm_output_align PARAMS ((FILE *, int));\n+extern int mmix_shiftable_wyde_value PARAMS ((unsigned HOST_WIDEST_INT));\n+extern void mmix_output_register_setting\n+  PARAMS ((FILE *, int, HOST_WIDEST_INT, int));\n+extern void mmix_conditional_register_usage PARAMS ((void));\n+extern int mmix_dbx_register_number PARAMS ((int));\n+\n+/* Things that need rtl.h, tree.h or real.h included, or in combination.  */\n+\n+/* Need tree.h */\n+#ifdef TREE_CODE\n+\n+extern void mmix_make_decl_one_only PARAMS ((tree));\n+extern int mmix_function_arg_pass_by_reference\n+  PARAMS ((const CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern rtx mmix_function_outgoing_value PARAMS ((tree, tree));\n+extern int mmix_data_alignment PARAMS ((tree, int));\n+extern int mmix_constant_alignment PARAMS ((tree, int));\n+extern int mmix_local_alignment PARAMS ((tree, int));\n+extern void mmix_setup_incoming_varargs\n+  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int));\n+extern void mmix_select_section PARAMS ((tree, int, int));\n+extern void mmix_encode_section_info PARAMS ((tree));\n+extern void mmix_unique_section PARAMS ((tree, int));\n+extern void mmix_asm_output_pool_prologue\n+  PARAMS ((FILE *, const char *, tree, int));\n+extern void mmix_asm_output_aligned_common\n+  PARAMS ((FILE *, const char *, int, int));\n+extern void mmix_asm_output_aligned_local\n+  PARAMS ((FILE *, const char *, int, int));\n+extern void mmix_asm_declare_register_global\n+  PARAMS ((FILE *, tree, int, const char *));\n+extern void mmix_asm_output_mi_thunk PARAMS ((FILE *, tree, int, tree));\n+\n+/* Need tree.h and rtl.h */\n+# ifdef RTX_CODE\n+extern rtx mmix_function_arg\n+  PARAMS ((const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int));\n+extern rtx mmix_expand_builtin_va_arg PARAMS ((tree, tree));\n+# endif /* RTX_CODE */\n+#endif /* TREE_CODE */\n+\n+/* Need rtl.h */\n+#ifdef RTX_CODE\n+extern void mmix_asm_output_addr_diff_elt PARAMS ((FILE *, rtx, int, int));\n+extern void mmix_asm_output_addr_vec_elt PARAMS ((FILE *, int));\n+extern enum reg_class mmix_preferred_reload_class\n+  PARAMS ((rtx, enum reg_class));\n+extern enum reg_class mmix_preferred_output_reload_class\n+  PARAMS ((rtx, enum reg_class));\n+extern enum reg_class mmix_secondary_reload_class\n+  PARAMS ((enum reg_class, enum machine_mode, rtx, int));\n+extern int mmix_const_ok_for_letter_p PARAMS ((HOST_WIDE_INT, int));\n+extern int mmix_const_double_ok_for_letter_p PARAMS ((rtx, int));\n+extern int mmix_extra_constraint PARAMS ((rtx, int));\n+extern rtx mmix_dynamic_chain_address PARAMS ((rtx));\n+extern rtx mmix_return_addr_rtx PARAMS ((int, rtx));\n+extern rtx mmix_eh_return_stackadj_rtx PARAMS ((void));\n+extern rtx mmix_eh_return_handler_rtx PARAMS ((void));\n+extern void mmix_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern int mmix_constant_address_p PARAMS ((rtx));\n+extern int mmix_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n+extern int mmix_legitimate_constant_p PARAMS ((rtx));\n+extern enum machine_mode mmix_select_cc_mode PARAMS ((RTX_CODE, rtx, rtx));\n+extern void mmix_canonicalize_comparison PARAMS ((RTX_CODE *, rtx *, rtx *));\n+extern int mmix_rtx_cost_recalculated\n+  PARAMS ((rtx, RTX_CODE, RTX_CODE, int *));\n+extern int mmix_address_cost PARAMS ((rtx));\n+extern void mmix_asm_output_double_int PARAMS ((FILE *, rtx, int));\n+extern void mmix_print_operand PARAMS ((FILE *, rtx, int));\n+extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n+extern int mmix_valid_comparison PARAMS ((RTX_CODE, enum machine_mode, rtx));\n+extern rtx mmix_gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n+#endif /* RTX_CODE */\n+\n+extern int mmix_asm_preferred_eh_data_format PARAMS ((int, int));\n+extern void mmix_setup_frame_addresses PARAMS ((void));\n+\n+/* Need real.h */\n+#ifdef GCC_REAL_H\n+extern void mmix_asm_output_double PARAMS ((FILE *, REAL_VALUE_TYPE *));\n+extern void mmix_asm_output_float PARAMS ((FILE *, REAL_VALUE_TYPE *));\n+#endif /* GCC_REAL_H */\n+\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "37d24d2e407c0638886672f4bf291eb76ea091fa", "filename": "gcc/config/mmix/mmix.c", "status": "added", "additions": 3160, "deletions": 0, "changes": 3160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265"}, {"sha": "d8a10a86081af0229ed8bd12db5f38826b5f4056", "filename": "gcc/config/mmix/mmix.h", "status": "added", "additions": 1292, "deletions": 0, "changes": 1292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,1292 @@\n+/* Definitions of target machine for GNU compiler, for MMIX.\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_MMIX_H\n+#define GCC_MMIX_H\n+\n+/* First, some local helper macros.  Note that the \"default\" value of\n+   FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER and\n+   REG_CLASS_CONTENTS depend on these values.  */\n+#define MMIX_RESERVED_GNU_ARG_0_REGNUM 231\n+#define MMIX_FIRST_ARG_REGNUM \\\n+  (TARGET_ABI_GNU ? MMIX_RESERVED_GNU_ARG_0_REGNUM : 16)\n+#define MMIX_FIRST_INCOMING_ARG_REGNUM \\\n+  (TARGET_ABI_GNU ? MMIX_RESERVED_GNU_ARG_0_REGNUM : 0)\n+#define MMIX_MAX_ARGS_IN_REGS 16\n+\n+/* FIXME: This one isn't fully implemented yet.  Return values larger than\n+   one register are passed by reference in MMIX_STRUCT_VALUE_REGNUM by the\n+   caller, except for return values of type \"complex\".  */\n+#define MMIX_MAX_REGS_FOR_VALUE 16\n+#define MMIX_RETURN_VALUE_REGNUM \\\n+  (TARGET_ABI_GNU ? MMIX_RESERVED_GNU_ARG_0_REGNUM : 15)\n+#define MMIX_OUTGOING_RETURN_VALUE_REGNUM \\\n+  (TARGET_ABI_GNU ? MMIX_RESERVED_GNU_ARG_0_REGNUM : 0)\n+#define MMIX_STRUCT_VALUE_REGNUM 251\n+#define MMIX_STATIC_CHAIN_REGNUM 252\n+#define MMIX_FRAME_POINTER_REGNUM 253\n+#define MMIX_STACK_POINTER_REGNUM 254\n+#define MMIX_LAST_GENERAL_REGISTER 255\n+#define MMIX_INCOMING_RETURN_ADDRESS_REGNUM 259\n+#define MMIX_HIMULT_REGNUM 258\n+#define MMIX_REMAINDER_REGNUM 260\n+#define MMIX_ARG_POINTER_REGNUM 261\n+#define MMIX_LAST_REGISTER_FILE_REGNUM 31\n+\n+/* Four registers; \"ideally, these registers should be call-clobbered\", so\n+   just grab a bunch of the common clobbered registers.  FIXME: Last\n+   registers of return-value should be used, with an error if there's a\n+   return-value (that collides in size).  */\n+#define MMIX_EH_RETURN_DATA_REGNO_START (MMIX_STRUCT_VALUE_REGNUM - 4)\n+\n+/* Try to keep the definitions from running away on their own.  */\n+#if (MMIX_EH_RETURN_DATA_REGNO_START \\\n+     != MMIX_RESERVED_GNU_ARG_0_REGNUM + MMIX_MAX_ARGS_IN_REGS)\n+ #error MMIX register definition inconsistency\n+#endif\n+\n+#if (MMIX_MAX_REGS_FOR_VALUE + MMIX_MAX_ARGS_IN_REGS > 32)\n+ #error MMIX parameters and return values bad, more than 32 registers\n+#endif\n+\n+/* This chosen as \"a call-clobbered hard register that is otherwise\n+   untouched by the epilogue\".  */\n+#define MMIX_EH_RETURN_STACKADJ_REGNUM MMIX_STATIC_CHAIN_REGNUM\n+\n+#ifdef REG_OK_STRICT\n+# define MMIX_REG_OK_STRICT 1\n+#else\n+# define MMIX_REG_OK_STRICT 0\n+#endif\n+\n+#define MMIX_FUNCTION_ARG_SIZE(MODE, TYPE) \\\n+ ((MODE) != BLKmode ? GET_MODE_SIZE (MODE) : int_size_in_bytes (TYPE))\n+\n+/* Declarations for helper variables that are not tied to a particular\n+   target macro.  */\n+extern struct rtx_def *mmix_compare_op0;\n+extern struct rtx_def *mmix_compare_op1;\n+\n+/* Per-function machine data.  This is normally an opaque type just\n+   defined and used in the tm.c file, but we need to see the definition in\n+   mmix.md too.  */\n+struct machine_function\n+ {\n+   int has_call_value_without_parameters;\n+   int has_landing_pad;\n+ };\n+\n+/* For these target macros, there is no generic documentation here.  You\n+   should read `Using and Porting GCC' for that.  Only comments specific\n+   to the MMIX target are here.\n+\n+   There are however references to the specific texinfo node (comments\n+   with \"Node:\"), so there should be little or nothing amiss.  Probably\n+   the opposite, since we don't have to care about old littering and\n+   soon outdated generic comments.  */\n+\n+/* Node: Driver */\n+\n+/* When both ABI:s work, this is how we tell them apart in code.  The\n+   GNU abi is implied the default.  Also implied in TARGET_DEFAULT.  */\n+#define CPP_SPEC \\\n+ \"%{abi=gnu:-D__MMIX_ABI_GNU__\\\n+    %{abi=mmixware:\\\n+      %eoptions -mabi=mmixware and -mabi=gnu are mutually exclusive}}\\\n+  %{!abi=gnu:-D__MMIX_ABI_MMIXWARE__}\"\n+\n+/* User symbols are in the same name-space as built-in symbols, but we\n+   don't need the built-in symbols, so remove those and instead apply\n+   stricter operand checking.  Don't warn when expanding insns.  */\n+#define ASM_SPEC \"-no-predefined-syms -x\"\n+\n+/* Pass on -mset-program-start=N and -mset-data-start=M to the linker.\n+   Provide default program start 0x100 unless -mno-set-program-start.\n+   Link to ELF if requested.  */\n+#define LINK_SPEC \\\n+ \"%{mset-program-start=*:--defsym __.MMIX.start..text=%*}\\\n+  %{mset-data-start=*:--defsym __.MMIX.start..data=%*}\\\n+  %{!mset-program-start=*:\\\n+    %{!mno-set-program-start:--defsym __.MMIX.start..text=0x100}}\\\n+  %{!melf:-m mmo}%{melf:-m elf64mmix}\"\n+\n+/* Put unused option values here.  */\n+extern char *mmix_cc1_ignored_option;\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\\\n+   {{\"set-program-start=\", &mmix_cc1_ignored_option,\t\\\n+  N_(\"Set start-address of the program\") },\t\t\\\n+    {\"set-data-start=\", &mmix_cc1_ignored_option,\t\\\n+  N_(\"Set start-address of data\")}}\n+\n+/* FIXME: There's no provision for profiling here.  */\n+#define STARTFILE_SPEC  \\\n+  \"crti%O%s crtbegin%O%s\"\n+\n+#define ENDFILE_SPEC \"crtend%O%s crtn%O%s\"\n+\n+/* Node: Run-time Target */\n+\n+/* Define __LONG_MAX__, since we're advised not to change glimits.h.  */\n+#define CPP_PREDEFINES \"-D__mmix__ -D__MMIX__ -D__LONG_MAX__=9223372036854775807L\"\n+\n+extern int target_flags;\n+\n+#define TARGET_MASK_LIBFUNCS 1\n+#define TARGET_MASK_ABI_GNU 2\n+#define TARGET_MASK_FCMP_EPSILON 4\n+#define TARGET_MASK_ZERO_EXTEND 8\n+#define TARGET_MASK_KNUTH_DIVISION 16\n+#define TARGET_MASK_TOPLEVEL_SYMBOLS 32\n+\n+/* FIXME: Get rid of this one.  */\n+#define TARGET_LIBFUNC (target_flags & TARGET_MASK_LIBFUNCS)\n+#define TARGET_ABI_GNU (target_flags & TARGET_MASK_ABI_GNU)\n+#define TARGET_FCMP_EPSILON (target_flags & TARGET_MASK_FCMP_EPSILON)\n+#define TARGET_ZERO_EXTEND (target_flags & TARGET_MASK_ZERO_EXTEND)\n+#define TARGET_KNUTH_DIVISION (target_flags & TARGET_MASK_KNUTH_DIVISION)\n+#define TARGET_TOPLEVEL_SYMBOLS (target_flags & TARGET_MASK_TOPLEVEL_SYMBOLS)\n+\n+#define TARGET_DEFAULT 0\n+\n+/* FIXME: Provide a way to *load* the epsilon register.\n+   Kill some of these; preferrably the -mint=* ones.  */\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+ {{\"libfuncs\",\t\tTARGET_MASK_LIBFUNCS,\t\t\t\t\\\n+   N_(\"For intrinsics library: pass all parameters in registers\")},\t\\\n+  {\"no-libfuncs\",\t-TARGET_MASK_LIBFUNCS, \"\"},\t\t\t\\\n+  {\"abi=mmixware\",\t-TARGET_MASK_ABI_GNU,\t\t\t\t\\\n+   N_(\"Use register stack for parameters and return value\")},\t\t\\\n+  {\"abi=gnu\",\t\tTARGET_MASK_ABI_GNU,\t\t\t\t\\\n+   N_(\"Use call-clobbered registers for parameters and return value\")},\t\\\n+  {\"epsilon\",\t\tTARGET_MASK_FCMP_EPSILON,\t\t\t\\\n+   N_(\"Use epsilon-respecting floating point compare instructions\")},\t\\\n+  {\"no-epsilon\",\t-TARGET_MASK_FCMP_EPSILON, \"\"},\t\t\t\\\n+  {\"zero-extend\",\tTARGET_MASK_ZERO_EXTEND,\t\t\t\\\n+   N_(\"Use zero-extending memory loads, not sign-extending ones\")},\t\\\n+  {\"no-zero-extend\",\t-TARGET_MASK_ZERO_EXTEND,  \"\"},\t\t\t\\\n+  {\"knuthdiv\",\t\tTARGET_MASK_KNUTH_DIVISION,\t\t\t\\\n+   N_(\"Generate divide results with reminder having the same sign as the\\\n+ divisor (not the dividend).\")},\t\t\t\t\t\\\n+  {\"no-knuthdiv\",\t-TARGET_MASK_KNUTH_DIVISION, \"\"},\t\t\\\n+  {\"toplevel-symbols\",\tTARGET_MASK_TOPLEVEL_SYMBOLS,\t\t\t\\\n+   N_(\"Prepend global symbols with \\\":\\\" (for use with PREFIX)\")},\t\\\n+  {\"no-toplevel-symbols\", 0,\t\t\t\t\t\t\\\n+   N_(\"Do not provide a default start-address 0x100 of the program\")},\t\\\n+  {\"elf\", 0,\t\t\t\t\t\t\t\t\\\n+   N_(\"Link to emit program in ELF format (rather than mmo)\")},\t\t\\\n+  {\"\",\t\t\tTARGET_DEFAULT, \"\"}}\n+\n+/* Unfortunately, this must not reference anything in \"mmix.c\".  */\n+#define TARGET_VERSION \\\n+  fprintf (stderr, \" (MMIX) 2001-09-01\")\n+\n+#define OVERRIDE_OPTIONS mmix_override_options ()\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (LEVEL >= 1)\t\t\t\t\\\n+\tflag_regmove = TRUE;\t\t\t\\\n+      \t\t\t\t\t\t\\\n+      if (SIZE || LEVEL > 1)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  flag_omit_frame_pointer = TRUE;\t\\\n+\t  flag_strength_reduce = FALSE;\t\t\\\n+\t}\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This one will have to wait a little bit; right now we can't debug\n+   neither with or without a frame-pointer.  */\n+/* #define CAN_DEBUG_WITHOUT_FP */\n+\n+\n+/* Node: Per-Function Data */\n+#define INIT_EXPANDERS mmix_init_expanders ()\n+\n+\n+/* Node: Storage Layout */\n+/* I see no bitfield instructions.  Anyway, the common order is from low\n+   to high, as the power of two, hence little-endian.  */\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+#define FLOAT_WORDS_BIG_ENDIAN 1\n+#define BITS_PER_UNIT 8\n+#define BITS_PER_WORD 64\n+#define UNITS_PER_WORD 8\n+#define POINTER_SIZE 64\n+\n+/* FIXME: This macro is correlated to MAX_FIXED_MODE_SIZE in that\n+   e.g. this macro must not be 8 (default, UNITS_PER_WORD) when\n+   MAX_FIXED_MODE_SIZE is 64 (default, DImode), or really: this must be\n+   set manually if MAX_FIXED_MODE_SIZE is not at least twice the register\n+   size.  By setting it to 4, we don't have to worry about TImode things\n+   yet.  Revisit, perhaps get TImode going or get some solution that does\n+   not mandate TImode or lie in other ways.  */\n+#define MIN_UNITS_PER_WORD 4\n+\n+/* FIXME: Promotion of modes currently generates slow code, extending\n+   before every operation.  */\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\\\n+ do {\t\t\t\t\t\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < 8)\t\t\\\n+   {\t\t\t\t\t\t\\\n+     (MODE) = DImode;\t\t\t\t\\\n+     /* Do the following some time later,\t\\\n+\tscrutinizing differences.  */\t\t\\\n+     if (0) (UNSIGNEDP) = 0;\t\t\t\\\n+   }\t\t\t\t\t\t\\\n+ } while (0)\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+#if 0\n+/* Apparently not doing TRT if int < register-size.  FIXME: Perhaps\n+   FUNCTION_VALUE and LIBCALL_VALUE needs tweaking as some ports say.  */\n+#define PROMOTE_FUNCTION_RETURN\n+#endif\n+\n+/* I'm a little bit undecided about this one.  It might be beneficial to\n+   promote all operations.  */\n+#define PROMOTE_FOR_CALL_ONLY\n+\n+/* We need to align everything to 64 bits that can affect the alignment\n+   of other types.  Since address N is interpreted in MMIX as (N modulo\n+   access_size), we must align.  */\n+#define PARM_BOUNDARY 64\n+#define STACK_BOUNDARY 64\n+#define FUNCTION_BOUNDARY 32\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* This one is only used in the ADA front end.  */\n+#define MINIMUM_ATOMIC_ALIGNMENT 8\n+\n+/* Copied from elfos.h.  */\n+#define MAX_OFILE_ALIGNMENT (32768 * 8)\n+\n+#define DATA_ALIGNMENT(TYPE, BASIC_ALIGN) \\\n+ mmix_data_alignment (TYPE, BASIC_ALIGN)\n+\n+#define CONSTANT_ALIGNMENT(CONSTANT, BASIC_ALIGN) \\\n+ mmix_constant_alignment (CONSTANT, BASIC_ALIGN)\n+\n+#define LOCAL_ALIGNMENT(TYPE, BASIC_ALIGN) \\\n+ mmix_local_alignment (TYPE, BASIC_ALIGN)\n+\n+/* Following other ports, this seems to most commonly be the word-size,\n+   so let's do that here too.  */\n+#define EMPTY_FIELD_BOUNDARY 64\n+\n+/* We chose to have this low solely for similarity with the alpha.  It has\n+   nothing to do with passing the tests dg/c99-scope-2 and\n+   execute/align-1.c.  Nothing.  Though the tests seem wrong.  Padding of\n+   the structure is automatically added to get alignment when needed if we\n+   set this to just byte-boundary.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* The lower bits are ignored.  */\n+#define STRICT_ALIGNMENT 1\n+\n+\n+/* Node: Type Layout */\n+\n+/* It might seem more natural to have 64-bit ints on a 64-bit machine,\n+   but then an occasional MMIX programmer needs to know how to put a lot\n+   of __attribute__ stuff to get to the 8, 16 and 32-bit modes rather\n+   than the \"intuitive\" char, short and int types.  */\n+#define INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* I have no rationale for this other than pointing at Alpha.  */\n+#define\tWCHAR_TYPE \"unsigned int\"\n+#define\tWCHAR_TYPE_SIZE 32\n+\n+\n+/* Node: Register Basics */\n+/* We tell GCC about all 256 general registers, and we also include\n+   rD, rE, rH, rJ and rR (in that order) so we can describe what insns\n+   clobber them.  We use a faked register for the argument pointer.  It is\n+   always eliminated towards the frame-pointer or the stack-pointer, never\n+   output in assembly.  Any fixed register would do for this, like $255,\n+   but future debugging is easier when using a separate register.  It\n+   counts as a global register for pseudorandom reasons.  */\n+#define FIRST_PSEUDO_REGISTER 262\n+\n+/* We treat general registers with no assigned purpose as fixed.  The\n+   stack pointer, $254, is also fixed.  Register $255 is referred to as a\n+   temporary register in the MMIX papers, and used as such in mmixal, so\n+   it should not be used as a stack pointer.  We set it to fixed, and use\n+   it \"manually\" at times of despair.  */\n+#define FIXED_REGISTERS \\\n+ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, \\\n+   1, 1, 0, 0, 0, 1 \\\n+ }\n+\n+/* General registers are fixed and therefore \"historically\" marked\n+   call-used.  (FIXME: This has changed).  Registers $15..$31 are\n+   call-clobbered; we'll put arguments in $16 and up, and we need $15 for\n+   the MMIX register-stack \"hole\".  */\n+#define CALL_USED_REGISTERS \\\n+ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, \\\n+   1, 1, 1, 1, 1, 1 \\\n+ }\n+\n+#define CONDITIONAL_REGISTER_USAGE mmix_conditional_register_usage ()\n+\n+/* No LOCAL_REGNO, INCOMING_REGNO or OUTGOING_REGNO, since those macros\n+   are not usable for MMIX: it doesn't have a fixed register window size.\n+   FIXME: Perhaps we should say something about $0..$15 may sometimes be\n+   the incoming $16..$31.  Those macros need better documentation; it\n+   looks like they're just bogus and that FUNCTION_INCOMING_ARG_REGNO_P\n+   and FUNCTION_OUTGOING_VALUE should be used where they're used.  For the\n+   moment, do nothing; things seem to work anyway.  */\n+\n+\n+/* Node: Allocation Order */\n+\n+/* We should allocate registers from 0 to 31 by increasing number, because\n+   I think that's what people expect.  Beyond that, just use\n+   call-clobbered global registers first, then call-clobbered special\n+   registers.  Last, the fixed registers.  */\n+#define MMIX_MMIXWARE_ABI_REG_ALLOC_ORDER\t\\\n+ { 0, 1, 2, 3, 4, 5, 6, 7,\t\t\t\\\n+   8, 9, 10, 11, 12, 13, 14, 15,\t\t\\\n+   16, 17, 18, 19, 20, 21, 22, 23,\t\t\\\n+   24, 25, 26, 27, 28, 29, 30, 31,    \t\t\\\n+\t\t\t\t\t\t\\\n+   252, 251, 250, 249, 248, 247, \t\t\\\n+   246, 245, 244, 243, 242, 241, 240, 239,\t\\\n+   238, 237, 236, 235, 234, 233, 232, 231,\t\\\n+\t\t\t\t\t\t\\\n+   253,\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+   258, 260, 259,\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+   32, 33, 34, 35, 36, 37, 38, 39,\t\t\\\n+   40, 41, 42, 43, 44, 45, 46, 47,\t\t\\\n+   48, 49, 50, 51, 52, 53, 54, 55,\t\t\\\n+   56, 57, 58, 59, 60, 61, 62, 63,\t\t\\\n+   64, 65, 66, 67, 68, 69, 70, 71,\t\t\\\n+   72, 73, 74, 75, 76, 77, 78, 79,\t\t\\\n+   80, 81, 82, 83, 84, 85, 86, 87,\t\t\\\n+   88, 89, 90, 91, 92, 93, 94, 95,\t\t\\\n+   96, 97, 98, 99, 100, 101, 102, 103,\t\t\\\n+   104, 105, 106, 107, 108, 109, 110, 111,\t\\\n+   112, 113, 114, 115, 116, 117, 118, 119,\t\\\n+   120, 121, 122, 123, 124, 125, 126, 127,\t\\\n+   128, 129, 130, 131, 132, 133, 134, 135,\t\\\n+   136, 137, 138, 139, 140, 141, 142, 143,\t\\\n+   144, 145, 146, 147, 148, 149, 150, 151,\t\\\n+   152, 153, 154, 155, 156, 157, 158, 159,\t\\\n+   160, 161, 162, 163, 164, 165, 166, 167,\t\\\n+   168, 169, 170, 171, 172, 173, 174, 175,\t\\\n+   176, 177, 178, 179, 180, 181, 182, 183,\t\\\n+   184, 185, 186, 187, 188, 189, 190, 191,\t\\\n+   192, 193, 194, 195, 196, 197, 198, 199,\t\\\n+   200, 201, 202, 203, 204, 205, 206, 207,\t\\\n+   208, 209, 210, 211, 212, 213, 214, 215,\t\\\n+   216, 217, 218, 219, 220, 221, 222, 223,\t\\\n+   224, 225, 226, 227, 228, 229, 230, 231,\t\\\n+   254, 255, 256, 257, 261 \t\t\t\\\n+ }\n+\n+/* As a convenience, we put this nearby, for ease of comparison.\n+   First, call-clobbered registers in reverse order of assignment as\n+   parameters (also the top ones; not because they're parameters, but\n+   for continuity).\n+\n+   Second, saved registers that go on the register-stack.\n+\n+   Third, special registers rH, rR and rJ.  They should not normally be\n+   allocated, but since they're call-clobbered, it is cheaper to use one\n+   of them than using a call-saved register for a call-clobbered use,\n+   assuming it is referenced a very limited number of times.  Other global\n+   and fixed registers come next; they are never allocated.  */\n+#define MMIX_GNU_ABI_REG_ALLOC_ORDER\t\t\\\n+{  252, 251, 250, 249, 248, 247, 246,\t\t\\\n+   245, 244, 243, 242, 241, 240, 239, 238,\t\\\n+   237, 236, 235, 234, 233, 232,\t\t\\\n+\t\t\t\t\t\t\\\n+   0, 1, 2, 3, 4, 5, 6, 7,\t\t\t\\\n+   8, 9, 10, 11, 12, 13, 14, 15,\t\t\\\n+   16, 17, 18, 19, 20, 21, 22, 23,\t\t\\\n+   24, 25, 26, 27, 28, 29, 30, 31,\t\t\\\n+\t\t\t\t\t\t\\\n+   253,\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+   258, 260, 259,\t\t\t\t\\\n+\t\t\t\t\t\t\\\n+   32, 33, 34, 35, 36, 37, 38, 39,\t\t\\\n+   40, 41, 42, 43, 44, 45, 46, 47,\t\t\\\n+   48, 49, 50, 51, 52, 53, 54, 55,\t\t\\\n+   56, 57, 58, 59, 60, 61, 62, 63,\t\t\\\n+   64, 65, 66, 67, 68, 69, 70, 71,\t\t\\\n+   72, 73, 74, 75, 76, 77, 78, 79,\t\t\\\n+   80, 81, 82, 83, 84, 85, 86, 87,\t\t\\\n+   88, 89, 90, 91, 92, 93, 94, 95,\t\t\\\n+   96, 97, 98, 99, 100, 101, 102, 103,\t\t\\\n+   104, 105, 106, 107, 108, 109, 110, 111,\t\\\n+   112, 113, 114, 115, 116, 117, 118, 119,\t\\\n+   120, 121, 122, 123, 124, 125, 126, 127,\t\\\n+   128, 129, 130, 131, 132, 133, 134, 135,\t\\\n+   136, 137, 138, 139, 140, 141, 142, 143,\t\\\n+   144, 145, 146, 147, 148, 149, 150, 151,\t\\\n+   152, 153, 154, 155, 156, 157, 158, 159,\t\\\n+   160, 161, 162, 163, 164, 165, 166, 167,\t\\\n+   168, 169, 170, 171, 172, 173, 174, 175,\t\\\n+   176, 177, 178, 179, 180, 181, 182, 183,\t\\\n+   184, 185, 186, 187, 188, 189, 190, 191,\t\\\n+   192, 193, 194, 195, 196, 197, 198, 199,\t\\\n+   200, 201, 202, 203, 204, 205, 206, 207,\t\\\n+   208, 209, 210, 211, 212, 213, 214, 215,\t\\\n+   216, 217, 218, 219, 220, 221, 222, 223,\t\\\n+   224, 225, 226, 227, 228, 229, 230, 231,\t\\\n+   254, 255, 256, 257, 261 \t\t\t\\\n+ }\n+\n+/* The default one.  */\n+#define REG_ALLOC_ORDER MMIX_MMIXWARE_ABI_REG_ALLOC_ORDER\n+\n+/* Node: Values in Registers */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)            \t\\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \t\\\n+    / UNITS_PER_WORD)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Note that no register can really be accessed in single-float mode, so\n+   we *can* say 1 here.  FIXME:  Will TRT happen for single-float, or do\n+   we have to punt to libgcc1.asm?  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+\n+/* Node: Leaf Functions */\n+/* (empty) */\n+\n+\n+/* Node: Register Classes */\n+\n+enum reg_class\n+{\n+  NO_REGS, GENERAL_REGS, REMAINDER_REG, HIMULT_REG,\n+  SYSTEM_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"REMAINDER_REG\", \"HIMULT_REG\",\t\\\n+  \"SYSTEM_REGS\", \"ALL_REGS\"}\n+\n+/* Note that the contents of each item is always 32 bits.  */\n+#define REG_CLASS_CONTENTS\t\t\t\\\n+ {{0, 0, 0, 0, 0, 0, 0, 0, 0},\t\t\t\\\n+  {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 0x20},\t\\\n+  {0, 0, 0, 0, 0, 0, 0, 0, 0x10},\t\t\\\n+  {0, 0, 0, 0, 0, 0, 0, 0, 4},\t\t\t\\\n+  {0, 0, 0, 0, 0, 0, 0, 0, 0x3f},\t\t\\\n+  {~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 0x3f}}\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\\\n+ ((REGNO) <= MMIX_LAST_GENERAL_REGISTER\t\t\t\t\\\n+  || (REGNO) == MMIX_ARG_POINTER_REGNUM\t\t\t\t\\\n+  ? GENERAL_REGS\t\t\t\t\t\t\\\n+  : (REGNO) == MMIX_REMAINDER_REGNUM ? REMAINDER_REG\t\t\\\n+  : (REGNO) == MMIX_HIMULT_REGNUM ? HIMULT_REG : SYSTEM_REGS)\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+#define REG_CLASS_FROM_LETTER(CHAR)\t\t\\\n+ ((CHAR) == 'x' ? SYSTEM_REGS\t\t\t\\\n+  : (CHAR) == 'y' ? REMAINDER_REG\t\t\\\n+  : (CHAR) == 'z' ? HIMULT_REG : NO_REGS)\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+ ((REGNO) <= MMIX_LAST_GENERAL_REGISTER\t\t\t\t\\\n+  || (REGNO) == MMIX_ARG_POINTER_REGNUM\t\t\t\t\\\n+  || (reg_renumber[REGNO] > 0\t\t\t\t\t\\\n+      && reg_renumber[REGNO] <= MMIX_LAST_GENERAL_REGISTER))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P (REGNO)\n+\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n+ mmix_preferred_reload_class (X, CLASS)\n+\n+#define PREFERRED_OUTPUT_RELOAD_CLASS(X, CLASS) \\\n+ mmix_preferred_output_reload_class (X, CLASS)\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n+ mmix_secondary_reload_class (CLASS, MODE, X, 1)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n+ mmix_secondary_reload_class (CLASS, MODE, X, 0)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE) HARD_REGNO_NREGS (CLASS, MODE)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\\\n+ mmix_const_ok_for_letter_p (VALUE, C)\n+\n+#define EXTRA_CONSTRAINT(VALUE, C)\t\\\n+ mmix_extra_constraint (VALUE, C)\n+\n+/* Do we need anything serious here?  Yes, any FLOT constant.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n+ mmix_const_double_ok_for_letter_p (VALUE, C)\n+\n+\n+/* Node: Frame Layout */\n+\n+#define STACK_GROWS_DOWNWARD\n+#define FRAME_GROWS_DOWNWARD\n+\n+#define STARTING_FRAME_OFFSET \\\n+  mmix_starting_frame_offset ()\n+\n+/* There is a stack slot between the frame-pointer and the first\n+   parameter, where the return address is sometimes stored.  FIXME:\n+   Unnecessary.  */\n+#define FIRST_PARM_OFFSET(FUNDECL) 8\n+\n+#define DYNAMIC_CHAIN_ADDRESS(FRAMEADDR) \\\n+ mmix_dynamic_chain_address (FRAMEADDR)\n+\n+/* FIXME: It seems RETURN_ADDR_OFFSET is undocumented.  */\n+\n+#define SETUP_FRAME_ADDRESSES() \\\n+ mmix_setup_frame_addresses ()\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\\\n+ mmix_return_addr_rtx (COUNT, FRAME)\n+\n+/* It's in rJ before we store it somewhere.  */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+ gen_rtx_REG (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM)\n+\n+/* FIXME: This does not seem properly documented or cross-indexed.\n+   Nowhere except in the code does it say it *has* to be in the range\n+   0..255, or else it will be truncated.  That goes for the default too.  */\n+#define DWARF_FRAME_RETURN_COLUMN \\\n+ DWARF_FRAME_REGNUM (MMIX_INCOMING_RETURN_ADDRESS_REGNUM)\n+\n+/* No return address is stored there.  */\n+#define INCOMING_FRAME_SP_OFFSET 0\n+\n+/* Node: Stack Checking */\n+/* (empty) */\n+\n+\n+/* Node: Exception Handling */\n+\n+#define EH_RETURN_DATA_REGNO(N) \\\n+ mmix_eh_return_data_regno (N)\n+\n+#define EH_RETURN_STACKADJ_RTX \\\n+ mmix_eh_return_stackadj_rtx ()\n+\n+#define EH_RETURN_HANDLER_RTX \\\n+ mmix_eh_return_handler_rtx ()\n+\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE, GLOBAL) \\\n+ mmix_asm_preferred_eh_data_format (CODE, GLOBAL)\n+\n+/* Node: Frame Registers */\n+#define STACK_POINTER_REGNUM MMIX_STACK_POINTER_REGNUM\n+\n+/* Perhaps we can use HARD_FRAME_POINTER_REGNUM and decide later on\n+   what register we want to use.  */\n+#define FRAME_POINTER_REGNUM MMIX_FRAME_POINTER_REGNUM\n+#define ARG_POINTER_REGNUM MMIX_ARG_POINTER_REGNUM\n+\n+#define STATIC_CHAIN_REGNUM MMIX_STATIC_CHAIN_REGNUM\n+\n+\n+/* Node: Elimination */\n+/* FIXME: Is this requirement built-in?  Anyway, we should try to get rid\n+   of it; we can deduce the value.  */\n+#define FRAME_POINTER_REQUIRED (nonlocal_goto_stack_level != NULL_RTX)\n+\n+/* The frame-pointer is stored in a location that either counts to the\n+   offset of incoming parameters, or that counts to the offset of the\n+   frame, so we can't use a single offset.  We therefore eliminate those\n+   two separately.  */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+ {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+  {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* We need not worry about when the frame-pointer is required for other\n+   reasons; GCC takes care of those cases.  */\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+ (OFFSET) = mmix_initial_elimination_offset (FROM, TO);\n+\n+\n+/* Node: Stack Arguments */\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACKSIZE) 0\n+\n+\n+/* Node: Register Arguments */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+ mmix_function_arg (&(CUM), MODE, TYPE, NAMED, 0)\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+ mmix_function_arg (&(CUM), MODE, TYPE, NAMED, 1)\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n+ mmix_function_arg_pass_by_reference (&(CUM), MODE, TYPE, NAMED)\n+\n+/* This *sounds* good, but does not seem to be implemented correctly to\n+   be a win; at least it wasn't in 2.7.2.  FIXME: Check and perhaps\n+   replace with a big comment.  */\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) 1\n+\n+typedef struct { int regs; int lib; int now_varargs; } CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\\\n+ ((CUM).regs = 0, (CUM).lib = ((LIBNAME) != 0), (CUM).now_varargs = 0)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((CUM).regs\t\t\t\t\t\t\t\\\n+  = ((MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n+     || (MMIX_FUNCTION_ARG_SIZE (MODE, TYPE) > 8\t\t\\\n+\t && !TARGET_LIBFUNC && !(CUM).lib))\t\t\t\\\n+  ? (MMIX_MAX_ARGS_IN_REGS) + 1\t\t\t\t\t\\\n+  : (CUM).regs + (7 + (MMIX_FUNCTION_ARG_SIZE (MODE, TYPE))) / 8)\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\t\\\n+ mmix_function_arg_regno_p (REGNO, 0)\n+\n+#define FUNCTION_INCOMING_ARG_REGNO_P(REGNO)\t\t\\\n+ mmix_function_arg_regno_p (REGNO, 1)\n+\n+\n+/* Node: Register Arguments */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+ gen_rtx_REG (TYPE_MODE (VALTYPE), MMIX_RETURN_VALUE_REGNUM)\n+\n+/* This needs to take care of the register hole for complex return values.  */\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n+ mmix_function_outgoing_value (VALTYPE, FUNC)\n+\n+#define LIBCALL_VALUE(MODE) \\\n+ gen_rtx_REG (MODE, MMIX_OUTGOING_RETURN_VALUE_REGNUM)\n+\n+#define FUNCTION_VALUE_REGNO_P(REGNO) \\\n+ ((REGNO) == MMIX_OUTGOING_RETURN_VALUE_REGNUM)\n+\n+\n+/* Node: Aggregate Return */\n+\n+#define STRUCT_VALUE_REGNUM MMIX_STRUCT_VALUE_REGNUM\n+\n+\n+/* Node: Caller Saves */\n+/* (empty) */\n+\n+\n+/* Node: Function Entry */\n+\n+/* See mmix.c for TARGET_ASM_FUNCTION_PROLOGUE and\n+   TARGET_ASM_FUNCTION_EPILOGUE.  */\n+\n+/* We need to say that the epilogue uses the return address, so the\n+   initial-value machinery restores it.  FIXME: Some targets\n+   conditionalize on \"reload_completed &&\".  Investigate difference.\n+   FIXME: Not needed if nonlocal_goto_stack_level.  */\n+#define EPILOGUE_USES(REGNO) \\\n+ ((REGNO) == MMIX_INCOMING_RETURN_ADDRESS_REGNUM)\n+\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n+ mmix_asm_output_mi_thunk (FILE, THUNK_FNDECL, DELTA, FUNCTION)\n+\n+\n+/* Node: Profiling */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+ mmix_function_profiler (FILE, LABELNO)\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)\t\\\n+ mmix_function_block_profiler (FILE, LABELNO)\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\\\n+ mmix_block_profiler (FILE, BLOCKNO)\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\\\n+ mmix_function_block_profiler_exit PARAMS ((FILE *));\n+\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\\\n+  __asm__ (\"SAVE $255,0\t\t\\n\\t\"\t\t\\\n+\t   \"SUBU $254,$254,8\t\\n\\t\"\t\t\\\n+ \t   \"STOU $255,$254,0\")\n+\n+#define MACHINE_STATE_RESTORE(ID)\t\t\\\n+  __asm__ (\"LDOU  $255,$254,0\t\\n\\t\"\t\t\\\n+\t   \"UNSAVE $255,0\")\n+\n+\n+\n+/* Node: Varargs */\n+\n+/* For the moment, let's stick to pushing argument registers on the stack.\n+   Later, we can parse all arguments in registers, to improve\n+   performance.  */\n+#define SETUP_INCOMING_VARARGS(A, M, T, P, S)\t\\\n+ mmix_setup_incoming_varargs(&(A), M, T, &(P), S)\n+\n+/* FIXME: This and other EXPAND_BUILTIN_VA_... target macros are not\n+   documented, although used by several targets.  */\n+#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) \\\n+ mmix_expand_builtin_va_arg (VALIST, TYPE)\n+\n+/* Node: Trampolines */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE) \\\n+ mmix_trampoline_template (FILE)\n+\n+#define TRAMPOLINE_SIZE mmix_trampoline_size\n+#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \\\n+ mmix_initialize_trampoline (ADDR, FNADDR, STATIC_CHAIN)\n+\n+\n+/* Node: Library Calls */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+\n+/* Node: Addressing Modes */\n+\n+#define CONSTANT_ADDRESS_P(X) \\\n+ mmix_constant_address_p (X)\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\\\n+ if (mmix_legitimate_address (MODE, X, MMIX_REG_OK_STRICT))\t\\\n+   goto LABEL\n+\n+#ifndef REG_OK_STRICT\n+# define REG_OK_FOR_BASE_P(X)\t\t\t\\\n+  (REGNO (X) <= MMIX_LAST_GENERAL_REGISTER\t\\\n+   || REGNO (X) == MMIX_ARG_POINTER_REGNUM\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+#else\n+# define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#endif /* REG_OK_STRICT */\n+\n+#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n+\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+ mmix_legitimate_constant_p (X)\n+\n+\n+/* Node: Condition Code */\n+\n+#define EXTRA_CC_MODES\t\t\t\t\\\n+ CC(CC_UNSmode, \"CC_UNS\")\t\t\t\\\n+ CC(CC_FPmode, \"CC_FP\")\t\t\t\t\\\n+ CC(CC_FPEQmode, \"CC_FPEQ\")\t\t\t\\\n+ CC(CC_FUNmode, \"CC_FUN\")\n+\n+#define SELECT_CC_MODE(OP, X, Y)\t\t\\\n+ mmix_select_cc_mode (OP, X, Y)\n+\n+#define CANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\\\n+ mmix_canonicalize_comparison (&(CODE), &(OP0), &(OP1));\n+\n+#define REVERSIBLE_CC_MODE(MODE)\t\t\\\n+ mmix_reversible_cc_mode (MODE)\n+\n+\n+/* Node: Costs */\n+\n+/* This one takes on both the RTX_COSTS and CONST_COSTS tasks.  */\n+#define DEFAULT_RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\\\n+   int mmix_rtx_cost;\t\t\t\t\t\t\\\n+   if (mmix_rtx_cost_recalculated (X, CODE, OUTER_CODE, \t\\\n+\t\t\t\t   &mmix_rtx_cost))\t\t\\\n+     return mmix_rtx_cost;\t\t\t\t\t\\\n+ }\n+\n+#define ADDRESS_COST(ADDRESS) mmix_address_cost (ADDRESS)\n+\n+/* The special registers can only move to and from general regs, and we\n+   need to check that their constraints match, so say 3 for them.  */\n+/* WARNING: gcc-2.7.2.2 i686-pc-linux-gnulibc1 (as shipped with RH 4.2)\n+   miscompiles reload1.c:reload_cse_simplify_set; a call to\n+   reload_cse_regno_equal_p is missing when checking if a substitution of\n+   a register setting is valid if this is defined to just the expression\n+   in mmix_register_move_cost.\n+\n+   Symptom: a (all?) register setting is optimized away for e.g.\n+   \"char *p1(char *p) { return p+1; }\" and the value of register zero ($0)\n+   is returned.\n+\n+   We can workaround by making this a function call - unknown if this\n+   causes dire speed effects.  */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO) \\\n+ mmix_register_move_cost (MODE, FROM, TO)\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+\n+/* Node: Sections */\n+\n+/* This must be a constant string, since it's used in crtstuff.c.  */\n+#define TEXT_SECTION_ASM_OP \\\n+ \"\\t.text ! mmixal:= 9H LOC 8B\"\n+\n+/* FIXME: Not documented.  */\n+#define DATA_SECTION_ASM_OP \\\n+ mmix_data_section_asm_op ()\n+\n+/* Stuff copied from elfos.h.  */\n+#define EXTRA_SECTIONS in_const\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\\\n+  CONST_SECTION_FUNCTION\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t.rodata\"\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\\\n+      in_section = in_const;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef  SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, RTX, ALIGN) const_section ()\n+\n+#define SELECT_SECTION(DECL, RELOC, ALIGN) \\\n+ mmix_select_section (DECL, RELOC, ALIGN)\n+\n+#define ENCODE_SECTION_INFO(DECL) \\\n+ mmix_encode_section_info (DECL)\n+\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+ (VAR) = mmix_strip_name_encoding (SYM_NAME)\n+\n+#define UNIQUE_SECTION(DECL, RELOC) \\\n+  mmix_unique_section (decl, reloc)\n+  \n+/* Node: PIC */\n+/* (empty) */\n+\n+\n+/* Node: File Framework */\n+\n+#define ASM_FILE_START(STREAM) \\\n+ mmix_asm_file_start (STREAM)\n+\n+#define ASM_FILE_END(STREAM) \\\n+ mmix_asm_file_end (STREAM)\n+\n+#define ASM_IDENTIFY_GCC(STREAM) \\\n+ mmix_asm_identify_gcc (STREAM)\n+\n+/* While any other punctuation character but \";\" would do, we prefer \"%\"\n+   or \"!\"; \"!\" is an unary operator and so will not be mistakenly included\n+   in correctly formed expressions.  The hash character adds mass; catches\n+   the eye.  We can't have it as a comment char by itself, since it's a\n+   hex-number prefix.  */\n+#define ASM_COMMENT_START \"!#\"\n+\n+/* These aren't currently functional.  We just keep them as markers.  */\n+#define ASM_APP_ON \"%APP\\n\"\n+#define ASM_APP_OFF \"%NO_APP\\n\"\n+\n+#define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME) \\\n+ mmix_asm_output_source_filename (STREAM, NAME)\n+\n+#define OUTPUT_QUOTED_STRING(STREAM, STRING) \\\n+ mmix_output_quoted_string (STREAM, STRING, strlen (STRING))\n+\n+#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE) \\\n+ mmix_asm_output_source_line  (STREAM, LINE)\n+\n+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n+\n+\n+/* Node: Data Output */\n+\n+#define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \\\n+ mmix_asm_output_double (STREAM, &VALUE)\n+\n+#define ASM_OUTPUT_FLOAT(STREAM, VALUE) \\\n+ mmix_asm_output_float (STREAM, &VALUE)\n+\n+#define ASM_OUTPUT_DOUBLE_INT(STREAM, EXP) \\\n+ mmix_asm_output_double_int (STREAM, EXP, 1)\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)\t\t\\\n+ do {\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\tTETRA \");\t\t\t\\\n+  mmix_print_operand (STREAM, EXP, 'L');\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+ } while (0)\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP) \\\n+ do {\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\tWYDE \");\t\t\t\\\n+  mmix_print_operand (STREAM, EXP, 'W');\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+ } while (0)\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP) \\\n+ do {\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\tBYTE \");\t\t\t\\\n+  mmix_print_operand (STREAM, EXP, 'B');\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\\\n+ } while (0)\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE) \\\n+ fprintf (STREAM, \"\\tBYTE %d\\n\", (VALUE) & 255)\n+\n+#define ASM_BYTE_OP \"\\tBYTE\\t\"\n+\n+/* We need these for DWARF2 EH data.  If we don't define them, the\n+   ordinary BYTE, WYDE, TETRA and OCTA will be used, and those are\n+   aligning.  */\n+#define UNALIGNED_SHORT_ASM_OP \"\\t.2byte\\t\"\n+#define UNALIGNED_INT_ASM_OP \"\\t.4byte\\t\"\n+#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.8byte\\t\"\n+\n+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN) \\\n+ mmix_asm_output_ascii (STREAM, PTR, LEN)\n+\n+\n+/* Node: Uninitialized Data */\n+\n+#define ASM_OUTPUT_ALIGNED_COMMON(ST, N, S, A) \\\n+ mmix_asm_output_aligned_common (ST, N, S, A)\n+\n+#define ASM_OUTPUT_ALIGNED_LOCAL(ST, N, S, A) \\\n+ mmix_asm_output_aligned_local (ST, N, S, A)\n+\n+\n+/* Node: Label Output */\n+\n+#define ASM_OUTPUT_LABEL(STREAM, NAME) \\\n+ mmix_asm_output_label (STREAM, NAME)\n+\n+#define ASM_DECLARE_REGISTER_GLOBAL(STREAM, DECL, REGNO, NAME) \\\n+ mmix_asm_declare_register_global (STREAM, DECL, REGNO, NAME)\n+\n+#define ASM_GLOBALIZE_LABEL(STREAM, NAME) \\\n+ mmix_asm_globalize_label (STREAM, NAME)\n+\n+#define ASM_WEAKEN_LABEL(STREAM, NAME) \\\n+ mmix_asm_weaken_label (STREAM, NAME)\n+\n+#define MAKE_DECL_ONE_ONLY(DECL) \\\n+ mmix_make_decl_one_only (DECL)\n+\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n+ mmix_asm_output_labelref (STREAM, NAME)\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM) \\\n+ mmix_asm_output_internal_label (STREAM, PREFIX, NUM)\n+\n+/* We insert a \":\" to disambiguate against user symbols like L5.  */\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM) \\\n+ sprintf (LABEL, \"*%s:%ld\", PREFIX, NUM)\n+\n+/* Insert \"::\"; these are rarer than internal labels.  FIXME: Make sure no\n+   \":\" is seen in the object file; we don't really want that mmixal\n+   feature visible there.  We don't want the default, which uses a dot;\n+   that'd be incompatible with mmixal.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\\\n+ ((OUTPUT) = (char *) alloca (strlen ((NAME)) + 2 + 10),\t\\\n+  sprintf ((OUTPUT), \"%s::%d\", (NAME), (LABELNO)))\n+\n+#define ASM_OUTPUT_DEF(STREAM, NAME, VALUE) \\\n+ mmix_asm_output_def (STREAM, NAME, VALUE)\n+\n+#define ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL(STREAM, SY, HI, LO) \\\n+ mmix_asm_output_define_label_difference_symbol (STREAM, SY, HI, LO)\n+\n+\n+/* Node: Macros for Initialization */\n+/* We're compiling to ELF and linking to MMO; all ELF features that GCC\n+   care for are there.  FIXME: Are they?  */\n+\n+/* These must be constant strings, since they're used in crtstuff.c.  */\n+#define INIT_SECTION_ASM_OP \"\\t.section .init,\\\"ax\\\" ! mmixal-incompatible\"\n+\n+#define FINI_SECTION_ASM_OP \"\\t.section .fini,\\\"ax\\\" ! mmixal-incompatible\"\n+\n+#define OBJECT_FORMAT_ELF\n+\n+\n+/* Node: Instruction Output */\n+\n+/* The non-$ register names must be prefixed with \":\", since they're\n+   affected by PREFIX.  We provide the non-colon names as additional\n+   names.  */\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+ {\"$0\", \"$1\", \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\",\t\t\t\\\n+  \"$8\", \"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\",\t\t\t\\\n+  \"$16\", \"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\",\t\t\\\n+  \"$24\", \"$25\", \"$26\", \"$27\", \"$28\", \"$29\", \"$30\", \"$31\",\t\t\\\n+  \"$32\", \"$33\", \"$34\", \"$35\", \"$36\", \"$37\", \"$38\", \"$39\",\t\t\\\n+  \"$40\", \"$41\", \"$42\", \"$43\", \"$44\", \"$45\", \"$46\", \"$47\",\t\t\\\n+  \"$48\", \"$49\", \"$50\", \"$51\", \"$52\", \"$53\", \"$54\", \"$55\",\t\t\\\n+  \"$56\", \"$57\", \"$58\", \"$59\", \"$60\", \"$61\", \"$62\", \"$63\",\t\t\\\n+  \"$64\", \"$65\", \"$66\", \"$67\", \"$68\", \"$69\", \"$70\", \"$71\",\t\t\\\n+  \"$72\", \"$73\", \"$74\", \"$75\", \"$76\", \"$77\", \"$78\", \"$79\",\t\t\\\n+  \"$80\", \"$81\", \"$82\", \"$83\", \"$84\", \"$85\", \"$86\", \"$87\",\t\t\\\n+  \"$88\", \"$89\", \"$90\", \"$91\", \"$92\", \"$93\", \"$94\", \"$95\",\t\t\\\n+  \"$96\", \"$97\", \"$98\", \"$99\", \"$100\", \"$101\", \"$102\", \"$103\",\t\t\\\n+  \"$104\", \"$105\", \"$106\", \"$107\", \"$108\", \"$109\", \"$110\", \"$111\",\t\\\n+  \"$112\", \"$113\", \"$114\", \"$115\", \"$116\", \"$117\", \"$118\", \"$119\",\t\\\n+  \"$120\", \"$121\", \"$122\", \"$123\", \"$124\", \"$125\", \"$126\", \"$127\",\t\\\n+  \"$128\", \"$129\", \"$130\", \"$131\", \"$132\", \"$133\", \"$134\", \"$135\",\t\\\n+  \"$136\", \"$137\", \"$138\", \"$139\", \"$140\", \"$141\", \"$142\", \"$143\",\t\\\n+  \"$144\", \"$145\", \"$146\", \"$147\", \"$148\", \"$149\", \"$150\", \"$151\",\t\\\n+  \"$152\", \"$153\", \"$154\", \"$155\", \"$156\", \"$157\", \"$158\", \"$159\",\t\\\n+  \"$160\", \"$161\", \"$162\", \"$163\", \"$164\", \"$165\", \"$166\", \"$167\",\t\\\n+  \"$168\", \"$169\", \"$170\", \"$171\", \"$172\", \"$173\", \"$174\", \"$175\",\t\\\n+  \"$176\", \"$177\", \"$178\", \"$179\", \"$180\", \"$181\", \"$182\", \"$183\",\t\\\n+  \"$184\", \"$185\", \"$186\", \"$187\", \"$188\", \"$189\", \"$190\", \"$191\",\t\\\n+  \"$192\", \"$193\", \"$194\", \"$195\", \"$196\", \"$197\", \"$198\", \"$199\",\t\\\n+  \"$200\", \"$201\", \"$202\", \"$203\", \"$204\", \"$205\", \"$206\", \"$207\",\t\\\n+  \"$208\", \"$209\", \"$210\", \"$211\", \"$212\", \"$213\", \"$214\", \"$215\",\t\\\n+  \"$216\", \"$217\", \"$218\", \"$219\", \"$220\", \"$221\", \"$222\", \"$223\",\t\\\n+  \"$224\", \"$225\", \"$226\", \"$227\", \"$228\", \"$229\", \"$230\", \"$231\",\t\\\n+  \"$232\", \"$233\", \"$234\", \"$235\", \"$236\", \"$237\", \"$238\", \"$239\",\t\\\n+  \"$240\", \"$241\", \"$242\", \"$243\", \"$244\", \"$245\", \"$246\", \"$247\",\t\\\n+  \"$248\", \"$249\", \"$250\", \"$251\", \"$252\", \"$253\", \"$254\", \"$255\",\t\\\n+  \":rD\",  \":rE\",  \":rH\",  \":rJ\",  \":rR\",  \"ap_!BAD!\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\\\n+ {{\"sp\", 254}, {\":sp\", 254}, {\"rD\", 256}, {\"rE\", 257},\t\\\n+  {\"rH\", 258}, {\"rJ\", 259}}\n+\n+#define PRINT_OPERAND(STREAM, X, CODE) \\\n+ mmix_print_operand (STREAM, X, CODE)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n+ mmix_print_operand_punct_valid_p (CODE)\n+\n+#define PRINT_OPERAND_ADDRESS(STREAM, X) \\\n+ mmix_print_operand_address (STREAM, X)\n+\n+#if 0\n+#define USER_LABEL_PREFIX \"_\"\n+#endif\n+\n+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO) \\\n+ mmix_asm_output_reg_push (STREAM, REGNO)\n+\n+#define ASM_OUTPUT_REG_POP(STREAM, REGNO) \\\n+ mmix_asm_output_reg_pop (STREAM, REGNO)\n+\n+\n+/* Node: Dispatch Tables */\n+\n+/* We define both types, since SImode is the better, but DImode the only\n+   possible for mmixal so that's the one actually used.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL) \\\n+ mmix_asm_output_addr_diff_elt (STREAM, BODY, VALUE, REL)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n+ mmix_asm_output_addr_vec_elt (STREAM, VALUE)\n+\n+\n+/* FIXME: Add to docs; It is not mentioned at all that\n+   ASM_OUTPUT_ADDR_VEC_ELT is used if relative elements are\n+   used, and that the default expects an undocumented macro\n+   \"ASM_LONG\".  */\n+#define ASM_LONG \"OCTA\"\n+\n+/* Node: Exception Region Output */\n+/* (empty) */\n+\n+/* Node: Alignment Output */\n+\n+#define ASM_OUTPUT_SKIP(STREAM, NBYTES) \\\n+ mmix_asm_output_skip (STREAM, NBYTES)\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n+ mmix_asm_output_align (STREAM, POWER)\n+\n+\n+/* Node: All Debuggers */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+ mmix_dbx_register_number (REGNO)\n+\n+\n+/* Node: DBX Options */\n+/* (empty) */\n+/* Node: DBX Hooks */\n+/* (empty) */\n+/* Node: File Names and DBX */\n+/* (empty) */\n+\n+\n+/* Node: SDB and DWARF */\n+#define DWARF2_DEBUGGING_INFO\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+\n+/* Node: Cross-compilation */\n+\n+/* FIXME: I don't know whether it is best to tweak emit-rtl.c to handle\n+   the case where sizeof (float) == word_size / 2 on the target, or to fix\n+   real.h to define REAL_ARITHMETIC in that case.  Anyway, it should be\n+   documented that a target can define this to force emulation.  Note that\n+   we don't check #ifdef CROSS_COMPILE here; not even if mmix gets\n+   self-hosted must we do that.  Case gcc.c-torture/compile/930611-1.c.  */\n+#define REAL_ARITHMETIC\n+\n+\n+/* Node: Misc */\n+\n+#define PREDICATE_CODES\t\t\t\t\\\n+ {\"mmix_reg_cc_operand\", {SUBREG, REG}},\t\\\n+ {\"mmix_foldable_comparison_operator\",\t\t\\\n+  {NE, EQ, GE, GT, LE, LT}},\t\t\t\\\n+ /* All '<', actually.  */\t\t\t\\\n+ {\"mmix_comparison_operator\",\t\t\t\\\n+  {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU,\t\\\n+   LTU, UNORDERED, ORDERED, UNEQ, UNGE, UNLE,\t\\\n+   UNLT, LTGT}},\t\t\t\t\\\n+ {\"mmix_symbolic_or_address_operand\",\t\t\\\n+  {SYMBOL_REF, LABEL_REF, CONST,\t\t\\\n+   SUBREG, REG, PLUS}},\t\t\t\t\\\n+ {\"mmix_reg_or_constant_operand\",\t\t\\\n+  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\t\\\n+ {\"mmix_reg_or_8bit_or_256_operand\",\t\t\\\n+  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\t\\\n+ {\"mmix_reg_or_8bit_operand\",\t\t\t\\\n+  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\t\\\n+ {\"mmix_reg_or_0_operand\",\t\t\t\\\n+  {CONST_INT, CONST_DOUBLE, SUBREG, REG}},\n+\n+#define SPECIAL_MODE_PREDICATES \"mmix_symbolic_or_address_operand\",\n+\n+/* There's no way to get a PC-relative offset into tables for SImode, so\n+   for the moment we have absolute entries in DImode.\n+   When we're going ELF, these should be SImode and 1.  */\n+#define CASE_VECTOR_MODE DImode\n+#define CASE_VECTOR_PC_RELATIVE 0\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* We have a choice, which makes this yet another parameter to tweak.  The\n+   gut feeling is currently that SIGN_EXTEND wins; \"int\" is more frequent\n+   than \"unsigned int\", and we have signed characters.  FIXME: measure.  */\n+#define LOAD_EXTEND_OP(MODE) (TARGET_ZERO_EXTEND ? ZERO_EXTEND : SIGN_EXTEND)\n+\n+/* Whatever.  I don't really know.  This has worked before.  It's also\n+   what everybody else is using.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+#define MOVE_MAX 8\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We have a choice here too.  */\n+#if 0\n+/* FIXME:  Revisit, we don't have scc expanders yet.  */\n+#define STORE_FLAG_VALUE 1\n+#endif\n+\n+#define Pmode DImode\n+\n+#define FUNCTION_MODE QImode\n+\n+/* When in due time we *will* have some specific headers.  */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+#define HANDLE_SYSV_PRAGMA\n+\n+/* These are checked.  */\n+#define DOLLARS_IN_IDENTIFIERS 0\n+#define NO_DOLLAR_IN_LABEL\n+#define NO_DOT_IN_LABEL\n+\n+#endif /* GCC_MMIX_H */\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "2bdf6e9598bd0f7475eeb47ca18ff8ee0a28f238", "filename": "gcc/config/mmix/mmix.md", "status": "added", "additions": 1187, "deletions": 0, "changes": 1187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,1187 @@\n+;; GCC machine description for MMIX\n+;; Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+;; Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et al.\n+\n+;; Uses of UNSPEC in this file:\n+;; UNSPEC_VOLATILE:\n+;;\n+;;\t0\tsync_icache (sync icache before trampoline jump)\n+;;\t1\tnonlocal_goto_receiver\n+;;\n+\n+;; The order of insns is as in Node: Standard Names, with smaller modes\n+;; before bigger modes.\n+\n+;; FIXME:s\n+;; - Use new formats; e.g. '{' not '\"*{'.\n+;; - define_constants.\n+\n+;; FIXME: Can we remove the reg-to-reg for smaller modes?  Shouldn't they\n+;; be synthesized ok?\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r ,r ,x ,r,r,m,??r\")\n+\t(match_operand:QI 1 \"general_operand\"\t    \"r,LS,K,rI,x,m,r,n\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   %s1 %0,%v1\n+   NEGU %0,0,%n1\n+   PUT %0,%1\n+   GET %0,%1\n+   LDB%U0 %0,%1\n+   STBU %1,%0\n+   %r0%I1\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,x,r,r,m,??r\")\n+\t(match_operand:HI 1 \"general_operand\"\t    \"r,LS,K,r,x,m,r,n\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   %s1 %0,%v1\n+   NEGU %0,0,%n1\n+   PUT %0,%1\n+   GET %0,%1\n+   LDW%U0 %0,%1\n+   STWU %1,%0\n+   %r0%I1\")\n+\n+;; gcc.c-torture/compile/920428-2.c fails if there's no \"n\".\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r ,r ,x,r,r,m,??r\")\n+\t(match_operand:SI 1 \"general_operand\"\t    \"r,LS,K,r,x,m,r,n\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   %s1 %0,%v1\n+   NEGU %0,0,%n1\n+   PUT %0,%1\n+   GET %0,%1\n+   LDT%U0 %0,%1\n+   STTU %1,%0\n+   %r0%I1\")\n+\n+;; We assume all \"s\" are addresses.  Does that hold?\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r ,r ,x,r,m ,r,m,r,??r\")\n+\t(match_operand:DI 1 \"general_operand\"\t    \"r,LS,K,r,x,I,m,r,s,n\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   %s1 %0,%v1\n+   NEGU %0,0,%n1\n+   PUT %0,%1\n+   GET %0,%1\n+   STCO %1,%0\n+   LDO %0,%1\n+   STOU %1,%0\n+   GETA %0,%1\n+   %r0%I1\")\n+\n+;; Note that we move around the float as a collection of bits; no\n+;; conversion to double.\n+(define_insn \"movsf\"\n+ [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,x,r,r,m,??r\")\n+       (match_operand:SF 1 \"general_operand\"\t   \"r,G,r,x,m,r,F\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   SETL %0,0\n+   PUT %0,%1\n+   GET %0,%1\n+   LDT %0,%1\n+   STTU %1,%0\n+   %r0%I1\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,x,r,r,m,??r\")\n+\t(match_operand:DF 1 \"general_operand\"\t    \"r,G,r,x,m,r,F\"))]\n+  \"\"\n+  \"@\n+   SET %0,%1\n+   SETL %0,0\n+   PUT %0,%1\n+   GET %0,%1\n+   LDO %0,%1\n+   STOU %1,%0\n+   %r0%I1\")\n+\f\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\"\t\"=r,r,r\")\n+\t(plus:DI\n+\t (match_operand:DI 1 \"register_operand\" \"%r,r,0\")\n+\t (match_operand:DI 2 \"mmix_reg_or_constant_operand\" \"rI,K,LS\")))]\n+  \"\"\n+  \"@\n+   ADDU %0,%1,%2\n+   SUBU %0,%1,%n2\n+   %i2 %0,%v2\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FADD %0,%1,%2\")\n+\n+;; Insn canonicalization *should* have removed the need for an integer\n+;; in operand 2.\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(minus:DI (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"r,I\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r,r\")))]\n+  \"\"\n+  \"@\n+   SUBU %0,%1,%2\n+   NEGU %0,%1,%2\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FSUB %0,%1,%2\")\n+\n+;; FIXME: Should we define_expand and match 2, 4, 8 (etc) with shift (or\n+;; %{something}2ADDU %0,%1,0)?  Hopefully GCC should still handle it, so\n+;; we don't have to taint the machine description.  If results are bad\n+;; enough, we may have to do it anyway.\n+(define_insn \"muldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(mult:DI (match_operand:DI 1 \"register_operand\" \"%r,r\")\n+\t\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"O,rI\")))\n+   (clobber (match_scratch:DI 3 \"=X,z\"))]\n+  \"\"\n+  \"@\n+   %m2ADDU %0,%1,%1\n+   MULU %0,%1,%2\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FMUL %0,%1,%2\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FDIV %0,%1,%2\")\n+\n+;; FIXME: Is \"frem\" doing the right operation for moddf3?\n+(define_insn \"moddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(mod:DF (match_operand:DF 1 \"register_operand\" \"r\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FREM %0,%1,%2\")\n+\n+;; FIXME: Should we define_expand for smin, smax, umin, umax using a\n+;; nifty conditional sequence?\n+\n+;; FIXME: The cuter andn combinations don't get here, presumably because\n+;; they ended up in the constant pool.  Check: still?\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(and:DI\n+\t (match_operand:DI 1 \"register_operand\" \"%r,0\")\n+\t (match_operand:DI 2 \"mmix_reg_or_constant_operand\" \"rI,NT\")))]\n+  \"\"\n+  \"@\n+   AND %0,%1,%2\n+   %A2 %0,%V2\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(ior:DI (match_operand:DI 1 \"register_operand\" \"%r,0\")\n+\t\t(match_operand:DI 2 \"mmix_reg_or_constant_operand\" \"rH,LS\")))]\n+  \"\"\n+  \"@\n+   OR %0,%1,%2\n+   %o2 %0,%v2\")\n+\n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"XOR %0,%1,%2\")\n+\f\n+;; FIXME:  When TImode works for other reasons (like cross-compiling from\n+;; a 32-bit host), add back umulditi3 and umuldi3_highpart here.\n+\n+;; FIXME: Check what's really reasonable for the mod part.\n+\n+;; One day we might persuade GCC to expand divisions with constants the\n+;; way MMIX does; giving the remainder the sign of the divisor.  But even\n+;; then, it might be good to have an option to divide the way \"everybody\n+;; else\" does.  Perhaps then, this option can be on by default.  Until\n+;; then, we do division and modulus in a library function.\n+\n+(define_insn \"divmoddi4\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=y\")\n+\t(mod:DI (match_dup 1) (match_dup 2)))]\n+  ;; Do the library stuff later.\n+  \"TARGET_KNUTH_DIVISION\"\n+  \"DIV %0,%1,%2\")\n+\n+(define_insn \"udivmoddi4\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+   (set (match_operand:DI 3 \"register_operand\" \"=y\")\n+\t(umod:DI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"DIVU %0,%1,%2\")\n+\n+(define_expand \"divdi3\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t  (div:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+     (clobber (scratch:DI))\n+     (clobber (scratch:DI))])]\n+  \"! TARGET_KNUTH_DIVISION\"\n+  \"\")\n+\n+;; The %2-is-%1-case is there just to make sure things don't fail.  Could\n+;; presumably happen with optimizations off; no evidence.\n+(define_insn \"*divdi3_nonknuth\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,r\")\n+\t(div:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"1,r\")))\n+   (clobber (match_scratch:DI 3 \"=1,1\"))\n+   (clobber (match_scratch:DI 4 \"=2,2\"))]\n+  \"! TARGET_KNUTH_DIVISION\"\n+  \"@\n+   SETL %0,1\n+   XOR $255,%1,%2\\;NEGU %0,0,%2\\;CSN %2,%2,%0\\;NEGU %0,0,%1\\;CSN %1,%1,%0\\;\\\n+DIVU %0,%1,%2\\;NEGU %1,0,%0\\;CSN %0,$255,%1\")\n+\n+(define_expand \"moddi3\"\n+  [(parallel\n+    [(set (match_operand:DI 0 \"register_operand\" \"=&r\")\n+\t  (mod:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"r\")))\n+     (clobber (scratch:DI))\n+     (clobber (scratch:DI))])]\n+  \"! TARGET_KNUTH_DIVISION\"\n+  \"\")\n+\n+;; The %2-is-%1-case is there just to make sure things don't fail.  Could\n+;; presumably happen with optimizations off; no evidence.\n+(define_insn \"*moddi3_nonknuth\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&r,r\")\n+\t(mod:DI (match_operand:DI 1 \"register_operand\" \"r,r\")\n+\t\t(match_operand:DI 2 \"register_operand\" \"1,r\")))\n+   (clobber (match_scratch:DI 3 \"=1,1\"))\n+   (clobber (match_scratch:DI 4 \"=2,2\"))]\n+  \"! TARGET_KNUTH_DIVISION\"\n+  \"@\n+   SETL %0,0\n+   NEGU %0,0,%2\\;CSN %2,%2,%0\\;NEGU $255,0,%1\\;CSN %1,%1,$255\\;\\\n+DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n+\f\n+(define_insn \"ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"SLU %0,%1,%2\")\n+\n+(define_insn \"ashrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DI\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"SR %0,%1,%2\")\n+\n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"SRU %0,%1,%2\")\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"NEGU %0,0,%1\")\n+\n+;; FIXME: GCC should be able to synthesize this by itself as \"0.0 - x\".\n+(define_expand \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(minus:DF (match_dup 2)\n+\t\t(match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"operands[2] = force_reg (DFmode, CONST0_RTX (DFmode));\")\n+\n+;; FIXME: define_expand for absdi2?\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"ANDNH %0,#8000\")\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FSQRT %0,%1\")\n+\n+;; FIXME: define_expand for ffssi2? (not ffsdi2 since int is SImode).\n+\n+(define_insn \"one_cmpldi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"NOR %0,%1,0\")\n+\f\n+;; Since we don't have cc0, we do what is recommended in the manual;\n+;; store away the operands for use in the branch, scc or movcc insn.\n+(define_expand \"cmpdi\"\n+  [(match_operand:DI 0 \"register_operand\" \"\")\n+   (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  mmix_compare_op0 = operands[0];\n+  mmix_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(match_operand:DF 0 \"register_operand\" \"\")\n+   (match_operand:DF 1 \"register_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  mmix_compare_op0 = operands[0];\n+  mmix_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; When the user-patterns expand, the resulting insns will match the\n+;; patterns below.\n+\n+;; We can fold the signed-compare where the register value is\n+;; already equal to (compare:CCTYPE (reg) (const_int 0)).\n+;;  We can't do that at all for floating-point, due to NaN, +0.0\n+;; and -0.0, and we can only do it for the non/zero test of\n+;; unsigned, so that has to be done another way.\n+;;  FIXME: Perhaps a peep2 changing CCcode to a new code, that\n+;; gets folded here.\n+(define_insn \"*cmpcc_folded\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(compare:CC\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (const_int 0)))]\n+  ;; FIXME: Can we test equivalence any other way?\n+  ;; FIXME: Can we fold any other way?\n+  \"REGNO (operands[1]) == REGNO (operands[0])\"\n+  \"%% folded: cmp %0,%1,0\")\n+\n+(define_insn \"*cmpcc\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+\t(compare:CC\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"CMP %0,%1,%2\")\n+\n+(define_insn \"*cmpu\"\n+  [(set (match_operand:CC_UNS 0 \"register_operand\" \"=r\")\n+\t(compare:CC_UNS\n+\t (match_operand:DI 1 \"register_operand\" \"r\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"CMPU %0,%1,%2\")\n+\n+(define_insn \"*fcmp\"\n+  [(set (match_operand:CC_FP 0 \"register_operand\" \"=r\")\n+\t(compare:CC_FP\n+\t (match_operand:DF 1 \"register_operand\" \"r\")\n+\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FCMP%e0 %0,%1,%2\")\n+\n+;; FIXME: for -mieee, add fsub %0,%1,%1\\;fsub %0,%2,%2 before to\n+;; make signalling compliant.\n+(define_insn \"*feql\"\n+  [(set (match_operand:CC_FPEQ 0 \"register_operand\" \"=r\")\n+\t(compare:CC_FPEQ\n+\t (match_operand:DF 1 \"register_operand\" \"r\")\n+\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FEQL%e0 %0,%1,%2\")\n+\n+(define_insn \"*fun\"\n+  [(set (match_operand:CC_FUN 0 \"register_operand\" \"=r\")\n+\t(compare:CC_FUN\n+\t (match_operand:DF 1 \"register_operand\" \"r\")\n+\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"FUN%e0 %0,%1,%2\")\n+\f\n+;; In order to get correct rounding, we have to use SFLOT and SFLOTU for\n+;; conversion.  They do not convert to SFmode; they convert to DFmode,\n+;; with rounding as of SFmode.  They are not usable as is, but we pretend\n+;; we have a single instruction but emit two.\n+\n+;; Note that this will (somewhat unexpectedly) create an inexact\n+;; exception if rounding is necessary - has to be masked off in crt0?\n+(define_expand \"floatdisf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rm\")\n+\t\t   (float:SF\n+\t\t    (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+\t      ;; Let's use a DI scratch, since SF don't generally get into\n+\t      ;; registers.  Dunno what's best; it's really a DF, but that\n+\t      ;; doesn't logically follow from operands in the pattern.\n+\t      (clobber (match_scratch:DI 2 \"=&r\"))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n+    {\n+      rtx stack_slot;\n+\n+      /* FIXME: This stack-slot remains even at -O3.  There must be a\n+\t better way.  */\n+      stack_slot\n+\t= validize_mem (assign_stack_temp (SFmode,\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+      emit_insn (gen_floatdisf2 (stack_slot, operands[1]));\n+      emit_move_insn (operands[0], stack_slot);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*floatdisf2_real\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(float:SF\n+\t (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+   (clobber (match_scratch:DI 2 \"=&r\"))]\n+  \"\"\n+  \"SFLOT %2,%1\\;STSF %2,%0\")\n+\n+(define_expand \"floatunsdisf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rm\")\n+\t\t   (unsigned_float:SF\n+\t\t    (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+\t      ;; Let's use a DI scratch, since SF don't generally get into\n+\t      ;; registers.  Dunno what's best; it's really a DF, but that\n+\t      ;; doesn't logically follow from operands in the pattern.\n+\t      (clobber (scratch:DI))])]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n+    {\n+      rtx stack_slot;\n+\n+      /* FIXME: This stack-slot remains even at -O3.  Must be a better\n+\t way.  */\n+      stack_slot\n+\t= validize_mem (assign_stack_temp (SFmode,\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+      emit_insn (gen_floatunsdisf2 (stack_slot, operands[1]));\n+      emit_move_insn (operands[0], stack_slot);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*floatunsdisf2_real\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(unsigned_float:SF\n+\t (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))\n+   (clobber (match_scratch:DI 2 \"=&r\"))]\n+  \"\"\n+  \"SFLOTU %2,%1\\;STSF %2,%0\")\n+\n+;; Note that this will (somewhat unexpectedly) create an inexact\n+;; exception if rounding is necessary - has to be masked off in crt0?\n+(define_insn \"floatdidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float:DF\n+\t (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"FLOT %0,%1\")\n+\n+(define_insn \"floatunsdidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(unsigned_float:DF\n+\t (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"\"\n+  \"FLOTU %0,%1\")\n+\n+(define_insn \"ftruncdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(fix:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  ;; ROUND_OFF\n+  \"FINT %0,1,%1\")\n+\n+;; Note that this will (somewhat unexpectedly) create an inexact\n+;; exception if rounding is necessary - has to be masked off in crt0?\n+(define_insn \"fix_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  ;; ROUND_OFF\n+  \"FIX %0,1,%1\")\n+\n+(define_insn \"fixuns_truncdfdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unsigned_fix:DI\n+\t (fix:DF (match_operand:DF 1 \"register_operand\" \"r\"))))]\n+  \"\"\n+  ;; ROUND_OFF\n+  \"FIXU %0,1,%1\")\n+\n+;; It doesn't seem like it's possible to have memory_operand as a\n+;; predicate here (testcase: libgcc2 floathisf).  FIXME:  Shouldn't it be\n+;; possible to do that?  Bug in GCC?  Anyway, this used to be a simple\n+;; pattern with a memory_operand predicate, but was split up with a\n+;; define_expand with the old pattern as \"anonymous\".\n+;; FIXME: Perhaps with SECONDARY_MEMORY_NEEDED?\n+(define_expand \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n+\t(fix:SF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n+    {\n+      /* FIXME: There should be a way to say: 'put this in operands[0]\n+\t but *after* the expanded insn'.  */\n+      rtx stack_slot;\n+\n+      /* There is no sane destination but a register here, if it wasn't\n+\t already MEM.  (It's too hard to get fatal_insn to work here.)  */\n+      if (! REG_P (operands[0]))\n+\tinternal_error (\\\"MMIX Internal: Bad truncdfsf2 expansion\\\");\n+\n+      /* FIXME: This stack-slot remains even at -O3.  Must be a better\n+\t way.  */\n+      stack_slot\n+\t= validize_mem (assign_stack_temp (SFmode,\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+      emit_insn (gen_truncdfsf2 (stack_slot, operands[1]));\n+      emit_move_insn (operands[0], stack_slot);\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*truncdfsf2_real\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(fix:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"STSF %1,%0\")\n+\n+;; Same comment as for truncdfsf2.\n+(define_expand \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float_extend:DF (match_operand:SF 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n+    {\n+      rtx stack_slot;\n+\n+      /* There is no sane destination but a register here, if it wasn't\n+\t already MEM.  (It's too hard to get fatal_insn to work here.)  */\n+      if (! REG_P (operands[0]))\n+\tinternal_error (\\\"MMIX Internal: Bad extendsfdf2 expansion\\\");\n+\n+      /* FIXME: This stack-slot remains even at -O3.  There must be a\n+\t better way.  */\n+      stack_slot\n+\t= validize_mem (assign_stack_temp (SFmode,\n+\t\t\t\t\t   GET_MODE_SIZE (SFmode), 0));\n+      emit_move_insn (stack_slot, operands[1]);\n+      emit_insn (gen_extendsfdf2 (operands[0], stack_slot));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*extendsfdf2_real\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float_extend:DF (match_operand:SF 1 \"memory_operand\" \"m\")))]\n+  \"\"\n+  \"LDSF %0,%1\")\n+\f\n+;; Neither sign-extend nor zero-extend are necessary; gcc knows how to\n+;; synthesize using shifts or and, except with a memory source and not\n+;; completely optimal.  FIXME: Actually, other bugs surface when those\n+;; patterns are defined; fix later.\n+\n+;; There are no sane values with the bit-patterns of (int) 0..255 except\n+;; 0 to use in movdfcc.\n+\n+(define_expand \"movdfcc\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(if_then_else:DF\n+\t (match_operand 1 \"comparison_operator\" \"\")\n+\t (match_operand:DF 2 \"mmix_reg_or_0_operand\" \"\")\n+\t (match_operand:DF 3 \"mmix_reg_or_0_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx cc_reg = mmix_gen_compare_reg (code, mmix_compare_op0,\n+\t\t\t\t     mmix_compare_op1);\n+  if (cc_reg == NULL_RTX)\n+    FAIL;\n+  operands[1] = gen_rtx (code, VOIDmode, cc_reg, const0_rtx);\n+}\")\n+\n+(define_expand \"movdicc\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(if_then_else:DI\n+\t (match_operand 1 \"comparison_operator\" \"\")\n+\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"\")\n+\t (match_operand:DI 3 \"mmix_reg_or_8bit_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx cc_reg = mmix_gen_compare_reg (code, mmix_compare_op0,\n+\t\t\t\t     mmix_compare_op1);\n+  if (cc_reg == NULL_RTX)\n+    FAIL;\n+  operands[1] = gen_rtx (code, VOIDmode, cc_reg, const0_rtx);\n+}\")\n+\n+;; FIXME: Is this the right way to do \"folding\" of CCmode -> DImode?\n+(define_insn \"*movdicc_real_foldable\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(if_then_else:DI\n+\t (match_operator 2 \"mmix_foldable_comparison_operator\"\n+\t\t\t [(match_operand 3 \"register_operand\" \"r,r,r,r\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI, 0  ,rI,GM\")\n+\t (match_operand:DI 4 \"mmix_reg_or_8bit_operand\" \"0  ,rI,GM ,rI\")))]\n+  \"\"\n+  \"@\n+   CS%d2 %0,%3,%1\n+   CS%D2 %0,%3,%4\n+   ZS%d2 %0,%3,%1\n+   ZS%D2 %0,%3,%4\")\n+\n+(define_insn \"*movdicc_real\"\n+  [(set\n+    (match_operand:DI 0 \"register_operand\"\t   \"=r\t,r ,r  ,r\")\n+    (if_then_else:DI\n+     (match_operator\n+      2 \"mmix_comparison_operator\"\n+      [(match_operand 3 \"mmix_reg_cc_operand\"\t    \"r\t,r ,r  ,r\")\n+      (const_int 0)])\n+     (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI, 0 ,rI, GM\")\n+     (match_operand:DI 4 \"mmix_reg_or_8bit_operand\" \"0\t,rI,GM ,rI\")))]\n+  \"\"\n+  \"@\n+   CS%d2 %0,%3,%1\n+   CS%D2 %0,%3,%4\n+   ZS%d2 %0,%3,%1\n+   ZS%D2 %0,%3,%4\")\n+\n+(define_insn \"*movdfcc_real_foldable\"\n+  [(set\n+    (match_operand:DF 0 \"register_operand\"\t\"=r  ,r  ,r  ,r\")\n+    (if_then_else:DF\n+     (match_operator\n+      2 \"mmix_foldable_comparison_operator\"\n+      [(match_operand 3 \"register_operand\"\t \"r  ,r  ,r  ,r\")\n+      (const_int 0)])\n+     (match_operand:DF 1 \"mmix_reg_or_0_operand\" \"rGM,0  ,rGM,GM\")\n+     (match_operand:DF 4 \"mmix_reg_or_0_operand\" \"0  ,rGM,GM ,rGM\")))]\n+  \"\"\n+  \"@\n+   CS%d2 %0,%3,%1\n+   CS%D2 %0,%3,%4\n+   ZS%d2 %0,%3,%1\n+   ZS%D2 %0,%3,%4\")\n+\n+(define_insn \"*movdfcc_real\"\n+  [(set\n+    (match_operand:DF 0 \"register_operand\"\t\"=r  ,r  ,r  ,r\")\n+    (if_then_else:DF\n+     (match_operator\n+      2 \"mmix_comparison_operator\"\n+      [(match_operand 3 \"mmix_reg_cc_operand\"\t \"r  ,r  ,r  ,r\")\n+      (const_int 0)])\n+     (match_operand:DF 1 \"mmix_reg_or_0_operand\" \"rGM,0  ,rGM,GM\")\n+     (match_operand:DF 4 \"mmix_reg_or_0_operand\" \"0  ,rGM,GM ,rGM\")))]\n+  \"\"\n+  \"@\n+   CS%d2 %0,%3,%1\n+   CS%D2 %0,%3,%4\n+   ZS%d2 %0,%3,%1\n+   ZS%D2 %0,%3,%4\")\n+\n+;; FIXME: scc patterns will probably help, I just skip them\n+;; right now.  Revisit.\n+\f\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (EQ, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (NE, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (GT, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (LE, mmix_compare_op0, mmix_compare_op1);\n+\n+  /* The head comment of optabs.c:can_compare_p says we're required to\n+     implement this, so we have to clean up the mess here. */\n+  if (operands[1] == NULL_RTX)\n+    {\n+      /* FIXME: Watch out for sharing/unsharing of rtx:es.  */\n+      emit_jump_insn ((*bcc_gen_fctn[(int) LT]) (operands[0]));\n+      emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (operands[0]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (GE, mmix_compare_op0, mmix_compare_op1);\n+\n+  /* The head comment of optabs.c:can_compare_p says we're required to\n+     implement this, so we have to clean up the mess here. */\n+  if (operands[1] == NULL_RTX)\n+    {\n+      /* FIXME: Watch out for sharing/unsharing of rtx:es.  */\n+      emit_jump_insn ((*bcc_gen_fctn[(int) GT]) (operands[0]));\n+      emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (operands[0]));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (LT, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (GTU, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (LEU, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (GEU, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (LTU, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+(define_expand \"bunordered\"\n+  [(set (pc)\n+\t(if_then_else (unordered (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (UNORDERED, mmix_compare_op0, mmix_compare_op1);\n+\n+  if (operands[1] == NULL_RTX)\n+    FAIL;\n+}\")\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+\t(if_then_else (ordered (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1]\n+    = mmix_gen_compare_reg (ORDERED, mmix_compare_op0, mmix_compare_op1);\n+}\")\n+\n+;; FIXME: we can emit an unordered-or-*not*-equal compare in one insn, but\n+;; there's no RTL code for it.  Maybe revisit in future.\n+\n+;; FIXME: Non/probable branches? Check for REG_BR_PROB note on the jump\n+;; insn and emit 'P' where suitable *and measure*.\n+;; FIXME: Odd/Even matchers?\n+(define_insn \"*bCC_foldable\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"mmix_foldable_comparison_operator\"\n+\t\t\t [(match_operand 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"B%d1 %2,%0\")\n+\n+(define_insn \"*bCC\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"mmix_comparison_operator\"\n+\t\t\t [(match_operand 2 \"mmix_reg_cc_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"B%d1 %2,%0\")\n+\n+(define_insn \"*bCC_inverted_foldable\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"mmix_foldable_comparison_operator\"\n+\t\t\t [(match_operand 2 \"register_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+;; REVERSIBLE_CC_MODE is checked by mmix_foldable_comparison_operator.\n+  \"\"\n+  \"B%D1 %2,%0\")\n+\n+(define_insn \"*bCC_inverted\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"mmix_comparison_operator\"\n+\t\t\t [(match_operand 2 \"mmix_reg_cc_operand\" \"r\")\n+\t\t\t  (const_int 0)])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"REVERSIBLE_CC_MODE (GET_MODE (operands[2]))\"\n+  \"B%D1 %2,%0\")\n+\f\n+(define_expand \"call\"\n+  [(parallel [(call (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t    (match_operand 1 \"general_operand\" \"\"))\n+\t      (use (match_operand 2 \"general_operand\" \"\"))\n+\t      (clobber (match_dup 4))])\n+   (set (match_dup 4) (match_dup 3))]\n+  \"\"\n+  \"\n+{\n+  /* Since the epilogue 'uses' the return address, and it is clobbered\n+     in the call, and we set it back after every call (all but one setting\n+     will be optimized away), integrity is maintained.  */\n+  operands[3]\n+    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+\n+  /* FIXME: There's a bug in gcc which causes NULL to be passed as\n+     operand[2] when we get out of registers, which later confuses gcc.\n+     Work around it by replacing it with const_int 0.  Possibly documentation\n+     error too.  */\n+  if (operands[2] == NULL_RTX)\n+    operands[2] = const0_rtx;\n+  operands[4] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+}\")\n+\n+(define_expand \"call_value\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand 2 \"general_operand\" \"\")))\n+\t      (use (match_operand 3 \"general_operand\" \"\"))\n+\t      (clobber (match_dup 5))])\n+   (set (match_dup 5) (match_dup 4))]\n+  \"\"\n+  \"\n+{\n+  /* Since the epilogue 'uses' the return address, and it is clobbered\n+     in the call, and we set it back after every call (all but one setting\n+     will be optimized away), integrity is maintained.  */\n+  operands[4]\n+    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+\n+  /* FIXME: See 'call'.  */\n+  if (operands[3] == NULL_RTX)\n+    operands[3] = const0_rtx;\n+\n+  /* FIXME: Documentation bug: operands[3] (operands[2] for 'call') is the\n+     *next* argument register, not the number of arguments in registers.  */\n+  cfun->machine->has_call_value_without_parameters\n+    |= REG_P (operands[3]) && REGNO (operands[3]) == MMIX_FIRST_ARG_REGNUM;\n+\n+  operands[5] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+}\")\n+\n+;; Don't use 'p' here.  A 'p' must stand first in constraints, or reload\n+;; messes up, not registering the address for reload.  Several C++\n+;; test-cases, including g++.brendan/crash40.C.  FIXME: This is arguably a\n+;; bug in gcc.  Note line ~2612 in reload.c, that does things on the\n+;; condition <<else if (constraints[i][0] == 'p')>> and the comment on\n+;; ~3017 that says:\n+;; <<   case 'p':\n+;;\t     /* All necessary reloads for an address_operand\n+;;\t        were handled in find_reloads_address.  */>>\n+;; Sorry, I have not dug deeper.  If symbolic addresses are used\n+;; rarely compared to addresses in registers, disparaging the\n+;; first (\"p\") alternative by adding ? in the first operand\n+;; might do the trick.  We define 'U' as a synonym to 'p', but without the\n+;; caveats (and vary small advantages) of 'p'.\n+(define_insn \"*call_real\"\n+  [(call (mem:QI\n+\t  (match_operand:DI 0 \"mmix_symbolic_or_address_operand\" \"s,rU\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   ;; 259 is rJ (We can't use the symbolic name here.  FIXME: Yes we can.)\n+   (clobber (reg:DI 259))]\n+  \"\"\n+  \"@\n+   PUSHJ $%p2,%0\n+   PUSHGO $%p2,%a0\")\n+\n+(define_insn \"*call_value_real\"\n+  [(set (match_operand 0 \"register_operand\" \"=r,r\")\n+\t(call (mem:QI\n+\t       (match_operand:DI 1 \"mmix_symbolic_or_address_operand\" \"s,rU\"))\n+\t      (match_operand 2 \"\" \"\")))\n+  (use (match_operand 3 \"\" \"\"))\n+  ;; 259 is rJ (We can't use the symbolic name here.  FIXME: Yes we can.)\n+  (clobber (reg:DI 259))]\n+  \"\"\n+  \"@\n+   PUSHJ $%p3,%1\n+   PUSHGO $%p3,%a1\")\n+\n+;; I hope untyped_call and untyped_return are not needed for MMIX.\n+;; Users of Objective C will notice.\n+\n+;; FIXME:  Add \"return\" pattern where the epilogue is just \"pop\n+;; 0,0\" or similar.\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"SWYM 0,0,0\")\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"JMP %0\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"GO $255,%a0\")\n+\n+;; FIXME: This is just a jump, and should be expanded to one.\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:DI 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"GO $255,%a0\")\n+\n+;; The only peculiar thing is that the register stack has to be unwound at\n+;; nonlocal_goto_receiver.  At each function that has a nonlocal label, we\n+;; save at function entry the location of the \"alpha\" register stack\n+;; pointer, rO, in stack slot known to that function (right below where\n+;; the frame-pointer would be located).\n+;; In the nonlocal goto receiver, we unwind the register stack by a series\n+;; of \"pop 0,0\" until rO equals the saved value.  (If it goes lower, we\n+;; should call abort.)\n+(define_expand \"nonlocal_goto_receiver\"\n+  [(parallel [(unspec_volatile [(match_dup 0)] 1)\n+\t      (clobber (scratch:DI))\n+\t      (clobber (reg:DI 259))])\n+   (set (reg:DI 259) (match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  rtx tem\n+    = validize_mem (gen_rtx_MEM (Pmode,\n+\t\t\t\t plus_constant (frame_pointer_rtx, -24)));\n+  operands[0] = XEXP (tem, 0);\n+  operands[1]\n+    = get_hard_reg_initial_val (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+\n+  /* Mark this function as containing a landing-pad.  */\n+  cfun->machine->has_landing_pad = 1;\n+}\")\n+\n+;; FIXME: Do we need to keep this in memory?  Can GCC counter our\n+;; expectations and use saved registers to keep the slot address in,\n+;; \"across\" the exception or goto?  Anyway, we need to make sure the value\n+;; ends up in a non-local register, so best is to load it ourselves.\n+(define_insn \"*nonlocal_goto_receiver_expanded\"\n+  [(unspec_volatile [(match_operand:DI 0 \"address_operand\" \"p\")] 1)\n+   (clobber (match_scratch:DI 1 \"=&r\"))\n+   (clobber (reg:DI 259))]\n+  \"\"\n+  \"GETA $255,0f\\;PUT rJ,$255\\;LDOU $255,%a0\\n\\\n+0: GET %1,rO\\;CMPU %1,%1,$255\\;BNP %1,1f\\;POP 0,0\\n1:\")\n+\f\n+(define_insn \"*Naddu\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:DI 2 \"const_int_operand\" \"n\"))\n+\t       (match_operand:DI 3 \"mmix_reg_or_8bit_operand\" \"rI\")))]\n+  \"GET_CODE (operands[2]) == CONST_INT\n+   && (INTVAL (operands[2]) == 2\n+       || INTVAL (operands[2]) == 4\n+       || INTVAL (operands[2]) == 8\n+       || INTVAL (operands[2]) == 16)\"\n+  \"%2ADDU %0,%1,%3\")\n+\n+(define_insn \"*andn\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t (not:DI (match_operand:DI 1 \"mmix_reg_or_8bit_operand\" \"rI\"))\n+\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"ANDN %0,%2,%1\")\n+\n+(define_insn \"*nand\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI\n+\t (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n+\t (not:DI (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\"))))]\n+  \"\"\n+  \"NAND %0,%1,%2\")\n+\n+(define_insn \"*nor\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t (not:DI (match_operand:DI 1 \"register_operand\" \"%r\"))\n+\t (not:DI (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\"))))]\n+  \"\"\n+  \"NOR %0,%1,%2\")\n+\n+(define_insn \"*nxor\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(not:DI\n+\t (xor:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"mmix_reg_or_8bit_operand\" \"rI\"))))]\n+  \"\"\n+  \"NXOR %0,%1,%2\")\n+\n+(define_insn \"sync_icache\"\n+  [(unspec_volatile [(match_operand:DI 0 \"memory_operand\" \"m\")\n+\t\t     (match_operand:DI 1 \"const_int_operand\" \"I\")] 0)]\n+  \"\"\n+  \"SYNCID %1,%0\")\n+\n+;; Local Variables:\n+;; mode: lisp\n+;; indent-tabs-mode: t\n+;; End:"}, {"sha": "13e2362804950ea570e43949c474d24968533842", "filename": "gcc/config/mmix/t-mmix", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Ft-mmix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fconfig%2Fmmix%2Ft-mmix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Ft-mmix?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -0,0 +1,20 @@\n+# See \"Target Fragment\" in GCC info.  That same order is used here.\n+LIBGCC1 =\n+\n+# libgcc1-test doesn't work.  There's critical stuff in crti and crtn and\n+# we know the result of running libgcc1-test anyway.\n+LIBGCC1_TEST =\n+CROSS_LIBGCC1 =\n+\n+TARGET_LIBGCC2_CFLAGS = -mlibfuncs -Dinhibit_libc -O2\n+\n+EXTRA_MULTILIB_PARTS = crti.o crtn.o crtbegin.o crtend.o\n+\n+MULTILIB_OPTIONS = mabi=gnu\n+MULTILIB_DIRNAMES = gnuabi\n+\n+$(T)crti.o: $(srcdir)/config/mmix/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crti.o -x assembler-with-cpp $(srcdir)/config/mmix/crti.asm\n+\n+$(T)crtn.o: $(srcdir)/config/mmix/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) -c -o crtn.o -x assembler-with-cpp $(srcdir)/config/mmix/crtn.asm"}, {"sha": "76a8cf21780f10ea8a7aa5b202df041ca52bd623", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -384,8 +384,8 @@ NeXT, Inc.@: donated the front end that supports the Objective-C\n language.\n \n @item\n-Hans-Peter Nilsson for the CRIS port, improvements to the search engine\n-setup, various documentation fixes and other small fixes.\n+Hans-Peter Nilsson for the CRIS and MMIX ports, improvements to the search\n+engine setup, various documentation fixes and other small fixes.\n \n @item\n Geoff Noer for this work on getting cygwin native builds working."}, {"sha": "fa897506a9c28b68d62d3805aaf7413beec6a179", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcf684c7a5ef5e899562a0a3621d51ed6b673265/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bcf684c7a5ef5e899562a0a3621d51ed6b673265", "patch": "@@ -574,6 +574,12 @@ in the following sections.\n -mno-callgraph-data  -mslow-bytes  -mno-slow-bytes  -mno-lsim @gol\n -mlittle-endian  -mbig-endian  -m210  -m340  -mstack-increment}\n \n+@emph{MMIX Options}\n+@gccoptlist{\n+-mlibfuncs -mno-libfuncs -mepsilon -mno-epsilon -mabi=gnu @gol\n+-mabi=mmixware -mzero-extend -mknuthdiv -mtoplevel-symbols @gol\n+-melf}\n+\n @emph{IA-64 Options}\n @gccoptlist{\n -mbig-endian  -mlittle-endian  -mgnu-as  -mgnu-ld  -mno-pic @gol\n@@ -5116,6 +5122,7 @@ that macro, which enables you to change the defaults.\n * D30V Options::\n * S/390 and zSeries Options::\n * CRIS Options::\n+* MMIX Options::\n @end menu\n \n @node M680x0 Options\n@@ -9633,6 +9640,52 @@ Like @option{-sim}, but pass linker options to locate initialized data at\n 0x40000000 and zero-initialized data at 0x80000000.\n @end table\n \n+@node MMIX Options\n+@subsection MMIX Options\n+@cindex MMIX Options\n+\n+These options are defined for the MMIX:\n+\n+@table @code\n+@item -mlibfuncs\n+@itemx -mno-libfuncs\n+Specify that intrinsic library functions are being compiled, passing all\n+values in registers, no matter the size.\n+\n+@item -mepsilon\n+@itemx -mno-epsilon\n+Generate floating-point comparison instructions that compare with respect\n+to the @code{rE} epsilon register.\n+\n+@item -mabi=mmixware\n+@itemx -mabi=gnu\n+Generate code that passes function parameters and return values that (in\n+the called function) are seen as registers @code{$0} and up, as opposed to\n+the GNU ABI which uses global registers @code{$231} and up.\n+\n+@item -mzero-extend\n+@item -mno-zero-extend\n+When reading data from memory in sizes shorter than 64 bits, use (do not\n+use) zero-extending load instructions by default, rather than\n+sign-extending ones.\n+\n+@item -mknuthdiv\n+@itemx -mno-knuthdiv\n+Make the result of a division yielding a remainder have the same sign as\n+the divisor.  With the default, @option{-mno-knuthdiv}, the sign of the\n+result follows the sign of the dividend.  Both methods are arithmetically\n+valid, the latter being almost exclusively used.\n+\n+@item -mtoplevel-symbols\n+@itemx -mno-toplevel-symbols\n+Prepend (do not prepend) a @code{:} to all global symbols, so the assembly\n+code can be used with the @code{PREFIX} assembly directive.\n+\n+@item -melf\n+Generate an executable in the @samp{ELF} format, rather than the default\n+@samp{mmo} format used by the @command{mmix} simulator.\n+@end table\n+\n \n @node Code Gen Options\n @section Options for Code Generation Conventions"}]}