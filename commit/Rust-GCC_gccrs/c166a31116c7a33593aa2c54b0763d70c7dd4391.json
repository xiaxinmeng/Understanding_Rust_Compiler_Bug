{"sha": "c166a31116c7a33593aa2c54b0763d70c7dd4391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE2NmEzMTExNmM3YTMzNTkzYWEyYzU0YjA3NjNkNzBjN2RkNDM5MQ==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:15:06Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-07-06T20:15:06Z"}, "message": "entered into RCS\n\nFrom-SVN: r1476", "tree": {"sha": "4ab72bd153a36b9459a8c41247387a25bab2d88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab72bd153a36b9459a8c41247387a25bab2d88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c166a31116c7a33593aa2c54b0763d70c7dd4391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c166a31116c7a33593aa2c54b0763d70c7dd4391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c166a31116c7a33593aa2c54b0763d70c7dd4391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c166a31116c7a33593aa2c54b0763d70c7dd4391/comments", "author": null, "committer": null, "parents": [{"sha": "373666321abc0c92b292160fbb328a991d205940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373666321abc0c92b292160fbb328a991d205940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/373666321abc0c92b292160fbb328a991d205940"}], "stats": {"total": 159, "additions": 106, "deletions": 53}, "files": [{"sha": "839a15528a5da02ea3c8094c8b2464d6db546cff", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -655,7 +655,7 @@ constrain_asm_operands (n_operands, operands, operand_constraints,\n \t\t/* Match any CONST_DOUBLE, but only if\n \t\t   we can examine the bits of it reliably.  */\n \t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t\t    && GET_CODE (op) != VOIDmode && ! flag_pretend_float)\n \t\t  break;\n \t\tif (GET_CODE (op) == CONST_DOUBLE)\n@@ -1160,7 +1160,7 @@ record_reg_life (insn, block, regstack)\n       int n_inputs, n_outputs;\n       char **constraints = (char **) alloca (n_operands * sizeof (char *));\n \n-      decode_asm_operands (body, operands, 0, constraints, 0);\n+      decode_asm_operands (body, operands, NULL_PTR, constraints, NULL_PTR);\n       get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n       record_asm_reg_life (insn, regstack, operands, constraints,\n \t\t\t   n_inputs, n_outputs);\n@@ -2383,15 +2383,16 @@ subst_stack_regs (insn, regstack)\n \t  char **constraints\n \t    = (char **) alloca (n_operands * sizeof (char *));\n \n-\t  decode_asm_operands (body, operands, operands_loc, constraints, 0);\n+\t  decode_asm_operands (body, operands, operands_loc,\n+\t\t\t       constraints, NULL_PTR);\n \t  get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n \t  subst_asm_stack_regs (insn, regstack, operands, operands_loc,\n \t\t\t\tconstraints, n_inputs, n_outputs);\n \t  return;\n \t}\n \n       if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\tfor (i = 0; i < XVECLEN (PATTERN (insn) , 0); i++)\n+\tfor (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t  {\n \t    if (stack_regs_mentioned_p (XVECEXP (PATTERN (insn), 0, i)))\n \t      subst_stack_regs_pat (insn, regstack,"}, {"sha": "7b646c3573ec2d853d60b650f03c8030d557e471", "filename": "gcc/rtl.c", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -36,6 +36,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n extern struct obstack *rtl_obstack;\n \n extern long ftell();\n+\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+extern long atol();\n+#endif\n \f\n /* Indexed by rtx code, gives number of operands for an rtx with that code.\n    Does NOT include rtx header data (code and links).\n@@ -136,6 +140,8 @@ char *rtx_format[] = {\n      \"i\" an integer\n          prints the integer\n      \"n\" like \"i\", but prints entries from `note_insn_name'\n+     \"w\" an integer of width HOST_BITS_PER_WIDE_INT\n+         prints the integer\n      \"s\" a pointer to a string\n          prints the string\n      \"S\" like \"s\", but optional:\n@@ -282,6 +288,7 @@ copy_rtx (orig)\n \t    XEXP (copy, i) = copy_rtx (XEXP (orig, i));\n \t  break;\n \n+\tcase '0':\n \tcase 'u':\n \t  XEXP (copy, i) = XEXP (orig, i);\n \t  break;\n@@ -297,9 +304,21 @@ copy_rtx (orig)\n \t    }\n \t  break;\n \n-\tdefault:\n+\tcase 'w':\n+\t  XWINT (copy, i) = XWINT (orig, i);\n+\t  break;\n+\n+\tcase 'i':\n \t  XINT (copy, i) = XINT (orig, i);\n \t  break;\n+\n+\tcase 's':\n+\tcase 'S':\n+\t  XSTR (copy, i) = XSTR (orig, i);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   return copy;\n@@ -355,6 +374,7 @@ copy_most_rtx (orig, may_share)\n \t    XEXP (copy, i) = copy_most_rtx (XEXP (orig, i), may_share);\n \t  break;\n \n+\tcase '0':\n \tcase 'u':\n \t  XEXP (copy, i) = XEXP (orig, i);\n \t  break;\n@@ -371,9 +391,22 @@ copy_most_rtx (orig, may_share)\n \t    }\n \t  break;\n \n-\tdefault:\n+\tcase 'w':\n+\t  XWINT (copy, i) = XWINT (orig, i);\n+\t  break;\n+\n+\tcase 'n':\n+\tcase 'i':\n \t  XINT (copy, i) = XINT (orig, i);\n \t  break;\n+\n+\tcase 's':\n+\tcase 'S':\n+\t  XSTR (copy, i) = XSTR (orig, i);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   return copy;\n@@ -500,6 +533,7 @@ read_rtx (infile)\n   rtx return_rtx;\n   register int c;\n   int tmp_int;\n+  HOST_WIDE_INT tmp_wide;\n \n   /* Linked list structure for making RTXs: */\n   struct rtx_list\n@@ -612,8 +646,7 @@ read_rtx (infile)\n \t    }\n \t  /* get vector length and allocate it */\n \t  XVEC (return_rtx, i) = (list_counter\n-\t\t\t\t  ? rtvec_alloc (list_counter)\n-\t\t\t\t  : (struct rtvec_def *) NULL);\n+\t\t\t\t  ? rtvec_alloc (list_counter) : NULL_RTVEC);\n \t  if (list_counter > 0)\n \t    {\n \t      next_rtx = list_rtx;\n@@ -684,6 +717,16 @@ read_rtx (infile)\n \t}\n \tbreak;\n \n+      case 'w':\n+\tread_name (tmp_char, infile);\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\ttmp_wide = atoi (tmp_char);\n+#else\n+\ttmp_wide = atol (tmp_char);\n+#endif\n+\tXWINT (return_rtx, i) = tmp_wide;\n+\tbreak;\n+\n       case 'i':\n       case 'n':\n \tread_name (tmp_char, infile);\n@@ -737,7 +780,7 @@ init_rtl ()\n       /* Set the GET_RTX_FORMAT of CONST_DOUBLE to a string\n \t of as many `i's as we now have elements.  */\n       for (i = 0; i < rtx_length[(int) CONST_DOUBLE]; i++)\n-\t*s++ = 'i';\n+\t*s++ = 'w';\n       *s++ = 0;\n     }\n #endif"}, {"sha": "8ccae191f00e33a00b3f498dffc218042303ddce", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -1,5 +1,5 @@\n /* Analyze RTL for C-Compiler\n-   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -184,7 +184,7 @@ rtx_addr_varies_p (x)\n    Only obvious integer terms are detected.\n    This is used in cse.c with the `related_value' field.*/\n \n-int\n+HOST_WIDE_INT\n get_integer_term (x)\n      rtx x;\n {\n@@ -561,7 +561,7 @@ find_last_value (x, pinsn, valid_to)\n     if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n       {\n \trtx set = single_set (p);\n-\trtx note = find_reg_note (p, REG_EQUAL, 0);\n+\trtx note = find_reg_note (p, REG_EQUAL, NULL_RTX);\n \n \tif (set && rtx_equal_p (x, SET_DEST (set)))\n \t  {\n@@ -735,7 +735,7 @@ reg_overlap_mentioned_p (x, in)\n   endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n \n-  return refers_to_regno_p (regno, endregno, in, 0);\n+  return refers_to_regno_p (regno, endregno, in, NULL_PTR);\n }\n \f\n /* Used for communications between the next few functions.  */\n@@ -886,6 +886,11 @@ rtx_equal_p (x, y)\n     {\n       switch (fmt[i])\n \t{\n+\tcase 'w':\n+\t  if (XWINT (x, i) != XWINT (y, i))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'n':\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))"}, {"sha": "7c4ef96b3cf39d1008153792dc863fcef18d4068", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -86,9 +86,9 @@ variable_size (size)\n     }\n \n   if (immediate_size_expand)\n-    expand_expr (size, 0, VOIDmode, 0);\n+    expand_expr (size, NULL_PTR, VOIDmode, 0);\n   else\n-    pending_sizes = tree_cons (0, size, pending_sizes);\n+    pending_sizes = tree_cons (NULL_TREE, size, pending_sizes);\n \n   return size;\n }\n@@ -280,7 +280,7 @@ layout_record (rec)\n \n       if (TREE_STATIC (field))\n \t{\n-\t  pending_statics = tree_cons (NULL, field, pending_statics);\n+\t  pending_statics = tree_cons (NULL_TREE, field, pending_statics);\n \t  continue;\n \t}\n       /* Enumerators and enum types which are local to this class need not\n@@ -873,14 +873,18 @@ make_signed_type (precision)\n   /* Create the extreme values based on the number of bits.  */\n \n   TYPE_MIN_VALUE (type)\n-    = build_int_2 ((precision-HOST_BITS_PER_INT > 0 ? 0 : (-1)<<(precision-1)),\n-\t\t   (-1)<<(precision-HOST_BITS_PER_INT-1 > 0\n-\t\t\t  ? precision-HOST_BITS_PER_INT-1\n-\t\t\t  : 0));\n+    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t    ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n+\t\t   (((HOST_WIDE_INT) (-1)\n+\t\t     << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t\t ? precision-HOST_BITS_PER_WIDE_INT - 1\n+\t\t\t : 0))));\n   TYPE_MAX_VALUE (type)\n-    = build_int_2 ((precision-HOST_BITS_PER_INT > 0 ? -1 : (1<<(precision-1))-1),\n-\t\t   (precision-HOST_BITS_PER_INT-1 > 0\n-\t\t    ? (1<<(precision-HOST_BITS_PER_INT-1))-1\n+    = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0 \n+\t\t    ? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n+\t\t   (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t    ? (((HOST_WIDE_INT) 1\n+\t\t\t<< (precision - HOST_BITS_PER_INT - 1)))-1\n \t\t    : 0));\n \n   /* Give this type's extreme values this type as their type.  */\n@@ -937,10 +941,12 @@ fixup_unsigned_type (type)\n \n   TYPE_MIN_VALUE (type) = build_int_2 (0, 0);\n   TYPE_MAX_VALUE (type)\n-    = build_int_2 (precision-HOST_BITS_PER_INT >= 0 ? -1 : (1<<precision)-1,\n-\t\t   precision-HOST_BITS_PER_INT > 0\n-\t\t   ? ((unsigned) ~0\n-\t\t      >> (HOST_BITS_PER_INT - (precision - HOST_BITS_PER_INT)))\n+    = build_int_2 (precision - HOST_BITS_PER_WIDE_INT >= 0\n+\t\t   ? -1 : ((HOST_WIDE_INT) 1<< precision) - 1,\n+\t\t   precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t   ? ((unsigned HOST_WIDE_INT) ~0\n+\t\t      >> (HOST_BITS_PER_WIDE_INT\n+\t\t\t  - (precision - HOST_BITS_PER_WIDE_INT)))\n \t\t   : 0);\n   TREE_TYPE (TYPE_MIN_VALUE (type)) = type;\n   TREE_TYPE (TYPE_MAX_VALUE (type)) = type;"}, {"sha": "f8c2fca0647a1c9ee2e57a009b1cb1363b64cd2e", "filename": "gcc/unroll.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -783,15 +783,14 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t     improperly shared rtl.  */\n \n \t  diff = expand_binop (mode, sub_optab, copy_rtx (final_value),\n-\t\t\t       copy_rtx (initial_value), 0, 0,\n+\t\t\t       copy_rtx (initial_value), NULL_RTX, 0,\n \t\t\t       OPTAB_LIB_WIDEN);\n \n \t  /* Now calculate (diff % (unroll * abs (increment))) by using an\n \t     and instruction.  */\n \t  diff = expand_binop (GET_MODE (diff), and_optab, diff,\n-\t\t\t       gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\tunroll_number * abs_inc - 1),\n-\t\t\t       0, 0, OPTAB_LIB_WIDEN);\n+\t\t\t       GEN_INT (unroll_number * abs_inc - 1),\n+\t\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \n \t  /* Now emit a sequence of branches to jump to the proper precond\n \t     loop entry point.  */\n@@ -826,9 +825,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t      else\n \t\tcmp_const = i;\n \n-\t      emit_cmp_insn (diff, gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t\t    abs_inc * cmp_const),\n-\t\t\t     EQ, 0, mode, 0, 0);\n+\t      emit_cmp_insn (diff, GEN_INT (abs_inc * cmp_const),\n+\t\t\t     EQ, NULL_RTX, mode, 0, 0);\n \n \t      if (i == 0)\n \t\temit_jump_insn (gen_beq (labels[i]));\n@@ -858,8 +856,8 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t      else\n \t\tcmp_const = abs_inc * (unroll_number - 1) + 1;\n \n-\t      emit_cmp_insn (diff, gen_rtx (CONST_INT, VOIDmode, cmp_const),\n-\t\t\t     EQ, 0, mode, 0, 0);\n+\t      emit_cmp_insn (diff, GEN_INT (cmp_const), EQ, NULL_RTX,\n+\t\t\t     mode, 0, 0);\n \n \t      if (neg_inc)\n \t\temit_jump_insn (gen_ble (labels[0]));\n@@ -1178,7 +1176,7 @@ precondition_loop_p (initial_value, final_value, increment, loop_start,\n     {\n       *initial_value = const0_rtx;\n       *increment = const1_rtx;\n-      *final_value = gen_rtx (CONST_INT, VOIDmode, loop_n_iterations);\n+      *final_value = GEN_INT (loop_n_iterations);\n \n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n@@ -1583,8 +1581,7 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n #endif\n \t\t  \n \t\t  splittable_regs[regno]\n-\t\t    = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t       INTVAL (giv_inc)\n+\t\t    = GEN_INT (INTVAL (giv_inc)\n \t\t\t       + INTVAL (splittable_regs[regno]));\n \t\t  giv_inc = splittable_regs[regno];\n \t\t  \n@@ -2391,7 +2388,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t       /* Check for the case where the pseudo is set by a shift/add\n \t\t  sequence, in which case the first insn setting the pseudo\n \t\t  is the first insn of the shift/add sequence.  */\n-\t       && (! (tem = find_reg_note (v->insn, REG_RETVAL, 0))\n+\t       && (! (tem = find_reg_note (v->insn, REG_RETVAL, NULL_RTX))\n \t\t   || (regno_first_uid[REGNO (v->dest_reg)]\n \t\t       != INSN_UID (XEXP (tem, 0)))))\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n@@ -2785,8 +2782,7 @@ final_biv_value (bl, loop_start, loop_end)\n \t     case it is needed later.  */\n \n \t  tem = gen_reg_rtx (bl->biv->mode);\n-\t  emit_iv_add_mult (increment,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, loop_n_iterations),\n+\t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n \t\t\t    bl->initial_value, tem, NEXT_INSN (loop_end));\n \n \t  if (loop_dump_stream)\n@@ -2877,8 +2873,7 @@ final_giv_value (v, loop_start, loop_end)\n \n \t  /* Put the final biv value in tem.  */\n \t  tem = gen_reg_rtx (bl->biv->mode);\n-\t  emit_iv_add_mult (increment,\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, loop_n_iterations),\n+\t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n \t\t\t    bl->initial_value, tem, insert_before);\n \n \t  /* Subtract off extra increments as we find them.  */\n@@ -2904,7 +2899,7 @@ final_giv_value (v, loop_start, loop_end)\n \t\t  \n \t\t  start_sequence ();\n \t\t  tem = expand_binop (GET_MODE (tem), sub_optab, tem,\n-\t\t\t\t      XEXP (SET_SRC (pattern), 1), 0, 0,\n+\t\t\t\t      XEXP (SET_SRC (pattern), 1), NULL_RTX, 0,\n \t\t\t\t      OPTAB_LIB_WIDEN);\n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n@@ -2947,14 +2942,15 @@ final_giv_value (v, loop_start, loop_end)\n /* Calculate the number of loop iterations.  Returns the exact number of loop\n    iterations if it can be calculated, otherwise returns zero.  */\n \n-unsigned long\n+unsigned HOST_WIDE_INT\n loop_iterations (loop_start, loop_end)\n      rtx loop_start, loop_end;\n {\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n   enum rtx_code comparison_code;\n-  int i, increment_dir;\n+  HOST_WIDE_INT i;\n+  int increment_dir;\n   int unsigned_compare, compare_dir, final_larger;\n   unsigned long tempu;\n   rtx last_loop_insn;\n@@ -3044,7 +3040,7 @@ loop_iterations (loop_start, loop_end)\n \t\t   && (set = single_set (insn))\n \t\t   && (SET_DEST (set) == comparison_value))\n \t    {\n-\t      rtx note = find_reg_note (insn, REG_EQUAL, 0);\n+\t      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n \t      if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n \t\tcomparison_value = XEXP (note, 0);\n@@ -3094,11 +3090,13 @@ loop_iterations (loop_start, loop_end)\n   /* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */\n   if (unsigned_compare)\n     final_larger\n-      = ((unsigned) INTVAL (final_value) > (unsigned) INTVAL (initial_value)) -\n-\t((unsigned) INTVAL (final_value) < (unsigned) INTVAL (initial_value));\n+      = ((unsigned HOST_WIDE_INT) INTVAL (final_value)\n+\t > (unsigned HOST_WIDE_INT) INTVAL (initial_value))\n+\t- ((unsigned HOST_WIDE_INT) INTVAL (final_value)\n+\t   < (unsigned HOST_WIDE_INT) INTVAL (initial_value));\n   else\n-    final_larger = (INTVAL (final_value) > INTVAL (initial_value)) -\n-      (INTVAL (final_value) < INTVAL (initial_value));\n+    final_larger = (INTVAL (final_value) > INTVAL (initial_value))\n+      - (INTVAL (final_value) < INTVAL (initial_value));\n \n   if (INTVAL (increment) > 0)\n     increment_dir = 1;"}, {"sha": "a7875ebece4162f3bcf8f7a379eb09501579e856", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c166a31116c7a33593aa2c54b0763d70c7dd4391/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=c166a31116c7a33593aa2c54b0763d70c7dd4391", "patch": "@@ -359,7 +359,7 @@ xcoffout_block (block, depth, args)\n \t  next_block_number++;\n \n \t  /* Output the subblocks.  */\n-\t  xcoffout_block (BLOCK_SUBBLOCKS (block), depth + 1, 0);\n+\t  xcoffout_block (BLOCK_SUBBLOCKS (block), depth + 1, NULL_TREE);\n \t}\n       block = BLOCK_CHAIN (block);\n     }"}]}