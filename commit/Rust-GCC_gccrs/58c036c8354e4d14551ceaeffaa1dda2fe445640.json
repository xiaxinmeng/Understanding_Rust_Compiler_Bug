{"sha": "58c036c8354e4d14551ceaeffaa1dda2fe445640", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjMDM2YzgzNTRlNGQxNDU1MWNlYWVmZmFhMWRkYTJmZTQ0NTY0MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-18T15:36:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-18T15:36:10Z"}, "message": "Add optabs for accelerating RAW and WAR alias checks\n\nThis patch adds optabs that check whether a read followed by a write\nor a write followed by a read can be divided into interleaved byte\naccesses without changing the dependencies between the bytes.\nThis is one of the uses of the SVE2 WHILERW and WHILEWR instructions.\n(The instructions can also be used to limit the VF at runtime,\nbut that's future work.)\n\n2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (vect_check_ptrs): Document.\n\t* optabs.def (check_raw_ptrs_optab, check_war_ptrs_optab): New optabs.\n\t* doc/md.texi: Document them.\n\t* internal-fn.def (IFN_CHECK_RAW_PTRS, IFN_CHECK_WAR_PTRS): New\n\tinternal functions.\n\t* internal-fn.h (internal_check_ptrs_fn_supported_p): Declare.\n\t* internal-fn.c (check_ptrs_direct): New macro.\n\t(expand_check_ptrs_optab_fn): Likewise.\n\t(direct_check_ptrs_optab_supported_p): Likewise.\n\t(internal_check_ptrs_fn_supported_p): New fuction.\n\t* tree-data-ref.c: Include internal-fn.h.\n\t(create_ifn_alias_checks): New function.\n\t(create_intersect_range_checks): Use it.\n\t* config/aarch64/iterators.md (SVE2_WHILE_PTR): New int iterator.\n\t(optab, cmp_op): Handle it.\n\t(raw_war, unspec): New int attributes.\n\t* config/aarch64/aarch64.md (UNSPEC_WHILERW, UNSPEC_WHILE_WR): New\n\tconstants.\n\t* config/aarch64/predicates.md (aarch64_bytes_per_sve_vector_operand):\n\tNew predicate.\n\t* config/aarch64/aarch64-sve2.md (check_<raw_war>_ptrs<mode>): New\n\texpander.\n\t(@aarch64_sve2_while<cmp_op><GPI:mode><PRED_ALL:mode>_ptest): New\n\tpattern.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_check_ptrs):\n\tNew procedure.\n\t* gcc.dg/vect/vect-alias-check-14.c: Expect IFN_CHECK_WAR to be\n\tused, if available.\n\t* gcc.dg/vect/vect-alias-check-15.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-16.c: Likewise IFN_CHECK_RAW.\n\t* gcc.target/aarch64/sve2/whilerw_1.c: New test.\n\t* gcc.target/aarch64/sve2/whilewr_1.c: Likewise.\n\t* gcc.target/aarch64/sve2/whilewr_2.c: Likewise.\n\nFrom-SVN: r278414", "tree": {"sha": "c4f41c8fbb38f8a7e7be198e099f370ebd20789b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4f41c8fbb38f8a7e7be198e099f370ebd20789b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c036c8354e4d14551ceaeffaa1dda2fe445640", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c036c8354e4d14551ceaeffaa1dda2fe445640", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c036c8354e4d14551ceaeffaa1dda2fe445640", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c036c8354e4d14551ceaeffaa1dda2fe445640/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78930e4b4867c0558cf347778591a67a0b235ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78930e4b4867c0558cf347778591a67a0b235ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78930e4b4867c0558cf347778591a67a0b235ca0"}], "stats": {"total": 376, "additions": 372, "deletions": 4}, "files": [{"sha": "c57e8c4008497bd3d23dae259ab7483ddb356895", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -1,3 +1,30 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/sourcebuild.texi (vect_check_ptrs): Document.\n+\t* optabs.def (check_raw_ptrs_optab, check_war_ptrs_optab): New optabs.\n+\t* doc/md.texi: Document them.\n+\t* internal-fn.def (IFN_CHECK_RAW_PTRS, IFN_CHECK_WAR_PTRS): New\n+\tinternal functions.\n+\t* internal-fn.h (internal_check_ptrs_fn_supported_p): Declare.\n+\t* internal-fn.c (check_ptrs_direct): New macro.\n+\t(expand_check_ptrs_optab_fn): Likewise.\n+\t(direct_check_ptrs_optab_supported_p): Likewise.\n+\t(internal_check_ptrs_fn_supported_p): New fuction.\n+\t* tree-data-ref.c: Include internal-fn.h.\n+\t(create_ifn_alias_checks): New function.\n+\t(create_intersect_range_checks): Use it.\n+\t* config/aarch64/iterators.md (SVE2_WHILE_PTR): New int iterator.\n+\t(optab, cmp_op): Handle it.\n+\t(raw_war, unspec): New int attributes.\n+\t* config/aarch64/aarch64.md (UNSPEC_WHILERW, UNSPEC_WHILE_WR): New\n+\tconstants.\n+\t* config/aarch64/predicates.md (aarch64_bytes_per_sve_vector_operand):\n+\tNew predicate.\n+\t* config/aarch64/aarch64-sve2.md (check_<raw_war>_ptrs<mode>): New\n+\texpander.\n+\t(@aarch64_sve2_while<cmp_op><GPI:mode><PRED_ALL:mode>_ptest): New\n+\tpattern.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree.c (build_vector_from_ctor): Directly return a zero vector for"}, {"sha": "106a9a015abe7d44ffcebcc8b41f29d96f937c81", "filename": "gcc/config/aarch64/aarch64-sve2.md", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve2.md?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -331,3 +331,61 @@\n   }\n   [(set_attr \"movprfx\" \"*,yes\")]\n )\n+\n+;; Use WHILERW and WHILEWR to accelerate alias checks.  This is only\n+;; possible if the accesses we're checking are exactly the same size\n+;; as an SVE vector.\n+(define_expand \"check_<raw_war>_ptrs<mode>\"\n+  [(match_operand:GPI 0 \"register_operand\")\n+   (unspec:VNx16BI\n+     [(match_operand:GPI 1 \"register_operand\")\n+      (match_operand:GPI 2 \"register_operand\")\n+      (match_operand:GPI 3 \"aarch64_bytes_per_sve_vector_operand\")\n+      (match_operand:GPI 4 \"const_int_operand\")]\n+     SVE2_WHILE_PTR)]\n+  \"TARGET_SVE2\"\n+{\n+  /* Use the widest predicate mode we can.  */\n+  unsigned int align = INTVAL (operands[4]);\n+  if (align > 8)\n+    align = 8;\n+  machine_mode pred_mode = aarch64_sve_pred_mode (align).require ();\n+\n+  /* Emit a WHILERW or WHILEWR, setting the condition codes based on\n+     the result.  */\n+  emit_insn (gen_aarch64_sve2_while_ptest\n+\t     (<SVE2_WHILE_PTR:unspec>, <MODE>mode, pred_mode,\n+\t      gen_rtx_SCRATCH (pred_mode), operands[1], operands[2],\n+\t      CONSTM1_RTX (VNx16BImode), CONSTM1_RTX (pred_mode)));\n+\n+  /* Set operand 0 to true if the last bit of the predicate result is set,\n+     i.e. if all elements are free of dependencies.  */\n+  rtx cc_reg = gen_rtx_REG (CC_NZCmode, CC_REGNUM);\n+  rtx cmp = gen_rtx_LTU (<MODE>mode, cc_reg, const0_rtx);\n+  emit_insn (gen_aarch64_cstore<mode> (operands[0], cmp, cc_reg));\n+  DONE;\n+})\n+\n+;; A WHILERW or WHILEWR in which only the flags result is interesting.\n+(define_insn_and_rewrite \"@aarch64_sve2_while<cmp_op><GPI:mode><PRED_ALL:mode>_ptest\"\n+  [(set (reg:CC_NZC CC_REGNUM)\n+\t(unspec:CC_NZC\n+\t  [(match_operand 3)\n+\t   (match_operand 4)\n+\t   (const_int SVE_KNOWN_PTRUE)\n+\t   (unspec:PRED_ALL\n+\t     [(match_operand:GPI 1 \"register_operand\" \"r\")\n+\t      (match_operand:GPI 2 \"register_operand\" \"r\")]\n+\t     SVE2_WHILE_PTR)]\n+\t  UNSPEC_PTEST))\n+   (clobber (match_scratch:PRED_ALL 0 \"=Upa\"))]\n+  \"TARGET_SVE2\"\n+  \"while<cmp_op>\\t%0.<PRED_ALL:Vetype>, %x1, %x2\"\n+  ;; Force the compiler to drop the unused predicate operand, so that we\n+  ;; don't have an unnecessary PTRUE.\n+  \"&& (!CONSTANT_P (operands[3]) || !CONSTANT_P (operands[4]))\"\n+  {\n+    operands[3] = CONSTM1_RTX (VNx16BImode);\n+    operands[4] = CONSTM1_RTX (<PRED_ALL:MODE>mode);\n+  }\n+)"}, {"sha": "87e9b9364bdcc783e444bf5ade20b473706367ee", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -245,6 +245,8 @@\n     UNSPEC_WHILE_LO\n     UNSPEC_WHILE_LS\n     UNSPEC_WHILE_LT\n+    UNSPEC_WHILERW\n+    UNSPEC_WHILEWR\n     UNSPEC_LDN\n     UNSPEC_STN\n     UNSPEC_INSR"}, {"sha": "83a0d156e84baf7dde8f9e46eeeca4edfa1f9037", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -2077,6 +2077,8 @@\n (define_int_iterator SVE_WHILE [UNSPEC_WHILE_LE UNSPEC_WHILE_LO\n \t\t\t\tUNSPEC_WHILE_LS UNSPEC_WHILE_LT])\n \n+(define_int_iterator SVE2_WHILE_PTR [UNSPEC_WHILERW UNSPEC_WHILEWR])\n+\n (define_int_iterator SVE_SHIFT_WIDE [UNSPEC_ASHIFT_WIDE\n \t\t\t\t     UNSPEC_ASHIFTRT_WIDE\n \t\t\t\t     UNSPEC_LSHIFTRT_WIDE])\n@@ -2157,6 +2159,8 @@\n \t\t\t(UNSPEC_FEXPA \"fexpa\")\n \t\t\t(UNSPEC_FTSMUL \"ftsmul\")\n \t\t\t(UNSPEC_FTSSEL \"ftssel\")\n+\t\t\t(UNSPEC_WHILERW \"vec_check_raw_alias\")\n+\t\t\t(UNSPEC_WHILEWR \"vec_check_war_alias\")\n \t\t\t(UNSPEC_COND_FABS \"abs\")\n \t\t\t(UNSPEC_COND_FADD \"add\")\n \t\t\t(UNSPEC_COND_FCADD90 \"cadd90\")\n@@ -2480,13 +2484,18 @@\n \t\t\t (UNSPEC_WHILE_LE \"le\")\n \t\t\t (UNSPEC_WHILE_LO \"lo\")\n \t\t\t (UNSPEC_WHILE_LS \"ls\")\n-\t\t\t (UNSPEC_WHILE_LT \"lt\")])\n+\t\t\t (UNSPEC_WHILE_LT \"lt\")\n+\t\t\t (UNSPEC_WHILERW \"rw\")\n+\t\t\t (UNSPEC_WHILEWR \"wr\")])\n \n (define_int_attr while_optab_cmp [(UNSPEC_WHILE_LE \"le\")\n \t\t\t\t  (UNSPEC_WHILE_LO \"ult\")\n \t\t\t\t  (UNSPEC_WHILE_LS \"ule\")\n \t\t\t\t  (UNSPEC_WHILE_LT \"lt\")])\n \n+(define_int_attr raw_war [(UNSPEC_WHILERW \"raw\")\n+\t\t\t  (UNSPEC_WHILEWR \"war\")])\n+\n (define_int_attr brk_op [(UNSPEC_BRKA \"a\") (UNSPEC_BRKB \"b\")\n \t\t\t (UNSPEC_BRKN \"n\")\n \t\t\t (UNSPEC_BRKPA \"pa\") (UNSPEC_BRKPB \"pb\")])\n@@ -2630,3 +2639,6 @@\n \t\t\t\t(UNSPEC_REVB \"16\")\n \t\t\t\t(UNSPEC_REVH \"32\")\n \t\t\t\t(UNSPEC_REVW \"64\")])\n+\n+(define_int_attr unspec [(UNSPEC_WHILERW \"UNSPEC_WHILERW\")\n+\t\t\t (UNSPEC_WHILEWR \"UNSPEC_WHILEWR\")])"}, {"sha": "232361235349c629be962885a133ebfe2dc0279e", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -869,3 +869,8 @@\n \n (define_predicate \"aarch64_sve_any_binary_operator\"\n   (match_code \"plus,minus,mult,div,udiv,smax,umax,smin,umin,and,ior,xor\"))\n+\n+(define_predicate \"aarch64_bytes_per_sve_vector_operand\"\n+  (and (match_code \"const_int,const_poly_int\")\n+       (match_test \"known_eq (wi::to_poly_wide (op, mode),\n+\t\t\t      BYTES_PER_SVE_VECTOR)\")))"}, {"sha": "0ad4a00739fff54fa95e91e25329a424afcc4b0f", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -5076,6 +5076,37 @@ for (i = 1; i < GET_MODE_NUNITS (@var{n}); i++)\n   operand0[i] = operand0[i - 1] && (operand1 + i < operand2);\n @end smallexample\n \n+@cindex @code{check_raw_ptrs@var{m}} instruction pattern\n+@item @samp{check_raw_ptrs@var{m}}\n+Check whether, given two pointers @var{a} and @var{b} and a length @var{len},\n+a write of @var{len} bytes at @var{a} followed by a read of @var{len} bytes\n+at @var{b} can be split into interleaved byte accesses\n+@samp{@var{a}[0], @var{b}[0], @var{a}[1], @var{b}[1], @dots{}}\n+without affecting the dependencies between the bytes.  Set operand 0\n+to true if the split is possible and false otherwise.\n+\n+Operands 1, 2 and 3 provide the values of @var{a}, @var{b} and @var{len}\n+respectively.  Operand 4 is a constant integer that provides the known\n+common alignment of @var{a} and @var{b}.  All inputs have mode @var{m}.\n+\n+This split is possible if:\n+\n+@smallexample\n+@var{a} == @var{b} || @var{a} + @var{len} <= @var{b} || @var{b} + @var{len} <= @var{a}\n+@end smallexample\n+\n+You should only define this pattern if the target has a way of accelerating\n+the test without having to do the individual comparisons.\n+\n+@cindex @code{check_war_ptrs@var{m}} instruction pattern\n+@item @samp{check_war_ptrs@var{m}}\n+Like @samp{check_raw_ptrs@var{m}}, but with the read and write swapped round.\n+The split is possible in this case if:\n+\n+@smallexample\n+@var{b} <= @var{a} || @var{a} + @var{len} <= @var{b}\n+@end smallexample\n+\n @cindex @code{vec_cmp@var{m}@var{n}} instruction pattern\n @item @samp{vec_cmp@var{m}@var{n}}\n Output a vector comparison.  Operand 0 of mode @var{n} is the destination for"}, {"sha": "a3432bc36704358347f3748cb0f111c36e0b5f7a", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -1487,6 +1487,10 @@ Target supports hardware vectors of @code{long}.\n @item vect_long_long\n Target supports hardware vectors of @code{long long}.\n \n+@item vect_check_ptrs\n+Target supports the @code{check_raw_ptrs} and @code{check_war_ptrs}\n+optabs on vectors.\n+\n @item vect_fully_masked\n Target supports fully-masked (also known as fully-predicated) loops,\n so that vector loops can handle partial as well as full vectors."}, {"sha": "88d52d2c25da8f37d5965c5efca9cf57ecf2f228", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -118,6 +118,7 @@ init_internal_fns ()\n #define fold_extract_direct { 2, 2, false }\n #define fold_left_direct { 1, 1, false }\n #define mask_fold_left_direct { 1, 1, false }\n+#define check_ptrs_direct { 0, 0, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n@@ -3006,6 +3007,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_mask_fold_left_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n+#define expand_check_ptrs_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 4)\n+\n /* RETURN_TYPE and ARGS are a return type and argument list that are\n    in principle compatible with FN (which satisfies direct_internal_fn_p).\n    Return the types that should be used to determine whether the\n@@ -3095,6 +3099,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p\n #define direct_fold_left_optab_supported_p direct_optab_supported_p\n #define direct_mask_fold_left_optab_supported_p direct_optab_supported_p\n+#define direct_check_ptrs_optab_supported_p direct_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n \n@@ -3572,6 +3577,24 @@ internal_gather_scatter_fn_supported_p (internal_fn ifn, tree vector_type,\n \t  && insn_operand_matches (icode, 3 + output_ops, GEN_INT (scale)));\n }\n \n+/* Return true if the target supports IFN_CHECK_{RAW,WAR}_PTRS function IFN\n+   for pointers of type TYPE when the accesses have LENGTH bytes and their\n+   common byte alignment is ALIGN.  */\n+\n+bool\n+internal_check_ptrs_fn_supported_p (internal_fn ifn, tree type,\n+\t\t\t\t    poly_uint64 length, unsigned int align)\n+{\n+  machine_mode mode = TYPE_MODE (type);\n+  optab optab = direct_internal_fn_optab (ifn);\n+  insn_code icode = direct_optab_handler (optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+  rtx length_rtx = immed_wide_int_const (length, mode);\n+  return (insn_operand_matches (icode, 3, length_rtx)\n+\t  && insn_operand_matches (icode, 4, GEN_INT (align)));\n+}\n+\n /* Expand STMT as though it were a call to internal function FN.  */\n \n void"}, {"sha": "85f45d660b7dc496b2f4d478128ac05d0a91a25d", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n    - cond_ternary: a conditional ternary optab, such as cond_fma_rev<mode>\n \n    - fold_left: for scalar = FN (scalar, vector), keyed off the vector mode\n+   - check_ptrs: used for check_{raw,war}_ptrs\n \n    DEF_INTERNAL_SIGNED_OPTAB_FN defines an internal function that\n    maps to one of two optabs, depending on the signedness of an input.\n@@ -136,6 +137,10 @@ DEF_INTERNAL_OPTAB_FN (MASK_STORE_LANES, 0,\n \t\t       vec_mask_store_lanes, mask_store_lanes)\n \n DEF_INTERNAL_OPTAB_FN (WHILE_ULT, ECF_CONST | ECF_NOTHROW, while_ult, while)\n+DEF_INTERNAL_OPTAB_FN (CHECK_RAW_PTRS, ECF_CONST | ECF_NOTHROW,\n+\t\t       check_raw_ptrs, check_ptrs)\n+DEF_INTERNAL_OPTAB_FN (CHECK_WAR_PTRS, ECF_CONST | ECF_NOTHROW,\n+\t\t       check_war_ptrs, check_ptrs)\n \n DEF_INTERNAL_OPTAB_FN (VEC_SHL_INSERT, ECF_CONST | ECF_NOTHROW,\n \t\t       vec_shl_insert, binary)"}, {"sha": "a1bc0819915f12a8d80af2e4477b6684f3df1feb", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -221,6 +221,8 @@ extern int internal_fn_mask_index (internal_fn);\n extern int internal_fn_stored_value_index (internal_fn);\n extern bool internal_gather_scatter_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t\t    tree, tree, int);\n+extern bool internal_check_ptrs_fn_supported_p (internal_fn, tree,\n+\t\t\t\t\t\tpoly_uint64, unsigned int);\n \n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);"}, {"sha": "24d8275000e74b54fc1f9f745a0f60375ed4114b", "filename": "gcc/optabs.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -429,6 +429,9 @@ OPTAB_D (atomic_xor_optab, \"atomic_xor$I$a\")\n OPTAB_D (get_thread_pointer_optab, \"get_thread_pointer$I$a\")\n OPTAB_D (set_thread_pointer_optab, \"set_thread_pointer$I$a\")\n \n+OPTAB_D (check_raw_ptrs_optab, \"check_raw_ptrs$a\")\n+OPTAB_D (check_war_ptrs_optab, \"check_war_ptrs$a\")\n+\n OPTAB_DC (vec_duplicate_optab, \"vec_duplicate$a\", VEC_DUPLICATE)\n OPTAB_DC (vec_series_optab, \"vec_series$a\", VEC_SERIES)\n OPTAB_D (vec_shl_insert_optab, \"vec_shl_insert_$a\")"}, {"sha": "01e8e2b8a69464ce0459d5354ec774518efe0d54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -1,3 +1,15 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_check_ptrs):\n+\tNew procedure.\n+\t* gcc.dg/vect/vect-alias-check-14.c: Expect IFN_CHECK_WAR to be\n+\tused, if available.\n+\t* gcc.dg/vect/vect-alias-check-15.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-16.c: Likewise IFN_CHECK_RAW.\n+\t* gcc.target/aarch64/sve2/whilerw_1.c: New test.\n+\t* gcc.target/aarch64/sve2/whilewr_1.c: Likewise.\n+\t* gcc.target/aarch64/sve2/whilewr_2.c: Likewise.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.target/aarch64/sve/acle/asm/ptest_pmore.c: New test."}, {"sha": "29bc571642db8858d3e4ca1027131a1a6559c4c1", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-14.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-14.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -60,5 +60,6 @@ main (void)\n \n /* { dg-final { scan-tree-dump {flags: *WAR\\n} \"vect\" { target vect_int } } } */\n /* { dg-final { scan-tree-dump-not {flags: [^\\n]*ARBITRARY\\n} \"vect\" } } */\n-/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" { target { ! vect_check_ptrs } } } } */\n+/* { dg-final { scan-tree-dump \"using an IFN_CHECK_WAR_PTRS test\" \"vect\" { target vect_check_ptrs } } } */\n /* { dg-final { scan-tree-dump-not \"using an index-based\" \"vect\" } } */"}, {"sha": "ad74496a6913dcf57ee4573ef1589263a32b074c", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-15.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-15.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -57,5 +57,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *WAW\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an address-based WAR/WAW test\" \"vect\" { target { ! vect_check_ptrs } } } } */\n+/* { dg-final { scan-tree-dump \"using an IFN_CHECK_WAR_PTRS test\" \"vect\" { target vect_check_ptrs } } } */\n /* { dg-final { scan-tree-dump-not \"using an index-based\" \"vect\" } } */"}, {"sha": "8a9a6fffde1d39f138c5f54221854e73cef89079", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-16.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-16.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -62,5 +62,6 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump {flags: *RAW\\n} \"vect\" { target vect_int } } } */\n-/* { dg-final { scan-tree-dump \"using an address-based overlap test\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"using an address-based overlap test\" \"vect\" { target { ! vect_check_ptrs } } } } */\n+/* { dg-final { scan-tree-dump \"using an IFN_CHECK_RAW_PTRS test\" \"vect\" { target vect_check_ptrs } } } */\n /* { dg-final { scan-tree-dump-not \"using an index-based\" \"vect\" } } */"}, {"sha": "63a6d2f4d627114a261b9e401489c3702d8c3a91", "filename": "gcc/testsuite/gcc.target/aarch64/sve2/whilerw_1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilerw_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilerw_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilerw_1.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\\\n+  TYPE\t\t\t\t\t\t\\\n+  test_##TYPE (TYPE *dst, TYPE *src, int n)\t\\\n+  {\t\t\t\t\t\t\\\n+    TYPE res = 0;\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tdst[i] += 1;\t\t\t\t\\\n+\tres += src[i];\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+    return res;\t\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (int8_t);\n+TEST_LOOP (int16_t);\n+TEST_LOOP (int32_t);\n+TEST_LOOP (int64_t);\n+\n+/* { dg-final { scan-assembler-times {\\twhilerw\\t} 4 } } */\n+/* { dg-final { scan-assembler-times {\\twhilerw\\tp[0-9]+\\.b, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilerw\\tp[0-9]+\\.h, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilerw\\tp[0-9]+\\.s, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilerw\\tp[0-9]+\\.d, x[0-9]+, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-not {\\twhilewr\\t} } } */"}, {"sha": "e204b37c6140411e34849416a180467d710c75be", "filename": "gcc/testsuite/gcc.target/aarch64/sve2/whilewr_1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_1.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  test_##TYPE (TYPE *dst, TYPE *src1, TYPE *src2, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      dst[i] = src1[i] + src2[i];\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (int8_t);\n+TEST_LOOP (int16_t);\n+TEST_LOOP (int32_t);\n+TEST_LOOP (int64_t);\n+\n+/* { dg-final { scan-assembler-times {\\twhilewr\\t} 8 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.b, x1, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.b, x2, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.h, x1, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.h, x2, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.s, x1, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.s, x2, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.d, x1, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.d, x2, x0\\n} 1 } } */\n+/* { dg-final { scan-assembler-not {\\twhilerw\\t} } } */"}, {"sha": "0b86991333efabf1889374cbd97bde8a4f155203", "filename": "gcc/testsuite/gcc.target/aarch64/sve2/whilewr_2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve2%2Fwhilewr_2.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-loop-distribute-patterns\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  test_##TYPE (TYPE *dst1, TYPE *dst2, TYPE *dst3, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        dst1[i] = 1;\t\t\t\t\t\t\\\n+        dst2[i] = 2;\t\t\t\t\t\t\\\n+        dst3[i] = 3;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+   }\n+\n+TEST_LOOP (int8_t);\n+TEST_LOOP (int16_t);\n+TEST_LOOP (int32_t);\n+TEST_LOOP (int64_t);\n+\n+/* { dg-final { scan-assembler-times {\\twhilewr\\t} 12 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.b, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.b, x0, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.b, x1, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.h, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.h, x0, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.h, x1, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.s, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.s, x0, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.s, x1, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.d, x0, x1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.d, x0, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\twhilewr\\tp[0-9]+\\.d, x1, x2\\n} 1 } } */\n+/* { dg-final { scan-assembler-not {\\twhilerw\\t} } } */"}, {"sha": "08af9f85b4ea7d1ccc4fdf5ad7ce5eb6877e0fdc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -6459,6 +6459,13 @@ proc check_effective_target_vect_natural_alignment { } {\n     return $et_vect_natural_alignment\n }\n \n+# Return true if the target supports the check_raw_ptrs and check_war_ptrs\n+# optabs on vectors.\n+\n+proc check_effective_target_vect_check_ptrs { } {\n+    return [check_effective_target_aarch64_sve2]\n+}\n+\n # Return true if fully-masked loops are supported.\n \n proc check_effective_target_vect_fully_masked { } {"}, {"sha": "117a14b29971cf376c39e619f806a3d1f663a901", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c036c8354e4d14551ceaeffaa1dda2fe445640/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=58c036c8354e4d14551ceaeffaa1dda2fe445640", "patch": "@@ -96,6 +96,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-eh.h\"\n #include \"ssa.h\"\n+#include \"internal-fn.h\"\n \n static struct datadep_stats\n {\n@@ -1719,6 +1720,80 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n     }\n }\n \n+/* A subroutine of create_intersect_range_checks, with a subset of the\n+   same arguments.  Try to use IFN_CHECK_RAW_PTRS and IFN_CHECK_WAR_PTRS\n+   to optimize cases in which the references form a simple RAW, WAR or\n+   WAR dependence.  */\n+\n+static bool\n+create_ifn_alias_checks (tree *cond_expr,\n+\t\t\t const dr_with_seg_len_pair_t &alias_pair)\n+{\n+  const dr_with_seg_len& dr_a = alias_pair.first;\n+  const dr_with_seg_len& dr_b = alias_pair.second;\n+\n+  /* Check for cases in which:\n+\n+     (a) we have a known RAW, WAR or WAR dependence\n+     (b) the accesses are well-ordered in both the original and new code\n+\t (see the comment above the DR_ALIAS_* flags for details); and\n+     (c) the DR_STEPs describe all access pairs covered by ALIAS_PAIR.  */\n+  if (alias_pair.flags & ~(DR_ALIAS_RAW | DR_ALIAS_WAR | DR_ALIAS_WAW))\n+    return false;\n+\n+  /* Make sure that both DRs access the same pattern of bytes,\n+     with a constant length and and step.  */\n+  poly_uint64 seg_len;\n+  if (!operand_equal_p (dr_a.seg_len, dr_b.seg_len, 0)\n+      || !poly_int_tree_p (dr_a.seg_len, &seg_len)\n+      || maybe_ne (dr_a.access_size, dr_b.access_size)\n+      || !operand_equal_p (DR_STEP (dr_a.dr), DR_STEP (dr_b.dr), 0)\n+      || !tree_fits_uhwi_p (DR_STEP (dr_a.dr)))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT bytes = tree_to_uhwi (DR_STEP (dr_a.dr));\n+  tree addr_a = DR_BASE_ADDRESS (dr_a.dr);\n+  tree addr_b = DR_BASE_ADDRESS (dr_b.dr);\n+\n+  /* See whether the target suports what we want to do.  WAW checks are\n+     equivalent to WAR checks here.  */\n+  internal_fn ifn = (alias_pair.flags & DR_ALIAS_RAW\n+\t\t     ? IFN_CHECK_RAW_PTRS\n+\t\t     : IFN_CHECK_WAR_PTRS);\n+  unsigned int align = MIN (dr_a.align, dr_b.align);\n+  poly_uint64 full_length = seg_len + bytes;\n+  if (!internal_check_ptrs_fn_supported_p (ifn, TREE_TYPE (addr_a),\n+\t\t\t\t\t   full_length, align))\n+    {\n+      full_length = seg_len + dr_a.access_size;\n+      if (!internal_check_ptrs_fn_supported_p (ifn, TREE_TYPE (addr_a),\n+\t\t\t\t\t       full_length, align))\n+\treturn false;\n+    }\n+\n+  /* Commit to using this form of test.  */\n+  addr_a = fold_build_pointer_plus (addr_a, DR_OFFSET (dr_a.dr));\n+  addr_a = fold_build_pointer_plus (addr_a, DR_INIT (dr_a.dr));\n+\n+  addr_b = fold_build_pointer_plus (addr_b, DR_OFFSET (dr_b.dr));\n+  addr_b = fold_build_pointer_plus (addr_b, DR_INIT (dr_b.dr));\n+\n+  *cond_expr = build_call_expr_internal_loc (UNKNOWN_LOCATION,\n+\t\t\t\t\t     ifn, boolean_type_node,\n+\t\t\t\t\t     4, addr_a, addr_b,\n+\t\t\t\t\t     size_int (full_length),\n+\t\t\t\t\t     size_int (align));\n+\n+  if (dump_enabled_p ())\n+    {\n+      if (ifn == IFN_CHECK_RAW_PTRS)\n+\tdump_printf (MSG_NOTE, \"using an IFN_CHECK_RAW_PTRS test\\n\");\n+      else\n+\tdump_printf (MSG_NOTE, \"using an IFN_CHECK_WAR_PTRS test\\n\");\n+    }\n+  return true;\n+}\n+\n /* Try to generate a runtime condition that is true if ALIAS_PAIR is\n    free of aliases, using a condition based on index values instead\n    of a condition based on addresses.  Return true on success,\n@@ -2240,6 +2315,9 @@ create_intersect_range_checks (class loop *loop, tree *cond_expr,\n   if (create_intersect_range_checks_index (loop, cond_expr, alias_pair))\n     return;\n \n+  if (create_ifn_alias_checks (cond_expr, alias_pair))\n+    return;\n+\n   if (create_waw_or_war_checks (cond_expr, alias_pair))\n     return;\n "}]}