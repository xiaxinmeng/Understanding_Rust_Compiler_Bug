{"sha": "4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE3N2M3MmI2YjgyZmUzMWZhODk3ZWY1Y2VkODU3OWI3MDZjOWRmYw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-04-09T10:57:03Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-04-09T10:57:03Z"}, "message": "i386.md (cmpcc): New.\n\n2009-04-09  Paolo Bonzini  <bonzini@gnu.org>\n\n        * config/i386/i386.md (cmpcc): New.\n        * config/i386/sync.md (sync_compare_and_swap*): Set FLAGS_REG.\n        (sync_compare_and_swap_cc*): Delete.\n\n        * config/s390/s390.c (s390_compare_emitted): Remove.\n        (s390_emit_compare): Handle MODE_CC s390_compare_op0 like\n        s390_compare_emitted used to be handled.  Assert that modes match.\n        (s390_emit_compare_and_swap): Use s390_emit_compare, do not\n        refer to sync_compare_and_swap_ccsi.\n        * config/s390/s390.h (s390_compare_emitted): Remove.\n        * config/s390/s390.md (seq): Look for MODE_CC s390_compare_op0\n        instead of s390_compare_emitted.\n        (stack_protect_test, sync_compare_and_swap_cc): Set s390_compare_op0\n        instead of s390_compare_emitted.\n        * config/s390/s390.md (cmpcc): New.\n        (sync_compare_and_swapqi, sync_compare_and_swaphi): Clobber\n        CC_REGNUM, do not pretend it's set.\n        (sync_compare_and_swap_cc*): Delete.\n        * config/s390/predicates.md (cc_reg_operand): New.\n\n        * expr.c (sync_compare_and_swap_cc): Delete.\n        * optabs.h (sync_compare_and_swap_cc): Delete.\n        * optabs.c (prepare_cmp_insn): Ignore which specific CCmode\n        is being used with can_compare_p.\n        (emit_cmp_and_jump_insn_1): Likewise when looking in the optab.\n        (find_cc_set): New.\n        (expand_bool_compare_and_swap): Do not use sync_compare_and_swap_cc,\n        look for a MODE_CC set instead.  Use emit_store_flag.\n        (expand_compare_and_swap_loop): Likewise, with some additional\n        complication to avoid a force_reg when useless.  Use\n        emit_cmp_and_jump_insns.\n        * genopinit.c (optabs): Delete sync_compare_and_swap_cc.\n        * doc/md.texi (sync_compare_and_swap_cc): Merge with\n        sync_compare_and_swap documentation.\n\njava:\n2009-04-09  Paolo Bonzini  <bonzini@gnu.org>\n\n        * builtins.c (compareAndSwapLong_builtin,\n        compareAndSwapInt_builtin, compareAndSwapObject_builtin,\n        VMSupportsCS8_builtin): Do not look at sync_compare_and_swap_cc.\n\nFrom-SVN: r145825", "tree": {"sha": "ece9481c78c8bf125765823a7704da2edc3e28dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece9481c78c8bf125765823a7704da2edc3e28dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf080c96e02d9b10dd18d7e900ed0c84d0d214af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf080c96e02d9b10dd18d7e900ed0c84d0d214af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf080c96e02d9b10dd18d7e900ed0c84d0d214af"}], "stats": {"total": 466, "additions": 190, "deletions": 276}, "files": [{"sha": "533705578d3f64b1496814a31c77e8e27c9c4c4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -1,3 +1,40 @@\n+2009-04-09  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * config/i386/i386.md (cmpcc): New.\n+        * config/i386/sync.md (sync_compare_and_swap*): Set FLAGS_REG.\n+        (sync_compare_and_swap_cc*): Delete.\n+\n+        * config/s390/s390.c (s390_compare_emitted): Remove.\n+        (s390_emit_compare): Handle MODE_CC s390_compare_op0 like\n+        s390_compare_emitted used to be handled.  Assert that modes match.\n+        (s390_emit_compare_and_swap): Use s390_emit_compare, do not\n+        refer to sync_compare_and_swap_ccsi.\n+        * config/s390/s390.h (s390_compare_emitted): Remove.\n+        * config/s390/s390.md (seq): Look for MODE_CC s390_compare_op0\n+        instead of s390_compare_emitted.\n+        (stack_protect_test, sync_compare_and_swap_cc): Set s390_compare_op0\n+        instead of s390_compare_emitted.\n+        * config/s390/s390.md (cmpcc): New.\n+        (sync_compare_and_swapqi, sync_compare_and_swaphi): Clobber\n+        CC_REGNUM, do not pretend it's set.\n+        (sync_compare_and_swap_cc*): Delete.\n+        * config/s390/predicates.md (cc_reg_operand): New.\n+\n+        * expr.c (sync_compare_and_swap_cc): Delete.\n+        * optabs.h (sync_compare_and_swap_cc): Delete.\n+        * optabs.c (prepare_cmp_insn): Ignore which specific CCmode\n+        is being used with can_compare_p.\n+        (emit_cmp_and_jump_insn_1): Likewise when looking in the optab.\n+        (find_cc_set): New.\n+        (expand_bool_compare_and_swap): Do not use sync_compare_and_swap_cc,\n+        look for a MODE_CC set instead.  Use emit_store_flag.\n+        (expand_compare_and_swap_loop): Likewise, with some additional\n+        complication to avoid a force_reg when useless.  Use\n+        emit_cmp_and_jump_insns.\n+        * genopinit.c (optabs): Delete sync_compare_and_swap_cc.\n+        * doc/md.texi (sync_compare_and_swap_cc): Merge with\n+        sync_compare_and_swap documentation.\n+\n 2009-04-09  Jan Hubicka  <jh@suse.cz>\n \n \t* except.c (find_prev_try): Break out from ...."}, {"sha": "a72c1b7232e3b73da0615fc100f05154fb679f4b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -1083,6 +1083,17 @@\n   DONE;\n })\n \n+(define_expand \"cmpcc\"\n+  [(set (reg:CC FLAGS_REG)\n+        (compare:CC (match_operand 0 \"flags_reg_operand\" \"\")\n+                    (match_operand 1 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  ix86_compare_op0 = operands[0];\n+  ix86_compare_op1 = operands[1];\n+  DONE;\n+})\n+\n ;; FP compares, step 1:\n ;; Set the FP condition codes.\n ;;"}, {"sha": "7167a71932a986aec020b519c4b36889d5df3708", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 16, "deletions": 102, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -70,7 +70,11 @@\n \t     (match_operand:CASMODE 2 \"register_operand\" \"\")\n \t     (match_operand:CASMODE 3 \"register_operand\" \"\")]\n \t    UNSPECV_CMPXCHG))\n-     (clobber (reg:CC FLAGS_REG))])]\n+   (set (reg:CCZ FLAGS_REG)\n+        (compare:CCZ\n+          (unspec_volatile:CASMODE\n+            [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n+          (match_dup 2)))])]\n   \"TARGET_CMPXCHG\"\n {\n   if ((<MODE>mode == DImode && !TARGET_64BIT) || <MODE>mode == TImode)\n@@ -109,7 +113,11 @@\n \t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n \t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n \t  UNSPECV_CMPXCHG))\n-   (clobber (reg:CC FLAGS_REG))]\n+   (set (reg:CCZ FLAGS_REG)\n+        (compare:CCZ\n+          (unspec_volatile:IMODE\n+            [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n+          (match_dup 2)))]\n   \"TARGET_CMPXCHG\"\n   \"lock{%;| }cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n \n@@ -123,7 +131,12 @@\n \t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"b\")\n \t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"c\")]\n \t  UNSPECV_CMPXCHG))\n-   (clobber (reg:CC FLAGS_REG))]\n+   (set (reg:CCZ FLAGS_REG)\n+        (compare:CCZ\n+          (unspec_volatile:DCASMODE\n+            [(match_dup 1) (match_dup 2) (match_dup 3) (match_dup 4)]\n+\t    UNSPECV_CMPXCHG)\n+          (match_dup 2)))]\n   \"\"\n   \"lock{%;| }cmpxchg<doublemodesuffix>b\\t%1\")\n \n@@ -137,105 +150,6 @@\n ;; just enumerate all regs possible here, which (as this is !TARGET_64BIT)\n ;; are just esi and edi.\n (define_insn \"*sync_double_compare_and_swapdi_pic\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n-\t(match_operand:DI 1 \"cmpxchg8b_pic_memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:DI\n-\t  [(match_dup 1)\n-\t   (match_operand:DI 2 \"register_operand\" \"A\")\n-\t   (match_operand:SI 3 \"register_operand\" \"SD\")\n-\t   (match_operand:SI 4 \"register_operand\" \"c\")]\n-\t  UNSPECV_CMPXCHG))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_CMPXCHG8B && flag_pic\"\n-  \"xchg{l}\\t%%ebx, %3\\;lock{%;| }cmpxchg8b\\t%1\\;xchg{l}\\t%%ebx, %3\")\n-\n-(define_expand \"sync_compare_and_swap_cc<mode>\"\n-  [(parallel\n-    [(set (match_operand:CASMODE 0 \"register_operand\" \"\")\n-\t  (match_operand:CASMODE 1 \"memory_operand\" \"\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:CASMODE\n-\t    [(match_dup 1)\n-\t     (match_operand:CASMODE 2 \"register_operand\" \"\")\n-\t     (match_operand:CASMODE 3 \"register_operand\" \"\")]\n-\t    UNSPECV_CMPXCHG))\n-     (set (match_dup 4)\n-\t  (compare:CCZ\n-\t    (unspec_volatile:CASMODE\n-\t      [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n-\t    (match_dup 2)))])]\n-  \"TARGET_CMPXCHG\"\n-{\n-  operands[4] = gen_rtx_REG (CCZmode, FLAGS_REG);\n-  ix86_compare_op0 = operands[4];\n-  ix86_compare_op1 = const0_rtx;\n-  if ((<MODE>mode == DImode && !TARGET_64BIT) || <MODE>mode == TImode)\n-    {\n-      enum machine_mode hmode = <MODE>mode == DImode ? SImode : DImode;\n-      rtx low = simplify_gen_subreg (hmode, operands[3], <MODE>mode, 0);\n-      rtx high = simplify_gen_subreg (hmode, operands[3], <MODE>mode,\n-\t\t\t\t      GET_MODE_SIZE (hmode));\n-      low = force_reg (hmode, low);\n-      high = force_reg (hmode, high);\n-      if (<MODE>mode == DImode)\n-\t{\n-\t  if (flag_pic && !cmpxchg8b_pic_memory_operand (operands[1], DImode))\n-\t    operands[1] = replace_equiv_address (operands[1],\n-\t\t\t\t\t\t force_reg (Pmode,\n-\t\t\t\t\t\t\t    XEXP (operands[1],\n-\t\t\t\t\t\t\t\t  0)));\n-\t  emit_insn (gen_sync_double_compare_and_swap_ccdi\n-\t\t     (operands[0], operands[1], operands[2], low, high));\n-\t}\n-      else if (<MODE>mode == TImode)\n-\temit_insn (gen_sync_double_compare_and_swap_ccti\n-\t\t   (operands[0], operands[1], operands[2], low, high));\n-      else\n-\tgcc_unreachable ();\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"*sync_compare_and_swap_cc<mode>\"\n-  [(set (match_operand:IMODE 0 \"register_operand\" \"=a\")\n-\t(match_operand:IMODE 1 \"memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:IMODE\n-\t  [(match_dup 1)\n-\t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n-\t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n-\t  UNSPECV_CMPXCHG))\n-   (set (reg:CCZ FLAGS_REG)\n-\t(compare:CCZ\n-\t  (unspec_volatile:IMODE\n-\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG)\n-\t  (match_dup 2)))]\n-  \"TARGET_CMPXCHG\"\n-  \"lock{%;| }cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n-\n-(define_insn \"sync_double_compare_and_swap_cc<mode>\"\n-  [(set (match_operand:DCASMODE 0 \"register_operand\" \"=A\")\n-\t(match_operand:DCASMODE 1 \"memory_operand\" \"+m\"))\n-   (set (match_dup 1)\n-\t(unspec_volatile:DCASMODE\n-\t  [(match_dup 1)\n-\t   (match_operand:DCASMODE 2 \"register_operand\" \"A\")\n-\t   (match_operand:<DCASHMODE> 3 \"register_operand\" \"b\")\n-\t   (match_operand:<DCASHMODE> 4 \"register_operand\" \"c\")]\n-\t  UNSPECV_CMPXCHG))\n-   (set (reg:CCZ FLAGS_REG)\n-\t(compare:CCZ\n-\t  (unspec_volatile:DCASMODE\n-\t    [(match_dup 1) (match_dup 2) (match_dup 3) (match_dup 4)]\n-\t    UNSPECV_CMPXCHG)\n-\t  (match_dup 2)))]\n-  \"\"\n-  \"lock{%;| }cmpxchg<doublemodesuffix>b\\t%1\")\n-\n-;; See above for the explanation of using the constraint \"SD\" for\n-;; operand 3.\n-(define_insn \"*sync_double_compare_and_swap_ccdi_pic\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=A\")\n \t(match_operand:DI 1 \"cmpxchg8b_pic_memory_operand\" \"+m\"))\n    (set (match_dup 1)"}, {"sha": "bb8fdf261d5e92302edac177b6777d7c32b6d73b", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -172,6 +172,11 @@\n   return (s390_branch_condition_mask (op) >= 0);\n })\n \n+;; Return true if op is the cc register.\n+(define_predicate \"cc_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == CC_REGNUM\")))\n+\n (define_predicate \"s390_signed_integer_comparison\"\n   (match_code \"eq, ne, lt, gt, le, ge\")\n {"}, {"sha": "1cf9f8eb270755a4dbc4b31feb38911d076ad9d1", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -224,13 +224,10 @@ struct processor_costs z10_cost =\n extern int reload_completed;\n \n /* Save information from a \"cmpxx\" operation until the branch or scc is\n-   emitted.  */\n+   emitted.  A pair of a MODE_CC register and a const0_rtx if a compare\n+   has been emitted already.  */\n rtx s390_compare_op0, s390_compare_op1;\n \n-/* Save the result of a compare_and_swap  until the branch or scc is\n-   emitted.  */\n-rtx s390_compare_emitted = NULL_RTX;\n-\n /* Structure used to hold the components of a S/390 memory\n    address.  A legitimate address on S/390 is of the general\n    form\n@@ -814,23 +811,23 @@ rtx\n s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n {\n   enum machine_mode mode = s390_select_ccmode (code, op0, op1);\n-  rtx ret = NULL_RTX;\n+  rtx cc;\n \n   /* Do not output a redundant compare instruction if a compare_and_swap\n      pattern already computed the result and the machine modes are compatible.  */\n-  if (s390_compare_emitted \n-      && (s390_cc_modes_compatible (GET_MODE (s390_compare_emitted), mode)\n-\t  == GET_MODE (s390_compare_emitted)))\n-    ret = gen_rtx_fmt_ee (code, VOIDmode, s390_compare_emitted, const0_rtx); \n+  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+    {\n+      gcc_assert (s390_cc_modes_compatible (GET_MODE (op0), mode)\n+\t\t  == GET_MODE (op0));\n+      cc = op0;\n+    }\n   else\n     {\n-      rtx cc = gen_rtx_REG (mode, CC_REGNUM);\n-      \n+      cc = gen_rtx_REG (mode, CC_REGNUM);\n       emit_insn (gen_rtx_SET (VOIDmode, cc, gen_rtx_COMPARE (mode, op0, op1)));\n-      ret = gen_rtx_fmt_ee (code, VOIDmode, cc, const0_rtx); \n     }\n-  s390_compare_emitted = NULL_RTX;\n-  return ret;\n+\n+  return gen_rtx_fmt_ee (code, VOIDmode, cc, const0_rtx); \n }\n \n /* Emit a SImode compare and swap instruction setting MEM to NEW_RTX if OLD\n@@ -841,14 +838,8 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n static rtx\n s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem, rtx cmp, rtx new_rtx)\n {\n-  rtx ret;\n-\n-  emit_insn (gen_sync_compare_and_swap_ccsi (old, mem, cmp, new_rtx));\n-  ret = gen_rtx_fmt_ee (code, VOIDmode, s390_compare_emitted, const0_rtx);\n-\n-  s390_compare_emitted = NULL_RTX;\n-\n-  return ret;\n+  emit_insn (gen_sync_compare_and_swapsi (old, mem, cmp, new_rtx));\n+  return s390_emit_compare (code, gen_rtx_REG (CCZ1mode, CC_REGNUM), const0_rtx);\n }\n \n /* Emit a jump instruction to TARGET.  If COND is NULL_RTX, emit an"}, {"sha": "bfe0268cc77fe805e2564b87695671fd68a24adb", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -817,7 +817,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */\n-extern struct rtx_def *s390_compare_op0, *s390_compare_op1, *s390_compare_emitted;\n+extern struct rtx_def *s390_compare_op0, *s390_compare_op1;\n \n \n /* Relative costs of operations.  */"}, {"sha": "16ed99e08f1bb5f3973bd3905caac1f933c3d2af", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -515,6 +515,16 @@\n   DONE;\n })\n \n+(define_expand \"cmpcc\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_operand 0 \"cc_reg_operand\" \"\")\n+                    (match_operand 1 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  s390_compare_op0 = operands[0];\n+  s390_compare_op1 = operands[1];\n+  DONE;\n+})\n \n ; Test-under-Mask instructions\n \n@@ -5122,7 +5132,7 @@\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n {\n-  if (!s390_compare_emitted || GET_MODE (s390_compare_emitted) != CCZ1mode)\n+  if (GET_MODE (s390_compare_op0) != CCZ1mode)\n     FAIL;\n   operands[1] = s390_emit_compare (NE, s390_compare_op0, s390_compare_op1);\n   PUT_MODE (operands[1], SImode);\n@@ -8242,33 +8252,11 @@\n \t     (match_operand:HQI 2 \"general_operand\" \"\")\n \t     (match_operand:HQI 3 \"general_operand\" \"\")]\n \t    UNSPECV_CAS))\n-     (set (reg:CCZ1 CC_REGNUM)\n-\t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n+     (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n   \"s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1],\n \t\t       operands[2], operands[3]); DONE;\")\n \n-(define_expand \"sync_compare_and_swap_cc<mode>\"\n-  [(parallel\n-    [(set (match_operand:TDSI 0 \"register_operand\" \"\")\n-\t  (match_operand:TDSI 1 \"memory_operand\" \"\"))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:TDSI\n-\t    [(match_dup 1)\n-\t     (match_operand:TDSI 2 \"register_operand\" \"\")\n-\t     (match_operand:TDSI 3 \"register_operand\" \"\")]\n-\t    UNSPECV_CAS))\n-     (set (match_dup 4)\n-\t  (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n-  \"\"\n-{\n-  /* Emulate compare.  */\n-  operands[4] = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n-  s390_compare_op0 = operands[1];\n-  s390_compare_op1 = operands[2];\n-  s390_compare_emitted = operands[4];\n-})\n-\n ; cds, cdsg\n (define_insn \"*sync_compare_and_swap<mode>\"\n   [(set (match_operand:DP 0 \"register_operand\" \"=r\")\n@@ -8682,17 +8670,14 @@\n     = gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, s390_get_thread_pointer (),\n                                         GEN_INT (TARGET_THREAD_SSP_OFFSET)));\n #endif\n-  s390_compare_op0 = operands[0];\n-  s390_compare_op1 = operands[1];\n-  s390_compare_emitted = gen_rtx_REG (CCZmode, CC_REGNUM);\n-\n   if (TARGET_64BIT)\n     emit_insn (gen_stack_protect_testdi (operands[0], operands[1]));\n   else\n     emit_insn (gen_stack_protect_testsi (operands[0], operands[1]));\n \n+  s390_compare_op0 = gen_rtx_REG (CCZmode, CC_REGNUM);\n+  s390_compare_op1 = const0_rtx;\n   emit_jump_insn (gen_beq (operands[2]));\n-\n   DONE;\n })\n "}, {"sha": "a78233c8eaa209c784e4ec2b6a9d83ca34ec9826", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -5091,19 +5091,15 @@ memory operations before the atomic operation occur before the atomic\n operation and all memory operations after the atomic operation occur\n after the atomic operation.\n \n-@cindex @code{sync_compare_and_swap_cc@var{mode}} instruction pattern\n-@item @samp{sync_compare_and_swap_cc@var{mode}}\n-\n-This pattern is just like @code{sync_compare_and_swap@var{mode}}, except\n-it should act as if compare part of the compare-and-swap were issued via\n-@code{cmp@var{m}}.  This comparison will only be used with @code{EQ} and\n-@code{NE} branches and @code{setcc} operations.\n-\n-Some targets do expose the success or failure of the compare-and-swap\n-operation via the status flags.  Ideally we wouldn't need a separate\n-named pattern in order to take advantage of this, but the combine pass\n-does not handle patterns with multiple sets, which is required by\n-definition for @code{sync_compare_and_swap@var{mode}}.\n+For targets where the success or failure of the compare-and-swap\n+operation is available via the status flags, it is possible\n+to avoid a separate compare operation and issue the subsequent\n+setcc or branch immediately after the compare-and-swap.  To this\n+end, GCC will look for a @code{MODE_CC} set in the output of\n+@code{sync_compare_and_swap@var{mode}}; if the machine description\n+includes such a set, the target should also define a special @code{cmpcc}\n+instruction.  GCC will then be able to take the destination of the\n+@code{MODE_CC} set and use it as the first operand of @code{cmpcc}.\n \n @cindex @code{sync_add@var{mode}} instruction pattern\n @cindex @code{sync_sub@var{mode}} instruction pattern"}, {"sha": "cd530d0a4f424abb94f3798d14b0d91953c92309", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -234,7 +234,6 @@ enum insn_code sync_new_and_optab[NUM_MACHINE_MODES];\n enum insn_code sync_new_xor_optab[NUM_MACHINE_MODES];\n enum insn_code sync_new_nand_optab[NUM_MACHINE_MODES];\n enum insn_code sync_compare_and_swap[NUM_MACHINE_MODES];\n-enum insn_code sync_compare_and_swap_cc[NUM_MACHINE_MODES];\n enum insn_code sync_lock_test_and_set[NUM_MACHINE_MODES];\n enum insn_code sync_lock_release[NUM_MACHINE_MODES];\n "}, {"sha": "8e13d1ccdf4ca2c27845c1cd17f96c8681c19af7", "filename": "gcc/genopinit.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -234,7 +234,6 @@ static const char * const optabs[] =\n   \"sync_new_xor_optab[$A] = CODE_FOR_$(sync_new_xor$I$a$)\",\n   \"sync_new_nand_optab[$A] = CODE_FOR_$(sync_new_nand$I$a$)\",\n   \"sync_compare_and_swap[$A] = CODE_FOR_$(sync_compare_and_swap$I$a$)\",\n-  \"sync_compare_and_swap_cc[$A] = CODE_FOR_$(sync_compare_and_swap_cc$I$a$)\",\n   \"sync_lock_test_and_set[$A] = CODE_FOR_$(sync_lock_test_and_set$I$a$)\",\n   \"sync_lock_release[$A] = CODE_FOR_$(sync_lock_release$I$a$)\",\n   \"optab_handler (vec_set_optab, $A)->insn_code = CODE_FOR_$(vec_set$a$)\","}, {"sha": "c4479f28bec6af444d7092d361fec46a2e60d3a7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -1,3 +1,9 @@\n+2009-04-09  Paolo Bonzini  <bonzini@gnu.org>\n+\n+        * builtins.c (compareAndSwapLong_builtin,\n+        compareAndSwapInt_builtin, compareAndSwapObject_builtin,\n+        VMSupportsCS8_builtin): Do not look at sync_compare_and_swap_cc.\n+\n 2009-03-31  Richard Guenther  <rguenther@suse.de>\n \n \t* java-gimplify.c (java_gimplify_expr): Do not manually gimplify"}, {"sha": "7ba12d3d4315ad08f42999f108052a743d2b78c5", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -304,8 +304,7 @@ compareAndSwapInt_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t   tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (int_type_node);\n-  if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n     {\n       tree addr, stmt;\n       UNMARSHAL5 (orig_call);\n@@ -324,8 +323,7 @@ compareAndSwapLong_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t    tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n-  if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n     {\n       tree addr, stmt;\n       UNMARSHAL5 (orig_call);\n@@ -343,8 +341,7 @@ compareAndSwapObject_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n \t\t\t      tree orig_call)\n {\n   enum machine_mode mode = TYPE_MODE (ptr_type_node);\n-  if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n   {\n     tree addr, stmt;\n     int builtin;\n@@ -422,8 +419,7 @@ VMSupportsCS8_builtin (tree method_return_type,\n {\n   enum machine_mode mode = TYPE_MODE (long_type_node);\n   gcc_assert (method_return_type == boolean_type_node);\n-  if (sync_compare_and_swap_cc[mode] != CODE_FOR_nothing \n-      || sync_compare_and_swap[mode] != CODE_FOR_nothing)\n+  if (sync_compare_and_swap[mode] != CODE_FOR_nothing)\n     return boolean_true_node;\n   else\n     return boolean_false_node;"}, {"sha": "058cebe33eb9f359f2137a9eb181b7dc85073380", "filename": "gcc/optabs.c", "status": "modified", "additions": 73, "deletions": 97, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -4143,11 +4143,15 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \n   *px = x;\n   *py = y;\n-  if (can_compare_p (*pcomparison, mode, purpose))\n+  if (GET_MODE_CLASS (mode) == MODE_CC)\n+    {\n+      gcc_assert (can_compare_p (*pcomparison, CCmode, purpose));\n+      return;\n+    }\n+  else if (can_compare_p (*pcomparison, mode, purpose))\n     return;\n \n   /* Handle a lib call just for the mode we are using.  */\n-\n   libfunc = optab_libfunc (cmp_optab, mode);\n   if (libfunc && !SCALAR_FLOAT_MODE_P (mode))\n     {\n@@ -4231,12 +4235,13 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n   /* Try combined insns first.  */\n   do\n     {\n+      enum machine_mode optab_mode = mclass == MODE_CC ? CCmode : wider_mode;\n       enum insn_code icode;\n       PUT_MODE (test, wider_mode);\n \n       if (label)\n \t{\n-\t  icode = optab_handler (cbranch_optab, wider_mode)->insn_code;\n+\t  icode = optab_handler (cbranch_optab, optab_mode)->insn_code;\n \n \t  if (icode != CODE_FOR_nothing\n \t      && insn_data[icode].operand[0].predicate (test, wider_mode))\n@@ -4249,7 +4254,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t}\n \n       /* Handle some compares against zero.  */\n-      icode = (int) optab_handler (tst_optab, wider_mode)->insn_code;\n+      icode = (int) optab_handler (tst_optab, optab_mode)->insn_code;\n       if (y == CONST0_RTX (mode) && icode != CODE_FOR_nothing)\n \t{\n \t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n@@ -4261,7 +4266,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \n       /* Handle compares for which there is a directly suitable insn.  */\n \n-      icode = (int) optab_handler (cmp_optab, wider_mode)->insn_code;\n+      icode = (int) optab_handler (cmp_optab, optab_mode)->insn_code;\n       if (icode != CODE_FOR_nothing)\n \t{\n \t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n@@ -6399,7 +6404,6 @@ init_optabs (void)\n       sync_new_xor_optab[i] = CODE_FOR_nothing;\n       sync_new_nand_optab[i] = CODE_FOR_nothing;\n       sync_compare_and_swap[i] = CODE_FOR_nothing;\n-      sync_compare_and_swap_cc[i] = CODE_FOR_nothing;\n       sync_lock_test_and_set[i] = CODE_FOR_nothing;\n       sync_lock_release[i] = CODE_FOR_nothing;\n \n@@ -6970,6 +6974,21 @@ expand_val_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n   return expand_val_compare_and_swap_1 (mem, old_val, new_val, target, icode);\n }\n \n+/* Helper function to find the MODE_CC set in a sync_compare_and_swap\n+   pattern.  */\n+\n+static void\n+find_cc_set (rtx x, const_rtx pat, void *data)\n+{\n+  if (REG_P (x) && GET_MODE_CLASS (GET_MODE (x)) == MODE_CC\n+      && GET_CODE (pat) == SET)\n+    {\n+      rtx *p_cc_reg = (rtx *) data;\n+      gcc_assert (!*p_cc_reg);\n+      *p_cc_reg = x;\n+    }\n+}\n+\n /* Expand a compare-and-swap operation and store true into the result if\n    the operation was successful and false otherwise.  Return the result.\n    Unlike other routines, TARGET is not optional.  */\n@@ -6979,84 +6998,46 @@ expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx subtarget, label0, label1;\n+  rtx subtarget, seq, cc_reg;\n \n   /* If the target supports a compare-and-swap pattern that simultaneously\n      sets some flag for success, then use it.  Otherwise use the regular\n      compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = sync_compare_and_swap_cc[mode];\n-  switch (icode)\n-    {\n-    default:\n-      subtarget = expand_val_compare_and_swap_1 (mem, old_val, new_val,\n-\t\t\t\t\t\t NULL_RTX, icode);\n-      if (subtarget != NULL_RTX)\n-\tbreak;\n-\n-      /* FALLTHRU */\n-    case CODE_FOR_nothing:\n-      icode = sync_compare_and_swap[mode];\n-      if (icode == CODE_FOR_nothing)\n-\treturn NULL_RTX;\n-\n-      /* Ensure that if old_val == mem, that we're not comparing\n-\t against an old value.  */\n-      if (MEM_P (old_val))\n-\told_val = force_reg (mode, old_val);\n+  icode = sync_compare_and_swap[mode];\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n \n+  do\n+    {\n+      start_sequence ();\n       subtarget = expand_val_compare_and_swap_1 (mem, old_val, new_val,\n-\t\t\t\t\t\t NULL_RTX, icode);\n+\t\t\t\t\t         NULL_RTX, icode);\n+      cc_reg = NULL_RTX;\n       if (subtarget == NULL_RTX)\n-\treturn NULL_RTX;\n-\n-      emit_cmp_insn (subtarget, old_val, EQ, const0_rtx, mode, true);\n-    }\n-\n-  /* If the target has a sane STORE_FLAG_VALUE, then go ahead and use a\n-     setcc instruction from the beginning.  We don't work too hard here,\n-     but it's nice to not be stupid about initial code gen either.  */\n-  if (STORE_FLAG_VALUE == 1)\n-    {\n-      icode = setcc_gen_code[EQ];\n-      if (icode != CODE_FOR_nothing)\n \t{\n-\t  enum machine_mode cmode = insn_data[icode].operand[0].mode;\n-\t  rtx insn;\n-\n-\t  subtarget = target;\n-\t  if (!insn_data[icode].operand[0].predicate (target, cmode))\n-\t    subtarget = gen_reg_rtx (cmode);\n-\n-\t  insn = GEN_FCN (icode) (subtarget);\n-\t  if (insn)\n-\t    {\n-\t      emit_insn (insn);\n-\t      if (GET_MODE (target) != GET_MODE (subtarget))\n-\t\t{\n-\t          convert_move (target, subtarget, 1);\n-\t\t  subtarget = target;\n-\t\t}\n-\t      return subtarget;\n-\t    }\n+\t  end_sequence ();\n+\t  return NULL_RTX;\n \t}\n-    }\n-\n-  /* Without an appropriate setcc instruction, use a set of branches to\n-     get 1 and 0 stored into target.  Presumably if the target has a\n-     STORE_FLAG_VALUE that isn't 1, then this will get cleaned up by ifcvt.  */\n \n-  label0 = gen_label_rtx ();\n-  label1 = gen_label_rtx ();\n+      if (have_insn_for (COMPARE, CCmode))\n+\tnote_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n+      seq = get_insns ();\n+      end_sequence ();\n \n-  emit_jump_insn (bcc_gen_fctn[EQ] (label0));\n-  emit_move_insn (target, const0_rtx);\n-  emit_jump_insn (gen_jump (label1));\n-  emit_barrier ();\n-  emit_label (label0);\n-  emit_move_insn (target, const1_rtx);\n-  emit_label (label1);\n+      /* We might be comparing against an old value.  Try again. :-(  */\n+      if (!cc_reg && MEM_P (old_val))\n+\t{\n+\t  seq = NULL_RTX;\n+\t  old_val = force_reg (mode, old_val);\n+        }\n+    }\n+  while (!seq);\n \n-  return target;\n+  emit_insn (seq);\n+  if (cc_reg)\n+    return emit_store_flag (target, EQ, cc_reg, const0_rtx, VOIDmode, 0, 1);\n+  else\n+    return emit_store_flag (target, EQ, subtarget, old_val, VOIDmode, 1, 1);\n }\n \n /* This is a helper function for the other atomic operations.  This function\n@@ -7073,7 +7054,7 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   enum insn_code icode;\n-  rtx label, cmp_reg, subtarget;\n+  rtx label, cmp_reg, subtarget, cc_reg;\n \n   /* The loop we want to generate looks like\n \n@@ -7100,37 +7081,32 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n   /* If the target supports a compare-and-swap pattern that simultaneously\n      sets some flag for success, then use it.  Otherwise use the regular\n      compare-and-swap and follow that immediately with a compare insn.  */\n-  icode = sync_compare_and_swap_cc[mode];\n-  switch (icode)\n-    {\n-    default:\n-      subtarget = expand_val_compare_and_swap_1 (mem, old_reg, new_reg,\n-\t\t\t\t\t\t cmp_reg, icode);\n-      if (subtarget != NULL_RTX)\n-\t{\n-\t  gcc_assert (subtarget == cmp_reg);\n-\t  break;\n-\t}\n+  icode = sync_compare_and_swap[mode];\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n \n-      /* FALLTHRU */\n-    case CODE_FOR_nothing:\n-      icode = sync_compare_and_swap[mode];\n-      if (icode == CODE_FOR_nothing)\n-\treturn false;\n+  subtarget = expand_val_compare_and_swap_1 (mem, old_reg, new_reg,\n+\t\t\t\t\t     cmp_reg, icode);\n+  if (subtarget == NULL_RTX)\n+    return false;\n \n-      subtarget = expand_val_compare_and_swap_1 (mem, old_reg, new_reg,\n-\t\t\t\t\t\t cmp_reg, icode);\n-      if (subtarget == NULL_RTX)\n-\treturn false;\n+  cc_reg = NULL_RTX;\n+  if (have_insn_for (COMPARE, CCmode))\n+    note_stores (PATTERN (get_last_insn ()), find_cc_set, &cc_reg);\n+  if (cc_reg)\n+    {\n+      cmp_reg = cc_reg;\n+      old_reg = const0_rtx;\n+    }\n+  else\n+    {\n       if (subtarget != cmp_reg)\n \temit_move_insn (cmp_reg, subtarget);\n-\n-      emit_cmp_insn (cmp_reg, old_reg, EQ, const0_rtx, mode, true);\n     }\n \n   /* ??? Mark this jump predicted not taken?  */\n-  emit_jump_insn (bcc_gen_fctn[NE] (label));\n-\n+  emit_cmp_and_jump_insns (cmp_reg, old_reg, NE, const0_rtx, GET_MODE (cmp_reg), 1,\n+\t\t\t   label);\n   return true;\n }\n "}, {"sha": "a518dc6ab862c2ca61f43df219c1545a519d12bf", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a77c72b6b82fe31fa897ef5ced8579b706c9dfc/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=4a77c72b6b82fe31fa897ef5ced8579b706c9dfc", "patch": "@@ -670,7 +670,6 @@ extern enum insn_code sync_new_nand_optab[NUM_MACHINE_MODES];\n \n /* Atomic compare and swap.  */\n extern enum insn_code sync_compare_and_swap[NUM_MACHINE_MODES];\n-extern enum insn_code sync_compare_and_swap_cc[NUM_MACHINE_MODES];\n \n /* Atomic exchange with acquire semantics.  */\n extern enum insn_code sync_lock_test_and_set[NUM_MACHINE_MODES];"}]}