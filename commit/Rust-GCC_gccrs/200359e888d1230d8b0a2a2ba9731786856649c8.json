{"sha": "200359e888d1230d8b0a2a2ba9731786856649c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwMzU5ZTg4OGQxMjMwZDhiMGEyYTJiYTk3MzE3ODY4NTY2NDljOA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-07-05T05:36:50Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-07-05T05:36:50Z"}, "message": "Merged with libbbid branch at revision 126349.\n\nFrom-SVN: r126353", "tree": {"sha": "6f9d40b9b41cc5724f2ee6be71198a7a43432d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f9d40b9b41cc5724f2ee6be71198a7a43432d86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200359e888d1230d8b0a2a2ba9731786856649c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200359e888d1230d8b0a2a2ba9731786856649c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200359e888d1230d8b0a2a2ba9731786856649c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200359e888d1230d8b0a2a2ba9731786856649c8/comments", "author": null, "committer": null, "parents": [{"sha": "e5e941450f9c08cb0b02c63ff172e970104f3b0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e941450f9c08cb0b02c63ff172e970104f3b0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e941450f9c08cb0b02c63ff172e970104f3b0d"}], "stats": {"total": 178213, "additions": 178204, "deletions": 9}, "files": [{"sha": "0c99d1408f58db10c16a0a534084913d9c5a1719", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -1,3 +1,11 @@\n+2007-07-04  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.dg/dfp/dfp-round.h (FE_DEC_TONEAREST): Redfined for BID.\n+\t(FE_DEC_DOWNWARD): Likewise.\n+\t(FE_DEC_UPWARD): Likewise.\n+\t(FE_DEC_TOWARDZERO): Likewise.\n+\t(FE_DEC_TONEARESTFROMZERO): Likewise.\n+\n 2007-07-04  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* gcc.c-torture/compile/pr32606.c: New."}, {"sha": "fc7fd5c238b78363c4720b41e31fbd7d1b3c7ddd", "filename": "gcc/testsuite/gcc.dg/dfp/dfp-round.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fdfp-round.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fdfp-round.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fdfp-round.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -2,11 +2,19 @@\n    pass on the rounding mode to decNumber, but later it can be replaced\n    with Official Stuff.  */\n \n+#ifdef __DECIMAL_BID_FORMAT__\n+#define FE_DEC_TONEAREST 0\n+#define FE_DEC_DOWNWARD 1\n+#define FE_DEC_UPWARD 2\n+#define FE_DEC_TOWARDZERO 3\n+#define FE_DEC_TONEARESTFROMZERO 4\n+#else\n #define FE_DEC_DOWNWARD 0\n #define FE_DEC_TONEAREST 1\n #define FE_DEC_TONEARESTFROMZERO 2\n #define FE_DEC_TOWARDZERO 3\n #define FE_DEC_UPWARD 4\n+#endif\n \n extern void __dfp_set_round (int);\n #define DFP_SETROUND(M) __dfp_set_round(M)"}, {"sha": "20751b3c42f6b8f410beff4620880e109ea3eb07", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -1,3 +1,7 @@\n+2007-07-04  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* Makefile.in: Use libbid for DFP when BID is enabled.\n+\n 2007-06-14  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config.host(*-cygwin* |*-mingw* ): Add crtbegin.o, crtend.o to\n@@ -6,7 +10,7 @@\n \n \n 2007-05-29  Zuxy Meng  <zuxy.meng@gmail.com>\n-            Danny Smith  <dannysmith@users.sourceforge.net>\n+\t    Danny Smith  <dannysmith@users.sourceforge.net>\n \n \tPR target/29498\n \t* config.host (i[34567]86-*-cygwin* | i[34567]86-*-mingw*) Add"}, {"sha": "f8115ea76ef21290cb15005fd8006312000372be", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -185,9 +185,13 @@ export slibdir\n version := $(shell $(CC) -dumpversion)\n \n ifeq ($(decimal_float),yes)\n+ifeq ($(enable_decimal_float),bid)\n+DECNUMINC = -I$(srcdir)/config/libbid -DENABLE_DECIMAL_BID_FORMAT\n+else\n DECNUMINC = -I$(srcdir)/../libdecnumber/$(enable_decimal_float) \\\n \t    -I$(srcdir)/../libdecnumber \\\n \t    -I$(MULTIBUILDTOP)../../libdecnumber\n+endif\n else\n DECNUMINC =\n endif\n@@ -469,17 +473,35 @@ D64PBIT = 1\n D128PBIT = 1\n endif\n \n-dec-filenames =\n+dfp-filenames =\n ifneq ($(D32PBIT)$(D64PBIT)$(D128PBIT),)\n-dec-filenames += decContext decNumber decExcept decRound decLibrary decUtility\n+ifeq ($(enable_decimal_float),bid)\n+dfp-filenames += decimal_globals decimal_data binarydecimal \\\n+\t\t _isinfd32 _isinfd64 _isinfd128 bid64_noncomp \\\n+\t\t bid128_fma bid_round bid_from_int convert_data \\\n+\t\t bid64_add bid128_add bid64_div bid128_div \\\n+\t\t bid64_mul bid128_mul bid64_compare bid128_compare \\\n+\t\t bid128 bid32_to_bid64 bid32_to_bid128 bid64_to_bid128 \\\n+\t\t bid64_to_int32 bid64_to_int64 \\\n+\t\t bid64_to_uint32 bid64_to_uint64 \\\n+\t\t bid128_to_int32 bid128_to_int64 \\\n+\t\t bid128_to_uint32 bid128_to_uint64\n+else\n+dfp-filenames += decContext decNumber decExcept decRound decLibrary decUtility\n+endif\n endif\n \n-dec-objects = $(patsubst %,%$(objext),$(dec-filenames))\n-$(dec-objects): %$(objext): $(srcdir)/../libdecnumber/%.c\n+dfp-objects = $(patsubst %,%$(objext),$(dfp-filenames))\n+ifeq ($(enable_decimal_float),bid)\n+$(dfp-objects): %$(objext): $(srcdir)/config/libbid/%.c\n+else\n+$(dfp-objects): %$(objext): $(srcdir)/../libdecnumber/%.c\n+endif\n \t$(gcc_compile) -c $<\n-libgcc-objects += $(dec-objects)\n+libgcc-objects += $(dfp-objects)\n \n decbits-filenames =\n+ifneq ($(enable_decimal_float),bid)\n ifneq ($(D32PBIT),)\n decbits-filenames += decimal32\n endif\n@@ -491,34 +513,61 @@ endif\n ifneq ($(D128PBIT),)\n decbits-filenames += decimal128\n endif\n-\n-ifeq ($(enable_decimal_float),bid)\n-decbits-filenames += bid2dpd_dpd2bid\n endif\n \n decbits-objects = $(patsubst %,%$(objext),$(decbits-filenames))\n+ifeq ($(enable_decimal_float),bid)\n+$(decbits-objects): %$(objext): $(srcdir)/config/libbid/%.c\n+else\n $(decbits-objects): %$(objext): $(srcdir)/../libdecnumber/$(enable_decimal_float)/%.c\n+endif\n \t$(gcc_compile) -c $<\n libgcc-objects += $(decbits-objects)\n \n # Next build individual support functions.\n+ifeq ($(enable_decimal_float),bid)\n+ifneq ($(D32PBIT),)\n+D32PBIT_FUNCS:=$(filter-out _plus_sd _minus_sd _conv_sd, $(D32PBIT_FUNCS))\n+endif\n+\n+ifneq ($(D64PBIT),)\n+D64PBIT_FUNCS:=$(filter-out _plus_dd _minus_dd _conv_dd, $(D64PBIT_FUNCS))\n+endif\n+\n+ifneq ($(D128PBIT),)\n+D128PBIT_FUNCS:=$(filter-out _plus_td _minus_td _conv_td, $(D128PBIT_FUNCS))\n+endif\n+endif\n+\n ifneq ($(D32PBIT),)\n d32pbit-o = $(patsubst %,%$(objext),$(D32PBIT_FUNCS))\n+ifeq ($(enable_decimal_float),bid)\n+$(d32pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n+else\n $(d32pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=32 -c $<\n libgcc-objects += $(d32pbit-o)\n endif\n \n ifneq ($(D64PBIT),)\n d64pbit-o = $(patsubst %,%$(objext),$(D64PBIT_FUNCS))\n+ifeq ($(enable_decimal_float),bid)\n+$(d64pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n+else\n $(d64pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=64 -c $<\n libgcc-objects += $(d64pbit-o)\n endif\n \n ifneq ($(D128PBIT),)\n d128pbit-o = $(patsubst %,%$(objext),$(D128PBIT_FUNCS))\n+ifeq ($(enable_decimal_float),bid)\n+$(d128pbit-o): %$(objext): $(srcdir)/config/libbid/%.c\n+else\n $(d128pbit-o): %$(objext): $(gcc_srcdir)/config/dfp-bit.c\n+endif\n \t$(gcc_compile) -DFINE_GRAINED_LIBRARIES -DL$* -DWIDTH=128 -c $<\n libgcc-objects += $(d128pbit-o)\n endif"}, {"sha": "aa9234c40708f81b89d2e3a2955ac82debf7de2a", "filename": "libgcc/config/libbid/ChangeLog", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2FChangeLog?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,153 @@\n+2007-07-04  Marius Cornea  <marius.cornea@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* _addsub_dd.c: New file from Intel BID library.\n+\t* _addsub_sd.c: Likewise.\n+\t* _addsub_td.c: Likewise.\n+\t* _dd_to_df.c: Likewise.\n+\t* _dd_to_di.c: Likewise.\n+\t* _dd_to_sd.c: Likewise.\n+\t* _dd_to_sf.c: Likewise.\n+\t* _dd_to_si.c: Likewise.\n+\t* _dd_to_td.c: Likewise.\n+\t* _dd_to_tf.c: Likewise.\n+\t* _dd_to_udi.c: Likewise.\n+\t* _dd_to_usi.c: Likewise.\n+\t* _dd_to_xf.c: Likewise.\n+\t* _df_to_dd.c: Likewise.\n+\t* _df_to_sd.c: Likewise.\n+\t* _df_to_td.c: Likewise.\n+\t* _di_to_dd.c: Likewise.\n+\t* _di_to_sd.c: Likewise.\n+\t* _di_to_td.c: Likewise.\n+\t* _div_dd.c: Likewise.\n+\t* _div_sd.c: Likewise.\n+\t* _div_td.c: Likewise.\n+\t* _eq_dd.c: Likewise.\n+\t* _eq_sd.c: Likewise.\n+\t* _eq_td.c: Likewise.\n+\t* _ge_dd.c: Likewise.\n+\t* _ge_sd.c: Likewise.\n+\t* _ge_td.c: Likewise.\n+\t* _gt_dd.c: Likewise.\n+\t* _gt_sd.c: Likewise.\n+\t* _gt_td.c: Likewise.\n+\t* _isinfd128.c: Likewise.\n+\t* _isinfd32.c: Likewise.\n+\t* _isinfd64.c: Likewise.\n+\t* _le_dd.c: Likewise.\n+\t* _le_sd.c: Likewise.\n+\t* _le_td.c: Likewise.\n+\t* _lt_dd.c: Likewise.\n+\t* _lt_sd.c: Likewise.\n+\t* _lt_td.c: Likewise.\n+\t* _mul_dd.c: Likewise.\n+\t* _mul_sd.c: Likewise.\n+\t* _mul_td.c: Likewise.\n+\t* _ne_dd.c: Likewise.\n+\t* _ne_sd.c: Likewise.\n+\t* _ne_td.c: Likewise.\n+\t* _sd_to_dd.c: Likewise.\n+\t* _sd_to_df.c: Likewise.\n+\t* _sd_to_di.c: Likewise.\n+\t* _sd_to_sf.c: Likewise.\n+\t* _sd_to_si.c: Likewise.\n+\t* _sd_to_td.c: Likewise.\n+\t* _sd_to_tf.c: Likewise.\n+\t* _sd_to_udi.c: Likewise.\n+\t* _sd_to_usi.c: Likewise.\n+\t* _sd_to_xf.c: Likewise.\n+\t* _sf_to_dd.c: Likewise.\n+\t* _sf_to_sd.c: Likewise.\n+\t* _sf_to_td.c: Likewise.\n+\t* _si_to_dd.c: Likewise.\n+\t* _si_to_sd.c: Likewise.\n+\t* _si_to_td.c: Likewise.\n+\t* _td_to_dd.c: Likewise.\n+\t* _td_to_df.c: Likewise.\n+\t* _td_to_di.c: Likewise.\n+\t* _td_to_sd.c: Likewise.\n+\t* _td_to_sf.c: Likewise.\n+\t* _td_to_si.c: Likewise.\n+\t* _td_to_tf.c: Likewise.\n+\t* _td_to_udi.c: Likewise.\n+\t* _td_to_usi.c: Likewise.\n+\t* _td_to_xf.c: Likewise.\n+\t* _tf_to_dd.c: Likewise.\n+\t* _tf_to_sd.c: Likewise.\n+\t* _tf_to_td.c: Likewise.\n+\t* _udi_to_dd.c: Likewise.\n+\t* _udi_to_sd.c: Likewise.\n+\t* _udi_to_td.c: Likewise.\n+\t* _unord_dd.c: Likewise.\n+\t* _unord_sd.c: Likewise.\n+\t* _unord_td.c: Likewise.\n+\t* _usi_to_dd.c: Likewise.\n+\t* _usi_to_sd.c: Likewise.\n+\t* _usi_to_td.c: Likewise.\n+\t* _xf_to_dd.c: Likewise.\n+\t* _xf_to_sd.c: Likewise.\n+\t* _xf_to_td.c: Likewise.\n+\n+2007-07-04  Marius Cornea  <marius.cornea@intel.com>\n+\n+\t* b2d.h: New file from Intel BID library.\n+\t* bid128_2_str.h: Likewise.\n+\t* bid128_2_str_macros.h: Likewise.\n+\t* bid128_2_str_tables.c: Likewise.\n+\t* bid128_add.c: Likewise.\n+\t* bid128.c: Likewise.\n+\t* bid128_compare.c: Likewise.\n+\t* bid128_div.c: Likewise.\n+\t* bid128_fma.c: Likewise.\n+\t* bid128_fromstring.c: Likewise.\n+\t* bid128_logb.c: Likewise.\n+\t* bid128_minmax.c: Likewise.\n+\t* bid128_mul.c: Likewise.\n+\t* bid128_next.c: Likewise.\n+\t* bid128_noncomp.c: Likewise.\n+\t* bid128_quantize.c: Likewise.\n+\t* bid128_rem.c: Likewise.\n+\t* bid128_round_integral.c: Likewise.\n+\t* bid128_scalb.c: Likewise.\n+\t* bid128_sqrt.c: Likewise.\n+\t* bid128_to_int32.c: Likewise.\n+\t* bid128_to_int64.c: Likewise.\n+\t* bid128_to_string.c: Likewise.\n+\t* bid128_to_uint32.c: Likewise.\n+\t* bid128_to_uint64.c: Likewise.\n+\t* bid32_to_bid128.c: Likewise.\n+\t* bid32_to_bid64.c: Likewise.\n+\t* bid64_add.c: Likewise.\n+\t* bid64_compare.c: Likewise.\n+\t* bid64_div.c: Likewise.\n+\t* bid64_fma.c: Likewise.\n+\t* bid64_logb.c: Likewise.\n+\t* bid64_minmax.c: Likewise.\n+\t* bid64_mul.c: Likewise.\n+\t* bid64_next.c: Likewise.\n+\t* bid64_noncomp.c: Likewise.\n+\t* bid64_quantize.c: Likewise.\n+\t* bid64_rem.c: Likewise.\n+\t* bid64_round_integral.c: Likewise.\n+\t* bid64_scalb.c: Likewise.\n+\t* bid64_sqrt.c: Likewise.\n+\t* bid64_to_bid128.c: Likewise.\n+\t* bid64_to_int32.c: Likewise.\n+\t* bid64_to_int64.c: Likewise.\n+\t* bid64_to_uint32.c: Likewise.\n+\t* bid64_to_uint64.c: Likewise.\n+\t* bid_conf.h: Likewise.\n+\t* bid_flag_operations.c: Likewise.\n+\t* bid_from_int.c: Likewise.\n+\t* bid_functions.h: Likewise.\n+\t* bid_internal.h: Likewise.\n+\t* bid_round.c: Likewise.\n+\t* bid_string.c: Likewise.\n+\t* binarydecimal.c: Likewise.\n+\t* convert_data.c: Likewise.\n+\t* decimal_data.c: Likewise.\n+\t* decimal_globals.c: Likewise.\n+\t* div_macros.h: Likewise.\n+\t* inline_bid_add.h: Likewise.\n+\t* sqrt_macros.h: Likewise."}, {"sha": "5c1a6eace15080b79e3c27fbc53cf45ae7695270", "filename": "libgcc/config/libbid/_addsub_dd.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_adddd3 (_Decimal64 x, _Decimal64 y) {\n+  union decimal64 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid64_add (ux.i, uy.i);\n+  return (res.d);\n+}\n+\n+_Decimal64\n+__bid_subdd3 (_Decimal64 x, _Decimal64 y) {\n+  union decimal64 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid64_sub (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "f67d06d59bb97c0188df2e969751fe013d40b684", "filename": "libgcc/config/libbid/_addsub_sd.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,58 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_addsd3 (_Decimal32 x, _Decimal32 y) {\n+  UINT64 x64, y64, res64;\n+  union decimal32 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res64 = __bid64_add (x64, y64);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}\n+\n+_Decimal32\n+__bid_subsd3 (_Decimal32 x, _Decimal32 y) {\n+  UINT64 x64, y64, res64;\n+  union decimal32 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res64 = __bid64_sub (x64, y64);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "2b25b4ecdeb383d30d1d377dd6cf1bd1d2d487e5", "filename": "libgcc/config/libbid/_addsub_td.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_addsub_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_addtd3 (_Decimal128 x, _Decimal128 y) {\n+  union decimal128 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid128_add (ux.i, uy.i);\n+  return (res.d);\n+}\n+\n+_Decimal128\n+__bid_subtd3 (_Decimal128 x, _Decimal128 y) {\n+  union decimal128 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid128_sub (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "97deaed051bd24d2f6634984fbb5e65f53b2458b", "filename": "libgcc/config/libbid/_dd_to_df.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_df.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DFtype\n+__bid_truncdddf (_Decimal64 x) {\n+  DFtype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_binary64 (ux.i);\n+  return (res);\n+}"}, {"sha": "a86a2fa06f01df830d7da1446427182eee05c9c2", "filename": "libgcc/config/libbid/_dd_to_di.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_di.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DItype\n+__bid_fixdddi (_Decimal64 x) {\n+  DItype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_int64_xint (ux.i);\n+  return (res);\n+}\n+\n+"}, {"sha": "236d6236502d966986b3907beba3fc07f03974a1", "filename": "libgcc/config/libbid/_dd_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal32\n+__bid_truncddsd2 (_Decimal64 x) {\n+  union decimal32 res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res.i = __bid64_to_bid32 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "9850c16517a7bf381950b449489b354456750e80", "filename": "libgcc/config/libbid/_dd_to_sf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_sf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SFtype\n+__bid_truncddsf (_Decimal64 x) {\n+  SFtype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_binary32 (ux.i);\n+  return (res);\n+}"}, {"sha": "c4733d53d28786b31d1dabaa6c4e4f4cabb04654", "filename": "libgcc/config/libbid/_dd_to_si.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_si.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SItype\n+__bid_fixddsi (_Decimal64 x) {\n+  SItype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_int32_xint (ux.i);\n+  return (res);\n+}\n+\n+"}, {"sha": "da9a56ac44c924f4b58de1b4b4bcd28b47a72b5a", "filename": "libgcc/config/libbid/_dd_to_td.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal128\n+__bid_extendddtd2 (_Decimal64 x) {\n+  union decimal128 res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res.i = __bid64_to_bid128 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "a9bb8bd762274b901b6a19b7e58265b38fc01719", "filename": "libgcc/config/libbid/_dd_to_tf.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_tf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+TFtype\n+__bid_extendddtf (_Decimal64 x) {\n+  union float128 res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res.i = __bid64_to_binary128 (ux.i);\n+  return (res.f);\n+}\n+#endif"}, {"sha": "fce0bfabab65dca6fd4b5a1325895e4cbb5b81a3", "filename": "libgcc/config/libbid/_dd_to_udi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_udi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+UDItype\n+__bid_fixunsdddi (_Decimal64 x) {\n+  UDItype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_uint64_xint (ux.i);\n+  if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n+  return (res);\n+}\n+"}, {"sha": "da57b204e2097bd800fb9f299e2a9595ac745eae", "filename": "libgcc/config/libbid/_dd_to_usi.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_usi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+USItype\n+__bid_fixunsddsi (_Decimal64 x) {\n+  USItype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_uint32_xint (ux.i);\n+  if (res == 0x80000000) res = 0; // for NaNs too\n+  return (res);\n+}\n+"}, {"sha": "e798330c7ccf6d2c467fdd6340a08d3396ca9530", "filename": "libgcc/config/libbid/_dd_to_xf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_dd_to_xf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+XFtype\n+__bid_extendddxf (_Decimal64 x) {\n+  XFtype res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_to_binary80 (ux.i);\n+  return (res);\n+}"}, {"sha": "8e94212235e433439c2eebc1f883917b33fb71ed", "filename": "libgcc/config/libbid/_df_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_extenddfdd (DFtype x) {\n+  union decimal64 res;\n+  res.i = __binary64_to_bid64 (x);\n+  return (res.d);\n+}"}, {"sha": "f0b02077a952fe0155ccbf9ce2e384e57690435b", "filename": "libgcc/config/libbid/_df_to_sd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_truncdfsd (DFtype x) {\n+  union decimal32 res;\n+  res.i = __binary64_to_bid32 (x);\n+  return (res.d);\n+}"}, {"sha": "94761e9a570eeebcb07176303b701fbe8e908627", "filename": "libgcc/config/libbid/_df_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_df_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_extenddftd (DFtype x) {\n+  union decimal128 res;\n+  res.i = __binary64_to_bid128 (x);\n+  return (res.d);\n+}"}, {"sha": "177291c9ef98e3ac6696cd9b66268ee35e757fb8", "filename": "libgcc/config/libbid/_di_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_floatdidd (DItype x) {\n+  union decimal64 res;\n+  res.i = __bid64_from_int64 (x);\n+  return (res.d);\n+}"}, {"sha": "5d074c310ee655c98a316a1b8f91beb1ad9e4030", "filename": "libgcc/config/libbid/_di_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_floatdisd (DItype x) {\n+  union decimal32 res;\n+  UINT64 res64;\n+\n+  res64 = __bid64_from_int64 (x);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "206b5cd1b22ca06e0c9dc569d5db763ddd9a659e", "filename": "libgcc/config/libbid/_di_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_di_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_floatditd (DItype x) {\n+  union decimal128 res;\n+  res.i = __bid128_from_int64 (x);\n+  return (res.d);\n+}"}, {"sha": "4b3ab33ec46d675ee0d14d9b4200a3e15018762a", "filename": "libgcc/config/libbid/_div_dd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_divdd3 (_Decimal64 x, _Decimal64 y) {\n+  union decimal64 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid64_div (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "930ef39d4398d2df69abbbf403898c54a1a6f18a", "filename": "libgcc/config/libbid/_div_sd.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_divsd3 (_Decimal32 x, _Decimal32 y) {\n+  UINT64 x64, y64, res64;\n+  union decimal32 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res64 = __bid64_div (x64, y64);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "207f7a235d08c032578f7340c44491b73af3c4c8", "filename": "libgcc/config/libbid/_div_td.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_div_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_div_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_divtd3 (_Decimal128 x, _Decimal128 y) {\n+  union decimal128 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid128_div (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "bb7ef4a88f8be84c5e3d320011851ee86479b709", "filename": "libgcc/config/libbid/_eq_dd.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_eqdd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_equal (ux.i, uy.i);\n+  if (res == 0)\n+    res = 1;\n+  else\n+    res = 0;\n+  return (res);\n+}"}, {"sha": "f9ae000350904dd9d9069c0b60f929b1c69e337e", "filename": "libgcc/config/libbid/_eq_sd.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,48 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_eqsd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_equal (x64, y64);\n+  if (res == 0)\n+    res = 1;\n+  else\n+    res = 0;\n+  return (res);\n+}"}, {"sha": "ff8dfd55fec81732d4d0e34a8f2ff2b830dba676", "filename": "libgcc/config/libbid/_eq_td.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_eq_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_eq_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_eqtd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_equal (ux.i, uy.i);\n+  if (res == 0)\n+    res = 1;\n+  else\n+    res = 0;\n+  return (res);\n+}"}, {"sha": "c198d69504c52c0077220c3654f95386badcb308", "filename": "libgcc/config/libbid/_ge_dd.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_gedd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_greater_equal (ux.i, uy.i);\n+  if (res == 0) res = -1;\n+\n+  return (res);\n+}"}, {"sha": "a242079a8417a8927ee8a99a90859176c7cbfece", "filename": "libgcc/config/libbid/_ge_sd.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_gesd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_greater_equal (x64, y64);\n+  if (res == 0) res = -1;\n+\n+  return (res);\n+}"}, {"sha": "41b886f93fae8126bcc6dc789a5ed22a0594a675", "filename": "libgcc/config/libbid/_ge_td.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ge_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ge_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_getd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_greater_equal (ux.i, uy.i);\n+  if (res == 0) res = -1;\n+\n+  return (res);\n+}"}, {"sha": "d95b727d090d7b082ed32cbc798da20b34a58a0e", "filename": "libgcc/config/libbid/_gt_dd.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_gtdd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_greater (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "a755f9e7677397df6155ac125e7f44230b536ca8", "filename": "libgcc/config/libbid/_gt_sd.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_gtsd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_greater (x64, y64);\n+  return (res);\n+}"}, {"sha": "783594e7ddde3bb3758986b222fe2add24e008c9", "filename": "libgcc/config/libbid/_gt_td.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_gt_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_gt_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_gttd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_greater (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "77c38ec1e908843e42ef6f97ce1eee1b11394a86", "filename": "libgcc/config/libbid/_isinfd128.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd128.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+int\n+isinfd128 (_Decimal128 x) {\n+  int res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_isInf (ux.i);\n+  return (res);\n+}\n+"}, {"sha": "74327d75969ef4fae90d92c9c5e62840293fe8e4", "filename": "libgcc/config/libbid/_isinfd32.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd32.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+int\n+isinfd32 (_Decimal32 x) {\n+  int res;\n+  UINT64 x64;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  res = __bid64_isInf (x64);\n+  return (res);\n+}\n+"}, {"sha": "579e107da35c5f8ab8ed6252a83c43a9e4380722", "filename": "libgcc/config/libbid/_isinfd64.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_isinfd64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+int\n+isinfd64 (_Decimal64 x) {\n+  int res;\n+  union decimal64 ux;\n+\n+  ux.d = x;\n+  res = __bid64_isInf (ux.i);\n+  return (res);\n+}\n+"}, {"sha": "e928c4afea7a449ce6c6e2aaf992a3514f6658c2", "filename": "libgcc/config/libbid/_le_dd.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_ledd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_less_equal (ux.i, uy.i);\n+  if (res != 0)\n+    res = -1;\n+  else\n+    res = 1;\n+  return (res);\n+}"}, {"sha": "460fc65296dca4b117fe3e297f89d49c787c5d08", "filename": "libgcc/config/libbid/_le_sd.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,48 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_lesd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_less_equal (x64, y64);\n+  if (res != 0)\n+    res = -1;\n+  else\n+    res = 1;\n+  return (res);\n+}"}, {"sha": "41e9aa59f4451acc60f862c719f18cc4cbc2a9d5", "filename": "libgcc/config/libbid/_le_td.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_le_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_le_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_letd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_less_equal (ux.i, uy.i);\n+  if (res != 0)\n+    res = -1;\n+  else\n+    res = 1;\n+  return (res);\n+}"}, {"sha": "2fe4371c525167e3785682e2f94923fba40e16e3", "filename": "libgcc/config/libbid/_lt_dd.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_ltdd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = -__bid64_quiet_less (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "64737101594e66c99a38471cc708142e52cdc496", "filename": "libgcc/config/libbid/_lt_sd.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_ltsd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = -__bid64_quiet_less (x64, y64);\n+  return (res);\n+}"}, {"sha": "573a328fdc16700509d796845048af6cf827f4b9", "filename": "libgcc/config/libbid/_lt_td.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_lt_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_lt_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_lttd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = -__bid128_quiet_less (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "79d70ebfb12269f2222f2733e7a1830447631dab", "filename": "libgcc/config/libbid/_mul_dd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_muldd3 (_Decimal64 x, _Decimal64 y) {\n+  union decimal64 ux, uy, res;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid64_mul (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "194b5f2acc130f9938fd5eb7baa8fa338ddd2339", "filename": "libgcc/config/libbid/_mul_sd.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_mulsd3 (_Decimal32 x, _Decimal32 y) {\n+  UINT64 x64, y64, res64;\n+  union decimal32 ux, uy, res;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res64 = __bid64_mul (x64, y64);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "12a0ecd15495fa63c28283934c8ae20ded1e47aa", "filename": "libgcc/config/libbid/_mul_td.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_mul_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_mul_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_multd3 (_Decimal128 x, _Decimal128 y) {\n+  union decimal128 ux, uy, res;\n+\n+  ux.d = x;\n+  uy.d = y;\n+  res.i = __bid128_mul (ux.i, uy.i);\n+  return (res.d);\n+}"}, {"sha": "d89f2cb1887f2f271494fd21479870daf8e6f343", "filename": "libgcc/config/libbid/_ne_dd.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_nedd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_not_equal (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "a541c9cfa4d35ab2595bb366fdde0d083e6f29a8", "filename": "libgcc/config/libbid/_ne_sd.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_nesd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_not_equal (x64, y64);\n+  return (res);\n+}"}, {"sha": "8b6fbda737fc00b4d047345d9996a4c6897138ee", "filename": "libgcc/config/libbid/_ne_td.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_ne_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_ne_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_netd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_not_equal (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "8991cda75040a58335f76bdc823a9314040ff870", "filename": "libgcc/config/libbid/_sd_to_dd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal64\n+__bid_extendsddd2 (_Decimal32 x) {\n+  union decimal64 res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res.i = __bid32_to_bid64 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "5ccb67a0e5f2a9b5cf6103a8b44be94b81a9a179", "filename": "libgcc/config/libbid/_sd_to_df.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_df.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DFtype\n+__bid_extendsddf (_Decimal32 x) {\n+  DFtype res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res = __bid32_to_binary64 (ux.i);\n+  return (res);\n+}"}, {"sha": "8f4894cf769d70ba2722b37715bff451e95a5816", "filename": "libgcc/config/libbid/_sd_to_di.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_di.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DItype\n+__bid_fixsddi (_Decimal32 x) {\n+  DItype res;\n+  UINT64 x64;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  res = __bid64_to_int64_xint (x64);\n+  return (res);\n+}\n+\n+"}, {"sha": "ea78ff8e95f1f6e0a1165d6c39e756e2d042d6a8", "filename": "libgcc/config/libbid/_sd_to_sf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_sf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SFtype\n+__bid_truncsdsf (_Decimal32 x) {\n+  SFtype res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res = __bid32_to_binary32 (ux.i);\n+  return (res);\n+}"}, {"sha": "d18771737348c28f006ee257406c5f14bf30451a", "filename": "libgcc/config/libbid/_sd_to_si.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_si.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SItype\n+__bid_fixsdsi (_Decimal32 x) {\n+  SItype res;\n+  UINT64 x64;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  res = __bid64_to_int32_xint (x64);\n+  return (res);\n+}\n+\n+"}, {"sha": "5d965d5af43507a9420b9aeae1afc4fd45585f27", "filename": "libgcc/config/libbid/_sd_to_td.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal128\n+__bid_extendsdtd2 (_Decimal32 x) {\n+  union decimal128 res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res.i = __bid32_to_bid128 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "16c84f8c5f09ddd0af6427713401ca66266e2e1b", "filename": "libgcc/config/libbid/_sd_to_tf.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_tf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+TFtype\n+__bid_extendsdtf (_Decimal32 x) {\n+  union float128 res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res.i = __bid32_to_binary128 (ux.i);\n+  return (res.f);\n+}\n+#endif"}, {"sha": "f6e035d3e4c9d5e85e5cd28ec5018355052333c8", "filename": "libgcc/config/libbid/_sd_to_udi.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_udi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+UDItype\n+__bid_fixunssddi (_Decimal32 x) {\n+  UDItype res;\n+  UINT64 x64;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  res = __bid64_to_uint64_xint (x64);\n+  if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n+  return (res);\n+}\n+"}, {"sha": "1cd329477f57336aeba6624d1b2179e4c1c0867e", "filename": "libgcc/config/libbid/_sd_to_usi.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_usi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+USItype\n+__bid_fixunssdsi (_Decimal32 x) {\n+  USItype res;\n+  UINT64 x64;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  res = __bid64_to_uint32_xint (x64);\n+  if (res == 0x80000000) res = 0; // for NaNs too\n+  return (res);\n+}\n+"}, {"sha": "46b14906c4661bf0d94bf7559db50cb65c1eab83", "filename": "libgcc/config/libbid/_sd_to_xf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sd_to_xf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+XFtype\n+__bid_extendsdxf (_Decimal32 x) {\n+  XFtype res;\n+  union decimal32 ux;\n+\n+  ux.d = x;\n+  res = __bid32_to_binary80 (ux.i);\n+  return (res);\n+}"}, {"sha": "e8a6ccfdffef8431059848a7340dced5d4117e81", "filename": "libgcc/config/libbid/_sf_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_extendsfdd (SFtype x) {\n+  union decimal64 res;\n+  res.i = __binary32_to_bid64 (x);\n+  return (res.d);\n+}"}, {"sha": "638a88c15a1bcac9e065e890ab71cad70ad9ca60", "filename": "libgcc/config/libbid/_sf_to_sd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_extendsfsd (SFtype x) {\n+  union decimal32 res;\n+  res.i = __binary32_to_bid32 (x);\n+  return (res.d);\n+}"}, {"sha": "9d55bbe03e9ee7bd2b524ab0a7a41fcb728fd58c", "filename": "libgcc/config/libbid/_sf_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_sf_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_extendsftd (SFtype x) {\n+  union decimal128 res;\n+  res.i = __binary32_to_bid128 (x);\n+  return (res.d);\n+}"}, {"sha": "c702efe1252569418fbd133f9c423debb3f810a8", "filename": "libgcc/config/libbid/_si_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_floatsidd (SItype x) {\n+  union decimal64 res;\n+  res.i = __bid64_from_int32 (x);\n+  return (res.d);\n+}"}, {"sha": "2f7a7e97970d8c9de86a41536acf982a0e32495c", "filename": "libgcc/config/libbid/_si_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_floatsisd (SItype x) {\n+  union decimal32 res;\n+  UINT64 res64;\n+\n+  res64 = __bid64_from_int32 (x);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "93a91b0fb3642351098af4232d87dcf81a81e0d6", "filename": "libgcc/config/libbid/_si_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_si_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_floatsitd (SItype x) {\n+  union decimal128 res;\n+  res.i = __bid128_from_int32 (x);\n+  return (res.d);\n+}"}, {"sha": "d4c2be9a71678505ecd44c98484b7076db68ee13", "filename": "libgcc/config/libbid/_td_to_dd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal64\n+__bid_trunctddd2 (_Decimal128 x) {\n+  union decimal128 ux;\n+  union decimal64 res;\n+\n+  ux.d = x;\n+  res.i = __bid128_to_bid64 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "48bf0923164c2ccb09ae419626f88a77e6aac6dc", "filename": "libgcc/config/libbid/_td_to_df.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_df.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DFtype\n+__bid_trunctddf (_Decimal128 x) {\n+  DFtype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_binary64 (ux.i);\n+  return (res);\n+}"}, {"sha": "fcdc8534bbe5967dec8efc98d2f7dcb85ee730d0", "filename": "libgcc/config/libbid/_td_to_di.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_di.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+DItype\n+__bid_fixtddi (_Decimal128 x) {\n+  DItype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_int64_xint (ux.i);\n+  return (res);\n+}\n+\n+"}, {"sha": "d2a64fc554bccab755d7403aa0d47b0d7d905dd4", "filename": "libgcc/config/libbid/_td_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+ \n+_Decimal32\n+__bid_trunctdsd2 (_Decimal128 x) {\n+  union decimal128 ux;\n+  union decimal32 res;\n+\n+  ux.d = x;\n+  res.i = __bid128_to_bid32 (ux.i);\n+  return (res.d);\n+}"}, {"sha": "8f775189cc65f1806993eb386878ecab84befd44", "filename": "libgcc/config/libbid/_td_to_sf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_sf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SFtype\n+__bid_trunctdsf (_Decimal128 x) {\n+  SFtype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_binary32 (ux.i);\n+  return (res);\n+}"}, {"sha": "e92b3fd2414bd83180a136ef093f040f7020b1cf", "filename": "libgcc/config/libbid/_td_to_si.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_si.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+SItype\n+__bid_fixtdsi (_Decimal128 x) {\n+  SItype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_int32_xint (ux.i);\n+  return (res);\n+}\n+"}, {"sha": "0e99199143125a9c15a40653b668cbaca3700438", "filename": "libgcc/config/libbid/_td_to_tf.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_tf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+TFtype\n+__bid_trunctdtf (_Decimal128 x) {\n+  union float128 res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res.i = __bid128_to_binary128 (ux.i);\n+  return (res.f);\n+}\n+#endif"}, {"sha": "92251f7c3167e09baafbdc315ef834ec93fccf5e", "filename": "libgcc/config/libbid/_td_to_udi.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_udi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+UDItype\n+__bid_fixunstddi (_Decimal128 x) {\n+  UDItype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_uint64_xint (ux.i);\n+  if (res == 0x8000000000000000ull) res = 0; // for NaNs too\n+  return (res);\n+}\n+\n+"}, {"sha": "ee755359632687ed2797fc912918e1fb975d5a47", "filename": "libgcc/config/libbid/_td_to_usi.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_usi.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+USItype\n+__bid_fixunstdsi (_Decimal128 x) {\n+  USItype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_uint32_xint (ux.i);\n+  if (res == 0x80000000) res = 0; // for NaNs too\n+  return (res);\n+}\n+\n+"}, {"sha": "92eecca56b1fae33b9f791d55b415b190e526ae5", "filename": "libgcc/config/libbid/_td_to_xf.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_td_to_xf.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+XFtype\n+__bid_trunctdxf (_Decimal128 x) {\n+  XFtype res;\n+  union decimal128 ux;\n+\n+  ux.d = x;\n+  res = __bid128_to_binary80 (ux.i);\n+  return (res);\n+}"}, {"sha": "5ae3aeff48273c82abb2174a5467fa6542cc3062", "filename": "libgcc/config/libbid/_tf_to_dd.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+_Decimal64\n+__bid_trunctfdd (TFtype x) {\n+  union decimal64 res;\n+  union float128 ux;\n+\n+  ux.f = x;\n+  res.i = __binary128_to_bid64 (ux.i);\n+  return (res.d);\n+}\n+#endif"}, {"sha": "4aa4f1517f0af54cd925d231cc04246c106f6223", "filename": "libgcc/config/libbid/_tf_to_sd.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+_Decimal32\n+__bid_trunctfsd (TFtype x) {\n+  union decimal32 res;\n+  union float128 ux;\n+\n+  ux.f = x;\n+  res.i = __binary128_to_bid32 (ux.i);\n+  return (res.d);\n+}\n+#endif"}, {"sha": "090ed43cd9650ba048ac7b46a6b147cf2c39d622", "filename": "libgcc/config/libbid/_tf_to_td.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_tf_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+#if LIBGCC2_HAS_TF_MODE || BID_HAS_TF_MODE\n+_Decimal128\n+__bid_extendtftd (TFtype x) {\n+  union decimal128 res;\n+  union float128 ux;\n+\n+  ux.f = x;\n+  res.i = __binary128_to_bid128 (ux.i);\n+  return (res.d);\n+}\n+#endif"}, {"sha": "8bf196c76c571695768d4aac0b3fbe07a3cfd04b", "filename": "libgcc/config/libbid/_udi_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_floatunsdidd (UDItype x) {\n+  union decimal64 res;\n+  res.i = __bid64_from_uint64 (x);\n+  return (res.d);\n+}"}, {"sha": "b8533ea0f3d2a05cce27c9eeeae29866af4f7351", "filename": "libgcc/config/libbid/_udi_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_floatunsdisd (UDItype x) {\n+  union decimal32 res;\n+  UINT64 res64;\n+\n+  res64 = __bid64_from_uint64 (x);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "53aa20bcfcd1b75d04b51a61c27cfba4a764909e", "filename": "libgcc/config/libbid/_udi_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_udi_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_floatunsditd (UDItype x) {\n+  union decimal128 res;\n+  res.i = __bid128_from_uint64 (x);\n+  return (res.d);\n+}"}, {"sha": "fc81ca14e46811f3ccfd9913f9f4c94d668cd8e5", "filename": "libgcc/config/libbid/_unord_dd.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_unorddd2 (_Decimal64 x, _Decimal64 y) {\n+  CMPtype res;\n+  union decimal64 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid64_quiet_unordered (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "753a67fd924df4189c5f9586fd563d5ec0509149", "filename": "libgcc/config/libbid/_unord_sd.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_unordsd2 (_Decimal32 x, _Decimal32 y) {\n+  CMPtype res;\n+  UINT64 x64, y64;\n+  union decimal32 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  x64 = __bid32_to_bid64 (ux.i);\n+  y64 = __bid32_to_bid64 (uy.i);\n+  res = __bid64_quiet_unordered (x64, y64);\n+  return (res);\n+}\n+"}, {"sha": "73dd974f9274f7f91dce7eaf604c3dfc186b2264", "filename": "libgcc/config/libbid/_unord_td.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_unord_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_unord_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+CMPtype\n+__bid_unordtd2 (_Decimal128 x, _Decimal128 y) {\n+  CMPtype res;\n+  union decimal128 ux, uy;\n+ \n+  ux.d = x;\n+  uy.d = y;\n+  res = __bid128_quiet_unordered (ux.i, uy.i);\n+  return (res);\n+}"}, {"sha": "db398a61bb3fbd7476f09d74b397811abe1f699f", "filename": "libgcc/config/libbid/_usi_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_floatunssidd (USItype x) {\n+  union decimal64 res;\n+  res.i = __bid64_from_uint32 (x);\n+  return (res.d);\n+}"}, {"sha": "3c8fa21a5f3f71fa3e3735723d25b9833fc069a0", "filename": "libgcc/config/libbid/_usi_to_sd.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,40 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_floatunssisd (USItype x) {\n+  union decimal32 res;\n+  UINT64 res64;\n+\n+  res64 = __bid64_from_uint32 (x);\n+  res.i = __bid64_to_bid32 (res64);\n+  return (res.d);\n+}"}, {"sha": "8cdc6e2ef13f8d58557ae0c0dc891089ea7b914b", "filename": "libgcc/config/libbid/_usi_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_usi_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_floatunssitd (USItype x) {\n+  union decimal128 res;\n+  res.i = __bid128_from_uint32 (x);\n+  return (res.d);\n+}"}, {"sha": "27e418fe296d17e437720fd9aa212d1fae412a82", "filename": "libgcc/config/libbid/_xf_to_dd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_dd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal64\n+__bid_truncxfdd (XFtype x) {\n+  union decimal64 res;\n+  res.i = __binary80_to_bid64 (x);\n+  return (res.d);\n+}"}, {"sha": "3c83e5873f29d24ede27da30832b8a5042ae9882", "filename": "libgcc/config/libbid/_xf_to_sd.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_sd.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal32\n+__bid_truncxfsd (XFtype x) {\n+  union decimal32 res;\n+  res.i = __binary80_to_bid32 (x);\n+  return (res.d);\n+}"}, {"sha": "48015ebca8d001489abe0f0fe52637e728f848ea", "filename": "libgcc/config/libbid/_xf_to_td.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2F_xf_to_td.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,37 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_conf.h\"\n+#include \"bid_functions.h\"\n+\n+_Decimal128\n+__bid_extendxftd (XFtype x) {\n+  union decimal128 res;\n+  res.i = __binary80_to_bid128 (x);\n+  return (res.d);\n+}"}, {"sha": "41b593516fb34238a60135dd1c2f93781dd66268", "filename": "libgcc/config/libbid/b2d.h", "status": "added", "additions": 3050, "deletions": 0, "changes": 3050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fb2d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fb2d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fb2d.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "f66768561366576126c9aa6d8c9fb106b917151b", "filename": "libgcc/config/libbid/bid128.c", "status": "added", "additions": 4042, "deletions": 0, "changes": 4042, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "6b2c535c36ee4aa9aa02d093bbeaa408fd389e9c", "filename": "libgcc/config/libbid/bid128_2_str.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,38 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+extern UINT64 __bid_Twoto60_m_10to18;\n+extern UINT64 __bid_Twoto60;\n+extern UINT64 __bid_Inv_Tento9;\n+extern UINT32 __bid_Twoto30_m_10to9;\n+extern UINT32 __bid_Tento9;\n+extern UINT32 __bid_Tento6;\n+extern UINT32 __bid_Tento3;\n+\n+extern char __bid_midi_tbl[1000][3];\n+extern UINT64 __bid_mod10_18_tbl[9][128];"}, {"sha": "d7da345480d4047b9752e7b21b7e97187be7dece", "filename": "libgcc/config/libbid/bid128_2_str_macros.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_macros.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,154 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define __L0_Normalize_10to18( X_hi, X_lo )            \\\n+{                                                      \\\n+UINT64 L0_tmp;                                         \\\n+L0_tmp = (X_lo) + __bid_Twoto60_m_10to18;                    \\\n+if (L0_tmp & __bid_Twoto60)                                  \\\n+ {(X_hi)=(X_hi)+1;(X_lo)=((L0_tmp<<4)>>4);}            \\\n+}\n+\n+\n+#define __L0_Normalize_10to9( X_hi, X_lo )             \\\n+{                                                      \\\n+UINT32 L0_tmp;                                         \\\n+L0_tmp = (X_lo) + __bid_Twoto30_m_10to9;                     \\\n+if (L0_tmp & 0x40000000)                               \\\n+ {(X_hi)=(X_hi)+1;(X_lo)=((L0_tmp<<2)>>2);}            \\\n+}\n+\n+\n+#define __L0_Split_MiDi_2( X, ptr )                    \\\n+{                                                      \\\n+UINT32 L0_head, L0_tail, L0_tmp;                       \\\n+ L0_head = (X) >> 10;                                  \\\n+ L0_tail = ((X)&(0x03FF))+(L0_head<<5)-(L0_head<<3);   \\\n+ L0_tmp  = (L0_tail)>>10; L0_head += L0_tmp;           \\\n+ L0_tail = (L0_tail&(0x03FF))+(L0_tmp<<5)-(L0_tmp<<3); \\\n+ if (L0_tail > 999){L0_tail -= 1000; L0_head += 1;}    \\\n+ *((ptr)++) = L0_head; *((ptr)++) = L0_tail;           \\\n+}\n+\n+\n+#define __L0_Split_MiDi_3( X, ptr )                    \\\n+{                                                      \\\n+UINT32 L0_X, L0_head, L0_mid, L0_tail, L0_tmp;         \\\n+ L0_X    = (UINT32)((X));                              \\\n+ L0_head = ((L0_X>>17)*34359)>>18;                     \\\n+ L0_X   -= L0_head*1000000;                            \\\n+ if (L0_X >= 1000000){L0_X -= 1000000;L0_head+=1;}     \\\n+ L0_mid  = L0_X >> 10;                                 \\\n+ L0_tail = (L0_X & (0x03FF))+(L0_mid<<5)-(L0_mid<<3);  \\\n+ L0_tmp  = (L0_tail)>>10; L0_mid += L0_tmp;            \\\n+ L0_tail = (L0_tail&(0x3FF))+(L0_tmp<<5)-(L0_tmp<<3);  \\\n+ if (L0_tail>999){L0_tail-=1000;L0_mid+=1;}            \\\n+ *((ptr)++)=L0_head;*((ptr)++)=L0_mid;                 \\\n+ *((ptr)++)=L0_tail;                                   \\\n+}\n+\n+#define __L1_Split_MiDi_6( X, ptr )                    \\\n+{                                                      \\\n+UINT32 L1_X_hi, L1_X_lo;                               \\\n+UINT64 L1_Xhi_64, L1_Xlo_64;                           \\\n+L1_Xhi_64 = ( ((X)>>28)*__bid_Inv_Tento9 ) >> 33;            \\\n+L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)__bid_Tento9;            \\\n+if (L1_Xlo_64 >= (UINT64)__bid_Tento9)                       \\\n+ {L1_Xlo_64-=(UINT64)__bid_Tento9;L1_Xhi_64+=1;}             \\\n+L1_X_hi=(UINT32)L1_Xhi_64; L1_X_lo=(UINT32)L1_Xlo_64;  \\\n+__L0_Split_MiDi_3(L1_X_hi,(ptr));                      \\\n+__L0_Split_MiDi_3(L1_X_lo,(ptr));                      \\\n+}\n+\n+#define __L1_Split_MiDi_6_Lead( X, ptr )               \\\n+{                                                      \\\n+UINT32 L1_X_hi, L1_X_lo;                               \\\n+UINT64 L1_Xhi_64, L1_Xlo_64;                           \\\n+if ((X)>=(UINT64)__bid_Tento9){                              \\\n+  L1_Xhi_64 = ( ((X)>>28)*__bid_Inv_Tento9 ) >> 33;          \\\n+  L1_Xlo_64 = (X) - L1_Xhi_64*(UINT64)__bid_Tento9;          \\\n+  if (L1_Xlo_64 >= (UINT64)__bid_Tento9)                     \\\n+   {L1_Xlo_64-=(UINT64)__bid_Tento9;L1_Xhi_64+=1;}           \\\n+  L1_X_hi=(UINT32)L1_Xhi_64;                           \\\n+  L1_X_lo=(UINT32)L1_Xlo_64;                           \\\n+  if (L1_X_hi>=__bid_Tento6){                                \\\n+     __L0_Split_MiDi_3(L1_X_hi,(ptr));                 \\\n+     __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n+  }                                                    \\\n+  else if (L1_X_hi>=__bid_Tento3){                           \\\n+     __L0_Split_MiDi_2(L1_X_hi,(ptr));                 \\\n+     __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n+  }                                                    \\\n+  else {                                               \\\n+       *((ptr)++) = L1_X_hi;                           \\\n+       __L0_Split_MiDi_3(L1_X_lo,(ptr));               \\\n+  }                                                    \\\n+}                                                      \\\n+else {                                                 \\\n+  L1_X_lo = (UINT32)(X);                               \\\n+  if (L1_X_lo>=__bid_Tento6){                                \\\n+     __L0_Split_MiDi_3(L1_X_lo,(ptr));                 \\\n+  }                                                    \\\n+  else if (L1_X_lo>=__bid_Tento3){                           \\\n+     __L0_Split_MiDi_2(L1_X_lo,(ptr));                 \\\n+  }                                                    \\\n+  else {                                               \\\n+       *((ptr)++) = L1_X_lo;                           \\\n+  }                                                    \\\n+}                                                      \\\n+}\n+\n+\n+#define __L0_MiDi2Str( X, c_ptr )              \\\n+{                                              \\\n+char *L0_src;                                  \\\n+ L0_src = __bid_midi_tbl[(X)];                       \\\n+ *((c_ptr)++) = *(L0_src++);                   \\\n+ *((c_ptr)++) = *(L0_src++);                   \\\n+ *((c_ptr)++) = *(L0_src);                     \\\n+}\n+\n+#define __L0_MiDi2Str_Lead( X, c_ptr )         \\\n+{                                              \\\n+char *L0_src;                                  \\\n+ L0_src = __bid_midi_tbl[(X)];                       \\\n+ if ((X)>=100){                                \\\n+ *((c_ptr)++) = *(L0_src++);                   \\\n+ *((c_ptr)++) = *(L0_src++);                   \\\n+ *((c_ptr)++) = *(L0_src);                     \\\n+ }                                             \\\n+ else if ((X)>=10){                            \\\n+ L0_src++;                                     \\\n+ *((c_ptr)++) = *(L0_src++);                   \\\n+ *((c_ptr)++) = *(L0_src);                     \\\n+ }                                             \\\n+ else {                                        \\\n+ L0_src++;L0_src++;                            \\\n+ *((c_ptr)++) = *(L0_src);                     \\\n+}                                              \\\n+}"}, {"sha": "780cb64a3a3d8b79b2685b08da0bfa4cd9ed9711", "filename": "libgcc/config/libbid/bid128_2_str_tables.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_2_str_tables.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,523 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+UINT64 __bid_Twoto60_m_10to18 = 152921504606846976LL;\n+UINT64 __bid_Twoto60 = 0x1000000000000000LL;\n+UINT64 __bid_Inv_Tento9 = 2305843009LL;        /* floor(2^61/10^9) */\n+UINT32 __bid_Twoto30_m_10to9 = 73741824;\n+UINT32 __bid_Tento9 = 1000000000;\n+UINT32 __bid_Tento6 = 1000000;\n+UINT32 __bid_Tento3 = 1000;\n+\n+char __bid_midi_tbl[1000][3] = {\n+  \"000\", \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"007\", \"008\", \"009\",\n+  \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\", \"019\",\n+  \"020\", \"021\", \"022\", \"023\", \"024\", \"025\", \"026\", \"027\", \"028\", \"029\",\n+  \"030\", \"031\", \"032\", \"033\", \"034\", \"035\", \"036\", \"037\", \"038\", \"039\",\n+  \"040\", \"041\", \"042\", \"043\", \"044\", \"045\", \"046\", \"047\", \"048\", \"049\",\n+  \"050\", \"051\", \"052\", \"053\", \"054\", \"055\", \"056\", \"057\", \"058\", \"059\",\n+  \"060\", \"061\", \"062\", \"063\", \"064\", \"065\", \"066\", \"067\", \"068\", \"069\",\n+  \"070\", \"071\", \"072\", \"073\", \"074\", \"075\", \"076\", \"077\", \"078\", \"079\",\n+  \"080\", \"081\", \"082\", \"083\", \"084\", \"085\", \"086\", \"087\", \"088\", \"089\",\n+  \"090\", \"091\", \"092\", \"093\", \"094\", \"095\", \"096\", \"097\", \"098\", \"099\",\n+  \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\", \"108\", \"109\",\n+  \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\", \"117\", \"118\", \"119\",\n+  \"120\", \"121\", \"122\", \"123\", \"124\", \"125\", \"126\", \"127\", \"128\", \"129\",\n+  \"130\", \"131\", \"132\", \"133\", \"134\", \"135\", \"136\", \"137\", \"138\", \"139\",\n+  \"140\", \"141\", \"142\", \"143\", \"144\", \"145\", \"146\", \"147\", \"148\", \"149\",\n+  \"150\", \"151\", \"152\", \"153\", \"154\", \"155\", \"156\", \"157\", \"158\", \"159\",\n+  \"160\", \"161\", \"162\", \"163\", \"164\", \"165\", \"166\", \"167\", \"168\", \"169\",\n+  \"170\", \"171\", \"172\", \"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\",\n+  \"180\", \"181\", \"182\", \"183\", \"184\", \"185\", \"186\", \"187\", \"188\", \"189\",\n+  \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\", \"198\", \"199\",\n+  \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"207\", \"208\", \"209\",\n+  \"210\", \"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"218\", \"219\",\n+  \"220\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\", \"229\",\n+  \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\", \"238\", \"239\",\n+  \"240\", \"241\", \"242\", \"243\", \"244\", \"245\", \"246\", \"247\", \"248\", \"249\",\n+  \"250\", \"251\", \"252\", \"253\", \"254\", \"255\", \"256\", \"257\", \"258\", \"259\",\n+  \"260\", \"261\", \"262\", \"263\", \"264\", \"265\", \"266\", \"267\", \"268\", \"269\",\n+  \"270\", \"271\", \"272\", \"273\", \"274\", \"275\", \"276\", \"277\", \"278\", \"279\",\n+  \"280\", \"281\", \"282\", \"283\", \"284\", \"285\", \"286\", \"287\", \"288\", \"289\",\n+  \"290\", \"291\", \"292\", \"293\", \"294\", \"295\", \"296\", \"297\", \"298\", \"299\",\n+  \"300\", \"301\", \"302\", \"303\", \"304\", \"305\", \"306\", \"307\", \"308\", \"309\",\n+  \"310\", \"311\", \"312\", \"313\", \"314\", \"315\", \"316\", \"317\", \"318\", \"319\",\n+  \"320\", \"321\", \"322\", \"323\", \"324\", \"325\", \"326\", \"327\", \"328\", \"329\",\n+  \"330\", \"331\", \"332\", \"333\", \"334\", \"335\", \"336\", \"337\", \"338\", \"339\",\n+  \"340\", \"341\", \"342\", \"343\", \"344\", \"345\", \"346\", \"347\", \"348\", \"349\",\n+  \"350\", \"351\", \"352\", \"353\", \"354\", \"355\", \"356\", \"357\", \"358\", \"359\",\n+  \"360\", \"361\", \"362\", \"363\", \"364\", \"365\", \"366\", \"367\", \"368\", \"369\",\n+  \"370\", \"371\", \"372\", \"373\", \"374\", \"375\", \"376\", \"377\", \"378\", \"379\",\n+  \"380\", \"381\", \"382\", \"383\", \"384\", \"385\", \"386\", \"387\", \"388\", \"389\",\n+  \"390\", \"391\", \"392\", \"393\", \"394\", \"395\", \"396\", \"397\", \"398\", \"399\",\n+  \"400\", \"401\", \"402\", \"403\", \"404\", \"405\", \"406\", \"407\", \"408\", \"409\",\n+  \"410\", \"411\", \"412\", \"413\", \"414\", \"415\", \"416\", \"417\", \"418\", \"419\",\n+  \"420\", \"421\", \"422\", \"423\", \"424\", \"425\", \"426\", \"427\", \"428\", \"429\",\n+  \"430\", \"431\", \"432\", \"433\", \"434\", \"435\", \"436\", \"437\", \"438\", \"439\",\n+  \"440\", \"441\", \"442\", \"443\", \"444\", \"445\", \"446\", \"447\", \"448\", \"449\",\n+  \"450\", \"451\", \"452\", \"453\", \"454\", \"455\", \"456\", \"457\", \"458\", \"459\",\n+  \"460\", \"461\", \"462\", \"463\", \"464\", \"465\", \"466\", \"467\", \"468\", \"469\",\n+  \"470\", \"471\", \"472\", \"473\", \"474\", \"475\", \"476\", \"477\", \"478\", \"479\",\n+  \"480\", \"481\", \"482\", \"483\", \"484\", \"485\", \"486\", \"487\", \"488\", \"489\",\n+  \"490\", \"491\", \"492\", \"493\", \"494\", \"495\", \"496\", \"497\", \"498\", \"499\",\n+  \"500\", \"501\", \"502\", \"503\", \"504\", \"505\", \"506\", \"507\", \"508\", \"509\",\n+  \"510\", \"511\", \"512\", \"513\", \"514\", \"515\", \"516\", \"517\", \"518\", \"519\",\n+  \"520\", \"521\", \"522\", \"523\", \"524\", \"525\", \"526\", \"527\", \"528\", \"529\",\n+  \"530\", \"531\", \"532\", \"533\", \"534\", \"535\", \"536\", \"537\", \"538\", \"539\",\n+  \"540\", \"541\", \"542\", \"543\", \"544\", \"545\", \"546\", \"547\", \"548\", \"549\",\n+  \"550\", \"551\", \"552\", \"553\", \"554\", \"555\", \"556\", \"557\", \"558\", \"559\",\n+  \"560\", \"561\", \"562\", \"563\", \"564\", \"565\", \"566\", \"567\", \"568\", \"569\",\n+  \"570\", \"571\", \"572\", \"573\", \"574\", \"575\", \"576\", \"577\", \"578\", \"579\",\n+  \"580\", \"581\", \"582\", \"583\", \"584\", \"585\", \"586\", \"587\", \"588\", \"589\",\n+  \"590\", \"591\", \"592\", \"593\", \"594\", \"595\", \"596\", \"597\", \"598\", \"599\",\n+  \"600\", \"601\", \"602\", \"603\", \"604\", \"605\", \"606\", \"607\", \"608\", \"609\",\n+  \"610\", \"611\", \"612\", \"613\", \"614\", \"615\", \"616\", \"617\", \"618\", \"619\",\n+  \"620\", \"621\", \"622\", \"623\", \"624\", \"625\", \"626\", \"627\", \"628\", \"629\",\n+  \"630\", \"631\", \"632\", \"633\", \"634\", \"635\", \"636\", \"637\", \"638\", \"639\",\n+  \"640\", \"641\", \"642\", \"643\", \"644\", \"645\", \"646\", \"647\", \"648\", \"649\",\n+  \"650\", \"651\", \"652\", \"653\", \"654\", \"655\", \"656\", \"657\", \"658\", \"659\",\n+  \"660\", \"661\", \"662\", \"663\", \"664\", \"665\", \"666\", \"667\", \"668\", \"669\",\n+  \"670\", \"671\", \"672\", \"673\", \"674\", \"675\", \"676\", \"677\", \"678\", \"679\",\n+  \"680\", \"681\", \"682\", \"683\", \"684\", \"685\", \"686\", \"687\", \"688\", \"689\",\n+  \"690\", \"691\", \"692\", \"693\", \"694\", \"695\", \"696\", \"697\", \"698\", \"699\",\n+  \"700\", \"701\", \"702\", \"703\", \"704\", \"705\", \"706\", \"707\", \"708\", \"709\",\n+  \"710\", \"711\", \"712\", \"713\", \"714\", \"715\", \"716\", \"717\", \"718\", \"719\",\n+  \"720\", \"721\", \"722\", \"723\", \"724\", \"725\", \"726\", \"727\", \"728\", \"729\",\n+  \"730\", \"731\", \"732\", \"733\", \"734\", \"735\", \"736\", \"737\", \"738\", \"739\",\n+  \"740\", \"741\", \"742\", \"743\", \"744\", \"745\", \"746\", \"747\", \"748\", \"749\",\n+  \"750\", \"751\", \"752\", \"753\", \"754\", \"755\", \"756\", \"757\", \"758\", \"759\",\n+  \"760\", \"761\", \"762\", \"763\", \"764\", \"765\", \"766\", \"767\", \"768\", \"769\",\n+  \"770\", \"771\", \"772\", \"773\", \"774\", \"775\", \"776\", \"777\", \"778\", \"779\",\n+  \"780\", \"781\", \"782\", \"783\", \"784\", \"785\", \"786\", \"787\", \"788\", \"789\",\n+  \"790\", \"791\", \"792\", \"793\", \"794\", \"795\", \"796\", \"797\", \"798\", \"799\",\n+  \"800\", \"801\", \"802\", \"803\", \"804\", \"805\", \"806\", \"807\", \"808\", \"809\",\n+  \"810\", \"811\", \"812\", \"813\", \"814\", \"815\", \"816\", \"817\", \"818\", \"819\",\n+  \"820\", \"821\", \"822\", \"823\", \"824\", \"825\", \"826\", \"827\", \"828\", \"829\",\n+  \"830\", \"831\", \"832\", \"833\", \"834\", \"835\", \"836\", \"837\", \"838\", \"839\",\n+  \"840\", \"841\", \"842\", \"843\", \"844\", \"845\", \"846\", \"847\", \"848\", \"849\",\n+  \"850\", \"851\", \"852\", \"853\", \"854\", \"855\", \"856\", \"857\", \"858\", \"859\",\n+  \"860\", \"861\", \"862\", \"863\", \"864\", \"865\", \"866\", \"867\", \"868\", \"869\",\n+  \"870\", \"871\", \"872\", \"873\", \"874\", \"875\", \"876\", \"877\", \"878\", \"879\",\n+  \"880\", \"881\", \"882\", \"883\", \"884\", \"885\", \"886\", \"887\", \"888\", \"889\",\n+  \"890\", \"891\", \"892\", \"893\", \"894\", \"895\", \"896\", \"897\", \"898\", \"899\",\n+  \"900\", \"901\", \"902\", \"903\", \"904\", \"905\", \"906\", \"907\", \"908\", \"909\",\n+  \"910\", \"911\", \"912\", \"913\", \"914\", \"915\", \"916\", \"917\", \"918\", \"919\",\n+  \"920\", \"921\", \"922\", \"923\", \"924\", \"925\", \"926\", \"927\", \"928\", \"929\",\n+  \"930\", \"931\", \"932\", \"933\", \"934\", \"935\", \"936\", \"937\", \"938\", \"939\",\n+  \"940\", \"941\", \"942\", \"943\", \"944\", \"945\", \"946\", \"947\", \"948\", \"949\",\n+  \"950\", \"951\", \"952\", \"953\", \"954\", \"955\", \"956\", \"957\", \"958\", \"959\",\n+  \"960\", \"961\", \"962\", \"963\", \"964\", \"965\", \"966\", \"967\", \"968\", \"969\",\n+  \"970\", \"971\", \"972\", \"973\", \"974\", \"975\", \"976\", \"977\", \"978\", \"979\",\n+  \"980\", \"981\", \"982\", \"983\", \"984\", \"985\", \"986\", \"987\", \"988\", \"989\",\n+  \"990\", \"991\", \"992\", \"993\", \"994\", \"995\", \"996\", \"997\", \"998\", \"999\"\n+};\n+\n+UINT64 __bid_mod10_18_tbl[9][128] = {\n+  // 2^59 = 576460752303423488, A and B breakdown, where data = A*10^18 + B \n+\n+  { \n+  0LL, 0LL, 0LL, 576460752303423488LL,        \n+      //  0*2^59,  1*2^59\n+  1LL, 152921504606846976LL, 1LL, 729382256910270464LL,        \n+      //  2*2^59,  3*2^59\n+  2LL, 305843009213693952LL, 2LL, 882303761517117440LL,        \n+      //  4*2^59,  5*2^59\n+  3LL, 458764513820540928LL, 4LL, 35225266123964416LL,        \n+      //  6*2^59,  7*2^59\n+  4LL, 611686018427387904LL, 5LL, 188146770730811392LL,        \n+      //  8*2^59,  9*2^59\n+  5LL, 764607523034234880LL, 6LL, 341068275337658368LL,        \n+  // 10*2^59, 11*2^59\n+  6LL, 917529027641081856LL, 7LL, 493989779944505344LL,        \n+      // 12*2^59, 13*2^59\n+  8LL, 70450532247928832LL, 8LL, 646911284551352320LL,        \n+      // 14*2^59, 15*2^59\n+  9LL, 223372036854775808LL, 9LL, 799832789158199296LL,        \n+      // 16*2^59, 17*2^59\n+  10LL, 376293541461622784LL, 10LL, 952754293765046272LL,        \n+      // 18*2^59, 19*2^59\n+  11LL, 529215046068469760LL, 12LL, 105675798371893248LL,        \n+      // 20*2^59, 21*2^59\n+  12LL, 682136550675316736LL, 13LL, 258597302978740224LL,        \n+      // 22*2^59, 23*2^59\n+  13LL, 835058055282163712LL, 14LL, 411518807585587200LL,        \n+      // 24*2^59, 25*2^59\n+  14LL, 987979559889010688LL, 15LL, 564440312192434176LL,        \n+      // 26*2^59, 27*2^59\n+  16LL, 140901064495857664LL, 16LL, 717361816799281152LL,        \n+      // 28*2^59, 29*2^59\n+  17LL, 293822569102704640LL, 17LL, 870283321406128128LL,        \n+      // 30*2^59, 31*2^59\n+  18LL, 446744073709551616LL, 19LL, 23204826012975104LL,        \n+      // 32*2^59, 33*2^59\n+  19LL, 599665578316398592LL, 20LL, 176126330619822080LL,        \n+      // 34*2^59, 35*2^59\n+  20LL, 752587082923245568LL, 21LL, 329047835226669056LL,        \n+      // 36*2^59, 37*2^59\n+  21LL, 905508587530092544LL, 22LL, 481969339833516032LL,        \n+      // 38*2^59, 39*2^59\n+  23LL, 58430092136939520LL, 23LL, 634890844440363008LL,        \n+      // 40*2^59, 41*2^59\n+  24LL, 211351596743786496LL, 24LL, 787812349047209984LL,        \n+      // 42*2^59, 43*2^59\n+  25LL, 364273101350633472LL, 25LL, 940733853654056960LL,        \n+      // 44*2^59, 45*2^59\n+  26LL, 517194605957480448LL, 27LL, 93655358260903936LL,        \n+      // 46*2^59, 47*2^59\n+  27LL, 670116110564327424LL, 28LL, 246576862867750912LL,        \n+      // 48*2^59, 49*2^59\n+  28LL, 823037615171174400LL, 29LL, 399498367474597888LL,        \n+      // 50*2^59, 51*2^59\n+  29LL, 975959119778021376LL, 30LL, 552419872081444864LL,        \n+      // 52*2^59, 53*2^59\n+  31LL, 128880624384868352LL, 31LL, 705341376688291840LL,        \n+      // 54*2^59, 55*2^59\n+  32LL, 281802128991715328LL, 32LL, 858262881295138816LL,        \n+      // 56*2^59, 57*2^59\n+  33LL, 434723633598562304LL, 34LL, 11184385901985792LL,        \n+      // 58*2^59, 59*2^59\n+  34LL, 587645138205409280LL, 35LL, 164105890508832768LL,        \n+      // 60*2^59, 61*2^59\n+  35LL, 740566642812256256LL, 36LL, 317027395115679744LL,        \n+      // 62*2^59, 63*2^59\n+  },\n+\n+  {\n+  // 2^65 = 36*10^18 + 893488147419103232\n+  0LL, 0LL, 36LL, 893488147419103232LL,        \n+      //  0*2^65,  1*2^65\n+  73LL, 786976294838206464LL, 110LL, 680464442257309696LL,        \n+      //  2*2^65,  3*2^65\n+  147LL, 573952589676412928LL, 184LL, 467440737095516160LL,        \n+      //  4*2^65,  5*2^65\n+  221LL, 360928884514619392LL, 258LL, 254417031933722624LL,        \n+      //  6*2^65,  7*2^65\n+  295LL, 147905179352825856LL, 332LL, 41393326771929088LL,        \n+      //  8*2^65,  9*2^65\n+  368LL, 934881474191032320LL, 405LL, 828369621610135552LL,        \n+      //  0*2^65,  1*2^65\n+  442LL, 721857769029238784LL, 479LL, 615345916448342016LL,        \n+      //  2*2^65,  3*2^65\n+  516LL, 508834063867445248LL, 553LL, 402322211286548480LL,        \n+      //  4*2^65,  5*2^65\n+  590LL, 295810358705651712LL, 627LL, 189298506124754944LL,        \n+      //  6*2^65,  7*2^65\n+  664LL, 82786653543858176LL, 700LL, 976274800962961408LL,        \n+      //  8*2^65,  9*2^65\n+  737LL, 869762948382064640LL, 774LL, 763251095801167872LL,        \n+      //  0*2^65,  1*2^65\n+  811LL, 656739243220271104LL, 848LL, 550227390639374336LL,        \n+      //  2*2^65,  3*2^65\n+  885LL, 443715538058477568LL, 922LL, 337203685477580800LL,        \n+      //  4*2^65,  5*2^65\n+  959LL, 230691832896684032LL, 996LL, 124179980315787264LL,        \n+      //  6*2^65,  7*2^65\n+  1033LL, 17668127734890496LL, 1069LL, 911156275153993728LL,        \n+      //  8*2^65,  9*2^65\n+  1106LL, 804644422573096960LL, 1143LL, 698132569992200192LL,        \n+      //  0*2^65,  1*2^65\n+  1180LL, 591620717411303424LL, 1217LL, 485108864830406656LL,        \n+      //  2*2^65,  3*2^65\n+  1254LL, 378597012249509888LL, 1291LL, 272085159668613120LL,        \n+      //  4*2^65,  5*2^65\n+  1328LL, 165573307087716352LL, 1365LL, 59061454506819584LL,        \n+      //  6*2^65,  7*2^65\n+  1401LL, 952549601925922816LL, 1438LL, 846037749345026048LL,        \n+      //  8*2^65,  9*2^65\n+  1475LL, 739525896764129280LL, 1512LL, 633014044183232512LL,        \n+      //  0*2^65,  1*2^65\n+  1549LL, 526502191602335744LL, 1586LL, 419990339021438976LL,        \n+      //  2*2^65,  3*2^65\n+  1623LL, 313478486440542208LL, 1660LL, 206966633859645440LL,        \n+      //  4*2^65,  5*2^65\n+  1697LL, 100454781278748672LL, 1733LL, 993942928697851904LL,        \n+      //  6*2^65,  7*2^65\n+  1770LL, 887431076116955136LL, 1807LL, 780919223536058368LL,        \n+      //  8*2^65,  9*2^65\n+  1844LL, 674407370955161600LL, 1881LL, 567895518374264832LL,        \n+      //  0*2^65,  1*2^65\n+  1918LL, 461383665793368064LL, 1955LL, 354871813212471296LL,        \n+      //  2*2^65,  3*2^65\n+  1992LL, 248359960631574528LL, 2029LL, 141848108050677760LL,        \n+      //  4*2^65,  5*2^65\n+  2066LL, 35336255469780992LL, 2102LL, 928824402888884224LL,        \n+      //  6*2^65,  7*2^65\n+  2139LL, 822312550307987456LL, 2176LL, 715800697727090688LL,        \n+      //  8*2^65,  9*2^65\n+  2213LL, 609288845146193920LL, 2250LL, 502776992565297152LL,        \n+      //  0*2^65,  1*2^65\n+  2287LL, 396265139984400384LL, 2324LL, 289753287403503616LL,        \n+      //  2*2^65,  3*2^65\n+  },\n+\n+  {\n+  0LL, 0LL, 2361LL, 183241434822606848LL,\n+  4722LL, 366482869645213696LL, 7083LL, 549724304467820544LL,\n+  9444LL, 732965739290427392LL, 11805LL, 916207174113034240LL,\n+  14167LL, 99448608935641088LL, 16528LL, 282690043758247936LL,\n+  18889LL, 465931478580854784LL, 21250LL, 649172913403461632LL,\n+  23611LL, 832414348226068480LL, 25973LL, 15655783048675328LL,\n+  28334LL, 198897217871282176LL, 30695LL, 382138652693889024LL,\n+  33056LL, 565380087516495872LL, 35417LL, 748621522339102720LL,\n+  37778LL, 931862957161709568LL, 40140LL, 115104391984316416LL,\n+  42501LL, 298345826806923264LL, 44862LL, 481587261629530112LL,\n+  47223LL, 664828696452136960LL, 49584LL, 848070131274743808LL,\n+  51946LL, 31311566097350656LL, 54307LL, 214553000919957504LL,\n+  56668LL, 397794435742564352LL, 59029LL, 581035870565171200LL,\n+  61390LL, 764277305387778048LL, 63751LL, 947518740210384896LL,\n+  66113LL, 130760175032991744LL, 68474LL, 314001609855598592LL,\n+  70835LL, 497243044678205440LL, 73196LL, 680484479500812288LL,\n+  75557LL, 863725914323419136LL, 77919LL, 46967349146025984LL,\n+  80280LL, 230208783968632832LL, 82641LL, 413450218791239680LL,\n+  85002LL, 596691653613846528LL, 87363LL, 779933088436453376LL,\n+  89724LL, 963174523259060224LL, 92086LL, 146415958081667072LL,\n+  94447LL, 329657392904273920LL, 96808LL, 512898827726880768LL,\n+  99169LL, 696140262549487616LL, 101530LL, 879381697372094464LL,\n+  103892LL, 62623132194701312LL, 106253LL, 245864567017308160LL,\n+  108614LL, 429106001839915008LL, 110975LL, 612347436662521856LL,\n+  113336LL, 795588871485128704LL, 115697LL, 978830306307735552LL,\n+  118059LL, 162071741130342400LL, 120420LL, 345313175952949248LL,\n+  122781LL, 528554610775556096LL, 125142LL, 711796045598162944LL,\n+  127503LL, 895037480420769792LL, 129865LL, 78278915243376640LL,\n+  132226LL, 261520350065983488LL, 134587LL, 444761784888590336LL,\n+  136948LL, 628003219711197184LL, 139309LL, 811244654533804032LL,\n+  141670LL, 994486089356410880LL, 144032LL, 177727524179017728LL,\n+  146393LL, 360968959001624576LL, 148754LL, 544210393824231424LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 151115LL, 727451828646838272LL,\n+  302231LL, 454903657293676544LL, 453347LL, 182355485940514816LL,\n+  604462LL, 909807314587353088LL, 755578LL, 637259143234191360LL,\n+  906694LL, 364710971881029632LL, 1057810LL, 92162800527867904LL,\n+  1208925LL, 819614629174706176LL, 1360041LL, 547066457821544448LL,\n+  1511157LL, 274518286468382720LL, 1662273LL, 1970115115220992LL,\n+  1813388LL, 729421943762059264LL, 1964504LL, 456873772408897536LL,\n+  2115620LL, 184325601055735808LL, 2266735LL, 911777429702574080LL,\n+  2417851LL, 639229258349412352LL, 2568967LL, 366681086996250624LL,\n+  2720083LL, 94132915643088896LL, 2871198LL, 821584744289927168LL,\n+  3022314LL, 549036572936765440LL, 3173430LL, 276488401583603712LL,\n+  3324546LL, 3940230230441984LL, 3475661LL, 731392058877280256LL,\n+  3626777LL, 458843887524118528LL, 3777893LL, 186295716170956800LL,\n+  3929008LL, 913747544817795072LL, 4080124LL, 641199373464633344LL,\n+  4231240LL, 368651202111471616LL, 4382356LL, 96103030758309888LL,\n+  4533471LL, 823554859405148160LL, 4684587LL, 551006688051986432LL,\n+  4835703LL, 278458516698824704LL, 4986819LL, 5910345345662976LL,\n+  5137934LL, 733362173992501248LL, 5289050LL, 460814002639339520LL,\n+  5440166LL, 188265831286177792LL, 5591281LL, 915717659933016064LL,\n+  5742397LL, 643169488579854336LL, 5893513LL, 370621317226692608LL,\n+  6044629LL, 98073145873530880LL, 6195744LL, 825524974520369152LL,\n+  6346860LL, 552976803167207424LL, 6497976LL, 280428631814045696LL,\n+  6649092LL, 7880460460883968LL, 6800207LL, 735332289107722240LL,\n+  6951323LL, 462784117754560512LL, 7102439LL, 190235946401398784LL,\n+  7253554LL, 917687775048237056LL, 7404670LL, 645139603695075328LL,\n+  7555786LL, 372591432341913600LL, 7706902LL, 100043260988751872LL,\n+  7858017LL, 827495089635590144LL, 8009133LL, 554946918282428416LL,\n+  8160249LL, 282398746929266688LL, 8311365LL, 9850575576104960LL,\n+  8462480LL, 737302404222943232LL, 8613596LL, 464754232869781504LL,\n+  8764712LL, 192206061516619776LL, 8915827LL, 919657890163458048LL,\n+  9066943LL, 647109718810296320LL, 9218059LL, 374561547457134592LL,\n+  9369175LL, 102013376103972864LL, 9520290LL, 829465204750811136LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 9671406LL, 556917033397649408LL,\n+  19342813LL, 113834066795298816LL, 29014219LL, 670751100192948224LL,\n+  38685626LL, 227668133590597632LL, 48357032LL, 784585166988247040LL,\n+  58028439LL, 341502200385896448LL, 67699845LL, 898419233783545856LL,\n+  77371252LL, 455336267181195264LL, 87042659LL, 12253300578844672LL,\n+  96714065LL, 569170333976494080LL, 106385472LL, 126087367374143488LL,\n+  116056878LL, 683004400771792896LL, 125728285LL, 239921434169442304LL,\n+  135399691LL, 796838467567091712LL, 145071098LL, 353755500964741120LL,\n+  154742504LL, 910672534362390528LL, 164413911LL, 467589567760039936LL,\n+  174085318LL, 24506601157689344LL, 183756724LL, 581423634555338752LL,\n+  193428131LL, 138340667952988160LL, 203099537LL, 695257701350637568LL,\n+  212770944LL, 252174734748286976LL, 222442350LL, 809091768145936384LL,\n+  232113757LL, 366008801543585792LL, 241785163LL, 922925834941235200LL,\n+  251456570LL, 479842868338884608LL, 261127977LL, 36759901736534016LL,\n+  270799383LL, 593676935134183424LL, 280470790LL, 150593968531832832LL,\n+  290142196LL, 707511001929482240LL, 299813603LL, 264428035327131648LL,\n+  309485009LL, 821345068724781056LL, 319156416LL, 378262102122430464LL,\n+  328827822LL, 935179135520079872LL, 338499229LL, 492096168917729280LL,\n+  348170636LL, 49013202315378688LL, 357842042LL, 605930235713028096LL,\n+  367513449LL, 162847269110677504LL, 377184855LL, 719764302508326912LL,\n+  386856262LL, 276681335905976320LL, 396527668LL, 833598369303625728LL,\n+  406199075LL, 390515402701275136LL, 415870481LL, 947432436098924544LL,\n+  425541888LL, 504349469496573952LL, 435213295LL, 61266502894223360LL,\n+  444884701LL, 618183536291872768LL, 454556108LL, 175100569689522176LL,\n+  464227514LL, 732017603087171584LL, 473898921LL, 288934636484820992LL,\n+  483570327LL, 845851669882470400LL, 493241734LL, 402768703280119808LL,\n+  502913140LL, 959685736677769216LL, 512584547LL, 516602770075418624LL,\n+  522255954LL, 73519803473068032LL, 531927360LL, 630436836870717440LL,\n+  541598767LL, 187353870268366848LL, 551270173LL, 744270903666016256LL,\n+  560941580LL, 301187937063665664LL, 570612986LL, 858104970461315072LL,\n+  580284393LL, 415022003858964480LL, 589955799LL, 971939037256613888LL,\n+  599627206LL, 528856070654263296LL, 609298613LL, 85773104051912704LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 618970019LL, 642690137449562112LL,\n+  1237940039LL, 285380274899124224LL, 1856910058LL, 928070412348686336LL, \n+  2475880078LL, 570760549798248448LL, 3094850098LL, 213450687247810560LL, \n+  3713820117LL, 856140824697372672LL, 4332790137LL, 498830962146934784LL, \n+  4951760157LL, 141521099596496896LL, 5570730176LL, 784211237046059008LL,\n+  6189700196LL, 426901374495621120LL, 6808670216LL, 69591511945183232LL,\n+  7427640235LL, 712281649394745344LL, 8046610255LL, 354971786844307456LL,\n+  8665580274LL, 997661924293869568LL, 9284550294LL, 640352061743431680LL,\n+  9903520314LL, 283042199192993792LL, 10522490333LL, 925732336642555904LL,\n+  11141460353LL, 568422474092118016LL, 11760430373LL, 211112611541680128LL,\n+  12379400392LL, 853802748991242240LL, 12998370412LL, 496492886440804352LL,\n+  13617340432LL, 139183023890366464LL, 14236310451LL, 781873161339928576LL,\n+  14855280471LL, 424563298789490688LL, 15474250491LL, 67253436239052800LL,\n+  16093220510LL, 709943573688614912LL, 16712190530LL, 352633711138177024LL,\n+  17331160549LL, 995323848587739136LL, 17950130569LL, 638013986037301248LL,\n+  18569100589LL, 280704123486863360LL, 19188070608LL, 923394260936425472LL,\n+  19807040628LL, 566084398385987584LL, 20426010648LL, 208774535835549696LL,\n+  21044980667LL, 851464673285111808LL, 21663950687LL, 494154810734673920LL,\n+  22282920707LL, 136844948184236032LL, 22901890726LL, 779535085633798144LL,\n+  23520860746LL, 422225223083360256LL, 24139830766LL, 64915360532922368LL,\n+  24758800785LL, 707605497982484480LL, 25377770805LL, 350295635432046592LL,\n+  25996740824LL, 992985772881608704LL, 26615710844LL, 635675910331170816LL,\n+  27234680864LL, 278366047780732928LL, 27853650883LL, 921056185230295040LL,\n+  28472620903LL, 563746322679857152LL, 29091590923LL, 206436460129419264LL,\n+  29710560942LL, 849126597578981376LL, 30329530962LL, 491816735028543488LL,\n+  30948500982LL, 134506872478105600LL, 31567471001LL, 777197009927667712LL,\n+  32186441021LL, 419887147377229824LL, 32805411041LL, 62577284826791936LL,\n+  33424381060LL, 705267422276354048LL, 34043351080LL, 347957559725916160LL,\n+  34662321099LL, 990647697175478272LL, 35281291119LL, 633337834625040384LL,\n+  35900261139LL, 276027972074602496LL, 36519231158LL, 918718109524164608LL,\n+  37138201178LL, 561408246973726720LL, 37757171198LL, 204098384423288832LL,\n+  38376141217LL, 846788521872850944LL, 38995111237LL, 489478659322413056LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 39614081257LL, 132168796771975168LL, \n+  79228162514LL, 264337593543950336LL, 118842243771LL, 396506390315925504LL,\n+  158456325028LL, 528675187087900672LL, 198070406285LL, 660843983859875840LL,\n+  237684487542LL, 793012780631851008LL, 277298568799LL, 925181577403826176LL,\n+  316912650057LL, 57350374175801344LL, 356526731314LL, 189519170947776512LL,\n+  396140812571LL, 321687967719751680LL, 435754893828LL, 453856764491726848LL,\n+  475368975085LL, 586025561263702016LL, 514983056342LL, 718194358035677184LL,\n+  554597137599LL, 850363154807652352LL, 594211218856LL, 982531951579627520LL,\n+  633825300114LL, 114700748351602688LL, 673439381371LL, 246869545123577856LL,\n+  713053462628LL, 379038341895553024LL, 752667543885LL, 511207138667528192LL,\n+  792281625142LL, 643375935439503360LL, 831895706399LL, 775544732211478528LL,\n+  871509787656LL, 907713528983453696LL, 911123868914LL, 39882325755428864LL,\n+  950737950171LL, 172051122527404032LL, 990352031428LL, 304219919299379200LL,\n+  1029966112685LL, 436388716071354368LL, 1069580193942LL, 568557512843329536LL,\n+  1109194275199LL, 700726309615304704LL, 1148808356456LL, 832895106387279872LL,\n+  1188422437713LL, 965063903159255040LL, 1228036518971LL, 97232699931230208LL,\n+  1267650600228LL, 229401496703205376LL, 1307264681485LL, 361570293475180544LL,\n+  1346878762742LL, 493739090247155712LL, 1386492843999LL, 625907887019130880LL,\n+  1426106925256LL, 758076683791106048LL, 1465721006513LL, 890245480563081216LL,\n+  1505335087771LL, 22414277335056384LL, 1544949169028LL, 154583074107031552LL,\n+  1584563250285LL, 286751870879006720LL, 1624177331542LL, 418920667650981888LL,\n+  1663791412799LL, 551089464422957056LL, 1703405494056LL, 683258261194932224LL,\n+  1743019575313LL, 815427057966907392LL, 1782633656570LL, 947595854738882560LL,\n+  1822247737828LL, 79764651510857728LL, 1861861819085LL, 211933448282832896LL,\n+  1901475900342LL, 344102245054808064LL, 1941089981599LL, 476271041826783232LL,\n+  1980704062856LL, 608439838598758400LL, 2020318144113LL, 740608635370733568LL,\n+  2059932225370LL, 872777432142708736LL, 2099546306628LL, 4946228914683904LL,\n+  2139160387885LL, 137115025686659072LL, 2178774469142LL, 269283822458634240LL,\n+  2218388550399LL, 401452619230609408LL, 2258002631656LL, 533621416002584576LL,\n+  2297616712913LL, 665790212774559744LL, 2337230794170LL, 797959009546534912LL,\n+  2376844875427LL, 930127806318510080LL, 2416458956685LL, 62296603090485248LL,\n+  2456073037942LL, 194465399862460416LL, 2495687119199LL, 326634196634435584LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 2535301200456LL, 458802993406410752LL,\n+  5070602400912LL, 917605986812821504LL, 7605903601369LL, 376408980219232256LL,\n+  10141204801825LL, 835211973625643008LL, 12676506002282LL, 294014967032053760LL,\n+  15211807202738LL, 752817960438464512LL, 17747108403195LL, 211620953844875264LL,\n+  20282409603651LL, 670423947251286016LL, 22817710804108LL, 129226940657696768LL,\n+  25353012004564LL, 588029934064107520LL, 27888313205021LL, 46832927470518272LL,\n+  30423614405477LL, 505635920876929024LL, 32958915605933LL, 964438914283339776LL,\n+  35494216806390LL, 423241907689750528LL, 38029518006846LL, 882044901096161280LL, 40564819207303LL, 340847894502572032LL, 43100120407759LL, 799650887908982784LL,\n+  45635421608216LL, 258453881315393536LL, 48170722808672LL, 717256874721804288LL,\n+  50706024009129LL, 176059868128215040LL, 53241325209585LL, 634862861534625792LL,\n+  55776626410042LL, 93665854941036544LL, 58311927610498LL, 552468848347447296LL,\n+  60847228810955LL, 11271841753858048LL, 63382530011411LL, 470074835160268800LL,\n+  65917831211867LL, 928877828566679552LL, 68453132412324LL, 387680821973090304LL,\n+  70988433612780LL, 846483815379501056LL, 73523734813237LL, 305286808785911808LL,\n+  76059036013693LL, 764089802192322560LL, 78594337214150LL, 222892795598733312LL,\n+  81129638414606LL, 681695789005144064LL, 83664939615063LL, 140498782411554816LL,\n+  86200240815519LL, 599301775817965568LL, 88735542015976LL, 58104769224376320LL,\n+  91270843216432LL, 516907762630787072LL, 93806144416888LL, 975710756037197824LL,\n+  96341445617345LL, 434513749443608576LL, 98876746817801LL, 893316742850019328LL,\n+  101412048018258LL, 352119736256430080LL, 103947349218714LL, 810922729662840832LL,\n+  106482650419171LL, 269725723069251584LL, 109017951619627LL, 728528716475662336LL,\n+  111553252820084LL, 187331709882073088LL, 114088554020540LL, 646134703288483840LL,\n+  116623855220997LL, 104937696694894592LL, 119159156421453LL, 563740690101305344LL,\n+  121694457621910LL, 22543683507716096LL, 124229758822366LL, 481346676914126848LL,\n+  126765060022822LL, 940149670320537600LL, 129300361223279LL, 398952663726948352LL,\n+  131835662423735LL, 857755657133359104LL, 134370963624192LL, 316558650539769856LL,\n+  136906264824648LL, 775361643946180608LL, 139441566025105LL, 234164637352591360LL,\n+  141976867225561LL, 692967630759002112LL, 144512168426018LL, 151770624165412864LL,\n+  147047469626474LL, 610573617571823616LL, 149582770826931LL, 69376610978234368LL,\n+  152118072027387LL, 528179604384645120LL, 154653373227843LL, 986982597791055872LL,\n+  157188674428300LL, 445785591197466624LL, 159723975628756LL, 904588584603877376LL,\n+  },\n+\n+  {\n+  0LL, 0LL, 162259276829213LL, 363391578010288128LL,\n+  324518553658426LL, 726783156020576256LL, 486777830487640LL, 90174734030864384LL,\n+  649037107316853LL, 453566312041152512LL, 811296384146066LL, 816957890051440640LL,\n+  973555660975280LL, 180349468061728768LL, 1135814937804493LL, 543741046072016896LL,\n+  1298074214633706LL, 907132624082305024LL, 1460333491462920LL, 270524202092593152LL,\n+  1622592768292133LL, 633915780102881280LL, 1784852045121346LL, 997307358113169408LL,\n+  1947111321950560LL, 360698936123457536LL, 2109370598779773LL, 724090514133745664LL,\n+  2271629875608987LL, 87482092144033792LL, 2433889152438200LL, 450873670154321920LL,\n+  2596148429267413LL, 814265248164610048LL, 2758407706096627LL, 177656826174898176LL,\n+  2920666982925840LL, 541048404185186304LL, 3082926259755053LL, 904439982195474432LL,\n+  3245185536584267LL, 267831560205762560LL, 3407444813413480LL, 631223138216050688LL,\n+  3569704090242693LL, 994614716226338816LL, 3731963367071907LL, 358006294236626944LL,\n+  3894222643901120LL, 721397872246915072LL, 4056481920730334LL, 84789450257203200LL,\n+  4218741197559547LL, 448181028267491328LL, 4381000474388760LL, 811572606277779456LL,\n+  4543259751217974LL, 174964184288067584LL, 4705519028047187LL, 538355762298355712LL,\n+  4867778304876400LL, 901747340308643840LL, 5030037581705614LL, 265138918318931968LL,\n+  5192296858534827LL, 628530496329220096LL, 5354556135364040LL, 991922074339508224LL,\n+  5516815412193254LL, 355313652349796352LL, 5679074689022467LL, 718705230360084480LL,\n+  5841333965851681LL, 82096808370372608LL, 6003593242680894LL, 445488386380660736LL,\n+  6165852519510107LL, 808879964390948864LL, 6328111796339321LL, 172271542401236992LL,\n+  6490371073168534LL, 535663120411525120LL, 6652630349997747LL, 899054698421813248LL,\n+  6814889626826961LL, 262446276432101376LL, 6977148903656174LL, 625837854442389504LL,\n+  7139408180485387LL, 989229432452677632LL, 7301667457314601LL, 352621010462965760LL,\n+  7463926734143814LL, 716012588473253888LL, 7626186010973028LL, 79404166483542016LL,\n+  7788445287802241LL, 442795744493830144LL, 7950704564631454LL, 806187322504118272LL,\n+  8112963841460668LL, 169578900514406400LL, 8275223118289881LL, 532970478524694528LL,\n+  8437482395119094LL, 896362056534982656LL, 8599741671948308LL, 259753634545270784LL,\n+  8762000948777521LL, 623145212555558912LL, 8924260225606734LL, 986536790565847040LL,\n+  9086519502435948LL, 349928368576135168LL, 9248778779265161LL, 713319946586423296LL,\n+  9411038056094375LL, 76711524596711424LL, 9573297332923588LL, 440103102606999552LL,\n+  9735556609752801LL, 803494680617287680LL, 9897815886582015LL, 166886258627575808LL,\n+  10060075163411228LL, 530277836637863936LL, 10222334440240441LL, 893669414648152064LL\n+  }\n+};"}, {"sha": "79bf9e55c6452480f2a222e43ed61869ef1d915d", "filename": "libgcc/config/libbid/bid128_add.c", "status": "added", "additions": 2440, "deletions": 0, "changes": 2440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_add.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "9b7d9baa9f3ffd12bd74b5737cec5e1f5d63f545", "filename": "libgcc/config/libbid/bid128_compare.c", "status": "added", "additions": 4611, "deletions": 0, "changes": 4611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_compare.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "9980c32e35520074da373944e07f2f9a55fcf45e", "filename": "libgcc/config/libbid/bid128_div.c", "status": "added", "additions": 464, "deletions": 0, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_div.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,464 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"div_macros.h\"\n+\n+extern UINT32 __bid_convert_table[5][128][2];\n+extern SINT8 __bid_factors[][2];\n+extern UINT8 __bid_packed_10000_zeros[];\n+\n+BID128_FUNCTION_ARG2(__bid128_div, x, y)\n+\n+  UINT256 CA4, CA4r, P256;\n+  UINT128 CX, CY, T128, CQ, CR, CA, TP128, Qh, Ql, res;\n+  UINT64 sign_x, sign_y, T, carry64, D, Q_high, Q_low, QX, X, PD;\n+  int_float fx, fy, f64;\n+  UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+  int exponent_x = 0, exponent_y, bin_index, bin_expon, diff_expon, ed2,\n+    digits_q, amount;\n+  int nzeros, i, j, k, d5;\n+  unsigned rmode;\n+\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    // test if x is NaN\n+    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull || // sNaN\n+          (y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res.w[1] = (x.w[1]) & QUIET_MASK64;\n+      res.w[0] = x.w[0];\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // check if y is Inf. \n+      if (((y.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull))\n+        // return NaN \n+      {\n+#ifdef SET_STATUS_FLAGS\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+      // y is NaN?\n+      if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n+        // return NaN \n+      {\n+        // return +/-Inf\n+        res.w[1] = ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | \n+            0x7800000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+    }\n+    // x is 0\n+    if ((y.w[1] & 0x7800000000000000ull) < 0x7800000000000000ull) {\n+      if ((!y.w[0]) && !(y.w[1] & 0x0001ffffffffffffull)) {\n+#ifdef SET_STATUS_FLAGS\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+        // x=y=0, return NaN\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+      // return 0\n+      res.w[1] = (x.w[1] ^ y.w[1]) & 0x8000000000000000ull;\n+      X = ((y.w[1]) << 1) >> 50;\n+      exponent_x = exponent_x - (int) X + DECIMAL_EXPONENT_BIAS_128;\n+      if (exponent_x > DECIMAL_MAX_EXPON_128)\n+        exponent_x = DECIMAL_MAX_EXPON_128;\n+      else if (exponent_x < 0)\n+        exponent_x = 0;\n+      res.w[1] |= (((UINT64) exponent_x) << 49);\n+      res.w[0] = 0;\n+      BID_RETURN (res);\n+    }\n+  }\n+  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) // sNaN\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res.w[1] = y.w[1] & QUIET_MASK64;\n+      res.w[0] = y.w[0];\n+      BID_RETURN (res);\n+    }\n+    // y is Infinity?\n+    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // return +/-0\n+      res.w[1] = sign_x ^ sign_y;\n+      res.w[0] = 0;\n+      BID_RETURN (res);\n+    }\n+    // y is 0, return +/-Inf\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+    res.w[1] =\n+      ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS_128;\n+\n+  if (__unsigned_compare_gt_128 (CY, CX)) {\n+    // CX < CY\n+\n+    // 2^64\n+    f64.i = 0x5f800000;\n+\n+    // fx ~ CX,   fy ~ CY\n+    fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+    fy.d = (float) CY.w[1] * f64.d + (float) CY.w[0];\n+    // expon_cy - expon_cx\n+    bin_index = (fy.i - fx.i) >> 23;\n+\n+    if (CX.w[1]) {\n+      T = __bid_power10_index_binexp_128[bin_index].w[0];\n+      __mul_64x128_short (CA, T, CX);\n+    } else {\n+      T128 = __bid_power10_index_binexp_128[bin_index];\n+      __mul_64x128_short (CA, CX.w[0], T128);\n+    }\n+\n+    ed2 = 33;\n+    if (__unsigned_compare_gt_128 (CY, CA))\n+      ed2++;\n+\n+    T128 = __bid_power10_table_128[ed2];\n+    __mul_128x128_to_256 (CA4, CA, T128);\n+\n+    ed2 += __bid_estimate_decimal_digits[bin_index];\n+    CQ.w[0] = CQ.w[1] = 0;\n+    diff_expon = diff_expon - ed2;\n+\n+  } else {\n+    // get CQ = CX/CY\n+    __div_128_by_128 (&CQ, &CR, CX, CY);\n+\n+    if (!CR.w[1] && !CR.w[0]) {\n+      get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+                  pfpsf);\n+      BID_RETURN (res);\n+    }\n+    // get number of decimal digits in CQ\n+    // 2^64\n+    f64.i = 0x5f800000;\n+    fx.d = (float) CQ.w[1] * f64.d + (float) CQ.w[0];\n+    // binary expon. of CQ\n+    bin_expon = (fx.i - 0x3f800000) >> 23;\n+\n+    digits_q = __bid_estimate_decimal_digits[bin_expon];\n+    TP128.w[0] = __bid_power10_index_binexp_128[bin_expon].w[0];\n+    TP128.w[1] = __bid_power10_index_binexp_128[bin_expon].w[1];\n+    if (__unsigned_compare_ge_128 (CQ, TP128))\n+      digits_q++;\n+\n+    ed2 = 34 - digits_q;\n+    T128.w[0] = __bid_power10_table_128[ed2].w[0];\n+    T128.w[1] = __bid_power10_table_128[ed2].w[1];\n+    __mul_128x128_to_256 (CA4, CR, T128);\n+    diff_expon = diff_expon - ed2;\n+    __mul_128x128_low (CQ, CQ, T128);\n+\n+  }\n+\n+  __div_256_by_128 (&CQ, &CA4, CY);\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (CA4.w[0] || CA4.w[1]) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!CA4.w[0] && !CA4.w[1])\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+    // check whether result is exact\n+  {\n+    // check whether CX, CY are short\n+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {\n+      i = (int) CY.w[0] - 1;\n+      j = (int) CX.w[0] - 1;\n+      // difference in powers of 2 __bid_factors for Y and X\n+      nzeros = ed2 - __bid_factors[i][0] + __bid_factors[j][0];\n+      // difference in powers of 5 __bid_factors\n+      d5 = ed2 - __bid_factors[i][1] + __bid_factors[j][1];\n+      if (d5 < nzeros)\n+        nzeros = d5;\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Qh, Ql, CQ, __bid_reciprocals10_128[nzeros]);\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = __bid_recip_scale[nzeros];\n+      __shr_128_long (CQ, Qh, amount);\n+\n+      diff_expon += nzeros;\n+    } else {\n+      // decompose Q as Qh*10^17 + Ql\n+      //T128 = __bid_reciprocals10_128[17];\n+      T128.w[0] = 0x44909befeb9fad49ull;\n+      T128.w[1] = 0x000b877aa3236a4bull;\n+      __mul_128x128_to_256 (P256, CQ, T128);\n+      //amount = __bid_recip_scale[17];\n+      Q_high = (P256.w[2] >> 44) | (P256.w[3] << (64 - 44));\n+      Q_low = CQ.w[0] - Q_high * 100000000000000000ull;\n+\n+      if (!Q_low) {\n+        diff_expon += 17;\n+\n+        tdigit[0] = Q_high & 0x3ffffff;\n+        tdigit[1] = 0;\n+        QX = Q_high >> 26;\n+        QX32 = QX;\n+        nzeros = 0;\n+\n+        for (j = 0; QX32; j++, QX32 >>= 7) {\n+          k = (QX32 & 127);\n+          tdigit[0] += __bid_convert_table[j][k][0];\n+          tdigit[1] += __bid_convert_table[j][k][1];\n+          if (tdigit[0] >= 100000000) {\n+            tdigit[0] -= 100000000;\n+            tdigit[1]++;\n+          }\n+        }\n+\n+        if (tdigit[1] >= 100000000) {\n+          tdigit[1] -= 100000000;\n+          if (tdigit[1] >= 100000000)\n+            tdigit[1] -= 100000000;\n+        }\n+\n+        digit = tdigit[0];\n+        if (!digit && !tdigit[1])\n+          nzeros += 16;\n+        else {\n+          if (!digit) {\n+            nzeros += 8;\n+            digit = tdigit[1];\n+          }\n+          // decompose digit\n+          PD = (UINT64) digit *0x068DB8BBull;\n+          digit_h = (UINT32) (PD >> 40);\n+          digit_low = digit - digit_h * 10000;\n+\n+          if (!digit_low)\n+            nzeros += 4;\n+          else\n+            digit_h = digit_low;\n+\n+          if (!(digit_h & 1))\n+            nzeros +=\n+              3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n+                            (digit_h & 7));\n+        }\n+\n+        if (nzeros) {\n+          __mul_64x64_to_128 (CQ, Q_high, __bid_reciprocals10_64[nzeros]);\n+\n+          // now get P/10^extra_digits: shift C64 right by M[extra_digits]-64\n+          amount = __bid_short_recip_scale[nzeros];\n+          CQ.w[0] = CQ.w[1] >> amount;\n+        } else\n+          CQ.w[0] = Q_high;\n+        CQ.w[1] = 0;\n+\n+        diff_expon += nzeros;\n+      } else {\n+        tdigit[0] = Q_low & 0x3ffffff;\n+        tdigit[1] = 0;\n+        QX = Q_low >> 26;\n+        QX32 = QX;\n+        nzeros = 0;\n+\n+        for (j = 0; QX32; j++, QX32 >>= 7) {\n+          k = (QX32 & 127);\n+          tdigit[0] += __bid_convert_table[j][k][0];\n+          tdigit[1] += __bid_convert_table[j][k][1];\n+          if (tdigit[0] >= 100000000) {\n+            tdigit[0] -= 100000000;\n+            tdigit[1]++;\n+          }\n+        }\n+\n+        if (tdigit[1] >= 100000000) {\n+          tdigit[1] -= 100000000;\n+          if (tdigit[1] >= 100000000)\n+            tdigit[1] -= 100000000;\n+        }\n+\n+        digit = tdigit[0];\n+        if (!digit && !tdigit[1])\n+          nzeros += 16;\n+        else {\n+          if (!digit) {\n+            nzeros += 8;\n+            digit = tdigit[1];\n+          }\n+          // decompose digit\n+          PD = (UINT64) digit *0x068DB8BBull;\n+          digit_h = (UINT32) (PD >> 40);\n+          digit_low = digit - digit_h * 10000;\n+\n+          if (!digit_low)\n+            nzeros += 4;\n+          else\n+            digit_h = digit_low;\n+\n+          if (!(digit_h & 1))\n+            nzeros +=\n+              3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n+                            (digit_h & 7));\n+        }\n+\n+        if (nzeros) {\n+          // get P*(2^M[extra_digits])/10^extra_digits\n+          __mul_128x128_full (Qh, Ql, CQ, __bid_reciprocals10_128[nzeros]);\n+\n+          //now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+          amount = __bid_recip_scale[nzeros];\n+          __shr_128 (CQ, Qh, amount);\n+        }\n+        diff_expon += nzeros;\n+\n+      }\n+    }\n+    get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode,\n+                pfpsf);\n+    BID_RETURN (res);\n+  }\n+#endif\n+\n+  if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+    // rounding\n+    // 2*CA4 - CY\n+    CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+    CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+    __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+    CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+\n+    D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+    carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+\n+    CQ.w[0] += carry64;\n+    if (CQ.w[0] < carry64)\n+      CQ.w[1]++;\n+#else\n+    rmode = rnd_mode;\n+    if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+    switch (rmode) {\n+    case ROUNDING_TO_NEAREST: // round to nearest code\n+      // rounding\n+      // 2*CA4 - CY\n+      CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+      CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+      __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+      CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+      D = (CA4r.w[1] | CA4r.w[0]) ? 1 : 0;\n+      carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) & ((CQ.w[0]) | D);\n+      CQ.w[0] += carry64;\n+      if (CQ.w[0] < carry64)\n+        CQ.w[1]++;\n+      break;\n+    case ROUNDING_TIES_AWAY:\n+      // rounding\n+      // 2*CA4 - CY\n+      CA4r.w[1] = (CA4.w[1] + CA4.w[1]) | (CA4.w[0] >> 63);\n+      CA4r.w[0] = CA4.w[0] + CA4.w[0];\n+      __sub_borrow_out (CA4r.w[0], carry64, CA4r.w[0], CY.w[0]);\n+      CA4r.w[1] = CA4r.w[1] - CY.w[1] - carry64;\n+      D = (CA4r.w[1] | CA4r.w[0]) ? 0 : 1;\n+      carry64 = (1 + (((SINT64) CA4r.w[1]) >> 63)) | D;\n+      CQ.w[0] += carry64;\n+      if (CQ.w[0] < carry64)\n+        CQ.w[1]++;\n+      break;\n+    case ROUNDING_DOWN:\n+    case ROUNDING_TO_ZERO:\n+      break;\n+    default: // rounding up\n+      CQ.w[0]++;\n+      if (!CQ.w[0])\n+        CQ.w[1]++;\n+      break;\n+    }\n+#endif\n+#endif\n+\n+  } else {\n+#ifdef SET_STATUS_FLAGS\n+    if (CA4.w[0] || CA4.w[1]) {\n+      // set status flags\n+      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+    }\n+#endif\n+\n+    handle_UF_128_rem (&res, sign_x ^ sign_y, diff_expon, CQ,\n+                       CA4.w[1] | CA4.w[0], &rnd_mode, pfpsf);\n+    BID_RETURN (res);\n+\n+  }\n+\n+  get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "22e08e2eee06b6c5f0233b3b861f8d6c4459b3a7", "filename": "libgcc/config/libbid/bid128_fma.c", "status": "added", "additions": 3408, "deletions": 0, "changes": 3408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_fma.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "d92c135bca0618cefe0e25d85c880f719092052d", "filename": "libgcc/config/libbid/bid128_fromstring.c", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_fromstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_fromstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_fromstring.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,397 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+#define MAX_FORMAT_DIGITS_128   34\n+#define MAX_STRING_DIGITS_128   100\n+#define MAX_SEARCH              MAX_STRING_DIGITS_128-MAX_FORMAT_DIGITS_128-1\n+\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid128_from_string (UINT128 * pres,\n+                    char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+                    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#else\n+\n+UINT128\n+__bid128_from_string (char *ps _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+                    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CX, res;\n+  UINT64 sign_x, coeff_high, coeff_low, coeff2, coeff_l2, carry,\n+    scale_high, right_radix_leading_zeros;\n+  int ndigits_before, ndigits_after, ndigits_total, dec_expon, sgn_exp,\n+    i, d2, rdx_pt_enc;\n+  char c, buffer[MAX_STRING_DIGITS_128];\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+#endif\n+\n+  right_radix_leading_zeros = rdx_pt_enc = 0;\n+\n+  // if null string, return NaN\n+  if (!ps) {\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // eliminate leading white space\n+  while ((*ps == ' ') || (*ps == '\\t'))\n+    ps++;\n+\n+  // c gets first character\n+  c = *ps;\n+\n+\n+  // if c is null or not equal to a (radix point, negative sign, \n+  // positive sign, or number) it might be SNaN, sNaN, Infinity\n+  if (!c\n+      || (c != '.' && c != '-' && c != '+'\n+          && ((unsigned) (c - '0') > 9))) {\n+    res.w[0] = 0;\n+    // Infinity?\n+    if ((tolower_macro (ps[0]) == 'i' && tolower_macro (ps[1]) == 'n'\n+         && tolower_macro (ps[2]) == 'f')\n+        && (!ps[3]\n+            || (tolower_macro (ps[3]) == 'i'\n+                && tolower_macro (ps[4]) == 'n'\n+                && tolower_macro (ps[5]) == 'i'\n+                && tolower_macro (ps[6]) == 't'\n+                && tolower_macro (ps[7]) == 'y' && !ps[8])\n+        )) {\n+      res.w[1] = 0x7800000000000000ull;\n+      BID_RETURN (res);\n+    }\n+    // return sNaN\n+    if (tolower_macro (ps[0]) == 's' && tolower_macro (ps[1]) == 'n' && \n+        tolower_macro (ps[2]) == 'a' && tolower_macro (ps[3]) == 'n') {        \n+        // case insensitive check for snan\n+      res.w[1] = 0x7e00000000000000ull;\n+      BID_RETURN (res);\n+    } else {\n+      // return qNaN\n+      res.w[1] = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+  }\n+  // if +Inf, -Inf, +Infinity, or -Infinity (case insensitive check for inf)   \n+  if ((tolower_macro (ps[1]) == 'i' && tolower_macro (ps[2]) == 'n' && \n+      tolower_macro (ps[3]) == 'f') && (!ps[4] || \n+      (tolower_macro (ps[4]) == 'i' && tolower_macro (ps[5]) == 'n' && \n+      tolower_macro (ps[6]) == 'i' && tolower_macro (ps[7]) == 't' && \n+      tolower_macro (ps[8]) == 'y' && !ps[9]))) { // ci check for infinity\n+    res.w[0] = 0;\n+\n+    if (c == '+')\n+      res.w[1] = 0x7800000000000000ull;\n+    else if (c == '-')\n+      res.w[1] = 0xf800000000000000ull;\n+    else\n+      res.w[1] = 0x7c00000000000000ull;\n+\n+    BID_RETURN (res);\n+  }\n+  // if +sNaN, +SNaN, -sNaN, or -SNaN\n+  if (tolower_macro (ps[1]) == 's' && tolower_macro (ps[2]) == 'n'\n+      && tolower_macro (ps[3]) == 'a' && tolower_macro (ps[4]) == 'n') {\n+    res.w[0] = 0;\n+    if (c == '-')\n+      res.w[1] = 0xfe00000000000000ull;\n+    else\n+      res.w[1] = 0x7e00000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // set up sign_x to be OR'ed with the upper word later\n+  if (c == '-')\n+    sign_x = 0x8000000000000000ull;\n+  else\n+    sign_x = 0;\n+\n+  // go to next character if leading sign\n+  if (c == '-' || c == '+')\n+    ps++;\n+\n+  c = *ps;\n+\n+  // if c isn't a decimal point or a decimal digit, return NaN\n+  if (c != '.' && ((unsigned) (c - '0') > 9)) {\n+    res.w[1] = 0x7c00000000000000ull | sign_x;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // detect zero (and eliminate/ignore leading zeros)\n+  if (*(ps) == '0') {\n+\n+    // if all numbers are zeros (with possibly 1 radix point, the number is zero\n+    // should catch cases such as: 000.0\n+    while (*ps == '0') {\n+\n+      ps++;\n+\n+      // for numbers such as 0.0000000000000000000000000000000000001001, \n+      // we want to count the leading zeros\n+      if (rdx_pt_enc) {\n+        right_radix_leading_zeros++;\n+      }\n+      // if this character is a radix point, make sure we haven't already \n+      // encountered one\n+      if (*(ps) == '.') {\n+        if (rdx_pt_enc == 0) {\n+          rdx_pt_enc = 1;\n+          // if this is the first radix point, and the next character is NULL, \n+          // we have a zero\n+          if (!*(ps + 1)) {\n+            res.w[1] =\n+              (0x3040000000000000ull -\n+               (right_radix_leading_zeros << 49)) | sign_x;\n+            res.w[0] = 0;\n+            BID_RETURN (res);\n+          }\n+          ps = ps + 1;\n+        } else {\n+          // if 2 radix points, return NaN\n+          res.w[1] = 0x7c00000000000000ull | sign_x;\n+          res.w[0] = 0;\n+          BID_RETURN (res);\n+        }\n+      } else if (!*(ps)) {\n+        //res.w[1] = 0x3040000000000000ull | sign_x;\n+        res.w[1] =\n+          (0x3040000000000000ull -\n+           (right_radix_leading_zeros << 49)) | sign_x;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+    }\n+  }\n+\n+  c = *ps;\n+\n+  // initialize local variables\n+  ndigits_before = ndigits_after = ndigits_total = 0;\n+  sgn_exp = 0;\n+  // pstart_coefficient = ps;\n+\n+  if (!rdx_pt_enc) {\n+    // investigate string (before radix point)\n+    while ((unsigned) (c - '0') <= 9\n+           && ndigits_before < MAX_STRING_DIGITS_128) {\n+      buffer[ndigits_before] = c;\n+      ps++;\n+      c = *ps;\n+      ndigits_before++;\n+    }\n+\n+    ndigits_total = ndigits_before;\n+    if (c == '.') {\n+      ps++;\n+      if ((c = *ps)) {\n+\n+        // investigate string (after radix point)\n+        while ((unsigned) (c - '0') <= 9\n+               && ndigits_total < MAX_STRING_DIGITS_128) {\n+          buffer[ndigits_total] = c;\n+          ps++;\n+          c = *ps;\n+          ndigits_total++;\n+        }\n+        ndigits_after = ndigits_total - ndigits_before;\n+      }\n+    }\n+  } else {\n+    // we encountered a radix point while detecting zeros\n+    //if (c = *ps){\n+\n+    c = *ps;\n+    ndigits_total = 0;\n+    // investigate string (after radix point)\n+    while ((unsigned) (c - '0') <= 9\n+           && ndigits_total < MAX_STRING_DIGITS_128) {\n+      buffer[ndigits_total] = c;\n+      ps++;\n+      c = *ps;\n+      ndigits_total++;\n+    }\n+    ndigits_after = ndigits_total - ndigits_before;\n+  }\n+\n+  // get exponent\n+  dec_expon = 0;\n+  if (ndigits_total < MAX_STRING_DIGITS_128) {\n+    if (c) {\n+      if (c != 'e' && c != 'E') {\n+        // return NaN\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+      ps++;\n+      c = *ps;\n+\n+      if (((unsigned) (c - '0') > 9)\n+          && ((c != '+' && c != '-') || (unsigned) (ps[1] - '0') > 9)) {\n+        // return NaN\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+\n+      if (c == '-') {\n+        sgn_exp = -1;\n+        ps++;\n+        c = *ps;\n+      } else if (c == '+') {\n+        ps++;\n+        c = *ps;\n+      }\n+\n+      dec_expon = c - '0';\n+      i = 1;\n+      ps++;\n+      c = *ps - '0';\n+      while (((unsigned) c) <= 9 && i < 7) {\n+        d2 = dec_expon + dec_expon;\n+        dec_expon = (d2 << 2) + d2 + c;\n+        ps++;\n+        c = *ps - '0';\n+        i++;\n+      }\n+    }\n+\n+    dec_expon = (dec_expon + sgn_exp) ^ sgn_exp;\n+  }\n+\n+\n+  if (ndigits_total <= MAX_FORMAT_DIGITS_128) {\n+    dec_expon +=\n+      DECIMAL_EXPONENT_BIAS_128 - ndigits_after -\n+      right_radix_leading_zeros;\n+    if (dec_expon < 0) {\n+      res.w[1] = 0 | sign_x;\n+      res.w[0] = 0;\n+    }\n+    if (ndigits_total == 0) {\n+      CX.w[0] = 0;\n+      CX.w[1] = 0;\n+    } else if (ndigits_total <= 19) {\n+      coeff_high = buffer[0] - '0';\n+      for (i = 1; i < ndigits_total; i++) {\n+        coeff2 = coeff_high + coeff_high;\n+        coeff_high = (coeff2 << 2) + coeff2 + buffer[i] - '0';\n+      }\n+      CX.w[0] = coeff_high;\n+      CX.w[1] = 0;\n+    } else {\n+      coeff_high = buffer[0] - '0';\n+      for (i = 1; i < ndigits_total - 17; i++) {\n+        coeff2 = coeff_high + coeff_high;\n+        coeff_high = (coeff2 << 2) + coeff2 + buffer[i] - '0';\n+      }\n+      coeff_low = buffer[i] - '0';\n+      i++;\n+      for (; i < ndigits_total; i++) {\n+        coeff_l2 = coeff_low + coeff_low;\n+        coeff_low = (coeff_l2 << 2) + coeff_l2 + buffer[i] - '0';\n+      }\n+      // now form the coefficient as coeff_high*10^19+coeff_low+carry\n+      scale_high = 100000000000000000ull;\n+      __mul_64x64_to_128_fast (CX, coeff_high, scale_high);\n+\n+      CX.w[0] += coeff_low;\n+      if (CX.w[0] < coeff_low)\n+        CX.w[1]++;\n+    }\n+    get_BID128_string (&res, sign_x, dec_expon, CX);\n+    BID_RETURN (res);\n+  } else {\n+    // simply round using the digits that were read\n+\n+    dec_expon +=\n+      ndigits_before + DECIMAL_EXPONENT_BIAS_128 -\n+      MAX_FORMAT_DIGITS_128 - right_radix_leading_zeros;\n+\n+    if (dec_expon < 0) {\n+      res.w[1] = 0 | sign_x;\n+      res.w[0] = 0;\n+    }\n+\n+    coeff_high = buffer[0] - '0';\n+    for (i = 1; i < MAX_FORMAT_DIGITS_128 - 17; i++) {\n+      coeff2 = coeff_high + coeff_high;\n+      coeff_high = (coeff2 << 2) + coeff2 + buffer[i] - '0';\n+    }\n+    coeff_low = buffer[i] - '0';\n+    i++;\n+    for (; i < MAX_FORMAT_DIGITS_128; i++) {\n+      coeff_l2 = coeff_low + coeff_low;\n+      coeff_low = (coeff_l2 << 2) + coeff_l2 + buffer[i] - '0';\n+    }\n+    carry = ((unsigned) ('4' - buffer[i])) >> 31;\n+    if ((buffer[i] == '5' && !(coeff_low & 1)) || dec_expon < 0) {\n+      if (dec_expon >= 0) {\n+        carry = 0;\n+        i++;\n+      }\n+      for (; i < ndigits_total; i++) {\n+        if (buffer[i] > '0') {\n+          carry = 1;\n+          break;\n+        }\n+      }\n+    }\n+    // now form the coefficient as coeff_high*10^17+coeff_low+carry\n+    scale_high = 100000000000000000ull;\n+    if (dec_expon < 0) {\n+      if (dec_expon > -MAX_FORMAT_DIGITS_128) {\n+        scale_high = 1000000000000000000ull;\n+        coeff_low = (coeff_low << 3) + (coeff_low << 1);\n+        dec_expon--;\n+      }\n+      if (dec_expon == -MAX_FORMAT_DIGITS_128\n+          && coeff_high > 50000000000000000ull)\n+        carry = 0;\n+    }\n+\n+    __mul_64x64_to_128_fast (CX, coeff_high, scale_high);\n+\n+    coeff_low += carry;\n+    CX.w[0] += coeff_low;\n+    if (CX.w[0] < coeff_low)\n+      CX.w[1]++;\n+\n+    get_BID128_string (&res, sign_x, dec_expon, CX);\n+    BID_RETURN (res);\n+  }\n+}"}, {"sha": "38e22ae1782def0268ae04c178b24023630f91cf", "filename": "libgcc/config/libbid/bid128_logb.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_logb.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+BID128_FUNCTION_ARG1(__bid128_logb, x)\n+\n+  UINT128 CX, L, res;\n+  UINT64 sign_x, sign_e, logb_sign;\n+  SINT64 D;\n+  int_float f64, fx;\n+  int exponent_x, bin_expon_cx, digits;\n+\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    // x is Infinity?\n+    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      if ((x.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)\n+        // +/-Inf, return Inf\n+        res.w[1] = 0x7800000000000000ull;\n+      BID_RETURN (res);\n+    }\n+    // x is 0 otherwise\n+\n+#ifdef SET_STATUS_FLAGS\n+    // set status flags\n+    __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+    res.w[1] = 0xf800000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+  // find number of digits in coefficient\n+  // 2^64\n+  f64.i = 0x5f800000;\n+  // fx ~ CX\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+  digits = __bid_estimate_decimal_digits[bin_expon_cx];\n+  // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n+  D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n+  if (D > 0\n+      || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+    digits++;\n+\n+  exponent_x = exponent_x - DECIMAL_EXPONENT_BIAS_128 - 1 + digits;\n+\n+  // extract sign and absolute value from exponent_x\n+  sign_e = ((SINT32) exponent_x) >> 31;\n+  exponent_x = (exponent_x + sign_e) ^ sign_e;\n+\n+  L.w[0] = exponent_x;\n+  L.w[1] = 0;\n+  logb_sign = sign_e << 63;\n+\n+  get_BID128_very_fast (&res, logb_sign, DECIMAL_EXPONENT_BIAS_128, L);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "6194a296c4a1295aac0681b721d3cf5b66642fcb", "filename": "libgcc/config/libbid/bid128_minmax.c", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_minmax.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,907 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID128 minimum number\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_minnum (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+UINT128\n+__bid128_minnum (UINT128 x, UINT128 y) {\n+#endif\n+\n+  UINT128 res;\n+  int exp_x, exp_y;\n+  int diff;\n+  UINT128 sig_x, sig_y;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // NaN (CASE1)\n+  // if x is NAN, then return y\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN \n+      // set invalid flag \n+      ; // *pfpsf |= INVALID_EXCEPTION; \n+      // return quiet (y) \n+      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull; \n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // if y is NAN, then return x\n+  else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal (not Greater).\n+  if (x.w[0] == y.w[0] && x.w[1] == y.w[1]) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    // if x is neg infinity, there is no way it is greater than y, return 0\n+    res = (((x.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is positive infinity, then x is less, return 0\n+    //                 if y is negative infinity, then x is greater, return 1\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // CONVERT X\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF X IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_x = 1;\n+  else\n+    non_canon_x = 0;\n+\n+  // CONVERT Y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF Y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n+      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_y = 1;\n+  else\n+    non_canon_y = 0;\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore ignore the sign\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => ignore the exponent \n+  //    field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    x_is_zero = 1;\n+  }\n+  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    y_is_zero = 1;\n+  }\n+\n+  if (x_is_zero && y_is_zero) {\n+    // if both numbers are zero, neither is greater => return either number\n+    res = x;\n+    BID_RETURN (res);\n+  } else if (x_is_zero) {\n+    // is x is zero, it is greater if Y is negative\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  } else if (y_is_zero) {\n+    // is y is zero, X is greater if it is positive\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGN (CASE5)\n+  // now, if the sign bits differ, x is greater if y is negative\n+  if (((x.w[1] ^ y.w[1]) & MASK_SIGN) == MASK_SIGN) {\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if exponents are the same, then we have a simple comparison of \n+  //    the significands\n+  if (exp_y == exp_x) {\n+    res = (((sig_x.w[1] > sig_y.w[1])\n+            || (sig_x.w[1] == sig_y.w[1]\n+                && sig_x.w[0] >= sig_y.w[0])) ^ ((x.w[1] & MASK_SIGN) ==\n+                                                 MASK_SIGN)) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // if both components are either bigger or smaller, it is clear what \n+  //    needs to be done\n+  if (sig_x.w[1] >= sig_y.w[1] && sig_x.w[0] >= sig_y.w[0]\n+      && exp_x > exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x.w[1] <= sig_y.w[1] && sig_x.w[0] <= sig_y.w[0]\n+      && exp_x < exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+\n+  diff = exp_x - exp_y;\n+\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (diff > 0) { // to simplify the loop below,\n+    // if exp_x is 33 greater than exp_y, no need for compensation\n+    if (diff > 33) {\n+      // difference cannot be greater than 10^33\n+      res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+      // if postitive, return whichever significand is larger \n+      // (converse if negative)\n+      res = ((((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n+              || (sig_n_prime256.w[1] > sig_y.w[1])\n+              || (sig_n_prime256.w[1] == sig_y.w[1]\n+                  && sig_n_prime256.w[0] >\n+                  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n+                                  MASK_SIGN)) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    res =\n+      (((sig_n_prime192.w[2] > 0) || (sig_n_prime192.w[1] > sig_y.w[1])\n+        || (sig_n_prime192.w[1] == sig_y.w[1]\n+            && sig_n_prime192.w[0] >\n+            sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  diff = exp_y - exp_x;\n+  // if exp_x is 33 less than exp_y, no need for compensation\n+  if (diff > 33) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    res =\n+      ((sig_n_prime256.w[3] != 0 || sig_n_prime256.w[2] != 0\n+        || (sig_n_prime256.w[1] > sig_x.w[1]\n+            || (sig_n_prime256.w[1] == sig_x.w[1]\n+                && sig_n_prime256.w[0] >\n+                sig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+                                 MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  // if postitive, return whichever significand is larger (converse if negative)\n+  res = ((sig_n_prime192.w[2] != 0 || (sig_n_prime192.w[1] > sig_x.w[1] || \n+      (sig_n_prime192.w[1] == sig_x.w[1] && sig_n_prime192.w[0] > sig_x.w[0])))\n+       ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128 minimum magnitude function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_minnum_mag (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+UINT128\n+__bid128_minnum_mag (UINT128 x, UINT128 y) {\n+#endif\n+\n+  UINT128 res;\n+  int exp_x, exp_y;\n+  int diff;\n+  UINT128 sig_x, sig_y;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char non_canon_x, non_canon_y;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // NaN (CASE1)\n+  // if x is NAN, then return y\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+      // set invalid flag\n+      ; // *pfpsf |= INVALID_EXCEPTION;\n+      // return quiet (y)\n+      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    // if y is NAN, then return x\n+    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal (not Greater).\n+  if (x.w[0] == y.w[0] && x.w[1] == y.w[1]) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    // if x infinity, it has maximum magnitude.\n+    // Check if magnitudes are equal.  If x is negative, return it.\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN\n+           && (y.w[1] & MASK_INF) == MASK_INF) ? x : y;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is infinity, then x is less in magnitude\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // CONVERT X\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF X IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_x = 1;\n+  else\n+    non_canon_x = 0;\n+\n+  // CONVERT Y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF Y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n+      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_y = 1;\n+  else\n+    non_canon_y = 0;\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore ignore the sign\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        therefore ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // check if exponents are the same and significands are the same\n+  if (exp_y == exp_x && sig_x.w[1] == sig_y.w[1]\n+      && sig_x.w[0] == sig_y.w[0]) {\n+    if (x.w[1] & 0x8000000000000000ull) { // x is negative\n+      res = x;\n+      BID_RETURN (res);\n+    } else {\n+      res = y;\n+      BID_RETURN (res);\n+    }\n+  } else if (((sig_x.w[1] > sig_y.w[1] || (sig_x.w[1] == sig_y.w[1]\n+               && sig_x.w[0] > sig_y.w[0])) && exp_x == exp_y)\n+             || ((sig_x.w[1] > sig_y.w[1]\n+                  || (sig_x.w[1] == sig_y.w[1]\n+                  && sig_x.w[0] >= sig_y.w[0]))\n+                 && exp_x > exp_y)) {\n+    // if both components are either bigger or smaller, it is clear what \n+    // needs to be done; also if the magnitudes are equal\n+    res = y;\n+    BID_RETURN (res);\n+  } else if (((sig_y.w[1] > sig_x.w[1] || (sig_y.w[1] == sig_x.w[1]\n+               && sig_y.w[0] > sig_x.w[0])) && exp_y == exp_x)\n+             || ((sig_y.w[1] > sig_x.w[1]\n+                  || (sig_y.w[1] == sig_x.w[1]\n+                  && sig_y.w[0] >= sig_x.w[0]))\n+                 && exp_y > exp_x)) {\n+    res = x;\n+    BID_RETURN (res);\n+  } else {\n+    ; // continue\n+  }\n+  diff = exp_x - exp_y;\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (diff > 0) { // to simplify the loop below,\n+    // if exp_x is 33 greater than exp_y, no need for compensation\n+    if (diff > 33) {\n+      res = y; // difference cannot be greater than 10^33\n+      BID_RETURN (res);\n+    }\n+    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+      // if positive, return whichever significand is larger \n+      // (converse if negative)\n+      if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n+          && sig_n_prime256.w[1] == sig_y.w[1]\n+          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+        res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x; // if equal\n+        BID_RETURN (res);\n+      }\n+      res = (((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n+             || (sig_n_prime256.w[1] > sig_y.w[1])\n+             || (sig_n_prime256.w[1] == sig_y.w[1]\n+                 && sig_n_prime256.w[0] > sig_y.w[0])) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    // if positive, return whichever significand is larger \n+    // (converse if negative)\n+    if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n+        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+      // if = in magnitude, return +, (if possible)\n+      res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    res = ((sig_n_prime192.w[2] > 0)\n+           || (sig_n_prime192.w[1] > sig_y.w[1])\n+           || (sig_n_prime192.w[1] == sig_y.w[1]\n+               && sig_n_prime192.w[0] > sig_y.w[0])) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  diff = exp_y - exp_x;\n+  // if exp_x is 33 less than exp_y, no need for compensation\n+  if (diff > 33) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    // if positive, return whichever significand is larger \n+    // (converse if negative)\n+    if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n+        && sig_n_prime256.w[1] == sig_x.w[1]\n+        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+      // if = in magnitude, return +, (if possible)\n+      res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    res = (sig_n_prime256.w[3] == 0 && sig_n_prime256.w[2] == 0\n+           && (sig_n_prime256.w[1] < sig_x.w[1]\n+               || (sig_n_prime256.w[1] == sig_x.w[1]\n+                   && sig_n_prime256.w[0] < sig_x.w[0]))) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  // if positive, return whichever significand is larger (converse if negative)\n+  if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_x.w[1]\n+      && (sig_n_prime192.w[0] == sig_x.w[0])) {\n+    // if = in magnitude, return +, if possible)\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  res = (sig_n_prime192.w[2] == 0 && (sig_n_prime192.w[1] < sig_x.w[1] || \n+      (sig_n_prime192.w[1] == sig_x.w[1] && \n+      sig_n_prime192.w[0] < sig_x.w[0]))) ? y : x;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128 maximum function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_maxnum (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+UINT128\n+__bid128_maxnum (UINT128 x, UINT128 y) {\n+#endif\n+\n+  UINT128 res;\n+  int exp_x, exp_y;\n+  int diff;\n+  UINT128 sig_x, sig_y;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // NaN (CASE1)\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    // if x is NAN, then return y\n+    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+      // set invalid flag\n+      ; // *pfpsf |= INVALID_EXCEPTION;\n+      // return quiet (y)\n+      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    // if y is NAN, then return x\n+    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal (not Greater).\n+  if (x.w[0] == y.w[0] && x.w[1] == y.w[1]) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is positive infinity, then x is less, return 0\n+    //                 if y is negative infinity, then x is greater, return 1\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // CONVERT X\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF X IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_x = 1;\n+  else\n+    non_canon_x = 0;\n+\n+  // CONVERT Y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF Y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n+      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_y = 1;\n+  else\n+    non_canon_y = 0;\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore ignore the sign\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        therefore ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    x_is_zero = 1;\n+  }\n+  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    y_is_zero = 1;\n+  }\n+\n+  if (x_is_zero && y_is_zero) {\n+    // if both numbers are zero, neither is greater => return either number\n+    res = x;\n+    BID_RETURN (res);\n+  } else if (x_is_zero) {\n+    // is x is zero, it is greater if Y is negative\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  } else if (y_is_zero) {\n+    // is y is zero, X is greater if it is positive\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGN (CASE5)\n+  // now, if the sign bits differ, x is greater if y is negative\n+  if (((x.w[1] ^ y.w[1]) & MASK_SIGN) == MASK_SIGN) {\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if exponents are the same, then we have a simple comparison of \n+  // the significands\n+  if (exp_y == exp_x) {\n+    res = (((sig_x.w[1] > sig_y.w[1]) || (sig_x.w[1] == sig_y.w[1] && \n+        sig_x.w[0] >= sig_y.w[0])) ^ \n+        ((x.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // if both components are either bigger or smaller, it is clear what \n+  // needs to be done\n+  if ((sig_x.w[1] > sig_y.w[1]\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] > sig_y.w[0]))\n+      && exp_x >= exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  if ((sig_x.w[1] < sig_y.w[1]\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] < sig_y.w[0]))\n+      && exp_x <= exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  diff = exp_x - exp_y;\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (diff > 0) { // to simplify the loop below,\n+    // if exp_x is 33 greater than exp_y, no need for compensation\n+    if (diff > 33) {\n+      // difference cannot be greater than 10^33\n+      res = ((x.w[1] & MASK_SIGN) != MASK_SIGN) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+      // if postitive, return whichever significand is larger \n+      // (converse if negative)\n+      res = ((((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n+              || (sig_n_prime256.w[1] > sig_y.w[1])\n+              || (sig_n_prime256.w[1] == sig_y.w[1]\n+                  && sig_n_prime256.w[0] >\n+                  sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) ==\n+                                  MASK_SIGN)) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    res =\n+      (((sig_n_prime192.w[2] > 0) || (sig_n_prime192.w[1] > sig_y.w[1])\n+        || (sig_n_prime192.w[1] == sig_y.w[1]\n+            && sig_n_prime192.w[0] >\n+            sig_y.w[0])) ^ ((y.w[1] & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  diff = exp_y - exp_x;\n+  // if exp_x is 33 less than exp_y, no need for compensation\n+  if (diff > 33) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    res =\n+      ((sig_n_prime256.w[3] != 0 || sig_n_prime256.w[2] != 0\n+        || (sig_n_prime256.w[1] > sig_x.w[1]\n+            || (sig_n_prime256.w[1] == sig_x.w[1]\n+                && sig_n_prime256.w[0] >\n+                sig_x.w[0]))) ^ ((x.w[1] & MASK_SIGN) !=\n+                                 MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  // if postitive, return whichever significand is larger (converse if negative)\n+  res = ((sig_n_prime192.w[2] != 0 || (sig_n_prime192.w[1] > sig_x.w[1] || \n+      (sig_n_prime192.w[1] == sig_x.w[1] && \n+      sig_n_prime192.w[0] > sig_x.w[0]))) ^ \n+      ((y.w[1] & MASK_SIGN) != MASK_SIGN)) ? x : y;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128 maximum magnitude function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_maxnum_mag (UINT128 * pres, UINT128 * px, UINT128 * py) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+UINT128\n+__bid128_maxnum_mag (UINT128 x, UINT128 y) {\n+#endif\n+\n+  UINT128 res;\n+  int exp_x, exp_y;\n+  int diff;\n+  UINT128 sig_x, sig_y;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char non_canon_x, non_canon_y;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // NaN (CASE1)\n+  if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    // if x is NAN, then return y\n+    if ((x.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+      // set invalid flag\n+      ; // *pfpsf |= INVALID_EXCEPTION;\n+      // return quiet (y)\n+      ; // y.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+    // if y is NAN, then return x\n+    if ((y.w[1] & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;   // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal (not Greater).\n+  if (x.w[0] == y.w[0] && x.w[1] == y.w[1]) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    // if x infinity, it has maximum magnitude\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN\n+           && (y.w[1] & MASK_INF) == MASK_INF) ? y : x;\n+    BID_RETURN (res);\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is positive infinity, then x is less, return 0\n+    //                 if y is negative infinity, then x is greater, return 1\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // CONVERT X\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF X IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_x = 1;\n+  else\n+    non_canon_x = 0;\n+\n+  // CONVERT Y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF Y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((sig_y.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_y.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_y.w[0] > 0x378d8e63ffffffffull))\n+      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull))\n+    non_canon_y = 1;\n+  else\n+    non_canon_y = 0;\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore ignore the sign\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //         therefore ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  if (non_canon_y || ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  if (exp_y == exp_x && sig_x.w[1] == sig_y.w[1]\n+      && sig_x.w[0] == sig_y.w[0]) {\n+    // check if exponents are the same and significands are the same\n+    if (x.w[1] & 0x8000000000000000ull) { // x is negative\n+      res = y;\n+      BID_RETURN (res);\n+    } else {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+  } else if (((sig_x.w[1] > sig_y.w[1] || (sig_x.w[1] == sig_y.w[1]\n+               && sig_x.w[0] > sig_y.w[0])) && exp_x == exp_y)\n+             || ((sig_x.w[1] > sig_y.w[1]\n+                  || (sig_x.w[1] == sig_y.w[1]\n+                  && sig_x.w[0] >= sig_y.w[0]))\n+                 && exp_x > exp_y)) {\n+    // if both components are either bigger or smaller, it is clear what \n+    // needs to be done; also if the magnitudes are equal\n+    res = x;\n+    BID_RETURN (res);\n+  } else if (((sig_y.w[1] > sig_x.w[1] || (sig_y.w[1] == sig_x.w[1]\n+               && sig_y.w[0] > sig_x.w[0])) && exp_y == exp_x)\n+             || ((sig_y.w[1] > sig_x.w[1]\n+                  || (sig_y.w[1] == sig_x.w[1]\n+                  && sig_y.w[0] >= sig_x.w[0]))\n+                 && exp_y > exp_x)) {\n+    res = y;\n+    BID_RETURN (res);\n+  } else {\n+    ;        // continue\n+  }\n+  diff = exp_x - exp_y;\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (diff > 0) { // to simplify the loop below,\n+    // if exp_x is 33 greater than exp_y, no need for compensation\n+    if (diff > 33) {\n+      res = x; // difference cannot be greater than 10^33\n+      BID_RETURN (res);\n+    }\n+    if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x, __bid_ten2k128[diff - 20]);\n+      // if postitive, return whichever significand is larger \n+      // (converse if negative)\n+      if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n+          && sig_n_prime256.w[1] == sig_y.w[1]\n+          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+        res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y; // if equal\n+        BID_RETURN (res);\n+      }\n+      res = (((sig_n_prime256.w[3] > 0) || sig_n_prime256.w[2] > 0)\n+             || (sig_n_prime256.w[1] > sig_y.w[1])\n+             || (sig_n_prime256.w[1] == sig_y.w[1]\n+                 && sig_n_prime256.w[0] > sig_y.w[0])) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_x);\n+    // if postitive, return whichever significand is larger (converse if negative)\n+    if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n+        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+      // if equal, return positive magnitude\n+      res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    res = ((sig_n_prime192.w[2] > 0)\n+           || (sig_n_prime192.w[1] > sig_y.w[1])\n+           || (sig_n_prime192.w[1] == sig_y.w[1]\n+               && sig_n_prime192.w[0] > sig_y.w[0])) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  diff = exp_y - exp_x;\n+  // if exp_x is 33 less than exp_y, no need for compensation\n+  if (diff > 33) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  if (diff > 19) { //128 by 128 bit multiply -> 256 bits\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y, __bid_ten2k128[diff - 20]);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    if (sig_n_prime256.w[3] == 0 && (sig_n_prime256.w[2] == 0)\n+        && sig_n_prime256.w[1] == sig_x.w[1]\n+        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+      // if equal, return positive (if possible)\n+      res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    res = (sig_n_prime256.w[3] == 0 && sig_n_prime256.w[2] == 0\n+           && (sig_n_prime256.w[1] < sig_x.w[1]\n+               || (sig_n_prime256.w[1] == sig_x.w[1]\n+                   && sig_n_prime256.w[0] < sig_x.w[0]))) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[diff], sig_y);\n+  // if postitive, return whichever significand is larger (converse if negative)\n+  if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_x.w[1]\n+      && (sig_n_prime192.w[0] == sig_x.w[0])) {\n+    // if equal, return positive (if possible)\n+    res = ((y.w[1] & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  res = (sig_n_prime192.w[2] == 0 && (sig_n_prime192.w[1] < sig_x.w[1] || \n+      (sig_n_prime192.w[1] == sig_x.w[1] && \n+      sig_n_prime192.w[0] < sig_x.w[0]))) ? x : y;\n+  BID_RETURN (res);\n+}"}, {"sha": "f5fe5e86871b72d435dfa5b0c73325acf10d4394", "filename": "libgcc/config/libbid/bid128_mul.c", "status": "added", "additions": 1804, "deletions": 0, "changes": 1804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_mul.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,1804 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_mul (UINT128 * pres, UINT128 * px,\n+            UINT128 *\n+            py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+            _EXC_INFO_PARAM) {\n+  UINT128 x = *px, y = *py;\n+\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+\n+#endif\n+#else\n+UINT128\n+__bid128_mul (UINT128 x,\n+            UINT128 y _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+            _EXC_INFO_PARAM) {\n+\n+#endif\n+  UINT128 res;\n+  UINT64 x_sign, y_sign, sign;\n+  UINT64 x_exp, y_exp;\n+\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  // Note: C2.w[1], C2.w[0] represent y_signif_hi, y_signif_lo (all are UINT64)\n+  UINT64 tmp64, tmp64A;\n+  BID_UI64DOUBLE tmp1, tmp2;\n+  int x_nr_bits, y_nr_bits;\n+  int q1, q2, ind, shift;\n+  UINT128 C1, C2;\n+  UINT128 Cstar;  // C* represents up to 34 decimal digits ~ 113 bits\n+  UINT384 fstar;\n+  int q;\n+  UINT128 P128, R128; // for underflow path\n+  UINT192 P192, R192; // for underflow path\n+  UINT256 C, P256, R256;\n+  UINT384 P384;\n+  UINT512 P512;\n+  int incr_exp = 0; // for underflow path\n+  int incr_exp1 = 0; // for underflow path\n+  int tmp_fpa = 0;  // if possible underflow and q>=34, use to undo the rounding\n+  UINT64 C1_hi, C2_hi;\n+  UINT64 C1_lo, C2_lo;\n+  int is_inexact = 0;\n+  int is_midpoint_lt_even = 0, is_midpoint_gt_even = 0;\n+  int is_inexact_lt_midpoint = 0, is_inexact_gt_midpoint = 0;\n+  int is_midpoint_lt_even1 = 0, is_midpoint_gt_even1 = 0;\n+  int is_inexact_lt_midpoint1 = 0, is_inexact_gt_midpoint1 = 0;\n+  int is_overflow = 0;\n+  int no_underflow = 0;\n+\n+  // unpack the arguments\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C1_hi = x.w[1] & MASK_COEFF;\n+  C1_lo = x.w[0];\n+\n+  // unpack y\n+  y_sign = y.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  y_exp = y.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C2_hi = y.w[1] & MASK_COEFF;\n+  C2_lo = y.w[0];\n+  sign = x_sign ^ y_sign;\n+\n+  // check for NaN or Infinity\n+  if (((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL)\n+      || ((y.w[1] & MASK_SPECIAL) == MASK_SPECIAL)) {\n+\n+    // x is special or y is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+\n+        // return quiet (x)\n+        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = x.w[0];\n+      } else { // x is QNaN\n+        if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+          // set invalid flag\n+          *pfpsf |= INVALID_EXCEPTION;\n+        }\n+        // return x\n+        res.w[1] = x.w[1];\n+        res.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else if ((y.w[1] & MASK_NAN) == MASK_NAN) { // y is NAN\n+      if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+\n+        // return quiet (y)\n+        res.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = y.w[0];\n+      } else { // y is QNaN\n+        // return y\n+        res.w[1] = y.w[1];\n+        res.w[0] = y.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else { // neither x nor y is NaN; at least one is infinity\n+      if ((x.w[1] & MASK_ANY_INF) == MASK_INF) { // x is infinity\n+        if (((y.w[1] & MASK_ANY_INF) == MASK_INF) || (C2_hi != 0x0ull)\n+            || (C2_lo != 0x0ull)) {\n+\n+          // y is infinity OR y is finite \n+          // if same sign, return +inf otherwise return -inf\n+          if (!sign) {\n+            res.w[1] = 0x7800000000000000ull; // +inf\n+            res.w[0] = 0x0000000000000000ull;\n+          } else { // x and y are infinities of opposite signs\n+            res.w[1] = 0xf800000000000000ull; // -inf\n+            res.w[0] = 0x0000000000000000ull;\n+          }\n+        } else { // if y is 0\n+          // set invalid flag\n+          *pfpsf |= INVALID_EXCEPTION;\n+\n+          // return QNaN Indefinite\n+          res.w[1] = 0x7c00000000000000ull;\n+          res.w[0] = 0x0000000000000000ull;\n+        }\n+      } else { // x is not NaN or infinity, so y must be infinity\n+        if ((C1_hi != 0x0ull) || (C1_lo != 0x0ull)) {\n+\n+          // x is finite\n+          // if same sign, return +inf otherwise return -inf\n+          if (!sign) {\n+            res.w[1] = 0x7800000000000000ull; // +inf\n+            res.w[0] = 0x0000000000000000ull;\n+          } else { // y and x are of opposite signs\n+            res.w[1] = 0xf800000000000000ull; // -inf\n+            res.w[0] = 0x0000000000000000ull;\n+          }\n+        } else { // if x is 0\n+          // set invalid flag\n+          *pfpsf |= INVALID_EXCEPTION;\n+\n+          // return QNaN Indefinite\n+          res.w[1] = 0x7c00000000000000ull;\n+          res.w[0] = 0x0000000000000000ull;\n+        }\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1_hi > 0x0001ed09bead87c0ull) || \n+      ((C1_hi == 0x0001ed09bead87c0ull) && (C1_lo > 0x378d8e63ffffffffull))) && \n+      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      x_exp = (x.w[1] << 2) & MASK_EXP; // same position as for G[0]G[1] != 11\n+    }\n+    x.w[1] = x.w[1] & 0x8000000000000000ull; // preserve the sign bit\n+    x.w[0] = 0;\n+    C1_hi = 0;\n+    C1_lo = 0;\n+  }\n+  // test for non-canonical values of the argument y\n+  if ((((C2_hi > 0x0001ed09bead87c0ull)\n+       || ((C2_hi == 0x0001ed09bead87c0ull)\n+           && (C2_lo > 0x378d8e63ffffffffull)))\n+      && ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      y_exp = (y.w[1] << 2) & MASK_EXP; // same position as for G[0]G[1] != 11\n+    }\n+    y.w[1] = y.w[1] & 0x8000000000000000ull; // preserve the sign bit\n+    y.w[0] = 0;\n+    C2_hi = 0;\n+    C2_lo = 0;\n+  }\n+  if (((C1_hi == 0x0ull) && (C1_lo == 0x0ull)) || ((C2_hi == 0x0ull)\n+      && (C2_lo == 0x0ull))) {\n+\n+    // x is 0 and y is not special OR y is 0 and x is not special\n+    // if same sign, return +0 otherwise return -0\n+    ind = (x_exp >> 49) + (y_exp >> 49) - 6176;\n+    if (ind < 0)\n+      ind = 0;\n+    if (ind > 0x2fff)\n+      ind = 0x2fff; // 6111 + 6176\n+    if ((x.w[1] & MASK_SIGN) == (y.w[1] & MASK_SIGN)) {\n+      res.w[1] = 0x0000000000000000ull | ((UINT64) ind << 49); // +0.0\n+      res.w[0] = 0x0000000000000000ull;\n+    } else { // opposite signs\n+      res.w[1] = 0x8000000000000000ull | ((UINT64) ind << 49); // -0.0\n+      res.w[0] = 0x0000000000000000ull;\n+    }\n+    BID_RETURN (res);\n+  } else { // x and y are not special and are not zero\n+    // unpack x\n+    C1.w[1] = C1_hi;\n+    C1.w[0] = C1_lo;\n+\n+    // q1 = nr. of decimal digits in x\n+    // determine first the nr. of bits in x\n+    if (C1.w[1] == 0) {\n+      if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n+        // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+        if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n+          tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n+          x_nr_bits =\n+            33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+        } else { // x < 2^32\n+          tmp1.d = (double) (C1.w[0]); // exact conversion\n+          x_nr_bits =\n+            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }} else { // if x < 2^53\n+        tmp1.d = (double) C1.w[0]; // exact conversion\n+        x_nr_bits =\n+          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }} else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+      tmp1.d = (double) C1.w[1]; // exact conversion\n+      x_nr_bits =\n+        65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    } q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q1 == 0) {\n+      q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+          || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+          && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+        q1++;\n+    }\n+    C2.w[1] = C2_hi;\n+    C2.w[0] = C2_lo;\n+    if (C2.w[1] == 0) {\n+      if (C2.w[0] >= 0x0020000000000000ull) { // y >= 2^53\n+        // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+        if (C2.w[0] >= 0x0000000100000000ull) { // y >= 2^32\n+          tmp2.d = (double) (C2.w[0] >> 32); // exact conversion\n+          y_nr_bits =\n+            32 + ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+        } else { // y < 2^32\n+          tmp2.d = (double) C2.w[0]; // exact conversion\n+          y_nr_bits =\n+            ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }} else { // if y < 2^53\n+        tmp2.d = (double) C2.w[0]; // exact conversion\n+        y_nr_bits =\n+          ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }} else { // C2.w[1] != 0 => nr. bits = 64 + nr_bits (C2.w[1])\n+      tmp2.d = (double) C2.w[1]; // exact conversion\n+      y_nr_bits =\n+        64 + ((((unsigned int) (tmp2.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    } q2 = __bid_nr_digits[y_nr_bits].digits;\n+    if (q2 == 0) {\n+      q2 = __bid_nr_digits[y_nr_bits].digits1;\n+      if (C2.w[1] > __bid_nr_digits[y_nr_bits].threshold_hi\n+          || (C2.w[1] == __bid_nr_digits[y_nr_bits].threshold_hi\n+          && C2.w[0] >= __bid_nr_digits[y_nr_bits].threshold_lo))\n+        q2++;\n+    }\n+    // the exact product has either q1 + q2 - 1 or q1 + q2 decimal digits\n+    // where 2 <= q1 + q2 <= 68\n+    // calculate C' = C1 * C2 and determine q\n+    C.w[3] = C.w[2] = C.w[1] = C.w[0] = 0;\n+    if (q1 + q2 <= 19) { // if 2 <= q1 + q2 <= 19, C' = C1 * C2 fits in 64 bits\n+      C.w[0] = C1.w[0] * C2.w[0];\n+\n+      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n+      if (C.w[0] < __bid_ten2k64[q1 + q2 - 1])\n+        q = q1 + q2 - 1; // q in [1, 18]\n+      else\n+        q = q1 + q2; // q in [2, 19]\n+      // length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n+    } else if (q1 + q2 == 20) { // C' = C1 * C2 fits in 64 or 128 bits\n+      // q1 <= 19 and q2 <= 19 so both C1 and C2 fit in 64 bits\n+      __mul_64x64_to_128MACH (C, C1.w[0], C2.w[0]);\n+\n+      // if C' < 10^(q1+q2-1) = 10^19 then q = q1+q2-1 = 19 else q = q1+q2 = 20\n+      if (C.w[1] == 0 && C.w[0] < __bid_ten2k64[19]) { // 19 = q1+q2-1\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n+        q = 19; // 19 = q1 + q2 - 1\n+      } else {\n+\n+        // if (C.w[1] == 0)\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        q = 20; // 20 = q1 + q2\n+      }\n+    } else if (q1 + q2 <= 38) { // 21 <= q1 + q2 <= 38\n+      // C' = C1 * C2 fits in 64 or 128 bits\n+      // (64 bits possibly, but only when q1 + q2 = 21 and C' has 20 digits)\n+      // at least one of C1, C2 has at most 19 decimal digits & fits in 64 bits\n+      if (q1 <= 19) {\n+        __mul_128x64_to_128 (C, C1.w[0], C2);\n+      } else { // q2 <= 19\n+        __mul_128x64_to_128 (C, C2.w[0], C1);\n+      }\n+\n+      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n+      if (C.w[1] < __bid_ten2k128[q1 + q2 - 21].w[1]\n+          || (C.w[1] == __bid_ten2k128[q1 + q2 - 21].w[1]\n+          && C.w[0] < __bid_ten2k128[q1 + q2 - 21].w[0])) {\n+\n+        // if (C.w[1] == 0) // q = 20, necessarily\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 64;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        q = q1 + q2 - 1; // q in [20, 37]\n+      } else {\n+\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        q = q1 + q2; // q in [21, 38]\n+      }\n+    } else if (q1 + q2 == 39) { // C' = C1 * C2 fits in 128 or 192 bits\n+      // both C1 and C2 fit in 128 bits (actually in 113 bits)\n+      // may replace this by 128x128_to192\n+      __mul_128x128_to_256 (C, C1, C2); // C.w[3] is 0\n+      // if C' < 10^(q1+q2-1) = 10^38 then q = q1+q2-1 = 38 else q = q1+q2 = 39\n+      if (C.w[2] == 0 && (C.w[1] < __bid_ten2k128[18].w[1] || \n+          (C.w[1] == __bid_ten2k128[18].w[1] && C.w[0] < __bid_ten2k128[18].w[0]))) { \n+          // 18 = 38 - 20 = q1+q2-1 - 20\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        q = 38; // 38 = q1 + q2 - 1\n+      } else {\n+\n+        // if (C.w[2] == 0)\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        q = 39; // 39 = q1 + q2\n+      }\n+    } else if (q1 + q2 <= 57) { // 40 <= q1 + q2 <= 57\n+      // C' = C1 * C2 fits in 128 or 192 bits\n+      // (128 bits possibly, but only when q1 + q2 = 40 and C' has 39 digits)\n+      // both C1 and C2 fit in 128 bits (actually in 113 bits); at most one\n+      // may fit in 64 bits\n+      if (C1.w[1] == 0) { // C1 fits in 64 bits\n+        // __mul_64x128_full (REShi64, RESlo128, A64, B128)\n+        __mul_64x128_full (C.w[2], C, C1.w[0], C2);\n+      } else if (C2.w[1] == 0) { // C2 fits in 64 bits\n+        // __mul_64x128_full (REShi64, RESlo128, A64, B128)\n+        __mul_64x128_full (C.w[2], C, C2.w[0], C1);\n+      } else { // both C1 and C2 require 128 bits\n+        // may use __mul_128x128_to_192 (C.w[2], C.w[0], C2.w[0], C1);\n+        __mul_128x128_to_256 (C, C1, C2); // C.w[3] = 0\n+      }\n+\n+      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n+      if (C.w[2] < __bid_ten2k256[q1 + q2 - 40].w[2]\n+          || (C.w[2] == __bid_ten2k256[q1 + q2 - 40].w[2]\n+          && (C.w[1] < __bid_ten2k256[q1 + q2 - 40].w[1]\n+              || (C.w[1] == __bid_ten2k256[q1 + q2 - 40].w[1]\n+              && C.w[0] < __bid_ten2k256[q1 + q2 - 40].w[0])))) {\n+\n+        // if (C.w[2] == 0) // q = 39, necessarily\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 128;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        q = q1 + q2 - 1; // q in [39, 56]\n+      } else {\n+\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        q = q1 + q2; // q in [40, 57]\n+      }\n+    } else if (q1 + q2 == 58) { // C' = C1 * C2 fits in 192 or 256 bits\n+      // both C1 and C2 fit in 128 bits (actually in 113 bits); at most one\n+      // may fit in 64 bits\n+      if (C1.w[1] == 0) { // C1 * C2 will fit in 192 bits\n+        __mul_64x128_full (C.w[2], C, C1.w[0], C2); // may use 64x128_to_192\n+      } else if (C2.w[1] == 0) { // C1 * C2 will fit in 192 bits\n+        __mul_64x128_full (C.w[2], C, C2.w[0], C1); // may use 64x128_to_192\n+      } else { // C1 * C2 will fit in 192 bits or in 256 bits\n+        __mul_128x128_to_256 (C, C1, C2);\n+      }\n+\n+      // if C' < 10^(q1+q2-1) = 10^57 then q = q1+q2-1 = 57 else q = q1+q2 = 58\n+      if (C.w[3] == 0 && (C.w[2] < __bid_ten2k256[18].w[2] || \n+          (C.w[2] == __bid_ten2k256[18].w[2] && (C.w[1] < __bid_ten2k256[18].w[1] || \n+          (C.w[1] == __bid_ten2k256[18].w[1] && C.w[0] < __bid_ten2k256[18].w[0]))))) {\n+          // 18 = 57 - 39 = q1+q2-1 - 39\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        q = 57; // 57 = q1 + q2 - 1\n+      } else {\n+\n+        // if (C.w[3] == 0)\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n+        q = 58; // 58 = q1 + q2\n+      }\n+    } else { // if 59 <= q1 + q2 <= 68\n+      // C' = C1 * C2 fits in 192 or 256 bits\n+      // (192 bits possibly, but only when q1 + q2 = 59 and C' has 58 digits)\n+      // both C1 and C2 fit in 128 bits (actually in 113 bits); none fits in\n+      // 64 bits\n+      // may use __mul_128x128_to_192 (C.w[2], C.w[0], C2.w[0], C1);\n+      __mul_128x128_to_256 (C, C1, C2); // C.w[3] = 0\n+      // if C' < 10^(q1+q2-1) then q = q1 + q2 - 1 else q = q1 + q2\n+      if (C.w[3] < __bid_ten2k256[q1 + q2 - 40].w[3]\n+          || (C.w[3] == __bid_ten2k256[q1 + q2 - 40].w[3]\n+          && (C.w[2] < __bid_ten2k256[q1 + q2 - 40].w[2]\n+              || (C.w[2] == __bid_ten2k256[q1 + q2 - 40].w[2]\n+              && (C.w[1] < __bid_ten2k256[q1 + q2 - 40].w[1]\n+                  || (C.w[1] == __bid_ten2k256[q1 + q2 - 40].w[1]\n+                  && C.w[0] < __bid_ten2k256[q1 + q2 - 40].w[0])))))) {\n+\n+        // if (C.w[3] == 0) // q = 58, necessarily\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 192;\n+        // else\n+        //   length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n+        q = q1 + q2 - 1; // q in [58, 67]\n+      } else {\n+\n+        // length of C1 * C2 rounded up to a multiple of 64 bits is len = 256;\n+        q = q1 + q2; // q in [59, 68]\n+      }\n+    }\n+    if (((UINT64) q << 49) + x_exp + y_exp <\n+        ((UINT64) P34 << 49) + EXP_MIN + BIN_EXP_BIAS) {\n+\n+      // possible underflow\n+      // q + ex + ey < P34 + EMIN <=> q - P34 < EMIN - ex - ey <=> q - P34 < ind\n+      goto _underflow_path;\n+    }\n+    if (q <= 34) { // 2 <= q <= 34 the result is exact, and fits in 113 bits\n+      tmp64 = x_exp + y_exp;\n+      if (tmp64 > EXP_MAX + BIN_EXP_BIAS) { // possible overflow\n+        ind = (tmp64 - EXP_MAX - BIN_EXP_BIAS) >> 49;\n+        if (ind > 34 - q) { // overflow in all rounding modes\n+          // |res| >= 10^p * 10^emax = 10^(p-1) * 10^(emax+1)\n+          // assemble the result\n+          if (rnd_mode == ROUNDING_TO_NEAREST\n+              || rnd_mode == ROUNDING_TIES_AWAY) {\n+            res.w[1] = sign | 0x7800000000000000ull;\n+            res.w[0] = 0x0ull;\n+          } else if (rnd_mode == ROUNDING_DOWN) {\n+            if (sign) { // res = -inf\n+              res.w[1] = 0xf800000000000000ull;\n+              res.w[0] = 0x0ull;\n+            } else { // res = +MAXFP\n+              res.w[1] = 0x5fffed09bead87c0ull;\n+              res.w[0] = 0x378d8e63ffffffffull;\n+            }\n+          } else if (rnd_mode == ROUNDING_UP) {\n+            if (sign) { // res = -MAXFP\n+              res.w[1] = 0xdfffed09bead87c0ull;\n+              res.w[0] = 0x378d8e63ffffffffull;\n+            } else { // res = +inf\n+              res.w[1] = 0x7800000000000000ull;\n+              res.w[0] = 0x0ull;\n+            }\n+          } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n+            // |res| = (10^34 - 1) * 10^6111 = +MAXFP\n+            res.w[1] = sign | 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull;\n+          }\n+\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+\n+          // set the overflow flag\n+          *pfpsf |= OVERFLOW_EXCEPTION;\n+\n+          // is_overflow = 1;\n+          BID_RETURN (res);\n+        } else { // tmp64 > EXP_MAX + BIN_EXP_BIAS but \n+          // ind = ((tmp64-EXP_MAX-BIN_EXP_BIAS)>>49) <= 34 - q\n+          // the exponent will be the maximum exponent\n+          // multiply C by 10^ind; the result fits in 34 digits\n+          if (ind <= 19) { // multiply by __bid_ten2k64[ind]\n+            if (q <= 19) { // 64x64 -> 128\n+              __mul_64x64_to_128MACH (C, C.w[0], __bid_ten2k64[ind]);\n+            } else { // 128 x 64 -> 128\n+              // may optimize to multiply 64 x 128 -> 128\n+              __mul_64x128_full (tmp64, C, __bid_ten2k64[ind], C);\n+            }\n+          } else { // if 20 <= ind <= 32 multiply by __bid_ten2k128[ind - 20]\n+            // it must be that C.w[1] = 0, as C < 10^14\n+            // may optimize to multiply 64 x 128 -> 128\n+            __mul_64x128_full (tmp64, C, C.w[0], __bid_ten2k128[ind - 20]);\n+          }\n+          res.w[0] = C.w[0];\n+          res.w[1] = C.w[1];\n+          res.w[1] |= EXP_MAX; // EXP MAX\n+        }\n+      } else {\n+        res.w[0] = C.w[0];\n+        res.w[1] = C.w[1];\n+        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+      }\n+      res.w[1] |= sign;\n+    } else if (q <= 38) { // 35 <= q <= 38; exact coefficient fits in 128 bits\n+      // C = C + 1/2 * 10^x where the result C fits in 127 bits\n+      ind = q - 35;\n+      tmp64 = C.w[0];\n+      C.w[0] = C.w[0] + __bid_midpoint64[ind];\n+      if (C.w[0] < tmp64)\n+        C.w[1]++;\n+\n+      // x = q - p = q - 34, 1 <= x <= 4\n+      // kx = 10^(-x) = __bid_ten2mk128M[ind]\n+      // C* = (C + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 128 bits\n+      __mul_128x128_to_256 (P256, C, __bid_ten2mk128M[ind]);\n+      Cstar.w[1] = P256.w[3];\n+      Cstar.w[0] = P256.w[2];\n+      fstar.w[2] = Cstar.w[0] & __bid_maskhigh128M[ind]; // fstar.w[3|4|5]=0\n+      fstar.w[1] = P256.w[1];\n+      fstar.w[0] = P256.w[0];\n+\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128M[] and __bid_maskhigh128M[]\n+      // the top Ex bits of 10^(-x) are T* = __bid_ten2mk128truncM[ind], e.g.\n+      // if x=1, T*=__bid_ten2mk128truncM[0]=0xcccccccccccccccccccccccccccccccc\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      //   if floor(C*) is even then C* = floor(C*) - logical right\n+      //       shift; C* has p decimal digits, correct by Prop. 1)\n+      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+      //       shift; C* has p decimal digits, correct by Pr. 1)\n+      // else\n+      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // n = C* * 10^(e+x)\n+\n+      // shift right C* by Ex-128 = __bid_shiftright128M[ind]\n+      shift = __bid_shiftright128M[ind]; // 3 <= shift <= 13\n+      Cstar.w[0] = (Cstar.w[0] >> shift) | (Cstar.w[1] << (64 - shift));\n+      Cstar.w[1] = (Cstar.w[1] >> shift);\n+\n+      // determine inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 > T*) then\n+      //   the result is inexact\n+      if (fstar.w[2] > __bid_one_half128M[ind]\n+          || (fstar.w[2] == __bid_one_half128M[ind]\n+          && (fstar.w[1] || fstar.w[0]))) {\n+\n+        // f* > 1/2 and the result may be exact\n+        // Calculate f* - 1/2\n+        tmp64 = fstar.w[2] - __bid_one_half128M[ind];\n+        if (tmp64 || fstar.w[1] > __bid_ten2mk128truncM[ind].w[1] || \n+            (fstar.w[1] == __bid_ten2mk128truncM[ind].w[1] && \n+            fstar.w[0] > __bid_ten2mk128truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          is_inexact_lt_midpoint = 1;\n+        }        // else the result is exact\n+      } else { // the result is inexact; f2* <= 1/2\n+        // set the inexact flag\n+        *pfpsf |= INEXACT_EXCEPTION;\n+        tmp_fpa = 1;\n+        is_inexact_gt_midpoint = 1;\n+      }\n+\n+      // check for midpoints (could do this before determining inexactness)\n+      if ((fstar.w[2] == 0) && (fstar.w[1] || fstar.w[0])\n+          && (fstar.w[1] < __bid_ten2mk128truncM[ind].w[1]\n+              || (fstar.w[1] == __bid_ten2mk128truncM[ind].w[1]\n+              && fstar.w[0] <= __bid_ten2mk128truncM[ind].w[0]))) {\n+\n+        // the result is a midpoint\n+        if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n+          // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n+          Cstar.w[0]--; // Cstar.w[0] is now even\n+          if (tmp_fpa == 1)\n+            tmp_fpa = 0;\n+          is_midpoint_gt_even = 1;\n+          is_inexact_lt_midpoint = 0;\n+          is_inexact_gt_midpoint = 0;\n+        } else { // else MP in [ODD, EVEN]\n+          is_midpoint_lt_even = 1;\n+          is_inexact_lt_midpoint = 0;\n+          is_inexact_gt_midpoint = 0;\n+        }\n+      }\n+      // check for rounding overflow\n+      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n+          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 2) << 49);\n+        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n+        Cstar.w[0] = 0x38c15b0a00000000ull;\n+\n+        // if rounding overflow made the exponent equal to emin, set underflow\n+        if (tmp64 == EXP_MIN + BIN_EXP_BIAS)\n+          *pfpsf |= UNDERFLOW_EXCEPTION;\n+      } else { // 10^33 <= Cstar <= 10^34 - 1\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 1) << 49); // ind+1 = q-34\n+      }\n+      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n+        // exp >= emax for the result rounded to nearest even\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY) {\n+          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n+\n+            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n+            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_DOWN) {\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0xf800000000000000ull; // -inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_UP) {\n+          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0x7800000000000000ull; // inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        }\n+        if (is_overflow) { // return for overflow\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+\n+          // set the overflow flag\n+          *pfpsf |= OVERFLOW_EXCEPTION;\n+\n+          // is_overflow = 1;\n+          BID_RETURN (res);\n+        }\n+      } else {\n+        res.w[0] = Cstar.w[0];\n+        res.w[1] = Cstar.w[1];\n+        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+      }\n+      res.w[1] |= sign;\n+    } else if (q <= 57) { // 39 <= q <= 57; exact coefficient takes 128-192 bits\n+      // C = C + 1/2 * 10^x where the result C fits in 190 bits\n+      // (10^57 - 1 + 1/2 * 10^23 can be represented with 190 bits)\n+      // x = q - p = q - 34, 5 <= x <= 23\n+      // kx = 10^(-x) = __bid_ten2mk192M[ind]\n+      // C* = (C + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 192 bits\n+      ind = q - 39; // 0 <= ind <= 18\n+      tmp64 = C.w[0];\n+      tmp64A = C.w[1];\n+\n+      // Note:\n+      // if 5 <= x <= 19 <=> 0 <= ind <= 14 then\n+      //   f* has 256 bits\n+      // else // if 20 <= x <= 23 <=> 15 <= ind <= 18 then\n+      //   f* has 320 bits\n+      if (ind <= 14) { // x - 1 = q - 35 = ind + 4 <= 18 \n+        // add one 64-bit word\n+        C.w[0] = C.w[0] + __bid_midpoint64[ind + 4];\n+        if (C.w[0] < tmp64)\n+          C.w[1]++;\n+        if (C.w[1] < tmp64A)\n+          C.w[2]++;\n+        __mul_192x192_to_384 (P384, C, __bid_ten2mk192M[ind])\n+          // calculate C* and f*; C* is actually floor(C*) in this case\n+          // C* and f* need shifting and masking, as shown by \n+          // __bid_shiftright192M[] and __bid_maskhigh192M[]\n+          // C* has 128 bits; P384.w[5], P384.w[4], P384.w[3] need to be\n+          // shifted right by Ex-192 = __bid_shiftright192M[ind]\n+          shift = __bid_shiftright192M[ind]; // 16 <= shift <= 63\n+        Cstar.w[0] = (P384.w[3] >> shift) | (P384.w[4] << (64 - shift));\n+        Cstar.w[1] = (P384.w[4] >> shift) | (P384.w[5] << (64 - shift));\n+\n+        // f* has 256 bits\n+        fstar.w[3] = P384.w[3] & __bid_maskhigh192M[ind];\n+        fstar.w[2] = P384.w[2];\n+        fstar.w[1] = P384.w[1];\n+        fstar.w[0] = P384.w[0];\n+\n+        // the top Ex bits of 10^(-x) are T* = __bid_ten2mk192truncM[ind], e.g. \n+        // if x=5, T* = __bid_ten2mk192truncM[0] =\n+        //   0xa7c5ac471b4784230fcf80dc33721d53cddd6e04c0592103\n+        // if (0 < f* < 10^(-x)) then the result is a midpoint\n+        //   if floor(C*) is even then C* = floor(C*) - logical right\n+        //       shift; C* has p decimal digits, correct by Prop. 1)\n+        //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+        //       shift; C* has p decimal digits, correct by Pr. 1)\n+        // else\n+        //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+        //       correct by Property 1)\n+        // n = C* * 10^(e+x)\n+\n+        // determine inexactness of the rounding of C*\n+        // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n+        //   the result is exact\n+        // else // if (f* - 1/2 >= T*) then\n+        //   the result is inexact\n+        if (fstar.w[3] > __bid_one_half192M[ind]\n+            || (fstar.w[3] == __bid_one_half192M[ind]\n+            && (fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n+\n+          // f* > 1/2 and the result may be exact\n+          // Calculate f* - 1/2\n+          tmp64 = fstar.w[3] - __bid_one_half192M[ind];\n+          if (tmp64 || fstar.w[2] > __bid_ten2mk192truncM[ind].w[2] || \n+              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n+              fstar.w[1] > __bid_ten2mk192truncM[ind].w[1]) || \n+              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n+              fstar.w[1] == __bid_ten2mk192truncM[ind].w[1] && \n+              fstar.w[0] > __bid_ten2mk192truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n+            // set the inexact flag\n+            *pfpsf |= INEXACT_EXCEPTION;\n+            is_inexact_lt_midpoint = 1;\n+          }        // else the result is exact\n+        } else { // the result is inexact; f2* <= 1/2\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          tmp_fpa = 1;\n+          is_inexact_gt_midpoint = 1;\n+        }\n+\n+        // check for midpoints (could do this before determining inexactness)\n+        if ((fstar.w[3] == 0)\n+            && (fstar.w[2] || fstar.w[1] || fstar.w[0])\n+            && (fstar.w[2] < __bid_ten2mk192truncM[ind].w[2]\n+                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n+                && fstar.w[1] < __bid_ten2mk192truncM[ind].w[1])\n+                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n+                && fstar.w[1] == __bid_ten2mk192truncM[ind].w[1]\n+                && fstar.w[0] <= __bid_ten2mk192truncM[ind].w[0]))) {\n+\n+          // the result is a midpoint\n+          if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n+            // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n+            Cstar.w[0]--; // Cstar.w[0] is now even\n+            if (tmp_fpa == 1)\n+              tmp_fpa = 0;\n+            is_midpoint_gt_even = 1;\n+            is_inexact_lt_midpoint = 0;\n+            is_inexact_gt_midpoint = 0;\n+          } else { // else MP in [ODD, EVEN]\n+            is_midpoint_lt_even = 1;\n+            is_inexact_lt_midpoint = 0;\n+            is_inexact_gt_midpoint = 0;\n+          }\n+        }\n+      } else { // if ind >= 15 <=> x - 1 = q - 35 = ind + 4 >= 19\n+        // add two 64-bit words\n+        C.w[0] = C.w[0] + __bid_midpoint128[ind - 15].w[0];\n+        C.w[1] = C.w[1] + __bid_midpoint128[ind - 15].w[1];\n+        if (C.w[0] < tmp64)\n+          C.w[1]++;\n+        if (C.w[1] < tmp64A)\n+          C.w[2]++;\n+        __mul_192x192_to_384 (P384, C, __bid_ten2mk192M[ind])\n+          // calculate C* and f*; C* is actually floor(C*) in this case\n+          // C* and f* need shifting and masking, as shown by\n+          // __bid_shiftright192M[] and __bid_maskhigh192M[]\n+          // C* has 128 bits; P384.w[5], P384.w[4], need to be\n+          // shifted right by Ex-256 = __bid_shiftright192M[ind]\n+          shift = __bid_shiftright192M[ind]; // 2 <= shift <= 12\n+        Cstar.w[0] = (P384.w[4] >> shift) | (P384.w[5] << (64 - shift));\n+        Cstar.w[1] = (P384.w[5] >> shift);\n+\n+        // f* has 320 bits\n+        fstar.w[4] = P384.w[4] & __bid_maskhigh192M[ind];\n+        fstar.w[3] = P384.w[3];\n+        fstar.w[2] = P384.w[2];\n+        fstar.w[1] = P384.w[1];\n+        fstar.w[0] = P384.w[0];\n+\n+        // the top Ex bits of 10^(-x) are T* = __bid_ten2mk192truncM[ind], e.g. \n+        // if x=23, T* = __bid_ten2mk192truncM[18] =\n+        //   0xc16d9a0095928a2775b7053c0f1782938d6f439b43088650\n+        // if (0 < f* < 10^(-x)) then the result is a midpoint\n+        //   if floor(C*) is even then C* = floor(C*) - logical right\n+        //       shift; C* has p decimal digits, correct by Prop. 1)\n+        //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+        //       shift; C* has p decimal digits, correct by Pr. 1)\n+        // else\n+        //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+        //       correct by Property 1)\n+        // n = C* * 10^(e+x)\n+\n+        // determine inexactness of the rounding of C*\n+        // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n+        //   the result is exact\n+        // else // if (f* - 1/2 >= T*) then\n+        //   the result is inexact\n+        if (fstar.w[4] > __bid_one_half192M[ind]\n+            || (fstar.w[4] == __bid_one_half192M[ind]\n+            && (fstar.w[3] || fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n+\n+          // f* > 1/2 and the result may be exact\n+          // Calculate f* - 1/2\n+          tmp64 = fstar.w[4] - __bid_one_half192M[ind];\n+          if (tmp64 || fstar.w[3] || fstar.w[2] > __bid_ten2mk192truncM[ind].w[2] || \n+              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n+              fstar.w[1] > __bid_ten2mk192truncM[ind].w[1]) || \n+              (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2] && \n+              fstar.w[1] == __bid_ten2mk192truncM[ind].w[1] && \n+              fstar.w[0] > __bid_ten2mk192truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n+            // set the inexact flag\n+            *pfpsf |= INEXACT_EXCEPTION;\n+            is_inexact_lt_midpoint = 1;\n+          } // else the result is exact\n+        } else { // the result is inexact; f2* <= 1/2\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          tmp_fpa = 1;\n+          is_inexact_gt_midpoint = 1;\n+        }\n+\n+        // check for midpoints (could do this before determining inexactness)\n+        if ((fstar.w[4] == 0) && (fstar.w[3] == 0)\n+            && (fstar.w[2] || fstar.w[1] || fstar.w[0])\n+            && (fstar.w[2] < __bid_ten2mk192truncM[ind].w[2]\n+                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n+                && fstar.w[1] < __bid_ten2mk192truncM[ind].w[1])\n+                || (fstar.w[2] == __bid_ten2mk192truncM[ind].w[2]\n+                && fstar.w[1] == __bid_ten2mk192truncM[ind].w[1]\n+                && fstar.w[0] <= __bid_ten2mk192truncM[ind].w[0]))) {\n+\n+          // the result is a midpoint\n+          if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n+            // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n+            Cstar.w[0]--; // Cstar.w[0] is now even\n+            if (tmp_fpa == 1)\n+              tmp_fpa = 0;\n+            is_midpoint_gt_even = 1;\n+            is_inexact_lt_midpoint = 0;\n+            is_inexact_gt_midpoint = 0;\n+          } else { // else MP in [ODD, EVEN]\n+            is_midpoint_lt_even = 1;\n+            is_inexact_lt_midpoint = 0;\n+            is_inexact_gt_midpoint = 0;\n+          }\n+        }\n+      }\n+\n+      // check for rounding overflow\n+      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n+          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 6) << 49);\n+        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n+        Cstar.w[0] = 0x38c15b0a00000000ull;\n+      } else { // 10^33 <= Cstar <= 10^34 - 1\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 5) << 49); // ind+5 = q-34\n+      }\n+      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n+        // exp >= emax for the result rounded to nearest even\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY) {\n+          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n+\n+            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n+            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_DOWN) {\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0xf800000000000000ull; // -inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_UP) {\n+          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0x7800000000000000ull; // inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        }\n+        if (is_overflow) { // return for overflow\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+\n+          // set the overflow flag\n+          *pfpsf |= OVERFLOW_EXCEPTION;\n+\n+          // is_overflow = 1;\n+        BID_RETURN (res)}\n+      } else {\n+        res.w[0] = Cstar.w[0];\n+        res.w[1] = Cstar.w[1];\n+        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+      }\n+      res.w[1] |= sign;\n+    } else { // if (58 <= q <= 68) exact coefficient takes 192-226 bits\n+      // C = C + 1/2 * 10^x where the result C fits in 226 bits\n+      // (10^68 - 1 + 1/2 * 10^34 can be represented with 226 bits)\n+      // x = q - p = q - 34, 24 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk256M[ind]\n+      // C* = (C + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 256 bits\n+      ind = q - 58; // 0 <= ind <= 10\n+      tmp64 = C.w[0];\n+      tmp64A = C.w[1];\n+\n+      // Note:\n+      // f* has 384 bits (more than 320 bits)\n+      // x - 1 = q - 35 = ind + 23\n+      // add two 64-bit words; e.g. for ind=0 <=> q=58, add 1/2*10^24\n+      C.w[0] = C.w[0] + __bid_midpoint128[ind + 4].w[0];\n+      C.w[1] = C.w[1] + __bid_midpoint128[ind + 4].w[1];\n+      if (C.w[0] < tmp64)\n+        C.w[1]++;\n+      if (C.w[1] < tmp64A)\n+        C.w[2]++;\n+      if (C.w[2] == 0)\n+        C.w[3]++;\n+      __mul_256x256_to_512 (P512, C, __bid_ten2mk256M[ind])\n+        // calculate C* and f*; C* is actually floor(C*) in this case\n+        // C* and f* need shifting and masking, as shown by \n+        // __bid_shiftright256M[] and __bid_maskhigh256M[]\n+        // C* has 128 bits; P512.w[7], P512.w[6], P512.w[5] need to be\n+        // shifted right by Ex-320 = __bid_shiftright256M[ind]\n+        shift = __bid_shiftright256M[ind]; // 15 <= shift <= 48\n+      if (shift == 32) {\n+        Cstar.w[0] =\n+          ((P512.w[5] >> 31) >> 1) | ((P512.w[6] << 31) << 1);\n+        Cstar.w[1] =\n+          ((P512.w[6] >> 31) >> 1) | ((P512.w[7] << 31) << 1);\n+      } else {\n+        Cstar.w[0] = (P512.w[5] >> shift) | (P512.w[6] << (64 - shift));\n+        Cstar.w[1] = (P512.w[6] >> shift) | (P512.w[7] << (64 - shift));\n+      }\n+      // f* has 384 bits\n+      fstar.w[5] = P512.w[5] & __bid_maskhigh256M[ind];\n+      fstar.w[4] = P512.w[4];\n+      fstar.w[3] = P512.w[3];\n+      fstar.w[2] = P512.w[2];\n+      fstar.w[1] = P512.w[1];\n+      fstar.w[0] = P512.w[0];\n+\n+      // the top Ex bits of 10^(-x) are T* = __bid_ten2mk256truncM[ind], e.g. \n+      // if x=24, T* = __bid_ten2mk256truncM[0] =\n+      //   0x9abe14cd44753b52c4926a9672793542d78c3615cf3a050cf23472530ce6e3ec =~\n+      //   10^(-24) * 2^335\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      //   if floor(C*) is even then C* = floor(C*) - logical right\n+      //       shift; C* has p decimal digits, correct by Prop. 1)\n+      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+      //       shift; C* has p decimal digits, correct by Pr. 1)\n+      // else\n+      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // n = C* * 10^(e+x)\n+\n+      // determine inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < T* ~= 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 >= T*) then\n+      //   the result is inexact\n+      if (fstar.w[5] > __bid_one_half256M[ind]\n+          || (fstar.w[5] == __bid_one_half256M[ind]\n+          && (fstar.w[4] || fstar.w[3] || fstar.w[2] || fstar.w[1]\n+              || fstar.w[0]))) {\n+\n+        // f* > 1/2 and the result may be exact\n+        // Calculate f* - 1/2\n+        tmp64 = fstar.w[5] - __bid_one_half256M[ind]; // tmp64 >= 0\n+        if (tmp64 || fstar.w[4] || fstar.w[3] > __bid_ten2mk256truncM[ind].w[3] || \n+            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n+            fstar.w[2] > __bid_ten2mk256truncM[ind].w[2]) || \n+            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n+            fstar.w[2] == __bid_ten2mk256truncM[ind].w[2] && \n+            fstar.w[1] > __bid_ten2mk256truncM[ind].w[1]) || \n+            (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3] && \n+            fstar.w[2] == __bid_ten2mk256truncM[ind].w[2] && \n+            fstar.w[1] == __bid_ten2mk256truncM[ind].w[1] && \n+            fstar.w[0] > __bid_ten2mk256truncM[ind].w[0])) { // f* - 1/2 > 10^(-x)\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          is_inexact_lt_midpoint = 1;\n+        } // else the result is exact\n+      } else { // the result is inexact; f2* <= 1/2\n+        // set the inexact flag\n+        *pfpsf |= INEXACT_EXCEPTION;\n+        tmp_fpa = 1;\n+        is_inexact_gt_midpoint = 1;\n+      }\n+\n+      // check for midpoints (could do this before determining inexactness)\n+      if ((fstar.w[5] == 0) && (fstar.w[4] == 0)\n+          && (fstar.w[3] || fstar.w[2] || fstar.w[1] || fstar.w[0])\n+          && (fstar.w[3] < __bid_ten2mk256truncM[ind].w[3]\n+              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n+              && fstar.w[2] < __bid_ten2mk256truncM[ind].w[2])\n+              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n+              && fstar.w[2] == __bid_ten2mk256truncM[ind].w[2]\n+              && fstar.w[1] < __bid_ten2mk256truncM[ind].w[1])\n+              || (fstar.w[3] == __bid_ten2mk256truncM[ind].w[3]\n+              && fstar.w[2] == __bid_ten2mk256truncM[ind].w[2]\n+              && fstar.w[1] == __bid_ten2mk256truncM[ind].w[1]\n+              && fstar.w[0] <= __bid_ten2mk256truncM[ind].w[1]))) {\n+\n+        // the result is a midpoint\n+        if (Cstar.w[0] & 0x01) { // Cstar.w[0] is odd; MP in [EVEN, ODD]\n+          // if floor(C*) is odd C = floor(C*) - 1; the result may be 0\n+          Cstar.w[0]--; // Cstar.w[0] is now even\n+          if (tmp_fpa == 1)\n+            tmp_fpa = 0;\n+          is_midpoint_gt_even = 1;\n+          is_inexact_lt_midpoint = 0;\n+          is_inexact_gt_midpoint = 0;\n+        } else { // else MP in [ODD, EVEN]\n+          is_midpoint_lt_even = 1;\n+          is_inexact_lt_midpoint = 0;\n+          is_inexact_gt_midpoint = 0;\n+        }\n+      }\n+      // check for rounding overflow\n+      if (Cstar.w[1] == 0x0001ed09bead87c0ull && \n+          Cstar.w[0] == 0x378d8e6400000000ull) { // if  Cstar = 10^34\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 25) << 49);\n+        Cstar.w[1] = 0x0000314dc6448d93ull; // Cstar = 10^33\n+        Cstar.w[0] = 0x38c15b0a00000000ull;\n+      } else { // 10^33 <= Cstar <= 10^34 - 1\n+        tmp64 = x_exp + y_exp + ((UINT64) (ind + 24) << 49); // ind+24 = q-34\n+      }\n+      if (tmp64 >= EXP_MAX + BIN_EXP_BIAS) { // possibble overflow\n+        // exp >= emax for the result rounded to nearest even\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY) {\n+          if (tmp64 > EXP_MAX + BIN_EXP_BIAS) {\n+\n+            // |res| >= 10^(p-1) * 10^(emax+1) <=> exp >= emax+1\n+            res.w[1] = sign | 0x7800000000000000ull; // +/-inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_DOWN) {\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0xf800000000000000ull; // -inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else if (rnd_mode == ROUNDING_UP) {\n+          if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (!sign && ((tmp64 > EXP_MAX + BIN_EXP_BIAS) || \n+              ((tmp64 == EXP_MAX + BIN_EXP_BIAS) && \n+              Cstar.w[1] == 0x0001ed09bead87c0ull && \n+              Cstar.w[0] == 0x378d8e63ffffffffull && // (10^34-1) * 10^emax\n+              is_inexact_lt_midpoint))) {\n+            res.w[1] = 0x7800000000000000ull; // inf\n+            res.w[0] = 0x0ull;\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        } else { // if (rnd_mode == ROUNDING_TO_ZERO)\n+          if (!sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = +MAXFP\n+            res.w[1] = 0x5fffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // (10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else if (sign && (tmp64 > EXP_MAX + BIN_EXP_BIAS) && \n+              !(tmp64 == EXP_MAX + BIN_EXP_BIAS + EXP_P1 && \n+              Cstar.w[1] == 0x0000314dc6448d93ull && \n+              Cstar.w[0] == 0x38c15b0a00000000ull && // 10^33 * 10^(emax+1)\n+              (is_midpoint_lt_even || is_inexact_gt_midpoint))) {\n+            // res = -MAXFP\n+            res.w[1] = 0xdfffed09bead87c0ull;\n+            res.w[0] = 0x378d8e63ffffffffull; // -(10^34-1) * 10^emax\n+            *pfpsf |= INEXACT_EXCEPTION; // set the inexact flag\n+            *pfpsf |= OVERFLOW_EXCEPTION; // set the overflow flag\n+            is_overflow = 1;\n+          } else { // not overflow\n+            res.w[0] = Cstar.w[0];\n+            res.w[1] = Cstar.w[1];\n+            res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+          }\n+        }\n+        if (is_overflow) { // return for overflow\n+          // set the inexact flag\n+          *pfpsf |= INEXACT_EXCEPTION;\n+\n+          // set the overflow flag\n+          *pfpsf |= OVERFLOW_EXCEPTION;\n+\n+          // is_overflow = 1;\n+          BID_RETURN (res);\n+        }\n+      } else {\n+        res.w[0] = Cstar.w[0];\n+        res.w[1] = Cstar.w[1];\n+        res.w[1] |= (tmp64 - BIN_EXP_BIAS);\n+      }\n+      res.w[1] |= sign;\n+    }\n+\n+    // general correction from RN to RA, RM, RP, RZ\n+    if (rnd_mode != ROUNDING_TO_NEAREST && !is_overflow) { // overflow is solved\n+      x_exp = res.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+      C1_hi = res.w[1] & MASK_COEFF;\n+      C1_lo = res.w[0];\n+      if ((!sign && ((rnd_mode == ROUNDING_UP && is_inexact_lt_midpoint) || \n+          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_UP) && \n+          is_midpoint_gt_even))) || \n+          (sign && ((rnd_mode == ROUNDING_DOWN && is_inexact_lt_midpoint) || \n+          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_DOWN) && \n+          is_midpoint_gt_even)))) {\n+\n+        // C1 = C1 + 1\n+        C1_lo = C1_lo + 1;\n+        if (C1_lo == 0) { // rounding overflow in the low 64 bits\n+          C1_hi = C1_hi + 1;\n+          if (C1_hi == 0x0001ed09bead87c0ull\n+              && C1_lo == 0x378d8e6400000000ull) {\n+\n+            // C1 = 10^34 => rounding overflow\n+            C1_hi = 0x0000314dc6448d93ull;\n+            C1_lo = 0x38c15b0a00000000ull; // 10^33\n+            x_exp = x_exp + EXP_P1;\n+          }\n+        }\n+      } else if ((is_midpoint_lt_even || is_inexact_gt_midpoint)\n+          && ((sign && (rnd_mode == ROUNDING_UP || \n+          rnd_mode == ROUNDING_TO_ZERO)) || \n+          (!sign && (rnd_mode == ROUNDING_DOWN || \n+          rnd_mode == ROUNDING_TO_ZERO)))) {\n+\n+        // C1 = C1 - 1\n+        C1_lo = C1_lo - 1;\n+        if (C1_lo == 0xffffffffffffffffull)\n+          C1_hi--;\n+\n+        // check if we crossed into the lower decade\n+        if (C1_hi == 0x0000314dc6448d93ull && C1_lo == 0x38c15b09ffffffffull) {\n+          // 10^33 - 1\n+          C1_hi = 0x0001ed09bead87c0ull; // 10^34 - 1\n+          C1_lo = 0x378d8e63ffffffffull;\n+          x_exp = x_exp - EXP_P1; // no underflow (TO CHECK)\n+        }\n+      } else {\n+        ; // exact, the result is already correct\n+      }\n+\n+      // assemble the result\n+      res.w[1] = x_exp | C1_hi;\n+      res.w[0] = C1_lo;\n+    }\n+    res.w[1] |= sign;\n+    BID_RETURN (res);\n+  }\n+_underflow_path:\n+  // got here because q - P34 < ind where ind = EMIN - ex - ey\n+  // q is the number of digits in C; ind is the [positive] exponent of the\n+  // negative power of 10 that must multiply C in order to make the result's\n+  // exponent equal to e_min - P34 + 1 = -6176\n+  ind =\n+    (int) (((SINT64) EXP_MIN + (SINT64) BIN_EXP_BIAS - (SINT64) x_exp -\n+            (SINT64) y_exp) >> 49);\n+\n+  // q - P34 < ind => -P34 + 1 < ind => -P34 + 2 <= ind\n+  // ind = EMIN - ex - ey < -6176 + 6176 + 6176 = 6176\n+  if (q < ind) { // q - ind < 0; result rounds to 0 when rounding to nearest\n+    // set the inexact and underflow flags\n+    *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n+    res.w[1] = EXP_MIN; // EXP_MIN = 0x0\n+    res.w[0] = 0x0;\n+    if (rnd_mode != ROUNDING_TO_NEAREST) {\n+      if ((rnd_mode == ROUNDING_DOWN && sign) || \n+          (rnd_mode == ROUNDING_UP && !sign))\n+        res.w[0] = 0x0000000000000001ull;\n+    }\n+  } else if (q == ind) { // q - ind = 0; result rounds to 0 or +/-1*10^EMIN\n+    // set the inexact and underflow flags\n+    *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n+\n+    // if C <= 5*10^(q-1) then C = 0 else C = 1\n+    if (q <= 19) {\n+      if (C.w[0] == __bid_midpoint64[q - 1]) { // C = 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n+            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else if (C.w[0] < __bid_midpoint64[q - 1]) { // C < 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && !sign)\n+            || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else { // C > 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && sign)\n+            || (rnd_mode == ROUNDING_UP && !sign)) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        }\n+      }\n+    } else if (q <= 38) { // 20 <= q <= 38\n+      // if q <= P34 = 34 the exact result rounded to P34 digits with unbounded \n+      // exponent will have an exponent smaller than e_min; otherwise if\n+      // 35 <= q <= 38, it depends\n+      if (C.w[1] == __bid_midpoint128[q - 20].w[1] && \n+          C.w[0] == __bid_midpoint128[q - 20].w[0]) { // C = 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n+            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else if (C.w[1] < __bid_midpoint128[q - 20].w[1] || \n+          (C.w[1] == __bid_midpoint128[q - 20].w[1] && \n+          C.w[0] < __bid_midpoint128[q - 20].w[0])) { // C < 0.5 * 10^emin \n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && !sign)\n+            || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else { // C > 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && sign)\n+            || (rnd_mode == ROUNDING_UP && !sign)) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        }\n+      }\n+    } else if (q <= 58) { // 39 <= q <= 58\n+      // Note: for q = 58 C may take 256 bits, so need to test C.w[3]\n+      if (C.w[3] == 0x0 && C.w[2] == __bid_midpoint192[q - 39].w[2] && \n+          C.w[1] == __bid_midpoint192[q - 39].w[1] && \n+          C.w[0] == __bid_midpoint192[q - 39].w[0]) { // C = 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n+            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else if ((C.w[3] == 0x0 && C.w[2] < __bid_midpoint192[q - 39].w[2]) || \n+          (C.w[3] == 0x0 && C.w[2] == __bid_midpoint192[q - 39].w[2] && \n+          C.w[1] < __bid_midpoint192[q - 39].w[1]) || (C.w[3] == 0x0 && \n+          C.w[2] == __bid_midpoint192[q - 39].w[2] && \n+          C.w[1] == __bid_midpoint192[q - 39].w[1] && \n+          C.w[0] < __bid_midpoint192[q - 39].w[0])) { // C < 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && !sign)\n+            || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else { // C > 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && sign)\n+            || (rnd_mode == ROUNDING_UP && !sign)) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        }\n+      }\n+    } else { // if (q <= 68), i.e. 59 <= q <= 68\n+      if (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n+          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n+          C.w[1] == __bid_midpoint256[q - 59].w[1] && \n+          C.w[0] == __bid_midpoint256[q - 59].w[0]) { // C = 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST || (rnd_mode == ROUNDING_DOWN\n+            && !sign) || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else if (C.w[3] < __bid_midpoint256[q - 59].w[3] || \n+          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n+          C.w[2] < __bid_midpoint256[q - 59].w[2]) || \n+          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n+          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n+          C.w[1] < __bid_midpoint256[q - 59].w[1]) || \n+          (C.w[3] == __bid_midpoint256[q - 59].w[3] && \n+          C.w[2] == __bid_midpoint256[q - 59].w[2] && \n+          C.w[1] == __bid_midpoint256[q - 59].w[1] && \n+          C.w[0] < __bid_midpoint256[q - 59].w[0])) { // C < 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && !sign)\n+            || (rnd_mode == ROUNDING_UP && sign)\n+            || rnd_mode == ROUNDING_TO_ZERO) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        }\n+      } else { // C > 0.5 * 10^emin\n+        if (rnd_mode == ROUNDING_TO_NEAREST\n+            || rnd_mode == ROUNDING_TIES_AWAY\n+            || (rnd_mode == ROUNDING_DOWN && sign)\n+            || (rnd_mode == ROUNDING_UP && !sign)) {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 1;\n+        } else {\n+          res.w[1] = EXP_MIN;\n+          res.w[0] = 0;\n+        }\n+      }\n+    }\n+  } else { // if 0 < q - ind < P34 <=> 1 <= q - ind <= P34 - 1 = 33\n+    // In general -P34 + 2 <= ind <= 6176 => -P34 + 2 <= ind < q =>\n+    // -P34 + 2 <= ind <= q - 1\n+    if (rnd_mode != ROUNDING_TO_NEAREST) {\n+      is_inexact_lt_midpoint = 0;\n+      is_inexact_gt_midpoint = 0;\n+      is_midpoint_lt_even = 0;\n+      is_midpoint_gt_even = 0;\n+    }\n+    if (ind <= 0) { // 0 <= -ind\n+      // the result is exact\n+      res.w[1] = (x_exp + y_exp - BIN_EXP_BIAS) | C.w[1];\n+      res.w[0] = C.w[0];\n+\n+      // because the result is exact the U and I status flags are not set\n+    } else {\n+\n+      // if ind > 0 <=> 1 <= ind <= q - 1; must remove ind digits\n+      // from C, which may have up to 68 digits; note that q >= ind + 1 >= 2\n+      // Note: there is no underflow in some cases when the coefficient of\n+      // the result is 10^33 or 10^33 - 1\n+      if (q <= 18) { // 2 <= q <= 18\n+        __bid_round64_2_18 (q, ind, C.w[0], &res.w[0], &incr_exp,\n+                      &is_midpoint_lt_even, &is_midpoint_gt_even,\n+                      &is_inexact_lt_midpoint, &is_inexact_gt_midpoint);\n+        if (incr_exp) {\n+\n+          // multiply by 10; this cannot be 10^33\n+          __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n+          res.w[1] |= (UINT64) EXP_MIN;\n+        } else { // underflow\n+          res.w[1] = (UINT64) EXP_MIN;\n+        }\n+        if (is_midpoint_lt_even || is_midpoint_gt_even\n+            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n+\n+          // set the inexact and underflow flags\n+          *pfpsf |= (INEXACT_EXCEPTION | UNDERFLOW_EXCEPTION);\n+        }\n+      } else if (q <= 38) { // 19 <= q <= 38\n+        P128.w[1] = C.w[1];\n+        P128.w[0] = C.w[0];\n+        __bid_round128_19_38 (q, ind, P128, &res, &incr_exp,\n+                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n+                        &is_inexact_lt_midpoint,\n+                        &is_inexact_gt_midpoint);\n+        if (incr_exp) {\n+\n+          // multiply by 10 and check is this is 10^33, because in that case\n+          // it is possible that this is not underflow\n+          if (q - ind <= 19) {\n+            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n+          } else { // if 20 <= q - ind\n+            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n+          }\n+          if ((q - ind + 1) == P34) { // the result is 10^(P34-1)\n+            // if the result rounded directly to P34 digits is the same, then\n+            // there is no underflow\n+            __bid_round128_19_38 (q, ind - 1, P128, &R128, &incr_exp1,\n+                            &is_midpoint_lt_even1,\n+                            &is_midpoint_gt_even1,\n+                            &is_inexact_lt_midpoint1,\n+                            &is_inexact_gt_midpoint1);\n+            if (res.w[1] == R128.w[1] && res.w[0] == R128.w[0]) {\n+              no_underflow = 1;\n+            }\n+          }\n+          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n+        } else { // underflow\n+          // res.w[1] = (UINT64)EXP_MIN | res.w[1]; // redundant\n+        }\n+        if (is_midpoint_lt_even || is_midpoint_gt_even\n+            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n+\n+          // set the inexact and underflow flags\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          is_inexact = 1;\n+          if (!no_underflow)\n+            *pfpsf |= UNDERFLOW_EXCEPTION;\n+        }\n+      } else if (q <= 57) { // 39 <= q <= 57\n+        P192.w[2] = C.w[2];\n+        P192.w[1] = C.w[1];\n+        P192.w[0] = C.w[0];\n+        __bid_round192_39_57 (q, ind, P192, &R192, &incr_exp,\n+                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n+                        &is_inexact_lt_midpoint,\n+                        &is_inexact_gt_midpoint);\n+        if (incr_exp) {\n+\n+          // multiply by 10 and check is this is 10^33, because in that case\n+          // it is possible that this is not underflow\n+          res.w[1] = R192.w[1]; // res has q - ind digits\n+          res.w[0] = R192.w[0];\n+          if (q - ind <= 19) {\n+            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n+          } else { // if 20 <= q - ind\n+            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n+          }\n+          if ((q - ind + 1) == P34) { // the result is 10^(P34-1) \n+            // if the result rounded directly to P34 digits is the same, then\n+            // there is no underflow\n+            __bid_round192_39_57 (q, ind - 1, P192, &R192, &incr_exp1,\n+                            &is_midpoint_lt_even1,\n+                            &is_midpoint_gt_even1,\n+                            &is_inexact_lt_midpoint1,\n+                            &is_inexact_gt_midpoint1);\n+            if (res.w[1] == R192.w[1] && res.w[0] == R192.w[0]) {\n+              no_underflow = 1;\n+            }\n+          }\n+          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n+        } else { // underflow\n+          res.w[1] = (UINT64) EXP_MIN | R192.w[1];\n+          res.w[0] = R192.w[0];\n+        }\n+        if (is_midpoint_lt_even || is_midpoint_gt_even\n+            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n+\n+          // set the inexact and underflow flags\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          is_inexact = 1;\n+          if (!no_underflow)\n+            *pfpsf |= UNDERFLOW_EXCEPTION;\n+        }\n+      } else if (q <= 76) { // 58 <= q <= 76 (actually 58 <= q <= 68)\n+        P256.w[3] = C.w[3];\n+        P256.w[2] = C.w[2];\n+        P256.w[1] = C.w[1];\n+        P256.w[0] = C.w[0];\n+        __bid_round256_58_76 (q, ind, P256, &R256, &incr_exp,\n+                        &is_midpoint_lt_even, &is_midpoint_gt_even,\n+                        &is_inexact_lt_midpoint,\n+                        &is_inexact_gt_midpoint);\n+        if (incr_exp) {\n+\n+          // multiply by 10 and check is this is 10^33, because in that case\n+          // it is possible that this is not underflow\n+          res.w[1] = R256.w[1]; // res has q - ind digits\n+          res.w[0] = R256.w[0];\n+          if (q - ind <= 19) {\n+            __mul_64x64_to_128MACH (res, res.w[0], __bid_ten2k64[1]);\n+          } else { // if 20 <= q - ind\n+            __mul_128x64_to_128 (res, __bid_ten2k64[1], res);\n+          }\n+          if ((q - ind + 1) == P34) { // the result is 10^(P34-1) \n+            // if the result rounded directly to P34 digits is the same, then\n+            // there is no underflow\n+            __bid_round256_58_76 (q, ind - 1, P256, &R256, &incr_exp1,\n+                            &is_midpoint_lt_even1,\n+                            &is_midpoint_gt_even1,\n+                            &is_inexact_lt_midpoint1,\n+                            &is_inexact_gt_midpoint1);\n+            if (res.w[1] == R256.w[1] && res.w[0] == R256.w[0]) {\n+              no_underflow = 1;\n+            }\n+          }\n+          // res.w[1] |= (UINT64)EXP_MIN; // redundant\n+        } else { // underflow\n+          res.w[1] = (UINT64) EXP_MIN | R256.w[1];\n+          res.w[0] = R256.w[0];\n+        }\n+        if (is_midpoint_lt_even || is_midpoint_gt_even\n+            || is_inexact_lt_midpoint || is_inexact_gt_midpoint) {\n+\n+          // set the inexact and underflow flags\n+          *pfpsf |= INEXACT_EXCEPTION;\n+          is_inexact = 1;\n+          if (!no_underflow)\n+            *pfpsf |= UNDERFLOW_EXCEPTION;\n+        }\n+      }\n+    }\n+\n+    // general correction from RN to RA, RM, RP, RZ\n+    if (rnd_mode != ROUNDING_TO_NEAREST) {\n+      x_exp = res.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+      // this must be e_min\n+      C1_hi = res.w[1] & MASK_COEFF;\n+      C1_lo = res.w[0];\n+      if ((!sign && ((rnd_mode == ROUNDING_UP && is_inexact_lt_midpoint) || \n+          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_UP) && \n+          is_midpoint_gt_even))) || \n+          (sign && ((rnd_mode == ROUNDING_DOWN && is_inexact_lt_midpoint) || \n+          ((rnd_mode == ROUNDING_TIES_AWAY || rnd_mode == ROUNDING_DOWN) && \n+          is_midpoint_gt_even)))) {\n+\n+        // C1 = C1 + 1\n+        C1_lo = C1_lo + 1;\n+        if (C1_lo == 0) { // rounding overflow in the low 64 bits\n+          C1_hi = C1_hi + 1;\n+          if (C1_hi == 0x0001ed09bead87c0ull\n+              && C1_lo == 0x378d8e6400000000ull) {\n+\n+            // C1 = 10^34 => rounding overflow (not possible) TO CHECK\n+            C1_hi = 0x0000314dc6448d93ull;\n+            C1_lo = 0x38c15b0a00000000ull; // 10^33\n+            x_exp = x_exp + EXP_P1; // this must be e_min\n+          }\n+        }\n+      } else if ((is_midpoint_lt_even || is_inexact_gt_midpoint) && \n+          ((sign && \n+          (rnd_mode == ROUNDING_UP || rnd_mode == ROUNDING_TO_ZERO)) || \n+          (!sign && \n+          (rnd_mode == ROUNDING_DOWN || rnd_mode == ROUNDING_TO_ZERO)))) {\n+\n+        // C1 = C1 - 1 (the exponent is emin already)\n+        C1_lo = C1_lo - 1;\n+        if (C1_lo == 0xffffffffffffffffull)\n+          C1_hi--;\n+\n+        // cannot cross into the lower decade anymore, but the result can be 0\n+      } else {\n+        ; // exact, the result is already correct\n+      }\n+\n+      // no overflow is possible\n+      // assemble the result\n+      res.w[1] = x_exp | C1_hi;\n+      res.w[0] = C1_lo;\n+\n+      // Now fix the case where the general rounding routine returned a non-tiny\n+      // result, but after the correction for rounding modes other than to\n+      // nearest, the result is less in magnitude than 100...0[34] * 10^(-6176)\n+      // (this is due to the fact that the general rounding routine works only\n+      // with rounding to nearest)\n+      if (is_inexact && (x_exp == EXP_MIN)\n+          && (C1_hi < 0x0000314dc6448d93ull\n+              || (C1_hi == 0x0000314dc6448d93ull\n+              && C1_lo < 0x38c15b0a00000000ull))) {\n+        *pfpsf |= UNDERFLOW_EXCEPTION;\n+      }\n+    }\n+  }\n+  res.w[1] |= sign;\n+  BID_RETURN (res);\n+}"}, {"sha": "a2b54a7628f68529e0eebf35d547c4125a100b39", "filename": "libgcc/config/libbid/bid128_next.c", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_next.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,572 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID128 nextup\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_nextup (UINT128 * pres,\n+               UINT128 *\n+               px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+UINT128\n+__bid128_nextup (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+               _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q1, ind;\n+  UINT128 C1;   // C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+\n+  BID_SWAP128(x);\n+  // unpack the argument\n+  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+        // return quiet (x)\n+        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = x.w[0];\n+      } else { // x is QNaN\n+        // return x\n+        res.w[1] = x.w[1];\n+        res.w[0] = x.w[0];\n+      }\n+    } else { // x is not NaN, so it must be infinity\n+      if (!x_sign) { // x is +inf\n+        res.w[1] = 0x7800000000000000ull; // +inf\n+        res.w[0] = 0x0000000000000000ull;\n+      } else { // x is -inf\n+        res.w[1] = 0xdfffed09bead87c0ull; // -MAXFP = -999...99 * 10^emax\n+        res.w[0] = 0x378d8e63ffffffffull;\n+      }\n+    }\n+    BID_RETURN (res);\n+  }\n+  // test for non-canonical values of the argument x\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull) || \n+      ((C1.w[1] == 0x0001ed09bead87c0ull) && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = 0;\n+    x.w[0] = 0;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is +/-0\n+    res.w[1] = 0x0000000000000000ull; // +1 * 10^emin\n+    res.w[0] = 0x0000000000000001ull;\n+  } else { // x is not special and is not zero\n+    if (x.w[1] == 0x5fffed09bead87c0ull\n+        && x.w[0] == 0x378d8e63ffffffffull) {\n+      // x = +MAXFP = 999...99 * 10^emax\n+      res.w[1] = 0x7800000000000000ull; // +inf\n+      res.w[0] = 0x0000000000000000ull;\n+    } else if (x.w[1] == 0x8000000000000000ull\n+               && x.w[0] == 0x0000000000000001ull) {\n+      // x = -MINFP = 1...99 * 10^emin\n+      res.w[1] = 0x8000000000000000ull; // -0\n+      res.w[0] = 0x0000000000000000ull;\n+    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+      // can add/subtract 1 ulp to the significand\n+\n+      // Note: we could check here if x >= 10^34 to speed up the case q1 = 34\n+      // q1 = nr. of decimal digits in x\n+      // determine first the nr. of bits in x\n+      if (C1.w[1] == 0) {\n+        if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n+          // split the 64-bit value in two 32-bit halves to avoid rnd errors\n+          if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n+            tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n+            x_nr_bits =\n+              33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+                    0x3ff);\n+          } else { // x < 2^32\n+            tmp1.d = (double) (C1.w[0]); // exact conversion\n+            x_nr_bits =\n+              1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+          }\n+        } else { // if x < 2^53\n+          tmp1.d = (double) C1.w[0]; // exact conversion\n+          x_nr_bits =\n+            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+        }\n+      } else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+        tmp1.d = (double) C1.w[1]; // exact conversion\n+        x_nr_bits =\n+          65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      if (q1 == 0) {\n+        q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n+        if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+            || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+            && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+          q1++;\n+      }\n+      // if q1 < P34 then pad the significand with zeros\n+      if (q1 < P34) {\n+        exp = (x_exp >> 49) - 6176;\n+        if (exp + 6176 > P34 - q1) {\n+          ind = P34 - q1; // 1 <= ind <= P34 - 1\n+          // pad with P34 - q1 zeros, until exponent = emin\n+          // C1 = C1 * 10^ind\n+          if (q1 <= 19) { // 64-bit C1\n+            if (ind <= 19) { // 64-bit 10^ind and 64-bit C1\n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 128-bit 10^ind and 64-bit C1\n+              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+            }\n+          } else { // C1 is (most likely) 128-bit\n+            if (ind <= 14) { // 64-bit 10^ind and 128-bit C1 (most likely)\n+              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n+            } else if (ind <= 19) { // 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n+              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+            }\n+          }\n+          x_exp = x_exp - ((UINT64) ind << 49);\n+        } else { // pad with zeros until the exponent reaches emin\n+          ind = exp + 6176;\n+          // C1 = C1 * 10^ind\n+          if (ind <= 19) { // 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n+            if (q1 <= 19) { // 64-bit C1, 64-bit 10^ind \n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n+              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n+            }\n+          } else { // if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n+            // 64-bit C1, 128-bit 10^ind\n+            __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+          }\n+          x_exp = EXP_MIN;\n+        }\n+      }\n+      if (!x_sign) { // x > 0\n+        // add 1 ulp (add 1 to the significand)\n+        C1.w[0]++;\n+        if (C1.w[0] == 0)\n+          C1.w[1]++;\n+        if (C1.w[1] == 0x0001ed09bead87c0ull && \n+            C1.w[0] == 0x378d8e6400000000ull) { // if  C1 = 10^34\n+          C1.w[1] = 0x0000314dc6448d93ull; // C1 = 10^33\n+          C1.w[0] = 0x38c15b0a00000000ull;\n+          x_exp = x_exp + EXP_P1;\n+        }\n+      } else { // x < 0\n+        // subtract 1 ulp (subtract 1 from the significand)\n+        C1.w[0]--;\n+        if (C1.w[0] == 0xffffffffffffffffull)\n+          C1.w[1]--;\n+        if (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && \n+            C1.w[0] == 0x38c15b09ffffffffull) { // if  C1 = 10^33 - 1\n+          C1.w[1] = 0x0001ed09bead87c0ull; // C1 = 10^34 - 1\n+          C1.w[0] = 0x378d8e63ffffffffull;\n+          x_exp = x_exp - EXP_P1;\n+        }\n+      }\n+      // assemble the result\n+      res.w[1] = x_sign | x_exp | C1.w[1];\n+      res.w[0] = C1.w[0];\n+    }        // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  }        // end x is not special and is not zero\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128 nextdown\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_nextdown (UINT128 * pres,\n+                 UINT128 *\n+                 px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+UINT128\n+__bid128_nextdown (UINT128 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+                 _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q1, ind;\n+  UINT128 C1;   // C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+\n+  BID_SWAP128(x);\n+  // unpack the argument\n+  x_sign = x.w[1] & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+        // return quiet (x)\n+        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = x.w[0];\n+      } else { // x is QNaN\n+        // return x\n+        res.w[1] = x.w[1];\n+        res.w[0] = x.w[0];\n+      }\n+    } else { // x is not NaN, so it must be infinity\n+      if (!x_sign) { // x is +inf\n+        res.w[1] = 0x5fffed09bead87c0ull; // +MAXFP = +999...99 * 10^emax\n+        res.w[0] = 0x378d8e63ffffffffull;\n+      } else { // x is -inf\n+        res.w[1] = 0xf800000000000000ull; // -inf\n+        res.w[0] = 0x0000000000000000ull;\n+      }\n+    }\n+    BID_RETURN (res);\n+  }\n+  // test for non-canonical values of the argument x\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull) || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+      && (C1.w[0] > 0x378d8e63ffffffffull))) && \n+      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = 0;\n+    x.w[0] = 0;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is +/-0\n+    res.w[1] = 0x8000000000000000ull; // -1 * 10^emin\n+    res.w[0] = 0x0000000000000001ull;\n+  } else { // x is not special and is not zero\n+    if (x.w[1] == 0xdfffed09bead87c0ull\n+        && x.w[0] == 0x378d8e63ffffffffull) {\n+      // x = -MAXFP = -999...99 * 10^emax\n+      res.w[1] = 0xf800000000000000ull; // -inf\n+      res.w[0] = 0x0000000000000000ull;\n+    } else if (x.w[1] == 0x0ull && x.w[0] == 0x0000000000000001ull) { // +MINFP\n+      res.w[1] = 0x0000000000000000ull; // +0\n+      res.w[0] = 0x0000000000000000ull;\n+    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+      // can add/subtract 1 ulp to the significand\n+\n+      // Note: we could check here if x >= 10^34 to speed up the case q1 = 34\n+      // q1 = nr. of decimal digits in x\n+      // determine first the nr. of bits in x\n+      if (C1.w[1] == 0) {\n+        if (C1.w[0] >= 0x0020000000000000ull) { // x >= 2^53\n+          // split the 64-bit value in two 32-bit halves to avoid rnd errors\n+          if (C1.w[0] >= 0x0000000100000000ull) { // x >= 2^32\n+            tmp1.d = (double) (C1.w[0] >> 32); // exact conversion\n+            x_nr_bits =\n+              33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) -\n+                    0x3ff);\n+          } else { // x < 2^32\n+            tmp1.d = (double) (C1.w[0]); // exact conversion\n+            x_nr_bits =\n+              1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+          }\n+        } else { // if x < 2^53\n+          tmp1.d = (double) C1.w[0]; // exact conversion\n+          x_nr_bits =\n+            1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+        }\n+      } else { // C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+        tmp1.d = (double) C1.w[1]; // exact conversion\n+        x_nr_bits =\n+          65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      if (q1 == 0) {\n+        q1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n+        if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+            || (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+            && C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+          q1++;\n+      }\n+      // if q1 < P then pad the significand with zeros\n+      if (q1 < P34) {\n+        exp = (x_exp >> 49) - 6176;\n+        if (exp + 6176 > P34 - q1) {\n+          ind = P34 - q1; // 1 <= ind <= P34 - 1\n+          // pad with P34 - q1 zeros, until exponent = emin\n+          // C1 = C1 * 10^ind\n+          if (q1 <= 19) { // 64-bit C1\n+            if (ind <= 19) { // 64-bit 10^ind and 64-bit C1\n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 128-bit 10^ind and 64-bit C1\n+              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+            }\n+          } else { // C1 is (most likely) 128-bit\n+            if (ind <= 14) { // 64-bit 10^ind and 128-bit C1 (most likely)\n+              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n+            } else if (ind <= 19) { // 64-bit 10^ind and 64-bit C1 (q1 <= 19)\n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 128-bit 10^ind and 64-bit C1 (C1 must be 64-bit)\n+              __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+            }\n+          }\n+          x_exp = x_exp - ((UINT64) ind << 49);\n+        } else { // pad with zeros until the exponent reaches emin\n+          ind = exp + 6176;\n+          // C1 = C1 * 10^ind\n+          if (ind <= 19) { // 1 <= P34 - q1 <= 19 <=> 15 <= q1 <= 33\n+            if (q1 <= 19) { // 64-bit C1, 64-bit 10^ind \n+              __mul_64x64_to_128MACH (C1, C1.w[0], __bid_ten2k64[ind]);\n+            } else { // 20 <= q1 <= 33 => 128-bit C1, 64-bit 10^ind\n+              __mul_128x64_to_128 (C1, __bid_ten2k64[ind], C1);\n+            }\n+          } else { // if 20 <= P34 - q1 <= 33 <=> 1 <= q1 <= 14 =>\n+            // 64-bit C1, 128-bit 10^ind\n+            __mul_128x64_to_128 (C1, C1.w[0], __bid_ten2k128[ind - 20]);\n+          }\n+          x_exp = EXP_MIN;\n+        }\n+      }\n+      if (x_sign) { // x < 0\n+        // add 1 ulp (add 1 to the significand)\n+        C1.w[0]++;\n+        if (C1.w[0] == 0)\n+          C1.w[1]++;\n+        if (C1.w[1] == 0x0001ed09bead87c0ull && \n+            C1.w[0] == 0x378d8e6400000000ull) { // if  C1 = 10^34\n+          C1.w[1] = 0x0000314dc6448d93ull; // C1 = 10^33\n+          C1.w[0] = 0x38c15b0a00000000ull;\n+          x_exp = x_exp + EXP_P1;\n+        }\n+      } else { // x > 0\n+        // subtract 1 ulp (subtract 1 from the significand)\n+        C1.w[0]--;\n+        if (C1.w[0] == 0xffffffffffffffffull)\n+          C1.w[1]--;\n+        if (x_exp != 0 && C1.w[1] == 0x0000314dc6448d93ull && \n+            C1.w[0] == 0x38c15b09ffffffffull) { // if  C1 = 10^33 - 1\n+          C1.w[1] = 0x0001ed09bead87c0ull; // C1 = 10^34 - 1\n+          C1.w[0] = 0x378d8e63ffffffffull;\n+          x_exp = x_exp - EXP_P1;\n+        }\n+      }\n+      // assemble the result\n+      res.w[1] = x_sign | x_exp | C1.w[1];\n+      res.w[0] = C1.w[0];\n+    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  } // end x is not special and is not zero\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128 nextafter\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_nextafter (UINT128 * pres, UINT128 * px,\n+                  UINT128 *\n+                  py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) \n+{\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+  UINT128 xnswp = *px;\n+  UINT128 ynswp = *py;\n+#else\n+UINT128\n+__bid128_nextafter (UINT128 x,\n+                  UINT128 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+                  _EXC_INFO_PARAM) {\n+  UINT128 xnswp = x;\n+  UINT128 ynswp = y;\n+#endif\n+\n+  UINT128 res;\n+  UINT128 tmp1, tmp2;\n+  FPSC tmp_fpsf = 0; // dummy fpsf for calls to comparison functions\n+  int res1, res2;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // check for NaNs\n+  if (((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL)\n+      || ((y.w[1] & MASK_SPECIAL) == MASK_SPECIAL)) {\n+    // x is special or y is special\n+\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+        // return quiet (x)\n+        res.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = x.w[0];\n+      } else { // x is QNaN\n+        if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+          // set invalid flag\n+          *pfpsf |= INVALID_EXCEPTION;\n+        }\n+        // return x\n+        res.w[1] = x.w[1];\n+        res.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else if ((y.w[1] & MASK_NAN) == MASK_NAN) { // y is NAN\n+      if ((y.w[1] & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+        // set invalid flag\n+        *pfpsf |= INVALID_EXCEPTION;\n+        // return quiet (y)\n+        res.w[1] = y.w[1] & 0xfdffffffffffffffull;\n+        res.w[0] = y.w[0];\n+      } else { // y is QNaN\n+        // return y\n+        res.w[1] = y.w[1];\n+        res.w[0] = y.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\n+      ; // let infinities fall through\n+    }\n+  }\n+  // neither x nor y is NaN\n+  tmp_fpsf = *pfpsf; // save fpsf\n+#if DECIMAL_CALL_BY_REFERENCE\n+  __bid128_quiet_equal (&res1, &xnswp,\n+                      &ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  __bid128_quiet_greater (&res2, &xnswp,\n+                        &ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+  res1 =\n+    __bid128_quiet_equal (xnswp,\n+                        ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res2 =\n+    __bid128_quiet_greater (xnswp,\n+                          ynswp _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+                          _EXC_INFO_ARG);\n+#endif\n+  *pfpsf = tmp_fpsf; // restore fpsf\n+  if (res1) { // x = y\n+    // return x with the sign of y\n+    res.w[1] = \n+        (x.w[1] & 0x7fffffffffffffffull) | (y.w[1] & 0x8000000000000000ull);\n+    res.w[0] = x.w[0];\n+  } else if (res2) { // x > y\n+#if DECIMAL_CALL_BY_REFERENCE\n+    __bid128_nextdown (&res,\n+                     &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+    res =\n+      __bid128_nextdown (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#endif\n+    BID_SWAP128(res);\n+  } else { // x < y\n+#if DECIMAL_CALL_BY_REFERENCE\n+    __bid128_nextup (&res,\n+                   &xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+    res = __bid128_nextup (xnswp _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#endif\n+    BID_SWAP128(res);\n+  }\n+  // if the operand x is finite but the result is infinite, signal \n+  // overflow and inexact\n+  if (((x.w[1] & MASK_SPECIAL) != MASK_SPECIAL)\n+      && ((res.w[1] & MASK_SPECIAL) == MASK_SPECIAL)) {\n+    // set the inexact flag\n+    *pfpsf |= INEXACT_EXCEPTION;\n+    // set the overflow flag\n+    *pfpsf |= OVERFLOW_EXCEPTION;\n+  }\n+  // if the result is in (-10^emin, 10^emin), and is different from the\n+  // operand x, signal underflow and inexact\n+  tmp1.w[HIGH_128W] = 0x0000314dc6448d93ull; \n+  tmp1.w[LOW_128W] = 0x38c15b0a00000000ull; // +100...0[34] * 10^emin\n+  tmp2.w[HIGH_128W] = res.w[1] & 0x7fffffffffffffffull;\n+  tmp2.w[LOW_128W] = res.w[0];\n+  tmp_fpsf = *pfpsf; // save fpsf\n+#if DECIMAL_CALL_BY_REFERENCE\n+  __bid128_quiet_greater (&res1, &tmp1,\n+                        &tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+                        _EXC_INFO_ARG);\n+  __bid128_quiet_not_equal (&res2, &xnswp,\n+                          &res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+                          _EXC_INFO_ARG);\n+#else\n+  res1 =\n+    __bid128_quiet_greater (tmp1,\n+                          tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+                          _EXC_INFO_ARG);\n+  res2 =\n+    __bid128_quiet_not_equal (xnswp,\n+                            res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+                            _EXC_INFO_ARG);\n+#endif\n+  *pfpsf = tmp_fpsf; // restore fpsf\n+  if (res1 && res2) {\n+    // set the inexact flag \n+    *pfpsf |= INEXACT_EXCEPTION;\n+    // set the underflow flag \n+    *pfpsf |= UNDERFLOW_EXCEPTION;\n+  }\n+  BID_RETURN (res);\n+}"}, {"sha": "f757bcbbd08b3763421b341c7b2f6fc806b8fab6", "filename": "libgcc/config/libbid/bid128_noncomp.c", "status": "added", "additions": 1200, "deletions": 0, "changes": 1200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_noncomp.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,1200 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *\n+ *    BID128 non-computational functions:\n+ *         - __bid128_isSigned\n+ *         - __bid128_isNormal\n+ *         - __bid128_isSubnormal\n+ *         - __bid128_isFinite\n+ *         - __bid128_isZero\n+ *         - __bid128_isInf\n+ *         - __bid128_isSignaling\n+ *         - __bid128_isCanonical\n+ *         - __bid128_isNaN\n+ *         - __bid128_copy\n+ *         - __bid128_negate\n+ *         - __bid128_abs\n+ *         - __bid128_copySign\n+ *         - __bid128_class\n+ *         - __bid128_totalOrder\n+ *         - __bid128_totalOrderMag\n+ *         - __bid128_sameQuantum\n+ *         - __bid128_radix\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isSigned (int *pres,\n+                 UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isSigned (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x.w[HIGH_128W] & MASK_SIGN) == MASK_SIGN);\n+  BID_RETURN (res);\n+}\n+\n+// return 1 iff x is not zero, nor NaN nor subnormal nor infinity\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isNormal (int *pres,\n+                 UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isNormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT64 x_exp, C1_hi, C1_lo;\n+  BID_UI64DOUBLE tmp1;\n+  int exp, q, x_nr_bits;\n+\n+  BID_SWAP128(x);\n+  // test for special values - infinity or NaN\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // unpack x \n+  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C1_hi = x.w[1] & MASK_COEFF;\n+  C1_lo = x.w[0];\n+  // test for zero\n+  if (C1_hi == 0 && C1_lo == 0) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // test for non-canonical values of the argument x\n+  if ((((C1_hi > 0x0001ed09bead87c0ull)\n+       || ((C1_hi == 0x0001ed09bead87c0ull)\n+           && (C1_lo > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // x is subnormal or normal\n+  // determine the number of digits q in the significand\n+  // q = nr. of decimal digits in x\n+  // determine first the nr. of bits in x\n+  if (C1_hi == 0) {\n+    if (C1_lo >= 0x0020000000000000ull) { // x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1_lo >= 0x0000000100000000ull) { // x >= 2^32\n+        tmp1.d = (double) (C1_lo >> 32); // exact conversion\n+        x_nr_bits =\n+          33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else { // x < 2^32\n+        tmp1.d = (double) (C1_lo); // exact conversion\n+        x_nr_bits =\n+          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else { // if x < 2^53\n+      tmp1.d = (double) C1_lo; // exact conversion\n+      x_nr_bits =\n+        1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else { // C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n+    tmp1.d = (double) C1_hi; // exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1_hi > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+        || (C1_hi == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+        && C1_lo >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (int) (x_exp >> 49) - 6176;\n+  // test for subnormal values of x\n+  if (exp + q <= -6143) {\n+    res = 0;\n+    BID_RETURN (res);\n+  } else {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+}\n+\n+// return 1 iff x is not zero, nor NaN nor normal nor infinity\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isSubnormal (int *pres,\n+                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isSubnormal (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT64 x_exp, C1_hi, C1_lo;\n+  BID_UI64DOUBLE tmp1;\n+  int exp, q, x_nr_bits;\n+\n+  BID_SWAP128(x);\n+  // test for special values - infinity or NaN\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // unpack x \n+  x_exp = x.w[1] & MASK_EXP; // biased and shifted left 49 bit positions\n+  C1_hi = x.w[1] & MASK_COEFF;\n+  C1_lo = x.w[0];\n+  // test for zero\n+  if (C1_hi == 0 && C1_lo == 0) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // test for non-canonical values of the argument x\n+  if ((((C1_hi > 0x0001ed09bead87c0ull)\n+       || ((C1_hi == 0x0001ed09bead87c0ull)\n+           && (C1_lo > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // x is subnormal or normal\n+  // determine the number of digits q in the significand\n+  // q = nr. of decimal digits in x\n+  // determine first the nr. of bits in x\n+  if (C1_hi == 0) {\n+    if (C1_lo >= 0x0020000000000000ull) { // x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1_lo >= 0x0000000100000000ull) { // x >= 2^32\n+        tmp1.d = (double) (C1_lo >> 32); // exact conversion\n+        x_nr_bits =\n+          33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else { // x < 2^32\n+        tmp1.d = (double) (C1_lo); // exact conversion\n+        x_nr_bits =\n+          1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else { // if x < 2^53\n+      tmp1.d = (double) C1_lo; // exact conversion\n+      x_nr_bits =\n+        1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else { // C1_hi != 0 => nr. bits = 64 + nr_bits (C1_hi)\n+    tmp1.d = (double) C1_hi; // exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1_hi > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+        || (C1_hi == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+        && C1_lo >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (int) (x_exp >> 49) - 6176;\n+  // test for subnormal values of x\n+  if (exp + q <= -6143) {\n+    res = 1;\n+  } else {\n+    res = 0;\n+  }\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isFinite (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isFinite (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  res = ((x.w[HIGH_128W] & MASK_INF) != MASK_INF);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isZero (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isZero (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT128 sig_x;\n+\n+  BID_SWAP128(x);\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) || // significand is non-canonical\n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n+      (sig_x.w[0] > 0x378d8e63ffffffffull)) || // significand is non-canonical\n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull && \n+      (x.w[1] & MASK_INF) != MASK_INF) || // significand is non-canonical\n+      (sig_x.w[1] == 0 && sig_x.w[0] == 0)) { // significand is 0\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  res = 0;\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isInf (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isInf (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  res = ((x.w[HIGH_128W] & MASK_INF) == MASK_INF)\n+    && ((x.w[HIGH_128W] & MASK_NAN) != MASK_NAN);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isSignaling (int *pres,\n+                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isSignaling (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x.w[HIGH_128W] & MASK_SNAN) == MASK_SNAN);\n+  BID_RETURN (res);\n+}\n+\n+// return 1 iff x is a canonical number ,infinity, or NaN.\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isCanonical (int *pres,\n+                    UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isCanonical (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT128 sig_x;\n+\n+  BID_SWAP128(x);\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) { // NaN\n+    if (x.w[1] & 0x01ffc00000000000ull) {\n+      res = 0;\n+      BID_RETURN (res);\n+    }\n+    sig_x.w[1] = x.w[1] & 0x00003fffffffffffull; // 46 bits\n+    sig_x.w[0] = x.w[0]; // 64 bits\n+    // payload must be < 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n+    if (sig_x.w[1] < 0x0000314dc6448d93ull\n+        || (sig_x.w[1] == 0x0000314dc6448d93ull\n+        && sig_x.w[0] < 0x38c15b0a00000000ull)) {\n+      res = 1;\n+    } else {\n+      res = 0;\n+    }\n+    BID_RETURN (res);\n+  } else if ((x.w[1] & MASK_INF) == MASK_INF) { // infinity\n+    if ((x.w[1] & 0x03ffffffffffffffull) || x.w[0]) {\n+      res = 0;\n+    } else {\n+      res = 1;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // not NaN or infinity; extract significand to ensure it is canonical\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  // a canonical number has a coefficient < 10^34 \n+  //    (0x0001ed09_bead87c0_378d8e64_00000000)\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull) || // significand is non-canonical\n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && (sig_x.w[0] > 0x378d8e63ffffffffull)) ||        // significand is non-canonical\n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    res = 0;\n+  } else {\n+    res = 1;\n+  }\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_isNaN (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_isNaN (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x.w[HIGH_128W] & MASK_NAN) == MASK_NAN);\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, with no change\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_copy (UINT128 * pres,\n+             UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+UINT128\n+__bid128_copy (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res;\n+\n+  res = x;\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, reversing the sign\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_negate (UINT128 * pres,\n+               UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+UINT128\n+__bid128_negate (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res;\n+\n+  x.w[HIGH_128W] ^= MASK_SIGN;\n+  res = x;\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, changing the sign to positive\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_abs (UINT128 * pres,\n+            UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+UINT128\n+__bid128_abs (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res;\n+\n+  x.w[HIGH_128W] &= ~MASK_SIGN;\n+  res = x;\n+  BID_RETURN (res);\n+}\n+\n+// copies operand x to destination in the same format as x, but with the sign of y\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_copySign (UINT128 * pres, UINT128 * px,\n+                 UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+UINT128\n+__bid128_copySign (UINT128 x, UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 res;\n+\n+  x.w[HIGH_128W] = (x.w[HIGH_128W] & ~MASK_SIGN) | (y.w[HIGH_128W] & MASK_SIGN);\n+  res = x;\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_class (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_class (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT256 sig_x_prime256;\n+  UINT192 sig_x_prime192;\n+  UINT128 sig_x;\n+  int exp_x;\n+\n+  BID_SWAP128(x);\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n+    if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\n+      res = signalingNaN;\n+    } else {\n+      res = quietNaN;\n+    }\n+    BID_RETURN (res);\n+  }\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n+      res = negativeInfinity;\n+    } else {\n+      res = positiveInfinity;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // decode number into exponent and significand\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  // check for zero or non-canonical\n+  if ((sig_x.w[1] > 0x0001ed09bead87c0ull)\n+      || ((sig_x.w[1] == 0x0001ed09bead87c0ull)\n+          && (sig_x.w[0] > 0x378d8e63ffffffffull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)\n+      || ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n+      res = negativeZero;\n+    } else {\n+      res = positiveZero;\n+    }\n+    BID_RETURN (res);\n+  }\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+  // if exponent is less than -6176, the number may be subnormal \n+  // (less than the smallest normal value)\n+  //  the smallest normal value is 1 x 10^-6143 = 10^33 x 10^-6176\n+  //  if (exp_x - 6176 < -6143)\n+  if (exp_x < 33) { // sig_x * 10^exp_x\n+    if (exp_x > 19) {\n+      __mul_128x128_to_256 (sig_x_prime256, sig_x,\n+                            __bid_ten2k128[exp_x - 20]);\n+      // 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n+      if ((sig_x_prime256.w[3] == 0) && (sig_x_prime256.w[2] == 0)\n+          && ((sig_x_prime256.w[1] < 0x0000314dc6448d93ull)\n+              || ((sig_x_prime256.w[1] == 0x0000314dc6448d93ull)\n+              && (sig_x_prime256.w[0] < 0x38c15b0a00000000ull)))) {\n+        res =\n+          ((x.w[1] & MASK_SIGN) ==\n+           MASK_SIGN) ? negativeSubnormal : positiveSubnormal;\n+        BID_RETURN (res);\n+      }\n+    } else {\n+      __mul_64x128_to_192 (sig_x_prime192, __bid_ten2k64[exp_x], sig_x);\n+      // 10^33 = 0x0000314dc6448d93_38c15b0a00000000\n+      if ((sig_x_prime192.w[2] == 0)\n+          && ((sig_x_prime192.w[1] < 0x0000314dc6448d93ull)\n+              || ((sig_x_prime192.w[1] == 0x0000314dc6448d93ull)\n+              && (sig_x_prime192.w[0] < 0x38c15b0a00000000ull)))) {\n+        res =\n+          ((x.w[1] & MASK_SIGN) ==\n+           MASK_SIGN) ? negativeSubnormal : positiveSubnormal;\n+        BID_RETURN (res);\n+      }\n+    }\n+  }\n+  // otherwise, normal number, determine the sign\n+  res =\n+    ((x.w[1] & MASK_SIGN) ==\n+     MASK_SIGN) ? negativeNormal : positiveNormal;\n+  BID_RETURN (res);\n+}\n+\n+// true if the exponents of x and y are the same, false otherwise.\n+// The special cases of sameQuantum(NaN, NaN) and sameQuantum(Inf, Inf) are true\n+// If exactly one operand is infinite or exactly one operand is NaN, then false\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_sameQuantum (int *pres, UINT128 * px,\n+                    UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+int\n+__bid128_sameQuantum (UINT128 x,\n+                    UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // if both operands are NaN, return true\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN\n+      || ((y.w[1] & MASK_NAN) == MASK_NAN)) {\n+    res = ((x.w[1] & MASK_NAN) == MASK_NAN\n+           && (y.w[1] & MASK_NAN) == MASK_NAN);\n+    BID_RETURN (res);\n+  }\n+  // if both operands are INF, return true\n+  if ((x.w[1] & MASK_INF) == MASK_INF\n+      || (y.w[1] & MASK_INF) == MASK_INF) {\n+    res = ((x.w[1] & MASK_INF) == MASK_INF)\n+      && ((y.w[1] & MASK_INF) == MASK_INF);\n+    BID_RETURN (res);\n+  }\n+  // decode exponents for both numbers, and return true if they match\n+  res =\n+    ((x.w[1] >> 49) & 0x0000000000003fffull) ==\n+    ((y.w[1] >> 49) & 0x0000000000003fffull);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_totalOrder (int *pres, UINT128 * px,\n+                   UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+int\n+__bid128_totalOrder (UINT128 x,\n+                   UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  int exp_x, exp_y;\n+  UINT128 sig_x, sig_y, pyld_y, pyld_x;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char x_is_zero = 0, y_is_zero = 0;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  // NaN (CASE 1)\n+  // if x and y are unordered numerically because either operand is NaN\n+  //    (1) totalOrder(-NaN, number) is true\n+  //    (2) totalOrder(number, +NaN) is true\n+  //    (3) if x and y are both NaN:\n+  //       i) negative sign bit < positive sign bit\n+  //       ii) signaling < quiet fir +NaN, reverse for -NaN\n+  //       iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n+    // if x is -NaN\n+    if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n+      // return true, unless y is -NaN also\n+      if ((y.w[1] & MASK_NAN) != MASK_NAN\n+          || (y.w[1] & MASK_SIGN) != MASK_SIGN) {\n+        res = 1; // y is a number, return 1\n+        BID_RETURN (res);\n+      } else { // if y and x are both -NaN\n+        // if x and y are both -SNaN or both -QNaN, we have to compare payloads\n+        // this statement evaluates to true if both are SNaN or QNaN\n+        if (!\n+            (((y.w[1] & MASK_SNAN) ==\n+              MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+          // it comes down to the payload.  we want to return true if x has a\n+          // larger payload, but first we must calculate the payload.\n+          pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+          pyld_y.w[0] = y.w[0];\n+          pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+          pyld_x.w[0] = x.w[0];\n+          if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+              || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+                  && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n+              || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n+            // if y is zero, x must be less than or numerically equal\n+            // y's payload is 0\n+            res = 1;\n+            BID_RETURN (res);\n+          }\n+          // if x is zero and y isn't, x has the smaller payload\n+          // definitely (since we know y isn't 0 at this point)\n+          if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+              || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+                  && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n+              || (pyld_x.w[0] == 0 && pyld_x.w[1] == 0)) {\n+            // x's payload is 0\n+            res = 0;\n+            BID_RETURN (res);\n+          }\n+          res = ((pyld_x.w[1] > pyld_y.w[1])\n+                 || (pyld_x.w[1] == pyld_y.w[1]\n+                     && pyld_x.w[0] >= pyld_y.w[0]));\n+          BID_RETURN (res);\n+        } else {\n+          // either x = -SNaN and y = -QNaN or x = -QNaN and y = -SNaN\n+          res = (y.w[1] & MASK_SNAN) == MASK_SNAN;\n+          // totalOrder (-QNaN, -SNaN) == 1\n+          BID_RETURN (res);\n+        }\n+      }\n+    } else { // x is +NaN\n+      // return false, unless y is +NaN also\n+      if ((y.w[1] & MASK_NAN) != MASK_NAN\n+          || (y.w[1] & MASK_SIGN) == MASK_SIGN) {\n+        res = 0; // y is a number, return 1\n+        BID_RETURN (res);\n+      } else {\n+        // x and y are both +NaN; \n+        // must investigate payload if both quiet or both signaling\n+        // this xnor statement will be true if both x and y are +QNaN or +SNaN\n+        if (!\n+            (((y.w[1] & MASK_SNAN) ==\n+              MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+          // it comes down to the payload.  we want to return true if x has a\n+          // smaller payload, but first we must calculate the payload.\n+          pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+          pyld_y.w[0] = y.w[0];\n+          pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+          pyld_x.w[0] = x.w[0];\n+          // if x is zero and y isn't, x has the smaller payload definitely \n+          // (since we know y isn't 0 at this point)\n+          if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+              || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+                  && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n+              || (pyld_x.w[1] == 0 && pyld_x.w[0] == 0)) {\n+            res = 1;\n+            BID_RETURN (res);\n+          }\n+          if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+              || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+                  && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n+              || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n+            // if y is zero, x must be less than or numerically equal\n+            res = 0;\n+            BID_RETURN (res);\n+          }\n+          res = ((pyld_x.w[1] < pyld_y.w[1])\n+                 || (pyld_x.w[1] == pyld_y.w[1]\n+                     && pyld_x.w[0] <= pyld_y.w[0]));\n+          BID_RETURN (res);\n+        } else {\n+          // return true if y is +QNaN and x is +SNaN \n+          // (we know they're different bc of xor if_stmt above)\n+          res = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n+          BID_RETURN (res);\n+        }\n+      }\n+    }\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\n+    // x is certainly not NAN in this case.\n+    // return true if y is positive\n+    res = ((y.w[1] & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE 2)\n+  // if all the bits are the same, the numbers are equal.\n+  if ((x.w[1] == y.w[1]) && (x.w[0] == y.w[0])) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGNS (CASE 3)\n+  // if signs are opposite, return 1 if x is negative \n+  // (if x < y, totalOrder is true)\n+  if (((x.w[1] & MASK_SIGN) == MASK_SIGN) ^ \n+      ((y.w[1] & MASK_SIGN) == MASK_SIGN)) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE 4)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    // if x == neg_inf, return (y == neg_inf);\n+    if ((x.w[1] & MASK_SIGN) == MASK_SIGN) {\n+      res = 1;\n+      BID_RETURN (res);\n+    } else {\n+      // x is positive infinity, only return1 if y is positive infinity as well\n+      res = ((y.w[1] & MASK_INF) == MASK_INF);\n+      BID_RETURN (res);\n+      // && (y & MASK_SIGN) != MASK_SIGN); (we know y has same sign as x)\n+    }\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so:\n+    //    if y is +inf, x<y\n+    //    if y is -inf, x>y\n+    res = ((y.w[1] & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // CONVERT x\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF x IS CANONICAL\n+  // 9999999999999999999999999999999999 (decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) || \n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n+      (sig_x.w[0] > 0x378d8e63ffffffffull))) && \n+      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+      ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    x_is_zero = 1;\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      exp_x = (x.w[1] >> 47) & 0x000000000003fffull;\n+    }\n+  }\n+  // CONVERT y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) || \n+      ((sig_y.w[1] == 0x0001ed09bead87c0ull) && \n+      (sig_y.w[0] > 0x378d8e63ffffffffull))) && \n+      ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+      ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    y_is_zero = 1;\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      exp_y = (y.w[1] >> 47) & 0x000000000003fffull;\n+    }\n+  }\n+  // ZERO (CASE 5)\n+  // if x and y represent the same entities, and both are negative \n+  // return true iff exp_x <= exp_y\n+  if (x_is_zero && y_is_zero) {\n+    // we know that signs must be the same because we would have caught it \n+    // in case3 if signs were different\n+    // totalOrder(x,y) iff exp_x >= exp_y for negative numbers\n+    // totalOrder(x,y) iff exp_x <= exp_y for positive numbers\n+    if (exp_x == exp_y) {\n+      res = 1;\n+      BID_RETURN (res);\n+    }\n+    res = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+    BID_RETURN (res);\n+  }\n+  // if x is zero and y isn't, clearly x has the smaller payload\n+  if (x_is_zero) {\n+    res = ((y.w[1] & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if y is zero, and x isn't, clearly y has the smaller payload\n+  if (y_is_zero) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE 6)\n+  // if both components are either bigger or smaller\n+  if (((sig_x.w[1] > sig_y.w[1])\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] > sig_y.w[0]))\n+      && exp_x >= exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  if (((sig_x.w[1] < sig_y.w[1])\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] < sig_y.w[0]))\n+      && exp_x <= exp_y) {\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (exp_x > exp_y) {\n+    // if exp_x is 33 greater than exp_y, it is definitely larger, \n+    // so no need for compensation\n+    if (exp_x - exp_y > 33) {\n+      res = ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+      BID_RETURN (res);\n+      // difference cannot be greater than 10^33\n+    }\n+    // otherwise adjust the x significand upwards\n+    if (exp_x - exp_y > 19) {\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x,\n+                            __bid_ten2k128[exp_x - exp_y - 20]);\n+      // the compensated significands are equal (ie \"x and y represent the same\n+      // entities\") return 1 if (negative && expx > expy) || \n+      // (positive && expx < expy)\n+      if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+          && (sig_n_prime256.w[1] == sig_y.w[1])\n+          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+        // the case exp_x == exp_y  cannot occur, because all bits must be \n+        // the same - would have been caught if (x == y)\n+        res = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+        BID_RETURN (res);\n+      }\n+      // if positive, return 1 if adjusted x is smaller than y\n+      res = (((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+              && ((sig_n_prime256.w[1] < sig_y.w[1])\n+                  || (sig_n_prime256.w[1] == sig_y.w[1]\n+                      && sig_n_prime256.w[0] <\n+                      sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+                                       MASK_SIGN));\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_x - exp_y], sig_x);\n+    // if positive, return whichever significand is larger \n+    // (converse if negative)\n+    if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n+        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+      res = ((exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+      BID_RETURN (res);\n+    }\n+    res = (((sig_n_prime192.w[2] == 0)\n+            && ((sig_n_prime192.w[1] < sig_y.w[1])\n+                || (sig_n_prime192.w[1] == sig_y.w[1]\n+                    && sig_n_prime192.w[0] <\n+                    sig_y.w[0]))) ^ ((x.w[1] & MASK_SIGN) ==\n+                                     MASK_SIGN));\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 33 less than exp_y, it is definitely smaller, \n+  // no need for compensation\n+  if (exp_y - exp_x > 33) {\n+    res = ((x.w[1] & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  if (exp_y - exp_x > 19) {\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y,\n+                          __bid_ten2k128[exp_y - exp_x - 20]);\n+    // if x and y represent the same entities and both are negative\n+    // return true iff exp_x <= exp_y\n+    if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+        && (sig_n_prime256.w[1] == sig_x.w[1])\n+        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+      res = (exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+      BID_RETURN (res);\n+    }\n+    // values are not equal, for positive numbers return 1 if x is less than y\n+    // and 0 otherwise\n+    res = (((sig_n_prime256.w[3] != 0) ||\n+            // if upper128 bits of compensated y are non-zero, y is bigger\n+            (sig_n_prime256.w[2] != 0) ||\n+            // if upper128 bits of compensated y are non-zero, y is bigger\n+            (sig_n_prime256.w[1] > sig_x.w[1]) ||\n+            // if compensated y is bigger, y is bigger\n+            (sig_n_prime256.w[1] == sig_x.w[1]\n+             && sig_n_prime256.w[0] >\n+             sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+    BID_RETURN (res);\n+  }\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_y - exp_x], sig_y);\n+  if ((sig_n_prime192.w[2] == 0) && (sig_n_prime192.w[1] == sig_x.w[1])\n+      && (sig_n_prime192.w[0] == sig_x.w[0])) {\n+    res = (exp_x <= exp_y) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  res = (((sig_n_prime192.w[2] != 0) ||\n+          // if upper128 bits of compensated y are non-zero, y is bigger\n+          (sig_n_prime192.w[1] > sig_x.w[1]) ||\n+          // if compensated y is bigger, y is bigger\n+          (sig_n_prime192.w[1] == sig_x.w[1]\n+           && sig_n_prime192.w[0] >\n+           sig_x.w[0])) ^ ((x.w[1] & MASK_SIGN) == MASK_SIGN));\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_totalOrderMag (int *pres, UINT128 * px,\n+                      UINT128 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+  UINT128 y = *py;\n+#else\n+int\n+__bid128_totalOrderMag (UINT128 x,\n+                      UINT128 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  int exp_x, exp_y;\n+  UINT128 sig_x, sig_y, pyld_y, pyld_x;\n+  UINT192 sig_n_prime192;\n+  UINT256 sig_n_prime256;\n+  char x_is_zero = 0, y_is_zero = 0;\n+\n+  BID_SWAP128(x);\n+  BID_SWAP128(y);\n+  x.w[1] = x.w[1] & 0x7fffffffffffffffull;\n+  y.w[1] = y.w[1] & 0x7fffffffffffffffull;\n+\n+  // NaN (CASE 1)\n+  // if x and y are unordered numerically because either operand is NaN\n+  //    (1) totalOrder(number, +NaN) is true\n+  //    (2) if x and y are both NaN:\n+  //       i) signaling < quiet fir +NaN\n+  //       ii) lesser payload < greater payload for +NaN\n+  if ((x.w[1] & MASK_NAN) == MASK_NAN) {\n+    // x is +NaN\n+    // return false, unless y is +NaN also\n+    if ((y.w[1] & MASK_NAN) != MASK_NAN) {\n+      res = 0; // y is a number, return 0\n+      BID_RETURN (res);\n+    } else {\n+      // x and y are both +NaN; \n+      // must investigate payload if both quiet or both signaling\n+      // this xnor statement will be true if both x and y are +QNaN or +SNaN\n+      if (!\n+          (((y.w[1] & MASK_SNAN) ==\n+            MASK_SNAN) ^ ((x.w[1] & MASK_SNAN) == MASK_SNAN))) {\n+        // it comes down to the payload.  we want to return true if x has a\n+        // smaller payload, but first we must calculate the payload.\n+        pyld_y.w[1] = y.w[1] & 0x00003fffffffffffull;\n+        pyld_y.w[0] = y.w[0];\n+        pyld_x.w[1] = x.w[1] & 0x00003fffffffffffull;\n+        pyld_x.w[0] = x.w[0];\n+        // if x is zero and y isn't, x has the smaller payload definitely \n+        // (since we know y isn't 0 at this point)\n+        if ((pyld_x.w[1] > 0x0000314dc6448d93ull)\n+            || ((pyld_x.w[1] == 0x0000314dc6448d93ull)\n+                && (pyld_x.w[0] > 0x38c15b09ffffffffull))\n+            || (pyld_x.w[1] == 0 && pyld_x.w[0] == 0)) {\n+          res = 1;\n+          BID_RETURN (res);\n+        }\n+        if ((pyld_y.w[1] > 0x0000314dc6448d93ull)\n+            || ((pyld_y.w[1] == 0x0000314dc6448d93ull)\n+                && (pyld_y.w[0] > 0x38c15b09ffffffffull))\n+            || (pyld_y.w[1] == 0 && pyld_y.w[0] == 0)) {\n+          // if y is zero, x must be less than or numerically equal\n+          res = 0;\n+          BID_RETURN (res);\n+        }\n+        res = ((pyld_x.w[1] < pyld_y.w[1])\n+               || (pyld_x.w[1] == pyld_y.w[1]\n+                   && pyld_x.w[0] <= pyld_y.w[0]));\n+        BID_RETURN (res);\n+      } else {\n+        // return true if y is +QNaN and x is +SNaN \n+        // (we know they're different bc of xor if_stmt above)\n+        res = ((x.w[1] & MASK_SNAN) == MASK_SNAN);\n+        BID_RETURN (res);\n+      }\n+    }\n+  } else if ((y.w[1] & MASK_NAN) == MASK_NAN) {\n+    // x is certainly not NAN in this case.\n+    // return true because y is positive\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE 2)\n+  // if all the bits are the same, the numbers are equal.\n+  if ((x.w[1] == y.w[1]) && (x.w[0] == y.w[0])) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE 3)\n+  if ((x.w[1] & MASK_INF) == MASK_INF) {\n+    // x is positive infinity, only return 1 if y is positive infinity as well\n+    res = ((y.w[1] & MASK_INF) == MASK_INF);\n+    BID_RETURN (res);\n+    // (we know y has same sign as x)\n+  } else if ((y.w[1] & MASK_INF) == MASK_INF) {\n+    // x is finite, so:\n+    //    since y is +inf, x<y\n+    res = 1;\n+    BID_RETURN (res);\n+  } else {\n+    ; // continue\n+  }\n+\n+  // CONVERT x\n+  sig_x.w[1] = x.w[1] & 0x0001ffffffffffffull;\n+  sig_x.w[0] = x.w[0];\n+  exp_x = (x.w[1] >> 49) & 0x000000000003fffull;\n+\n+  // CHECK IF x IS CANONICAL\n+  // 9999999999999999999999999999999999 (decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((((sig_x.w[1] > 0x0001ed09bead87c0ull) || \n+      ((sig_x.w[1] == 0x0001ed09bead87c0ull) && \n+      (sig_x.w[0] > 0x378d8e63ffffffffull))) && \n+      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+      ((sig_x.w[1] == 0) && (sig_x.w[0] == 0))) {\n+    x_is_zero = 1;\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      exp_x = (x.w[1] >> 47) & 0x000000000003fffull;\n+    }\n+  }\n+  // CONVERT y\n+  exp_y = (y.w[1] >> 49) & 0x0000000000003fffull;\n+  sig_y.w[1] = y.w[1] & 0x0001ffffffffffffull;\n+  sig_y.w[0] = y.w[0];\n+\n+  // CHECK IF y IS CANONICAL\n+  // 9999999999999999999999999999999999(decimal) = \n+  //     1ed09_bead87c0_378d8e63_ffffffff(hexadecimal)\n+  // [0, 10^34) is the 754r supported canonical range.  \n+  // If the value exceeds that, it is interpreted as 0.\n+  if ((((sig_y.w[1] > 0x0001ed09bead87c0ull) || \n+      ((sig_y.w[1] == 0x0001ed09bead87c0ull) && \n+      (sig_y.w[0] > 0x378d8e63ffffffffull))) && \n+      ((y.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+      ((sig_y.w[1] == 0) && (sig_y.w[0] == 0))) {\n+    y_is_zero = 1;\n+    // check for the case where the exponent is shifted right by 2 bits!\n+    if ((y.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+      exp_y = (y.w[1] >> 47) & 0x000000000003fffull;\n+    }\n+  }\n+  // ZERO (CASE 4)\n+  if (x_is_zero && y_is_zero) {\n+    // we know that signs must be the same because we would have caught it \n+    // in case3 if signs were different\n+    // totalOrder(x,y) iff exp_x <= exp_y for positive numbers\n+    if (exp_x == exp_y) {\n+      res = 1;\n+      BID_RETURN (res);\n+    }\n+    res = (exp_x <= exp_y);\n+    BID_RETURN (res);\n+  }\n+  // if x is zero and y isn't, clearly x has the smaller payload\n+  if (x_is_zero) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if y is zero, and x isn't, clearly y has the smaller payload\n+  if (y_is_zero) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE 5)\n+  // if both components are either bigger or smaller\n+  if (((sig_x.w[1] > sig_y.w[1])\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] > sig_y.w[0]))\n+      && exp_x >= exp_y) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  if (((sig_x.w[1] < sig_y.w[1])\n+       || (sig_x.w[1] == sig_y.w[1] && sig_x.w[0] < sig_y.w[0]))\n+      && exp_x <= exp_y) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 33, it comes down to the compensated significand\n+  if (exp_x > exp_y) {\n+    // if exp_x is 33 greater than exp_y, it is definitely larger, \n+    // so no need for compensation\n+    if (exp_x - exp_y > 33) {\n+      res = 0; // difference cannot be greater than 10^33\n+      BID_RETURN (res);\n+    }\n+    // otherwise adjust the x significand upwards\n+    if (exp_x - exp_y > 19) {\n+      __mul_128x128_to_256 (sig_n_prime256, sig_x,\n+                            __bid_ten2k128[exp_x - exp_y - 20]);\n+      // the compensated significands are equal (ie \"x and y represent the same\n+      // entities\") return 1 if (negative && expx > expy) || \n+      // (positive && expx < expy)\n+      if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+          && (sig_n_prime256.w[1] == sig_y.w[1])\n+          && (sig_n_prime256.w[0] == sig_y.w[0])) {\n+        // the case (exp_x == exp_y) cannot occur, because all bits must be \n+        // the same - would have been caught if (x == y)\n+        res = (exp_x <= exp_y);\n+        BID_RETURN (res);\n+      }\n+      // since positive, return 1 if adjusted x is smaller than y\n+      res = ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+             && ((sig_n_prime256.w[1] < sig_y.w[1])\n+                 || (sig_n_prime256.w[1] == sig_y.w[1]\n+                     && sig_n_prime256.w[0] < sig_y.w[0])));\n+      BID_RETURN (res);\n+    }\n+    __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_x - exp_y], sig_x);\n+    // if positive, return whichever significand is larger \n+    // (converse if negative)\n+    if ((sig_n_prime192.w[2] == 0) && sig_n_prime192.w[1] == sig_y.w[1]\n+        && (sig_n_prime192.w[0] == sig_y.w[0])) {\n+      res = (exp_x <= exp_y);\n+      BID_RETURN (res);\n+    }\n+    res = ((sig_n_prime192.w[2] == 0)\n+           && ((sig_n_prime192.w[1] < sig_y.w[1])\n+               || (sig_n_prime192.w[1] == sig_y.w[1]\n+                   && sig_n_prime192.w[0] < sig_y.w[0])));\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 33 less than exp_y, it is definitely smaller, \n+  // no need for compensation\n+  if (exp_y - exp_x > 33) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  if (exp_y - exp_x > 19) {\n+    // adjust the y significand upwards\n+    __mul_128x128_to_256 (sig_n_prime256, sig_y,\n+                          __bid_ten2k128[exp_y - exp_x - 20]);\n+    if ((sig_n_prime256.w[3] == 0) && (sig_n_prime256.w[2] == 0)\n+        && (sig_n_prime256.w[1] == sig_x.w[1])\n+        && (sig_n_prime256.w[0] == sig_x.w[0])) {\n+      res = (exp_x <= exp_y);\n+      BID_RETURN (res);\n+    }\n+    // values are not equal, for positive numbers return 1 if x is less than y\n+    // and 0 otherwise\n+    res = ((sig_n_prime256.w[3] != 0) ||\n+           // if upper128 bits of compensated y are non-zero, y is bigger\n+           (sig_n_prime256.w[2] != 0) ||\n+           // if upper128 bits of compensated y are non-zero, y is bigger\n+           (sig_n_prime256.w[1] > sig_x.w[1]) ||\n+           // if compensated y is bigger, y is bigger\n+           (sig_n_prime256.w[1] == sig_x.w[1]\n+            && sig_n_prime256.w[0] > sig_x.w[0]));\n+    BID_RETURN (res);\n+  }\n+  __mul_64x128_to_192 (sig_n_prime192, __bid_ten2k64[exp_y - exp_x], sig_y);\n+  if ((sig_n_prime192.w[2] == 0) && (sig_n_prime192.w[1] == sig_x.w[1])\n+      && (sig_n_prime192.w[0] == sig_x.w[0])) {\n+    res = (exp_x <= exp_y);\n+    BID_RETURN (res);\n+  }\n+  res = ((sig_n_prime192.w[2] != 0) ||\n+         // if upper128 bits of compensated y are non-zero, y is bigger\n+         (sig_n_prime192.w[1] > sig_x.w[1]) ||\n+         // if compensated y is bigger, y is bigger\n+         (sig_n_prime192.w[1] == sig_x.w[1]\n+          && sig_n_prime192.w[0] > sig_x.w[0]));\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid128_radix (int *pres, UINT128 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+int\n+__bid128_radix (UINT128 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  if (x.w[LOW_128W])        // dummy test\n+    res = 10;\n+  else\n+    res = 10;\n+  BID_RETURN (res);\n+}"}, {"sha": "aa69b84fc334f1498a0f9298689edf1a5e7917a1", "filename": "libgcc/config/libbid/bid128_quantize.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_quantize.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,270 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+BID128_FUNCTION_ARG2(__bid128_quantize, x, y)\n+\n+  UINT256 CT;\n+  UINT128 CX, CY, T, CX2, CR, Stemp, res, REM_H, C2N;\n+  UINT64 sign_x, sign_y, remainder_h, carry, CY64;\n+  int_float tempx;\n+  int exponent_x = 0, exponent_y = 0, digits_x, extra_digits, amount;\n+  int expon_diff, total_digits, bin_expon_cx, rmode, status;\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n+    // y is Inf. or NaN\n+#ifdef SET_STATUS_FLAGS\n+    if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // test if y is NaN\n+    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n+        // set status flags\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+      }\n+#endif\n+      res.w[1] = y.w[1] & QUIET_MASK64;\n+      res.w[0] = y.w[0];\n+      BID_RETURN (res);\n+    }\n+    // y is Infinity?\n+    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // check if x is not Inf.\n+      if (((x.w[1] & 0x7c00000000000000ull) < 0x7800000000000000ull)) {\n+        // return NaN \n+#ifdef SET_STATUS_FLAGS\n+        // set status flags\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      } else if (((x.w[1] & 0x7c00000000000000ull) <= 0x7800000000000000ull)) {\n+        res.w[1] = x.w[1];\n+        res.w[0] = x.w[0];\n+        BID_RETURN (res);\n+      }\n+    }\n+  }\n+\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    // test if x is NaN or Inf\n+    if ((x.w[1] & 0x7c00000000000000ull) == 0x7800000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      // set status flags\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res.w[1] = 0x7c00000000000000ull;\n+      res.w[0] = x.w[0];\n+      BID_RETURN (res);\n+    } else if ((x.w[1] & 0x7c00000000000000ull) ==\n+               0x7c00000000000000ull) {\n+      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+        // set status flags\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      }\n+      res.w[1] = x.w[1] & QUIET_MASK64;\n+      res.w[0] = x.w[0];\n+      BID_RETURN (res);\n+    }\n+    if (!CX.w[1] && !CX.w[0]) {\n+      get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+      BID_RETURN (res);\n+    }\n+  }\n+  // get number of decimal digits in coefficient_x\n+  if (CX.w[1]) {\n+    tempx.d = (float) CX.w[1];\n+    bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f + 64;\n+  } else {\n+    tempx.d = (float) CX.w[0];\n+    bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+  }\n+  digits_x = __bid_estimate_decimal_digits[bin_expon_cx];\n+  if (CX.w[1] > __bid_power10_table_128[digits_x].w[1]\n+      || (CX.w[1] == __bid_power10_table_128[digits_x].w[1]\n+          && CX.w[0] >= __bid_power10_table_128[digits_x].w[0]))\n+    digits_x++;\n+\n+  expon_diff = exponent_x - exponent_y;\n+  total_digits = digits_x + expon_diff;\n+\n+  if ((UINT32) total_digits <= 34) {\n+    if (expon_diff >= 0) {\n+      T = __bid_power10_table_128[expon_diff];\n+      __mul_128x128_low (CX2, T, CX);\n+      get_BID128_very_fast (&res, sign_x, exponent_y, CX2);\n+      BID_RETURN (res);\n+    }\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+    // must round off -expon_diff digits\n+    extra_digits = -expon_diff;\n+    __add_128_128 (CX, CX, __bid_round_const_table_128[rmode][extra_digits]);\n+\n+    // get P*(2^M[extra_digits])/10^extra_digits\n+    __mul_128x128_to_256 (CT, CX, __bid_reciprocals10_128[extra_digits]);\n+\n+    // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+    amount = __bid_recip_scale[extra_digits];\n+    CX2.w[0] = CT.w[2];\n+    CX2.w[1] = CT.w[3];\n+    if (amount >= 64) {\n+      CR.w[1] = 0;\n+      CR.w[0] = CX2.w[1] >> (amount - 64);\n+    } else {\n+      __shr_128 (CR, CX2, amount);\n+    }\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    if (rnd_mode == 0)\n+#endif\n+      if (CR.w[0] & 1) {\n+        // check whether fractional part of initial_P/10^extra_digits is \n+        // exactly .5 this is the same as fractional part of \n+        // (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n+\n+        // get remainder\n+        if (amount >= 64) {\n+          remainder_h = CX2.w[0] | (CX2.w[1] << (128 - amount));\n+        } else\n+          remainder_h = CX2.w[0] << (64 - amount);\n+\n+        // test whether fractional part is 0\n+        if (!remainder_h\n+            && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+                || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+                    && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0]))) {\n+          CR.w[0]--;\n+        }\n+      }\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+    status = INEXACT_EXCEPTION;\n+\n+    // get remainder\n+    if (amount >= 64) {\n+      REM_H.w[1] = (CX2.w[1] << (128 - amount));\n+      REM_H.w[0] = CX2.w[0];\n+    } else {\n+      REM_H.w[1] = CX2.w[0] << (64 - amount);\n+      REM_H.w[0] = 0;\n+    }\n+\n+    switch (rmode) {\n+    case ROUNDING_TO_NEAREST:\n+    case ROUNDING_TIES_AWAY:\n+      // test whether fractional part is 0\n+      if (REM_H.w[1] == 0x8000000000000000ull && !REM_H.w[0]\n+          && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+              || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+                  && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+        status = EXACT_STATUS;\n+      break;\n+    case ROUNDING_DOWN:\n+    case ROUNDING_TO_ZERO:\n+      if (!(REM_H.w[1] | REM_H.w[0])\n+          && (CT.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+              || (CT.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+                  && CT.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+        status = EXACT_STATUS;\n+      break;\n+    default:\n+      // round up\n+      __add_carry_out (Stemp.w[0], CY64, CT.w[0],\n+                       __bid_reciprocals10_128[extra_digits].w[0]);\n+      __add_carry_in_out (Stemp.w[1], carry, CT.w[1],\n+                          __bid_reciprocals10_128[extra_digits].w[1], CY64);\n+      if (amount < 64) {\n+        C2N.w[1] = 0;\n+        C2N.w[0] = ((UINT64) 1) << amount;\n+        REM_H.w[0] = REM_H.w[1] >> (64 - amount);\n+        REM_H.w[1] = 0;\n+      } else {\n+        C2N.w[1] = ((UINT64) 1) << (amount - 64);\n+        C2N.w[0] = 0;\n+        REM_H.w[1] >>= (128 - amount);\n+      }\n+      REM_H.w[0] += carry;\n+      if (REM_H.w[0] < carry)\n+        REM_H.w[1]++;\n+      if (__unsigned_compare_ge_128 (REM_H, C2N))\n+        status = EXACT_STATUS;\n+    }\n+\n+    __set_status_flags (pfpsf, status);\n+\n+#endif\n+    get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n+    BID_RETURN (res);\n+  }\n+  if (total_digits < 0) {\n+    CR.w[1] = CR.w[0] = 0;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+    if (rmode == ROUNDING_UP)\n+      CR.w[0] = 1;\n+#endif\n+#endif\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+#endif\n+    get_BID128_very_fast (&res, sign_x, exponent_y, CR);\n+    BID_RETURN (res);\n+  }\n+  // else  more than 34 digits in coefficient\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res.w[1] = 0x7c00000000000000ull;\n+  res.w[0] = 0;\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "e22043eeb0bf701858cc6a8e397106e9e40620e1", "filename": "libgcc/config/libbid/bid128_rem.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_rem.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,219 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"div_macros.h\"\n+\n+\n+BID128_FUNCTION_ARG2(__bid128_rem, x, y)\n+\n+  UINT256 P256;\n+  UINT128 CX, CY, CX2, CQ, CR, T, CXS, P128, res;\n+  UINT64 sign_x, sign_y;\n+  SINT64 D;\n+  int_float f64, fx;\n+  int exponent_x = 0, exponent_y, diff_expon, bin_expon_cx, scale, scale0;\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+#ifdef SET_STATUS_FLAGS\n+    if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // test if x is NaN\n+    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((x.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res.w[1] = x.w[1] & QUIET_MASK64;\n+      res.w[0] = x.w[0];\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // check if y is Inf.\n+      if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull))\n+        // return NaN \n+      {\n+#ifdef SET_STATUS_FLAGS\n+        // set status flags\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+\n+    }\n+    // x is 0\n+    if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) { // not Inf/NaN\n+      if ((!y.w[0]) && !(y.w[1] & 0x0001ffffffffffffull)) {\n+#ifdef SET_STATUS_FLAGS\n+        // set status flags\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+        // x=y=0, return NaN\n+        res.w[1] = 0x7c00000000000000ull;\n+        res.w[0] = 0;\n+        BID_RETURN (res);\n+      }\n+      // return 0\n+      exponent_y = (y.w[1] >> 49) & 0x3fff;\n+      if (exponent_x > exponent_y)\n+        exponent_x = exponent_y;\n+\n+      res.w[1] = sign_x | (((UINT64) exponent_x) << 49);\n+      res.w[0] = 0;\n+      BID_RETURN (res);\n+    }\n+  }\n+  if (!unpack_BID128_value (&sign_y, &exponent_y, &CY, y)) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y.w[1] & SNAN_MASK64) == SNAN_MASK64) // y is sNaN\n+        __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res.w[1] = y.w[1] & QUIET_MASK64;\n+      res.w[0] = y.w[0];\n+      BID_RETURN (res);\n+    }\n+    // y is Infinity?\n+    if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // return x\n+      res.w[1] = x.w[1];\n+      res.w[0] = x.w[0];\n+      BID_RETURN (res);\n+    }\n+    // y is 0\n+#ifdef SET_STATUS_FLAGS\n+    // set status flags\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+    BID_RETURN (res);\n+  }\n+\n+  diff_expon = exponent_x - exponent_y;\n+\n+  if (diff_expon <= 0) {\n+    diff_expon = -diff_expon;\n+\n+    if (diff_expon > 34) {\n+      // |x|<|y| in this case\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // set exponent of y to exponent_x, scale coefficient_y\n+    T = __bid_power10_table_128[diff_expon];\n+    __mul_128x128_to_256 (P256, CY, T);\n+\n+    if (P256.w[2] || P256.w[3]) {\n+      // |x|<|y| in this case\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+\n+    CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+    CX2.w[0] = CX.w[0] << 1;\n+    if (__unsigned_compare_ge_128 (P256, CX2)) {\n+      // |x|<|y| in this case\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+\n+    P128.w[0] = P256.w[0];\n+    P128.w[1] = P256.w[1];\n+    __div_128_by_128 (&CQ, &CR, CX, P128);\n+\n+    CX2.w[1] = (CR.w[1] << 1) | (CR.w[0] >> 63);\n+    CX2.w[0] = CR.w[0] << 1;\n+    if ((__unsigned_compare_gt_128 (CX2, P256))\n+        || (CX2.w[1] == P256.w[1] && CX2.w[0] == P256.w[0]\n+            && (CQ.w[0] & 1))) {\n+      __sub_128_128 (CR, P256, CR);\n+      sign_x ^= 0x8000000000000000ull;\n+    }\n+\n+    get_BID128_very_fast (&res, sign_x, exponent_x, CR);\n+    BID_RETURN (res);\n+  }\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  scale0 = 38;\n+  if (!CY.w[1])\n+    scale0 = 34;\n+\n+  while (diff_expon > 0) {\n+    // get number of digits in CX and scale=38-digits\n+    // fx ~ CX\n+    fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+    bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+    scale = scale0 - __bid_estimate_decimal_digits[bin_expon_cx];\n+    // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n+    D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n+    if (D > 0\n+        || (!D\n+            && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+      scale--;\n+\n+    if (diff_expon >= scale)\n+      diff_expon -= scale;\n+    else {\n+      scale = diff_expon;\n+      diff_expon = 0;\n+    }\n+\n+    T = __bid_power10_table_128[scale];\n+    __mul_128x128_low (CXS, CX, T);\n+\n+    __div_128_by_128 (&CQ, &CX, CXS, CY);\n+\n+    // check for remainder == 0\n+    if (!CX.w[1] && !CX.w[0]) {\n+      get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+  CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+  CX2.w[0] = CX.w[0] << 1;\n+  if ((__unsigned_compare_gt_128 (CX2, CY))\n+      || (CX2.w[1] == CY.w[1] && CX2.w[0] == CY.w[0] && (CQ.w[0] & 1))) {\n+    __sub_128_128 (CX, CY, CX);\n+    sign_x ^= 0x8000000000000000ull;\n+  }\n+\n+  get_BID128_very_fast (&res, sign_x, exponent_y, CX);\n+  BID_RETURN (res);\n+}"}, {"sha": "a9952a9bc8b1e5dc4a94ab0b1842535b16062b4e", "filename": "libgcc/config/libbid/bid128_round_integral.c", "status": "added", "additions": 1912, "deletions": 0, "changes": 1912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_round_integral.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,1912 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_exact\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1(__bid128_round_integral_exact, x)\n+\n+  UINT128 res = {{ 0xbaddbaddbaddbaddull, 0xbaddbaddbaddbaddull }};\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  UINT64 tmp64;\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  UINT256 fstar;\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull) || \n+      ((C1.w[1] == 0x0001ed09bead87c0ull) && \n+      (C1.w[0] > 0x378d8e63ffffffffull))) && \n+      ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull)) || \n+      ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent\n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  switch (rnd_mode) {\n+  case ROUNDING_TO_NEAREST:\n+  case ROUNDING_TIES_AWAY:\n+    // if (exp <= -(p+1)) return 0.0\n+    if (x_exp <= 0x2ffa000000000000ull) {\t// 0x2ffa000000000000ull == -35\n+      res.w[1] = x_sign | 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_DOWN:\n+    // if (exp <= -p) return -1.0 or +0.0\n+    if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffa000000000000ull == -34\n+      if (x_sign) {\n+\t// if negative, return negative 1, because we know coefficient\n+\t// is non-zero (would have been caught above)\n+\tres.w[1] = 0xb040000000000000ull;\n+\tres.w[0] = 0x0000000000000001ull;\n+      } else {\n+\t// if positive, return positive 0, because we know coefficient is\n+\t// non-zero (would have been caught above)\n+\tres.w[1] = 0x3040000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_UP:\n+    // if (exp <= -p) return -0.0 or +1.0\n+    if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffc000000000000ull == -34\n+      if (x_sign) {\n+\t// if negative, return negative 0, because we know the coefficient\n+\t// is non-zero (would have been caught above)\n+\tres.w[1] = 0xb040000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\n+\t// if positive, return positive 1, because we know coefficient is\n+\t// non-zero (would have been caught above)\n+\tres.w[1] = 0x3040000000000000ull;\n+\tres.w[0] = 0x0000000000000001ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TO_ZERO:\n+    // if (exp <= -p) return -0.0 or +0.0\n+    if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffc000000000000ull == -34\n+      res.w[1] = x_sign | 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  }\n+\n+  // q = nr. of decimal digits in x\n+  //  determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  }\n+  // exp < 0\n+  switch (rnd_mode) {\n+  case ROUNDING_TO_NEAREST:\n+    if ((q + exp) >= 0) {\t// exp < 0 and 1 <= -exp <= q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 = C1 + 1/2 * 10^x where the result C1 fits in 127 bits\n+      tmp64 = C1.w[0];\n+      if (ind <= 19) {\n+\tC1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+      } else {\n+\tC1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+\tC1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+      }\n+      if (C1.w[0] < tmp64)\n+\tC1.w[1]++;\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 118 bits\n+      __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+      // determine the value of res and fstar\n+\n+      // determine inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 > T*) then\n+      //   the result is inexact\n+      // Note: we are going to use __bid_ten2mk128[] instead of __bid_ten2mk128trunc[]\n+\n+      if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+\t// redundant shift = __bid_shiftright128[ind - 1]; // shift = 0\n+\tres.w[1] = P256.w[3];\n+\tres.w[0] = P256.w[2];\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* < 10^(-x) <=> midpoint\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\t// if 0 < fstar < 10^(-x), subtract 1 if odd (for rounding to even)\n+\tif ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t    ((fstar.w[1] < (__bid_ten2mk128[ind - 1].w[1]))\n+\t     || ((fstar.w[1] == __bid_ten2mk128[ind - 1].w[1])\n+\t\t && (fstar.w[0] < __bid_ten2mk128[ind - 1].w[0])))) {\n+\t  // subract 1 to make even\n+\t  if (res.w[0]-- == 0) {\n+\t    res.w[1]--;\n+\t  }\n+\t}\n+\tif (fstar.w[1] > 0x8000000000000000ull || \n+            (fstar.w[1] == 0x8000000000000000ull && fstar.w[0] > 0x0ull)) {\n+          // f* > 1/2 and the result may be exact\n+\t  tmp64 = fstar.w[1] - 0x8000000000000000ull;\t// f* - 1/2\n+\t  if ((tmp64 > __bid_ten2mk128[ind - 1].w[1]\n+\t       || (tmp64 == __bid_ten2mk128[ind - 1].w[1]\n+\t       && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact \n+\t} else {\t// the result is inexact; f2* <= 1/2  \n+\t  // set the inexact flag \n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres.w[1] = (P256.w[3] >> shift);\n+\tres.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* < 10^(-x) <=> midpoint\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t    fstar.w[2] == 0 && (fstar.w[1] < __bid_ten2mk128[ind - 1].w[1]\n+\t\t\t\t|| (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t\t\t&& fstar.w[0] < __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  // subract 1 to make even\n+\t  if (res.w[0]-- == 0) {\n+\t    res.w[1]--;\n+\t  }\n+\t}\n+\tif (fstar.w[2] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[2] == __bid_one_half128[ind - 1]\n+\t    && (fstar.w[1] || fstar.w[0]))) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  tmp64 = fstar.w[2] - __bid_one_half128[ind - 1];\n+\t  if (tmp64 || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t      && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact\n+\t} else {\t// the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else {\t// 22 <= ind - 1 <= 33\n+\tshift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+\tres.w[1] = 0;\n+\tres.w[0] = P256.w[3] >> shift;\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* < 10^(-x) <=> midpoint\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t    fstar.w[3] == 0 && fstar.w[2] == 0\n+\t    && (fstar.w[1] < __bid_ten2mk128[ind - 1].w[1]\n+\t\t|| (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& fstar.w[0] < __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  // subract 1 to make even\n+\t  if (res.w[0]-- == 0) {\n+\t    res.w[1]--;\n+\t  }\n+\t}\n+\tif (fstar.w[3] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[3] == __bid_one_half128[ind - 1]\n+\t    && (fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  tmp64 = fstar.w[3] - __bid_one_half128[ind - 1];\n+\t  if (tmp64 || fstar.w[2]\n+\t      || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t      && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact\n+\t} else {\t// the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      }\n+      res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+      BID_RETURN (res);\n+    } else {\t// if ((q + exp) < 0) <=> q < -exp\n+      // the result is +0 or -0\n+      res.w[1] = x_sign | 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    if ((q + exp) >= 0) {\t// exp < 0 and 1 <= -exp <= q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 = C1 + 1/2 * 10^x where the result C1 fits in 127 bits\n+      tmp64 = C1.w[0];\n+      if (ind <= 19) {\n+\tC1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+      } else {\n+\tC1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+\tC1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+      }\n+      if (C1.w[0] < tmp64)\n+\tC1.w[1]++;\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 118 bits\n+      __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+      // the top Ex bits of 10^(-x) are T* = __bid_ten2mk128trunc[ind], e.g.\n+      // if x=1, T*=__bid_ten2mk128trunc[0]=0x19999999999999999999999999999999\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      //   if floor(C*) is even then C* = floor(C*) - logical right\n+      //       shift; C* has p decimal digits, correct by Prop. 1)\n+      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+      //       shift; C* has p decimal digits, correct by Pr. 1)\n+      // else\n+      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // n = C* * 10^(e+x)\n+\n+      // determine also the inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 > T*) then\n+      //   the result is inexact\n+      // Note: we are going to use __bid_ten2mk128[] instead of __bid_ten2mk128trunc[]\n+      // shift right C* by Ex-128 = __bid_shiftright128[ind]\n+      if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+\t// redundant shift = __bid_shiftright128[ind - 1]; // shift = 0\n+\tres.w[1] = P256.w[3];\n+\tres.w[0] = P256.w[2];\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\tif (fstar.w[1] > 0x8000000000000000ull || \n+            (fstar.w[1] == 0x8000000000000000ull && fstar.w[0] > 0x0ull)) {\n+          // f* > 1/2 and the result may be exact\n+\t  tmp64 = fstar.w[1] - 0x8000000000000000ull;\t// f* - 1/2\n+\t  if ((tmp64 > __bid_ten2mk128[ind - 1].w[1]\n+\t       || (tmp64 == __bid_ten2mk128[ind - 1].w[1]\n+\t       && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact\n+\t} else {\t// the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres.w[1] = (P256.w[3] >> shift);\n+\tres.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\tif (fstar.w[2] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[2] == __bid_one_half128[ind - 1]\n+\t    && (fstar.w[1] || fstar.w[0]))) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  tmp64 = fstar.w[2] - __bid_one_half128[ind - 1];\n+\t  if (tmp64 || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t      && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact\n+\t} else {\t// the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else {\t// 22 <= ind - 1 <= 33\n+\tshift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+\tres.w[1] = 0;\n+\tres.w[0] = P256.w[3] >> shift;\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\tif (fstar.w[3] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[3] == __bid_one_half128[ind - 1]\n+\t    && (fstar.w[2] || fstar.w[1] || fstar.w[0]))) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  tmp64 = fstar.w[3] - __bid_one_half128[ind - 1];\n+\t  if (tmp64 || fstar.w[2]\n+\t      || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t      && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  }\t// else the result is exact\n+\t} else {\t// the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      }\n+      // if the result was a midpoint, it was already rounded away from zero\n+      res.w[1] |= x_sign | 0x3040000000000000ull;\n+      BID_RETURN (res);\n+    } else {\t// if ((q + exp) < 0) <=> q < -exp\n+      // the result is +0 or -0\n+      res.w[1] = x_sign | 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_DOWN:\n+    if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x' \n+      // (number of digits to be chopped off)\n+      // chop off ind digits from the lower part of C1 \n+      // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+      // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+      // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+      // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+      // tmp64 = C1.w[0];\n+      // if (ind <= 19) {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+      // } else {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+      //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+      // }\n+      // if (C1.w[0] < tmp64) C1.w[1]++;\n+      // if carry-out from C1.w[0], increment C1.w[1]\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 118 bits\n+      __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+      if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+\tres.w[1] = P256.w[3];\n+\tres.w[0] = P256.w[2];\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\t// redundant fstar.w[1] = P256.w[1];\n+\t// redundant fstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((P256.w[1] > __bid_ten2mk128[ind - 1].w[1])\n+\t    || (P256.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& (P256.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if positive, the truncated value is already the correct result\n+\t  if (x_sign) {\t// if negative\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 0 <= shift <= 102\n+\tres.w[1] = (P256.w[3] >> shift);\n+\tres.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[2] || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if positive, the truncated value is already the correct result\n+\t  if (x_sign) {\t// if negative\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      } else {\t// 22 <= ind - 1 <= 33\n+\tshift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+\tres.w[1] = 0;\n+\tres.w[0] = P256.w[3] >> shift;\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[3] || fstar.w[2]\n+\t    || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if positive, the truncated value is already the correct result\n+\t  if (x_sign) {\t// if negative\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      }\n+      res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+      BID_RETURN (res);\n+    } else {\t// if exp < 0 and q + exp <= 0\n+      if (x_sign) {\t// negative rounds down to -1.0\n+\tres.w[1] = 0xb040000000000000ull;\n+\tres.w[0] = 0x0000000000000001ull;\n+      } else {\t// positive rpunds down to +0.0\n+\tres.w[1] = 0x3040000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_UP:\n+    if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x' \n+      // (number of digits to be chopped off)\n+      // chop off ind digits from the lower part of C1 \n+      // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+      // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+      // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+      // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+      // tmp64 = C1.w[0];\n+      // if (ind <= 19) {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+      // } else {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+      //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+      // }\n+      // if (C1.w[0] < tmp64) C1.w[1]++;  \n+      // if carry-out from C1.w[0], increment C1.w[1]\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+      // C* = C1 * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 118 bits\n+      __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+      if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+\tres.w[1] = P256.w[3];\n+\tres.w[0] = P256.w[2];\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\t// redundant fstar.w[1] = P256.w[1]; \n+\t// redundant fstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((P256.w[1] > __bid_ten2mk128[ind - 1].w[1])\n+\t    || (P256.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& (P256.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if negative, the truncated value is already the correct result\n+\t  if (!x_sign) {\t// if positive\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres.w[1] = (P256.w[3] >> shift);\n+\tres.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[2] || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if negative, the truncated value is already the correct result\n+\t  if (!x_sign) {\t// if positive\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      } else {\t// 22 <= ind - 1 <= 33\n+\tshift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+\tres.w[1] = 0;\n+\tres.w[0] = P256.w[3] >> shift;\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[3] || fstar.w[2]\n+\t    || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t  // if negative, the truncated value is already the correct result\n+\t  if (!x_sign) {\t// if positive\n+\t    if (++res.w[0] == 0) {\n+\t      res.w[1]++;\n+\t    }\n+\t  }\n+\t}\n+      }\n+      res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+      BID_RETURN (res);\n+    } else {\t// if exp < 0 and q + exp <= 0\n+      if (x_sign) {\t// negative rounds up to -0.0\n+\tres.w[1] = 0xb040000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// positive rpunds up to +1.0\n+\tres.w[1] = 0x3040000000000000ull;\n+\tres.w[0] = 0x0000000000000001ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TO_ZERO:\n+    if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+      // (number of digits to be chopped off)\n+      // chop off ind digits from the lower part of C1 \n+      // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+      // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+      // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+      // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+      //tmp64 = C1.w[0];\n+      // if (ind <= 19) {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+      // } else {\n+      //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+      //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+      // }\n+      // if (C1.w[0] < tmp64) C1.w[1]++;  \n+      // if carry-out from C1.w[0], increment C1.w[1]\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 34\n+      // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 118 bits\n+      __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+      if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+\tres.w[1] = P256.w[3];\n+\tres.w[0] = P256.w[2];\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\t// redundant fstar.w[1] = P256.w[1]; \n+\t// redundant fstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((P256.w[1] > __bid_ten2mk128[ind - 1].w[1])\n+\t    || (P256.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& (P256.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres.w[1] = (P256.w[3] >> shift);\n+\tres.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[2] || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else {\t// 22 <= ind - 1 <= 33\n+\tshift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+\tres.w[1] = 0;\n+\tres.w[0] = P256.w[3] >> shift;\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[3] || fstar.w[2]\n+\t    || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      }\n+      res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+      BID_RETURN (res);\n+    } else {\t// if exp < 0 and q + exp <= 0 the result is +0 or -0\n+      res.w[1] = x_sign | 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  }\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_nearest_even\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1_NORND(__bid128_round_integral_nearest_even, x)\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  UINT64 tmp64;\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  // UINT128 res is C* at first - represents up to 34 decimal digits ~ 113 bits\n+  UINT256 fstar;\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull)\n+       || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+\t   && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent\n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  // if (exp <= -(p+1)) return 0\n+  if (x_exp <= 0x2ffa000000000000ull) {\t// 0x2ffa000000000000ull == -35\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x\n+  //  determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  } else if ((q + exp) >= 0) {\t// exp < 0 and 1 <= -exp <= q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 = C1 + 1/2 * 10^x where the result C1 fits in 127 bits\n+    tmp64 = C1.w[0];\n+    if (ind <= 19) {\n+      C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+    } else {\n+      C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+      C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+    }\n+    if (C1.w[0] < tmp64)\n+      C1.w[1]++;\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 34\n+    // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 118 bits\n+    __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+    // determine the value of res and fstar\n+    if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+      // redundant shift = __bid_shiftright128[ind - 1]; // shift = 0\n+      res.w[1] = P256.w[3];\n+      res.w[0] = P256.w[2];\n+      // redundant fstar.w[3] = 0;\n+      // redundant fstar.w[2] = 0;\n+      // redundant fstar.w[1] = P256.w[1];\n+      // redundant fstar.w[0] = P256.w[0];\n+      // fraction f* < 10^(-x) <=> midpoint\n+      // f* is in the right position to be compared with\n+      // 10^(-x) from __bid_ten2mk128[]\n+      // if 0 < fstar < 10^(-x), subtract 1 if odd (for rounding to even)\n+      if ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t  ((P256.w[1] < (__bid_ten2mk128[ind - 1].w[1]))\n+\t   || ((P256.w[1] == __bid_ten2mk128[ind - 1].w[1])\n+\t       && (P256.w[0] < __bid_ten2mk128[ind - 1].w[0])))) {\n+\t// subract 1 to make even\n+\tif (res.w[0]-- == 0) {\n+\t  res.w[1]--;\n+\t}\n+      }\n+    } else if (ind - 1 <= 21) {\t// 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res.w[1] = (P256.w[3] >> shift);\n+      res.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+      // redundant fstar.w[3] = 0;\n+      fstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+      fstar.w[1] = P256.w[1];\n+      fstar.w[0] = P256.w[0];\n+      // fraction f* < 10^(-x) <=> midpoint\n+      // f* is in the right position to be compared with\n+      // 10^(-x) from __bid_ten2mk128[]\n+      if ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t  fstar.w[2] == 0 && (fstar.w[1] < __bid_ten2mk128[ind - 1].w[1]\n+\t\t\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t\t      && fstar.w[0] < __bid_ten2mk128[ind - 1].w[0]))) {\n+\t// subract 1 to make even\n+\tif (res.w[0]-- == 0) {\n+\t  res.w[1]--;\n+\t}\n+      }\n+    } else {\t// 22 <= ind - 1 <= 33\n+      shift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+      res.w[1] = 0;\n+      res.w[0] = P256.w[3] >> shift;\n+      fstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+      fstar.w[2] = P256.w[2];\n+      fstar.w[1] = P256.w[1];\n+      fstar.w[0] = P256.w[0];\n+      // fraction f* < 10^(-x) <=> midpoint\n+      // f* is in the right position to be compared with\n+      // 10^(-x) from __bid_ten2mk128[]\n+      if ((res.w[0] & 0x0000000000000001ull) &&\t// is result odd?\n+\t  fstar.w[3] == 0 && fstar.w[2] == 0\n+\t  && (fstar.w[1] < __bid_ten2mk128[ind - 1].w[1]\n+\t      || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t      && fstar.w[0] < __bid_ten2mk128[ind - 1].w[0]))) {\n+\t// subract 1 to make even\n+\tif (res.w[0]-- == 0) {\n+\t  res.w[1]--;\n+\t}\n+      }\n+    }\n+    res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+    BID_RETURN (res);\n+  } else {\t// if ((q + exp) < 0) <=> q < -exp\n+    // the result is +0 or -0\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_negative\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1_NORND(__bid128_round_integral_negative, x)\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo \n+  // (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  // UINT128 res is C* at first - represents up to 34 decimal digits ~ \n+  // 113 bits\n+  UINT256 fstar;\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull)\n+       || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+\t   && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent\n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  // if (exp <= -p) return -1.0 or +0.0\n+  if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffc000000000000ull == -34\n+    if (x_sign) {\n+      // if negative, return negative 1, because we know the coefficient\n+      // is non-zero (would have been caught above)\n+      res.w[1] = 0xb040000000000000ull;\n+      res.w[0] = 0x0000000000000001ull;\n+    } else {\n+      // if positive, return positive 0, because we know coefficient is\n+      // non-zero (would have been caught above)\n+      res.w[1] = 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x\n+  // determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  } else if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x' \n+    // (number of digits to be chopped off)\n+    // chop off ind digits from the lower part of C1 \n+    // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+    // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+    // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+    // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+    //tmp64 = C1.w[0];\n+    // if (ind <= 19) {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+    // } else {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+    //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+    // }\n+    // if (C1.w[0] < tmp64) C1.w[1]++;\n+    // if carry-out from C1.w[0], increment C1.w[1]\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 34\n+    // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 118 bits\n+    __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+    if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+      res.w[1] = P256.w[3];\n+      res.w[0] = P256.w[2];\n+      // if positive, the truncated value is already the correct result\n+      if (x_sign) {\t// if negative\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\t// redundant fstar.w[1] = P256.w[1];\n+\t// redundant fstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((P256.w[1] > __bid_ten2mk128[ind - 1].w[1])\n+\t    || (P256.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& (P256.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    } else if (ind - 1 <= 21) {\t// 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 0 <= shift <= 102\n+      res.w[1] = (P256.w[3] >> shift);\n+      res.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+      // if positive, the truncated value is already the correct result\n+      if (x_sign) {\t// if negative\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[2] || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    } else {\t// 22 <= ind - 1 <= 33\n+      shift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+      res.w[1] = 0;\n+      res.w[0] = P256.w[3] >> shift;\n+      // if positive, the truncated value is already the correct result\n+      if (x_sign) {\t// if negative\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with\n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[3] || fstar.w[2]\n+\t    || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    }\n+    res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+    BID_RETURN (res);\n+  } else {\t// if exp < 0 and q + exp <= 0\n+    if (x_sign) {\t// negative rounds down to -1.0\n+      res.w[1] = 0xb040000000000000ull;\n+      res.w[0] = 0x0000000000000001ull;\n+    } else {\t// positive rpunds down to +0.0\n+      res.w[1] = 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_positive\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1_NORND(__bid128_round_integral_positive, x)\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo \n+  // (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  // UINT128 res is C* at first - represents up to 34 decimal digits ~ \n+  // 113 bits\n+  UINT256 fstar;\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull)\n+       || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+\t   && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent \n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  // if (exp <= -p) return -0.0 or +1.0\n+  if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffc000000000000ull == -34\n+    if (x_sign) {\n+      // if negative, return negative 0, because we know the coefficient \n+      // is non-zero (would have been caught above)\n+      res.w[1] = 0xb040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+    } else {\n+      // if positive, return positive 1, because we know coefficient is \n+      // non-zero (would have been caught above)\n+      res.w[1] = 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000001ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x\n+  // determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  } else if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+    // need to shift right -exp digits from the coefficient; exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x' \n+    // (number of digits to be chopped off)\n+    // chop off ind digits from the lower part of C1 \n+    // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+    // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+    // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+    // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+    // tmp64 = C1.w[0];\n+    // if (ind <= 19) {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+    // } else {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+    //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+    // }\n+    // if (C1.w[0] < tmp64) C1.w[1]++;  \n+    // if carry-out from C1.w[0], increment C1.w[1]\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 34\n+    // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+    // C* = C1 * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 118 bits\n+    __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+    if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+      res.w[1] = P256.w[3];\n+      res.w[0] = P256.w[2];\n+      // if negative, the truncated value is already the correct result\n+      if (!x_sign) {\t// if positive\n+\t// redundant fstar.w[3] = 0;\n+\t// redundant fstar.w[2] = 0;\n+\t// redundant fstar.w[1] = P256.w[1]; \n+\t// redundant fstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif ((P256.w[1] > __bid_ten2mk128[ind - 1].w[1])\n+\t    || (P256.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t\t&& (P256.w[0] >= __bid_ten2mk128[ind - 1].w[0]))) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    } else if (ind - 1 <= 21) {\t// 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res.w[1] = (P256.w[3] >> shift);\n+      res.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+      // if negative, the truncated value is already the correct result\n+      if (!x_sign) {\t// if positive\n+\t// redundant fstar.w[3] = 0;\n+\tfstar.w[2] = P256.w[2] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[2] || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    } else {\t// 22 <= ind - 1 <= 33\n+      shift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+      res.w[1] = 0;\n+      res.w[0] = P256.w[3] >> shift;\n+      // if negative, the truncated value is already the correct result\n+      if (!x_sign) {\t// if positive\n+\tfstar.w[3] = P256.w[3] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[2] = P256.w[2];\n+\tfstar.w[1] = P256.w[1];\n+\tfstar.w[0] = P256.w[0];\n+\t// fraction f* > 10^(-x) <=> inexact\n+\t// f* is in the right position to be compared with \n+\t// 10^(-x) from __bid_ten2mk128[]\n+\tif (fstar.w[3] || fstar.w[2]\n+\t    || fstar.w[1] > __bid_ten2mk128[ind - 1].w[1]\n+\t    || (fstar.w[1] == __bid_ten2mk128[ind - 1].w[1]\n+\t    && fstar.w[0] >= __bid_ten2mk128[ind - 1].w[0])) {\n+\t  if (++res.w[0] == 0) {\n+\t    res.w[1]++;\n+\t  }\n+\t}\n+      }\n+    }\n+    res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+    BID_RETURN (res);\n+  } else {\t// if exp < 0 and q + exp <= 0\n+    if (x_sign) {\t// negative rounds up to -0.0\n+      res.w[1] = 0xb040000000000000ull;\n+      res.w[0] = 0x0000000000000000ull;\n+    } else {\t// positive rpunds up to +1.0\n+      res.w[1] = 0x3040000000000000ull;\n+      res.w[0] = 0x0000000000000001ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_zero\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1_NORND(__bid128_round_integral_zero, x)\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo\n+  // (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  // UINT128 res is C* at first - represents up to 34 decimal digits ~\n+  // 113 bits\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull)\n+       || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+\t   && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent\n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  // if (exp <= -p) return -0.0 or +0.0\n+  if (x_exp <= 0x2ffc000000000000ull) {\t// 0x2ffc000000000000ull == -34\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x\n+  // determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  } else if ((q + exp) > 0) {\t// exp < 0 and 1 <= -exp < q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+    // (number of digits to be chopped off)\n+    // chop off ind digits from the lower part of C1 \n+    // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+    // FOR ROUND_TO_ZERO, WE DON'T NEED TO ADD 1/2 ULP\n+    // FOR ROUND_TO_POSITIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF POSITIVE\n+    // FOR ROUND_TO_NEGATIVE_INFINITY, WE TRUNCATE, THEN ADD 1 IF NEGATIVE\n+    //tmp64 = C1.w[0];\n+    // if (ind <= 19) {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+    // } else {\n+    //   C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+    //   C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+    // }\n+    // if (C1.w[0] < tmp64) C1.w[1]++;  \n+    // if carry-out from C1.w[0], increment C1.w[1]\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 34\n+    // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 118 bits\n+    __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+    if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+      res.w[1] = P256.w[3];\n+      res.w[0] = P256.w[2];\n+    } else if (ind - 1 <= 21) {\t// 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res.w[1] = (P256.w[3] >> shift);\n+      res.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+    } else {\t// 22 <= ind - 1 <= 33\n+      shift = __bid_shiftright128[ind - 1] - 64;\t// 2 <= shift <= 38\n+      res.w[1] = 0;\n+      res.w[0] = P256.w[3] >> shift;\n+    }\n+    res.w[1] = x_sign | 0x3040000000000000ull | res.w[1];\n+    BID_RETURN (res);\n+  } else {\t// if exp < 0 and q + exp <= 0 the result is +0 or -0\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID128_round_integral_nearest_away\n+ ****************************************************************************/\n+\n+BID128_FUNCTION_ARG1_NORND(__bid128_round_integral_nearest_away, x)\n+\n+  UINT128 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp;\t\t\t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo \n+  // (all are UINT64)\n+  UINT64 tmp64;\n+  BID_UI64DOUBLE tmp1;\n+  unsigned int x_nr_bits;\n+  int q, ind, shift;\n+  UINT128 C1;\n+  // UINT128 res is C* at first - represents up to 34 decimal digits ~ \n+  // 113 bits\n+  // UINT256 fstar;\n+  UINT256 P256;\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) {\t// x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) {\t// x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return Quiet (SNaN)\n+\tres.w[1] = x.w[1] & 0xfdffffffffffffffull;\n+\tres.w[0] = x.w[0];\n+      } else {\t// x is QNaN\n+\t// return the input QNaN\n+\tres.w[1] = x.w[1];\n+\tres.w[0] = x.w[0];\n+      }\n+      BID_RETURN (res);\n+    } else {\t// x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) {\t// x is +inf\n+\t// return +inf\n+\tres.w[1] = 0x7800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      } else {\t// x is -inf \n+\t// return -inf\n+\tres.w[1] = 0xf800000000000000ull;\n+\tres.w[0] = 0x0000000000000000ull;\n+      }\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack x\n+  x_sign = x.w[1] & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  x_exp = x.w[1] & MASK_EXP;\t// biased and shifted left 49 bit positions\n+  C1.w[1] = x.w[1] & MASK_COEFF;\n+  C1.w[0] = x.w[0];\n+\n+  // test for non-canonical values:\n+  // - values whose encoding begins with x00, x01, or x10 and whose\n+  //   coefficient is larger than 10^34 -1, or\n+  // - values whose encoding begins with x1100, x1101, x1110 (if NaNs\n+  //   and infinitis were eliminated already this test is reduced to\n+  //   checking for x10x)\n+\n+  // test for non-canonical values of the argument x\n+  if ((((C1.w[1] > 0x0001ed09bead87c0ull)\n+       || ((C1.w[1] == 0x0001ed09bead87c0ull)\n+\t   && (C1.w[0] > 0x378d8e63ffffffffull)))\n+      && ((x.w[1] & 0x6000000000000000ull) != 0x6000000000000000ull))\n+      || ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull)) {\n+    x.w[1] = x.w[1] & 0x8000000000000000ull;\t// preserve the sign bit\n+    x.w[0] = 0;\n+    x_exp = 0x1820ull << 49;\n+    C1.w[1] = 0;\n+    C1.w[0] = 0;\n+  }\n+  // test for input equal to zero\n+  if ((C1.w[1] == 0x0ull) && (C1.w[0] == 0x0ull)) {\n+    // x is 0\n+    // return 0 preserving the sign bit and the preferred exponent\n+    // of MAX(Q(x), 0)\n+    if (x_exp <= (0x1820ull << 49)) {\n+      res.w[1] =\n+\t(x.w[1] & 0x8000000000000000ull) | 0x3040000000000000ull;\n+    } else {\n+      res.w[1] = x.w[1] & 0xfffe000000000000ull;\n+    }\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // x is not special and is not zero\n+\n+  // if (exp <= -(p+1)) return 0.0\n+  if (x_exp <= 0x2ffa000000000000ull) {\t// 0x2ffa000000000000ull == -35\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x\n+  //  determine first the nr. of bits in x\n+  if (C1.w[1] == 0) {\n+    if (C1.w[0] >= 0x0020000000000000ull) {\t// x >= 2^53\n+      // split the 64-bit value in two 32-bit halves to avoid rounding errors\n+      if (C1.w[0] >= 0x0000000100000000ull) {\t// x >= 2^32\n+\ttmp1.d = (double) (C1.w[0] >> 32);\t// exact conversion\n+\tx_nr_bits =\n+\t  33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      } else {\t// x < 2^32\n+\ttmp1.d = (double) (C1.w[0]);\t// exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+    } else {\t// if x < 2^53\n+      tmp1.d = (double) C1.w[0];\t// exact conversion\n+      x_nr_bits =\n+\t1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    }\n+  } else {\t// C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])\n+    tmp1.d = (double) C1.w[1];\t// exact conversion\n+    x_nr_bits =\n+      65 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+  }\n+  q = __bid_nr_digits[x_nr_bits - 1].digits;\n+  if (q == 0) {\n+    q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+    if (C1.w[1] > __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t|| (C1.w[1] == __bid_nr_digits[x_nr_bits - 1].threshold_hi\n+\t&& C1.w[0] >= __bid_nr_digits[x_nr_bits - 1].threshold_lo))\n+      q++;\n+  }\n+  exp = (x_exp >> 49) - 6176;\n+  if (exp >= 0) {\t// -exp <= 0\n+    // the argument is an integer already\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  } else if ((q + exp) >= 0) {\t// exp < 0 and 1 <= -exp <= q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 34; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 = C1 + 1/2 * 10^x where the result C1 fits in 127 bits\n+    tmp64 = C1.w[0];\n+    if (ind <= 19) {\n+      C1.w[0] = C1.w[0] + __bid_midpoint64[ind - 1];\n+    } else {\n+      C1.w[0] = C1.w[0] + __bid_midpoint128[ind - 20].w[0];\n+      C1.w[1] = C1.w[1] + __bid_midpoint128[ind - 20].w[1];\n+    }\n+    if (C1.w[0] < tmp64)\n+      C1.w[1]++;\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 34\n+    // kx = 10^(-x) = __bid_ten2mk128[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 118 bits\n+    __mul_128x128_to_256 (P256, C1, __bid_ten2mk128[ind - 1]);\n+    // the top Ex bits of 10^(-x) are T* = __bid_ten2mk128trunc[ind], e.g.\n+    // if x=1, T*=__bid_ten2mk128trunc[0]=0x19999999999999999999999999999999\n+    // if (0 < f* < 10^(-x)) then the result is a midpoint\n+    //   if floor(C*) is even then C* = floor(C*) - logical right\n+    //       shift; C* has p decimal digits, correct by Prop. 1)\n+    //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+    //       shift; C* has p decimal digits, correct by Pr. 1)\n+    // else\n+    //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // n = C* * 10^(e+x)\n+\n+    // shift right C* by Ex-128 = __bid_shiftright128[ind]\n+    if (ind - 1 <= 2) {\t// 0 <= ind - 1 <= 2 => shift = 0\n+      res.w[1] = P256.w[3];\n+      res.w[0] = P256.w[2];\n+    } else if (ind - 1 <= 21) {\t// 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res.w[0] = (P256.w[3] << (64 - shift)) | (P256.w[2] >> shift);\n+      res.w[1] = (P256.w[3] >> shift);\n+    } else {\t// 22 <= ind - 1 <= 33\n+      shift = __bid_shiftright128[ind - 1];\t// 2 <= shift <= 38\n+      res.w[1] = 0;\n+      res.w[0] = (P256.w[3] >> (shift - 64));\t// 2 <= shift - 64 <= 38\n+    }\n+    // if the result was a midpoint, it was already rounded away from zero\n+    res.w[1] |= x_sign | 0x3040000000000000ull;\n+    BID_RETURN (res);\n+  } else {\t// if ((q + exp) < 0) <=> q < -exp\n+    // the result is +0 or -0\n+    res.w[1] = x_sign | 0x3040000000000000ull;\n+    res.w[0] = 0x0000000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}"}, {"sha": "8f85d3c4087e400df85915b98ea10a4ff356f830", "filename": "libgcc/config/libbid/bid128_scalb.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_scalb.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+#define DECIMAL_EXPONENT_BIAS_128 6176\n+#define MAX_DECIMAL_EXPONENT_128  12287\n+\n+\n+\n+BID128_FUNCTION_ARG128_ARGTYPE2(__bid128_scalb, x, int, n)\n+\n+UINT128 CX, CX2, CX8, res;\n+  UINT64 sign_x;\n+  int exponent_x, rmode;\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    // x is Inf. or NaN or 0\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    BID_RETURN (res);\n+  }\n+\n+  exponent_x += n;\n+\n+  if ((UINT32) exponent_x <= MAX_DECIMAL_EXPONENT_128) {\n+    get_BID128_very_fast (&res, sign_x, exponent_x, CX);\n+    BID_RETURN (res);\n+  }\n+  // check for overflow\n+  if (exponent_x > MAX_DECIMAL_EXPONENT_128) {\n+    if (CX.w[1] < 0x314dc6448d93ull) {\n+      // try to normalize coefficient\n+      do {\n+\tCX8.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n+\tCX8.w[0] = CX.w[0] << 3;\n+\tCX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+\tCX2.w[0] = CX.w[0] << 1;\n+\t__add_128_128 (CX, CX2, CX8);\n+\n+\texponent_x--;\n+      }\n+      while (CX.w[1] < 0x314dc6448d93ull\n+\t     && exponent_x > MAX_DECIMAL_EXPONENT_128);\n+\n+      if (exponent_x <= MAX_DECIMAL_EXPONENT_128) {\n+\tget_BID128_very_fast (&res, sign_x, exponent_x, CX);\n+\tBID_RETURN (res);\n+      }\n+    }\n+  }\n+  // exponent < 0\n+  // the BID pack routine will round the coefficient\n+  rmode = rnd_mode;\n+  get_BID128 (&res, sign_x, exponent_x, CX, (unsigned int *) &rmode,\n+\t      pfpsf);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "bae395f60d343eeab590aa71a997cb7b61f3be87", "filename": "libgcc/config/libbid/bid128_sqrt.c", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_sqrt.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,278 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"sqrt_macros.h\"\n+\n+BID128_FUNCTION_ARG1(__bid128_sqrt, x)\n+\n+  UINT256 M256, C256, C4, C8;\n+  UINT128 CX, CX1, CX2, A10, S2, T128, TP128, CS, CSM, res;\n+  UINT64 sign_x, Carry;\n+  SINT64 D;\n+  int_float fx, f64;\n+  int exponent_x = 0, bin_expon_cx;\n+  int digits, scale, exponent_q;\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {\n+    res.w[1] = x.w[1];\n+    res.w[0] = x.w[0];\n+    // NaN ?\n+    if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((x.w[1] & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\t  res.w[1] &= QUIET_MASK64;\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      if (sign_x) {\n+\t// -Inf, return NaN\n+\tres.w[1] = 0x7c00000000000000ull;\n+#ifdef SET_STATUS_FLAGS\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      }\n+      BID_RETURN (res);\n+    }\n+    // x is 0 otherwise\n+\n+    res.w[1] =\n+      sign_x |\n+      ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1) <<\n+       49);\n+    BID_RETURN (res);\n+  }\n+  if (sign_x) {\n+    res.w[1] = 0x7c00000000000000ull;\n+    res.w[0] = 0;\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    BID_RETURN (res);\n+  }\n+  // 2^64\n+  f64.i = 0x5f800000;\n+\n+  // fx ~ CX\n+  fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+  bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+  digits = __bid_estimate_decimal_digits[bin_expon_cx];\n+\n+  A10 = CX;\n+  if (exponent_x & 1) {\n+    A10.w[1] = (CX.w[1] << 3) | (CX.w[0] >> 61);\n+    A10.w[0] = CX.w[0] << 3;\n+    CX2.w[1] = (CX.w[1] << 1) | (CX.w[0] >> 63);\n+    CX2.w[0] = CX.w[0] << 1;\n+    __add_128_128 (A10, A10, CX2);\n+  }\n+\n+  CS.w[0] = short_sqrt128 (A10);\n+  CS.w[1] = 0;\n+  // check for exact result\n+  if (CS.w[0] * CS.w[0] == A10.w[0]) {\n+    __mul_64x64_to_128_fast (S2, CS.w[0], CS.w[0]);\n+    if (S2.w[1] == A10.w[1])\t// && S2.w[0]==A10.w[0])\n+    {\n+      get_BID128_very_fast (&res, 0,\n+\t\t\t    (exponent_x +\n+\t\t\t     DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n+      BID_RETURN (res);\n+    }\n+  }\n+  // get number of digits in CX\n+  D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n+  if (D > 0\n+      || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+    digits++;\n+\n+  // if exponent is odd, scale coefficient by 10\n+  scale = 67 - digits;\n+  exponent_q = exponent_x - scale;\n+  scale += (exponent_q & 1);\t// exp. bias is even\n+\n+  if (scale > 38) {\n+    T128 = __bid_power10_table_128[scale - 37];\n+    __mul_128x128_low (CX1, CX, T128);\n+\n+    TP128 = __bid_power10_table_128[37];\n+    __mul_128x128_to_256 (C256, CX1, TP128);\n+  } else {\n+    T128 = __bid_power10_table_128[scale];\n+    __mul_128x128_to_256 (C256, CX, T128);\n+  }\n+\n+\n+  // 4*C256\n+  C4.w[3] = (C256.w[3] << 2) | (C256.w[2] >> 62);\n+  C4.w[2] = (C256.w[2] << 2) | (C256.w[1] >> 62);\n+  C4.w[1] = (C256.w[1] << 2) | (C256.w[0] >> 62);\n+  C4.w[0] = C256.w[0] << 2;\n+\n+  long_sqrt128 (&CS, C256);\n+\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  if (!((rnd_mode) & 3)) {\n+#endif\n+#endif\n+    // compare to midpoints\n+    CSM.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+    CSM.w[0] = (CS.w[0] + CS.w[0]) | 1;\n+    // CSM^2\n+    //__mul_128x128_to_256(M256, CSM, CSM);\n+    __sqr128_to_256 (M256, CSM);\n+\n+    if (C4.w[3] > M256.w[3]\n+\t|| (C4.w[3] == M256.w[3]\n+\t    && (C4.w[2] > M256.w[2]\n+\t\t|| (C4.w[2] == M256.w[2]\n+\t\t    && (C4.w[1] > M256.w[1]\n+\t\t\t|| (C4.w[1] == M256.w[1]\n+\t\t\t    && C4.w[0] > M256.w[0])))))) {\n+      // round up\n+      CS.w[0]++;\n+      if (!CS.w[0])\n+\tCS.w[1]++;\n+    } else {\n+      C8.w[1] = (CS.w[1] << 3) | (CS.w[0] >> 61);\n+      C8.w[0] = CS.w[0] << 3;\n+      // M256 - 8*CSM\n+      __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+      __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+      __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+      M256.w[3] = M256.w[3] - Carry;\n+\n+      // if CSM' > C256, round up\n+      if (M256.w[3] > C4.w[3]\n+\t  || (M256.w[3] == C4.w[3]\n+\t      && (M256.w[2] > C4.w[2]\n+\t\t  || (M256.w[2] == C4.w[2]\n+\t\t      && (M256.w[1] > C4.w[1]\n+\t\t\t  || (M256.w[1] == C4.w[1]\n+\t\t\t      && M256.w[0] > C4.w[0])))))) {\n+\t// round down\n+\tif (!CS.w[0])\n+\t  CS.w[1]--;\n+\tCS.w[0]--;\n+      }\n+    }\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  } else {\n+    __sqr128_to_256 (M256, CS);\n+    C8.w[1] = (CS.w[1] << 1) | (CS.w[0] >> 63);\n+    C8.w[0] = CS.w[0] << 1;\n+    if (M256.w[3] > C256.w[3]\n+\t|| (M256.w[3] == C256.w[3]\n+\t    && (M256.w[2] > C256.w[2]\n+\t\t|| (M256.w[2] == C256.w[2]\n+\t\t    && (M256.w[1] > C256.w[1]\n+\t\t\t|| (M256.w[1] == C256.w[1]\n+\t\t\t    && M256.w[0] > C256.w[0])))))) {\n+      __sub_borrow_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+      __sub_borrow_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+      __sub_borrow_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+      M256.w[3] = M256.w[3] - Carry;\n+      M256.w[0]++;\n+      if (!M256.w[0]) {\n+\tM256.w[1]++;\n+\tif (!M256.w[1]) {\n+\t  M256.w[2]++;\n+\t  if (!M256.w[2])\n+\t    M256.w[3]++;\n+\t}\n+      }\n+\n+      if (!CS.w[0])\n+\tCS.w[1]--;\n+      CS.w[0]--;\n+\n+      if (M256.w[3] > C256.w[3]\n+\t  || (M256.w[3] == C256.w[3]\n+\t      && (M256.w[2] > C256.w[2]\n+\t\t  || (M256.w[2] == C256.w[2]\n+\t\t      && (M256.w[1] > C256.w[1]\n+\t\t\t  || (M256.w[1] == C256.w[1]\n+\t\t\t      && M256.w[0] > C256.w[0])))))) {\n+\n+\tif (!CS.w[0])\n+\t  CS.w[1]--;\n+\tCS.w[0]--;\n+      }\n+    }\n+\n+    else {\n+      __add_carry_out (M256.w[0], Carry, M256.w[0], C8.w[0]);\n+      __add_carry_in_out (M256.w[1], Carry, M256.w[1], C8.w[1], Carry);\n+      __add_carry_in_out (M256.w[2], Carry, M256.w[2], 0, Carry);\n+      M256.w[3] = M256.w[3] + Carry;\n+      M256.w[0]++;\n+      if (!M256.w[0]) {\n+\tM256.w[1]++;\n+\tif (!M256.w[1]) {\n+\t  M256.w[2]++;\n+\t  if (!M256.w[2])\n+\t    M256.w[3]++;\n+\t}\n+      }\n+      if (M256.w[3] < C256.w[3]\n+\t  || (M256.w[3] == C256.w[3]\n+\t      && (M256.w[2] < C256.w[2]\n+\t\t  || (M256.w[2] == C256.w[2]\n+\t\t      && (M256.w[1] < C256.w[1]\n+\t\t\t  || (M256.w[1] == C256.w[1]\n+\t\t\t      && M256.w[0] <= C256.w[0])))))) {\n+\n+\tCS.w[0]++;\n+\tif (!CS.w[0])\n+\t  CS.w[1]++;\n+      }\n+    }\n+    // RU?\n+    if ((rnd_mode) == ROUNDING_UP) {\n+      CS.w[0]++;\n+      if (!CS.w[0])\n+\tCS.w[1]++;\n+    }\n+\n+  }\n+#endif\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+#endif\n+  get_BID128_fast (&res, 0,\n+\t\t   (exponent_q + DECIMAL_EXPONENT_BIAS_128) >> 1, CS);\n+  BID_RETURN (res);\n+}"}, {"sha": "62399d32120d21dad4457012ca82aecb39fd4de1", "filename": "libgcc/config/libbid/bid128_to_int32.c", "status": "added", "additions": 3657, "deletions": 0, "changes": 3657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int32.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "4bbfb8cb7ceddc2855c93e36b6191d8ad909fe12", "filename": "libgcc/config/libbid/bid128_to_int64.c", "status": "added", "additions": 2979, "deletions": 0, "changes": 2979, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_int64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "ea94979b90bdf729305cb621f10d037f895db31c", "filename": "libgcc/config/libbid/bid128_to_string.c", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_string.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,260 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID128_to_string\n+ ****************************************************************************/\n+\n+#include <stdio.h>\n+#include \"bid_internal.h\"\n+#include \"bid128_2_str.h\"\n+#include \"bid128_2_str_macros.h\"\n+\n+extern int __bid128_coeff_2_string (UINT64 X_hi, UINT64 X_lo,\n+\t\t\t\t  char *char_ptr);\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid128_to_string (char *str,\n+\t\t  UINT128 *\n+\t\t  px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t  _EXC_INFO_PARAM) {\n+  UINT128 x;\n+#else\n+\n+void\n+__bid128_to_string (char *str,\n+\t\t  UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t  _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  int ind;\n+  UINT128 C1;\n+  unsigned int k = 0; // pointer in the string\n+  unsigned int d0, d123;\n+  UINT64 HI_18Dig, LO_18Dig, Tmp;\n+  UINT32 MiDi[12], *ptr;\n+  char *c_ptr_start, *c_ptr;\n+  int midi_ind, k_lcv, len;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+#endif\n+\n+  // check for NaN or Infinity\n+  if ((x.w[1] & MASK_SPECIAL) == MASK_SPECIAL) {\n+    // x is special\n+    if ((x.w[1] & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x.w[1] & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\tstr[0] = 'S';\n+\tstr[1] = 'N';\n+\tstr[2] = 'a';\n+\tstr[3] = 'N';\n+\tstr[4] = '\\0';\n+      } else { // x is QNaN\n+\tstr[0] = 'Q';\n+\tstr[1] = 'N';\n+\tstr[2] = 'a';\n+\tstr[3] = 'N';\n+\tstr[4] = '\\0';\n+      }\n+    } else { // x is not a NaN, so it must be infinity\n+      if ((x.w[1] & MASK_SIGN) == 0x0ull) { // x is +inf\n+\tstr[0] = '+';\n+\tstr[1] = 'I';\n+\tstr[2] = 'n';\n+\tstr[3] = 'f';\n+\tstr[4] = '\\0';\n+      } else { // x is -inf \n+\tstr[0] = '-';\n+\tstr[1] = 'I';\n+\tstr[2] = 'n';\n+\tstr[3] = 'f';\n+\tstr[4] = '\\0';\n+      }\n+    }\n+    return;\n+  } else if (((x.w[1] & MASK_COEFF) == 0x0ull) && (x.w[0] == 0x0ull)) {\n+    // x is 0\n+    len = 0;\n+\n+    //determine if +/-\n+    if (x.w[1] & MASK_SIGN)\n+      str[len++] = '-';\n+    else\n+      str[len++] = '+';\n+    str[len++] = '0';\n+    str[len++] = 'E';\n+\n+    // extract the exponent and print\n+    exp = (int) (((x.w[1] & MASK_EXP) >> 49) - 6176);\n+    if (exp >= 0) {\n+      str[len++] = '+';\n+      len += sprintf (str + len, \"%u\", exp);// should not use sprintf (should \n+      // use sophisticated algorithm, since we know range of exp is limited)\n+      str[len++] = '\\0';\n+    } else {\n+      len += sprintf (str + len, \"%d\", exp);// should not use sprintf (should \n+      // use sophisticated algorithm, since we know range of exp is limited)\n+      str[len++] = '\\0';\n+    }\n+    return;\n+  } else { // x is not special and is not zero\n+    // unpack x\n+    x_sign = x.w[1] & MASK_SIGN;// 0 for positive, MASK_SIGN for negative\n+    x_exp = x.w[1] & MASK_EXP;// biased and shifted left 49 bit positions\n+    C1.w[1] = x.w[1] & MASK_COEFF;\n+    C1.w[0] = x.w[0];\n+    exp = (x_exp >> 49) - 6176;\n+\n+    // determine sign's representation as a char\n+    if (x_sign)\n+      str[k++] = '-';// negative number\n+    else\n+      str[k++] = '+';// positive number\n+\n+    // determine coefficient's representation as a decimal string\n+\n+    // if zero or non-canonical, set coefficient to '0'\n+    if ((C1.w[1] > 0x0001ed09bead87c0ull) || \n+        (C1.w[1] == 0x0001ed09bead87c0ull && \n+        (C1.w[0] > 0x378d8e63ffffffffull)) || \n+        ((x.w[1] & 0x6000000000000000ull) == 0x6000000000000000ull) || \n+        ((C1.w[1] == 0) && (C1.w[0] == 0))) {\n+      str[k++] = '0';\n+    } else {\n+      /* ****************************************************\n+         This takes a bid coefficient in C1.w[1],C1.w[0] \n+         and put the converted character sequence at location \n+         starting at &(str[k]). The function returns the number\n+         of MiDi returned. Note that the character sequence \n+         does not have leading zeros EXCEPT when the input is of\n+         zero value. It will then output 1 character '0'\n+         The algorithm essentailly tries first to get a sequence of\n+         Millenial Digits \"MiDi\" and then uses table lookup to get the\n+         character strings of these MiDis.\n+         **************************************************** */\n+      /* Algorithm first decompose possibly 34 digits in hi and lo\n+         18 digits. (The high can have at most 16 digits). It then\n+         uses macro that handle 18 digit portions.\n+         The first step is to get hi and lo such that\n+         2^(64) C1.w[1] + C1.w[0] = hi * 10^18  + lo,   0 <= lo < 10^18.\n+         We use a table lookup method to obtain the hi and lo 18 digits.\n+         [C1.w[1],C1.w[0]] = c_8 2^(107) + c_7 2^(101) + ... + c_0 2^(59) + d\n+         where 0 <= d < 2^59 and each c_j has 6 bits. Because d fits in\n+         18 digits,  we set hi = 0, and lo = d to begin with.\n+         We then retrieve from a table, for j = 0, 1, ..., 8\n+         that gives us A and B where c_j 2^(59+6j) = A * 10^18 + B.\n+         hi += A ; lo += B; After each accumulation into lo, we normalize \n+         immediately. So at the end, we have the decomposition as we need. */\n+\n+      Tmp = C1.w[0] >> 59;\n+      LO_18Dig = (C1.w[0] << 5) >> 5;\n+      Tmp += (C1.w[1] << 5);\n+      HI_18Dig = 0;\n+      k_lcv = 0;\n+      // Tmp = {C1.w[1]{49:0}, C1.w[0]{63:59}}\n+      // Lo_18Dig = {C1.w[0]{58:0}}\n+\n+      while (Tmp) {\n+\tmidi_ind = (int) (Tmp & 0x000000000000003FLL);\n+\tmidi_ind <<= 1;\n+\tTmp >>= 6;\n+\tHI_18Dig += __bid_mod10_18_tbl[k_lcv][midi_ind++];\n+\tLO_18Dig += __bid_mod10_18_tbl[k_lcv++][midi_ind];\n+\t__L0_Normalize_10to18 (HI_18Dig, LO_18Dig);\n+      }\n+      ptr = MiDi;\n+      if (HI_18Dig == 0LL) {\n+\t__L1_Split_MiDi_6_Lead (LO_18Dig, ptr);\n+      } else {\n+\t__L1_Split_MiDi_6_Lead (HI_18Dig, ptr);\n+\t__L1_Split_MiDi_6 (LO_18Dig, ptr);\n+      }\n+      len = ptr - MiDi;\n+      c_ptr_start = &(str[k]);\n+      c_ptr = c_ptr_start;\n+\n+      /* now convert the MiDi into character strings */\n+      __L0_MiDi2Str_Lead (MiDi[0], c_ptr);\n+      for (k_lcv = 1; k_lcv < len; k_lcv++) {\n+\t__L0_MiDi2Str (MiDi[k_lcv], c_ptr);\n+      }\n+      k = k + (c_ptr - c_ptr_start);\n+    }\n+\n+    // print E and sign of exponent\n+    str[k++] = 'E';\n+    if (exp < 0) {\n+      exp = -exp;\n+      str[k++] = '-';\n+    } else {\n+      str[k++] = '+';\n+    }\n+\n+    // determine exponent's representation as a decimal string\n+    // d0 = exp / 1000;\n+    // Use Property 1\n+    d0 = (exp * 0x418a) >> 24;// 0x418a * 2^-24 = (10^(-3))RP,15\n+    d123 = exp - 1000 * d0;\n+\n+    if (d0) { // 1000 <= exp <= 6144 => 4 digits to return\n+      str[k++] = d0 + 0x30;// ASCII for decimal digit d0\n+      ind = 3 * d123;\n+      str[k++] = __bid_char_table3[ind];\n+      str[k++] = __bid_char_table3[ind + 1];\n+      str[k++] = __bid_char_table3[ind + 2];\n+    } else { // 0 <= exp <= 999 => d0 = 0\n+      if (d123 < 10) { // 0 <= exp <= 9 => 1 digit to return\n+\tstr[k++] = d123 + 0x30;// ASCII\n+      } else if (d123 < 100) { // 10 <= exp <= 99 => 2 digits to return\n+\tind = 2 * (d123 - 10);\n+\tstr[k++] = __bid_char_table2[ind];\n+\tstr[k++] = __bid_char_table2[ind + 1];\n+      } else { // 100 <= exp <= 999 => 3 digits to return\n+\tind = 3 * d123;\n+\tstr[k++] = __bid_char_table3[ind];\n+\tstr[k++] = __bid_char_table3[ind + 1];\n+\tstr[k++] = __bid_char_table3[ind + 2];\n+      }\n+    }\n+    str[k] = '\\0';\n+\n+  }\n+  return;\n+\n+}"}, {"sha": "b6ea47948f90d6a062cfd3bbefa67e300e6465b0", "filename": "libgcc/config/libbid/bid128_to_uint32.c", "status": "added", "additions": 3561, "deletions": 0, "changes": 3561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint32.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "de6fd60e29500eb6a6dd90625efa860a05a49734", "filename": "libgcc/config/libbid/bid128_to_uint64.c", "status": "added", "additions": 3382, "deletions": 0, "changes": 3382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid128_to_uint64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "1d47a5f519c1576337473310b929f549323209dd", "filename": "libgcc/config/libbid/bid32_to_bid128.c", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid128.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,227 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#define BID_128RES\n+#include \"bid_internal.h\"\n+\n+/*\n+ * Takes a BID32 as input and converts it to a BID128 and returns it.\n+ */\n+TYPE0_FUNCTION_ARGTYPE1_NORND(UINT128, __bid32_to_bid128, UINT32, x)\n+\n+  UINT128 new_coeff, res;\n+  UINT32 sign_x;\n+  int exponent_x = 0;\n+  UINT32 coefficient_x = 0;\n+\n+  if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    if (((x) & 0x78000000) == 0x78000000) {\n+      res.w[0] = 0;\n+      res.w[1] = ((UINT64) (x)) << 32;\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+  new_coeff.w[0] = coefficient_x;\n+  new_coeff.w[1] = 0;\n+  get_BID128_very_fast (&res, ((UINT64) sign_x) << 32,\n+\t\t\texponent_x + DECIMAL_EXPONENT_BIAS_128 -\n+\t\t\tDECIMAL_EXPONENT_BIAS_32, new_coeff);\n+  BID_RETURN (res);\n+} // convert_bid32_to_bid128\n+\n+\n+/*\n+ * Takes a BID128 as input and converts it to a BID32 and returns it.\n+ */\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid128_to_bid32 (UINT32 * pres,\n+\t\t UINT128 *\n+\t\t px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t _EXC_INFO_PARAM) {\n+  UINT128 x = *px;\n+#else\n+\n+UINT32\n+__bid128_to_bid32 (UINT128 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CX, T128, TP128, Qh, Ql, Qh1, Stemp, Tmp, Tmp1;\n+  UINT64 sign_x, carry, cy;\n+  SINT64 D;\n+  UINT32 res;\n+  int_float f64, fx;\n+  int exponent_x = 0, extra_digits, amount, bin_expon_cx;\n+  unsigned rmode, status;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+#endif\n+\n+  BID_SWAP128(x);\n+  // unpack arguments, check for NaN or Infinity or 0\n+  if (!unpack_BID128 (&sign_x, &exponent_x, &CX, &x)) {\n+    if (((x.w[1]) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      res = ((UINT32) (x.w[1] >> 32)) & 0xfc000000;\n+      BID_RETURN_VAL (res);\n+    }\n+    // x is 0\n+    amount =\n+      exponent_x - DECIMAL_EXPONENT_BIAS_128 + DECIMAL_EXPONENT_BIAS_32;\n+    if (((unsigned) amount) > DECIMAL_MAX_EXPON_32) {\n+      sign_x >>= 32;\n+      if (amount < 0)\n+\tres = sign_x;\n+      res =\n+\tget_BID32 ((UINT32) (sign_x >> 32), DECIMAL_MAX_EXPON_32, 0,\n+\t\t   rnd_mode, pfpsf);\n+      BID_RETURN_VAL (res);\n+    }\n+  }\n+\n+  if (CX.w[1] || (CX.w[0] >= 10000000)) {\n+    // find number of digits in coefficient\n+    // 2^64\n+    f64.i = 0x5f800000;\n+    // fx ~ CX\n+    fx.d = (float) CX.w[1] * f64.d + (float) CX.w[0];\n+    bin_expon_cx = ((fx.i >> 23) & 0xff) - 0x7f;\n+    extra_digits = __bid_estimate_decimal_digits[bin_expon_cx] - 7;\n+    // scale = 38-__bid_estimate_decimal_digits[bin_expon_cx];\n+    D = CX.w[1] - __bid_power10_index_binexp_128[bin_expon_cx].w[1];\n+    if (D > 0 || (!D && CX.w[0] >= __bid_power10_index_binexp_128[bin_expon_cx].w[0]))\n+      extra_digits++;\n+\n+    exponent_x += extra_digits;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+    T128 = __bid_round_const_table_128[rmode][extra_digits];\n+    __add_carry_out (CX.w[0], carry, T128.w[0], CX.w[0]);\n+    CX.w[1] = CX.w[1] + T128.w[1] + carry;\n+\n+    TP128 = __bid_reciprocals10_128[extra_digits];\n+    __mul_128x128_full (Qh, Ql, CX, TP128);\n+    amount = __bid_recip_scale[extra_digits];\n+\n+    if (amount >= 64) {\n+      CX.w[0] = Qh.w[1] >> (amount - 64);\n+      CX.w[1] = 0;\n+    } else {\n+      __shr_128 (CX, Qh, amount);\n+    }\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    if (!(rnd_mode))\n+#endif\n+      if (CX.w[0] & 1) {\n+\t// check whether fractional part of initial_P/10^ed1 is exactly .5\n+\n+\t// get remainder\n+\t__shl_128_long (Qh1, Qh, (128 - amount));\n+\n+\tif (!Qh1.w[1] && !Qh1.w[0]\n+\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0]))) {\n+\t  CX.w[0]--;\n+\t}\n+      }\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+\n+    {\n+      status = INEXACT_EXCEPTION;\n+      // get remainder\n+      __shl_128_long (Qh1, Qh, (128 - amount));\n+\n+      switch (rmode) {\n+      case ROUNDING_TO_NEAREST:\n+      case ROUNDING_TIES_AWAY:\n+\t// test whether fractional part is 0\n+\tif (Qh1.w[1] == 0x8000000000000000ull && (!Qh1.w[0])\n+\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      case ROUNDING_DOWN:\n+      case ROUNDING_TO_ZERO:\n+\tif ((!Qh1.w[1]) && (!Qh1.w[0])\n+\t    && (Ql.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Ql.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t    && Ql.w[0] < __bid_reciprocals10_128[extra_digits].w[0])))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      default:\n+\t// round up\n+\t__add_carry_out (Stemp.w[0], cy, Ql.w[0],\n+\t\t\t __bid_reciprocals10_128[extra_digits].w[0]);\n+\t__add_carry_in_out (Stemp.w[1], carry, Ql.w[1],\n+\t\t\t    __bid_reciprocals10_128[extra_digits].w[1], cy);\n+\t__shr_128_long (Qh, Qh1, (128 - amount));\n+\tTmp.w[0] = 1;\n+\tTmp.w[1] = 0;\n+\t__shl_128_long (Tmp1, Tmp, amount);\n+\tQh.w[0] += carry;\n+\tif (Qh.w[0] < carry)\n+\t  Qh.w[1]++;\n+\tif (__unsigned_compare_ge_128 (Qh, Tmp1))\n+\t  status = EXACT_STATUS;\n+      }\n+\n+      if (status != EXACT_STATUS)\n+\t__set_status_flags (pfpsf, status);\n+    }\n+\n+#endif\n+\n+  }\n+\n+  res =\n+    get_BID32 ((UINT32) (sign_x >> 32),\n+\t       exponent_x - DECIMAL_EXPONENT_BIAS_128 +\n+\t       DECIMAL_EXPONENT_BIAS_32, CX.w[0], rnd_mode, pfpsf);\n+  BID_RETURN_VAL (res);\n+\n+}"}, {"sha": "46a76eb9df57bd15780067b4b863b11f40a05d78", "filename": "libgcc/config/libbid/bid32_to_bid64.c", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid32_to_bid64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,204 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+/*\n+ * Takes a BID32 as input and converts it to a BID64 and returns it.\n+ */\n+TYPE0_FUNCTION_ARGTYPE1_NORND(UINT64, __bid32_to_bid64, UINT32, x)\n+\n+  UINT64 res;\n+  UINT32 sign_x;\n+  int exponent_x = 0;\n+  UINT32 coefficient_x = 0;\n+\n+  if (!unpack_BID32 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // Inf, NaN, 0\n+    if (((x) & 0x78000000) == 0x78000000) {\n+      res = ((UINT64) (x)) << 32;\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+  res =\n+    very_fast_get_BID64_small_mantissa (((UINT64) sign_x) << 32,\n+\t\t\t\t\texponent_x +\n+\t\t\t\t\tDECIMAL_EXPONENT_BIAS -\n+\t\t\t\t\tDECIMAL_EXPONENT_BIAS_32,\n+\t\t\t\t\t(UINT64) coefficient_x);\n+  BID_RETURN (res);\n+} // convert_bid32_to_bid64\n+\n+\n+/*\n+ * Takes a BID64 as input and converts it to a BID32 and returns it.\n+ */\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_to_bid32 (UINT32 * pres,\n+\t\tUINT64 *\n+\t\tpx _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t_EXC_INFO_PARAM) {\n+  UINT64 x;\n+#else\n+\n+UINT32\n+__bid64_to_bid32 (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t_EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 Q;\n+  UINT64 sign_x, coefficient_x, remainder_h, carry, Stemp;\n+  UINT32 res;\n+  int_float tempx;\n+  int exponent_x, bin_expon_cx, extra_digits, rmode, amount;\n+  unsigned status=0;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity, 0\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    if (((x) & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      res = ((UINT32) ((x) >> 32)) & 0xfc000000;\n+      BID_RETURN (res);\n+    }\n+    exponent_x =\n+      exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_32;\n+    if (exponent_x < 0)\n+      exponent_x = 0;\n+    if (exponent_x > DECIMAL_MAX_EXPON_32)\n+      exponent_x = DECIMAL_MAX_EXPON_32;\n+    res = (sign_x >> 32) | (exponent_x << 23);\n+    BID_RETURN (res);\n+  }\n+\n+\texponent_x = exponent_x - DECIMAL_EXPONENT_BIAS + DECIMAL_EXPONENT_BIAS_32;\n+\n+  // check number of digits\n+  if (coefficient_x >= 10000000) {\n+    tempx.d = (float) coefficient_x;\n+    bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+    extra_digits = __bid_estimate_decimal_digits[bin_expon_cx] - 7;\n+    // add test for range\n+    if (coefficient_x >= __bid_power10_index_binexp[bin_expon_cx])\n+      extra_digits++;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+\n+    coefficient_x += __bid_round_const_table[rmode][extra_digits];\n+    exponent_x += extra_digits;\n+\tif((exponent_x<0) && (exponent_x + MAX_FORMAT_DIGITS_32 >= 0)) {\n+\t\textra_digits -= exponent_x;\n+\t\texponent_x = 0;\n+\t\tstatus = UNDERFLOW_EXCEPTION;\n+\t}\n+    __mul_64x64_to_128 (Q, coefficient_x,\n+\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\n+    // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+    amount = __bid_short_recip_scale[extra_digits];\n+\n+    coefficient_x = Q.w[1] >> amount;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    if (rmode == 0)\t//ROUNDING_TO_NEAREST\n+#endif\n+      if (coefficient_x & 1) {\n+\t// check whether fractional part of initial_P/10^extra_digits \n+        // is exactly .5\n+\n+\t// get remainder\n+\tremainder_h = Q.w[1] << (64 - amount);\n+\n+\tif (!remainder_h && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t  coefficient_x--;\n+      }\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+\n+    {\n+      status |= INEXACT_EXCEPTION;\n+      // get remainder\n+      remainder_h = Q.w[1] << (64 - amount);\n+\n+      switch (rmode) {\n+      case ROUNDING_TO_NEAREST:\n+      case ROUNDING_TIES_AWAY:\n+\t// test whether fractional part is 0\n+\tif (remainder_h == 0x8000000000000000ull\n+\t    && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      case ROUNDING_DOWN:\n+      case ROUNDING_TO_ZERO:\n+\tif (!remainder_h && (Q.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      default:\n+\t// round up\n+\t__add_carry_out (Stemp, carry, Q.w[0],\n+\t\t\t __bid_reciprocals10_64[extra_digits]);\n+\tif ((remainder_h >> (64 - amount)) + carry >=\n+\t    (((UINT64) 1) << amount))\n+\t  status = EXACT_STATUS;\n+      }\n+\n+      if (status != EXACT_STATUS)\n+\t__set_status_flags (pfpsf, status);\n+    }\n+\n+#endif\n+\n+  }\n+\n+  res =\n+    get_BID32 ((UINT32) (sign_x >> 32),\n+\t       exponent_x,\n+\t       coefficient_x, rnd_mode,\n+\t       pfpsf);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "0646f824c9b91937ff12860aa40b002f24e64e9f", "filename": "libgcc/config/libbid/bid64_add.c", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_add.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,605 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 add\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *   if(exponent_a < exponent_b)\n+ *       switch a, b\n+ *   diff_expon = exponent_a - exponent_b\n+ *   if(diff_expon > 16)\n+ *      return normalize(a)\n+ *   if(coefficient_a*10^diff_expon guaranteed below 2^62)\n+ *       S = sign_a*coefficient_a*10^diff_expon + sign_b*coefficient_b\n+ *       if(|S|<10^16)\n+ *           return get_BID64(sign(S),exponent_b,|S|)\n+ *       else\n+ *          determine number of extra digits in S (1, 2, or 3)\n+ *            return rounded result\n+ *   else // large exponent difference\n+ *       if(number_digits(coefficient_a*10^diff_expon) +/- 10^16)\n+ *          guaranteed the same as\n+ *          number_digits(coefficient_a*10^diff_expon) )\n+ *           S = normalize(coefficient_a + (sign_a^sign_b)*10^(16-diff_expon))\n+ *           corr = 10^16 + (sign_a^sign_b)*coefficient_b\n+ *           corr*10^exponent_b is rounded so it aligns with S*10^exponent_S\n+ *           return get_BID64(sign_a,exponent(S),S+rounded(corr))\n+ *       else\n+ *         add sign_a*coefficient_a*10^diff_expon, sign_b*coefficient_b\n+ *             in 128-bit integer arithmetic, then round to 16 decimal digits\n+ *           \n+ *\n+ ****************************************************************************/\n+\n+#include \"bid_internal.h\"\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void __bid64_add (UINT64 * pres, UINT64 * px,\n+\t\tUINT64 *\n+\t\tpy _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t_EXC_INFO_PARAM);\n+#else\n+UINT64 __bid64_add (UINT64 x,\n+\t\t      UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t      _EXC_MASKS_PARAM _EXC_INFO_PARAM);\n+#endif\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_sub (UINT64 * pres, UINT64 * px,\n+\t   UINT64 *\n+\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 y = *py;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  // check if y is not NaN\n+  if (((y & NAN_MASK64) != NAN_MASK64))\n+    y ^= 0x8000000000000000ull;\n+  __bid64_add (pres, px,\n+\t     &y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t     _EXC_INFO_ARG);\n+}\n+#else\n+\n+UINT64\n+__bid64_sub (UINT64 x,\n+\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  // check if y is not NaN\n+  if (((y & NAN_MASK64) != NAN_MASK64))\n+    y ^= 0x8000000000000000ull;\n+\n+  return __bid64_add (x,\n+\t\t    y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t    _EXC_INFO_ARG);\n+}\n+#endif\n+\n+\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_add (UINT64 * pres, UINT64 * px,\n+\t   UINT64 *\n+\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 x, y;\n+#else\n+\n+UINT64\n+__bid64_add (UINT64 x,\n+\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT128 CA, CT, CT_new;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, C64_new;\n+  UINT64 valid_x, valid_y;\n+  UINT64 res;\n+  UINT64 sign_a, sign_b, coefficient_a, coefficient_b, sign_s, sign_ab,\n+    rem_a;\n+  UINT64 saved_ca, saved_cb, C0_64, C64, remainder_h, T1, carry, tmp;\n+  int_double tempx;\n+  int exponent_x = 0, exponent_y = 0, exponent_a, exponent_b, diff_dec_expon;\n+  int bin_expon_ca, extra_digits, amount, scale_k, scale_ca;\n+  unsigned rmode, status;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  y = *py;\n+#endif\n+\n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n+  valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!valid_x) {\n+    // x is Inf. or NaN\n+\n+    // test if x is NaN\n+    if ((x & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t  || ((y & SNAN_MASK64) == SNAN_MASK64))\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = x & QUIET_MASK64;\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n+      // check if y is Inf\n+      if (((y & NAN_MASK64) == INFINITY_MASK64)) {\n+\tif (sign_x == (y & 0x8000000000000000ull)) {\n+\t  res = x;\n+\t  BID_RETURN (res);\n+\t}\n+\t// return NaN\n+\t{\n+#ifdef SET_STATUS_FLAGS\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\t  res = NAN_MASK64;\n+\t  BID_RETURN (res);\n+\t}\n+      }\n+      // check if y is NaN\n+      if (((y & NAN_MASK64) == NAN_MASK64)) {\n+\tres = y & QUIET_MASK64;\n+#ifdef SET_STATUS_FLAGS\n+\tif (((y & SNAN_MASK64) == SNAN_MASK64))\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (res);\n+      }\n+      // otherwise return +/-Inf\n+      {\n+\tres = x;\n+\tBID_RETURN (res);\n+      }\n+    }\n+    // x is 0\n+    {\n+      if ((y & SPECIAL_ENCODING_MASK64) == SPECIAL_ENCODING_MASK64) {\n+\texponent_y = ((UINT32) (y >> 51)) & 0x3ff;\n+\tif (exponent_y <= exponent_x) {\n+\t  res = y;\n+\t  BID_RETURN (res);\n+\t}\n+      } else if (y & 0x001fffffffffffffull) {\n+\texponent_y = ((UINT32) (y >> 53)) & 0x3ff;\n+\tif (exponent_y <= exponent_x) {\n+\t  res = y;\n+\t  BID_RETURN (res);\n+\t}\n+      }\n+    }\n+\n+  }\n+  if (!valid_y) {\n+    // y is Inf. or NaN?\n+    if (((y & INFINITY_MASK64) == INFINITY_MASK64)) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = y & QUIET_MASK64;\n+      BID_RETURN (res);\n+    }\n+    // y is 0\n+    if (!coefficient_x) { // x==0\n+      if (exponent_x <= exponent_y)\n+\tres = ((x << 1) >> 1);\n+      else\n+\tres = ((y << 1) >> 1);\n+      if (sign_x == sign_y)\n+\tres |= sign_x;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+      if (rnd_mode == ROUNDING_DOWN && sign_x != sign_y)\n+\tres |= 0x8000000000000000ull;\n+#endif\n+#endif\n+      BID_RETURN (res);\n+    } else if (exponent_y >= exponent_x) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+  }\n+  // sort arguments by exponent\n+  if (exponent_x < exponent_y) {\n+    sign_a = sign_y;\n+    exponent_a = exponent_y;\n+    coefficient_a = coefficient_y;\n+    sign_b = sign_x;\n+    exponent_b = exponent_x;\n+    coefficient_b = coefficient_x;\n+  } else {\n+    sign_a = sign_x;\n+    exponent_a = exponent_x;\n+    coefficient_a = coefficient_x;\n+    sign_b = sign_y;\n+    exponent_b = exponent_y;\n+    coefficient_b = coefficient_y;\n+  }\n+\n+  // exponent difference\n+  diff_dec_expon = exponent_a - exponent_b;\n+\n+  /* get binary coefficients of x and y */\n+\n+  //--- get number of bits in the coefficients of x and y ---\n+\n+  // version 2 (original)\n+  tempx.d = (double) coefficient_a;\n+  bin_expon_ca = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n+\n+  if (diff_dec_expon > MAX_FORMAT_DIGITS) {\n+    // normalize a to a 16-digit coefficient\n+\n+    scale_ca = __bid_estimate_decimal_digits[bin_expon_ca];\n+    if (coefficient_a >= __bid_power10_table_128[scale_ca].w[0])\n+      scale_ca++;\n+\n+    scale_k = 16 - scale_ca;\n+\n+    coefficient_a *= __bid_power10_table_128[scale_k].w[0];\n+\n+    diff_dec_expon -= scale_k;\n+    exponent_a -= scale_k;\n+\n+    /* get binary coefficients of x and y */\n+\n+    //--- get number of bits in the coefficients of x and y ---\n+    tempx.d = (double) coefficient_a;\n+    bin_expon_ca = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n+\n+    if (diff_dec_expon > MAX_FORMAT_DIGITS) {\n+#ifdef SET_STATUS_FLAGS\n+      if (coefficient_b) {\n+\t__set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+      }\n+#endif\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+      if (((rnd_mode) & 3) && coefficient_b)\t// not ROUNDING_TO_NEAREST\n+      {\n+\tswitch (rnd_mode) {\n+\tcase ROUNDING_DOWN:\n+\t  if (sign_b) {\n+\t    coefficient_a -= ((((SINT64) sign_a) >> 63) | 1);\n+\t    if (coefficient_a < 1000000000000000ull) {\n+\t      exponent_a--;\n+\t      coefficient_a = 9999999999999999ull;\n+\t    } else if (coefficient_a >= 10000000000000000ull) {\n+\t      exponent_a++;\n+\t      coefficient_a = 1000000000000000ull;\n+\t    }\n+\t  }\n+\t  break;\n+\tcase ROUNDING_UP:\n+\t  if (!sign_b) {\n+\t    coefficient_a += ((((SINT64) sign_a) >> 63) | 1);\n+\t    if (coefficient_a < 1000000000000000ull) {\n+\t      exponent_a--;\n+\t      coefficient_a = 9999999999999999ull;\n+\t    } else if (coefficient_a >= 10000000000000000ull) {\n+\t      exponent_a++;\n+\t      coefficient_a = 1000000000000000ull;\n+\t    }\n+\t  }\n+\t  break;\n+\tdefault:\t// RZ\n+\t  if (sign_a != sign_b) {\n+\t    coefficient_a--;\n+\t    if (coefficient_a < 1000000000000000ull) {\n+\t      exponent_a--;\n+\t      coefficient_a = 9999999999999999ull;\n+\t    }\n+\t  }\n+\t  break;\n+\t}\n+      } else\n+#endif\n+#endif\n+\t// check special case here\n+\tif ((coefficient_a == 1000000000000000ull)\n+\t    && (diff_dec_expon == MAX_FORMAT_DIGITS + 1)\n+\t    && (sign_a ^ sign_b) && (coefficient_b > 5000000000000000ull)) {\n+\tcoefficient_a = 9999999999999999ull;\n+\texponent_a--;\n+      }\n+\n+      res =\n+\tfast_get_BID64_check_OF (sign_a, exponent_a, coefficient_a,\n+\t\t\t\t rnd_mode, pfpsf);\n+      BID_RETURN (res);\n+    }\n+  }\n+  // test whether coefficient_a*10^(exponent_a-exponent_b)  may exceed 2^62\n+  if (bin_expon_ca + __bid_estimate_bin_expon[diff_dec_expon] < 60) {\n+    // coefficient_a*10^(exponent_a-exponent_b)<2^63\n+\n+    // multiply by 10^(exponent_a-exponent_b)\n+    coefficient_a *= __bid_power10_table_128[diff_dec_expon].w[0];\n+\n+    // sign mask\n+    sign_b = ((SINT64) sign_b) >> 63;\n+    // apply sign to coeff. of b\n+    coefficient_b = (coefficient_b + sign_b) ^ sign_b;\n+\n+    // apply sign to coefficient a\n+    sign_a = ((SINT64) sign_a) >> 63;\n+    coefficient_a = (coefficient_a + sign_a) ^ sign_a;\n+\n+    coefficient_a += coefficient_b;\n+    // get sign\n+    sign_s = ((SINT64) coefficient_a) >> 63;\n+    coefficient_a = (coefficient_a + sign_s) ^ sign_s;\n+    sign_s &= 0x8000000000000000ull;\n+\n+    // coefficient_a < 10^16 ?\n+    if (coefficient_a < __bid_power10_table_128[MAX_FORMAT_DIGITS].w[0]) {\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+      if (rnd_mode == ROUNDING_DOWN && (!coefficient_a)\n+\t  && sign_a != sign_b)\n+\tsign_s = 0x8000000000000000ull;\n+#endif\n+#endif\n+      res = very_fast_get_BID64 (sign_s, exponent_b, coefficient_a);\n+      BID_RETURN (res);\n+    }\n+    // otherwise rounding is necessary\n+\n+    // already know coefficient_a<10^19\n+    // coefficient_a < 10^17 ?\n+    if (coefficient_a < __bid_power10_table_128[17].w[0])\n+      extra_digits = 1;\n+    else if (coefficient_a < __bid_power10_table_128[18].w[0])\n+      extra_digits = 2;\n+    else\n+      extra_digits = 3;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_s && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+    coefficient_a += __bid_round_const_table[rmode][extra_digits];\n+\n+    // get P*(2^M[extra_digits])/10^extra_digits\n+    __mul_64x64_to_128 (CT, coefficient_a,\n+\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\n+    // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+    amount = __bid_short_recip_scale[extra_digits];\n+    C64 = CT.w[1] >> amount;\n+\n+  } else {\n+    // coefficient_a*10^(exponent_a-exponent_b) is large\n+    sign_s = sign_a;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_s && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+\n+    // check whether we can take faster path\n+    scale_ca = __bid_estimate_decimal_digits[bin_expon_ca];\n+\n+    sign_ab = sign_a ^ sign_b;\n+    sign_ab = ((SINT64) sign_ab) >> 63;\n+\n+    // T1 = 10^(16-diff_dec_expon)\n+    T1 = __bid_power10_table_128[16 - diff_dec_expon].w[0];\n+\n+    // get number of digits in coefficient_a\n+    if (coefficient_a >= __bid_power10_table_128[scale_ca].w[0]) {\n+      scale_ca++;\n+    }\n+\n+    scale_k = 16 - scale_ca;\n+\n+    // addition\n+    saved_ca = coefficient_a - T1;\n+    coefficient_a =\n+      (SINT64) saved_ca *(SINT64) __bid_power10_table_128[scale_k].w[0];\n+    extra_digits = diff_dec_expon - scale_k;\n+\n+    // apply sign\n+    saved_cb = (coefficient_b + sign_ab) ^ sign_ab;\n+    // add 10^16 and rounding constant\n+    coefficient_b =\n+      saved_cb + 10000000000000000ull +\n+      __bid_round_const_table[rmode][extra_digits];\n+\n+    // get P*(2^M[extra_digits])/10^extra_digits\n+    __mul_64x64_to_128 (CT, coefficient_b,\n+\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\n+    // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+    amount = __bid_short_recip_scale[extra_digits];\n+    C0_64 = CT.w[1] >> amount;\n+\n+    // result coefficient \n+    C64 = C0_64 + coefficient_a;\n+    // filter out difficult (corner) cases\n+    // this test ensures the number of digits in coefficient_a does not change \n+    // after adding (the appropriately scaled and rounded) coefficient_b\n+    if ((UINT64) (C64 - 1000000000000000ull - 1) > 9000000000000000ull - 2) {\n+      if (C64 >= 10000000000000000ull) {\n+\t// result has more than 16 digits\n+\tif (!scale_k) {\n+\t  // must divide coeff_a by 10\n+\t  saved_ca = saved_ca + T1;\n+\t  __mul_64x64_to_128 (CA, saved_ca, 0x3333333333333334ull); \n+              //__bid_reciprocals10_64[1]);\n+\t  coefficient_a = CA.w[1] >> 1;\n+\t  rem_a =\n+\t    saved_ca - (coefficient_a << 3) - (coefficient_a << 1);\n+\t  coefficient_a = coefficient_a - T1;\n+\n+\t  saved_cb += rem_a * __bid_power10_table_128[diff_dec_expon].w[0];\n+\t} else\n+\t  coefficient_a =\n+\t    (SINT64) (saved_ca - T1 -\n+\t\t      (T1 << 3)) * (SINT64) __bid_power10_table_128[scale_k -\n+\t\t\t\t\t\t\t      1].w[0];\n+\n+\textra_digits++;\n+\tcoefficient_b =\n+\t  saved_cb + 100000000000000000ull +\n+\t  __bid_round_const_table[rmode][extra_digits];\n+\n+\t// get P*(2^M[extra_digits])/10^extra_digits\n+\t__mul_64x64_to_128 (CT, coefficient_b,\n+\t\t\t    __bid_reciprocals10_64[extra_digits]);\n+\n+\t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+\tamount = __bid_short_recip_scale[extra_digits];\n+\tC0_64 = CT.w[1] >> amount;\n+\n+\t// result coefficient \n+\tC64 = C0_64 + coefficient_a;\n+      } else if (C64 <= 1000000000000000ull) {\n+\t// less than 16 digits in result\n+\tcoefficient_a =\n+\t  (SINT64) saved_ca *(SINT64) __bid_power10_table_128[scale_k +\n+\t\t\t\t\t\t\t1].w[0];\n+\t//extra_digits --;\n+\texponent_b--;\n+\tcoefficient_b =\n+\t  (saved_cb << 3) + (saved_cb << 1) + 100000000000000000ull +\n+\t  __bid_round_const_table[rmode][extra_digits];\n+\n+\t// get P*(2^M[extra_digits])/10^extra_digits\n+\t__mul_64x64_to_128 (CT_new, coefficient_b,\n+\t\t\t    __bid_reciprocals10_64[extra_digits]);\n+\n+\t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+\tamount = __bid_short_recip_scale[extra_digits];\n+\tC0_64 = CT_new.w[1] >> amount;\n+\n+\t// result coefficient \n+\tC64_new = C0_64 + coefficient_a;\n+\tif (C64_new < 10000000000000000ull) {\n+\t  C64 = C64_new;\n+#ifdef SET_STATUS_FLAGS\n+\t  CT = CT_new;\n+#endif\n+\t} else\n+\t  exponent_b++;\n+      }\n+\n+    }\n+\n+  }\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+  if (rmode == 0)\t//ROUNDING_TO_NEAREST\n+#endif\n+    if (C64 & 1) {\n+      // check whether fractional part of initial_P/10^extra_digits is \n+      // exactly .5\n+      // this is the same as fractional part of \n+      //      (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n+\n+      // get remainder\n+      remainder_h = CT.w[1] << (64 - amount);\n+\n+      // test whether fractional part is 0\n+      if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits])) {\n+\tC64--;\n+      }\n+    }\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+  status = INEXACT_EXCEPTION;\n+\n+  // get remainder\n+  remainder_h = CT.w[1] << (64 - amount);\n+\n+  switch (rmode) {\n+  case ROUNDING_TO_NEAREST:\n+  case ROUNDING_TIES_AWAY:\n+    // test whether fractional part is 0\n+    if ((remainder_h == 0x8000000000000000ull)\n+\t&& (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+      status = EXACT_STATUS;\n+    break;\n+  case ROUNDING_DOWN:\n+  case ROUNDING_TO_ZERO:\n+    if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+      status = EXACT_STATUS;\n+    //if(!C64 && rmode==ROUNDING_DOWN) sign_s=sign_y;\n+    break;\n+  default:\n+    // round up\n+    __add_carry_out (tmp, carry, CT.w[0],\n+\t\t     __bid_reciprocals10_64[extra_digits]);\n+    if ((remainder_h >> (64 - amount)) + carry >=\n+\t(((UINT64) 1) << amount))\n+      status = EXACT_STATUS;\n+    break;\n+  }\n+  __set_status_flags (pfpsf, status);\n+\n+#endif\n+\n+  res =\n+    fast_get_BID64_check_OF (sign_s, exponent_b + extra_digits, C64,\n+\t\t\t     rnd_mode, pfpsf);\n+  BID_RETURN (res);\n+}"}, {"sha": "888d561a0be958f3b9e1a70faccbffea83aa75e6", "filename": "libgcc/config/libbid/bid64_compare.c", "status": "added", "additions": 3471, "deletions": 0, "changes": 3471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_compare.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "94cac28036c074ed40e75b2d25031aee7c6892ef", "filename": "libgcc/config/libbid/bid64_div.c", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_div.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,497 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 divide\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *  if(coefficient_x<coefficient_y)\n+ *    p = number_digits(coefficient_y) - number_digits(coefficient_x)\n+ *    A = coefficient_x*10^p\n+ *    B = coefficient_y\n+ *    CA= A*10^(15+j), j=0 for A>=B, 1 otherwise\n+ *    Q = 0\n+ *  else\n+ *    get Q=(int)(coefficient_x/coefficient_y) \n+ *        (based on double precision divide)\n+ *    check for exact divide case\n+ *    Let R = coefficient_x - Q*coefficient_y\n+ *    Let m=16-number_digits(Q)\n+ *    CA=R*10^m, Q=Q*10^m\n+ *    B = coefficient_y\n+ *  endif\n+ *    if (CA<2^64)\n+ *      Q += CA/B  (64-bit unsigned divide)\n+ *    else \n+ *      get final Q using double precision divide, followed by 3 integer \n+ *          iterations\n+ *    if exact result, eliminate trailing zeros\n+ *    check for underflow\n+ *    round coefficient to nearest\n+ *\n+ ****************************************************************************/\n+\n+#include \"bid_internal.h\"\n+\n+extern UINT32 __bid_convert_table[5][128][2];\n+extern SINT8 __bid_factors[][2];\n+extern UINT8 __bid_packed_10000_zeros[];\n+\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_div (UINT64 * pres, UINT64 * px,\n+\t   UINT64 *\n+\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 x, y;\n+#else\n+\n+UINT64\n+__bid64_div (UINT64 x,\n+\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CA, CT;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, A, B, QX, PD;\n+  UINT64 A2, Q, Q2, B2, B4, B5, R, T, DU, res;\n+  UINT64 valid_x, valid_y;\n+  SINT64 D;\n+  int_double t_scale, tempq, temp_b;\n+  int_float tempx, tempy;\n+  double da, db, dq, da_h, da_l;\n+  int exponent_x = 0, exponent_y = 0, bin_expon_cx;\n+  int diff_expon, ed1, ed2, bin_index;\n+  int rmode, amount;\n+  int nzeros, i, j, k, d5;\n+  UINT32 QX32, tdigit[3], digit, digit_h, digit_low;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  y = *py;\n+#endif\n+\n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n+  valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!valid_x) {\n+    // x is Inf. or NaN\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // test if x is NaN\n+    if ((x & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (x & QUIET_MASK64);\n+    }\n+    // x is Infinity?\n+    if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n+      // check if y is Inf or NaN\n+      if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n+\t// y==Inf, return NaN \n+#ifdef SET_STATUS_FLAGS\n+\tif ((y & NAN_MASK64) == INFINITY_MASK64)\t// Inf/Inf\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (NAN_MASK64);\n+      }\n+      // otherwise return +/-Inf\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull) | INFINITY_MASK64);\n+    }\n+    // x==0\n+    if (((y & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n+\t&& !(y << (64 - 53))) {\n+      // y==0 , return NaN\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (NAN_MASK64);\n+    }\n+    if (((y & INFINITY_MASK64) != INFINITY_MASK64)) {\n+      if ((y & SPECIAL_ENCODING_MASK64) == SPECIAL_ENCODING_MASK64)\n+\texponent_y = ((UINT32) (y >> 51)) & 0x3ff;\n+      else\n+\texponent_y = ((UINT32) (y >> 53)) & 0x3ff;\n+      sign_y = y & 0x8000000000000000ull;\n+\n+      exponent_x = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+      if (exponent_x > DECIMAL_MAX_EXPON_64)\n+\texponent_x = DECIMAL_MAX_EXPON_64;\n+      else if (exponent_x < 0)\n+\texponent_x = 0;\n+      BID_RETURN ((sign_x ^ sign_y) | (((UINT64) exponent_x) << 53));\n+    }\n+\n+  }\n+  if (!valid_y) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (y & QUIET_MASK64);\n+    }\n+    // y is Infinity?\n+    if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n+      // return +/-0\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull));\n+    }\n+    // y is 0\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+    BID_RETURN ((sign_x ^ sign_y) | INFINITY_MASK64);\n+  }\n+\n+  diff_expon = exponent_x - exponent_y + DECIMAL_EXPONENT_BIAS;\n+\n+  if (coefficient_x < coefficient_y) {\n+    // get number of decimal digits for c_x, c_y\n+\n+    //--- get number of bits in the coefficients of x and y ---\n+    tempx.d = (float) coefficient_x;\n+    tempy.d = (float) coefficient_y;\n+    bin_index = (tempy.i - tempx.i) >> 23;\n+\n+    A = coefficient_x * __bid_power10_index_binexp[bin_index];\n+    B = coefficient_y;\n+\n+    temp_b.d = (double) B;\n+\n+    // compare A, B\n+    DU = (A - B) >> 63;\n+    ed1 = 15 + (int) DU;\n+    ed2 = __bid_estimate_decimal_digits[bin_index] + ed1;\n+    T = __bid_power10_table_128[ed1].w[0];\n+    __mul_64x64_to_128 (CA, A, T);\n+\n+    Q = 0;\n+    diff_expon = diff_expon - ed2;\n+\n+    // adjust double precision db, to ensure that later A/B - (int)(da/db) > -1\n+    if (coefficient_y < 0x0020000000000000ull) {\n+      temp_b.i += 1;\n+      db = temp_b.d;\n+    } else\n+      db = (double) (B + 2 + (B & 1));\n+\n+  } else {\n+    // get c_x/c_y\n+\n+    //  set last bit before conversion to DP\n+    A2 = coefficient_x | 1;\n+    da = (double) A2;\n+\n+    db = (double) coefficient_y;\n+\n+    tempq.d = da / db;\n+    Q = (UINT64) tempq.d;\n+\n+    R = coefficient_x - coefficient_y * Q;\n+\n+    // will use to get number of dec. digits of Q\n+    bin_expon_cx = (tempq.i >> 52) - 0x3ff;\n+\n+    // R<0 ?\n+    D = ((SINT64) R) >> 63;\n+    Q += D;\n+    R += (coefficient_y & D);\n+\n+    // exact result ?\n+    if (((SINT64) R) <= 0) {\n+      // can have R==-1 for coeff_y==1\n+      res =\n+\tget_BID64 (sign_x ^ sign_y, diff_expon, (Q + R), rnd_mode,\n+\t\t   pfpsf);\n+      BID_RETURN (res);\n+    }\n+    // get decimal digits of Q\n+    DU = __bid_power10_index_binexp[bin_expon_cx] - Q - 1;\n+    DU >>= 63;\n+\n+    ed2 = 16 - __bid_estimate_decimal_digits[bin_expon_cx] - (int) DU;\n+\n+    T = __bid_power10_table_128[ed2].w[0];\n+    __mul_64x64_to_128 (CA, R, T);\n+    B = coefficient_y;\n+\n+    Q *= __bid_power10_table_128[ed2].w[0];\n+    diff_expon -= ed2;\n+\n+  }\n+\n+  if (!CA.w[1]) {\n+    Q2 = CA.w[0] / B;\n+    B2 = B + B;\n+    B4 = B2 + B2;\n+    R = CA.w[0] - Q2 * B;\n+    Q += Q2;\n+  } else {\n+\n+    // 2^64\n+    t_scale.i = 0x43f0000000000000ull;\n+    // convert CA to DP\n+    da_h = CA.w[1];\n+    da_l = CA.w[0];\n+    da = da_h * t_scale.d + da_l;\n+\n+    // quotient\n+    dq = da / db;\n+    Q2 = (UINT64) dq;\n+\n+    // get w[0] remainder\n+    R = CA.w[0] - Q2 * B;\n+\n+    // R<0 ?\n+    D = ((SINT64) R) >> 63;\n+    Q2 += D;\n+    R += (B & D);\n+\n+    // now R<6*B\n+\n+    // quick divide\n+\n+    // 4*B\n+    B2 = B + B;\n+    B4 = B2 + B2;\n+\n+    R = R - B4;\n+    // R<0 ?\n+    D = ((SINT64) R) >> 63;\n+    // restore R if negative\n+    R += (B4 & D);\n+    Q2 += ((~D) & 4);\n+\n+    R = R - B2;\n+    // R<0 ?\n+    D = ((SINT64) R) >> 63;\n+    // restore R if negative\n+    R += (B2 & D);\n+    Q2 += ((~D) & 2);\n+\n+    R = R - B;\n+    // R<0 ?\n+    D = ((SINT64) R) >> 63;\n+    // restore R if negative\n+    R += (B & D);\n+    Q2 += ((~D) & 1);\n+\n+    Q += Q2;\n+  }\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (R) {\n+    // set status flags\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+  }\n+#ifndef LEAVE_TRAILING_ZEROS\n+  else\n+#endif\n+#else\n+#ifndef LEAVE_TRAILING_ZEROS\n+  if (!R)\n+#endif\n+#endif\n+#ifndef LEAVE_TRAILING_ZEROS\n+  {\n+    // eliminate trailing zeros\n+\n+    // check whether CX, CY are short\n+    if ((coefficient_x <= 1024) && (coefficient_y <= 1024)) {\n+      i = (int) coefficient_y - 1;\n+      j = (int) coefficient_x - 1;\n+      // difference in powers of 2 __bid_factors for Y and X\n+      nzeros = ed2 - __bid_factors[i][0] + __bid_factors[j][0];\n+      // difference in powers of 5 __bid_factors\n+      d5 = ed2 - __bid_factors[i][1] + __bid_factors[j][1];\n+      if (d5 < nzeros)\n+\tnzeros = d5;\n+\n+      __mul_64x64_to_128 (CT, Q, __bid_reciprocals10_64[nzeros]);\n+\n+      // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+      amount = __bid_short_recip_scale[nzeros];\n+      Q = CT.w[1] >> amount;\n+\n+      diff_expon += nzeros;\n+    } else {\n+      tdigit[0] = Q & 0x3ffffff;\n+      tdigit[1] = 0;\n+      QX = Q >> 26;\n+      QX32 = QX;\n+      nzeros = 0;\n+\n+      for (j = 0; QX32; j++, QX32 >>= 7) {\n+\tk = (QX32 & 127);\n+\ttdigit[0] += __bid_convert_table[j][k][0];\n+\ttdigit[1] += __bid_convert_table[j][k][1];\n+\tif (tdigit[0] >= 100000000) {\n+\t  tdigit[0] -= 100000000;\n+\t  tdigit[1]++;\n+\t}\n+      }\n+\n+      digit = tdigit[0];\n+      if (!digit && !tdigit[1])\n+\tnzeros += 16;\n+      else {\n+\tif (!digit) {\n+\t  nzeros += 8;\n+\t  digit = tdigit[1];\n+\t}\n+\t// decompose digit\n+\tPD = (UINT64) digit *0x068DB8BBull;\n+\tdigit_h = (UINT32) (PD >> 40);\n+\tdigit_low = digit - digit_h * 10000;\n+\n+\tif (!digit_low)\n+\t  nzeros += 4;\n+\telse\n+\t  digit_h = digit_low;\n+\n+\tif (!(digit_h & 1))\n+\t  nzeros +=\n+\t    3 & (UINT32) (__bid_packed_10000_zeros[digit_h >> 3] >>\n+\t\t\t  (digit_h & 7));\n+      }\n+\n+      if (nzeros) {\n+\t__mul_64x64_to_128 (CT, Q, __bid_reciprocals10_64[nzeros]);\n+\n+\t// now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+\tamount = __bid_short_recip_scale[nzeros];\n+\tQ = CT.w[1] >> amount;\n+      }\n+      diff_expon += nzeros;\n+\n+    }\n+    if (diff_expon >= 0) {\n+      res =\n+\tfast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, Q,\n+\t\t\t\t rnd_mode, pfpsf);\n+      BID_RETURN (res);\n+    }\n+  }\n+#endif\n+\n+  if (diff_expon >= 0) {\n+#ifdef IEEE_ROUND_NEAREST\n+    // round to nearest code\n+    // R*10\n+    R += R;\n+    R = (R << 2) + R;\n+    B5 = B4 + B;\n+\n+    // compare 10*R to 5*B\n+    R = B5 - R;\n+    // correction for (R==0 && (Q&1))\n+    R -= (Q & 1);\n+    // R<0 ?\n+    D = ((UINT64) R) >> 63;\n+    Q += D;\n+#else\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+    // round to nearest code\n+    // R*10\n+    R += R;\n+    R = (R << 2) + R;\n+    B5 = B4 + B;\n+\n+    // compare 10*R to 5*B\n+    R = B5 - R;\n+    // correction for (R==0 && (Q&1))\n+    R -= (Q & 1);\n+    // R<0 ?\n+    D = ((UINT64) R) >> 63;\n+    Q += D;\n+#else\n+    rmode = rnd_mode;\n+    if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+    switch (rmode) {\n+    case 0:\t// round to nearest code\n+    case ROUNDING_TIES_AWAY:\n+      // R*10\n+      R += R;\n+      R = (R << 2) + R;\n+      B5 = B4 + B;\n+      // compare 10*R to 5*B\n+      R = B5 - R;\n+      // correction for (R==0 && (Q&1))\n+      R -= ((Q | (rmode >> 2)) & 1);\n+      // R<0 ?\n+      D = ((UINT64) R) >> 63;\n+      Q += D;\n+      break;\n+    case ROUNDING_DOWN:\n+    case ROUNDING_TO_ZERO:\n+      break;\n+    default:\t// rounding up\n+      Q++;\n+      break;\n+    }\n+#endif\n+#endif\n+\n+    res =\n+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, Q, rnd_mode,\n+\t\t\t       pfpsf);\n+    BID_RETURN (res);\n+  } else {\n+    // UF occurs\n+\n+#ifdef SET_STATUS_FLAGS\n+    if ((diff_expon + 16 < 0)) {\n+      // set status flags\n+      __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+    }\n+#endif\n+    rmode = rnd_mode;\n+    res =\n+      get_BID64_UF (sign_x ^ sign_y, diff_expon, Q, R, rmode, pfpsf);\n+    BID_RETURN (res);\n+\n+  }\n+\n+\n+}"}, {"sha": "875c6e1d10e0c36107662545a0436fc32482a46f", "filename": "libgcc/config/libbid/bid64_fma.c", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_fma.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,627 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 fma\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *  if multiplication is guranteed exact (short coefficients)\n+ *     call the unpacked arg. equivalent of __bid64_add(x*y, z)\n+ *  else \n+ *     get full coefficient_x*coefficient_y product\n+ *     call subroutine to perform addition of 64-bit argument \n+ *                                         to 128-bit product\n+ *\n+ ****************************************************************************/\n+\n+#include \"inline_bid_add.h\"\n+\n+//////////////////////////////////////////////////////////////////////////\n+//\n+//  If coefficient_z is less than 16 digits long, normalize to 16 digits\n+//\n+/////////////////////////////////////////////////////////////////////////\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  #ifndef IEEE_ROUND_NEAREST\n+static UINT64\n+__bid_normalize (UINT64 sign_z, int exponent_z,\n+               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n+               int rounding_mode, unsigned *fpsc) {\n+  #else\n+static UINT64\n+__bid_normalize (UINT64 z, UINT64 sign_z, int exponent_z,\n+               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n+               int rounding_mode, unsigned *fpsc) {\n+  #endif\n+#else\n+static UINT64\n+__bid_normalize (UINT64 z, UINT64 sign_z, int exponent_z,\n+               UINT64 coefficient_z, UINT64 round_dir, int round_flag,\n+               int rounding_mode, unsigned *fpsc) {\n+#endif\n+  SINT64 D;\n+  int_double tempx;\n+  int digits_z, bin_expon, scale, rmode;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+  rmode = rounding_mode;\n+  if (sign_z && (unsigned) (rmode - 1) < 2)\n+    rmode = 3 - rmode;\n+#else\n+  if (coefficient_z >= __bid_power10_table_128[15].w[0])\n+    return z;\n+#endif\n+#endif\n+#ifdef IEEE_ROUND_NEAREST_TIES_AWAY\n+  if (coefficient_z >= __bid_power10_table_128[15].w[0])\n+    return z;\n+#endif\n+\n+  //--- get number of bits in the coefficients of x and y ---\n+  tempx.d = (double) coefficient_z;\n+  bin_expon = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n+  // get number of decimal digits in the coeff_x\n+  digits_z = __bid_estimate_decimal_digits[bin_expon];\n+  if (coefficient_z >= __bid_power10_table_128[digits_z].w[0])\n+    digits_z++;\n+\n+  scale = 16 - digits_z;\n+  exponent_z -= scale;\n+  if (exponent_z < 0) {\n+    scale += exponent_z;\n+    exponent_z = 0;\n+  }\n+  coefficient_z *= __bid_power10_table_128[scale].w[0];\n+\n+#ifdef SET_STATUS_FLAGS\n+  if (round_flag) {\n+    __set_status_flags (fpsc, INEXACT_EXCEPTION);\n+    if (coefficient_z < 1000000000000000ull)\n+      __set_status_flags (fpsc, UNDERFLOW_EXCEPTION);\n+    else if ((coefficient_z == 1000000000000000ull) && !exponent_z\n+\t     && ((SINT64) (round_dir ^ sign_z) < 0) && round_flag\n+\t     && (rmode == ROUNDING_DOWN || rmode == ROUNDING_TO_ZERO))\n+      __set_status_flags (fpsc, UNDERFLOW_EXCEPTION);\n+  }\n+#endif\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+  if (round_flag && (rmode & 3)) {\n+    D = round_dir ^ sign_z;\n+\n+    if (rmode == ROUNDING_UP) {\n+      if (D >= 0)\n+\tcoefficient_z++;\n+    } else {\n+      if (D < 0)\n+\tcoefficient_z--;\n+      if (coefficient_z < 1000000000000000ull && exponent_z) {\n+\tcoefficient_z = 9999999999999999ull;\n+\texponent_z--;\n+      }\n+    }\n+  }\n+#endif\n+#endif\n+\n+  return get_BID64 (sign_z, exponent_z, coefficient_z, rounding_mode,\n+\t\t    fpsc);\n+}\n+\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+extern void __bid64_mul (UINT64 * pres, UINT64 * px,\n+\t\t       UINT64 *\n+\t\t       py _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM);\n+#else\n+\n+extern UINT64 __bid64_mul (UINT64 x,\n+\t\t\t     UINT64 y _RND_MODE_PARAM\n+\t\t\t     _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t     _EXC_INFO_PARAM);\n+#endif\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_fma (UINT64 * pres, UINT64 * px, UINT64 * py,\n+\t   UINT64 *\n+\t   pz _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 x, y, z;\n+#else\n+\n+UINT64\n+__bid64_fma (UINT64 x, UINT64 y,\n+\t   UINT64 z _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 P, PU, CT, CZ;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, sign_z,\n+    coefficient_z;\n+  UINT64 C64, remainder_y, res;\n+  UINT64 CYh, CY0L, T;\n+  int_double tempx, tempy;\n+  int extra_digits, exponent_x = 0, exponent_y = 0, bin_expon_cx, bin_expon_cy,\n+    bin_expon_product, rmode;\n+  int digits_p, bp, final_exponent, exponent_z, digits_z, ez, ey,\n+    scale_z, uf_status;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  y = *py;\n+  z = *pz;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN\n+\n+    // test if x is NaN\n+    if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((x & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n+\t  ((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n+\t  ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (x & QUIET_MASK64);\n+    }\n+    // x is Infinity?\n+    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // check if y is 0\n+      if (((y & 0x6000000000000000ull) != 0x6000000000000000ull)\n+\t  && !(y << (64 - 53))) {\n+\t// y==0, return NaN\n+#ifdef SET_STATUS_FLAGS\n+\tif ((z & 0x7e00000000000000ull) != 0x7c00000000000000ull)\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (0x7c00000000000000ull);\n+      }\n+      // test if z is Inf of oposite sign\n+      if (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n+\t  && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n+\t// return NaN \n+#ifdef SET_STATUS_FLAGS\n+\tif (((y & 0x7e00000000000000ull) != 0x7c00000000000000ull) ||\t// qNaN\n+\t    ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (0x7c00000000000000ull);\n+      }\n+      if ((y & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+\tif (((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n+\t    ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (y & QUIET_MASK64);\n+      }\n+      if ((z & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+\tif (((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (z & QUIET_MASK64);\n+      }\n+      // otherwise return +/-Inf\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n+\t\t  0x7800000000000000ull);\n+    }\n+    // x is 0\n+    if (((y & 0x7800000000000000ull) != 0x7800000000000000ull)\n+\t&& ((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+      if ((z & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+\texponent_z = ((UINT32) (z >> 51)) & 0x3ff;\n+\tcoefficient_z =\n+\t  (z & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n+      } else {\n+\texponent_z = ((UINT32) (z >> 53)) & 0x3ff;\n+\tcoefficient_z = z & 0x001fffffffffffffull;\n+      }\n+\n+      if (coefficient_z) {\n+\tif ((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n+\t  exponent_y =\n+\t    exponent_x - DECIMAL_EXPONENT_BIAS +\n+\t    (((UINT32) (y >> 51)) & 0x3ff);\n+\telse\n+\t  exponent_y =\n+\t    exponent_x - DECIMAL_EXPONENT_BIAS +\n+\t    (((UINT32) (y >> 53)) & 0x3ff);\n+\n+\tsign_z = z & 0x8000000000000000ull;\n+\n+\tif (exponent_y >= exponent_z)\n+\t  BID_RETURN (z);\n+\tres =\n+\t  add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n+\t\t      &rnd_mode, pfpsf);\n+\tBID_RETURN (res);\n+      }\n+    }\n+  }\n+  if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((y & 0x7e00000000000000ull) == 0x7e00000000000000ull) ||\t// sNaN\n+\t  ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (y & QUIET_MASK64);\n+    }\n+    // y is Infinity?\n+    if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      // check if x is 0\n+      if (((x & 0x6000000000000000ull) != 0x6000000000000000ull)\n+\t  && !(x << (64 - 53))) {\n+\t// y==0, return NaN\n+#ifdef SET_STATUS_FLAGS\n+\tif ((z & 0x7e00000000000000ull) != 0x7c00000000000000ull)\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (0x7c00000000000000ull);\n+      }\n+      // test if z is Inf of oposite sign\n+      if (((z & 0x7c00000000000000ull) == 0x7800000000000000ull)\n+\t  && (((x ^ y) ^ z) & 0x8000000000000000ull)) {\n+#ifdef SET_STATUS_FLAGS\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\t// return NaN\n+\tBID_RETURN (0x7c00000000000000ull);\n+      }\n+      if ((z & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+\tif (((z & 0x7e00000000000000ull) == 0x7e00000000000000ull))\t// sNaN\n+\t  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\tBID_RETURN (z & QUIET_MASK64);\n+      }\n+      // otherwise return +/-Inf\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull) |\n+\t\t  0x7800000000000000ull);\n+    }\n+    // y is 0 \n+    if (((z & 0x7800000000000000ull) != 0x7800000000000000ull)) {\n+      if ((z & 0x6000000000000000ull) == 0x6000000000000000ull) {\n+\texponent_z = ((UINT32) (z >> 51)) & 0x3ff;\n+\tcoefficient_z =\n+\t  (z & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n+      } else {\n+\texponent_z = ((UINT32) (z >> 53)) & 0x3ff;\n+\tcoefficient_z = z & 0x001fffffffffffffull;\n+      }\n+\n+      if (coefficient_z) {\n+\texponent_y += exponent_x - DECIMAL_EXPONENT_BIAS;\n+\n+\tsign_z = z & 0x8000000000000000ull;\n+\n+\tif (exponent_y >= exponent_z)\n+\t  BID_RETURN (z);\n+\tres =\n+\t  add_zero64 (exponent_y, sign_z, exponent_z, coefficient_z,\n+\t\t      &rnd_mode, pfpsf);\n+\tBID_RETURN (res);\n+      }\n+    }\n+  }\n+\n+  if (!unpack_BID64 (&sign_z, &exponent_z, &coefficient_z, z)) {\n+    // y is Inf. or NaN or 0\n+\n+    // test if y is NaN/Inf\n+    if ((z & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((z & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (z & QUIET_MASK64);\n+    }\n+    // z is 0, return x*y\n+    if ((!coefficient_x) || (!coefficient_y)) {\n+      //0+/-0\n+      exponent_x += exponent_y - DECIMAL_EXPONENT_BIAS;\n+      if (exponent_x > DECIMAL_MAX_EXPON_64)\n+\texponent_x = DECIMAL_MAX_EXPON_64;\n+      else if (exponent_x < 0)\n+\texponent_x = 0;\n+      if (exponent_x <= exponent_z)\n+\tres = ((UINT64) exponent_x) << 53;\n+      else\n+\tres = ((z << 1) >> 1);\n+      if ((sign_x ^ sign_y) == sign_z)\n+\tres |= sign_z;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+      else if (rnd_mode == ROUNDING_DOWN)\n+\tres |= 0x8000000000000000ull;\n+#endif\n+#endif\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+\n+  /* get binary coefficients of x and y */\n+\n+  //--- get number of bits in the coefficients of x and y ---\n+  // version 2 (original)\n+  tempx.d = (double) coefficient_x;\n+  bin_expon_cx = ((tempx.i & MASK_BINARY_EXPONENT) >> 52);\n+\n+  tempy.d = (double) coefficient_y;\n+  bin_expon_cy = ((tempy.i & MASK_BINARY_EXPONENT) >> 52);\n+\n+  // magnitude estimate for coefficient_x*coefficient_y is \n+  //        2^(unbiased_bin_expon_cx + unbiased_bin_expon_cx)\n+  bin_expon_product = bin_expon_cx + bin_expon_cy;\n+\n+  // check if coefficient_x*coefficient_y<2^(10*k+3)\n+  // equivalent to unbiased_bin_expon_cx + unbiased_bin_expon_cx < 10*k+1\n+  if (bin_expon_product < UPPER_EXPON_LIMIT + 2 * BINARY_EXPONENT_BIAS) {\n+    //  easy multiply\n+    C64 = coefficient_x * coefficient_y;\n+    final_exponent = exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS;\n+    if ((final_exponent > 0) || (!coefficient_z)) {\n+      res =\n+\tget_add64 (sign_z, exponent_z, coefficient_z, sign_x ^ sign_y,\n+\t\t   final_exponent, C64, rnd_mode, pfpsf);\n+      BID_RETURN (res);\n+    } else {\n+      P.w[0] = C64;\n+      P.w[1] = 0;\n+      extra_digits = 0;\n+    }\n+  } else {\n+    if (!coefficient_z) {\n+#if DECIMAL_CALL_BY_REFERENCE\n+      __bid64_mul (&res, px,\n+\t\t py _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t _EXC_INFO_ARG);\n+#else\n+      res =\n+\t__bid64_mul (x,\n+\t\t   y _RND_MODE_ARG _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t   _EXC_INFO_ARG);\n+#endif\n+      BID_RETURN (res);\n+    }\n+    // get 128-bit product: coefficient_x*coefficient_y\n+    __mul_64x64_to_128 (P, coefficient_x, coefficient_y);\n+\n+    // tighten binary range of P:  leading bit is 2^bp\n+    // unbiased_bin_expon_product <= bp <= unbiased_bin_expon_product+1\n+    bin_expon_product -= 2 * BINARY_EXPONENT_BIAS;\n+    __tight_bin_range_128 (bp, P, bin_expon_product);\n+\n+    // get number of decimal digits in the product\n+    digits_p = __bid_estimate_decimal_digits[bp];\n+    if (!(__unsigned_compare_gt_128 (__bid_power10_table_128[digits_p], P)))\n+      digits_p++;\t// if __bid_power10_table_128[digits_p] <= P\n+\n+    // determine number of decimal digits to be rounded out\n+    extra_digits = digits_p - MAX_FORMAT_DIGITS;\n+    final_exponent =\n+      exponent_x + exponent_y + extra_digits - DECIMAL_EXPONENT_BIAS;\n+  }\n+\n+  if (((unsigned) final_exponent) >= 3 * 256) {\n+    if (final_exponent < 0) {\n+      //--- get number of bits in the coefficients of z  ---\n+      tempx.d = (double) coefficient_z;\n+      bin_expon_cx = ((tempx.i & MASK_BINARY_EXPONENT) >> 52) - 0x3ff;\n+      // get number of decimal digits in the coeff_x\n+      digits_z = __bid_estimate_decimal_digits[bin_expon_cx];\n+      if (coefficient_z >= __bid_power10_table_128[digits_z].w[0])\n+\tdigits_z++;\n+      // underflow\n+      if ((final_exponent + 16 < 0)\n+\t  || (exponent_z + digits_z > 33 + final_exponent)) {\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  #ifndef IEEE_ROUND_NEAREST\n+        res = __bid_normalize (sign_z, exponent_z, coefficient_z,\n+                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+  #else\n+        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n+                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+  #endif\n+#else\n+        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n+                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+#endif\n+\tBID_RETURN (res);\n+      }\n+\n+      ez = exponent_z + digits_z - 16;\n+      if (ez < 0)\n+\tez = 0;\n+      scale_z = exponent_z - ez;\n+      coefficient_z *= __bid_power10_table_128[scale_z].w[0];\n+      ey = final_exponent - extra_digits;\n+      extra_digits = ez - ey;\n+      if (extra_digits > 33) {\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  #ifndef IEEE_ROUND_NEAREST\n+\tres = __bid_normalize (sign_z, exponent_z, coefficient_z,\n+                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+  #else\n+        res = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n+                         sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+\n+  #endif\n+#else\n+\tres = __bid_normalize (z, sign_z, exponent_z, coefficient_z,\n+\t\t\t sign_x ^ sign_y, 1, rnd_mode, pfpsf);\n+#endif\n+\tBID_RETURN (res);\n+      }\n+      //else  // extra_digits<=32\n+\n+      if (extra_digits > 17) {\n+\tCYh = __truncate (P, 16);\n+\t// get remainder\n+\tT = __bid_power10_table_128[16].w[0];\n+\t__mul_64x64_to_64 (CY0L, CYh, T);\n+\tremainder_y = P.w[0] - CY0L;\n+\n+\textra_digits -= 16;\n+\tP.w[0] = CYh;\n+\tP.w[1] = 0;\n+      } else\n+\tremainder_y = 0;\n+\n+      // align coeff_x, CYh\n+      __mul_64x64_to_128 (CZ, coefficient_z,\n+\t\t\t  __bid_power10_table_128[extra_digits].w[0]);\n+\n+      if (sign_z == (sign_y ^ sign_x)) {\n+\t__add_128_128 (CT, CZ, P);\n+\tif (__unsigned_compare_ge_128\n+\t    (CT, __bid_power10_table_128[16 + extra_digits])) {\n+\t  extra_digits++;\n+\t  ez++;\n+\t}\n+      } else {\n+\tif (remainder_y && (__unsigned_compare_ge_128 (CZ, P))) {\n+\t  P.w[0]++;\n+\t  if (!P.w[0])\n+\t    P.w[1]++;\n+\t}\n+\t__sub_128_128 (CT, CZ, P);\n+\tif (((SINT64) CT.w[1]) < 0) {\n+\t  sign_z = sign_y ^ sign_x;\n+\t  CT.w[0] = 0 - CT.w[0];\n+\t  CT.w[1] = 0 - CT.w[1];\n+\t  if (CT.w[0])\n+\t    CT.w[1]--;\n+\t}\n+\tif (ez\n+\t    &&\n+\t    (__unsigned_compare_gt_128\n+\t     (__bid_power10_table_128[15 + extra_digits], CT))) {\n+\t  extra_digits--;\n+\t  ez--;\n+\t}\n+      }\n+\n+#ifdef SET_STATUS_FLAGS\n+      uf_status = 0;\n+      if ((!ez)\n+\t  &&\n+\t  __unsigned_compare_gt_128 (__bid_power10_table_128\n+\t\t\t\t     [extra_digits + 15], CT)) {\n+\trmode = rnd_mode;\n+\tif (sign_z && (unsigned) (rmode - 1) < 2)\n+\t  rmode = 3 - rmode;\n+\t//__add_128_64(PU, CT, __bid_round_const_table[rmode][extra_digits]);\n+\tPU = __bid_power10_table_128[extra_digits + 15];\n+\tPU.w[0]--;\n+\tif (__unsigned_compare_gt_128 (PU, CT)\n+\t    || (rmode == ROUNDING_DOWN)\n+\t    || (rmode == ROUNDING_TO_ZERO))\n+\t  uf_status = UNDERFLOW_EXCEPTION;\n+\telse if (extra_digits < 2) {\n+\t  if ((rmode == ROUNDING_UP)) {\n+\t    if (!extra_digits)\n+\t      uf_status = UNDERFLOW_EXCEPTION;\n+\t    else {\n+\t      if (remainder_y && (sign_z != (sign_y ^ sign_x)))\n+\t\tremainder_y = __bid_power10_table_128[16].w[0] - remainder_y;\n+\n+\t      if (__bid_power10_table_128[15].w[0] > remainder_y)\n+\t\tuf_status = UNDERFLOW_EXCEPTION;\n+\t    }\n+\t  } else\t// RN or RN_away\n+\t  {\n+\t    if (remainder_y && (sign_z != (sign_y ^ sign_x)))\n+\t      remainder_y = __bid_power10_table_128[16].w[0] - remainder_y;\n+\n+\t    if (!extra_digits) {\n+\t      remainder_y += __bid_round_const_table[rmode][15];\n+\t      if (remainder_y < __bid_power10_table_128[16].w[0])\n+\t\tuf_status = UNDERFLOW_EXCEPTION;\n+\t    } else {\n+\t      if (remainder_y < __bid_round_const_table[rmode][16])\n+\t\tuf_status = UNDERFLOW_EXCEPTION;\n+\t    }\n+\t  }\n+\t  //__set_status_flags (pfpsf, uf_status);\n+\t}\n+      }\n+#endif\n+      res =\n+\t__bid_full_round64_remainder (sign_z, ez - extra_digits, CT,\n+\t\t\t\t      extra_digits, remainder_y,\n+\t\t\t\t      rnd_mode, pfpsf, uf_status);\n+      BID_RETURN (res);\n+\n+    } else {\n+      if ((sign_z == (sign_x ^ sign_y))\n+\t  || (final_exponent > 3 * 256 + 15)) {\n+\tres =\n+\t  fast_get_BID64_check_OF (sign_x ^ sign_y, final_exponent,\n+\t\t\t\t   1000000000000000ull, rnd_mode,\n+\t\t\t\t   pfpsf);\n+\tBID_RETURN (res);\n+      }\n+    }\n+  }\n+\n+\n+  if (extra_digits > 0) {\n+    res =\n+      get_add128 (sign_z, exponent_z, coefficient_z, sign_x ^ sign_y,\n+\t\t  final_exponent, P, extra_digits, rnd_mode, pfpsf);\n+    BID_RETURN (res);\n+  }\n+  // go to convert_format and exit\n+  else {\n+    C64 = __low_64 (P);\n+\n+    res =\n+      get_add64 (sign_z, exponent_z, coefficient_z, sign_x ^ sign_y,\n+\t\t exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS, C64,\n+\t\t rnd_mode, pfpsf);\n+    BID_RETURN (res);\n+  }\n+}"}, {"sha": "04c8e0fff1d94b65ae86cc337c4e31073c005cae", "filename": "libgcc/config/libbid/bid64_logb.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_logb.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,100 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define MAX_FORMAT_DIGITS     16\n+#define DECIMAL_EXPONENT_BIAS 398\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_logb (UINT64 * pres,\n+\t    UINT64 *\n+\t    px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t    _EXC_INFO_PARAM) {\n+  UINT64 x;\n+#else\n+\n+UINT64\n+__bid64_logb (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 sign_x, coefficient_x, res;\n+  UINT64 logb_coeff, logb_sign;\n+  SINT32 sign_e;\n+  int exponent_x;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN\n+\n+    // test if x is NaN\n+    if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      res = 0x7800000000000000ull;\n+      BID_RETURN (res);\n+    }\n+    // x is 0\n+    {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);\n+#endif\n+      res = 0xf800000000000000ull;\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+  exponent_x =\n+    exponent_x - DECIMAL_EXPONENT_BIAS + MAX_FORMAT_DIGITS - 1;\n+\n+  // extract sign and absolute value from exponent_x\n+  sign_e = ((SINT32) exponent_x) >> 31;\n+  exponent_x = (exponent_x + sign_e) ^ sign_e;\n+\n+  logb_coeff = exponent_x;\n+  logb_sign = sign_e & 1;\n+  logb_sign <<= 63;\n+\n+  res =\n+    very_fast_get_BID64_small_mantissa (logb_sign,\n+\t\t\t\t\tDECIMAL_EXPONENT_BIAS,\n+\t\t\t\t\tlogb_coeff);\n+  BID_RETURN (res);\n+}"}, {"sha": "b0c9a5a552ddd24ecdab754a99974c3d52bee449", "filename": "libgcc/config/libbid/bid64_minmax.c", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_minmax.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,720 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID64 minimum function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+static const UINT64 mult_factor[16] = {\n+  1ull, 10ull, 100ull, 1000ull,\n+  10000ull, 100000ull, 1000000ull, 10000000ull,\n+  100000000ull, 1000000000ull, 10000000000ull, 100000000000ull,\n+  1000000000000ull, 10000000000000ull,\n+  100000000000000ull, 1000000000000000ull\n+};\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_minnum (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_minnum (UINT64 x, UINT64 y) {\n+#endif\n+\n+  UINT64 res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y;\n+  UINT128 sig_n_prime;\n+  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+\n+  // NaN (CASE1)\n+  // if x is NAN, then return y\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    // check if y is SNaN\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN \n+      // return quiet (SNaN) \n+      ; // y = y & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // if y is NAN, then return x\n+  else if ((y & MASK_NAN) == MASK_NAN) {\n+    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal, return either number\n+  if (x == y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // if x is neg infinity, there is no way it is greater than y, return x\n+    if (((x & MASK_SIGN) == MASK_SIGN)) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // x is pos infinity, return y\n+    else {\n+      res = y;\n+      BID_RETURN (res);\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is positive infinity, then x is less, return y\n+    //                 if y is negative infinity, then x is greater, return x\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull) {\n+      non_canon_x = 1;\n+    } else {\n+      non_canon_x = 0;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    non_canon_x = 0;\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull) {\n+      non_canon_y = 1;\n+    } else {\n+      non_canon_y = 0;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    non_canon_y = 0;\n+  }\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore \n+  //        ignore the sign, and neither number is greater\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || sig_x == 0) {\n+    x_is_zero = 1;\n+  }\n+  if (non_canon_y || sig_y == 0) {\n+    y_is_zero = 1;\n+  }\n+\n+  if (x_is_zero && y_is_zero) {\n+    // if both numbers are zero, neither is greater => return either\n+    res = y;\n+    BID_RETURN (res);\n+  } else if (x_is_zero) {\n+    // is x is zero, it is greater if Y is negative\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  } else if (y_is_zero) {\n+    // is y is zero, X is greater if it is positive\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? y : x;;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGN (CASE5)\n+  // now, if the sign bits differ, x is greater if y is negative\n+  if (((x ^ y) & MASK_SIGN) == MASK_SIGN) {\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+\n+  // if both components are either bigger or smaller, \n+  // it is clear what needs to be done\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? y : x; // difference cannot be >10^15\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n+  if (exp_x > exp_y) { // to simplify the loop below,\n+\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      res = y;\n+      BID_RETURN (res);\n+    }\n+\n+    res = (((sig_n_prime.w[1] > 0)\n+\t    || sig_n_prime.w[0] > sig_y) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t    MASK_SIGN)) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  // if postitive, return whichever significand is larger (converse if negative)\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  res = (((sig_n_prime.w[1] == 0)\n+\t  && (sig_x > sig_n_prime.w[0])) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t    MASK_SIGN)) ? y : x;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64 minimum magnitude function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_minnum_mag (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_minnum_mag (UINT64 x, UINT64 y) {\n+#endif\n+\n+  UINT64 res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y;\n+  UINT128 sig_n_prime;\n+  char non_canon_x, non_canon_y;\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // if x is NAN, then return y\n+    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    // check if y is SNaN\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n+      // return quiet (SNaN)\n+      ; // y = y & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\n+    // if y is NAN, then return x\n+    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal, return either number\n+  if (x == y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // x is infinity, its magnitude is greater than or equal to y\n+    // return x only if y is infinity and x is negative\n+    res = ((x & MASK_SIGN) == MASK_SIGN\n+\t   && (y & MASK_INF) == MASK_INF) ? x : y;\n+    BID_RETURN (res);\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // y is infinity, then it must be greater in magnitude, return x\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull) {\n+      non_canon_x = 1;\n+    } else {\n+      non_canon_x = 0;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    non_canon_x = 0;\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull) {\n+      non_canon_y = 1;\n+    } else {\n+      non_canon_y = 0;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    non_canon_y = 0;\n+  }\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore \n+  //        ignore the sign, and neither number is greater\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || sig_x == 0) {\n+    res = x; // x_is_zero, its magnitude must be smaller than y\n+    BID_RETURN (res);\n+  }\n+  if (non_canon_y || sig_y == 0) {\n+    res = y; // y_is_zero, its magnitude must be smaller than x\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if both components are either bigger or smaller, \n+  // it is clear what needs to be done\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    res = y; // difference cannot be greater than 10^15\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n+  if (exp_x > exp_y) { // to simplify the loop below,\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+    // now, sig_n_prime has: sig_x * 10^(exp_x-exp_y), this is \n+    // the compensated signif.\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      // two numbers are equal, return minNum(x,y)\n+      res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x;\n+      BID_RETURN (res);\n+    }\n+    // now, if compensated_x (sig_n_prime) is greater than y, return y,  \n+    // otherwise return x\n+    res = ((sig_n_prime.w[1] != 0) || sig_n_prime.w[0] > sig_y) ? y : x;\n+    BID_RETURN (res);\n+  }\n+  // exp_y must be greater than exp_x, thus adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? y : x; \n+        // two numbers are equal, return either\n+    BID_RETURN (res);\n+  }\n+\n+  res = ((sig_n_prime.w[1] == 0) && (sig_x > sig_n_prime.w[0])) ? y : x;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64 maximum function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_maxnum (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_maxnum (UINT64 x, UINT64 y) {\n+#endif\n+\n+  UINT64 res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y;\n+  UINT128 sig_n_prime;\n+  char x_is_zero = 0, y_is_zero = 0, non_canon_x, non_canon_y;\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // if x is NAN, then return y\n+    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    // check if y is SNaN\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n+      // return quiet (SNaN)\n+      ; // y = y & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\n+    // if y is NAN, then return x\n+    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal (not Greater).\n+  if (x == y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // if x is neg infinity, there is no way it is greater than y, return y\n+    // x is pos infinity, it is greater, unless y is positive infinity => \n+    // return y!=pos_infinity\n+    if (((x & MASK_SIGN) == MASK_SIGN)) {\n+      res = y;\n+      BID_RETURN (res);\n+    } else {\n+      res = (((y & MASK_INF) != MASK_INF)\n+\t     || ((y & MASK_SIGN) == MASK_SIGN)) ? x : y;\n+      BID_RETURN (res);\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // x is finite, so if y is positive infinity, then x is less, return y\n+    //                 if y is negative infinity, then x is greater, return x\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull) {\n+      non_canon_x = 1;\n+    } else {\n+      non_canon_x = 0;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    non_canon_x = 0;\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull) {\n+      non_canon_y = 1;\n+    } else {\n+      non_canon_y = 0;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    non_canon_y = 0;\n+  }\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore \n+  //        ignore the sign, and neither number is greater\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || sig_x == 0) {\n+    x_is_zero = 1;\n+  }\n+  if (non_canon_y || sig_y == 0) {\n+    y_is_zero = 1;\n+  }\n+\n+  if (x_is_zero && y_is_zero) {\n+    // if both numbers are zero, neither is greater => return NOTGREATERTHAN\n+    res = y;\n+    BID_RETURN (res);\n+  } else if (x_is_zero) {\n+    // is x is zero, it is greater if Y is negative\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  } else if (y_is_zero) {\n+    // is y is zero, X is greater if it is positive\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? x : y;;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGN (CASE5)\n+  // now, if the sign bits differ, x is greater if y is negative\n+  if (((x ^ y) & MASK_SIGN) == MASK_SIGN) {\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+\n+  // if both components are either bigger or smaller, \n+  //     it is clear what needs to be done\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN) ? x : y; \n+        // difference cannot be > 10^15\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n+  if (exp_x > exp_y) { // to simplify the loop below,\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+    // if postitive, return whichever significand is larger \n+    // (converse if negative)\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      res = y;\n+      BID_RETURN (res);\n+    }\n+    res = (((sig_n_prime.w[1] > 0)\n+\t    || sig_n_prime.w[0] > sig_y) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t    MASK_SIGN)) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  // if postitive, return whichever significand is larger (converse if negative)\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  res = (((sig_n_prime.w[1] == 0)\n+\t  && (sig_x > sig_n_prime.w[0])) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t    MASK_SIGN)) ? x : y;\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64 maximum magnitude function - returns greater of two numbers\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_maxnum_mag (UINT64 * pres, UINT64 * px, UINT64 * py) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_maxnum_mag (UINT64 x, UINT64 y) {\n+#endif\n+\n+  UINT64 res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y;\n+  UINT128 sig_n_prime;\n+  char non_canon_x, non_canon_y;\n+\n+  // NaN (CASE1)\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // if x is NAN, then return y\n+    if ((x & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    // check if y is SNaN\n+    if ((y & MASK_SNAN) == MASK_SNAN) {\n+      ; // *pfpsf |= INVALID_EXCEPTION; // set invalid status flag if sNaN\n+      // return quiet (SNaN)\n+      ; // y = y & 0xfdffffffffffffffull;\n+    }\n+    res = y;\n+    BID_RETURN (res);\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\n+    // if y is NAN, then return x\n+    if ((y & 0x0200000000000000ull) == 0x0200000000000000ull) {\n+      ; // *pfpsf |= INVALID_EXCEPTION;        // set exception if sNaN\n+    }\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal, return either number\n+  if (x == y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // x is infinity, its magnitude is greater than or equal to y\n+    // return y as long as x isn't negative infinity\n+    res = ((x & MASK_SIGN) == MASK_SIGN\n+\t   && (y & MASK_INF) == MASK_INF) ? y : x;\n+    BID_RETURN (res);\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // y is infinity, then it must be greater in magnitude\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull) {\n+      non_canon_x = 1;\n+    } else {\n+      non_canon_x = 0;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    non_canon_x = 0;\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull) {\n+      non_canon_y = 1;\n+    } else {\n+      non_canon_y = 0;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    non_canon_y = 0;\n+  }\n+\n+  // ZERO (CASE4)\n+  // some properties:\n+  //    (+ZERO == -ZERO) => therefore \n+  //        ignore the sign, and neither number is greater\n+  //    (ZERO x 10^A == ZERO x 10^B) for any valid A, B => \n+  //        ignore the exponent field\n+  //    (Any non-canonical # is considered 0)\n+  if (non_canon_x || sig_x == 0) {\n+    res = y; // x_is_zero, its magnitude must be smaller than y\n+    BID_RETURN (res);\n+  }\n+  if (non_canon_y || sig_y == 0) {\n+    res = x; // y_is_zero, its magnitude must be smaller than x\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if both components are either bigger or smaller, \n+  // it is clear what needs to be done\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    res = x; // difference cannot be greater than 10^15\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = y;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down to the compensated significand\n+  if (exp_x > exp_y) { // to simplify the loop below,\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+    // now, sig_n_prime has: sig_x * 10^(exp_x-exp_y), \n+    // this is the compensated signif.\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      // two numbers are equal, return maxNum(x,y)\n+      res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y;\n+      BID_RETURN (res);\n+    }\n+    // now, if compensated_x (sig_n_prime) is greater than y return y,  \n+    // otherwise return x\n+    res = ((sig_n_prime.w[1] != 0) || sig_n_prime.w[0] > sig_y) ? x : y;\n+    BID_RETURN (res);\n+  }\n+  // exp_y must be greater than exp_x, thus adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    res = ((y & MASK_SIGN) == MASK_SIGN) ? x : y; \n+        // two numbers are equal, return either\n+    BID_RETURN (res);\n+  }\n+\n+  res = ((sig_n_prime.w[1] == 0) && (sig_x > sig_n_prime.w[0])) ? x : y;\n+  BID_RETURN (res);\n+}"}, {"sha": "3798dcbbb02ebbb6c5a2a7e2f79bb1e69daa9e7f", "filename": "libgcc/config/libbid/bid64_mul.c", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_mul.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,380 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 multiply\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *  if(number_digits(coefficient_x)+number_digits(coefficient_y) guaranteed\n+ *       below 16)\n+ *      return get_BID64(sign_x^sign_y, exponent_x + exponent_y - dec_bias,\n+ *                     coefficient_x*coefficient_y)\n+ *  else\n+ *      get long product: coefficient_x*coefficient_y\n+ *      determine number of digits to round off (extra_digits)\n+ *      rounding is performed as a 128x128-bit multiplication by \n+ *         2^M[extra_digits]/10^extra_digits, followed by a shift\n+ *         M[extra_digits] is sufficiently large for required accuracy \n+ *\n+ ****************************************************************************/\n+\n+#include \"bid_internal.h\"\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_mul (UINT64 * pres, UINT64 * px,\n+\t   UINT64 *\n+\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 x, y;\n+#else\n+\n+UINT64\n+__bid64_mul (UINT64 x,\n+\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 P, PU, C128, Q_high, Q_low, Stemp;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y;\n+  UINT64 C64, remainder_h, carry, CY, res;\n+  UINT64 valid_x, valid_y;\n+  int_double tempx, tempy;\n+  int extra_digits, exponent_x = 0, exponent_y = 0, bin_expon_cx, bin_expon_cy,\n+    bin_expon_product;\n+  int rmode, digits_p, bp, amount, amount2, final_exponent, round_up;\n+  unsigned status, uf_status;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  y = *py;\n+#endif\n+\n+  valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);\n+  valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!valid_x) {\n+\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    // x is Inf. or NaN\n+\n+    // test if x is NaN\n+    if ((x & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (x & QUIET_MASK64);\n+    }\n+    // x is Infinity?\n+    if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n+      // check if y is 0\n+      if (((y & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n+\t  && !(y << (64 - 53))) {\n+#ifdef SET_STATUS_FLAGS\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\t// y==0 , return NaN\n+\tBID_RETURN (NAN_MASK64);\n+      }\n+      // check if y is NaN\n+      if ((y & NAN_MASK64) == NAN_MASK64)\n+\t// y==NaN , return NaN\n+\tBID_RETURN (y & QUIET_MASK64);\n+      // otherwise return +/-Inf\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull) | INFINITY_MASK64);\n+    }\n+    // x is 0\n+    if (((y & INFINITY_MASK64) != INFINITY_MASK64)) {\n+      if ((y & SPECIAL_ENCODING_MASK64) == SPECIAL_ENCODING_MASK64)\n+\texponent_y = ((UINT32) (y >> 51)) & 0x3ff;\n+      else\n+\texponent_y = ((UINT32) (y >> 53)) & 0x3ff;\n+      sign_y = y & 0x8000000000000000ull;\n+\n+      exponent_x += exponent_y - DECIMAL_EXPONENT_BIAS;\n+      if (exponent_x > DECIMAL_MAX_EXPON_64)\n+\texponent_x = DECIMAL_MAX_EXPON_64;\n+      else if (exponent_x < 0)\n+\texponent_x = 0;\n+      BID_RETURN ((sign_x ^ sign_y) | (((UINT64) exponent_x) << 53));\n+    }\n+  }\n+  if (!valid_y) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y & NAN_MASK64) == NAN_MASK64) {\n+#ifdef SET_STATUS_FLAGS\n+      if ((y & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (y & QUIET_MASK64);\n+    }\n+    // y is Infinity?\n+    if ((y & INFINITY_MASK64) == INFINITY_MASK64) {\n+      // check if x is 0\n+      if (((x & SPECIAL_ENCODING_MASK64) != SPECIAL_ENCODING_MASK64)\n+\t  && !(x << (64 - 53))) {\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+\t// x==0, return NaN\n+\tBID_RETURN (NAN_MASK64);\n+      }\n+      // otherwise return +/-Inf\n+      BID_RETURN (((x ^ y) & 0x8000000000000000ull) | INFINITY_MASK64);\n+    }\n+    // y is 0\n+    exponent_x += exponent_y - DECIMAL_EXPONENT_BIAS;\n+    if (exponent_x > DECIMAL_MAX_EXPON_64)\n+      exponent_x = DECIMAL_MAX_EXPON_64;\n+    else if (exponent_x < 0)\n+      exponent_x = 0;\n+    BID_RETURN ((sign_x ^ sign_y) | (((UINT64) exponent_x) << 53));\n+  }\n+  //--- get number of bits in the coefficients of x and y ---\n+  // version 2 (original)\n+  tempx.d = (double) coefficient_x;\n+  bin_expon_cx = ((tempx.i & MASK_BINARY_EXPONENT) >> 52);\n+  tempy.d = (double) coefficient_y;\n+  bin_expon_cy = ((tempy.i & MASK_BINARY_EXPONENT) >> 52);\n+\n+  // magnitude estimate for coefficient_x*coefficient_y is \n+  //        2^(unbiased_bin_expon_cx + unbiased_bin_expon_cx)\n+  bin_expon_product = bin_expon_cx + bin_expon_cy;\n+\n+  // check if coefficient_x*coefficient_y<2^(10*k+3)\n+  // equivalent to unbiased_bin_expon_cx + unbiased_bin_expon_cx < 10*k+1\n+  if (bin_expon_product < UPPER_EXPON_LIMIT + 2 * BINARY_EXPONENT_BIAS) {\n+    //  easy multiply\n+    C64 = coefficient_x * coefficient_y;\n+\n+    res =\n+      get_BID64_small_mantissa (sign_x ^ sign_y,\n+\t\t\t\texponent_x + exponent_y -\n+\t\t\t\tDECIMAL_EXPONENT_BIAS, C64, rnd_mode,\n+\t\t\t\tpfpsf);\n+    BID_RETURN (res);\n+  } else {\n+    uf_status = 0;\n+    // get 128-bit product: coefficient_x*coefficient_y\n+    __mul_64x64_to_128 (P, coefficient_x, coefficient_y);\n+\n+    // tighten binary range of P:  leading bit is 2^bp\n+    // unbiased_bin_expon_product <= bp <= unbiased_bin_expon_product+1\n+    bin_expon_product -= 2 * BINARY_EXPONENT_BIAS;\n+\n+    __tight_bin_range_128 (bp, P, bin_expon_product);\n+\n+    // get number of decimal digits in the product\n+    digits_p = __bid_estimate_decimal_digits[bp];\n+    if (!(__unsigned_compare_gt_128 (__bid_power10_table_128[digits_p], P)))\n+      digits_p++;\t// if __bid_power10_table_128[digits_p] <= P\n+\n+    // determine number of decimal digits to be rounded out\n+    extra_digits = digits_p - MAX_FORMAT_DIGITS;\n+    final_exponent =\n+      exponent_x + exponent_y + extra_digits - DECIMAL_EXPONENT_BIAS;\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x ^ sign_y && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+\n+    round_up = 0;\n+    if (((unsigned) final_exponent) >= 3 * 256) {\n+      if (final_exponent < 0) {\n+\t// underflow\n+\tif (final_exponent + 16 < 0) {\n+\t  res = sign_x ^ sign_y;\n+\t  __set_status_flags (pfpsf,\n+\t\t\t      UNDERFLOW_EXCEPTION | INEXACT_EXCEPTION);\n+\t  if (rmode == ROUNDING_UP)\n+\t    res |= 1;\n+\t  BID_RETURN (res);\n+\t}\n+\n+\tuf_status = UNDERFLOW_EXCEPTION;\n+\tif (final_exponent == -1) {\n+\t  __add_128_64 (PU, P, __bid_round_const_table[rmode][extra_digits]);\n+\t  if (__unsigned_compare_ge_128\n+\t      (PU, __bid_power10_table_128[extra_digits + 16]))\n+\t    uf_status = 0;\n+\t}\n+\textra_digits -= final_exponent;\n+\tfinal_exponent = 0;\n+\n+\tif (extra_digits > 17) {\n+\t  __mul_128x128_full (Q_high, Q_low, P, __bid_reciprocals10_128[16]);\n+\n+\t  amount = __bid_recip_scale[16];\n+\t  __shr_128 (P, Q_high, amount);\n+\n+\t  // get sticky bits\n+\t  amount2 = 64 - amount;\n+\t  remainder_h = 0;\n+\t  remainder_h--;\n+\t  remainder_h >>= amount2;\n+\t  remainder_h = remainder_h & Q_high.w[0];\n+\n+\t  extra_digits -= 16;\n+\t  if (remainder_h || (Q_low.w[1] > __bid_reciprocals10_128[16].w[1]\n+\t\t\t      || (Q_low.w[1] ==\n+\t\t\t\t  __bid_reciprocals10_128[16].w[1]\n+\t\t\t\t  && Q_low.w[0] >=\n+\t\t\t\t  __bid_reciprocals10_128[16].w[0]))) {\n+\t    round_up = 1;\n+\t    __set_status_flags (pfpsf,\n+\t\t\t\tUNDERFLOW_EXCEPTION |\n+\t\t\t\tINEXACT_EXCEPTION);\n+\t    P.w[0] = (P.w[0] << 3) + (P.w[0] << 1);\n+\t    P.w[0] |= 1;\n+\t    extra_digits++;\n+\t  }\n+\t}\n+      } else {\n+\tres =\n+\t  fast_get_BID64_check_OF (sign_x ^ sign_y, final_exponent,\n+\t\t\t\t   1000000000000000ull, rnd_mode,\n+\t\t\t\t   pfpsf);\n+\tBID_RETURN (res);\n+      }\n+    }\n+\n+\n+    if (extra_digits > 0) {\n+      // will divide by 10^(digits_p - 16)\n+\n+      // add a constant to P, depending on rounding mode\n+      // 0.5*10^(digits_p - 16) for round-to-nearest\n+      __add_128_64 (P, P, __bid_round_const_table[rmode][extra_digits]);\n+\n+      // get P*(2^M[extra_digits])/10^extra_digits\n+      __mul_128x128_full (Q_high, Q_low, P,\n+\t\t\t  __bid_reciprocals10_128[extra_digits]);\n+\n+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128\n+      amount = __bid_recip_scale[extra_digits];\n+      __shr_128 (C128, Q_high, amount);\n+\n+      C64 = __low_64 (C128);\n+\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+      if (rmode == 0)\t//ROUNDING_TO_NEAREST\n+#endif\n+\tif ((C64 & 1) && !round_up) {\n+\t  // check whether fractional part of initial_P/10^extra_digits \n+          // is exactly .5\n+\t  // this is the same as fractional part of \n+\t  // (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n+\n+\t  // get remainder\n+\t  remainder_h = Q_high.w[0] << (64 - amount);\n+\n+\t  // test whether fractional part is 0\n+\t  if (!remainder_h\n+\t      && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t  || (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t      && Q_low.w[0] <\n+\t\t      __bid_reciprocals10_128[extra_digits].w[0]))) {\n+\t    C64--;\n+\t  }\n+\t}\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+      status = INEXACT_EXCEPTION | uf_status;\n+\n+      // get remainder\n+      remainder_h = Q_high.w[0] << (64 - amount);\n+\n+      switch (rmode) {\n+      case ROUNDING_TO_NEAREST:\n+      case ROUNDING_TIES_AWAY:\n+\t// test whether fractional part is 0\n+\tif (remainder_h == 0x8000000000000000ull\n+\t    && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t    && Q_low.w[0] <\n+\t\t    __bid_reciprocals10_128[extra_digits].w[0])))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      case ROUNDING_DOWN:\n+      case ROUNDING_TO_ZERO:\n+\tif (!remainder_h\n+\t    && (Q_low.w[1] < __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t|| (Q_low.w[1] == __bid_reciprocals10_128[extra_digits].w[1]\n+\t\t    && Q_low.w[0] <\n+\t\t    __bid_reciprocals10_128[extra_digits].w[0])))\n+\t  status = EXACT_STATUS;\n+\tbreak;\n+      default:\n+\t// round up\n+\t__add_carry_out (Stemp.w[0], CY, Q_low.w[0],\n+\t\t\t __bid_reciprocals10_128[extra_digits].w[0]);\n+\t__add_carry_in_out (Stemp.w[1], carry, Q_low.w[1],\n+\t\t\t    __bid_reciprocals10_128[extra_digits].w[1], CY);\n+\tif ((remainder_h >> (64 - amount)) + carry >=\n+\t    (((UINT64) 1) << amount))\n+\t  status = EXACT_STATUS;\n+      }\n+\n+      __set_status_flags (pfpsf, status);\n+#endif\n+\n+      // convert to BID and return\n+      res =\n+\tfast_get_BID64_check_OF (sign_x ^ sign_y, final_exponent, C64,\n+\t\t\t\t rmode, pfpsf);\n+      BID_RETURN (res);\n+    }\n+    // go to convert_format and exit\n+    C64 = __low_64 (P);\n+    res =\n+      get_BID64 (sign_x ^ sign_y,\n+\t\t exponent_x + exponent_y - DECIMAL_EXPONENT_BIAS, C64,\n+\t\t rmode, pfpsf);\n+    BID_RETURN (res);\n+  }\n+}"}, {"sha": "62fd091f85fedbe0d4b5883320c6b49fa6edef74", "filename": "libgcc/config/libbid/bid64_next.c", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_next.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,446 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID64 nextup\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_nextup (UINT64 * pres,\n+\t      UINT64 *\n+\t      px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_nextup (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t      _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q1, ind;\n+  UINT64 C1; \t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+\n+  // check for NaNs and infinities\n+  if ((x & MASK_SNAN) == MASK_SNAN) { // check for SNaN\n+    // set invalid flag\n+    *pfpsf |= INVALID_EXCEPTION;\n+    // return quiet (SNaN)\n+    res = x & 0xfdffffffffffffffull;\n+    BID_RETURN (res);\n+  } else if ((x & MASK_NAN) == MASK_NAN) { // check for QNaN\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((x & MASK_INF) == MASK_INF) { // check for Infinity\n+    if (!(x & 0x8000000000000000ull)) { // x is +inf\n+      res = 0x7800000000000000ull;\n+    } else { // x is -inf\n+      res = 0xf7fb86f26fc0ffffull; // -MAXFP = -999...99 * 10^emax\n+    }\n+    BID_RETURN (res);\n+  }\n+  // unpack the argument\n+  x_sign = x & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51; // biased\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      x_exp = 0;\n+      C1 = 0;\n+    }\n+  } else {\n+    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53; // biased\n+    C1 = x & MASK_BINARY_SIG1;\n+  }\n+\n+  // check for zeros (possibly from non-canonical values)\n+  if (C1 == 0x0ull) {\n+    // x is 0\n+    res = 0x0000000000000001ull; // MINFP = 1 * 10^emin\n+  } else { // x is not special and is not zero\n+    if (x == 0x77fb86f26fc0ffffull) {\n+      // x = +MAXFP = 999...99 * 10^emax\n+      res = 0x7800000000000000ull; // +inf\n+    } else if (x == 0x8000000000000001ull) {\n+      // x = -MINFP = 1...99 * 10^emin\n+      res = 0x8000000000000000ull; // -0\n+    } else { // -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+      // can add/subtract 1 ulp to the significand\n+\n+      // Note: we could check here if x >= 10^16 to speed up the case q1 =16 \n+      // q1 = nr. of decimal digits in x (1 <= q1 <= 54)\n+      //  determine first the nr. of bits in x\n+      if (C1 >= MASK_BINARY_OR2) { // x >= 2^53\n+\t// split the 64-bit value in two 32-bit halves to avoid rounding errors\n+\tif (C1 >= 0x0000000100000000ull) { // x >= 2^32\n+\t  tmp1.d = (double) (C1 >> 32); // exact conversion\n+\t  x_nr_bits =\n+\t    33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t} else { // x < 2^32\n+\t  tmp1.d = (double) C1; // exact conversion\n+\t  x_nr_bits =\n+\t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t}\n+      } else { // if x < 2^53\n+\ttmp1.d = (double) C1; // exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      if (q1 == 0) {\n+\tq1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\t  q1++;\n+      }\n+      // if q1 < P16 then pad the significand with zeros\n+      if (q1 < P16) {\n+\tif ((SINT64)x_exp > P16 - q1) {\n+\t  ind = P16 - q1; // 1 <= ind <= P16 - 1\n+\t  // pad with P16 - q1 zeros, until exponent = emin\n+\t  // C1 = C1 * 10^ind\n+\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  x_exp = x_exp - ind;\n+\t} else { // pad with zeros until the exponent reaches emin\n+\t  ind = x_exp;\n+\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  x_exp = EXP_MIN;\n+\t}\n+      }\n+      if (!x_sign) { // x > 0\n+\t// add 1 ulp (add 1 to the significand)\n+\tC1++;\n+\tif (C1 == 0x002386f26fc10000ull) { // if  C1 = 10^16\n+\t  C1 = 0x00038d7ea4c68000ull; // C1 = 10^15\n+\t  x_exp++;\n+\t}\n+\t// Ok, because MAXFP = 999...99 * 10^emax was caught already\n+      } else { // x < 0\n+\t// subtract 1 ulp (subtract 1 from the significand)\n+\tC1--;\n+\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) { // if  C1 = 10^15 - 1\n+\t  C1 = 0x002386f26fc0ffffull; // C1 = 10^16 - 1\n+\t  x_exp--;\n+\t}\n+      }\n+      // assemble the result\n+      // if significand has 54 bits\n+      if (C1 & MASK_BINARY_OR2) {\n+\tres =\n+\t  x_sign | (x_exp << 51) | MASK_STEERING_BITS | (C1 &\n+\t\t\t\t\t\t\t MASK_BINARY_SIG2);\n+      } else { // significand fits in 53 bits\n+\tres = x_sign | (x_exp << 53) | C1;\n+      }\n+    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  } // end x is not special and is not zero\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64 nextdown\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_nextdown (UINT64 * pres,\n+\t\tUINT64 *\n+\t\tpx _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_nextdown (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t_EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res;\n+  UINT64 x_sign;\n+  UINT64 x_exp;\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q1, ind;\n+  UINT64 C1; \t// C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (UINT64)\n+\n+  // check for NaNs and infinities\n+  if ((x & MASK_SNAN) == MASK_SNAN) { // check for SNaN\n+    // set invalid flag\n+    *pfpsf |= INVALID_EXCEPTION;\n+    // return quiet (SNaN)\n+    res = x & 0xfdffffffffffffffull;\n+    BID_RETURN (res);\n+  } else if ((x & MASK_NAN) == MASK_NAN) { // check for QNaN\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((x & MASK_INF) == MASK_INF) { // check for Infinity\n+    if (x & 0x8000000000000000ull) { // x is -inf\n+      res = 0xf800000000000000ull;\n+    } else { // x is +inf\n+      res = 0x77fb86f26fc0ffffull; // +MAXFP = +999...99 * 10^emax\n+    }\n+    BID_RETURN (res);\n+  }\n+  // unpack the argument\n+  x_sign = x & MASK_SIGN; // 0 for positive, MASK_SIGN for negative\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    x_exp = (x & MASK_BINARY_EXPONENT2) >> 51; // biased\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      x_exp = 0;\n+      C1 = 0;\n+    }\n+  } else {\n+    x_exp = (x & MASK_BINARY_EXPONENT1) >> 53; // biased\n+    C1 = x & MASK_BINARY_SIG1;\n+  }\n+\n+  // check for zeros (possibly from non-canonical values)\n+  if (C1 == 0x0ull) {\n+    // x is 0\n+    res = 0x8000000000000001ull; // -MINFP = -1 * 10^emin\n+  } else { // x is not special and is not zero\n+    if (x == 0xf7fb86f26fc0ffffull) {\n+      // x = -MAXFP = -999...99 * 10^emax\n+      res = 0xf800000000000000ull; // -inf\n+    } else if (x == 0x0000000000000001ull) {\n+      // x = +MINFP = 1...99 * 10^emin\n+      res = 0x0000000000000000ull; // -0\n+    } else { // -MAXFP + 1ulp <= x <= -MINFP OR MINFP + 1 ulp <= x <= MAXFP\n+      // can add/subtract 1 ulp to the significand\n+\n+      // Note: we could check here if x >= 10^16 to speed up the case q1 =16 \n+      // q1 = nr. of decimal digits in x (1 <= q1 <= 16)\n+      //  determine first the nr. of bits in x\n+      if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+\t// split the 64-bit value in two 32-bit halves to avoid \n+\t// rounding errors\n+\tif (C1 >= 0x0000000100000000ull) { // x >= 2^32\n+\t  tmp1.d = (double) (C1 >> 32); // exact conversion\n+\t  x_nr_bits =\n+\t    33 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t} else { // x < 2^32\n+\t  tmp1.d = (double) C1; // exact conversion\n+\t  x_nr_bits =\n+\t    1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+\t}\n+      } else { // if x < 2^53\n+\ttmp1.d = (double) C1; // exact conversion\n+\tx_nr_bits =\n+\t  1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+      }\n+      q1 = __bid_nr_digits[x_nr_bits - 1].digits;\n+      if (q1 == 0) {\n+\tq1 = __bid_nr_digits[x_nr_bits - 1].digits1;\n+\tif (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\t  q1++;\n+      }\n+      // if q1 < P16 then pad the significand with zeros\n+      if (q1 < P16) {\n+\tif ((SINT64)x_exp > P16 - q1) {\n+\t  ind = P16 - q1; // 1 <= ind <= P16 - 1\n+\t  // pad with P16 - q1 zeros, until exponent = emin\n+\t  // C1 = C1 * 10^ind\n+\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  x_exp = x_exp - ind;\n+\t} else { // pad with zeros until the exponent reaches emin\n+\t  ind = x_exp;\n+\t  C1 = C1 * __bid_ten2k64[ind];\n+\t  x_exp = EXP_MIN;\n+\t}\n+      }\n+      if (x_sign) { // x < 0\n+\t// add 1 ulp (add 1 to the significand)\n+\tC1++;\n+\tif (C1 == 0x002386f26fc10000ull) { // if  C1 = 10^16\n+\t  C1 = 0x00038d7ea4c68000ull; // C1 = 10^15\n+\t  x_exp++;\n+\t  // Ok, because -MAXFP = -999...99 * 10^emax was caught already\n+\t}\n+      } else { // x > 0\n+\t// subtract 1 ulp (subtract 1 from the significand)\n+\tC1--;\n+\tif (C1 == 0x00038d7ea4c67fffull && x_exp != 0) { // if  C1 = 10^15 - 1\n+\t  C1 = 0x002386f26fc0ffffull; // C1 = 10^16 - 1\n+\t  x_exp--;\n+\t}\n+      }\n+      // assemble the result\n+      // if significand has 54 bits\n+      if (C1 & MASK_BINARY_OR2) {\n+\tres =\n+\t  x_sign | (x_exp << 51) | MASK_STEERING_BITS | (C1 &\n+\t\t\t\t\t\t\t MASK_BINARY_SIG2);\n+      } else { // significand fits in 53 bits\n+\tres = x_sign | (x_exp << 53) | C1;\n+      }\n+    } // end -MAXFP <= x <= -MINFP - 1 ulp OR MINFP <= x <= MAXFP - 1 ulp\n+  } // end x is not special and is not zero\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64 nextafter\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_nextafter (UINT64 * pres, UINT64 * px,\n+\t\t UINT64 *\n+\t\t py _EXC_FLAGS_PARAM _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_nextafter (UINT64 x,\n+\t\t UINT64 y _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res;\n+  UINT64 tmp1, tmp2;\n+  FPSC tmp_fpsf = 0; // dummy fpsf for calls to comparison functions\n+  int res1, res2;\n+\n+\n+  // check for NaNs\n+  if (((x & MASK_NAN) == MASK_NAN) || ((y & MASK_NAN) == MASK_NAN)) {\n+    // x is NaN or y is NaN\n+\n+    if ((x & MASK_NAN) == MASK_NAN) { // x is NAN\n+      if ((x & MASK_SNAN) == MASK_SNAN) { // x is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (x)\n+\tres = x & 0xfdffffffffffffffull;\n+\tres = x;\n+      } else { // x is QNaN\n+\tif ((y & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+\t  // set invalid flag\n+\t  *pfpsf |= INVALID_EXCEPTION;\n+\t}\n+\t// return x\n+\tres = x;\n+      }\n+      BID_RETURN (res);\n+    } else if ((y & MASK_NAN) == MASK_NAN) { // y is NAN\n+      if ((y & MASK_SNAN) == MASK_SNAN) { // y is SNAN\n+\t// set invalid flag\n+\t*pfpsf |= INVALID_EXCEPTION;\n+\t// return quiet (y)\n+\tres = y & 0xfdffffffffffffffull;\n+\tres = y;\n+      } else { // y is QNaN\n+\t// return y\n+\tres = y;\n+      }\n+      BID_RETURN (res);\n+    } else {\n+      ; // let infinities fall through\n+    }\n+  }\n+  // neither x nor y is NaN\n+  tmp_fpsf = *pfpsf; // save fpsf\n+#if DECIMAL_CALL_BY_REFERENCE\n+  __bid64_quiet_equal (&res1, px,\n+\t\t     py _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  __bid64_quiet_greater (&res2, px,\n+\t\t       py _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+  res1 =\n+    __bid64_quiet_equal (x,\n+\t\t       y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+  res2 =\n+    __bid64_quiet_greater (x,\n+\t\t\t y _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#endif\n+  *pfpsf = tmp_fpsf; // restore fpsf\n+  if (res1) { // x = y\n+    // return x with the sign of y\n+    res = (x & 0x7fffffffffffffffull) | (y & 0x8000000000000000ull);\n+  } else if (res2) { // x > y\n+#if DECIMAL_CALL_BY_REFERENCE\n+    __bid64_nextdown (&res,\n+\t\t    px _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+    res =\n+      __bid64_nextdown (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#endif\n+  } else { // x < y\n+#if DECIMAL_CALL_BY_REFERENCE\n+    __bid64_nextup (&res, px _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#else\n+    res = __bid64_nextup (x _EXC_FLAGS_ARG _EXC_MASKS_ARG _EXC_INFO_ARG);\n+#endif\n+  }\n+  // if the operand x is finite but the result is infinite, signal\n+  // overflow and inexact\n+  if (((x & MASK_INF) != MASK_INF) && ((res & MASK_INF) == MASK_INF)) {\n+    // set the inexact flag\n+    *pfpsf |= INEXACT_EXCEPTION;\n+    // set the overflow flag\n+    *pfpsf |= OVERFLOW_EXCEPTION;\n+  }\n+  // if the result is in (-10^emin, 10^emin), and is different from the\n+  // operand x, signal underflow and inexact \n+  tmp1 = 0x00038d7ea4c68000ull; // +100...0[16] * 10^emin\n+  tmp2 = res & 0x7fffffffffffffffull;\n+  tmp_fpsf = *pfpsf; // save fpsf\n+#if DECIMAL_CALL_BY_REFERENCE\n+  __bid64_quiet_greater (&res1, &tmp1,\n+\t\t       &tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t       _EXC_INFO_ARG);\n+  __bid64_quiet_not_equal (&res2, &x,\n+\t\t\t &res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t _EXC_INFO_ARG);\n+#else\n+  res1 =\n+    __bid64_quiet_greater (tmp1,\n+\t\t\t tmp2 _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t _EXC_INFO_ARG);\n+  res2 =\n+    __bid64_quiet_not_equal (x,\n+\t\t\t   res _EXC_FLAGS_ARG _EXC_MASKS_ARG\n+\t\t\t   _EXC_INFO_ARG);\n+#endif\n+  *pfpsf = tmp_fpsf; // restore fpsf\n+  if (res1 && res2) {\n+    // if (__bid64_quiet_greater (tmp1, tmp2, &tmp_fpsf) &&\n+    // __bid64_quiet_not_equal (x, res, &tmp_fpsf)) {\n+    // set the inexact flag\n+    *pfpsf |= INEXACT_EXCEPTION;\n+    // set the underflow flag\n+    *pfpsf |= UNDERFLOW_EXCEPTION;\n+  }\n+  BID_RETURN (res);\n+}"}, {"sha": "18fe231ecfcb6dd1caaaec3e3105570c5458223b", "filename": "libgcc/config/libbid/bid64_noncomp.c", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_noncomp.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,956 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+static const UINT64 mult_factor[16] = {\n+  1ull, 10ull, 100ull, 1000ull,\n+  10000ull, 100000ull, 1000000ull, 10000000ull,\n+  100000000ull, 1000000000ull, 10000000000ull, 100000000000ull,\n+  1000000000000ull, 10000000000000ull,\n+  100000000000000ull, 1000000000000000ull\n+};\n+\n+/*****************************************************************************\n+ *    BID64 non-computational functions:\n+ *         - __bid64_isSigned\n+ *         - __bid64_isNormal\n+ *         - __bid64_isSubnormal\n+ *         - __bid64_isFinite\n+ *         - __bid64_isZero\n+ *         - __bid64_isInf\n+ *         - __bid64_isSignaling\n+ *         - __bid64_isCanonical\n+ *         - __bid64_isNaN\n+ *         - __bid64_copy\n+ *         - __bid64_negate\n+ *         - __bid64_abs\n+ *         - __bid64_copySign\n+ *         - __bid64_class\n+ *         - __bid64_sameQuantum\n+ *         - __bid64_totalOrder\n+ *         - __bid64_totalOrderMag\n+ *         - __bid64_radix\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isSigned (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isSigned (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x & MASK_SIGN) == MASK_SIGN);\n+  BID_RETURN (res);\n+}\n+\n+// return 1 iff x is not zero, nor NaN nor subnormal nor infinity\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isNormal (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isNormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT128 sig_x_prime;\n+  UINT64 sig_x;\n+  unsigned int exp_x;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NaN\n+    res = 0;\n+  } else {\n+    // decode number into exponent and significand\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+      // check for zero or non-canonical\n+      if (sig_x > 9999999999999999ull || sig_x == 0) {\n+\tres = 0; // zero or non-canonical\n+\tBID_RETURN (res);\n+      }\n+      exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    } else {\n+      sig_x = (x & MASK_BINARY_SIG1);\n+      if (sig_x == 0) {\n+\tres = 0; // zero\n+\tBID_RETURN (res);\n+      }\n+      exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    }\n+    // if exponent is less than -383, the number may be subnormal\n+    // if (exp_x - 398 = -383) the number may be subnormal\n+    if (exp_x < 15) {\n+      __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n+      if (sig_x_prime.w[1] == 0\n+\t  && sig_x_prime.w[0] < 1000000000000000ull) {\n+\tres = 0; // subnormal\n+      } else {\n+\tres = 1; // normal\n+      }\n+    } else {\n+      res = 1; // normal\n+    }\n+  }\n+  BID_RETURN (res);\n+}\n+\n+// return 1 iff x is not zero, nor NaN nor normal nor infinity\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isSubnormal (int *pres,\n+\t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isSubnormal (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT128 sig_x_prime;\n+  UINT64 sig_x;\n+  unsigned int exp_x;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NaN\n+    res = 0;\n+  } else {\n+    // decode number into exponent and significand\n+    if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+      sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+      // check for zero or non-canonical\n+      if (sig_x > 9999999999999999ull || sig_x == 0) {\n+\tres = 0; // zero or non-canonical\n+\tBID_RETURN (res);\n+      }\n+      exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    } else {\n+      sig_x = (x & MASK_BINARY_SIG1);\n+      if (sig_x == 0) {\n+\tres = 0; // zero\n+\tBID_RETURN (res);\n+      }\n+      exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    }\n+    // if exponent is less than -383, the number may be subnormal\n+    // if (exp_x - 398 = -383) the number may be subnormal\n+    if (exp_x < 15) {\n+      __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n+      if (sig_x_prime.w[1] == 0\n+\t  && sig_x_prime.w[0] < 1000000000000000ull) {\n+\tres = 1; // subnormal\n+      } else {\n+\tres = 0; // normal\n+      }\n+    } else {\n+      res = 0; // normal\n+    }\n+  }\n+  BID_RETURN (res);\n+}\n+\n+//iff x is zero, subnormal or normal (not infinity or NaN)\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isFinite (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isFinite (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x & MASK_INF) != MASK_INF);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isZero (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isZero (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  // if infinity or nan, return 0\n+  if ((x & MASK_INF) == MASK_INF) {\n+    res = 0;\n+  } else if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1]\n+    // => sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    // if(sig_x > 9999999999999999ull) {return 1;}\n+    res =\n+      (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) >\n+       9999999999999999ull);\n+  } else {\n+    res = ((x & MASK_BINARY_SIG1) == 0);\n+  }\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isInf (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isInf (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x & MASK_INF) == MASK_INF) && ((x & MASK_NAN) != MASK_NAN);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isSignaling (int *pres,\n+\t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isSignaling (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x & MASK_SNAN) == MASK_SNAN);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isCanonical (int *pres,\n+\t\t   UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isCanonical (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  if ((x & MASK_NAN) == MASK_NAN) { // NaN\n+    if (x & 0x01fc000000000000ull) {\n+      res = 0;\n+    } else if ((x & 0x0003ffffffffffffull) > 999999999999999ull) { // payload\n+      res = 0;\n+    } else {\n+      res = 1;\n+    }\n+  } else if ((x & MASK_INF) == MASK_INF) {\n+    if (x & 0x03ffffffffffffffull) {\n+      res = 0;\n+    } else {\n+      res = 1;\n+    }\n+  } else if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) { // 54-bit coeff.\n+    res =\n+      (((x & MASK_BINARY_SIG2) | MASK_BINARY_OR2) <=\n+       9999999999999999ull);\n+  } else { // 53-bit coeff.\n+    res = 1;\n+  }\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_isNaN (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_isNaN (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+\n+  res = ((x & MASK_NAN) == MASK_NAN);\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, with no change\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_copy (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_copy (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 res;\n+\n+  res = x;\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, reversing the sign\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_negate (UINT64 * pres,\n+\t      UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_negate (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 res;\n+\n+  res = x ^ MASK_SIGN;\n+  BID_RETURN (res);\n+}\n+\n+// copies a floating-point operand x to destination y, changing the sign to positive\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_abs (UINT64 * pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_abs (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 res;\n+\n+  res = x & ~MASK_SIGN;\n+  BID_RETURN (res);\n+}\n+\n+// copies operand x to destination in the same format as x, but \n+// with the sign of y\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_copySign (UINT64 * pres, UINT64 * px,\n+\t\tUINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+UINT64\n+__bid64_copySign (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 res;\n+\n+  res = (x & ~MASK_SIGN) | (y & MASK_SIGN);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_class (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_class (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  UINT128 sig_x_prime;\n+  UINT64 sig_x;\n+  int exp_x;\n+\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // is the NaN signaling?\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      res = signalingNaN;\n+      BID_RETURN (res);\n+    }\n+    // if NaN and not signaling, must be quietNaN\n+    res = quietNaN;\n+    BID_RETURN (res);\n+  } else if ((x & MASK_INF) == MASK_INF) {\n+    // is the Infinity negative?\n+    if ((x & MASK_SIGN) == MASK_SIGN) {\n+      res = negativeInfinity;\n+    } else {\n+      // otherwise, must be positive infinity\n+      res = positiveInfinity;\n+    }\n+    BID_RETURN (res);\n+  } else if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // decode number into exponent and significand\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    // check for zero or non-canonical\n+    if (sig_x > 9999999999999999ull || sig_x == 0) {\n+      if ((x & MASK_SIGN) == MASK_SIGN) {\n+\tres = negativeZero;\n+      } else {\n+\tres = positiveZero;\n+      }\n+      BID_RETURN (res);\n+    }\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+  } else {\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    if (sig_x == 0) {\n+      res =\n+\t((x & MASK_SIGN) == MASK_SIGN) ? negativeZero : positiveZero;\n+      BID_RETURN (res);\n+    }\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+  }\n+  // if exponent is less than -383, number may be subnormal\n+  //  if (exp_x - 398 < -383)\n+  if (exp_x < 15) { // sig_x *10^exp_x\n+    __mul_64x64_to_128MACH (sig_x_prime, sig_x, mult_factor[exp_x]);\n+    if (sig_x_prime.w[1] == 0\n+\t&& (sig_x_prime.w[0] < 1000000000000000ull)) {\n+      res =\n+\t((x & MASK_SIGN) ==\n+\t MASK_SIGN) ? negativeSubnormal : positiveSubnormal;\n+      BID_RETURN (res);\n+    }\n+  }\n+  // otherwise, normal number, determine the sign\n+  res =\n+    ((x & MASK_SIGN) == MASK_SIGN) ? negativeNormal : positiveNormal;\n+  BID_RETURN (res);\n+}\n+\n+// true if the exponents of x and y are the same, false otherwise.\n+// The special cases of sameQuantum (NaN, NaN) and sameQuantum (Inf, Inf) are \n+// true.\n+// If exactly one operand is infinite or exactly one operand is NaN, then false\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_sameQuantum (int *pres, UINT64 * px,\n+\t\t   UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+int\n+__bid64_sameQuantum (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  unsigned int exp_x, exp_y;\n+\n+  // if both operands are NaN, return true; if just one is NaN, return false\n+  if ((x & MASK_NAN) == MASK_NAN || ((y & MASK_NAN) == MASK_NAN)) {\n+    res = ((x & MASK_NAN) == MASK_NAN && (y & MASK_NAN) == MASK_NAN);\n+    BID_RETURN (res);\n+  }\n+  // if both operands are INF, return true; if just one is INF, return false\n+  if ((x & MASK_INF) == MASK_INF || (y & MASK_INF) == MASK_INF) {\n+    res = ((x & MASK_INF) == MASK_INF && (y & MASK_INF) == MASK_INF);\n+    BID_RETURN (res);\n+  }\n+  // decode exponents for both numbers, and return true if they match\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+  }\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+  }\n+  res = (exp_x == exp_y);\n+  BID_RETURN (res);\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_totalOrder (int *pres, UINT64 * px,\n+\t\t  UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+int\n+__bid64_totalOrder (UINT64 x, UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y, pyld_y, pyld_x;\n+  UINT128 sig_n_prime;\n+  char x_is_zero = 0, y_is_zero = 0;\n+\n+  // NaN (CASE1)\n+  // if x and y are unordered numerically because either operand is NaN\n+  //    (1) totalOrder(-NaN, number) is true\n+  //    (2) totalOrder(number, +NaN) is true\n+  //    (3) if x and y are both NaN:\n+  //           i) negative sign bit < positive sign bit\n+  //           ii) signaling < quiet fir +NaN, reverse for -NaN\n+  //           iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // if x is -NaN\n+    if ((x & MASK_SIGN) == MASK_SIGN) {\n+      // return true, unless y is -NaN also\n+      if ((y & MASK_NAN) != MASK_NAN || (y & MASK_SIGN) != MASK_SIGN) {\n+\tres = 1; // y is a number, return 1\n+\tBID_RETURN (res);\n+      } else { // if y and x are both -NaN\n+\t// if x and y are both -sNaN or both -qNaN, we have to compare payloads\n+\t// this xnor statement evaluates to true if both are sNaN or qNaN\n+\tif (!\n+\t    (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n+\t\t\t\t\t       MASK_SNAN))) {\n+\t  // it comes down to the payload.  we want to return true if x has a\n+\t  // larger payload, but first we must calculate the payload.\n+\t  pyld_y = y & 0x0003ffffffffffffull;\n+\t  pyld_x = x & 0x0003ffffffffffffull;\n+\t  if (pyld_y > 999999999999999ull || pyld_y == 0) {\n+\t    // if y is zero, x must be less than or numerically equal\n+\t    // y's payload is 0\n+\t    res = 1;\n+\t    BID_RETURN (res);\n+\t  }\n+\t  // if x is zero and y isn't, x has the smaller payload\n+\t  // definitely (since we know y isn't 0 at this point)\n+\t  if (pyld_x > 999999999999999ull || pyld_x == 0) {\n+\t    // x's payload is 0\n+\t    res = 0;\n+\t    BID_RETURN (res);\n+\t  }\n+\t  res = (pyld_x >= pyld_y);\n+\t  BID_RETURN (res);\n+\t} else {\n+\t  // either x = -sNaN and y = -qNaN or x = -qNaN and y = -sNaN\n+\t  res = (y & MASK_SNAN) == MASK_SNAN; // totalOrder(-qNaN, -sNaN) == 1\n+\t  BID_RETURN (res);\n+\t}\n+      }\n+    } else { // x is +NaN\n+      // return false, unless y is +NaN also\n+      if ((y & MASK_NAN) != MASK_NAN || (y & MASK_SIGN) == MASK_SIGN) {\n+\tres = 0; // y is a number, return 1\n+\tBID_RETURN (res);\n+      } else {\n+\t// x and y are both +NaN; \n+\t// must investigate payload if both quiet or both signaling\n+\t// this xnor statement will be true if both x and y are +qNaN or +sNaN\n+\tif (!\n+\t    (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n+\t\t\t\t\t       MASK_SNAN))) {\n+\t  // it comes down to the payload.  we want to return true if x has a\n+\t  // smaller payload, but first we must calculate the payload.\n+\t  pyld_y = y & 0x0003ffffffffffffull;\n+\t  pyld_x = x & 0x0003ffffffffffffull;\n+\t  // if x is zero and y isn't, x has the smaller \n+\t  // payload definitely (since we know y isn't 0 at this point)\n+\t  if (pyld_x > 999999999999999ull || pyld_x == 0) {\n+\t    res = 1;\n+\t    BID_RETURN (res);\n+\t  }\n+\t  if (pyld_y > 999999999999999ull || pyld_y == 0) {\n+\t    // if y is zero, x must be less than or numerically equal\n+\t    res = 0;\n+\t    BID_RETURN (res);\n+\t  }\n+\t  res = (pyld_x <= pyld_y);\n+\t  BID_RETURN (res);\n+\t} else {\n+\t  // return true if y is +qNaN and x is +sNaN \n+\t  // (we know they're different bc of xor if_stmt above)\n+\t  res = ((x & MASK_SNAN) == MASK_SNAN);\n+\t  BID_RETURN (res);\n+\t}\n+      }\n+    }\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\n+    // x is certainly not NAN in this case.\n+    // return true if y is positive\n+    res = ((y & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits are the same, these numbers are equal.\n+  if (x == y) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // OPPOSITE SIGNS (CASE 3)\n+  // if signs are opposite, return 1 if x is negative \n+  // (if x<y, totalOrder is true)\n+  if (((x & MASK_SIGN) == MASK_SIGN) ^ ((y & MASK_SIGN) == MASK_SIGN)) {\n+    res = (x & MASK_SIGN) == MASK_SIGN;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE4)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // if x==neg_inf, return (y == neg_inf)?1:0;\n+    if ((x & MASK_SIGN) == MASK_SIGN) {\n+      res = 1;\n+      BID_RETURN (res);\n+    } else {\n+      // x is positive infinity, only return1 if y \n+      // is positive infinity as well\n+      // (we know y has same sign as x)\n+      res = ((y & MASK_INF) == MASK_INF);\n+      BID_RETURN (res);\n+    }\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // x is finite, so:\n+    //    if y is +inf, x<y\n+    //    if y is -inf, x>y\n+    res = ((y & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull || sig_x == 0) {\n+      x_is_zero = 1;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    if (sig_x == 0) {\n+      x_is_zero = 1;\n+    }\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull || sig_y == 0) {\n+      y_is_zero = 1;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    if (sig_y == 0) {\n+      y_is_zero = 1;\n+    }\n+  }\n+\n+  // ZERO (CASE 5)\n+  // if x and y represent the same entities, and \n+  // both are negative , return true iff exp_x <= exp_y\n+  if (x_is_zero && y_is_zero) {\n+    if (!((x & MASK_SIGN) == MASK_SIGN) ^\n+\t((y & MASK_SIGN) == MASK_SIGN)) {\n+      // if signs are the same:\n+      // totalOrder(x,y) iff exp_x >= exp_y for negative numbers\n+      // totalOrder(x,y) iff exp_x <= exp_y for positive numbers\n+      if (exp_x == exp_y) {\n+\tres = 1;\n+\tBID_RETURN (res);\n+      }\n+      res = (exp_x <= exp_y) ^ ((x & MASK_SIGN) == MASK_SIGN);\n+      BID_RETURN (res);\n+    } else {\n+      // signs are different.\n+      // totalOrder(-0, +0) is true\n+      // totalOrder(+0, -0) is false\n+      res = ((x & MASK_SIGN) == MASK_SIGN);\n+      BID_RETURN (res);\n+    }\n+  }\n+  // if x is zero and y isn't, clearly x has the smaller payload.\n+  if (x_is_zero) {\n+    res = ((y & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if y is zero, and x isn't, clearly y has the smaller payload.\n+  if (y_is_zero) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if both components are either bigger or smaller, \n+  // it is clear what needs to be done\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = ((x & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, it is \n+  // definitely larger, so no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    // difference cannot be greater than 10^15\n+    res = ((x & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, it is \n+  // definitely smaller, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = ((x & MASK_SIGN) != MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down \n+  // to the compensated significand\n+  if (exp_x > exp_y) {\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+    // if x and y represent the same entities, \n+    // and both are negative, return true iff exp_x <= exp_y\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      // case cannot occure, because all bits must \n+      // be the same - would have been caught if (x==y)\n+      res = (exp_x <= exp_y) ^ ((x & MASK_SIGN) == MASK_SIGN);\n+      BID_RETURN (res);\n+    }\n+    // if positive, return 1 if adjusted x is smaller than y\n+    res = ((sig_n_prime.w[1] == 0)\n+\t   && sig_n_prime.w[0] < sig_y) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t   MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  // if x and y represent the same entities, \n+  // and both are negative, return true iff exp_x <= exp_y\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    // Cannot occur, because all bits must be the same. \n+    // Case would have been caught if (x==y)\n+    res = (exp_x <= exp_y) ^ ((x & MASK_SIGN) == MASK_SIGN);\n+    BID_RETURN (res);\n+  }\n+  // values are not equal, for positive numbers return 1 \n+  // if x is less than y.  0 otherwise\n+  res = ((sig_n_prime.w[1] > 0)\n+\t || (sig_x < sig_n_prime.w[0])) ^ ((x & MASK_SIGN) ==\n+\t\t\t\t\t   MASK_SIGN);\n+  BID_RETURN (res);\n+}\n+\n+//totalOrderMag is TotalOrder(abs(x), abs(y))\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_totalOrderMag (int *pres, UINT64 * px,\n+\t\t     UINT64 * py _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+  UINT64 y = *py;\n+#else\n+int\n+__bid64_totalOrderMag (UINT64 x,\n+\t\t     UINT64 y _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  int exp_x, exp_y;\n+  UINT64 sig_x, sig_y, pyld_y, pyld_x;\n+  UINT128 sig_n_prime;\n+  char x_is_zero = 0, y_is_zero = 0;\n+\n+  // NaN (CASE1)\n+  // if x and y are unordered numerically because either operand is NaN\n+  //    (1) totalOrder(-NaN, number) is true\n+  //    (2) totalOrder(number, +NaN) is true\n+  //    (3) if x and y are both NaN:\n+  //           i) negative sign bit < positive sign bit\n+  //           ii) signaling < quiet fir +NaN, reverse for -NaN\n+  //           iii) lesser payload < greater payload for +NaN (reverse for -NaN)\n+  if ((x & MASK_NAN) == MASK_NAN) {\n+    // x is +NaN\n+\n+    // return false, unless y is +NaN also\n+    if ((y & MASK_NAN) != MASK_NAN) {\n+      res = 0; // y is a number, return 1\n+      BID_RETURN (res);\n+\n+    } else {\n+\n+      // x and y are both +NaN; \n+      // must investigate payload if both quiet or both signaling\n+      // this xnor statement will be true if both x and y are +qNaN or +sNaN\n+      if (!\n+\t  (((y & MASK_SNAN) == MASK_SNAN) ^ ((x & MASK_SNAN) ==\n+\t\t\t\t\t     MASK_SNAN))) {\n+\t// it comes down to the payload.  we want to return true if x has a\n+\t// smaller payload, but first we must calculate the payload.\n+\tpyld_y = y & 0x0003ffffffffffffull;\n+\tpyld_x = x & 0x0003ffffffffffffull;\n+\t// if x is zero and y isn't, x has the smaller \n+\t// payload definitely (since we know y isn't 0 at this point)\n+\tif (pyld_x > 999999999999999ull || pyld_x == 0) {\n+\t  res = 1;\n+\t  BID_RETURN (res);\n+\t}\n+\n+\tif (pyld_y > 999999999999999ull || pyld_y == 0) {\n+\t  // if y is zero, x must be less than or numerically equal\n+\t  res = 0;\n+\t  BID_RETURN (res);\n+\t}\n+\tres = (pyld_x <= pyld_y);\n+\tBID_RETURN (res);\n+\n+      } else {\n+\t// return true if y is +qNaN and x is +sNaN \n+\t// (we know they're different bc of xor if_stmt above)\n+\tres = ((x & MASK_SNAN) == MASK_SNAN);\n+\tBID_RETURN (res);\n+      }\n+    }\n+\n+  } else if ((y & MASK_NAN) == MASK_NAN) {\n+    // x is certainly not NAN in this case.\n+    // return true if y is positive\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // SIMPLE (CASE2)\n+  // if all the bits (except sign bit) are the same, \n+  // these numbers are equal.\n+  if ((x & ~MASK_SIGN) == (y & ~MASK_SIGN)) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // INFINITY (CASE3)\n+  if ((x & MASK_INF) == MASK_INF) {\n+    // x is positive infinity, only return1 \n+    // if y is positive infinity as well\n+    res = ((y & MASK_INF) == MASK_INF);\n+    BID_RETURN (res);\n+  } else if ((y & MASK_INF) == MASK_INF) {\n+    // x is finite, so:\n+    //    if y is +inf, x<y\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if steering bits are 11 (condition will be 0), \n+  // then exponent is G[0:w+1] =>\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_x = (x & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_x = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_x > 9999999999999999ull || sig_x == 0) {\n+      x_is_zero = 1;\n+    }\n+  } else {\n+    exp_x = (x & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_x = (x & MASK_BINARY_SIG1);\n+    if (sig_x == 0) {\n+      x_is_zero = 1;\n+    }\n+  }\n+\n+  // if steering bits are 11 (condition will be 0), \n+  // then exponent is G[0:w+1] =>\n+  if ((y & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    exp_y = (y & MASK_BINARY_EXPONENT2) >> 51;\n+    sig_y = (y & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (sig_y > 9999999999999999ull || sig_y == 0) {\n+      y_is_zero = 1;\n+    }\n+  } else {\n+    exp_y = (y & MASK_BINARY_EXPONENT1) >> 53;\n+    sig_y = (y & MASK_BINARY_SIG1);\n+    if (sig_y == 0) {\n+      y_is_zero = 1;\n+    }\n+  }\n+\n+  // ZERO (CASE 5)\n+  // if x and y represent the same entities, \n+  // and both are negative , return true iff exp_x <= exp_y\n+  if (x_is_zero && y_is_zero) {\n+    // totalOrder(x,y) iff exp_x <= exp_y for positive numbers\n+    res = (exp_x <= exp_y);\n+    BID_RETURN (res);\n+  }\n+  // if x is zero and y isn't, clearly x has the smaller payload.\n+  if (x_is_zero) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if y is zero, and x isn't, clearly y has the smaller payload.\n+  if (y_is_zero) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  // REDUNDANT REPRESENTATIONS (CASE6)\n+  // if both components are either bigger or smaller\n+  if (sig_x > sig_y && exp_x >= exp_y) {\n+    res = 0;\n+    BID_RETURN (res);\n+  }\n+  if (sig_x < sig_y && exp_x <= exp_y) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 greater than exp_y, it is definitely \n+  // larger, so no need for compensation\n+  if (exp_x - exp_y > 15) {\n+    res = 0; // difference cannot be greater than 10^15\n+    BID_RETURN (res);\n+  }\n+  // if exp_x is 15 less than exp_y, it is definitely \n+  // smaller, no need for compensation\n+  if (exp_y - exp_x > 15) {\n+    res = 1;\n+    BID_RETURN (res);\n+  }\n+  // if |exp_x - exp_y| < 15, it comes down \n+  // to the compensated significand\n+  if (exp_x > exp_y) {\n+\n+    // otherwise adjust the x significand upwards\n+    __mul_64x64_to_128MACH (sig_n_prime, sig_x,\n+\t\t\t    mult_factor[exp_x - exp_y]);\n+\n+    // if x and y represent the same entities, \n+    // and both are negative, return true iff exp_x <= exp_y\n+    if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_y)) {\n+      // case cannot occur, because all bits \n+      // must be the same - would have been caught if (x==y)\n+      res = (exp_x <= exp_y);\n+      BID_RETURN (res);\n+    }\n+    // if positive, return 1 if adjusted x is smaller than y\n+    res = ((sig_n_prime.w[1] == 0) && sig_n_prime.w[0] < sig_y);\n+    BID_RETURN (res);\n+  }\n+  // adjust the y significand upwards\n+  __mul_64x64_to_128MACH (sig_n_prime, sig_y,\n+\t\t\t  mult_factor[exp_y - exp_x]);\n+\n+  // if x and y represent the same entities, \n+  // and both are negative, return true iff exp_x <= exp_y\n+  if (sig_n_prime.w[1] == 0 && (sig_n_prime.w[0] == sig_x)) {\n+    res = (exp_x <= exp_y);\n+    BID_RETURN (res);\n+  }\n+  // values are not equal, for positive numbers \n+  // return 1 if x is less than y.  0 otherwise\n+  res = ((sig_n_prime.w[1] > 0) || (sig_x < sig_n_prime.w[0]));\n+  BID_RETURN (res);\n+\n+}\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_radix (int *pres, UINT64 * px _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+int\n+__bid64_radix (UINT64 x _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  int res;\n+  if (x)\t// dummy test\n+    res = 10;\n+  else\n+    res = 10;\n+  BID_RETURN (res);\n+}"}, {"sha": "db434fa30bd9b2b2ede43b0110bc46324b95701d", "filename": "libgcc/config/libbid/bid64_quantize.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_quantize.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,231 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define MAX_FORMAT_DIGITS     16\n+#define DECIMAL_EXPONENT_BIAS 398\n+#define MAX_DECIMAL_EXPONENT  767\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_quantize (UINT64 * pres, UINT64 * px,\n+\t\tUINT64 *\n+\t\tpy _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t_EXC_INFO_PARAM) {\n+  UINT64 x, y;\n+#else\n+\n+UINT64\n+__bid64_quantize (UINT64 x,\n+\t\tUINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t_EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CT;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, remainder_h, C64;\n+  UINT64 tmp, carry, res;\n+  int_float tempx;\n+  int exponent_x, exponent_y = 0, digits_x, extra_digits, amount, amount2;\n+  int expon_diff, total_digits, bin_expon_cx;\n+  unsigned rmode, status;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  y = *py;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n+    // Inf. or NaN or 0\n+#ifdef SET_STATUS_FLAGS\n+    if ((x & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // x=Inf, y=Inf?\n+    if (((x << 1) == 0xf000000000000000ull)\n+\t&& ((y << 1) == 0xf000000000000000ull)) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // Inf or NaN?\n+    if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((y & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+\t  || (((y & 0x7c00000000000000ull) == 0x7800000000000000ull) &&\t//Inf\n+\t      ((x & 0x7c00000000000000ull) < 0x7800000000000000ull)))\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+  }\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN or 0\n+\n+    // Inf or NaN?\n+    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((x & 0x7e00000000000000ull) == 0x7e00000000000000ull)\t// sNaN\n+\t  || ((x & 0x7c00000000000000ull) == 0x7800000000000000ull))\t//Inf \n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+\n+    res = very_fast_get_BID64_small_mantissa (sign_x, exponent_y, 0);\n+    BID_RETURN (res);\n+  }\n+  // get number of decimal digits in coefficient_x\n+  tempx.d = (float) coefficient_x;\n+  bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+  digits_x = __bid_estimate_decimal_digits[bin_expon_cx];\n+  if (coefficient_x >= __bid_power10_table_128[digits_x].w[0])\n+    digits_x++;\n+\n+  expon_diff = exponent_x - exponent_y;\n+  total_digits = digits_x + expon_diff;\n+\n+  // check range of scaled coefficient\n+  if ((UINT32) (total_digits + 1) <= 17) {\n+    if (expon_diff >= 0) {\n+      coefficient_x *= __bid_power10_table_128[expon_diff].w[0];\n+      res = very_fast_get_BID64 (sign_x, exponent_y, coefficient_x);\n+      BID_RETURN (res);\n+    }\n+    // must round off -expon_diff digits\n+    extra_digits = -expon_diff;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+#else\n+    rmode = 0;\n+#endif\n+#else\n+    rmode = 0;\n+#endif\n+    coefficient_x += __bid_round_const_table[rmode][extra_digits];\n+\n+    // get P*(2^M[extra_digits])/10^extra_digits\n+    __mul_64x64_to_128 (CT, coefficient_x,\n+\t\t\t__bid_reciprocals10_64[extra_digits]);\n+\n+    // now get P/10^extra_digits: shift C64 right by M[extra_digits]-128\n+    amount = __bid_short_recip_scale[extra_digits];\n+    C64 = CT.w[1] >> amount;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    if (rnd_mode == 0)\n+#endif\n+      if (C64 & 1) {\n+\t// check whether fractional part of initial_P/10^extra_digits \n+        // is exactly .5\n+\t// this is the same as fractional part of \n+\t//   (initial_P + 0.5*10^extra_digits)/10^extra_digits is exactly zero\n+\n+\t// get remainder\n+\tamount2 = 64 - amount;\n+\tremainder_h = 0;\n+\tremainder_h--;\n+\tremainder_h >>= amount2;\n+\tremainder_h = remainder_h & CT.w[1];\n+\n+\t// test whether fractional part is 0\n+\tif (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits])) {\n+\t  C64--;\n+\t}\n+      }\n+#endif\n+\n+#ifdef SET_STATUS_FLAGS\n+    status = INEXACT_EXCEPTION;\n+    // get remainder\n+    remainder_h = CT.w[1] << (64 - amount);\n+    switch (rmode) {\n+    case ROUNDING_TO_NEAREST:\n+    case ROUNDING_TIES_AWAY:\n+      // test whether fractional part is 0\n+      if ((remainder_h == 0x8000000000000000ull)\n+\t  && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\tstatus = EXACT_STATUS;\n+      break;\n+    case ROUNDING_DOWN:\n+    case ROUNDING_TO_ZERO:\n+      if (!remainder_h && (CT.w[0] < __bid_reciprocals10_64[extra_digits]))\n+\tstatus = EXACT_STATUS;\n+      //if(!C64 && rmode==ROUNDING_DOWN) sign_s=sign_y;\n+      break;\n+    default:\n+      // round up\n+      __add_carry_out (tmp, carry, CT.w[0],\n+\t\t       __bid_reciprocals10_64[extra_digits]);\n+      if ((remainder_h >> (64 - amount)) + carry >=\n+\t  (((UINT64) 1) << amount))\n+\tstatus = EXACT_STATUS;\n+      break;\n+    }\n+    __set_status_flags (pfpsf, status);\n+#endif\n+\n+    res = very_fast_get_BID64_small_mantissa (sign_x, exponent_y, C64);\n+    BID_RETURN (res);\n+  }\n+\n+  if (total_digits < 0) {\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+#endif\n+    C64 = 0;\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+#ifndef IEEE_ROUND_NEAREST\n+    rmode = rnd_mode;\n+    if (sign_x && (unsigned) (rmode - 1) < 2)\n+      rmode = 3 - rmode;\n+    if (rmode == ROUNDING_UP)\n+      C64 = 1;\n+#endif\n+#endif\n+    res = very_fast_get_BID64_small_mantissa (sign_x, exponent_y, C64);\n+    BID_RETURN (res);\n+  }\n+  // else  more than 16 digits in coefficient\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+  res = 0x7c00000000000000ull;\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "a127767675de4ff5ab780aa918e3176016a00cfb", "filename": "libgcc/config/libbid/bid64_rem.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_rem.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,232 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 remainder\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *  if(exponent_x < exponent_y)\n+ *    scale coefficient_y so exponents are aligned\n+ *    perform coefficient divide (64-bit integer divide), unless\n+ *            coefficient_y is longer than 64 bits (clearly larger \n+ *                                               than coefficient_x) \n+ *  else  // exponent_x > exponent_y\n+ *     use a loop to scale coefficient_x to 18_digits, divide by \n+ *         coefficient_y (64-bit integer divide), calculate remainder\n+ *         as new_coefficient_x and repeat until final remainder is obtained \n+ *         (when new_exponent_x < exponent_y)\n+ *\n+ ****************************************************************************/\n+\n+#include \"bid_internal.h\"\n+\n+#define MAX_FORMAT_DIGITS     16\n+#define DECIMAL_EXPONENT_BIAS 398\n+#define MASK_BINARY_EXPONENT  0x7ff0000000000000ull\n+#define BINARY_EXPONENT_BIAS  0x3ff\n+#define UPPER_EXPON_LIMIT     51\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_rem (UINT64 * pres, UINT64 * px,\n+\t   UINT64 *\n+\t   py _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t   _EXC_INFO_PARAM) {\n+  UINT64 x, y;\n+#else\n+\n+UINT64\n+__bid64_rem (UINT64 x,\n+\t   UINT64 y _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CY;\n+  UINT64 sign_x, sign_y, coefficient_x, coefficient_y, res;\n+  UINT64 Q, R, R2, T;\n+  int_float tempx;\n+  int exponent_x = 0, exponent_y, bin_expon, e_scale;\n+  int digits_x, diff_expon;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+  x = *px;\n+  y = *py;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN or 0\n+#ifdef SET_STATUS_FLAGS\n+    if ((y & SNAN_MASK64) == SNAN_MASK64)\t// y is sNaN\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+\n+    // test if x is NaN\n+    if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((x & SNAN_MASK64) == SNAN_MASK64))\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = x & QUIET_MASK64;;\n+      BID_RETURN (res);\n+    }\n+    // x is Infinity?\n+    if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((y & NAN_MASK64) != NAN_MASK64))\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      // return NaN\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+    // x is 0\n+    // return x if y != 0\n+    if (((y & 0x7800000000000000ull) < 0x7800000000000000ull) &&\n+\t(((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n+\t || (y << (64 - 53)))) {\n+      if ((y & 0x6000000000000000ull) == 0x6000000000000000ull)\n+\texponent_y = (y >> 51) & 0x3ff;\n+      else\n+\texponent_y = (y >> 53) & 0x3ff;\n+\n+      if (exponent_y < exponent_x)\n+\texponent_x = exponent_y;\n+\n+      x = exponent_x;\n+      x <<= 53;\n+\n+      res = x | sign_x;\n+      BID_RETURN (res);\n+    }\n+\n+  }\n+  if (!unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y)) {\n+    // y is Inf. or NaN\n+\n+    // test if y is NaN\n+    if ((y & 0x7c00000000000000ull) == 0x7c00000000000000ull) {\n+#ifdef SET_STATUS_FLAGS\n+      if (((y & SNAN_MASK64) == SNAN_MASK64))\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = y & QUIET_MASK64;;\n+      BID_RETURN (res);\n+    }\n+    // y is Infinity?\n+    if ((y & 0x7800000000000000ull) == 0x7800000000000000ull) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // y is 0, return NaN\n+    {\n+#ifdef SET_STATUS_FLAGS\n+      __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      res = 0x7c00000000000000ull;\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+\n+  diff_expon = exponent_x - exponent_y;\n+  if (diff_expon <= 0) {\n+    diff_expon = -diff_expon;\n+\n+    if (diff_expon > 16) {\n+      // |x|<|y| in this case\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+    // set exponent of y to exponent_x, scale coefficient_y\n+    T = __bid_power10_table_128[diff_expon].w[0];\n+    __mul_64x64_to_128 (CY, coefficient_y, T);\n+\n+    if (CY.w[1] || CY.w[0] > (coefficient_x << 1)) {\n+      res = x;\n+      BID_RETURN (res);\n+    }\n+\n+    Q = coefficient_x / CY.w[0];\n+    R = coefficient_x - Q * CY.w[0];\n+\n+    R2 = R + R;\n+    if (R2 > CY.w[0] || (R2 == CY.w[0] && (Q & 1))) {\n+      R = CY.w[0] - R;\n+      sign_x ^= 0x8000000000000000ull;\n+    }\n+\n+    res = very_fast_get_BID64 (sign_x, exponent_x, R);\n+    BID_RETURN (res);\n+  }\n+\n+\n+  while (diff_expon > 0) {\n+    // get number of digits in coeff_x\n+    tempx.d = (float) coefficient_x;\n+    bin_expon = ((tempx.i >> 23) & 0xff) - 0x7f;\n+    digits_x = __bid_estimate_decimal_digits[bin_expon];\n+    // will not use this test, dividend will have 18 or 19 digits\n+    //if(coefficient_x >= __bid_power10_table_128[digits_x].w[0])\n+    //      digits_x++;\n+\n+    e_scale = 18 - digits_x;\n+    if (diff_expon >= e_scale) {\n+      diff_expon -= e_scale;\n+    } else {\n+      e_scale = diff_expon;\n+      diff_expon = 0;\n+    }\n+\n+    // scale dividend to 18 or 19 digits\n+    coefficient_x *= __bid_power10_table_128[e_scale].w[0];\n+\n+    // quotient\n+    Q = coefficient_x / coefficient_y;\n+    // remainder\n+    coefficient_x -= Q * coefficient_y;\n+\n+    // check for remainder == 0\n+    if (!coefficient_x) {\n+      res = very_fast_get_BID64_small_mantissa (sign_x, exponent_y, 0);\n+      BID_RETURN (res);\n+    }\n+  }\n+\n+  R2 = coefficient_x + coefficient_x;\n+  if (R2 > coefficient_y || (R2 == coefficient_y && (Q & 1))) {\n+    coefficient_x = coefficient_y - coefficient_x;\n+    sign_x ^= 0x8000000000000000ull;\n+  }\n+\n+  res = very_fast_get_BID64 (sign_x, exponent_y, coefficient_x);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "bbc981e4787912843918443bfb3ca01dd7c71cb5", "filename": "libgcc/config/libbid/bid64_round_integral.c", "status": "added", "additions": 1180, "deletions": 0, "changes": 1180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_round_integral.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,1180 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_exact\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_exact (UINT64 * pres,\n+\t\t\t    UINT64 *\n+\t\t\t    px _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t\t    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  unsigned int rnd_mode = *prnd_mode;\n+#endif\n+#else\n+UINT64\n+__bid64_round_integral_exact (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t\t\t    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0xbaddbaddbaddbaddull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1 represents the significand (UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  // UINT64 res is C* at first - represents up to 16 decimal digits <= 54 bits\n+  UINT128 fstar = {{ 0x0ull, 0x0ull }};;\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then \n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical return 0 preserving the sign bit and \n+  // the preferred exponent of MAX(Q(x), 0)\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  switch (rnd_mode) {\n+  case ROUNDING_TO_NEAREST:\n+  case ROUNDING_TIES_AWAY:\n+    // return 0 if (exp <= -(p+1))\n+    if (exp <= -17) {\n+      res = x_sign | 0x31c0000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_DOWN:\n+    // return 0 if (exp <= -p)\n+    if (exp <= -16) {\n+      if (x_sign) {\n+\tres = 0xb1c0000000000001ull;\n+      } else {\n+\tres = 0x31c0000000000000ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_UP:\n+    // return 0 if (exp <= -p)\n+    if (exp <= -16) {\n+      if (x_sign) {\n+\tres = 0xb1c0000000000000ull;\n+      } else {\n+\tres = 0x31c0000000000001ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TO_ZERO:\n+    // return 0 if (exp <= -p) \n+    if (exp <= -16) {\n+      res = x_sign | 0x31c0000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  } // end switch ()\n+\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+\n+  switch (rnd_mode) {\n+  case ROUNDING_TO_NEAREST:\n+    if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits\n+      // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+      C1 = C1 + __bid_midpoint64[ind - 1];\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 16\n+      // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 64 bits\n+      __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      //   if floor(C*) is even then C* = floor(C*) - logical right\n+      //       shift; C* has p decimal digits, correct by Prop. 1)\n+      //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+      //       shift; C* has p decimal digits, correct by Pr. 1)\n+      // else  \n+      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // n = C* * 10^(e+x)  \n+\n+      if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+\tres = P128.w[1];\n+\tfstar.w[1] = 0;\n+\tfstar.w[0] = P128.w[0];\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres = (P128.w[1] >> shift);\n+\tfstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[0] = P128.w[0];\n+      }\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      // since round_to_even, subtract 1 if current result is odd\n+      if ((res & 0x0000000000000001ull) && (fstar.w[1] == 0)\n+\t  && (fstar.w[0] < __bid_ten2mk64[ind - 1])) {\n+\tres--;\n+      }\n+      // determine inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 > T*) then\n+      //   the result is inexact\n+      if (ind - 1 <= 2) {\n+\tif (fstar.w[0] > 0x8000000000000000ull) {\n+\t  // f* > 1/2 and the result may be exact\n+\t  // fstar.w[0] - 0x8000000000000000ull is f* - 1/2\n+\t  if ((fstar.w[0] - 0x8000000000000000ull) > __bid_ten2mk64[ind - 1]) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  } // else the result is exact\n+\t} else { // the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else { // if 3 <= ind - 1 <= 21\n+\tif (fstar.w[1] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[1] == __bid_one_half128[ind - 1]\n+\t    && fstar.w[0])) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  if (fstar.w[1] > __bid_one_half128[ind - 1]\n+\t      || fstar.w[0] > __bid_ten2mk64[ind - 1]) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  } // else the result is exact\n+\t} else { // the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      }\n+      // set exponent to zero as it was negative before.\n+      res = x_sign | 0x31c0000000000000ull | res;\n+      BID_RETURN (res);\n+    } else { // if exp < 0 and q + exp < 0\n+      // the result is +0 or -0\n+      res = x_sign | 0x31c0000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TIES_AWAY:\n+    if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits\n+      // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+      C1 = C1 + __bid_midpoint64[ind - 1];\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 16\n+      // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+      // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 64 bits\n+      __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+      // if (0 < f* < 10^(-x)) then the result is a midpoint\n+      //   C* = floor(C*) - logical right shift; C* has p decimal digits, \n+      //       correct by Prop. 1)\n+      // else\n+      //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // n = C* * 10^(e+x)\n+\n+      if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+\tres = P128.w[1];\n+\tfstar.w[1] = 0;\n+\tfstar.w[0] = P128.w[0];\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres = (P128.w[1] >> shift);\n+\tfstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[0] = P128.w[0];\n+      }\n+      // midpoints are already rounded correctly\n+      // determine inexactness of the rounding of C*\n+      // if (0 < f* - 1/2 < 10^(-x)) then\n+      //   the result is exact\n+      // else // if (f* - 1/2 > T*) then\n+      //   the result is inexact\n+      if (ind - 1 <= 2) {\n+\tif (fstar.w[0] > 0x8000000000000000ull) {\n+\t  // f* > 1/2 and the result may be exact \n+\t  // fstar.w[0] - 0x8000000000000000ull is f* - 1/2\n+\t  if ((fstar.w[0] - 0x8000000000000000ull) > __bid_ten2mk64[ind - 1]) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  } // else the result is exact\n+\t} else { // the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      } else { // if 3 <= ind - 1 <= 21\n+\tif (fstar.w[1] > __bid_one_half128[ind - 1]\n+\t    || (fstar.w[1] == __bid_one_half128[ind - 1]\n+\t    && fstar.w[0])) {\n+\t  // f2* > 1/2 and the result may be exact\n+\t  // Calculate f2* - 1/2\n+\t  if (fstar.w[1] > __bid_one_half128[ind - 1]\n+\t      || fstar.w[0] > __bid_ten2mk64[ind - 1]) {\n+\t    // set the inexact flag\n+\t    *pfpsf |= INEXACT_EXCEPTION;\n+\t  } // else the result is exact\n+\t} else { // the result is inexact; f2* <= 1/2\n+\t  // set the inexact flag\n+\t  *pfpsf |= INEXACT_EXCEPTION;\n+\t}\n+      }\n+      // set exponent to zero as it was negative before.\n+      res = x_sign | 0x31c0000000000000ull | res;\n+      BID_RETURN (res);\n+    } else { // if exp < 0 and q + exp < 0\n+      // the result is +0 or -0\n+      res = x_sign | 0x31c0000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_DOWN:\n+    if ((q + exp) > 0) { // exp < 0 and 1 <= -exp < q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 fits in 64 bits\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 16\n+      // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+      // C* = C1 * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 64 bits\n+      __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+      // C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // if (0 < f* < 10^(-x)) then the result is exact\n+      // n = C* * 10^(e+x)  \n+\n+      if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+\tres = P128.w[1];\n+\tfstar.w[1] = 0;\n+\tfstar.w[0] = P128.w[0];\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres = (P128.w[1] >> shift);\n+\tfstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[0] = P128.w[0];\n+      }\n+      // if (f* > 10^(-x)) then the result is inexact\n+      if ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind - 1])) {\n+\tif (x_sign) {\n+\t  // if negative and not exact, increment magnitude\n+\t  res++;\n+\t}\n+\t*pfpsf |= INEXACT_EXCEPTION;\n+      }\n+      // set exponent to zero as it was negative before.\n+      res = x_sign | 0x31c0000000000000ull | res;\n+      BID_RETURN (res);\n+    } else { // if exp < 0 and q + exp <= 0\n+      // the result is +0 or -1\n+      if (x_sign) {\n+\tres = 0xb1c0000000000001ull;\n+      } else {\n+\tres = 0x31c0000000000000ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_UP:\n+    if ((q + exp) > 0) { // exp < 0 and 1 <= -exp < q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 fits in 64 bits\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 16\n+      // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+      // C* = C1 * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 64 bits\n+      __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+      // C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // if (0 < f* < 10^(-x)) then the result is exact\n+      // n = C* * 10^(e+x)  \n+\n+      if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+\tres = P128.w[1];\n+\tfstar.w[1] = 0;\n+\tfstar.w[0] = P128.w[0];\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres = (P128.w[1] >> shift);\n+\tfstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[0] = P128.w[0];\n+      }\n+      // if (f* > 10^(-x)) then the result is inexact\n+      if ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind - 1])) {\n+\tif (!x_sign) {\n+\t  // if positive and not exact, increment magnitude\n+\t  res++;\n+\t}\n+\t*pfpsf |= INEXACT_EXCEPTION;\n+      }\n+      // set exponent to zero as it was negative before.\n+      res = x_sign | 0x31c0000000000000ull | res;\n+      BID_RETURN (res);\n+    } else { // if exp < 0 and q + exp <= 0\n+      // the result is -0 or +1\n+      if (x_sign) {\n+\tres = 0xb1c0000000000000ull;\n+      } else {\n+\tres = 0x31c0000000000001ull;\n+      }\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  case ROUNDING_TO_ZERO:\n+    if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+      // need to shift right -exp digits from the coefficient; exp will be 0\n+      ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+      // chop off ind digits from the lower part of C1 \n+      // C1 fits in 127 bits\n+      // calculate C* and f*\n+      // C* is actually floor(C*) in this case\n+      // C* and f* need shifting and masking, as shown by\n+      // __bid_shiftright128[] and __bid_maskhigh128[]\n+      // 1 <= x <= 16\n+      // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+      // C* = C1 * 10^(-x)\n+      // the approximation of 10^(-x) was rounded up to 64 bits\n+      __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+      // C* = floor(C*) (logical right shift; C has p decimal digits,\n+      //       correct by Property 1)\n+      // if (0 < f* < 10^(-x)) then the result is exact\n+      // n = C* * 10^(e+x)  \n+\n+      if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+\tres = P128.w[1];\n+\tfstar.w[1] = 0;\n+\tfstar.w[0] = P128.w[0];\n+      } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+\tshift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+\tres = (P128.w[1] >> shift);\n+\tfstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+\tfstar.w[0] = P128.w[0];\n+      }\n+      // if (f* > 10^(-x)) then the result is inexact\n+      if ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind - 1])) {\n+\t*pfpsf |= INEXACT_EXCEPTION;\n+      }\n+      // set exponent to zero as it was negative before.\n+      res = x_sign | 0x31c0000000000000ull | res;\n+      BID_RETURN (res);\n+    } else { // if exp < 0 and q + exp < 0\n+      // the result is +0 or -0\n+      res = x_sign | 0x31c0000000000000ull;\n+      *pfpsf |= INEXACT_EXCEPTION;\n+      BID_RETURN (res);\n+    }\n+    break;\n+  } // end switch ()\n+  BID_RETURN (res);\n+}\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_nearest_even\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_nearest_even (UINT64 * pres,\n+\t\t\t\t   UINT64 *\n+\t\t\t\t   px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t\t   _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_round_integral_nearest_even (UINT64 x _EXC_FLAGS_PARAM\n+\t\t\t\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0x0ull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  UINT128 fstar;\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then\n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  // return 0 if (exp <= -(p+1))\n+  if (exp <= -17) {\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits\n+    // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+    C1 = C1 + __bid_midpoint64[ind - 1];\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 16\n+    // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 64 bits\n+    __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+    // if (0 < f* < 10^(-x)) then the result is a midpoint\n+    //   if floor(C*) is even then C* = floor(C*) - logical right\n+    //       shift; C* has p decimal digits, correct by Prop. 1)\n+    //   else if floor(C*) is odd C* = floor(C*)-1 (logical right\n+    //       shift; C* has p decimal digits, correct by Pr. 1)\n+    // else  \n+    //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // n = C* * 10^(e+x)  \n+\n+    if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+      res = P128.w[1];\n+      fstar.w[1] = 0;\n+      fstar.w[0] = P128.w[0];\n+    } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res = (P128.w[1] >> shift);\n+      fstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+      fstar.w[0] = P128.w[0];\n+    }\n+    // if (0 < f* < 10^(-x)) then the result is a midpoint\n+    // since round_to_even, subtract 1 if current result is odd\n+    if ((res & 0x0000000000000001ull) && (fstar.w[1] == 0)\n+\t&& (fstar.w[0] < __bid_ten2mk64[ind - 1])) {\n+      res--;\n+    }\n+    // set exponent to zero as it was negative before.\n+    res = x_sign | 0x31c0000000000000ull | res;\n+    BID_RETURN (res);\n+  } else { // if exp < 0 and q + exp < 0\n+    // the result is +0 or -0\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_negative\n+ *****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_negative (UINT64 * pres,\n+\t\t\t       UINT64 *\n+\t\t\t       px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t       _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_round_integral_negative (UINT64 x _EXC_FLAGS_PARAM\n+\t\t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0x0ull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  // UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits\n+  UINT128 fstar;\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then\n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  // return 0 if (exp <= -p)\n+  if (exp <= -16) {\n+    if (x_sign) {\n+      res = 0xb1c0000000000001ull;\n+    } else {\n+      res = 0x31c0000000000000ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((q + exp) > 0) { // exp < 0 and 1 <= -exp < q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 fits in 64 bits\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 16\n+    // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+    // C* = C1 * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 64 bits\n+    __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+    // C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // if (0 < f* < 10^(-x)) then the result is exact\n+    // n = C* * 10^(e+x)  \n+\n+    if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+      res = P128.w[1];\n+      fstar.w[1] = 0;\n+      fstar.w[0] = P128.w[0];\n+    } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res = (P128.w[1] >> shift);\n+      fstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+      fstar.w[0] = P128.w[0];\n+    }\n+    // if (f* > 10^(-x)) then the result is inexact\n+    if (x_sign\n+\t&& ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind - 1]))) {\n+      // if negative and not exact, increment magnitude\n+      res++;\n+    }\n+    // set exponent to zero as it was negative before.\n+    res = x_sign | 0x31c0000000000000ull | res;\n+    BID_RETURN (res);\n+  } else { // if exp < 0 and q + exp <= 0\n+    // the result is +0 or -1\n+    if (x_sign) {\n+      res = 0xb1c0000000000001ull;\n+    } else {\n+      res = 0x31c0000000000000ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_positive\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_positive (UINT64 * pres,\n+\t\t\t       UINT64 *\n+\t\t\t       px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t       _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_round_integral_positive (UINT64 x _EXC_FLAGS_PARAM\n+\t\t\t       _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0x0ull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  // UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits\n+  UINT128 fstar;\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then\n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  // return 0 if (exp <= -p)\n+  if (exp <= -16) {\n+    if (x_sign) {\n+      res = 0xb1c0000000000000ull;\n+    } else {\n+      res = 0x31c0000000000001ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((q + exp) > 0) { // exp < 0 and 1 <= -exp < q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 fits in 64 bits\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 16\n+    // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+    // C* = C1 * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 64 bits\n+    __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+    // C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // if (0 < f* < 10^(-x)) then the result is exact\n+    // n = C* * 10^(e+x)  \n+\n+    if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+      res = P128.w[1];\n+      fstar.w[1] = 0;\n+      fstar.w[0] = P128.w[0];\n+    } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res = (P128.w[1] >> shift);\n+      fstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+      fstar.w[0] = P128.w[0];\n+    }\n+    // if (f* > 10^(-x)) then the result is inexact\n+    if (!x_sign\n+\t&& ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind - 1]))) {\n+      // if positive and not exact, increment magnitude\n+      res++;\n+    }\n+    // set exponent to zero as it was negative before.\n+    res = x_sign | 0x31c0000000000000ull | res;\n+    BID_RETURN (res);\n+  } else { // if exp < 0 and q + exp <= 0\n+    // the result is -0 or +1\n+    if (x_sign) {\n+      res = 0xb1c0000000000000ull;\n+    } else {\n+      res = 0x31c0000000000001ull;\n+    }\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_zero\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_zero (UINT64 * pres,\n+\t\t\t   UINT64 *\n+\t\t\t   px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t   _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_round_integral_zero (UINT64 x _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t   _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0x0ull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  // UINT64 res is C* at first - represents up to 34 decimal digits ~ 113 bits\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then\n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  // return 0 if (exp <= -p)\n+  if (exp <= -16) {\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 fits in 127 bits\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 16\n+    // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+    // C* = C1 * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 64 bits\n+    __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+    // C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // if (0 < f* < 10^(-x)) then the result is exact\n+    // n = C* * 10^(e+x)  \n+\n+    if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+      res = P128.w[1];\n+      // redundant fstar.w[1] = 0;\n+      // redundant fstar.w[0] = P128.w[0];\n+    } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res = (P128.w[1] >> shift);\n+      // redundant fstar.w[1] = P128.w[1] & __bid_maskhigh128[ind - 1];\n+      // redundant fstar.w[0] = P128.w[0];\n+    }\n+    // if (f* > 10^(-x)) then the result is inexact\n+    // if ((fstar.w[1] != 0) || (fstar.w[0] >= __bid_ten2mk64[ind-1])){\n+    //   // redundant\n+    // }\n+    // set exponent to zero as it was negative before.\n+    res = x_sign | 0x31c0000000000000ull | res;\n+    BID_RETURN (res);\n+  } else { // if exp < 0 and q + exp < 0\n+    // the result is +0 or -0\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}\n+\n+/*****************************************************************************\n+ *  BID64_round_integral_nearest_away\n+ ****************************************************************************/\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+void\n+__bid64_round_integral_nearest_away (UINT64 * pres,\n+\t\t\t\t   UINT64 *\n+\t\t\t\t   px _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t\t\t\t   _EXC_INFO_PARAM) {\n+  UINT64 x = *px;\n+#else\n+UINT64\n+__bid64_round_integral_nearest_away (UINT64 x _EXC_FLAGS_PARAM\n+\t\t\t\t   _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+\n+  UINT64 res = 0x0ull;\n+  UINT64 x_sign;\n+  int exp; \t// unbiased exponent\n+  // Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are UINT64)\n+  BID_UI64DOUBLE tmp1;\n+  int x_nr_bits;\n+  int q, ind, shift;\n+  UINT64 C1;\n+  UINT128 P128;\n+\n+  if ((x & MASK_INF) == MASK_INF) { // x is either INF or NAN\n+    res = x;\n+    if ((x & MASK_SNAN) == MASK_SNAN) {\n+      // set invalid flag\n+      *pfpsf |= INVALID_EXCEPTION;\n+      // return Quiet (SNaN)\n+      res = x & 0xfdffffffffffffffull;\n+    }\n+    // return original input if QNaN or INF, quietize if SNaN\n+    BID_RETURN (res);\n+  }\n+  // unpack x\n+  x_sign = x & MASK_SIGN;\t// 0 for positive, MASK_SIGN for negative\n+  if ((x & MASK_STEERING_BITS) == MASK_STEERING_BITS) {\n+    // if the steering bits are 11 (condition will be 0), then\n+    // the exponent is G[0:w+1]\n+    exp = ((x & MASK_BINARY_EXPONENT2) >> 51) - 398;\n+    C1 = (x & MASK_BINARY_SIG2) | MASK_BINARY_OR2;\n+    if (C1 > 9999999999999999ull) { // non-canonical\n+      exp = 0;\n+      C1 = 0;\n+    }\n+  } else { // if ((x & MASK_STEERING_BITS) != MASK_STEERING_BITS)\n+    exp = ((x & MASK_BINARY_EXPONENT1) >> 53) - 398;\n+    C1 = (x & MASK_BINARY_SIG1);\n+  }\n+\n+  // if x is 0 or non-canonical\n+  if (C1 == 0) {\n+    if (exp < 0)\n+      exp = 0;\n+    res = x_sign | (((UINT64) exp + 398) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x is a finite non-zero number (not 0, non-canonical, or special)\n+\n+  // return 0 if (exp <= -(p+1))\n+  if (exp <= -17) {\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+  // q = nr. of decimal digits in x (1 <= q <= 54)\n+  //  determine first the nr. of bits in x\n+  if (C1 >= 0x0020000000000000ull) { // x >= 2^53\n+    q = 16;\n+  } else { // if x < 2^53\n+    tmp1.d = (double) C1;\t// exact conversion\n+    x_nr_bits =\n+      1 + ((((unsigned int) (tmp1.ui64 >> 52)) & 0x7ff) - 0x3ff);\n+    q = __bid_nr_digits[x_nr_bits - 1].digits;\n+    if (q == 0) {\n+      q = __bid_nr_digits[x_nr_bits - 1].digits1;\n+      if (C1 >= __bid_nr_digits[x_nr_bits - 1].threshold_lo)\n+\tq++;\n+    }\n+  }\n+\n+  if (exp >= 0) { // -exp <= 0\n+    // the argument is an integer already\n+    res = x;\n+    BID_RETURN (res);\n+  } else if ((q + exp) >= 0) { // exp < 0 and 1 <= -exp <= q\n+    // need to shift right -exp digits from the coefficient; the exp will be 0\n+    ind = -exp;\t// 1 <= ind <= 16; ind is a synonym for 'x'\n+    // chop off ind digits from the lower part of C1 \n+    // C1 = C1 + 1/2 * 10^x where the result C1 fits in 64 bits\n+    // FOR ROUND_TO_NEAREST, WE ADD 1/2 ULP(y) then truncate\n+    C1 = C1 + __bid_midpoint64[ind - 1];\n+    // calculate C* and f*\n+    // C* is actually floor(C*) in this case\n+    // C* and f* need shifting and masking, as shown by\n+    // __bid_shiftright128[] and __bid_maskhigh128[]\n+    // 1 <= x <= 16\n+    // kx = 10^(-x) = __bid_ten2mk64[ind - 1]\n+    // C* = (C1 + 1/2 * 10^x) * 10^(-x)\n+    // the approximation of 10^(-x) was rounded up to 64 bits\n+    __mul_64x64_to_128 (P128, C1, __bid_ten2mk64[ind - 1]);\n+\n+    // if (0 < f* < 10^(-x)) then the result is a midpoint\n+    //   C* = floor(C*) - logical right shift; C* has p decimal digits, \n+    //       correct by Prop. 1)\n+    // else\n+    //   C* = floor(C*) (logical right shift; C has p decimal digits,\n+    //       correct by Property 1)\n+    // n = C* * 10^(e+x)\n+\n+    if (ind - 1 <= 2) { // 0 <= ind - 1 <= 2 => shift = 0\n+      res = P128.w[1];\n+    } else if (ind - 1 <= 21) { // 3 <= ind - 1 <= 21 => 3 <= shift <= 63\n+      shift = __bid_shiftright128[ind - 1];\t// 3 <= shift <= 63\n+      res = (P128.w[1] >> shift);\n+    }\n+    // midpoints are already rounded correctly\n+    // set exponent to zero as it was negative before.\n+    res = x_sign | 0x31c0000000000000ull | res;\n+    BID_RETURN (res);\n+  } else { // if exp < 0 and q + exp < 0\n+    // the result is +0 or -0\n+    res = x_sign | 0x31c0000000000000ull;\n+    BID_RETURN (res);\n+  }\n+}"}, {"sha": "28d9107abb662d27888c1bb4fcb507ecf0560a4f", "filename": "libgcc/config/libbid/bid64_scalb.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_scalb.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,94 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include \"bid_internal.h\"\n+\n+#define MAX_FORMAT_DIGITS     16\n+#define DECIMAL_EXPONENT_BIAS 398\n+#define MAX_DECIMAL_EXPONENT  767\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_scalb (UINT64 * pres, UINT64 * px,\n+\t     int *pn _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+  UINT64 x;\n+  int n;\n+#else\n+\n+UINT64\n+__bid64_scalb (UINT64 x,\n+\t     int n _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t     _EXC_INFO_PARAM) {\n+#endif\n+  UINT64 sign_x, coefficient_x, res;\n+  int exponent_x, rmode;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+  n = *pn;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN or 0\n+    res = x;\n+    BID_RETURN (res);\n+  }\n+\n+  exponent_x += n;\n+\n+  if ((UINT32) exponent_x <= MAX_DECIMAL_EXPONENT) {\n+    res = very_fast_get_BID64 (sign_x, exponent_x, coefficient_x);\n+    BID_RETURN (res);\n+  }\n+  // check for overflow\n+  if (exponent_x > MAX_DECIMAL_EXPONENT) {\n+    // try to normalize coefficient\n+    while ((coefficient_x < 1000000000000000ull)\n+\t   && (exponent_x > MAX_DECIMAL_EXPONENT)) {\n+      // coefficient_x < 10^15, scale by 10\n+      coefficient_x = (coefficient_x << 1) + (coefficient_x << 3);\n+      exponent_x--;\n+    }\n+    if (exponent_x <= MAX_DECIMAL_EXPONENT) {\n+      res = very_fast_get_BID64 (sign_x, exponent_x, coefficient_x);\n+      BID_RETURN (res);\n+    }\n+  }\n+  // exponent < 0\n+  // the BID pack routine will round the coefficient\n+  rmode = rnd_mode;\n+  res = get_BID64 (sign_x, exponent_x, coefficient_x, rmode, pfpsf);\n+  BID_RETURN (res);\n+\n+}"}, {"sha": "4a89cc65bcb75e81587d249a0485d3c475fdbc35", "filename": "libgcc/config/libbid/bid64_sqrt.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_sqrt.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8", "patch": "@@ -0,0 +1,198 @@\n+/* Copyright (C) 2007  Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/*****************************************************************************\n+ *    BID64 square root\n+ *****************************************************************************\n+ *\n+ *  Algorithm description:\n+ *\n+ *  if(exponent_x is odd)\n+ *     scale coefficient_x by 10, adjust exponent\n+ *  - get lower estimate for number of digits in coefficient_x\n+ *  - scale coefficient x to between 31 and 33 decimal digits\n+ *  - in parallel, check for exact case and return if true\n+ *  - get high part of result coefficient using double precision sqrt\n+ *  - compute remainder and refine coefficient in one iteration (which \n+ *                                 modifies it by at most 1)\n+ *  - result exponent is easy to compute from the adjusted arg. exponent \n+ *\n+ ****************************************************************************/\n+\n+#include \"bid_internal.h\"\n+\n+extern double sqrt (double);\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+\n+void\n+__bid64_sqrt (UINT64 * pres,\n+\t    UINT64 *\n+\t    px _RND_MODE_PARAM _EXC_FLAGS_PARAM _EXC_MASKS_PARAM\n+\t    _EXC_INFO_PARAM) {\n+  UINT64 x;\n+#else\n+\n+UINT64\n+__bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM\n+\t    _EXC_MASKS_PARAM _EXC_INFO_PARAM) {\n+#endif\n+  UINT128 CA, CT;\n+  UINT64 sign_x, coefficient_x;\n+  UINT64 Q, Q2, A10, C4, R, R2, QE, res;\n+  SINT64 D;\n+  int_double t_scale;\n+  int_float tempx;\n+  double da, dq, da_h, da_l, dqe;\n+  int exponent_x, exponent_q, bin_expon_cx;\n+  int digits_x;\n+  int scale;\n+\n+#if DECIMAL_CALL_BY_REFERENCE\n+#if !DECIMAL_GLOBAL_ROUNDING\n+  _IDEC_round rnd_mode = *prnd_mode;\n+#endif\n+  x = *px;\n+#endif\n+\n+  // unpack arguments, check for NaN or Infinity\n+  if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {\n+    // x is Inf. or NaN or 0\n+\n+    if ((x & INFINITY_MASK64) == INFINITY_MASK64) {\n+      res = x;\n+      if (x == 0xf800000000000000ull)\t// -Infinity\n+      {\n+\tres = NAN_MASK64;\n+#ifdef SET_STATUS_FLAGS\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      }\n+#ifdef SET_STATUS_FLAGS\n+      if ((x & SNAN_MASK64) == SNAN_MASK64)\t// sNaN\n+\t__set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+      BID_RETURN (res & QUIET_MASK64);\n+    }\n+    // x is 0\n+    exponent_x = (exponent_x + DECIMAL_EXPONENT_BIAS) >> 1;\n+    res = sign_x | (((UINT64) exponent_x) << 53);\n+    BID_RETURN (res);\n+  }\n+  // x<0?\n+  if (sign_x && coefficient_x) {\n+    res = NAN_MASK64;\n+#ifdef SET_STATUS_FLAGS\n+    __set_status_flags (pfpsf, INVALID_EXCEPTION);\n+#endif\n+    BID_RETURN (res);\n+  }\n+  //--- get number of bits in the coefficient of x ---\n+  tempx.d = (float) coefficient_x;\n+  bin_expon_cx = ((tempx.i >> 23) & 0xff) - 0x7f;\n+  digits_x = __bid_estimate_decimal_digits[bin_expon_cx];\n+  // add test for range\n+  if (coefficient_x >= __bid_power10_index_binexp[bin_expon_cx])\n+    digits_x++;\n+\n+  A10 = coefficient_x;\n+  if (exponent_x & 1) {\n+    A10 = (A10 << 2) + A10;\n+    A10 += A10;\n+  }\n+\n+  dqe = sqrt ((double) A10);\n+  QE = (UINT32) dqe;\n+  if (QE * QE == A10) {\n+    res =\n+      very_fast_get_BID64 (0, (exponent_x + DECIMAL_EXPONENT_BIAS) >> 1,\n+\t\t\t   QE);\n+    BID_RETURN (res);\n+  }\n+  // if exponent is odd, scale coefficient by 10\n+  scale = 31 - digits_x;\n+  exponent_q = exponent_x - scale;\n+  scale += (exponent_q & 1);\t// exp. bias is even\n+\n+  CT = __bid_power10_table_128[scale];\n+  __mul_64x128_short (CA, coefficient_x, CT);\n+\n+  // 2^64\n+  t_scale.i = 0x43f0000000000000ull;\n+  // convert CA to DP\n+  da_h = CA.w[1];\n+  da_l = CA.w[0];\n+  da = da_h * t_scale.d + da_l;\n+\n+  dq = sqrt (da);\n+\n+  Q = (UINT64) dq;\n+\n+  // get sign(sqrt(CA)-Q)\n+  R = CA.w[0] - Q * Q;\n+  R = ((SINT64) R) >> 63;\n+  D = R + R + 1;\n+\n+  exponent_q = (exponent_q + DECIMAL_EXPONENT_BIAS) >> 1;\n+\n+#ifdef SET_STATUS_FLAGS\n+  __set_status_flags (pfpsf, INEXACT_EXCEPTION);\n+#endif\n+\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  if (!((rnd_mode) & 3)) {\n+#endif\n+#endif\n+\n+    // midpoint to check\n+    Q2 = Q + Q + D;\n+    C4 = CA.w[0] << 2;\n+\n+    // get sign(-sqrt(CA)+Midpoint)\n+    R2 = Q2 * Q2 - C4;\n+    R2 = ((SINT64) R2) >> 63;\n+\n+    // adjust Q if R!=R2\n+    Q += (D & (R ^ R2));\n+#ifndef IEEE_ROUND_NEAREST\n+#ifndef IEEE_ROUND_NEAREST_TIES_AWAY\n+  } else {\n+    C4 = CA.w[0];\n+    Q += D;\n+    if ((SINT64) (Q * Q - C4) > 0)\n+      Q--;\n+    if (rnd_mode == ROUNDING_UP)\n+      Q++;\n+  }\n+#endif\n+#endif\n+\n+  res = fast_get_BID64 (0, exponent_q, Q);\n+  BID_RETURN (res);\n+}"}, {"sha": "1fc0b59591cb7eb8eece6ab99141ef5a49ea830a", "filename": "libgcc/config/libbid/bid64_to_bid128.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_bid128.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "d0213200933e5ebeb953ee9acb22f396b241c628", "filename": "libgcc/config/libbid/bid64_to_int32.c", "status": "added", "additions": 2594, "deletions": 0, "changes": 2594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int32.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "2bd0eb8d0223db861581b341244063176098b857", "filename": "libgcc/config/libbid/bid64_to_int64.c", "status": "added", "additions": 2334, "deletions": 0, "changes": 2334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_int64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "041cca68f6aa0ee94a0db5722a3e1b169cf42bc8", "filename": "libgcc/config/libbid/bid64_to_uint32.c", "status": "added", "additions": 2275, "deletions": 0, "changes": 2275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint32.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "df18f71e13d2edfee125fd22aa36e8dc1b1e5579", "filename": "libgcc/config/libbid/bid64_to_uint64.c", "status": "added", "additions": 2278, "deletions": 0, "changes": 2278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid64_to_uint64.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "fab4c8117435cfa15d96a52231581ea7bfbfcaf4", "filename": "libgcc/config/libbid/bid_conf.h", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_conf.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "3198f968bf7b61ae94b718338009ff5678d299b2", "filename": "libgcc/config/libbid/bid_flag_operations.c", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_flag_operations.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "f8d1dd264f39d68638d350ac09c1a0692fe36dbe", "filename": "libgcc/config/libbid/bid_from_int.c", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_from_int.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "76d52cd8b98784b5eeed2b5c65e439a76f0a93bf", "filename": "libgcc/config/libbid/bid_functions.h", "status": "added", "additions": 2676, "deletions": 0, "changes": 2676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_functions.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "7f117687b67934ecf50538e873c75d064c58d8ab", "filename": "libgcc/config/libbid/bid_internal.h", "status": "added", "additions": 2572, "deletions": 0, "changes": 2572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_internal.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "d920ae23b42f6795b6a7fe884ac3aba6fd3d7b0f", "filename": "libgcc/config/libbid/bid_intrinsics.h", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_intrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_intrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_intrinsics.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "a92db3daf9ea75fad3d6fd0d165ad5c8916e7c6a", "filename": "libgcc/config/libbid/bid_round.c", "status": "added", "additions": 1104, "deletions": 0, "changes": 1104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_round.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_round.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_round.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "e339dd2023465b96418f35a37665149cdc6fb199", "filename": "libgcc/config/libbid/bid_string.c", "status": "added", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbid_string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbid_string.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "f0097f0c0f76cbb5dff481122a78a3c5939e902d", "filename": "libgcc/config/libbid/binarydecimal.c", "status": "added", "additions": 100387, "deletions": 0, "changes": 100387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fbinarydecimal.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "44ecbacb3aee8509273e62a71eb19b566afb66e1", "filename": "libgcc/config/libbid/convert_data.c", "status": "added", "additions": 2113, "deletions": 0, "changes": 2113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fconvert_data.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fconvert_data.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fconvert_data.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "4f74d010e38f84f47409b62506b30da38acce24f", "filename": "libgcc/config/libbid/decimal_data.c", "status": "added", "additions": 1083, "deletions": 0, "changes": 1083, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdecimal_data.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdecimal_data.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fdecimal_data.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "ae3329858767912321e869d1aa07dda9369a952e", "filename": "libgcc/config/libbid/decimal_globals.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdecimal_globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdecimal_globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fdecimal_globals.c?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "63b7d3c4a58c88b3ca5f2e87a75b4567d5489068", "filename": "libgcc/config/libbid/div_macros.h", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdiv_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fdiv_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fdiv_macros.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "5601b39350008e464dc73a0a93caf1414f41899a", "filename": "libgcc/config/libbid/inline_bid_add.h", "status": "added", "additions": 1180, "deletions": 0, "changes": 1180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Finline_bid_add.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Finline_bid_add.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Finline_bid_add.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}, {"sha": "a8e6311ac479f052c788315bc5e1770d63c44010", "filename": "libgcc/config/libbid/sqrt_macros.h", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fsqrt_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200359e888d1230d8b0a2a2ba9731786856649c8/libgcc%2Fconfig%2Flibbid%2Fsqrt_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Flibbid%2Fsqrt_macros.h?ref=200359e888d1230d8b0a2a2ba9731786856649c8"}]}