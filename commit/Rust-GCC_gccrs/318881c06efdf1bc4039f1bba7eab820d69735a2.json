{"sha": "318881c06efdf1bc4039f1bba7eab820d69735a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE4ODgxYzA2ZWZkZjFiYzQwMzlmMWJiYTdlYWI4MjBkNjk3MzVhMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-14T16:28:59Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-14T16:28:59Z"}, "message": "sh-protos.h: New file.\n\n\t* sh-protos.h: New file.\n\n\t* sh.c: Include insn-config.h, toplev.h, recog.h and tm_p.h.\n\tAdd static prototypes.  Fix compile time warnings.\n\n\t* sh.h: Move prototypes to sh-protos.h.  Fix compile time warnings.\n\t* sh.md: Likewise.\n\t* elf.h: Likewise.\n\nFrom-SVN: r31418", "tree": {"sha": "c6310f842a4787519d84d6cf641895e33ee5a5d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6310f842a4787519d84d6cf641895e33ee5a5d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/318881c06efdf1bc4039f1bba7eab820d69735a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318881c06efdf1bc4039f1bba7eab820d69735a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/318881c06efdf1bc4039f1bba7eab820d69735a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/318881c06efdf1bc4039f1bba7eab820d69735a2/comments", "author": null, "committer": null, "parents": [{"sha": "2b046bda6e342d0b7031eed2cb884dd396484f6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b046bda6e342d0b7031eed2cb884dd396484f6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b046bda6e342d0b7031eed2cb884dd396484f6b"}], "stats": {"total": 347, "additions": 240, "deletions": 107}, "files": [{"sha": "0ee184d224de881345ecd51bf0d1ca809764b144", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -1,3 +1,14 @@\n+2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* sh-protos.h: New file.\n+\n+\t* sh.c: Include insn-config.h, toplev.h, recog.h and tm_p.h.\n+\tAdd static prototypes.  Fix compile time warnings.\n+\t\n+\t* sh.h: Move prototypes to sh-protos.h.  Fix compile time warnings.\n+\t* sh.md: Likewise.\n+\t* elf.h: Likewise.\n+\n 2000-01-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* arc-protos.h: New file."}, {"sha": "3fda1b6f259a4bd846e5695fcbe323164eb9ed5a", "filename": "gcc/config/sh/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Felf.h?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -84,7 +84,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \\\n-  sprintf ((STRING), \"*%s%s%d\", LOCAL_LABEL_PREFIX, (PREFIX), (NUM))\n+  sprintf ((STRING), \"*%s%s%ld\", LOCAL_LABEL_PREFIX, (PREFIX), (long)(NUM))\n \n #undef ASM_OUTPUT_INTERNAL_LABEL\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM) \\"}, {"sha": "86a92d1680113ee23adc49a4207a365295090137", "filename": "gcc/config/sh/sh-protos.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -0,0 +1,112 @@\n+/* Definitions of target machine for GNU compiler for Hitachi Super-H.\n+   Copyright (C) 1993-1998, 1999 Free Software Foundation, Inc.\n+   Contributed by Steve Chamberlain (sac@cygnus.com).\n+   Improved by Jim Wilson (wilson@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef RTX_CODE\n+extern struct rtx_def *sh_builtin_saveregs PARAMS ((void));\n+extern struct rtx_def *prepare_scc_operands PARAMS ((enum rtx_code));\n+\n+/* Declare functions defined in sh.c and used in templates.  */\n+\n+extern const char *output_branch PARAMS ((int, rtx, rtx *));\n+extern const char *output_ieee_ccmpeq PARAMS ((rtx, rtx *));\n+extern const char *output_branchy_insn PARAMS ((enum rtx_code, const char *, rtx, rtx *));\n+extern const char *output_movedouble PARAMS ((rtx, rtx[], enum machine_mode));\n+extern const char *output_movepcrel PARAMS ((rtx, rtx[], enum machine_mode));\n+extern const char *output_far_jump PARAMS ((rtx, rtx));\n+\n+extern void machine_dependent_reorg PARAMS ((rtx));\n+extern struct rtx_def *sfunc_uses_reg PARAMS ((rtx));\n+extern int barrier_align PARAMS ((rtx));\n+extern int fp_zero_operand PARAMS ((rtx));\n+extern int fp_one_operand PARAMS ((rtx));\n+extern int fp_int_operand PARAMS ((rtx));\n+extern rtx get_fpscr_rtx PARAMS ((void));\n+extern void emit_sf_insn PARAMS ((rtx));\n+extern void emit_df_insn PARAMS ((rtx));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern int expand_block_move PARAMS ((rtx *));\n+extern int prepare_move_operands PARAMS ((rtx[], enum machine_mode mode));\n+extern void from_compare PARAMS ((rtx *, int));\n+extern int shift_insns_rtx PARAMS ((rtx));\n+extern int shiftcosts PARAMS ((rtx));\n+extern int andcosts PARAMS ((rtx));\n+extern int multcosts PARAMS ((rtx));\n+extern void gen_ashift PARAMS ((int, int, rtx));\n+extern void gen_ashift_hi PARAMS ((int, int, rtx));\n+extern void gen_shifty_op PARAMS ((int, rtx *));\n+extern void gen_shifty_hi_op PARAMS ((int, rtx *));\n+extern int expand_ashiftrt PARAMS ((rtx *));\n+extern int sh_dynamicalize_shift_p PARAMS ((rtx));\n+extern int shl_and_kind PARAMS ((rtx, rtx, int *));\n+extern int shl_and_length PARAMS ((rtx));\n+extern int shl_and_scr_length PARAMS ((rtx));\n+extern int gen_shl_and PARAMS ((rtx, rtx, rtx, rtx));\n+extern int shl_sext_kind PARAMS ((rtx, rtx, int *));\n+extern int shl_sext_length PARAMS ((rtx));\n+extern int gen_shl_sext PARAMS ((rtx, rtx, rtx, rtx));\n+extern int regs_used PARAMS ((rtx, int));\n+extern void fixup_addr_diff_vecs PARAMS ((rtx));\n+extern int get_dest_uid PARAMS ((rtx, int));\n+extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n+extern int system_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int general_movsrc_operand PARAMS ((rtx, enum machine_mode));\n+extern int general_movdst_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_arith_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int fp_extended_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n+extern int logical_operand PARAMS ((rtx, enum machine_mode));\n+extern int tertiary_reload_operand PARAMS ((rtx, enum machine_mode));\n+extern int fpscr_operand PARAMS ((rtx, enum machine_mode));\n+extern int commutative_float_operator PARAMS ((rtx, enum machine_mode));\n+extern int noncommutative_float_operator PARAMS ((rtx, enum machine_mode));\n+extern int binary_float_operator PARAMS ((rtx, enum machine_mode));\n+extern int reg_unused_after PARAMS ((rtx, rtx));\n+extern void expand_sf_unop PARAMS ((rtx (*)(rtx, rtx, rtx), rtx *));\n+extern void expand_sf_binop PARAMS ((rtx (*)(rtx, rtx, rtx, rtx), rtx *));\n+extern void expand_df_unop PARAMS ((rtx (*)(rtx, rtx, rtx), rtx *));\n+extern void expand_df_binop PARAMS ((rtx (*)(rtx, rtx, rtx, rtx), rtx *));\n+extern void expand_fp_branch PARAMS ((rtx (*)(void), rtx (*)(void)));\n+#ifdef TREE_CODE\n+extern void sh_va_start PARAMS ((int, tree, rtx));\n+extern rtx sh_va_arg PARAMS ((tree, tree));\n+#endif /* TREE_CODE */\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern void sh_pragma_insert_attributes PARAMS ((tree, tree *, tree *));\n+extern int sh_valid_machine_decl_attribute PARAMS ((tree, tree, tree, tree));\n+extern tree sh_build_va_list PARAMS ((void));\n+#endif /* TREE_CODE */\n+\n+extern const char *output_jump_label_table PARAMS ((void));\n+extern int sh_handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n+extern struct rtx_def *get_fpscr_rtx PARAMS ((void));\n+extern void output_file_start PARAMS ((FILE *));\n+extern void sh_expand_prologue PARAMS ((void));\n+extern void sh_expand_epilogue PARAMS ((void));\n+extern void function_epilogue PARAMS ((FILE *, int));\n+extern int initial_elimination_offset PARAMS ((int, int));\n+extern void emit_fpscr_use PARAMS ((void));\n+extern void remove_dead_before_cse PARAMS ((void));"}, {"sha": "385c3635b7b5eb9730498afd9c94c9e3a3a39171", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 102, "deletions": 72, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -22,6 +22,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"insn-config.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -32,6 +33,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"tm_p.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \n@@ -130,11 +134,24 @@ enum reg_class reg_class_from_letter[] =\n \n int assembler_dialect;\n \n-rtx get_fpscr_rtx ();\n-void emit_sf_insn ();\n-void emit_df_insn ();\n-\n-static void split_branches PROTO ((rtx));\n+static void split_branches PARAMS ((rtx));\n+static int branch_dest PARAMS ((rtx));\n+static void force_into PARAMS ((rtx, rtx));\n+static void print_slot PARAMS ((rtx));\n+static rtx add_constant PARAMS ((rtx, enum machine_mode, rtx));\n+static void dump_table PARAMS ((rtx));\n+static int hi_const PARAMS ((rtx));\n+static int broken_move PARAMS ((rtx));\n+static int mova_p PARAMS ((rtx));\n+static rtx find_barrier PARAMS ((int, rtx, rtx));\n+static int noncall_uses_reg PARAMS ((rtx, rtx, rtx *));\n+static rtx gen_block_redirect PARAMS ((rtx, int, int));\n+static void output_stack_adjust PARAMS ((int, rtx, int));\n+static void push PARAMS ((int));\n+static void pop PARAMS ((int));\n+static void push_regs PARAMS ((int, int));\n+static int calc_live_regs PARAMS ((int *, int *));\n+static void mark_use PARAMS ((rtx, rtx *));\n \f\n /* Print the operand address in x to the stream.  */\n \n@@ -270,6 +287,8 @@ print_operand (stream, x, code)\n \t    x = adj_offsettable_operand (x, 4);\n \t  print_operand_address (stream, XEXP (x, 0));\n \t  break;\n+\tdefault:\n+\t  break;\n \t}\n       break;\n     case 'o':\n@@ -279,6 +298,8 @@ print_operand (stream, x, code)\n \tcase MINUS: fputs (\"sub\", stream); break;\n \tcase MULT:  fputs (\"mul\", stream); break;\n \tcase DIV:   fputs (\"div\", stream); break;\n+\tdefault:\n+\t  break;\n \t}\n       break;\n     default:\n@@ -303,8 +324,6 @@ print_operand (stream, x, code)\n     }\n }\n \f\n-static void force_into PROTO ((rtx, rtx));\n-\n /* Like force_operand, but guarantees that VALUE ends up in TARGET.  */\n static void\n force_into (value, target)\n@@ -497,6 +516,8 @@ prepare_scc_operands (code)\n     case LEU:\n       code = GEU;\n       break;\n+    default:\n+      break;\n     }\n   if (code != oldcode)\n     {\n@@ -513,7 +534,7 @@ prepare_scc_operands (code)\n   if ((code != EQ && code != NE\n        && (sh_compare_op1 != const0_rtx\n \t   || code == GTU  || code == GEU || code == LTU || code == LEU))\n-      || TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      || (TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT))\n     sh_compare_op1 = force_reg (mode, sh_compare_op1);\n \n   if (TARGET_SH4 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -581,9 +602,9 @@ from_compare (operands, code)\n    Since the SH cannot move a DI or DF in one instruction, we have\n    to take care when we see overlapping source and dest registers.  */\n \n-char *\n+const char *\n output_movedouble (insn, operands, mode)\n-     rtx insn;\n+     rtx insn ATTRIBUTE_UNUSED;\n      rtx operands[];\n      enum machine_mode mode;\n {\n@@ -668,13 +689,13 @@ print_slot (insn)\n   INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n }\n \n-char *\n+const char *\n output_far_jump (insn, op)\n      rtx insn;\n      rtx op;\n {\n   struct { rtx lab, reg, op; } this;\n-  char *jump;\n+  const char *jump;\n   int far;\n   int offset = branch_dest (insn) - insn_addresses[INSN_UID (insn)];\n \n@@ -729,7 +750,7 @@ static int lf = 100;\n \n /* Output code for ordinary branches.  */\n \n-char *\n+const char *\n output_branch (logic, insn, operands)\n      int logic;\n      rtx insn;\n@@ -781,15 +802,14 @@ output_branch (logic, insn, operands)\n     }\n }\n \n-char *\n+const char *\n output_branchy_insn (code, template, insn, operands)\n-     char *template;\n      enum rtx_code code;\n+     const char *template;\n      rtx insn;\n      rtx *operands;\n {\n   rtx next_insn = NEXT_INSN (insn);\n-  int label_nr;\n \n   if (next_insn && GET_CODE (next_insn) == JUMP_INSN && condjump_p (next_insn))\n     {\n@@ -820,11 +840,11 @@ output_branchy_insn (code, template, insn, operands)\n   return template;\n }\n \n-char *\n+const char *\n output_ieee_ccmpeq (insn, operands)\n-     rtx insn, operands;\n+     rtx insn, *operands;\n {\n-  output_branchy_insn (NE, \"bt\\t%l9\\\\;fcmp/eq\\t%1,%0\", insn, operands);\n+  return output_branchy_insn (NE, \"bt\\t%l9\\\\;fcmp/eq\\t%1,%0\", insn, operands);\n }\n \f\n /* Output to FILE the start of the assembler file.  */\n@@ -833,8 +853,6 @@ void\n output_file_start (file)\n      FILE *file;\n {\n-  register int pos;\n-\n   output_file_directive (file, main_input_filename);\n \n   /* Switch to the data section so that the coffsem symbol and the\n@@ -969,7 +987,7 @@ andcosts (x)\n /* Return the cost of a multiply.  */\n int\n multcosts (x)\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n {\n   if (TARGET_SH2)\n     {\n@@ -1071,7 +1089,7 @@ gen_ashift_hi (type, n, reg)\n /* Output RTL to split a constant shift into its component SH constant\n    shift instructions.  */\n    \n-int\n+void\n gen_shifty_op (code, operands)\n      int code;\n      rtx *operands;\n@@ -1119,14 +1137,14 @@ gen_shifty_op (code, operands)\n /* Same as above, but optimized for values where the topmost bits don't\n    matter.  */\n \n-int\n+void\n gen_shifty_hi_op (code, operands)\n      int code;\n      rtx *operands;\n {\n   int value = INTVAL (operands[2]);\n   int max, i;\n-  void (*gen_fun)();\n+  void (*gen_fun) PARAMS ((int, int, rtx));\n \n   /* This operation is used by and_shl for SImode values with a few\n      high bits known to be cleared.  */\n@@ -1226,7 +1244,8 @@ expand_ashiftrt (operands)\n   return 1;\n }\n \n-int sh_dynamicalize_shift_p (count)\n+int\n+sh_dynamicalize_shift_p (count)\n      rtx count;\n {\n   return shift_insns[INTVAL (count)] > 1 + SH_DYNAMIC_SHIFT_COST;\n@@ -1293,7 +1312,7 @@ shl_and_kind (left_rtx, mask_rtx, attrp)\n       for (width = 8; width <= 16; width += 8)\n \t{\n \t  /* Can we zero-extend right away? */\n-\t  if (lsb2 == (HOST_WIDE_INT)1 << width)\n+\t  if (lsb2 == (unsigned HOST_WIDE_INT)1 << width)\n \t    {\n \t      cost\n \t\t= 1 + ext_shift_insns[right] + ext_shift_insns[left + right];\n@@ -1414,7 +1433,7 @@ gen_shl_and (dest, left_rtx, mask_rtx, source)\n   unsigned HOST_WIDE_INT mask;\n   int kind = shl_and_kind (left_rtx, mask_rtx, attributes);\n   int right, total_shift;\n-  int (*shift_gen_fun) PROTO((int, rtx*)) = gen_shifty_hi_op;\n+  void (*shift_gen_fun) PARAMS ((int, rtx*)) = gen_shifty_hi_op;\n \n   right = attributes[0];\n   total_shift = INTVAL (left_rtx) + right;\n@@ -1469,7 +1488,7 @@ gen_shl_and (dest, left_rtx, mask_rtx, source)\n       /* If the topmost bit that matters is set, set the topmost bits\n \t that don't matter.  This way, we might be able to get a shorter\n \t signed constant.  */\n-      if (mask & ((HOST_WIDE_INT)1 << 31 - total_shift))\n+      if (mask & ((HOST_WIDE_INT)1 << (31 - total_shift)))\n \tmask |= (HOST_WIDE_INT)~0 << (31 - total_shift);\n     case 2:\n       /* Don't expand fine-grained when combining, because that will\n@@ -1853,9 +1872,9 @@ static int pool_size;\n \n static rtx\n add_constant (x, mode, last_value)\n-     rtx last_value;\n      rtx x;\n      enum machine_mode mode;\n+     rtx last_value;\n {\n   int i;\n   rtx lab;\n@@ -2173,26 +2192,27 @@ find_barrier (num_mova, mova, from)\n \t{\n \t  if (new_align > si_align)\n \t    {\n-\t      si_limit -= count_si - 1 & new_align - si_align;\n+\t      si_limit -= (count_si - 1) & (new_align - si_align);\n \t      si_align = new_align;\n \t    }\n-\t  count_si = count_si + new_align - 1 & -new_align;\n+\t  count_si = (count_si + new_align - 1) & -new_align;\n \t  count_si += inc;\n \t}\n       if (found_hi)\n \t{\n \t  if (new_align > hi_align)\n \t    {\n-\t      hi_limit -= count_hi - 1 & new_align - hi_align;\n+\t      hi_limit -= (count_hi - 1) & (new_align - hi_align);\n \t      hi_align = new_align;\n \t    }\n-\t  count_hi = count_hi + new_align - 1 & -new_align;\n+\t  count_hi = (count_hi + new_align - 1) & -new_align;\n \t  count_hi += inc;\n \t}\n       from = NEXT_INSN (from);\n     }\n \n   if (num_mova)\n+  {\n     if (leading_mova)\n       {\n \t/* Try as we might, the leading mova is out of range.  Change\n@@ -2208,6 +2228,7 @@ find_barrier (num_mova, mova, from)\n \tfrom = mova;\n \tgood_barrier = found_barrier = barrier_before_mova;\n       }\n+  }\n \n   if (found_barrier)\n     {\n@@ -2421,6 +2442,8 @@ regs_used (x, is_dest)\n     case CALL:\n       used |= 0x00ff00f0;\n       break;\n+    default:\n+      break;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n@@ -2489,7 +2512,7 @@ gen_block_redirect (jump, addr, need_block)\n \t the delay slot.  Therefore, find out which registers it uses, and\n \t try to avoid using them.  */\n \t \n-      for (scan = jump; scan = PREV_INSN (scan); )\n+      for (scan = jump; (scan = PREV_INSN (scan)); )\n \t{\n \t  enum rtx_code code;\n \n@@ -2507,7 +2530,7 @@ gen_block_redirect (jump, addr, need_block)\n \t      break;\n \t    }\n \t}\n-      for (used = dead = 0, scan = JUMP_LABEL (jump); scan = NEXT_INSN (scan); )\n+      for (used = dead = 0, scan = JUMP_LABEL (jump); (scan = NEXT_INSN (scan)); )\n \t{\n \t  enum rtx_code code;\n \n@@ -2526,10 +2549,12 @@ gen_block_redirect (jump, addr, need_block)\n \t\t  break;\n \t\t}\n \t      if (code == JUMP_INSN)\n+\t      {\n \t\tif (jump_left-- && simplejump_p (scan))\n \t\t  scan = JUMP_LABEL (scan);\n \t\telse\n \t\t  break;\n+\t      }\n \t    }\n \t}\n       /* Mask out the stack pointer again, in case it was\n@@ -2599,6 +2624,7 @@ struct far_branch\n   int address;\n };\n \n+static  void gen_far_branch PARAMS ((struct far_branch *));\n enum mdep_reorg_phase_e mdep_reorg_phase;\n void\n gen_far_branch (bp)\n@@ -3068,7 +3094,6 @@ machine_dependent_reorg (first)\n \t\t  rtx *patp = &PATTERN (scan), pat = *patp;\n \t\t  rtx src, dst;\n \t\t  rtx lab;\n-\t\t  rtx newinsn;\n \t\t  rtx newsrc;\n \t\t  enum machine_mode mode;\n \n@@ -3131,7 +3156,7 @@ machine_dependent_reorg (first)\n \t\t      last_float_move = scan;\n \t\t      last_float = src;\n \t\t      newsrc = gen_rtx (MEM, mode,\n-\t\t\t\t\t((TARGET_SH4 && ! TARGET_FMOVD\n+\t\t\t\t\t(((TARGET_SH4 && ! TARGET_FMOVD)\n \t\t\t\t\t  || REGNO (dst) == FPUL_REG)\n \t\t\t\t\t ? r0_inc_rtx\n \t\t\t\t\t : r0_rtx));\n@@ -3257,9 +3282,7 @@ split_branches (first)\n \t    if (get_attr_length (insn) > 4)\n \t      {\n \t\trtx src = SET_SRC (PATTERN (insn));\n-\t\trtx cond = XEXP (src, 0);\n \t\trtx olabel = XEXP (XEXP (src, 1), 0);\n-\t\trtx jump;\n \t\tint addr = insn_addresses[INSN_UID (insn)];\n \t\trtx label = 0;\n \t\tint dest_uid = get_dest_uid (olabel, max_uid);\n@@ -3303,13 +3326,15 @@ split_branches (first)\n \t\t\tbp->near_label = label;\n \t\t      }\n \t\t    else if (label && ! NEXT_INSN (label))\n+\t\t    {\n \t\t      if (addr + 2 - bp->address <= CONDJUMP_MAX)\n \t\t\tbp->insert_place = insn;\n \t\t      else\n \t\t\tgen_far_branch (bp);\n+\t\t    }\n \t\t  }\n \t\tif (! label\n-\t\t    || NEXT_INSN (label) && bp->address - addr < CONDJUMP_MIN)\n+\t\t    || (NEXT_INSN (label) && bp->address - addr < CONDJUMP_MIN))\n \t\t  {\n \t\t    bp->near_label = label = gen_label_rtx ();\n \t\t    bp->insert_place = insn;\n@@ -3448,8 +3473,8 @@ split_branches (first)\n void\n final_prescan_insn (insn, opvec, noperands)\n      rtx insn;\n-     rtx *opvec;\n-     int noperands;\n+     rtx *opvec ATTRIBUTE_UNUSED;\n+     int noperands ATTRIBUTE_UNUSED;\n {\n   if (TARGET_DUMPISIZE)\n     fprintf (asm_out_file, \"\\n! at %04x\\n\", insn_addresses[INSN_UID (insn)]);\n@@ -3484,7 +3509,7 @@ final_prescan_insn (insn, opvec, noperands)\n /* Dump out any constants accumulated in the final pass.  These will\n    only be labels.  */\n \n-char *\n+const char *\n output_jump_label_table ()\n {\n   int i;\n@@ -3712,6 +3737,7 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t    live_regs_mask |= 1 << reg;\n \t  count++;\n \t  if (TARGET_SH4 && TARGET_FMOVD && reg >= FIRST_FP_REG)\n+\t  {\n \t    if (reg <= LAST_FP_REG)\n \t      {\n \t\tif (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n@@ -3729,6 +3755,7 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t\ttarget_flags &= ~FPU_SINGLE_BIT;\n \t\tcount++;\n \t      }\n+\t  }\n \t}\n     }\n \n@@ -3868,8 +3895,8 @@ sh_expand_epilogue ()\n \n void\n function_epilogue (stream, size)\n-     FILE *stream;\n-     int size;\n+     FILE *stream ATTRIBUTE_UNUSED;\n+     int size ATTRIBUTE_UNUSED;\n {\n   trap_exit = pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n   sp_switch = NULL_RTX;\n@@ -3878,7 +3905,6 @@ function_epilogue (stream, size)\n rtx\n sh_builtin_saveregs ()\n {\n-  tree fntype = TREE_TYPE (current_function_decl);\n   /* First unnamed integer register.  */\n   int first_intreg = current_function_args_info.arg_count[(int) SH_ARG_INT];\n   /* Number of integer registers we need to save.  */\n@@ -3887,8 +3913,7 @@ sh_builtin_saveregs ()\n   int first_floatreg = current_function_args_info.arg_count[(int) SH_ARG_FLOAT];\n   /* Number of SFmode float regs to save.  */\n   int n_floatregs = MAX (0, NPARM_REGS (SFmode) - first_floatreg);\n-  int ptrsize = GET_MODE_SIZE (Pmode);\n-  rtx valist, regbuf, fpregs;\n+  rtx regbuf, fpregs;\n   int bufsize, regno, alias_set;\n \n   /* Allocate block of memory for the regs. */\n@@ -4088,7 +4113,7 @@ sh_va_arg (valist, type)\n      tree valist, type;\n {\n   HOST_WIDE_INT size, rsize;\n-  tree base, tmp, pptr_type_node;\n+  tree tmp, pptr_type_node;\n   rtx addr_rtx, r;\n \n   size = int_size_in_bytes (type);\n@@ -4260,9 +4285,9 @@ initial_elimination_offset (from, to)\n \n int\n sh_handle_pragma (p_getc, p_ungetc, pname)\n-     int (*  p_getc)   PROTO((void));\n-     void (* p_ungetc) PROTO((int));\n-     char *  pname;\n+     int (*  p_getc)   PARAMS ((void)) ATTRIBUTE_UNUSED;\n+     void (* p_ungetc) PARAMS ((int)) ATTRIBUTE_UNUSED;\n+     const char * pname;\n {\n   int retval = 0;\n \n@@ -4282,10 +4307,8 @@ void\n sh_pragma_insert_attributes (node, attributes, prefix)\n      tree node;\n      tree * attributes;\n-     tree * prefix;\n+     tree * prefix ATTRIBUTE_UNUSED;\n {\n-  tree a;\n-\n   if (! pragma_interrupt\n       || TREE_CODE (node) != FUNCTION_DECL)\n     return;\n@@ -4317,12 +4340,10 @@ sh_pragma_insert_attributes (node, attributes, prefix)\n int\n sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n      tree decl;\n-     tree attributes;\n+     tree attributes ATTRIBUTE_UNUSED;\n      tree attr;\n      tree args;\n {\n-  int retval = 0;\n-\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     return 0;\n \n@@ -4367,6 +4388,8 @@ sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n       trap_exit = TREE_INT_CST_LOW (TREE_VALUE (args));\n       return 1;\n     }\n+\n+  return 0;\n }\n \n \f\n@@ -4378,7 +4401,7 @@ sh_valid_machine_decl_attribute (decl, attributes, attr, args)\n int\n system_reg_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (REGNO (op))\n     {\n@@ -4597,15 +4620,16 @@ fp_one_operand (op)\n int\n tertiary_reload_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   enum rtx_code code = GET_CODE (op);\n   return code == MEM || (TARGET_SH4 && code == CONST_DOUBLE);\n }\n \n int\n-fpscr_operand (op)\n+fpscr_operand (op, mode)\n      rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == REG && REGNO (op) == FPSCR_REG\n \t  && GET_MODE (op) == PSImode);\n@@ -4623,6 +4647,8 @@ commutative_float_operator (op, mode)\n     case PLUS:\n     case MULT:\n       return 1;\n+    default:\n+      break;\n     }\n   return 0;\n }\n@@ -4639,6 +4665,8 @@ noncommutative_float_operator (op, mode)\n     case MINUS:\n     case DIV:\n       return 1;\n+    default:\n+      break;\n     }\n   return 0;\n }\n@@ -4657,13 +4685,15 @@ binary_float_operator (op, mode)\n     case MULT:\n     case DIV:\n       return 1;\n+    default:\n+      break;\n     }\n   return 0;\n }\n \f\n /* Return the destination address of a branch.  */\n    \n-int\n+static int\n branch_dest (branch)\n      rtx branch;\n {\n@@ -4696,7 +4726,7 @@ reg_unused_after (reg, insn)\n       && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n     return 1;\n \n-  while (insn = NEXT_INSN (insn))\n+  while ((insn = NEXT_INSN (insn)))\n     {\n       code = GET_CODE (insn);\n \n@@ -4832,15 +4862,15 @@ emit_df_insn (pat)\n \n void\n expand_sf_unop (fun, operands)\n-     rtx (*fun)();\n+     rtx (*fun) PARAMS ((rtx, rtx, rtx));\n      rtx *operands;\n {\n   emit_sf_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n }\n \n void\n expand_sf_binop (fun, operands)\n-     rtx (*fun)();\n+     rtx (*fun) PARAMS ((rtx, rtx, rtx, rtx));\n      rtx *operands;\n {\n   emit_sf_insn ((*fun) (operands[0], operands[1], operands[2],\n@@ -4849,15 +4879,15 @@ expand_sf_binop (fun, operands)\n \n void\n expand_df_unop (fun, operands)\n-     rtx (*fun)();\n+     rtx (*fun) PARAMS ((rtx, rtx, rtx));\n      rtx *operands;\n {\n   emit_df_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n }\n \n void\n expand_df_binop (fun, operands)\n-     rtx (*fun)();\n+     rtx (*fun) PARAMS ((rtx, rtx, rtx, rtx));\n      rtx *operands;\n {\n   emit_df_insn ((*fun) (operands[0], operands[1], operands[2],\n@@ -4866,7 +4896,7 @@ expand_df_binop (fun, operands)\n \n void\n expand_fp_branch (compare, branch)\n-     rtx (*compare) (), (*branch) ();\n+     rtx (*compare) PARAMS ((void)), (*branch) PARAMS ((void));\n {\n   (GET_MODE (sh_compare_op0)  == SFmode ? emit_sf_insn : emit_df_insn)\n     ((*compare) ());\n@@ -4881,7 +4911,7 @@ expand_fp_branch (compare, branch)\n /* This should best be called at about the time FINALIZE_PIC is called,\n    but not dependent on flag_pic.  Alas, there is no suitable hook there,\n    so this gets called from HAVE_RETURN.  */\n-int\n+void\n emit_fpscr_use ()\n {\n   static int fpscr_uses = 0;\n@@ -5006,7 +5036,7 @@ mark_use (x, reg_set_block)\n     }\n }\n \n-int\n+void\n remove_dead_before_cse ()\n {\n   rtx *reg_set_block, last, last_call, insn, set;\n@@ -5070,5 +5100,5 @@ remove_dead_before_cse ()\n \t}\n       mark_use (PATTERN (insn), reg_set_block);\n     }\n-  return 0;\n+  return;\n }"}, {"sha": "f101ca7ec3f502fc2c57d778682e9c3e999c095c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 10, "deletions": 29, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -799,7 +799,7 @@ extern enum reg_class reg_class_from_letter[];\n       : R0_REGS)\t\t\t\t\t\t\t\\\n    : (CLASS == FPSCR_REGS\t\t\t\t\t\t\\\n       && ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\\\n-\t  || GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS))\t\\\n+\t  || (GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS)))\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : SECONDARY_OUTPUT_RELOAD_CLASS((CLASS),(MODE),(X)))\n \n@@ -1011,8 +1011,8 @@ struct sh_args {\n \n #define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n   (((TYPE) == 0 \\\n-    || (! TREE_ADDRESSABLE ((tree)(TYPE))) \\\n-\t&& (! TARGET_HITACHI || ! AGGREGATE_TYPE_P (TYPE))) \\\n+    || ((! TREE_ADDRESSABLE ((tree)(TYPE))) \\\n+\t&& (! TARGET_HITACHI || ! AGGREGATE_TYPE_P (TYPE)))) \\\n    && (TARGET_SH3E \\\n        ? ((MODE) == BLKmode \\\n \t  ? (((CUM).arg_count[(int) SH_ARG_INT] * UNITS_PER_WORD \\\n@@ -1135,7 +1135,7 @@ extern int current_function_anonymous_args;\n \n /* Alignment required for a trampoline in bits .  */\n #define TRAMPOLINE_ALIGNMENT \\\n-  ((CACHE_LOG < 3 || TARGET_SMALLCODE && ! TARGET_HARVARD) ? 32 : 64)\n+  ((CACHE_LOG < 3 || (TARGET_SMALLCODE && ! TARGET_HARVARD)) ? 32 : 64)\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -1166,7 +1166,6 @@ extern int current_function_anonymous_args;\n    : (rtx) 0)\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n-extern struct rtx_def *sh_builtin_saveregs ();\n #define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n \f\n /* Addressing modes, and classification of registers for them.  */\n@@ -1344,7 +1343,7 @@ extern struct rtx_def *sh_builtin_saveregs ();\n       if (GET_MODE_SIZE (MODE) <= 8 && BASE_REGISTER_RTX_P (xop0))\t\\\n \tGO_IF_LEGITIMATE_INDEX ((MODE), xop1, LABEL);\t\t\t\\\n       if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n-\t  || TARGET_SH4 && TARGET_FMOVD && MODE == DFmode)\t\\\n+\t  || (TARGET_SH4 && TARGET_FMOVD && MODE == DFmode))\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (BASE_REGISTER_RTX_P (xop1) && INDEX_REGISTER_RTX_P (xop0))\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n@@ -1843,10 +1842,10 @@ dtors_section()\t\t\t\t\t\t\t\\\n }\n \n #define ASM_OUTPUT_REG_PUSH(file, v) \\\n-  fprintf ((file), \"\\tmov.l\\tr%s,-@r15\\n\", (v));\n+  fprintf ((file), \"\\tmov.l\\tr%d,-@r15\\n\", (v));\n \n #define ASM_OUTPUT_REG_POP(file, v) \\\n-  fprintf ((file), \"\\tmov.l\\t@r15+,r%s\\n\", (v));\n+  fprintf ((file), \"\\tmov.l\\t@r15+,r%d\\n\", (v));\n \n /* The assembler's names for the registers.  RFP need not always be used as\n    the Real framepointer; it can also be used as a normal general register.\n@@ -1918,7 +1917,7 @@ extern char fp_reg_names[][5];\n \n /* Make an internal label into a string.  */\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM) \\\n-  sprintf ((STRING), \"*%s%s%d\", LOCAL_LABEL_PREFIX, (PREFIX), (NUM))\n+  sprintf ((STRING), \"*%s%s%ld\", LOCAL_LABEL_PREFIX, (PREFIX), (long)(NUM))\n \n /* Output an internal label definition.  */\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM) \\\n@@ -1945,6 +1944,8 @@ extern char fp_reg_names[][5];\n     case QImode:\t\t\t\t\t\t\t\\\n       asm_fprintf ((STREAM), \"\\t.byte\\t%LL%d-%LL%d\\n\", (VALUE),(REL));\t\\\n       break;\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n     }\n \n /* Output an absolute table element.  */\n@@ -2062,7 +2063,6 @@ do { char dstr[30];\t\t\t\t\t\\\n \f\n extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n-extern struct rtx_def *prepare_scc_operands();\n \n /* Which processor to schedule for.  The elements of the enumeration must\n    match exactly the cpu attribute in the sh.md file.  */\n@@ -2082,17 +2082,6 @@ extern enum machine_mode sh_addr_diff_vec_mode;\n \n extern int optimize; /* needed for gen_casesi.  */\n \n-/* Declare functions defined in sh.c and used in templates.  */\n-\n-extern char *output_branch();\n-extern char *output_ieee_ccmpeq();\n-extern char *output_branchy_insn();\n-extern char *output_shift();\n-extern char *output_movedouble();\n-extern char *output_movepcrel();\n-extern char *output_jump_label_table();\n-extern char *output_far_jump();\n-\n enum mdep_reorg_phase_e\n {\n   SH_BEFORE_MDEP_REORG,\n@@ -2105,10 +2094,6 @@ enum mdep_reorg_phase_e\n \n extern enum mdep_reorg_phase_e mdep_reorg_phase;\n \n-void machine_dependent_reorg ();\n-struct rtx_def *sfunc_uses_reg ();\n-int barrier_align ();\n-\n #define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg(X)\n \n /* Generate calls to memcpy, memcmp and memset.  */\n@@ -2119,7 +2104,6 @@ int barrier_align ();\n    is a C expression whose value is 1 if the pragma was handled by the\n    macro, zero otherwise.  */\n #define HANDLE_PRAGMA(GETC, UNGETC, NODE) sh_handle_pragma (GETC, UNGETC, NODE)\n-extern int sh_handle_pragma ();\n \n /* Set when processing a function with pragma interrupt turned on.  */\n \n@@ -2132,18 +2116,15 @@ extern struct rtx_def *sp_switch;\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n-extern int sh_valid_machine_decl_attribute ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n-extern void sh_pragma_insert_attributes ();\n #define PRAGMA_INSERT_ATTRIBUTES(node, pattr, prefix_attr) \\\n   sh_pragma_insert_attributes (node, pattr, prefix_attr)\n \n extern int sh_flag_remove_dead_before_cse;\n extern int rtx_equal_function_value_matters;\n extern struct rtx_def *fpscr_rtx;\n-extern struct rtx_def *get_fpscr_rtx ();\n \n \f\n /* Instructions with unfilled delay slots take up an extra two bytes for"}, {"sha": "2334b83aad147cae3d05cdcf5abf343804207d50", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/318881c06efdf1bc4039f1bba7eab820d69735a2/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=318881c06efdf1bc4039f1bba7eab820d69735a2", "patch": "@@ -2365,8 +2365,8 @@\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"r,FQ,m,r\"))]\n   \"(! TARGET_SH4 || reload_completed\n     /* ??? We provide some insn so that direct_{load,store}[DFmode] get set */\n-    || GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3\n-    || GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3)\n+    || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3)\n+    || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3))\n    && (arith_reg_operand (operands[0], DFmode)\n        || arith_reg_operand (operands[1], DFmode))\"\n   \"* return output_movedouble (insn, operands, DFmode);\"\n@@ -2821,8 +2821,8 @@\n   \"\n    (! TARGET_SH3E\n     /* ??? We provide some insn so that direct_{load,store}[SFmode] get set */\n-    || GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3\n-    || GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3)\n+    || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3)\n+    || (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3))\n    && (arith_reg_operand (operands[0], SFmode)\n        || arith_reg_operand (operands[1], SFmode))\"\n   \"@\n@@ -3467,7 +3467,6 @@\n     {\n       if (TARGET_IEEE)\n \t{\n-\t  rtx t_reg = gen_rtx_REG (SImode, T_REG);\n \t  rtx lab = gen_label_rtx ();\n \t  prepare_scc_operands (EQ);\n \t  emit_jump_insn (gen_branch_true (lab));"}]}