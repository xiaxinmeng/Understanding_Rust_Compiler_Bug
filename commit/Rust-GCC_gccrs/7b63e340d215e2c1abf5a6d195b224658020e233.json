{"sha": "7b63e340d215e2c1abf5a6d195b224658020e233", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I2M2UzNDBkMjE1ZTJjMWFiZjVhNmQxOTViMjI0NjU4MDIwZTIzMw==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2004-06-29T01:39:37Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-06-29T01:39:37Z"}, "message": "Expression.java: New file.\n\n2004-06-28  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* java/beans/Expression.java: New file.\n\t* java/beans/Statement.java: New file.\n\t* Makefile.am: Added new files.\n\t* Makefile.in: Re-generate.\n\nFrom-SVN: r83836", "tree": {"sha": "4c8a0b8d4a4b1fa8601144228fb18ec6acea5bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c8a0b8d4a4b1fa8601144228fb18ec6acea5bda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b63e340d215e2c1abf5a6d195b224658020e233", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b63e340d215e2c1abf5a6d195b224658020e233", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b63e340d215e2c1abf5a6d195b224658020e233", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b63e340d215e2c1abf5a6d195b224658020e233/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1fe2e047c833096430c8a30ce20455c66c780e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1fe2e047c833096430c8a30ce20455c66c780e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1fe2e047c833096430c8a30ce20455c66c780e5"}], "stats": {"total": 476, "additions": 470, "deletions": 6}, "files": [{"sha": "92d6ba0d8cfd307341beaf449375b7b0438eef2a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7b63e340d215e2c1abf5a6d195b224658020e233", "patch": "@@ -1,3 +1,10 @@\n+2004-06-28  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* java/beans/Expression.java: New file.\n+\t* java/beans/Statement.java: New file.\n+\t* Makefile.am: Added new files.\n+\t* Makefile.in: Re-generate.\n+\n 2004-06-27 Mark Wielaard  <mark@klomp.org>\n \n \t* java/io/FilePermission.java (usingPerms): Removed."}, {"sha": "cd893bb188640ff8d5887053d74ee4f90379c0e6", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=7b63e340d215e2c1abf5a6d195b224658020e233", "patch": "@@ -1284,6 +1284,7 @@ java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n java/beans/EventSetDescriptor.java \\\n java/beans/ExceptionListener.java \\\n+java/beans/Expression.java \\\n java/beans/FeatureDescriptor.java \\\n java/beans/IndexedPropertyDescriptor.java \\\n java/beans/IntrospectionException.java \\\n@@ -1299,6 +1300,7 @@ java/beans/PropertyEditor.java \\\n java/beans/PropertyEditorManager.java \\\n java/beans/PropertyEditorSupport.java \\\n java/beans/PropertyVetoException.java \\\n+java/beans/Statement.java \\\n java/beans/SimpleBeanInfo.java \\\n java/beans/VetoableChangeListener.java \\\n java/beans/VetoableChangeListenerProxy.java \\"}, {"sha": "4a1cd9b973bc40d4aff533d89f29fc914dd54eee", "filename": "libjava/Makefile.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=7b63e340d215e2c1abf5a6d195b224658020e233", "patch": "@@ -963,6 +963,7 @@ java/beans/Customizer.java \\\n java/beans/DesignMode.java \\\n java/beans/EventSetDescriptor.java \\\n java/beans/ExceptionListener.java \\\n+java/beans/Expression.java \\\n java/beans/FeatureDescriptor.java \\\n java/beans/IndexedPropertyDescriptor.java \\\n java/beans/IntrospectionException.java \\\n@@ -978,6 +979,7 @@ java/beans/PropertyEditor.java \\\n java/beans/PropertyEditorManager.java \\\n java/beans/PropertyEditorSupport.java \\\n java/beans/PropertyVetoException.java \\\n+java/beans/Statement.java \\\n java/beans/SimpleBeanInfo.java \\\n java/beans/VetoableChangeListener.java \\\n java/beans/VetoableChangeListenerProxy.java \\\n@@ -3084,8 +3086,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/classpath/ServiceFactory.P \\\n .deps/gnu/classpath/ServiceProviderLoadingAction.P .deps/gnu/gcj/Core.P \\\n .deps/gnu/gcj/RawData.P .deps/gnu/gcj/RawDataManaged.P \\\n-.deps/gnu/gcj/convert/BytesToUnicode.P \\\n-.deps/gnu/gcj/convert/Convert.P .deps/gnu/gcj/convert/IOConverter.P \\\n+.deps/gnu/gcj/convert/BytesToUnicode.P .deps/gnu/gcj/convert/Convert.P \\\n+.deps/gnu/gcj/convert/IOConverter.P \\\n .deps/gnu/gcj/convert/Input_8859_1.P \\\n .deps/gnu/gcj/convert/Input_ASCII.P \\\n .deps/gnu/gcj/convert/Input_EUCJIS.P \\\n@@ -3480,8 +3482,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/util/prefs/MemoryBasedFactory.P \\\n .deps/gnu/java/util/prefs/MemoryBasedPreferences.P \\\n .deps/gnu/java/util/prefs/NodeReader.P \\\n-.deps/gnu/java/util/prefs/NodeWriter.P \\\n-.deps/gnu/regexp/CharIndexed.P \\\n+.deps/gnu/java/util/prefs/NodeWriter.P .deps/gnu/regexp/CharIndexed.P \\\n .deps/gnu/regexp/CharIndexedCharArray.P \\\n .deps/gnu/regexp/CharIndexedInputStream.P \\\n .deps/gnu/regexp/CharIndexedString.P \\\n@@ -3723,7 +3724,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/beans/BeanDescriptor.P .deps/java/beans/BeanInfo.P \\\n .deps/java/beans/Beans.P .deps/java/beans/Customizer.P \\\n .deps/java/beans/DesignMode.P .deps/java/beans/EventSetDescriptor.P \\\n-.deps/java/beans/ExceptionListener.P \\\n+.deps/java/beans/ExceptionListener.P .deps/java/beans/Expression.P \\\n .deps/java/beans/FeatureDescriptor.P \\\n .deps/java/beans/IndexedPropertyDescriptor.P \\\n .deps/java/beans/IntrospectionException.P \\\n@@ -3737,7 +3738,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/beans/PropertyEditorManager.P \\\n .deps/java/beans/PropertyEditorSupport.P \\\n .deps/java/beans/PropertyVetoException.P \\\n-.deps/java/beans/SimpleBeanInfo.P \\\n+.deps/java/beans/SimpleBeanInfo.P .deps/java/beans/Statement.P \\\n .deps/java/beans/VetoableChangeListener.P \\\n .deps/java/beans/VetoableChangeListenerProxy.P \\\n .deps/java/beans/VetoableChangeSupport.P .deps/java/beans/Visibility.P \\"}, {"sha": "33268d19e15bd4b6686cf3cd68d5a07479462331", "filename": "libjava/java/beans/Expression.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2Fjava%2Fbeans%2FExpression.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2Fjava%2Fbeans%2FExpression.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FExpression.java?ref=7b63e340d215e2c1abf5a6d195b224658020e233", "patch": "@@ -0,0 +1,133 @@\n+/* java.beans.Expression\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+/**\n+ * class Expression\n+ *\n+ * An Expression captures the execution of an object method that\n+ * returns a value.  It stores an object, the method to call, and the\n+ * arguments to pass to the method.\n+ *\n+ * @since 1.4\n+ */\n+public class Expression extends Statement\n+{\n+  // This is a placeholder to indicate that value hasn't been set\n+  // yet;\n+  private static final Object unset = new Object();\n+\n+  // The value to return.  This is equal to unset until getValue is called.\n+  private Object value;\n+   \n+\n+  /**\n+   * Constructor\n+   *\n+   * Constructs an Expression representing the invocation of\n+   * object.methodName(arg[0], arg[1], ...);  However, it will never\n+   * be executed.  Instead, value will always be returned.\n+   *\n+   * @param value The value to return.\n+   * @param target The object to invoke the method on.\n+   * @param methodName The object method to invoke.\n+   * @param arguments An array of arguments to pass to the method.\n+   */\n+  public Expression(Object value, Object target, String methodName,\n+\t\t    Object[] arguments)\n+  {\n+    super(target, methodName, arguments);\n+    this.value = value;\n+  }\n+\n+  /**\n+   * Constructor\n+   *\n+   * Constructs an Expression representing the invocation of\n+   * object.methodName(arg[0], arg[1], ...);\n+   *\n+   * @param target The object to invoke the method on.\n+   * @param methodName The object method to invoke.\n+   * @param arguments An array of arguments to pass to the method.\n+   */\n+  public Expression(Object target, String methodName, Object[] arguments)\n+  {\n+    super(target, methodName, arguments);\n+    this.value = unset;\n+  }\n+\n+  /**\n+   * Return the result of executing the method.\n+   *\n+   * If the cached value has not yet been set, the method is\n+   * executed in the same way as Statement.execute(), except that\n+   * the value is cached, and then returned.  If the value has been\n+   * set, it is returned without executing the method again.\n+   *\n+   * @return the result of executing the method.\n+   * @exception Exception if an error occurs\n+   */\n+  public Object getValue() throws Exception\n+  {\n+    if (value == unset)\n+      value = doExecute();\n+    return value;\n+  }\n+\n+  /**\n+   * Set the cached value to be returned by getValue()\n+   *\n+   * @param value the value to cache and return.\n+   */\n+  public void setValue(Object value)\n+  {\n+    this.value = value;\n+  }\n+    \n+  /**\n+   * Return a string representation of this expression.\n+   */\n+  public String toString()\n+  {\n+    String result = super.toString();\n+    if (value != unset)\n+      return value.getClass().getName() + \" \" + result;\n+    return result;\n+  }\n+}"}, {"sha": "7ee25bcafbc236d9b46cf81d9a13a33354dd6945", "filename": "libjava/java/beans/Statement.java", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2Fjava%2Fbeans%2FStatement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b63e340d215e2c1abf5a6d195b224658020e233/libjava%2Fjava%2Fbeans%2FStatement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FStatement.java?ref=7b63e340d215e2c1abf5a6d195b224658020e233", "patch": "@@ -0,0 +1,321 @@\n+/* java.beans.Statement\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.beans;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * class Statement\n+ *\n+ * A Statement captures the execution of an object method.  It stores\n+ * the object, the method to call, and the arguments to the method and\n+ * provides the ability to execute the method on the object, using the\n+ * provided arguments.\n+ *\n+ * @since 1.4\n+ */\n+public class Statement\n+{\n+  private Object target;\n+  private String methodName;\n+  private Object[] arguments;\n+\n+  // One or the other of these will get a value after execute is\n+  // called once, but not both.\n+  private transient Method method;\n+  private transient Constructor ctor;\n+\n+  /**\n+   * Constructs a statement representing the invocation of\n+   * object.methodName(arg[0], arg[1], ...);\n+   *\n+   * @param target The object to invoke the method on.\n+   * @param methodName The object method to invoke.\n+   * @param arguments An array of arguments to pass to the method.\n+   */\n+  public Statement(Object target, String methodName, Object[] arguments)\n+  {\n+    this.target = target;\n+    this.methodName = methodName;\n+    this.arguments = arguments;\n+  }\n+\n+  /**\n+   * Execute the statement.\n+   *\n+   * Finds the specified method in the target object and calls it with\n+   * the arguments given in the constructor.\n+   *\n+   * The most specific method according to the JLS(15.11) is used when\n+   * there are multiple methods with the same name.\n+   *\n+   * Execute performs some special handling for methods and\n+   * parameters:\n+   *\n+   * Static methods can be executed by providing the class as a\n+   * target.\n+   *\n+   * The method name new is reserved to call the constructor \n+   * new() will construct an object and return it.  Not useful unless\n+   * an expression :-)\n+   *\n+   * If the target is an array, get and set as defined in\n+   * java.util.List are recognized as valid methods and mapped to the\n+   * methods of the same name in java.lang.reflect.Array.\n+   *\n+   * The native datatype wrappers Boolean, Byte, Character, Double,\n+   * Float, Integer, Long, and Short will map to methods that have\n+   * native datatypes as parameters, in the same way as Method.invoke.\n+   * However, these wrappers also select methods that actually take\n+   * the wrapper type as an argument.\n+   *\n+   * The Sun spec doesn't deal with overloading between int and\n+   * Integer carefully.  If there are two methods, one that takes an\n+   * Integer and the other taking an int, the method chosen is not\n+   * specified, and can depend on the order in which the methods are\n+   * declared in the source file.\n+   *\n+   * @throws Exception if an exception occurs while locating or\n+   * \t\t       invoking the method.\n+   */\n+  public void execute() throws Exception\n+  {\n+    doExecute();\n+  }\n+  \n+  private static Class wrappers[] = \n+    {\n+      Boolean.class, Byte.class, Character.class, Double.class, Float.class,\n+      Integer.class, Long.class, Short.class\n+    };\n+\n+  private static Class natives[] = \n+    {\n+      Boolean.TYPE, Byte.TYPE, Character.TYPE, Double.TYPE, Float.TYPE,\n+      Integer.TYPE, Long.TYPE, Short.TYPE\n+    };\n+\n+  // Given a wrapper class, return the native class for it.  For\n+  // example, if c is Integer, Integer.TYPE is returned.\n+  private Class unwrap(Class c)\n+  {\n+    for (int i = 0; i < wrappers.length; i++)\n+      if (c == wrappers[i])\n+\treturn natives[i];\n+    return null;\n+  }\n+\n+  // Return true if all args can be assigned to params, false\n+  // otherwise.  Arrays are guaranteed to be the same length.\n+  private boolean compatible(Class[] params, Class[] args)\n+  {\n+    for (int i = 0; i < params.length; i++)\n+      {\n+\t// Treat Integer like int if appropriate\n+\tClass nativeType = unwrap(args[i]);\n+\tif (nativeType != null && params[i].isPrimitive()\n+\t    && params[i].isAssignableFrom(nativeType))\n+\t  continue;\n+\tif (params[i].isAssignableFrom(args[i]))\n+\t  continue;\n+\n+\treturn false;\n+      }\n+    return true;\n+  }\n+\n+  /**\n+   * Return true if the method arguments in first are more specific\n+   * than the method arguments in second, i.e. all args in first can\n+   * be assigned to those in second.\n+   *\n+   * A method is more specific if all parameters can also be fed to\n+   * the less specific method, because, e.g. the less specific method\n+   * accepts a base class of the equivalent argument for the more\n+   * specific one.\n+   *\n+   * @param first a <code>Class[]</code> value\n+   * @param second a <code>Class[]</code> value\n+   * @return a <code>boolean</code> value\n+   */\n+  private boolean moreSpecific(Class[] first, Class[] second)\n+  {\n+    for (int j=0; j < first.length; j++)\n+      {\n+\tif (second[j].isAssignableFrom(first[j]))\n+\t  continue;\n+\treturn false;\n+      }\n+    return true;\n+  }\n+\n+  final Object doExecute() throws Exception\n+  {\n+    Class klazz = (target instanceof Class)\n+\t? (Class) target : target.getClass();\n+    Object args[] = (arguments == null) ? new Object[0] : arguments;\n+    Class argTypes[] = new Class[args.length];\n+    for (int i = 0; i < args.length; i++)\n+      argTypes[i] = args[i].getClass();\n+\n+    if (target.getClass().isArray())\n+      {\n+\t// FIXME: invoke may have to be used.  For now, cast to Number\n+\t// and hope for the best.  If caller didn't behave, we go boom\n+\t// and throw the exception.\n+\tif (methodName.equals(\"get\") && argTypes.length == 1)\n+\t  return Array.get(target, ((Number)args[0]).intValue());\n+\tif (methodName.equals(\"set\") && argTypes.length == 2)\n+\t  {\n+\t    Object obj = Array.get(target, ((Number)args[0]).intValue());\n+\t    Array.set(target, ((Number)args[0]).intValue(), args[1]);\n+\t    return obj;\n+\t  }\n+\tthrow new NoSuchMethodException(\"No matching method for statement \" + toString());\n+      }\n+\n+    // If we already cached the method, just use it.\n+    if (method != null)\n+      return method.invoke(target, args);\n+    else if (ctor != null)\n+      return ctor.newInstance(args);\n+\n+    // Find a matching method to call.  JDK seems to go through all\n+    // this to find the method to call.\n+\n+    // if method name or length don't match, skip\n+    // Need to go through each arg\n+    // If arg is wrapper - check if method arg is matchable builtin\n+    //  or same type or super\n+    //  - check that method arg is same or super\n+\n+    if (methodName.equals(\"new\") && target instanceof Class)\n+      {\n+\tConstructor ctors[] = klazz.getConstructors();\n+\tfor (int i = 0; i < ctors.length; i++)\n+\t  {\n+\t    // Skip methods with wrong number of args.\n+\t    Class ptypes[] = ctors[i].getParameterTypes();\n+\t    System.out.println(\"ptypeslen = \" + ptypes.length);\n+\t    System.out.println(\"ptypes = \" + ptypes);\n+\t    System.out.println(\"ctor = \" + ctors[i].getName());\n+\t    for (int j=0; j < ptypes.length; j++) {\n+\t      System.out.println(\"param = \" + ptypes[i].getName());\n+     \n+\t    }\n+\t      \n+\t    \n+\t    if (ptypes.length != args.length)  continue;\n+\n+\t    // Check if method matches\n+\t    if (!compatible(ptypes, argTypes)) continue;\n+\n+\t    // Use method[i] if it is more specific. \n+\t    // FIXME: should this check both directions and throw if\n+\t    // neither is more specific?\n+\t    if (ctor == null)\n+\t      {\n+\t\tctor = ctors[i];\n+\t\tcontinue;\n+\t      }\n+\t    Class mptypes[] = ctor.getParameterTypes();\n+\t    if (moreSpecific(ptypes, mptypes))\n+\t      ctor = ctors[i];\n+\t  }\n+\tif (ctor == null)\n+\t  throw new InstantiationException(\"No matching constructor for statement \" + toString());\n+\treturn ctor.newInstance(args);\n+      }\n+\n+    Method methods[] = klazz.getMethods();\n+\n+    for (int i = 0; i < methods.length; i++)\n+      {\n+\t// Skip methods with wrong name or number of args.\n+\tif (!methods[i].getName().equals(methodName)) continue;\n+\tClass ptypes[] = methods[i].getParameterTypes();\n+\tif (ptypes.length != args.length)  continue;\n+\n+\t// Check if method matches\n+\tif (!compatible(ptypes, argTypes)) continue;\n+\n+\t// Use method[i] if it is more specific. \n+\t// FIXME: should this check both directions and throw if\n+\t// neither is more specific?\n+\tif (method == null)\n+\t  {\n+\t    method = methods[i];\n+\t    continue;\n+\t  }\n+\tClass mptypes[] = method.getParameterTypes();\n+\tif (moreSpecific(ptypes, mptypes))\n+\t  method = methods[i];\n+      }\n+    if (method == null)\n+      throw new NoSuchMethodException(\"No matching method for statement \" + toString());\n+    return method.invoke(target, args);\n+  }\n+\n+  \n+\n+  /** Return the statement arguments. */\n+  public Object[] getArguments() { return arguments; }\n+\n+  /** Return the statement method name. */\n+  public String getMethodName() { return methodName; }\n+\n+  /** Return the statement object. */\n+  public Object getTarget() { return target; }\n+\n+  /** Return a string representation. */\n+  public String toString()\n+  {\n+    String result = target.getClass().getName() + \".\" + methodName + \"(\";\n+    String sep = \"\";\n+    for (int i = 0; i < arguments.length; i++)\n+      {\n+\tresult = result + sep + arguments[i].getClass().getName();\n+\tsep = \", \";\n+      }\n+    result = result + \")\";\n+    return result;\n+  }\n+}"}]}