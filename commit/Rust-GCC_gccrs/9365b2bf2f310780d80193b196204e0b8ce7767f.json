{"sha": "9365b2bf2f310780d80193b196204e0b8ce7767f", "node_id": "C_kwDOANBUbNoAKDkzNjViMmJmMmYzMTA3ODBkODAxOTNiMTk2MjA0ZTBiOGNlNzc2N2Y", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-07-25T06:10:01Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2022-07-25T17:33:16Z"}, "message": "analyzer: fix coding style in sm-fd.cc\n\ngcc/analyzer/ChangeLog:\n\n\t* sm-fd.cc: Run dos2unix and fix coding style issues.", "tree": {"sha": "b1cc07594e5c18281e8fba571a191c92243d46d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1cc07594e5c18281e8fba571a191c92243d46d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9365b2bf2f310780d80193b196204e0b8ce7767f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9365b2bf2f310780d80193b196204e0b8ce7767f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9365b2bf2f310780d80193b196204e0b8ce7767f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9365b2bf2f310780d80193b196204e0b8ce7767f/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16aafa3194d4851a07cc204f56a5f0618f77e5d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16aafa3194d4851a07cc204f56a5f0618f77e5d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16aafa3194d4851a07cc204f56a5f0618f77e5d7"}], "stats": {"total": 2114, "additions": 1057, "deletions": 1057}, "files": [{"sha": "56b0063ba42312877026fe70d26b238a0c4d19af", "filename": "gcc/analyzer/sm-fd.cc", "status": "modified", "additions": 1057, "deletions": 1057, "changes": 2114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9365b2bf2f310780d80193b196204e0b8ce7767f/gcc%2Fanalyzer%2Fsm-fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9365b2bf2f310780d80193b196204e0b8ce7767f/gcc%2Fanalyzer%2Fsm-fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-fd.cc?ref=9365b2bf2f310780d80193b196204e0b8ce7767f", "patch": "@@ -1,1057 +1,1057 @@\n-/* A state machine for detecting misuses of POSIX file descriptor APIs.\r\n-   Copyright (C) 2019-2022 Free Software Foundation, Inc.\r\n-   Contributed by Immad Mir <mir@sourceware.org>.\r\n-\r\n-This file is part of GCC.\r\n-\r\n-GCC is free software; you can redistribute it and/or modify it\r\n-under the terms of the GNU General Public License as published by\r\n-the Free Software Foundation; either version 3, or (at your option)\r\n-any later version.\r\n-\r\n-GCC is distributed in the hope that it will be useful, but\r\n-WITHOUT ANY WARRANTY; without even the implied warranty of\r\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n-General Public License for more details.\r\n-\r\n-You should have received a copy of the GNU General Public License\r\n-along with GCC; see the file COPYING3.  If not see\r\n-<http://www.gnu.org/licenses/>.  */\r\n-\r\n-#include \"config.h\"\r\n-#include \"system.h\"\r\n-#include \"coretypes.h\"\r\n-#include \"tree.h\"\r\n-#include \"function.h\"\r\n-#include \"basic-block.h\"\r\n-#include \"gimple.h\"\r\n-#include \"options.h\"\r\n-#include \"diagnostic-path.h\"\r\n-#include \"diagnostic-metadata.h\"\r\n-#include \"function.h\"\r\n-#include \"json.h\"\r\n-#include \"analyzer/analyzer.h\"\r\n-#include \"diagnostic-event-id.h\"\r\n-#include \"analyzer/analyzer-logging.h\"\r\n-#include \"analyzer/sm.h\"\r\n-#include \"analyzer/pending-diagnostic.h\"\r\n-#include \"analyzer/function-set.h\"\r\n-#include \"analyzer/analyzer-selftests.h\"\r\n-#include \"tristate.h\"\r\n-#include \"selftest.h\"\r\n-#include \"stringpool.h\"\r\n-#include \"attribs.h\"\r\n-#include \"analyzer/call-string.h\"\r\n-#include \"analyzer/program-point.h\"\r\n-#include \"analyzer/store.h\"\r\n-#include \"analyzer/region-model.h\"\r\n-#include \"bitmap.h\"\r\n-\r\n-#if ENABLE_ANALYZER\r\n-\r\n-namespace ana {\r\n-\r\n-namespace {\r\n-\r\n-/* An enum for distinguishing between three different access modes. */\r\n-\r\n-enum access_mode\r\n-{\r\n-  READ_WRITE,\r\n-  READ_ONLY,\r\n-  WRITE_ONLY\r\n-};\r\n-\r\n-enum access_directions\r\n-{\r\n-  DIRS_READ_WRITE,\r\n-  DIRS_READ,\r\n-  DIRS_WRITE\r\n-};\r\n-\r\n-class fd_state_machine : public state_machine\r\n-{\r\n-public:\r\n-  fd_state_machine (logger *logger);\r\n-\r\n-  bool\r\n-  inherited_state_p () const final override\r\n-  {\r\n-    return false;\r\n-  }\r\n-\r\n-  state_machine::state_t\r\n-  get_default_state (const svalue *sval) const final override\r\n-  {\r\n-    if (tree cst = sval->maybe_get_constant ())\r\n-      {\r\n-        if (TREE_CODE (cst) == INTEGER_CST)\r\n-          {\r\n-            int val = TREE_INT_CST_LOW (cst);\r\n-            if (val >= 0)\r\n-              return m_constant_fd;\r\n-            else\r\n-              return m_invalid;\r\n-          }\r\n-      }\r\n-    return m_start;\r\n-  }\r\n-\r\n-  bool on_stmt (sm_context *sm_ctxt, const supernode *node,\r\n-                const gimple *stmt) const final override;\r\n-\r\n-  void on_condition (sm_context *sm_ctxt, const supernode *node,\r\n-                     const gimple *stmt, const svalue *lhs, const tree_code op,\r\n-                     const svalue *rhs) const final override;\r\n-\r\n-  bool can_purge_p (state_t s) const final override;\r\n-  pending_diagnostic *on_leak (tree var) const final override;\r\n-\r\n-  bool is_unchecked_fd_p (state_t s) const;\r\n-  bool is_valid_fd_p (state_t s) const;\r\n-  bool is_closed_fd_p (state_t s) const;\r\n-  bool is_constant_fd_p (state_t s) const;\r\n-  bool is_readonly_fd_p (state_t s) const;\r\n-  bool is_writeonly_fd_p (state_t s) const;\r\n-  enum access_mode get_access_mode_from_flag (int flag) const;\r\n-\r\n-  /* State for a constant file descriptor (>= 0) */\r\n-  state_t m_constant_fd;\r\n-\r\n-  /* States representing a file descriptor that hasn't yet been\r\n-    checked for validity after opening, for three different\r\n-    access modes.  */\r\n-  state_t m_unchecked_read_write;\r\n-\r\n-  state_t m_unchecked_read_only;\r\n-\r\n-  state_t m_unchecked_write_only;\r\n-\r\n-  /* States for representing a file descriptor that is known to be valid (>=\r\n-    0), for three different access modes.*/\r\n-  state_t m_valid_read_write;\r\n-\r\n-  state_t m_valid_read_only;\r\n-\r\n-  state_t m_valid_write_only;\r\n-\r\n-  /* State for a file descriptor that is known to be invalid (< 0). */\r\n-  state_t m_invalid;\r\n-\r\n-  /* State for a file descriptor that has been closed.*/\r\n-  state_t m_closed;\r\n-\r\n-  /* State for a file descriptor that we do not want to track anymore . */\r\n-  state_t m_stop;\r\n-\r\n-private:\r\n-  void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-                const gcall *call) const;\r\n-  void on_close (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-                 const gcall *call) const;\r\n-  void on_read (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-                const gcall *call, const tree callee_fndecl) const;\r\n-  void on_write (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-                 const gcall *call, const tree callee_fndecl) const;\r\n-  void check_for_open_fd (sm_context *sm_ctxt, const supernode *node,\r\n-                          const gimple *stmt, const gcall *call,\r\n-                          const tree callee_fndecl,\r\n-                          enum access_directions access_fn) const;\r\n-\r\n-  void make_valid_transitions_on_condition (sm_context *sm_ctxt,\r\n-                                            const supernode *node,\r\n-                                            const gimple *stmt,\r\n-                                            const svalue *lhs) const;\r\n-  void make_invalid_transitions_on_condition (sm_context *sm_ctxt,\r\n-                                              const supernode *node,\r\n-                                              const gimple *stmt,\r\n-                                              const svalue *lhs) const;\r\n-  void check_for_fd_attrs (sm_context *sm_ctxt, const supernode *node,\r\n-                           const gimple *stmt, const gcall *call,\r\n-                           const tree callee_fndecl, const char *attr_name,\r\n-                           access_directions fd_attr_access_dir) const;\r\n-};\r\n-\r\n-/* Base diagnostic class relative to fd_state_machine. */\r\n-class fd_diagnostic : public pending_diagnostic\r\n-{\r\n-public:\r\n-  fd_diagnostic (const fd_state_machine &sm, tree arg) : m_sm (sm), m_arg (arg)\r\n-  {\r\n-  }\r\n-\r\n-  bool\r\n-  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n-  {\r\n-    return same_tree_p (m_arg, ((const fd_diagnostic &)base_other).m_arg);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_state_change (const evdesc::state_change &change) override\r\n-  {\r\n-    if (change.m_old_state == m_sm.get_start_state ()\r\n-        && m_sm.is_unchecked_fd_p (change.m_new_state))\r\n-      {\r\n-        if (change.m_new_state == m_sm.m_unchecked_read_write)\r\n-          return change.formatted_print (\"opened here as read-write\");\r\n-\r\n-        if (change.m_new_state == m_sm.m_unchecked_read_only)\r\n-          return change.formatted_print (\"opened here as read-only\");\r\n-\r\n-        if (change.m_new_state == m_sm.m_unchecked_write_only)\r\n-          return change.formatted_print (\"opened here as write-only\");\r\n-      }\r\n-\r\n-    if (change.m_new_state == m_sm.m_closed)\r\n-      return change.formatted_print (\"closed here\");\r\n-\r\n-    if (m_sm.is_unchecked_fd_p (change.m_old_state)\r\n-        && m_sm.is_valid_fd_p (change.m_new_state))\r\n-      {\r\n-        if (change.m_expr)\r\n-          return change.formatted_print (\r\n-              \"assuming %qE is a valid file descriptor (>= 0)\", change.m_expr);\r\n-        else\r\n-          return change.formatted_print (\"assuming a valid file descriptor\");\r\n-      }\r\n-\r\n-    if (m_sm.is_unchecked_fd_p (change.m_old_state)\r\n-        && change.m_new_state == m_sm.m_invalid)\r\n-      {\r\n-        if (change.m_expr)\r\n-          return change.formatted_print (\r\n-              \"assuming %qE is an invalid file descriptor (< 0)\",\r\n-              change.m_expr);\r\n-        else\r\n-          return change.formatted_print (\"assuming an invalid file descriptor\");\r\n-      }\r\n-\r\n-    return label_text ();\r\n-  }\r\n-\r\n-protected:\r\n-  const fd_state_machine &m_sm;\r\n-  tree m_arg;\r\n-};\r\n-\r\n-class fd_param_diagnostic : public fd_diagnostic\r\n-{\r\n-public:\r\n-  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl,\r\n-                       const char *attr_name, int arg_idx)\r\n-      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\r\n-        m_attr_name (attr_name), m_arg_idx (arg_idx)\r\n-  {\r\n-  }\r\n-\r\n-  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl)\r\n-      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\r\n-        m_attr_name (NULL), m_arg_idx (-1)\r\n-  {\r\n-  }\r\n- \r\n-  bool\r\n-  subclass_equal_p (const pending_diagnostic &base_other) const override\r\n-  {\r\n-    const fd_param_diagnostic &sub_other\r\n-        = (const fd_param_diagnostic &)base_other;\r\n-    return (same_tree_p (m_arg, sub_other.m_arg)\r\n-            && same_tree_p (m_callee_fndecl, sub_other.m_callee_fndecl)\r\n-            && m_arg_idx == sub_other.m_arg_idx\r\n-            && ((m_attr_name)\r\n-                    ? (strcmp (m_attr_name, sub_other.m_attr_name) == 0)\r\n-                    : true));\r\n-  }\r\n-\r\n-  void\r\n-  inform_filedescriptor_attribute (access_directions fd_dir)\r\n-  {\r\n-\r\n-    if (m_attr_name)\r\n-      switch (fd_dir)\r\n-        {\r\n-        case DIRS_READ_WRITE:\r\n-          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n-                  \"argument %d of %qD must be an open file descriptor, due to \"\r\n-                  \"%<__attribute__((%s(%d)))%>\",\r\n-                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n-          break;\r\n-        case DIRS_WRITE:\r\n-          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n-                  \"argument %d of %qD must be a readable file descriptor, due \"\r\n-                  \"to %<__attribute__((%s(%d)))%>\",\r\n-                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n-          break;\r\n-        case DIRS_READ:\r\n-          inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\r\n-                  \"argument %d of %qD must be a writable file descriptor, due \"\r\n-                  \"to %<__attribute__((%s(%d)))%>\",\r\n-                  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\r\n-          break;\r\n-        }\r\n-  }\r\n-\r\n-protected:\r\n-  tree m_callee_fndecl;\r\n-  const char *m_attr_name;\r\n-  /* ARG_IDX is 0-based. */\r\n-  int m_arg_idx;\r\n-};\r\n-\r\n-class fd_leak : public fd_diagnostic\r\n-{\r\n-public:\r\n-  fd_leak (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg) {}\r\n-\r\n-  const char *\r\n-  get_kind () const final override\r\n-  {\r\n-    return \"fd_leak\";\r\n-  }\r\n-\r\n-  int\r\n-  get_controlling_option () const final override\r\n-  {\r\n-    return OPT_Wanalyzer_fd_leak;\r\n-  }\r\n-\r\n-  bool\r\n-  emit (rich_location *rich_loc) final override\r\n-  {\r\n-    /*CWE-775: Missing Release of File Descriptor or Handle after Effective\r\n-      Lifetime\r\n-     */\r\n-    diagnostic_metadata m;\r\n-    m.add_cwe (775);\r\n-    if (m_arg)\r\n-      return warning_meta (rich_loc, m, get_controlling_option (),\r\n-                           \"leak of file descriptor %qE\", m_arg);\r\n-    else\r\n-      return warning_meta (rich_loc, m, get_controlling_option (),\r\n-                           \"leak of file descriptor\");\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_state_change (const evdesc::state_change &change) final override\r\n-  {\r\n-    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n-      {\r\n-        m_open_event = change.m_event_id;\r\n-        return label_text::borrow (\"opened here\");\r\n-      }\r\n-\r\n-    return fd_diagnostic::describe_state_change (change);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_final_event (const evdesc::final_event &ev) final override\r\n-  {\r\n-    if (m_open_event.known_p ())\r\n-      {\r\n-        if (ev.m_expr)\r\n-          return ev.formatted_print (\"%qE leaks here; was opened at %@\",\r\n-                                     ev.m_expr, &m_open_event);\r\n-        else\r\n-          return ev.formatted_print (\"leaks here; was opened at %@\",\r\n-                                     &m_open_event);\r\n-      }\r\n-    else\r\n-      {\r\n-        if (ev.m_expr)\r\n-          return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\r\n-        else\r\n-          return ev.formatted_print (\"leaks here\");\r\n-      }\r\n-  }\r\n-\r\n-private:\r\n-  diagnostic_event_id_t m_open_event;\r\n-};\r\n-\r\n-class fd_access_mode_mismatch : public fd_param_diagnostic\r\n-{\r\n-public:\r\n-  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\r\n-                           enum access_directions fd_dir,\r\n-                           const tree callee_fndecl, const char *attr_name,\r\n-                           int arg_idx)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx),\r\n-        m_fd_dir (fd_dir)\r\n-\r\n-  {\r\n-  }\r\n-\r\n-  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\r\n-                           enum access_directions fd_dir,\r\n-                           const tree callee_fndecl)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl), m_fd_dir (fd_dir)\r\n-  {\r\n-  }\r\n-  \r\n-  const char *\r\n-  get_kind () const final override\r\n-  {\r\n-    return \"fd_access_mode_mismatch\";\r\n-  }\r\n-\r\n-  int\r\n-  get_controlling_option () const final override\r\n-  {\r\n-    return OPT_Wanalyzer_fd_access_mode_mismatch;\r\n-  }\r\n-\r\n-  bool\r\n-  emit (rich_location *rich_loc) final override\r\n-  {\r\n-    bool warned;\r\n-    switch (m_fd_dir)\r\n-      {\r\n-      case DIRS_READ:\r\n-        warned =  warning_at (rich_loc, get_controlling_option (),\r\n-                           \"%qE on read-only file descriptor %qE\",\r\n-                           m_callee_fndecl, m_arg);\r\n-        break;\r\n-      case DIRS_WRITE:\r\n-        warned = warning_at (rich_loc, get_controlling_option (),\r\n-                           \"%qE on write-only file descriptor %qE\",\r\n-                           m_callee_fndecl, m_arg);\r\n-        break;\r\n-      default:\r\n-        gcc_unreachable ();\r\n-      }\r\n-      if (warned)\r\n-        inform_filedescriptor_attribute (m_fd_dir);\r\n-      return warned;\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_final_event (const evdesc::final_event &ev) final override\r\n-  {\r\n-    switch (m_fd_dir)\r\n-      {\r\n-      case DIRS_READ:\r\n-        return ev.formatted_print (\"%qE on read-only file descriptor %qE\",\r\n-                                   m_callee_fndecl, m_arg);\r\n-      case DIRS_WRITE:\r\n-        return ev.formatted_print (\"%qE on write-only file descriptor %qE\",\r\n-                                   m_callee_fndecl, m_arg);\r\n-      default:\r\n-        gcc_unreachable ();\r\n-      }\r\n-  }\r\n-\r\n-private:\r\n-  enum access_directions m_fd_dir;\r\n-};\r\n-\r\n-class fd_double_close : public fd_diagnostic\r\n-{\r\n-public:\r\n-  fd_double_close (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg)\r\n-  {\r\n-  }\r\n-\r\n-  const char *\r\n-  get_kind () const final override\r\n-  {\r\n-    return \"fd_double_close\";\r\n-  }\r\n-\r\n-  int\r\n-  get_controlling_option () const final override\r\n-  {\r\n-    return OPT_Wanalyzer_fd_double_close;\r\n-  }\r\n-  bool\r\n-  emit (rich_location *rich_loc) final override\r\n-  {\r\n-    diagnostic_metadata m;\r\n-    // CWE-1341: Multiple Releases of Same Resource or Handle\r\n-    m.add_cwe (1341);\r\n-    return warning_meta (rich_loc, m, get_controlling_option (),\r\n-                         \"double %<close%> of file descriptor %qE\", m_arg);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_state_change (const evdesc::state_change &change) override\r\n-  {\r\n-    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n-      return label_text::borrow (\"opened here\");\r\n-\r\n-    if (change.m_new_state == m_sm.m_closed)\r\n-      {\r\n-        m_first_close_event = change.m_event_id;\r\n-        return change.formatted_print (\"first %qs here\", \"close\");\r\n-      }\r\n-    return fd_diagnostic::describe_state_change (change);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_final_event (const evdesc::final_event &ev) final override\r\n-  {\r\n-    if (m_first_close_event.known_p ())\r\n-      return ev.formatted_print (\"second %qs here; first %qs was at %@\",\r\n-                                 \"close\", \"close\", &m_first_close_event);\r\n-    return ev.formatted_print (\"second %qs here\", \"close\");\r\n-  }\r\n-\r\n-private:\r\n-  diagnostic_event_id_t m_first_close_event;\r\n-};\r\n-\r\n-class fd_use_after_close : public fd_param_diagnostic\r\n-{\r\n-public:\r\n-  fd_use_after_close (const fd_state_machine &sm, tree arg,\r\n-                      const tree callee_fndecl, const char *attr_name,\r\n-                      int arg_idx)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\r\n-  {\r\n-  }\r\n-\r\n-  fd_use_after_close (const fd_state_machine &sm, tree arg,\r\n-                      const tree callee_fndecl)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl)\r\n-  {\r\n-  }\r\n-\r\n-  const char *\r\n-  get_kind () const final override\r\n-  {\r\n-    return \"fd_use_after_close\";\r\n-  }\r\n-\r\n-  int\r\n-  get_controlling_option () const final override\r\n-  {\r\n-    return OPT_Wanalyzer_fd_use_after_close;\r\n-  }\r\n-\r\n-  bool\r\n-  emit (rich_location *rich_loc) final override\r\n-  {\r\n-    bool warned;\r\n-    warned = warning_at (rich_loc, get_controlling_option (),\r\n-                       \"%qE on closed file descriptor %qE\", m_callee_fndecl,\r\n-                       m_arg);\r\n-    if (warned)\r\n-      inform_filedescriptor_attribute (DIRS_READ_WRITE);\r\n-    return warned;\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_state_change (const evdesc::state_change &change) override\r\n-  {\r\n-    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n-      return label_text::borrow (\"opened here\");\r\n-\r\n-    if (change.m_new_state == m_sm.m_closed)\r\n-      {\r\n-        m_first_close_event = change.m_event_id;\r\n-        return change.formatted_print (\"closed here\");\r\n-      }\r\n-\r\n-    return fd_diagnostic::describe_state_change (change);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_final_event (const evdesc::final_event &ev) final override\r\n-  {\r\n-    if (m_first_close_event.known_p ())\r\n-        return ev.formatted_print (\r\n-            \"%qE on closed file descriptor %qE; %qs was at %@\", m_callee_fndecl,\r\n-            m_arg, \"close\", &m_first_close_event);\r\n-      else\r\n-        return ev.formatted_print (\"%qE on closed file descriptor %qE\",\r\n-                                  m_callee_fndecl, m_arg);\r\n-  }\r\n-\r\n-private:\r\n-  diagnostic_event_id_t m_first_close_event;\r\n-};\r\n-\r\n-class fd_use_without_check : public fd_param_diagnostic\r\n-{\r\n-public:\r\n-  fd_use_without_check (const fd_state_machine &sm, tree arg,\r\n-                        const tree callee_fndecl, const char *attr_name,\r\n-                        int arg_idx)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\r\n-  {\r\n-  }\r\n-\r\n-  fd_use_without_check (const fd_state_machine &sm, tree arg,\r\n-                        const tree callee_fndecl)\r\n-      : fd_param_diagnostic (sm, arg, callee_fndecl)\r\n-  {\r\n-  }\r\n-\r\n-  const char *\r\n-  get_kind () const final override\r\n-  {\r\n-    return \"fd_use_without_check\";\r\n-  }\r\n-\r\n-  int\r\n-  get_controlling_option () const final override\r\n-  {\r\n-    return OPT_Wanalyzer_fd_use_without_check;\r\n-  }\r\n-\r\n-  bool\r\n-  emit (rich_location *rich_loc) final override\r\n-  {\r\n-    bool warned;\r\n-    warned = warning_at (rich_loc, get_controlling_option (),\r\n-                        \"%qE on possibly invalid file descriptor %qE\",\r\n-                        m_callee_fndecl, m_arg);\r\n-    if (warned)\r\n-     inform_filedescriptor_attribute (DIRS_READ_WRITE);\r\n-    return warned;\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_state_change (const evdesc::state_change &change) override\r\n-  {\r\n-    if (m_sm.is_unchecked_fd_p (change.m_new_state))\r\n-      {\r\n-        m_first_open_event = change.m_event_id;\r\n-        return label_text::borrow (\"opened here\");\r\n-      }\r\n-\r\n-    return fd_diagnostic::describe_state_change (change);\r\n-  }\r\n-\r\n-  label_text\r\n-  describe_final_event (const evdesc::final_event &ev) final override\r\n-  {\r\n-    if (m_first_open_event.known_p ())\r\n-      return ev.formatted_print (\r\n-          \"%qE could be invalid: unchecked value from %@\", m_arg,\r\n-          &m_first_open_event);\r\n-    else\r\n-      return ev.formatted_print (\"%qE could be invalid\", m_arg);\r\n-  }\r\n-\r\n-private:\r\n-  diagnostic_event_id_t m_first_open_event;  \r\n-};\r\n-\r\n-fd_state_machine::fd_state_machine (logger *logger)\r\n-    : state_machine (\"file-descriptor\", logger),\r\n-      m_constant_fd (add_state (\"fd-constant\")),\r\n-      m_unchecked_read_write (add_state (\"fd-unchecked-read-write\")),\r\n-      m_unchecked_read_only (add_state (\"fd-unchecked-read-only\")),\r\n-      m_unchecked_write_only (add_state (\"fd-unchecked-write-only\")),\r\n-      m_valid_read_write (add_state (\"fd-valid-read-write\")),\r\n-      m_valid_read_only (add_state (\"fd-valid-read-only\")),\r\n-      m_valid_write_only (add_state (\"fd-valid-write-only\")),\r\n-      m_invalid (add_state (\"fd-invalid\")),\r\n-      m_closed (add_state (\"fd-closed\")),\r\n-      m_stop (add_state (\"fd-stop\"))\r\n-{\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_unchecked_fd_p (state_t s) const\r\n-{\r\n-  return (s == m_unchecked_read_write\r\n-       || s == m_unchecked_read_only\r\n-       || s == m_unchecked_write_only);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_valid_fd_p (state_t s) const\r\n-{\r\n-  return (s == m_valid_read_write\r\n-       || s == m_valid_read_only\r\n-       || s == m_valid_write_only);\r\n-}\r\n-\r\n-enum access_mode\r\n-fd_state_machine::get_access_mode_from_flag (int flag) const\r\n-{\r\n-  /* FIXME: this code assumes the access modes on the host and\r\n-          target are the same, which in practice might not be the case. */\r\n-\r\n-  if ((flag & O_ACCMODE) == O_RDONLY)\r\n-    {\r\n-      return READ_ONLY;\r\n-    }\r\n-  else if ((flag & O_ACCMODE) == O_WRONLY)\r\n-    {\r\n-      return WRITE_ONLY;\r\n-    }\r\n-  return READ_WRITE;\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_readonly_fd_p (state_t state) const\r\n-{\r\n-  return (state == m_unchecked_read_only || state == m_valid_read_only);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_writeonly_fd_p (state_t state) const\r\n-{\r\n-  return (state == m_unchecked_write_only || state == m_valid_write_only);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_closed_fd_p (state_t state) const\r\n-{\r\n-  return (state == m_closed);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::is_constant_fd_p (state_t state) const\r\n-{\r\n-  return (state == m_constant_fd);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\r\n-                           const gimple *stmt) const\r\n-{\r\n-  if (const gcall *call = dyn_cast<const gcall *> (stmt))\r\n-    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\r\n-      {\r\n-        if (is_named_call_p (callee_fndecl, \"open\", call, 2))\r\n-          {\r\n-            on_open (sm_ctxt, node, stmt, call);\r\n-            return true;\r\n-          } //  \"open\"\r\n-\r\n-        if (is_named_call_p (callee_fndecl, \"close\", call, 1))\r\n-          {\r\n-            on_close (sm_ctxt, node, stmt, call);\r\n-            return true;\r\n-          } //  \"close\"\r\n-\r\n-        if (is_named_call_p (callee_fndecl, \"write\", call, 3))\r\n-          {\r\n-            on_write (sm_ctxt, node, stmt, call, callee_fndecl);\r\n-            return true;\r\n-          } // \"write\"\r\n-\r\n-        if (is_named_call_p (callee_fndecl, \"read\", call, 3))\r\n-          {\r\n-            on_read (sm_ctxt, node, stmt, call, callee_fndecl);\r\n-            return true;\r\n-          } // \"read\"\r\n-\r\n-          \r\n-        {\r\n-          // Handle __attribute__((fd_arg))\r\n-\r\n-          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n-                              \"fd_arg\", DIRS_READ_WRITE);\r\n-\r\n-          // Handle __attribute__((fd_arg_read))\r\n-\r\n-          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n-                              \"fd_arg_read\", DIRS_READ);\r\n-\r\n-          // Handle __attribute__((fd_arg_write))\r\n-\r\n-          check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\r\n-                              \"fd_arg_write\", DIRS_WRITE);\r\n-        }          \r\n-      }\r\n-\r\n-  return false;\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::check_for_fd_attrs (\r\n-    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-    const gcall *call, const tree callee_fndecl, const char *attr_name,\r\n-    access_directions fd_attr_access_dir) const\r\n-{\r\n-\r\n-  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (callee_fndecl));\r\n-  attrs = lookup_attribute (attr_name, attrs);\r\n-  if (!attrs)\r\n-    return;\r\n-\r\n-  if (!TREE_VALUE (attrs))\r\n-    return;\r\n-\r\n-  auto_bitmap argmap;\r\n-\r\n-  for (tree idx = TREE_VALUE (attrs); idx; idx = TREE_CHAIN (idx))\r\n-    {\r\n-      unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (idx)) - 1;\r\n-      bitmap_set_bit (argmap, val);\r\n-    }\r\n-  if (bitmap_empty_p (argmap))\r\n-    return;\r\n-\r\n-  for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\r\n-    {\r\n-      tree arg = gimple_call_arg (call, arg_idx);\r\n-      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n-      state_t state = sm_ctxt->get_state (stmt, arg);\r\n-      bool bit_set = bitmap_bit_p (argmap, arg_idx);\r\n-      if (TREE_CODE (TREE_TYPE (arg)) != INTEGER_TYPE)\r\n-        continue;\r\n-      if (bit_set) // Check if arg_idx is marked by any of the file descriptor\r\n-                   // attributes\r\n-        {\r\n-\r\n-          if (is_closed_fd_p (state))\r\n-            {\r\n-\r\n-              sm_ctxt->warn (node, stmt, arg,\r\n-                             new fd_use_after_close (*this, diag_arg,\r\n-                                                     callee_fndecl, attr_name,\r\n-                                                     arg_idx));\r\n-              continue;\r\n-            }\r\n-\r\n-          if (!(is_valid_fd_p (state) || (state == m_stop)))\r\n-            {\r\n-              if (!is_constant_fd_p (state))\r\n-                sm_ctxt->warn (node, stmt, arg,\r\n-                               new fd_use_without_check (*this, diag_arg,\r\n-                                                        callee_fndecl, attr_name,\r\n-                                                        arg_idx));\r\n-            }\r\n-\r\n-          switch (fd_attr_access_dir)\r\n-            {\r\n-            case DIRS_READ_WRITE:\r\n-              break;\r\n-            case DIRS_READ:\r\n-\r\n-              if (is_writeonly_fd_p (state))\r\n-                {\r\n-                  sm_ctxt->warn (\r\n-                      node, stmt, arg,\r\n-                      new fd_access_mode_mismatch (*this, diag_arg, DIRS_WRITE,\r\n-                                                   callee_fndecl, attr_name, arg_idx));\r\n-                }\r\n-\r\n-              break;\r\n-            case DIRS_WRITE:\r\n-\r\n-              if (is_readonly_fd_p (state))\r\n-                {\r\n-                  sm_ctxt->warn (\r\n-                      node, stmt, arg,\r\n-                      new fd_access_mode_mismatch (*this, diag_arg, DIRS_READ,\r\n-                                                   callee_fndecl, attr_name, arg_idx));\r\n-                }\r\n-\r\n-              break;\r\n-            }\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-\r\n-void\r\n-fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\r\n-                           const gimple *stmt, const gcall *call) const\r\n-{\r\n-  tree lhs = gimple_call_lhs (call);\r\n-  if (lhs)\r\n-    {\r\n-      tree arg = gimple_call_arg (call, 1);\r\n-      if (TREE_CODE (arg) == INTEGER_CST)\r\n-        {\r\n-          int flag = TREE_INT_CST_LOW (arg);\r\n-          enum access_mode mode = get_access_mode_from_flag (flag);\r\n-\r\n-          switch (mode)\r\n-            {\r\n-            case READ_ONLY:\r\n-              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n-                                      m_unchecked_read_only);\r\n-              break;\r\n-            case WRITE_ONLY:\r\n-              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n-                                      m_unchecked_write_only);\r\n-              break;\r\n-            default:\r\n-              sm_ctxt->on_transition (node, stmt, lhs, m_start,\r\n-                                      m_unchecked_read_write);\r\n-            }\r\n-        }\r\n-    }\r\n-  else\r\n-    {\r\n-      sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\r\n-    }\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\r\n-                            const gimple *stmt, const gcall *call) const\r\n-{\r\n-  tree arg = gimple_call_arg (call, 0);\r\n-  state_t state = sm_ctxt->get_state (stmt, arg);\r\n-  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n-\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_start, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_write, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_only, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_write_only, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_write, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_only, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_valid_write_only, m_closed);\r\n-  sm_ctxt->on_transition (node, stmt, arg, m_constant_fd, m_closed);\r\n-\r\n-  if (is_closed_fd_p (state))\r\n-    {\r\n-      sm_ctxt->warn (node, stmt, arg, new fd_double_close (*this, diag_arg));\r\n-      sm_ctxt->set_next_state (stmt, arg, m_stop);\r\n-    }\r\n-}\r\n-void\r\n-fd_state_machine::on_read (sm_context *sm_ctxt, const supernode *node,\r\n-                           const gimple *stmt, const gcall *call,\r\n-                           const tree callee_fndecl) const\r\n-{\r\n-  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_READ);\r\n-}\r\n-void\r\n-fd_state_machine::on_write (sm_context *sm_ctxt, const supernode *node,\r\n-                            const gimple *stmt, const gcall *call,\r\n-                            const tree callee_fndecl) const\r\n-{\r\n-  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_WRITE);\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::check_for_open_fd (\r\n-    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-    const gcall *call, const tree callee_fndecl,\r\n-    enum access_directions callee_fndecl_dir) const\r\n-{\r\n-  tree arg = gimple_call_arg (call, 0);\r\n-  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n-  state_t state = sm_ctxt->get_state (stmt, arg);\r\n-\r\n-  if (is_closed_fd_p (state))\r\n-    {\r\n-      sm_ctxt->warn (node, stmt, arg,\r\n-                     new fd_use_after_close (*this, diag_arg, callee_fndecl));\r\n-    }\r\n-\r\n-  else\r\n-    {\r\n-      if (!(is_valid_fd_p (state) || (state == m_stop)))\r\n-        {\r\n-          if (!is_constant_fd_p (state))\r\n-            sm_ctxt->warn (\r\n-                node, stmt, arg,\r\n-                new fd_use_without_check (*this, diag_arg, callee_fndecl));\r\n-        }\r\n-      switch (callee_fndecl_dir)\r\n-        {\r\n-        case DIRS_READ:\r\n-          if (is_writeonly_fd_p (state))\r\n-            {\r\n-              tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n-              sm_ctxt->warn (node, stmt, arg,\r\n-                             new fd_access_mode_mismatch (\r\n-                                 *this, diag_arg, DIRS_WRITE, callee_fndecl));\r\n-            }\r\n-\r\n-          break;\r\n-        case DIRS_WRITE:\r\n-\r\n-          if (is_readonly_fd_p (state))\r\n-            {\r\n-              tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\r\n-              sm_ctxt->warn (node, stmt, arg,\r\n-                             new fd_access_mode_mismatch (\r\n-                                 *this, diag_arg, DIRS_READ, callee_fndecl));\r\n-            }\r\n-          break;\r\n-        default:\r\n-          gcc_unreachable ();\r\n-        }\r\n-    }\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::on_condition (sm_context *sm_ctxt, const supernode *node,\r\n-                                const gimple *stmt, const svalue *lhs,\r\n-                                enum tree_code op, const svalue *rhs) const\r\n-{\r\n-  if (tree cst = rhs->maybe_get_constant ())\r\n-    {\r\n-      if (TREE_CODE (cst) == INTEGER_CST)\r\n-        {\r\n-          int val = TREE_INT_CST_LOW (cst);\r\n-          if (val == -1)\r\n-            {\r\n-              if (op == NE_EXPR)\r\n-                make_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n-\r\n-              else if (op == EQ_EXPR)\r\n-                make_invalid_transitions_on_condition (sm_ctxt, node, stmt,\r\n-                                                       lhs);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-  if (rhs->all_zeroes_p ())\r\n-    {\r\n-      if (op == GE_EXPR)\r\n-        make_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n-      else if (op == LT_EXPR)\r\n-        make_invalid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\r\n-    }\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::make_valid_transitions_on_condition (sm_context *sm_ctxt,\r\n-                                                       const supernode *node,\r\n-                                                       const gimple *stmt,\r\n-                                                       const svalue *lhs) const\r\n-{\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write,\r\n-                          m_valid_read_write);\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only,\r\n-                          m_valid_read_only);\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only,\r\n-                          m_valid_write_only);\r\n-}\r\n-\r\n-void\r\n-fd_state_machine::make_invalid_transitions_on_condition (\r\n-    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\r\n-    const svalue *lhs) const\r\n-{\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write, m_invalid);\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only, m_invalid);\r\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only, m_invalid);\r\n-}\r\n-\r\n-bool\r\n-fd_state_machine::can_purge_p (state_t s) const\r\n-{\r\n-  if (is_unchecked_fd_p (s) || is_valid_fd_p (s))\r\n-    return false;\r\n-  else\r\n-    return true;\r\n-}\r\n-\r\n-pending_diagnostic *\r\n-fd_state_machine::on_leak (tree var) const\r\n-{\r\n-  return new fd_leak (*this, var);\r\n-}\r\n-} // namespace\r\n-\r\n-state_machine *\r\n-make_fd_state_machine (logger *logger)\r\n-{\r\n-  return new fd_state_machine (logger);\r\n-}\r\n-} // namespace ana\r\n-\r\n-#endif // ENABLE_ANALYZER\n\\ No newline at end of file\n+/* A state machine for detecting misuses of POSIX file descriptor APIs.\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n+   Contributed by Immad Mir <mir@sourceware.org>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"options.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"function.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/pending-diagnostic.h\"\n+#include \"analyzer/function-set.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"bitmap.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+namespace {\n+\n+/* An enum for distinguishing between three different access modes.  */\n+\n+enum access_mode\n+{\n+  READ_WRITE,\n+  READ_ONLY,\n+  WRITE_ONLY\n+};\n+\n+enum access_directions\n+{\n+  DIRS_READ_WRITE,\n+  DIRS_READ,\n+  DIRS_WRITE\n+};\n+\n+class fd_state_machine : public state_machine\n+{\n+public:\n+  fd_state_machine (logger *logger);\n+\n+  bool\n+  inherited_state_p () const final override\n+  {\n+    return false;\n+  }\n+\n+  state_machine::state_t\n+  get_default_state (const svalue *sval) const final override\n+  {\n+    if (tree cst = sval->maybe_get_constant ())\n+      {\n+\tif (TREE_CODE (cst) == INTEGER_CST)\n+\t  {\n+\t    int val = TREE_INT_CST_LOW (cst);\n+\t    if (val >= 0)\n+\t      return m_constant_fd;\n+\t    else\n+\t      return m_invalid;\n+\t  }\n+      }\n+    return m_start;\n+  }\n+\n+  bool on_stmt (sm_context *sm_ctxt, const supernode *node,\n+\t\tconst gimple *stmt) const final override;\n+\n+  void on_condition (sm_context *sm_ctxt, const supernode *node,\n+\t\t     const gimple *stmt, const svalue *lhs, const tree_code op,\n+\t\t     const svalue *rhs) const final override;\n+\n+  bool can_purge_p (state_t s) const final override;\n+  pending_diagnostic *on_leak (tree var) const final override;\n+\n+  bool is_unchecked_fd_p (state_t s) const;\n+  bool is_valid_fd_p (state_t s) const;\n+  bool is_closed_fd_p (state_t s) const;\n+  bool is_constant_fd_p (state_t s) const;\n+  bool is_readonly_fd_p (state_t s) const;\n+  bool is_writeonly_fd_p (state_t s) const;\n+  enum access_mode get_access_mode_from_flag (int flag) const;\n+\n+  /* State for a constant file descriptor (>= 0) */\n+  state_t m_constant_fd;\n+\n+  /* States representing a file descriptor that hasn't yet been\n+    checked for validity after opening, for three different\n+    access modes.  */\n+  state_t m_unchecked_read_write;\n+\n+  state_t m_unchecked_read_only;\n+\n+  state_t m_unchecked_write_only;\n+\n+  /* States for representing a file descriptor that is known to be valid (>=\n+    0), for three different access modes.  */\n+  state_t m_valid_read_write;\n+\n+  state_t m_valid_read_only;\n+\n+  state_t m_valid_write_only;\n+\n+  /* State for a file descriptor that is known to be invalid (< 0). */\n+  state_t m_invalid;\n+\n+  /* State for a file descriptor that has been closed.  */\n+  state_t m_closed;\n+\n+  /* State for a file descriptor that we do not want to track anymore . */\n+  state_t m_stop;\n+\n+private:\n+  void on_open (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+\t\tconst gcall *call) const;\n+  void on_close (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+\t\t const gcall *call) const;\n+  void on_read (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+\t\tconst gcall *call, const tree callee_fndecl) const;\n+  void on_write (sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+\t\t const gcall *call, const tree callee_fndecl) const;\n+  void check_for_open_fd (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t  const gimple *stmt, const gcall *call,\n+\t\t\t  const tree callee_fndecl,\n+\t\t\t  enum access_directions access_fn) const;\n+\n+  void make_valid_transitions_on_condition (sm_context *sm_ctxt,\n+\t\t\t\t\t    const supernode *node,\n+\t\t\t\t\t    const gimple *stmt,\n+\t\t\t\t\t    const svalue *lhs) const;\n+  void make_invalid_transitions_on_condition (sm_context *sm_ctxt,\n+\t\t\t\t\t      const supernode *node,\n+\t\t\t\t\t      const gimple *stmt,\n+\t\t\t\t\t      const svalue *lhs) const;\n+  void check_for_fd_attrs (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t   const gimple *stmt, const gcall *call,\n+\t\t\t   const tree callee_fndecl, const char *attr_name,\n+\t\t\t   access_directions fd_attr_access_dir) const;\n+};\n+\n+/* Base diagnostic class relative to fd_state_machine.  */\n+class fd_diagnostic : public pending_diagnostic\n+{\n+public:\n+  fd_diagnostic (const fd_state_machine &sm, tree arg) : m_sm (sm), m_arg (arg)\n+  {\n+  }\n+\n+  bool\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\n+  {\n+    return same_tree_p (m_arg, ((const fd_diagnostic &)base_other).m_arg);\n+  }\n+\n+  label_text\n+  describe_state_change (const evdesc::state_change &change) override\n+  {\n+    if (change.m_old_state == m_sm.get_start_state ()\n+\t&& m_sm.is_unchecked_fd_p (change.m_new_state))\n+      {\n+\tif (change.m_new_state == m_sm.m_unchecked_read_write)\n+\t  return change.formatted_print (\"opened here as read-write\");\n+\n+\tif (change.m_new_state == m_sm.m_unchecked_read_only)\n+\t  return change.formatted_print (\"opened here as read-only\");\n+\n+\tif (change.m_new_state == m_sm.m_unchecked_write_only)\n+\t  return change.formatted_print (\"opened here as write-only\");\n+      }\n+\n+    if (change.m_new_state == m_sm.m_closed)\n+      return change.formatted_print (\"closed here\");\n+\n+    if (m_sm.is_unchecked_fd_p (change.m_old_state)\n+\t&& m_sm.is_valid_fd_p (change.m_new_state))\n+      {\n+\tif (change.m_expr)\n+\t  return change.formatted_print (\n+\t      \"assuming %qE is a valid file descriptor (>= 0)\", change.m_expr);\n+\telse\n+\t  return change.formatted_print (\"assuming a valid file descriptor\");\n+      }\n+\n+    if (m_sm.is_unchecked_fd_p (change.m_old_state)\n+\t&& change.m_new_state == m_sm.m_invalid)\n+      {\n+\tif (change.m_expr)\n+\t  return change.formatted_print (\n+\t      \"assuming %qE is an invalid file descriptor (< 0)\",\n+\t      change.m_expr);\n+\telse\n+\t  return change.formatted_print (\"assuming an invalid file descriptor\");\n+      }\n+\n+    return label_text ();\n+  }\n+\n+protected:\n+  const fd_state_machine &m_sm;\n+  tree m_arg;\n+};\n+\n+class fd_param_diagnostic : public fd_diagnostic\n+{\n+public:\n+  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl,\n+\t\t       const char *attr_name, int arg_idx)\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\n+\tm_attr_name (attr_name), m_arg_idx (arg_idx)\n+  {\n+  }\n+\n+  fd_param_diagnostic (const fd_state_machine &sm, tree arg, tree callee_fndecl)\n+      : fd_diagnostic (sm, arg), m_callee_fndecl (callee_fndecl),\n+\tm_attr_name (NULL), m_arg_idx (-1)\n+  {\n+  }\n+\n+  bool\n+  subclass_equal_p (const pending_diagnostic &base_other) const override\n+  {\n+    const fd_param_diagnostic &sub_other\n+\t= (const fd_param_diagnostic &)base_other;\n+    return (same_tree_p (m_arg, sub_other.m_arg)\n+\t    && same_tree_p (m_callee_fndecl, sub_other.m_callee_fndecl)\n+\t    && m_arg_idx == sub_other.m_arg_idx\n+\t    && ((m_attr_name)\n+\t\t    ? (strcmp (m_attr_name, sub_other.m_attr_name) == 0)\n+\t\t    : true));\n+  }\n+\n+  void\n+  inform_filedescriptor_attribute (access_directions fd_dir)\n+  {\n+\n+    if (m_attr_name)\n+      switch (fd_dir)\n+\t{\n+\tcase DIRS_READ_WRITE:\n+\t  inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\n+\t\t  \"argument %d of %qD must be an open file descriptor, due to \"\n+\t\t  \"%<__attribute__((%s(%d)))%>\",\n+\t\t  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\n+\t  break;\n+\tcase DIRS_WRITE:\n+\t  inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\n+\t\t  \"argument %d of %qD must be a readable file descriptor, due \"\n+\t\t  \"to %<__attribute__((%s(%d)))%>\",\n+\t\t  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\n+\t  break;\n+\tcase DIRS_READ:\n+\t  inform (DECL_SOURCE_LOCATION (m_callee_fndecl),\n+\t\t  \"argument %d of %qD must be a writable file descriptor, due \"\n+\t\t  \"to %<__attribute__((%s(%d)))%>\",\n+\t\t  m_arg_idx + 1, m_callee_fndecl, m_attr_name, m_arg_idx + 1);\n+\t  break;\n+\t}\n+  }\n+\n+protected:\n+  tree m_callee_fndecl;\n+  const char *m_attr_name;\n+  /* ARG_IDX is 0-based.  */\n+  int m_arg_idx;\n+};\n+\n+class fd_leak : public fd_diagnostic\n+{\n+public:\n+  fd_leak (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg) {}\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_leak\";\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_leak;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    /*CWE-775: Missing Release of File Descriptor or Handle after Effective\n+      Lifetime\n+     */\n+    diagnostic_metadata m;\n+    m.add_cwe (775);\n+    if (m_arg)\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t   \"leak of file descriptor %qE\", m_arg);\n+    else\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t   \"leak of file descriptor\");\n+  }\n+\n+  label_text\n+  describe_state_change (const evdesc::state_change &change) final override\n+  {\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\n+      {\n+\tm_open_event = change.m_event_id;\n+\treturn label_text::borrow (\"opened here\");\n+      }\n+\n+    return fd_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_open_event.known_p ())\n+      {\n+\tif (ev.m_expr)\n+\t  return ev.formatted_print (\"%qE leaks here; was opened at %@\",\n+\t\t\t\t     ev.m_expr, &m_open_event);\n+\telse\n+\t  return ev.formatted_print (\"leaks here; was opened at %@\",\n+\t\t\t\t     &m_open_event);\n+      }\n+    else\n+      {\n+\tif (ev.m_expr)\n+\t  return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n+\telse\n+\t  return ev.formatted_print (\"leaks here\");\n+      }\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_open_event;\n+};\n+\n+class fd_access_mode_mismatch : public fd_param_diagnostic\n+{\n+public:\n+  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\n+\t\t\t   enum access_directions fd_dir,\n+\t\t\t   const tree callee_fndecl, const char *attr_name,\n+\t\t\t   int arg_idx)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx),\n+\tm_fd_dir (fd_dir)\n+\n+  {\n+  }\n+\n+  fd_access_mode_mismatch (const fd_state_machine &sm, tree arg,\n+\t\t\t   enum access_directions fd_dir,\n+\t\t\t   const tree callee_fndecl)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl), m_fd_dir (fd_dir)\n+  {\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_access_mode_mismatch\";\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_access_mode_mismatch;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    bool warned;\n+    switch (m_fd_dir)\n+      {\n+      case DIRS_READ:\n+\twarned =  warning_at (rich_loc, get_controlling_option (),\n+\t\t\t   \"%qE on read-only file descriptor %qE\",\n+\t\t\t   m_callee_fndecl, m_arg);\n+\tbreak;\n+      case DIRS_WRITE:\n+\twarned = warning_at (rich_loc, get_controlling_option (),\n+\t\t\t   \"%qE on write-only file descriptor %qE\",\n+\t\t\t   m_callee_fndecl, m_arg);\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+      if (warned)\n+\tinform_filedescriptor_attribute (m_fd_dir);\n+      return warned;\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    switch (m_fd_dir)\n+      {\n+      case DIRS_READ:\n+\treturn ev.formatted_print (\"%qE on read-only file descriptor %qE\",\n+\t\t\t\t   m_callee_fndecl, m_arg);\n+      case DIRS_WRITE:\n+\treturn ev.formatted_print (\"%qE on write-only file descriptor %qE\",\n+\t\t\t\t   m_callee_fndecl, m_arg);\n+      default:\n+\tgcc_unreachable ();\n+      }\n+  }\n+\n+private:\n+  enum access_directions m_fd_dir;\n+};\n+\n+class fd_double_close : public fd_diagnostic\n+{\n+public:\n+  fd_double_close (const fd_state_machine &sm, tree arg) : fd_diagnostic (sm, arg)\n+  {\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_double_close\";\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_double_close;\n+  }\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    // CWE-1341: Multiple Releases of Same Resource or Handle\n+    m.add_cwe (1341);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"double %<close%> of file descriptor %qE\", m_arg);\n+  }\n+\n+  label_text\n+  describe_state_change (const evdesc::state_change &change) override\n+  {\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\n+      return label_text::borrow (\"opened here\");\n+\n+    if (change.m_new_state == m_sm.m_closed)\n+      {\n+\tm_first_close_event = change.m_event_id;\n+\treturn change.formatted_print (\"first %qs here\", \"close\");\n+      }\n+    return fd_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_first_close_event.known_p ())\n+      return ev.formatted_print (\"second %qs here; first %qs was at %@\",\n+\t\t\t\t \"close\", \"close\", &m_first_close_event);\n+    return ev.formatted_print (\"second %qs here\", \"close\");\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_close_event;\n+};\n+\n+class fd_use_after_close : public fd_param_diagnostic\n+{\n+public:\n+  fd_use_after_close (const fd_state_machine &sm, tree arg,\n+\t\t      const tree callee_fndecl, const char *attr_name,\n+\t\t      int arg_idx)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\n+  {\n+  }\n+\n+  fd_use_after_close (const fd_state_machine &sm, tree arg,\n+\t\t      const tree callee_fndecl)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl)\n+  {\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_use_after_close\";\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_use_after_close;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    bool warned;\n+    warned = warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"%qE on closed file descriptor %qE\", m_callee_fndecl,\n+\t\t       m_arg);\n+    if (warned)\n+      inform_filedescriptor_attribute (DIRS_READ_WRITE);\n+    return warned;\n+  }\n+\n+  label_text\n+  describe_state_change (const evdesc::state_change &change) override\n+  {\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\n+      return label_text::borrow (\"opened here\");\n+\n+    if (change.m_new_state == m_sm.m_closed)\n+      {\n+\tm_first_close_event = change.m_event_id;\n+\treturn change.formatted_print (\"closed here\");\n+      }\n+\n+    return fd_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_first_close_event.known_p ())\n+\treturn ev.formatted_print (\n+\t    \"%qE on closed file descriptor %qE; %qs was at %@\", m_callee_fndecl,\n+\t    m_arg, \"close\", &m_first_close_event);\n+      else\n+\treturn ev.formatted_print (\"%qE on closed file descriptor %qE\",\n+\t\t\t\t  m_callee_fndecl, m_arg);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_close_event;\n+};\n+\n+class fd_use_without_check : public fd_param_diagnostic\n+{\n+public:\n+  fd_use_without_check (const fd_state_machine &sm, tree arg,\n+\t\t\tconst tree callee_fndecl, const char *attr_name,\n+\t\t\tint arg_idx)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl, attr_name, arg_idx)\n+  {\n+  }\n+\n+  fd_use_without_check (const fd_state_machine &sm, tree arg,\n+\t\t\tconst tree callee_fndecl)\n+      : fd_param_diagnostic (sm, arg, callee_fndecl)\n+  {\n+  }\n+\n+  const char *\n+  get_kind () const final override\n+  {\n+    return \"fd_use_without_check\";\n+  }\n+\n+  int\n+  get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_fd_use_without_check;\n+  }\n+\n+  bool\n+  emit (rich_location *rich_loc) final override\n+  {\n+    bool warned;\n+    warned = warning_at (rich_loc, get_controlling_option (),\n+\t\t\t\"%qE on possibly invalid file descriptor %qE\",\n+\t\t\tm_callee_fndecl, m_arg);\n+    if (warned)\n+     inform_filedescriptor_attribute (DIRS_READ_WRITE);\n+    return warned;\n+  }\n+\n+  label_text\n+  describe_state_change (const evdesc::state_change &change) override\n+  {\n+    if (m_sm.is_unchecked_fd_p (change.m_new_state))\n+      {\n+\tm_first_open_event = change.m_event_id;\n+\treturn label_text::borrow (\"opened here\");\n+      }\n+\n+    return fd_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_first_open_event.known_p ())\n+      return ev.formatted_print (\n+\t  \"%qE could be invalid: unchecked value from %@\", m_arg,\n+\t  &m_first_open_event);\n+    else\n+      return ev.formatted_print (\"%qE could be invalid\", m_arg);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_open_event;\n+};\n+\n+fd_state_machine::fd_state_machine (logger *logger)\n+    : state_machine (\"file-descriptor\", logger),\n+      m_constant_fd (add_state (\"fd-constant\")),\n+      m_unchecked_read_write (add_state (\"fd-unchecked-read-write\")),\n+      m_unchecked_read_only (add_state (\"fd-unchecked-read-only\")),\n+      m_unchecked_write_only (add_state (\"fd-unchecked-write-only\")),\n+      m_valid_read_write (add_state (\"fd-valid-read-write\")),\n+      m_valid_read_only (add_state (\"fd-valid-read-only\")),\n+      m_valid_write_only (add_state (\"fd-valid-write-only\")),\n+      m_invalid (add_state (\"fd-invalid\")),\n+      m_closed (add_state (\"fd-closed\")),\n+      m_stop (add_state (\"fd-stop\"))\n+{\n+}\n+\n+bool\n+fd_state_machine::is_unchecked_fd_p (state_t s) const\n+{\n+  return (s == m_unchecked_read_write\n+       || s == m_unchecked_read_only\n+       || s == m_unchecked_write_only);\n+}\n+\n+bool\n+fd_state_machine::is_valid_fd_p (state_t s) const\n+{\n+  return (s == m_valid_read_write\n+       || s == m_valid_read_only\n+       || s == m_valid_write_only);\n+}\n+\n+enum access_mode\n+fd_state_machine::get_access_mode_from_flag (int flag) const\n+{\n+  /* FIXME: this code assumes the access modes on the host and\n+     target are the same, which in practice might not be the case.  */\n+\n+  if ((flag & O_ACCMODE) == O_RDONLY)\n+    {\n+      return READ_ONLY;\n+    }\n+  else if ((flag & O_ACCMODE) == O_WRONLY)\n+    {\n+      return WRITE_ONLY;\n+    }\n+  return READ_WRITE;\n+}\n+\n+bool\n+fd_state_machine::is_readonly_fd_p (state_t state) const\n+{\n+  return (state == m_unchecked_read_only || state == m_valid_read_only);\n+}\n+\n+bool\n+fd_state_machine::is_writeonly_fd_p (state_t state) const\n+{\n+  return (state == m_unchecked_write_only || state == m_valid_write_only);\n+}\n+\n+bool\n+fd_state_machine::is_closed_fd_p (state_t state) const\n+{\n+  return (state == m_closed);\n+}\n+\n+bool\n+fd_state_machine::is_constant_fd_p (state_t state) const\n+{\n+  return (state == m_constant_fd);\n+}\n+\n+bool\n+fd_state_machine::on_stmt (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t   const gimple *stmt) const\n+{\n+  if (const gcall *call = dyn_cast<const gcall *> (stmt))\n+    if (tree callee_fndecl = sm_ctxt->get_fndecl_for_call (call))\n+      {\n+\tif (is_named_call_p (callee_fndecl, \"open\", call, 2))\n+\t  {\n+\t    on_open (sm_ctxt, node, stmt, call);\n+\t    return true;\n+\t  } //  \"open\"\n+\n+\tif (is_named_call_p (callee_fndecl, \"close\", call, 1))\n+\t  {\n+\t    on_close (sm_ctxt, node, stmt, call);\n+\t    return true;\n+\t  } //  \"close\"\n+\n+\tif (is_named_call_p (callee_fndecl, \"write\", call, 3))\n+\t  {\n+\t    on_write (sm_ctxt, node, stmt, call, callee_fndecl);\n+\t    return true;\n+\t  } // \"write\"\n+\n+\tif (is_named_call_p (callee_fndecl, \"read\", call, 3))\n+\t  {\n+\t    on_read (sm_ctxt, node, stmt, call, callee_fndecl);\n+\t    return true;\n+\t  } // \"read\"\n+\n+\n+\t{\n+\t  // Handle __attribute__((fd_arg))\n+\n+\t  check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\n+\t\t\t      \"fd_arg\", DIRS_READ_WRITE);\n+\n+\t  // Handle __attribute__((fd_arg_read))\n+\n+\t  check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\n+\t\t\t      \"fd_arg_read\", DIRS_READ);\n+\n+\t  // Handle __attribute__((fd_arg_write))\n+\n+\t  check_for_fd_attrs (sm_ctxt, node, stmt, call, callee_fndecl,\n+\t\t\t      \"fd_arg_write\", DIRS_WRITE);\n+\t}\n+      }\n+\n+  return false;\n+}\n+\n+void\n+fd_state_machine::check_for_fd_attrs (\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+    const gcall *call, const tree callee_fndecl, const char *attr_name,\n+    access_directions fd_attr_access_dir) const\n+{\n+\n+  tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (callee_fndecl));\n+  attrs = lookup_attribute (attr_name, attrs);\n+  if (!attrs)\n+    return;\n+\n+  if (!TREE_VALUE (attrs))\n+    return;\n+\n+  auto_bitmap argmap;\n+\n+  for (tree idx = TREE_VALUE (attrs); idx; idx = TREE_CHAIN (idx))\n+    {\n+      unsigned int val = TREE_INT_CST_LOW (TREE_VALUE (idx)) - 1;\n+      bitmap_set_bit (argmap, val);\n+    }\n+  if (bitmap_empty_p (argmap))\n+    return;\n+\n+  for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\n+    {\n+      tree arg = gimple_call_arg (call, arg_idx);\n+      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+      state_t state = sm_ctxt->get_state (stmt, arg);\n+      bool bit_set = bitmap_bit_p (argmap, arg_idx);\n+      if (TREE_CODE (TREE_TYPE (arg)) != INTEGER_TYPE)\n+\tcontinue;\n+      if (bit_set) // Check if arg_idx is marked by any of the file descriptor\n+\t\t   // attributes\n+\t{\n+\n+\t  if (is_closed_fd_p (state))\n+\t    {\n+\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new fd_use_after_close (*this, diag_arg,\n+\t\t\t\t\t\t     callee_fndecl, attr_name,\n+\t\t\t\t\t\t     arg_idx));\n+\t      continue;\n+\t    }\n+\n+\t  if (!(is_valid_fd_p (state) || (state == m_stop)))\n+\t    {\n+\t      if (!is_constant_fd_p (state))\n+\t\tsm_ctxt->warn (node, stmt, arg,\n+\t\t\t       new fd_use_without_check (*this, diag_arg,\n+\t\t\t\t\t\t\tcallee_fndecl, attr_name,\n+\t\t\t\t\t\t\targ_idx));\n+\t    }\n+\n+\t  switch (fd_attr_access_dir)\n+\t    {\n+\t    case DIRS_READ_WRITE:\n+\t      break;\n+\t    case DIRS_READ:\n+\n+\t      if (is_writeonly_fd_p (state))\n+\t\t{\n+\t\t  sm_ctxt->warn (\n+\t\t      node, stmt, arg,\n+\t\t      new fd_access_mode_mismatch (*this, diag_arg, DIRS_WRITE,\n+\t\t\t\t\t\t   callee_fndecl, attr_name, arg_idx));\n+\t\t}\n+\n+\t      break;\n+\t    case DIRS_WRITE:\n+\n+\t      if (is_readonly_fd_p (state))\n+\t\t{\n+\t\t  sm_ctxt->warn (\n+\t\t      node, stmt, arg,\n+\t\t      new fd_access_mode_mismatch (*this, diag_arg, DIRS_READ,\n+\t\t\t\t\t\t   callee_fndecl, attr_name, arg_idx));\n+\t\t}\n+\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+void\n+fd_state_machine::on_open (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t   const gimple *stmt, const gcall *call) const\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  if (lhs)\n+    {\n+      tree arg = gimple_call_arg (call, 1);\n+      if (TREE_CODE (arg) == INTEGER_CST)\n+\t{\n+\t  int flag = TREE_INT_CST_LOW (arg);\n+\t  enum access_mode mode = get_access_mode_from_flag (flag);\n+\n+\t  switch (mode)\n+\t    {\n+\t    case READ_ONLY:\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t      m_unchecked_read_only);\n+\t      break;\n+\t    case WRITE_ONLY:\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t      m_unchecked_write_only);\n+\t      break;\n+\t    default:\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start,\n+\t\t\t\t      m_unchecked_read_write);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      sm_ctxt->warn (node, stmt, NULL_TREE, new fd_leak (*this, NULL_TREE));\n+    }\n+}\n+\n+void\n+fd_state_machine::on_close (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t    const gimple *stmt, const gcall *call) const\n+{\n+  tree arg = gimple_call_arg (call, 0);\n+  state_t state = sm_ctxt->get_state (stmt, arg);\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+\n+  sm_ctxt->on_transition (node, stmt, arg, m_start, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_write, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_read_only, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_unchecked_write_only, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_write, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_read_only, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_valid_write_only, m_closed);\n+  sm_ctxt->on_transition (node, stmt, arg, m_constant_fd, m_closed);\n+\n+  if (is_closed_fd_p (state))\n+    {\n+      sm_ctxt->warn (node, stmt, arg, new fd_double_close (*this, diag_arg));\n+      sm_ctxt->set_next_state (stmt, arg, m_stop);\n+    }\n+}\n+void\n+fd_state_machine::on_read (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t   const gimple *stmt, const gcall *call,\n+\t\t\t   const tree callee_fndecl) const\n+{\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_READ);\n+}\n+void\n+fd_state_machine::on_write (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t    const gimple *stmt, const gcall *call,\n+\t\t\t    const tree callee_fndecl) const\n+{\n+  check_for_open_fd (sm_ctxt, node, stmt, call, callee_fndecl, DIRS_WRITE);\n+}\n+\n+void\n+fd_state_machine::check_for_open_fd (\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+    const gcall *call, const tree callee_fndecl,\n+    enum access_directions callee_fndecl_dir) const\n+{\n+  tree arg = gimple_call_arg (call, 0);\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+  state_t state = sm_ctxt->get_state (stmt, arg);\n+\n+  if (is_closed_fd_p (state))\n+    {\n+      sm_ctxt->warn (node, stmt, arg,\n+\t\t     new fd_use_after_close (*this, diag_arg, callee_fndecl));\n+    }\n+\n+  else\n+    {\n+      if (!(is_valid_fd_p (state) || (state == m_stop)))\n+\t{\n+\t  if (!is_constant_fd_p (state))\n+\t    sm_ctxt->warn (\n+\t\tnode, stmt, arg,\n+\t\tnew fd_use_without_check (*this, diag_arg, callee_fndecl));\n+\t}\n+      switch (callee_fndecl_dir)\n+\t{\n+\tcase DIRS_READ:\n+\t  if (is_writeonly_fd_p (state))\n+\t    {\n+\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new fd_access_mode_mismatch (\n+\t\t\t\t *this, diag_arg, DIRS_WRITE, callee_fndecl));\n+\t    }\n+\n+\t  break;\n+\tcase DIRS_WRITE:\n+\n+\t  if (is_readonly_fd_p (state))\n+\t    {\n+\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+\t      sm_ctxt->warn (node, stmt, arg,\n+\t\t\t     new fd_access_mode_mismatch (\n+\t\t\t\t *this, diag_arg, DIRS_READ, callee_fndecl));\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n+void\n+fd_state_machine::on_condition (sm_context *sm_ctxt, const supernode *node,\n+\t\t\t\tconst gimple *stmt, const svalue *lhs,\n+\t\t\t\tenum tree_code op, const svalue *rhs) const\n+{\n+  if (tree cst = rhs->maybe_get_constant ())\n+    {\n+      if (TREE_CODE (cst) == INTEGER_CST)\n+\t{\n+\t  int val = TREE_INT_CST_LOW (cst);\n+\t  if (val == -1)\n+\t    {\n+\t      if (op == NE_EXPR)\n+\t\tmake_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\n+\n+\t      else if (op == EQ_EXPR)\n+\t\tmake_invalid_transitions_on_condition (sm_ctxt, node, stmt,\n+\t\t\t\t\t\t       lhs);\n+\t    }\n+\t}\n+    }\n+\n+  if (rhs->all_zeroes_p ())\n+    {\n+      if (op == GE_EXPR)\n+\tmake_valid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\n+      else if (op == LT_EXPR)\n+\tmake_invalid_transitions_on_condition (sm_ctxt, node, stmt, lhs);\n+    }\n+}\n+\n+void\n+fd_state_machine::make_valid_transitions_on_condition (sm_context *sm_ctxt,\n+\t\t\t\t\t\t       const supernode *node,\n+\t\t\t\t\t\t       const gimple *stmt,\n+\t\t\t\t\t\t       const svalue *lhs) const\n+{\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write,\n+\t\t\t  m_valid_read_write);\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only,\n+\t\t\t  m_valid_read_only);\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only,\n+\t\t\t  m_valid_write_only);\n+}\n+\n+void\n+fd_state_machine::make_invalid_transitions_on_condition (\n+    sm_context *sm_ctxt, const supernode *node, const gimple *stmt,\n+    const svalue *lhs) const\n+{\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_write, m_invalid);\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_read_only, m_invalid);\n+  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked_write_only, m_invalid);\n+}\n+\n+bool\n+fd_state_machine::can_purge_p (state_t s) const\n+{\n+  if (is_unchecked_fd_p (s) || is_valid_fd_p (s))\n+    return false;\n+  else\n+    return true;\n+}\n+\n+pending_diagnostic *\n+fd_state_machine::on_leak (tree var) const\n+{\n+  return new fd_leak (*this, var);\n+}\n+} // namespace\n+\n+state_machine *\n+make_fd_state_machine (logger *logger)\n+{\n+  return new fd_state_machine (logger);\n+}\n+} // namespace ana\n+\n+#endif // ENABLE_ANALYZER"}]}