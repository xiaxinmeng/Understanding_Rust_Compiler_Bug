{"sha": "52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "node_id": "C_kwDOANBUbNoAKDUyYjdiODZmOGM3MmViMTllNjM3ZjFlNzJmZmQxMGYzOWI4Y2I4Mjk", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-04T08:43:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-04T13:12:28Z"}, "message": "tree-optimization/103116 - SLP permutes and peeling for gaps\n\nThe testcase shows that we can end up with a contiguous access across\nloop iterations but by means of permutations the elements accessed\nmight only cover parts of a vector.  In this case we end up with\nGROUP_GAP == 0 but still need to avoid accessing excess elements\nin the last loop iterations.  Peeling for gaps is designed to cover\nthis but a single scalar iteration might not cover all of the excess\nelements.  The following ensures peeling for gaps is done in this\nsituation and when that isn't sufficient because we need to peel\nmore than one iteration (gcc.dg/vect/pr103116-2.c), fail the SLP\nvectorization.\n\n2022-05-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/103116\n\t* tree-vect-stmts.cc (get_group_load_store_type): Handle the\n\tcase we need peeling for gaps even though GROUP_GAP is zero.\n\n\t* gcc.dg/vect/pr103116-1.c: New testcase.\n\t* gcc.dg/vect/pr103116-2.c: Likewise.", "tree": {"sha": "e3be8ae54b34bd4c70e8ec90c02eebb5c53734ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3be8ae54b34bd4c70e8ec90c02eebb5c53734ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aa9aa76bbf53213fb60ad36bd999726dc75aa98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa9aa76bbf53213fb60ad36bd999726dc75aa98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aa9aa76bbf53213fb60ad36bd999726dc75aa98"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "d3639fc8cfda98091886476f70158035dbc24163", "filename": "gcc/testsuite/gcc.dg/vect/pr103116-1.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-1.c?ref=52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target mmap } */\n+\n+#include <sys/mman.h>\n+#include <stdio.h>\n+\n+#define COUNT 128\n+#define MMAP_SIZE 0x20000\n+#define ADDRESS 0x1122000000\n+#define TYPE unsigned int\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+void __attribute__((noipa))\n+loop (TYPE *restrict x, TYPE *restrict y)\n+{\n+  for (int i = 0; i < COUNT; ++i)\n+    {\n+      x[i * 4] = y[i * 2] + 1;\n+      x[i * 4 + 1] = y[i * 2] + 2;\n+      x[i * 4 + 2] = y[i * 2 + 1] + 3;\n+      x[i * 4 + 3] = y[i * 2 + 1] + 4;\n+    }\n+}\n+\n+TYPE x[COUNT * 4];\n+\n+int\n+main (void)\n+{\n+  void *y;\n+  TYPE *end_y;\n+\n+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,\n+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (y == MAP_FAILED)\n+    {\n+      perror (\"mmap\");\n+      return 1;\n+    }\n+\n+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);\n+\n+  loop (x, end_y - COUNT * 2);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Data access with gaps requires scalar epilogue loop\" \"vect\" { target { vect_perm && vect_int } } } } */"}, {"sha": "2f4ed0f404c76b700fe3e6eefff4ca6a37f91101", "filename": "gcc/testsuite/gcc.dg/vect/pr103116-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr103116-2.c?ref=52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target mmap } */\n+/* { dg-additional-options \"-mssse3\" { target x86_64-*-* i?86-*-* } } */\n+\n+#include <sys/mman.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define COUNT 128\n+#define MMAP_SIZE 0x20000\n+#define ADDRESS 0x1122000000\n+#define TYPE unsigned short\n+#define GROUP_SIZE 2\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+void __attribute__((noipa))\n+loop (TYPE *restrict x, TYPE *restrict y)\n+{\n+  for (int i = 0; i < COUNT; ++i)\n+    {\n+      x[i * 8] = y[i * GROUP_SIZE] + 1;\n+      x[i * 8 + 1] = y[i * GROUP_SIZE] + 2;\n+      x[i * 8 + 2] = y[i * GROUP_SIZE + 1] + 3;\n+      x[i * 8 + 3] = y[i * GROUP_SIZE + 1] + 4;\n+      x[i * 8 + 4] = y[i * GROUP_SIZE] + 5;\n+      x[i * 8 + 5] = y[i * GROUP_SIZE] + 6;\n+      x[i * 8 + 6] = y[i * GROUP_SIZE + 1] + 7;\n+      x[i * 8 + 7] = y[i * GROUP_SIZE + 1] + 8;\n+    }\n+}\n+\n+TYPE x[COUNT * 4];\n+\n+int\n+main (void)\n+{\n+  void *y;\n+  TYPE *end_y;\n+\n+  check_vect ();\n+\n+  y = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,\n+            MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (y == MAP_FAILED)\n+    {\n+      perror (\"mmap\");\n+      return 1;\n+    }\n+\n+  end_y = (TYPE *) ((char *) y + MMAP_SIZE);\n+\n+  loop (x, end_y - COUNT * GROUP_SIZE);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"peeling for gaps insufficient for access\" \"vect\" { target { vect_perm_short } } } } */"}, {"sha": "d8da13e312aeb6bcc9b3a8ff0c8145f82561e806", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52b7b86f8c72eb19e637f1e72ffd10f39b8cb829/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=52b7b86f8c72eb19e637f1e72ffd10f39b8cb829", "patch": "@@ -2293,6 +2293,37 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n \t      gcc_assert (!loop_vinfo || cmp > 0);\n \t      *memory_access_type = VMAT_CONTIGUOUS;\n \t    }\n+\n+\t  /* When we have a contiguous access across loop iterations\n+\t     but the access in the loop doesn't cover the full vector\n+\t     we can end up with no gap recorded but still excess\n+\t     elements accessed, see PR103116.  Make sure we peel for\n+\t     gaps if necessary and sufficient and give up if not.  */\n+\t  if (loop_vinfo\n+\t      && *memory_access_type == VMAT_CONTIGUOUS\n+\t      && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ()\n+\t      && !multiple_p (group_size * LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+\t\t\t      nunits))\n+\t    {\n+\t      unsigned HOST_WIDE_INT cnunits, cvf;\n+\t      if (!can_overrun_p\n+\t\t  || !nunits.is_constant (&cnunits)\n+\t\t  || !LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&cvf)\n+\t\t  /* Peeling for gaps assumes that a single scalar iteration\n+\t\t     is enough to make sure the last vector iteration doesn't\n+\t\t     access excess elements.\n+\t\t     ???  Enhancements include peeling multiple iterations\n+\t\t     or using masked loads with a static mask.  */\n+\t\t  || (group_size * cvf) % cnunits + group_size < cnunits)\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"peeling for gaps insufficient for \"\n+\t\t\t\t     \"access\\n\");\n+\t\t  return false;\n+\t\t}\n+\t      overrun_p = true;\n+\t    }\n \t}\n     }\n   else"}]}