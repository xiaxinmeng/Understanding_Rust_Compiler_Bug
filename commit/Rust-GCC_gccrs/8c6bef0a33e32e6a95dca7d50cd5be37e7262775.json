{"sha": "8c6bef0a33e32e6a95dca7d50cd5be37e7262775", "node_id": "C_kwDOANBUbNoAKDhjNmJlZjBhMzNlMzJlNmE5NWRjYTdkNTBjZDViZTM3ZTcyNjI3NzU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-06-01T23:00:48Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-04T07:46:00Z"}, "message": "[Ada] Do not make procedure call with only tag-indeternminate actuals dispatching\n\nThe RM 3.9.2(19) clause says that the controlling tag value is statically\ndetermined to be the tag of the tagged type involved.  As a matter of fact,\nthe call would be made dispatching only as a by-product of the propagation\nof the controlling tag value to the tag-indeternminate actuals, but that's\nunnecessary and not done in the equivalent case of a procedure call with\nboth statically tagged and tag-indeternminate actuals.\n\ngcc/ada/\n\n\t* sem_disp.adb (Check_Dispatching_Call): Merge the two special cases\n\twhere there are no controlling actuals but tag-indeternminate ones.", "tree": {"sha": "fbddcb7d0612c5865ddd13f8b1d8d30c80fea4bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbddcb7d0612c5865ddd13f8b1d8d30c80fea4bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c6bef0a33e32e6a95dca7d50cd5be37e7262775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6bef0a33e32e6a95dca7d50cd5be37e7262775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6bef0a33e32e6a95dca7d50cd5be37e7262775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6bef0a33e32e6a95dca7d50cd5be37e7262775/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f03b43fc7552fe105d33612b3b89b4f0b222798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f03b43fc7552fe105d33612b3b89b4f0b222798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f03b43fc7552fe105d33612b3b89b4f0b222798"}], "stats": {"total": 77, "additions": 35, "deletions": 42}, "files": [{"sha": "ee1d96ec389da5797451b9f1b3887c274fd66392", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c6bef0a33e32e6a95dca7d50cd5be37e7262775/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c6bef0a33e32e6a95dca7d50cd5be37e7262775/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=8c6bef0a33e32e6a95dca7d50cd5be37e7262775", "patch": "@@ -540,8 +540,10 @@ package body Sem_Disp is\n       Control                : Node_Id := Empty;\n       Func                   : Entity_Id;\n       Subp_Entity            : Entity_Id;\n-      Indeterm_Ancestor_Call : Boolean := False;\n-      Indeterm_Ctrl_Type     : Entity_Id := Empty; -- init to avoid warning\n+\n+      Indeterm_Ctrl_Type : Entity_Id := Empty;\n+      --  Type of a controlling formal whose actual is a tag-indeterminate call\n+      --  whose result type is different from, but is an ancestor of, the type.\n \n       Static_Tag : Node_Id := Empty;\n       --  If a controlling formal has a statically tagged actual, the tag of\n@@ -935,8 +937,7 @@ package body Sem_Disp is\n               and then Base_Type (Etype (Actual)) /= Base_Type (Etype (Formal))\n               and then Is_Ancestor (Etype (Actual), Etype (Formal))\n             then\n-               Indeterm_Ancestor_Call := True;\n-               Indeterm_Ctrl_Type     := Etype (Formal);\n+               Indeterm_Ctrl_Type := Etype (Formal);\n \n             --  If the formal is controlling but the actual is not, the type\n             --  of the actual is statically known, and may be used as the\n@@ -946,39 +947,13 @@ package body Sem_Disp is\n               and then Is_Entity_Name (Actual)\n               and then Is_Tagged_Type (Etype (Actual))\n             then\n-               Static_Tag := Actual;\n+               Static_Tag := Etype (Actual);\n             end if;\n \n             Next_Actual (Actual);\n             Next_Formal (Formal);\n          end loop;\n \n-         --  If the call doesn't have a controlling actual but does have an\n-         --  indeterminate actual that requires dispatching treatment, then an\n-         --  object is needed that will serve as the controlling argument for\n-         --  a dispatching call on the indeterminate actual. This can occur\n-         --  in the unusual situation of a default actual given by a tag-\n-         --  indeterminate call and where the type of the call is an ancestor\n-         --  of the type associated with a containing call to an inherited\n-         --  operation (see AI-239).\n-\n-         --  Rather than create an object of the tagged type, which would\n-         --  be problematic for various reasons (default initialization,\n-         --  discriminants), the tag of the containing call's associated\n-         --  tagged type is directly used to control the dispatching.\n-\n-         if No (Control)\n-           and then Indeterm_Ancestor_Call\n-           and then No (Static_Tag)\n-         then\n-            Control :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Occurrence_Of (Indeterm_Ctrl_Type, Loc),\n-                Attribute_Name => Name_Tag);\n-\n-            Analyze (Control);\n-         end if;\n-\n          if Present (Control) then\n \n             --  Verify that no controlling arguments are statically tagged\n@@ -1030,17 +1005,35 @@ package body Sem_Disp is\n \n             Check_Direct_Call;\n \n-         --  If there is a statically tagged actual and a tag-indeterminate\n-         --  call to a function of the ancestor (such as that provided by a\n-         --  default), then treat this as a dispatching call and propagate\n-         --  the tag to the tag-indeterminate call(s).\n-\n-         elsif Present (Static_Tag) and then Indeterm_Ancestor_Call then\n-            Control :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         =>\n-                  New_Occurrence_Of (Etype (Static_Tag), Loc),\n-                Attribute_Name => Name_Tag);\n+         --  If the call doesn't have a controlling actual but does have an\n+         --  indeterminate actual that requires dispatching treatment, then an\n+         --  object is needed that will serve as the controlling argument for\n+         --  a dispatching call on the indeterminate actual. This can occur\n+         --  in the unusual situation of a default actual given by a tag-\n+         --  indeterminate call and where the type of the call is an ancestor\n+         --  of the type associated with a containing call to an inherited\n+         --  operation (see AI-239).\n+\n+         --  Rather than create an object of the tagged type, which would\n+         --  be problematic for various reasons (default initialization,\n+         --  discriminants), the tag of the containing call's associated\n+         --  tagged type is directly used to control the dispatching.\n+\n+         elsif Present (Indeterm_Ctrl_Type) then\n+            if Present (Static_Tag) then\n+               Control :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     New_Occurrence_Of (Static_Tag, Loc),\n+                   Attribute_Name => Name_Tag);\n+\n+            else\n+               Control :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                      New_Occurrence_Of (Indeterm_Ctrl_Type, Loc),\n+                   Attribute_Name => Name_Tag);\n+            end if;\n \n             Analyze (Control);\n "}]}