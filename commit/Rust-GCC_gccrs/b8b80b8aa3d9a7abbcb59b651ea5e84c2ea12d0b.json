{"sha": "b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhiODBiOGFhM2Q5YTdhYmJjYjU5YjY1MWVhNWU4NGMyZWExMmQwYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-11T10:06:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-06-11T16:12:30Z"}, "message": "tree-optimization/101025 - fix store-motion dependence checking\n\nThis plugs a hole in store-motion where it fails to perform dependence\nchecking on conditionally executed but not store-motioned refs.\n\n2021-06-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101025\n\t* tree-ssa-loop-im.c (sm_seq_valid_bb): Make sure to process\n\tall refs that require dependence checking.\n\n\t* gcc.dg/torture/pr101025.c: New testcase.", "tree": {"sha": "14fcaf112b2d51e697765d7441b197030daf0ea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fcaf112b2d51e697765d7441b197030daf0ea7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5ed0148347beea1bd34795de146adddd2454c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ed0148347beea1bd34795de146adddd2454c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ed0148347beea1bd34795de146adddd2454c36"}], "stats": {"total": 61, "additions": 59, "deletions": 2}, "files": [{"sha": "483e0ff799702824223bf786c78ca1f89b61ad26", "filename": "gcc/testsuite/gcc.dg/torture/pr101025.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101025.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101025.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr101025.c?ref=b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+int a[10];\n+int b, d, g;\n+volatile char c;\n+short e;\n+volatile int f;\n+int main()\n+{\n+  for (; d <= 9; d++) {\n+      b = e = 0;\n+      for (; e < 4; e++)\n+        a[e] = 4;\n+      for (; b <= 3; b++)\n+        if (g)\n+          f = 0;\n+        else\n+          a[b] = c;\n+  }\n+  if (a[1] != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "1c865b28fd65c1b739401a40dbcfac8a0def9635", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=b8b80b8aa3d9a7abbcb59b651ea5e84c2ea12d0b", "patch": "@@ -2169,6 +2169,7 @@ execute_sm (class loop *loop, im_mem_ref *ref,\n enum sm_kind { sm_ord, sm_unord, sm_other };\n struct seq_entry\n {\n+  seq_entry () {}\n   seq_entry (unsigned f, sm_kind k, tree fr = NULL)\n     : first (f), second (k), from (fr) {}\n   unsigned first;\n@@ -2352,6 +2353,8 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t      unsigned min_len = MIN(first_edge_seq.length (),\n \t\t\t\t     edge_seq.length ());\n \t      /* Incrementally merge seqs into first_edge_seq.  */\n+\t      int first_uneq = -1;\n+\t      auto_vec<seq_entry, 2> extra_refs;\n \t      for (unsigned int i = 0; i < min_len; ++i)\n \t\t{\n \t\t  /* ???  We can more intelligently merge when we face different\n@@ -2367,6 +2370,11 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t\t\tbitmap_set_bit (refs_not_supported, edge_seq[i].first);\n \t\t      first_edge_seq[i].second = sm_other;\n \t\t      first_edge_seq[i].from = NULL_TREE;\n+\t\t      /* Record the dropped refs for later processing.  */\n+\t\t      if (first_uneq == -1)\n+\t\t\tfirst_uneq = i;\n+\t\t      extra_refs.safe_push (seq_entry (edge_seq[i].first,\n+\t\t\t\t\t\t       sm_other, NULL_TREE));\n \t\t    }\n \t\t  /* sm_other prevails.  */\n \t\t  else if (first_edge_seq[i].second != edge_seq[i].second)\n@@ -2399,10 +2407,36 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t\t}\n \t      else if (edge_seq.length () > first_edge_seq.length ())\n \t\t{\n+\t\t  if (first_uneq == -1)\n+\t\t    first_uneq = first_edge_seq.length ();\n \t\t  for (unsigned i = first_edge_seq.length ();\n \t\t       i < edge_seq.length (); ++i)\n-\t\t    if (edge_seq[i].second == sm_ord)\n-\t\t      bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t    {\n+\t\t      if (edge_seq[i].second == sm_ord)\n+\t\t\tbitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t      extra_refs.safe_push (seq_entry (edge_seq[i].first,\n+\t\t\t\t\t\t       sm_other, NULL_TREE));\n+\t\t    }\n+\t\t}\n+\t      /* Put unmerged refs at first_uneq to force dependence checking\n+\t\t on them.  */\n+\t      if (first_uneq != -1)\n+\t\t{\n+\t\t  /* Missing ordered_splice_at.  */\n+\t\t  if ((unsigned)first_uneq == first_edge_seq.length ())\n+\t\t    first_edge_seq.safe_splice (extra_refs);\n+\t\t  else\n+\t\t    {\n+\t\t      unsigned fes_length = first_edge_seq.length ();\n+\t\t      first_edge_seq.safe_grow (fes_length\n+\t\t\t\t\t\t+ extra_refs.length ());\n+\t\t      memmove (&first_edge_seq[first_uneq + extra_refs.length ()],\n+\t\t\t       &first_edge_seq[first_uneq],\n+\t\t\t       (fes_length - first_uneq) * sizeof (seq_entry));\n+\t\t      memcpy (&first_edge_seq[first_uneq],\n+\t\t\t      extra_refs.address (),\n+\t\t\t      extra_refs.length () * sizeof (seq_entry));\n+\t\t    }\n \t\t}\n \t    }\n \t  /* Use the sequence from the first edge and push SMs down.  */"}]}