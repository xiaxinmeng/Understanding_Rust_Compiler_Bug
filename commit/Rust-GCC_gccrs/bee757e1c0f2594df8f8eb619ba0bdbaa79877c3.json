{"sha": "bee757e1c0f2594df8f8eb619ba0bdbaa79877c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVlNzU3ZTFjMGYyNTk0ZGY4ZjhlYjYxOWJhMGJkYmFhNzk4NzdjMw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:26:02Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-08-25T20:26:02Z"}, "message": "(struct attr_desc): Add unsigned_p field.\n\n\t(struct function_unit_op): Add issue_delay, conflict_exp, and\n\tissue_exp fields.  Drop busyexp field.\n\t(struct function_unit): Add needs_blockage_function,\n\tneeds_range_function, issue_delay, and max_blockage fields.  Drop\n\tcostexp, and busy delay fields.\n\t(enum operator): Add POS_MINUS_OP, EQ_OP, MIN_OP, RANGE_OP.\n\t(operate_exp): Implement new ops.\n\t(make_internal_attr): Set unsigned_p based on the value of SPECIAL.\n\t(write_attr_get): Function is unsigned when unsigned_p is true.\n\t(write_attr_valueq): Write hex value of large constants in a comment.\n\t(simplify_by_exploding): Check for EXP having no EQ_ATTR expressions\n\tand for all values as the default.\n\t(find_and_mark_used_attributes): Add TERMS and NTERMS parameters.\n\t(max_attr_value): Allow IF_THEN_ELSE.\n\t(simplify_knowing, write_complex_function, extend_range): New\n\tfunctions.\n\t(gen_unit): Use local variables to name the fields.  Change the\n\tmeaning of busy-delay to issue-delay.\n\t(expand_units): Compute issue_exp.  Write attributes for computing\n\t`<name>_unit_blockage' and `<name>_unit_blockage_range' functions.\n\tCompute max_blockage, and the needs_*_function values.\n\t(write_function_unit_info): Write blockage function and conflict cost\n\tfunctions using write_complex_function.  Write new function_unit_desc\n\tfields.\n(expand_units): Use the normalized values of the\n\tunit's CONDEXP and BUSYEXP.\n\nFrom-SVN: r1952", "tree": {"sha": "5f08bde490d8e8d86768df5a791b6a38177b123f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f08bde490d8e8d86768df5a791b6a38177b123f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3/comments", "author": null, "committer": null, "parents": [{"sha": "de19227a2540747aef16ca542681e1416ef00fb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de19227a2540747aef16ca542681e1416ef00fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de19227a2540747aef16ca542681e1416ef00fb0"}], "stats": {"total": 546, "additions": 400, "deletions": 146}, "files": [{"sha": "2eb9230450a24f66184c3252b8997cf01ba40f5a", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 400, "deletions": 146, "changes": 546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee757e1c0f2594df8f8eb619ba0bdbaa79877c3/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=bee757e1c0f2594df8f8eb619ba0bdbaa79877c3", "patch": "@@ -167,6 +167,7 @@ struct attr_desc\n   struct attr_desc *next;\t/* Next attribute. */\n   int is_numeric;\t\t/* Values of this attribute are numeric. */\n   int negative_ok;\t\t/* Allow negative numeric values.  */\n+  int unsigned_p;\t\t/* Make the output function unsigned int.  */\n   int is_const;\t\t\t/* Attribute value constant for each run.  */\n   int is_special;\t\t/* Don't call `write_attr_set'. */\n   struct attr_value *first_value; /* First value of this attribute. */\n@@ -175,6 +176,14 @@ struct attr_desc\n \n #define NULL_ATTR (struct attr_desc *) NULL\n \n+/* A range of values.  */\n+\n+struct range\n+{\n+  int min;\n+  int max;\n+};\n+\n /* Structure for each DEFINE_DELAY.  */\n \n struct delay_desc\n@@ -192,7 +201,9 @@ struct function_unit_op\n   struct function_unit_op *next; /* Next operation for this function unit.  */\n   int num;\t\t\t/* Ordinal for this operation type in unit.  */\n   int ready;\t\t\t/* Cost until data is ready.  */\n-  rtx busyexp;\t\t\t/* Expression computing conflict cost.  */\n+  int issue_delay;\t\t/* Cost until unit can accept another insn.  */\n+  rtx conflict_exp;\t\t/* Expression TRUE for insns incurring issue delay.  */\n+  rtx issue_exp;\t\t/* Expression computing issue delay.  */\n };\n \n /* Record information about each function unit mentioned in a\n@@ -207,14 +218,14 @@ struct function_unit\n   int simultaneity;\t\t/* Maximum number of simultaneous insns\n \t\t\t\t   on this function unit or 0 if unlimited.  */\n   rtx condexp;\t\t\t/* Expression TRUE for insn needing unit. */\n-  rtx costexp;\t\t\t/* Worst-case cost as function of insn. */\n   int num_opclasses;\t\t/* Number of different operation types.  */\n   struct function_unit_op *ops;\t/* Pointer to first operation type.  */\n   int needs_conflict_function;\t/* Nonzero if a conflict function required.  */\n+  int needs_blockage_function;\t/* Nonzero if a blockage function required.  */\n+  int needs_range_function;\t/* Nonzero if a blockage range function required.  */\n   rtx default_cost;\t\t/* Conflict cost, if constant.  */\n-  rtx max_busy_cost;\t\t/* Maximum conflict cost.  */\n-  int min_busy_delay;\t\t/* Minimum conflict cost.  */\n-  int max_busy_delay;\t\t/* Maximum conflict cost.  */\n+  struct range issue_delay;\t/* Range of issue delay values.  */\n+  int max_blockage;\t\t/* Maximum time an insn blocks the unit.  */\n };\n \n /* Listheads of above structures.  */\n@@ -240,7 +251,7 @@ static int num_units;\n \n /* Used as operand to `operate_exp':  */\n \n-enum operator {PLUS_OP, MINUS_OP, OR_OP, MAX_OP};\n+enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, MAX_OP, MIN_OP, RANGE_OP};\n \n /* Stores, for each insn code, the number of constraint alternatives.  */\n \n@@ -301,6 +312,7 @@ static rtx copy_boolean ();\n static void expand_delays ();\n static rtx operate_exp ();\n static void expand_units ();\n+static rtx simplify_knowing ();\n static rtx encode_units_mask ();\n static void fill_attr ();\n static rtx substitute_address ();\n@@ -349,13 +361,15 @@ static void write_upcase ();\n static void write_indent ();\n static void write_eligible_delay ();\n static void write_function_unit_info ();\n+static void write_complex_function ();\n static int n_comma_elts ();\n static char *next_comma_elt ();\n static struct attr_desc *find_attr ();\n static void make_internal_attr ();\n static struct attr_value *find_most_used ();\n static rtx find_single_value ();\n static rtx make_numeric_value ();\n+static void extend_range ();\n char *xrealloc ();\n char *xmalloc ();\n static void fatal ();\n@@ -1504,17 +1518,39 @@ operate_exp (op, left, right)\n \t      i = left_value - right_value;\n \t      break;\n \n+\t    case POS_MINUS_OP:  /* The positive part of LEFT - RIGHT.  */\n+\t      if (left_value > right_value)\n+\t\ti = left_value - right_value;\n+\t      else\n+\t\ti = 0;\n+\t      break;\n+\n \t    case OR_OP:\n \t      i = left_value | right_value;\n \t      break;\n \n+\t    case EQ_OP:\n+\t      i = left_value == right_value;\n+\t      break;\n+\n+\t    case RANGE_OP:\n+\t      i = (left_value << (HOST_BITS_PER_INT / 2)) | right_value;\n+\t      break;\n+\n \t    case MAX_OP:\n \t      if (left_value > right_value)\n \t\ti = left_value;\n \t      else\n \t\ti = right_value;\n \t      break;\n \n+\t    case MIN_OP:\n+\t      if (left_value < right_value)\n+\t\ti = left_value;\n+\t      else\n+\t\ti = right_value;\n+\t      break;\n+\n \t    default:\n \t      abort ();\n \t    }\n@@ -1646,7 +1682,15 @@ operate_exp (op, left, right)\n    and a `<name>_unit_conflict_cost' function is given an insn already\n    executing on the unit and a candidate to execute and will give the\n    cost from the time the executing insn started until the candidate\n-   can start (ignore limitations on the number of simultaneous insns).  */\n+   can start (ignore limitations on the number of simultaneous insns).\n+\n+   For each unit, a `<name>_unit_blockage' function is given an insn\n+   already executing on the unit and a candidate to execute and will\n+   give the delay incurred due to function unit conflicts.  The range of\n+   blockage cost values for a given executing insn is given by the\n+   `<name>_unit_blockage_range' function.  These values are encoded in\n+   an int where the upper half gives the minimum value and the lower\n+   half gives the maximum value.  */\n \n static void\n expand_units ()\n@@ -1659,19 +1703,47 @@ expand_units ()\n   char *str;\n   int i, j, u, num, nvalues;\n \n-  /* Validate the expressions we were given for the conditions and busy cost.\n-     Then make attributes for use in the conflict function.  */\n+  /* Rebuild the condition for the unit to share the RTL expressions.\n+     Sharing is required by simplify_by_exploding.  Build the issue delay\n+     expressions.  Validate the expressions we were given for the conditions\n+     and conflict vector.  Then make attributes for use in the conflict\n+     function.  */\n+\n   for (unit = units; unit; unit = unit->next)\n-    for (op = unit->ops; op; op = op->next)\n-      {\n-\top->condexp = check_attr_test (op->condexp, 0);\n-\top->busyexp = check_attr_value (make_canonical (NULL_ATTR,\n-\t\t\t\t\t\t\top->busyexp),\n+    {\n+      rtx min_issue = make_numeric_value (unit->issue_delay.min);\n+\n+      unit->condexp = check_attr_test (unit->condexp, 0);\n+\n+      for (op = unit->ops; op; op = op->next)\n+\t{\n+\t  rtx issue_delay = make_numeric_value (op->issue_delay);\n+\t  rtx issue_exp = issue_delay;\n+\n+\t  /* Build, validate, and simplify the issue delay expression.  */\n+\t  if (op->conflict_exp != true_rtx)\n+\t    issue_exp = attr_rtx (IF_THEN_ELSE, op->conflict_exp,\n+\t\t\t\t  issue_exp, make_numeric_value (0));\n+\t  issue_exp = check_attr_value (make_canonical (NULL_ATTR,\n+\t\t\t\t\t\t\tissue_exp),\n \t\t\t\t\tNULL_ATTR);\n-\tstr = attr_printf (strlen (unit->name) + 11, \"*%s_case_%d\",\n-\t\t\t   unit->name, op->num);\n-\tmake_internal_attr (str, op->busyexp, 1);\n-      }\n+\t  issue_exp = simplify_knowing (issue_exp, unit->condexp);\n+\t  op->issue_exp = issue_exp;\n+\n+\t  /* Make an attribute for use in the conflict function if needed.  */\n+\t  unit->needs_conflict_function = (unit->issue_delay.min\n+\t\t\t\t\t   != unit->issue_delay.max);\n+\t  if (unit->needs_conflict_function)\n+\t    {\n+\t      str = attr_printf (strlen (unit->name) + 11, \"*%s_cost_%d\",\n+\t\t\t\t unit->name, op->num);\n+\t      make_internal_attr (str, issue_exp, 1);\n+\t    }\n+\n+\t  /* Validate the condition.  */\n+\t  op->condexp = check_attr_test (op->condexp, 0);\n+\t}\n+    }\n \n   /* Compute the mask of function units used.  Initially, the unitsmask is\n      zero.   Set up a conditional to compute each unit's contribution.  */\n@@ -1682,7 +1754,7 @@ expand_units ()\n   /* Merge each function unit into the unit mask attributes.  */\n   for (unit = units; unit; unit = unit->next)\n     {\n-      XEXP (newexp, 0) = check_attr_test (unit->condexp, 0);\n+      XEXP (newexp, 0) = unit->condexp;\n       XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n       unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n     }\n@@ -1788,13 +1860,128 @@ expand_units ()\n \t  XVECEXP (readycost, 0, nvalues * 2 + 1) = make_numeric_value (value);\n \t}\n \n-      /* Make an attribute for the ready_cost function.  Simplifying\n-\t further with simplify_by_exploding doesn't win.  */\n       if (u < num_units)\n-\tstr = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n-\t\t\t   unit->name);\n+\t{\n+\t  rtx max_blockage = 0, min_blockage = 0;\n+\n+\t  /* Simplify the readycost expression by only considering insns\n+\t     that use the unit.  */\n+\t  readycost = simplify_knowing (readycost, unit->condexp);\n+\n+\t  /* Determine the blockage cost the executing insn (E) given\n+\t     the candidate insn (C).  This is the maximum of the issue\n+\t     delay, the pipeline delay, and the simultaneity constraint.\n+\t     Each function_unit_op represents the characteristics of the\n+\t     candidate insn, so in the expressions below, C is a known\n+\t     term and E is an unknown term.\n+\n+\t     The issue delay function for C is op->issue_exp and is used to\n+\t     write the `<name>_unit_conflict_cost' function.  Symbolicly\n+\t     this is \"ISSUE-DELAY (E,C)\".\n+\n+\t     The pipeline delay results form the FIFO constraint on the\n+\t     function unit and is \"READY-COST (E) + 1 - READY-COST (C)\".\n+\n+\t     The simultaneity constraint is based on how long it takes to\n+\t     fill the unit given the minimum issue delay.  FILL-TIME is the\n+\t     constant \"MIN (ISSUE-DELAY (*,*)) * (SIMULTANEITY - 1)\", and\n+\t     the simultaneity constraint is \"READY-COST (E) - FILL-TIME\"\n+\t     if SIMULTANEITY is non-zero and zero otherwise.\n+\n+\t     Thus, BLOCKAGE (E,C) when SIMULTANEITY is zero is\n+\n+\t         MAX (ISSUE-DELAY (E,C),\n+\t\t      READY-COST (E) - (READY-COST (C) - 1))\n+\n+\t     and otherwise\n+\n+\t         MAX (ISSUE-DELAY (E,C),\n+\t\t      READY-COST (E) - (READY-COST (C) - 1),\n+\t\t      READY-COST (E) - FILL-TIME)\n+\n+\t     The `<name>_unit_blockage' function is computed by determining\n+\t     this value for each candidate insn.  As these values are\n+\t     computed, we also compute the upper and lower bounds for\n+\t     BLOCKAGE (E,*).  These are combined to form the function\n+\t     `<name>_unit_blockage_range'.  Finally, the maximum blockage\n+\t     cost, MAX (BLOCKAGE (*,*)), is computed.  */\n+\n+\t  for (op = unit->ops; op; op = op->next)\n+\t    {\n+\t      rtx blockage = readycost;\n+\t      int delay = op->ready - 1;\n+\n+\t      if (unit->simultaneity != 0)\n+\t\tdelay = MIN (delay, ((unit->simultaneity - 1)\n+\t\t\t\t     * unit->issue_delay.min));\n+\n+\t      if (delay > 0)\n+\t\tblockage = operate_exp (POS_MINUS_OP, blockage,\n+\t\t\t\t\tmake_numeric_value (delay));\n+\n+\t      blockage = operate_exp (MAX_OP, blockage, op->issue_exp);\n+\t      blockage = simplify_knowing (blockage, unit->condexp);\n+\n+\t      /* Add this op's contribution to MAX (BLOCKAGE (E,*)) and\n+\t\t MIN (BLOCKAGE (E,*)).  */\n+\t      if (max_blockage == 0)\n+\t\tmax_blockage = min_blockage = blockage;\n+\t      else\n+\t\t{\n+\t\t  max_blockage\n+\t\t    = simplify_knowing (operate_exp (MAX_OP, max_blockage,\n+\t\t\t\t\t\t     blockage),\n+\t\t\t\t\tunit->condexp);\n+\t\t  min_blockage\n+\t\t    = simplify_knowing (operate_exp (MIN_OP, min_blockage,\n+\t\t\t\t\t\t     blockage),\n+\t\t\t\t\tunit->condexp);\n+\t\t}\n+\n+\t      /* Make an attribute for use in the blockage function.  */\n+\t      str = attr_printf (strlen (unit->name) + 12, \"*%s_block_%d\",\n+\t\t\t\t unit->name, op->num);\n+\t      make_internal_attr (str, blockage, 1);\n+\t    }\n+\n+\t  /* Record MAX (BLOCKAGE (*,*)).  */\n+\t  unit->max_blockage = max_attr_value (max_blockage);\n+\n+\t  /* See if the upper and lower bounds of BLOCKAGE (E,*) are the\n+\t     same.  If so, the blockage function carries no additional\n+\t     information and is not written.  */\n+\t  newexp = operate_exp (EQ_OP, max_blockage, min_blockage);\n+\t  newexp = simplify_knowing (newexp, unit->condexp);\n+\t  unit->needs_blockage_function\n+\t    = (GET_CODE (newexp) != CONST_STRING\n+\t       || atoi (XSTR (newexp, 0)) != 1);\n+\n+\t  /* If the all values of BLOCKAGE (E,C) have the same value,\n+\t     neither blockage function is written.  */\t  \n+\t  unit->needs_range_function\n+\t    = (unit->needs_blockage_function\n+\t       || GET_CODE (max_blockage) != CONST_STRING);\n+\n+\t  if (unit->needs_range_function)\n+\t    {\n+\t      /* Compute the blockage range function and make an attribute\n+\t\t for writing it's value.  */\n+\t      newexp = operate_exp (RANGE_OP, min_blockage, max_blockage);\n+\t      newexp = simplify_knowing (newexp, unit->condexp);\n+\n+\t      str = attr_printf (strlen (unit->name) + 20,\n+\t\t\t\t \"*%s_unit_blockage_range\", unit->name);\n+\t      make_internal_attr (str, newexp, 4);\n+\t    }\n+\n+\t  str = attr_printf (strlen (unit->name) + 20, \"*%s_unit_ready_cost\",\n+\t\t\t     unit->name);\n+\t}\n       else\n \tstr = \"*result_ready_cost\";\n+\n+      /* Make an attribute for the ready_cost function.  Simplifying\n+\t further with simplify_by_exploding doesn't win.  */\n       make_internal_attr (str, readycost, 0);\n     }\n \n@@ -1804,7 +1991,8 @@ expand_units ()\n     {\n       rtx caseexp;\n \n-      if (unit->min_busy_delay == unit->max_busy_delay)\n+      if (! unit->needs_conflict_function\n+\t  && ! unit->needs_blockage_function)\n \tcontinue;\n \n       caseexp = rtx_alloc (COND);\n@@ -1833,6 +2021,21 @@ expand_units ()\n     }\n }\n \n+/* Simplify EXP given KNOWN_TRUE.  */\n+\n+static rtx\n+simplify_knowing (exp, known_true)\n+     rtx exp, known_true;\n+{\n+  if (GET_CODE (exp) != CONST_STRING)\n+    {\n+      exp = attr_rtx (IF_THEN_ELSE, known_true, exp,\n+\t\t      make_numeric_value (max_attr_value (exp)));\n+      exp = simplify_by_exploding (exp);\n+    }\n+  return exp;\n+}\n+\n /* Translate the CONST_STRING expressions in X to change the encoding of\n    value.  On input, the value is a bitmask with a one bit for each unit\n    used; on output, the value is the unit number (zero based) if one\n@@ -3170,11 +3373,11 @@ simplify_by_exploding (exp)\n   rtx list = 0, link, condexp, defval;\n   struct dimension *space;\n   rtx *condtest, *condval;\n-  int i, j, total, ndim;\n+  int i, j, total, ndim = 0;\n   int most_tests, num_marks, new_marks;\n \n   /* Locate all the EQ_ATTR expressions.  */\n-  if (! find_and_mark_used_attributes (exp, &list))\n+  if (! find_and_mark_used_attributes (exp, &list, &ndim) || ndim == 0)\n     {\n       unmark_used_attributes (list, 0, 0);\n       return exp;\n@@ -3186,9 +3389,6 @@ simplify_by_exploding (exp)\n      cover the domain of the attribute.  This makes the expanded COND form\n      order independent.  */\n \n-  ndim = 0;\n-  for (link = list; link; link = XEXP (link, 1))\n-    ndim++;\n   space = (struct dimension *) alloca (ndim * sizeof (struct dimension));\n \n   total = 1;\n@@ -3289,6 +3489,10 @@ simplify_by_exploding (exp)\n   if (num_marks == 0)\n     return exp;\n \n+  /* If all values are the default, use that.  */\n+  if (total == most_tests)\n+    return defval;\n+\n   /* Make a COND with the most common constant value the default.  (A more\n      complex method where tests with the same value were combined didn't\n      seem to improve things.)  */\n@@ -3311,8 +3515,9 @@ simplify_by_exploding (exp)\n    tests have known value.  */\n \n static int\n-find_and_mark_used_attributes (exp, terms)\n+find_and_mark_used_attributes (exp, terms, nterms)\n      rtx exp, *terms;\n+     int *nterms;\n {\n   int i;\n \n@@ -3325,28 +3530,29 @@ find_and_mark_used_attributes (exp, terms)\n \t  XEXP (link, 0) = exp;\n \t  XEXP (link, 1) = *terms;\n \t  *terms = link;\n+\t  *nterms += 1;\n \t  MEM_VOLATILE_P (exp) = 1;\n \t}\n     case CONST_STRING:\n       return 1;\n \n     case IF_THEN_ELSE:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 2), terms))\n+      if (! find_and_mark_used_attributes (XEXP (exp, 2), terms, nterms))\n \treturn 0;\n     case IOR:\n     case AND:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms))\n+      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms, nterms))\n \treturn 0;\n     case NOT:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 0), terms))\n+      if (! find_and_mark_used_attributes (XEXP (exp, 0), terms, nterms))\n \treturn 0;\n       return 1;\n \n     case COND:\n       for (i = 0; i < XVECLEN (exp, 0); i++)\n-\tif (! find_and_mark_used_attributes (XVECEXP (exp, 0, i), terms))\n+\tif (! find_and_mark_used_attributes (XVECEXP (exp, 0, i), terms, nterms))\n \t  return 0;\n-      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms))\n+      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms, nterms))\n \treturn 0;\n       return 1;\n     }\n@@ -3935,15 +4141,21 @@ gen_unit (def)\n {\n   struct function_unit *unit;\n   struct function_unit_op *op;\n+  char *name = XSTR (def, 0);\n+  int multiplicity = XINT (def, 1);\n+  int simultaneity = XINT (def, 2);\n+  rtx condexp = XEXP (def, 3);\n+  int ready_cost = MAX (XINT (def, 4), 1);\n+  int issue_delay = MAX (XINT (def, 5), 1);\n \n   /* See if we have already seen this function unit.  If so, check that\n      the multiplicity and simultaneity values are the same.  If not, make\n      a structure for this function unit.  */\n   for (unit = units; unit; unit = unit->next)\n-    if (! strcmp (unit->name, XSTR (def, 0)))\n+    if (! strcmp (unit->name, name))\n       {\n-\tif (unit->multiplicity != XINT (def, 1)\n-\t    || unit->simultaneity != XINT (def, 2))\n+\tif (unit->multiplicity != multiplicity\n+\t    || unit->simultaneity != simultaneity)\n \t  fatal (\"Differing specifications given for `%s' function unit.\",\n \t\t unit->name);\n \tbreak;\n@@ -3952,27 +4164,28 @@ gen_unit (def)\n   if (unit == 0)\n     {\n       unit = (struct function_unit *) xmalloc (sizeof (struct function_unit));\n-      unit->name = XSTR (def, 0);\n-      unit->multiplicity = XINT (def, 1);\n-      unit->simultaneity = XINT (def, 2);\n+      unit->name = name;\n+      unit->multiplicity = multiplicity;\n+      unit->simultaneity = simultaneity;\n+      unit->issue_delay.min = unit->issue_delay.max = issue_delay;\n       unit->num = num_units++;\n       unit->num_opclasses = 0;\n       unit->condexp = false_rtx;\n       unit->ops = 0;\n       unit->next = units;\n-      unit->min_busy_delay = unit->max_busy_delay = XINT (def, 5);\n       units = unit;\n     }\n \n   /* Make a new operation class structure entry and initialize it.  */\n   op = (struct function_unit_op *) xmalloc (sizeof (struct function_unit_op));\n-  op->condexp = XEXP (def, 3);\n+  op->condexp = condexp;\n   op->num = unit->num_opclasses++;\n-  op->ready = XINT (def, 4);\n+  op->ready = ready_cost;\n+  op->issue_delay = issue_delay;\n   op->next = unit->ops;\n   unit->ops = op;\n \n-  /* Set our busy expression based on whether or not an optional conflict\n+  /* Set our issue expression based on whether or not an optional conflict\n      vector was specified.  */\n   if (XVEC (def, 6))\n     {\n@@ -3983,17 +4196,13 @@ gen_unit (def)\n       for (i = 0; i < XVECLEN (def, 6); i++)\n \torexp = insert_right_side (IOR, orexp, XVECEXP (def, 6, i), -2);\n \n-      op->busyexp = attr_rtx (IF_THEN_ELSE, orexp,\n-\t\t\t      make_numeric_value (XINT (def, 5)),\n-\t\t\t      make_numeric_value (0));\n-      unit->min_busy_delay = MIN (unit->min_busy_delay, 0);\n-      unit->max_busy_delay = MAX (unit->max_busy_delay, XINT (def, 5));\n+      op->conflict_exp = orexp;\n+      extend_range (&unit->issue_delay, 1, issue_delay);\n     }\n   else\n     {\n-      op->busyexp = make_numeric_value (XINT (def, 5));\n-      unit->min_busy_delay = MIN (unit->min_busy_delay, XINT (def, 5));\n-      unit->max_busy_delay = MAX (unit->max_busy_delay, XINT (def, 5));\n+      op->conflict_exp = true_rtx;\n+      extend_range (&unit->issue_delay, issue_delay, issue_delay);\n     }\n \n   /* Merge our conditional into that of the function unit so we can determine\n@@ -4249,6 +4458,14 @@ max_attr_value (exp)\n \tcurrent_max = n;\n     }\n \n+  else if (GET_CODE (exp) == IF_THEN_ELSE)\n+    {\n+      current_max = max_attr_value (XEXP (exp, 1));\n+      n = max_attr_value (XEXP (exp, 2));\n+      if (n > current_max)\n+\tcurrent_max = n;\n+    }\n+\n   else\n     abort ();\n \n@@ -4331,10 +4548,12 @@ write_attr_get (attr)\n \n   /* Write out start of function, then all values with explicit `case' lines,\n      then a `default', then the value with the most uses.  */\n-  if (attr->is_numeric)\n-    printf (\"int\\n\");\n-  else\n+  if (!attr->is_numeric)\n     printf (\"enum attr_%s\\n\", attr->name);\n+  else if (attr->unsigned_p)\n+    printf (\"unsigned int\\n\");\n+  else\n+    printf (\"int\\n\");\n \n   /* If the attribute name starts with a star, the remainder is the name of\n      the subroutine to use, instead of `get_attr_...'.  */\n@@ -4583,7 +4802,12 @@ write_attr_valueq (attr, s)\n      char *s;\n {\n   if (attr->is_numeric)\n-    printf (\"%s\", s);\n+    {\n+      printf (\"%s\", s);\n+      /* Make the blockage range values easier to read.  */\n+      if (strlen (s) > 1)\n+\tprintf (\" /* 0x%x */\", atoi (s));\n+    }\n   else\n     {\n       write_upcase (attr->name);\n@@ -4758,107 +4982,27 @@ static void\n write_function_unit_info ()\n {\n   struct function_unit *unit;\n-  struct attr_desc *case_attr, *attr;\n-  struct attr_value *av, *common_av;\n-  rtx value;\n-  char *str;\n-  int using_case;\n   int i;\n \n   /* Write out conflict routines for function units.  Don't bother writing\n-     one if there is only one busy value.  */\n+     one if there is only one issue delay value.  */\n \n   for (unit = units; unit; unit = unit->next)\n     {\n-      /* Record the maximum busy cost.  */\n-      unit->max_busy_cost = make_numeric_value (unit->max_busy_delay);\n+      if (unit->needs_blockage_function)\n+\twrite_complex_function (unit, \"blockage\", \"block\");\n \n       /* If the minimum and maximum conflict costs are the same, there\n \t is only one value, so we don't need a function.  */\n-      if (unit->min_busy_delay == unit->max_busy_delay)\n+      if (! unit->needs_conflict_function)\n \t{\n-\t  unit->needs_conflict_function = 0;\n-\t  unit->default_cost = unit->max_busy_cost;\n+\t  unit->default_cost = make_numeric_value (unit->issue_delay.max);\n \t  continue;\n \t}\n \n       /* The function first computes the case from the candidate insn.  */\n-      unit->needs_conflict_function = 1;\n       unit->default_cost = make_numeric_value (0);\n-\n-      printf (\"static int\\n\");\n-      printf (\"%s_unit_conflict_cost (executing_insn, candidate_insn)\\n\",\n-\t      unit->name);\n-      printf (\"     rtx executing_insn;\\n\");\n-      printf (\"     rtx candidate_insn;\\n\");\n-      printf (\"{\\n\");\n-      printf (\"  rtx insn;\\n\");\n-      printf (\"  int casenum;\\n\\n\");\n-      printf (\"  insn = candidate_insn;\\n\");\n-      printf (\"  switch (recog_memoized (insn))\\n\");\n-      printf (\"    {\\n\");\n-\n-      /* Write the `switch' statement to get the case value.  */\n-      str = (char *) alloca (strlen (unit->name) + 10);\n-      sprintf (str, \"*%s_cases\", unit->name);\n-      case_attr = find_attr (str, 0);\n-      if (! case_attr) abort ();\n-      common_av = find_most_used (case_attr);\n-\n-      for (av = case_attr->first_value; av; av = av->next)\n-\tif (av != common_av)\n-\t  write_attr_case (case_attr, av, 1,\n-\t\t\t   \"casenum =\", \";\", 4, unit->condexp);\n-\n-      write_attr_case (case_attr, common_av, 0,\n-\t\t       \"casenum =\", \";\", 4, unit->condexp);\n-      printf (\"    }\\n\\n\");\n-\n-      /* Now write an outer switch statement on each case.  Then write\n-\t the tests on the executing function within each.  */\n-      printf (\"  insn = executing_insn;\\n\");\n-      printf (\"  switch (casenum)\\n\");\n-      printf (\"    {\\n\");\n-\n-      for (i = 0; i < unit->num_opclasses; i++)\n-\t{\n-\t  /* Ensure using this case.  */\n-\t  using_case = 0;\n-\t  for (av = case_attr->first_value; av; av = av->next)\n-\t    if (av->num_insns\n-\t\t&& contained_in_p (make_numeric_value (i), av->value))\n-\t      using_case = 1;\n-\n-\t  if (! using_case)\n-\t    continue;\n-\n-\t  printf (\"    case %d:\\n\", i);\n-\t  sprintf (str, \"*%s_case_%d\", unit->name, i);\n-\t  attr = find_attr (str, 0);\n-\t  if (! attr) abort ();\n-\n-\t  /* If single value, just write it.  */\n-\t  value = find_single_value (attr);\n-\t  if (value)\n-\t    write_attr_set (attr, 6, value, \"return\", \";\\n\", true_rtx, -2);\n-\t  else\n-\t    {\n-\t      common_av = find_most_used (attr);\n-\t      printf (\"      switch (recog_memoized (insn))\\n\");\n-\t      printf (\"\\t{\\n\");\n-\n-\t      for (av = attr->first_value; av; av = av->next)\n-\t\tif (av != common_av)\n-\t\t  write_attr_case (attr, av, 1,\n-\t\t\t\t   \"return\", \";\", 8, unit->condexp);\n-\n-\t      write_attr_case (attr, common_av, 0,\n-\t\t\t       \"return\", \";\", 8, unit->condexp);\n-\t      printf (\"      }\\n\\n\");\n-\t    }\n-\t}\n-\n-      printf (\"    }\\n}\\n\\n\");\n+      write_complex_function (unit, \"conflict_cost\", \"cost\");\n     }\n \n   /* Now that all functions have been written, write the table describing\n@@ -4875,13 +5019,25 @@ write_function_unit_info ()\n \tif (unit->num == i)\n \t  break;\n \n-      printf (\"  {\\\"%s\\\", %d, %d, %d, %s, %s, %s_unit_ready_cost, \",\n+      printf (\"  {\\\"%s\\\", %d, %d, %d, %s, %d, %s_unit_ready_cost, \",\n \t      unit->name, 1 << unit->num, unit->multiplicity,\n \t      unit->simultaneity, XSTR (unit->default_cost, 0),\n-\t      XSTR (unit->max_busy_cost, 0), unit->name);\n+\t      unit->issue_delay.max, unit->name);\n \n       if (unit->needs_conflict_function)\n-\tprintf (\"%s_unit_conflict_cost\", unit->name);\n+\tprintf (\"%s_unit_conflict_cost, \", unit->name);\n+      else\n+\tprintf (\"0, \");\n+\n+      printf (\"%d, \", unit->max_blockage);\n+\n+      if (unit->needs_range_function)\n+\tprintf (\"%s_unit_blockage_range, \", unit->name);\n+      else\n+\tprintf (\"0, \");\n+\n+      if (unit->needs_blockage_function)\n+\tprintf (\"%s_unit_blockage\", unit->name);\n       else\n \tprintf (\"0\");\n \n@@ -4890,6 +5046,93 @@ write_function_unit_info ()\n \n   printf (\"};\\n\\n\");\n }\n+\n+static void\n+write_complex_function (unit, name, connection)\n+     struct function_unit *unit;\n+     char *name, *connection;\n+{\n+  struct attr_desc *case_attr, *attr;\n+  struct attr_value *av, *common_av;\n+  rtx value;\n+  char *str;\n+  int using_case;\n+  int i;\n+\n+  printf (\"static int\\n\");\n+  printf (\"%s_unit_%s (executing_insn, candidate_insn)\\n\",\n+\t  unit->name, name);\n+  printf (\"     rtx executing_insn;\\n\");\n+  printf (\"     rtx candidate_insn;\\n\");\n+  printf (\"{\\n\");\n+  printf (\"  rtx insn;\\n\");\n+  printf (\"  int casenum;\\n\\n\");\n+  printf (\"  insn = candidate_insn;\\n\");\n+  printf (\"  switch (recog_memoized (insn))\\n\");\n+  printf (\"    {\\n\");\n+\n+  /* Write the `switch' statement to get the case value.  */\n+  str = (char *) alloca (strlen (unit->name) + strlen (name) + strlen (connection) + 10);\n+  sprintf (str, \"*%s_cases\", unit->name);\n+  case_attr = find_attr (str, 0);\n+  if (! case_attr) abort ();\n+  common_av = find_most_used (case_attr);\n+\n+  for (av = case_attr->first_value; av; av = av->next)\n+    if (av != common_av)\n+      write_attr_case (case_attr, av, 1,\n+\t\t       \"casenum =\", \";\", 4, unit->condexp);\n+\n+  write_attr_case (case_attr, common_av, 0,\n+\t\t   \"casenum =\", \";\", 4, unit->condexp);\n+  printf (\"    }\\n\\n\");\n+\n+  /* Now write an outer switch statement on each case.  Then write\n+     the tests on the executing function within each.  */\n+  printf (\"  insn = executing_insn;\\n\");\n+  printf (\"  switch (casenum)\\n\");\n+  printf (\"    {\\n\");\n+\n+  for (i = 0; i < unit->num_opclasses; i++)\n+    {\n+      /* Ensure using this case.  */\n+      using_case = 0;\n+      for (av = case_attr->first_value; av; av = av->next)\n+\tif (av->num_insns\n+\t    && contained_in_p (make_numeric_value (i), av->value))\n+\t  using_case = 1;\n+\n+      if (! using_case)\n+\tcontinue;\n+\n+      printf (\"    case %d:\\n\", i);\n+      sprintf (str, \"*%s_%s_%d\", unit->name, connection, i);\n+      attr = find_attr (str, 0);\n+      if (! attr) abort ();\n+\n+      /* If single value, just write it.  */\n+      value = find_single_value (attr);\n+      if (value)\n+\twrite_attr_set (attr, 6, value, \"return\", \";\\n\", true_rtx, -2);\n+      else\n+\t{\n+\t  common_av = find_most_used (attr);\n+\t  printf (\"      switch (recog_memoized (insn))\\n\");\n+\t  printf (\"\\t{\\n\");\n+\n+\t  for (av = attr->first_value; av; av = av->next)\n+\t    if (av != common_av)\n+\t      write_attr_case (attr, av, 1,\n+\t\t\t       \"return\", \";\", 8, unit->condexp);\n+\n+\t  write_attr_case (attr, common_av, 0,\n+\t\t\t   \"return\", \";\", 8, unit->condexp);\n+\t  printf (\"      }\\n\\n\");\n+\t}\n+    }\n+\n+  printf (\"    }\\n}\\n\\n\");\n+}\n \f\n /* This page contains miscellaneous utility routines.  */\n \n@@ -4996,6 +5239,7 @@ make_internal_attr (name, value, special)\n   attr->is_const = 0;\n   attr->is_special = (special & 1) != 0;\n   attr->negative_ok = (special & 2) != 0;\n+  attr->unsigned_p = (special & 4) != 0;\n   attr->default_val = get_attr_value (value, attr, -2);\n }\n \n@@ -5067,6 +5311,16 @@ make_numeric_value (n)\n   return exp;\n }\n \f\n+static void\n+extend_range (range, min, max)\n+     struct range *range;\n+     int min;\n+     int max;\n+{\n+  if (range->min > min) range->min = min;\n+  if (range->max < max) range->max = max;\n+}\n+\n char *\n xrealloc (ptr, size)\n      char *ptr;"}]}