{"sha": "c116b9806466d5f3cfa3d274af443fc538be52e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExNmI5ODA2NDY2ZDVmM2NmYTNkMjc0YWY0NDNmYzUzOGJlNTJlMw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2008-07-31T08:18:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-31T08:18:53Z"}, "message": "prj.adb, [...]: Remove declarations that were for gprmake only\n\n2008-07-31  Vincent Celier  <celier@adacore.com>\n\n\t* prj.adb, clean.adb, prj-nmsc.adb, prj.ads: Remove declarations that\n\twere for gprmake only\n\nFrom-SVN: r138365", "tree": {"sha": "6946a68e495356da0239f5be89603ea28381e776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6946a68e495356da0239f5be89603ea28381e776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c116b9806466d5f3cfa3d274af443fc538be52e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c116b9806466d5f3cfa3d274af443fc538be52e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c116b9806466d5f3cfa3d274af443fc538be52e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c116b9806466d5f3cfa3d274af443fc538be52e3/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3023ce4262d7de329d1082347943a91621b88e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3023ce4262d7de329d1082347943a91621b88e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3023ce4262d7de329d1082347943a91621b88e1d"}], "stats": {"total": 1540, "additions": 33, "deletions": 1507}, "files": [{"sha": "30aa9a45c41682d151b258b5756771017ff97b14", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=c116b9806466d5f3cfa3d274af443fc538be52e3", "patch": "@@ -826,9 +826,6 @@ package body Clean is\n       Index2      : Int;\n       Lib_File    : File_Name_Type;\n \n-      Source_Id   : Other_Source_Id;\n-      Source      : Other_Source;\n-\n       Global_Archive : Boolean := False;\n \n    begin\n@@ -881,7 +878,7 @@ package body Clean is\n                --  Source_Dirs or Source_Files is specified as an empty list,\n                --  so always look for Ada units in extending projects.\n \n-               if Data.Langs (Ada_Language_Index)\n+               if Data.Ada_Sources_Present\n                  or else Data.Extends /= No_Project\n                then\n                   for Unit in Unit_Table.First ..\n@@ -1044,40 +1041,6 @@ package body Clean is\n                   end if;\n                end if;\n \n-               if Data.Other_Sources_Present then\n-\n-                  --  There is non-Ada code: delete the object files and\n-                  --  the dependency files if they exist.\n-\n-                  Source_Id := Data.First_Other_Source;\n-                  while Source_Id /= No_Other_Source loop\n-                     Source :=\n-                       Project_Tree.Other_Sources.Table (Source_Id);\n-\n-                     if Is_Regular_File\n-                       (Get_Name_String (Source.Object_Name))\n-                     then\n-                        Delete (Obj_Dir, Get_Name_String (Source.Object_Name));\n-                     end if;\n-\n-                     if\n-                       Is_Regular_File (Get_Name_String (Source.Dep_Name))\n-                     then\n-                        Delete (Obj_Dir, Get_Name_String (Source.Dep_Name));\n-                     end if;\n-\n-                     Source_Id := Source.Next;\n-                  end loop;\n-\n-                  --  If it is a library with only non Ada sources, delete\n-                  --  the fake archive and the dependency file, if they exist.\n-\n-                  if Data.Library\n-                    and then not Data.Langs (Ada_Language_Index)\n-                  then\n-                     Clean_Archive (Project, Global => False);\n-                  end if;\n-               end if;\n             end;\n          end if;\n "}, {"sha": "f3b40b3a9e0dec05ef85f218b7d5e80eddecba7e", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 20, "deletions": 892, "changes": 912, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=c116b9806466d5f3cfa3d274af443fc538be52e3", "patch": "@@ -65,9 +65,6 @@ package body Prj.Nmsc is\n    ALI_Suffix   : constant String := \".ali\";\n    --  File suffix for ali files\n \n-   Object_Suffix : constant String := Get_Target_Object_Suffix.all;\n-   --  File suffix for object files\n-\n    type Name_Location is record\n       Name     : File_Name_Type;\n       Location : Source_Ptr;\n@@ -267,20 +264,6 @@ package body Prj.Nmsc is\n       Data    : in out Project_Data);\n    --  Check the configuration attributes for the project\n \n-   procedure Check_For_Source\n-     (File_Name        : File_Name_Type;\n-      Path_Name        : Path_Name_Type;\n-      Project          : Project_Id;\n-      In_Tree          : Project_Tree_Ref;\n-      Data             : in out Project_Data;\n-      Location         : Source_Ptr;\n-      Language         : Language_Index;\n-      Suffix           : String;\n-      Naming_Exception : Boolean);\n-   --  Check if a file, with name File_Name and path Path_Name, in a source\n-   --  directory is a source for language Language in project Project of\n-   --  project tree In_Tree. ???\n-\n    procedure Check_If_Externally_Built\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref;\n@@ -369,15 +352,6 @@ package body Prj.Nmsc is\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n-   procedure Find_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      For_Language : Language_Index;\n-      Current_Dir  : String);\n-   --  Find all the sources in all of the source directories of a project for\n-   --  a specified language.\n-\n    procedure Search_Directories\n      (Project         : Project_Id;\n       In_Tree         : Project_Tree_Ref;\n@@ -467,8 +441,7 @@ package body Prj.Nmsc is\n    --  Source_Names.\n \n    procedure Find_Explicit_Sources\n-     (Lang        : Language_Index;\n-      Current_Dir : String;\n+     (Current_Dir : String;\n       Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Data        : in out Project_Data);\n@@ -566,16 +539,6 @@ package body Prj.Nmsc is\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n-   procedure Record_Other_Sources\n-     (Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Data              : in out Project_Data;\n-      Language          : Language_Index;\n-      Naming_Exceptions : Boolean);\n-   --  Record the sources of a language in a project. When Naming_Exceptions is\n-   --  True, mark the found sources as such, to later remove those that are not\n-   --  named in a list of sources.\n-\n    procedure Remove_Source\n      (Id          : Source_Id;\n       Replaced_By : Source_Id;\n@@ -597,13 +560,6 @@ package body Prj.Nmsc is\n      (Data : Project_Data; In_Tree : Project_Tree_Ref);\n    --  List all the source directories of a project\n \n-   function Suffix_For\n-     (Language : Language_Index;\n-      Naming   : Naming_Data;\n-      In_Tree  : Project_Tree_Ref) return File_Name_Type;\n-   --  Get the suffix for the source of a language from a package naming. If\n-   --  not specified, return the default for the language.\n-\n    procedure Warn_If_Not_Sources\n      (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n@@ -2449,287 +2405,6 @@ package body Prj.Nmsc is\n       end loop;\n    end Check_Configuration;\n \n-   ----------------------\n-   -- Check_For_Source --\n-   ----------------------\n-\n-   procedure Check_For_Source\n-     (File_Name        : File_Name_Type;\n-      Path_Name        : Path_Name_Type;\n-      Project          : Project_Id;\n-      In_Tree          : Project_Tree_Ref;\n-      Data             : in out Project_Data;\n-      Location         : Source_Ptr;\n-      Language         : Language_Index;\n-      Suffix           : String;\n-      Naming_Exception : Boolean)\n-   is\n-      Name          : String := Get_Name_String (File_Name);\n-      Real_Location : Source_Ptr := Location;\n-\n-   begin\n-      Canonical_Case_File_Name (Name);\n-\n-      --  A file is a source of a language if Naming_Exception is True (case\n-      --  of naming exceptions) or if its file name ends with the suffix.\n-\n-      if Naming_Exception\n-        or else\n-          (Name'Length > Suffix'Length\n-            and then\n-              Name (Name'Last - Suffix'Length + 1 .. Name'Last) = Suffix)\n-      then\n-         if Real_Location = No_Location then\n-            Real_Location := Data.Location;\n-         end if;\n-\n-         declare\n-            Path_Id   : Path_Name_Type;\n-            C_Path_Id : Path_Name_Type;\n-            --  The path name id (in canonical case)\n-\n-            File_Id : File_Name_Type;\n-            --  The file name id (in canonical case)\n-\n-            Obj_Id : File_Name_Type;\n-            --  The object file name\n-\n-            Obj_Path_Id : Path_Name_Type;\n-            --  The object path name\n-\n-            Dep_Id : File_Name_Type;\n-            --  The dependency file name\n-\n-            Dep_Path_Id : Path_Name_Type;\n-            --  The dependency path name\n-\n-            Dot_Pos : Natural := 0;\n-            --  Position of the last dot in Name\n-\n-            Source    : Other_Source;\n-            Source_Id : Other_Source_Id := Data.First_Other_Source;\n-\n-         begin\n-            --  Get the file name id\n-\n-            if Osint.File_Names_Case_Sensitive then\n-               File_Id := File_Name;\n-            else\n-               Name_Len := Name'Length;\n-               Name_Buffer (1 .. Name_Len) := Name;\n-               File_Id := Name_Find;\n-            end if;\n-\n-            --  Get the path name id\n-\n-            Path_Id := Path_Name;\n-\n-            if Osint.File_Names_Case_Sensitive then\n-               C_Path_Id := Path_Name;\n-            else\n-               declare\n-                  C_Path   : String := Get_Name_String (Path_Name);\n-               begin\n-                  Canonical_Case_File_Name (C_Path);\n-                  Name_Len := C_Path'Length;\n-                  Name_Buffer (1 .. Name_Len) := C_Path;\n-                  C_Path_Id := Name_Find;\n-               end;\n-            end if;\n-\n-            --  Find the position of the last dot\n-\n-            for J in reverse Name'Range loop\n-               if Name (J) = '.' then\n-                  Dot_Pos := J;\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if Dot_Pos <= Name'First then\n-               Dot_Pos := Name'Last + 1;\n-            end if;\n-\n-            --  Compute the object file name\n-\n-            Get_Name_String (File_Id);\n-            Name_Len := Dot_Pos - Name'First;\n-\n-            for J in Object_Suffix'Range loop\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := Object_Suffix (J);\n-            end loop;\n-\n-            Obj_Id := Name_Find;\n-\n-            --  Compute the object path name\n-\n-            Get_Name_String (Data.Object_Directory.Display_Name);\n-\n-            if Name_Buffer (Name_Len) /= Directory_Separator\n-              and then Name_Buffer (Name_Len) /= '/'\n-            then\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := Directory_Separator;\n-            end if;\n-\n-            Add_Str_To_Name_Buffer (Get_Name_String (Obj_Id));\n-            Obj_Path_Id := Name_Find;\n-\n-            --  Compute the dependency file name\n-\n-            Get_Name_String (File_Id);\n-            Name_Len := Dot_Pos - Name'First + 1;\n-            Name_Buffer (Name_Len) := '.';\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := 'd';\n-            Dep_Id := Name_Find;\n-\n-            --  Compute the dependency path name\n-\n-            Get_Name_String (Data.Object_Directory.Display_Name);\n-\n-            if Name_Buffer (Name_Len) /= Directory_Separator\n-              and then Name_Buffer (Name_Len) /= '/'\n-            then\n-               Name_Len := Name_Len + 1;\n-               Name_Buffer (Name_Len) := Directory_Separator;\n-            end if;\n-\n-            Add_Str_To_Name_Buffer (Get_Name_String (Dep_Id));\n-            Dep_Path_Id := Name_Find;\n-\n-            --  Check if source is already in the list of source for this\n-            --  project: it may have already been specified as a naming\n-            --  exception for the same language or an other language, or\n-            --  they may be two identical file names in different source\n-            --  directories.\n-\n-            while Source_Id /= No_Other_Source loop\n-               Source := In_Tree.Other_Sources.Table (Source_Id);\n-\n-               if Source.File_Name = File_Id then\n-                  --  Two sources of different languages cannot have the same\n-                  --  file name.\n-\n-                  if Source.Language /= Language then\n-                     Error_Msg_File_1 := File_Name;\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"{ cannot be a source of several languages\",\n-                        Real_Location);\n-                     return;\n-\n-                  --  No problem if a file has already been specified as\n-                  --  a naming exception of this language.\n-\n-                  elsif Source.Path_Name = C_Path_Id then\n-\n-                     --  Reset the naming exception flag, if this is not a\n-                     --  naming exception.\n-\n-                     if not Naming_Exception then\n-                        In_Tree.Other_Sources.Table\n-                          (Source_Id).Naming_Exception := False;\n-                     end if;\n-\n-                     return;\n-\n-                  --  There are several files with the same names, but the\n-                  --  order of the source directories is known (no /**):\n-                  --  only the first one encountered is kept, the other ones\n-                  --  are ignored.\n-\n-                  elsif Data.Known_Order_Of_Source_Dirs then\n-                     return;\n-\n-                  --  But it is an error if the order of the source directories\n-                  --  is not known.\n-\n-                  else\n-                     Error_Msg_File_1 := File_Name;\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"{ is found in several source directories\",\n-                        Real_Location);\n-                     return;\n-                  end if;\n-\n-               --  Two sources with different file names cannot have the same\n-               --  object file name.\n-\n-               elsif Source.Object_Name = Obj_Id then\n-                  Error_Msg_File_1 := File_Id;\n-                  Error_Msg_File_2 := Source.File_Name;\n-                  Error_Msg_File_3 := Obj_Id;\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"{ and { have the same object file {\",\n-                     Real_Location);\n-                     return;\n-               end if;\n-\n-               Source_Id := Source.Next;\n-            end loop;\n-\n-            if Current_Verbosity = High then\n-               Write_Str (\"      found \");\n-               Display_Language_Name (Language);\n-               Write_Str (\" source \"\"\");\n-               Write_Str (Get_Name_String (File_Name));\n-               Write_Line (\"\"\"\");\n-               Write_Str (\"      object path = \");\n-               Write_Line (Get_Name_String (Obj_Path_Id));\n-            end if;\n-\n-            --  Create the Other_Source record\n-\n-            Source :=\n-              (Language         => Language,\n-               File_Name        => File_Id,\n-               Path_Name        => Path_Id,\n-               Source_TS        => File_Stamp (Path_Id),\n-               Object_Name      => Obj_Id,\n-               Object_Path      => Obj_Path_Id,\n-               Object_TS        => File_Stamp (Obj_Path_Id),\n-               Dep_Name         => Dep_Id,\n-               Dep_Path         => Dep_Path_Id,\n-               Dep_TS           => File_Stamp (Dep_Path_Id),\n-               Naming_Exception => Naming_Exception,\n-               Next             => No_Other_Source);\n-\n-            --  And add it to the Other_Sources table\n-\n-            Other_Source_Table.Increment_Last (In_Tree.Other_Sources);\n-            In_Tree.Other_Sources.Table\n-              (Other_Source_Table.Last (In_Tree.Other_Sources)) := Source;\n-\n-            --  There are sources of languages other than Ada in this project\n-\n-            Data.Other_Sources_Present := True;\n-\n-            --  And there are sources of this language in this project\n-\n-            Set (Language, True, Data, In_Tree);\n-\n-            --  Add this source to the list of sources of languages other than\n-            --  Ada of the project.\n-\n-            if Data.First_Other_Source = No_Other_Source then\n-               Data.First_Other_Source :=\n-                 Other_Source_Table.Last (In_Tree.Other_Sources);\n-\n-            else\n-               In_Tree.Other_Sources.Table (Data.Last_Other_Source).Next :=\n-                 Other_Source_Table.Last (In_Tree.Other_Sources);\n-            end if;\n-\n-            Data.Last_Other_Source :=\n-              Other_Source_Table.Last (In_Tree.Other_Sources);\n-         end;\n-      end if;\n-   end Check_For_Source;\n-\n    -------------------------------\n    -- Check_If_Externally_Built --\n    -------------------------------\n@@ -4683,11 +4358,8 @@ package body Prj.Nmsc is\n                  (Name => Name_Ada, Next => No_Name_List);\n \n                --  Attribute Languages is not specified. So, it defaults to\n-               --  a project of language Ada only.\n-\n-               Data.Langs (Ada_Language_Index) := True;\n-\n-               --  No sources of languages other than Ada\n+               --  a project of language Ada only. No sources of languages\n+               --  other than Ada\n \n                Data.Other_Sources_Present := False;\n \n@@ -4757,13 +4429,10 @@ package body Prj.Nmsc is\n                NL_Id             : Name_List_Index := No_Name_List;\n \n             begin\n-               if Get_Mode = Ada_Only then\n-\n-                  --  Assume that there is no language specified yet\n+               --  Assume there are no language declared\n \n-                  Data.Other_Sources_Present := False;\n-                  Data.Ada_Sources_Present   := False;\n-               end if;\n+               Data.Ada_Sources_Present := False;\n+               Data.Other_Sources_Present := False;\n \n                --  If there are no languages declared, there are no sources\n \n@@ -4820,21 +4489,9 @@ package body Prj.Nmsc is\n                           (Lang_Name, No_Name_List);\n \n                         if Get_Mode = Ada_Only then\n-                           Index := Language_Indexes.Get (Lang_Name);\n-\n-                           if Index = No_Language_Index then\n-                              Add_Language_Name (Lang_Name);\n-                              Index := Last_Language_Index;\n-                           end if;\n-\n-                           Set (Index, True, Data, In_Tree);\n-                           Set (Language_Processing =>\n-                                  Default_Language_Processing_Data,\n-                                For_Language        => Index,\n-                                In_Project          => Data,\n-                                In_Tree             => In_Tree);\n+                           --  Check for language Ada\n \n-                           if Index = Ada_Language_Index then\n+                           if Lang_Name = Name_Ada then\n                               Data.Ada_Sources_Present := True;\n \n                            else\n@@ -5936,155 +5593,6 @@ package body Prj.Nmsc is\n \n    end Find_Ada_Sources;\n \n-   ------------------\n-   -- Find_Sources --\n-   ------------------\n-\n-   procedure Find_Sources\n-     (Project      : Project_Id;\n-      In_Tree      : Project_Tree_Ref;\n-      Data         : in out Project_Data;\n-      For_Language : Language_Index;\n-      Current_Dir  : String)\n-   is\n-      Source_Dir      : String_List_Id;\n-      Element         : String_Element;\n-      Dir             : Dir_Type;\n-      Current_Source  : String_List_Id := Nil_String;\n-      Source_Recorded : Boolean := False;\n-\n-   begin\n-      if Current_Verbosity = High then\n-         Write_Line (\"Looking for sources:\");\n-      end if;\n-\n-      --  Loop through subdirectories\n-\n-      Source_Dir := Data.Source_Dirs;\n-      while Source_Dir /= Nil_String loop\n-         begin\n-            Source_Recorded := False;\n-            Element := In_Tree.String_Elements.Table (Source_Dir);\n-\n-            if Element.Value /= No_Name then\n-               Get_Name_String (Element.Display_Value);\n-\n-               declare\n-                  Source_Directory : constant String :=\n-                                       Name_Buffer (1 .. Name_Len) &\n-                                         Directory_Separator;\n-\n-                  Dir_Last : constant Natural :=\n-                               Compute_Directory_Last (Source_Directory);\n-\n-               begin\n-                  if Current_Verbosity = High then\n-                     Write_Str (\"Source_Dir = \");\n-                     Write_Line (Source_Directory);\n-                  end if;\n-\n-                  --  We look to every entry in the source directory\n-\n-                  Open (Dir, Source_Directory\n-                               (Source_Directory'First .. Dir_Last));\n-\n-                  loop\n-                     Read (Dir, Name_Buffer, Name_Len);\n-\n-                     if Current_Verbosity = High then\n-                        Write_Str  (\"   Checking \");\n-                        Write_Line (Name_Buffer (1 .. Name_Len));\n-                     end if;\n-\n-                     exit when Name_Len = 0;\n-\n-                     declare\n-                        File_Name : constant File_Name_Type := Name_Find;\n-                        Path      : constant String :=\n-                          Normalize_Pathname\n-                            (Name           => Name_Buffer (1 .. Name_Len),\n-                             Directory      => Source_Directory\n-                               (Source_Directory'First .. Dir_Last),\n-                             Resolve_Links  => Opt.Follow_Links_For_Files,\n-                             Case_Sensitive => True);\n-                        Path_Name : Path_Name_Type;\n-\n-                     begin\n-                        Name_Len := Path'Length;\n-                        Name_Buffer (1 .. Name_Len) := Path;\n-                        Path_Name := Name_Find;\n-\n-                        if For_Language = Ada_Language_Index then\n-\n-                           --  We attempt to register it as a source. However,\n-                           --  there is no error if the file does not contain\n-                           --  a valid source. But there is an error if we have\n-                           --  a duplicate unit name.\n-\n-                           Record_Ada_Source\n-                             (File_Name       => File_Name,\n-                              Path_Name       => Path_Name,\n-                              Project         => Project,\n-                              In_Tree         => In_Tree,\n-                              Data            => Data,\n-                              Location        => No_Location,\n-                              Current_Source  => Current_Source,\n-                              Source_Recorded => Source_Recorded,\n-                              Current_Dir     => Current_Dir);\n-\n-                        else\n-                           Check_For_Source\n-                             (File_Name        => File_Name,\n-                              Path_Name        => Path_Name,\n-                              Project          => Project,\n-                              In_Tree          => In_Tree,\n-                              Data             => Data,\n-                              Location         => No_Location,\n-                              Language         => For_Language,\n-                              Suffix           =>\n-                                Body_Suffix_Of (For_Language, Data, In_Tree),\n-                              Naming_Exception => False);\n-                        end if;\n-                     end;\n-                  end loop;\n-\n-                  Close (Dir);\n-               end;\n-            end if;\n-\n-         exception\n-            when Directory_Error =>\n-               null;\n-         end;\n-\n-         if Source_Recorded then\n-            In_Tree.String_Elements.Table (Source_Dir).Flag :=\n-              True;\n-         end if;\n-\n-         Source_Dir := Element.Next;\n-      end loop;\n-\n-      if Current_Verbosity = High then\n-         Write_Line (\"end Looking for sources.\");\n-      end if;\n-\n-      if For_Language = Ada_Language_Index then\n-\n-         --  If we have looked for sources and found none, then it is an error,\n-         --  except if it is an extending project. If a non extending project\n-         --  is not supposed to contain any source files, then never call\n-         --  Find_Sources.\n-\n-         if Current_Source /= Nil_String then\n-            Data.Ada_Sources_Present := True;\n-\n-         elsif Data.Extends = No_Project then\n-            Report_No_Sources (Project, \"Ada\", In_Tree, Data.Location);\n-         end if;\n-      end if;\n-   end Find_Sources;\n-\n    --------------------------------\n    -- Free_Ada_Naming_Exceptions --\n    --------------------------------\n@@ -7606,8 +7114,7 @@ package body Prj.Nmsc is\n    ---------------------------\n \n    procedure Find_Explicit_Sources\n-     (Lang        : Language_Index;\n-      Current_Dir : String;\n+     (Current_Dir : String;\n       Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Data        : in out Project_Data)\n@@ -7654,18 +7161,9 @@ package body Prj.Nmsc is\n                Data.Ada_Sources_Present := Current /= Nil_String;\n             end if;\n \n-            --  If we are processing other languages in the case of gprmake,\n-            --  we should not reset the list of sources, which was already\n-            --  initialized for the Ada files.\n-\n-            if Get_Mode /= Ada_Only or else Lang /= Ada_Language_Index then\n+            if Get_Mode = Multi_Language then\n                if Current = Nil_String then\n-                  case Get_Mode is\n-                     when Ada_Only =>\n-                        Data.Source_Dirs := Nil_String;\n-                     when Multi_Language =>\n-                        Data.First_Language_Processing := No_Language_Index;\n-                  end case;\n+                  Data.First_Language_Processing := No_Language_Index;\n \n                   --  This project contains no source. For projects that\n                   --  don't extend other projects, this also means that\n@@ -7743,17 +7241,8 @@ package body Prj.Nmsc is\n             end loop;\n \n             if Get_Mode = Ada_Only then\n-               if Lang = Ada_Language_Index then\n-                  Get_Path_Names_And_Record_Ada_Sources\n-                    (Project, In_Tree, Data, Current_Dir);\n-               else\n-                  Record_Other_Sources\n-                    (Project           => Project,\n-                     In_Tree           => In_Tree,\n-                     Data              => Data,\n-                     Language          => Lang,\n-                     Naming_Exceptions => False);\n-               end if;\n+               Get_Path_Names_And_Record_Ada_Sources\n+                 (Project, In_Tree, Data, Current_Dir);\n             end if;\n          end;\n \n@@ -7787,18 +7276,8 @@ package body Prj.Nmsc is\n                if Get_Mode = Ada_Only then\n                   --  Look in the source directories to find those sources\n \n-                  if Lang = Ada_Language_Index then\n-                     Get_Path_Names_And_Record_Ada_Sources\n-                       (Project, In_Tree, Data, Current_Dir);\n-\n-                  else\n-                     Record_Other_Sources\n-                       (Project           => Project,\n-                        In_Tree           => In_Tree,\n-                        Data              => Data,\n-                        Language          => Lang,\n-                        Naming_Exceptions => False);\n-                  end if;\n+                  Get_Path_Names_And_Record_Ada_Sources\n+                    (Project, In_Tree, Data, Current_Dir);\n                end if;\n             end if;\n          end;\n@@ -7808,22 +7287,9 @@ package body Prj.Nmsc is\n          --  specified. Find all the files that satisfy the naming\n          --  scheme in all the source directories.\n \n-         case Get_Mode is\n-            when Ada_Only  =>\n-               if Lang = Ada_Language_Index then\n-                  Find_Ada_Sources (Project, In_Tree, Data, Current_Dir);\n-               else\n-                  --  Find all the files that satisfy the naming scheme in\n-                  --  all the source directories. All the naming exceptions\n-                  --  that effectively exist are also part of the source\n-                  --  of this language.\n-\n-                  Find_Sources (Project, In_Tree, Data, Lang, Current_Dir);\n-               end if;\n-\n-            when Multi_Language =>\n-               null;\n-         end case;\n+         if Get_Mode = Ada_Only then\n+            Find_Ada_Sources (Project, In_Tree, Data, Current_Dir);\n+         end if;\n       end if;\n \n       if Get_Mode = Multi_Language then\n@@ -7888,7 +7354,6 @@ package body Prj.Nmsc is\n       end if;\n \n       if Get_Mode = Ada_Only\n-        and then Lang = Ada_Language_Index\n         and then Data.Extends = No_Project\n       then\n          --  We should have found at least one source, if not report an error\n@@ -8829,9 +8294,6 @@ package body Prj.Nmsc is\n       procedure Remove_Locally_Removed_Files_From_Units;\n       --  Mark all locally removed sources as such in the Units table\n \n-      procedure Process_Other_Sources_In_Ada_Only_Mode;\n-      --  Find sources for language other than Ada when in Ada_Only mode\n-\n       procedure Process_Sources_In_Multi_Language_Mode;\n       --  Find all source files when in multi language mode\n \n@@ -8895,116 +8357,6 @@ package body Prj.Nmsc is\n          end loop;\n       end Remove_Locally_Removed_Files_From_Units;\n \n-      --------------------------------------------\n-      -- Process_Other_Sources_In_Ada_Only_Mode --\n-      --------------------------------------------\n-\n-      procedure Process_Other_Sources_In_Ada_Only_Mode is\n-      begin\n-         --  Set Source_Present to False. It will be set back to True\n-         --  whenever a source is found.\n-\n-         Data.Other_Sources_Present := False;\n-         for Lang in Ada_Language_Index + 1 .. Last_Language_Index loop\n-\n-            --  For each language (other than Ada) in the project file\n-\n-            if Is_Present (Lang, Data, In_Tree) then\n-\n-               --  Reset the indication that there are sources of this\n-               --  language. It will be set back to True whenever we find\n-               --  a source of the language.\n-\n-               Set (Lang, False, Data, In_Tree);\n-\n-               --  First, get the source suffix for the language\n-\n-               Set (Suffix       => Suffix_For (Lang, Data.Naming, In_Tree),\n-                    For_Language => Lang,\n-                    In_Project   => Data,\n-                    In_Tree      => In_Tree);\n-\n-               --  Then, deal with the naming exceptions, if any\n-\n-               Source_Names.Reset;\n-\n-               declare\n-                  Naming_Exceptions : constant Variable_Value :=\n-                    Value_Of\n-                      (Index     => Language_Names.Table (Lang),\n-                       Src_Index => 0,\n-                       In_Array  => Data.Naming.Implementation_Exceptions,\n-                       In_Tree   => In_Tree);\n-                  Element_Id        : String_List_Id;\n-                  Element           : String_Element;\n-                  File_Id           : File_Name_Type;\n-                  Source_Found      : Boolean := False;\n-\n-               begin\n-                  --  If there are naming exceptions, look through them one\n-                  --  by one.\n-\n-                  if Naming_Exceptions /= Nil_Variable_Value then\n-                     Element_Id := Naming_Exceptions.Values;\n-\n-                     while Element_Id /= Nil_String loop\n-                        Element := In_Tree.String_Elements.Table (Element_Id);\n-\n-                        if Osint.File_Names_Case_Sensitive then\n-                           File_Id := File_Name_Type (Element.Value);\n-                        else\n-                           Get_Name_String (Element.Value);\n-                           Canonical_Case_File_Name\n-                             (Name_Buffer (1 .. Name_Len));\n-                           File_Id := Name_Find;\n-                        end if;\n-\n-                        --  Put each naming exception in the Source_Names hash\n-                        --  table, but if there are repetition, don't bother\n-                        --  after the first instance.\n-\n-                        if Source_Names.Get (File_Id) = No_Name_Location then\n-                           Source_Found := True;\n-                           Source_Names.Set\n-                             (File_Id,\n-                              (Name     => File_Id,\n-                               Location => Element.Location,\n-                               Source   => No_Source,\n-                               Except   => False,\n-                               Found    => False));\n-                        end if;\n-\n-                        Element_Id := Element.Next;\n-                     end loop;\n-\n-                     --  If there is at least one naming exception, record\n-                     --  those that are found in the source directories.\n-\n-                     if Source_Found then\n-                        Record_Other_Sources\n-                          (Project           => Project,\n-                           In_Tree           => In_Tree,\n-                           Data              => Data,\n-                           Language          => Lang,\n-                           Naming_Exceptions => True);\n-                     end if;\n-\n-                  end if;\n-               end;\n-\n-               --  Now, check if a list of sources is declared either through\n-               --  a string list (attribute Source_Files) or a text file\n-               --  (attribute Source_List_File). If a source list is declared,\n-               --  we will consider only those naming exceptions that are\n-               --  on the list.\n-\n-               Source_Names.Reset;\n-               Find_Explicit_Sources\n-                 (Lang, Current_Dir, Project, In_Tree, Data);\n-            end if;\n-         end loop;\n-      end Process_Other_Sources_In_Ada_Only_Mode;\n-\n       --------------------------------------------\n       -- Process_Sources_In_Multi_Language_Mode --\n       --------------------------------------------\n@@ -9077,7 +8429,7 @@ package body Prj.Nmsc is\n          end loop;\n \n          Find_Explicit_Sources\n-           (Ada_Language_Index, Current_Dir, Project, In_Tree, Data);\n+           (Current_Dir, Project, In_Tree, Data);\n \n          --  Mark as such the sources that are declared as excluded\n \n@@ -9219,15 +8571,10 @@ package body Prj.Nmsc is\n       case Get_Mode is\n          when Ada_Only =>\n             if Is_A_Language (In_Tree, Data, Name_Ada) then\n-               Find_Explicit_Sources\n-                 (Ada_Language_Index, Current_Dir, Project, In_Tree, Data);\n+               Find_Explicit_Sources (Current_Dir, Project, In_Tree, Data);\n                Remove_Locally_Removed_Files_From_Units;\n             end if;\n \n-            if Data.Other_Sources_Present then\n-               Process_Other_Sources_In_Ada_Only_Mode;\n-            end if;\n-\n          when Multi_Language =>\n             if Data.First_Language_Processing /= No_Language_Index then\n                Process_Sources_In_Multi_Language_Mode;\n@@ -9624,179 +8971,6 @@ package body Prj.Nmsc is\n       end if;\n    end Record_Ada_Source;\n \n-   --------------------------\n-   -- Record_Other_Sources --\n-   --------------------------\n-\n-   procedure Record_Other_Sources\n-     (Project           : Project_Id;\n-      In_Tree           : Project_Tree_Ref;\n-      Data              : in out Project_Data;\n-      Language          : Language_Index;\n-      Naming_Exceptions : Boolean)\n-   is\n-      Source_Dir     : String_List_Id;\n-      Element        : String_Element;\n-      Path           : Path_Name_Type;\n-      Dir            : Dir_Type;\n-      Canonical_Name : File_Name_Type;\n-      Name_Str       : String (1 .. 1_024);\n-      Last           : Natural := 0;\n-      NL             : Name_Location;\n-      First_Error    : Boolean := True;\n-      Suffix         : constant String :=\n-                         Body_Suffix_Of (Language, Data, In_Tree);\n-\n-   begin\n-      Source_Dir := Data.Source_Dirs;\n-      while Source_Dir /= Nil_String loop\n-         Element := In_Tree.String_Elements.Table (Source_Dir);\n-\n-         declare\n-            Dir_Path : constant String :=\n-                         Get_Name_String (Element.Display_Value);\n-         begin\n-            if Current_Verbosity = High then\n-               Write_Str (\"checking directory \"\"\");\n-               Write_Str (Dir_Path);\n-               Write_Str (\"\"\" for \");\n-\n-               if Naming_Exceptions then\n-                  Write_Str (\"naming exceptions\");\n-               else\n-                  Write_Str (\"sources\");\n-               end if;\n-\n-               Write_Str (\" of Language \");\n-               Display_Language_Name (Language);\n-            end if;\n-\n-            Open (Dir, Dir_Path);\n-\n-            loop\n-               Read (Dir, Name_Str, Last);\n-               exit when Last = 0;\n-\n-               if Is_Regular_File\n-                 (Dir_Path & Directory_Separator & Name_Str (1 .. Last))\n-               then\n-                  Name_Len := Last;\n-                  Name_Buffer (1 .. Name_Len) := Name_Str (1 .. Last);\n-                  Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-                  Canonical_Name := Name_Find;\n-                  NL := Source_Names.Get (Canonical_Name);\n-\n-                  if NL /= No_Name_Location then\n-                     if NL.Found then\n-                        if not Data.Known_Order_Of_Source_Dirs then\n-                           Error_Msg_File_1 := Canonical_Name;\n-                           Error_Msg\n-                             (Project, In_Tree,\n-                              \"{ is found in several source directories\",\n-                              NL.Location);\n-                        end if;\n-\n-                     else\n-                        NL.Found := True;\n-                        Source_Names.Set (Canonical_Name, NL);\n-                        Name_Len := Dir_Path'Length;\n-                        Name_Buffer (1 .. Name_Len) := Dir_Path;\n-                        Add_Char_To_Name_Buffer (Directory_Separator);\n-                        Add_Str_To_Name_Buffer (Name_Str (1 .. Last));\n-                        Path := Name_Find;\n-\n-                        Check_For_Source\n-                          (File_Name        => Canonical_Name,\n-                           Path_Name        => Path,\n-                           Project          => Project,\n-                           In_Tree          => In_Tree,\n-                           Data             => Data,\n-                           Location         => NL.Location,\n-                           Language         => Language,\n-                           Suffix           => Suffix,\n-                           Naming_Exception => Naming_Exceptions);\n-                     end if;\n-                  end if;\n-               end if;\n-            end loop;\n-\n-            Close (Dir);\n-         end;\n-\n-         Source_Dir := Element.Next;\n-      end loop;\n-\n-      if not Naming_Exceptions then\n-         NL := Source_Names.Get_First;\n-\n-         --  It is an error if a source file name in a source list or\n-         --  in a source list file is not found.\n-\n-         while NL /= No_Name_Location loop\n-            if not NL.Found then\n-               Err_Vars.Error_Msg_File_1 := NL.Name;\n-\n-               if First_Error then\n-                  Error_Msg\n-                    (Project, In_Tree, \"source file { cannot be found\",\n-                     NL.Location);\n-                  First_Error := False;\n-\n-               else\n-                  Error_Msg\n-                    (Project, In_Tree, \"\\source file { cannot be found\",\n-                     NL.Location);\n-               end if;\n-            end if;\n-\n-            NL := Source_Names.Get_Next;\n-         end loop;\n-\n-         --  Any naming exception of this language that is not in a list\n-         --  of sources must be removed.\n-\n-         declare\n-            Source_Id : Other_Source_Id;\n-            Prev_Id   : Other_Source_Id;\n-            Source    : Other_Source;\n-\n-         begin\n-            Prev_Id := No_Other_Source;\n-            Source_Id := Data.First_Other_Source;\n-            while Source_Id /= No_Other_Source loop\n-               Source := In_Tree.Other_Sources.Table (Source_Id);\n-\n-               if Source.Language = Language\n-                 and then Source.Naming_Exception\n-               then\n-                  if Current_Verbosity = High then\n-                     Write_Str (\"Naming exception \"\"\");\n-                     Write_Str (Get_Name_String (Source.File_Name));\n-                     Write_Str (\"\"\" is not in the list of sources,\");\n-                     Write_Line (\" so it is removed.\");\n-                  end if;\n-\n-                  if Prev_Id = No_Other_Source then\n-                     Data.First_Other_Source := Source.Next;\n-                  else\n-                     In_Tree.Other_Sources.Table (Prev_Id).Next := Source.Next;\n-                  end if;\n-\n-                  Source_Id := Source.Next;\n-\n-                  if Source_Id = No_Other_Source then\n-                     Data.Last_Other_Source := Prev_Id;\n-                  end if;\n-\n-               else\n-                  Prev_Id := Source_Id;\n-                  Source_Id := Source.Next;\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n-   end Record_Other_Sources;\n-\n    -------------------\n    -- Remove_Source --\n    -------------------\n@@ -9971,52 +9145,6 @@ package body Prj.Nmsc is\n       Write_Line (\"end Source_Dirs.\");\n    end Show_Source_Dirs;\n \n-   ----------------\n-   -- Suffix_For --\n-   ----------------\n-\n-   function Suffix_For\n-     (Language : Language_Index;\n-      Naming   : Naming_Data;\n-      In_Tree  : Project_Tree_Ref) return File_Name_Type\n-   is\n-      Suffix : constant Variable_Value :=\n-        Value_Of\n-          (Index     => Language_Names.Table (Language),\n-           Src_Index => 0,\n-           In_Array  => Naming.Body_Suffix,\n-           In_Tree   => In_Tree);\n-\n-   begin\n-      --  If no suffix for this language in package Naming, use the default\n-\n-      if Suffix = Nil_Variable_Value then\n-         Name_Len := 0;\n-\n-         case Language is\n-            when Ada_Language_Index =>\n-               Add_Str_To_Name_Buffer (\".adb\");\n-\n-            when C_Language_Index =>\n-               Add_Str_To_Name_Buffer (\".c\");\n-\n-            when C_Plus_Plus_Language_Index =>\n-               Add_Str_To_Name_Buffer (\".cpp\");\n-\n-            when others =>\n-               return No_File;\n-         end case;\n-\n-      --  Otherwise use the one specified\n-\n-      else\n-         Get_Name_String (Suffix.Value);\n-      end if;\n-\n-      Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-      return Name_Find;\n-   end Suffix_For;\n-\n    -------------------------\n    -- Warn_If_Not_Sources --\n    -------------------------"}, {"sha": "c59b2fdf5022f8ea57298ebb2b69fea3c296fefc", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 6, "deletions": 326, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=c116b9806466d5f3cfa3d274af443fc538be52e3", "patch": "@@ -32,9 +32,11 @@ with Prj.Attr;\n with Prj.Env;\n with Prj.Err;  use Prj.Err;\n with Snames;   use Snames;\n+with Table;\n with Uintp;    use Uintp;\n \n with System.Case_Util; use System.Case_Util;\n+with System.HTable;\n \n package body Prj is\n \n@@ -50,8 +52,6 @@ package body Prj is\n \n    The_Empty_String : Name_Id;\n \n-   Name_C_Plus_Plus : Name_Id;\n-\n    Default_Ada_Spec_Suffix_Id : File_Name_Type;\n    Default_Ada_Body_Suffix_Id : File_Name_Type;\n    Slash_Id                   : Path_Name_Type;\n@@ -83,9 +83,7 @@ package body Prj is\n                         Specs                     => No_Array_Element,\n                         Bodies                    => No_Array_Element,\n                         Specification_Exceptions  => No_Array_Element,\n-                        Implementation_Exceptions => No_Array_Element,\n-                        Impl_Suffixes             => No_Impl_Suffixes,\n-                        Supp_Suffixes             => No_Supp_Language_Index);\n+                        Implementation_Exceptions => No_Array_Element);\n \n    Project_Empty : constant Project_Data :=\n                      (Qualifier                      => Unspecified,\n@@ -113,6 +111,8 @@ package body Prj is\n                       Lib_Auto_Init                  => False,\n                       Libgnarl_Needed                => Unknown,\n                       Symbol_Data                    => No_Symbols,\n+                      Ada_Sources_Present            => True,\n+                      Other_Sources_Present          => True,\n                       Ada_Sources                    => Nil_String,\n                       Sources                        => Nil_String,\n                       First_Source                   => No_Source,\n@@ -152,17 +152,7 @@ package body Prj is\n                       Seen                           => False,\n                       Need_To_Build_Lib              => False,\n                       Depth                          => 0,\n-                      Unkept_Comments                => False,\n-                      Langs                          => No_Languages,\n-                      Supp_Languages                 => No_Supp_Language_Index,\n-                      Ada_Sources_Present            => True,\n-                      Other_Sources_Present          => True,\n-                      First_Other_Source             => No_Other_Source,\n-                      Last_Other_Source              => No_Other_Source,\n-                      First_Lang_Processing          =>\n-                        Default_First_Language_Processing_Data,\n-                      Supp_Language_Processing       =>\n-                        No_Supp_Language_Index);\n+                      Unkept_Comments                => False);\n \n    package Temp_Files is new Table.Table\n      (Table_Component_Type => Path_Name_Type,\n@@ -174,18 +164,6 @@ package body Prj is\n    --  Table to store the path name of all the created temporary files, so that\n    --  they can be deleted at the end, or when the program is interrupted.\n \n-   -----------------------\n-   -- Add_Language_Name --\n-   -----------------------\n-\n-   procedure Add_Language_Name (Name : Name_Id) is\n-   begin\n-      Last_Language_Index := Last_Language_Index + 1;\n-      Language_Indexes.Set (Name, Last_Language_Index);\n-      Language_Names.Increment_Last;\n-      Language_Names.Table (Last_Language_Index) := Name;\n-   end Add_Language_Name;\n-\n    -------------------\n    -- Add_To_Buffer --\n    -------------------\n@@ -341,21 +319,6 @@ package body Prj is\n       return \"\";\n    end Body_Suffix_Of;\n \n-   function Body_Suffix_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return String\n-   is\n-      Suffix_Id : constant File_Name_Type :=\n-                    Suffix_Of (Language, In_Project, In_Tree);\n-   begin\n-      if Suffix_Id /= No_File then\n-         return Get_Name_String (Suffix_Id);\n-      else\n-         return \".\" & Get_Name_String (Language_Names.Table (Language));\n-      end if;\n-   end Body_Suffix_Of;\n-\n    -----------------------------\n    -- Default_Ada_Body_Suffix --\n    -----------------------------\n@@ -430,17 +393,6 @@ package body Prj is\n       Write_Str (Name_Buffer (1 .. Name_Len));\n    end Display_Language_Name;\n \n-   ---------------------------\n-   -- Display_Language_Name --\n-   ---------------------------\n-\n-   procedure Display_Language_Name (Language : Language_Index) is\n-   begin\n-      Get_Name_String (Language_Names.Table (Language));\n-      To_Upper (Name_Buffer (1 .. 1));\n-      Write_Str (Name_Buffer (1 .. Name_Len));\n-   end Display_Language_Name;\n-\n    ----------------\n    -- Empty_File --\n    ----------------\n@@ -638,22 +590,12 @@ package body Prj is\n          Name_Len := 1;\n          Name_Buffer (1) := '/';\n          Slash_Id := Name_Find;\n-         Name_Len := 3;\n-         Name_Buffer (1 .. 3) := \"c++\";\n-         Name_C_Plus_Plus := Name_Find;\n \n          Prj.Env.Initialize;\n          Prj.Attr.Initialize;\n          Set_Name_Table_Byte (Name_Project,  Token_Type'Pos (Tok_Project));\n          Set_Name_Table_Byte (Name_Extends,  Token_Type'Pos (Tok_Extends));\n          Set_Name_Table_Byte (Name_External, Token_Type'Pos (Tok_External));\n-\n-         Language_Indexes.Reset;\n-         Last_Language_Index := No_Language_Index;\n-         Language_Names.Init;\n-         Add_Language_Name (Name_Ada);\n-         Add_Language_Name (Name_C);\n-         Add_Language_Name (Name_C_Plus_Plus);\n       end if;\n \n       if Tree /= No_Project_Tree then\n@@ -729,84 +671,6 @@ package body Prj is\n       return False;\n    end Is_Extending;\n \n-   ----------------\n-   -- Is_Present --\n-   ----------------\n-\n-   function Is_Present\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return Boolean\n-   is\n-   begin\n-      case Language is\n-         when No_Language_Index =>\n-            return False;\n-\n-         when First_Language_Indexes =>\n-            return In_Project.Langs (Language);\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Language;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Supp_Languages;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Present_Languages.Table (Supp_Index);\n-\n-                  if Supp.Index = Language then\n-                     return Supp.Present;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               return False;\n-            end;\n-      end case;\n-   end Is_Present;\n-\n-   ---------------------------------\n-   -- Language_Processing_Data_Of --\n-   ---------------------------------\n-\n-   function Language_Processing_Data_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return Language_Processing_Data\n-   is\n-   begin\n-      case Language is\n-         when No_Language_Index =>\n-            return Default_Language_Processing_Data;\n-\n-         when First_Language_Indexes =>\n-            return In_Project.First_Lang_Processing (Language);\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Language_Data;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Supp_Language_Processing;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Languages.Table (Supp_Index);\n-\n-                  if Supp.Index = Language then\n-                     return Supp.Data;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               return Default_Language_Processing_Data;\n-            end;\n-      end case;\n-   end Language_Processing_Data_Of;\n-\n    -----------------------\n    -- Objects_Exist_For --\n    -----------------------\n@@ -980,13 +844,6 @@ package body Prj is\n    begin\n       Prj.Env.Initialize;\n \n-      --  gprmake tables\n-\n-      Present_Language_Table.Init (Tree.Present_Languages);\n-      Supp_Suffix_Table.Init      (Tree.Supp_Suffixes);\n-      Supp_Language_Table.Init    (Tree.Supp_Languages);\n-      Other_Source_Table.Init     (Tree.Other_Sources);\n-\n       --  Visible tables\n \n       Language_Data_Table.Init      (Tree.Languages_Data);\n@@ -1040,144 +897,6 @@ package body Prj is\n         and then Left.Separate_Suffix = Right.Separate_Suffix;\n    end Same_Naming_Scheme;\n \n-   ---------\n-   -- Set --\n-   ---------\n-\n-   procedure Set\n-     (Language   : Language_Index;\n-      Present    : Boolean;\n-      In_Project : in out Project_Data;\n-      In_Tree    : Project_Tree_Ref)\n-   is\n-   begin\n-      case Language is\n-         when No_Language_Index =>\n-            null;\n-\n-         when First_Language_Indexes =>\n-            In_Project.Langs (Language) := Present;\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Language;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Supp_Languages;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Present_Languages.Table (Supp_Index);\n-\n-                  if Supp.Index = Language then\n-                     In_Tree.Present_Languages.Table (Supp_Index).Present :=\n-                       Present;\n-                     return;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               Supp := (Index => Language, Present => Present,\n-                        Next  => In_Project.Supp_Languages);\n-               Present_Language_Table.Increment_Last\n-                 (In_Tree.Present_Languages);\n-               Supp_Index :=\n-                 Present_Language_Table.Last (In_Tree.Present_Languages);\n-               In_Tree.Present_Languages.Table (Supp_Index) :=\n-                 Supp;\n-               In_Project.Supp_Languages := Supp_Index;\n-            end;\n-      end case;\n-   end Set;\n-\n-   procedure Set\n-     (Language_Processing : Language_Processing_Data;\n-      For_Language        : Language_Index;\n-      In_Project          : in out Project_Data;\n-      In_Tree             : Project_Tree_Ref)\n-   is\n-   begin\n-      case For_Language is\n-         when No_Language_Index =>\n-            null;\n-\n-         when First_Language_Indexes =>\n-            In_Project.First_Lang_Processing (For_Language) :=\n-              Language_Processing;\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Language_Data;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Supp_Language_Processing;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Languages.Table (Supp_Index);\n-\n-                  if Supp.Index = For_Language then\n-                     In_Tree.Supp_Languages.Table\n-                       (Supp_Index).Data := Language_Processing;\n-                     return;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               Supp := (Index => For_Language, Data => Language_Processing,\n-                        Next  => In_Project.Supp_Language_Processing);\n-               Supp_Language_Table.Increment_Last\n-                 (In_Tree.Supp_Languages);\n-               Supp_Index := Supp_Language_Table.Last\n-                               (In_Tree.Supp_Languages);\n-               In_Tree.Supp_Languages.Table (Supp_Index) := Supp;\n-               In_Project.Supp_Language_Processing := Supp_Index;\n-            end;\n-      end case;\n-   end Set;\n-\n-   procedure Set\n-     (Suffix       : File_Name_Type;\n-      For_Language : Language_Index;\n-      In_Project   : in out Project_Data;\n-      In_Tree      : Project_Tree_Ref)\n-   is\n-   begin\n-      case For_Language is\n-         when No_Language_Index =>\n-            null;\n-\n-         when First_Language_Indexes =>\n-            In_Project.Naming.Impl_Suffixes (For_Language) := Suffix;\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Suffix;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Naming.Supp_Suffixes;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Suffixes.Table (Supp_Index);\n-\n-                  if Supp.Index = For_Language then\n-                     In_Tree.Supp_Suffixes.Table (Supp_Index).Suffix := Suffix;\n-                     return;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               Supp := (Index => For_Language, Suffix => Suffix,\n-                        Next  => In_Project.Naming.Supp_Suffixes);\n-               Supp_Suffix_Table.Increment_Last (In_Tree.Supp_Suffixes);\n-               Supp_Index := Supp_Suffix_Table.Last (In_Tree.Supp_Suffixes);\n-               In_Tree.Supp_Suffixes.Table (Supp_Index) := Supp;\n-               In_Project.Naming.Supp_Suffixes := Supp_Index;\n-            end;\n-      end case;\n-   end Set;\n-\n    ---------------------\n    -- Set_Body_Suffix --\n    ---------------------\n@@ -1426,45 +1145,6 @@ package body Prj is\n       end if;\n    end Standard_Naming_Data;\n \n-   ---------------\n-   -- Suffix_Of --\n-   ---------------\n-\n-   function Suffix_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return File_Name_Type\n-   is\n-   begin\n-      case Language is\n-         when No_Language_Index =>\n-            return No_File;\n-\n-         when First_Language_Indexes =>\n-            return In_Project.Naming.Impl_Suffixes (Language);\n-\n-         when others =>\n-            declare\n-               Supp       : Supp_Suffix;\n-               Supp_Index : Supp_Language_Index;\n-\n-            begin\n-               Supp_Index := In_Project.Naming.Supp_Suffixes;\n-               while Supp_Index /= No_Supp_Language_Index loop\n-                  Supp := In_Tree.Supp_Suffixes.Table (Supp_Index);\n-\n-                  if Supp.Index = Language then\n-                     return Supp.Suffix;\n-                  end if;\n-\n-                  Supp_Index := Supp.Next;\n-               end loop;\n-\n-               return No_File;\n-            end;\n-      end case;\n-   end  Suffix_Of;\n-\n    -------------------\n    -- Switches_Name --\n    -------------------"}, {"sha": "6f913c8a6fa6e11d204a6f5445f13e70be7b8bca", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 6, "deletions": 251, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c116b9806466d5f3cfa3d274af443fc538be52e3/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=c116b9806466d5f3cfa3d274af443fc538be52e3", "patch": "@@ -32,15 +32,12 @@\n with Casing; use Casing;\n with Namet;  use Namet;\n with Scans;  use Scans;\n-with Table;\n with Types;  use Types;\n \n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n with GNAT.Dynamic_Tables;\n with GNAT.OS_Lib;          use GNAT.OS_Lib;\n \n-with System.HTable;\n-\n package Prj is\n \n    Subdirs_Option : constant String := \"--subdirs=\";\n@@ -838,164 +835,6 @@ package Prj is\n    --  Similar to 'Value (but avoid use of this attribute in compiler)\n    --  Raises Constraint_Error if not a Casing_Type image.\n \n-   --  Declarations for gprmake:\n-\n-   First_Language_Index        : constant Language_Index := 1;\n-   First_Language_Indexes_Last : constant Language_Index := 5;\n-\n-   Ada_Language_Index         : constant Language_Index :=\n-                                  First_Language_Index;\n-   C_Language_Index           : constant Language_Index :=\n-                                  Ada_Language_Index + 1;\n-   C_Plus_Plus_Language_Index : constant Language_Index :=\n-                                  C_Language_Index + 1;\n-\n-   Last_Language_Index : Language_Index := No_Language_Index;\n-\n-   subtype First_Language_Indexes is Language_Index\n-      range First_Language_Index .. First_Language_Indexes_Last;\n-\n-   package Language_Indexes is new System.HTable.Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Language_Index,\n-      No_Element => No_Language_Index,\n-      Key        => Name_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  Mapping of language names to language indexes\n-\n-   package Language_Names is new Table.Table\n-     (Table_Component_Type => Name_Id,\n-      Table_Index_Type     => Language_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Prj.Language_Names\");\n-   --  The table for the name of programming languages\n-\n-   procedure Add_Language_Name (Name : Name_Id);\n-\n-   procedure Display_Language_Name (Language : Language_Index);\n-\n-   type Languages_In_Project is array (First_Language_Indexes) of Boolean;\n-   --  Set of supported languages used in a project\n-\n-   No_Languages : constant Languages_In_Project := (others => False);\n-   --  No supported languages are used\n-\n-   type Supp_Language_Index is new Nat;\n-   No_Supp_Language_Index  : constant Supp_Language_Index := 0;\n-\n-   type Supp_Language is record\n-      Index   : Language_Index := No_Language_Index;\n-      Present : Boolean := False;\n-      Next    : Supp_Language_Index := No_Supp_Language_Index;\n-   end record;\n-\n-   package Present_Language_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Language,\n-      Table_Index_Type     => Supp_Language_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100);\n-   --  The table for the presence of languages with an index that is outside\n-   --  of First_Language_Indexes.\n-\n-   type Impl_Suffix_Array is array (First_Language_Indexes) of File_Name_Type;\n-   --  Suffixes for the non spec sources of the different supported languages\n-   --  in a project.\n-\n-   No_Impl_Suffixes : constant Impl_Suffix_Array := (others => No_File);\n-   --  A default value for the non spec source suffixes\n-\n-   type Supp_Suffix is record\n-      Index   : Language_Index      := No_Language_Index;\n-      Suffix  : File_Name_Type      := No_File;\n-      Next    : Supp_Language_Index := No_Supp_Language_Index;\n-   end record;\n-\n-   package Supp_Suffix_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Suffix,\n-      Table_Index_Type     => Supp_Language_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100);\n-   --  The table for the presence of languages with an index that is outside\n-   --  of First_Language_Indexes.\n-\n-   type Lang_Kind is (GNU, Other);\n-\n-   type Language_Processing_Data is record\n-      Compiler_Drivers     : Name_List_Index := No_Name_List;\n-      Compiler_Paths       : Name_Id         := No_Name;\n-      Compiler_Kinds       : Lang_Kind       := GNU;\n-      Dependency_Options   : Name_List_Index := No_Name_List;\n-      Compute_Dependencies : Name_List_Index := No_Name_List;\n-      Include_Options      : Name_List_Index := No_Name_List;\n-      Binder_Drivers       : Name_Id         := No_Name;\n-      Binder_Driver_Paths  : Name_Id         := No_Name;\n-   end record;\n-\n-   Default_Language_Processing_Data :\n-     constant Language_Processing_Data :=\n-       (Compiler_Drivers     => No_Name_List,\n-        Compiler_Paths       => No_Name,\n-        Compiler_Kinds       => GNU,\n-        Dependency_Options   => No_Name_List,\n-        Compute_Dependencies => No_Name_List,\n-        Include_Options      => No_Name_List,\n-        Binder_Drivers       => No_Name,\n-        Binder_Driver_Paths  => No_Name);\n-\n-   type First_Language_Processing_Data is\n-     array (First_Language_Indexes) of Language_Processing_Data;\n-\n-   Default_First_Language_Processing_Data :\n-      constant First_Language_Processing_Data :=\n-                 (others => Default_Language_Processing_Data);\n-\n-   type Supp_Language_Data is record\n-      Index : Language_Index := No_Language_Index;\n-      Data  : Language_Processing_Data := Default_Language_Processing_Data;\n-      Next  : Supp_Language_Index := No_Supp_Language_Index;\n-   end record;\n-\n-   package Supp_Language_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Supp_Language_Data,\n-      Table_Index_Type     => Supp_Language_Index,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 4,\n-      Table_Increment      => 100);\n-   --  The table for language data when there are more languages than\n-   --  in First_Language_Indexes.\n-\n-   type Other_Source_Id is new Nat;\n-   No_Other_Source : constant Other_Source_Id := 0;\n-\n-   type Other_Source is record\n-      Language         : Language_Index;       --  language of the source\n-      File_Name        : File_Name_Type;       --  source file simple name\n-      Path_Name        : Path_Name_Type;       --  source full path name\n-      Source_TS        : Time_Stamp_Type;      --  source file time stamp\n-      Object_Name      : File_Name_Type;       --  object file simple name\n-      Object_Path      : Path_Name_Type;       --  object full path name\n-      Object_TS        : Time_Stamp_Type;      --  object file time stamp\n-      Dep_Name         : File_Name_Type;       --  dependency file simple name\n-      Dep_Path         : Path_Name_Type;       --  dependency full path name\n-      Dep_TS           : Time_Stamp_Type;      --  dependency file time stamp\n-      Naming_Exception : Boolean := False;     --  True if a naming exception\n-      Next             : Other_Source_Id := No_Other_Source;\n-   end record;\n-   --  Data for a source in a language other than Ada\n-\n-   package Other_Source_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Other_Source,\n-      Table_Index_Type     => Other_Source_Id,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 200,\n-      Table_Increment      => 100);\n-   --  The table for sources of languages other than Ada\n-\n    --  The following record contains data for a naming scheme\n \n    type Naming_Data is record\n@@ -1044,10 +883,6 @@ package Prj is\n       --  An associative array listing body file names that do not have the\n       --  body suffix. Not used by Ada. Indexed by programming language name.\n \n-      --  For gprmake:\n-\n-      Impl_Suffixes : Impl_Suffix_Array   := No_Impl_Suffixes;\n-      Supp_Suffixes : Supp_Language_Index := No_Supp_Language_Index;\n    end record;\n \n    function Spec_Suffix_Of\n@@ -1407,6 +1242,12 @@ package Prj is\n       -- Sources --\n       -------------\n \n+      Ada_Sources_Present : Boolean := True;\n+      --  True if there are Ada sources in the project\n+\n+      Other_Sources_Present : Boolean := True;\n+      --  True if there are non-Ada sources in the project\n+\n       Ada_Sources : String_List_Id := Nil_String;\n       --  The list of all the Ada source file names (gnatmake only)\n \n@@ -1515,32 +1356,6 @@ package Prj is\n       --  True if there are comments in the project sources that cannot be kept\n       --  in the project tree.\n \n-      ------------------\n-      --  For gprmake --\n-      ------------------\n-\n-      Langs          : Languages_In_Project := No_Languages;\n-      Supp_Languages : Supp_Language_Index  := No_Supp_Language_Index;\n-      --  Indicate the different languages of the source of this project\n-\n-      Ada_Sources_Present : Boolean := True;\n-      --  True if there are Ada sources in the project\n-\n-      Other_Sources_Present : Boolean := True;\n-      --  True if there are sources from languages other than Ada in the\n-      --  project.\n-\n-      First_Other_Source : Other_Source_Id := No_Other_Source;\n-      --  First source of a language other than Ada\n-\n-      Last_Other_Source : Other_Source_Id := No_Other_Source;\n-      --  Last source of a language other than Ada\n-\n-      First_Lang_Processing    : First_Language_Processing_Data :=\n-                                   Default_First_Language_Processing_Data;\n-      Supp_Language_Processing : Supp_Language_Index :=\n-                                   No_Supp_Language_Index;\n-      --  Language configurations\n    end record;\n \n    function Empty_Project (Tree : Project_Tree_Ref) return Project_Data;\n@@ -1664,13 +1479,6 @@ package Prj is\n          Files_HT          : Files_Htable.Instance;\n          Source_Paths_HT   : Source_Paths_Htable.Instance;\n \n-         --  For gprmake:\n-\n-         Present_Languages : Present_Language_Table.Instance;\n-         Supp_Suffixes     : Supp_Suffix_Table.Instance;\n-         Supp_Languages    : Supp_Language_Table.Instance;\n-         Other_Sources     : Other_Source_Table.Instance;\n-\n          --  Private part\n \n          Private_Part : Private_Project_Tree_Data;\n@@ -1743,59 +1551,6 @@ package Prj is\n      (Source_File_Name : File_Name_Type) return File_Name_Type;\n    --  Returns the switches file name corresponding to a source file name\n \n-   --  For gprmake\n-\n-   function Body_Suffix_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return String;\n-   --  Returns the suffix of sources of language Language in project In_Project\n-   --  in project tree In_Tree.\n-\n-   function Is_Present\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return Boolean;\n-   --  Return True when Language is one of the languages used in\n-   --  project In_Project.\n-\n-   procedure Set\n-     (Language   : Language_Index;\n-      Present    : Boolean;\n-      In_Project : in out Project_Data;\n-      In_Tree    : Project_Tree_Ref);\n-   --  Indicate if Language is or not a language used in project In_Project\n-\n-   function Language_Processing_Data_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return Language_Processing_Data;\n-   --  Return the Language_Processing_Data for language Language in project\n-   --  In_Project. Return the default when no Language_Processing_Data are\n-   --  defined for the language.\n-\n-   procedure Set\n-     (Language_Processing : Language_Processing_Data;\n-      For_Language        : Language_Index;\n-      In_Project          : in out Project_Data;\n-      In_Tree             : Project_Tree_Ref);\n-   --  Set the Language_Processing_Data for language Language in project\n-   --  In_Project.\n-\n-   function Suffix_Of\n-     (Language   : Language_Index;\n-      In_Project : Project_Data;\n-      In_Tree    : Project_Tree_Ref) return File_Name_Type;\n-   --  Return the suffix for language Language in project In_Project. Return\n-   --  No_Name when no suffix is defined for the language.\n-\n-   procedure Set\n-     (Suffix       : File_Name_Type;\n-      For_Language : Language_Index;\n-      In_Project   : in out Project_Data;\n-      In_Tree      : Project_Tree_Ref);\n-   --  Set the suffix for language Language in project In_Project\n-\n    ----------------\n    -- Temp Files --\n    ----------------"}]}