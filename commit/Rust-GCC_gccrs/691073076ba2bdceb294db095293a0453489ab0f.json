{"sha": "691073076ba2bdceb294db095293a0453489ab0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkxMDczMDc2YmEyYmRjZWIyOTRkYjA5NTI5M2EwNDUzNDg5YWIwZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-04-12T03:41:36Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-04-12T03:41:36Z"}, "message": "expmed.c (store_bit_field): Truncate CONST_INTs.\n\n* expmed.c (store_bit_field): Truncate CONST_INTs.\n(expand_mult_highpart, expand_divmod): Likewise.\n* expr.c (convert_modes, store_field): Likewise.\n* integrate.c (expand_inline_function): Use promote_mode() to\ndetermine whether to convert_modes() an argument as signed\nor unsigned.\n* optabs.c (expand_binop): Get CONST_INT operands\nsign-extended for their appropriate modes.\n* stmt.c (emit_case_nodes): Convert node values to the\nappropriate mode.\n(expand_end_case): Convert minval and range to the appropriate\nmode.\n* unroll.c (loop_iterations): Truncate abs_diff to the mode of\nthe iteration variable.\n* varasm.c (immed_double_const): Don't require words to be\nnarrower than host wide ints to properly sign-extend\nCONST_INTs.\n\nFrom-SVN: r41285", "tree": {"sha": "943b9fe0140e410d24c23703edfa24a7154c671e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/943b9fe0140e410d24c23703edfa24a7154c671e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/691073076ba2bdceb294db095293a0453489ab0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691073076ba2bdceb294db095293a0453489ab0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/691073076ba2bdceb294db095293a0453489ab0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/691073076ba2bdceb294db095293a0453489ab0f/comments", "author": null, "committer": null, "parents": [{"sha": "001643af8038ea54c0fdf32ce0cc570fafed0c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/001643af8038ea54c0fdf32ce0cc570fafed0c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/001643af8038ea54c0fdf32ce0cc570fafed0c2c"}], "stats": {"total": 241, "additions": 181, "deletions": 60}, "files": [{"sha": "83ec61933ce865cd36e9a091256af79d0f649f6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -1,3 +1,23 @@\n+2001-04-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* expmed.c (store_bit_field): Truncate CONST_INTs.\n+\t(expand_mult_highpart, expand_divmod): Likewise.\n+\t* expr.c (convert_modes, store_field): Likewise.\n+\t* integrate.c (expand_inline_function): Use promote_mode() to\n+\tdetermine whether to convert_modes() an argument as signed\n+\tor unsigned.\n+\t* optabs.c (expand_binop): Get CONST_INT operands\n+\tsign-extended for their appropriate modes.\n+\t* stmt.c (emit_case_nodes): Convert node values to the\n+\tappropriate mode.\n+\t(expand_end_case): Convert minval and range to the appropriate\n+\tmode.\n+\t* unroll.c (loop_iterations): Truncate abs_diff to the mode of\n+\tthe iteration variable.\n+\t* varasm.c (immed_double_const): Don't require words to be\n+\tnarrower than host wide ints to properly sign-extend\n+\tCONST_INTs.\n+\n 2001-04-12  kaz Kojima  <kkojima@rr.iij4u.or.jp>\n \n \t* sh.md (builtin_setjmp_receiver): New expander."}, {"sha": "b2396ae9bd94f85bf5d5f421f8bec1cc9b62007a", "filename": "gcc/expmed.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -592,6 +592,8 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t      else\n \t\tvalue1 = gen_lowpart (maxmode, value1);\n \t    }\n+\t  else if (GET_CODE (value) == CONST_INT)\n+\t    value1 = GEN_INT (trunc_int_for_mode (INTVAL (value), maxmode));\n \t  else if (!CONSTANT_P (value))\n \t    /* Parse phase is supposed to make VALUE's data type\n \t       match that of the component reference, which is a type\n@@ -2787,7 +2789,7 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   if (size > HOST_BITS_PER_WIDE_INT)\n     abort ();\n \n-  op1 = GEN_INT (cnst1);\n+  op1 = GEN_INT (trunc_int_for_mode (cnst1, mode));\n \n   if (GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n     wide_op1 = op1;\n@@ -3274,7 +3276,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\tif (rem_flag && d < 0)\n \t\t  {\n \t\t    d = abs_d;\n-\t\t    op1 = GEN_INT (abs_d);\n+\t\t    op1 = GEN_INT (trunc_int_for_mode (abs_d, compute_mode));\n \t\t  }\n \n \t\tif (d == 1)\n@@ -3304,7 +3306,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\tt1 = copy_to_mode_reg (compute_mode, op0);\n \t\t\tdo_cmp_and_jump (t1, const0_rtx, GE,\n \t\t\t\t\t compute_mode, label);\n-\t\t\texpand_inc (t1, GEN_INT (abs_d - 1));\n+\t\t\texpand_inc (t1, GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t\t (abs_d - 1, compute_mode)));\n \t\t\temit_label (label);\n \t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n \t\t\t\t\t\t build_int_2 (lgup, 0),\n@@ -3341,7 +3344,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t  \t\t       REG_EQUAL,\n \t\t\t\t\t       gen_rtx_DIV (compute_mode,\n \t\t\t\t\t\t\t    op0,\n-\t\t\t\t\t\t\t    GEN_INT (abs_d)));\n+\t\t\t\t\t\t\t    GEN_INT\n+\t\t\t\t\t\t\t    (trunc_int_for_mode\n+\t\t\t\t\t\t\t     (abs_d,\n+\t\t\t\t\t\t\t      compute_mode))));\n \n \t\t\tquotient = expand_unop (compute_mode, neg_optab,\n \t\t\t\t\t\tquotient, quotient, 0);\n@@ -3840,8 +3846,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t    ml = invert_mod2n (d >> pre_shift, size);\n \t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t       build_int_2 (pre_shift, 0), NULL_RTX, unsignedp);\n-\t    quotient = expand_mult (compute_mode, t1, GEN_INT (ml), NULL_RTX,\n-\t\t\t      \t    0);\n+\t    quotient = expand_mult (compute_mode, t1,\n+\t\t\t\t    GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t     (ml, compute_mode)),\n+\t\t\t\t    NULL_RTX, 0);\n \n \t    insn = get_last_insn ();\n \t    set_unique_reg_note (insn,"}, {"sha": "970c275cde5026dfb58b9ebe8c8c91b5b26ebb17", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -1360,7 +1360,7 @@ convert_modes (mode, oldmode, x, unsignedp)\n \t      && (val & ((HOST_WIDE_INT) 1 << (width - 1))))\n \t    val |= (HOST_WIDE_INT) (-1) << width;\n \n-\t  return GEN_INT (val);\n+\t  return GEN_INT (trunc_int_for_mode (val, mode));\n \t}\n \n       return gen_lowpart (mode, x);\n@@ -5268,7 +5268,13 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \t      enum machine_mode tmode;\n \n \t      if (unsignedp)\n-\t\treturn expand_and (temp, GEN_INT (width_mask), NULL_RTX);\n+\t\treturn expand_and (temp,\n+\t\t\t\t   GEN_INT\n+\t\t\t\t   (trunc_int_for_mode\n+\t\t\t\t    (width_mask,\n+\t\t\t\t     GET_MODE (temp) == VOIDmode\n+\t\t\t\t     ? value_mode\n+\t\t\t\t     : GET_MODE (temp))), NULL_RTX);\n \t      tmode = GET_MODE (temp);\n \t      if (tmode == VOIDmode)\n \t\ttmode = value_mode;"}, {"sha": "1955c0511bdd101ceac61bd2004ee7d909f21be3", "filename": "gcc/integrate.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -702,13 +702,24 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       else if (GET_CODE (loc) != MEM)\n \t{\n \t  if (GET_MODE (loc) != TYPE_MODE (TREE_TYPE (arg)))\n-\t    /* The mode if LOC and ARG can differ if LOC was a variable\n-\t       that had its mode promoted via PROMOTED_MODE.  */\n-\t    arg_vals[i] = convert_modes (GET_MODE (loc),\n-\t\t\t\t\t TYPE_MODE (TREE_TYPE (arg)),\n-\t\t\t\t\t expand_expr (arg, NULL_RTX, mode,\n-\t\t\t\t\t\t      EXPAND_SUM),\n-\t\t\t\t\t TREE_UNSIGNED (TREE_TYPE (formal)));\n+\t    {\n+\t      int unsignedp = TREE_UNSIGNED (TREE_TYPE (formal));\n+\t      enum machine_mode pmode = TYPE_MODE (TREE_TYPE (formal));\n+\n+\t      pmode = promote_mode (TREE_TYPE (formal), pmode,\n+\t\t\t\t    &unsignedp, 0);\n+\n+\t      if (GET_MODE (loc) != pmode)\n+\t\tabort ();\n+\n+\t      /* The mode if LOC and ARG can differ if LOC was a variable\n+\t\t that had its mode promoted via PROMOTED_MODE.  */\n+\t      arg_vals[i] = convert_modes (pmode,\n+\t\t\t\t\t   TYPE_MODE (TREE_TYPE (arg)),\n+\t\t\t\t\t   expand_expr (arg, NULL_RTX, mode,\n+\t\t\t\t\t\t\tEXPAND_SUM),\n+\t\t\t\t\t   unsignedp);\n+\t    }\n \t  else\n \t    arg_vals[i] = expand_expr (arg, NULL_RTX, mode, EXPAND_SUM);\n \t}"}, {"sha": "4f30779ec43de3e32de9f910a86e7f2aba4e1ae8", "filename": "gcc/optabs.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -723,17 +723,25 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t}\n \n       /* In case the insn wants input operands in modes different from\n-\t the result, convert the operands.  */\n+\t the result, convert the operands.  It would seem that we\n+\t don't need to convert CONST_INTs, but we do, so that they're\n+\t a properly sign-extended for their modes.  */\n \n-      if (GET_MODE (op0) != VOIDmode\n-\t  && GET_MODE (op0) != mode0\n+      if (GET_MODE (op0) != mode0\n \t  && mode0 != VOIDmode)\n-\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n+\txop0 = convert_modes (mode0,\n+\t\t\t      GET_MODE (op0) != VOIDmode\n+\t\t\t      ? GET_MODE (op0)\n+\t\t\t      : mode0,\n+\t\t\t      xop0, unsignedp);\n \n-      if (GET_MODE (xop1) != VOIDmode\n-\t  && GET_MODE (xop1) != mode1\n+      if (GET_MODE (xop1) != mode1\n \t  && mode1 != VOIDmode)\n-\txop1 = convert_to_mode (mode1, xop1, unsignedp);\n+\txop1 = convert_modes (mode1,\n+\t\t\t      GET_MODE (op1) != VOIDmode\n+\t\t\t      ? GET_MODE (op1)\n+\t\t\t      : mode1,\n+\t\t\t      xop1, unsignedp);\n \n       /* Now, if insn's predicates don't allow our operands, put them into\n \t pseudo regs.  */\n@@ -4295,7 +4303,9 @@ expand_fix (to, from, unsignedp)\n \t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  expand_fix (to, target, 0);\n \t  target = expand_binop (GET_MODE (to), xor_optab, to,\n-\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1 << (bitsize - 1)),\n+\t\t\t\t GEN_INT (trunc_int_for_mode\n+\t\t\t\t\t  ((HOST_WIDE_INT) 1 << (bitsize - 1),\n+\t\t\t\t\t   GET_MODE (to))),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n \n \t  if (target != to)"}, {"sha": "9b706061217030c6b7725c0e9cb98faf414ac42e", "filename": "gcc/stmt.c", "status": "modified", "additions": 100, "deletions": 36, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -1,6 +1,6 @@\n /* Expands front end tree to back end RTL for GNU C-Compiler\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -5474,13 +5474,17 @@ expand_end_case (orig_index)\n \t      op1 = expand_expr (minval, NULL_RTX, VOIDmode, 0);\n \n \t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n+\t      op1 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (minval)),\n+\t\t\t\t   op1, TREE_UNSIGNED (TREE_TYPE (minval)));\n \t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n \t\t  (op1, op_mode))\n \t\top1 = copy_to_mode_reg (op_mode, op1);\n \n \t      op2 = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n \t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n+\t      op2 = convert_modes (op_mode, TYPE_MODE (TREE_TYPE (range)),\n+\t\t\t\t   op2, TREE_UNSIGNED (TREE_TYPE (range)));\n \t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n \t\t  (op2, op_mode))\n \t\top2 = copy_to_mode_reg (op_mode, op2);\n@@ -5503,7 +5507,11 @@ expand_end_case (orig_index)\n \t      do_pending_stack_adjust ();\n \n \t      do_tablejump (index, TYPE_MODE (index_type),\n-\t\t\t    expand_expr (range, NULL_RTX, VOIDmode, 0),\n+\t\t\t    convert_modes (TYPE_MODE (index_type),\n+\t\t\t\t\t   TYPE_MODE (TREE_TYPE (range)),\n+\t\t\t\t\t   expand_expr (range, NULL_RTX,\n+\t\t\t\t\t\t\tVOIDmode, 0),\n+\t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (range))),\n \t\t\t    table_label, default_label);\n \t      win = 1;\n \t    }\n@@ -6027,6 +6035,7 @@ emit_case_nodes (index, node, default_label, index_type)\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n   int unsignedp = TREE_UNSIGNED (index_type);\n   enum machine_mode mode = GET_MODE (index);\n+  enum machine_mode imode = TYPE_MODE (index_type);\n \n   /* See if our parents have already tested everything for us.\n      If they have, emit an unconditional jump for this node.  */\n@@ -6038,7 +6047,11 @@ emit_case_nodes (index, node, default_label, index_type)\n       /* Node is single valued.  First see if the index expression matches\n \t this node and then check our children, if any.  */\n \n-      do_jump_if_equal (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n+      do_jump_if_equal (index,\n+\t\t\tconvert_modes (mode, imode,\n+\t\t\t\t       expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       unsignedp),\n \t\t\tlabel_rtx (node->code_label), unsignedp);\n \n       if (node->right != 0 && node->left != 0)\n@@ -6052,8 +6065,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  if (node_is_bounded (node->right, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (node->right->code_label));\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n@@ -6062,8 +6078,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  else if (node_is_bounded (node->left, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (node->left->code_label));\n \t      emit_case_nodes (index, node->right, default_label, index_type);\n@@ -6078,8 +6097,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t      /* See if the value is on the right.  */\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (test_label));\n \n@@ -6110,8 +6132,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n \t\t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t\t   expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\tVOIDmode, 0),\n+\t\t\t\t\t   convert_modes\n+\t\t\t\t\t   (mode, imode,\n+\t\t\t\t\t    expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t\t    unsignedp),\n \t\t\t\t\t   LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t\t   default_label);\n \t\t}\n@@ -6123,8 +6148,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->right explicitly.  */\n \t    do_jump_if_equal (index,\n-\t\t\t      expand_expr (node->right->low, NULL_RTX,\n-\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t      convert_modes\n+\t\t\t      (mode, imode,\n+\t\t\t       expand_expr (node->right->low, NULL_RTX,\n+\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t       unsignedp),\n \t\t\t      label_rtx (node->right->code_label), unsignedp);\n \t}\n \n@@ -6150,9 +6178,12 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_high_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_and_jump_insns (index, expand_expr (node->high,\n-\t\t\t\t\t\t\t       NULL_RTX,\n-\t\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t  emit_cmp_and_jump_insns (index,\n+\t\t\t\t\t   convert_modes\n+\t\t\t\t\t   (mode, imode,\n+\t\t\t\t\t    expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t\t    unsignedp),\n \t\t\t\t\t   GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t\t   default_label);\n \t\t}\n@@ -6164,8 +6195,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->left explicitly.  */\n \t    do_jump_if_equal (index,\n-\t\t\t      expand_expr (node->left->low, NULL_RTX,\n-\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t      convert_modes\n+\t\t\t      (mode, imode,\n+\t\t\t       expand_expr (node->left->low, NULL_RTX,\n+\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t       unsignedp),\n \t\t\t      label_rtx (node->left->code_label), unsignedp);\n \t}\n     }\n@@ -6187,8 +6221,12 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  if (node_is_bounded (node->right, index_type))\n \t    /* Right hand node is fully bounded so we can eliminate any\n \t       testing and branch directly to the target code.  */\n-\t    emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t VOIDmode, 0),\n+\t    emit_cmp_and_jump_insns (index,\n+\t\t\t\t     convert_modes\n+\t\t\t\t     (mode, imode,\n+\t\t\t\t      expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t      unsignedp),\n \t\t\t\t     GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t     label_rtx (node->right->code_label));\n \t  else\n@@ -6198,16 +6236,23 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t      test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (test_label));\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t       VOIDmode, 0),\n+\t  emit_cmp_and_jump_insns (index,\n+\t\t\t\t   convert_modes\n+\t\t\t\t   (mode, imode,\n+\t\t\t\t    expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t    unsignedp),\n \t\t\t\t   GE, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t   label_rtx (node->code_label));\n \n@@ -6234,16 +6279,23 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n \n \t  /* Value belongs to this node or to the right-hand subtree.  */\n \n-\t  emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t       VOIDmode, 0),\n+\t  emit_cmp_and_jump_insns (index,\n+\t\t\t\t   convert_modes\n+\t\t\t\t   (mode, imode,\n+\t\t\t\t    expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t    unsignedp),\n \t\t\t\t   LE, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t   label_rtx (node->code_label));\n \n@@ -6257,17 +6309,23 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n \t  emit_cmp_and_jump_insns (index,\n-\t\t\t\t   expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\tVOIDmode, 0),\n+\t\t\t\t   convert_modes\n+\t\t\t\t   (mode, imode,\n+\t\t\t\t    expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t    unsignedp),\n \t\t\t\t   GE, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t   label_rtx (node->code_label));\n \n@@ -6283,17 +6341,23 @@ emit_case_nodes (index, node, default_label, index_type)\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n \n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n \t      emit_cmp_and_jump_insns (index,\n-\t\t\t\t       expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       convert_modes\n+\t\t\t\t       (mode, imode,\n+\t\t\t\t\texpand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t\tunsignedp),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }"}, {"sha": "52de4996bd4d0532168b5d2882ada11bfa49b0ce", "filename": "gcc/unroll.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -3962,6 +3962,8 @@ loop_iterations (loop)\n   else\n     abort ();\n \n+  abs_diff = trunc_int_for_mode (abs_diff, GET_MODE (iteration_var));\n+\n   /* For NE tests, make sure that the iteration variable won't miss\n      the final value.  If abs_diff mod abs_incr is not zero, then the\n      iteration variable will overflow before the loop exits, and we"}, {"sha": "a803fe174ad876c9df0e2f73222b5a04d654b83e", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/691073076ba2bdceb294db095293a0453489ab0f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=691073076ba2bdceb294db095293a0453489ab0f", "patch": "@@ -1984,7 +1984,7 @@ immed_double_const (i0, i1, mode)\n \t represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n \t The later confuses the sparc backend.  */\n \n-      if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n+      if (width < HOST_BITS_PER_WIDE_INT\n \t  && (i0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n \ti0 |= ((HOST_WIDE_INT) (-1) << width);\n "}]}