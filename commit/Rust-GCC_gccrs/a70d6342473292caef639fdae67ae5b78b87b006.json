{"sha": "a70d6342473292caef639fdae67ae5b78b87b006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcwZDYzNDI0NzMyOTJjYWVmNjM5ZmRhZTY3YWU1Yjc4Yjg3YjAwNg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-05-24T08:44:56Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-05-24T08:44:56Z"}, "message": "passes.texi (Tree-SSA passes): Document SLP pass.\n\n\n\t* doc/passes.texi (Tree-SSA passes): Document SLP pass.\n\t* tree-pass.h (pass_slp_vectorize): New pass.\n\t* params.h (SLP_MAX_INSNS_IN_BB): Define.\n\t* timevar.def (TV_TREE_SLP_VECTORIZATION): Define.\n\t* tree-vectorizer.c (timevar.h): Include.\n\t(user_vect_verbosity_level): Declare.\n\t(vect_location): Fix comment.\n\t(vect_set_verbosity_level): Update user_vect_verbosity_level\n\tinstead of vect_verbosity_level.\n\t(vect_set_dump_settings): Add an argument. Ignore user defined\n\tverbosity if dump flags require higher level of verbosity. Print to\n\tstderr only for loop vectorization.\n\t(vectorize_loops): Update call to vect_set_dump_settings.\n\t(execute_vect_slp): New function.\n\t(gate_vect_slp): Likewise.\n\t(struct gimple_opt_pass pass_slp_vectorize): New.\n\t* tree-vectorizer.h (struct _bb_vec_info): Define along macros to\n\taccess its members.\n\t(vec_info_for_bb): New function.\n\t(struct _stmt_vec_info): Add bb_vinfo and a macro for its access.\n\t(VECTORIZATION_ENABLED): New macro.\n\t(SLP_ENABLED, SLP_DISABLED): Likewise.\n\t(vect_is_simple_use): Add bb_vec_info argument.\n\t(new_stmt_vec_info, vect_analyze_data_ref_dependences,\n\tvect_analyze_data_refs_alignment, vect_verify_datarefs_alignment,\n\tvect_analyze_data_ref_accesses, vect_analyze_data_refs,\n\tvect_schedule_slp, vect_analyze_slp): Likewise.\n\t(vect_analyze_stmt): Add slp_tree argument.\n\t(find_bb_location): Declare.\n\t(vect_slp_analyze_bb, vect_slp_transform_bb): Likewise.\n\t* tree-vect-loop.c (new_loop_vec_info): Adjust function calls.\n\t(vect_analyze_loop_operations, vect_analyze_loop,\n\tget_initial_def_for_induction, vect_create_epilog_for_reduction,\n\tvect_finalize_reduction, vectorizable_reduction,\n\tvectorizable_live_operation, vect_transform_loop): Likewise.\n\t* tree-data-ref.c (dr_analyze_innermost): Update comment,\n\tskip evolution analysis if analyzing a basic block.\n\t(dr_analyze_indices): Likewise.\n\t(initialize_data_dependence_relation): Skip the test whether the\n\tobject is invariant for basic blocks.\n\t(compute_all_dependences): Skip dependence analysis for data\n\treferences in basic blocks.\n\t(find_data_references_in_stmt): Don't fail in case of invariant\n\taccess in basic block.\n\t(find_data_references_in_bb): New function.\n\t(find_data_references_in_loop): Move code to\n\tfind_data_references_in_bb    and add a call to it.\n\t(compute_data_dependences_for_bb): New function.\n\t* tree-data-ref.h (compute_data_dependences_for_bb): Declare.\n\t* tree-vect-data-refs.c (vect_check_interleaving): Adjust to the case\n\tthat STEP is 0.\n\t(vect_analyze_data_ref_dependence): Check for interleaving in case of\n\tunknown dependence in basic block and fail in case of dependence in\n\tbasic block.\n\t(vect_analyze_data_ref_dependences): Add bb_vinfo argument, get data\n\tdependence instances from either loop or basic block vectorization\n\tinfo.\n\t(vect_compute_data_ref_alignment): Check if it is loop vectorization\n\tbefore calling nested_in_vect_loop_p.\n\t(vect_compute_data_refs_alignment): Add bb_vinfo argument, get data\n\tdependence instances from either loop or basic block vectorization\n\tinfo.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t(vect_enhance_data_refs_alignment): Adjust function calls.\n\t(vect_analyze_data_refs_alignment): Likewise.\n\t(vect_analyze_group_access): Fix printing. Skip different checks if\n\tDR_STEP is 0. Keep strided stores either in loop or basic block\n\tvectorization data structure. Fix indentation.\n\t(vect_analyze_data_ref_access): Fix comments, allow zero step in\n\tbasic blocks.\n\t(vect_analyze_data_ref_accesses): Add bb_vinfo argument, get data\n\tdependence instances from either loop or basic block vectorization\n\tinfo.\n\t(vect_analyze_data_refs): Update comment. Call\n\tcompute_data_dependences_for_bb to analyze basic blocks.\n\t(vect_create_addr_base_for_vector_ref): Check for outer loop only in\n\tcase of loop vectorization. In case of basic block vectorization use\n\tdata-ref itself   as  a base.\n\t(vect_create_data_ref_ptr): In case of basic block vectorization:\n\tdon't advance the pointer, add new statements before the current\n\tstatement.  Adjust function calls.\n\t(vect_supportable_dr_alignment): Support only aligned accesses in\n\tbasic block vectorization.\n\t* common.opt (ftree-slp-vectorize): New flag.\n\t* tree-vect-patterns.c (widened_name_p): Adjust function calls.\n\t(vect_pattern_recog_1): Likewise.\n\t* tree-vect-stmts.c (process_use): Likewise.\n\t(vect_init_vector): Add new statements in the beginning of the basic\n\tblock in case of basic block SLP.\n\t(vect_get_vec_def_for_operand): Adjust function calls.\n\t(vect_finish_stmt_generation): Likewise.\n\t(vectorizable_call): Add assert that it is loop vectorization, adjust\n\tfunction calls.\n\t(vectorizable_conversion, vectorizable_assignment): Likewise.\n\t(vectorizable_operation): In case of basic block SLP, take\n\tvectorization factor from statement's type and skip the relevance\n\tcheck. Adjust function calls.\n\t(vectorizable_type_demotion): Add assert that it is loop\n\tvectorization, adjust function calls.\n\t(vectorizable_type_promotion): Likewise.\n\t(vectorizable_store): Check for outer loop only in case of loop\n\tvectorization. Adjust function calls. For basic blocks, skip the\n\trelevance check and don't advance pointers.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Add assert that it is loop vectorization,\n\tadjust function calls.\n\t(vect_analyze_stmt): Add argument. In case of basic block SLP, check\n\tthat it is not reduction, get vector type, call only supported\n\tfunctions, skip loop    specific parts.\n\t(vect_transform_stmt): Check for outer loop only in case of loop\n\tvectorization.\n\t(new_stmt_vec_info): Add new argument and initialize bb_vinfo.\n\t(vect_is_simple_use): Fix comment, add new argument, fix conditions\n\tfor external definition.\n\t* passes.c (pass_slp_vectorize): New pass.\n\t* tree-vect-slp.c (find_bb_location): New function.\n\t(vect_get_and_check_slp_defs): Add argument, adjust function calls,\n\tcheck for patterns only in loops.\n\t(vect_build_slp_tree): Add argument, adjust function calls, fail in\n\tcase of multiple types in basic block SLP.\n\t(vect_mark_slp_stmts_relevant): New function.\n\t(vect_supported_load_permutation_p): Fix comment.\n\t(vect_analyze_slp_instance): Add argument. In case of basic block\n\tSLP, take vectorization factor from statement's type, check that\n\tunrolling factor is 1. Adjust function call. Save SLP instance in\n\teither loop or basic block vectorization structure. Return FALSE,\n\tif SLP failed.\n\t(vect_analyze_slp): Add argument. Get strided stores groups from\n\teither loop or basic block vectorization structure. Return FALSE\n\tif basic block SLP failed.\n\t(new_bb_vec_info): New function.\n\t(destroy_bb_vec_info, vect_slp_analyze_node_operations,\n\tvect_slp_analyze_operations, vect_slp_analyze_bb): Likewise.\n\t(vect_schedule_slp): Add argument. Get SLP instances from either\n\tloop or basic block vectorization structure. Set vectorization factor\n\tto be 1 for basic block SLP.\n\t(vect_slp_transform_bb): New function.\n\t* params.def (PARAM_SLP_MAX_INSNS_IN_BB): Define.\n\nFrom-SVN: r147829", "tree": {"sha": "da9d0140b9b9e4e0d76c968aefa90a9a14c95470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da9d0140b9b9e4e0d76c968aefa90a9a14c95470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a70d6342473292caef639fdae67ae5b78b87b006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70d6342473292caef639fdae67ae5b78b87b006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a70d6342473292caef639fdae67ae5b78b87b006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a70d6342473292caef639fdae67ae5b78b87b006/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ffa52e113dd467e6a15b2843748b1bac203eb7bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa52e113dd467e6a15b2843748b1bac203eb7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa52e113dd467e6a15b2843748b1bac203eb7bc"}], "stats": {"total": 2869, "additions": 2563, "deletions": 306}, "files": [{"sha": "19fc0b6bee7b8e7f552fab6572813a70d49452c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -1,3 +1,144 @@\n+2009-05-24  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* doc/passes.texi (Tree-SSA passes): Document SLP pass.\n+\t* tree-pass.h (pass_slp_vectorize): New pass.\n+\t* params.h (SLP_MAX_INSNS_IN_BB): Define.\n+\t* timevar.def (TV_TREE_SLP_VECTORIZATION): Define.\n+\t* tree-vectorizer.c (timevar.h): Include.\n+\t(user_vect_verbosity_level): Declare.\n+\t(vect_location): Fix comment.\n+\t(vect_set_verbosity_level): Update user_vect_verbosity_level\n+\tinstead of vect_verbosity_level.\n+\t(vect_set_dump_settings): Add an argument. Ignore user defined\n+\tverbosity if dump flags require higher level of verbosity. Print to\n+\tstderr only for loop vectorization.\n+\t(vectorize_loops): Update call to vect_set_dump_settings.\n+\t(execute_vect_slp): New function.\n+\t(gate_vect_slp): Likewise.\n+\t(struct gimple_opt_pass pass_slp_vectorize): New.\n+\t* tree-vectorizer.h (struct _bb_vec_info): Define along macros to\n+\taccess its members.\n+\t(vec_info_for_bb): New function.\n+\t(struct _stmt_vec_info): Add bb_vinfo and a macro for its access.\n+\t(VECTORIZATION_ENABLED): New macro.\n+\t(SLP_ENABLED, SLP_DISABLED): Likewise.\n+\t(vect_is_simple_use): Add bb_vec_info argument.\n+\t(new_stmt_vec_info, vect_analyze_data_ref_dependences,\n+\tvect_analyze_data_refs_alignment, vect_verify_datarefs_alignment,\n+\tvect_analyze_data_ref_accesses, vect_analyze_data_refs,\n+\tvect_schedule_slp, vect_analyze_slp): Likewise.\n+\t(vect_analyze_stmt): Add slp_tree argument.\n+\t(find_bb_location): Declare.\n+\t(vect_slp_analyze_bb, vect_slp_transform_bb): Likewise.\n+\t* tree-vect-loop.c (new_loop_vec_info): Adjust function calls.\n+\t(vect_analyze_loop_operations, vect_analyze_loop,\n+\tget_initial_def_for_induction, vect_create_epilog_for_reduction,\n+\tvect_finalize_reduction, vectorizable_reduction,\n+\tvectorizable_live_operation, vect_transform_loop): Likewise.\n+\t* tree-data-ref.c (dr_analyze_innermost): Update comment,\n+\tskip evolution analysis if analyzing a basic block.\n+\t(dr_analyze_indices): Likewise.\n+\t(initialize_data_dependence_relation): Skip the test whether the\n+\tobject is invariant for basic blocks.\n+\t(compute_all_dependences): Skip dependence analysis for data\n+\treferences in basic blocks.\n+\t(find_data_references_in_stmt): Don't fail in case of invariant\n+\taccess in basic block.\n+\t(find_data_references_in_bb): New function.\n+\t(find_data_references_in_loop): Move code to\n+\tfind_data_references_in_bb    and add a call to it.\n+\t(compute_data_dependences_for_bb): New function.\n+\t* tree-data-ref.h (compute_data_dependences_for_bb): Declare.\n+\t* tree-vect-data-refs.c (vect_check_interleaving): Adjust to the case\n+\tthat STEP is 0.\n+\t(vect_analyze_data_ref_dependence): Check for interleaving in case of\n+\tunknown dependence in basic block and fail in case of dependence in\n+\tbasic block.\n+\t(vect_analyze_data_ref_dependences): Add bb_vinfo argument, get data\n+\tdependence instances from either loop or basic block vectorization\n+\tinfo.\n+\t(vect_compute_data_ref_alignment): Check if it is loop vectorization\n+\tbefore calling nested_in_vect_loop_p.\n+\t(vect_compute_data_refs_alignment): Add bb_vinfo argument, get data\n+\tdependence instances from either loop or basic block vectorization\n+\tinfo.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t(vect_enhance_data_refs_alignment): Adjust function calls.\n+\t(vect_analyze_data_refs_alignment): Likewise.\n+\t(vect_analyze_group_access): Fix printing. Skip different checks if\n+\tDR_STEP is 0. Keep strided stores either in loop or basic block\n+\tvectorization data structure. Fix indentation.\n+\t(vect_analyze_data_ref_access): Fix comments, allow zero step in\n+\tbasic blocks.\n+\t(vect_analyze_data_ref_accesses): Add bb_vinfo argument, get data\n+\tdependence instances from either loop or basic block vectorization\n+\tinfo.\n+\t(vect_analyze_data_refs): Update comment. Call\n+\tcompute_data_dependences_for_bb to analyze basic blocks.\n+\t(vect_create_addr_base_for_vector_ref): Check for outer loop only in\n+\tcase of loop vectorization. In case of basic block vectorization use\n+\tdata-ref itself   as  a base.\n+\t(vect_create_data_ref_ptr): In case of basic block vectorization:\n+\tdon't advance the pointer, add new statements before the current\n+\tstatement.  Adjust function calls.\n+\t(vect_supportable_dr_alignment): Support only aligned accesses in\n+\tbasic block vectorization.\n+\t* common.opt (ftree-slp-vectorize): New flag.\n+\t* tree-vect-patterns.c (widened_name_p): Adjust function calls.\n+\t(vect_pattern_recog_1): Likewise.\n+\t* tree-vect-stmts.c (process_use): Likewise.\n+\t(vect_init_vector): Add new statements in the beginning of the basic\n+\tblock in case of basic block SLP.\n+\t(vect_get_vec_def_for_operand): Adjust function calls.\n+\t(vect_finish_stmt_generation): Likewise.\n+\t(vectorizable_call): Add assert that it is loop vectorization, adjust\n+\tfunction calls.\n+\t(vectorizable_conversion, vectorizable_assignment): Likewise.\n+\t(vectorizable_operation): In case of basic block SLP, take\n+\tvectorization factor from statement's type and skip the relevance\n+\tcheck. Adjust function calls.\n+\t(vectorizable_type_demotion): Add assert that it is loop\n+\tvectorization, adjust function calls.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vectorizable_store): Check for outer loop only in case of loop\n+\tvectorization. Adjust function calls. For basic blocks, skip the\n+\trelevance check and don't advance pointers.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_condition): Add assert that it is loop vectorization,\n+\tadjust function calls.\n+\t(vect_analyze_stmt): Add argument. In case of basic block SLP, check\n+\tthat it is not reduction, get vector type, call only supported\n+\tfunctions, skip loop    specific parts.\n+\t(vect_transform_stmt): Check for outer loop only in case of loop\n+\tvectorization.\n+\t(new_stmt_vec_info): Add new argument and initialize bb_vinfo.\n+\t(vect_is_simple_use): Fix comment, add new argument, fix conditions\n+\tfor external definition.\n+\t* passes.c (pass_slp_vectorize): New pass.\n+\t* tree-vect-slp.c (find_bb_location): New function.\n+\t(vect_get_and_check_slp_defs): Add argument, adjust function calls,\n+\tcheck for patterns only in loops.\n+\t(vect_build_slp_tree): Add argument, adjust function calls, fail in\n+\tcase of multiple types in basic block SLP.\n+\t(vect_mark_slp_stmts_relevant): New function.\n+\t(vect_supported_load_permutation_p): Fix comment.\n+\t(vect_analyze_slp_instance): Add argument. In case of basic block\n+\tSLP, take vectorization factor from statement's type, check that\n+\tunrolling factor is 1. Adjust function call. Save SLP instance in\n+\teither loop or basic block vectorization structure. Return FALSE,\n+\tif SLP failed.\n+\t(vect_analyze_slp): Add argument. Get strided stores groups from\n+\teither loop or basic block vectorization structure. Return FALSE\n+\tif basic block SLP failed.\n+\t(new_bb_vec_info): New function.\n+\t(destroy_bb_vec_info, vect_slp_analyze_node_operations,\n+\tvect_slp_analyze_operations, vect_slp_analyze_bb): Likewise.\n+\t(vect_schedule_slp): Add argument. Get SLP instances from either\n+\tloop or basic block vectorization structure. Set vectorization factor\n+\tto be 1 for basic block SLP.\n+\t(vect_slp_transform_bb): New function.\n+\t* params.def (PARAM_SLP_MAX_INSNS_IN_BB): Define.\n+\n 2009-05-23  Mark Mitchell  <mark@codesourcery.com>\n \n \t* final.c (shorten_branches): Do not align labels for jump tables."}, {"sha": "c70639ec42d7e1bfaec7743a3b97052ddae0fb51", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -1330,6 +1330,10 @@ ftree-vectorize\n Common Report Var(flag_tree_vectorize) Optimization\n Enable loop vectorization on trees\n \n+ftree-slp-vectorize\n+Common Report Var(flag_tree_slp_vectorize) Init(2) Optimization\n+Enable basic block vectorization (SLP) on trees\n+\n fvect-cost-model\n Common Report Var(flag_vect_cost_model) Optimization\n Enable use of cost model in vectorization"}, {"sha": "b28b87cb57ab6650bc3978887b48909556b90061", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -438,11 +438,19 @@ conceptually unrolled by a factor @code{VF} (vectorization factor), which is\n the number of elements operated upon in parallel in each iteration, and the \n @code{VF} copies of each scalar operation are fused to form a vector operation.\n Additional loop transformations such as peeling and versioning may take place\n-to align the number of iterations, and to align the memory accesses in the loop.\n-The pass is implemented in @file{tree-vectorizer.c} (the main driver and general\n-utilities), @file{tree-vect-analyze.c} and @file{tree-vect-transform.c}.\n+to align the number of iterations, and to align the memory accesses in the \n+loop.\n+The pass is implemented in @file{tree-vectorizer.c} (the main driver),\n+@file{tree-vect-loop.c} and @file{tree-vect-loop-manip.c} (loop specific parts \n+and general loop utilities), @file{tree-vect-slp} (loop-aware SLP \n+functionality), @file{tree-vect-stmts.c} and @file{tree-vect-data-refs.c}.\n Analysis of data references is in @file{tree-data-ref.c}.\n \n+SLP Vectorization.  This pass performs vectorization of straight-line code. The\n+pass is implemented in @file{tree-vectorizer.c} (the main driver),\n+@file{tree-vect-slp.c}, @file{tree-vect-stmts.c} and \n+@file{tree-vect-data-refs.c}.\n+\n Autoparallelization.  This pass splits the loop iteration space to run\n into several threads.  The pass is implemented in @file{tree-parloops.c}.\n "}, {"sha": "befa0711155d03e1f61d7c43149a2c8d40bb5f58", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -765,6 +765,12 @@ DEFPARAM (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,\n \t  \"max basic blocks number in loop for loop invariant motion\",\n \t  10000, 0, 0)\n \n+/* Avoid SLP vectorization of large basic blocks.  */\n+DEFPARAM (PARAM_SLP_MAX_INSNS_IN_BB,\n+          \"slp-max-insns-in-bb\",\n+          \"Maximum number of instructions in basic block to be considered for SLP vectorization\",\n+          1000, 0, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "16ed29234ca79947746c063da38c6fef5ccac199", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -170,4 +170,6 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_SWITCH_CONVERSION_BRANCH_RATIO)\n #define LOOP_INVARIANT_MAX_BBS_IN_LOOP \\\n   PARAM_VALUE (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP)\n+#define SLP_MAX_INSNS_IN_BB \\\n+  PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "28838b57a0e0c4e478f3a84140d4e75445d1e1f1", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -662,6 +662,7 @@ init_optimization_passes (void)\n \t      NEXT_PASS (pass_dce_loop);\n \t    }\n \t  NEXT_PASS (pass_complete_unroll);\n+\t  NEXT_PASS (pass_slp_vectorize);\n \t  NEXT_PASS (pass_parallelize_loops);\n \t  NEXT_PASS (pass_loop_prefetch);\n \t  NEXT_PASS (pass_iv_optimize);"}, {"sha": "cdb08f1c7f75c786de6eb94373c472c579400ff1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -1,3 +1,19 @@\n+2009-05-24  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/bb-slp-1.c: New test.\n+\t* gcc.dg/vect/bb-slp-2.c, gcc.dg/vect/bb-slp-3.c, \n+\tgcc.dg/vect/bb-slp-4.c, gcc.dg/vect/bb-slp-5.c, \n+\tgcc.dg/vect/bb-slp-6.c, gcc.dg/vect/bb-slp-7.c,\n+\tgcc.dg/vect/bb-slp-8.c, gcc.dg/vect/bb-slp-9.c, \n+\tgcc.dg/vect/bb-slp-10.c, gcc.dg/vect/bb-slp-11.c, \n+\tgcc.dg/vect/no-tree-reassoc-bb-slp-12.c, gcc.dg/vect/bb-slp-13.c, \n+\tgcc.dg/vect/bb-slp-14.c, gcc.dg/vect/bb-slp-15.c, \n+\tgcc.dg/vect/bb-slp-16.c, gcc.dg/vect/bb-slp-17.c, \n+\tgcc.dg/vect/bb-slp-18.c, gcc.dg/vect/bb-slp-19.c, \n+\tgcc.dg/vect/bb-slp-20.c, gcc.dg/vect/bb-slp-21.c,\n+\tgcc.dg/vect/bb-slp-22.c: Likewise.\n+\t* gcc.dg/vect/vect.exp: Run basic block SLP tests.\n+\n 2009-05-23  Mark Mitchell  <mark@codesourcery.com>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n "}, {"sha": "57e5665247d3ff92c9e1699aff4a763f49a0743e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-1.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32 \n+\n+unsigned int out[N*8];\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 (int dummy)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  \n+  for (i = 0; i < N; i++)\n+    {\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      /* Avoid loop vectorization.  */\n+      if (dummy == 32)\n+        abort ();\n+    }\n+\n+  /* check results: */ \n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (33);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "abac3c31a407f6d27fd84c96339128d81b0fd6e9", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-10.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[2];\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Misaligned store.  */\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[2] != (in[0] + 23) * x\n+      || out[3] != (in[1] + 142) * y\n+      || out[4] != (in[2] + 2) * x\n+      || out[5] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"unsupported alignment in basic block.\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "456f9618139bacc8909f51eab2c9941be88e445f", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-11.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  short a0, a1, a2, a3;\n+\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "5005ae5019f5bd7e6773d5d1e5a8cd64bf1b9abf", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-13.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-13.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "673a163c92f18bb778232552831f551d2d4fb26a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-14.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-14.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Not consecutive load with permutation - not supported.  */\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[1] + 2;\n+  a3 = in[3] + 31;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[1] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\"  } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "ba8bc757e863f7ff442e09416a2b2f70f7809cb0", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-15.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-15.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  if (x > y)\n+    x = x + y;\n+  else\n+    y = x;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "16cd7a18d6710ac6fd26ab550cdcbe977d85fc87", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-16.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-16.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32 \n+\n+unsigned int out[N*8];\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+unsigned int arr[N] = {0,1,2,3,4,5,6,7};\n+\n+__attribute__ ((noinline)) int\n+main1 (int dummy)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  unsigned int a = 0;\n+  \n+  for (i = 0; i < N; i++)\n+    {\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      *pout++ = *pin++ + a;\n+      if (arr[i] = i)\n+        a = i;\n+      else\n+        a = 2;\n+    }\n+\n+  a = 0;\n+  /* check results: */ \n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8] + a\n+         || out[i*8 + 1] != in[i*8 + 1] + a\n+         || out[i*8 + 2] != in[i*8 + 2] + a\n+         || out[i*8 + 3] != in[i*8 + 3] + a\n+         || out[i*8 + 4] != in[i*8 + 4] + a\n+         || out[i*8 + 5] != in[i*8 + 5] + a\n+         || out[i*8 + 6] != in[i*8 + 6] + a\n+         || out[i*8 + 7] != in[i*8 + 7] + a)\n+\tabort ();\n+\n+      if (arr[i] = i)\n+        a = i;\n+      else\n+        a = 2;\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (33);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "36227391d2e28632d303f02a593ca853ec0854f4", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-17.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-17.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int b[N];\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  if (x > y)\n+    x = x + y;\n+  else\n+    y = x;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+ \n+  b[0] = a0;\n+  b[1] = a1;\n+ \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y\n+      || b[0] != in[0] + 23\n+      || b[1] != in[1] + 142)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "ab99f822affd444e3699923541fc491245067c8a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-18.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-18.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != a0 * x\n+      || out[1] != a1 * y\n+      || out[2] != a2 * x\n+      || out[3] != a3 * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "5ee83a1945e4bc722286f5ef62b56c9349cf8d83", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-19.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-19.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned short out[N];\n+unsigned short in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned short *pin = &in[0];\n+  unsigned short *pout = &out[0];\n+ \n+  /* A group of 9 shorts - unsupported for now.  */\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+\n+  /* Check results.  */\n+  if (out[0] != in[0]\n+      || out[1] != in[1]\n+      || out[2] != in[2]\n+      || out[3] != in[3]\n+      || out[4] != in[4]\n+      || out[5] != in[5]\n+      || out[6] != in[6]\n+      || out[7] != in[7]\n+      || out[8] != in[8])\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { xfail *-*-* }  } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "1de319868291f606de118103f19e988fb8582754", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N*8];\n+unsigned int in[N*8] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};\n+\n+__attribute__ ((noinline)) int\n+main1 (int dummy)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  \n+  for (i = 0; i < N*2; i++)\n+    {\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+      *pout++ = *pin++;\n+\n+      /* Avoid loop vectorization.  */\n+      if (dummy == 32)\n+        abort ();\n+    }\n+\n+  /* check results:  */ \n+  for (i = 0; i < N; i++)\n+    {\n+      if (out[i*8] !=  in[i*8]\n+         || out[i*8 + 1] != in[i*8 + 1]\n+         || out[i*8 + 2] != in[i*8 + 2]\n+         || out[i*8 + 3] != in[i*8 + 3]\n+         || out[i*8 + 4] != in[i*8 + 4]\n+         || out[i*8 + 5] != in[i*8 + 5]\n+         || out[i*8 + 6] != in[i*8 + 6]\n+         || out[i*8 + 7] != in[i*8 + 7])\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (33);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "a40a629d1e7decf6413b22002b508eedeeda238a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-20.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-20.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+int b[N];\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  if (x > y)\n+    x = x + y;\n+  else\n+    y = x;\n+\n+  /* Two SLP instances in the basic block, only one is supported for now,\n+     the second one contains type conversion.  */\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+ \n+  b[0] = -a0;\n+  b[1] = -a1;\n+  b[2] = -a2;\n+  b[3] = -a3;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y\n+      || b[0] != -(in[0] + 23)\n+      || b[1] != -(in[1] + 142)\n+      || b[2] != -(in[2] + 2)\n+      || b[3] != -(in[3] + 31))\n+      \n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "f0b4f6b1ac89c2dac43ace9fb6eb94ef0ae45815", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-21.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-21.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int b[N];\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Two SLP instances in one basic block.  */\n+  if (x > y)\n+    x = x + y;\n+  else\n+    y = x;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+ \n+  b[0] = a0;\n+  b[1] = a1;\n+  b[2] = a2;\n+  b[3] = a3;\n+  \n+  out[0] = a0 * x;\n+  out[1] = a1 * y;\n+  out[2] = a2 * x;\n+  out[3] = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y\n+      || b[0] != (in[0] + 23)\n+      || b[1] != (in[1] + 142)\n+      || b[2] != (in[2] + 2)\n+      || b[3] != (in[3] + 31))\n+      \n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"slp\" { target { ! {vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "3e6e685f118b5d79fb37f7dee49f98590b0a822c", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-22.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-22.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int b[N];\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+\n+  a0 = in[0] + 23;\n+  a1 = in[1] + 142;\n+  a2 = in[2] + 2;\n+  a3 = in[3] + 31;\n+\n+  if (x > y)\n+    {\n+      b[0] = a0;\n+      b[1] = a1;\n+      b[2] = a2;\n+      b[3] = a3;\n+    }\n+  else\n+    {\n+      out[0] = a0 * x;\n+      out[1] = a1 * y;\n+      out[2] = a2 * x;\n+      out[3] = a3 * y;\n+    }\n+\n+  /* Check results.  */\n+  if ((x <= y \n+       && (out[0] != (in[0] + 23) * x\n+           || out[1] != (in[1] + 142) * y\n+           || out[2] != (in[2] + 2) * x\n+           || out[3] != (in[3] + 31) * y))\n+       || (x > y\n+           && (b[0] != (in[0] + 23)\n+               || b[1] != (in[1] + 142)\n+               || b[2] != (in[2] + 2)\n+               || b[3] != (in[3] + 31))))\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { target { ! {vect_int_mult } } } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 2 \"slp\"  { target vect_int_mult  } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "07ad7129ad729a138643626c5eb2abf454057187", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-3.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-3.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  \n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+\n+  /* Check results.  */\n+  if (out[0] != in[0]\n+      || out[1] != in[1]\n+      || out[2] != in[2]\n+      || out[3] != in[3])\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "3e74fff29b5163b7440d15438a11e4fb95f81a34", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-4.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-4.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned short out[N];\n+unsigned short in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned short *pin = &in[0];\n+  unsigned short *pout = &out[0];\n+  \n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+\n+  /* Check results.  */\n+  if (out[0] != in[0]\n+      || out[1] != in[1]\n+      || out[2] != in[2]\n+      || out[3] != in[3])\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "0775d998c8ddbb4c028d8909b711ff503483914d", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-5.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-5.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned short out[N];\n+unsigned short in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 ()\n+{\n+  int i;\n+  unsigned short *pin = &in[0];\n+  unsigned short *pout = &out[0];\n+  \n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+\n+  /* Check results.  */\n+  if (out[0] != in[0]\n+      || out[1] != in[1]\n+      || out[2] != in[2]\n+      || out[3] != in[3]\n+      || out[4] != in[4]\n+      || out[5] != in[5]\n+      || out[6] != in[6]\n+      || out[7] != in[7])\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "d351691c2fc5635f009021005d5eb7140ee91edc", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-6.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-6.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  unsigned int a0, a1, a2, a3;\n+\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "e3fac8d5dbe624c9a4b0aad9ba56c65b5663dfaf", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-7.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[0];\n+  unsigned int *pout = &out[0];\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Non isomorphic.  */\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ * 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] * 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "b0c1be77a3ebeabf3be352671edac05c59ce57ff", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-8.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-8.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y, unsigned int *pin, unsigned int *pout)\n+{\n+  int i;\n+  unsigned int a0, a1, a2, a3;\n+ \n+  /* pin and pout may alias.  */\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[0] + 23) * x\n+      || out[1] != (in[1] + 142) * y\n+      || out[2] != (in[2] + 2) * x\n+      || out[3] != (in[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3, &in[0], &out[0]);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "e8fe1507365bd4ae5f360c931205329d2d5d5e18", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-9.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[1];\n+  unsigned int *pout = &out[0];\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Misaligned load.  */\n+  a0 = *pin++ + 23;\n+  a1 = *pin++ + 142;\n+  a2 = *pin++ + 2;\n+  a3 = *pin++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in[1] + 23) * x\n+      || out[1] != (in[2] + 142) * y\n+      || out[2] != (in[3] + 2) * x\n+      || out[3] != (in[4] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"unsupported alignment in basic block.\" 1 \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "d0b2ed4fff7711f82dba627ea92c07d102a4eb30", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-reassoc-bb-slp-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-reassoc-bb-slp-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-reassoc-bb-slp-12.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in1[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+unsigned int in2[N] = {10,11,12,13,14,15,16,17,18,19,110,111,112,113,114,115};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin1 = &in1[0];\n+  unsigned int *pin2 = &in2[0];\n+  unsigned int *pout = &out[0];\n+  unsigned int a0, a1, a2, a3;\n+\n+  a0 = *pin2++ - *pin1++ + 23;\n+  a1 = *pin2++ - *pin1++ + 142;\n+  a2 = *pin2++ - *pin1++ + 2;\n+  a3 = *pin2++ - *pin1++ + 31;\n+  \n+  *pout++ = a0 * x;\n+  *pout++ = a1 * y;\n+  *pout++ = a2 * x;\n+  *pout++ = a3 * y;\n+\n+  /* Check results.  */\n+  if (out[0] != (in2[0] - in1[0] + 23) * x\n+      || out[1] != (in2[1] - in1[1] + 142) * y\n+      || out[2] != (in2[2] - in1[2] + 2) * x\n+      || out[3] != (in2[3] - in1[3] + 31) * y)\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_int_mult } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "42435eb313016ddaa3f875381d02afdff79551dd", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -122,6 +122,8 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/nodump-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n \n lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\" \n+set VECT_SLP_CFLAGS $DEFAULT_VECTCFLAGS\n+lappend VECT_SLP_CFLAGS \"-fdump-tree-slp-details\"\n \n # Main loop.\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/pr*.\\[cS\\]]]  \\\n@@ -130,10 +132,14 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/vect-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/slp-*.\\[cS\\]]]  \\\n         \"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/bb-slp*.\\[cS\\]]]  \\\n+        \"\" $VECT_SLP_CFLAGS\n+\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS\n set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+set SAVED_VECT_SLP_CFLAGS $VECT_SLP_CFLAGS\n \n # --param vect-max-version-for-alias-checks=0 tests\n set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n@@ -262,6 +268,11 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O3-*.\\[cS\\]]]  \\\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/O1-*.\\[cS\\]]]  \\\n         \"\" $O1_VECTCFLAGS\n \n+# -fno-tree-reassoc\n+set VECT_SLP_CFLAGS $SAVED_VECT_SLP_CFLAGS\n+lappend VECT_SLP_CFLAGS \"-fno-tree-reassoc\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/no-tree-reassoc-bb-slp-*.\\[cS\\]]]  \\\n+        \"\" $VECT_SLP_CFLAGS\n \n # Clean up.\n set dg-do-what-default ${save-dg-do-what-default}"}, {"sha": "53967b38476cb90e8d5fc9510e60c1451da35cdb", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -121,6 +121,7 @@ DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")\n+DEFTIMEVAR (TV_TREE_SLP_VECTORIZATION, \"tree slp vectorization\")\n DEFTIMEVAR (TV_GRAPHITE_TRANSFORMS   , \"GRAPHITE loop transforms\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear\")\n DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, \"tree loop distribution\")"}, {"sha": "dc79e8a8bc4207ab67884604300447a0c3c6f3cf", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 94, "deletions": 35, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -668,8 +668,9 @@ canonicalize_base_object_address (tree addr)\n   return build_fold_addr_expr (TREE_OPERAND (addr, 0));\n }\n \n-/* Analyzes the behavior of the memory reference DR in the innermost loop that\n-   contains it. Returns true if analysis succeed or false otherwise.  */\n+/* Analyzes the behavior of the memory reference DR in the innermost loop or \n+   basic block that contains it. Returns true if analysis succeed or false\n+   otherwise.  */\n \n bool\n dr_analyze_innermost (struct data_reference *dr)\n@@ -683,6 +684,7 @@ dr_analyze_innermost (struct data_reference *dr)\n   int punsignedp, pvolatilep;\n   affine_iv base_iv, offset_iv;\n   tree init, dinit, step;\n+  bool in_loop = (loop && loop->num);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"analyze_innermost: \");\n@@ -699,13 +701,24 @@ dr_analyze_innermost (struct data_reference *dr)\n     }\n \n   base = build_fold_addr_expr (base);\n-  if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv, false))\n+  if (in_loop)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n-      return false;\n+      if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv, \n+                      false))\n+        {\n+          if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n+          return false;\n+        }\n+    }\n+  else\n+    {\n+      base_iv.base = base;\n+      base_iv.step = ssize_int (0);\n+      base_iv.no_overflow = true;\n     }\n-  if (!poffset)\n+\n+  if (!poffset || !in_loop)\n     {\n       offset_iv.base = ssize_int (0);\n       offset_iv.step = ssize_int (0);\n@@ -752,25 +765,31 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n   struct loop *loop = loop_containing_stmt (stmt);\n   VEC (tree, heap) *access_fns = NULL;\n   tree ref = unshare_expr (DR_REF (dr)), aref = ref, op;\n-  tree base, off, access_fn;\n-  basic_block before_loop = block_before_loop (nest);\n-\n+  tree base, off, access_fn = NULL_TREE;\n+  basic_block before_loop = NULL;\n+ \n+  if (nest)\n+    before_loop = block_before_loop (nest);\n+    \n   while (handled_component_p (aref))\n     {\n       if (TREE_CODE (aref) == ARRAY_REF)\n \t{\n \t  op = TREE_OPERAND (aref, 1);\n-\t  access_fn = analyze_scalar_evolution (loop, op);\n-\t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n-\t  VEC_safe_push (tree, heap, access_fns, access_fn);\n+\t  if (nest)\n+\t    {\n+  \t      access_fn = analyze_scalar_evolution (loop, op);\n+\t      access_fn = instantiate_scev (before_loop, loop, access_fn);\n+\t      VEC_safe_push (tree, heap, access_fns, access_fn);\n+\t    }\n \n \t  TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n \t}\n       \n       aref = TREE_OPERAND (aref, 0);\n     }\n \n-  if (INDIRECT_REF_P (aref))\n+  if (nest && INDIRECT_REF_P (aref))\n     {\n       op = TREE_OPERAND (aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n@@ -1332,8 +1351,9 @@ initialize_data_dependence_relation (struct data_reference *a,\n   /* If the base of the object is not invariant in the loop nest, we cannot\n      analyze it.  TODO -- in fact, it would suffice to record that there may\n      be arbitrary dependences in the loops where the base object varies.  */\n-  if (!object_address_invariant_in_loop_p (VEC_index (loop_p, loop_nest, 0),\n-\t\t\t\t\t   DR_BASE_OBJECT (a)))\n+  if (loop_nest \n+      && !object_address_invariant_in_loop_p (VEC_index (loop_p, loop_nest, 0),\n+     \t\t\t\t\t      DR_BASE_OBJECT (a)))\n     {\n       DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n       return res;\n@@ -4003,7 +4023,8 @@ compute_all_dependences (VEC (data_reference_p, heap) *datarefs,\n \t{\n \t  ddr = initialize_data_dependence_relation (a, b, loop_nest);\n \t  VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n-\t  compute_affine_dependence (ddr, VEC_index (loop_p, loop_nest, 0));\n+          if (loop_nest)\n+   \t    compute_affine_dependence (ddr, VEC_index (loop_p, loop_nest, 0));\n \t}\n \n   if (compute_self_and_rr)\n@@ -4110,9 +4131,10 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n       dr = create_data_ref (nest, *ref->pos, stmt, ref->is_read);\n       gcc_assert (dr != NULL);\n   \n-      /* FIXME -- data dependence analysis does not work correctly for objects with\n-\t invariant addresses.  Let us fail here until the problem is fixed.  */\n-      if (dr_address_invariant_p (dr))\n+      /* FIXME -- data dependence analysis does not work correctly for objects \n+         with invariant addresses in loop nests.  Let us fail here until the\n+\t problem is fixed.  */\n+      if (dr_address_invariant_p (dr) && nest)\n \t{\n \t  free_data_ref (dr);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -4127,6 +4149,33 @@ find_data_references_in_stmt (struct loop *nest, gimple stmt,\n   return ret;\n }\n \n+/* Search the data references in LOOP, and record the information into\n+   DATAREFS.  Returns chrec_dont_know when failing to analyze a\n+   difficult case, returns NULL_TREE otherwise.  */\n+\n+static tree\n+find_data_references_in_bb (struct loop *loop, basic_block bb,\n+                            VEC (data_reference_p, heap) **datarefs)\n+{\n+  gimple_stmt_iterator bsi;\n+\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    {\n+      gimple stmt = gsi_stmt (bsi);\n+\n+      if (!find_data_references_in_stmt (loop, stmt, datarefs))\n+        {\n+          struct data_reference *res;\n+          res = XCNEW (struct data_reference);\n+          VEC_safe_push (data_reference_p, heap, *datarefs, res);\n+\n+          return chrec_dont_know;\n+        }\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Search the data references in LOOP, and record the information into\n    DATAREFS.  Returns chrec_dont_know when failing to analyze a\n    difficult case, returns NULL_TREE otherwise.\n@@ -4140,28 +4189,18 @@ find_data_references_in_loop (struct loop *loop,\n {\n   basic_block bb, *bbs;\n   unsigned int i;\n-  gimple_stmt_iterator bsi;\n \n   bbs = get_loop_body_in_dom_order (loop);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n       bb = bbs[i];\n \n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (bsi);\n-\n-\t  if (!find_data_references_in_stmt (loop, stmt, datarefs))\n-\t    {\n-\t      struct data_reference *res;\n-\t      res = XCNEW (struct data_reference);\n-\t      VEC_safe_push (data_reference_p, heap, *datarefs, res);\n-\n-\t      free (bbs);\n-\t      return chrec_dont_know;\n-\t    }\n-\t}\n+      if (find_data_references_in_bb (loop, bb, datarefs) == chrec_dont_know)\n+        {\n+          free (bbs);\n+          return chrec_dont_know;\n+        }\n     }\n   free (bbs);\n \n@@ -4298,6 +4337,26 @@ compute_data_dependences_for_loop (struct loop *loop,\n   return res;\n }\n \n+/* Returns true when the data dependences for the basic block BB have been \n+   computed, false otherwise.\n+   DATAREFS is initialized to all the array elements contained in this basic \n+   block, DEPENDENCE_RELATIONS contains the relations between the data\n+   references. Compute read-read and self relations if\n+   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n+bool\n+compute_data_dependences_for_bb (basic_block bb,\n+                                 bool compute_self_and_read_read_dependences,\n+                                 VEC (data_reference_p, heap) **datarefs,\n+                                 VEC (ddr_p, heap) **dependence_relations)\n+{\n+  if (find_data_references_in_bb (NULL, bb, datarefs) == chrec_dont_know)\n+    return false;\n+\n+  compute_all_dependences (*datarefs, dependence_relations, NULL,\n+                           compute_self_and_read_read_dependences);\n+  return true;\n+}\n+\n /* Entry point (for testing only).  Analyze all the data references\n    and the dependence relations in LOOP.\n "}, {"sha": "dfce23309f57451bd634224b3cebe028fd16a756", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -383,6 +383,9 @@ bool dr_analyze_innermost (struct data_reference *);\n extern bool compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       VEC (data_reference_p, heap) **,\n \t\t\t\t\t       VEC (ddr_p, heap) **);\n+extern bool compute_data_dependences_for_bb (basic_block, bool,\n+                                             VEC (data_reference_p, heap) **,\n+                                             VEC (ddr_p, heap) **);\n extern tree find_data_references_in_loop (struct loop *, \n                                           VEC (data_reference_p, heap) **);\n extern void print_direction_vector (FILE *, lambda_vector, int);"}, {"sha": "abb4bd11caa3f03521e42207600e62cce934c131", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -338,6 +338,7 @@ extern struct gimple_opt_pass pass_graphite_transforms;\n extern struct gimple_opt_pass pass_if_conversion;\n extern struct gimple_opt_pass pass_loop_distribution;\n extern struct gimple_opt_pass pass_vectorize;\n+extern struct gimple_opt_pass pass_slp_vectorize;\n extern struct gimple_opt_pass pass_complete_unroll;\n extern struct gimple_opt_pass pass_complete_unrolli;\n extern struct gimple_opt_pass pass_parallelize_loops;"}, {"sha": "e74251d69c346e2663afb211fd9ba2321b6d99d7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 227, "deletions": 81, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -363,7 +363,7 @@ vect_check_interleaving (struct data_reference *dra,\n \t and DRB is accessed before DRA.  */\n       diff_mod_size = (init_a - init_b) % type_size_a;\n \n-      if ((init_a - init_b) > step)\n+      if (step && (init_a - init_b) > step)\n          return false; \n \n       if (diff_mod_size == 0)\n@@ -385,7 +385,7 @@ vect_check_interleaving (struct data_reference *dra,\n \t interleaving, and DRA is accessed before DRB.  */\n       diff_mod_size = (init_b - init_a) % type_size_a;\n \n-      if ((init_b - init_a) > step)\n+      if (step && (init_b - init_a) > step)\n          return false;\n \n       if (diff_mod_size == 0)\n@@ -479,6 +479,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   return true;\n }\n \n+\n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n@@ -490,8 +491,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n                                   loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  struct loop *loop = NULL;\n+  int vectorization_factor = 0;\n   struct data_reference *dra = DDR_A (ddr);\n   struct data_reference *drb = DDR_B (ddr);\n   stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n@@ -508,23 +509,68 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       return false;\n     }\n \n-  if ((DR_IS_READ (dra) && DR_IS_READ (drb)) || dra == drb)\n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+    }\n+\n+  if ((DR_IS_READ (dra) && DR_IS_READ (drb) && loop_vinfo) || dra == drb)\n     return false;\n   \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n+      if (loop_vinfo) \n+        {\n+          if (vect_print_dump_info (REPORT_DR_DETAILS))\n+            {\n+              fprintf (vect_dump, \"versioning for alias required: \"\n+                                  \"can't determine dependence between \");\n+              print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+              fprintf (vect_dump, \" and \");\n+              print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+            }\n+      \n+          /* Add to list of ddrs that need to be tested at run-time.  */\n+          return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+        }\n+\n+      /* When vectorizing a basic block unknown depnedence can still mean\n+\t strided access.  */\n+      if (vect_check_interleaving (dra, drb))\n+         return false;\n+\n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n         {\n-          fprintf (vect_dump,\n-                   \"versioning for alias required: can't determine dependence between \");\n+          fprintf (vect_dump, \"can't determine dependence between \");\n           print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n-      /* Add to list of ddrs that need to be tested at run-time.  */\n-      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+\n+      return true;\n     }\n \n+  /* Versioning for alias is not yet supported for basic block SLP, and\n+     dependence distance is unapplicable, hence, in case of known data \n+     dependence, basic block vectorization is impossible for now.  */\n+  if (!loop_vinfo)\n+    {\n+      if (dra != drb && vect_check_interleaving (dra, drb))\n+        return false;\n+\t\t   \n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+        {\n+          fprintf (vect_dump, \"determined dependence between \");\n+          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+          fprintf (vect_dump, \" and \");\n+          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+        }\n+\n+      return true;\t\n+    }\n+\n+  /* Loop-based vectorization and known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n@@ -589,9 +635,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t{\n-\t  fprintf (vect_dump,\n-\t\t   \"not vectorized, possible dependence \"\n-\t\t   \"between data-refs \");\n+\t  fprintf (vect_dump, \"not vectorized, possible dependence \"\n+    \t\t              \"between data-refs \");\n \t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n \t  fprintf (vect_dump, \" and \");\n \t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n@@ -609,15 +654,21 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n    exist any data dependences between them.  */\n          \n bool\n-vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n+vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, \n+                                   bb_vec_info bb_vinfo)\n {\n   unsigned int i;\n-  VEC (ddr_p, heap) * ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+  VEC (ddr_p, heap) *ddrs = NULL;\n   struct data_dependence_relation *ddr;\n \n   if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n      \n+  if (loop_vinfo)\n+    ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n+  else\n+    ddrs = BB_VINFO_DDRS (bb_vinfo);\n+     \n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n     if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n       return false;\n@@ -644,7 +695,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   gimple stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);  \n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n   tree ref = DR_REF (dr);\n   tree vectype;\n   tree base, base_addr;\n@@ -655,6 +706,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n \n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n+    \n   /* Initialize misalignment to unknown.  */\n   SET_DR_MISALIGNMENT (dr, -1);\n \n@@ -669,7 +723,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n      stays the same throughout the execution of the inner-loop, which is why\n      we have to check that the stride of the dataref in the inner-loop evenly\n      divides by the vector size.  */\n-  if (nested_in_vect_loop_p (loop, stmt))\n+  if (loop && nested_in_vect_loop_p (loop, stmt))\n     {\n       tree step = DR_STEP (dr);\n       HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n@@ -773,12 +827,18 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n static bool\n-vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n+vect_compute_data_refs_alignment (loop_vec_info loop_vinfo, \n+                                  bb_vec_info bb_vinfo)\n {\n-  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n   unsigned int i;\n \n+  if (loop_vinfo)\n+    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  else\n+    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n+\t    \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     if (!vect_compute_data_ref_alignment (dr))\n       return false;\n@@ -850,14 +910,19 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n    Return TRUE if all data references in the loop can be\n    handled with respect to alignment.  */\n \n-static bool\n-vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n+bool\n+vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n-  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n+  if (loop_vinfo)\n+    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  else\n+    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n+\n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n       gimple stmt = DR_STMT (dr);\n@@ -1223,7 +1288,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"Peeling for alignment will be applied.\");\n \n-\t  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+\t  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n \t  gcc_assert (stat);\n           return stat;\n         }\n@@ -1331,15 +1396,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n \n-      stat = vect_verify_datarefs_alignment (loop_vinfo);\n+      stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n       gcc_assert (stat);\n       return stat;\n     }\n \n   /* This point is reached if neither peeling nor versioning is being done.  */\n   gcc_assert (! (do_peeling || do_versioning));\n \n-  stat = vect_verify_datarefs_alignment (loop_vinfo);\n+  stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n   return stat;\n }\n \n@@ -1350,12 +1415,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n bool\n-vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo) \n+vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo, \n+                                  bb_vec_info bb_vinfo)\n {\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs_alignment ===\");\n \n-  if (!vect_compute_data_refs_alignment (loop_vinfo))\n+  if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \tfprintf (vect_dump, \n@@ -1381,6 +1447,7 @@ vect_analyze_group_access (struct data_reference *dr)\n   gimple stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n   HOST_WIDE_INT stride;\n   bool slp_impossible = false;\n@@ -1406,8 +1473,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n \t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n \t    {\n-\t      fprintf (vect_dump, \"Detected single element interleaving %d \",\n-\t\t       DR_GROUP_SIZE (vinfo_for_stmt (stmt)));\n+\t      fprintf (vect_dump, \"Detected single element interleaving \");\n \t      print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n \t      fprintf (vect_dump, \" step \");\n \t      print_generic_expr (vect_dump, step, TDF_SLIM);\n@@ -1508,8 +1574,8 @@ vect_analyze_group_access (struct data_reference *dr)\n          the type to get COUNT_IN_BYTES.  */\n       count_in_bytes = type_size * count;\n \n-     /* Check that the size of the interleaving (including gaps) is not greater\n-         than STEP.  */\n+      /* Check that the size of the interleaving (including gaps) is not \n+         greater than STEP.  */\n       if (dr_step && dr_step < count_in_bytes + gaps * type_size)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1522,7 +1588,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       /* Check that the size of the interleaving is equal to STEP for stores,\n          i.e., that there are no gaps.  */\n-      if (dr_step != count_in_bytes)\n+      if (dr_step && dr_step != count_in_bytes)\n         {\n           if (DR_IS_READ (dr))\n             {\n@@ -1541,7 +1607,7 @@ vect_analyze_group_access (struct data_reference *dr)\n         }\n \n       /* Check that STEP is a multiple of type size.  */\n-      if ((dr_step % type_size) != 0)\n+      if (dr_step && (dr_step % type_size) != 0)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             {\n@@ -1566,14 +1632,25 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  if (slp_impossible)\n \t    return false;\n \t}\n+\n+      if (stride == 0)\n+        stride = count;\n+\t\n       DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"Detected interleaving of size %d\", (int)stride);\n \n       /* SLP: create an SLP data structure for every interleaving group of \n \t stores for further analysis in vect_analyse_slp.  */\n       if (!DR_IS_READ (dr) && !slp_impossible)\n-\tVEC_safe_push (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo), stmt);\n+        {\n+          if (loop_vinfo)\n+            VEC_safe_push (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo),\n+                           stmt);\n+          if (bb_vinfo)\n+            VEC_safe_push (gimple, heap, BB_VINFO_STRIDED_STORES (bb_vinfo), \n+                           stmt);\n+        }\n     }\n \n   return true;\n@@ -1592,21 +1669,24 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   gimple stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n   HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n \n-  if (!step)\n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n+    \n+  if (loop_vinfo && !step)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data-ref access\");\n+\tfprintf (vect_dump, \"bad data-ref access in loop\");\n       return false;\n     }\n \n-  /* Don't allow invariant accesses.  */\n-  if (dr_step == 0)\n+  /* Don't allow invariant accesses in loops.  */\n+  if (loop_vinfo && dr_step == 0)\n     return false; \n \n-  if (nested_in_vect_loop_p (loop, stmt))\n+  if (loop && nested_in_vect_loop_p (loop, stmt))\n     {\n       /* Interleaved accesses are not yet supported within outer-loop\n         vectorization for references in the inner-loop.  */\n@@ -1635,7 +1715,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       return true;\n     }\n \n-  if (nested_in_vect_loop_p (loop, stmt))\n+  if (loop && nested_in_vect_loop_p (loop, stmt))\n     {\n       if (vect_print_dump_info (REPORT_ALIGNMENT))\n \tfprintf (vect_dump, \"strided access in outer loop.\");\n@@ -1657,15 +1737,20 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n    FORNOW: handle only arrays and pointer accesses.  */\n \n bool\n-vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n+vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n   unsigned int i;\n-  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n \n+  if (loop_vinfo)\n+    datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  else\n+    datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n+\n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     if (!vect_analyze_data_ref_access (dr))\n       {\n@@ -1752,37 +1837,51 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n /* Function vect_analyze_data_refs.\n \n-  Find all the data references in the loop.\n+  Find all the data references in the loop or basic block.\n \n    The general structure of the analysis of data refs in the vectorizer is as\n    follows:\n-   1- vect_analyze_data_refs(loop): call compute_data_dependences_for_loop to\n-      find and analyze all data-refs in the loop and their dependences.\n+   1- vect_analyze_data_refs(loop/bb): call \n+      compute_data_dependences_for_loop/bb to find and analyze all data-refs\n+      in the loop/bb and their dependences.\n    2- vect_analyze_dependences(): apply dependence testing using ddrs.\n    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n \n */\n \n bool\n-vect_analyze_data_refs (loop_vec_info loop_vinfo)  \n+vect_analyze_data_refs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)  \n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n+  basic_block bb = NULL;\n   unsigned int i;\n   VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n   tree scalar_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\\n\");\n-\n-  compute_data_dependences_for_loop (loop, true,\n-                                     &LOOP_VINFO_DATAREFS (loop_vinfo),\n-                                     &LOOP_VINFO_DDRS (loop_vinfo));\n+  \n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      compute_data_dependences_for_loop (loop, true,\n+                                         &LOOP_VINFO_DATAREFS (loop_vinfo),\n+                                         &LOOP_VINFO_DDRS (loop_vinfo));\n+      datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+    }\n+  else\n+    {\n+      bb = BB_VINFO_BB (bb_vinfo);\n+      compute_data_dependences_for_bb (bb, true,\n+                                       &BB_VINFO_DATAREFS (bb_vinfo),\n+                                       &BB_VINFO_DDRS (bb_vinfo));\n+      datarefs = BB_VINFO_DATAREFS (bb_vinfo);\n+    }\n \n   /* Go through the data-refs, check that the analysis succeeded. Update pointer\n      from stmt_vec_info struct to DR and vectype.  */\n-  datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n@@ -1834,7 +1933,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t inner-most enclosing loop).  We do that by building a reference to the\n \t first location accessed by the inner-loop, and analyze it relative to\n \t the outer-loop.  */ \t\n-      if (nested_in_vect_loop_p (loop, stmt)) \n+      if (loop && nested_in_vect_loop_p (loop, stmt)) \n \t{\n \t  tree outer_step, outer_base, outer_init;\n \t  HOST_WIDE_INT pbitsize, pbitpos;\n@@ -2053,7 +2152,6 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n   tree data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n   tree base_name;\n   tree data_ref_base_var;\n@@ -2065,22 +2163,28 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n   tree init = unshare_expr (DR_INIT (dr));\n   tree vect_ptr_type;\n   tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n-  gcc_assert (loop);\n-  if (loop != containing_loop)\n+  if (loop_vinfo && loop && loop != (gimple_bb (stmt))->loop_father)\n     {\n-      loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      struct loop *outer_loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-      gcc_assert (nested_in_vect_loop_p (loop, stmt));\n+      gcc_assert (nested_in_vect_loop_p (outer_loop, stmt));\n \n       data_ref_base = unshare_expr (STMT_VINFO_DR_BASE_ADDRESS (stmt_info));\n       base_offset = unshare_expr (STMT_VINFO_DR_OFFSET (stmt_info));\n       init = unshare_expr (STMT_VINFO_DR_INIT (stmt_info));\n     }\n \n-  /* Create data_ref_base */\n-  base_name = build_fold_indirect_ref (data_ref_base);\n+  if (loop_vinfo)\n+    base_name = build_fold_indirect_ref (data_ref_base);\n+  else\n+    {\n+      base_offset = ssize_int (0);\n+      init = ssize_int (0);\n+      base_name = build_fold_indirect_ref (unshare_expr (DR_REF (dr)));\n+    }  \n+\n   data_ref_base_var = create_tmp_var (TREE_TYPE (data_ref_base), \"batmp\");\n   add_referenced_var (data_ref_base_var);\n   data_ref_base = force_gimple_operand (data_ref_base, &seq, true,\n@@ -2110,15 +2214,24 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n     }\n \n   /* base + base_offset */\n-  addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base), \n-\t\t\t   data_ref_base, base_offset);\n-\n+  if (loop_vinfo)\n+    addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base),\n+                             data_ref_base, base_offset);\n+  else\n+    {\n+      if (TREE_CODE (DR_REF (dr)) == INDIRECT_REF)\n+        addr_base = unshare_expr (TREE_OPERAND (DR_REF (dr), 0));\n+      else\n+        addr_base = build1 (ADDR_EXPR, \n+                            build_pointer_type (TREE_TYPE (DR_REF (dr))),\n+                            unshare_expr (DR_REF (dr)));\n+    }\n+\t\t      \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n \n   vec_stmt = fold_convert (vect_ptr_type, addr_base);\n   addr_expr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                      get_name (base_name));\n-\n   add_referenced_var (addr_expr);\n   vec_stmt = force_gimple_operand (vec_stmt, &seq, false, addr_expr);\n   gimple_seq_add_seq (new_stmt_list, seq);\n@@ -2186,16 +2299,16 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n-  struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n+  struct loop *loop = NULL;\n+  bool nested_in_vect_loop = false;\n+  struct loop *containing_loop = NULL;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vect_ptr_type;\n   tree vect_ptr;\n   tree new_temp;\n   gimple vec_stmt;\n   gimple_seq new_stmt_list = NULL;\n-  edge pe;\n+  edge pe = NULL;\n   basic_block new_bb;\n   tree vect_ptr_init;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n@@ -2205,7 +2318,23 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n   tree indx_before_incr, indx_after_incr;\n   gimple incr;\n   tree step;\n-\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+ \n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+      containing_loop = (gimple_bb (stmt))->loop_father;\n+      pe = loop_preheader_edge (loop);\n+    }\n+  else\n+    {\n+      gcc_assert (bb_vinfo);\n+      only_init = true;\n+      *ptr_incr = NULL;\n+    }\n+\t\t\t\t\t\t\t    \n   /* Check the step (evolution) of the load in LOOP, and record\n      whether it's invariant.  */\n   if (nested_in_vect_loop)\n@@ -2305,11 +2434,15 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \n   new_temp = vect_create_addr_base_for_vector_ref (stmt, &new_stmt_list,\n                                                    offset, loop);\n-  pe = loop_preheader_edge (loop);\n   if (new_stmt_list)\n     {\n-      new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmt_list);\n-      gcc_assert (!new_bb);\n+      if (pe)\n+        {\n+          new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmt_list);\n+          gcc_assert (!new_bb);\n+        }\n+      else\n+        gsi_insert_seq_before (&gsi, new_stmt_list, GSI_SAME_STMT);\n     }\n \n   *initial_address = new_temp;\n@@ -2319,16 +2452,21 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\t\t\t  fold_convert (vect_ptr_type, new_temp));\n   vect_ptr_init = make_ssa_name (vect_ptr, vec_stmt);\n   gimple_assign_set_lhs (vec_stmt, vect_ptr_init);\n-  new_bb = gsi_insert_on_edge_immediate (pe, vec_stmt);\n-  gcc_assert (!new_bb);\n-\n+  if (pe)\n+    {\n+      new_bb = gsi_insert_on_edge_immediate (pe, vec_stmt);\n+      gcc_assert (!new_bb);\n+    }\n+  else\n+    gsi_insert_before (&gsi, vec_stmt, GSI_SAME_STMT);\n \n   /** (4) Handle the updating of the vector-pointer inside the loop.\n \t  This is needed when ONLY_INIT is false, and also when AT_LOOP\n \t  is the inner-loop nested in LOOP (during outer-loop vectorization).\n    **/\n \n-  if (only_init && at_loop == loop) /* No update in loop is required.  */\n+  /* No update in loop is required.  */\n+  if (only_init && (!loop_vinfo || at_loop == loop)) \n     {\n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -2351,7 +2489,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\t vect_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -2383,7 +2521,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\t containing_loop, &incr_gsi, insert_after, &indx_before_incr,\n \t\t &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo));\n+      set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -3237,13 +3375,21 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   enum machine_mode mode = TYPE_MODE (vectype);\n-  struct loop *vect_loop = LOOP_VINFO_LOOP (STMT_VINFO_LOOP_VINFO (stmt_info));\n-  bool nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n   bool invariant_in_outerloop = false;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *vect_loop = NULL;\n+  bool nested_in_vect_loop = false;\n \n   if (aligned_access_p (dr))\n     return dr_aligned;\n \n+  if (!loop_vinfo)\n+    /* FORNOW: Misaligned accesses are supported only in loops.  */\n+    return dr_unaligned_unsupported;\n+\n+  vect_loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n+\n   if (nested_in_vect_loop)\n     {\n       tree outerloop_step = STMT_VINFO_DR_STEP (stmt_info);"}, {"sha": "33b0a9d57968964753ef2fb78da5db5b6b779254", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -640,14 +640,14 @@ new_loop_vec_info (struct loop *loop)\n             {\n               gimple phi = gsi_stmt (si);\n               gimple_set_uid (phi, 0);\n-              set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res));\n+              set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, res, NULL));\n             }\n \n           for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n             {\n               gimple stmt = gsi_stmt (si);\n               gimple_set_uid (stmt, 0);\n-              set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res));\n+              set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, res, NULL));\n             }\n         }\n     }\n@@ -1153,7 +1153,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \n           gcc_assert (stmt_info);\n \n-\t  if (!vect_analyze_stmt (stmt, &need_to_vectorize))\n+\t  if (!vect_analyze_stmt (stmt, &need_to_vectorize, NULL))\n \t    return false;\n \n           if (STMT_VINFO_RELEVANT_P (stmt_info) && !PURE_SLP_STMT (stmt_info))\n@@ -1316,7 +1316,7 @@ vect_analyze_loop (struct loop *loop)\n      FORNOW: Handle only simple, array references, which\n      alignment can be forced, and aligned pointer-references.  */\n \n-  ok = vect_analyze_data_refs (loop_vinfo);\n+  ok = vect_analyze_data_refs (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1346,7 +1346,7 @@ vect_analyze_loop (struct loop *loop)\n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n \n-  ok = vect_analyze_data_refs_alignment (loop_vinfo);\n+  ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1367,7 +1367,7 @@ vect_analyze_loop (struct loop *loop)\n   /* Analyze data dependences between the data-refs in the loop. \n      FORNOW: fail at the first data dependence that we encounter.  */\n \n-  ok = vect_analyze_data_ref_dependences (loop_vinfo);\n+  ok = vect_analyze_data_ref_dependences (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1379,7 +1379,7 @@ vect_analyze_loop (struct loop *loop)\n   /* Analyze the access patterns of the data-refs in the loop (consecutive,\n      complex, etc.). FORNOW: Only handle consecutive access pattern.  */\n \n-  ok = vect_analyze_data_ref_accesses (loop_vinfo);\n+  ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1402,7 +1402,7 @@ vect_analyze_loop (struct loop *loop)\n     }\n \n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo);\n+  ok = vect_analyze_slp (loop_vinfo, NULL);\n   if (ok)\n     {\n       /* Decide which possible SLP instances to SLP.  */\n@@ -2354,7 +2354,7 @@ get_initial_def_for_induction (gimple iv_phi)\n   add_referenced_var (vec_dest);\n   induction_phi = create_phi_node (vec_dest, iv_loop->header);\n   set_vinfo_for_stmt (induction_phi,\n-\t\t      new_stmt_vec_info (induction_phi, loop_vinfo));\n+\t\t      new_stmt_vec_info (induction_phi, loop_vinfo, NULL));\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n@@ -2363,7 +2363,8 @@ get_initial_def_for_induction (gimple iv_phi)\n   vec_def = make_ssa_name (vec_dest, new_stmt);\n   gimple_assign_set_lhs (new_stmt, vec_def);\n   gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n-  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo));\n+  set_vinfo_for_stmt (new_stmt, new_stmt_vec_info (new_stmt, loop_vinfo, \n+                                                   NULL));\n \n   /* Set the arguments of the phi node:  */\n   add_phi_arg (induction_phi, vec_init, pe);\n@@ -2405,7 +2406,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \n \t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n \t  set_vinfo_for_stmt (new_stmt,\n-\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo));\n+\t\t\t      new_stmt_vec_info (new_stmt, loop_vinfo, NULL));\n \t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n \t  prev_stmt_vinfo = vinfo_for_stmt (new_stmt); \n \t}\n@@ -2743,7 +2744,7 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n   for (j = 0; j < ncopies; j++)\n     {\n       phi = create_phi_node (SSA_NAME_VAR (vect_def), exit_bb);\n-      set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo));\n+      set_vinfo_for_stmt (phi, new_stmt_vec_info (phi, loop_vinfo, NULL));\n       if (j == 0)\n \tnew_phi = phi;\n       else\n@@ -3021,7 +3022,8 @@ vect_create_epilog_for_reduction (tree vect_def, gimple stmt,\n \t  epilog_stmt = adjustment_def ? epilog_stmt : new_phi;\n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = epilog_stmt;\n \t  set_vinfo_for_stmt (epilog_stmt, \n-\t\t\t      new_stmt_vec_info (epilog_stmt, loop_vinfo));\n+\t\t\t      new_stmt_vec_info (epilog_stmt, loop_vinfo, \n+\t\t\t                         NULL));\n \t  if (adjustment_def)\n \t    STMT_VINFO_RELATED_STMT (vinfo_for_stmt (epilog_stmt)) =\n \t\tSTMT_VINFO_RELATED_STMT (vinfo_for_stmt (new_phi));\n@@ -3204,7 +3206,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n      The last use is the reduction variable.  */\n   for (i = 0; i < op_type-1; i++)\n     {\n-      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt,\n+      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt,\n \t\t\t\t\t  &def, &dt);\n       gcc_assert (is_simple_use);\n       if (dt != vect_internal_def\n@@ -3214,8 +3216,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \treturn false;\n     }\n \n-  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &def, \n-                                      &dt);\n+  is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt, \n+                                      &def, &dt);\n   gcc_assert (is_simple_use);\n   gcc_assert (dt == vect_reduction_def);\n   gcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n@@ -3394,7 +3396,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  /* Create the reduction-phi that defines the reduction-operand.  */\n \t  new_phi = create_phi_node (vec_dest, loop->header);\n-\t  set_vinfo_for_stmt (new_phi, new_stmt_vec_info (new_phi, loop_vinfo));\n+\t  set_vinfo_for_stmt (new_phi, new_stmt_vec_info (new_phi, loop_vinfo, \n+\t                                                  NULL));\n \t}\n \n       /* Handle uses.  */\n@@ -3592,7 +3595,8 @@ vectorizable_live_operation (gimple stmt,\n \top = TREE_OPERAND (gimple_op (stmt, 1), i);\n       else\n \top = gimple_op (stmt, i + 1);\n-      if (op && !vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+      if (op\n+          && !vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def, &dt))\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"use not simple.\");\n@@ -3766,7 +3770,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t  if (vect_print_dump_info (REPORT_DETAILS))\n \t\t    fprintf (vect_dump, \"=== scheduling SLP instances ===\");\n \n-\t\t  vect_schedule_slp (loop_vinfo);\n+\t\t  vect_schedule_slp (loop_vinfo, NULL);\n \t\t}\n \n \t      /* Hybrid SLP stmts must be vectorized in addition to SLP.  */"}, {"sha": "a41f7b4bcdf3e22a6c732e558e3db76a371c28b6", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -78,7 +78,7 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt)\n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n-  if (!vect_is_simple_use (name, loop_vinfo, def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (name, loop_vinfo, NULL, def_stmt, &def, &dt))\n     return false;\n \n   if (dt != vect_internal_def\n@@ -102,7 +102,8 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt)\n       || (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 2)))\n     return false;\n \n-  if (!vect_is_simple_use (oprnd0, loop_vinfo, &dummy_gimple, &dummy, &dt))\n+  if (!vect_is_simple_use (oprnd0, loop_vinfo, NULL, &dummy_gimple, &dummy, \n+                           &dt))\n     return false;\n \n   return true;\n@@ -734,7 +735,7 @@ vect_pattern_recog_1 (\n   /* Mark the stmts that are involved in the pattern. */\n   gsi_insert_before (&si, pattern_stmt, GSI_SAME_STMT);\n   set_vinfo_for_stmt (pattern_stmt,\n-\t\t      new_stmt_vec_info (pattern_stmt, loop_vinfo));\n+\t\t      new_stmt_vec_info (pattern_stmt, loop_vinfo, NULL));\n   pattern_stmt_info = vinfo_for_stmt (pattern_stmt);\n   \n   STMT_VINFO_RELATED_STMT (pattern_stmt_info) = stmt;"}, {"sha": "ece3297422b8677726e0ca3caeb30900393b6615", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 452, "deletions": 61, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -38,6 +38,29 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"tree-vectorizer.h\"\n \n+/* Extract the location of the basic block in the source code.\n+   Return the basic block location if succeed and NULL if not.  */\n+\n+LOC\n+find_bb_location (basic_block bb)\n+{\n+  gimple stmt = NULL;\n+  gimple_stmt_iterator si;\n+\n+  if (!bb)\n+    return UNKNOWN_LOC;\n+\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      stmt = gsi_stmt (si);\n+      if (gimple_location (stmt) != UNKNOWN_LOC)\n+        return gimple_location (stmt);\n+    }\n+\n+  return UNKNOWN_LOC;\n+}\n+\n+\n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n \n static void\n@@ -77,8 +100,9 @@ vect_free_slp_instance (slp_instance instance)\n    the SLP group (stored in FIRST_STMT_...).  */\n \n static bool\n-vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n-\t\t\t     gimple stmt, VEC (gimple, heap) **def_stmts0,\n+vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+                             slp_tree slp_node, gimple stmt, \n+\t\t\t     VEC (gimple, heap) **def_stmts0,\n \t\t\t     VEC (gimple, heap) **def_stmts1,\n \t\t\t     enum vect_def_type *first_stmt_dt0,\n \t\t\t     enum vect_def_type *first_stmt_dt1,\n@@ -96,7 +120,10 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n   stmt_vec_info stmt_info = \n     vinfo_for_stmt (VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0));\n   enum gimple_rhs_class rhs_class;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n+  \n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   rhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (stmt));\n   number_of_oprnds = gimple_num_ops (stmt) - 1;\t/* RHS only */\n@@ -105,7 +132,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n     {\n       oprnd = gimple_op (stmt, i + 1);\n \n-      if (!vect_is_simple_use (oprnd, loop_vinfo, &def_stmt, &def, &dt[i])\n+      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def, \n+                               &dt[i])\n \t  || (!def_stmt && dt[i] != vect_constant_def))\n \t{\n \t  if (vect_print_dump_info (REPORT_SLP)) \n@@ -117,10 +145,10 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n \t  return false;\n \t}\n \n-      /* Check if DEF_STMT is a part of a pattern and get the def stmt from\n-         the pattern. Check that all the stmts of the node are in the\n+      /* Check if DEF_STMT is a part of a pattern in LOOP and get the def stmt\n+         from the pattern. Check that all the stmts of the node are in the\n          pattern.  */\n-      if (def_stmt && gimple_bb (def_stmt)\n+      if (loop && def_stmt && gimple_bb (def_stmt)\n           && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt))\n           && vinfo_for_stmt (def_stmt)\n           && STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (def_stmt)))\n@@ -271,12 +299,13 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, slp_tree slp_node,\n    TRUE.  */\n \n static bool\n-vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node, \n-\t\t     unsigned int group_size, \n-\t\t     int *inside_cost, int *outside_cost,\n-\t\t     int ncopies_for_cost, unsigned int *max_nunits,\n+vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo, \n+                     slp_tree *node, unsigned int group_size,\n+                     int *inside_cost, int *outside_cost,\n+                     int ncopies_for_cost, unsigned int *max_nunits,\n                      VEC (int, heap) **load_permutation,\n-                     VEC (slp_tree, heap) **loads)\n+                     VEC (slp_tree, heap) **loads,\n+                     unsigned int vectorization_factor)\n {\n   VEC (gimple, heap) *def_stmts0 = VEC_alloc (gimple, heap, group_size);\n   VEC (gimple, heap) *def_stmts1 =  VEC_alloc (gimple, heap, group_size);\n@@ -290,7 +319,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n   tree lhs;\n   bool stop_recursion = false, need_same_oprnds = false;\n   tree vectype, scalar_type, first_op1 = NULL_TREE;\n-  unsigned int vectorization_factor = 0, ncopies;\n+  unsigned int ncopies;\n   optab optab;\n   int icode;\n   enum machine_mode optab_op2_mode;\n@@ -336,13 +365,18 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n             }\n           return false;\n         }\n-\n-      gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-      vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\t\n       ncopies = vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n-      if (ncopies > 1 && vect_print_dump_info (REPORT_SLP))\n-        fprintf (vect_dump, \"SLP with multiple types \");\n+      if (ncopies != 1)\n+        {\n+\t  if (vect_print_dump_info (REPORT_SLP))\n+            fprintf (vect_dump, \"SLP with multiple types \");\n \n+          /* FORNOW: multiple types are unsupported in BB SLP.  */\n+\t  if (bb_vinfo)\n+\t    return false;\n+        }\n+\t\n       /* In case of multiple types we need to detect the smallest type.  */\n       if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n         *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -438,8 +472,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t  if (REFERENCE_CLASS_P (lhs))\n \t    {\n \t      /* Store.  */\n-\t      if (!vect_get_and_check_slp_defs (loop_vinfo, *node, stmt,\n-\t\t\t\t\t\t&def_stmts0, &def_stmts1, \n+\t      if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, \n+\t\t\t\t\t\tstmt, &def_stmts0, &def_stmts1, \n \t\t\t\t\t\t&first_stmt_dt0, \n \t\t\t\t\t\t&first_stmt_dt1, \n \t\t\t\t\t\t&first_stmt_def0_type, \n@@ -552,7 +586,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t    }\n \n \t  /* Find the def-stmts.  */ \n-\t  if (!vect_get_and_check_slp_defs (loop_vinfo, *node, stmt,\n+\t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n \t\t\t\t\t    &def_stmts0, &def_stmts1,\n \t\t\t\t\t    &first_stmt_dt0, &first_stmt_dt1, \n \t\t\t\t\t    &first_stmt_def0_type, \n@@ -590,9 +624,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_RIGHT (left_node) = NULL;\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (left_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (left_node) = 0;\n-      if (!vect_build_slp_tree (loop_vinfo, &left_node, group_size, \n+      if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &left_node, group_size, \n \t\t\t\tinside_cost, outside_cost, ncopies_for_cost, \n-\t\t\t\tmax_nunits, load_permutation, loads))\n+\t\t\t\tmax_nunits, load_permutation, loads,\n+\t\t\t\tvectorization_factor))\n \treturn false;\n       \n       SLP_TREE_LEFT (*node) = left_node;\n@@ -607,9 +642,10 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n       SLP_TREE_RIGHT (right_node) = NULL;\n       SLP_TREE_OUTSIDE_OF_LOOP_COST (right_node) = 0;\n       SLP_TREE_INSIDE_OF_LOOP_COST (right_node) = 0;\n-      if (!vect_build_slp_tree (loop_vinfo, &right_node, group_size,\n+      if (!vect_build_slp_tree (loop_vinfo, bb_vinfo, &right_node, group_size,\n \t\t\t\tinside_cost, outside_cost, ncopies_for_cost,\n-\t\t\t\tmax_nunits, load_permutation, loads))\n+\t\t\t\tmax_nunits, load_permutation, loads,\n+\t\t\t\tvectorization_factor))\n \treturn false;\n       \n       SLP_TREE_RIGHT (*node) = right_node;\n@@ -664,6 +700,31 @@ vect_mark_slp_stmts (slp_tree node, enum slp_vect_type mark, int j)\n }\n \n \n+/* Mark the statements of the tree rooted at NODE as relevant (vect_used).  */\n+\n+static void\n+vect_mark_slp_stmts_relevant (slp_tree node)\n+{\n+  int i;\n+  gimple stmt;\n+  stmt_vec_info stmt_info;\n+\n+  if (!node)\n+    return;\n+\n+  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+    {\n+      stmt_info = vinfo_for_stmt (stmt);\n+      gcc_assert (!STMT_VINFO_RELEVANT (stmt_info) \n+                  || STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope);\n+      STMT_VINFO_RELEVANT (stmt_info) = vect_used_in_scope;\n+    }\n+\n+  vect_mark_slp_stmts_relevant (SLP_TREE_LEFT (node));\n+  vect_mark_slp_stmts_relevant (SLP_TREE_RIGHT (node));\n+}\n+\n+\n /* Check if the permutation required by the SLP INSTANCE is supported.  \n    Reorganize the SLP nodes stored in SLP_INSTANCE_LOADS if needed.  */\n \n@@ -736,7 +797,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   int i = 0, j, prev = -1, next, k;\n   bool supported;\n \n-  /* FORNOW: permutations are only supported for loop-aware SLP.  */\n+  /* FORNOW: permutations are only supported in SLP.  */\n   if (!slp_instn)\n     return false;\n \n@@ -809,7 +870,8 @@ vect_find_first_load_in_slp_instance (slp_instance instance)\n    Return FALSE if it's impossible to SLP any stmt in the loop.  */\n \n static bool\n-vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n+vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+                           gimple stmt)\n {\n   slp_instance new_instance;\n   slp_tree node = XNEW (struct _slp_tree);\n@@ -818,7 +880,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   tree vectype, scalar_type;\n   gimple next;\n   unsigned int vectorization_factor = 0, ncopies;\n-  bool slp_impossible = false; \n   int inside_cost = 0, outside_cost = 0, ncopies_for_cost;\n   unsigned int max_nunits = 0;\n   VEC (int, heap) *load_permutation;\n@@ -838,9 +899,24 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n     }\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  if (loop_vinfo)\n+    vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  else\n+    /* No multitypes in BB SLP.  */\n+    vectorization_factor = nunits;\n+\n   ncopies = vectorization_factor / nunits;\n \n+  /* Calculate the unrolling factor.  */\n+  unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n+  if (unrolling_factor != 1 && !loop_vinfo)\n+    {\n+      if (vect_print_dump_info (REPORT_SLP))\n+        fprintf (vect_dump, \"Build SLP failed: unrolling required in BB SLP\");\n+      \n+      return false;\n+    }\n+\n   /* Create a node (a root of the SLP tree) for the packed strided stores.  */ \n   SLP_TREE_SCALAR_STMTS (node) = VEC_alloc (gimple, heap, group_size);\n   next = stmt;\n@@ -858,9 +934,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   SLP_TREE_OUTSIDE_OF_LOOP_COST (node) = 0;\n   SLP_TREE_INSIDE_OF_LOOP_COST (node) = 0;\n \n-  /* Calculate the unrolling factor.  */\n-  unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n-\t\n   /* Calculate the number of vector stmts to create based on the unrolling\n      factor (number of vectors is 1 if NUNITS >= GROUP_SIZE, and is\n      GROUP_SIZE / NUNITS otherwise.  */\n@@ -870,9 +943,10 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   loads = VEC_alloc (slp_tree, heap, group_size); \n \n   /* Build the tree for the SLP instance.  */\n-  if (vect_build_slp_tree (loop_vinfo, &node, group_size, &inside_cost,  \n-\t\t\t   &outside_cost, ncopies_for_cost, &max_nunits,\n-                           &load_permutation, &loads))\n+  if (vect_build_slp_tree (loop_vinfo, bb_vinfo, &node, group_size, \n+                           &inside_cost, &outside_cost, ncopies_for_cost, \n+\t\t\t   &max_nunits, &load_permutation, &loads, \n+\t\t\t   vectorization_factor))\n     {\n       /* Create a new SLP instance.  */  \n       new_instance = XNEW (struct _slp_instance);\n@@ -883,7 +957,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n       if (max_nunits > nunits)\n         unrolling_factor = least_common_multiple (max_nunits, group_size)\n                            / group_size;\n-\n+\t\t\t   \n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (new_instance) = outside_cost;\n       SLP_INSTANCE_INSIDE_OF_LOOP_COST (new_instance) = inside_cost;\n@@ -912,8 +986,14 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n       else\n         VEC_free (int, heap, SLP_INSTANCE_LOAD_PERMUTATION (new_instance));\n \n-      VEC_safe_push (slp_instance, heap, LOOP_VINFO_SLP_INSTANCES (loop_vinfo), \n-\t\t     new_instance);\n+      if (loop_vinfo)\n+        VEC_safe_push (slp_instance, heap, \n+                       LOOP_VINFO_SLP_INSTANCES (loop_vinfo), \n+  \t\t       new_instance);\n+      else\n+        VEC_safe_push (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo),\n+                       new_instance);\n+\t\t       \n       if (vect_print_dump_info (REPORT_SLP))\n \tvect_print_slp_tree (node);\n \n@@ -926,37 +1006,40 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, gimple stmt)\n   VEC_free (int, heap, load_permutation);\n   VEC_free (slp_tree, heap, loads);\n    \n-  if (slp_impossible)\n-    return false;\n-\n-  /* SLP failed for this instance, but it is still possible to SLP other stmts \n-     in the loop.  */\n-  return true;\n+  return false;\n }\n \n \n /* Check if there are stmts in the loop can be vectorized using SLP. Build SLP\n    trees of packed scalar stmts if SLP is possible.  */\n \n bool\n-vect_analyze_slp (loop_vec_info loop_vinfo)\n+vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n   unsigned int i;\n-  VEC (gimple, heap) *strided_stores = LOOP_VINFO_STRIDED_STORES (loop_vinfo);\n+  VEC (gimple, heap) *strided_stores;\n   gimple store;\n+  bool ok = false;\n \n   if (vect_print_dump_info (REPORT_SLP))\n     fprintf (vect_dump, \"=== vect_analyze_slp ===\");\n \n+  if (loop_vinfo)\n+    strided_stores = LOOP_VINFO_STRIDED_STORES (loop_vinfo);\n+  else\n+    strided_stores = BB_VINFO_STRIDED_STORES (bb_vinfo);\n+    \n   for (i = 0; VEC_iterate (gimple, strided_stores, i, store); i++)\n-    if (!vect_analyze_slp_instance (loop_vinfo, store))\n-      {\n-\t/* SLP failed. No instance can be SLPed in the loop.  */\n-\tif (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\t\n-\t  fprintf (vect_dump, \"SLP failed.\");\n+    if (vect_analyze_slp_instance (loop_vinfo, bb_vinfo, store))\n+      ok = true;\n \n-\treturn false;\n-      }\n+  if (bb_vinfo && !ok)    \n+    {\n+      if (vect_print_dump_info (REPORT_SLP))\n+        fprintf (vect_dump, \"Failed to SLP the basic block.\");\n+\n+      return false;\n+    }\n \n   return true;\n }\n@@ -1041,6 +1124,255 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n     vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n }\n \n+\n+/* Create and initialize a new bb_vec_info struct for BB, as well as\n+   stmt_vec_info structs for all the stmts in it.  */\n+ \n+static bb_vec_info\n+new_bb_vec_info (basic_block bb)\n+{\n+  bb_vec_info res = NULL;\n+  gimple_stmt_iterator gsi;\n+\n+  res = (bb_vec_info) xcalloc (1, sizeof (struct _bb_vec_info));\n+  BB_VINFO_BB (res) = bb;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      gimple_set_uid (stmt, 0);\n+      set_vinfo_for_stmt (stmt, new_stmt_vec_info (stmt, NULL, res));\n+    }\n+\n+  BB_VINFO_STRIDED_STORES (res) = VEC_alloc (gimple, heap, 10);\n+  BB_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 2);\n+\n+  bb->aux = res;\n+  return res;\n+}\n+\n+\n+/* Free BB_VINFO struct, as well as all the stmt_vec_info structs of all the\n+   stmts in the basic block.  */\n+\n+static void\n+destroy_bb_vec_info (bb_vec_info bb_vinfo)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator si;\n+\n+  if (!bb_vinfo)\n+    return;\n+\n+  bb = BB_VINFO_BB (bb_vinfo);\n+\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple stmt = gsi_stmt (si);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+      if (stmt_info)\n+        /* Free stmt_vec_info.  */\n+        free_stmt_vec_info (stmt);\n+    }\n+\n+  VEC_free (gimple, heap, BB_VINFO_STRIDED_STORES (bb_vinfo));\n+  VEC_free (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo));\n+  free (bb_vinfo);\n+  bb->aux = NULL;\n+}\n+\n+\n+/* Analyze statements contained in SLP tree node after recursively analyzing\n+   the subtree. Return TRUE if the operations are supported.  */\n+\n+static bool\n+vect_slp_analyze_node_operations (bb_vec_info bb_vinfo, slp_tree node)\n+{\n+  bool dummy;\n+  int i;\n+  gimple stmt;\n+\n+  if (!node)\n+    return true;\n+\n+  if (!vect_slp_analyze_node_operations (bb_vinfo, SLP_TREE_LEFT (node))\n+      || !vect_slp_analyze_node_operations (bb_vinfo, SLP_TREE_RIGHT (node)))\n+    return false;\n+\n+  for (i = 0; VEC_iterate (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt); i++)\n+    {\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+      gcc_assert (stmt_info);\n+      gcc_assert (PURE_SLP_STMT (stmt_info));\n+\n+      if (!vect_analyze_stmt (stmt, &dummy, node))\n+        return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+/* Analyze statements in SLP instances of the basic block. Return TRUE if the\n+   operations are supported. */\n+\n+static bool\n+vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n+{\n+  VEC (slp_instance, heap) *slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n+  slp_instance instance;\n+  int i;\n+\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); )\n+    {\n+      if (!vect_slp_analyze_node_operations (bb_vinfo, \n+                                             SLP_INSTANCE_TREE (instance)))\n+        {\n+ \t  vect_free_slp_instance (instance);\n+          VEC_ordered_remove (slp_instance, slp_instances, i);\n+\t}\n+      else\n+        i++;\n+    }\t\n+ \n+  if (!VEC_length (slp_instance, slp_instances))\n+    return false;\n+\n+  return true;\n+}\n+\n+\n+/* Cheick if the basic block can be vectorized.  */\n+\n+bb_vec_info\n+vect_slp_analyze_bb (basic_block bb)\n+{\n+  bb_vec_info bb_vinfo;\n+  VEC (ddr_p, heap) *ddrs;\n+  VEC (slp_instance, heap) *slp_instances;\n+  slp_instance instance;\n+  int i, insns = 0;\n+  gimple_stmt_iterator gsi;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    insns++;\n+\n+  if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: too many instructions in basic \"\n+                            \"block.\\n\");\n+\n+      return NULL;\n+    }\n+\n+  bb_vinfo = new_bb_vec_info (bb);\n+  if (!bb_vinfo)\n+    return NULL;\n+\n+  if (!vect_analyze_data_refs (NULL, bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: unhandled data-ref in basic \"\n+                            \"block.\\n\");\n+\t\t  \n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+  ddrs = BB_VINFO_DDRS (bb_vinfo);\n+  if (!VEC_length (ddr_p, ddrs)) \n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: not enough data-refs in basic \"\n+                            \"block.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+  if (!vect_analyze_data_refs_alignment (NULL, bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: bad data alignment in basic \"\n+                            \"block.\\n\");\n+\t\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+   \n+   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo))\n+    {\n+     if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+       fprintf (vect_dump, \"not vectorized: unhandled data dependence in basic\"\n+                           \" block.\\n\");\n+\t\t  \n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+  if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n+    {\n+     if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+       fprintf (vect_dump, \"not vectorized: unhandled data access in basic \"\n+                           \"block.\\n\");\n+\t\t\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+   if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: unsupported alignment in basic \"\n+                            \"block.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+  /* Check the SLP opportunities in the basic block, analyze and build SLP\n+     trees.  */\n+  if (!vect_analyze_slp (NULL, bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: failed to find SLP opportunities \"\n+                            \"in basic block.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+  \n+  slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n+\n+  /* Mark all the statements that we want to vectorize as pure SLP and\n+     relevant.  */\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    {\n+      vect_mark_slp_stmts (SLP_INSTANCE_TREE (instance), pure_slp, -1);\n+      vect_mark_slp_stmts_relevant (SLP_INSTANCE_TREE (instance));\n+    }  \n+\n+  if (!vect_slp_analyze_operations (bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: bad operation in basic block.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"BB will be vectorized using SLP\\n\");\n+\n+  return bb_vinfo;\n+}\n+\n+\n /* SLP costs are calculated according to SLP instance unrolling factor (i.e., \n    the number of created vector stmts depends on the unrolling factor). However,\n    the actual number of vector stmts for every SLP node depends on VF which is\n@@ -1064,6 +1396,7 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n       / SLP_INSTANCE_UNROLLING_FACTOR (instance);\t  \n }\n \n+\n /* For constant and loop invariant defs of SLP_NODE this function returns \n    (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.  \n    OP_NUM determines if we gather defs for operand 0 or operand 1 of the scalar\n@@ -1284,6 +1617,7 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n     vect_get_constant_vectors (slp_node, vec_oprnds1, 1, number_of_vects);\n }\n \n+\n /* Create NCOPIES permutation statements using the mask MASK_BYTES (by \n    building a vector of type MASK_TYPE from it) and two input vectors placed in\n    DR_CHAIN at FIRST_VEC_INDX and SECOND_VEC_INDX for the first copy and\n@@ -1588,7 +1922,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n static bool\n vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n-                            unsigned int vectorization_factor) \n+                            unsigned int vectorization_factor)\n {\n   gimple stmt;\n   bool strided_store, is_store;\n@@ -1658,7 +1992,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n     si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n   else\n     si = gsi_for_stmt (stmt);\n-\n+  \n   is_store = vect_transform_stmt (stmt, &si, &strided_store, node, instance);\n   if (is_store)\n     {\n@@ -1680,24 +2014,81 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \n \n bool\n-vect_schedule_slp (loop_vec_info loop_vinfo)\n+vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n {\n-  VEC (slp_instance, heap) *slp_instances = \n-    LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+  VEC (slp_instance, heap) *slp_instances;\n   slp_instance instance;\n-  unsigned int i;\n+  unsigned int i, vf;\n   bool is_store = false;\n \n+  if (loop_vinfo)\n+    {\n+      slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n+      vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+    }  \n+  else\n+    {\n+      slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n+      vf = 1;\n+    }  \n+\n   for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n     {\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n-                            instance, LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n-\t\t\t  \n+                                             instance, vf);\n       if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS)\n \t  || vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \tfprintf (vect_dump, \"vectorizing stmts using SLP.\");\n     }\n \n   return is_store;\n }\n+\n+\n+/* Vectorize the basic block.  */\n+\n+void\n+vect_slp_transform_bb (basic_block bb)\n+{\n+  bb_vec_info bb_vinfo = vec_info_for_bb (bb);\n+  gimple_stmt_iterator si;\n+\n+  gcc_assert (bb_vinfo);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"SLPing BB\\n\");\n+\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple stmt = gsi_stmt (si);\n+      stmt_vec_info stmt_info;\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"------>SLPing statement: \");\n+          print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+        }\n+\n+      stmt_info = vinfo_for_stmt (stmt);\n+      gcc_assert (stmt_info);\n+\n+      /* Schedule all the SLP instances when the first SLP stmt is reached.  */\n+      if (STMT_SLP_TYPE (stmt_info))\n+        {\n+          vect_schedule_slp (NULL, bb_vinfo);\n+          break;\n+        }\n+    }\n+\n+  mark_sym_for_renaming (gimple_vop (cfun));\n+  /* The memory tags and pointers in vectorized statements need to\n+     have their SSA forms updated.  FIXME, why can't this be delayed\n+     until all the loops have been transformed?  */\n+  update_ssa (TODO_update_ssa);\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"BB VECTORIZED\\n\");\n+}\n+\n+"}, {"sha": "9ac733a76beba10c8bddda86bbd5cb0908f077b1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 204, "deletions": 82, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -248,7 +248,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   if (!exist_non_indexing_operands_for_use_p (use, stmt))\n      return true;\n \n-  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (use, loop_vinfo, NULL, &def_stmt, &def, &dt))\n     { \n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n@@ -336,7 +336,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n         {\n         case vect_unused_in_scope:\n           relevant = (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def) ?\n-                        vect_used_in_outer_by_reduction : vect_unused_in_scope;\n+                      vect_used_in_outer_by_reduction : vect_unused_in_scope;\n           break;\n \n         case vect_used_in_outer_by_reduction:\n@@ -813,13 +813,29 @@ vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n   else\n     {\n       loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-      if (nested_in_vect_loop_p (loop, stmt))\n-        loop = loop->inner;\n-      pe = loop_preheader_edge (loop);\n-      new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n-      gcc_assert (!new_bb);\n+      \n+      if (loop_vinfo)\n+        {\n+          struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+          if (nested_in_vect_loop_p (loop, stmt))\n+            loop = loop->inner;\n+          \n+\t  pe = loop_preheader_edge (loop);\n+          new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n+          gcc_assert (!new_bb);\n+\t}\n+      else\n+       {\n+          bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_vinfo);\n+          basic_block bb;\n+          gimple_stmt_iterator gsi_bb_start;\n+\n+          gcc_assert (bb_vinfo);\n+          bb = BB_VINFO_BB (bb_vinfo);\n+          gsi_bb_start = gsi_start_bb (bb);\n+          gsi_insert_before (&gsi_bb_start, init_stmt, GSI_SAME_STMT);\n+       }\n     }\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -832,6 +848,7 @@ vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n   return vec_oprnd;\n }\n \n+\n /* Function vect_get_vec_def_for_operand.\n \n    OP is an operand in STMT. This function returns a (vector) def that will be\n@@ -869,7 +886,8 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       print_generic_expr (vect_dump, op, TDF_SLIM);\n     }\n \n-  is_simple_use = vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n+  is_simple_use = vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def, \n+                                      &dt);\n   gcc_assert (is_simple_use);\n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1122,12 +1140,14 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n   gcc_assert (gimple_code (stmt) != GIMPLE_LABEL);\n \n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n \n-  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, loop_vinfo));\n+  set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, loop_vinfo, \n+                                                   bb_vinfo));\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1191,6 +1211,9 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   enum { NARROW, NONE, WIDEN } modifier;\n   size_t i, nargs;\n \n+  /* FORNOW: unsupported in basic block SLP.  */\n+  gcc_assert (loop_vinfo);\n+    \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -1232,7 +1255,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \t}\n       rhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[i]))\n+      if (!vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def, &dt[i]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -1509,6 +1532,9 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Is STMT a vectorizable conversion?   */\n \n+  /* FORNOW: unsupported in basic block SLP.  */\n+  gcc_assert (loop_vinfo);\n+  \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -1575,7 +1601,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   gcc_assert (ncopies >= 1);\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"use not simple.\");\n@@ -1759,6 +1785,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   int i;\n   VEC(tree,heap) *vec_oprnds = NULL;\n   tree vop;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n@@ -1772,7 +1799,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (ncopies > 1)\n     return false; /* FORNOW */\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -1792,7 +1819,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   else\n     return false;\n \n-  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -1875,6 +1902,14 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   unsigned int k;\n   bool shift_p = false;\n   bool scalar_shift_arg = false;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  int vf;\n+\n+  if (loop_vinfo)\n+    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  else\n+    /* FORNOW: multiple types are not supported in basic block SLP.  */\n+    vf = nunits_in;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n@@ -1886,7 +1921,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -1924,7 +1959,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use (op0, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -1934,7 +1969,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt[1]))\n+      if (!vect_is_simple_use (op1, loop_vinfo, bb_vinfo, &def_stmt, &def, \n+                               &dt[1]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -2016,8 +2052,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \tfprintf (vect_dump, \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n-          || (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t      < vect_min_worthwhile_factor (code)\n+\t  || (vf < vect_min_worthwhile_factor (code)\n               && !vec_stmt))\n         return false;\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2026,8 +2061,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Worthwhile without SIMD support? Check only during analysis.  */\n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n-      && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t < vect_min_worthwhile_factor (code)\n+      && vf < vect_min_worthwhile_factor (code)\n       && !vec_stmt)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2333,6 +2367,9 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n   tree last_oprnd, intermediate_type;\n \n+  /* FORNOW: not supported by basic block SLP vectorization.  */\n+  gcc_assert (loop_vinfo);\n+\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -2371,7 +2408,6 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     ncopies = 1;\n   else\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n-\n   gcc_assert (ncopies >= 1);\n \n   if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n@@ -2382,7 +2418,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -2562,7 +2598,7 @@ vect_create_vectorized_promotion_stmts (VEC (tree, heap) **vec_oprnds0,\n                                               prev_stmt_info);\n     }\n }\n-\n+    \n \n /* Function vectorizable_type_promotion\n \n@@ -2600,6 +2636,9 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   VEC (tree, heap) *vec_dsts = NULL, *interm_types = NULL, *tmp_vec_dsts = NULL;\n   \n+  /* FORNOW: not supported by basic block SLP vectorization.  */\n+  gcc_assert (loop_vinfo);\n+    \n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n     return false;\n \n@@ -2650,7 +2689,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"use not simple.\");\n@@ -2661,7 +2700,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, loop_vinfo, &def_stmt, &def, &dt[1]))\n+      if (!vect_is_simple_use (op1, loop_vinfo, NULL, &def_stmt, &def, &dt[1]))\n         {\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -2806,7 +2845,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n   enum machine_mode vec_mode;\n   tree dummy;\n   enum dr_alignment_support alignment_support_scheme;\n@@ -2827,6 +2866,10 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool slp = (slp_node != NULL);\n   stmt_vec_info first_stmt_vinfo;\n   unsigned int vec_num;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+\n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n@@ -2839,14 +2882,14 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   gcc_assert (ncopies >= 1);\n \n   /* FORNOW. This restriction should be relaxed.  */\n-  if (nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n+  if (loop && nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"multiple types in nested loop.\");\n       return false;\n     }\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -2865,7 +2908,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   gcc_assert (gimple_assign_single_p (stmt));\n   op = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -2907,7 +2950,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n             {\n \t      gcc_assert (gimple_assign_single_p (next_stmt));\n \t      op = gimple_assign_rhs1 (next_stmt);\n-              if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt))\n+              if (!vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, \n+                                       &def, &dt))\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump, \"use not simple.\");\n@@ -2935,7 +2979,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n \n       /* FORNOW */\n-      gcc_assert (!nested_in_vect_loop_p (loop, stmt));\n+      gcc_assert (!loop || !nested_in_vect_loop_p (loop, stmt));\n \n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n@@ -3063,7 +3107,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE, \n \t\t\t\t\t\t  &dummy, &ptr_incr, false, \n \t\t\t\t\t\t  &inv_p);\n-\t  gcc_assert (!inv_p);\n+\t  gcc_assert (bb_vinfo || !inv_p);\n \t}\n       else \n \t{\n@@ -3077,7 +3121,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = VEC_index (tree, oprnds, i);\n-\t      vect_is_simple_use (op, loop_vinfo, &def_stmt, &def, &dt);\n+\t      vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, &def, \n+\t                          &dt);\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, op); \n \t      VEC_replace(tree, dr_chain, i, vec_oprnd);\n \t      VEC_replace(tree, oprnds, i, vec_oprnd);\n@@ -3162,9 +3207,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   stmt_vec_info prev_stmt_info; \n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n   struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n-  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+  bool nested_in_vect_loop = false;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n@@ -3192,6 +3237,18 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool slp = (slp_node != NULL);\n   bool slp_perm = false;\n   enum tree_code code;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  int vf;\n+\n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+      vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+    }\n+  else\n+    /* FORNOW: multiple types are not supported in basic block SLP.  */\n+    vf = nunits;\n \n   /* Multiple types in SLP are handled by creating the appropriate number of\n      vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n@@ -3211,10 +3268,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return false;\n     }\n \n-  if (slp && SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance))\n-    slp_perm = true;\n- \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n@@ -3300,7 +3354,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  strided_load = false;\n \t  vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-\t}\n+          if (SLP_INSTANCE_LOAD_PERMUTATION (slp_node_instance))\n+            slp_perm = true;\n+    \t}\n       else\n \tvec_num = group_size;\n \n@@ -3419,7 +3475,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n      This can only occur when vectorizing memory accesses in the inner-loop\n      nested within an outer-loop that is being vectorized.  */\n \n-  if (nested_in_vect_loop_p (loop, stmt)\n+  if (loop && nested_in_vect_loop_p (loop, stmt)\n       && (TREE_INT_CST_LOW (DR_STEP (dr))\n \t  % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0))\n     {\n@@ -3551,7 +3607,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    }\n \n \t  /* 4. Handle invariant-load.  */\n-\t  if (inv_p)\n+\t  if (inv_p && !bb_vinfo)\n \t    {\n \t      gcc_assert (!strided_load);\n \t      gcc_assert (nested_in_vect_loop_p (loop, stmt));\n@@ -3598,8 +3654,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n       if (slp_perm)\n         {\n-          if (!vect_transform_slp_perm_load (stmt, dr_chain, gsi,\n-                                   LOOP_VINFO_VECT_FACTOR (loop_vinfo),\n+          if (!vect_transform_slp_perm_load (stmt, dr_chain, gsi, vf,\n                                              slp_node_instance, false))\n             {\n               VEC_free (tree, heap, dr_chain);\n@@ -3659,7 +3714,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use (lhs, loop_vinfo, &lhs_def_stmt, &def, &dt))\n+      if (!vect_is_simple_use (lhs, loop_vinfo, NULL, &lhs_def_stmt, &def, \n+                               &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST\n@@ -3669,7 +3725,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use (rhs, loop_vinfo, &rhs_def_stmt, &def, &dt))\n+      if (!vect_is_simple_use (rhs, loop_vinfo, NULL, &rhs_def_stmt, &def, \n+                               &dt))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST\n@@ -3709,6 +3766,9 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n   enum tree_code code;\n \n+  /* FORNOW: unsupported in basic block SLP.  */\n+  gcc_assert (loop_vinfo);\n+    \n   gcc_assert (ncopies >= 1);\n   if (ncopies > 1)\n     return false; /* FORNOW */\n@@ -3757,7 +3817,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (then_clause) == SSA_NAME)\n     {\n       gimple then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, loop_vinfo, \n+      if (!vect_is_simple_use (then_clause, loop_vinfo, NULL, \n \t\t\t       &then_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -3769,7 +3829,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (else_clause) == SSA_NAME)\n     {\n       gimple else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, loop_vinfo, \n+      if (!vect_is_simple_use (else_clause, loop_vinfo, NULL,\n \t\t\t       &else_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -3819,27 +3879,30 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n /* Make sure the statement is vectorizable.  */\n \n bool\n-vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n+vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);  \n   bool ok;\n+  HOST_WIDE_INT dummy;\n+  tree scalar_type, vectype;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       fprintf (vect_dump, \"==> examining statement: \");\n       print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n     }\n \n-  /* Skip stmts that do not need to be vectorized. In loops this is expected\n+  /* Skip stmts that do not need to be vectorized. In loops this is expected \n      to include:\n      - the COND_EXPR which is the loop exit condition\n      - any LABEL_EXPRs in the loop\n-     - computations that are used only for array indexing or loop control.\n+     - computations that are used only for array indexing or loop control.  \n      In basic blocks we only analyze statements that are a part of some SLP\n      instance, therefore, all the statements are relevant.  */\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) \n       && !STMT_VINFO_LIVE_P (stmt_info))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3854,9 +3917,9 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n         break;\n \n       case vect_reduction_def:\n-         gcc_assert (relevance == vect_used_in_outer\n+         gcc_assert (!bb_vinfo && (relevance == vect_used_in_outer\n                      || relevance == vect_used_in_outer_by_reduction\n-                     || relevance == vect_unused_in_scope);\n+                     || relevance == vect_unused_in_scope));\n          break;\n \n       case vect_induction_def:\n@@ -3867,6 +3930,37 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n         gcc_unreachable ();\n     }\n \n+  if (bb_vinfo)\n+    {\n+      gcc_assert (PURE_SLP_STMT (stmt_info));\n+\n+      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"get vectype for scalar type:  \");\n+          print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+        }\n+\n+      vectype = get_vectype_for_scalar_type (scalar_type);\n+      if (!vectype)\n+        {\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            {\n+               fprintf (vect_dump, \"not SLPed: unsupported data-type \");\n+               print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+            }\n+          return false;\n+        }\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"vectype:  \");\n+          print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+        }\n+\n+      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n+   }\n+\n   if (STMT_VINFO_RELEVANT_P (stmt_info))\n     {\n       gcc_assert (!VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))));\n@@ -3875,8 +3969,9 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n     }\n \n    ok = true;\n-   if (STMT_VINFO_RELEVANT_P (stmt_info)\n-       || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n+   if (!bb_vinfo \n+       && (STMT_VINFO_RELEVANT_P (stmt_info)\n+           || STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def))\n       ok = (vectorizable_type_promotion (stmt, NULL, NULL, NULL)\n             || vectorizable_type_demotion (stmt, NULL, NULL, NULL)\n             || vectorizable_conversion (stmt, NULL, NULL, NULL)\n@@ -3887,6 +3982,14 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n             || vectorizable_store (stmt, NULL, NULL, NULL)\n             || vectorizable_condition (stmt, NULL, NULL)\n             || vectorizable_reduction (stmt, NULL, NULL));\n+    else\n+      {\n+        if (bb_vinfo)\n+          ok = (vectorizable_operation (stmt, NULL, NULL, node)\n+                || vectorizable_assignment (stmt, NULL, NULL, node)\n+                || vectorizable_load (stmt, NULL, NULL, node, NULL)\n+                || vectorizable_store (stmt, NULL, NULL, node));\n+      }\t    \n \n   if (!ok)\n     {\n@@ -3896,10 +3999,13 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n           fprintf (vect_dump, \"supported: \");\n           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n         }\n-\n+    \n       return false;\n     }\n \n+  if (bb_vinfo)\n+    return true;\n+\n   /* Stmts that are (also) \"live\" (i.e. - that are used out of the loop)\n       need extra handling, except for vectorizable reductions.  */\n   if (STMT_VINFO_LIVE_P (stmt_info)\n@@ -3914,16 +4020,16 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n           fprintf (vect_dump, \"supported: \");\n           print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n         }\n-\n+   \n        return false;\n     }\n \n   if (!PURE_SLP_STMT (stmt_info))\n     {\n-      /* Groups of strided accesses whose size is not a power of 2 are not\n-         vectorizable yet using loop-vectorization. Therefore, if this stmt\n-         feeds non-SLP-able stmts (i.e., this stmt has to be both SLPed and\n-         loop-based vectorized), the loop cannot be vectorized.  */\n+      /* Groups of strided accesses whose size is not a power of 2 are not \n+         vectorizable yet using loop-vectorization. Therefore, if this stmt \n+\t feeds non-SLP-able stmts (i.e., this stmt has to be both SLPed and \n+\t loop-based vectorized), the loop cannot be vectorized.  */\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n           && exact_log2 (DR_GROUP_SIZE (vinfo_for_stmt (\n                                         DR_GROUP_FIRST_DR (stmt_info)))) == -1)\n@@ -3938,7 +4044,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize)\n           return false;\n         }\n     }\n-\n+     \n   return true;\n }\n \n@@ -3957,8 +4063,6 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   gimple orig_stmt_in_pattern;\n   bool done;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   switch (STMT_VINFO_TYPE (stmt_info))\n     {\n@@ -4045,19 +4149,23 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle inner-loop stmts whose DEF is used in the loop-nest that\n      is being vectorized, but outside the immediately enclosing loop.  */\n   if (vec_stmt\n-      && nested_in_vect_loop_p (loop, stmt)\n+      && STMT_VINFO_LOOP_VINFO (stmt_info)\n+      && nested_in_vect_loop_p (LOOP_VINFO_LOOP (\n+                                STMT_VINFO_LOOP_VINFO (stmt_info)), stmt)\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type\n       && (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_outer\n-          || STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_outer_by_reduction))\n+          || STMT_VINFO_RELEVANT (stmt_info) == \n+                                           vect_used_in_outer_by_reduction))\n     {\n-      struct loop *innerloop = loop->inner;\n+      struct loop *innerloop = LOOP_VINFO_LOOP (\n+                                STMT_VINFO_LOOP_VINFO (stmt_info))->inner;\n       imm_use_iterator imm_iter;\n       use_operand_p use_p;\n       tree scalar_dest;\n       gimple exit_phi;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n-       fprintf (vect_dump, \"Record the vdef for outer-loop vectorization.\");\n+        fprintf (vect_dump, \"Record the vdef for outer-loop vectorization.\");\n \n       /* Find the relevant loop-exit phi-node, and reord the vec_stmt there\n         (to be used when vectorizing outer-loop stmts that use the DEF of\n@@ -4137,14 +4245,16 @@ vect_remove_stores (gimple first_stmt)\n    Create and initialize a new stmt_vec_info struct for STMT.  */\n \n stmt_vec_info\n-new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo)\n+new_stmt_vec_info (gimple stmt, loop_vec_info loop_vinfo, \n+                   bb_vec_info bb_vinfo)\n {\n   stmt_vec_info res;\n   res = (stmt_vec_info) xcalloc (1, sizeof (struct _stmt_vec_info));\n \n   STMT_VINFO_TYPE (res) = undef_vec_info_type;\n   STMT_VINFO_STMT (res) = stmt;\n   STMT_VINFO_LOOP_VINFO (res) = loop_vinfo;\n+  STMT_VINFO_BB_VINFO (res) = bb_vinfo;\n   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_LIVE_P (res) = false;\n   STMT_VINFO_VECTYPE (res) = NULL;\n@@ -4267,23 +4377,30 @@ get_vectype_for_scalar_type (tree scalar_type)\n /* Function vect_is_simple_use.\n \n    Input:\n-   LOOP - the loop that is being vectorized.\n-   OPERAND - operand of a stmt in LOOP.\n+   LOOP_VINFO - the vect info of the loop that is being vectorized.\n+   BB_VINFO - the vect info of the basic block that is being vectorized.\n+   OPERAND - operand of a stmt in the loop or bb.\n    DEF - the defining stmt in case OPERAND is an SSA_NAME.\n \n    Returns whether a stmt with OPERAND can be vectorized.\n-   Supportable operands are constants, loop invariants, and operands that are\n-   defined by the current iteration of the loop. Unsupportable operands are \n-   those that are defined by a previous iteration of the loop (as is the case\n-   in reduction/induction computations).  */\n+   For loops, supportable operands are constants, loop invariants, and operands \n+   that are defined by the current iteration of the loop. Unsupportable \n+   operands are those that are defined by a previous iteration of the loop (as \n+   is the case in reduction/induction computations).\n+   For basic blocks, supportable operands are constants and bb invariants.\n+   For now, operands defined outside the basic block are not supported.  */\n \n bool\n-vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n+vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, \n+                    bb_vec_info bb_vinfo, gimple *def_stmt,\n \t\t    tree *def, enum vect_def_type *dt)\n { \n   basic_block bb;\n   stmt_vec_info stmt_vinfo;\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *loop = NULL;\n+  \n+  if (loop_vinfo)\n+    loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   *def_stmt = NULL;\n   *def = NULL_TREE;\n@@ -4299,6 +4416,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n       *dt = vect_constant_def;\n       return true;\n     }\n+    \n   if (is_gimple_min_invariant (operand))\n     {\n       *def = operand;\n@@ -4312,6 +4430,7 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n         fprintf (vect_dump, \"non-associatable copy.\");\n       operand = TREE_OPERAND (operand, 0);\n     }\n+    \n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -4343,7 +4462,10 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, gimple *def_stmt,\n     }\n \n   bb = gimple_bb (*def_stmt);\n-  if (!flow_bb_inside_loop_p (loop, bb))\n+\n+  if ((loop && !flow_bb_inside_loop_p (loop, bb))\n+      || (!loop && bb != BB_VINFO_BB (bb_vinfo))\n+      || (!loop && gimple_code (*def_stmt) == GIMPLE_PHI)) \n     *dt = vect_external_def;\n   else\n     {"}, {"sha": "4ab8547dee202745eacf0823db3399b133efc6e8", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 91, "deletions": 10, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -68,15 +68,17 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfglayout.h\"\n #include \"tree-vectorizer.h\"\n #include \"tree-pass.h\"\n+#include \"timevar.h\"\n \n /* vect_dump will be set to stderr or dump_file if exist.  */\n FILE *vect_dump;\n \n /* vect_verbosity_level set to an invalid value \n    to mark that it's uninitialized.  */\n static enum verbosity_levels vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n+static enum verbosity_levels user_vect_verbosity_level = MAX_VERBOSITY_LEVEL;\n \n-/* Loop location.  */\n+/* Loop or bb location.  */\n LOC vect_location;\n \n /* Bitmap of virtual variables to be renamed.  */\n@@ -99,9 +101,10 @@ vect_set_verbosity_level (const char *val)\n \n    vl = atoi (val);\n    if (vl < MAX_VERBOSITY_LEVEL)\n-     vect_verbosity_level = (enum verbosity_levels) vl;\n+     user_vect_verbosity_level = (enum verbosity_levels) vl;\n    else\n-     vect_verbosity_level = (enum verbosity_levels) (MAX_VERBOSITY_LEVEL - 1);\n+     user_vect_verbosity_level \n+      = (enum verbosity_levels) (MAX_VERBOSITY_LEVEL - 1);\n }\n \n \n@@ -115,17 +118,33 @@ vect_set_verbosity_level (const char *val)\n    print to stderr, otherwise print to the dump file.  */\n \n static void\n-vect_set_dump_settings (void)\n+vect_set_dump_settings (bool slp)\n {\n   vect_dump = dump_file;\n \n   /* Check if the verbosity level was defined by the user:  */\n-  if (vect_verbosity_level != MAX_VERBOSITY_LEVEL)\n+  if (user_vect_verbosity_level != MAX_VERBOSITY_LEVEL)\n     {\n-      /* If there is no dump file, print to stderr.  */\n-      if (!dump_file)\n-        vect_dump = stderr;\n-      return;\n+      vect_verbosity_level = user_vect_verbosity_level;\n+      /* Ignore user defined verbosity if dump flags require higher level of\n+         verbosity.  */\n+      if (dump_file) \n+        {\n+          if (((dump_flags & TDF_DETAILS) \n+                && vect_verbosity_level >= REPORT_DETAILS)\n+  \t       || ((dump_flags & TDF_STATS)\n+\t            && vect_verbosity_level >= REPORT_UNVECTORIZED_LOCATIONS))\n+            return;\n+        }\n+      else\n+        {\n+          /* If there is no dump file, print to stderr in case of loop \n+             vectorization.  */ \n+          if (!slp)\n+            vect_dump = stderr;\n+\n+          return;\n+        }\n     }\n \n   /* User didn't specify verbosity level:  */\n@@ -185,7 +204,7 @@ vectorize_loops (void)\n     return 0;\n \n   /* Fix the verbosity level if not defined explicitly by the user.  */\n-  vect_set_dump_settings ();\n+  vect_set_dump_settings (false);\n \n   /* Allocate the bitmap that records which virtual variables  \n      need to be renamed.  */\n@@ -245,6 +264,68 @@ vectorize_loops (void)\n }\n  \n \n+/*  Entry point to basic block SLP phase.  */\n+\n+static unsigned int\n+execute_vect_slp (void)\n+{\n+  basic_block bb;\n+\n+  /* Fix the verbosity level if not defined explicitly by the user.  */\n+  vect_set_dump_settings (true);\n+\n+  init_stmt_vec_info_vec ();\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      vect_location = find_bb_location (bb);\n+\n+      if (vect_slp_analyze_bb (bb))\n+        {\n+          vect_slp_transform_bb (bb);\n+\n+          if (vect_print_dump_info (REPORT_VECTORIZED_LOCATIONS))\n+            fprintf (vect_dump, \"basic block vectorized using SLP\\n\");\n+        }\n+    }\n+\n+  free_stmt_vec_info_vec ();\n+  return 0;\n+}\n+\n+static bool\n+gate_vect_slp (void)\n+{\n+  /* Apply SLP either if the vectorizer is on and the user didn't specify \n+     whether to run SLP or not, or if the SLP flag was set by the user.  */\n+  return ((flag_tree_vectorize != 0 && flag_tree_slp_vectorize != 0) \n+          || flag_tree_slp_vectorize == 1);\n+}\n+\n+struct gimple_opt_pass pass_slp_vectorize =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"slp\",                                /* name */\n+  gate_vect_slp,                        /* gate */\n+  execute_vect_slp,                     /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_TREE_SLP_VECTORIZATION,            /* tv_id */\n+  PROP_ssa | PROP_cfg,                  /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect\n+    | TODO_verify_ssa\n+    | TODO_dump_func\n+    | TODO_update_ssa   \n+    | TODO_verify_stmts                 /* todo_flags_finish */\n+ }\n+};\n+\n+\n /* Increase alignment of global arrays to improve vectorization potential.\n    TODO:\n    - Consider also structs that have an array field."}, {"sha": "bf2917008b1630faff01754c8ae8a1f07e29f994", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a70d6342473292caef639fdae67ae5b78b87b006/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a70d6342473292caef639fdae67ae5b78b87b006", "patch": "@@ -281,6 +281,36 @@ nested_in_vect_loop_p (struct loop *loop, gimple stmt)\n           && (loop->inner == (gimple_bb (stmt))->loop_father));\n }\n \n+typedef struct _bb_vec_info {\n+\n+  basic_block bb;\n+  /* All interleaving chains of stores in the basic block, represented by the \n+     first stmt in the chain.  */\n+  VEC(gimple, heap) *strided_stores;\n+\n+  /* All SLP instances in the basic block. This is a subset of the set of \n+     STRIDED_STORES of the basic block.  */\n+  VEC(slp_instance, heap) *slp_instances;\n+\n+  /* All data references in the basic block.  */\n+  VEC (data_reference_p, heap) *datarefs;\n+\n+  /* All data dependences in the basic block.  */\n+  VEC (ddr_p, heap) *ddrs;\n+} *bb_vec_info;\n+\n+#define BB_VINFO_BB(B)              (B)->bb\n+#define BB_VINFO_STRIDED_STORES(B)  (B)->strided_stores\n+#define BB_VINFO_SLP_INSTANCES(B)   (B)->slp_instances\n+#define BB_VINFO_DATAREFS(B)        (B)->datarefs\n+#define BB_VINFO_DDRS(B)            (B)->ddrs\n+\n+static inline bb_vec_info\n+vec_info_for_bb (basic_block bb)\n+{\n+  return (bb_vec_info) bb->aux;\n+}\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized defs.                                        */\n /*-----------------------------------------------------------------*/\n@@ -437,12 +467,16 @@ typedef struct _stmt_vec_info {\n \n   /*  Whether the stmt is SLPed, loop-based vectorized, or both.  */\n   enum slp_vect_type slp_type;\n+  \n+  /* The bb_vec_info with respect to which STMT is vectorized.  */\n+  bb_vec_info bb_vinfo;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n #define STMT_VINFO_TYPE(S)                 (S)->type\n #define STMT_VINFO_STMT(S)                 (S)->stmt\n #define STMT_VINFO_LOOP_VINFO(S)           (S)->loop_vinfo\n+#define STMT_VINFO_BB_VINFO(S)             (S)->bb_vinfo\n #define STMT_VINFO_RELEVANT(S)             (S)->relevant\n #define STMT_VINFO_LIVE_P(S)               (S)->live\n #define STMT_VINFO_VECTYPE(S)              (S)->vectype\n@@ -707,23 +741,24 @@ extern void slpeel_make_loop_iterate_ntimes (struct loop *, tree);\n extern bool slpeel_can_duplicate_loop_p (const struct loop *, const_edge);\n extern void vect_loop_versioning (loop_vec_info, bool, tree *, gimple_seq *);\n extern void vect_do_peeling_for_loop_bound (loop_vec_info, tree *,\n-\t\t\t\t\t    tree, gimple_seq);\n+                                            tree, gimple_seq);\n extern void vect_do_peeling_for_alignment (loop_vec_info);\n extern LOC find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n extern tree get_vectype_for_scalar_type (tree);\n-extern bool vect_is_simple_use (tree, loop_vec_info, gimple *, tree *,\n-\t\t\t\tenum vect_def_type *);\n+extern bool vect_is_simple_use (tree, loop_vec_info, bb_vec_info, gimple *,\n+                                tree *,  enum vect_def_type *);\n extern bool supportable_widening_operation (enum tree_code, gimple, tree,\n                                             tree *, tree *, enum tree_code *, \n                                             enum tree_code *, int *, \n                                             VEC (tree, heap) **);\n extern bool supportable_narrowing_operation (enum tree_code, const_gimple,\n                                              tree, enum tree_code *, int *, \n                                              VEC (tree, heap) **);\n-extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info);\n+extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info, \n+                                        bb_vec_info);\n extern void free_stmt_vec_info (gimple stmt);\n extern tree vectorizable_function (gimple, tree, tree);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n@@ -742,22 +777,23 @@ extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n extern bool vect_transform_stmt (gimple, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple);\n-extern bool vect_analyze_stmt (gimple, bool *);\n+extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n                                            (struct data_reference *);\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n-extern bool vect_analyze_data_ref_dependences (loop_vec_info);\n+extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n-extern bool vect_analyze_data_refs_alignment (loop_vec_info);\n-extern bool vect_analyze_data_ref_accesses (loop_vec_info);\n+extern bool vect_analyze_data_refs_alignment (loop_vec_info, bb_vec_info);\n+extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);\n+extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n-extern bool vect_analyze_data_refs (loop_vec_info);\n+extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info);\n extern tree vect_create_data_ref_ptr (gimple, struct loop *, tree, tree *,\n-                                      gimple *, bool, bool *);\n+                                      gimple *, bool, bool *); \n extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_strided_store_supported (tree);\n@@ -799,13 +835,16 @@ extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (gimple, VEC (tree, heap) *,\n                                           gimple_stmt_iterator *, int, \n                                           slp_instance, bool);\n-extern bool vect_schedule_slp (loop_vec_info);\n+extern bool vect_schedule_slp (loop_vec_info, bb_vec_info);\n extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n-extern bool vect_analyze_slp (loop_vec_info);\n+extern bool vect_analyze_slp (loop_vec_info, bb_vec_info);\n extern void vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n extern void vect_get_slp_defs (slp_tree, VEC (tree,heap) **,\n                                VEC (tree,heap) **);\n+extern LOC find_bb_location (basic_block);\n+extern bb_vec_info vect_slp_analyze_bb (basic_block);\n+extern void vect_slp_transform_bb (basic_block);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}