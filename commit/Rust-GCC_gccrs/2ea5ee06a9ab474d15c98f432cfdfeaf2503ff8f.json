{"sha": "2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVhNWVlMDZhOWFiNDc0ZDE1Yzk4ZjQzMmNmZGZlYWYyNTAzZmY4Zg==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2010-09-13T17:57:29Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2010-09-13T17:57:29Z"}, "message": "tree-ssa-ter.c (temp_expr_table_d): Add call_cnt field.\n\n\t* tree-ssa-ter.c (temp_expr_table_d): Add call_cnt field.\n\t(new_temp_expr_table): Allocate call_cnt vector.\n\t(free_temp_expr_table): Free it.\n\t(process_replaceable): Add call_cnt parm and set in vector.\n\t(find_replaceable_in_bb): Skip replacement if def/use span a call.\n\t(debug_ter): Dump call_cnt value, remove stderr uses.\n\nFrom-SVN: r164252", "tree": {"sha": "a2a47707d1425e8ff810edbdb47c56e534a34a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2a47707d1425e8ff810edbdb47c56e534a34a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f/comments", "author": null, "committer": null, "parents": [{"sha": "a8733ebff646c02dbe622118ac6a39ba7d352d47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8733ebff646c02dbe622118ac6a39ba7d352d47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8733ebff646c02dbe622118ac6a39ba7d352d47"}], "stats": {"total": 44, "additions": 35, "deletions": 9}, "files": [{"sha": "a29717b5d90eec5dbe05e0b06035b91738cdc4ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "patch": "@@ -1,3 +1,12 @@\n+2010-09-13  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* tree-ssa-ter.c (temp_expr_table_d): Add call_cnt field.\n+\t(new_temp_expr_table): Allocate call_cnt vector.\n+\t(free_temp_expr_table): Free it.\n+\t(process_replaceable): Add call_cnt parm and set in vector.\n+\t(find_replaceable_in_bb): Skip replacement if def/use span a call.\n+\t(debug_ter): Dump call_cnt value, remove stderr uses.\n+\n 2010-09-13  Jan Hubicka  <jh@suse.cz>\n \n \t* tree.c (build_zero_cst): New."}, {"sha": "01eb7bb1db87d8ccbe0f181c8eaf6a01f00ee3ab", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=2ea5ee06a9ab474d15c98f432cfdfeaf2503ff8f", "patch": "@@ -167,6 +167,7 @@ typedef struct temp_expr_table_d\n   bitmap partition_in_use;\t\t/* Partitions with kill entries.  */\n   bitmap new_replaceable_dependencies;\t/* Holding place for pending dep's.  */\n   int *num_in_part;\t\t\t/* # of ssa_names in a partition.  */\n+  int *call_cnt;\t\t\t/* Call count at definition.  */\n } *temp_expr_table_p;\n \n /* Used to indicate a dependency on VDEFs.  */\n@@ -209,6 +210,7 @@ new_temp_expr_table (var_map map)\n       if (p != NO_PARTITION)\n         t->num_in_part[p]++;\n     }\n+  t->call_cnt = XCNEWVEC (int, num_ssa_names + 1);\n \n   return t;\n }\n@@ -240,6 +242,7 @@ free_temp_expr_table (temp_expr_table_p t)\n   free (t->kill_list);\n   free (t->partition_dependencies);\n   free (t->num_in_part);\n+  free (t->call_cnt);\n \n   if (t->replaceable_expressions)\n     ret = t->replaceable_expressions;\n@@ -469,7 +472,7 @@ finished_with_expr (temp_expr_table_p tab, int version, bool free_expr)\n /* Create an expression entry for a replaceable expression.  */\n \n static void\n-process_replaceable (temp_expr_table_p tab, gimple stmt)\n+process_replaceable (temp_expr_table_p tab, gimple stmt, int call_cnt)\n {\n   tree var, def, basevar;\n   int version;\n@@ -510,6 +513,8 @@ process_replaceable (temp_expr_table_p tab, gimple stmt)\n       make_dependent_on_partition (tab, version, VIRTUAL_PARTITION (tab));\n       add_to_partition_kill_list (tab, VIRTUAL_PARTITION (tab), version);\n     }\n+\n+  tab->call_cnt[version] = call_cnt;\n }\n \n \n@@ -576,11 +581,12 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n {\n   gimple_stmt_iterator bsi;\n   gimple stmt;\n-  tree def, use;\n+  tree def, use, fndecl;\n   int partition;\n   var_map map = tab->map;\n   ssa_op_iter iter;\n   bool stmt_replaceable;\n+  int cur_call_cnt = 0;\n \n   for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n@@ -634,10 +640,12 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t\t    same_root_var = true;\n \t\t}\n \n-\t      /* Mark expression as replaceable unless stmt is volatile or the\n+\t      /* Mark expression as replaceable unless stmt is volatile, or the\n \t\t def variable has the same root variable as something in the\n-\t\t substitution list.  */\n-\t      if (gimple_has_volatile_ops (stmt) || same_root_var)\n+\t\t substitution list, or the def and use span a call such that\n+\t\t we'll expand lifetimes across a call.  */\n+\t      if (gimple_has_volatile_ops (stmt) || same_root_var ||\n+\t\t  tab->call_cnt[ver] != cur_call_cnt)\n \t\tfinished_with_expr (tab, ver, true);\n \t      else\n \t\tmark_replaceable (tab, use, stmt_replaceable);\n@@ -652,9 +660,17 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t    kill_expr (tab, partition);\n \t}\n \n+      /* Increment counter if this is a non BUILT_IN call. We allow\n+\t replacement over BUILT_IN calls since many will expand to inline\n+\t insns instead of a true call.  */\n+      if (is_gimple_call (stmt)\n+\t  && !((fndecl = gimple_call_fndecl (stmt))\n+\t       && DECL_BUILT_IN (fndecl)))\n+\tcur_call_cnt++;\n+\n       /* Now see if we are creating a new expression or not.  */\n       if (stmt_replaceable)\n-\tprocess_replaceable (tab, stmt);\n+\tprocess_replaceable (tab, stmt, cur_call_cnt);\n \n       /* Free any unused dependency lists.  */\n       bitmap_clear (tab->new_replaceable_dependencies);\n@@ -737,18 +753,19 @@ debug_ter (FILE *f, temp_expr_table_p t)\n   for (x = 1; x < num_ssa_names; x++)\n     if (t->expr_decl_uids[x])\n       {\n-        print_generic_expr (stderr, ssa_name (x), TDF_SLIM);\n+        print_generic_expr (f, ssa_name (x), TDF_SLIM);\n         fprintf (f, \" dep-parts : \");\n \tif (t->partition_dependencies[x]\n \t    && !bitmap_empty_p (t->partition_dependencies[x]))\n \t  {\n \t    EXECUTE_IF_SET_IN_BITMAP (t->partition_dependencies[x], 0, y, bi)\n \t      fprintf (f, \"P%d \",y);\n \t  }\n-\tfprintf (stderr, \"   basedecls: \");\n+\tfprintf (f, \"   basedecls: \");\n \tEXECUTE_IF_SET_IN_BITMAP (t->expr_decl_uids[x], 0, y, bi)\n \t  fprintf (f, \"%d \",y);\n-\tfprintf (stderr, \"\\n\");\n+\tfprintf (f, \"   call_cnt : %d\",t->call_cnt[x]);\n+\tfprintf (f, \"\\n\");\n       }\n \n   bitmap_print (f, t->partition_in_use, \"Partitions in use \","}]}