{"sha": "3877c560656f4961cc50952c3bba3c40812c36c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg3N2M1NjA2NTZmNDk2MWNjNTA5NTJjM2JiYTNjNDA4MTJjMzZjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:27:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:27:50Z"}, "message": "New CONST_VECTOR layout\n\nThis patch makes CONST_VECTOR use the same encoding as VECTOR_CST.\n\nOne problem that occurs in RTL but not at the tree level is that a fair\namount of code uses XVEC and XVECEXP directly on CONST_VECTORs (which is\nvalid, just with looser checking).  This is complicated by the fact that\nvectors are also represented as PARALLELs in some target interfaces,\nso using XVECEXP is a good polymorphic way of handling both forms.\n\nRather than try to untangle all that, the best approach seemed to be to\ncontinue to encode every element in a fixed-length vector.  That way only\ntarget-independent and AArch64 code need to be precise about using\nCONST_VECTOR_ELT over XVECEXP.\n\nAfter this change is no longer valid to modify CONST_VECTORs in-place.\nThis needed some fix-up in the powerpc backends.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/rtl.texi (const_vector): Describe new encoding scheme.\n\t* Makefile.in (OBJS): Add rtx-vector-builder.o.\n\t* rtx-vector-builder.h: New file.\n\t* rtx-vector-builder.c: Likewise.\n\t* rtl.h (rtx_def::u2): Add a const_vector field.\n\t(CONST_VECTOR_NPATTERNS): New macro.\n\t(CONST_VECTOR_NELTS_PER_PATTERN): Likewise.\n\t(CONST_VECTOR_DUPLICATE_P): Likewise.\n\t(CONST_VECTOR_STEPPED_P): Likewise.\n\t(CONST_VECTOR_ENCODED_ELT): Likewise.\n\t(const_vec_duplicate_p): Check for a duplicated vector encoding.\n\t(unwrap_const_vec_duplicate): Likewise.\n\t(const_vec_series_p): Check for a non-duplicated vector encoding.\n\tSay that the function only returns true for integer vectors.\n\t* emit-rtl.c: Include rtx-vector-builder.h.\n\t(gen_const_vec_duplicate_1): Delete.\n\t(gen_const_vector): Call gen_const_vec_duplicate instead of\n\tgen_const_vec_duplicate_1.\n\t(const_vec_series_p_1): Operate directly on the CONST_VECTOR encoding.\n\t(gen_const_vec_duplicate): Use rtx_vector_builder.\n\t(gen_const_vec_series): Likewise.\n\t(gen_rtx_CONST_VECTOR): Likewise.\n\t* config/powerpcspe/powerpcspe.c: Include rtx-vector-builder.h.\n\t(swap_const_vector_halves): Take an rtx pointer rather than rtx.\n\tBuild a new vector rather than modifying a CONST_VECTOR in-place.\n\t(handle_special_swappables): Update call accordingly.\n\t* config/rs6000/rs6000-p8swap.c: Include rtx-vector-builder.h.\n\t(swap_const_vector_halves): Take an rtx pointer rather than rtx.\n\tBuild a new vector rather than modifying a CONST_VECTOR in-place.\n\t(handle_special_swappables): Update call accordingly.\n\nFrom-SVN: r256102", "tree": {"sha": "6a597b75586e86b045125cf698b9b23ec15e2d4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a597b75586e86b045125cf698b9b23ec15e2d4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3877c560656f4961cc50952c3bba3c40812c36c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3877c560656f4961cc50952c3bba3c40812c36c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3877c560656f4961cc50952c3bba3c40812c36c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3877c560656f4961cc50952c3bba3c40812c36c3/comments", "author": null, "committer": null, "parents": [{"sha": "8eff75e0d2a3495c5bc182324644a080d47205ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eff75e0d2a3495c5bc182324644a080d47205ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eff75e0d2a3495c5bc182324644a080d47205ac"}], "stats": {"total": 533, "additions": 448, "deletions": 85}, "files": [{"sha": "bff9ff5c0493f472b56fdddbf2e18699ede339e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -1,3 +1,36 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/rtl.texi (const_vector): Describe new encoding scheme.\n+\t* Makefile.in (OBJS): Add rtx-vector-builder.o.\n+\t* rtx-vector-builder.h: New file.\n+\t* rtx-vector-builder.c: Likewise.\n+\t* rtl.h (rtx_def::u2): Add a const_vector field.\n+\t(CONST_VECTOR_NPATTERNS): New macro.\n+\t(CONST_VECTOR_NELTS_PER_PATTERN): Likewise.\n+\t(CONST_VECTOR_DUPLICATE_P): Likewise.\n+\t(CONST_VECTOR_STEPPED_P): Likewise.\n+\t(CONST_VECTOR_ENCODED_ELT): Likewise.\n+\t(const_vec_duplicate_p): Check for a duplicated vector encoding.\n+\t(unwrap_const_vec_duplicate): Likewise.\n+\t(const_vec_series_p): Check for a non-duplicated vector encoding.\n+\tSay that the function only returns true for integer vectors.\n+\t* emit-rtl.c: Include rtx-vector-builder.h.\n+\t(gen_const_vec_duplicate_1): Delete.\n+\t(gen_const_vector): Call gen_const_vec_duplicate instead of\n+\tgen_const_vec_duplicate_1.\n+\t(const_vec_series_p_1): Operate directly on the CONST_VECTOR encoding.\n+\t(gen_const_vec_duplicate): Use rtx_vector_builder.\n+\t(gen_const_vec_series): Likewise.\n+\t(gen_rtx_CONST_VECTOR): Likewise.\n+\t* config/powerpcspe/powerpcspe.c: Include rtx-vector-builder.h.\n+\t(swap_const_vector_halves): Take an rtx pointer rather than rtx.\n+\tBuild a new vector rather than modifying a CONST_VECTOR in-place.\n+\t(handle_special_swappables): Update call accordingly.\n+\t* config/rs6000/rs6000-p8swap.c: Include rtx-vector-builder.h.\n+\t(swap_const_vector_halves): Take an rtx pointer rather than rtx.\n+\tBuild a new vector rather than modifying a CONST_VECTOR in-place.\n+\t(handle_special_swappables): Update call accordingly.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* simplify-rtx.c (simplify_const_binary_operation): Use"}, {"sha": "a1af00322a674f9056cbf24a9fdf8cff8eb8a696", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -1453,6 +1453,7 @@ OBJS = \\\n \trtlhash.o \\\n \trtlanal.o \\\n \trtlhooks.o \\\n+\trtx-vector-builder.o \\\n \trun-rtl-passes.o \\\n \tsched-deps.o \\\n \tsched-ebb.o \\"}, {"sha": "f5868dd237d372d016fb4eede981193ea384050d", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -79,6 +79,7 @@\n #endif\n #include \"case-cfn-macros.h\"\n #include \"ppc-auxv.h\"\n+#include \"rtx-vector-builder.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -42581,34 +42582,35 @@ mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)\n     }\n }\n \n-/* OP is either a CONST_VECTOR or an expression containing one.\n+/* *OP_PTR is either a CONST_VECTOR or an expression containing one.\n    Swap the first half of the vector with the second in the first\n    case.  Recurse to find it in the second.  */\n static void\n-swap_const_vector_halves (rtx op)\n+swap_const_vector_halves (rtx *op_ptr)\n {\n   int i;\n+  rtx op = *op_ptr;\n   enum rtx_code code = GET_CODE (op);\n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      int half_units = GET_MODE_NUNITS (GET_MODE (op)) / 2;\n-      for (i = 0; i < half_units; ++i)\n-\t{\n-\t  rtx temp = CONST_VECTOR_ELT (op, i);\n-\t  CONST_VECTOR_ELT (op, i) = CONST_VECTOR_ELT (op, i + half_units);\n-\t  CONST_VECTOR_ELT (op, i + half_units) = temp;\n-\t}\n+      int units = GET_MODE_NUNITS (GET_MODE (op));\n+      rtx_vector_builder builder (GET_MODE (op), units, 1);\n+      for (i = 0; i < units / 2; ++i)\n+\tbuilder.quick_push (CONST_VECTOR_ELT (op, i + units / 2));\n+      for (i = 0; i < units / 2; ++i)\n+\tbuilder.quick_push (CONST_VECTOR_ELT (op, i));\n+      *op_ptr = builder.build ();\n     }\n   else\n     {\n       int j;\n       const char *fmt = GET_RTX_FORMAT (code);\n       for (i = 0; i < GET_RTX_LENGTH (code); ++i)\n \tif (fmt[i] == 'e' || fmt[i] == 'u')\n-\t  swap_const_vector_halves (XEXP (op, i));\n+\t  swap_const_vector_halves (&XEXP (op, i));\n \telse if (fmt[i] == 'E')\n \t  for (j = 0; j < XVECLEN (op, i); ++j)\n-\t    swap_const_vector_halves (XVECEXP (op, i, j));\n+\t    swap_const_vector_halves (&XVECEXP (op, i, j));\n     }\n }\n \n@@ -42900,8 +42902,7 @@ handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n       {\n \t/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */\n \tgcc_assert (GET_CODE (body) == SET);\n-\trtx rhs = SET_SRC (body);\n-\tswap_const_vector_halves (rhs);\n+\tswap_const_vector_halves (&SET_SRC (body));\n \tif (dump_file)\n \t  fprintf (dump_file, \"Swapping constant halves in insn %d\\n\", i);\n \tbreak;"}, {"sha": "e0d8f3148cd7d2c9a08ee43c2dd82193cefcb8c0", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -36,6 +36,7 @@\n #include \"expr.h\"\n #include \"output.h\"\n #include \"tree-pass.h\"\n+#include \"rtx-vector-builder.h\"\n \n /* Analyze vector computations and remove unnecessary doubleword\n    swaps (xxswapdi instructions).  This pass is performed only\n@@ -931,34 +932,35 @@ mark_swaps_for_removal (swap_web_entry *insn_entry, unsigned int i)\n     }\n }\n \n-/* OP is either a CONST_VECTOR or an expression containing one.\n+/* *OP_PTR is either a CONST_VECTOR or an expression containing one.\n    Swap the first half of the vector with the second in the first\n    case.  Recurse to find it in the second.  */\n static void\n-swap_const_vector_halves (rtx op)\n+swap_const_vector_halves (rtx *op_ptr)\n {\n   int i;\n+  rtx op = *op_ptr;\n   enum rtx_code code = GET_CODE (op);\n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n-      int half_units = GET_MODE_NUNITS (GET_MODE (op)) / 2;\n-      for (i = 0; i < half_units; ++i)\n-\t{\n-\t  rtx temp = CONST_VECTOR_ELT (op, i);\n-\t  CONST_VECTOR_ELT (op, i) = CONST_VECTOR_ELT (op, i + half_units);\n-\t  CONST_VECTOR_ELT (op, i + half_units) = temp;\n-\t}\n+      int units = GET_MODE_NUNITS (GET_MODE (op));\n+      rtx_vector_builder builder (GET_MODE (op), units, 1);\n+      for (i = 0; i < units / 2; ++i)\n+\tbuilder.quick_push (CONST_VECTOR_ELT (op, i + units / 2));\n+      for (i = 0; i < units / 2; ++i)\n+\tbuilder.quick_push (CONST_VECTOR_ELT (op, i));\n+      *op_ptr = builder.build ();\n     }\n   else\n     {\n       int j;\n       const char *fmt = GET_RTX_FORMAT (code);\n       for (i = 0; i < GET_RTX_LENGTH (code); ++i)\n \tif (fmt[i] == 'e' || fmt[i] == 'u')\n-\t  swap_const_vector_halves (XEXP (op, i));\n+\t  swap_const_vector_halves (&XEXP (op, i));\n \telse if (fmt[i] == 'E')\n \t  for (j = 0; j < XVECLEN (op, i); ++j)\n-\t    swap_const_vector_halves (XVECEXP (op, i, j));\n+\t    swap_const_vector_halves (&XVECEXP (op, i, j));\n     }\n }\n \n@@ -1251,8 +1253,7 @@ handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n       {\n \t/* A CONST_VECTOR will only show up somewhere in the RHS of a SET.  */\n \tgcc_assert (GET_CODE (body) == SET);\n-\trtx rhs = SET_SRC (body);\n-\tswap_const_vector_halves (rhs);\n+\tswap_const_vector_halves (&SET_SRC (body));\n \tif (dump_file)\n \t  fprintf (dump_file, \"Swapping constant halves in insn %d\\n\", i);\n \tbreak;"}, {"sha": "18935b0407c72b8ed39d3e29e1c9f9369f46e0a4", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 86, "deletions": 12, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -1644,18 +1644,92 @@ low-level routines) and @code{const_poly_int_value} gives the full\n \n @findex const_vector\n @item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])\n-Represents a vector constant.  The square brackets stand for the vector\n-containing the constant elements.  @var{x0}, @var{x1} and so on are\n-the @code{const_int}, @code{const_wide_int}, @code{const_double} or\n-@code{const_fixed} elements.\n-\n-The number of units in a @code{const_vector} is obtained with the macro\n-@code{CONST_VECTOR_NUNITS} as in @code{CONST_VECTOR_NUNITS (@var{v})}.\n-\n-Individual elements in a vector constant are accessed with the macro\n-@code{CONST_VECTOR_ELT} as in @code{CONST_VECTOR_ELT (@var{v}, @var{n})}\n-where @var{v} is the vector constant and @var{n} is the element\n-desired.\n+Represents a vector constant.  The values in square brackets are\n+elements of the vector, which are always @code{const_int},\n+@code{const_wide_int}, @code{const_double} or @code{const_fixed}\n+expressions.\n+\n+Each vector constant @var{v} is treated as a specific instance of an\n+arbitrary-length sequence that itself contains\n+@samp{CONST_VECTOR_NPATTERNS (@var{v})} interleaved patterns.  Each\n+pattern has the form:\n+\n+@smallexample\n+@{ @var{base0}, @var{base1}, @var{base1} + @var{step}, @var{base1} + @var{step} * 2, @dots{} @}\n+@end smallexample\n+\n+The first three elements in each pattern are enough to determine the\n+values of the other elements.  However, if all @var{step}s are zero,\n+only the first two elements are needed.  If in addition each @var{base1}\n+is equal to the corresponding @var{base0}, only the first element in\n+each pattern is needed.  The number of determining elements per pattern\n+is given by @samp{CONST_VECTOR_NELTS_PER_PATTERN (@var{v})}.\n+\n+For example, the constant:\n+\n+@smallexample\n+@{ 0, 1, 2, 6, 3, 8, 4, 10, 5, 12, 6, 14, 7, 16, 8, 18 @}\n+@end smallexample\n+\n+is interpreted as an interleaving of the sequences:\n+\n+@smallexample\n+@{ 0, 2, 3, 4, 5, 6, 7, 8 @}\n+@{ 1, 6, 8, 10, 12, 14, 16, 18 @}\n+@end smallexample\n+\n+where the sequences are represented by the following patterns:\n+\n+@smallexample\n+@var{base0} == 0, @var{base1} == 2, @var{step} == 1\n+@var{base0} == 1, @var{base1} == 6, @var{step} == 2\n+@end smallexample\n+\n+In this case:\n+\n+@smallexample\n+CONST_VECTOR_NPATTERNS (@var{v}) == 2\n+CONST_VECTOR_NELTS_PER_PATTERN (@var{v}) == 3\n+@end smallexample\n+\n+Thus the first 6 elements (@samp{@{ 0, 1, 2, 6, 3, 8 @}}) are enough\n+to determine the whole sequence; we refer to them as the ``encoded''\n+elements.  They are the only elements present in the square brackets\n+for variable-length @code{const_vector}s (i.e. for\n+@code{const_vector}s whose mode @var{m} has a variable number of\n+elements).  However, as a convenience to code that needs to handle\n+both @code{const_vector}s and @code{parallel}s, all elements are\n+present in the square brackets for fixed-length @code{const_vector}s;\n+the encoding scheme simply reduces the amount of work involved in\n+processing constants that follow a regular pattern.\n+\n+Sometimes this scheme can create two possible encodings of the same\n+vector.  For example @{ 0, 1 @} could be seen as two patterns with\n+one element each or one pattern with two elements (@var{base0} and\n+@var{base1}).  The canonical encoding is always the one with the\n+fewest patterns or (if both encodings have the same number of\n+petterns) the one with the fewest encoded elements.\n+\n+@samp{const_vector_encoding_nelts (@var{v})} gives the total number of\n+encoded elements in @var{v}, which is 6 in the example above.\n+@code{CONST_VECTOR_ENCODED_ELT (@var{v}, @var{i})} accesses the value\n+of encoded element @var{i}.\n+\n+@samp{CONST_VECTOR_DUPLICATE_P (@var{v})} is true if @var{v} simply contains\n+repeated instances of @samp{CONST_VECTOR_NPATTERNS (@var{v})} values.  This is\n+a shorthand for testing @samp{CONST_VECTOR_NELTS_PER_PATTERN (@var{v}) == 1}.\n+\n+@samp{CONST_VECTOR_STEPPED_P (@var{v})} is true if at least one\n+pattern in @var{v} has a nonzero step.  This is a shorthand for\n+testing @samp{CONST_VECTOR_NELTS_PER_PATTERN (@var{v}) == 3}.\n+\n+@code{CONST_VECTOR_NUNITS (@var{v})} gives the total number of elements\n+in @var{v}; it is a shorthand for getting the number of units in\n+@samp{GET_MODE (@var{v})}.\n+\n+The utility function @code{const_vector_elt} gives the value of an\n+arbitrary element as an @code{rtx}.  @code{const_vector_int_elt} gives\n+the same value as a @code{wide_int}.\n \n @findex const_string\n @item (const_string @var{str})"}, {"sha": "c9599e19ec0021fac6c292d3219e1d7cc62e4fa9", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"opts.h\"\n #include \"predict.h\"\n+#include \"rtx-vector-builder.h\"\n \n struct target_rtl default_target_rtl;\n #if SWITCHABLE_TARGET\n@@ -5872,33 +5873,15 @@ valid_for_const_vector_p (machine_mode, rtx x)\n \t  || CONST_FIXED_P (x));\n }\n \n-/* Like gen_const_vec_duplicate, but ignore const_tiny_rtx.  */\n-\n-static rtx\n-gen_const_vec_duplicate_1 (machine_mode mode, rtx el)\n-{\n-  int nunits = GET_MODE_NUNITS (mode);\n-  rtvec v = rtvec_alloc (nunits);\n-  for (int i = 0; i < nunits; ++i)\n-    RTVEC_ELT (v, i) = el;\n-  return gen_rtx_raw_CONST_VECTOR (mode, v);\n-}\n-\n /* Generate a vector constant of mode MODE in which every element has\n    value ELT.  */\n \n rtx\n gen_const_vec_duplicate (machine_mode mode, rtx elt)\n {\n-  scalar_mode inner_mode = GET_MODE_INNER (mode);\n-  if (elt == CONST0_RTX (inner_mode))\n-    return CONST0_RTX (mode);\n-  else if (elt == CONST1_RTX (inner_mode))\n-    return CONST1_RTX (mode);\n-  else if (elt == CONSTM1_RTX (inner_mode))\n-    return CONSTM1_RTX (mode);\n-\n-  return gen_const_vec_duplicate_1 (mode, elt);\n+  rtx_vector_builder builder (mode, 1, 1);\n+  builder.quick_push (elt);\n+  return builder.build ();\n }\n \n /* Return a vector rtx of mode MODE in which every element has value X.\n@@ -5912,28 +5895,44 @@ gen_vec_duplicate (machine_mode mode, rtx x)\n   return gen_rtx_VEC_DUPLICATE (mode, x);\n }\n \n-/* A subroutine of const_vec_series_p that handles the case in which\n-   X is known to be an integer CONST_VECTOR.  */\n+/* A subroutine of const_vec_series_p that handles the case in which:\n+\n+     (GET_CODE (X) == CONST_VECTOR\n+      && CONST_VECTOR_NPATTERNS (X) == 1\n+      && !CONST_VECTOR_DUPLICATE_P (X))\n+\n+   is known to hold.  */\n \n bool\n const_vec_series_p_1 (const_rtx x, rtx *base_out, rtx *step_out)\n {\n-  unsigned int nelts = CONST_VECTOR_NUNITS (x);\n-  if (nelts < 2)\n+  /* Stepped sequences are only defined for integers, to avoid specifying\n+     rounding behavior.  */\n+  if (GET_MODE_CLASS (GET_MODE (x)) != MODE_VECTOR_INT)\n+    return false;\n+\n+  /* A non-duplicated vector with two elements can always be seen as a\n+     series with a nonzero step.  Longer vectors must have a stepped\n+     encoding.  */\n+  if (CONST_VECTOR_NUNITS (x) != 2\n+      && !CONST_VECTOR_STEPPED_P (x))\n     return false;\n \n+  /* Calculate the step between the first and second elements.  */\n   scalar_mode inner = GET_MODE_INNER (GET_MODE (x));\n   rtx base = CONST_VECTOR_ELT (x, 0);\n   rtx step = simplify_binary_operation (MINUS, inner,\n-\t\t\t\t\tCONST_VECTOR_ELT (x, 1), base);\n+\t\t\t\t\tCONST_VECTOR_ENCODED_ELT (x, 1), base);\n   if (rtx_equal_p (step, CONST0_RTX (inner)))\n     return false;\n \n-  for (unsigned int i = 2; i < nelts; ++i)\n+  /* If we have a stepped encoding, check that the step between the\n+     second and third elements is the same as STEP.  */\n+  if (CONST_VECTOR_STEPPED_P (x))\n     {\n       rtx diff = simplify_binary_operation (MINUS, inner,\n-\t\t\t\t\t    CONST_VECTOR_ELT (x, i),\n-\t\t\t\t\t    CONST_VECTOR_ELT (x, i - 1));\n+\t\t\t\t\t    CONST_VECTOR_ENCODED_ELT (x, 2),\n+\t\t\t\t\t    CONST_VECTOR_ENCODED_ELT (x, 1));\n       if (!rtx_equal_p (step, diff))\n \treturn false;\n     }\n@@ -5952,14 +5951,12 @@ gen_const_vec_series (machine_mode mode, rtx base, rtx step)\n   gcc_assert (valid_for_const_vector_p (mode, base)\n \t      && valid_for_const_vector_p (mode, step));\n \n-  int nunits = GET_MODE_NUNITS (mode);\n-  rtvec v = rtvec_alloc (nunits);\n-  scalar_mode inner_mode = GET_MODE_INNER (mode);\n-  RTVEC_ELT (v, 0) = base;\n-  for (int i = 1; i < nunits; ++i)\n-    RTVEC_ELT (v, i) = simplify_gen_binary (PLUS, inner_mode,\n-\t\t\t\t\t    RTVEC_ELT (v, i - 1), step);\n-  return gen_rtx_raw_CONST_VECTOR (mode, v);\n+  rtx_vector_builder builder (mode, 1, 3);\n+  builder.quick_push (base);\n+  for (int i = 1; i < 3; ++i)\n+    builder.quick_push (simplify_gen_binary (PLUS, GET_MODE_INNER (mode),\n+\t\t\t\t\t     builder[i - 1], step));\n+  return builder.build ();\n }\n \n /* Generate a vector of mode MODE in which element I has the value\n@@ -5990,7 +5987,7 @@ gen_const_vector (machine_mode mode, int constant)\n   rtx el = const_tiny_rtx[constant][(int) inner];\n   gcc_assert (el);\n \n-  return gen_const_vec_duplicate_1 (mode, el);\n+  return gen_const_vec_duplicate (mode, el);\n }\n \n /* Generate a vector like gen_rtx_raw_CONST_VEC, but use the zero vector when\n@@ -6005,7 +6002,11 @@ gen_rtx_CONST_VECTOR (machine_mode mode, rtvec v)\n   if (rtvec_all_equal_p (v))\n     return gen_const_vec_duplicate (mode, RTVEC_ELT (v, 0));\n \n-  return gen_rtx_raw_CONST_VECTOR (mode, v);\n+  unsigned int nunits = GET_NUM_ELEM (v);\n+  rtx_vector_builder builder (mode, nunits, 1);\n+  for (unsigned int i = 0; i < nunits; ++i)\n+    builder.quick_push (RTVEC_ELT (v, i));\n+  return builder.build (v);\n }\n \n /* Initialise global register information required by all functions.  */"}, {"sha": "64012d0058bf54cb8696fd16a86f774f0564906d", "filename": "gcc/rtl.h", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -418,6 +418,19 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n     /* In a CONST_WIDE_INT (aka hwivec_def), this is the number of\n        HOST_WIDE_INTs in the hwivec_def.  */\n     unsigned int num_elem;\n+\n+    /* Information about a CONST_VECTOR.  */\n+    struct\n+    {\n+      /* The value of CONST_VECTOR_NPATTERNS.  */\n+      unsigned int npatterns : 16;\n+\n+      /* The value of CONST_VECTOR_NELTS_PER_PATTERN.  */\n+      unsigned int nelts_per_pattern : 8;\n+\n+      /* For future expansion.  */\n+      unsigned int unused : 8;\n+    } const_vector;\n   } GTY ((skip)) u2;\n \n   /* The first element of the operands of this rtx.\n@@ -1958,6 +1971,23 @@ set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n /* For a CONST_VECTOR, return element #n.  */\n #define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n \n+/* See rtl.texi for a description of these macros.  */\n+#define CONST_VECTOR_NPATTERNS(RTX) \\\n+ (RTL_FLAG_CHECK1 (\"CONST_VECTOR_NPATTERNS\", (RTX), CONST_VECTOR) \\\n+  ->u2.const_vector.npatterns)\n+\n+#define CONST_VECTOR_NELTS_PER_PATTERN(RTX) \\\n+ (RTL_FLAG_CHECK1 (\"CONST_VECTOR_NELTS_PER_PATTERN\", (RTX), CONST_VECTOR) \\\n+  ->u2.const_vector.nelts_per_pattern)\n+\n+#define CONST_VECTOR_DUPLICATE_P(RTX) \\\n+  (CONST_VECTOR_NELTS_PER_PATTERN (RTX) == 1)\n+\n+#define CONST_VECTOR_STEPPED_P(RTX) \\\n+  (CONST_VECTOR_NELTS_PER_PATTERN (RTX) == 3)\n+\n+#define CONST_VECTOR_ENCODED_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n+\n /* For a CONST_VECTOR, return the number of elements in a vector.  */\n #define CONST_VECTOR_NUNITS(RTX) XCVECLEN (RTX, 0, CONST_VECTOR)\n \n@@ -2910,7 +2940,9 @@ const_vec_p (const_rtx x)\n inline bool\n const_vec_duplicate_p (const_rtx x)\n {\n-  return ((GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n+  return ((GET_CODE (x) == CONST_VECTOR\n+\t   && CONST_VECTOR_NPATTERNS (x) == 1\n+\t   && CONST_VECTOR_DUPLICATE_P (x))\n \t  || (GET_CODE (x) == CONST\n \t      && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE));\n }\n@@ -2922,9 +2954,11 @@ template <typename T>\n inline bool\n const_vec_duplicate_p (T x, T *elt)\n {\n-  if (GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n+  if (GET_CODE (x) == CONST_VECTOR\n+      && CONST_VECTOR_NPATTERNS (x) == 1\n+      && CONST_VECTOR_DUPLICATE_P (x))\n     {\n-      *elt = CONST_VECTOR_ELT (x, 0);\n+      *elt = CONST_VECTOR_ENCODED_ELT (x, 0);\n       return true;\n     }\n   if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE)\n@@ -2957,8 +2991,10 @@ template <typename T>\n inline T\n unwrap_const_vec_duplicate (T x)\n {\n-  if (GET_CODE (x) == CONST_VECTOR && rtvec_all_equal_p (XVEC (x, 0)))\n-    return CONST_VECTOR_ELT (x, 0);\n+  if (GET_CODE (x) == CONST_VECTOR\n+      && CONST_VECTOR_NPATTERNS (x) == 1\n+      && CONST_VECTOR_DUPLICATE_P (x))\n+    return CONST_VECTOR_ENCODED_ELT (x, 0);\n   if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_DUPLICATE)\n     return XEXP (XEXP (x, 0), 0);\n   return x;\n@@ -2967,8 +3003,8 @@ unwrap_const_vec_duplicate (T x)\n /* In emit-rtl.c.  */\n extern bool const_vec_series_p_1 (const_rtx, rtx *, rtx *);\n \n-/* Return true if X is a constant vector that contains a linear series\n-   of the form:\n+/* Return true if X is an integer constant vector that contains a linear\n+   series of the form:\n \n    { B, B + S, B + 2 * S, B + 3 * S, ... }\n \n@@ -2978,7 +3014,8 @@ inline bool\n const_vec_series_p (const_rtx x, rtx *base_out, rtx *step_out)\n {\n   if (GET_CODE (x) == CONST_VECTOR\n-      && GET_MODE_CLASS (GET_MODE (x)) == MODE_VECTOR_INT)\n+      && CONST_VECTOR_NPATTERNS (x) == 1\n+      && !CONST_VECTOR_DUPLICATE_P (x))\n     return const_vec_series_p_1 (x, base_out, step_out);\n   if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == VEC_SERIES)\n     {"}, {"sha": "6c39a3d5f2d6f8ead20681756d21ba5e1383bad7", "filename": "gcc/rtx-vector-builder.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtx-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtx-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.c?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -0,0 +1,100 @@\n+/* A class for building vector rtx constants.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"rtx-vector-builder.h\"\n+\n+/* Return a CONST_VECTOR for the current constant.  V is an existing\n+   rtvec that contains all the elements.  */\n+\n+rtx\n+rtx_vector_builder::build (rtvec v)\n+{\n+  finalize ();\n+\n+  rtx x = find_cached_value ();\n+  if (x)\n+    return x;\n+\n+  x = gen_rtx_raw_CONST_VECTOR (m_mode, v);\n+  CONST_VECTOR_NPATTERNS (x) = npatterns ();\n+  CONST_VECTOR_NELTS_PER_PATTERN (x) = nelts_per_pattern ();\n+  return x;\n+}\n+\n+/* Return a vector element with the value BASE + FACTOR * STEP.  */\n+\n+rtx\n+rtx_vector_builder::apply_step (rtx base, unsigned int factor,\n+\t\t\t\tconst wide_int &step) const\n+{\n+  scalar_int_mode int_mode = as_a <scalar_int_mode> (GET_MODE_INNER (m_mode));\n+  return immed_wide_int_const (wi::add (rtx_mode_t (base, int_mode),\n+\t\t\t\t\tfactor * step),\n+\t\t\t       int_mode);\n+}\n+\n+/* Return a CONST_VECTOR for the current constant.  */\n+\n+rtx\n+rtx_vector_builder::build ()\n+{\n+  finalize ();\n+\n+  rtx x = find_cached_value ();\n+  if (x)\n+    return x;\n+\n+  unsigned int nelts = GET_MODE_NUNITS (m_mode);\n+  rtvec v = rtvec_alloc (nelts);\n+  for (unsigned int i = 0; i < nelts; ++i)\n+    RTVEC_ELT (v, i) = elt (i);\n+  x = gen_rtx_raw_CONST_VECTOR (m_mode, v);\n+  CONST_VECTOR_NPATTERNS (x) = npatterns ();\n+  CONST_VECTOR_NELTS_PER_PATTERN (x) = nelts_per_pattern ();\n+  return x;\n+}\n+\n+/* Check whether there is a global cached value for the vector.\n+   Return it if so, otherwise return null.  */\n+\n+rtx\n+rtx_vector_builder::find_cached_value ()\n+{\n+  if (encoded_nelts () != 1)\n+    return NULL_RTX;\n+\n+  rtx elt = (*this)[0];\n+\n+  /* We can be called before the global vector constants are set up,\n+     but in that case we'll just return null.  */\n+  scalar_mode inner_mode = GET_MODE_INNER (m_mode);\n+  if (elt == CONST0_RTX (inner_mode))\n+    return CONST0_RTX (m_mode);\n+  else if (elt == CONST1_RTX (inner_mode))\n+    return CONST1_RTX (m_mode);\n+  else if (elt == CONSTM1_RTX (inner_mode))\n+    return CONSTM1_RTX (m_mode);\n+\n+  return NULL_RTX;\n+}"}, {"sha": "d4dbdbaa50be786e062344765ae3b0df951b7f10", "filename": "gcc/rtx-vector-builder.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtx-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3877c560656f4961cc50952c3bba3c40812c36c3/gcc%2Frtx-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.h?ref=3877c560656f4961cc50952c3bba3c40812c36c3", "patch": "@@ -0,0 +1,115 @@\n+/* A class for building vector rtx constants.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RTX_VECTOR_BUILDER_H\n+#define GCC_RTX_VECTOR_BUILDER_H\n+\n+#include \"vector-builder.h\"\n+\n+/* This class is used to build VECTOR_CSTs from a sequence of elements.\n+   See vector_builder for more details.  */\n+class rtx_vector_builder : public vector_builder<rtx, rtx_vector_builder>\n+{\n+  typedef vector_builder<rtx, rtx_vector_builder> parent;\n+  friend class vector_builder<rtx, rtx_vector_builder>;\n+\n+public:\n+  rtx_vector_builder () : m_mode (VOIDmode) {}\n+  rtx_vector_builder (machine_mode, unsigned int, unsigned int);\n+  rtx build (rtvec);\n+  rtx build ();\n+\n+  machine_mode mode () const { return m_mode; }\n+\n+  void new_vector (machine_mode, unsigned int, unsigned int);\n+\n+private:\n+  bool equal_p (rtx, rtx) const;\n+  bool allow_steps_p () const;\n+  bool integral_p (rtx) const;\n+  wide_int step (rtx, rtx) const;\n+  rtx apply_step (rtx, unsigned int, const wide_int &) const;\n+  bool can_elide_p (rtx) const { return true; }\n+  void note_representative (rtx *, rtx) {}\n+\n+  rtx find_cached_value ();\n+\n+  machine_mode m_mode;\n+};\n+\n+/* Create a new builder for a vector of mode MODE.  Initially encode the\n+   value as NPATTERNS interleaved patterns with NELTS_PER_PATTERN elements\n+   each.  */\n+\n+inline\n+rtx_vector_builder::rtx_vector_builder (machine_mode mode,\n+\t\t\t\t\tunsigned int npatterns,\n+\t\t\t\t\tunsigned int nelts_per_pattern)\n+{\n+  new_vector (mode, npatterns, nelts_per_pattern);\n+}\n+\n+/* Start building a new vector of mode MODE.  Initially encode the value\n+   as NPATTERNS interleaved patterns with NELTS_PER_PATTERN elements each.  */\n+\n+inline void\n+rtx_vector_builder::new_vector (machine_mode mode, unsigned int npatterns,\n+\t\t\t\tunsigned int nelts_per_pattern)\n+{\n+  m_mode = mode;\n+  parent::new_vector (GET_MODE_NUNITS (mode), npatterns, nelts_per_pattern);\n+}\n+\n+/* Return true if elements ELT1 and ELT2 are equal.  */\n+\n+inline bool\n+rtx_vector_builder::equal_p (rtx elt1, rtx elt2) const\n+{\n+  return rtx_equal_p (elt1, elt2);\n+}\n+\n+/* Return true if a stepped representation is OK.  We don't allow\n+   linear series for anything other than integers, to avoid problems\n+   with rounding.  */\n+\n+inline bool\n+rtx_vector_builder::allow_steps_p () const\n+{\n+  return is_a <scalar_int_mode> (GET_MODE_INNER (m_mode));\n+}\n+\n+/* Return true if element ELT can be interpreted as an integer.  */\n+\n+inline bool\n+rtx_vector_builder::integral_p (rtx elt) const\n+{\n+  return CONST_SCALAR_INT_P (elt);\n+}\n+\n+/* Return the value of element ELT2 minus the value of element ELT1.\n+   Both elements are known to be CONST_SCALAR_INT_Ps.  */\n+\n+inline wide_int\n+rtx_vector_builder::step (rtx elt1, rtx elt2) const\n+{\n+  return wi::sub (rtx_mode_t (elt2, GET_MODE_INNER (m_mode)),\n+\t\t  rtx_mode_t (elt1, GET_MODE_INNER (m_mode)));\n+}\n+\n+#endif"}]}