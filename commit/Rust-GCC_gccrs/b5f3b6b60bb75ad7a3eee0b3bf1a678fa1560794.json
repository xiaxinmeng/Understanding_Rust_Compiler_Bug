{"sha": "b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmM2I2YjYwYmI3NWFkN2EzZWVlMGIzYmYxYTY3OGZhMTU2MDc5NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T21:59:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T21:59:47Z"}, "message": "(strip_compound_expr): New function.\n\n(fold): Call it; avoid exponential work when simplifying binary op over\na COND_EXPR.\n\nFrom-SVN: r6921", "tree": {"sha": "9ba5748b78c32e55ca1662f9efd38943ee4c58d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ba5748b78c32e55ca1662f9efd38943ee4c58d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794/comments", "author": null, "committer": null, "parents": [{"sha": "92f9aa51764db2cee9a2e5617c9c58295c0ed476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92f9aa51764db2cee9a2e5617c9c58295c0ed476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92f9aa51764db2cee9a2e5617c9c58295c0ed476"}], "stats": {"total": 56, "additions": 50, "deletions": 6}, "files": [{"sha": "e681278e05f8a4b9ad84416839685ba2775e3103", "filename": "gcc/fold-const.c", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b5f3b6b60bb75ad7a3eee0b3bf1a678fa1560794", "patch": "@@ -77,6 +77,7 @@ static int simple_operand_p PROTO((tree));\n static tree range_test\tPROTO((enum tree_code, tree, enum tree_code,\n \t\t\t       enum tree_code, tree, tree, tree));\n static tree fold_truthop PROTO((enum tree_code, tree, tree, tree));\n+static tree strip_compound_expr PROTO((tree, tree));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n@@ -3093,6 +3094,43 @@ fold_truthop (code, truth_type, lhs, rhs)\n \t\tconst_binop (BIT_IOR_EXPR, l_const, r_const, 0));\n }\n \f\n+/* If T contains a COMPOUND_EXPR which was inserted merely to evaluate\n+   S, a SAVE_EXPR, return the expression actually being evaluated.   Note\n+   that we may sometimes modify the tree.  */\n+\n+static tree\n+strip_compound_expr (t, s)\n+     tree t;\n+     tree s;\n+{\n+  tree type = TREE_TYPE (t);\n+  enum tree_code code = TREE_CODE (t);\n+\n+  /* See if this is the COMPOUND_EXPR we want to eliminate.  */\n+  if (code == COMPOUND_EXPR && TREE_CODE (TREE_OPERAND (t, 0)) == CONVERT_EXPR\n+      && TREE_OPERAND (TREE_OPERAND (t, 0), 0) == s)\n+    return TREE_OPERAND (t, 1);\n+\n+  /* See if this is a COND_EXPR or a simple arithmetic operator.   We\n+     don't bother handling any other types.  */\n+  else if (code == COND_EXPR)\n+    {\n+      TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n+      TREE_OPERAND (t, 1) = strip_compound_expr (TREE_OPERAND (t, 1), s);\n+      TREE_OPERAND (t, 2) = strip_compound_expr (TREE_OPERAND (t, 2), s);\n+    }\n+  else if (TREE_CODE_CLASS (code) == '1')\n+    TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n+  else if (TREE_CODE_CLASS (code) == '<'\n+\t   || TREE_CODE_CLASS (code) == '2')\n+    {\n+      TREE_OPERAND (t, 0) = strip_compound_expr (TREE_OPERAND (t, 0), s);\n+      TREE_OPERAND (t, 1) = strip_compound_expr (TREE_OPERAND (t, 1), s);\n+    }\n+\n+  return t;\n+}\n+\f\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -3328,8 +3366,10 @@ fold (expr)\n \t     SAVE_EXPR interfers with later optimizations, suppressing\n \t     it when we can is important.  */\n \n-\t  if ((TREE_CODE (arg0) != VAR_DECL && TREE_CODE (arg0) != PARM_DECL)\n-\t      || TREE_SIDE_EFFECTS (arg0))\n+\t  if (TREE_CODE (arg0) != SAVE_EXPR\n+\t      && ((TREE_CODE (arg0) != VAR_DECL\n+\t\t   && TREE_CODE (arg0) != PARM_DECL)\n+\t\t  || TREE_SIDE_EFFECTS (arg0)))\n \t    {\n \t      tree lhs = fold (build (code, type, arg0, true_value));\n \t      tree rhs = fold (build (code, type, arg0, false_value));\n@@ -3345,7 +3385,8 @@ fold (expr)\n \t\t\t      fold (build (code, type, arg0, false_value))));\n \t  if (TREE_CODE (arg0) == SAVE_EXPR)\n \t    return build (COMPOUND_EXPR, type,\n-\t\t\t  convert (void_type_node, arg0), test);\n+\t\t\t  convert (void_type_node, arg0),\n+\t\t\t  strip_compound_expr (test, arg0));\n \t  else\n \t    return convert (type, test);\n \t}\n@@ -3371,8 +3412,10 @@ fold (expr)\n \t      false_value = integer_zero_node;\n \t    }\n \n-\t  if ((TREE_CODE (arg1) != VAR_DECL && TREE_CODE (arg1) != PARM_DECL)\n-\t      || TREE_SIDE_EFFECTS (arg1))\n+\t  if (TREE_CODE (arg1) != SAVE_EXPR\n+\t      && ((TREE_CODE (arg1) != VAR_DECL\n+\t\t   && TREE_CODE (arg1) != PARM_DECL)\n+\t\t  || TREE_SIDE_EFFECTS (arg1)))\n \t    {\n \t      tree lhs = fold (build (code, type, true_value, arg1));\n \t      tree rhs = fold (build (code, type, false_value, arg1));\n@@ -3388,7 +3431,8 @@ fold (expr)\n \t\t\t      fold (build (code, type, false_value, arg1))));\n \t  if (TREE_CODE (arg1) == SAVE_EXPR)\n \t    return build (COMPOUND_EXPR, type,\n-\t\t\t  convert (void_type_node, arg1), test);\n+\t\t\t  convert (void_type_node, arg1),\n+\t\t\t  strip_compound_expr (test, arg1));\n \t  else\n \t    return convert (type, test);\n \t}"}]}