{"sha": "e3342de49cbee48957acc749b9566eee230860be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMzNDJkZTQ5Y2JlZTQ4OTU3YWNjNzQ5Yjk1NjZlZWUyMzA4NjBiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:26:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:26:47Z"}, "message": "Make vec_perm_indices use new vector encoding\n\nThis patch changes vec_perm_indices from a plain vec<> to a class\nthat stores a canonicalized permutation, using the same encoding\nas for VECTOR_CSTs.  This means that vec_perm_indices now carries\ninformation about the number of vectors being permuted (currently\nalways 1 or 2) and the number of elements in each input vector.\n\nA new vec_perm_builder class is used to actually build up the vector,\nlike tree_vector_builder does for trees.  vec_perm_indices is the\ncompleted representation, a bit like VECTOR_CST is for trees.\n\nThe patch just does a mechanical conversion of the code to\nvec_perm_builder: a later patch uses explicit encodings where possible.\n\nThe point of all this is that it makes the representation suitable\nfor variable-length vectors.  It's no longer necessary for the\nunderlying vec<>s to store every element explicitly.\n\nIn int-vector-builder.h, \"using the same encoding as tree and rtx constants\"\ndescribes the endpoint -- adding the rtx encoding comes later.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* int-vector-builder.h: New file.\n\t* vec-perm-indices.h: Include int-vector-builder.h.\n\t(vec_perm_indices): Redefine as an int_vector_builder.\n\t(auto_vec_perm_indices): Delete.\n\t(vec_perm_builder): Redefine as a stand-alone class.\n\t(vec_perm_indices::vec_perm_indices): New function.\n\t(vec_perm_indices::clamp): Likewise.\n\t* vec-perm-indices.c: Include fold-const.h and tree-vector-builder.h.\n\t(vec_perm_indices::new_vector): New function.\n\t(vec_perm_indices::new_expanded_vector): Update for new\n\tvec_perm_indices class.\n\t(vec_perm_indices::rotate_inputs): New function.\n\t(vec_perm_indices::all_in_range_p): Operate directly on the\n\tencoded form, without computing elided elements.\n\t(tree_to_vec_perm_builder): Operate directly on the VECTOR_CST\n\tencoding.  Update for new vec_perm_indices class.\n\t* optabs.c (expand_vec_perm_const): Create a vec_perm_indices for\n\tthe given vec_perm_builder.\n\t(expand_vec_perm_var): Update vec_perm_builder constructor.\n\t(expand_mult_highpart): Use vec_perm_builder instead of\n\tauto_vec_perm_indices.\n\t* optabs-query.c (can_mult_highpart_p): Use vec_perm_builder and\n\tvec_perm_indices instead of auto_vec_perm_indices.  Use a single\n\tor double series encoding as appropriate.\n\t* fold-const.c (fold_ternary_loc): Use vec_perm_builder and\n\tvec_perm_indices instead of auto_vec_perm_indices.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n\t(vect_permute_store_chain): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t(vect_permute_load_chain): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Likewise.\n\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n\t(vectorizable_mask_load_store): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t* tree-vect-generic.c (lower_vec_perm): Use vec_perm_builder and\n\tvec_perm_indices instead of auto_vec_perm_indices.  Use\n\ttree_to_vec_perm_builder to read the vector from a tree.\n\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Take a\n\tvec_perm_builder instead of a vec_perm_indices.\n\t(have_whole_vector_shift): Use vec_perm_builder and\n\tvec_perm_indices instead of auto_vec_perm_indices.  Leave the\n\ttruncation to calc_vec_perm_mask_for_shift.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t* config/aarch64/aarch64.c (expand_vec_perm_d::perm): Change\n\tfrom auto_vec_perm_indices to vec_perm_indices.\n\t(aarch64_expand_vec_perm_const_1): Use rotate_inputs on d.perm\n\tinstead of changing individual elements.\n\t(aarch64_vectorize_vec_perm_const): Use new_vector to install\n\tthe vector in d.perm.\n\t* config/arm/arm.c (expand_vec_perm_d::perm): Change\n\tfrom auto_vec_perm_indices to vec_perm_indices.\n\t(arm_expand_vec_perm_const_1): Use rotate_inputs on d.perm\n\tinstead of changing individual elements.\n\t(arm_vectorize_vec_perm_const): Use new_vector to install\n\tthe vector in d.perm.\n\t* config/powerpcspe/powerpcspe.c (rs6000_expand_extract_even):\n\tUpdate vec_perm_builder constructor.\n\t(rs6000_expand_interleave): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_expand_extract_even): Likewise.\n\t(rs6000_expand_interleave): Likewise.\n\nFrom-SVN: r256095", "tree": {"sha": "32a86a752b83bafed11e1621d738a7fd284a93f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a86a752b83bafed11e1621d738a7fd284a93f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3342de49cbee48957acc749b9566eee230860be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3342de49cbee48957acc749b9566eee230860be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3342de49cbee48957acc749b9566eee230860be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3342de49cbee48957acc749b9566eee230860be/comments", "author": null, "committer": null, "parents": [{"sha": "6da64f1b329f57c07f22ec034bc7bc4b0dc9e87b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da64f1b329f57c07f22ec034bc7bc4b0dc9e87b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da64f1b329f57c07f22ec034bc7bc4b0dc9e87b"}], "stats": {"total": 686, "additions": 528, "deletions": 158}, "files": [{"sha": "53782f0c115aed92fde472676b479598b14ef6ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -1,3 +1,72 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* int-vector-builder.h: New file.\n+\t* vec-perm-indices.h: Include int-vector-builder.h.\n+\t(vec_perm_indices): Redefine as an int_vector_builder.\n+\t(auto_vec_perm_indices): Delete.\n+\t(vec_perm_builder): Redefine as a stand-alone class.\n+\t(vec_perm_indices::vec_perm_indices): New function.\n+\t(vec_perm_indices::clamp): Likewise.\n+\t* vec-perm-indices.c: Include fold-const.h and tree-vector-builder.h.\n+\t(vec_perm_indices::new_vector): New function.\n+\t(vec_perm_indices::new_expanded_vector): Update for new\n+\tvec_perm_indices class.\n+\t(vec_perm_indices::rotate_inputs): New function.\n+\t(vec_perm_indices::all_in_range_p): Operate directly on the\n+\tencoded form, without computing elided elements.\n+\t(tree_to_vec_perm_builder): Operate directly on the VECTOR_CST\n+\tencoding.  Update for new vec_perm_indices class.\n+\t* optabs.c (expand_vec_perm_const): Create a vec_perm_indices for\n+\tthe given vec_perm_builder.\n+\t(expand_vec_perm_var): Update vec_perm_builder constructor.\n+\t(expand_mult_highpart): Use vec_perm_builder instead of\n+\tauto_vec_perm_indices.\n+\t* optabs-query.c (can_mult_highpart_p): Use vec_perm_builder and\n+\tvec_perm_indices instead of auto_vec_perm_indices.  Use a single\n+\tor double series encoding as appropriate.\n+\t* fold-const.c (fold_ternary_loc): Use vec_perm_builder and\n+\tvec_perm_indices instead of auto_vec_perm_indices.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n+\t(vect_permute_store_chain): Likewise.\n+\t(vect_grouped_load_supported): Likewise.\n+\t(vect_permute_load_chain): Likewise.\n+\t(vect_shift_permute_load_chain): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Likewise.\n+\t* tree-vect-stmts.c (perm_mask_for_reverse): Likewise.\n+\t(vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_bswap): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t* tree-vect-generic.c (lower_vec_perm): Use vec_perm_builder and\n+\tvec_perm_indices instead of auto_vec_perm_indices.  Use\n+\ttree_to_vec_perm_builder to read the vector from a tree.\n+\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Take a\n+\tvec_perm_builder instead of a vec_perm_indices.\n+\t(have_whole_vector_shift): Use vec_perm_builder and\n+\tvec_perm_indices instead of auto_vec_perm_indices.  Leave the\n+\ttruncation to calc_vec_perm_mask_for_shift.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t* config/aarch64/aarch64.c (expand_vec_perm_d::perm): Change\n+\tfrom auto_vec_perm_indices to vec_perm_indices.\n+\t(aarch64_expand_vec_perm_const_1): Use rotate_inputs on d.perm\n+\tinstead of changing individual elements.\n+\t(aarch64_vectorize_vec_perm_const): Use new_vector to install\n+\tthe vector in d.perm.\n+\t* config/arm/arm.c (expand_vec_perm_d::perm): Change\n+\tfrom auto_vec_perm_indices to vec_perm_indices.\n+\t(arm_expand_vec_perm_const_1): Use rotate_inputs on d.perm\n+\tinstead of changing individual elements.\n+\t(arm_vectorize_vec_perm_const): Use new_vector to install\n+\tthe vector in d.perm.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_expand_extract_even):\n+\tUpdate vec_perm_builder constructor.\n+\t(rs6000_expand_interleave): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_expand_extract_even): Likewise.\n+\t(rs6000_expand_interleave): Likewise.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs-query.c (can_vec_perm_var_p): Check whether lowering"}, {"sha": "93e9d9f956aede53ccb5f01479fb439e962ed0fc", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -13252,7 +13252,7 @@ aarch64_split_combinev16qi (rtx operands[3])\n struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n-  auto_vec_perm_indices perm;\n+  vec_perm_indices perm;\n   machine_mode vmode;\n   bool one_vector_p;\n   bool testing_p;\n@@ -13642,10 +13642,7 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   unsigned int nelt = d->perm.length ();\n   if (d->perm[0] >= nelt)\n     {\n-      gcc_assert (nelt == (nelt & -nelt));\n-      for (unsigned int i = 0; i < nelt; ++i)\n-\td->perm[i] ^= nelt; /* Keep the same index, but in the other vector.  */\n-\n+      d->perm.rotate_inputs (1);\n       std::swap (d->op0, d->op1);\n     }\n \n@@ -13685,12 +13682,10 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n \n   /* Calculate whether all elements are in one vector.  */\n   unsigned int nelt = sel.length ();\n-  d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n       unsigned int ei = sel[i] & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n-      d.perm.quick_push (ei);\n     }\n \n   switch (which)\n@@ -13709,8 +13704,6 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n \t input vector.  */\n       /* Fall Through.  */\n     case 2:\n-      for (i = 0; i < nelt; ++i)\n-\td.perm[i] &= nelt - 1;\n       d.op0 = op1;\n       d.one_vector_p = true;\n       break;\n@@ -13721,6 +13714,8 @@ aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n       break;\n     }\n \n+  d.perm.new_vector (sel.encoding (), d.one_vector_p ? 1 : 2, nelt);\n+\n   if (!d.testing_p)\n     return aarch64_expand_vec_perm_const_1 (&d);\n "}, {"sha": "11e35ade62fb9debac70ab438bc729bf74e777db", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -28854,7 +28854,7 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n struct expand_vec_perm_d\n {\n   rtx target, op0, op1;\n-  auto_vec_perm_indices perm;\n+  vec_perm_indices perm;\n   machine_mode vmode;\n   bool one_vector_p;\n   bool testing_p;\n@@ -29362,9 +29362,7 @@ arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   unsigned int nelt = d->perm.length ();\n   if (d->perm[0] >= nelt)\n     {\n-      for (unsigned int i = 0; i < nelt; ++i)\n-\td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n-\n+      d->perm.rotate_inputs (1);\n       std::swap (d->op0, d->op1);\n     }\n \n@@ -29404,12 +29402,10 @@ arm_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n   d.testing_p = !target;\n \n   nelt = GET_MODE_NUNITS (d.vmode);\n-  d.perm.reserve (nelt);\n   for (i = which = 0; i < nelt; ++i)\n     {\n       int ei = sel[i] & (2 * nelt - 1);\n       which |= (ei < nelt ? 1 : 2);\n-      d.perm.quick_push (ei);\n     }\n \n   switch (which)\n@@ -29428,8 +29424,6 @@ arm_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n \t input vector.  */\n       /* FALLTHRU */\n     case 2:\n-      for (i = 0; i < nelt; ++i)\n-        d.perm[i] &= nelt - 1;\n       d.op0 = op1;\n       d.one_vector_p = true;\n       break;\n@@ -29440,6 +29434,8 @@ arm_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n       break;\n     }\n \n+  d.perm.new_vector (sel.encoding (), d.one_vector_p ? 1 : 2, nelt);\n+\n   if (d.testing_p)\n     return arm_expand_vec_perm_const_1 (&d);\n "}, {"sha": "520f2e13cb3055fcc19704050d1cb28543bf3e20", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -38782,7 +38782,7 @@ rs6000_expand_extract_even (rtx target, rtx op0, rtx op1)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, nelt = GET_MODE_NUNITS (vmode);\n-  vec_perm_builder perm (nelt);\n+  vec_perm_builder perm (nelt, nelt, 1);\n \n   for (i = 0; i < nelt; i++)\n     perm.quick_push (i * 2);\n@@ -38797,7 +38797,7 @@ rs6000_expand_interleave (rtx target, rtx op0, rtx op1, bool highp)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, high, nelt = GET_MODE_NUNITS (vmode);\n-  vec_perm_builder perm (nelt);\n+  vec_perm_builder perm (nelt, nelt, 1);\n \n   high = (highp ? 0 : nelt / 2);\n   for (i = 0; i < nelt / 2; i++)"}, {"sha": "2e4af413758d692ab880bef4d4051c7412e5a2b7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -36042,7 +36042,7 @@ rs6000_expand_extract_even (rtx target, rtx op0, rtx op1)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, nelt = GET_MODE_NUNITS (vmode);\n-  vec_perm_builder perm (nelt);\n+  vec_perm_builder perm (nelt, nelt, 1);\n \n   for (i = 0; i < nelt; i++)\n     perm.quick_push (i * 2);\n@@ -36057,7 +36057,7 @@ rs6000_expand_interleave (rtx target, rtx op0, rtx op1, bool highp)\n {\n   machine_mode vmode = GET_MODE (target);\n   unsigned i, high, nelt = GET_MODE_NUNITS (vmode);\n-  vec_perm_builder perm (nelt);\n+  vec_perm_builder perm (nelt, nelt, 1);\n \n   high = (highp ? 0 : nelt / 2);\n   for (i = 0; i < nelt / 2; i++)"}, {"sha": "ca0d8fd9319fda9e0c4223ad9703aef9f1e207bb", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -11373,7 +11373,7 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t    {\n \t      unsigned int nelts = VECTOR_CST_NELTS (arg0), i;\n \t      gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n-\t      auto_vec_perm_indices sel (nelts);\n+\t      vec_perm_builder sel (nelts, nelts, 1);\n \t      for (i = 0; i < nelts; i++)\n \t\t{\n \t\t  tree val = VECTOR_CST_ELT (arg0, i);\n@@ -11384,7 +11384,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t  else /* Currently unreachable.  */\n \t\t    return NULL_TREE;\n \t\t}\n-\t      tree t = fold_vec_perm (type, arg1, arg2, sel);\n+\t      tree t = fold_vec_perm (type, arg1, arg2,\n+\t\t\t\t      vec_perm_indices (sel, 2, nelts));\n \t      if (t != NULL_TREE)\n \t\treturn t;\n \t    }\n@@ -11716,8 +11717,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  mask2 = 2 * nelts - 1;\n \t  mask = single_arg ? (nelts - 1) : mask2;\n \t  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n-\t  auto_vec_perm_indices sel (nelts);\n-\t  auto_vec_perm_indices sel2 (nelts);\n+\t  vec_perm_builder sel (nelts, nelts, 1);\n+\t  vec_perm_builder sel2 (nelts, nelts, 1);\n \t  for (i = 0; i < nelts; i++)\n \t    {\n \t      tree val = VECTOR_CST_ELT (arg2, i);\n@@ -11762,12 +11763,13 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t      need_mask_canon = true;\n \t    }\n \n+\t  vec_perm_indices indices (sel, 2, nelts);\n \t  if ((TREE_CODE (op0) == VECTOR_CST\n \t       || TREE_CODE (op0) == CONSTRUCTOR)\n \t      && (TREE_CODE (op1) == VECTOR_CST\n \t\t  || TREE_CODE (op1) == CONSTRUCTOR))\n \t    {\n-\t      tree t = fold_vec_perm (type, op0, op1, sel);\n+\t      tree t = fold_vec_perm (type, op0, op1, indices);\n \t      if (t != NULL_TREE)\n \t\treturn t;\n \t    }\n@@ -11779,11 +11781,14 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t     argument permutation while still allowing an equivalent\n \t     2-argument version.  */\n \t  if (need_mask_canon && arg2 == op2\n-\t      && !can_vec_perm_const_p (TYPE_MODE (type), sel, false)\n-\t      && can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n+\t      && !can_vec_perm_const_p (TYPE_MODE (type), indices, false)\n+\t      && can_vec_perm_const_p (TYPE_MODE (type),\n+\t\t\t\t       vec_perm_indices (sel2, 2, nelts),\n+\t\t\t\t       false))\n \t    {\n \t      need_mask_canon = need_mask_canon2;\n-\t      sel = sel2;\n+\t      sel.truncate (0);\n+\t      sel.splice (sel2);\n \t    }\n \n \t  if (need_mask_canon && arg2 == op2)"}, {"sha": "c416ee05bbf61e0f58747b253d45d5206daa52f1", "filename": "gcc/int-vector-builder.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fint-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fint-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fint-vector-builder.h?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -0,0 +1,90 @@\n+/* A class for building vector integer constants.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_INT_VECTOR_BUILDER_H\n+#define GCC_INT_VECTOR_BUILDER_H 1\n+\n+#include \"vector-builder.h\"\n+\n+/* This class is used to build vectors of integer type T using the same\n+   encoding as tree and rtx constants.  See vector_builder for more\n+   details.  */\n+template<typename T>\n+class int_vector_builder : public vector_builder<T, int_vector_builder<T> >\n+{\n+  typedef vector_builder<T, int_vector_builder> parent;\n+  friend class vector_builder<T, int_vector_builder>;\n+\n+public:\n+  int_vector_builder () {}\n+  int_vector_builder (unsigned int, unsigned int, unsigned int);\n+\n+  using parent::new_vector;\n+\n+private:\n+  bool equal_p (T, T) const;\n+  bool allow_steps_p () const { return true; }\n+  bool integral_p (T) const { return true; }\n+  T step (T, T) const;\n+  T apply_step (T, unsigned int, T) const;\n+  bool can_elide_p (T) const { return true; }\n+  void note_representative (T *, T) {}\n+};\n+\n+/* Create a new builder for a vector with FULL_NELTS elements.\n+   Initially encode the value as NPATTERNS interleaved patterns with\n+   NELTS_PER_PATTERN elements each.  */\n+\n+template<typename T>\n+inline\n+int_vector_builder<T>::int_vector_builder (unsigned int full_nelts,\n+\t\t\t\t\t   unsigned int npatterns,\n+\t\t\t\t\t   unsigned int nelts_per_pattern)\n+{\n+  new_vector (full_nelts, npatterns, nelts_per_pattern);\n+}\n+\n+/* Return true if elements ELT1 and ELT2 are equal.  */\n+\n+template<typename T>\n+inline bool\n+int_vector_builder<T>::equal_p (T elt1, T elt2) const\n+{\n+  return elt1 == elt2;\n+}\n+\n+/* Return the value of element ELT2 minus the value of element ELT1.  */\n+\n+template<typename T>\n+inline T\n+int_vector_builder<T>::step (T elt1, T elt2) const\n+{\n+  return elt2 - elt1;\n+}\n+\n+/* Return a vector element with the value BASE + FACTOR * STEP.  */\n+\n+template<typename T>\n+inline T\n+int_vector_builder<T>::apply_step (T base, unsigned int factor, T step) const\n+{\n+  return base + factor * step;\n+}\n+\n+#endif"}, {"sha": "de0ad1094c5bc912b8d6eb6fcd1475b9c45218e1", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -516,12 +516,13 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n       op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n-\t  auto_vec_perm_indices sel (nunits);\n+\t  vec_perm_builder sel (nunits, nunits, 1);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel.quick_push (!BYTES_BIG_ENDIAN\n \t\t\t    + (i & ~1)\n \t\t\t    + ((i & 1) ? nunits : 0));\n-\t  if (can_vec_perm_const_p (mode, sel))\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  if (can_vec_perm_const_p (mode, indices))\n \t    return 2;\n \t}\n     }\n@@ -532,10 +533,11 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n       op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n-\t  auto_vec_perm_indices sel (nunits);\n+\t  vec_perm_builder sel (nunits, nunits, 1);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n-\t  if (can_vec_perm_const_p (mode, sel))\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  if (can_vec_perm_const_p (mode, indices))\n \t    return 3;\n \t}\n     }"}, {"sha": "db13a25b15a3351a532d62b0ccc93f0578117fce", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -5476,6 +5476,11 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n   rtx_insn *last = get_last_insn ();\n \n   bool single_arg_p = rtx_equal_p (v0, v1);\n+  /* Always specify two input vectors here and leave the target to handle\n+     cases in which the inputs are equal.  Not all backends can cope with\n+     the single-input representation when testing for a double-input\n+     target instruction.  */\n+  vec_perm_indices indices (sel, 2, GET_MODE_NUNITS (mode));\n \n   /* See if this can be handled with a vec_shr.  We only do this if the\n      second vector is all zeroes.  */\n@@ -5488,7 +5493,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n       && (shift_code != CODE_FOR_nothing\n \t  || shift_code_qi != CODE_FOR_nothing))\n     {\n-      rtx shift_amt = shift_amt_for_vec_perm_mask (mode, sel);\n+      rtx shift_amt = shift_amt_for_vec_perm_mask (mode, indices);\n       if (shift_amt)\n \t{\n \t  struct expand_operand ops[3];\n@@ -5520,7 +5525,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n       else\n \tv1 = force_reg (mode, v1);\n \n-      if (targetm.vectorize.vec_perm_const (mode, target, v0, v1, sel))\n+      if (targetm.vectorize.vec_perm_const (mode, target, v0, v1, indices))\n \treturn target;\n     }\n \n@@ -5529,7 +5534,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n   rtx target_qi = NULL_RTX, v0_qi = NULL_RTX, v1_qi = NULL_RTX;\n   if (qimode != VOIDmode)\n     {\n-      qimode_indices.new_expanded_vector (sel, GET_MODE_UNIT_SIZE (mode));\n+      qimode_indices.new_expanded_vector (indices, GET_MODE_UNIT_SIZE (mode));\n       target_qi = gen_reg_rtx (qimode);\n       v0_qi = gen_lowpart (qimode, v0);\n       v1_qi = gen_lowpart (qimode, v1);\n@@ -5556,7 +5561,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n      REQUIRED_SEL_MODE is OK.  */\n   if (sel_mode != required_sel_mode)\n     {\n-      if (!selector_fits_mode_p (required_sel_mode, sel))\n+      if (!selector_fits_mode_p (required_sel_mode, indices))\n \t{\n \t  delete_insns_since (last);\n \t  return NULL_RTX;\n@@ -5567,7 +5572,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n   insn_code icode = direct_optab_handler (vec_perm_optab, mode);\n   if (icode != CODE_FOR_nothing)\n     {\n-      rtx sel_rtx = vec_perm_indices_to_rtx (sel_mode, sel);\n+      rtx sel_rtx = vec_perm_indices_to_rtx (sel_mode, indices);\n       rtx tmp = expand_vec_perm_1 (icode, target, v0, v1, sel_rtx);\n       if (tmp)\n \treturn tmp;\n@@ -5642,7 +5647,7 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   gcc_assert (sel != NULL);\n \n   /* Broadcast the low byte each element into each of its bytes.  */\n-  vec_perm_builder const_sel (w);\n+  vec_perm_builder const_sel (w, w, 1);\n   for (i = 0; i < w; ++i)\n     {\n       int this_e = i / u * u;\n@@ -5890,7 +5895,7 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   expand_insn (optab_handler (tab2, mode), 3, eops);\n   m2 = gen_lowpart (mode, eops[0].value);\n \n-  auto_vec_perm_indices sel (nunits);\n+  vec_perm_builder sel (nunits, nunits, 1);\n   if (method == 2)\n     {\n       for (i = 0; i < nunits; ++i)"}, {"sha": "41eef51f3e076efadd224a41e1bdfb28cdb2a2c0", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -2018,7 +2018,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   elem_type = TREE_TYPE (type);\n   elem_size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n \n-  auto_vec_perm_indices sel (nelts);\n+  vec_perm_builder sel (nelts, nelts, 1);\n   orig = NULL;\n   conv_code = ERROR_MARK;\n   maybe_ident = true;\n@@ -2109,7 +2109,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     {\n       tree mask_type;\n \n-      if (!can_vec_perm_const_p (TYPE_MODE (type), sel))\n+      vec_perm_indices indices (sel, 1, nelts);\n+      if (!can_vec_perm_const_p (TYPE_MODE (type), indices))\n \treturn false;\n       mask_type\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),"}, {"sha": "48673d11c1f4b901c50ad581784b516c94da2f67", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 69, "deletions": 40, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -4579,14 +4579,15 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-      auto_vec_perm_indices sel (nelt);\n+      vec_perm_builder sel (nelt, nelt, 1);\n       sel.quick_grow (nelt);\n \n       if (count == 3)\n \t{\n \t  unsigned int j0 = 0, j1 = 0, j2 = 0;\n \t  unsigned int i, j;\n \n+\t  vec_perm_indices indices;\n \t  for (j = 0; j < 3; j++)\n \t    {\n \t      int nelt0 = ((3 - j) * nelt) % 3;\n@@ -4601,7 +4602,8 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = 0;\n \t\t}\n-\t      if (!can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (!can_vec_perm_const_p (mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -4618,7 +4620,8 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = nelt + j2++;\n \t\t}\n-\t      if (!can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (!can_vec_perm_const_p (mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -4638,11 +4641,13 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t      sel[i * 2] = i;\n \t      sel[i * 2 + 1] = i + nelt;\n \t    }\n-\t  if (can_vec_perm_const_p (mode, sel))\n+\t  vec_perm_indices indices (sel, 2, nelt);\n+\t  if (can_vec_perm_const_p (mode, indices))\n \t    {\n \t      for (i = 0; i < nelt; i++)\n \t\tsel[i] += nelt / 2;\n-\t      if (can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (can_vec_perm_const_p (mode, indices))\n \t\treturn true;\n \t    }\n \t}\n@@ -4744,7 +4749,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   unsigned int i, n, log_length = exact_log2 (length);\n   unsigned int j, nelt = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  auto_vec_perm_indices sel (nelt);\n+  vec_perm_builder sel (nelt, nelt, 1);\n   sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n@@ -4755,6 +4760,7 @@ vect_permute_store_chain (vec<tree> dr_chain,\n     {\n       unsigned int j0 = 0, j1 = 0, j2 = 0;\n \n+      vec_perm_indices indices;\n       for (j = 0; j < 3; j++)\n         {\n \t  int nelt0 = ((3 - j) * nelt) % 3;\n@@ -4770,7 +4776,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t      if (3 * i + nelt2 < nelt)\n \t\tsel[3 * i + nelt2] = 0;\n \t    }\n-\t  perm3_mask_low = vect_gen_perm_mask_checked (vectype, sel);\n+\t  indices.new_vector (sel, 2, nelt);\n+\t  perm3_mask_low = vect_gen_perm_mask_checked (vectype, indices);\n \n \t  for (i = 0; i < nelt; i++)\n \t    {\n@@ -4781,7 +4788,8 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t      if (3 * i + nelt2 < nelt)\n \t\tsel[3 * i + nelt2] = nelt + j2++;\n \t    }\n-\t  perm3_mask_high = vect_gen_perm_mask_checked (vectype, sel);\n+\t  indices.new_vector (sel, 2, nelt);\n+\t  perm3_mask_high = vect_gen_perm_mask_checked (vectype, indices);\n \n \t  vect1 = dr_chain[0];\n \t  vect2 = dr_chain[1];\n@@ -4818,11 +4826,13 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t  sel[i * 2] = i;\n \t  sel[i * 2 + 1] = i + nelt;\n \t}\n-\tperm_mask_high = vect_gen_perm_mask_checked (vectype, sel);\n+\tvec_perm_indices indices (sel, 2, nelt);\n+\tperm_mask_high = vect_gen_perm_mask_checked (vectype, indices);\n \n \tfor (i = 0; i < nelt; i++)\n \t  sel[i] += nelt / 2;\n-\tperm_mask_low = vect_gen_perm_mask_checked (vectype, sel);\n+\tindices.new_vector (sel, 2, nelt);\n+\tperm_mask_low = vect_gen_perm_mask_checked (vectype, indices);\n \n \tfor (i = 0, n = log_length; i < n; i++)\n \t  {\n@@ -5167,11 +5177,12 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, j, nelt = GET_MODE_NUNITS (mode);\n-      auto_vec_perm_indices sel (nelt);\n+      vec_perm_builder sel (nelt, nelt, 1);\n       sel.quick_grow (nelt);\n \n       if (count == 3)\n \t{\n+\t  vec_perm_indices indices;\n \t  unsigned int k;\n \t  for (k = 0; k < 3; k++)\n \t    {\n@@ -5180,7 +5191,8 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = 3 * i + k;\n \t\telse\n \t\t  sel[i] = 0;\n-\t      if (!can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (!can_vec_perm_const_p (mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5193,7 +5205,8 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = i;\n \t\telse\n \t\t  sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n-\t      if (!can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (!can_vec_perm_const_p (mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5208,13 +5221,16 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t{\n \t  /* If length is not equal to 3 then only power of 2 is supported.  */\n \t  gcc_assert (pow2p_hwi (count));\n+\n \t  for (i = 0; i < nelt; i++)\n \t    sel[i] = i * 2;\n-\t  if (can_vec_perm_const_p (mode, sel))\n+\t  vec_perm_indices indices (sel, 2, nelt);\n+\t  if (can_vec_perm_const_p (mode, indices))\n \t    {\n \t      for (i = 0; i < nelt; i++)\n \t\tsel[i] = i * 2 + 1;\n-\t      if (can_vec_perm_const_p (mode, sel))\n+\t      indices.new_vector (sel, 2, nelt);\n+\t      if (can_vec_perm_const_p (mode, indices))\n \t\treturn true;\n \t    }\n         }\n@@ -5329,7 +5345,7 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   unsigned int i, j, log_length = exact_log2 (length);\n   unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  auto_vec_perm_indices sel (nelt);\n+  vec_perm_builder sel (nelt, nelt, 1);\n   sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n@@ -5340,22 +5356,24 @@ vect_permute_load_chain (vec<tree> dr_chain,\n     {\n       unsigned int k;\n \n+      vec_perm_indices indices;\n       for (k = 0; k < 3; k++)\n \t{\n \t  for (i = 0; i < nelt; i++)\n \t    if (3 * i + k < 2 * nelt)\n \t      sel[i] = 3 * i + k;\n \t    else\n \t      sel[i] = 0;\n-\t  perm3_mask_low = vect_gen_perm_mask_checked (vectype, sel);\n+\t  indices.new_vector (sel, 2, nelt);\n+\t  perm3_mask_low = vect_gen_perm_mask_checked (vectype, indices);\n \n \t  for (i = 0, j = 0; i < nelt; i++)\n \t    if (3 * i + k < 2 * nelt)\n \t      sel[i] = i;\n \t    else\n \t      sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n-\n-\t  perm3_mask_high = vect_gen_perm_mask_checked (vectype, sel);\n+\t  indices.new_vector (sel, 2, nelt);\n+\t  perm3_mask_high = vect_gen_perm_mask_checked (vectype, indices);\n \n \t  first_vect = dr_chain[0];\n \t  second_vect = dr_chain[1];\n@@ -5387,11 +5405,13 @@ vect_permute_load_chain (vec<tree> dr_chain,\n \n       for (i = 0; i < nelt; ++i)\n \tsel[i] = i * 2;\n-      perm_mask_even = vect_gen_perm_mask_checked (vectype, sel);\n+      vec_perm_indices indices (sel, 2, nelt);\n+      perm_mask_even = vect_gen_perm_mask_checked (vectype, indices);\n \n       for (i = 0; i < nelt; ++i)\n \tsel[i] = i * 2 + 1;\n-      perm_mask_odd = vect_gen_perm_mask_checked (vectype, sel);\n+      indices.new_vector (sel, 2, nelt);\n+      perm_mask_odd = vect_gen_perm_mask_checked (vectype, indices);\n \n       for (i = 0; i < log_length; i++)\n \t{\n@@ -5527,7 +5547,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n-  auto_vec_perm_indices sel (nelt);\n+  vec_perm_builder sel (nelt, nelt, 1);\n   sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n@@ -5541,57 +5561,61 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i * 2;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2 + 1;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      vec_perm_indices indices (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shuffle of 2 fields structure is not \\\n \t\t\t      supported by target\\n\");\n \t  return false;\n \t}\n-      perm2_mask1 = vect_gen_perm_mask_checked (vectype, sel);\n+      perm2_mask1 = vect_gen_perm_mask_checked (vectype, indices);\n \n       for (i = 0; i < nelt / 2; ++i)\n \tsel[i] = i * 2 + 1;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shuffle of 2 fields structure is not \\\n \t\t\t      supported by target\\n\");\n \t  return false;\n \t}\n-      perm2_mask2 = vect_gen_perm_mask_checked (vectype, sel);\n+      perm2_mask2 = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to shift all elements.\n \t For vector length 8 it is {4 5 6 7 8 9 10 11}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = nelt / 2 + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shift permutation is not supported by target\\n\");\n \t  return false;\n \t}\n-      shift1_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      shift1_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to select vector from 2.\n \t For vector length 8 it is {0 1 2 3 12 13 14 15}.  */\n       for (i = 0; i < nelt / 2; i++)\n \tsel[i] = i;\n       for (i = nelt / 2; i < nelt; i++)\n \tsel[i] = nelt + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"select is not supported by target\\n\");\n \t  return false;\n \t}\n-      select_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      select_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       for (i = 0; i < log_length; i++)\n \t{\n@@ -5647,67 +5671,72 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t  sel[i] = 3 * k + (l % 3);\n \t  k++;\n \t}\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      vec_perm_indices indices (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shuffle of 3 fields structure is not \\\n \t\t\t      supported by target\\n\");\n \t  return false;\n \t}\n-      perm3_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      perm3_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to shift all elements.\n \t For vector length 8 it is {6 7 8 9 10 11 12 13}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shift permutation is not supported by target\\n\");\n \t  return false;\n \t}\n-      shift1_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      shift1_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to shift all elements.\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + 1 + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shift permutation is not supported by target\\n\");\n \t  return false;\n \t}\n-      shift2_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      shift2_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to shift all elements.\n \t For vector length 8 it is {3 4 5 6 7 8 9 10}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shift permutation is not supported by target\\n\");\n \t  return false;\n \t}\n-      shift3_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      shift3_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       /* Generating permutation constant to shift all elements.\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"shift permutation is not supported by target\\n\");\n \t  return false;\n \t}\n-      shift4_mask = vect_gen_perm_mask_checked (vectype, sel);\n+      shift4_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n       for (k = 0; k < 3; k++)\n \t{"}, {"sha": "767721cd62ca0406d1f111b2b9b84f4c8a2058eb", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -1299,15 +1299,13 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \tmask = gimple_assign_rhs1 (def_stmt);\n     }\n \n-  if (TREE_CODE (mask) == VECTOR_CST)\n-    {\n-      auto_vec_perm_indices sel_int (elements);\n-\n-      for (i = 0; i < elements; ++i)\n-\tsel_int.quick_push (TREE_INT_CST_LOW (VECTOR_CST_ELT (mask, i))\n-\t\t\t    & (2 * elements - 1));\n+  vec_perm_builder sel_int;\n \n-      if (can_vec_perm_const_p (TYPE_MODE (vect_type), sel_int))\n+  if (TREE_CODE (mask) == VECTOR_CST\n+      && tree_to_vec_perm_builder (&sel_int, mask))\n+    {\n+      vec_perm_indices indices (sel_int, 2, elements);\n+      if (can_vec_perm_const_p (TYPE_MODE (vect_type), indices))\n \t{\n \t  gimple_assign_set_rhs3 (stmt, mask);\n \t  update_stmt (stmt);\n@@ -1319,14 +1317,14 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t  != CODE_FOR_nothing\n \t  && TREE_CODE (vec1) == VECTOR_CST\n \t  && initializer_zerop (vec1)\n-\t  && sel_int[0]\n-\t  && sel_int[0] < elements)\n+\t  && indices[0]\n+\t  && indices[0] < elements)\n \t{\n \t  for (i = 1; i < elements; ++i)\n \t    {\n-\t      unsigned int expected = i + sel_int[0];\n+\t      unsigned int expected = i + indices[0];\n \t      /* Indices into the second vector are all equivalent.  */\n-\t      if (MIN (elements, (unsigned) sel_int[i])\n+\t      if (MIN (elements, (unsigned) indices[i])\n \t\t  != MIN (elements, expected))\n  \t\tbreak;\n \t    }"}, {"sha": "fa33c7dfc94782381ace52ab2fec4adecbb5db3b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -3713,12 +3713,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n    vector elements (not bits) for a vector with NELT elements.  */\n static void\n calc_vec_perm_mask_for_shift (unsigned int offset, unsigned int nelt,\n-\t\t\t      vec_perm_indices *sel)\n+\t\t\t      vec_perm_builder *sel)\n {\n-  unsigned int i;\n-\n-  for (i = 0; i < nelt; i++)\n-    sel->quick_push ((i + offset) & (2 * nelt - 1));\n+  sel->new_vector (nelt, nelt, 1);\n+  for (unsigned int i = 0; i < nelt; i++)\n+    sel->quick_push (i + offset);\n }\n \n /* Checks whether the target supports whole-vector shifts for vectors of mode\n@@ -3731,13 +3730,13 @@ have_whole_vector_shift (machine_mode mode)\n     return true;\n \n   unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-  auto_vec_perm_indices sel (nelt);\n-\n+  vec_perm_builder sel;\n+  vec_perm_indices indices;\n   for (i = nelt/2; i >= 1; i/=2)\n     {\n-      sel.truncate (0);\n       calc_vec_perm_mask_for_shift (i, nelt, &sel);\n-      if (!can_vec_perm_const_p (mode, sel, false))\n+      indices.new_vector (sel, 2, nelt);\n+      if (!can_vec_perm_const_p (mode, indices, false))\n \treturn false;\n     }\n   return true;\n@@ -5055,7 +5054,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       if (reduce_with_shift && !slp_reduc)\n         {\n           int nelements = vec_size_in_bits / element_bitsize;\n-          auto_vec_perm_indices sel (nelements);\n+\t  vec_perm_builder sel;\n+\t  vec_perm_indices indices;\n \n           int elt_offset;\n \n@@ -5079,9 +5079,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                elt_offset >= 1;\n                elt_offset /= 2)\n             {\n-\t      sel.truncate (0);\n \t      calc_vec_perm_mask_for_shift (elt_offset, nelements, &sel);\n-\t      tree mask = vect_gen_perm_mask_any (vectype, sel);\n+\t      indices.new_vector (sel, 2, nelements);\n+\t      tree mask = vect_gen_perm_mask_any (vectype, indices);\n \t      epilog_stmt = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n \t\t\t\t\t\t new_temp, zero_vec, mask);\n               new_name = make_ssa_name (vec_dest, epilog_stmt);"}, {"sha": "ca7827f51bec0eab752241ad982b946a71d77bb8", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -894,15 +894,16 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n     {\n       unsigned int count = TYPE_VECTOR_SUBPARTS (vectype);\n-      auto_vec_perm_indices sel (count);\n+      vec_perm_builder sel (count, count, 1);\n       for (i = 0; i < count; ++i)\n \t{\n \t  unsigned int elt = i;\n \t  if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n \t    elt += count;\n \t  sel.quick_push (elt);\n \t}\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+      vec_perm_indices indices (sel, 2, count);\n+      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n \t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n@@ -3570,8 +3571,9 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  auto_vec_perm_indices mask (nunits);\n+  vec_perm_builder mask (nunits, nunits, 1);\n   mask.quick_grow (nunits);\n+  vec_perm_indices indices;\n \n   /* Initialize the vect stmts of NODE to properly insert the generated\n      stmts later.  */\n@@ -3644,27 +3646,30 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t    noop_p = false;\n \t  mask[index++] = mask_element;\n \n-\t  if (index == nunits)\n+\t  if (index == nunits && !noop_p)\n \t    {\n-\t      if (! noop_p\n-\t\t  && ! can_vec_perm_const_p (mode, mask))\n+\t      indices.new_vector (mask, 2, nunits);\n+\t      if (!can_vec_perm_const_p (mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    {\n \t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t       vect_location, \n \t\t\t\t       \"unsupported vect permute { \");\n \t\t      for (i = 0; i < nunits; ++i)\n-\t\t\tdump_printf (MSG_MISSED_OPTIMIZATION, \"%d \", mask[i]);\n+\t\t\tdump_printf (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t     HOST_WIDE_INT_PRINT_DEC \" \", mask[i]);\n \t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n \t\t    }\n \t\t  gcc_assert (analyze_only);\n \t\t  return false;\n \t\t}\n \n-\t      if (! noop_p)\n-\t\t++*n_perms;\n+\t      ++*n_perms;\n+\t    }\n \n+\t  if (index == nunits)\n+\t    {\n \t      if (!analyze_only)\n \t\t{\n \t\t  tree mask_vec = NULL_TREE;\n@@ -3797,7 +3802,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       enum tree_code code0 = gimple_assign_rhs_code (stmt);\n       enum tree_code ocode = ERROR_MARK;\n       gimple *ostmt;\n-      auto_vec_perm_indices mask (group_size);\n+      vec_perm_builder mask (group_size, group_size, 1);\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt)\n \tif (gimple_assign_rhs_code (ostmt) != code0)\n \t  {"}, {"sha": "fed870ea5f63096770e435874189f09369befe7f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -1717,13 +1717,14 @@ perm_mask_for_reverse (tree vectype)\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  auto_vec_perm_indices sel (nunits);\n+  vec_perm_builder sel (nunits, nunits, 1);\n   for (i = 0; i < nunits; ++i)\n     sel.quick_push (nunits - 1 - i);\n \n-  if (!can_vec_perm_const_p (TYPE_MODE (vectype), sel))\n+  vec_perm_indices indices (sel, 1, nunits);\n+  if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n     return NULL_TREE;\n-  return vect_gen_perm_mask_checked (vectype, sel);\n+  return vect_gen_perm_mask_checked (vectype, indices);\n }\n \n /* A subroutine of get_load_store_type, with a subset of the same\n@@ -2185,27 +2186,32 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  modifier = WIDEN;\n \n-\t  auto_vec_perm_indices sel (gather_off_nunits);\n+\t  vec_perm_builder sel (gather_off_nunits, gather_off_nunits, 1);\n \t  for (i = 0; i < gather_off_nunits; ++i)\n \t    sel.quick_push (i | nunits);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n+\t  vec_perm_indices indices (sel, 1, gather_off_nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype,\n+\t\t\t\t\t\t  indices);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n \t  modifier = NARROW;\n \n-\t  auto_vec_perm_indices sel (nunits);\n+\t  vec_perm_builder sel (nunits, nunits, 1);\n \t  sel.quick_grow (nunits);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel[i] = i < gather_off_nunits\n \t\t     ? i : i + nunits - gather_off_nunits;\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (vectype, indices);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n \t  ncopies *= 2;\n+\n \t  for (i = 0; i < nunits; ++i)\n \t    sel[i] = i | gather_off_nunits;\n-\t  mask_perm_mask = vect_gen_perm_mask_checked (masktype, sel);\n+\t  indices.new_vector (sel, 2, gather_off_nunits);\n+\t  mask_perm_mask = vect_gen_perm_mask_checked (masktype, indices);\n \t}\n       else\n \tgcc_unreachable ();\n@@ -2498,12 +2504,13 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n   unsigned int num_bytes = TYPE_VECTOR_SUBPARTS (char_vectype);\n   unsigned word_bytes = num_bytes / nunits;\n \n-  auto_vec_perm_indices elts (num_bytes);\n+  vec_perm_builder elts (num_bytes, num_bytes, 1);\n   for (unsigned i = 0; i < nunits; ++i)\n     for (unsigned j = 0; j < word_bytes; ++j)\n       elts.quick_push ((i + 1) * word_bytes - j - 1);\n \n-  if (!can_vec_perm_const_p (TYPE_MODE (char_vectype), elts))\n+  vec_perm_indices indices (elts, 1, num_bytes);\n+  if (!can_vec_perm_const_p (TYPE_MODE (char_vectype), indices))\n     return false;\n \n   if (! vec_stmt)\n@@ -5826,22 +5833,25 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  modifier = WIDEN;\n \n-\t  auto_vec_perm_indices sel (scatter_off_nunits);\n+\t  vec_perm_builder sel (scatter_off_nunits, scatter_off_nunits, 1);\n \t  for (i = 0; i < (unsigned int) scatter_off_nunits; ++i)\n \t    sel.quick_push (i | nunits);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n+\t  vec_perm_indices indices (sel, 1, scatter_off_nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype,\n+\t\t\t\t\t\t  indices);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t}\n       else if (nunits == (unsigned int) scatter_off_nunits * 2)\n \t{\n \t  modifier = NARROW;\n \n-\t  auto_vec_perm_indices sel (nunits);\n+\t  vec_perm_builder sel (nunits, nunits, 1);\n \t  for (i = 0; i < (unsigned int) nunits; ++i)\n \t    sel.quick_push (i | scatter_off_nunits);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (vectype, indices);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t  ncopies *= 2;\n \t}\n@@ -6862,22 +6872,25 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  modifier = WIDEN;\n \n-\t  auto_vec_perm_indices sel (gather_off_nunits);\n+\t  vec_perm_builder sel (gather_off_nunits, gather_off_nunits, 1);\n \t  for (i = 0; i < gather_off_nunits; ++i)\n \t    sel.quick_push (i | nunits);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n+\t  vec_perm_indices indices (sel, 1, gather_off_nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype,\n+\t\t\t\t\t\t  indices);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n \t  modifier = NARROW;\n \n-\t  auto_vec_perm_indices sel (nunits);\n+\t  vec_perm_builder sel (nunits, nunits, 1);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel.quick_push (i < gather_off_nunits\n \t\t\t    ? i : i + nunits - gather_off_nunits);\n \n-\t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  perm_mask = vect_gen_perm_mask_checked (vectype, indices);\n \t  ncopies *= 2;\n \t}\n       else"}, {"sha": "3a35425bee211223e9e22da3b7e28cada896c187", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 89, "deletions": 14, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -22,11 +22,33 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"vec-perm-indices.h\"\n #include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"tree-vector-builder.h\"\n #include \"backend.h\"\n #include \"rtl.h\"\n #include \"memmodel.h\"\n #include \"emit-rtl.h\"\n \n+/* Switch to a new permutation vector that selects between NINPUTS vector\n+   inputs that have NELTS_PER_INPUT elements each.  Take the elements of the\n+   new permutation vector from ELEMENTS, clamping each one to be in range.  */\n+\n+void\n+vec_perm_indices::new_vector (const vec_perm_builder &elements,\n+\t\t\t      unsigned int ninputs,\n+\t\t\t      unsigned int nelts_per_input)\n+{\n+  m_ninputs = ninputs;\n+  m_nelts_per_input = nelts_per_input;\n+  /* Expand the encoding and clamp each element.  E.g. { 0, 2, 4, ... }\n+     might wrap halfway if there is only one vector input.  */\n+  unsigned int full_nelts = elements.full_nelts ();\n+  m_encoding.new_vector (full_nelts, full_nelts, 1);\n+  for (unsigned int i = 0; i < full_nelts; ++i)\n+    m_encoding.quick_push (clamp (elements.elt (i)));\n+  m_encoding.finalize ();\n+}\n+\n /* Switch to a new permutation vector that selects the same input elements\n    as ORIG, but with each element split into FACTOR pieces.  For example,\n    if ORIG is { 1, 2, 0, 3 } and FACTOR is 2, the new permutation is\n@@ -36,14 +58,31 @@ void\n vec_perm_indices::new_expanded_vector (const vec_perm_indices &orig,\n \t\t\t\t       unsigned int factor)\n {\n-  truncate (0);\n-  reserve (orig.length () * factor);\n-  for (unsigned int i = 0; i < orig.length (); ++i)\n+  m_ninputs = orig.m_ninputs;\n+  m_nelts_per_input = orig.m_nelts_per_input * factor;\n+  m_encoding.new_vector (orig.m_encoding.full_nelts () * factor,\n+\t\t\t orig.m_encoding.npatterns () * factor,\n+\t\t\t orig.m_encoding.nelts_per_pattern ());\n+  unsigned int encoded_nelts = orig.m_encoding.encoded_nelts ();\n+  for (unsigned int i = 0; i < encoded_nelts; ++i)\n     {\n-      element_type base = orig[i] * factor;\n+      element_type base = orig.m_encoding[i] * factor;\n       for (unsigned int j = 0; j < factor; ++j)\n-\tquick_push (base + j);\n+\tm_encoding.quick_push (base + j);\n     }\n+  m_encoding.finalize ();\n+}\n+\n+/* Rotate the inputs of the permutation right by DELTA inputs.  This changes\n+   the values of the permutation vector but it doesn't change the way that\n+   the elements are encoded.  */\n+\n+void\n+vec_perm_indices::rotate_inputs (int delta)\n+{\n+  element_type element_delta = delta * m_nelts_per_input;\n+  for (unsigned int i = 0; i < m_encoding.length (); ++i)\n+    m_encoding[i] = clamp (m_encoding[i] + element_delta);\n }\n \n /* Return true if all elements of the permutation vector are in the range\n@@ -52,9 +91,44 @@ vec_perm_indices::new_expanded_vector (const vec_perm_indices &orig,\n bool\n vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n {\n-  for (unsigned int i = 0; i < length (); ++i)\n-    if ((*this)[i] < start || ((*this)[i] - start) >= size)\n+  /* Check the first two elements of each pattern.  */\n+  unsigned int npatterns = m_encoding.npatterns ();\n+  unsigned int nelts_per_pattern = m_encoding.nelts_per_pattern ();\n+  unsigned int base_nelts = npatterns * MIN (nelts_per_pattern, 2);\n+  for (unsigned int i = 0; i < base_nelts; ++i)\n+    if (m_encoding[i] < start || (m_encoding[i] - start) >= size)\n       return false;\n+\n+  /* For stepped encodings, check the full range of the series.  */\n+  if (nelts_per_pattern == 3)\n+    {\n+      element_type limit = input_nelts ();\n+\n+      /* The number of elements in each pattern beyond the first two\n+\t that we checked above.  */\n+      unsigned int step_nelts = (m_encoding.full_nelts () / npatterns) - 2;\n+      for (unsigned int i = 0; i < npatterns; ++i)\n+\t{\n+\t  /* BASE1 has been checked but BASE2 hasn't.   */\n+\t  element_type base1 = m_encoding[i + npatterns];\n+\t  element_type base2 = m_encoding[i + base_nelts];\n+\n+\t  /* The step to add to get from BASE1 to each subsequent value.  */\n+\t  element_type step = clamp (base2 - base1);\n+\n+\t  /* STEP has no inherent sign, so a value near LIMIT can\n+\t     act as a negative step.  The series is in range if it\n+\t     is in range according to one of the two interpretations.\n+\n+\t     Since we're dealing with clamped values, ELEMENT_TYPE is\n+\t     wide enough for overflow not to be a problem.  */\n+\t  element_type headroom_down = base1 - start;\n+\t  element_type headroom_up = size - headroom_down - 1;\n+\t  if (headroom_up < step * step_nelts\n+\t      && headroom_down < (limit - step) * step_nelts)\n+\t    return false;\n+\t}\n+    }\n   return true;\n }\n \n@@ -65,15 +139,16 @@ vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n bool\n tree_to_vec_perm_builder (vec_perm_builder *builder, tree cst)\n {\n-  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (cst));\n-  for (unsigned int i = 0; i < nelts; ++i)\n-    if (!tree_fits_shwi_p (vector_cst_elt (cst, i)))\n+  unsigned int encoded_nelts = vector_cst_encoded_nelts (cst);\n+  for (unsigned int i = 0; i < encoded_nelts; ++i)\n+    if (!tree_fits_shwi_p (VECTOR_CST_ENCODED_ELT (cst, i)))\n       return false;\n \n-  builder->reserve (nelts);\n-  for (unsigned int i = 0; i < nelts; ++i)\n-    builder->quick_push (tree_to_shwi (vector_cst_elt (cst, i))\n-\t\t\t & (2 * nelts - 1));\n+  builder->new_vector (TYPE_VECTOR_SUBPARTS (TREE_TYPE (cst)),\n+\t\t       VECTOR_CST_NPATTERNS (cst),\n+\t\t       VECTOR_CST_NELTS_PER_PATTERN (cst));\n+  for (unsigned int i = 0; i < encoded_nelts; ++i)\n+    builder->quick_push (tree_to_shwi (VECTOR_CST_ENCODED_ELT (cst, i)));\n   return true;\n }\n "}, {"sha": "a36666298ccfcab43978e223ee6fbb98b5a241e9", "filename": "gcc/vec-perm-indices.h", "status": "modified", "additions": 97, "deletions": 10, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3342de49cbee48957acc749b9566eee230860be/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=e3342de49cbee48957acc749b9566eee230860be", "patch": "@@ -20,30 +20,117 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VEC_PERN_INDICES_H\n #define GCC_VEC_PERN_INDICES_H 1\n \n+#include \"int-vector-builder.h\"\n+\n+/* A vector_builder for building constant permutation vectors.\n+   The elements do not need to be clamped to a particular range\n+   of input elements.  */\n+typedef int_vector_builder<HOST_WIDE_INT> vec_perm_builder;\n+\n /* This class represents a constant permutation vector, such as that used\n-   as the final operand to a VEC_PERM_EXPR.  */\n-class vec_perm_indices : public auto_vec<unsigned short, 32>\n+   as the final operand to a VEC_PERM_EXPR.\n+\n+   Permutation vectors select indices modulo the number of input elements,\n+   and the class canonicalizes each permutation vector for a particular\n+   number of input vectors and for a particular number of elements per\n+   input.  For example, the gimple statements:\n+\n+    _1 = VEC_PERM_EXPR <a, a, { 0, 2, 4, 6, 0, 2, 4, 6 }>;\n+    _2 = VEC_PERM_EXPR <a, a, { 0, 2, 4, 6, 8, 10, 12, 14 }>;\n+    _3 = VEC_PERM_EXPR <a, a, { 0, 2, 20, 22, 24, 2, 4, 14 }>;\n+\n+   effectively have only a single vector input \"a\".  If \"a\" has 8\n+   elements, the indices select elements modulo 8, which makes all three\n+   VEC_PERM_EXPRs equivalent.  The canonical form is for the indices to be\n+   in the range [0, number of input elements - 1], so the class treats the\n+   second and third permutation vectors as though they had been the first.\n+\n+   The class copes with cases in which the input and output vectors have\n+   different numbers of elements.  */\n+class vec_perm_indices\n {\n-  typedef unsigned short element_type;\n-  typedef auto_vec<element_type, 32> parent_type;\n+  typedef HOST_WIDE_INT element_type;\n \n public:\n-  vec_perm_indices () {}\n-  vec_perm_indices (unsigned int nunits) : parent_type (nunits) {}\n+  vec_perm_indices ();\n+  vec_perm_indices (const vec_perm_builder &, unsigned int, unsigned int);\n \n+  void new_vector (const vec_perm_builder &, unsigned int, unsigned int);\n   void new_expanded_vector (const vec_perm_indices &, unsigned int);\n+  void rotate_inputs (int delta);\n \n+  /* Return the underlying vector encoding.  */\n+  const vec_perm_builder &encoding () const { return m_encoding; }\n+\n+  /* Return the number of output elements.  This is called length ()\n+     so that we present a more vec-like interface.  */\n+  unsigned int length () const { return m_encoding.full_nelts (); }\n+\n+  /* Return the number of input vectors being permuted.  */\n+  unsigned int ninputs () const { return m_ninputs; }\n+\n+  /* Return the number of elements in each input vector.  */\n+  unsigned int nelts_per_input () const { return m_nelts_per_input; }\n+\n+  /* Return the total number of input elements.  */\n+  unsigned int input_nelts () const { return m_ninputs * m_nelts_per_input; }\n+\n+  element_type clamp (element_type) const;\n+  element_type operator[] (unsigned int i) const;\n   bool all_in_range_p (element_type, element_type) const;\n \n private:\n   vec_perm_indices (const vec_perm_indices &);\n-};\n \n-/* Temporary.  */\n-typedef vec_perm_indices vec_perm_builder;\n-typedef vec_perm_indices auto_vec_perm_indices;\n+  vec_perm_builder m_encoding;\n+  unsigned int m_ninputs;\n+  unsigned int m_nelts_per_input;\n+};\n \n bool tree_to_vec_perm_builder (vec_perm_builder *, tree);\n rtx vec_perm_indices_to_rtx (machine_mode, const vec_perm_indices &);\n \n+inline\n+vec_perm_indices::vec_perm_indices ()\n+  : m_ninputs (0),\n+    m_nelts_per_input (0)\n+{\n+}\n+\n+/* Construct a permutation vector that selects between NINPUTS vector\n+   inputs that have NELTS_PER_INPUT elements each.  Take the elements of\n+   the new vector from ELEMENTS, clamping each one to be in range.  */\n+\n+inline\n+vec_perm_indices::vec_perm_indices (const vec_perm_builder &elements,\n+\t\t\t\t    unsigned int ninputs,\n+\t\t\t\t    unsigned int nelts_per_input)\n+{\n+  new_vector (elements, ninputs, nelts_per_input);\n+}\n+\n+/* Return the canonical value for permutation vector element ELT,\n+   taking into account the current number of input elements.  */\n+\n+inline vec_perm_indices::element_type\n+vec_perm_indices::clamp (element_type elt) const\n+{\n+  element_type limit = input_nelts ();\n+  elt %= limit;\n+  /* Treat negative elements as counting from the end.  This only matters\n+     if the vector size is not a power of 2.  */\n+  if (elt < 0)\n+    elt += limit;\n+  return elt;\n+}\n+\n+/* Return the value of vector element I, which might or might not be\n+   explicitly encoded.  */\n+\n+inline vec_perm_indices::element_type\n+vec_perm_indices::operator[] (unsigned int i) const\n+{\n+  return clamp (m_encoding.elt (i));\n+}\n+\n #endif"}]}