{"sha": "ae54c1b09963779c5c3914782324ff48af32e2f1", "node_id": "C_kwDOANBUbNoAKGFlNTRjMWIwOTk2Mzc3OWM1YzM5MTQ3ODIzMjRmZjQ4YWYzMmUyZjE", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wilco.dijkstra@arm.com", "date": "2022-06-01T15:46:36Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2022-06-01T17:13:57Z"}, "message": "AArch64: Cleanup option processing code\n\nFurther cleanup option processing. Remove the duplication of global\nvariables for CPU and tune settings so that CPU option processing is\nsimplified even further. Move global variables that need save and\nrestore due to target option processing into aarch64.opt. This removes\nthe need for explicit saving/restoring and unnecessary reparsing of\noptions.\n\ngcc/\n\t* config/aarch64/aarch64.opt (explicit_tune_core): Rename to\n\tselected_tune.\n\t(explicit_arch): Rename to selected_arch.\n\t(x_aarch64_override_tune_string): Remove.\n\t(aarch64_ra_sign_key): Add as TargetVariable so it gets saved/restored.\n\t(aarch64_override_tune_string): Add Save so it gets saved/restored.\n\t* config/aarch64/aarch64.h (aarch64_architecture_version): Remove.\n\t* config/aarch64/aarch64.cc (aarch64_architecture_version): Remove.\n\t(processor): Remove archtecture_version field.\n\t(selected_arch): Remove global.\n\t(selected_cpu): Remove global.\n\t(selected_tune): Remove global.\n\t(aarch64_ra_sign_key): Move global to aarch64.opt so it is saved.\n\t(aarch64_override_options_internal): Use aarch64_get_tune_cpu.\n\t(aarch64_override_options): Further simplify code to only set\n\tselected_arch and selected_tune globals.\n\t(aarch64_option_save): Remove now that target options are saved.\n\t(aarch64_option_restore): Remove redundant target option restores.\n\t* config/aarch64/aarch64-c.cc (aarch64_update_cpp_builtins): Use\n\tAARCH64_ISA_V9.\n\t* config/aarch64/aarch64-opts.h (aarch64_key_type): Add, moved from...\n\t* config/aarch64/aarch64-protos.h (aarch64_key_type): Remove.\n\t(aarch64_ra_sign_key): Remove.", "tree": {"sha": "d752f87a693613ca3992d020b25e49683ef7f0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d752f87a693613ca3992d020b25e49683ef7f0d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae54c1b09963779c5c3914782324ff48af32e2f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae54c1b09963779c5c3914782324ff48af32e2f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae54c1b09963779c5c3914782324ff48af32e2f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae54c1b09963779c5c3914782324ff48af32e2f1/comments", "author": {"login": "Wilco1", "id": 58446312, "node_id": "MDQ6VXNlcjU4NDQ2MzEy", "avatar_url": "https://avatars.githubusercontent.com/u/58446312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Wilco1", "html_url": "https://github.com/Wilco1", "followers_url": "https://api.github.com/users/Wilco1/followers", "following_url": "https://api.github.com/users/Wilco1/following{/other_user}", "gists_url": "https://api.github.com/users/Wilco1/gists{/gist_id}", "starred_url": "https://api.github.com/users/Wilco1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Wilco1/subscriptions", "organizations_url": "https://api.github.com/users/Wilco1/orgs", "repos_url": "https://api.github.com/users/Wilco1/repos", "events_url": "https://api.github.com/users/Wilco1/events{/privacy}", "received_events_url": "https://api.github.com/users/Wilco1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf78d8411d00e21c30512d2af895e70d38bbfb77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf78d8411d00e21c30512d2af895e70d38bbfb77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf78d8411d00e21c30512d2af895e70d38bbfb77"}], "stats": {"total": 214, "additions": 76, "deletions": 138}, "files": [{"sha": "3d2fb5ec2ef33e66aaa59d216c53a29737262794", "filename": "gcc/config/aarch64/aarch64-c.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -82,7 +82,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n {\n   aarch64_def_or_undef (flag_unsafe_math_optimizations, \"__ARM_FP_FAST\", pfile);\n \n-  builtin_define_with_int_value (\"__ARM_ARCH\", aarch64_architecture_version);\n+  builtin_define_with_int_value (\"__ARM_ARCH\", AARCH64_ISA_V9 ? 9 : 8);\n \n   builtin_define_with_int_value (\"__ARM_SIZEOF_MINIMAL_ENUM\",\n \t\t\t\t flag_short_enums ? 1 : 4);"}, {"sha": "421648a156a02cc1f43660eddc5de38c2f366a72", "filename": "gcc/config/aarch64/aarch64-opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-opts.h?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -98,4 +98,10 @@ enum stack_protector_guard {\n   SSP_GLOBAL\t\t\t/* global canary */\n };\n \n+/* The key type that -msign-return-address should use.  */\n+enum aarch64_key_type {\n+  AARCH64_KEY_A,\n+  AARCH64_KEY_B\n+};\n+\n #endif"}, {"sha": "dabd047d7ba2c532238720d59ecd59f0f5ba822f", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -672,14 +672,6 @@ enum simd_immediate_check {\n   AARCH64_CHECK_MOV  = AARCH64_CHECK_ORR | AARCH64_CHECK_BIC\n };\n \n-/* The key type that -msign-return-address should use.  */\n-enum aarch64_key_type {\n-  AARCH64_KEY_A,\n-  AARCH64_KEY_B\n-};\n-\n-extern enum aarch64_key_type aarch64_ra_sign_key;\n-\n extern struct tune_params aarch64_tune_params;\n \n /* The available SVE predicate patterns, known in the ACLE as \"svpattern\".  */"}, {"sha": "5969d1f56c2b3f3e13e38bf9537a51d6379c9ca8", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 63, "deletions": 120, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -306,9 +306,6 @@ static bool aarch64_print_address_internal (FILE*, machine_mode, rtx,\n \t\t\t\t\t    aarch64_addr_query_type);\n static HOST_WIDE_INT aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val);\n \n-/* Major revision number of the ARM Architecture implemented by the target.  */\n-unsigned aarch64_architecture_version;\n-\n /* The processor for which instructions should be scheduled.  */\n enum aarch64_processor aarch64_tune = cortexa53;\n \n@@ -2677,7 +2674,6 @@ struct processor\n   enum aarch64_processor ident;\n   enum aarch64_processor sched_core;\n   enum aarch64_arch arch;\n-  unsigned architecture_version;\n   const uint64_t flags;\n   const struct tune_params *const tune;\n };\n@@ -2686,33 +2682,23 @@ struct processor\n static const struct processor all_architectures[] =\n {\n #define AARCH64_ARCH(NAME, CORE, ARCH_IDENT, ARCH_REV, FLAGS) \\\n-  {NAME, CORE, CORE, AARCH64_ARCH_##ARCH_IDENT, ARCH_REV, FLAGS, NULL},\n+  {NAME, CORE, CORE, AARCH64_ARCH_##ARCH_IDENT, FLAGS, NULL},\n #include \"aarch64-arches.def\"\n-  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, 0, NULL}\n+  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n /* Processor cores implementing AArch64.  */\n static const struct processor all_cores[] =\n {\n #define AARCH64_CORE(NAME, IDENT, SCHED, ARCH, FLAGS, COSTS, IMP, PART, VARIANT) \\\n   {NAME, IDENT, SCHED, AARCH64_ARCH_##ARCH,\t\t\t\t\\\n-  all_architectures[AARCH64_ARCH_##ARCH].architecture_version,\t\\\n   FLAGS, &COSTS##_tunings},\n #include \"aarch64-cores.def\"\n-  {\"generic\", generic, cortexa53, AARCH64_ARCH_8A, 8,\n+  {\"generic\", generic, cortexa53, AARCH64_ARCH_8A,\n     AARCH64_FL_FOR_ARCH8, &generic_tunings},\n-  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, 0, NULL}\n+  {NULL, aarch64_none, aarch64_none, aarch64_no_arch, 0, NULL}\n };\n \n-\n-/* Target specification.  These are populated by the -march, -mtune, -mcpu\n-   handling code or by target attributes.  */\n-static const struct processor *selected_arch;\n-static const struct processor *selected_cpu;\n-static const struct processor *selected_tune;\n-\n-enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A;\n-\n /* The current tuning set.  */\n struct tune_params aarch64_tune_params = generic_tunings;\n \n@@ -10353,8 +10339,8 @@ aarch64_case_values_threshold (void)\n   /* Use the specified limit for the number of cases before using jump\n      tables at higher optimization levels.  */\n   if (optimize > 2\n-      && selected_cpu->tune->max_case_values != 0)\n-    return selected_cpu->tune->max_case_values;\n+      && aarch64_tune_params.max_case_values != 0)\n+    return aarch64_tune_params.max_case_values;\n   else\n     return optimize_size ? 8 : 11;\n }\n@@ -17425,6 +17411,26 @@ initialize_aarch64_tls_size (struct gcc_options *opts)\n   return;\n }\n \n+/* Return the CPU corresponding to the enum CPU.  */\n+\n+static const struct processor *\n+aarch64_get_tune_cpu (enum aarch64_processor cpu)\n+{\n+  gcc_assert (cpu != aarch64_none);\n+\n+  return &all_cores[cpu];\n+}\n+\n+/* Return the architecture corresponding to the enum ARCH.  */\n+\n+static const struct processor *\n+aarch64_get_arch (enum aarch64_arch arch)\n+{\n+  gcc_assert (arch != aarch64_no_arch);\n+\n+  return &all_architectures[arch];\n+}\n+\n /* Parse STRING looking for options in the format:\n      string\t:: option:string\n      option\t:: name=substring\n@@ -17535,18 +17541,18 @@ aarch64_override_options_after_change_1 (struct gcc_options *opts)\n void\n aarch64_override_options_internal (struct gcc_options *opts)\n {\n-  aarch64_tune_flags = selected_tune->flags;\n-  aarch64_tune = selected_tune->sched_core;\n+  const struct processor *tune = aarch64_get_tune_cpu (opts->x_selected_tune);\n+  aarch64_tune_flags = tune->flags;\n+  aarch64_tune = tune->sched_core;\n   /* Make a copy of the tuning parameters attached to the core, which\n      we may later overwrite.  */\n-  aarch64_tune_params = *(selected_tune->tune);\n-  aarch64_architecture_version = selected_arch->architecture_version;\n-  if (selected_tune->tune == &generic_tunings)\n+  aarch64_tune_params = *(tune->tune);\n+  if (tune->tune == &generic_tunings)\n     aarch64_adjust_generic_arch_tuning (aarch64_tune_params);\n \n   if (opts->x_aarch64_override_tune_string)\n     aarch64_parse_override_string (opts->x_aarch64_override_tune_string,\n-\t\t\t\t  &aarch64_tune_params);\n+\t\t\t\t   &aarch64_tune_params);\n \n   /* This target defaults to strict volatile bitfields.  */\n   if (opts->x_flag_strict_volatile_bitfields < 0 && abi_version_at_least (2))\n@@ -17707,13 +17713,6 @@ aarch64_override_options_internal (struct gcc_options *opts)\n       && opts->x_optimize >= aarch64_tune_params.prefetch->default_opt_level)\n     opts->x_flag_prefetch_loop_arrays = 1;\n \n-  if (opts->x_aarch64_arch_string == NULL)\n-    opts->x_aarch64_arch_string = selected_arch->name;\n-  if (opts->x_aarch64_cpu_string == NULL)\n-    opts->x_aarch64_cpu_string = selected_cpu->name;\n-  if (opts->x_aarch64_tune_string == NULL)\n-    opts->x_aarch64_tune_string = selected_tune->name;\n-\n   aarch64_override_options_after_change_1 (opts);\n }\n \n@@ -18065,26 +18064,6 @@ aarch64_validate_mtune (const char *str, const struct processor **res)\n   return false;\n }\n \n-/* Return the CPU corresponding to the enum CPU.  */\n-\n-static const struct processor *\n-aarch64_get_tune_cpu (enum aarch64_processor cpu)\n-{\n-  gcc_assert (cpu != aarch64_none);\n-\n-  return &all_cores[cpu];\n-}\n-\n-/* Return the architecture corresponding to the enum ARCH.  */\n-\n-static const struct processor *\n-aarch64_get_arch (enum aarch64_arch arch)\n-{\n-  gcc_assert (arch != aarch64_no_arch);\n-\n-  return &all_architectures[arch];\n-}\n-\n /* Return the VG value associated with -msve-vector-bits= value VALUE.  */\n \n static poly_uint16\n@@ -18120,9 +18099,9 @@ aarch64_override_options (void)\n   uint64_t arch_isa = 0;\n   aarch64_isa_flags = 0;\n \n-  selected_cpu = NULL;\n-  selected_arch = NULL;\n-  selected_tune = NULL;\n+  const struct processor *cpu = NULL;\n+  const struct processor *arch = NULL;\n+  const struct processor *tune = NULL;\n \n   if (aarch64_harden_sls_string)\n     aarch64_validate_sls_mitigation (aarch64_harden_sls_string);\n@@ -18134,56 +18113,52 @@ aarch64_override_options (void)\n      If either of -march or -mtune is given, they override their\n      respective component of -mcpu.  */\n   if (aarch64_cpu_string)\n-    aarch64_validate_mcpu (aarch64_cpu_string, &selected_cpu, &cpu_isa);\n+    aarch64_validate_mcpu (aarch64_cpu_string, &cpu, &cpu_isa);\n \n   if (aarch64_arch_string)\n-    aarch64_validate_march (aarch64_arch_string, &selected_arch, &arch_isa);\n+    aarch64_validate_march (aarch64_arch_string, &arch, &arch_isa);\n \n   if (aarch64_tune_string)\n-    aarch64_validate_mtune (aarch64_tune_string, &selected_tune);\n+    aarch64_validate_mtune (aarch64_tune_string, &tune);\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n \n-  if (selected_cpu && selected_arch)\n+  if (cpu && arch)\n     {\n       /* If both -mcpu and -march are specified, warn if they are not\n \t architecturally compatible and prefer the -march ISA flags.  */\n-      if (selected_arch->arch != selected_cpu->arch)\n+      if (arch->arch != cpu->arch)\n \t{\n \t  warning (0, \"switch %<-mcpu=%s%> conflicts with %<-march=%s%> switch\",\n \t\t       aarch64_cpu_string,\n \t\t       aarch64_arch_string);\n \t}\n \n+      selected_arch = arch->arch;\n       aarch64_isa_flags = arch_isa;\n     }\n-  else if (selected_cpu)\n+  else if (cpu)\n     {\n-      selected_arch = &all_architectures[selected_cpu->arch];\n+      selected_arch = cpu->arch;\n       aarch64_isa_flags = cpu_isa;\n     }\n-  else if (selected_arch)\n+  else if (arch)\n     {\n-      selected_cpu = &all_cores[selected_arch->ident];\n+      cpu = &all_cores[arch->ident];\n+      selected_arch = arch->arch;\n       aarch64_isa_flags = arch_isa;\n     }\n   else\n     {\n       /* No -mcpu or -march specified, so use the default CPU.  */\n-      selected_cpu = &all_cores[TARGET_CPU_DEFAULT];\n-      selected_arch = &all_architectures[selected_cpu->arch];\n-      aarch64_isa_flags = selected_cpu->flags;\n+      cpu = &all_cores[TARGET_CPU_DEFAULT];\n+      selected_arch = cpu->arch;\n+      aarch64_isa_flags = cpu->flags;\n     }\n \n-  explicit_arch = selected_arch->arch;\n-  if (!selected_tune)\n-    selected_tune = selected_cpu;\n-  explicit_tune_core = selected_tune->ident;\n-\n-  gcc_assert (explicit_tune_core != aarch64_none);\n-  gcc_assert (explicit_arch != aarch64_no_arch);\n+  selected_tune = tune ? tune->ident : cpu->ident;\n \n   if (aarch64_enable_bti == 2)\n     {\n@@ -18302,38 +18277,14 @@ initialize_aarch64_code_model (struct gcc_options *opts)\n     }\n }\n \n-/* Implement TARGET_OPTION_SAVE.  */\n-\n-static void\n-aarch64_option_save (struct cl_target_option *ptr, struct gcc_options *opts,\n-\t\t     struct gcc_options */* opts_set */)\n-{\n-  ptr->x_aarch64_override_tune_string = opts->x_aarch64_override_tune_string;\n-  ptr->x_aarch64_branch_protection_string\n-    = opts->x_aarch64_branch_protection_string;\n-}\n-\n /* Implements TARGET_OPTION_RESTORE.  Restore the backend codegen decisions\n    using the information saved in PTR.  */\n \n static void\n aarch64_option_restore (struct gcc_options *opts,\n-\t\t\tstruct gcc_options */* opts_set */,\n-\t\t\tstruct cl_target_option *ptr)\n+\t\t\tstruct gcc_options * /* opts_set */,\n+\t\t\tstruct cl_target_option * /* ptr */)\n {\n-  opts->x_explicit_arch = ptr->x_explicit_arch;\n-  selected_arch = aarch64_get_arch (ptr->x_explicit_arch);\n-  opts->x_explicit_tune_core = ptr->x_explicit_tune_core;\n-  selected_tune = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n-  opts->x_aarch64_override_tune_string = ptr->x_aarch64_override_tune_string;\n-  opts->x_aarch64_branch_protection_string\n-    = ptr->x_aarch64_branch_protection_string;\n-  if (opts->x_aarch64_branch_protection_string)\n-    {\n-      aarch64_parse_branch_protection (opts->x_aarch64_branch_protection_string,\n-\t\t\t\t\tNULL);\n-    }\n-\n   aarch64_override_options_internal (opts);\n }\n \n@@ -18343,11 +18294,11 @@ static void\n aarch64_option_print (FILE *file, int indent, struct cl_target_option *ptr)\n {\n   const struct processor *cpu\n-    = aarch64_get_tune_cpu (ptr->x_explicit_tune_core);\n-  uint64_t isa_flags = ptr->x_aarch64_isa_flags;\n-  const struct processor *arch = aarch64_get_arch (ptr->x_explicit_arch);\n+    = aarch64_get_tune_cpu (ptr->x_selected_tune);\n+  const struct processor *arch = aarch64_get_arch (ptr->x_selected_arch);\n   std::string extension\n-    = aarch64_get_extension_string_for_isa_flags (isa_flags, arch->flags);\n+    = aarch64_get_extension_string_for_isa_flags (ptr->x_aarch64_isa_flags,\n+\t\t\t\t\t\t  arch->flags);\n \n   fprintf (file, \"%*sselected tune = %s\\n\", indent, \"\", cpu->name);\n   fprintf (file, \"%*sselected arch = %s%s\\n\", indent, \"\",\n@@ -18460,8 +18411,7 @@ aarch64_handle_attr_arch (const char *str)\n   if (parse_res == AARCH64_PARSE_OK)\n     {\n       gcc_assert (tmp_arch);\n-      selected_arch = tmp_arch;\n-      explicit_arch = selected_arch->arch;\n+      selected_arch = tmp_arch->arch;\n       return true;\n     }\n \n@@ -18499,11 +18449,8 @@ aarch64_handle_attr_cpu (const char *str)\n   if (parse_res == AARCH64_PARSE_OK)\n     {\n       gcc_assert (tmp_cpu);\n-      selected_tune = tmp_cpu;\n-      explicit_tune_core = selected_tune->ident;\n-\n-      selected_arch = &all_architectures[tmp_cpu->arch];\n-      explicit_arch = selected_arch->arch;\n+      selected_tune = tmp_cpu->ident;\n+      selected_arch = tmp_cpu->arch;\n       return true;\n     }\n \n@@ -18571,8 +18518,7 @@ aarch64_handle_attr_tune (const char *str)\n   if (parse_res == AARCH64_PARSE_OK)\n     {\n       gcc_assert (tmp_tune);\n-      selected_tune = tmp_tune;\n-      explicit_tune_core = selected_tune->ident;\n+      selected_tune = tmp_tune->ident;\n       return true;\n     }\n \n@@ -22492,7 +22438,7 @@ aarch64_declare_function_name (FILE *stream, const char* name,\n   gcc_assert (targ_options);\n \n   const struct processor *this_arch\n-    = aarch64_get_arch (targ_options->x_explicit_arch);\n+    = aarch64_get_arch (targ_options->x_selected_arch);\n \n   uint64_t isa_flags = targ_options->x_aarch64_isa_flags;\n   std::string extension\n@@ -22511,7 +22457,7 @@ aarch64_declare_function_name (FILE *stream, const char* name,\n      useful to readers of the generated asm.  Do it only when it changes\n      from function to function and verbose assembly is requested.  */\n   const struct processor *this_tune\n-    = aarch64_get_tune_cpu (targ_options->x_explicit_tune_core);\n+    = aarch64_get_tune_cpu (targ_options->x_selected_tune);\n \n   if (flag_debug_asm && aarch64_last_printed_tune_string != this_tune->name)\n     {\n@@ -22597,7 +22543,7 @@ aarch64_start_file (void)\n     = TREE_TARGET_OPTION (target_option_default_node);\n \n   const struct processor *default_arch\n-    = aarch64_get_arch (default_options->x_explicit_arch);\n+    = aarch64_get_arch (default_options->x_selected_arch);\n   uint64_t default_isa_flags = default_options->x_aarch64_isa_flags;\n   std::string extension\n     = aarch64_get_extension_string_for_isa_flags (default_isa_flags,\n@@ -27477,9 +27423,6 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_OFFLOAD_OPTIONS\n #define TARGET_OFFLOAD_OPTIONS aarch64_offload_options\n \n-#undef TARGET_OPTION_SAVE\n-#define TARGET_OPTION_SAVE aarch64_option_save\n-\n #undef TARGET_OPTION_RESTORE\n #define TARGET_OPTION_RESTORE aarch64_option_restore\n "}, {"sha": "80cfe4b740798072ed2a3d08089ff889943f916a", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -148,9 +148,6 @@\n \n #define PCC_BITFIELD_TYPE_MATTERS\t1\n \n-/* Major revision number of the ARM Architecture implemented by the target.  */\n-extern unsigned aarch64_architecture_version;\n-\n /* Instruction tuning/selection flags.  */\n \n /* Bit values used to identify processor capabilities.  */"}, {"sha": "d8e1f42a3a683c6d2cb7d930a41ec2e0415e2bf1", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae54c1b09963779c5c3914782324ff48af32e2f1/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=ae54c1b09963779c5c3914782324ff48af32e2f1", "patch": "@@ -22,20 +22,20 @@ HeaderInclude\n config/aarch64/aarch64-opts.h\n \n TargetVariable\n-enum aarch64_processor explicit_tune_core = aarch64_none\n+enum aarch64_processor selected_tune = aarch64_none\n \n TargetVariable\n-enum aarch64_arch explicit_arch = aarch64_no_arch\n-\n-TargetSave\n-const char *x_aarch64_override_tune_string\n+enum aarch64_arch selected_arch = aarch64_no_arch\n \n TargetVariable\n uint64_t aarch64_isa_flags = 0\n \n TargetVariable\n unsigned aarch64_enable_bti = 2\n \n+TargetVariable\n+enum aarch64_key_type aarch64_ra_sign_key = AARCH64_KEY_A\n+\n ; The TLS dialect names to use with -mtls-dialect.\n \n Enum\n@@ -139,7 +139,7 @@ Target RejectNegative Joined Enum(aarch64_abi) Var(aarch64_abi) Init(AARCH64_ABI\n Generate code that conforms to the specified ABI.\n \n moverride=\n-Target RejectNegative ToLower Joined Var(aarch64_override_tune_string)\n+Target RejectNegative ToLower Joined Var(aarch64_override_tune_string) Save\n -moverride=<string>\tPower users only! Override CPU optimization parameters.\n \n Enum"}]}