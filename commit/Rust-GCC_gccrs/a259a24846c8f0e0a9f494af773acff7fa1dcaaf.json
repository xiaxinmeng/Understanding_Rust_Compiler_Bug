{"sha": "a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1OWEyNDg0NmM4ZjBlMGE5ZjQ5NGFmNzczYWNmZjdmYTFkY2FhZg==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-06-03T22:29:12Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "1999-06-03T22:29:12Z"}, "message": "[multiple changes]\n\n1999-06-02  Warren Levy  <warrenl@cygnus.com>\n\t* java/net/URL.java (URL(URL,String)): Initialize port to -1.\n\tIgnore context if spec is an absolute URL.  Fix braindead\n\tstring comparison.\n\t(hashCode): Use JDK 1.2 style algorithm.\n\t* java/net/URLStreamHandler.java (parseURL): Reimplement to handle\n\tcontext URL properly.\n1999-05-30  Anthony Green  <green@cygnus.com>\n\t* java/net/URLStreamHandler.java (parseURL): Parse relative URLs\n\tcorrectly.  Clean up \"/../\" and \"/./\" path fragments.\n\nFrom-SVN: r27334", "tree": {"sha": "6cc7b3c8a9f79ac770d95f7a313ebfed94ca7de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc7b3c8a9f79ac770d95f7a313ebfed94ca7de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/comments", "author": null, "committer": null, "parents": [{"sha": "4d070fd3cd90ca25dd13e3dc5f2777d478930631", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d070fd3cd90ca25dd13e3dc5f2777d478930631", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d070fd3cd90ca25dd13e3dc5f2777d478930631"}], "stats": {"total": 145, "additions": 114, "deletions": 31}, "files": [{"sha": "bd9afc2e2e6fa2b521313e2258f64d5bd592383a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "patch": "@@ -1,3 +1,17 @@\n+1999-06-02  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/net/URL.java (URL(URL,String)): Initialize port to -1.\n+\tIgnore context if spec is an absolute URL.  Fix braindead\n+\tstring comparison.\n+\t(hashCode): Use JDK 1.2 style algorithm.\n+\t* java/net/URLStreamHandler.java (parseURL): Reimplement to handle\n+\tcontext URL properly.\n+\n+1999-05-30  Anthony Green  <green@cygnus.com>\n+\n+\t* java/net/URLStreamHandler.java (parseURL): Parse relative URLs\n+\tcorrectly.  Clean up \"/../\" and \"/./\" path fragments.\n+\n 1999-05-28  Warren Levy  <warrenl@cygnus.com>\n \n \t* java/net/DatagramSocket.java (laddr): Removed."}, {"sha": "b6dc13d8db44a6889043e2700caf25aa6f240dc5", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "patch": "@@ -29,7 +29,7 @@ public final class URL implements Serializable\n {\n   private String protocol;\n   private String host;\n-  private int port;\n+  private int port = -1;\t// Initialize for constructor using context.\n   private String file;\n   private String ref;\n   private URLStreamHandler handler;\n@@ -117,14 +117,22 @@ public URL(URL context, String spec, URLStreamHandler handler)\n      * to the context's file.  The optional anchor is not inherited. \n      */\n \n+    // If this is an absolute URL, then ignore context completely.\n+    // An absolute URL must have chars prior to \"://\" but cannot have a colon\n+    // right after the \"://\".  The second colon is for an optional port value\n+    // and implies that the host from the context is used if available.\n     int colon;\n+    if ((colon = spec.indexOf(\"://\", 1)) > 0 &&\n+\t! spec.regionMatches(colon, \"://:\", 0, 4))\n+      context = null;\n+\n     int slash;\n     if ((colon = spec.indexOf(':')) > 0 &&\n \t(colon < (slash = spec.indexOf('/')) || slash < 0))\n       {\n \t// Protocol specified in spec string.\n \tprotocol = spec.substring(0, colon);\n-\tif (context != null && context.protocol == protocol)\n+\tif (context != null && context.protocol.equals(protocol))\n \t  {\n \t    // The 1.2 doc specifically says these are copied to the new URL.\n \t    host = context.host;\n@@ -222,8 +230,20 @@ public int hashCode()\n   {\n     // JCL book says this is computed using (only) the hashcodes of the \n     // protocol, host and file fields.  Empirical evidence indicates this\n-    // is probably XOR.\n-    return (protocol.hashCode() ^ host.hashCode() ^ file.hashCode());\n+    // is probably XOR in JDK 1.1.  In JDK 1.2 it seems to be a sum including\n+    // the port.\n+    //\n+    // JDK 1.2 online doc infers that host could be null because it\n+    // explicitly states that file cannot be null but is silent on host.\n+    // A simple example with protocol \"http\" (hashcode 3213448), host null,\n+    // file \"/\" (hashcode 47) produced a hashcode (3213494) which appeared\n+    // to be the sum of the two hashcodes plus the port.  Another example\n+    // using \"/index.html\" for file bore this out; as well as \"#\" for file\n+    // (which was reduced to \"\" with a hashcode of zero).  A \"\" host also\n+    // causes the port number and the two hashcodes to be summed.\n+\n+    return (protocol.hashCode() + ((host == null) ? 0 : host.hashCode()) +\n+\tport + file.hashCode());\n   }\n \n   public URLConnection openConnection() throws IOException"}, {"sha": "ba2114c8068cc8d28a0781da710211a5889d9412", "filename": "libjava/java/net/URLStreamHandler.java", "status": "modified", "additions": 76, "deletions": 27, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a259a24846c8f0e0a9f494af773acff7fa1dcaaf/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=a259a24846c8f0e0a9f494af773acff7fa1dcaaf", "patch": "@@ -28,29 +28,35 @@ protected abstract URLConnection openConnection(URL u)\n \n   protected void parseURL(URL u, String spec, int start, int limit)\n   {\n-    String tmpStr;\n-    String host = \"\";\t// Initialize to null string.\n-    String file;\n-    int port = -1;\n-    int colon;\n-\n+    String host = u.getHost();\n+    int port = u.getPort();\n+    String file = u.getFile();\n+    \n     /* TBD: The JDK 1.2 doc specifically says that limit is the position\n      * to stop parsing at and that it will be either the end of the string\n      * or the position of '#'; thus the doc infers that this method does\n      * not set the ref.\n      */\n-    tmpStr = spec.substring(start, limit);\n-    int hostEnd = 0;\n-    if (tmpStr.startsWith(\"//\"))\n+    if (spec.regionMatches (start, \"//\", 0, 2))\n       {\n-\tint slash = tmpStr.indexOf('/', 2);\n-\thostEnd = tmpStr.length();\n-\tif (slash >= 0)\n-\t  hostEnd = slash;\n+\tint hostEnd;\n+\tint colon;\n \n-\thost = tmpStr.substring(2, hostEnd);\n-\n-\t// Look for optional port number.\n+\tstart += 2;\n+\tint slash = spec.indexOf('/', start);\n+\tif (slash >= 0) \n+\t  hostEnd = slash;\n+        else\n+\t  hostEnd = limit;\n+\n+\thost = spec.substring (start, hostEnd);\n+\t\n+\t// Look for optional port number.  It is valid for the non-port\n+\t// part of the host name to be null (e.g. a URL \"http://:80\").\n+\t// TBD: JDK 1.2 in this case sets host to null rather than \"\";\n+\t// this is undocumented and likely an unintended side effect in 1.2\n+\t// so we'll be simple here and stick with \"\". Note that\n+\t// \"http://\" or \"http:///\" produce a \"\" host in JDK 1.2.\n \tif ((colon = host.indexOf(':')) >= 0)\n \t  {\n \t    try\n@@ -59,17 +65,55 @@ protected void parseURL(URL u, String spec, int start, int limit)\n \t      }\n \t    catch (NumberFormatException e)\n \t      {\n-\t\t; // Ignore invalid port values; port is already set to -1.\n+\t\t; // Ignore invalid port values; port is already set to u's\n+\t\t  // port.\n \t      }\n \t    host = host.substring(0, colon);\n \t  }\n+\tfile = null;\n+\tstart = hostEnd;\n+      } \n+    else if (host == null) \n+      host = \"\";\n+\n+    if (start < limit && spec.charAt(start) == '/') \n+      {\n+\t// This is an absolute path name; ignore any file context.\n+\tfile = spec.substring(start, limit);\n+      } \n+    else if (file == null || file.length() <= 0)\n+      {\n+\t// No file context available; just spec for file.\n+\tfile = \"/\" + spec.substring(start, limit);\n+      }\n+    else if (start < limit)\n+      {\n+\t// Context is available, but only override it if there is a new file.\n+        // FIXME: unsure to what extent `/` and File.separatorChar\n+\t//        can mix in URLs.  Ignore File.separatorChar for now.\n+\tfile = file.substring(0, file.lastIndexOf('/'))\n+\t\t+ \"/\" + spec.substring(start, limit);\n       }\n \n-    if (hostEnd < tmpStr.length())\n-      file = ((tmpStr.startsWith(\"/\")) ? \"\" : \"/\") + tmpStr.substring(hostEnd);\n-    else\n-      file = \"/\";\n+    int index;\n \n+    // Replace \"/./\" with \"/\".  This probably isn't very efficient in\n+    // the general case, but it's probably not bad most of the time.\n+    while ((index = file.indexOf(\"/./\")) >= 0)\n+      file = file.substring(0, index) + file.substring(index + 2);\n+\n+    // Process \"/../\" correctly.  This probably isn't very efficient in\n+    // the general case, but it's probably not bad most of the time.\n+    while ((index = file.indexOf(\"/../\")) >= 0)\n+      {\n+\t// Strip of the previous directory - if it exists.\n+\tint previous = file.lastIndexOf('/', index - 1);\n+\tif (previous >= 0)\n+\t  file = file.substring(0, previous) + file.substring(index + 3);\n+\telse\n+\t  file = file.substring(index + 3);\n+      }\n+    \n     u.set(u.getProtocol(), host, port, file, u.getRef());\n   }\n   \n@@ -90,12 +134,17 @@ protected String toExternalForm(URL u)\n     file = u.getFile();\n     ref = u.getRef();\n \n-    if (! host.equals(\"\"))\n-      {\n-        resStr = resStr + \"//\" + host;\n-\tif (port >= 0)\n-\t  resStr = resStr + \":\" + port;\n-      }\n+    // JDK 1.2 online doc infers that host could be null because it\n+    // explicitly states that file cannot be null, but is silent on host.\n+    //\n+    // Note that this produces different results from JDK 1.2 as JDK 1.2\n+    // ignores a non-default port if host is null or \"\".  That is inconsistent\n+    // with the spec since the result of this method is spec'ed so it can be\n+    // used to construct a new URL that is equivalent to the original.\n+    if (host == null)\n+      host = \"\";\n+    if (port >= 0 || ! (host.length() == 0))\n+      resStr = resStr + \"//\" + host + (port < 0 ? \"\" : \":\" + port);\n \n     resStr = resStr + file;\n "}]}