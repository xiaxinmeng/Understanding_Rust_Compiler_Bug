{"sha": "ba1536dac780f3f92c5eab999fda6931f6247fc1", "node_id": "C_kwDOANBUbNoAKGJhMTUzNmRhYzc4MGYzZjkyYzVlYWI5OTlmZGE2OTMxZjYyNDdmYzE", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wilco.dijkstra@arm.com", "date": "2022-12-05T10:49:25Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco.dijkstra@arm.com", "date": "2022-12-06T20:27:25Z"}, "message": "AArch64: Cleanup move immediate code\n\nSimplify, refactor and improve various move immediate functions.\nAllow 32-bit MOVN/I as a valid 64-bit immediate which removes special\ncases in aarch64_internal_mov_immediate.  Add new constraint so the movdi\npattern only needs a single alternative for move immediate.\n\ngcc/\n\t* config/aarch64/aarch64.cc (aarch64_bitmask_imm): Use unsigned type.\n\t(aarch64_is_mov_xn_imm): New function.\n\t(aarch64_move_imm): Refactor, assert mode is SImode or DImode.\n\t(aarch64_internal_mov_immediate): Assert mode is SImode or DImode.\n\tSimplify special cases.\n\t(aarch64_uimm12_shift): Simplify code.\n\t(aarch64_clamp_to_uimm12_shift): Likewise.\n\t(aarch64_movw_imm): Rename to aarch64_is_movz.\n\t(aarch64_float_const_rtx_p): Pass either SImode or DImode to\n\taarch64_internal_mov_immediate.\n\t(aarch64_rtx_costs): Likewise.\n\t* config/aarch64/aarch64.md (movdi_aarch64): Merge 'N' and 'M'\n\tconstraints into single 'O'.\n\t(mov<mode>_aarch64): Likewise.\n\t* config/aarch64/aarch64-protos.h (aarch64_move_imm): Use unsigned.\n\t(aarch64_bitmask_imm): Likewise.\n\t(aarch64_uimm12_shift): Likewise.\n\t(aarch64_is_mov_xn_imm): New prototype.\n\t* config/aarch64/constraints.md: Add 'O' for 32/64-bit immediates,\n\tlimit 'N' to 64-bit only moves.", "tree": {"sha": "fa2f3d8d88c30e204aeb396cd772d94efd71282e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa2f3d8d88c30e204aeb396cd772d94efd71282e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba1536dac780f3f92c5eab999fda6931f6247fc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba1536dac780f3f92c5eab999fda6931f6247fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba1536dac780f3f92c5eab999fda6931f6247fc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba1536dac780f3f92c5eab999fda6931f6247fc1/comments", "author": {"login": "Wilco1", "id": 58446312, "node_id": "MDQ6VXNlcjU4NDQ2MzEy", "avatar_url": "https://avatars.githubusercontent.com/u/58446312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Wilco1", "html_url": "https://github.com/Wilco1", "followers_url": "https://api.github.com/users/Wilco1/followers", "following_url": "https://api.github.com/users/Wilco1/following{/other_user}", "gists_url": "https://api.github.com/users/Wilco1/gists{/gist_id}", "starred_url": "https://api.github.com/users/Wilco1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Wilco1/subscriptions", "organizations_url": "https://api.github.com/users/Wilco1/orgs", "repos_url": "https://api.github.com/users/Wilco1/repos", "events_url": "https://api.github.com/users/Wilco1/events{/privacy}", "received_events_url": "https://api.github.com/users/Wilco1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Wilco1", "id": 58446312, "node_id": "MDQ6VXNlcjU4NDQ2MzEy", "avatar_url": "https://avatars.githubusercontent.com/u/58446312?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Wilco1", "html_url": "https://github.com/Wilco1", "followers_url": "https://api.github.com/users/Wilco1/followers", "following_url": "https://api.github.com/users/Wilco1/following{/other_user}", "gists_url": "https://api.github.com/users/Wilco1/gists{/gist_id}", "starred_url": "https://api.github.com/users/Wilco1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Wilco1/subscriptions", "organizations_url": "https://api.github.com/users/Wilco1/orgs", "repos_url": "https://api.github.com/users/Wilco1/repos", "events_url": "https://api.github.com/users/Wilco1/events{/privacy}", "received_events_url": "https://api.github.com/users/Wilco1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "710c9676520dfd38b4bfdcc937ce026ed89921d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/710c9676520dfd38b4bfdcc937ce026ed89921d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/710c9676520dfd38b4bfdcc937ce026ed89921d6"}], "stats": {"total": 187, "additions": 85, "deletions": 102}, "files": [{"sha": "f3d847e3e8882c460da552eec0e5a2c38c0f097e", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ba1536dac780f3f92c5eab999fda6931f6247fc1", "patch": "@@ -756,7 +756,7 @@ void aarch64_post_cfi_startproc (void);\n poly_int64 aarch64_initial_elimination_offset (unsigned, unsigned);\n int aarch64_get_condition_code (rtx);\n bool aarch64_address_valid_for_prefetch_p (rtx, bool);\n-bool aarch64_bitmask_imm (HOST_WIDE_INT val, machine_mode);\n+bool aarch64_bitmask_imm (unsigned HOST_WIDE_INT val, machine_mode);\n unsigned HOST_WIDE_INT aarch64_and_split_imm1 (HOST_WIDE_INT val_in);\n unsigned HOST_WIDE_INT aarch64_and_split_imm2 (HOST_WIDE_INT val_in);\n bool aarch64_and_bitmask_imm (unsigned HOST_WIDE_INT val_in, machine_mode mode);\n@@ -793,7 +793,7 @@ bool aarch64_masks_and_shift_for_bfi_p (scalar_int_mode, unsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT,\n \t\t\t\t\tunsigned HOST_WIDE_INT);\n bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);\n-bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n+bool aarch64_move_imm (unsigned HOST_WIDE_INT, machine_mode);\n machine_mode aarch64_sve_int_mode (machine_mode);\n opt_machine_mode aarch64_sve_pred_mode (unsigned int);\n machine_mode aarch64_sve_pred_mode (machine_mode);\n@@ -843,8 +843,9 @@ bool aarch64_sve_float_arith_immediate_p (rtx, bool);\n bool aarch64_sve_float_mul_immediate_p (rtx);\n bool aarch64_split_dimode_const_store (rtx, rtx);\n bool aarch64_symbolic_address_p (rtx);\n-bool aarch64_uimm12_shift (HOST_WIDE_INT);\n+bool aarch64_uimm12_shift (unsigned HOST_WIDE_INT);\n int aarch64_movk_shift (const wide_int_ref &, const wide_int_ref &);\n+bool aarch64_is_mov_xn_imm (unsigned HOST_WIDE_INT);\n bool aarch64_use_return_insn_p (void);\n const char *aarch64_output_casesi (rtx *);\n "}, {"sha": "89bf0dff904b6b52b71841aec299541f01884f3d", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 68, "deletions": 90, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=ba1536dac780f3f92c5eab999fda6931f6247fc1", "patch": "@@ -5625,12 +5625,10 @@ aarch64_bitmask_imm (unsigned HOST_WIDE_INT val)\n \n /* Return true if VAL is a valid bitmask immediate for MODE.  */\n bool\n-aarch64_bitmask_imm (HOST_WIDE_INT val_in, machine_mode mode)\n+aarch64_bitmask_imm (unsigned HOST_WIDE_INT val, machine_mode mode)\n {\n   if (mode == DImode)\n-    return aarch64_bitmask_imm (val_in);\n-\n-  unsigned HOST_WIDE_INT val = val_in;\n+    return aarch64_bitmask_imm (val);\n \n   if (mode == SImode)\n     return aarch64_bitmask_imm ((val & 0xffffffff) | (val << 32));\n@@ -5669,51 +5667,55 @@ aarch64_check_bitmask (unsigned HOST_WIDE_INT val,\n }\n \n \n-/* Return true if val is an immediate that can be loaded into a\n-   register by a MOVZ instruction.  */\n-static bool\n-aarch64_movw_imm (HOST_WIDE_INT val, scalar_int_mode mode)\n+/* Return true if VAL is a valid MOVZ immediate.  */\n+static inline bool\n+aarch64_is_movz (unsigned HOST_WIDE_INT val)\n {\n-  if (GET_MODE_SIZE (mode) > 4)\n-    {\n-      if ((val & (((HOST_WIDE_INT) 0xffff) << 32)) == val\n-\t   || (val & (((HOST_WIDE_INT) 0xffff) << 48)) == val)\n-\treturn 1;\n-    }\n-  else\n-    {\n-      /* Ignore sign extension.  */\n-      val &= (HOST_WIDE_INT) 0xffffffff;\n-    }\n-  return ((val & (((HOST_WIDE_INT) 0xffff) << 0)) == val\n-\t  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);\n+  return (val >> (ctz_hwi (val) & 48)) < 65536;\n }\n \n \n-/* Return true if VAL is an immediate that can be loaded into a\n-   register in a single instruction.  */\n+/* Return true if immediate VAL can be created by a 64-bit MOVI/MOVN/MOVZ.  */\n bool\n-aarch64_move_imm (HOST_WIDE_INT val, machine_mode mode)\n+aarch64_is_mov_xn_imm (unsigned HOST_WIDE_INT val)\n {\n-  scalar_int_mode int_mode;\n-  if (!is_a <scalar_int_mode> (mode, &int_mode))\n-    return false;\n+  return aarch64_is_movz (val) || aarch64_is_movz (~val)\n+    || aarch64_bitmask_imm (val);\n+}\n \n-  if (aarch64_movw_imm (val, int_mode) || aarch64_movw_imm (~val, int_mode))\n-    return 1;\n-  return aarch64_bitmask_imm (val, int_mode);\n+\n+/* Return true if VAL is an immediate that can be created by a single\n+   MOV instruction.  */\n+bool\n+aarch64_move_imm (unsigned HOST_WIDE_INT val, machine_mode mode)\n+{\n+  gcc_assert (mode == SImode || mode == DImode);\n+\n+  if (val < 65536)\n+    return true;\n+\n+  unsigned HOST_WIDE_INT mask =\n+    (val >> 32) == 0 || mode == SImode ? 0xffffffff : HOST_WIDE_INT_M1U;\n+\n+  if (aarch64_is_movz (val & mask) || aarch64_is_movz (~val & mask))\n+    return true;\n+\n+  val = (val & mask) | ((val << 32) & ~mask);\n+  return aarch64_bitmask_imm (val);\n }\n \n \n static int\n aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n-\t\t\t\tscalar_int_mode mode)\n+\t\t\t\tmachine_mode mode)\n {\n   int i;\n   unsigned HOST_WIDE_INT val, val2, mask;\n   int one_match, zero_match;\n   int num_insns;\n \n+  gcc_assert (mode == SImode || mode == DImode);\n+\n   val = INTVAL (imm);\n \n   if (aarch64_move_imm (val, mode))\n@@ -5723,31 +5725,6 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n       return 1;\n     }\n \n-  /* Check to see if the low 32 bits are either 0xffffXXXX or 0xXXXXffff\n-     (with XXXX non-zero). In that case check to see if the move can be done in\n-     a smaller mode.  */\n-  val2 = val & 0xffffffff;\n-  if (mode == DImode\n-      && aarch64_move_imm (val2, SImode)\n-      && (((val >> 32) & 0xffff) == 0 || (val >> 48) == 0))\n-    {\n-      if (generate)\n-\temit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n-\n-      /* Check if we have to emit a second instruction by checking to see\n-\t if any of the upper 32 bits of the original DI mode value is set.  */\n-      if (val == val2)\n-\treturn 1;\n-\n-      i = (val >> 48) ? 48 : 32;\n-\n-      if (generate)\n-\t emit_insn (gen_insv_immdi (dest, GEN_INT (i),\n-\t\t\t\t    GEN_INT ((val >> i) & 0xffff)));\n-\n-      return 2;\n-    }\n-\n   if ((val >> 32) == 0 || mode == SImode)\n     {\n       if (generate)\n@@ -5771,24 +5748,31 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n   one_match = ((~val & mask) == 0) + ((~val & (mask << 16)) == 0) +\n     ((~val & (mask << 32)) == 0) + ((~val & (mask << 48)) == 0);\n \n+  /* Try a bitmask immediate and a movk to generate the immediate\n+     in 2 instructions.  */\n+\n   if (zero_match < 2 && one_match < 2)\n     {\n-      /* Try emitting a bitmask immediate with a movk replacing 16 bits.\n-\t For a 64-bit bitmask try whether changing 16 bits to all ones or\n-\t zeroes creates a valid bitmask.  To check any repeated bitmask,\n-\t try using 16 bits from the other 32-bit half of val.  */\n-\n       for (i = 0; i < 64; i += 16)\n-\tif (aarch64_check_bitmask (val, val2, mask << i))\n-\t  {\n-\t    if (generate)\n-\t      {\n-\t\temit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n-\t\temit_insn (gen_insv_immdi (dest, GEN_INT (i),\n-\t\t\t\t\t   GEN_INT ((val >> i) & 0xffff)));\n-\t      }\n-\t    return 2;\n-\t  }\n+\t{\n+\t  if (aarch64_check_bitmask (val, val2, mask << i))\n+\t    break;\n+\n+\t  val2 = val & ~(mask << i);\n+\t  if ((val2 >> 32) == 0 && aarch64_move_imm (val2, DImode))\n+\t    break;\n+\t}\n+\n+      if (i != 64)\n+\t{\n+\t  if (generate)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n+\t      emit_insn (gen_insv_immdi (dest, GEN_INT (i),\n+\t\t\t\t\t GEN_INT ((val >> i) & 0xffff)));\n+\t    }\n+\t  return 2;\n+\t}\n     }\n \n   /* Try a bitmask plus 2 movk to generate the immediate in 3 instructions.  */\n@@ -5857,26 +5841,24 @@ aarch64_mov128_immediate (rtx imm)\n /* Return true if val can be encoded as a 12-bit unsigned immediate with\n    a left shift of 0 or 12 bits.  */\n bool\n-aarch64_uimm12_shift (HOST_WIDE_INT val)\n+aarch64_uimm12_shift (unsigned HOST_WIDE_INT val)\n {\n-  return ((val & (((HOST_WIDE_INT) 0xfff) << 0)) == val\n-\t  || (val & (((HOST_WIDE_INT) 0xfff) << 12)) == val\n-\t  );\n+  return val < 4096 || (val & 0xfff000) == val;\n }\n \n /* Returns the nearest value to VAL that will fit as a 12-bit unsigned immediate\n    that can be created with a left shift of 0 or 12.  */\n static HOST_WIDE_INT\n-aarch64_clamp_to_uimm12_shift (HOST_WIDE_INT val)\n+aarch64_clamp_to_uimm12_shift (unsigned HOST_WIDE_INT val)\n {\n   /* Check to see if the value fits in 24 bits, as that is the maximum we can\n      handle correctly.  */\n-  gcc_assert ((val & 0xffffff) == val);\n+  gcc_assert (val < 0x1000000);\n \n-  if (((val & 0xfff) << 0) == val)\n+  if (val < 4096)\n     return val;\n \n-  return val & (0xfff << 12);\n+  return val & 0xfff000;\n }\n \n \n@@ -7024,8 +7006,7 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n       return;\n     }\n \n-  aarch64_internal_mov_immediate (dest, imm, true,\n-\t\t\t\t  as_a <scalar_int_mode> (mode));\n+  aarch64_internal_mov_immediate (dest, imm, true, mode);\n }\n \n /* Return the MEM rtx that provides the canary value that should be used\n@@ -11197,9 +11178,7 @@ aarch64_float_const_rtx_p (rtx x)\n       && SCALAR_FLOAT_MODE_P (mode)\n       && aarch64_reinterpret_float_as_int (x, &ival))\n     {\n-      scalar_int_mode imode = (mode == HFmode\n-\t\t\t       ? SImode\n-\t\t\t       : int_mode_for_mode (mode).require ());\n+      machine_mode imode = known_eq (GET_MODE_SIZE (mode), 8) ? DImode : SImode;\n       int num_instr = aarch64_internal_mov_immediate\n \t\t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n       return num_instr < 3;\n@@ -13857,10 +13836,10 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t     proportionally expensive to the number of instructions\n \t     required to build that constant.  This is true whether we\n \t     are compiling for SPEED or otherwise.  */\n-\t  if (!is_a <scalar_int_mode> (mode, &int_mode))\n-\t    int_mode = word_mode;\n+\t  machine_mode imode = known_le (GET_MODE_SIZE (mode), 4)\n+\t\t\t\t? SImode : DImode;\n \t  *cost = COSTS_N_INSNS (aarch64_internal_mov_immediate\n-\t\t\t\t (NULL_RTX, x, false, int_mode));\n+\t\t\t\t (NULL_RTX, x, false, imode));\n \t}\n       return true;\n \n@@ -13876,9 +13855,8 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t  bool succeed = aarch64_reinterpret_float_as_int (x, &ival);\n \t  gcc_assert (succeed);\n \n-\t  scalar_int_mode imode = (mode == HFmode\n-\t\t\t\t   ? SImode\n-\t\t\t\t   : int_mode_for_mode (mode).require ());\n+\t  machine_mode imode = known_eq (GET_MODE_SIZE (mode), 8)\n+\t\t\t\t? DImode : SImode;\n \t  int ncost = aarch64_internal_mov_immediate\n \t\t(NULL_RTX, gen_int_mode (ival, imode), false, imode);\n \t  *cost += COSTS_N_INSNS (ncost);"}, {"sha": "82cc716d654f9ca7d89fcff50f0cd33f5c6f5ebb", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=ba1536dac780f3f92c5eab999fda6931f6247fc1", "patch": "@@ -1309,16 +1309,15 @@\n )\n \n (define_insn_and_split \"*movdi_aarch64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,k,r,r,r,r,r, r,w, m,m,   r,  r,  r, w,r,w, w\")\n-\t(match_operand:DI 1 \"aarch64_mov_operand\"  \" r,r,k,N,M,n,Usv,m,m,rZ,w,Usw,Usa,Ush,rZ,w,w,Dd\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,k,r,r,r,r, r,w, m,m,   r,  r,  r, w,r,w, w\")\n+\t(match_operand:DI 1 \"aarch64_mov_operand\"  \" r,r,k,O,n,Usv,m,m,rZ,w,Usw,Usa,Ush,rZ,w,w,Dd\"))]\n   \"(register_operand (operands[0], DImode)\n     || aarch64_reg_or_zero (operands[1], DImode))\"\n   \"@\n    mov\\\\t%x0, %x1\n    mov\\\\t%0, %x1\n    mov\\\\t%x0, %1\n-   mov\\\\t%x0, %1\n-   mov\\\\t%w0, %1\n+   * return aarch64_is_mov_xn_imm (INTVAL (operands[1])) ? \\\"mov\\\\t%x0, %1\\\" : \\\"mov\\\\t%w0, %1\\\";\n    #\n    * return aarch64_output_sve_cnt_immediate (\\\"cnt\\\", \\\"%x0\\\", operands[1]);\n    ldr\\\\t%x0, %1\n@@ -1340,11 +1339,11 @@\n        DONE;\n     }\"\n   ;; The \"mov_imm\" type for CNTD is just a placeholder.\n-  [(set_attr \"type\" \"mov_reg,mov_reg,mov_reg,mov_imm,mov_imm,mov_imm,mov_imm,\n+  [(set_attr \"type\" \"mov_reg,mov_reg,mov_reg,mov_imm,mov_imm,mov_imm,\n \t\t     load_8,load_8,store_8,store_8,load_8,adr,adr,f_mcr,f_mrc,\n \t\t     fmov,neon_move\")\n-   (set_attr \"arch\"   \"*,*,*,*,*,*,sve,*,fp,*,fp,*,*,*,fp,fp,fp,simd\")\n-   (set_attr \"length\" \"4,4,4,4,4,*,  4,4, 4,4, 4,8,4,4, 4, 4, 4,   4\")]\n+   (set_attr \"arch\"   \"*,*,*,*,*,sve,*,fp,*,fp,*,*,*,fp,fp,fp,simd\")\n+   (set_attr \"length\" \"4,4,4,4,*,  4,4, 4,4, 4,8,4,4, 4, 4, 4,   4\")]\n )\n \n (define_insn \"insv_imm<mode>\"\n@@ -1508,7 +1507,7 @@\n \n (define_insn \"*mov<mode>_aarch64\"\n   [(set (match_operand:DFD 0 \"nonimmediate_operand\" \"=w, w  ,?r,w,w  ,w  ,w,m,r,m ,r,r\")\n-\t(match_operand:DFD 1 \"general_operand\"      \"Y , ?rY, w,w,Ufc,Uvi,m,w,m,rY,r,N\"))]\n+\t(match_operand:DFD 1 \"general_operand\"      \"Y , ?rY, w,w,Ufc,Uvi,m,w,m,rY,r,O\"))]\n   \"TARGET_FLOAT && (register_operand (operands[0], <MODE>mode)\n     || aarch64_reg_or_fp_zero (operands[1], <MODE>mode))\"\n   \"@\n@@ -1523,7 +1522,7 @@\n    ldr\\\\t%x0, %1\n    str\\\\t%x1, %0\n    mov\\\\t%x0, %x1\n-   mov\\\\t%x0, %1\"\n+   * return aarch64_is_mov_xn_imm (INTVAL (operands[1])) ? \\\"mov\\\\t%x0, %1\\\" : \\\"mov\\\\t%w0, %1\\\";\"\n   [(set_attr \"type\" \"neon_move,f_mcr,f_mrc,fmov,fconstd,neon_move,\\\n \t\t     f_loadd,f_stored,load_8,store_8,mov_reg,\\\n \t\t     fconstd\")"}, {"sha": "ad2e5e05f4268c5d1ecc0c27b9d88b54169a1953", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba1536dac780f3f92c5eab999fda6931f6247fc1/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=ba1536dac780f3f92c5eab999fda6931f6247fc1", "patch": "@@ -106,6 +106,11 @@\n \n (define_constraint \"N\"\n  \"A constant that can be used with a 64-bit MOV immediate operation.\"\n+ (and (match_code \"const_int\")\n+      (match_test \"aarch64_is_mov_xn_imm (ival)\")))\n+\n+(define_constraint \"O\"\n+ \"A constant that can be used with a 32 or 64-bit MOV immediate operation.\"\n  (and (match_code \"const_int\")\n       (match_test \"aarch64_move_imm (ival, DImode)\")))\n "}]}