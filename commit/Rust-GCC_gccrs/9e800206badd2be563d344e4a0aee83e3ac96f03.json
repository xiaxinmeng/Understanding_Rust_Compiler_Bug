{"sha": "9e800206badd2be563d344e4a0aee83e3ac96f03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4MDAyMDZiYWRkMmJlNTYzZDM0NGU0YTBhZWU4M2UzYWM5NmYwMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-05-20T00:35:24Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-05-20T00:35:24Z"}, "message": "except.c (dw2_build_landing_pads): Use word_mode, not Pmode, as ncessary.\n\n\t* except.c (dw2_build_landing_pads): Use word_mode, not Pmode,\n\tas ncessary.\n\t(expand_eh_return): Convert between word_mode and Pmode.\n\t* unwind-dw2.c (extract_cie_info): Do not assume words and pointers\n\tare the same size.\n\t(execute_stack_op): Likewise.\n\t(execute_cfa_program): Likewise.\n\t(uw_frame_state_for): Likewise.\n\t(uw_update_context_1): Likewise.\n\t* unwind.inc (_Unwind_Reason_Code): Likewise.\n\t* config/mips/mips.h (EH_RETURN_DATA_REGNO): Define.\n\t(EH_RETURN_STACKADJ_RTX): Likewise.\n\t* config/mips/mips.c (compute_frame_size): Make space for saving\n\tEH return registers.\n\t(mips_expand_epilogue): Handle EH stack adjustments.\n\t* config/mips/mips.md (eh_return): New pattern.\n\t(eh_set_lr_si): Likewise.\n\t(eh_set_lr_di): Likewise.\n\tAdd splitter to perform EH return after reload.\n\nFrom-SVN: r42332", "tree": {"sha": "acfb4573f234684042fcc91f25abdf25bb73a6f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acfb4573f234684042fcc91f25abdf25bb73a6f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e800206badd2be563d344e4a0aee83e3ac96f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e800206badd2be563d344e4a0aee83e3ac96f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e800206badd2be563d344e4a0aee83e3ac96f03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e800206badd2be563d344e4a0aee83e3ac96f03/comments", "author": null, "committer": null, "parents": [{"sha": "878de307d62595211f10a0a88a9551215c14c898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878de307d62595211f10a0a88a9551215c14c898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878de307d62595211f10a0a88a9551215c14c898"}], "stats": {"total": 284, "additions": 221, "deletions": 63}, "files": [{"sha": "8b4ebf3c8ebf109cece12c6d58163653b70d5182", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -1,3 +1,25 @@\n+Sat May 19 18:23:04 2001  Richard Henderson <rth@redhat.com>\n+\n+\t* except.c (dw2_build_landing_pads): Use word_mode, not Pmode,\n+\tas ncessary.\n+\t(expand_eh_return): Convert between word_mode and Pmode.\n+\t* unwind-dw2.c (extract_cie_info): Do not assume words and pointers\n+\tare the same size.\n+\t(execute_stack_op): Likewise.\n+\t(execute_cfa_program): Likewise.\n+\t(uw_frame_state_for): Likewise.\n+\t(uw_update_context_1): Likewise.\n+\t* unwind.inc (_Unwind_Reason_Code): Likewise.\n+\t* config/mips/mips.h (EH_RETURN_DATA_REGNO): Define.\n+\t(EH_RETURN_STACKADJ_RTX): Likewise.\n+\t* config/mips/mips.c (compute_frame_size): Make space for saving\n+\tEH return registers.\n+\t(mips_expand_epilogue): Handle EH stack adjustments.\n+\t* config/mips/mips.md (eh_return): New pattern.\n+\t(eh_set_lr_si): Likewise.\n+\t(eh_set_lr_di): Likewise.\n+\tAdd splitter to perform EH return after reload.\n+\t\t\n 2001-05-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* jump.c (mark_jump_label): Tidy previous change."}, {"sha": "c90857e3050e62d9d97246c6d72d8fbd202a3231", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -6244,6 +6244,20 @@ compute_frame_size (size)\n \t}\n     }\n \n+  /* We need to restore these for the handler.  */\n+  if (current_function_calls_eh_return)\n+    {\n+      int i;\n+      for (i = 0; ; ++i)\n+\t{\n+\t  regno = EH_RETURN_DATA_REGNO (i);\n+\t  if (regno == INVALID_REGNUM)\n+\t    break;\n+\t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n+\t  mask |= 1L << (regno - GP_REG_FIRST);\n+\t}\n+    }\n+\n   /* Calculate space needed for fp registers.  */\n   if (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT)\n     {\n@@ -7534,13 +7548,27 @@ mips_expand_epilogue ()\n       if (tsize > 32767 && TARGET_MIPS16)\n \tabort ();\n \n+      if (current_function_calls_eh_return)\n+\t{\n+\t  rtx eh_ofs = EH_RETURN_STACKADJ_RTX;\n+\t  if (Pmode == DImode)\n+\t    emit_insn (gen_adddi3 (eh_ofs, eh_ofs, tsize_rtx));\n+\t  else\n+\t    emit_insn (gen_addsi3 (eh_ofs, eh_ofs, tsize_rtx));\n+\t  tsize_rtx = eh_ofs;\n+\t}\n+\n       emit_insn (gen_blockage ());\n-      if (Pmode == DImode && tsize != 0)\n-\temit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       tsize_rtx));\n-      else if (tsize != 0)\n-\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       tsize_rtx));\n+\n+      if (tsize != 0 || current_function_calls_eh_return)\n+\t{\n+\t  if (Pmode == DImode)\n+\t    emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   tsize_rtx));\n+\t  else\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   tsize_rtx));\n+\t}\n     }\n \n   /* The mips16 loads the return address into $7, not $31.  */"}, {"sha": "3d3ea807fbd8cf2c5e25daac53b1d0cdf4953db4", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -1105,6 +1105,10 @@ while (0)\n /* Before the prologue, RA lives in r31.  */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (VOIDmode, GP_REG_FIRST + 31)\n \n+/* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + GP_ARG_FIRST : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, GP_REG_FIRST + 3)\n+\n /* Overrides for the COFF debug format.  */\n #define PUT_SDB_SCL(a)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\\"}, {"sha": "5b8d00e92888fbd83bf999c9e75dbb25fef9177e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -26,6 +26,26 @@\n ;; ??? Currently does not have define_function_unit support for the R8000.\n ;; Must include new entries for fmadd in addition to existing entries.\n \n+;; UNSPEC values used in mips.md\n+;; Number\tUSE\n+;; 0\t\tmovsi_ul\n+;; 1\t\tmovsi_us, get_fnaddr\n+;; 2\t\tloadgp\n+;; 3\t\teh_set_return\n+;; 20\t\tbuiltin_setjmp_setup\n+;;\n+;; UNSPEC_VOLATILE values\n+;; 0\t\tblockage\n+;; 3\t\tbuiltin_longjmp\n+;; 10\t\tconsttable_qi\n+;; 11\t\tconsttable_hi\n+;; 12\t\tconsttable_si\n+;; 13\t\tconsttable_di\n+;; 14\t\tconsttable_sf\n+;; 15\t\tconsttable_df\n+;; 16\t\talign_2\n+;; 17\t\talign_4\n+;; 18\t\talign_8\n \f\n \n ;; ....................\n@@ -9484,6 +9504,73 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\;j\\\\t%2\"\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"16\")])\n \n+;; This is used in compiling the unwind routines.\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  enum machine_mode gpr_mode = TARGET_64BIT ? DImode : SImode;\n+\n+  if (GET_MODE (operands[1]) != gpr_mode)\n+    operands[1] = convert_to_mode (gpr_mode, operands[1], 0);\n+  if (TARGET_64BIT)\n+    emit_insn (gen_eh_set_lr_di (operands[1]));\n+  else\n+    emit_insn (gen_eh_set_lr_si (operands[1]));\n+\n+  emit_move_insn (EH_RETURN_STACKADJ_RTX, operands[0]);\n+  DONE;\n+}\")\n+\n+;; Clobber the return address on the stack.  We can't expand this\n+;; until we know where it will be put in the stack frame.\n+\n+(define_insn \"eh_set_lr_si\"\n+  [(unspec [(match_operand:SI 0 \"register_operand\" \"r\")] 3)\n+   (clobber (match_scratch:SI 1 \"=&r\"))]\n+  \"! TARGET_64BIT\"\n+  \"#\")\n+\n+(define_insn \"eh_set_lr_di\"\n+  [(unspec [(match_operand:DI 0 \"register_operand\" \"r\")] 3)\n+   (clobber (match_scratch:DI 1 \"=&r\"))]\n+  \"TARGET_64BIT\"\n+  \"#\")\n+\n+(define_split\n+  [(unspec [(match_operand 0 \"register_operand\" \"r\")] 3)\n+   (clobber (match_scratch 1 \"=&r\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  HOST_WIDE_INT gp_offset;\n+  rtx base;\n+\n+  compute_frame_size (get_frame_size ());\n+  if (((current_frame_info.mask >> 31) & 1) == 0)\n+    abort ();\n+  gp_offset = current_frame_info.gp_sp_offset;\n+\n+  if (gp_offset < 32768)\n+    base = stack_pointer_rtx;\n+  else\n+    {\n+      base = operands[1];\n+      emit_move_insn (base, GEN_INT (gp_offset));\n+      if (Pmode == DImode)\n+\temit_insn (gen_adddi3 (base, base, stack_pointer_rtx));\n+      else\n+\temit_insn (gen_addsi3 (base, base, stack_pointer_rtx));\n+      gp_offset = 0;\n+    }\n+  emit_move_insn (gen_rtx_MEM (GET_MODE (operands[0]),\n+\t\t\t       plus_constant (base, gp_offset)),\n+\t\t  operands[0]);\n+  DONE;\n+}\")\n \f\n ;;\n ;;  ...................."}, {"sha": "c7493e7d9306c48f835bf5f1ed80e3e7c411bbb7", "filename": "gcc/except.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -1897,7 +1897,7 @@ dw2_build_landing_pads ()\n       emit_move_insn (cfun->eh->exc_ptr,\n \t\t      gen_rtx_REG (Pmode, EH_RETURN_DATA_REGNO (0)));\n       emit_move_insn (cfun->eh->filter,\n-\t\t      gen_rtx_REG (Pmode, EH_RETURN_DATA_REGNO (1)));\n+\t\t      gen_rtx_REG (word_mode, EH_RETURN_DATA_REGNO (1)));\n \n       seq = get_insns ();\n       end_sequence ();\n@@ -3035,6 +3035,8 @@ expand_eh_return ()\n   else\n #endif\n     {\n+      rtx handler;\n+\n       ra = EH_RETURN_HANDLER_RTX;\n       if (! ra)\n \t{\n@@ -3043,7 +3045,17 @@ expand_eh_return ()\n \t}\n \n       emit_move_insn (sa, cfun->eh->ehr_stackadj);\n-      emit_move_insn (ra, cfun->eh->ehr_handler);\n+\n+      handler = cfun->eh->ehr_handler;\n+      if (GET_MODE (ra) != Pmode)\n+\t{\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\t  handler = convert_memory_address (GET_MODE (ra), handler);\n+#else\n+\t  handler = convert_to_mode (GET_MODE (ra), handler, 0);\n+#endif\n+\t}\n+      emit_move_insn (ra, handler);\n     }\n \n   emit_label (around_label);"}, {"sha": "3011bc7341f396fad76227b90f2794c9b450911a", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -218,15 +218,12 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n   const unsigned char *aug = cie->augmentation;\n   const unsigned char *p = aug + strlen (aug) + 1;\n   const unsigned char *ret = NULL;\n-  _Unwind_Word code_align;\n-  _Unwind_Sword data_align;\n+  _Unwind_Ptr tmp;\n \n   /* Immediately following the augmentation are the code and\n      data alignment and return address column.  */\n-  p = read_uleb128 (p, &code_align);\n-  p = read_sleb128 (p, &data_align);\n-  fs->code_align = code_align;\n-  fs->data_align = data_align;\n+  p = read_uleb128 (p, &tmp); fs->code_align = tmp;\n+  p = read_sleb128 (p, &tmp); fs->data_align = (saddr) tmp;\n   fs->retaddr_column = *p++;\n   fs->lsda_encoding = DW_EH_PE_omit;\n \n@@ -235,9 +232,8 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n      the size.  */\n   if (*aug == 'z')\n     {\n-      _Unwind_Word i;\n-      p = read_uleb128 (p, &i);\n-      ret = p + i;\n+      p = read_uleb128 (p, &tmp);\n+      ret = p + tmp;\n \n       fs->saw_z = 1;\n       ++aug;\n@@ -303,6 +299,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n       enum dwarf_location_atom op = *op_ptr++;\n       _Unwind_Word result, reg;\n       _Unwind_Sword offset;\n+      _Unwind_Ptr ptrtmp;\n \n       switch (op)\n \t{\n@@ -379,11 +376,12 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  op_ptr += 8;\n \t  break;\n \tcase DW_OP_constu:\n-\t  op_ptr = read_uleb128 (op_ptr, &result);\n+\t  op_ptr = read_uleb128 (op_ptr, &ptrtmp);\n+\t  result = ptrtmp;\n \t  break;\n \tcase DW_OP_consts:\n-\t  op_ptr = read_sleb128 (op_ptr, &offset);\n-\t  result = offset;\n+\t  op_ptr = read_sleb128 (op_ptr, &ptrtmp);\n+\t  result = (saddr)ptrtmp;\n \t  break;\n \n \tcase DW_OP_reg0:\n@@ -421,7 +419,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  result = _Unwind_GetGR (context, op - DW_OP_reg0);\n \t  break;\n \tcase DW_OP_regx:\n-\t  op_ptr = read_uleb128 (op_ptr, &reg);\n+\t  op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;\n \t  result = _Unwind_GetGR (context, reg);\n \t  break;\n \n@@ -457,12 +455,12 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \tcase DW_OP_breg29:\n \tcase DW_OP_breg30:\n \tcase DW_OP_breg31:\n-\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  op_ptr = read_sleb128 (op_ptr, &ptrtmp); offset = (saddr)ptrtmp;\n \t  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;\n \t  break;\n \tcase DW_OP_bregx:\n-\t  op_ptr = read_uleb128 (op_ptr, &reg);\n-\t  op_ptr = read_sleb128 (op_ptr, &offset);\n+\t  op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;\n+\t  op_ptr = read_sleb128 (op_ptr, &ptrtmp); offset = (saddr)ptrtmp;\n \t  result = _Unwind_GetGR (context, reg) + offset;\n \t  break;\n \n@@ -559,7 +557,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t      result = ~result;\n \t      break;\n \t    case DW_OP_plus_uconst:\n-\t      op_ptr = read_uleb128 (op_ptr, &reg);\n+\t      op_ptr = read_uleb128 (op_ptr, &ptrtmp); reg = ptrtmp;\n \t      result += reg;\n \t      break;\n \t    }\n@@ -698,16 +696,17 @@ execute_cfa_program (const unsigned char *insn_ptr,\n   while (insn_ptr < insn_end && fs->pc < context->ra)\n     {\n       unsigned char insn = *insn_ptr++;\n-      _Unwind_Word reg, uoffset;\n+      _Unwind_Word reg;\n       _Unwind_Sword offset;\n+      _Unwind_Ptr ptrtmp;\n \n       if (insn & DW_CFA_advance_loc)\n \tfs->pc += (insn & 0x3f) * fs->code_align;\n       else if (insn & DW_CFA_offset)\n \t{\n \t  reg = insn & 0x3f;\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n-\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  offset = ptrtmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t}\n@@ -724,28 +723,28 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  break;\n \n \tcase DW_CFA_advance_loc1:\n-\t  fs->pc += read_1u (insn_ptr);\n+\t  fs->pc += read_1u (insn_ptr) * fs->code_align;\n \t  insn_ptr += 1;\n \t  break;\n \tcase DW_CFA_advance_loc2:\n-\t  fs->pc += read_2u (insn_ptr);\n+\t  fs->pc += read_2u (insn_ptr) * fs->code_align;\n \t  insn_ptr += 2;\n \t  break;\n \tcase DW_CFA_advance_loc4:\n-\t  fs->pc += read_4u (insn_ptr);\n+\t  fs->pc += read_4u (insn_ptr) * fs->code_align;\n \t  insn_ptr += 4;\n \t  break;\n \n \tcase DW_CFA_offset_extended:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n-\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  offset = ptrtmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t  break;\n \n \tcase DW_CFA_restore_extended:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n \t  fs->regs.reg[reg].how = REG_UNSAVED;\n \t  break;\n \n@@ -757,8 +756,8 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \tcase DW_CFA_register:\n \t  {\n \t    _Unwind_Word reg2;\n-\t    insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t    insn_ptr = read_uleb128 (insn_ptr, &reg2);\n+\t    insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n+\t    insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg2 = ptrtmp;\n \t    fs->regs.reg[reg].how = REG_SAVED_REG;\n \t    fs->regs.reg[reg].loc.reg = reg2;\n \t  }\n@@ -790,55 +789,60 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  break;\n \n \tcase DW_CFA_def_cfa:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n-\t  fs->cfa_offset = uoffset;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_reg = ptrtmp;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_offset = ptrtmp;\n \t  fs->cfa_how = CFA_REG_OFFSET;\n \t  break;\n \n \tcase DW_CFA_def_cfa_register:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_reg = ptrtmp;\n \t  fs->cfa_how = CFA_REG_OFFSET;\n \t  break;\n \n \tcase DW_CFA_def_cfa_offset:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n-\t  fs->cfa_offset = uoffset;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_offset = ptrtmp;\n \t  /* cfa_how deliberately not set.  */\n \t  break;\n \n \tcase DW_CFA_def_cfa_expression:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n \t  fs->cfa_exp = insn_ptr;\n \t  fs->cfa_how = CFA_EXP;\n-\t  insn_ptr += uoffset;\n+\t  insn_ptr += ptrtmp;\n \t  break;\n \n \tcase DW_CFA_expression:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n \t  fs->regs.reg[reg].how = REG_SAVED_EXP;\n \t  fs->regs.reg[reg].loc.exp = insn_ptr;\n-\t  insn_ptr += uoffset;\n+\t  insn_ptr += ptrtmp;\n \t  break;\n \n \t  /* From the 2.1 draft.  */\n \tcase DW_CFA_offset_extended_sf:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  insn_ptr = read_sleb128 (insn_ptr, &offset);\n-\t  offset *= fs->data_align;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n+\t  insn_ptr = read_sleb128 (insn_ptr, &ptrtmp);\n+\t  offset = (saddr)ptrtmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = offset;\n \t  break;\n \t  \n \tcase DW_CFA_def_cfa_sf:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_reg);\n-\t  insn_ptr = read_sleb128 (insn_ptr, &fs->cfa_offset);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_reg = ptrtmp;\n+\t  insn_ptr = read_sleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_offset = (saddr)ptrtmp;\n \t  fs->cfa_how = CFA_REG_OFFSET;\n \t  break;\n \n \tcase DW_CFA_def_cfa_offset_sf:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &fs->cfa_offset);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  fs->cfa_offset = ptrtmp;\n \t  /* cfa_how deliberately not set.  */\n \t  break;\n \n@@ -852,15 +856,16 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  break;\n \n \tcase DW_CFA_GNU_args_size:\n-\t  insn_ptr = read_uleb128 (insn_ptr, &context->args_size);\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  context->args_size = ptrtmp;\n \t  break;\n \n \tcase DW_CFA_GNU_negative_offset_extended:\n \t  /* Obsoleted by DW_CFA_offset_extended_sf, but used by\n \t     older PowerPC code.  */\n-\t  insn_ptr = read_uleb128 (insn_ptr, &reg);\n-\t  insn_ptr = read_uleb128 (insn_ptr, &uoffset);\n-\t  offset = (_Unwind_Sword)uoffset * fs->data_align;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp); reg = ptrtmp;\n+\t  insn_ptr = read_uleb128 (insn_ptr, &ptrtmp);\n+\t  offset = ptrtmp * fs->data_align;\n \t  fs->regs.reg[reg].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[reg].loc.offset = -offset;\n \t  break;\n@@ -916,7 +921,7 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n   insn = NULL;\n   if (fs->saw_z)\n     {\n-      _Unwind_Word i;\n+      _Unwind_Ptr i;\n       aug = read_uleb128 (aug, &i);\n       insn = aug + i;\n     }\n@@ -964,7 +969,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t that this will not be a problem.  */\n       {\n \tconst unsigned char *exp = fs->cfa_exp;\n-\t_Unwind_Word len;\n+\t_Unwind_Ptr len;\n \n \texp = read_uleb128 (exp, &len);\n \tcfa = (void *) (_Unwind_Ptr)\n@@ -992,7 +997,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n       case REG_SAVED_EXP:\n \t{\n \t  const unsigned char *exp = fs->regs.reg[i].loc.exp;\n-\t  _Unwind_Word len;\n+\t  _Unwind_Ptr len;\n \t  _Unwind_Ptr val;\n \n \t  exp = read_uleb128 (exp, &len);"}, {"sha": "85636d40c034b96f56b6345851a530eedcd20c27", "filename": "gcc/unwind.inc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e800206badd2be563d344e4a0aee83e3ac96f03/gcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.inc?ref=9e800206badd2be563d344e4a0aee83e3ac96f03", "patch": "@@ -135,8 +135,8 @@ static _Unwind_Reason_Code\n _Unwind_ForcedUnwind_Phase2(struct _Unwind_Exception *exc,\n \t\t\t    struct _Unwind_Context *context)\n {\n-  _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) exc->private_1;\n-  void *stop_argument = (void *) exc->private_2;\n+  _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) (_Unwind_Ptr) exc->private_1;\n+  void *stop_argument = (void *) (_Unwind_Ptr) exc->private_2;\n   _Unwind_Reason_Code code, stop_code;\n \n   while (1)"}]}