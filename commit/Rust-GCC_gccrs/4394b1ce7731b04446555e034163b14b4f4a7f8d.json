{"sha": "4394b1ce7731b04446555e034163b14b4f4a7f8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM5NGIxY2U3NzMxYjA0NDQ2NTU1ZTAzNDE2M2IxNGI0ZjRhN2Y4ZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T16:09:42Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T16:09:42Z"}, "message": "c-family: Fix regression in location-overflow-test-1.c [PR97117]\n\nThe r11-3266 patch that added macro support to -Wmisleading-indentation\naccidentally suppressed the column-tracking diagnostic in\nget_visual_column in some cases, e.g. in the location-overflow-test-1.c\ntestcase.\n\nMore generally, when all three tokens are on the same line and we've run\nout of locations with column info, then their location_t values will be\nequal, and we exit early from should_warn_for_misleading_indentation due\nto the new check\n\n  /* Give up if the loci are not all distinct.  */\n  if (guard_loc == body_loc || body_loc == next_stmt_loc)\n    return false;\n\nbefore we ever call get_visual_column.\n\n[ This new check is needed to detect and give up on analyzing code\n  fragments where exactly two out of the three tokens come from the same\n  macro expansion, e.g.\n\n    #define MACRO \\\n      if (a)      \\\n        foo ();\n\n    MACRO; bar ();\n\n  Here, guard_loc and body_loc will be equal and point to the macro\n  expansion point (and next_stmt_loc will point to 'bar').  The heuristics\n  that the warning uses are not really valid in scenarios like these.  ]\n\nIn order to restore the column-tracking diagnostic, this patch moves the\nthe diagnostic code out from get_visual_column to earlier in\nshould_warn_for_misleading_indentation.  Moreover, it tests the three\nlocations for a zero column all at once, which I suppose should make us\nissue the diagnostic more consistently.\n\ngcc/c-family/ChangeLog:\n\n\tPR testsuite/97117\n\t* c-indentation.c (get_visual_column): Remove location_t\n\tparameter.  Move the column-tracking diagnostic code from here\n\tto ...\n\t(should_warn_for_misleading_indentation): ... here, before the\n\tearly exit for when the loci are not all distinct.  Don't pass a\n\tlocation_t argument to get_visual_column.\n\t(assert_get_visual_column_succeeds): Don't pass a location_t\n\targument to get_visual_column.\n\t(assert_get_visual_column_fails): Likewise.", "tree": {"sha": "ddb92ae849196b286c709c15b7f8ff96b13771c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddb92ae849196b286c709c15b7f8ff96b13771c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4394b1ce7731b04446555e034163b14b4f4a7f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4394b1ce7731b04446555e034163b14b4f4a7f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4394b1ce7731b04446555e034163b14b4f4a7f8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4394b1ce7731b04446555e034163b14b4f4a7f8d/comments", "author": null, "committer": null, "parents": [{"sha": "c5395d88dfa2123ca5155008c8c8339ded98fd32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5395d88dfa2123ca5155008c8c8339ded98fd32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5395d88dfa2123ca5155008c8c8339ded98fd32"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "836a524f266a1a54afdf7902d17366b34c41c9eb", "filename": "gcc/c-family/c-indentation.c", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4394b1ce7731b04446555e034163b14b4f4a7f8d/gcc%2Fc-family%2Fc-indentation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4394b1ce7731b04446555e034163b14b4f4a7f8d/gcc%2Fc-family%2Fc-indentation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-indentation.c?ref=4394b1ce7731b04446555e034163b14b4f4a7f8d", "patch": "@@ -45,36 +45,11 @@ next_tab_stop (unsigned int vis_column, unsigned int tab_width)\n    on the line (up to or before EXPLOC).  */\n \n static bool\n-get_visual_column (expanded_location exploc, location_t loc,\n+get_visual_column (expanded_location exploc,\n \t\t   unsigned int *out,\n \t\t   unsigned int *first_nws,\n \t\t   unsigned int tab_width)\n {\n-  /* PR c++/68819: if the column number is zero, we presumably\n-     had a location_t > LINE_MAP_MAX_LOCATION_WITH_COLS, and so\n-     we have no column information.\n-     Act as if no conversion was possible, triggering the\n-     error-handling path in the caller.  */\n-  if (!exploc.column)\n-    {\n-      static bool issued_note = false;\n-      if (!issued_note)\n-\t{\n-\t  /* Notify the user the first time this happens.  */\n-\t  issued_note = true;\n-\t  inform (loc,\n-\t\t  \"%<-Wmisleading-indentation%> is disabled from this point\"\n-\t\t  \" onwards, since column-tracking was disabled due to\"\n-\t\t  \" the size of the code/headers\");\n-\t  if (!flag_large_source_files)\n-\t    inform (loc,\n-\t\t    \"adding %<-flarge-source-files%> will allow for more\" \n-\t\t    \" column-tracking support, at the expense of compilation\"\n-\t\t    \" time and memory\");\n-\t}\n-      return false;\n-    }\n-\n   char_span line = location_get_source_line (exploc.file, exploc.line);\n   if (!line)\n     return false;\n@@ -325,14 +300,37 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t\t\t\t\t\tNULL);\n     }\n \n-  /* Give up if the loci are not all distinct.  */\n-  if (guard_loc == body_loc || body_loc == next_stmt_loc)\n-    return false;\n-\n   expanded_location body_exploc = expand_location (body_loc);\n   expanded_location next_stmt_exploc = expand_location (next_stmt_loc);\n   expanded_location guard_exploc = expand_location (guard_loc);\n \n+  /* PR c++/68819: if the column number is zero, we presumably\n+     had a location_t > LINE_MAP_MAX_LOCATION_WITH_COLS, and so\n+     we have no column information.  */\n+  if (!guard_exploc.column || !body_exploc.column || !next_stmt_exploc.column)\n+    {\n+      static bool issued_note = false;\n+      if (!issued_note)\n+\t{\n+\t  /* Notify the user the first time this happens.  */\n+\t  issued_note = true;\n+\t  inform (guard_loc,\n+\t\t  \"%<-Wmisleading-indentation%> is disabled from this point\"\n+\t\t  \" onwards, since column-tracking was disabled due to\"\n+\t\t  \" the size of the code/headers\");\n+\t  if (!flag_large_source_files)\n+\t    inform (guard_loc,\n+\t\t    \"adding %<-flarge-source-files%> will allow for more\" \n+\t\t    \" column-tracking support, at the expense of compilation\"\n+\t\t    \" time and memory\");\n+\t}\n+      return false;\n+    }\n+\n+  /* Give up if the loci are not all distinct.  */\n+  if (guard_loc == body_loc || body_loc == next_stmt_loc)\n+    return false;\n+\n   const unsigned int tab_width = global_dc->tabstop;\n \n   /* They must be in the same file.  */\n@@ -378,7 +376,7 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t  gcc_assert (guard_exploc.line == next_stmt_exploc.line);\n \t  unsigned int guard_vis_column;\n \t  unsigned int guard_line_first_nws;\n-\t  if (!get_visual_column (guard_exploc, guard_loc,\n+\t  if (!get_visual_column (guard_exploc,\n \t\t\t\t  &guard_vis_column,\n \t\t\t\t  &guard_line_first_nws, tab_width))\n \t    return false;\n@@ -438,15 +436,15 @@ should_warn_for_misleading_indentation (const token_indent_info &guard_tinfo,\n \t the case for input files containing #line directives, and these\n \t are often for autogenerated sources (e.g. from .md files), where\n \t it's not clear that it's meaningful to look at indentation.  */\n-      if (!get_visual_column (next_stmt_exploc, next_stmt_loc,\n+      if (!get_visual_column (next_stmt_exploc,\n \t\t\t      &next_stmt_vis_column,\n \t\t\t      &next_stmt_line_first_nws, tab_width))\n \treturn false;\n-      if (!get_visual_column (body_exploc, body_loc,\n+      if (!get_visual_column (body_exploc,\n \t\t\t      &body_vis_column,\n \t\t\t      &body_line_first_nws, tab_width))\n \treturn false;\n-      if (!get_visual_column (guard_exploc, guard_loc,\n+      if (!get_visual_column (guard_exploc,\n \t\t\t      &guard_vis_column,\n \t\t\t      &guard_line_first_nws, tab_width))\n \treturn false;\n@@ -701,7 +699,7 @@ assert_get_visual_column_succeeds (const location &loc,\n   exploc.sysp = false;\n   unsigned int actual_visual_column;\n   unsigned int actual_first_nws;\n-  bool result = get_visual_column (exploc, UNKNOWN_LOCATION,\n+  bool result = get_visual_column (exploc,\n \t\t\t\t   &actual_visual_column,\n \t\t\t\t   &actual_first_nws, tab_width);\n   ASSERT_TRUE_AT (loc, result);\n@@ -739,7 +737,7 @@ assert_get_visual_column_fails (const location &loc,\n   exploc.sysp = false;\n   unsigned int actual_visual_column;\n   unsigned int actual_first_nws;\n-  bool result = get_visual_column (exploc, UNKNOWN_LOCATION,\n+  bool result = get_visual_column (exploc,\n \t\t\t\t   &actual_visual_column,\n \t\t\t\t   &actual_first_nws, tab_width);\n   ASSERT_FALSE_AT (loc, result);"}]}