{"sha": "423462fb6785896c8031319d50ac38fbca3afb51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzNDYyZmI2Nzg1ODk2YzgwMzEzMTlkNTBhYzM4ZmJjYTNhZmI1MQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-05T14:23:06Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:13Z"}, "message": "Added proper cfg_attr expansion", "tree": {"sha": "2189e0aefa07f55ade13bd052e9d852f3afdccfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2189e0aefa07f55ade13bd052e9d852f3afdccfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/423462fb6785896c8031319d50ac38fbca3afb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423462fb6785896c8031319d50ac38fbca3afb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/423462fb6785896c8031319d50ac38fbca3afb51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/423462fb6785896c8031319d50ac38fbca3afb51/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7cf2f7789dccbb1d8aac6222b2b1c0f4d5f18f6"}], "stats": {"total": 120, "additions": 86, "deletions": 34}, "files": [{"sha": "44a38ac5ff78624803513a27e7d8e888f65c1cdb", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=423462fb6785896c8031319d50ac38fbca3afb51", "patch": "@@ -5048,18 +5048,19 @@ MacroParser::parse_meta_item_lit ()\n bool\n AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n {\n-  /* cfg value of container is purely based on cfg of each inner item - all\n-   * must be true */\n-  for (const auto &inner_item : items)\n+  /* NOTE: assuming that only first item must be true - cfg should only have one item, and cfg_attr only has first item as predicate. TODO ensure that this is correct. */\n+  if (items.empty ())\n+    return false;\n+\n+  return items[0]->check_cfg_predicate (session);\n+\n+  /*for (const auto &inner_item : items)\n     {\n       if (!inner_item->check_cfg_predicate (session))\n \treturn false;\n     }\n \n-  /* TODO: as far as I can tell, there should only be a single element to\n-   * check here, so ensure there is only a single element in items too? */\n-\n-  return true;\n+  return true;*/\n }\n \n bool\n@@ -5346,6 +5347,53 @@ MetaItemPathLit::to_attribute () const\n \t\t\t    new AttrInputLiteral (lit)));\n }\n \n+std::vector<Attribute> AttrInputMetaItemContainer::separate_cfg_attrs () const {\n+    rust_assert (!items.empty ());\n+\n+    if (items.size () == 1)\n+      return {};\n+\n+    std::vector<Attribute> attrs;\n+    attrs.reserve (items.size () - 1);\n+\n+    for (auto it = items.begin () + 1; it != items.end (); ++it) {\n+      Attribute attr = (*it)->to_attribute ();\n+      if (attr.is_empty ()) {\n+        // TODO should this be an error that causes us to chuck out everything?\n+        continue;\n+      }\n+      attrs.push_back (std::move (attr));\n+    }\n+\n+    attrs.shrink_to_fit ();\n+    return attrs;\n+  }\n+\n+bool Attribute::check_cfg_predicate (const Session &session)\n+  {\n+    /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n+     * cfg_attr path */\n+    if (!has_attr_input () || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n+      return false;\n+\n+    // TODO: maybe replace with storing a \"has been parsed\" variable?\n+    parse_attr_to_meta_item ();\n+    // can't be const because of this anyway\n+\n+    return attr_input->check_cfg_predicate (session);\n+  }\n+\n+std::vector<Attribute> Attribute::separate_cfg_attrs () {\n+    if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n+      return {};\n+\n+      // TODO: maybe replace with storing a \"has been parsed\" variable?\n+      parse_attr_to_meta_item ();\n+      // can't be const because of this anyway\n+\n+    return attr_input->separate_cfg_attrs ();\n+  }\n+\n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes\n  * any longer than they already are. */"}, {"sha": "cfb5f9b230efb7fcf193a46181675c3bc0823c5f", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=423462fb6785896c8031319d50ac38fbca3afb51", "patch": "@@ -83,6 +83,8 @@ class AttrInput\n   // Parse attribute input to meta item, if possible\n   virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n \n+  virtual std::vector<Attribute> separate_cfg_attrs () const { return {}; }\n+\n protected:\n   // pure virtual clone implementation\n   virtual AttrInput *clone_attr_input_impl () const = 0;\n@@ -590,20 +592,9 @@ struct Attribute\n \n   /* Determines whether cfg predicate is true and item with attribute should not\n    * be stripped. */\n-  bool check_cfg_predicate (const Session &session)\n-  {\n-    /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n-     * cfg_attr path */\n-\n-    if (!has_attr_input ())\n-      return false;\n+  bool check_cfg_predicate (const Session &session);\n \n-    // TODO: maybe replace with storing a \"has been parsed\" variable?\n-    parse_attr_to_meta_item ();\n-    // can't be const because of this anyway\n-\n-    return attr_input->check_cfg_predicate (session);\n-  }\n+  std::vector<Attribute> separate_cfg_attrs ();\n \n protected:\n   // not virtual as currently no subclasses of Attribute, but could be in future\n@@ -683,6 +674,8 @@ class AttrInputMetaItemContainer : public AttrInput\n       clone_attr_input_meta_item_container_impl ());\n   }\n \n+  std::vector<Attribute> separate_cfg_attrs () const override;\n+\n protected:\n   // Use covariance to implement clone function as returning this type\n   AttrInputMetaItemContainer *clone_attr_input_impl () const override"}, {"sha": "9ecbb51cb2cb27426fb2148fadd205728105cd95", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=423462fb6785896c8031319d50ac38fbca3afb51", "patch": "@@ -572,6 +572,8 @@ class MetaListNameValueStr : public MetaItem\n };\n \n // Object that parses macros from a token stream.\n+/* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n+ * attributes, I believe */\n struct MacroParser\n {\n private:"}, {"sha": "6afe8a5166b787cd5f5f417fcb37f6c53ab2ba75", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=423462fb6785896c8031319d50ac38fbca3afb51", "patch": "@@ -25,19 +25,23 @@ namespace Rust {\n     }\n \n     /* Determines whether cfg predicate is true and item with attribute should not\n-     * be stripped. */\n-    bool check_cfg_predicate() {}\n-\n-    /* Determines whether cfg predicate is true and item with attribute should not\n-     * be stripped. */\n-    bool check_cfg(AST::Attribute& attr) {}\n+     * be stripped. TODO can this be const reference or does it have to mutate? */\n+    bool MacroExpander::check_cfg(AST::Attribute& attr) {}\n \n     // Expands cfg_attr attributes.\n-    void expand_attrs_cfgattr(std::vector<AST::Attribute>& attrs) {\n-        for (auto it = attrs.begin(); it != attrs.end();) {\n-            auto& attr = *it;\n+    void MacroExpander::expand_cfg_attrs(std::vector<AST::Attribute>& attrs) {\n+        for (int i = 0; i < attrs.size (); ) {\n+            auto& attr = attrs[i];\n             if (attr.get_path() == \"cfg_attr\") {\n-                if (check_cfg(attr)) {\n+                if (attr.check_cfg_predicate (session)) {\n+                    // split off cfg_attr\n+                    std::vector<AST::Attribute> new_attrs = attr.separate_cfg_attrs ();\n+\n+                    // remove attr from vector\n+                    attrs.erase (attrs.begin () + i);\n+\n+                    // add new attrs to vector\n+                    attrs.insert (attrs.begin() + i, std::make_move_iterator (new_attrs.begin ()), std::make_move_iterator (new_attrs.end ()));\n                 }\n \n                 /* do something - if feature (first token in tree) is in fact enabled,\n@@ -47,17 +51,18 @@ namespace Rust {\n                  * recursive, so check for expanded attributes being recursive and\n                  * possibly recursively call the expand_attrs? */\n             } else {\n-                ++it;\n+                i++;\n             }\n         }\n+        attrs.shrink_to_fit ();\n     }\n \n     void MacroExpander::expand_crate() {\n         /* fill macro/decorator map from init list? not sure where init list comes\n          * from? */\n \n-        // expand crate attributes\n-        expand_attrs_cfgattr(crate.inner_attrs);\n+        // expand crate cfg_attr attributes\n+        expand_cfg_attrs(crate.inner_attrs);\n \n         // expand module attributes?\n "}, {"sha": "7e684a90e10ed26bdb3b6ee4f0f7fa2ee91d0b1a", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/423462fb6785896c8031319d50ac38fbca3afb51/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=423462fb6785896c8031319d50ac38fbca3afb51", "patch": "@@ -27,7 +27,7 @@ struct MacroExpander\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n-  MacroExpander (AST::Crate &crate, ExpansionCfg cfg) : cfg (cfg), crate (crate)\n+  MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session) : cfg (cfg), crate (crate), session (session)\n   {}\n \n   ~MacroExpander () = default;\n@@ -40,11 +40,15 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n+  void expand_cfg_attrs(std::vector<AST::Attribute>& attrs);\n+  bool check_cfg(AST::Attribute& attr);\n+\n   /* TODO: make it extend ASTVisitor so that individual items can be accessed\n    * properly? */\n \n private:\n   AST::Crate &crate;\n+  Session &session;\n };\n } // namespace Rust\n "}]}