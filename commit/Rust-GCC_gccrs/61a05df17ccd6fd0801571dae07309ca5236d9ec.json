{"sha": "61a05df17ccd6fd0801571dae07309ca5236d9ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhMDVkZjE3Y2NkNmZkMDgwMTU3MWRhZTA3MzA5Y2E1MjM2ZDllYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-03-28T11:08:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-03-28T11:08:16Z"}, "message": "Bring from lto-branch:\n\n\t2008-09-03  Doug Kwan  <dougkwan@google.com>\n\n\t* cgraphbuild.c (initialize_inline_failed): Use cgraph_inline_failed_t\n\tenums instead of reason strings.\n\t* cgraph.c (cgraph_create_edge): Same.\n\t(cgraph_inline_failed_string): New function.\n\t* cgraph.h (cgraph_inline_failed_t): New enum type.\n\t(cgraph_inline_failed_string): New prototype.\n\t(struct cgraph_edge): Change type of INLINED_FAILED from constant\n\tchar pointer to cgraph_inline_failed_t.\n\t(cgraph_inline_p): Adjust prototype to use cgraph_inline_failed_t.\n\t(cgraph_default_inline_p): Ditto.\n\t* gcc/cgraphunit.c (cgraph_inline_p): Change type of parameter REASON\n\tto cgraph_inline_failed_t pointer.\n\t* cif-code.def: New file.\n\t* ipa-inline.c (cgraph_mark_inline_edge): Use an enum instead of a\n\treason string.\n\t(cgraph_check_inline_limits): Change type of REASON to pointer to\n\tcgraph_inline_failed_t.  Replace reason strings with enums.\n\t(cgraph_default_inline_p): Ditto.\n\t(cgraph_recursive_inlining_p): Ditto.\n\t(update_caller_keys): Change type of FAILED_REASON to\n\tcgraph_inline_failed_t.\n\t(cgraph_set_inline_failed): Change type of REASON to pointer to\n\tcgraph_inline_failed_t.  Call cgraph_inline_failed_string to\n\tconvert enums to strings for text output.\n\t(cgraph_decide_inlining_of_small_function): Change FAILED_REASON\n\tto be of type cgraph_inline_failed_t.  Replace reason strings with\n\tenums.  Call cgraph_inline_failed_string to covert enums\n\tto strings for text output.\n\t(cgraph_decide_inlining): Replace reason strings with enums.\n\t(cgraph_decide_inlining_incrementally): Change type of FAILED_REASON\n\tto cgraph_inline_failed_t type.  Call cgraph_inline_failed_string\n\tfor text output.\n\t* tree-inline.c (expand_call_inline): Change type of REASON\n\tto cgraph_inline_failed_t.  Replace reason strings with enums.\n\tCall cgraph_inline_failed_string for text output.\n\t* Makefile.in (CGRAPH_H): Add cif-code.def to dependencies.\n\t(cgraph.o): Ditto.\n\nFrom-SVN: r145176", "tree": {"sha": "0557e52d0af921b06b93448b142c8e6390a24930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0557e52d0af921b06b93448b142c8e6390a24930"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a05df17ccd6fd0801571dae07309ca5236d9ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a05df17ccd6fd0801571dae07309ca5236d9ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a05df17ccd6fd0801571dae07309ca5236d9ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a05df17ccd6fd0801571dae07309ca5236d9ec/comments", "author": null, "committer": null, "parents": [{"sha": "144e8aac3db919da759194f93628b91377afc4eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144e8aac3db919da759194f93628b91377afc4eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/144e8aac3db919da759194f93628b91377afc4eb"}], "stats": {"total": 179, "additions": 127, "deletions": 52}, "files": [{"sha": "db8837c9797ab9271036b357cf12208d8810425f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -1,3 +1,46 @@\n+2009-03-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tBring from lto-branch:\n+\t2008-09-03  Doug Kwan  <dougkwan@google.com>\n+\n+\t* cgraphbuild.c (initialize_inline_failed): Use cgraph_inline_failed_t\n+\tenums instead of reason strings.\n+\t* cgraph.c (cgraph_create_edge): Same.\n+\t(cgraph_inline_failed_string): New function.\n+\t* cgraph.h (cgraph_inline_failed_t): New enum type.\n+\t(cgraph_inline_failed_string): New prototype.\n+\t(struct cgraph_edge): Change type of INLINED_FAILED from constant\n+\tchar pointer to cgraph_inline_failed_t.\n+\t(cgraph_inline_p): Adjust prototype to use cgraph_inline_failed_t.\n+\t(cgraph_default_inline_p): Ditto.\n+\t* gcc/cgraphunit.c (cgraph_inline_p): Change type of parameter REASON\n+\tto cgraph_inline_failed_t pointer.\n+\t* cif-code.def: New file.\n+\t* ipa-inline.c (cgraph_mark_inline_edge): Use an enum instead of a\n+\treason string.\n+\t(cgraph_check_inline_limits): Change type of REASON to pointer to\n+\tcgraph_inline_failed_t.  Replace reason strings with enums.\n+\t(cgraph_default_inline_p): Ditto.\n+\t(cgraph_recursive_inlining_p): Ditto.\n+\t(update_caller_keys): Change type of FAILED_REASON to\n+\tcgraph_inline_failed_t.\n+\t(cgraph_set_inline_failed): Change type of REASON to pointer to\n+\tcgraph_inline_failed_t.  Call cgraph_inline_failed_string to\n+\tconvert enums to strings for text output.\n+\t(cgraph_decide_inlining_of_small_function): Change FAILED_REASON\n+\tto be of type cgraph_inline_failed_t.  Replace reason strings with\n+\tenums.  Call cgraph_inline_failed_string to covert enums\n+\tto strings for text output.\n+\t(cgraph_decide_inlining): Replace reason strings with enums.\n+\t(cgraph_decide_inlining_incrementally): Change type of FAILED_REASON\n+\tto cgraph_inline_failed_t type.  Call cgraph_inline_failed_string\n+\tfor text output.\n+\t* tree-inline.c (expand_call_inline): Change type of REASON\n+\tto cgraph_inline_failed_t.  Replace reason strings with enums.\n+\tCall cgraph_inline_failed_string for text output.\n+\t* Makefile.in (CGRAPH_H): Add cif-code.def to dependencies.\n+\t(cgraph.o): Ditto.\n+\n 2009-03-28  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_node, cgraph_remove_node, dump_cgraph_node,"}, {"sha": "d17d6a9c00d6ed0b977e07d2d110042ebf709d83", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -680,14 +680,13 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n     }\n \n   if (!callee->analyzed)\n-    edge->inline_failed = N_(\"function body not available\");\n+    edge->inline_failed = CIF_BODY_NOT_AVAILABLE;\n   else if (callee->local.redefined_extern_inline)\n-    edge->inline_failed = N_(\"redefined extern inline functions are not \"\n-\t\t\t     \"considered for inlining\");\n+    edge->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n   else if (callee->local.inlinable)\n-    edge->inline_failed = N_(\"function not considered for inlining\");\n+    edge->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n   else\n-    edge->inline_failed = N_(\"function not inlinable\");\n+    edge->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n \n   edge->aux = NULL;\n \n@@ -1105,6 +1104,24 @@ cgraph_rtl_info (tree decl)\n   return &node->rtl;\n }\n \n+/* Return a string describing the failure REASON.  */\n+\n+const char*\n+cgraph_inline_failed_string (cgraph_inline_failed_t reason)\n+{\n+#undef DEFCIFCODE\n+#define DEFCIFCODE(code, string)\tstring,\n+\n+  static const char *cif_string_table[CIF_N_REASONS] = {\n+#include \"cif-code.def\"\n+  };\n+\n+  /* Signedness of an enum type is implementation defined, so cast it\n+     to unsigned before testing. */\n+  gcc_assert ((unsigned) reason < CIF_N_REASONS);\n+  return cif_string_table[reason];\n+}\n+\n /* Return name of the node used in debug output.  */\n const char *\n cgraph_node_name (struct cgraph_node *node)"}, {"sha": "d2d310aa29ffd0c4154a5a2d28f5091915cb552a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -189,6 +189,13 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   tree inline_decl;\n };\n \n+#define DEFCIFCODE(code, string)\tCIF_ ## code,\n+/* Reasons for inlining failures.  */\n+typedef enum {\n+#include \"cif-code.def\"\n+  CIF_N_REASONS\n+} cgraph_inline_failed_t;\n+\n struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\")))\n {\n   struct cgraph_node *caller;\n@@ -199,9 +206,9 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n   struct cgraph_edge *next_callee;\n   gimple call_stmt;\n   PTR GTY ((skip (\"\"))) aux;\n-  /* When NULL, inline this call.  When non-NULL, points to the explanation\n-     why function was not inlined.  */\n-  const char *inline_failed;\n+  /* When equal to CIF_OK, inline this call.  Otherwise, points to the\n+     explanation why function was not inlined.  */\n+  cgraph_inline_failed_t inline_failed;\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n   /* Expected frequency of executions within the function. \n@@ -332,6 +339,7 @@ void cgraph_unnest_node (struct cgraph_node *);\n \n enum availability cgraph_function_body_availability (struct cgraph_node *);\n void cgraph_add_new_function (tree, bool);\n+const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n \n /* In cgraphunit.c  */\n void cgraph_finalize_function (tree, bool);\n@@ -340,7 +348,7 @@ void cgraph_finalize_compilation_unit (void);\n void cgraph_optimize (void);\n void cgraph_mark_needed_node (struct cgraph_node *);\n void cgraph_mark_reachable_node (struct cgraph_node *);\n-bool cgraph_inline_p (struct cgraph_edge *, const char **reason);\n+bool cgraph_inline_p (struct cgraph_edge *, cgraph_inline_failed_t *reason);\n bool cgraph_preserve_function_body_p (tree);\n void verify_cgraph (void);\n void verify_cgraph_node (struct cgraph_node *);\n@@ -449,7 +457,6 @@ varpool_next_static_initializer (struct varpool_node *node)\n \n /* In ipa-inline.c  */\n void cgraph_clone_inlined_nodes (struct cgraph_edge *, bool, bool);\n-bool cgraph_default_inline_p (struct cgraph_node *, const char **);\n unsigned int compute_inline_parameters (struct cgraph_node *);\n \n "}, {"sha": "f9bc6201afbcec8ce30685444adabba56158ea50", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -92,14 +92,13 @@ initialize_inline_failed (struct cgraph_node *node)\n       gcc_assert (!e->callee->global.inlined_to);\n       gcc_assert (e->inline_failed);\n       if (node->local.redefined_extern_inline)\n-\te->inline_failed = N_(\"redefined extern inline functions are not \"\n-\t\t\t   \"considered for inlining\");\n+\te->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n       else if (!node->local.inlinable)\n-\te->inline_failed = N_(\"function not inlinable\");\n+\te->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       else if (gimple_call_cannot_inline_p (e->call_stmt))\n-\te->inline_failed = N_(\"mismatched arguments\");\n+\te->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n       else\n-\te->inline_failed = N_(\"function not considered for inlining\");\n+\te->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n     }\n }\n "}, {"sha": "d098db4de9aa77673f3d806c15cb8e5ea16e2977", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -1061,7 +1061,7 @@ cgraph_expand_function (struct cgraph_node *node)\n /* Return true when CALLER_DECL should be inlined into CALLEE_DECL.  */\n \n bool\n-cgraph_inline_p (struct cgraph_edge *e, const char **reason)\n+cgraph_inline_p (struct cgraph_edge *e, cgraph_inline_failed_t *reason)\n {\n   *reason = e->inline_failed;\n   return !e->inline_failed;"}, {"sha": "94e4576f1aea248003f789c5e56f4c27f6992240", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -261,7 +261,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     cgraph_redirect_edge_callee (e, cgraph_node (e->callee->inline_decl));\n \n   gcc_assert (e->inline_failed);\n-  e->inline_failed = NULL;\n+  e->inline_failed = CIF_OK;\n \n   if (!e->callee->global.inlined)\n     DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n@@ -361,7 +361,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n \n static bool\n cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t\t    const char **reason, bool one_only)\n+\t\t\t    cgraph_inline_failed_t *reason, bool one_only)\n {\n   int times = 0;\n   struct cgraph_edge *e;\n@@ -396,7 +396,7 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n       && newsize > limit)\n     {\n       if (reason)\n-        *reason = N_(\"--param large-function-growth limit reached\");\n+        *reason = CIF_LARGE_FUNCTION_GROWTH_LIMIT;\n       return false;\n     }\n \n@@ -411,16 +411,16 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n       && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n     {\n       if (reason)\n-        *reason = N_(\"--param large-stack-frame-growth limit reached\");\n+        *reason = CIF_LARGE_STACK_FRAME_GROWTH_LIMIT;\n       return false;\n     }\n   return true;\n }\n \n /* Return true when function N is small enough to be inlined.  */\n \n-bool\n-cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n+static bool\n+cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n {\n   tree decl = n->decl;\n \n@@ -429,14 +429,14 @@ cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n   if (!flag_inline_small_functions && !DECL_DECLARED_INLINE_P (decl))\n     {\n       if (reason)\n-\t*reason = N_(\"function not inline candidate\");\n+\t*reason = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n       return false;\n     }\n \n   if (!DECL_STRUCT_FUNCTION (decl)->cfg)\n     {\n       if (reason)\n-\t*reason = N_(\"function body not available\");\n+\t*reason = CIF_BODY_NOT_AVAILABLE;\n       return false;\n     }\n \n@@ -445,7 +445,7 @@ cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n       if (n->global.insns >= MAX_INLINE_INSNS_SINGLE)\n \t{\n \t  if (reason)\n-\t    *reason = N_(\"--param max-inline-insns-single limit reached\");\n+\t    *reason = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  return false;\n \t}\n     }\n@@ -454,7 +454,7 @@ cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n       if (n->global.insns >= MAX_INLINE_INSNS_AUTO)\n \t{\n \t  if (reason)\n-\t    *reason = N_(\"--param max-inline-insns-auto limit reached\");\n+\t    *reason = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n \t  return false;\n \t}\n     }\n@@ -469,7 +469,7 @@ cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n static bool\n cgraph_recursive_inlining_p (struct cgraph_node *to,\n \t\t\t     struct cgraph_node *what,\n-\t\t\t     const char **reason)\n+\t\t\t     cgraph_inline_failed_t *reason)\n {\n   bool recursive;\n   if (to->global.inlined_to)\n@@ -480,7 +480,7 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n      not warn on it.  */\n   if (recursive && reason)\n     *reason = (what->local.disregard_inline_limits\n-\t       ? N_(\"recursive inlining\") : \"\");\n+\t       ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n   return recursive;\n }\n \n@@ -566,7 +566,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes)\n {\n   struct cgraph_edge *edge;\n-  const char *failed_reason;\n+  cgraph_inline_failed_t failed_reason;\n \n   if (!node->local.inlinable || node->local.disregard_inline_limits\n       || node->global.inlined_to)\n@@ -790,12 +790,14 @@ cgraph_decide_recursive_inlining (struct cgraph_node *node,\n /* Set inline_failed for all callers of given function to REASON.  */\n \n static void\n-cgraph_set_inline_failed (struct cgraph_node *node, const char *reason)\n+cgraph_set_inline_failed (struct cgraph_node *node,\n+\t\t\t  cgraph_inline_failed_t reason)\n {\n   struct cgraph_edge *e;\n \n   if (dump_file)\n-    fprintf (dump_file, \"Inlining failed: %s\\n\", reason);\n+    fprintf (dump_file, \"Inlining failed: %s\\n\",\n+\t     cgraph_inline_failed_string (reason));\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->inline_failed)\n       e->inline_failed = reason;\n@@ -840,7 +842,7 @@ cgraph_decide_inlining_of_small_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n-  const char *failed_reason;\n+  cgraph_inline_failed_t failed_reason;\n   fibheap_t heap = fibheap_new ();\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_insns, max_insns;\n@@ -887,7 +889,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       struct cgraph_node *where;\n       int growth =\n \tcgraph_estimate_size_after_inlining (1, edge->caller, edge->callee);\n-      const char *not_good = NULL;\n+      cgraph_inline_failed_t not_good = CIF_OK;\n \n       growth -= edge->caller->global.insns;\n \n@@ -939,28 +941,30 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  if (where->global.inlined_to)\n \t    {\n \t      edge->inline_failed\n-\t\t= (edge->callee->local.disregard_inline_limits ? N_(\"recursive inlining\") : \"\");\n+\t\t= (edge->callee->local.disregard_inline_limits\n+\t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" inline_failed:Recursive inlining performed only for function itself.\\n\");\n \t      continue;\n \t    }\n \t}\n \n       if (!cgraph_maybe_hot_edge_p (edge))\n- \tnot_good = N_(\"call is unlikely and code size would grow\");\n+ \tnot_good = CIF_UNLIKELY_CALL;\n       if (!flag_inline_functions\n \t  && !DECL_DECLARED_INLINE_P (edge->callee->decl))\n- \tnot_good = N_(\"function not declared inline and code size would grow\");\n+ \tnot_good = CIF_NOT_DECLARED_INLINED;\n       if (optimize_function_for_size_p (DECL_STRUCT_FUNCTION(edge->caller->decl)))\n- \tnot_good = N_(\"optimizing for size and code size would grow\");\n+ \tnot_good = CIF_OPTIMIZING_FOR_SIZE;\n       if (not_good && growth > 0 && cgraph_estimate_growth (edge->callee) > 0)\n \t{\n           if (!cgraph_recursive_inlining_p (edge->caller, edge->callee,\n \t\t\t\t            &edge->inline_failed))\n \t    {\n \t      edge->inline_failed = not_good;\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n+\t\tfprintf (dump_file, \" inline_failed:%s.\\n\",\n+\t\t\t cgraph_inline_failed_string (edge->inline_failed));\n \t    }\n \t  continue;\n \t}\n@@ -970,16 +974,18 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t\t\t            &edge->inline_failed))\n \t    {\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n+\t\tfprintf (dump_file, \" inline_failed:%s.\\n\",\n+\t\t\t cgraph_inline_failed_string (edge->inline_failed));\n \t    }\n \t  continue;\n \t}\n       if (!tree_can_inline_p (edge->caller->decl, edge->callee->decl))\n \t{\n \t  gimple_call_set_cannot_inline (edge->call_stmt, true);\n-\t  edge->inline_failed = N_(\"target specific option mismatch\");\n+\t  edge->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n+\t    fprintf (dump_file, \" inline_failed:%s.\\n\",\n+\t\t     cgraph_inline_failed_string (edge->inline_failed));\n \t  continue;\n \t}\n       if (cgraph_recursive_inlining_p (edge->caller, edge->callee,\n@@ -1005,7 +1011,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" Not inlining into %s:%s.\\n\",\n-\t\t\t cgraph_node_name (edge->caller), edge->inline_failed);\n+\t\t\t cgraph_node_name (edge->caller),\n+\t\t\t cgraph_inline_failed_string (edge->inline_failed));\n \t      continue;\n \t    }\n \t  callee = edge->callee;\n@@ -1053,7 +1060,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       if (!edge->callee->local.disregard_inline_limits && edge->inline_failed\n           && !cgraph_recursive_inlining_p (edge->caller, edge->callee,\n \t\t\t\t           &edge->inline_failed))\n-\tedge->inline_failed = N_(\"--param inline-unit-growth limit reached\");\n+\tedge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n     }\n \n   if (new_indirect_edges)\n@@ -1163,7 +1170,7 @@ cgraph_decide_inlining (void)\n \t     reason why inline failed.  */\n \t  for (e = node->callers; e; e = e->next_caller)\n \t    if (e->inline_failed)\n-\t      e->inline_failed = N_(\"recursive inlining\");\n+\t      e->inline_failed = CIF_RECURSIVE_INLINING;\n \t  if (dump_file)\n \t    fprintf (dump_file, \n \t\t     \" Inlined for a net change of %+i insns.\\n\",\n@@ -1289,7 +1296,7 @@ try_inline (struct cgraph_edge *e, enum inlining_mode mode, int depth)\n \t\t       cgraph_node_name (e->caller));\n \t    }\n \t  e->inline_failed = (e->callee->local.disregard_inline_limits\n-\t\t              ? N_(\"recursive inlining\") : \"\");\n+\t\t              ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n           return false;\n \t}\n     }\n@@ -1330,7 +1337,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n-  const char *failed_reason;\n+  cgraph_inline_failed_t failed_reason;\n   enum inlining_mode old_mode;\n \n #ifdef ENABLE_CHECKING\n@@ -1475,7 +1482,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    if (dump_file)\n \t      {\n \t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file, \"Not inlining: %s.\\n\", e->inline_failed);\n+\t\tfprintf (dump_file, \"Not inlining: %s.\\n\",\n+\t\t\t cgraph_inline_failed_string (e->inline_failed));\n \t      }\n \t    continue;\n \t  }"}, {"sha": "37d9098034fb3afb7e36df54321ea2539e373660", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a05df17ccd6fd0801571dae07309ca5236d9ec/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=61a05df17ccd6fd0801571dae07309ca5236d9ec", "patch": "@@ -3153,7 +3153,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n   tree modify_dest;\n   location_t saved_location;\n   struct cgraph_edge *cg_edge;\n-  const char *reason;\n+  cgraph_inline_failed_t reason;\n   basic_block return_block;\n   edge e;\n   gimple_stmt_iterator gsi, stmt_gsi;\n@@ -3218,7 +3218,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n       cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t  bb->count, CGRAPH_FREQ_BASE,\n \t\t\t  bb->loop_depth)->inline_failed\n-\t= N_(\"originally indirect function call not considered for inlining\");\n+\t= CIF_ORIGINALLY_INDIRECT_CALL;\n       if (dump_file)\n \t{\n \t   fprintf (dump_file, \"Created new direct edge to %s\",\n@@ -3241,18 +3241,19 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t  /* Avoid warnings during early inline pass. */\n \t  && cgraph_global_info_ready)\n \t{\n-\t  sorry (\"inlining failed in call to %q+F: %s\", fn, reason);\n+\t  sorry (\"inlining failed in call to %q+F: %s\", fn,\n+\t\t cgraph_inline_failed_string (reason));\n \t  sorry (\"called from here\");\n \t}\n       else if (warn_inline && DECL_DECLARED_INLINE_P (fn)\n \t       && !DECL_IN_SYSTEM_HEADER (fn)\n-\t       && strlen (reason)\n+\t       && reason != CIF_UNSPECIFIED\n \t       && !lookup_attribute (\"noinline\", DECL_ATTRIBUTES (fn))\n \t       /* Avoid warnings during early inline pass. */\n \t       && cgraph_global_info_ready)\n \t{\n \t  warning (OPT_Winline, \"inlining failed in call to %q+F: %s\",\n-\t\t   fn, reason);\n+\t\t   fn, cgraph_inline_failed_string (reason));\n \t  warning (OPT_Winline, \"called from here\");\n \t}\n       goto egress;"}]}