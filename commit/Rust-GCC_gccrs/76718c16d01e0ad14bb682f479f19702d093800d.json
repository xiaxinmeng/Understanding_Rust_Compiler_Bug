{"sha": "76718c16d01e0ad14bb682f479f19702d093800d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY3MThjMTZkMDFlMGFkMTRiYjY4MmY0NzlmMTk3MDJkMDkzODAwZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-30T09:46:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-30T09:46:19Z"}, "message": "ipa-inline.c (cgraph_estimate_growth): Discover self recursive functions.\n\n\n\t* ipa-inline.c (cgraph_estimate_growth): Discover self recursive\n\tfunctions.\n\t(cgraph_decide_inlining_of_small_function): Use edge->count to detect\n\tprofile presence locally.\n\nFrom-SVN: r139800", "tree": {"sha": "2acd1c50be0f353991823e0873d49d8c122e29d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2acd1c50be0f353991823e0873d49d8c122e29d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76718c16d01e0ad14bb682f479f19702d093800d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76718c16d01e0ad14bb682f479f19702d093800d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76718c16d01e0ad14bb682f479f19702d093800d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76718c16d01e0ad14bb682f479f19702d093800d/comments", "author": null, "committer": null, "parents": [{"sha": "21bacb7e151c93c5944d8645bb780693fc55f586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21bacb7e151c93c5944d8645bb780693fc55f586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21bacb7e151c93c5944d8645bb780693fc55f586"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "b712a12dec985259478369af0f9bd8118fb1e734", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76718c16d01e0ad14bb682f479f19702d093800d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76718c16d01e0ad14bb682f479f19702d093800d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76718c16d01e0ad14bb682f479f19702d093800d", "patch": "@@ -1,3 +1,10 @@\n+2008-08-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (cgraph_estimate_growth): Discover self recursive\n+\tfunctions.\n+\t(cgraph_decide_inlining_of_small_function): Use edge->count to detect\n+\tprofile presence locally.\n+\n 2008-08-29  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR bootstrap/37086"}, {"sha": "4c8096ae9b68ab188c73711aedf19558da9ae967", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76718c16d01e0ad14bb682f479f19702d093800d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76718c16d01e0ad14bb682f479f19702d093800d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=76718c16d01e0ad14bb682f479f19702d093800d", "patch": "@@ -318,18 +318,25 @@ cgraph_estimate_growth (struct cgraph_node *node)\n {\n   int growth = 0;\n   struct cgraph_edge *e;\n+  bool self_recursive = false;\n+\n   if (node->global.estimated_growth != INT_MIN)\n     return node->global.estimated_growth;\n \n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->inline_failed)\n-      growth += (cgraph_estimate_size_after_inlining (1, e->caller, node)\n-\t\t - e->caller->global.insns);\n+    {\n+      if (e->caller == node)\n+        self_recursive = true;\n+      if (e->inline_failed)\n+\tgrowth += (cgraph_estimate_size_after_inlining (1, e->caller, node)\n+\t\t   - e->caller->global.insns);\n+    }\n \n-  /* ??? Wrong for self recursive functions or cases where we decide to not\n-     inline for different reasons, but it is not big deal as in that case\n-     we will keep the body around, but we will also avoid some inlining.  */\n-  if (!node->needed && !DECL_EXTERNAL (node->decl))\n+  /* ??? Wrong for non-trivially self recursive functions or cases where\n+     we decide to not inline for different reasons, but it is not big deal\n+     as in that case we will keep the body around, but we will also avoid\n+     some inlining.  */\n+  if (!node->needed && !DECL_EXTERNAL (node->decl) && !self_recursive)\n     growth -= node->global.insns;\n \n   node->global.estimated_growth = growth;\n@@ -906,8 +913,13 @@ cgraph_decide_inlining_of_small_functions (void)\n \t is not good idea so prohibit the recursive inlining.\n \n \t ??? When the frequencies are taken into account we might not need this\n-\t restriction.   */\n-      if (!max_count)\n+\t restriction.\n+\n+\t We need to be cureful here, in some testcases, e.g. directivec.c in\n+\t libcpp, we can estimate self recursive function to have negative growth\n+\t for inlining completely.\n+\t */\n+      if (!edge->count)\n \t{\n \t  where = edge->caller;\n \t  while (where->global.inlined_to)"}]}