{"sha": "35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU4ODZmMGJkNGE4YmNiMWZlOGI1ZjYwZDc2ZmI5NGU1YTBkNGY5YQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-02-23T18:09:37Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-02-23T18:09:37Z"}, "message": "PR middle-end/69780 - [4.9/5/6 Regression] ICE on __builtin_alloca_with_align\n\nPR middle-end/69780 - [4.9/5/6 Regression] ICE on __builtin_alloca_with_align\n\twith small alignment\nPR c/69759 - __builtin_alloca and __builtin_alloca_with_align undocumented\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (check_builtin_function_arguments): Validate and reject\n\tinvalid arguments to __builtin_alloca_with_align.\n\ngcc/ChangeLog:\n\t* doc/extend.texi (Other Builtins): Document __builtin_alloca and\n\t__builtin_alloca_with_align.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/ext/builtin_alloca.C: New test.\n\t* gcc.dg/builtins-68.c: New test.\n\nFrom-SVN: r233640", "tree": {"sha": "31229d1c30f7097460a4e6ee71688919aa7913cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31229d1c30f7097460a4e6ee71688919aa7913cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "162cc7e3831881c28bf89902caf3287c377d4f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/162cc7e3831881c28bf89902caf3287c377d4f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/162cc7e3831881c28bf89902caf3287c377d4f8d"}], "stats": {"total": 434, "additions": 434, "deletions": 0}, "files": [{"sha": "3c629efaf11c9441d9cec87491821900f6813665", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -1,3 +1,9 @@\n+2016-02-23  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/69759\n+\t* doc/extend.texi (Other Builtins): Document __builtin_alloca and\n+\t__builtin_alloca_with_align.\n+\n 2016-02-23  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386-c.c (ix86_target_macros): Remove __SEG_TLS."}, {"sha": "66d74f402abc78cf944534b9cf146448a26f1e83", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -1,3 +1,9 @@\n+2016-02-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/69780\n+\t* c-common.c (check_builtin_function_arguments): Validate and\n+\treject invalid arguments to __builtin_alloca_with_align.\n+\n 2016-02-20  Mark Wielaard  <mjw@redhat.com>\n \n \tPR c/28901"}, {"sha": "71da6e9b472425b732f67c2ac96bce4052f671fb", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -9818,6 +9818,33 @@ check_builtin_function_arguments (tree fndecl, int nargs, tree *args)\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n+    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+      {\n+\t/* Get the requested alignment (in bits) if it's a constant\n+\t   integer expression.  */\n+\tunsigned HOST_WIDE_INT align\n+\t  = tree_fits_uhwi_p (args[1]) ? tree_to_uhwi (args[1]) : 0;\n+\n+\t/* Determine if the requested alignment is a power of 2.  */\n+\tif ((align & (align - 1)))\n+\t  align = 0;\n+\n+\t/* The maximum alignment in bits corresponding to the same\n+\t   maximum in bytes enforced in check_user_alignment().  */\n+\tunsigned maxalign = (UINT_MAX >> 1) + 1;\n+  \n+\t/* Reject invalid alignments.  */\n+\tif (align < BITS_PER_UNIT || maxalign < align)\n+\t  {\n+\t    error_at (EXPR_LOC_OR_LOC (args[1], input_location),\n+\t\t      \"second argument to function %qE must be a constant \"\n+\t\t      \"integer power of 2 between %qi and %qu bits\",\n+\t\t      fndecl, BITS_PER_UNIT, maxalign);\n+\t    return false;\n+\t  }\n+      return true;\n+      }\n+\n     case BUILT_IN_CONSTANT_P:\n       return builtin_function_validate_nargs (fndecl, nargs, 1);\n "}, {"sha": "10a42b6ceca9aec7be345545656ba7bf75f38752", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -10127,6 +10127,8 @@ in the Cilk Plus language manual which can be found at\n @node Other Builtins\n @section Other Built-in Functions Provided by GCC\n @cindex built-in functions\n+@findex __builtin_alloca\n+@findex __builtin_alloca_with_align\n @findex __builtin_call_with_static_chain\n @findex __builtin_fpclassify\n @findex __builtin_isfinite\n@@ -10673,6 +10675,92 @@ In the same fashion, GCC provides @code{fpclassify}, @code{isfinite},\n @code{__builtin_} prefixed.  The @code{isinf} and @code{isnan}\n built-in functions appear both with and without the @code{__builtin_} prefix.\n \n+@deftypefn {Built-in Function} void *__builtin_alloca (size_t size)\n+The @code{__builtin_alloca} function must be called at block scope.\n+The function allocates an object @var{size} bytes large on the stack\n+of the calling function.  The object is aligned on the default stack\n+alignment boundary for the target determined by the\n+@code{__BIGGEST_ALIGNMENT__} macro.  The @code{__builtin_alloca}\n+function returns a pointer to the first byte of the allocated object.\n+The lifetime of the allocated object ends just before the calling\n+function returns to its caller.   This is so even when\n+@code{__builtin_alloca} is called within a nested block.\n+\n+For example, the following function allocates eight objects of @code{n}\n+bytes each on the stack, storing a pointer to each in consecutive elements\n+of the array @code{a}.  It then passes the array to function @code{g}\n+which can safely use the storage pointed to by each of the array elements.\n+\n+@smallexample\n+void f (unsigned n)\n+@{\n+  void *a [8];\n+  for (int i = 0; i != 8; ++i)\n+    a [i] = __builtin_alloca (n);\n+\n+  g (a, n);   // @r{safe}\n+@}\n+@end smallexample\n+\n+Since the @code{__builtin_alloca} function doesn't validate its argument\n+it is the responsibility of its caller to make sure the argument doesn't\n+cause it to exceed the stack size limit.\n+The @code{__builtin_alloca} function is provided to make it possible to\n+allocate on the stack arrays of bytes with an upper bound that may be\n+computed at run time.  Since C99 @xref{Variable Length} Arrays offer\n+similar functionality under a portable, more convenient, and safer\n+interface they are recommended instead, in both C99 and C++ programs\n+where GCC provides them as an extension.\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void *__builtin_alloca_with_align (size_t size, size_t alignment)\n+The @code{__builtin_alloca_with_align} function must be called at block\n+scope.  The function allocates an object @var{size} bytes large on\n+the stack of the calling function.  The allocated object is aligned on\n+the boundary specified by the argument @var{alignment} whose unit is given\n+in bits (not bytes).  The @var{size} argument must be positive and not\n+exceed the stack size limit.  The @var{alignment} argument must be a constant\n+integer expression that evaluates to a power of 2 greater than or equal to\n+@code{CHAR_BIT} and less than some unspecified maximum.  Invocations\n+with other values are rejected with an error indicating the valid bounds.\n+The function returns a pointer to the first byte of the allocated object.\n+The lifetime of the allocated object ends at the end of the block in which\n+the function was called.  The allocated storage is released no later than\n+just before the calling function returns to its caller, but may be released\n+at the end of the block in which the function was called.\n+\n+For example, in the following function the call to @code{g} is unsafe\n+because when @code{overalign} is non-zero, the space allocated by\n+@code{__builtin_alloca_with_align} may have been released at the end\n+of the @code{if} statement in which it was called.\n+\n+@smallexample\n+void f (unsigned n, bool overalign)\n+@{\n+  void *p;\n+  if (overalign)\n+    p = __builtin_alloca_with_align (n, 64 /* bits */);\n+  else\n+    p = __builtin_alloc (n);\n+\n+  g (p, n);   // @r{unsafe}\n+@}\n+@end smallexample\n+\n+Since the @code{__builtin_alloca_with_align} function doesn't validate its\n+@var{size} argument it is the responsibility of its caller to make sure\n+the argument doesn't cause it to exceed the stack size limit.\n+The @code{__builtin_alloca_with_align} function is provided to make\n+it possible to allocate on the stack overaligned arrays of bytes with\n+an upper bound that may be computed at run time.  Since C99\n+@xref{Variable Length} Arrays offer the same functionality under\n+a portable, more convenient, and safer interface they are recommended\n+instead, in both C99 and C++ programs where GCC provides them as\n+an extension.\n+\n+@end deftypefn\n+\n @deftypefn {Built-in Function} int __builtin_types_compatible_p (@var{type1}, @var{type2})\n \n You can use the built-in function @code{__builtin_types_compatible_p} to"}, {"sha": "9fa77b1c47a460ec7013710c2d9d99db61071ded", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -1,3 +1,9 @@\n+2016-02-23  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/69780\n+\t* g++.dg/ext/builtin_alloca.C: New test.\n+\t* gcc.dg/builtins-68.c: New test.\n+\n 2016-02-23  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.target/i386/addr-space-3.c: Remove test."}, {"sha": "10a9bdce474b22d22fb6ec44b598a83e2657878c", "filename": "gcc/testsuite/g++.dg/ext/builtin_alloca.C", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin_alloca.C?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -0,0 +1,191 @@\n+// PR middle-end/69780 - [4.9/5/6 Regression] ICE on\n+//     __builtin_alloca_with_align with small alignment\n+// { dg-require-effective-target alloca }\n+// { dg-do compile }\n+\n+#define CHAR_BIT  __CHAR_BIT__\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+#define LONG_MAX  __LONG_MAX__\n+#define LLONG_MAX __LONG_LONG_MAX__\n+\n+static void* p;\n+\n+// Verify that valid __builtin_alloca_with_align expressions are accepted.\n+void test_valid (int n)\n+{\n+  enum {\n+    A1   = CHAR_BIT *   1,\n+    A2   = CHAR_BIT *   2,\n+    A4   = CHAR_BIT *   4,\n+    A8   = CHAR_BIT *   8,\n+    A16  = CHAR_BIT *  16,\n+    A32  = CHAR_BIT *  32\n+  };\n+\n+  const int a1 = A1;\n+  const int a2 = A2;\n+  const int a4 = A4;\n+  const int a8 = A8;\n+  const int a16 = A16;\n+  const int a32 = A32;\n+\n+  // Valid alignments are power of 2 positive multiples of CHAR_BIT.\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  1);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  2);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  4);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  8);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT * 16);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT * 32);\n+\n+  p =  __builtin_alloca_with_align (n, A1);\n+  p =  __builtin_alloca_with_align (n, A2);\n+  p =  __builtin_alloca_with_align (n, A4);\n+  p =  __builtin_alloca_with_align (n, A8);\n+  p =  __builtin_alloca_with_align (n, A16);\n+  p =  __builtin_alloca_with_align (n, A32);\n+\n+  p =  __builtin_alloca_with_align (n, a1);\n+  p =  __builtin_alloca_with_align (n, a2);\n+  p =  __builtin_alloca_with_align (n, a4);\n+  p =  __builtin_alloca_with_align (n, a8);\n+  p =  __builtin_alloca_with_align (n, a16);\n+  p =  __builtin_alloca_with_align (n, a32);\n+}\n+\n+template <int A> struct X { enum { Align = A }; };\n+\n+template <int A>\n+void test_valid_template (int n)\n+{\n+  // Valid alignments are power of 2 positive multiples of CHAR_BIT.\n+  p =  __builtin_alloca_with_align (n, A);\n+}\n+\n+template void test_valid_template<CHAR_BIT>(int);\n+template void test_valid_template<CHAR_BIT * 2>(int);\n+template void test_valid_template<CHAR_BIT * 4>(int);\n+template void test_valid_template<CHAR_BIT * 8>(int);\n+template void test_valid_template<CHAR_BIT * 16>(int);\n+template void test_valid_template<CHAR_BIT * 32>(int);\n+\n+// Exercise the alignment in a dependent context.\n+template <int A>\n+void test_valid_template_dep (int n)\n+{\n+  // Valid alignments are power of 2 positive multiples of CHAR_BIT.\n+  p =  __builtin_alloca_with_align (n, X<A>::Align);\n+}\n+\n+template void test_valid_template_dep<CHAR_BIT>(int);\n+template void test_valid_template_dep<CHAR_BIT * 2>(int);\n+template void test_valid_template_dep<CHAR_BIT * 4>(int);\n+template void test_valid_template_dep<CHAR_BIT * 8>(int);\n+template void test_valid_template_dep<CHAR_BIT * 16>(int);\n+template void test_valid_template_dep<CHAR_BIT * 32>(int);\n+\n+// Invalid size must be rejected (and not cause an ICE).\n+void test_arg1_non_int (int n)\n+{\n+  extern void f ();\n+\n+  p =  __builtin_alloca_with_align ((void*)0, 32);   // { dg-error \"invalid conversion\" }\n+\n+  p =  __builtin_alloca_with_align (\"\", 32);         // { dg-error \"invalid conversion\" }\n+  p =  __builtin_alloca_with_align (L\"\", 32);        // { dg-error \"invalid conversion\" }\n+  p =  __builtin_alloca_with_align (f, 32);          // { dg-error \"invalid conversion\" }\n+}\n+\n+// Non-integer alignment must be rejected.\n+void test_arg2_non_int (int n)\n+{\n+  // Verify the full text of the diagnostic just once.\n+  p =  __builtin_alloca_with_align (n, 0.0);         // { dg-error \"second argument to function .__builtin_alloca_with_align. must be a constant integer power of 2 between .8. and \" }\n+\n+  p =  __builtin_alloca_with_align (n, (void*)0);    // { dg-error \"invalid conversion|must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, \"\");          // { dg-error \"invalid conversion|must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, L\"\");         // { dg-error \"invalid conversion|must be a constant integer\" }\n+}\n+\n+// Integer alignment that's not a constant expression must be rejected.\n+void test_arg2_non_const (int n, int a1)\n+{\n+  extern const int a2;\n+  static volatile const int a3 = CHAR_BIT;\n+  \n+  p =  __builtin_alloca_with_align (n, a1);       // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, a2);       // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, a3);       // { dg-error \"must be a constant integer\" }\n+}\n+\n+// Constant integer alignment that's not a power of 2 positive multiple\n+// of CHAR_BIT must be rejected.\n+void test_arg2_non_pow2 (int n)\n+{\n+  p =  __builtin_alloca_with_align (n, INT_MIN);     // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, -1);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, !1);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, !0);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  0);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  1);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  2);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  3);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  4);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  5);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  6);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  7);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n,  9);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 10);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 11);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 12);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 13);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 14);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 15);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 17);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 31);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 33);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 63);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 65);          // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, INT_MAX);     // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, ~0U);         // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, LONG_MAX);    // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, ~0LU);        // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, 1LLU << 34);  // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, LLONG_MAX);   // { dg-error \"must be a constant integer\" }\n+  p =  __builtin_alloca_with_align (n, ~0LLU);       // { dg-error \"must be a constant integer\" }\n+}\n+\n+// Exercise invalid alignment specified by a template argument.\n+template <int A>\n+void test_invalid_template_1 (int n)\n+{\n+  // Valid alignments are power of 2 positive multiples of CHAR_BIT.\n+  p =  __builtin_alloca_with_align (n, A);           // { dg-error \"must be a constant integer\" }\n+}\n+\n+template void test_invalid_template_1<1>(int);\n+\n+template <int A>\n+void test_invalid_template_7 (int n)\n+{\n+  p =  __builtin_alloca_with_align (n, A);           // { dg-error \"must be a constant integer\" }\n+}\n+\n+template void test_invalid_template_7<7>(int);\n+\n+template <int A>\n+void test_invalid_template_9 (int n)\n+{\n+  p =  __builtin_alloca_with_align (n, A);           // { dg-error \"must be a constant integer\" }\n+}\n+\n+template void test_invalid_template_9<9>(int);\n+\n+// Exercise invalid alignment specified by a template dependent argument.\n+template <int A>\n+void test_invalid_template_dep_1 (int n)\n+{\n+  p =  __builtin_alloca_with_align (n, X<A>::Align);     // { dg-error \"must be a constant integer\" }\n+}\n+\n+template void test_invalid_template_dep_1<1>(int);"}, {"sha": "d2e65d08060191d096eeb54a5b05b1b784a827c7", "filename": "gcc/testsuite/gcc.dg/builtins-68.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-68.c?ref=35886f0bd4a8bcb1fe8b5f60d76fb94e5a0d4f9a", "patch": "@@ -0,0 +1,110 @@\n+/* PR middle-end/69780 - [4.9/5/6 Regression] ICE on\n+     __builtin_alloca_with_align with small alignment */\n+/* { dg-require-effective-target alloca } */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wno-long-long\" } */\n+\n+#define CHAR_BIT  __CHAR_BIT__\n+#define INT_MAX   __INT_MAX__\n+#define INT_MIN   (-INT_MAX - 1)\n+#define LONG_MAX  __LONG_MAX__\n+#define LLONG_MAX __LONG_LONG_MAX__\n+\n+static void* p;\n+\n+/* Verify that valid __builtin_alloca_with_align expressions are accepted.  */\n+void test_valid (int n)\n+{\n+  enum {\n+    A1   = CHAR_BIT *   1,\n+    A2   = CHAR_BIT *   2,\n+    A4   = CHAR_BIT *   4,\n+    A8   = CHAR_BIT *   8,\n+    A16  = CHAR_BIT *  16,\n+    A32  = CHAR_BIT *  32\n+  };\n+\n+  /* Valid alignments are power of 2 positive multiples of CHAR_BIT.  */\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  1);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  2);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  4);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT *  8);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT * 16);\n+  p =  __builtin_alloca_with_align (n, CHAR_BIT * 32);\n+\n+  p =  __builtin_alloca_with_align (n, A1);\n+  p =  __builtin_alloca_with_align (n, A2);\n+  p =  __builtin_alloca_with_align (n, A4);\n+  p =  __builtin_alloca_with_align (n, A8);\n+  p =  __builtin_alloca_with_align (n, A16);\n+  p =  __builtin_alloca_with_align (n, A32);\n+}\n+\n+/* Non-integer alignments must be rejected.  */\n+void test_arg2_non_int (int n)\n+{\n+  /* Verify the full text of the diagnostic just once.  */\n+  p =  __builtin_alloca_with_align (n, 0.0);         /* { dg-error \"second argument to function .__builtin_alloca_with_align. must be a constant integer power of 2 between .8. and \" } */\n+\n+  /* Disable diagnostic complaining about converting void* to int that\n+     preempts the \"constant integer expression\" error.  */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wint-conversion\"\n+\n+  p =  __builtin_alloca_with_align (n, (void*)0);    /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, \"\");          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, L\"\");         /* { dg-error \"must be a constant integer\" } */\n+\n+#pragma GCC diagnostic pop\n+\n+}\n+\n+/* Integer alignment that's not a constant expression must be rejected.  */\n+void test_arg2_non_const (int n, int a1)\n+{\n+  extern const int a2;\n+  static const int a3 = CHAR_BIT;\n+  static volatile const int a4 = CHAR_BIT;\n+  \n+  p =  __builtin_alloca_with_align (n, a1);       /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, a2);       /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, a3);       /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, a4);       /* { dg-error \"must be a constant integer\" } */\n+}\n+\n+/* Constant integer alignment that's not a power of 2 positive multiple\n+   of CHAR_BIT less than (1LLU << 32) must be rejected.  */\n+void test_arg2_non_pow2 (int n)\n+{\n+  p =  __builtin_alloca_with_align (n, INT_MIN);     /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, -1);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, !1);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, !0);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  0);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  1);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  2);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  3);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  4);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  5);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  6);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  7);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n,  9);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 10);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 11);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 12);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 13);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 14);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 15);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 17);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 31);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 33);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 63);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 65);          /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, INT_MAX);     /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, ~0U);         /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, LONG_MAX);    /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, ~0LU);        /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, 1LLU << 34);  /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, LLONG_MAX);   /* { dg-error \"must be a constant integer\" } */\n+  p =  __builtin_alloca_with_align (n, ~0LLU);       /* { dg-error \"must be a constant integer\" } */\n+}"}]}