{"sha": "59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlkNTk2MGNkYmEzZmIxYmQ4ZDljMjM0ZmMzNmZiNjM0YjNlOWFiMg==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2018-12-28T11:34:14Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2018-12-28T11:34:14Z"}, "message": "For libgomp OpenACC entry points, redefine the \"device\" argument to \"flags\"\n\n... so that we're then able to use this for other flags in addition to\n\"GOACC_FLAG_HOST_FALLBACK\".\n\n\tgcc/\n\t* omp-expand.c (expand_omp_target): Restructure OpenACC vs. OpenMP\n\tcode paths.  Update for libgomp OpenACC entry points change.\n\tinclude/\n\t* gomp-constants.h (GOACC_FLAG_HOST_FALLBACK)\n\t(GOACC_FLAGS_MARSHAL_OP, GOACC_FLAGS_UNMARSHAL): Define.\n\tlibgomp/\n\t* oacc-parallel.c (GOACC_parallel_keyed, GOACC_parallel)\n\t(GOACC_data_start, GOACC_enter_exit_data, GOACC_update)\n\t(GOACC_declare): Redefine the \"device\" argument to \"flags\".\n\nFrom-SVN: r267448", "tree": {"sha": "4a94d5d6765f11cca6f5d093ef0afa7a5c98b934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a94d5d6765f11cca6f5d093ef0afa7a5c98b934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a12987e79513b46d317c6973555c582ba4da895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a12987e79513b46d317c6973555c582ba4da895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a12987e79513b46d317c6973555c582ba4da895"}], "stats": {"total": 197, "additions": 136, "deletions": 61}, "files": [{"sha": "741c02d6cdaec143a49d258ca6399b49678ef802", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -1,3 +1,8 @@\n+2018-12-28  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* omp-expand.c (expand_omp_target): Restructure OpenACC vs. OpenMP\n+\tcode paths.  Update for libgomp OpenACC entry points change.\n+\n 2018-12-28  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>\n "}, {"sha": "79bc9acb7711048a182911da7dfb6b39e4c400a7", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 73, "deletions": 40, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -7496,9 +7496,8 @@ expand_omp_target (struct omp_region *region)\n \n   /* Emit a library call to launch the offloading region, or do data\n      transfers.  */\n-  tree t1, t2, t3, t4, device, cond, depend, c, clauses;\n+  tree t1, t2, t3, t4, depend, c, clauses;\n   enum built_in_function start_ix;\n-  location_t clause_loc;\n   unsigned int flags_i = 0;\n \n   switch (gimple_omp_target_kind (entry_stmt))\n@@ -7542,49 +7541,63 @@ expand_omp_target (struct omp_region *region)\n \n   clauses = gimple_omp_target_clauses (entry_stmt);\n \n-  /* By default, the value of DEVICE is GOMP_DEVICE_ICV (let runtime\n-     library choose) and there is no conditional.  */\n-  cond = NULL_TREE;\n-  device = build_int_cst (integer_type_node, GOMP_DEVICE_ICV);\n-\n-  c = omp_find_clause (clauses, OMP_CLAUSE_IF);\n-  if (c)\n-    cond = OMP_CLAUSE_IF_EXPR (c);\n-\n-  c = omp_find_clause (clauses, OMP_CLAUSE_DEVICE);\n-  if (c)\n+  tree device = NULL_TREE;\n+  location_t device_loc = UNKNOWN_LOCATION;\n+  tree goacc_flags = NULL_TREE;\n+  if (is_gimple_omp_oacc (entry_stmt))\n     {\n-      /* Even if we pass it to all library function calls, it is currently only\n-\t defined/used for the OpenMP target ones.  */\n-      gcc_checking_assert (start_ix == BUILT_IN_GOMP_TARGET\n-\t\t\t   || start_ix == BUILT_IN_GOMP_TARGET_DATA\n-\t\t\t   || start_ix == BUILT_IN_GOMP_TARGET_UPDATE\n-\t\t\t   || start_ix == BUILT_IN_GOMP_TARGET_ENTER_EXIT_DATA);\n-\n-      device = OMP_CLAUSE_DEVICE_ID (c);\n-      clause_loc = OMP_CLAUSE_LOCATION (c);\n+      /* By default, no GOACC_FLAGs are set.  */\n+      goacc_flags = integer_zero_node;\n     }\n   else\n-    clause_loc = gimple_location (entry_stmt);\n-\n-  c = omp_find_clause (clauses, OMP_CLAUSE_NOWAIT);\n-  if (c)\n-    flags_i |= GOMP_TARGET_FLAG_NOWAIT;\n+    {\n+      c = omp_find_clause (clauses, OMP_CLAUSE_DEVICE);\n+      if (c)\n+\t{\n+\t  device = OMP_CLAUSE_DEVICE_ID (c);\n+\t  device_loc = OMP_CLAUSE_LOCATION (c);\n+\t}\n+      else\n+\t{\n+\t  /* By default, the value of DEVICE is GOMP_DEVICE_ICV (let runtime\n+\t     library choose).  */\n+\t  device = build_int_cst (integer_type_node, GOMP_DEVICE_ICV);\n+\t  device_loc = gimple_location (entry_stmt);\n+\t}\n \n-  /* Ensure 'device' is of the correct type.  */\n-  device = fold_convert_loc (clause_loc, integer_type_node, device);\n+      c = omp_find_clause (clauses, OMP_CLAUSE_NOWAIT);\n+      if (c)\n+\tflags_i |= GOMP_TARGET_FLAG_NOWAIT;\n+    }\n \n-  /* If we found the clause 'if (cond)', build\n-     (cond ? device : GOMP_DEVICE_HOST_FALLBACK).  */\n+  /* By default, there is no conditional.  */\n+  tree cond = NULL_TREE;\n+  c = omp_find_clause (clauses, OMP_CLAUSE_IF);\n+  if (c)\n+    cond = OMP_CLAUSE_IF_EXPR (c);\n+  /* If we found the clause 'if (cond)', build:\n+     OpenACC: goacc_flags = (cond ? goacc_flags : flags | GOACC_FLAG_HOST_FALLBACK)\n+     OpenMP: device = (cond ? device : GOMP_DEVICE_HOST_FALLBACK) */\n   if (cond)\n     {\n+      tree *tp;\n+      if (is_gimple_omp_oacc (entry_stmt))\n+\ttp = &goacc_flags;\n+      else\n+\t{\n+\t  /* Ensure 'device' is of the correct type.  */\n+\t  device = fold_convert_loc (device_loc, integer_type_node, device);\n+\n+\t  tp = &device;\n+\t}\n+\n       cond = gimple_boolify (cond);\n \n       basic_block cond_bb, then_bb, else_bb;\n       edge e;\n       tree tmp_var;\n \n-      tmp_var = create_tmp_var (TREE_TYPE (device));\n+      tmp_var = create_tmp_var (TREE_TYPE (*tp));\n       if (offloaded)\n \te = split_block_after_labels (new_bb);\n       else\n@@ -7607,13 +7620,20 @@ expand_omp_target (struct omp_region *region)\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n       gsi = gsi_start_bb (then_bb);\n-      stmt = gimple_build_assign (tmp_var, device);\n+      stmt = gimple_build_assign (tmp_var, *tp);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n       gsi = gsi_start_bb (else_bb);\n-      stmt = gimple_build_assign (tmp_var,\n-\t\t\t\t  build_int_cst (integer_type_node,\n-\t\t\t\t\t\t GOMP_DEVICE_HOST_FALLBACK));\n+      if (is_gimple_omp_oacc (entry_stmt))\n+\tstmt = gimple_build_assign (tmp_var,\n+\t\t\t\t    BIT_IOR_EXPR,\n+\t\t\t\t    *tp,\n+\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t   GOACC_FLAG_HOST_FALLBACK));\n+      else\n+\tstmt = gimple_build_assign (tmp_var,\n+\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t   GOMP_DEVICE_HOST_FALLBACK));\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n       make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n@@ -7623,14 +7643,17 @@ expand_omp_target (struct omp_region *region)\n       make_edge (then_bb, new_bb, EDGE_FALLTHRU);\n       make_edge (else_bb, new_bb, EDGE_FALLTHRU);\n \n-      device = tmp_var;\n+      *tp = tmp_var;\n+\n       gsi = gsi_last_nondebug_bb (new_bb);\n     }\n   else\n     {\n       gsi = gsi_last_nondebug_bb (new_bb);\n-      device = force_gimple_operand_gsi (&gsi, device, true, NULL_TREE,\n-\t\t\t\t\t true, GSI_SAME_STMT);\n+\n+      if (device != NULL_TREE)\n+\tdevice = force_gimple_operand_gsi (&gsi, device, true, NULL_TREE,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n     }\n \n   t = gimple_omp_target_data_arg (entry_stmt);\n@@ -7654,7 +7677,17 @@ expand_omp_target (struct omp_region *region)\n   bool tagging = false;\n   /* The maximum number used by any start_ix, without varargs.  */\n   auto_vec<tree, 11> args;\n-  args.quick_push (device);\n+  if (is_gimple_omp_oacc (entry_stmt))\n+    {\n+      tree goacc_flags_m = fold_build1 (GOACC_FLAGS_MARSHAL_OP,\n+\t\t\t\t\tTREE_TYPE (goacc_flags), goacc_flags);\n+      goacc_flags_m = force_gimple_operand_gsi (&gsi, goacc_flags_m, true,\n+\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\tGSI_SAME_STMT);\n+      args.quick_push (goacc_flags_m);\n+    }\n+  else\n+    args.quick_push (device);\n   if (offloaded)\n     args.quick_push (build_fold_addr_expr (child_fn));\n   args.quick_push (t1);"}, {"sha": "cfdfb50854f0cd925c4c8fd704956f0bee259542", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -4697,7 +4697,7 @@ find_func_aliases_for_builtin_call (struct function *fn, gcall *t)\n \t\t  argpos = 1;\n \t\t  break;\n \t\tcase BUILT_IN_GOACC_PARALLEL:\n-\t\t  /* __builtin_GOACC_parallel (device, fn, mapnum, hostaddrs,\n+\t\t  /* __builtin_GOACC_parallel (flags_m, fn, mapnum, hostaddrs,\n \t\t\t\t\t       sizes, kinds, ...).  */\n \t\t  fnpos = 1;\n \t\t  argpos = 3;\n@@ -5255,7 +5255,7 @@ find_func_clobbers (struct function *fn, gimple *origt)\n \t\t  argpos = 1;\n \t\t  break;\n \t\tcase BUILT_IN_GOACC_PARALLEL:\n-\t\t  /* __builtin_GOACC_parallel (device, fn, mapnum, hostaddrs,\n+\t\t  /* __builtin_GOACC_parallel (flags_m, fn, mapnum, hostaddrs,\n \t\t\t\t\t       sizes, kinds, ...).  */\n \t\t  fnpos = 1;\n \t\t  argpos = 3;"}, {"sha": "886e9a6ca35c6d84a6e0ca6091e12643c9ce76af", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -1,3 +1,8 @@\n+2018-12-28  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* gomp-constants.h (GOACC_FLAG_HOST_FALLBACK)\n+\t(GOACC_FLAGS_MARSHAL_OP, GOACC_FLAGS_UNMARSHAL): Define.\n+\n 2018-12-22  Jason Merrill  <jason@redhat.com>\n \n \t* demangle.h: Remove support for ancient GNU (pre-3.0), Lucid,"}, {"sha": "b6b6733bd8756074bd092d75b46c2db4d6ea1835", "filename": "include/gomp-constants.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -197,6 +197,18 @@ enum gomp_map_kind\n /* Internal to libgomp.  */\n #define GOMP_TARGET_FLAG_UPDATE\t\t(1U << 31)\n \n+\n+/* OpenACC construct flags.  */\n+\n+/* Force host fallback execution.  */\n+#define GOACC_FLAG_HOST_FALLBACK\t(1 << 0)\n+\n+/* For legacy reasons, in the ABI, the GOACC_FLAGs are encoded as an inverted\n+   bitmask.  */\n+#define GOACC_FLAGS_MARSHAL_OP\t\tBIT_NOT_EXPR\n+#define GOACC_FLAGS_UNMARSHAL(X)\t(~(X))\n+\n+\n /* Versions of libgomp and device-specific plugins.  GOMP_VERSION\n    should be incremented whenever an ABI-incompatible change is introduced\n    to the plugin interface defined in libgomp/libgomp.h.  */"}, {"sha": "aa69f42d3ca0b18168702bc4a3a5c9da78f3416c", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -1,3 +1,9 @@\n+2018-12-28  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* oacc-parallel.c (GOACC_parallel_keyed, GOACC_parallel)\n+\t(GOACC_data_start, GOACC_enter_exit_data, GOACC_update)\n+\t(GOACC_declare): Redefine the \"device\" argument to \"flags\".\n+\n 2018-12-28  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "57bd484ba8a1b8e6c9417f424aa3be37a0aefd99", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=59d5960cdba3fb1bd8d9c234fc36fb634b3e9ab2", "patch": "@@ -38,6 +38,16 @@\n #include <stdarg.h>\n #include <assert.h>\n \n+\n+/* In the ABI, the GOACC_FLAGs are encoded as an inverted bitmask, so that we\n+   continue to support the following two legacy values.  */\n+_Static_assert (GOACC_FLAGS_UNMARSHAL (GOMP_DEVICE_ICV) == 0,\n+\t\t\"legacy GOMP_DEVICE_ICV broken\");\n+_Static_assert (GOACC_FLAGS_UNMARSHAL (GOMP_DEVICE_HOST_FALLBACK)\n+\t\t== GOACC_FLAG_HOST_FALLBACK,\n+\t\t\"legacy GOMP_DEVICE_HOST_FALLBACK broken\");\n+\n+\n /* Returns the number of mappings associated with the pointer or pset. PSET\n    have three mappings, whereas pointer have two.  */\n \n@@ -105,17 +115,18 @@ handle_ftn_pointers (size_t mapnum, void **hostaddrs, size_t *sizes,\n static void goacc_wait (int async, int num_waits, va_list *ap);\n \n \n-/* Launch a possibly offloaded function on DEVICE.  FN is the host fn\n+/* Launch a possibly offloaded function with FLAGS.  FN is the host fn\n    address.  MAPNUM, HOSTADDRS, SIZES & KINDS  describe the memory\n    blocks to be copied to/from the device.  Varadic arguments are\n    keyed optional parameters terminated with a zero.  */\n \n void\n-GOACC_parallel_keyed (int device, void (*fn) (void *),\n+GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \t\t      size_t mapnum, void **hostaddrs, size_t *sizes,\n \t\t      unsigned short *kinds, ...)\n {\n-  bool host_fallback = device == GOMP_DEVICE_HOST_FALLBACK;\n+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n+\n   va_list ap;\n   struct goacc_thread *thr;\n   struct gomp_device_descr *acc_dev;\n@@ -145,7 +156,7 @@ GOACC_parallel_keyed (int device, void (*fn) (void *),\n \n   /* Host fallback if \"if\" clause is false or if the current device is set to\n      the host.  */\n-  if (host_fallback)\n+  if (flags & GOACC_FLAG_HOST_FALLBACK)\n     {\n       goacc_save_and_set_bind (acc_device_host);\n       fn (hostaddrs);\n@@ -269,7 +280,7 @@ GOACC_parallel_keyed (int device, void (*fn) (void *),\n /* Legacy entry point, only provide host execution.  */\n \n void\n-GOACC_parallel (int device, void (*fn) (void *),\n+GOACC_parallel (int flags_m, void (*fn) (void *),\n \t\tsize_t mapnum, void **hostaddrs, size_t *sizes,\n \t\tunsigned short *kinds,\n \t\tint num_gangs, int num_workers, int vector_length,\n@@ -281,10 +292,11 @@ GOACC_parallel (int device, void (*fn) (void *),\n }\n \n void\n-GOACC_data_start (int device, size_t mapnum,\n+GOACC_data_start (int flags_m, size_t mapnum,\n \t\t  void **hostaddrs, size_t *sizes, unsigned short *kinds)\n {\n-  bool host_fallback = device == GOMP_DEVICE_HOST_FALLBACK;\n+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n+\n   struct target_mem_desc *tgt;\n \n #ifdef HAVE_INTTYPES_H\n@@ -302,7 +314,7 @@ GOACC_data_start (int device, size_t mapnum,\n \n   /* Host fallback or 'do nothing'.  */\n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-      || host_fallback)\n+      || (flags & GOACC_FLAG_HOST_FALLBACK))\n     {\n       tgt = gomp_map_vars (NULL, 0, NULL, NULL, NULL, NULL, true,\n \t\t\t   GOMP_MAP_VARS_OPENACC);\n@@ -333,13 +345,14 @@ GOACC_data_end (void)\n }\n \n void\n-GOACC_enter_exit_data (int device, size_t mapnum,\n+GOACC_enter_exit_data (int flags_m, size_t mapnum,\n \t\t       void **hostaddrs, size_t *sizes, unsigned short *kinds,\n \t\t       int async, int num_waits, ...)\n {\n+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n+\n   struct goacc_thread *thr;\n   struct gomp_device_descr *acc_dev;\n-  bool host_fallback = device == GOMP_DEVICE_HOST_FALLBACK;\n   bool data_enter = false;\n   size_t i;\n \n@@ -349,7 +362,7 @@ GOACC_enter_exit_data (int device, size_t mapnum,\n   acc_dev = thr->dev;\n \n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-      || host_fallback)\n+      || (flags & GOACC_FLAG_HOST_FALLBACK))\n     return;\n \n   if (num_waits)\n@@ -523,11 +536,12 @@ goacc_wait (int async, int num_waits, va_list *ap)\n }\n \n void\n-GOACC_update (int device, size_t mapnum,\n+GOACC_update (int flags_m, size_t mapnum,\n \t      void **hostaddrs, size_t *sizes, unsigned short *kinds,\n \t      int async, int num_waits, ...)\n {\n-  bool host_fallback = device == GOMP_DEVICE_HOST_FALLBACK;\n+  int flags = GOACC_FLAGS_UNMARSHAL (flags_m);\n+\n   size_t i;\n \n   goacc_lazy_initialize ();\n@@ -536,7 +550,7 @@ GOACC_update (int device, size_t mapnum,\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n   if ((acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-      || host_fallback)\n+      || (flags & GOACC_FLAG_HOST_FALLBACK))\n     return;\n \n   if (num_waits)\n@@ -643,7 +657,7 @@ GOACC_get_thread_num (void)\n }\n \n void\n-GOACC_declare (int device, size_t mapnum,\n+GOACC_declare (int flags_m, size_t mapnum,\n \t       void **hostaddrs, size_t *sizes, unsigned short *kinds)\n {\n   int i;\n@@ -663,7 +677,7 @@ GOACC_declare (int device, size_t mapnum,\n \t  case GOMP_MAP_POINTER:\n \t  case GOMP_MAP_RELEASE:\n \t  case GOMP_MAP_DELETE:\n-\t    GOACC_enter_exit_data (device, 1, &hostaddrs[i], &sizes[i],\n+\t    GOACC_enter_exit_data (flags_m, 1, &hostaddrs[i], &sizes[i],\n \t\t\t\t   &kinds[i], GOMP_ASYNC_SYNC, 0);\n \t    break;\n \n@@ -672,18 +686,18 @@ GOACC_declare (int device, size_t mapnum,\n \n \t  case GOMP_MAP_ALLOC:\n \t    if (!acc_is_present (hostaddrs[i], sizes[i]))\n-\t      GOACC_enter_exit_data (device, 1, &hostaddrs[i], &sizes[i],\n+\t      GOACC_enter_exit_data (flags_m, 1, &hostaddrs[i], &sizes[i],\n \t\t\t\t     &kinds[i], GOMP_ASYNC_SYNC, 0);\n \t    break;\n \n \t  case GOMP_MAP_TO:\n-\t    GOACC_enter_exit_data (device, 1, &hostaddrs[i], &sizes[i],\n+\t    GOACC_enter_exit_data (flags_m, 1, &hostaddrs[i], &sizes[i],\n \t\t\t\t   &kinds[i], GOMP_ASYNC_SYNC, 0);\n \n \t    break;\n \n \t  case GOMP_MAP_FROM:\n-\t    GOACC_enter_exit_data (device, 1, &hostaddrs[i], &sizes[i],\n+\t    GOACC_enter_exit_data (flags_m, 1, &hostaddrs[i], &sizes[i],\n \t\t\t\t   &kinds[i], GOMP_ASYNC_SYNC, 0);\n \t    break;\n "}]}