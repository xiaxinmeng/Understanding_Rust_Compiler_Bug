{"sha": "a734f2a306418b3d017f8f42ff11296b5c857652", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTczNGYyYTMwNjQxOGIzZDAxN2Y4ZjQyZmYxMTI5NmI1Yzg1NzY1Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2001-08-09T16:22:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-08-09T16:22:23Z"}, "message": "fde-glibc.c: Require glibc 2.2.4+ headers.\n\n\t* config/ia64/fde-glibc.c: Require glibc 2.2.4+ headers.\n\t(find_fde_for_dso): Remove.\n\t(_Unwind_IteratePhdrCallback): New.\n\t(_Unwind_FindTableEntry): Use dl_iterate_phdr.\n\t* config/ia64/crtbegin.asm (__ia64_app_header): Remove.\n\nFrom-SVN: r44742", "tree": {"sha": "6e023229408bf79d99040381ec3f27f51744d580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e023229408bf79d99040381ec3f27f51744d580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a734f2a306418b3d017f8f42ff11296b5c857652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a734f2a306418b3d017f8f42ff11296b5c857652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a734f2a306418b3d017f8f42ff11296b5c857652", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a734f2a306418b3d017f8f42ff11296b5c857652/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21d936870387dc6253c88346d357ff230ed50806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d936870387dc6253c88346d357ff230ed50806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d936870387dc6253c88346d357ff230ed50806"}], "stats": {"total": 157, "additions": 59, "deletions": 98}, "files": [{"sha": "e27d76c5bcb8ce10c82ed8a1a9a90b69803ef05c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a734f2a306418b3d017f8f42ff11296b5c857652", "patch": "@@ -1,3 +1,11 @@\n+2001-08-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/ia64/fde-glibc.c: Require glibc 2.2.4+ headers.\n+\t(find_fde_for_dso): Remove.\n+\t(_Unwind_IteratePhdrCallback): New.\n+\t(_Unwind_FindTableEntry): Use dl_iterate_phdr.\n+\t* config/ia64/crtbegin.asm (__ia64_app_header): Remove.\n+\n Thu Aug  9 11:30:20 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (emit_single_push_insn): Only exists ifdef PUSH_ROUNDING."}, {"sha": "ac2f86bcc87c99de9dded67843f8700d0e80cf57", "filename": "gcc/config/ia64/crtbegin.asm", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fcrtbegin.asm?ref=a734f2a306418b3d017f8f42ff11296b5c857652", "patch": "@@ -32,14 +32,6 @@ __DTOR_LIST__:\n dtor_ptr:\n \tdata8\t__DTOR_LIST__# + 8\n \n-#ifndef SHARED\n-\t.type __ia64_app_header#,@object\n-\t.size __ia64_app_header#,8\n-\t.global __ia64_app_header\n-__ia64_app_header:\n-\tdata8\t@segrel(.Lsegrel_ref#)\n-#endif\n-\n \t/* A handle for __cxa_finalize to manage c++ local destructors.  */\n \t.global __dso_handle#\n \t.type __dso_handle#,@object\n@@ -85,30 +77,6 @@ __dso_handle:\n \t  ;;\n \t}\n \n-#ifndef SHARED\n-/*\n- * Fragment of the ELF _init routine that sets up __ia64_app_header\n- */\n-\n-.section .init,\"ax\",\"progbits\"\n-.Lsegrel_ref:\n-\t{ .mmi\n-\t  addl r2 = @gprel(__ia64_app_header), gp\n-\t  mov r16 = ip\n-\t  ;;\n-\t}\n-\t{ .mmi\n-\t  ld8 r3 = [r2]\n-\t  ;;\n-\t  sub r16 = r16, r3\n-\t  ;;\n-\t}\n-\t{ .mfb\n-\t  st8 [r2] = r16\n-\t  ;;\n-\t}\n-#endif\n-\n .section .text\n \t.align\t16\n \t.proc\t__do_global_dtors_aux#"}, {"sha": "c663f584458c9cdf26dd8c38bda84460aac5ddc0", "filename": "gcc/config/ia64/fde-glibc.c", "status": "modified", "additions": 51, "deletions": 66, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a734f2a306418b3d017f8f42ff11296b5c857652/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ffde-glibc.c?ref=a734f2a306418b3d017f8f42ff11296b5c857652", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000 Free Software Foundation, Inc.\n+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@cygnus.com>.\n \n    This file is part of GNU CC.\n@@ -28,70 +28,73 @@\n /* Locate the FDE entry for a given address, using glibc ld.so routines\n    to avoid register/deregister calls at DSO load/unload.  */\n \n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE\n+#endif\n+#include \"config.h\"\n+#include <stddef.h>\n #include <stdlib.h>\n #include <link.h>\n-#include <bits/libc-lock.h>\n #include \"unwind-ia64.h\"\n \n+#if __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 2) \\\n+    || (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && !defined(DT_CONFIG))\n+# error You need GLIBC 2.2.4 or later on IA-64 Linux\n+#endif\n \n-/* Initialized by crtbegin from the main application.  */\n-extern Elf64_Ehdr *__ia64_app_header;\n-\n-/* ??? A redeclaration of the lock in ld.so.  Perhaps this should\n-   appear in <link.h> in a new glibc version.  */\n-__libc_lock_define (extern, _dl_load_lock)\n-\n-/* This always exists, even in a static application.  */\n-extern struct link_map *_dl_loaded;\n+struct unw_ia64_callback_data\n+{\n+  Elf64_Addr pc;\n+  unsigned long *segment_base;\n+  unsigned long *gp;\n+  struct unw_table_entry *ret;\n+};\n \n-static struct unw_table_entry *\n-find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr,\n-\t\t  unsigned long *pseg_base, unsigned long *pgp)\n+static int\n+_Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n {\n-  Elf64_Phdr *phdr, *p_unwind, *p_dynamic;\n+  struct unw_ia64_callback_data *data = (struct unw_ia64_callback_data *) ptr;\n+  const Elf64_Phdr *phdr, *p_unwind, *p_dynamic;\n   long n, match;\n   Elf64_Addr load_base, seg_base;\n   struct unw_table_entry *f_base, *f;\n   size_t lo, hi;\n \n-  /* Verify that we are looking at an ELF header.  */\n-  if (ehdr->e_ident[0] != 0x7f\n-      || ehdr->e_ident[1] != 'E'\n-      || ehdr->e_ident[2] != 'L'\n-      || ehdr->e_ident[3] != 'F'\n-      || ehdr->e_ident[EI_CLASS] != ELFCLASS64\n-      || ehdr->e_ident[EI_DATA] != ELFDATA2LSB\n-      || ehdr->e_machine != EM_IA_64)\n-    abort ();\n+  /* Make sure struct dl_phdr_info is at least as big as we need.  */\n+  if (size < offsetof (struct dl_phdr_info, dlpi_phnum)\n+\t     + sizeof (info->dlpi_phnum))\n+    return -1;\n \n   match = 0;\n-  phdr = (Elf64_Phdr *)((char *)ehdr + ehdr->e_phoff);\n-  load_base = (ehdr->e_type == ET_DYN ? (Elf64_Addr)ehdr : 0);\n+  phdr = info->dlpi_phdr;\n+  load_base = info->dlpi_addr;\n   p_unwind = NULL;\n   p_dynamic = NULL;\n+  seg_base = ~(Elf64_Addr) 0;\n \n   /* See if PC falls into one of the loaded segments.  Find the unwind\n      segment at the same time.  */\n-  for (n = ehdr->e_phnum; --n >= 0; phdr++)\n+  for (n = info->dlpi_phnum; --n >= 0; phdr++)\n     {\n       if (phdr->p_type == PT_LOAD)\n \t{\n \t  Elf64_Addr vaddr = phdr->p_vaddr + load_base;\n-\t  if (pc >= vaddr && pc < vaddr + phdr->p_memsz)\n+\t  if (data->pc >= vaddr && data->pc < vaddr + phdr->p_memsz)\n \t    match = 1;\n+\t  if (vaddr < seg_base)\n+\t    seg_base = vaddr;\n \t}\n       else if (phdr->p_type == PT_IA_64_UNWIND)\n \tp_unwind = phdr;\n       else if (phdr->p_type == PT_DYNAMIC)\n \tp_dynamic = phdr;\n     }\n   if (!match || !p_unwind)\n-    return NULL;\n+    return 0;\n \n   /* Search for the FDE within the unwind segment.  */\n \n   f_base = (struct unw_table_entry *) (p_unwind->p_vaddr + load_base);\n-  seg_base = (Elf64_Addr) ehdr;\n   lo = 0;\n   hi = p_unwind->p_memsz / sizeof (struct unw_table_entry);\n \n@@ -100,18 +103,19 @@ find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr,\n       size_t mid = (lo + hi) / 2;\n \n       f = f_base + mid;\n-      if (pc < f->start_offset + seg_base)\n+      if (data->pc < f->start_offset + seg_base)\n \thi = mid;\n-      else if (pc >= f->end_offset + seg_base)\n+      else if (data->pc >= f->end_offset + seg_base)\n \tlo = mid + 1;\n       else\n         goto found;\n     }\n-  return NULL;\n+  return 0;\n \n  found:\n-  *pseg_base = seg_base;\n-  *pgp = 0;\n+  *data->segment_base = seg_base;\n+  *data->gp = 0;\n+  data->ret = f;\n \n   if (p_dynamic)\n     {\n@@ -121,8 +125,8 @@ find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr,\n       for (; dyn->d_tag != DT_NULL ; dyn++)\n \tif (dyn->d_tag == DT_PLTGOT)\n \t  {\n-\t    /* ??? Glibc seems to have relocated this already.  */\n-\t    *pgp = dyn->d_un.d_ptr;\n+\t    /* On IA-64, _DYNAMIC is writable and GLIBC has relocated it.  */\n+\t    *data->gp = dyn->d_un.d_ptr;\n \t    break;\n \t  }\n     }\n@@ -131,10 +135,10 @@ find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr,\n       /* Otherwise this is a static executable with no _DYNAMIC.\n \t The gp is constant program-wide.  */\n       register unsigned long gp __asm__(\"gp\");\n-      *pgp = gp;\n+      *data->gp = gp;\n     }\n \n-  return f;\n+  return 1;\n }\n \n /* Return a pointer to the unwind table entry for the function\n@@ -144,34 +148,15 @@ struct unw_table_entry *\n _Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n                         unsigned long *gp)\n {\n-  struct unw_table_entry *ret;\n-  struct link_map *map;\n+  struct unw_ia64_callback_data data;\n \n-  /* Check the main application first, hoping that most of the user's\n-     code is there instead of in some library.  */\n-  ret = find_fde_for_dso ((Elf64_Addr)pc, __ia64_app_header,\n-\t\t\t  segment_base, gp);\n-  if (ret)\n-    return ret;\n+  data.pc = (Elf64_Addr) pc;\n+  data.segment_base = segment_base;\n+  data.gp = gp;\n+  data.ret = NULL;\n \n-  /* Glibc is probably unique in that we can (with certain restrictions)\n-     dynamicly load libraries into staticly linked applications.  Thus\n-     we _always_ check _dl_loaded.  */\n-\n-  __libc_lock_lock (_dl_load_lock);\n-\n-  for (map = _dl_loaded; map ; map = map->l_next)\n-    {\n-      /* Skip the main application's entry.  */\n-      if (map->l_name[0] == 0)\n-\tcontinue;\n-      ret = find_fde_for_dso ((Elf64_Addr)pc, (Elf64_Ehdr *)map->l_addr,\n-\t\t\t      segment_base, gp);\n-      if (ret)\n-\tbreak;\n-    }\n-\n-  __libc_lock_unlock (_dl_load_lock);\n+  if (dl_iterate_phdr (_Unwind_IteratePhdrCallback, &data) < 0)\n+    return NULL;\n \n-  return ret;\n+  return data.ret;\n }"}]}