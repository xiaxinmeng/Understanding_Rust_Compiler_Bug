{"sha": "2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwNWM1ZWRjYWMzZmJjMGEzOWFkNzRjNjNiYWIxNTM0ZWU2ZTQ5MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-18T18:39:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-18T18:39:52Z"}, "message": "cgraph.c (cgraph_make_edge, [...]): Set nothrow flag.\n\n\t* cgraph.c (cgraph_make_edge, dump_cgraph_node, cgraph_set_call_stmt):\n\tSet nothrow flag.\n\t* cgraph.h (struct function): Reduce loop_nest to 30 bits; add\n\tcan_throw_external flag.\n\t* ipa-reference.c (ipa_utils_reduced_inorder): Update call.\n\t* ipa-pure-const.c (ignore_edge): New function.\n\t(propagate): Compute order for NOTHROW computation; set NOTHROWs\n\tonly over can_throw_external edges.\n\t(local_pure_const): Add nothrow flag.\n\t* ipa-utils.c (searchc): Add ignore_edge callback.\n\t(ipa_utils_reduced_inorder): Add ignore_edge callback.\n\t* ipa-utils.h (ipa_utils_reduced_inorder): Update prototype.\n\t(set_nothrow_function_flags): Update cgraph.\n\t* tree-cfg.c (verify_stmt): Relax nothrow checking when in IPA mode.\n\nFrom-SVN: r146322", "tree": {"sha": "605c8e1d928935149f9367d15c77d8c439de199f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605c8e1d928935149f9367d15c77d8c439de199f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/comments", "author": null, "committer": null, "parents": [{"sha": "c7f9c0b9835fc77208bddffec0ba71d33fb425fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f9c0b9835fc77208bddffec0ba71d33fb425fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f9c0b9835fc77208bddffec0ba71d33fb425fa"}], "stats": {"total": 159, "additions": 132, "deletions": 27}, "files": [{"sha": "33cea052effda27a82237044dfad2e8e1612db35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -1,3 +1,20 @@\n+2009-04-18  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_make_edge, dump_cgraph_node, cgraph_set_call_stmt):\n+\tSet nothrow flag.\n+\t* cgraph.h (struct function): Reduce loop_nest to 30 bits; add\n+\tcan_throw_external flag.\n+\t* ipa-reference.c (ipa_utils_reduced_inorder): Update call.\n+\t* ipa-pure-const.c (ignore_edge): New function.\n+\t(propagate): Compute order for NOTHROW computation; set NOTHROWs\n+\tonly over can_throw_external edges.\n+\t(local_pure_const): Add nothrow flag.\n+\t* ipa-utils.c (searchc): Add ignore_edge callback.\n+\t(ipa_utils_reduced_inorder): Add ignore_edge callback.\n+\t* ipa-utils.h (ipa_utils_reduced_inorder): Update prototype.\n+\t(set_nothrow_function_flags): Update cgraph.\n+\t* tree-cfg.c (verify_stmt): Relax nothrow checking when in IPA mode.\n+\n 2009-04-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/39804"}, {"sha": "f7189b92ecaed6cce53698a7d8e451be1148e3fb", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -640,6 +640,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n \t\t\t\t htab_hash_pointer (e->call_stmt));\n     }\n   e->call_stmt = new_stmt;\n+  e->can_throw_external = stmt_can_throw_external (new_stmt);\n   if (e->caller->call_site_hash)\n     {\n       void **slot;\n@@ -704,6 +705,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   edge->caller = caller;\n   edge->callee = callee;\n   edge->call_stmt = call_stmt;\n+  edge->can_throw_external = stmt_can_throw_external (call_stmt);\n   edge->prev_caller = NULL;\n   edge->next_caller = callee->callers;\n   if (callee->callers)\n@@ -1215,6 +1217,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \tfprintf(f, \"(inlined) \");\n       if (edge->indirect_call)\n \tfprintf(f, \"(indirect) \");\n+      if (edge->can_throw_external)\n+\tfprintf(f, \"(can throw external) \");\n     }\n \n   fprintf (f, \"\\n  calls: \");"}, {"sha": "347653fc79ed332ebe364ab49884c8db340ae191", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -216,9 +216,11 @@ struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_call\n      per function call.  The range is 0 to CGRAPH_FREQ_MAX.  */\n   int frequency;\n   /* Depth of loop nest, 1 means no loop nest.  */\n-  unsigned int loop_nest : 31;\n+  unsigned int loop_nest : 30;\n   /* Whether this edge describes a call that was originally indirect.  */\n   unsigned int indirect_call : 1;\n+  /* Can this call throw externally?  */\n+  unsigned int can_throw_external : 1;\n   /* Unique id of the edge.  */\n   int uid;\n };"}, {"sha": "bc3b8c495a23427a63c0a5dd5e3633d17e131875", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -2846,6 +2846,10 @@ set_nothrow_function_flags (void)\n \t\t\t\t\t     (current_function_decl))\n           >= AVAIL_AVAILABLE))\n     {\n+      struct cgraph_node *node = cgraph_node (current_function_decl);\n+      struct cgraph_edge *e;\n+      for (e = node->callers; e; e = e->next_caller)\n+        e->can_throw_external = false;\n       TREE_NOTHROW (current_function_decl) = 1;\n \n       if (dump_file)"}, {"sha": "1aef09f5221ebd250241f0073cf37ed7f8f28a2c", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 87, "deletions": 18, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -637,6 +637,12 @@ generate_summary (void)\n   visited_nodes = NULL;\n }\n \n+static bool\n+ignore_edge (struct cgraph_edge *e)\n+{\n+  return (!e->can_throw_external);\n+}\n+\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by generate_summary.\n    Note that there is no function_transform pass since this only\n@@ -656,7 +662,7 @@ propagate (void)\n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n   cgraph_remove_node_duplication_hook (node_duplication_hook_holder);\n   cgraph_remove_node_removal_hook (node_removal_hook_holder);\n-  order_pos = ipa_utils_reduced_inorder (order, true, false);\n+  order_pos = ipa_utils_reduced_inorder (order, true, false, NULL);\n   if (dump_file)\n     {\n       dump_cgraph (dump_file);\n@@ -671,7 +677,6 @@ propagate (void)\n     {\n       enum pure_const_state_e pure_const_state = IPA_CONST;\n       bool looping = false;\n-      bool can_throw = false;\n       int count = 0;\n       node = order[i];\n \n@@ -684,13 +689,10 @@ propagate (void)\n \t  if (pure_const_state < w_l->pure_const_state)\n \t    pure_const_state = w_l->pure_const_state;\n \n-\t  if (w_l->can_throw)\n-\t    can_throw = true;\n \t  if (w_l->looping)\n \t    looping = true;\n \n-\t  if (pure_const_state == IPA_NEITHER\n-\t      && can_throw)\n+\t  if (pure_const_state == IPA_NEITHER)\n \t    break;\n \n \t  count++;\n@@ -707,16 +709,10 @@ propagate (void)\n \t\t  funct_state y_l = get_function_state (y);\n \t\t  if (pure_const_state < y_l->pure_const_state)\n \t\t    pure_const_state = y_l->pure_const_state;\n-\t\t  if (pure_const_state == IPA_NEITHER\n-\t\t      && can_throw) \n+\t\t  if (pure_const_state == IPA_NEITHER)\n \t\t    break;\n \t\t  if (y_l->looping)\n \t\t    looping = true;\n-\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n-\t\t      /* FIXME: We should check that the throw can get external.\n-\t\t         We also should handle only loops formed by can throw external\n-\t\t\t edges.  */)\n-\t\t    can_throw = true;\n \t\t}\n \t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n@@ -766,12 +762,80 @@ propagate (void)\n \t    default:\n \t      break;\n \t    }\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w = w_info->next_cycle;\n+\t}\n+    }\n+\n+  /* Cleanup. */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      /* Get rid of the aux information.  */\n+      if (node->aux)\n+\t{\n+\t  w_info = (struct ipa_dfs_info *) node->aux;\n+\t  free (node->aux);\n+\t  node->aux = NULL;\n+\t}\n+    }\n+  order_pos = ipa_utils_reduced_inorder (order, true, false, ignore_edge);\n+  if (dump_file)\n+    {\n+      dump_cgraph (dump_file);\n+      ipa_utils_print_order(dump_file, \"reduced for nothrow\", order, order_pos);\n+    }\n+  /* Propagate the local information thru the call graph to produce\n+     the global information.  All the nodes within a cycle will have\n+     the same info so we collapse cycles first.  Then we can do the\n+     propagation in one pass from the leaves to the roots.  */\n+  for (i = 0; i < order_pos; i++ )\n+    {\n+      bool can_throw = false;\n+      node = order[i];\n+\n+      /* Find the worst state for any node in the cycle.  */\n+      w = node;\n+      while (w)\n+\t{\n+\t  struct cgraph_edge *e;\n+\t  funct_state w_l = get_function_state (w);\n+\n+\t  if (w_l->can_throw)\n+\t    can_throw = true;\n+\n+\t  if (can_throw)\n+\t    break;\n+\t\t\n+\t  for (e = w->callees; e; e = e->next_callee) \n+\t    {\n+\t      struct cgraph_node *y = e->callee;\n+\n+\t      if (cgraph_function_body_availability (y) > AVAIL_OVERWRITABLE)\n+\t\t{\n+\t\t  funct_state y_l = get_function_state (y);\n+\n+\t\t  if (can_throw) \n+\t\t    break;\n+\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n+\t\t      && e->can_throw_external)\n+\t\t    can_throw = true;\n+\t\t}\n+\t    }\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w = w_info->next_cycle;\n+\t}\n+\n+      /* Copy back the region's pure_const_state which is shared by\n+\t all nodes in the region.  */\n+      w = node;\n+      while (w)\n+\t{\n \t  if (!can_throw && !TREE_NOTHROW (w->decl))\n \t    {\n-\t      /* FIXME: TREE_NOTHROW is not set because passmanager will execute\n-\t         verify_ssa and verify_cfg on every function.  Before fixup_cfg is done,\n-\t         those functions are going to have NOTHROW calls in EH regions reulting\n-\t         in ICE.  */\n+\t      struct cgraph_edge *e;\n+\t      TREE_NOTHROW (w->decl) = true;\n+\t      for (e = w->callers; e; e = e->next_caller)\n+\t        e->can_throw_external = false;\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",  \n \t\t\t cgraph_node_name (w));\n@@ -918,7 +982,12 @@ local_pure_const (void)\n     }\n   if (!l->can_throw && !TREE_NOTHROW (current_function_decl))\n     {\n-      TREE_NOTHROW (current_function_decl) = 1;\n+      struct cgraph_edge *e;\n+\n+      TREE_NOTHROW (current_function_decl) = true;\n+      for (e = cgraph_node (current_function_decl)->callers;\n+           e; e = e->next_caller)\n+\te->can_throw_external = false;\n       changed = true;\n       if (dump_file)\n \tfprintf (dump_file, \"Function found to be nothrow: %s\\n\","}, {"sha": "36cb5f3f5f986d24c4a7fbbdef5be553b7a1a8f8", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -995,7 +995,7 @@ propagate (void)\n   struct cgraph_node *w;\n   struct cgraph_node **order =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n-  int order_pos = ipa_utils_reduced_inorder (order, false, true);\n+  int order_pos = ipa_utils_reduced_inorder (order, false, true, NULL);\n   int i;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n@@ -1006,7 +1006,7 @@ propagate (void)\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the\n      propagation in one pass from the leaves to the roots.  */\n-  order_pos = ipa_utils_reduced_inorder (order, true, true);\n+  order_pos = ipa_utils_reduced_inorder (order, true, true, NULL);\n   if (dump_file)\n     ipa_utils_print_order(dump_file, \"reduced\", order, order_pos);\n "}, {"sha": "2fe0396b496e33bd69c66b4b57b839b7822c8416", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -81,7 +81,8 @@ struct searchc_env {\n    searching from.  */\n \n static void\n-searchc (struct searchc_env* env, struct cgraph_node *v) \n+searchc (struct searchc_env* env, struct cgraph_node *v,\n+\t bool (*ignore_edge) (struct cgraph_edge *))\n {\n   struct cgraph_edge *edge;\n   struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->aux;\n@@ -101,12 +102,15 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n       struct ipa_dfs_info * w_info;\n       struct cgraph_node *w = edge->callee;\n \n+      if (ignore_edge && ignore_edge (edge))\n+        continue;\n+\n       if (w->aux && cgraph_function_body_availability (edge->callee) > AVAIL_OVERWRITABLE)\n \t{\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  if (w_info->new_node) \n \t    {\n-\t      searchc (env, w);\n+\t      searchc (env, w, ignore_edge);\n \t      v_info->low_link =\n \t\t(v_info->low_link < w_info->low_link) ?\n \t\tv_info->low_link : w_info->low_link;\n@@ -152,7 +156,8 @@ searchc (struct searchc_env* env, struct cgraph_node *v)\n \n int\n ipa_utils_reduced_inorder (struct cgraph_node **order, \n-\t\t\t   bool reduce, bool allow_overwritable)\n+\t\t\t   bool reduce, bool allow_overwritable,\n+\t\t\t   bool (*ignore_edge) (struct cgraph_edge *))\n {\n   struct cgraph_node *node;\n   struct searchc_env env;\n@@ -193,7 +198,7 @@ ipa_utils_reduced_inorder (struct cgraph_node **order,\n   while (result)\n     {\n       node = (struct cgraph_node *)result->value;\n-      searchc (&env, node);\n+      searchc (&env, node, ignore_edge);\n       result = splay_tree_min (env.nodes_marked_new);\n     }\n   splay_tree_delete (env.nodes_marked_new);"}, {"sha": "31d78374ff6aefefa1a855cec8e635910a267b95", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -39,7 +39,8 @@ struct ipa_dfs_info {\n \n /* In ipa-utils.c  */\n void ipa_utils_print_order (FILE*, const char *, struct cgraph_node**, int);\n-int ipa_utils_reduced_inorder (struct cgraph_node **, bool, bool);\n+int ipa_utils_reduced_inorder (struct cgraph_node **, bool, bool,\n+\t\t\t       bool (*ignore_edge) (struct cgraph_edge *));\n tree get_base_var (tree);\n \n  "}, {"sha": "9c7014637849afdf5477e0fa23b8b8424c5566d9", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2505c5edcac3fbc0a39ad74c63bab1534ee6e491/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2505c5edcac3fbc0a39ad74c63bab1534ee6e491", "patch": "@@ -4156,7 +4156,10 @@ verify_stmt (gimple_stmt_iterator *gsi)\n      to match.  */\n   if (lookup_stmt_eh_region (stmt) >= 0)\n     {\n-      if (!stmt_could_throw_p (stmt))\n+      /* During IPA passes, ipa-pure-const sets nothrow flags on calls\n+         and they are updated on statements only after fixup_cfg\n+\t is executed at beggining of expansion stage.  */\n+      if (!stmt_could_throw_p (stmt) && cgraph_state != CGRAPH_STATE_IPA_SSA)\n \t{\n \t  error (\"statement marked for throw, but doesn%'t\");\n \t  goto fail;"}]}