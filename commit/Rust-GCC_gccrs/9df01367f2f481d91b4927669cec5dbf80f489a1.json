{"sha": "9df01367f2f481d91b4927669cec5dbf80f489a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRmMDEzNjdmMmY0ODFkOTFiNDkyNzY2OWNlYzVkYmY4MGY0ODlhMQ==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-10-26T01:11:00Z"}, "committer": {"name": "Mikhail Maltsev", "email": "miyuki@gcc.gnu.org", "date": "2015-10-26T01:11:00Z"}, "message": "ENABLE_CHECKING refactoring: pool allocators\n\ngcc/\n\t* alloc-pool.h (base_pool_allocator::initialize, ::allocate): Remove\n\tconditional compilation.\n\t(base_pool_allocator::remove): Use flag_checking.\n\nFrom-SVN: r229307", "tree": {"sha": "894bf374925fcfd2acdc742139c822b41c51ffc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894bf374925fcfd2acdc742139c822b41c51ffc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9df01367f2f481d91b4927669cec5dbf80f489a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9df01367f2f481d91b4927669cec5dbf80f489a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9df01367f2f481d91b4927669cec5dbf80f489a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9df01367f2f481d91b4927669cec5dbf80f489a1/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e51b667fe84d42ef5b48095047158cae94b408b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51b667fe84d42ef5b48095047158cae94b408b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51b667fe84d42ef5b48095047158cae94b408b9"}], "stats": {"total": 33, "additions": 16, "deletions": 17}, "files": [{"sha": "d8a22c39b5d75431d5b0848480433248958d4634", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9df01367f2f481d91b4927669cec5dbf80f489a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9df01367f2f481d91b4927669cec5dbf80f489a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9df01367f2f481d91b4927669cec5dbf80f489a1", "patch": "@@ -1,3 +1,9 @@\n+2015-10-26  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* alloc-pool.h (base_pool_allocator::initialize, ::allocate): Remove\n+\tconditional compilation.\n+\t(base_pool_allocator::remove): Use flag_checking.\n+\n 2015-10-25  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/som.h (EH_FRAME_THROUGH_COLLECT2): Define."}, {"sha": "404b558e027e08a699fb159e59668d3e00320405", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9df01367f2f481d91b4927669cec5dbf80f489a1/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9df01367f2f481d91b4927669cec5dbf80f489a1/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=9df01367f2f481d91b4927669cec5dbf80f489a1", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define ALLOC_POOL_H\n \n #include \"memory-block.h\"\n+#include \"options.h\"\t    // for flag_checking\n \n extern void dump_alloc_pool_statistics (void);\n \n@@ -275,15 +276,13 @@ base_pool_allocator <TBlockAllocator>::initialize ()\n   m_elts_per_block = (TBlockAllocator::block_size - header_size) / size;\n   gcc_checking_assert (m_elts_per_block != 0);\n \n-#ifdef ENABLE_CHECKING\n   /* Increase the last used ID and use it for this pool.\n      ID == 0 is used for free elements of pool so skip it.  */\n   last_id++;\n   if (last_id == 0)\n     last_id++;\n \n   m_id = last_id;\n-#endif\n }\n \n /* Free all memory allocated for the given memory pool.  */\n@@ -387,10 +386,9 @@ base_pool_allocator <TBlockAllocator>::allocate ()\n       block = m_virgin_free_list;\n       header = (allocation_pool_list*) allocation_object::get_data (block);\n       header->next = NULL;\n-#ifdef ENABLE_CHECKING\n+\n       /* Mark the element to be free.  */\n       ((allocation_object*) block)->id = 0;\n-#endif\n       VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (header,size));\n       m_returned_free_list = header;\n       m_virgin_free_list += m_elt_size;\n@@ -404,10 +402,8 @@ base_pool_allocator <TBlockAllocator>::allocate ()\n   m_returned_free_list = header->next;\n   m_elts_free--;\n \n-#ifdef ENABLE_CHECKING\n   /* Set the ID for element.  */\n   allocation_object::get_instance (header)->id = m_id;\n-#endif\n   VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (header, size));\n \n   return (void *)(header);\n@@ -418,26 +414,23 @@ template <typename TBlockAllocator>\n inline void\n base_pool_allocator <TBlockAllocator>::remove (void *object)\n {\n-  gcc_checking_assert (m_initialized);\n-\n-  allocation_pool_list *header;\n-  int size ATTRIBUTE_UNUSED;\n-  size = m_elt_size - offsetof (allocation_object, u.data);\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (object\n+  if (flag_checking)\n+    {\n+      gcc_assert (m_initialized);\n+      gcc_assert (object\n \t      /* Check if we free more than we allocated, which is Bad (TM).  */\n \t      && m_elts_free < m_elts_allocated\n \t      /* Check whether the PTR was allocated from POOL.  */\n \t      && m_id == allocation_object::get_instance (object)->id);\n \n-  memset (object, 0xaf, size);\n+      int size = m_elt_size - offsetof (allocation_object, u.data);\n+      memset (object, 0xaf, size);\n+    }\n \n   /* Mark the element to be free.  */\n   allocation_object::get_instance (object)->id = 0;\n-#endif\n \n-  header = (allocation_pool_list*) object;\n+  allocation_pool_list *header = (allocation_pool_list*) object;\n   header->next = m_returned_free_list;\n   m_returned_free_list = header;\n   VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (object, size));"}]}