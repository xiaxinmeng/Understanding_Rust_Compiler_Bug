{"sha": "ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzYzNkYzA3MDJlY2EwNmJkZTQ4NDFlM2JiZGYwZDQyOGI3MTk2OA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-15T17:57:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-15T17:57:53Z"}, "message": "Fix simplify_shift_const_1 handling of vector shifts\n\nsimplify_shift_const_1 handles both shifts of scalars by scalars\nand shifts of vectors by scalars.  For vectors this means that\neach element is shifted by the same amount.\n\nHowever:\n\n(a) the two cases weren't always distinguished, so we'd try\n        things for vectors that only made sense for scalars.\n\n(b) a lot of the range and bitcount checks were based on the\n        bitsize or precision of the full shifted operand, rather\n        than the mode of each element.\n\nFixing (b) accidentally exposed more optimisation opportunities,\nalthough that wasn't the point of the patch.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* combine.c (simplify_shift_const_1): Use the number of bits\n\tin the inner mode to determine the range of the shift.\n\tWhen handling shifts of vectors, skip any rules that apply\n\tonly to scalars.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242442", "tree": {"sha": "51c0c3fdc5c0927ce9f1865ae0afe38fadb0b018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51c0c3fdc5c0927ce9f1865ae0afe38fadb0b018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3c3dc0702eca06bde4841e3bbdf0d428b71968/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89e64bc0305f36a4abe486ce07cbee7c13a6dc81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e64bc0305f36a4abe486ce07cbee7c13a6dc81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e64bc0305f36a4abe486ce07cbee7c13a6dc81"}], "stats": {"total": 152, "additions": 98, "deletions": 54}, "files": [{"sha": "dee6da04808093071e30afe29892eb539a8a7ed1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3c3dc0702eca06bde4841e3bbdf0d428b71968/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3c3dc0702eca06bde4841e3bbdf0d428b71968/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "patch": "@@ -1,3 +1,12 @@\n+2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (simplify_shift_const_1): Use the number of bits\n+\tin the inner mode to determine the range of the shift.\n+\tWhen handling shifts of vectors, skip any rules that apply\n+\tonly to scalars.\n+\n 2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "3f197fa60a6bca306fdfd7521bdac52224e30e1c", "filename": "gcc/combine.c", "status": "modified", "additions": 89, "deletions": 54, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3c3dc0702eca06bde4841e3bbdf0d428b71968/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3c3dc0702eca06bde4841e3bbdf0d428b71968/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ba3c3dc0702eca06bde4841e3bbdf0d428b71968", "patch": "@@ -10228,12 +10228,12 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n      want to do this inside the loop as it makes it more difficult to\n      combine shifts.  */\n   if (SHIFT_COUNT_TRUNCATED)\n-    orig_count &= GET_MODE_BITSIZE (mode) - 1;\n+    orig_count &= GET_MODE_UNIT_BITSIZE (mode) - 1;\n \n   /* If we were given an invalid count, don't do anything except exactly\n      what was requested.  */\n \n-  if (orig_count < 0 || orig_count >= (int) GET_MODE_PRECISION (mode))\n+  if (orig_count < 0 || orig_count >= (int) GET_MODE_UNIT_PRECISION (mode))\n     return NULL_RTX;\n \n   count = orig_count;\n@@ -10250,16 +10250,14 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n       /* Convert ROTATERT to ROTATE.  */\n       if (code == ROTATERT)\n \t{\n-\t  unsigned int bitsize = GET_MODE_PRECISION (result_mode);\n+\t  unsigned int bitsize = GET_MODE_UNIT_PRECISION (result_mode);\n \t  code = ROTATE;\n-\t  if (VECTOR_MODE_P (result_mode))\n-\t    count = bitsize / GET_MODE_NUNITS (result_mode) - count;\n-\t  else\n-\t    count = bitsize - count;\n+\t  count = bitsize - count;\n \t}\n \n       shift_mode = try_widen_shift_mode (code, varop, count, result_mode,\n \t\t\t\t\t mode, outer_op, outer_const);\n+      machine_mode shift_unit_mode = GET_MODE_INNER (shift_mode);\n \n       /* Handle cases where the count is greater than the size of the mode\n \t minus 1.  For ASHIFT, use the size minus one as the count (this can\n@@ -10271,12 +10269,12 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t multiple operations, each of which are defined, we know what the\n \t result is supposed to be.  */\n \n-      if (count > (GET_MODE_PRECISION (shift_mode) - 1))\n+      if (count > (GET_MODE_PRECISION (shift_unit_mode) - 1))\n \t{\n \t  if (code == ASHIFTRT)\n-\t    count = GET_MODE_PRECISION (shift_mode) - 1;\n+\t    count = GET_MODE_PRECISION (shift_unit_mode) - 1;\n \t  else if (code == ROTATE || code == ROTATERT)\n-\t    count %= GET_MODE_PRECISION (shift_mode);\n+\t    count %= GET_MODE_PRECISION (shift_unit_mode);\n \t  else\n \t    {\n \t      /* We can't simply return zero because there may be an\n@@ -10292,44 +10290,49 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n       if (complement_p)\n \tbreak;\n \n-      /* An arithmetic right shift of a quantity known to be -1 or 0\n-\t is a no-op.  */\n-      if (code == ASHIFTRT\n-\t  && (num_sign_bit_copies (varop, shift_mode)\n-\t      == GET_MODE_PRECISION (shift_mode)))\n+      if (shift_mode == shift_unit_mode)\n \t{\n-\t  count = 0;\n-\t  break;\n-\t}\n+\t  /* An arithmetic right shift of a quantity known to be -1 or 0\n+\t     is a no-op.  */\n+\t  if (code == ASHIFTRT\n+\t      && (num_sign_bit_copies (varop, shift_unit_mode)\n+\t\t  == GET_MODE_PRECISION (shift_unit_mode)))\n+\t    {\n+\t      count = 0;\n+\t      break;\n+\t    }\n \n-      /* If we are doing an arithmetic right shift and discarding all but\n-\t the sign bit copies, this is equivalent to doing a shift by the\n-\t bitsize minus one.  Convert it into that shift because it will often\n-\t allow other simplifications.  */\n-\n-      if (code == ASHIFTRT\n-\t  && (count + num_sign_bit_copies (varop, shift_mode)\n-\t      >= GET_MODE_PRECISION (shift_mode)))\n-\tcount = GET_MODE_PRECISION (shift_mode) - 1;\n-\n-      /* We simplify the tests below and elsewhere by converting\n-\t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n-\t `make_compound_operation' will convert it to an ASHIFTRT for\n-\t those machines (such as VAX) that don't have an LSHIFTRT.  */\n-      if (code == ASHIFTRT\n-\t  && val_signbit_known_clear_p (shift_mode,\n-\t\t\t\t\tnonzero_bits (varop, shift_mode)))\n-\tcode = LSHIFTRT;\n-\n-      if (((code == LSHIFTRT\n-\t    && HWI_COMPUTABLE_MODE_P (shift_mode)\n-\t    && !(nonzero_bits (varop, shift_mode) >> count))\n-\t   || (code == ASHIFT\n-\t       && HWI_COMPUTABLE_MODE_P (shift_mode)\n-\t       && !((nonzero_bits (varop, shift_mode) << count)\n-\t\t    & GET_MODE_MASK (shift_mode))))\n-\t  && !side_effects_p (varop))\n-\tvarop = const0_rtx;\n+\t  /* If we are doing an arithmetic right shift and discarding all but\n+\t     the sign bit copies, this is equivalent to doing a shift by the\n+\t     bitsize minus one.  Convert it into that shift because it will\n+\t     often allow other simplifications.  */\n+\n+\t  if (code == ASHIFTRT\n+\t      && (count + num_sign_bit_copies (varop, shift_unit_mode)\n+\t\t  >= GET_MODE_PRECISION (shift_unit_mode)))\n+\t    count = GET_MODE_PRECISION (shift_unit_mode) - 1;\n+\n+\t  /* We simplify the tests below and elsewhere by converting\n+\t     ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n+\t     `make_compound_operation' will convert it to an ASHIFTRT for\n+\t     those machines (such as VAX) that don't have an LSHIFTRT.  */\n+\t  if (code == ASHIFTRT\n+\t      && HWI_COMPUTABLE_MODE_P (shift_unit_mode)\n+\t      && val_signbit_known_clear_p (shift_unit_mode,\n+\t\t\t\t\t    nonzero_bits (varop,\n+\t\t\t\t\t\t\t  shift_unit_mode)))\n+\t    code = LSHIFTRT;\n+\n+\t  if (((code == LSHIFTRT\n+\t\t&& HWI_COMPUTABLE_MODE_P (shift_unit_mode)\n+\t\t&& !(nonzero_bits (varop, shift_unit_mode) >> count))\n+\t       || (code == ASHIFT\n+\t\t   && HWI_COMPUTABLE_MODE_P (shift_unit_mode)\n+\t\t   && !((nonzero_bits (varop, shift_unit_mode) << count)\n+\t\t\t& GET_MODE_MASK (shift_unit_mode))))\n+\t      && !side_effects_p (varop))\n+\t    varop = const0_rtx;\n+\t}\n \n       switch (GET_CODE (varop))\n \t{\n@@ -10346,6 +10349,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase MEM:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* If we have (xshiftrt (mem ...) C) and C is MODE_WIDTH\n \t     minus the width of a smaller mode, we can do this with a\n \t     SIGN_EXTEND or ZERO_EXTEND from the narrower memory location.  */\n@@ -10368,6 +10375,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase SUBREG:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* If VAROP is a SUBREG, strip it as long as the inner operand has\n \t     the same number of words as what we've seen so far.  Then store\n \t     the widest mode in MODE.  */\n@@ -10424,9 +10435,9 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t     interpreted as the sign bit in a narrower mode, so, if\n \t     the result is narrower, don't discard the shift.  */\n \t  if (code == LSHIFTRT\n-\t      && count == (GET_MODE_BITSIZE (result_mode) - 1)\n-\t      && (GET_MODE_BITSIZE (result_mode)\n-\t\t  >= GET_MODE_BITSIZE (GET_MODE (varop))))\n+\t      && count == (GET_MODE_UNIT_BITSIZE (result_mode) - 1)\n+\t      && (GET_MODE_UNIT_BITSIZE (result_mode)\n+\t\t  >= GET_MODE_UNIT_BITSIZE (GET_MODE (varop))))\n \t    {\n \t      varop = XEXP (varop, 0);\n \t      continue;\n@@ -10437,14 +10448,17 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \tcase LSHIFTRT:\n \tcase ASHIFT:\n \tcase ROTATE:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* Here we have two nested shifts.  The result is usually the\n \t     AND of a new shift with a mask.  We compute the result below.  */\n \t  if (CONST_INT_P (XEXP (varop, 1))\n \t      && INTVAL (XEXP (varop, 1)) >= 0\n \t      && INTVAL (XEXP (varop, 1)) < GET_MODE_PRECISION (GET_MODE (varop))\n \t      && HWI_COMPUTABLE_MODE_P (result_mode)\n-\t      && HWI_COMPUTABLE_MODE_P (mode)\n-\t      && !VECTOR_MODE_P (result_mode))\n+\t      && HWI_COMPUTABLE_MODE_P (mode))\n \t    {\n \t      enum rtx_code first_code = GET_CODE (varop);\n \t      unsigned int first_count = INTVAL (XEXP (varop, 1));\n@@ -10610,7 +10624,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase NOT:\n-\t  if (VECTOR_MODE_P (mode))\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n \t    break;\n \n \t  /* Make this fit the case below.  */\n@@ -10620,6 +10635,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \tcase IOR:\n \tcase AND:\n \tcase XOR:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* If we have (xshiftrt (ior (plus X (const_int -1)) X) C)\n \t     with C the size of VAROP - 1 and the shift is logical if\n \t     STORE_FLAG_VALUE is 1 and arithmetic if STORE_FLAG_VALUE is -1,\n@@ -10696,6 +10715,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase EQ:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* Convert (lshiftrt (eq FOO 0) C) to (xor FOO 1) if STORE_FLAG_VALUE\n \t     says that the sign bit can be tested, FOO has mode MODE, C is\n \t     GET_MODE_PRECISION (MODE) - 1, and FOO has only its low-order bit\n@@ -10717,6 +10740,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase NEG:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* (lshiftrt (neg A) C) where A is either 0 or 1 and C is one less\n \t     than the number of bits in the mode is equivalent to A.  */\n \t  if (code == LSHIFTRT\n@@ -10740,6 +10767,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase PLUS:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* (lshiftrt (plus A -1) C) where A is either 0 or 1 and C\n \t     is one less than the number of bits in the mode is\n \t     equivalent to (xor A 1).  */\n@@ -10821,6 +10852,10 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  break;\n \n \tcase MINUS:\n+\t  /* The following rules apply only to scalars.  */\n+\t  if (shift_mode != shift_unit_mode)\n+\t    break;\n+\n \t  /* If we have (xshiftrt (minus (ashiftrt X C)) X) C)\n \t     with C the size of VAROP - 1 and the shift is logical if\n \t     STORE_FLAG_VALUE is 1 and arithmetic if STORE_FLAG_VALUE is -1,\n@@ -10854,8 +10889,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t      && GET_CODE (XEXP (varop, 0)) == LSHIFTRT\n \t      && CONST_INT_P (XEXP (XEXP (varop, 0), 1))\n \t      && (INTVAL (XEXP (XEXP (varop, 0), 1))\n-\t\t  >= (GET_MODE_PRECISION (GET_MODE (XEXP (varop, 0)))\n-\t\t      - GET_MODE_PRECISION (GET_MODE (varop)))))\n+\t\t  >= (GET_MODE_UNIT_PRECISION (GET_MODE (XEXP (varop, 0)))\n+\t\t      - GET_MODE_UNIT_PRECISION (GET_MODE (varop)))))\n \t    {\n \t      rtx varop_inner = XEXP (varop, 0);\n "}]}