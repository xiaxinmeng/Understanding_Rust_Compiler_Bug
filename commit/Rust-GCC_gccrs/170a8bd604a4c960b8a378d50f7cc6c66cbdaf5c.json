{"sha": "170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwYThiZDYwNGE0Yzk2MGI4YTM3OGQ1MGY3Y2M2YzY2Y2JkYWY1Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-12-22T10:22:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-12-22T10:22:15Z"}, "message": "extend.texi (Loop-Specific Pragmas): Document pragma GCC unroll.\n\n\t* doc/extend.texi (Loop-Specific Pragmas): Document pragma GCC unroll.\nc-family/\n\t* c-pragma.c (init_pragma): Register pragma GCC unroll.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_UNROLL.\nc/\n\t* c-parser.c (c_parser_while_statement): Add unroll parameter and\n\tbuild ANNOTATE_EXPR if present.  Add 3rd operand to ANNOTATE_EXPR.\n\t(c_parser_do_statement): Likewise.\n\t(c_parser_for_statement): Likewise.\n\t(c_parser_statement_after_labels): Adjust calls to above.\n\t(c_parse_pragma_ivdep): New static function.\n\t(c_parser_pragma_unroll): Likewise.\n\t(c_parser_pragma) <PRAGMA_IVDEP>: Add support for pragma Unroll.\n\t<PRAGMA_UNROLL>: New case.\ncp/\n\t* constexpr.c (cxx_eval_constant_expression) <ANNOTATE_EXPR>: Remove\n\tassertion on 2nd operand.\n\t(potential_constant_expression_1): Likewise.\n\t* cp-tree.def (RANGE_FOR_STMT): Take a 5th operand.\n\t* cp-tree.h (RANGE_FOR_UNROLL): New macro.\n\t(cp_convert_range_for): Adjust prototype.\n\t(finish_while_stmt_cond): Likewise.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t* init.c (build_vec_init): Adjut call to finish_for_cond.\n\t* parser.c (cp_parser_statement): Adjust call to\n\tcp_parser_iteration_statement.\n\t(cp_parser_for): Add unroll parameter and pass it in calls to\n\tcp_parser_range_for and cp_parser_c_for.\n\t(cp_parser_c_for): Add unroll parameter and pass it in call to\n\tfinish_for_cond.\n\t(cp_parser_range_for): Add unroll parameter, set in on RANGE_FOR_STMT\n\tand pass it in call to cp_convert_range_for.\n\t(cp_convert_range_for): Add unroll parameter and pass it in call to\n\tfinish_for_cond.\n\t(cp_parser_iteration_statement): Add unroll parameter and pass it in\n\tcalls to finish_while_stmt_cond, finish_do_stmt and cp_parser_for.\n\t(cp_parser_pragma_ivdep): New static function.\n\t(cp_parser_pragma_unroll): Likewise.\n\t(cp_parser_pragma) <PRAGMA_IVDEP>: Add support for pragma Unroll.\n\t<PRAGMA_UNROLL>: New case.\n\t* pt.c (tsubst_expr) <FOR_STMT>: Adjust call to finish_for_cond.\n\t<RANGE_FOR_STMT>: Pass unrolling factor to cp_convert_range_for.\n\t<WHILE_STMT>: Adjust call to finish_while_stmt_cond.\n\t<DO_STMT>: Adjust call to finish_do_stmt.\n\t* semantics.c (finish_while_stmt_cond): Add unroll parameter and\n\tbuild ANNOTATE_EXPR if present.\n\t(finish_do_stmt): Likewise.\n\t(finish_for_cond): Likewise.\n\t(begin_range_for_stmt): Build RANGE_FOR_STMT with 5th operand.\nfortran/\n\t* array.c (gfc_copy_iterator): Copy unroll field.\n\t* decl.c (directive_unroll): New global variable.\n\t(gfc_match_gcc_unroll): New function.\n\t* gfortran.h (gfc_iterator]): Add unroll field.\n\t(directive_unroll): Declare:\n\t* match.c (gfc_match_do): Use memset to initialize the iterator.\n\t* match.h (gfc_match_gcc_unroll): New prototype.\n\t* parse.c (decode_gcc_attribute): Match \"unroll\".\n\t(parse_do_block): Set iterator's unroll.\n\t(parse_executable): Diagnose misplaced unroll directive.\n\t* trans-stmt.c (gfc_trans_simple_do) Annotate loop condition with\n\tannot_expr_unroll_kind.\n\t(gfc_trans_do): Likewise.\n\t* gfortran.texi (GNU Fortran Compiler Directives): Split section into\n\tsubections 'ATTRIBUTES directive' and 'UNROLL directive'.\n\nFrom-SVN: r255973", "tree": {"sha": "51107593d97f5e01e7b9dfa212cf1ab21d1998f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51107593d97f5e01e7b9dfa212cf1ab21d1998f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/comments", "author": null, "committer": null, "parents": [{"sha": "fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5"}], "stats": {"total": 1001, "additions": 926, "deletions": 75}, "files": [{"sha": "3d36602d7773402f8744f4e95f03882a5266edd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,8 @@\n+2017-12-22  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/extend.texi (Loop-Specific Pragmas): Document pragma GCC unroll.\n+\n 2017-12-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/83487"}, {"sha": "f4efa6818e85cc281cc29ca09f5fa2e4f4193a33", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,9 @@\n+2017-12-22  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-pragma.c (init_pragma): Register pragma GCC unroll.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_UNROLL.\n+\n 2017-12-22  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/83527"}, {"sha": "a4e9b745adbd843fddc84bd71b5119bb53339c0f", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1526,6 +1526,10 @@ init_pragma (void)\n     cpp_register_deferred_pragma (parse_in, \"GCC\", \"ivdep\", PRAGMA_IVDEP, false,\n \t\t\t\t  false);\n \n+  if (!flag_preprocess_only)\n+    cpp_register_deferred_pragma (parse_in, \"GCC\", \"unroll\", PRAGMA_UNROLL,\n+\t\t\t\t  false, false);\n+\n #ifdef HANDLE_PRAGMA_PACK_WITH_EXPANSION\n   c_register_pragma_with_expansion (0, \"pack\", handle_pragma_pack);\n #else"}, {"sha": "f55fe4fefdaa45c63590a122fb8857fa5779e7d3", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -69,6 +69,7 @@ enum pragma_kind {\n \n   PRAGMA_GCC_PCH_PREPROCESS,\n   PRAGMA_IVDEP,\n+  PRAGMA_UNROLL,\n \n   PRAGMA_FIRST_EXTERNAL\n };"}, {"sha": "f4756c800a17463c03c34c32684f45494d16de2e", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,16 @@\n+2017-12-22  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-parser.c (c_parser_while_statement): Add unroll parameter and\n+\tbuild ANNOTATE_EXPR if present.  Add 3rd operand to ANNOTATE_EXPR.\n+\t(c_parser_do_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.\n+\t(c_parser_statement_after_labels): Adjust calls to above.\n+\t(c_parse_pragma_ivdep): New static function.\n+\t(c_parser_pragma_unroll): Likewise.\n+\t(c_parser_pragma) <PRAGMA_IVDEP>: Add support for pragma Unroll.\n+\t<PRAGMA_UNROLL>: New case.\n+\n 2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-typeck.c (comptypes_internal, function_types_compatible_p,"}, {"sha": "05d1e0fe46ea7894cecb0f0142c8a867371af446", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 120, "deletions": 24, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1406,9 +1406,9 @@ static tree c_parser_c99_block_statement (c_parser *, bool *,\n \t\t\t\t\t  location_t * = NULL);\n static void c_parser_if_statement (c_parser *, bool *, vec<tree> *);\n static void c_parser_switch_statement (c_parser *, bool *);\n-static void c_parser_while_statement (c_parser *, bool, bool *);\n-static void c_parser_do_statement (c_parser *, bool);\n-static void c_parser_for_statement (c_parser *, bool, bool *);\n+static void c_parser_while_statement (c_parser *, bool, unsigned short, bool *);\n+static void c_parser_do_statement (c_parser *, bool, unsigned short);\n+static void c_parser_for_statement (c_parser *, bool, unsigned short, bool *);\n static tree c_parser_asm_statement (c_parser *);\n static tree c_parser_asm_operands (c_parser *);\n static tree c_parser_asm_goto_operands (c_parser *);\n@@ -5400,13 +5400,13 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t  c_parser_switch_statement (parser, if_p);\n \t  break;\n \tcase RID_WHILE:\n-\t  c_parser_while_statement (parser, false, if_p);\n+\t  c_parser_while_statement (parser, false, 0, if_p);\n \t  break;\n \tcase RID_DO:\n-\t  c_parser_do_statement (parser, false);\n+\t  c_parser_do_statement (parser, 0, false);\n \t  break;\n \tcase RID_FOR:\n-\t  c_parser_for_statement (parser, false, if_p);\n+\t  c_parser_for_statement (parser, false, 0, if_p);\n \t  break;\n \tcase RID_GOTO:\n \t  c_parser_consume_token (parser);\n@@ -5896,7 +5896,8 @@ c_parser_switch_statement (c_parser *parser, bool *if_p)\n    implement -Wparentheses.  */\n \n static void\n-c_parser_while_statement (c_parser *parser, bool ivdep, bool *if_p)\n+c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n+\t\t\t  bool *if_p)\n {\n   tree block, cond, body, save_break, save_cont;\n   location_t loc;\n@@ -5912,6 +5913,11 @@ c_parser_while_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t\t   build_int_cst (integer_type_node,\n \t\t\t\t  annot_expr_ivdep_kind),\n \t\t   integer_zero_node);\n+  if (unroll && cond != error_mark_node)\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t  annot_expr_unroll_kind),\n+\t\t   build_int_cst (integer_type_node, unroll));\n   save_break = c_break_label;\n   c_break_label = NULL_TREE;\n   save_cont = c_cont_label;\n@@ -5946,7 +5952,7 @@ c_parser_while_statement (c_parser *parser, bool ivdep, bool *if_p)\n */\n \n static void\n-c_parser_do_statement (c_parser *parser, bool ivdep)\n+c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n {\n   tree block, cond, body, save_break, save_cont, new_break, new_cont;\n   location_t loc;\n@@ -5974,6 +5980,11 @@ c_parser_do_statement (c_parser *parser, bool ivdep)\n \t\t   build_int_cst (integer_type_node,\n \t\t\t\t  annot_expr_ivdep_kind),\n \t\t   integer_zero_node);\n+  if (unroll && cond != error_mark_node)\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t  annot_expr_unroll_kind),\n+ \t\t   build_int_cst (integer_type_node, unroll));\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n   c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);\n@@ -6040,7 +6051,8 @@ c_parser_do_statement (c_parser *parser, bool ivdep)\n    implement -Wparentheses.  */\n \n static void\n-c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n+c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n+\t\t\tbool *if_p)\n {\n   tree block, cond, incr, save_break, save_cont, body;\n   /* The following are only used when parsing an ObjC foreach statement.  */\n@@ -6159,6 +6171,12 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t\t\t\t  \"%<GCC ivdep%> pragma\");\n \t\t  cond = error_mark_node;\n \t\t}\n+\t      else if (unroll)\n+\t\t{\n+\t\t  c_parser_error (parser, \"missing loop condition in loop with \"\n+\t\t\t\t  \"%<GCC unroll%> pragma\");\n+\t\t  cond = error_mark_node;\n+\t\t}\n \t      else\n \t\t{\n \t\t  c_parser_consume_token (parser);\n@@ -6176,6 +6194,11 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t\t\t   build_int_cst (integer_type_node,\n \t\t\t\t\t  annot_expr_ivdep_kind),\n \t\t\t   integer_zero_node);\n+\t  if (unroll && cond != error_mark_node)\n+\t    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+ \t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t  annot_expr_unroll_kind),\n+\t\t\t   build_int_cst (integer_type_node, unroll));\n \t}\n       /* Parse the increment expression (the third expression in a\n \t for-statement).  In the case of a foreach-statement, this is\n@@ -10833,6 +10856,49 @@ c_parser_objc_at_dynamic_declaration (c_parser *parser)\n }\n \n \f\n+/* Parse a pragma GCC ivdep.  */\n+\n+static bool\n+c_parse_pragma_ivdep (c_parser *parser)\n+{\n+  c_parser_consume_pragma (parser);\n+  c_parser_skip_to_pragma_eol (parser);\n+  return true;\n+}\n+\n+/* Parse a pragma GCC unroll.  */\n+\n+static unsigned short\n+c_parser_pragma_unroll (c_parser *parser)\n+{\n+  unsigned short unroll;\n+  c_parser_consume_pragma (parser);\n+  location_t location = c_parser_peek_token (parser)->location;\n+  tree expr = c_parser_expr_no_commas (parser, NULL).value;\n+  mark_exp_read (expr);\n+  expr = c_fully_fold (expr, false, NULL);\n+  HOST_WIDE_INT lunroll = 0;\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+      || TREE_CODE (expr) != INTEGER_CST\n+      || (lunroll = tree_to_shwi (expr)) < 0\n+      || lunroll >= USHRT_MAX)\n+    {\n+      error_at (location, \"%<#pragma GCC unroll%> requires an\"\n+\t\t\" assignment-expression that evaluates to a non-negative\"\n+\t\t\" integral constant less than %u\", USHRT_MAX);\n+      unroll = 0;\n+    }\n+  else\n+    {\n+      unroll = (unsigned short)lunroll;\n+      if (unroll == 0)\n+\tunroll = 1;\n+    }\n+\n+  c_parser_skip_to_pragma_eol (parser);\n+  return unroll;\n+}\n+\n /* Handle pragmas.  Some OpenMP pragmas are associated with, and therefore\n    should be considered, statements.  ALLOW_STMT is true if we're within\n    the context of a function and such pragmas are to be allowed.  Returns\n@@ -10975,21 +11041,51 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       return c_parser_omp_ordered (parser, context, if_p);\n \n     case PRAGMA_IVDEP:\n-      c_parser_consume_pragma (parser);\n-      c_parser_skip_to_pragma_eol (parser);\n-      if (!c_parser_next_token_is_keyword (parser, RID_FOR)\n-\t  && !c_parser_next_token_is_keyword (parser, RID_WHILE)\n-\t  && !c_parser_next_token_is_keyword (parser, RID_DO))\n-\t{\n-\t  c_parser_error (parser, \"for, while or do statement expected\");\n-\t  return false;\n-\t}\n-      if (c_parser_next_token_is_keyword (parser, RID_FOR))\n-\tc_parser_for_statement (parser, true, if_p);\n-      else if (c_parser_next_token_is_keyword (parser, RID_WHILE))\n-\tc_parser_while_statement (parser, true, if_p);\n-      else\n-\tc_parser_do_statement (parser, true);\n+      {\n+\tconst bool ivdep = c_parse_pragma_ivdep (parser);\n+\tunsigned short unroll;\n+\tif (c_parser_peek_token (parser)->pragma_kind == PRAGMA_UNROLL)\n+\t  unroll = c_parser_pragma_unroll (parser);\n+\telse\n+\t  unroll = 0;\n+\tif (!c_parser_next_token_is_keyword (parser, RID_FOR)\n+\t    && !c_parser_next_token_is_keyword (parser, RID_WHILE)\n+\t    && !c_parser_next_token_is_keyword (parser, RID_DO))\n+\t  {\n+\t    c_parser_error (parser, \"for, while or do statement expected\");\n+\t    return false;\n+\t  }\n+\tif (c_parser_next_token_is_keyword (parser, RID_FOR))\n+\t  c_parser_for_statement (parser, ivdep, unroll, if_p);\n+\telse if (c_parser_next_token_is_keyword (parser, RID_WHILE))\n+\t  c_parser_while_statement (parser, ivdep, unroll, if_p);\n+\telse\n+\t  c_parser_do_statement (parser, ivdep, unroll);\n+      }\n+      return false;\n+\n+    case PRAGMA_UNROLL:\n+      {\n+\tunsigned short unroll = c_parser_pragma_unroll (parser);\n+\tbool ivdep;\n+\tif (c_parser_peek_token (parser)->pragma_kind == PRAGMA_IVDEP)\n+\t  ivdep = c_parse_pragma_ivdep (parser);\n+\telse\n+\t  ivdep = false;\n+\tif (!c_parser_next_token_is_keyword (parser, RID_FOR)\n+\t    && !c_parser_next_token_is_keyword (parser, RID_WHILE)\n+\t    && !c_parser_next_token_is_keyword (parser, RID_DO))\n+\t  {\n+\t    c_parser_error (parser, \"for, while or do statement expected\");\n+\t    return false;\n+\t  }\n+\tif (c_parser_next_token_is_keyword (parser, RID_FOR))\n+\t  c_parser_for_statement (parser, ivdep, unroll, if_p);\n+\telse if (c_parser_next_token_is_keyword (parser, RID_WHILE))\n+\t  c_parser_while_statement (parser, ivdep, unroll, if_p);\n+\telse\n+\t  c_parser_do_statement (parser, ivdep, unroll);\n+      }\n       return false;\n \n     case PRAGMA_GCC_PCH_PREPROCESS:"}, {"sha": "fbffe0c339041f0688ac86f694639011fd9cb561", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,42 @@\n+2017-12-22  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* constexpr.c (cxx_eval_constant_expression) <ANNOTATE_EXPR>: Remove\n+\tassertion on 2nd operand.\n+\t(potential_constant_expression_1): Likewise.\n+\t* cp-tree.def (RANGE_FOR_STMT): Take a 5th operand.\n+\t* cp-tree.h (RANGE_FOR_UNROLL): New macro.\n+\t(cp_convert_range_for): Adjust prototype.\n+\t(finish_while_stmt_cond): Likewise.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t* init.c (build_vec_init): Adjut call to finish_for_cond.\n+\t* parser.c (cp_parser_statement): Adjust call to\n+\tcp_parser_iteration_statement.\n+\t(cp_parser_for): Add unroll parameter and pass it in calls to\n+\tcp_parser_range_for and cp_parser_c_for.\n+\t(cp_parser_c_for): Add unroll parameter and pass it in call to\n+\tfinish_for_cond.\n+\t(cp_parser_range_for): Add unroll parameter, set in on RANGE_FOR_STMT\n+\tand pass it in call to cp_convert_range_for.\n+\t(cp_convert_range_for): Add unroll parameter and pass it in call to\n+\tfinish_for_cond.\n+\t(cp_parser_iteration_statement): Add unroll parameter and pass it in\n+\tcalls to finish_while_stmt_cond, finish_do_stmt and cp_parser_for.\n+\t(cp_parser_pragma_ivdep): New static function.\n+\t(cp_parser_pragma_unroll): Likewise.\n+\t(cp_parser_pragma) <PRAGMA_IVDEP>: Add support for pragma Unroll.\n+\t<PRAGMA_UNROLL>: New case.\n+\t* pt.c (tsubst_expr) <FOR_STMT>: Adjust call to finish_for_cond.\n+\t<RANGE_FOR_STMT>: Pass unrolling factor to cp_convert_range_for.\n+\t<WHILE_STMT>: Adjust call to finish_while_stmt_cond.\n+\t<DO_STMT>: Adjust call to finish_do_stmt.\n+\t* semantics.c (finish_while_stmt_cond): Add unroll parameter and\n+\tbuild ANNOTATE_EXPR if present.\n+\t(finish_do_stmt): Likewise.\n+\t(finish_for_cond): Likewise.\n+\t(begin_range_for_stmt): Build RANGE_FOR_STMT with 5th operand.\n+\n 2017-12-21  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/83406"}, {"sha": "25b19fa02290d9c19694db9c158bbcdf550e5432", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -4689,7 +4689,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n \n     case ANNOTATE_EXPR:\n-      gcc_assert (tree_to_uhwi (TREE_OPERAND (t, 1)) == annot_expr_ivdep_kind);\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\tlval,\n \t\t\t\t\tnon_constant_p, overflow_p,\n@@ -5940,7 +5939,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       }\n \n     case ANNOTATE_EXPR:\n-      gcc_assert (tree_to_uhwi (TREE_OPERAND (t, 1)) == annot_expr_ivdep_kind);\n       return RECUR (TREE_OPERAND (t, 0), rval);\n \n     default:"}, {"sha": "d04624a5bd209469cf966a243234efac48e00d8b", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -302,8 +302,8 @@ DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_statement, 5)\n \n /* Used to represent a range-based `for' statement. The operands are\n    RANGE_FOR_DECL, RANGE_FOR_EXPR, RANGE_FOR_BODY, and RANGE_FOR_SCOPE,\n-   respectively.  Only used in templates.  */\n-DEFTREECODE (RANGE_FOR_STMT, \"range_for_stmt\", tcc_statement, 4)\n+   RANGE_FOR_UNROLL respectively.  Only used in templates.  */\n+DEFTREECODE (RANGE_FOR_STMT, \"range_for_stmt\", tcc_statement, 5)\n \n /* Used to represent a 'while' statement. The operands are WHILE_COND\n    and WHILE_BODY, respectively.  */"}, {"sha": "d408370f898b0541a42d0dfd90ebbafd67aa9987", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -4844,6 +4844,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define RANGE_FOR_EXPR(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 1)\n #define RANGE_FOR_BODY(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 2)\n #define RANGE_FOR_SCOPE(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 3)\n+#define RANGE_FOR_UNROLL(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 4)\n #define RANGE_FOR_IVDEP(NODE)\tTREE_LANG_FLAG_6 (RANGE_FOR_STMT_CHECK (NODE))\n \n #define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n@@ -6433,7 +6434,8 @@ extern tree implicitly_declare_fn               (special_function_kind, tree,\n extern bool maybe_clone_body\t\t\t(tree);\n \n /* In parser.c */\n-extern tree cp_convert_range_for (tree, tree, tree, tree, unsigned int, bool);\n+extern tree cp_convert_range_for (tree, tree, tree, tree, unsigned int, bool,\n+\t\t\t\t  unsigned short);\n extern bool parsing_nsdmi (void);\n extern bool parsing_default_capturing_generic_lambda_in_template (void);\n extern void inject_this_parameter (tree, cp_cv_quals);\n@@ -6718,16 +6720,16 @@ extern void begin_else_clause\t\t\t(tree);\n extern void finish_else_clause\t\t\t(tree);\n extern void finish_if_stmt\t\t\t(tree);\n extern tree begin_while_stmt\t\t\t(void);\n-extern void finish_while_stmt_cond\t\t(tree, tree, bool);\n+extern void finish_while_stmt_cond\t(tree, tree, bool, unsigned short);\n extern void finish_while_stmt\t\t\t(tree);\n extern tree begin_do_stmt\t\t\t(void);\n extern void finish_do_body\t\t\t(tree);\n-extern void finish_do_stmt\t\t\t(tree, tree, bool);\n+extern void finish_do_stmt\t\t(tree, tree, bool, unsigned short);\n extern tree finish_return_stmt\t\t\t(tree);\n extern tree begin_for_scope\t\t\t(tree *);\n extern tree begin_for_stmt\t\t\t(tree, tree);\n extern void finish_init_stmt\t\t\t(tree);\n-extern void finish_for_cond\t\t\t(tree, tree, bool);\n+extern void finish_for_cond\t\t(tree, tree, bool, unsigned short);\n extern void finish_for_expr\t\t\t(tree, tree);\n extern void finish_for_stmt\t\t\t(tree);\n extern tree begin_range_for_stmt\t\t(tree, tree);"}, {"sha": "6e11cf3423c44ea81f7ae2cc1108aec196f7d189", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -4323,7 +4323,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n       finish_init_stmt (for_stmt);\n       finish_for_cond (build2 (GT_EXPR, boolean_type_node, iterator,\n \t\t\t       build_int_cst (TREE_TYPE (iterator), -1)),\n-\t\t       for_stmt, false);\n+\t\t       for_stmt, false, 0);\n       elt_init = cp_build_unary_op (PREDECREMENT_EXPR, iterator, false,\n \t\t\t\t    complain);\n       if (elt_init == error_mark_node)"}, {"sha": "b04ed9adce0c040c3c86c619cfc683496cf82da6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 116, "deletions": 23, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -2112,15 +2112,15 @@ static tree cp_parser_selection_statement\n static tree cp_parser_condition\n   (cp_parser *);\n static tree cp_parser_iteration_statement\n-  (cp_parser *, bool *, bool);\n+  (cp_parser *, bool *, bool, unsigned short);\n static bool cp_parser_init_statement\n   (cp_parser *, tree *decl);\n static tree cp_parser_for\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, unsigned short);\n static tree cp_parser_c_for\n-  (cp_parser *, tree, tree, bool);\n+  (cp_parser *, tree, tree, bool, unsigned short);\n static tree cp_parser_range_for\n-  (cp_parser *, tree, tree, tree, bool);\n+  (cp_parser *, tree, tree, tree, bool, unsigned short);\n static void do_range_for_auto_deduction\n   (tree, tree);\n static tree cp_parser_perform_range_for_lookup\n@@ -10742,7 +10742,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tcase RID_WHILE:\n \tcase RID_DO:\n \tcase RID_FOR:\n-\t  statement = cp_parser_iteration_statement (parser, if_p, false);\n+\t  statement = cp_parser_iteration_statement (parser, if_p, false, 0);\n \t  break;\n \n \tcase RID_BREAK:\n@@ -11579,7 +11579,7 @@ cp_parser_condition (cp_parser* parser)\n    not included. */\n \n static tree\n-cp_parser_for (cp_parser *parser, bool ivdep)\n+cp_parser_for (cp_parser *parser, bool ivdep, unsigned short unroll)\n {\n   tree init, scope, decl;\n   bool is_range_for;\n@@ -11591,13 +11591,14 @@ cp_parser_for (cp_parser *parser, bool ivdep)\n   is_range_for = cp_parser_init_statement (parser, &decl);\n \n   if (is_range_for)\n-    return cp_parser_range_for (parser, scope, init, decl, ivdep);\n+    return cp_parser_range_for (parser, scope, init, decl, ivdep, unroll);\n   else\n-    return cp_parser_c_for (parser, scope, init, ivdep);\n+    return cp_parser_c_for (parser, scope, init, ivdep, unroll);\n }\n \n static tree\n-cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep)\n+cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep,\n+\t\t unsigned short unroll)\n {\n   /* Normal for loop */\n   tree condition = NULL_TREE;\n@@ -11618,7 +11619,13 @@ cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep)\n \t\t       \"%<GCC ivdep%> pragma\");\n       condition = error_mark_node;\n     }\n-  finish_for_cond (condition, stmt, ivdep);\n+  else if (unroll)\n+    {\n+      cp_parser_error (parser, \"missing loop condition in loop with \"\n+\t\t       \"%<GCC unroll%> pragma\");\n+      condition = error_mark_node;\n+    }\n+  finish_for_cond (condition, stmt, ivdep, unroll);\n   /* Look for the `;'.  */\n   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n@@ -11642,7 +11649,7 @@ cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep)\n \n static tree\n cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n-\t\t     bool ivdep)\n+\t\t     bool ivdep, unsigned short unroll)\n {\n   tree stmt, range_expr;\n   auto_vec <cxx_binding *, 16> bindings;\n@@ -11711,6 +11718,8 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n       stmt = begin_range_for_stmt (scope, init);\n       if (ivdep)\n \tRANGE_FOR_IVDEP (stmt) = 1;\n+      if (unroll)\n+\tRANGE_FOR_UNROLL (stmt) = build_int_cst (integer_type_node, unroll);\n       finish_range_for_decl (stmt, range_decl, range_expr);\n       if (!type_dependent_expression_p (range_expr)\n \t  /* do_auto_deduction doesn't mess with template init-lists.  */\n@@ -11721,7 +11730,8 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n     {\n       stmt = begin_for_stmt (scope, init);\n       stmt = cp_convert_range_for (stmt, range_decl, range_expr,\n-\t\t\t\t   decomp_first_name, decomp_cnt, ivdep);\n+\t\t\t\t   decomp_first_name, decomp_cnt, ivdep,\n+\t\t\t\t   unroll);\n     }\n   return stmt;\n }\n@@ -11815,7 +11825,7 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n tree\n cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n \t\t      tree decomp_first_name, unsigned int decomp_cnt,\n-\t\t      bool ivdep)\n+\t\t      bool ivdep, unsigned short unroll)\n {\n   tree begin, end;\n   tree iter_type, begin_expr, end_expr;\n@@ -11876,7 +11886,7 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n \t\t\t\t begin, ERROR_MARK,\n \t\t\t\t end, ERROR_MARK,\n \t\t\t\t NULL, tf_warning_or_error);\n-  finish_for_cond (condition, statement, ivdep);\n+  finish_for_cond (condition, statement, ivdep, unroll);\n \n   /* The new increment expression.  */\n   expression = finish_unary_op_expr (input_location,\n@@ -12054,7 +12064,8 @@ cp_parser_range_for_member_function (tree range, tree identifier)\n    Returns the new WHILE_STMT, DO_STMT, FOR_STMT or RANGE_FOR_STMT.  */\n \n static tree\n-cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n+cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep,\n+\t\t\t       unsigned short unroll)\n {\n   cp_token *token;\n   enum rid keyword;\n@@ -12088,7 +12099,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n \tparens.require_open (parser);\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n-\tfinish_while_stmt_cond (condition, statement, ivdep);\n+\tfinish_while_stmt_cond (condition, statement, ivdep, unroll);\n \t/* Look for the `)'.  */\n \tparens.require_close (parser);\n \t/* Parse the dependent statement.  */\n@@ -12123,7 +12134,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n \t/* Parse the expression.  */\n \texpression = cp_parser_expression (parser);\n \t/* We're done with the do-statement.  */\n-\tfinish_do_stmt (expression, statement, ivdep);\n+\tfinish_do_stmt (expression, statement, ivdep, unroll);\n \t/* Look for the `)'.  */\n \tparens.require_close (parser);\n \t/* Look for the `;'.  */\n@@ -12137,7 +12148,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n \tmatching_parens parens;\n \tparens.require_open (parser);\n \n-\tstatement = cp_parser_for (parser, ivdep);\n+\tstatement = cp_parser_for (parser, ivdep, unroll);\n \n \t/* Look for the `)'.  */\n \tparens.require_close (parser);\n@@ -38377,6 +38388,45 @@ cp_parser_initial_pragma (cp_token *first_token)\n   cp_lexer_get_preprocessor_token (NULL, first_token);\n }\n \n+/* Parse a pragma GCC ivdep.  */\n+\n+static bool\n+cp_parser_pragma_ivdep (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  return true;\n+}\n+\n+/* Parse a pragma GCC unroll.  */\n+\n+static unsigned short\n+cp_parser_pragma_unroll (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  location_t location = cp_lexer_peek_token (parser->lexer)->location;\n+  tree expr = cp_parser_constant_expression (parser);\n+  unsigned short unroll;\n+  expr = maybe_constant_value (expr);\n+  HOST_WIDE_INT lunroll = 0;\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (expr))\n+      || TREE_CODE (expr) != INTEGER_CST\n+      || (lunroll = tree_to_shwi (expr)) < 0\n+      || lunroll >= USHRT_MAX)\n+    {\n+      error_at (location, \"%<#pragma GCC unroll%> requires an\"\n+\t\t\" assignment-expression that evaluates to a non-negative\"\n+\t\t\" integral constant less than %u\", USHRT_MAX);\n+      unroll = 0;\n+    }\n+  else\n+    {\n+      unroll = (unsigned short)lunroll;\n+      if (unroll == 0)\n+\tunroll = 1;\n+    }\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  return unroll;\n+}\n+\n /* Normal parsing of a pragma token.  Here we can (and must) use the\n    regular lexer.  */\n \n@@ -38618,17 +38668,60 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \t\t      \"%<#pragma GCC ivdep%> must be inside a function\");\n \t    break;\n \t  }\n-\tcp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-\tcp_token *tok;\n-\ttok = cp_lexer_peek_token (the_parser->lexer);\n+\tconst bool ivdep = cp_parser_pragma_ivdep (parser, pragma_tok);\n+\tunsigned short unroll;\n+\tcp_token *tok = cp_lexer_peek_token (the_parser->lexer);\n+\tif (tok->type == CPP_PRAGMA\n+\t    && cp_parser_pragma_kind (tok) == PRAGMA_UNROLL)\n+\t  {\n+\t    tok = cp_lexer_consume_token (parser->lexer);\n+\t    unroll = cp_parser_pragma_unroll (parser, tok);\n+\t    tok = cp_lexer_peek_token (the_parser->lexer);\n+\t  }\n+\telse\n+\t  unroll = 0;\n+\tif (tok->type != CPP_KEYWORD\n+\t    || (tok->keyword != RID_FOR\n+\t\t&& tok->keyword != RID_WHILE\n+\t\t&& tok->keyword != RID_DO))\n+\t  {\n+\t    cp_parser_error (parser, \"for, while or do statement expected\");\n+\t    return false;\n+\t  }\n+\tcp_parser_iteration_statement (parser, if_p, ivdep, unroll);\n+\treturn true;\n+      }\n+\n+    case PRAGMA_UNROLL:\n+      {\n+\tif (context == pragma_external)\n+\t  {\n+\t    error_at (pragma_tok->location,\n+\t\t      \"%<#pragma GCC unroll%> must be inside a function\");\n+\t    break;\n+\t  }\n+\tconst unsigned short unroll\n+\t  = cp_parser_pragma_unroll (parser, pragma_tok);\n+\tbool ivdep;\n+\tcp_token *tok = cp_lexer_peek_token (the_parser->lexer);\n+\tif (tok->type == CPP_PRAGMA\n+\t    && cp_parser_pragma_kind (tok) == PRAGMA_IVDEP)\n+\t  {\n+\t    tok = cp_lexer_consume_token (parser->lexer);\n+\t    ivdep = cp_parser_pragma_ivdep (parser, tok);\n+\t    tok = cp_lexer_peek_token (the_parser->lexer);\n+\t  }\n+\telse\n+\t  ivdep = false;\n \tif (tok->type != CPP_KEYWORD\n-\t    || (tok->keyword != RID_FOR && tok->keyword != RID_WHILE\n+\t    || (tok->keyword != RID_FOR\n+\t\t&& tok->keyword != RID_WHILE\n \t\t&& tok->keyword != RID_DO))\n \t  {\n \t    cp_parser_error (parser, \"for, while or do statement expected\");\n \t    return false;\n \t  }\n-\tcp_parser_iteration_statement (parser, if_p, true);\n+\tcp_parser_iteration_statement (parser, if_p, ivdep, unroll);\n \treturn true;\n       }\n "}, {"sha": "a8144e85a39ddd2ece2cd026530be2bbbd186992", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -16127,7 +16127,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       RECUR (FOR_INIT_STMT (t));\n       finish_init_stmt (stmt);\n       tmp = RECUR (FOR_COND (t));\n-      finish_for_cond (tmp, stmt, false);\n+      finish_for_cond (tmp, stmt, false, 0);\n       tmp = RECUR (FOR_EXPR (t));\n       finish_for_expr (tmp, stmt);\n       {\n@@ -16146,18 +16146,20 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n         decl = tsubst (decl, args, complain, in_decl);\n         maybe_push_decl (decl);\n         expr = RECUR (RANGE_FOR_EXPR (t));\n+\tconst unsigned short unroll\n+\t  = RANGE_FOR_UNROLL (t) ? tree_to_uhwi (RANGE_FOR_UNROLL (t)) : 0;\n \tif (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n \t  {\n \t    unsigned int cnt;\n \t    tree first;\n \t    decl = tsubst_decomp_names (decl, RANGE_FOR_DECL (t), args,\n \t\t\t\t\tcomplain, in_decl, &first, &cnt);\n \t    stmt = cp_convert_range_for (stmt, decl, expr, first, cnt,\n-\t\t\t\t\t RANGE_FOR_IVDEP (t));\n+\t\t\t\t\t RANGE_FOR_IVDEP (t), unroll);\n \t  }\n \telse\n \t  stmt = cp_convert_range_for (stmt, decl, expr, NULL_TREE, 0,\n-\t\t\t\t       RANGE_FOR_IVDEP (t));\n+\t\t\t\t       RANGE_FOR_IVDEP (t), unroll);\n \tbool prev = note_iteration_stmt_body_start ();\n         RECUR (RANGE_FOR_BODY (t));\n \tnote_iteration_stmt_body_end (prev);\n@@ -16168,7 +16170,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     case WHILE_STMT:\n       stmt = begin_while_stmt ();\n       tmp = RECUR (WHILE_COND (t));\n-      finish_while_stmt_cond (tmp, stmt, false);\n+      finish_while_stmt_cond (tmp, stmt, false, 0);\n       {\n \tbool prev = note_iteration_stmt_body_start ();\n \tRECUR (WHILE_BODY (t));\n@@ -16186,7 +16188,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       }\n       finish_do_body (stmt);\n       tmp = RECUR (DO_COND (t));\n-      finish_do_stmt (tmp, stmt, false);\n+      finish_do_stmt (tmp, stmt, false, 0);\n       break;\n \n     case IF_STMT:"}, {"sha": "95b20c5b162b0d3e8e94cdeaf975103125136805", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -798,7 +798,8 @@ begin_while_stmt (void)\n    WHILE_STMT.  */\n \n void\n-finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n+finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep,\n+\t\t\tunsigned short unroll)\n {\n   cond = maybe_convert_cond (cond);\n   finish_cond (&WHILE_COND (while_stmt), cond);\n@@ -810,6 +811,14 @@ finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n \t\t\t\t      build_int_cst (integer_type_node,\n \t\t\t\t\t\t     annot_expr_ivdep_kind),\n \t\t\t\t      integer_zero_node);\n+  if (unroll && cond != error_mark_node)\n+    WHILE_COND (while_stmt) = build3 (ANNOTATE_EXPR,\n+\t\t\t\t      TREE_TYPE (WHILE_COND (while_stmt)),\n+\t\t\t\t      WHILE_COND (while_stmt),\n+\t\t\t\t      build_int_cst (integer_type_node,\n+\t\t\t\t\t\t     annot_expr_unroll_kind),\n+\t\t\t\t      build_int_cst (integer_type_node,\n+\t\t\t\t\t\t     unroll));\n   simplify_loop_decl_cond (&WHILE_COND (while_stmt), WHILE_BODY (while_stmt));\n }\n \n@@ -854,14 +863,18 @@ finish_do_body (tree do_stmt)\n    COND is as indicated.  */\n \n void\n-finish_do_stmt (tree cond, tree do_stmt, bool ivdep)\n+finish_do_stmt (tree cond, tree do_stmt, bool ivdep, unsigned short unroll)\n {\n   cond = maybe_convert_cond (cond);\n   end_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node, annot_expr_ivdep_kind),\n \t\t   integer_zero_node);\n+  if (unroll && cond != error_mark_node)\n+    cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\t   build_int_cst (integer_type_node, annot_expr_unroll_kind),\n+\t\t   build_int_cst (integer_type_node, unroll));\n   DO_COND (do_stmt) = cond;\n }\n \n@@ -970,7 +983,7 @@ finish_init_stmt (tree for_stmt)\n    FOR_STMT.  */\n \n void\n-finish_for_cond (tree cond, tree for_stmt, bool ivdep)\n+finish_for_cond (tree cond, tree for_stmt, bool ivdep, unsigned short unroll)\n {\n   cond = maybe_convert_cond (cond);\n   finish_cond (&FOR_COND (for_stmt), cond);\n@@ -982,6 +995,14 @@ finish_for_cond (tree cond, tree for_stmt, bool ivdep)\n \t\t\t\t  build_int_cst (integer_type_node,\n \t\t\t\t\t\t annot_expr_ivdep_kind),\n \t\t\t\t  integer_zero_node);\n+  if (unroll && cond != error_mark_node)\n+    FOR_COND (for_stmt) = build3 (ANNOTATE_EXPR,\n+\t\t\t\t  TREE_TYPE (FOR_COND (for_stmt)),\n+\t\t\t\t  FOR_COND (for_stmt),\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t annot_expr_unroll_kind),\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t unroll));\n   simplify_loop_decl_cond (&FOR_COND (for_stmt), FOR_BODY (for_stmt));\n }\n \n@@ -1057,7 +1078,7 @@ begin_range_for_stmt (tree scope, tree init)\n   begin_maybe_infinite_loop (boolean_false_node);\n \n   r = build_stmt (input_location, RANGE_FOR_STMT,\n-\t\t  NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n+\t\t  NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n \n   if (scope == NULL_TREE)\n     {"}, {"sha": "2a553ad3e167240b3a8f5aea36932bd7a0185fa0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -22381,9 +22381,7 @@ function.  The parenthesis around the options is optional.\n \n The @code{#pragma GCC target} pragma is presently implemented for\n x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.\n-@end table\n \n-@table @code\n @item #pragma GCC optimize (@var{\"string\"}...)\n @cindex pragma GCC optimize\n \n@@ -22394,9 +22392,7 @@ if @code{attribute((optimize(\"STRING\")))} was specified for that\n function.  The parenthesis around the options is optional.\n @xref{Function Attributes}, for more information about the\n @code{optimize} attribute and the attribute syntax.\n-@end table\n \n-@table @code\n @item #pragma GCC push_options\n @itemx #pragma GCC pop_options\n @cindex pragma GCC push_options\n@@ -22407,15 +22403,14 @@ options.  It is intended for include files where you temporarily want\n to switch to using a different @samp{#pragma GCC target} or\n @samp{#pragma GCC optimize} and then to pop back to the previous\n options.\n-@end table\n \n-@table @code\n @item #pragma GCC reset_options\n @cindex pragma GCC reset_options\n \n This pragma clears the current @code{#pragma GCC target} and\n @code{#pragma GCC optimize} to use the default switches as specified\n on the command line.\n+\n @end table\n \n @node Loop-Specific Pragmas\n@@ -22424,7 +22419,6 @@ on the command line.\n @table @code\n @item #pragma GCC ivdep\n @cindex pragma GCC ivdep\n-@end table\n \n With this pragma, the programmer asserts that there are no loop-carried\n dependencies which would prevent consecutive iterations of\n@@ -22459,6 +22453,16 @@ void ignore_vec_dep (int *a, int k, int c, int m)\n @}\n @end smallexample\n \n+@item #pragma GCC unroll @var{n}\n+@cindex pragma GCC unroll @var{n}\n+\n+You can use this pragma to control how many times a loop should be unrolled.\n+It must be placed immediately before a @code{for}, @code{while} or @code{do}\n+loop or a @code{#pragma GCC ivdep}, and applies only to the loop that follows.\n+@var{n} is an integer constant expression specifying the unrolling factor.\n+The values of @math{0} and @math{1} block any unrolling of the loop.\n+\n+@end table\n \n @node Unnamed Fields\n @section Unnamed Structure and Union Fields"}, {"sha": "d0cbc37bf93aa4fd54b2c09f5f574d98465fb5d0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,22 @@\n+2017-12-22  Bernhard Reutner-Fischer  <aldot@gcc.gnu.org>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* array.c (gfc_copy_iterator): Copy unroll field.\n+\t* decl.c (directive_unroll): New global variable.\n+\t(gfc_match_gcc_unroll): New function.\n+\t* gfortran.h (gfc_iterator]): Add unroll field.\n+\t(directive_unroll): Declare:\n+\t* match.c (gfc_match_do): Use memset to initialize the iterator.\n+\t* match.h (gfc_match_gcc_unroll): New prototype.\n+\t* parse.c (decode_gcc_attribute): Match \"unroll\".\n+\t(parse_do_block): Set iterator's unroll.\n+\t(parse_executable): Diagnose misplaced unroll directive.\n+\t* trans-stmt.c (gfc_trans_simple_do) Annotate loop condition with\n+\tannot_expr_unroll_kind.\n+\t(gfc_trans_do): Likewise.\n+\t* gfortran.texi (GNU Fortran Compiler Directives): Split section into\n+\tsubections 'ATTRIBUTES directive' and 'UNROLL directive'.\n+\n 2017-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* scanner.c (preprocessor_line): Replace Yoda conditions with typical"}, {"sha": "81476b2f6fab8298f6928bd2240d2bc2387cf135", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -2123,6 +2123,7 @@ gfc_copy_iterator (gfc_iterator *src)\n   dest->start = gfc_copy_expr (src->start);\n   dest->end = gfc_copy_expr (src->end);\n   dest->step = gfc_copy_expr (src->step);\n+  dest->unroll = src->unroll;\n \n   return dest;\n }"}, {"sha": "d2c794fc2ae3b5f5ef9857c47b8e273c07dfd8ea", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -95,6 +95,9 @@ gfc_symbol *gfc_new_block;\n \n bool gfc_matching_function;\n \n+/* Set upon parsing a !GCC$ unroll n directive for use in the next loop.  */\n+int directive_unroll = -1;\n+\n /* If a kind expression of a component of a parameterized derived type is\n    parameterized, temporarily store the expression here.  */\n static gfc_expr *saved_kind_expr = NULL;\n@@ -104,7 +107,6 @@ static gfc_expr *saved_kind_expr = NULL;\n static gfc_actual_arglist *decl_type_param_list;\n static gfc_actual_arglist *type_param_spec_list;\n \n-\n /********************* DATA statement subroutines *********************/\n \n static bool in_match_data = false;\n@@ -10958,3 +10960,37 @@ gfc_match_gcc_attributes (void)\n   gfc_error (\"Syntax error in !GCC$ ATTRIBUTES statement at %C\");\n   return MATCH_ERROR;\n }\n+\n+\n+/* Match a !GCC$ UNROLL statement of the form:\n+      !GCC$ UNROLL n\n+\n+   The parameter n is the number of times we are supposed to unroll.\n+\n+   When we come here, we have already matched the !GCC$ UNROLL string.  */\n+match\n+gfc_match_gcc_unroll (void)\n+{\n+  int value;\n+\n+  if (gfc_match_small_int (&value) == MATCH_YES)\n+    {\n+      if (value < 0 || value > USHRT_MAX)\n+\t{\n+\t  gfc_error (\"%<GCC unroll%> directive requires a\"\n+\t      \" non-negative integral constant\"\n+\t      \" less than or equal to %u at %C\",\n+\t      USHRT_MAX\n+\t  );\n+\t  return MATCH_ERROR;\n+\t}\n+      if (gfc_match_eos () == MATCH_YES)\n+\t{\n+\t  directive_unroll = value == 0 ? 1 : value;\n+\t  return MATCH_YES;\n+\t}\n+    }\n+\n+  gfc_error (\"Syntax error in !GCC$ UNROLL directive at %C\");\n+  return MATCH_ERROR;\n+}"}, {"sha": "7b837c9fe508880ab15eb5203c71402f07daef71", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -2350,6 +2350,7 @@ gfc_case;\n typedef struct\n {\n   gfc_expr *var, *start, *end, *step;\n+  unsigned short unroll;\n }\n gfc_iterator;\n \n@@ -2724,6 +2725,7 @@ gfc_finalizer;\n /* decl.c */\n bool gfc_in_match_data (void);\n match gfc_match_char_spec (gfc_typespec *);\n+extern int directive_unroll;\n \n /* Handling Parameterized Derived Types  */\n bool gfc_insert_kind_parameter_exprs (gfc_expr *);"}, {"sha": "fc95ec0bf7462a2fed54fcb780cc0a3f89f81cc7", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -3447,6 +3447,14 @@ as this requires the new array descriptor.\n @node GNU Fortran Compiler Directives\n @section GNU Fortran Compiler Directives\n \n+@menu\n+* ATTRIBUTES directive::\n+* UNROLL directive::\n+@end menu\n+\n+@node ATTRIBUTES directive\n+@subsection ATTRIBUTES directive\n+\n The Fortran standard describes how a conforming program shall\n behave; however, the exact implementation is not standardized.  In order\n to allow the user to choose specific implementation details, compiler\n@@ -3520,6 +3528,19 @@ of the procedure; for variables and procedure pointers, they shall be in\n the same declaration part as the variable or procedure pointer.\n \n \n+@node UNROLL directive\n+@subsection UNROLL directive\n+\n+The syntax of the directive is\n+\n+@code{!GCC$ unroll N}\n+\n+You can use this directive to control how many times a loop should be unrolled.\n+It must be placed immediately before a @code{DO} loop and applies only to the\n+loop that follows.  N is an integer constant specifying the unrolling factor.\n+The values of 0 and 1 block any unrolling of the loop.\n+\n+\n \n @node Non-Fortran Main Program\n @section Non-Fortran Main Program"}, {"sha": "f7de5d501fc348e42614ecadceaf00b86225af17", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -2540,8 +2540,8 @@ gfc_match_do (void)\n \n   old_loc = gfc_current_locus;\n \n+  memset (&iter, '\\0', sizeof (gfc_iterator));\n   label = NULL;\n-  iter.var = iter.start = iter.end = iter.step = NULL;\n \n   m = gfc_match_label ();\n   if (m == MATCH_ERROR)"}, {"sha": "a5f62913a854a9cfa9f2e6e54feff3594f6592e0", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -241,6 +241,7 @@ match gfc_match_contiguous (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n match gfc_match_gcc_attributes (void);\n+match gfc_match_gcc_unroll (void);\n match gfc_match_import (void);\n match gfc_match_intent (void);\n match gfc_match_intrinsic (void);"}, {"sha": "91be6da72367d7fff43158b4a62830d83c630af6", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1063,6 +1063,7 @@ decode_gcc_attribute (void)\n   old_locus = gfc_current_locus;\n \n   match (\"attributes\", gfc_match_gcc_attributes, ST_ATTR_DECL);\n+  match (\"unroll\", gfc_match_gcc_unroll, ST_NONE);\n \n   /* All else has failed, so give up.  See if any of the matchers has\n      stored an error message of some sort.  */\n@@ -4635,7 +4636,14 @@ parse_do_block (void)\n   s.ext.end_do_label = new_st.label1;\n \n   if (new_st.ext.iterator != NULL)\n-    stree = new_st.ext.iterator->var->symtree;\n+    {\n+      stree = new_st.ext.iterator->var->symtree;\n+      if (directive_unroll != -1)\n+\t{\n+\t  new_st.ext.iterator->unroll = directive_unroll;\n+\t  directive_unroll = -1;\n+\t}\n+    }\n   else\n     stree = NULL;\n \n@@ -5393,6 +5401,9 @@ parse_executable (gfc_statement st)\n \t  return st;\n \t}\n \n+      if (directive_unroll != -1)\n+\tgfc_error (\"%<GCC unroll%> directive does not commence a loop at %C\");\n+\n       st = next_statement ();\n     }\n }"}, {"sha": "e6569e020365b21585bff9d4f267769cba019df7", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1979,6 +1979,11 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n \t\t\t    fold_convert (type, to));\n \n   cond = gfc_evaluate_now_loc (loc, cond, &body);\n+  if (code->ext.iterator->unroll && cond != error_mark_node)\n+    cond\n+      = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\tbuild_int_cst (integer_type_node, annot_expr_unroll_kind),\n+\t\tbuild_int_cst (integer_type_node, code->ext.iterator->unroll));\n \n   /* The loop exit.  */\n   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n@@ -2305,6 +2310,11 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   /* End with the loop condition.  Loop until countm1t == 0.  */\n   cond = fold_build2_loc (loc, EQ_EXPR, logical_type_node, countm1t,\n \t\t\t  build_int_cst (utype, 0));\n+  if (code->ext.iterator->unroll && cond != error_mark_node)\n+    cond\n+      = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n+\t\tbuild_int_cst (integer_type_node, annot_expr_unroll_kind),\n+\t\tbuild_int_cst (integer_type_node, code->ext.iterator->unroll));\n   tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n   tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n \t\t\t cond, tmp, build_empty_stmt (loc));"}, {"sha": "91d1102e2063d3bfe6779523b68599c2658e1c11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -1,3 +1,20 @@\n+2017-12-22  Mike Stump  <mikestump@comcast.net>\n+            Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-c++-common/unroll-1.c: New test.\n+\t* c-c++-common/unroll-2.c: Likewise.\n+\t* c-c++-common/unroll-3.c: Likewise.\n+\t* c-c++-common/unroll-4.c: Likewise.\n+\t* c-c++-common/unroll-5.c: Likewise.\n+\t* g++.dg/ext/unroll-1.C: Likewise.\n+\t* g++.dg/ext/unroll-2.C: Likewise.\n+\t* g++.dg/ext/unroll-3.C: Likewise.\n+\t* gfortran.dg/directive_unroll_1.f90: Likewise.\n+\t* gfortran.dg/directive_unroll_2.f90: Likewise.\n+\t* gfortran.dg/directive_unroll_3.f90: Likewise.\n+\t* gfortran.dg/directive_unroll_4.f90: Likewise.\n+\t* gfortran.dg/directive_unroll_5.f90: Likewise.\n+\n 2017-12-22  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR debug/83527"}, {"sha": "ccae250af530c17acbc123dadb6ed11946d3a59f", "filename": "gcc/testsuite/c-c++-common/unroll-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-1.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details -fdump-rtl-loop2_unroll-details\" } */\n+\n+extern void bar (int);\n+\n+int j;\n+\n+void test (void)\n+{\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+  /* { dg-final { scan-tree-dump \"11:.*: note: loop with 8 iterations completely unrolled\" \"cunrolli\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 7; ++i)\n+    bar(i);\n+  /* { dg-final { scan-tree-dump \"16:.*: note: loop with 7 iterations completely unrolled\" \"cunrolli\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 15; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"21:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"26:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 7\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"31:.*: note: loop unrolled 3 times\" \"loop2_unroll\" } } */\n+\n+  unsigned long i = 0;\n+  #pragma GCC unroll 3\n+  do {\n+    bar(i);\n+  } while (++i < 9);\n+  /* { dg-final { scan-rtl-dump \"3\\[79\\]:.*: note: loop unrolled 2 times\" \"loop2_unroll\" } } */\n+}"}, {"sha": "635b6c25349ed0f7dc5a68f14c16233a5bae020d", "filename": "gcc/testsuite/c-c++-common/unroll-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-2.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-cunroll-details -fdump-rtl-loop2_unroll-details\" } */\n+\n+extern void bar (int);\n+\n+int j;\n+\n+void test (void)\n+{\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+  /* { dg-final { scan-tree-dump \"11:.*: note: loop with 7 iterations completely unrolled\" \"cunroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 7; ++i)\n+    bar(i);\n+  /* { dg-final { scan-tree-dump \"16:.*: note: loop with 6 iterations completely unrolled\" \"cunroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 15; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"21:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"26:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 7\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"31:.*: note: loop unrolled 3 times\" \"loop2_unroll\" } } */\n+\n+  unsigned long i = 0;\n+  #pragma GCC unroll 3\n+  do {\n+    bar(i);\n+  } while (++i < 9);\n+  /* { dg-final { scan-rtl-dump \"3\\[79\\]:.*: note: loop unrolled 2 times\" \"loop2_unroll\" } } */\n+}"}, {"sha": "6cefa7583baaf337dc2c017f934c563daec49e2b", "filename": "gcc/testsuite/c-c++-common/unroll-3.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-3.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdisable-tree-cunroll -fdump-rtl-loop2_unroll-details\" } */\n+\n+extern void bar (int);\n+\n+int j;\n+\n+void test (void)\n+{\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump-not \"11:.*: note: loop unrolled\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 7; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump-not \"16:.*: note: loop unrolled\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= 15; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"21:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 8\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"26:.*: note: loop unrolled 7 times\" \"loop2_unroll\" } } */\n+\n+  #pragma GCC unroll 7\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+  /* { dg-final { scan-rtl-dump \"31:.*: note: loop unrolled 3 times\" \"loop2_unroll\" } } */\n+\n+  unsigned long i = 0;\n+  #pragma GCC unroll 3\n+  do {\n+    bar(i);\n+  } while (++i < 9);\n+  /* { dg-final { scan-rtl-dump \"3\\[79\\]:.*: note: loop unrolled 2 times\" \"loop2_unroll\" } } */\n+}"}, {"sha": "1c1988174ba750a2b09eb4b6b26484ca1a990315", "filename": "gcc/testsuite/c-c++-common/unroll-4.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-4.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funroll-all-loops -fdump-rtl-loop2_unroll-details -fdump-tree-cunrolli-details\" } */\n+\n+extern void bar (int);\n+\n+int j;\n+\n+void test (void)\n+{\n+  #pragma GCC unroll 0\n+  #pragma GCC ivdep\n+  for (unsigned long i = 1; i <= 3; ++i)\n+    bar(i);\n+\n+  #pragma GCC ivdep\n+  #pragma GCC unroll 0\n+  for (unsigned long i = 1; i <= j; ++i)\n+    bar(i);\n+\n+  /* { dg-final { scan-tree-dump \"Not unrolling loop .: user didn't want it unrolled completely\" \"cunrolli\" } } */\n+  /* { dg-final { scan-rtl-dump-times \"Not unrolling loop, user didn't want it unrolled\" 2 \"loop2_unroll\" } } */\n+}"}, {"sha": "754f3b18d5781efb7b25ed457577d18e4021db30", "filename": "gcc/testsuite/c-c++-common/unroll-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funroll-5.c?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+\n+extern void bar (int);\n+\n+int j;\n+\n+void test (void)\n+{\n+  #pragma GCC unroll 4+4\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+\n+  #pragma GCC unroll -1\t/* { dg-error \"requires an assignment-expression that evaluates to a non-negative integral constant less than\" } */\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+\n+  #pragma GCC unroll 20000000000\t/* { dg-error \"requires an assignment-expression that evaluates to a non-negative integral constant less than\" } */\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+\n+  #pragma GCC unroll j\t/* { dg-error \"requires an assignment-expression that evaluates to a non-negative integral constant less than\" } */\n+                        /* { dg-error \"cannot appear in a constant-expression|is not usable in a constant expression\" \"\" { target c++ } 21 } */\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+\n+  #pragma GCC unroll  4.2\t/* { dg-error \"requires an assignment-expression that evaluates to a non-negative integral constant less than\" } */\n+  for (unsigned long i = 1; i <= 8; ++i)\n+    bar(i);\n+}"}, {"sha": "2d58a6a7b0e7afec6ab657aa321f5557743c123d", "filename": "gcc/testsuite/g++.dg/ext/unroll-1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-1.C?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-cunrolli-details\" }\n+\n+template <typename T>\n+void\n+foo (T *a, T *b, T *c)\n+{\n+#pragma GCC unroll 8\n+  for (int i = 0; i < 8; i++)\n+    a[i] = b[i] * c[i];\n+}\n+\n+void\n+bar (int *a, int *b, int *c)\n+{\n+  foo <int> (a, b, c);\n+}\n+\n+// { dg-final { scan-tree-dump \"note: loop with 8 iterations completely unrolled\" \"cunrolli\" } }"}, {"sha": "e68cc3176751e7e1d5cc83faa3c7ce85538039fb", "filename": "gcc/testsuite/g++.dg/ext/unroll-2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-2.C?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-cunrolli-details\" }\n+// { dg-skip-if \"range for\" { *-*-* } { \"-std=gnu++98\" } { \"\" } }\n+\n+void\n+foo (int (&a)[8], int *b, int *c)\n+{\n+#pragma GCC unroll 8\n+  for (int i : a)\n+    a[i] = b[i] * c[i];\n+}\n+\n+// { dg-final { scan-tree-dump \"note: loop with 8 iterations completely unrolled\" \"cunrolli\" } }"}, {"sha": "6516ee97c96f857edcc37645cb5bd5bcda5b691d", "filename": "gcc/testsuite/g++.dg/ext/unroll-3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Funroll-3.C?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-cunrolli-details\" }\n+// { dg-skip-if \"range for\" { *-*-* } { \"-std=gnu++98\" } { \"\" } }\n+\n+template <typename T>\n+void\n+foo (T (&a)[8], T *b, T *c)\n+{\n+#pragma GCC unroll 8\n+  for (int i : a)\n+    a[i] = b[i] * c[i];\n+}\n+\n+void\n+bar (int (&a)[8], int *b, int *c)\n+{\n+  foo <int> (a, b, c);\n+}\n+\n+// { dg-final { scan-tree-dump \"note: loop with 8 iterations completely unrolled\" \"cunrolli\" } }"}, {"sha": "00fe7dcb3458e9a7d7336f299b9690a32dff7ad0", "filename": "gcc/testsuite/gfortran.dg/directive_unroll_1.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_1.f90?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-cunrolli-details -fdump-rtl-loop2_unroll-details\" }\n+! Test that\n+! #pragma GCC unroll n\n+! works\n+\n+subroutine test1(a)\n+  implicit NONE\n+  integer :: a(8)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, 8, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-tree-dump \"12:.*: note: loop with 8 iterations completely unrolled\" \"cunrolli\" } } */\n+end subroutine test1\n+\n+subroutine test2(a, n)\n+  implicit NONE\n+  integer :: a(n)\n+  integer (kind=1), intent(in) :: n\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"24:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test2\n+\n+subroutine test3(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=n, 1, -1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"36:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test3\n+\n+subroutine test4(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 2\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"48:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test4"}, {"sha": "bc93f91afa74bd7a1f8ee870e728f2cde3f3d226", "filename": "gcc/testsuite/gfortran.dg/directive_unroll_2.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_2.f90?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fdump-tree-cunroll-details -fdump-rtl-loop2_unroll-details\" }\n+! Test that\n+! #pragma GCC unroll n\n+! works\n+\n+subroutine test1(a)\n+  implicit NONE\n+  integer :: a(8)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, 8, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-tree-dump \"12:.*: note: loop with 7 iterations completely unrolled\" \"cunroll\" } } */\n+end subroutine test1\n+\n+subroutine test2(a, n)\n+  implicit NONE\n+  integer :: a(n)\n+  integer (kind=1), intent(in) :: n\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"24:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test2\n+\n+subroutine test3(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=n, 1, -1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"36:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test3\n+\n+subroutine test4(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 2\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"48:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test4"}, {"sha": "4e3ec09547a876fe9fd76a34b9c90b8bebfc536a", "filename": "gcc/testsuite/gfortran.dg/directive_unroll_3.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_3.f90?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fdisable-tree-cunroll -fdump-rtl-loop2_unroll-details\" }\n+! Test that\n+! #pragma GCC unroll n\n+! works\n+\n+subroutine test1(a)\n+  implicit NONE\n+  integer :: a(8)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, 8, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump-not \"12:.: note: loop unrolled\" \"loop2_unroll\" } }\n+end subroutine test1\n+\n+subroutine test2(a, n)\n+  implicit NONE\n+  integer :: a(n)\n+  integer (kind=1), intent(in) :: n\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"24:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test2\n+\n+subroutine test3(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=n, 1, -1\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"36:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test3\n+\n+subroutine test4(a, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  DO i=1, n, 2\n+    call dummy(a(i))\n+  ENDDO\n+! { dg-final { scan-rtl-dump \"48:.: note: loop unrolled 7 times\" \"loop2_unroll\" } }\n+end subroutine test4"}, {"sha": "fbb5f24e76fbef834fcb6c03942ace09fd3fa823", "filename": "gcc/testsuite/gfortran.dg/directive_unroll_4.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_4.f90?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -funroll-all-loops -fdump-rtl-loop2_unroll-details -fdump-tree-cunrolli-details\" }\n+! Test that\n+! #pragma GCC unroll n\n+! works\n+\n+subroutine test1(a)\n+  implicit NONE\n+  integer :: a(8)\n+  integer (kind=4) :: i\n+!GCC$ unroll 0\n+  DO i=1, 8, 1\n+    call dummy(a(i))\n+  ENDDO\n+end subroutine test1\n+\n+subroutine test2(a, n)\n+  implicit NONE\n+  integer :: a(n)\n+  integer (kind=1), intent(in) :: n\n+  integer (kind=4) :: i\n+!GCC$ unroll 0\n+  DO i=1, n, 1\n+    call dummy(a(i))\n+  ENDDO\n+end subroutine test2\n+\n+! { dg-final { scan-tree-dump \"Not unrolling loop .: user didn't want it unrolled completely\" \"cunrolli\" } } */\n+! { dg-final { scan-rtl-dump-times \"Not unrolling loop, user didn't want it unrolled\" 2 \"loop2_unroll\" } } */"}, {"sha": "b88b4b2c380c9d7dc755e054b0a6e71050cef197", "filename": "gcc/testsuite/gfortran.dg/directive_unroll_5.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdirective_unroll_5.f90?ref=170a8bd604a4c960b8a378d50f7cc6c66cbdaf5c", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+\n+! Test that\n+! #pragma GCC unroll n\n+! rejects invalid n and improper use\n+\n+subroutine wrong1(n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer (kind=4) :: i\n+!GCC$ unroll 999999999 ! { dg-error \"non-negative integral constant less than\" }\n+  DO i=0, n, 1\n+    call dummy1(i)\n+  ENDDO\n+end subroutine wrong1\n+\n+subroutine wrong2(a, b, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n), b(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll -1 ! { dg-error \"non-negative integral constant less than\" }\n+  DO i=1, n, 2\n+    call dummy2(a(i), b(i), i)\n+  ENDDO\n+end subroutine wrong2\n+\n+subroutine wrong3(a, b, n)\n+  implicit NONE\n+  integer (kind=1), intent(in) :: n\n+  integer :: a(n), b(n)\n+  integer (kind=4) :: i\n+!GCC$ unroll 8\n+  write (*,*) \"wrong\"! { dg-error \"directive does not commence a loop\" }\n+  DO i=n, 1, -1\n+    call dummy2(a(i), b(i), i)\n+  ENDDO\n+end subroutine wrong3"}]}