{"sha": "bae5261adbac2ef2c69532d85da0a224dfc2650d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFlNTI2MWFkYmFjMmVmMmM2OTUzMmQ4NWRhMGEyMjRkZmMyNjUwZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2001-10-30T04:27:17Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-10-30T04:27:17Z"}, "message": "convert.c, [...]: Use /* */ for all commentary, not #if 0 ...\n\n\t* convert.c, inout.c, loop.c, nloop.c, tasking.c, timing.c,\n\ttypeck.c: Use /* */ for all commentary, not #if 0 ... #endif.\n\tChange the nested comments this creates to // notation.\n\tUn-double apostrophes.\n\nFrom-SVN: r46626", "tree": {"sha": "9a97199c7e609bbf14afc49e48d3f1891684270b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a97199c7e609bbf14afc49e48d3f1891684270b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bae5261adbac2ef2c69532d85da0a224dfc2650d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae5261adbac2ef2c69532d85da0a224dfc2650d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae5261adbac2ef2c69532d85da0a224dfc2650d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae5261adbac2ef2c69532d85da0a224dfc2650d/comments", "author": null, "committer": null, "parents": [{"sha": "b016d07e15f81ab694af75c4dcce46f9d2da3676", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b016d07e15f81ab694af75c4dcce46f9d2da3676", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b016d07e15f81ab694af75c4dcce46f9d2da3676"}], "stats": {"total": 177, "additions": 89, "deletions": 88}, "files": [{"sha": "c412e583e67104984590d16c8c6fa0cb0cd4426f", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -1,3 +1,10 @@\n+2001-10-29  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* convert.c, inout.c, loop.c, nloop.c, tasking.c, timing.c,\n+\ttypeck.c: Use /* */ for all commentary, not #if 0 ... #endif.\n+\tChange the nested comments this creates to // notation.\n+\tUn-double apostrophes.\n+\n Sat Sep 22 09:15:08 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* Make-lang.in (cc1chill): Add attribs.o."}, {"sha": "3a4a8be0119a3eb1203014ae1d7cfdeb67447b3a", "filename": "gcc/ch/convert.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconvert.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -1086,9 +1086,7 @@ convert (type, expr)\n \t  error (\"initializer is not an array or string mode\");\n \t  return error_mark_node;\n \t}\n-#if 0\n-      FIXME check that nentries will fit in type;\n-#endif\n+      /* FIXME check that nentries will fit in type; */\n       if (!integer_zerop (needed_padding))\n \t{\n \t  tree padding, padding_type, padding_range;"}, {"sha": "b4749066061ded923a1b8c2fed0bcb8f83700277", "filename": "gcc/ch/inout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Finout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Finout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Finout.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -1466,7 +1466,7 @@ access_dynamic (access)\n   return integer_zero_node;\n }\n \n-#if 0\n+/*\n    returns a structure like\n    STRUCT (data STRUCT (flags ULONG,\n                         reclength ULONG,\n@@ -1480,7 +1480,7 @@ access_dynamic (access)\n    TYPE_DECL __recordmode recordmode ? recordmode : void_type_node\n    TYPE_DECL __indexmode  indexmode  ? indexmode  : void_type_node\n    CONST_DECL __dynamic   dynamic ? integer_one_node : integer_zero_node\n-#endif\n+*/\n \n static tree\n build_access_part ()\n@@ -1547,7 +1547,7 @@ build_access_mode (indexmode, recordmode, dynamic)\n   return type;\n }\n \f\n-#if 0\n+/*\n   returns a structure like:\n   STRUCT (txt STRUCT (flags ULONG,\n                       text_record PTR,\n@@ -1567,7 +1567,7 @@ build_access_mode (indexmode, recordmode, dynamic)\n   TYPE_DECL __indexmode indexmode ? indexmode : void_type_node\n   CONST_DECL __text_length\n   CONST_DECL __dynamic  dynamic ? integer_one_node : integer_zero_node\n-#endif\n+*/\n tree\n build_text_mode (textlength, indexmode, dynamic)\n      tree textlength;"}, {"sha": "8322b969a0e46b90b6f59804db208e501cedd014", "filename": "gcc/ch/loop.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Floop.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -131,7 +131,7 @@ typedef struct loop {\n \n static LOOP *loopstack = (LOOP *)0;\n \f\n-#if 0\n+/*\n \n Here is a CHILL DO FOR statement:\n \n@@ -147,10 +147,10 @@ following works:\n           FOR i := (i+1) TO (i+10) DO\n \n To prevent changes to the start/end/step expressions from\n-effecting the loop''s termination, and to make the loop end-check\n+effecting the loop's termination, and to make the loop end-check\n as simple as possible, we evaluate the step expression into\n a temporary and compute a hidden iteration count before entering \n-the loop''s body.  User code cannot effect the counter, and the\n+the loop's body.  User code cannot effect the counter, and the\n end-loop check simply decrements the counter and checks for zero.\n \n The whole phrase FOR iter := ... TO end_exp can be repeated\n@@ -160,7 +160,7 @@ is discussed later.\n The loop counter calculations need careful design since a loop\n from MININT TO MAXINT must work, in the precision of integers.\n \n-Here''s how it works, in C:\n+Here's how it works, in C:\n \n         0) The DO ... OD loop is simply a block with \n            its own scope.  \n@@ -195,7 +195,7 @@ Here''s how it works, in C:\n                 start_temp = start_exp\n                 end_temp = end_exp\n \t\tif (end_exp < start_exp) goto end_loop\n-                /* following line is all unsigned arithmetic */\n+                // following line is all unsigned arithmetic\n \t\titer_var = (end_exp - start_exp) / step_exp\n                 user_var = start_temp\n \t   loop_top:\n@@ -218,7 +218,7 @@ Here''s how it works, in C:\n                 start_temp = start_exp\n                 end_temp = end_exp\n \t\tif (end_exp > start_exp) goto end_loop\n-                /* following line is all unsigned arithmetic */\n+                // following line is all unsigned arithmetic\n \t\titer_var = (start_exp - end_exp) / step_exp\n                 user_var = start_temp\n \t   loop_top:\n@@ -234,9 +234,9 @@ Here''s how it works, in C:\n \tpop scope\n \n \n-        5) The range loop, which iterates over a mode''s possible\n+        5) The range loop, which iterates over a mode's possible\n            values, works just like the above step loops, but with\n-           the start and end values taken from the mode''s lower\n+           the start and end values taken from the mode's lower\n            and upper domain values.\n \f\n \n@@ -249,7 +249,7 @@ Here''s how it works, in C:\n              loc_ptr_temp as pointer to a composite base type\n         \n                if array is varying\n-                   iter_var = array''s length field\n+                   iter_var = array's length field\n                else\n                    iter_var = sizeof array / sizeof base_type\n \t       loc_ptr_temp = &of highest or lowest indexable entry\n@@ -290,20 +290,20 @@ Here''s how it works, in C:\n \tpop scope\n \f\n \n-So, here''s the general DO FOR schema, as implemented here:\n+So, here's the general DO FOR schema, as implemented here:\n \n-        expand_start_loop   -- start the loop''s control scope\n+        expand_start_loop   -- start the loop's control scope\n         -- start scope for synthesized loop variables\n         declare_temps       -- create, initialize temporary variables\n         maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n         initialize_iter_var -- initialize the iteration counter\n-                            -- initialize user''s loop variable\n+                            -- initialize user's loop variable\n         expand_start_loop   -- generate top-of-loop label\n         top_loop_end_check  -- generate while code and/or\n                                powerset find-a-bit function call\n         .\n         .\n-        .  user''s loop body code\n+        .  user's loop body code\n         .\n         .\n         bottom_loop_end_check  -- exit if counter has become zero\n@@ -322,7 +322,7 @@ the 'increment_temps' step must increment all temporaries\n        \"the actions statement list in a do action, including any\n        loop counter and while control\".  This means that an exp-\n        ression in a WHILE control can include references to the\n-       loop counters created for the loop''s exclusive use.  \n+       loop counters created for the loop's exclusive use.  \n        Example:\n \n              DCL a (1:10) INT;\n@@ -331,9 +331,9 @@ the 'increment_temps' step must increment all temporaries\n              ...\n              OD;\n        The 'j' referenced in the while is the loc-identity 'j'\n-       created inside the loop''s scope, and NOT the 'j' declared\n+       created inside the loop's scope, and NOT the 'j' declared\n        before the loop.\n-#endif\n+*/\n \f\n /*\n  * The following routines are called directly by the"}, {"sha": "579041a80a3cc73e5dbe0c35b71139f8389e7d5d", "filename": "gcc/ch/nloop.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Fnloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Fnloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fnloop.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -143,7 +143,7 @@ typedef struct loop {\n \n static LOOP *loop_stack = (LOOP *)0;\n \f\n-#if 0\n+/*\n \n Here is a CHILL DO FOR statement:\n \n@@ -159,10 +159,10 @@ following works:\n           FOR i := (i+1) TO (i+10) DO\n \n To prevent changes to the start/end/step expressions from\n-effecting the loop''s termination, and to make the loop end-check\n+effecting the loop's termination, and to make the loop end-check\n as simple as possible, we evaluate the step expression into\n a temporary and compute a hidden iteration count before entering \n-the loop''s body.  User code cannot effect the counter, and the\n+the loop's body.  User code cannot effect the counter, and the\n end-loop check simply decrements the counter and checks for zero.\n \n The whole phrase FOR iter := ... TO end_exp can be repeated\n@@ -172,7 +172,7 @@ is discussed later.\n The loop counter calculations need careful design since a loop\n from MININT TO MAXINT must work, in the precision of integers.\n \n-Here''s how it works, in C:\n+Here's how it works, in C:\n \n         0) The DO ... OD loop is simply a block with \n            its own scope.  \n@@ -207,7 +207,7 @@ Here''s how it works, in C:\n                 start_temp = start_exp\n                 end_temp = end_exp\n \t\tif (end_exp < start_exp) goto end_loop\n-                /* following line is all unsigned arithmetic */\n+                // following line is all unsigned arithmetic\n \t\titer_var = (end_exp - start_exp + step_exp) / step_exp\n                 user_var = start_temp\n \t   loop_top:\n@@ -230,7 +230,7 @@ Here''s how it works, in C:\n                 start_temp = start_exp\n                 end_temp = end_exp\n \t\tif (end_exp > start_exp) goto end_loop\n-                /* following line is all unsigned arithmetic */\n+                // following line is all unsigned arithmetic\n \t\titer_var = (start_exp - end_exp + step_exp) / step_exp\n                 user_var = start_temp\n \t   loop_top:\n@@ -246,9 +246,9 @@ Here''s how it works, in C:\n \tpop scope\n \n \n-        5) The range loop, which iterates over a mode''s possible\n+        5) The range loop, which iterates over a mode's possible\n            values, works just like the above step loops, but with\n-           the start and end values taken from the mode''s lower\n+           the start and end values taken from the mode's lower\n            and upper domain values.\n \f\n \n@@ -261,7 +261,7 @@ Here''s how it works, in C:\n              loc_ptr_temp as pointer to a composite base type\n         \n                if array is varying\n-                   iter_var = array''s length field\n+                   iter_var = array's length field\n                else\n                    iter_var = sizeof array / sizeof base_type\n \t       loc_ptr_temp = &of highest or lowest indexable entry\n@@ -285,9 +285,9 @@ Here''s how it works, in C:\n \n \t        powerset_temp := start_exp\n \t   loop_top:\n-\t        /* if DOWN */\n+\t        // if DOWN\n                 if (__flsetclrpowerset () == 0) goto end_loop;\n-                /* not DOWN */\n+                // not DOWN\n                 if (__ffsetclrpowerset () == 0) goto end_loop;\n \t\tif (!condition) goto end_loop\n \t\t.\n@@ -298,22 +298,22 @@ Here''s how it works, in C:\n \tpop scope\n \f\n \n-So, here''s the general DO FOR schema, as implemented here:\n+So, here's the general DO FOR schema, as implemented here:\n \n         classify_loop       -- what type of loop have we?\n                             -- build_iterator does some of this, also\n-        expand_start_loop   -- start the loop''s control scope\n+        expand_start_loop   -- start the loop's control scope\n         -- start scope for synthesized loop variables\n         declare_temps       -- create, initialize temporary variables\n         maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n         initialize_iter_var -- initialize the iteration counter\n-                            -- initialize user''s loop variable\n+                            -- initialize user's loop variable\n         expand_start_loop   -- generate top-of-loop label\n         top_loop_end_check  -- generate while code and/or\n                                powerset find-a-bit function call\n         .\n         .\n-        .  user''s loop body code\n+        .  user's loop body code\n         .\n         .\n         bottom_loop_end_check  -- exit if counter has become zero\n@@ -332,7 +332,7 @@ the 'increment_temps' step must increment all temporaries\n        \"the actions statement list in a do action, including any\n        loop counter and while control\".  This means that an exp-\n        ression in a WHILE control can include references to the\n-       loop counters created for the loop''s exclusive use.  \n+       loop counters created for the loop's exclusive use.  \n        Example:\n \n              DCL a (1:10) INT;\n@@ -341,9 +341,9 @@ the 'increment_temps' step must increment all temporaries\n              ...\n              OD;\n        The 'j' referenced in the while is the loc-identity 'j'\n-       created inside the loop''s scope, and NOT the 'j' declared\n+       created inside the loop's scope, and NOT the 'j' declared\n        before the loop.\n-#endif\n+*/\n \f\n /*\n  * The following routines are called directly by the"}, {"sha": "99a606902f4b75901085190e1177de05aba150be", "filename": "gcc/ch/tasking.c", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftasking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftasking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftasking.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -1218,19 +1218,19 @@ build_instance_type ()\n   pointer_to_instance = build_chill_pointer_type (instance_type_node);\n }\n \f\n-#if 0\n+/*\n  *\n  * The tasking message descriptor looks like this C structure:\n  *\n  * typedef struct\n  *   {\n- *     short *sc;                 /* ptr to code integer */\n- *     int    data_len;           /* length of signal/buffer data msg */\n- *     void  *data;               /* ptr to signal/buffer data */\n+ *     short *sc;                 // ptr to code integer\n+ *     int    data_len;           // length of signal/buffer data msg\n+ *     void  *data;               // ptr to signal/buffer data\n  *   } SignalDescr;\n  *\n  *\n-#endif\n+ */\n \n static void\n build_tasking_message_type ()\n@@ -1486,7 +1486,7 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n \t\t  tree_cons (NULL_TREE, linenumber, NULL_TREE)))))))));\n }\n \f\n-#if 0\n+/*\n  * The following code builds a RECEIVE CASE action, which actually\n  * has 2 different functionalities:\n  *\n@@ -1512,16 +1512,16 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  *        STOP;\n  *      ESAC;\n  *\n- * Because we don''t know until we get to the ESAC how\n+ * Because we don't know until we get to the ESAC how\n  * many signals need processing, we generate the following\n  * C-equivalent code:\n  *\n- * /* define the codes for the signals */\n+ * // define the codes for the signals\n  * static short __tmp_advance_code;\n  * static short __tmp_terminate_code;\n  * static short __tmp_sig1_code;\n  *\n- * /* define the types of the signals */\n+ * // define the types of the signals\n  * typedef struct\n  *  {\n  *     char fld0;\n@@ -1536,7 +1536,7 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  * static short count;\n  * static char char_code;\n  *\n- * {               /* start a new symbol context */\n+ * {               // start a new symbol context\n  *   int    number_of_sigs;\n  *   short *sig_code [];\n  *   void  *sigdatabuf;\n@@ -1554,22 +1554,22 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  *                                 &instance_loc);\n  *   if (sigcode == __tmp_advance_code)\n  *     {\n- *       /* code for advance alternative's action_statement_list */\n+ *       // code for advance alternative's action_statement_list\n  *       count++;\n  *     }\n  *   else if (sigcode == __tmp_terminate_code)\n  *     {\n- *        /* copy signal's data to where they belong,\n- *           with range-check, if enabled */\n+ *        // copy signal's data to where they belong,\n+ *           with range-check, if enabled\n  *        char_code = ((__tmp_terminate_struct *)sigdatabuf)->fld0;\n  *\n- *       /* code for terminate alternative's action_statement_list */\n+ *       // code for terminate alternative's action_statement_list\n  *        __send_signal (sig1 ..... );\n  *        goto __workloop_end;\n  *     }\n  *   else\n  *     {\n- *        /* code here for the ELSE action_statement_list */\n+ *        // code here for the ELSE action_statement_list\n  *        __stop_process ();\n  *     }\n  *   goto __rc_done;\n@@ -1586,7 +1586,7 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  *   goto __rcdoit;\n  *\n  * __rc_done: ;\n- * }               /* end the new symbol context */\n+ * }               // end the new symbol context\n  * __workloop_end: ;\n  *\n  *\n@@ -1612,7 +1612,7 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  *          STOP;\n  *      ESAC;\n  *\n- * Because we don''t know until we get to the ESAC how\n+ * Because we don't know until we get to the ESAC how\n  * many buffers need processing, we generate the following\n  * C-equivalent code:\n  *\n@@ -1630,7 +1630,7 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  * static short count;\n  *\n  * workloop:\n- * {                     /* start a new symbol context */\n+ * {                     // start a new symbol context\n  *   int     number_of_sigs;\n  *   void   *sig_code [];\n  *   void   *sigdatabuf;\n@@ -1684,10 +1684,10 @@ expand_send_signal (sigmsgbuffer, optroutinginfo, optsendto,\n  *   goto __rcdoit;\n  *\n  *  __rc_done;\n- * }          /* end of symbol context */\n+ * }          // end of symbol context\n  * __workloop_end:\n  *\n-#endif\n+ */\n \f\n struct rc_state_type\n {\n@@ -2381,7 +2381,7 @@ void expand_continue_event (evloc)\n           tree_cons (NULL_TREE, linenumber, NULL_TREE)))));\n }\n \f\n-#if 0\n+/*\n  * The following code builds a DELAY CASE statement,\n  * which looks like this in CHILL:\n  *\n@@ -2394,12 +2394,12 @@ void expand_continue_event (evloc)\n  *      (ev2, ev3): count2 +:= 1;\n  *    ESAC; \n  *\n- * Because we don''t know until we get to the ESAC how\n+ * Because we don't know until we get to the ESAC how\n  * many events need processing, we generate the following\n  * C-equivalent code:\n  *\n  *\n- * {               /* start a new symbol context */\n+ * {               // start a new symbol context\n  *   typedef struct\n  *   {\n  *      void           *p;\n@@ -2419,12 +2419,12 @@ void expand_continue_event (evloc)\n  *                                    linenumber);\n  *   if (whatevent == &ev1)\n  *     {\n- *       /* code for ev1 alternative's action_statement_list */\n+ *       // code for ev1 alternative's action_statement_list\n  *       count1 += 1;\n  *     }\n  *   else if (whatevent == &ev2 || whatevent == &ev3)\n  *     {\n- *       /* code for ev2 and ev3 alternative's action_statement_list */\n+ *       // code for ev2 and ev3 alternative's action_statement_list\n  *       count2 += 1;\n  *     }\n  *   goto __dl_done;\n@@ -2440,9 +2440,9 @@ void expand_continue_event (evloc)\n  *\n  * __dl_done: \n  *   ;\n- * }               /* end the new symbol context */\n+ * }               // end the new symbol context\n  *\n-#endif\n+ */\n \f\n struct dl_state_type\n {\n@@ -2708,7 +2708,7 @@ build_delay_case_end (event_list)\n   free(dl_state);\n }\n \f\n-#if 0\n+/*\n  * The following code builds a simple delay statement,\n  * which looks like this in CHILL:\n  *\n@@ -2729,16 +2729,15 @@ build_delay_case_end (event_list)\n  *\n  * static short __tmp_ev1_code;\n  * \n- * {  /* start a new symbol context */\n+ * {  // start a new symbol context\n  *\n  *   Descr __delay_array[1] = { { ev1, 5 } };\n  *\n  *   __delay_event (1, &__delay_array, 7, NULL,\n  *\t\t    filename, linenumber);\n  *\n- * } /* end of symbol scope */\n+ * } // end of symbol scope\n  */\n-#endif\n void\n build_delay_action (event, optpriority)\n \ttree event, optpriority;"}, {"sha": "c53fed752de2ec31aa4599de4d8a75e917904095", "filename": "gcc/ch/timing.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftiming.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftiming.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftiming.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -189,7 +189,7 @@ timing_init ()\n \t\t    0, NOT_BUILT_IN, NULL_PTR);\n }\n \n-#if 0\n+/*\n  *\n  * build AT action\n  *\n@@ -206,7 +206,7 @@ timing_init ()\n  * else\n  *   to-action-list\n  *\n-#endif\n+ */\n \n void\n build_at_action (t)\n@@ -235,7 +235,7 @@ build_at_action (t)\n   emit_line_note (input_filename, lineno);\n }\n \n-#if 0\n+/* \n  *\n  * build CYCLE action\n  *\n@@ -254,7 +254,7 @@ build_at_action (t)\n  *    goto label;\n  *  }\n  *\n-#endif\n+ */\n \n tree\n build_cycle_start (t)\n@@ -317,7 +317,7 @@ build_cycle_end (toid)\n   expand_goto (TREE_VALUE (toid));\n }\n \n-#if 0\n+/*\n  *\n  * build AFTER ACTION\n  *\n@@ -343,7 +343,7 @@ build_cycle_end (toid)\n  *   end-label:\n  * }\n  *\n-#endif\n+ */\n \n void\n build_after_start (duration, delay_flag)"}, {"sha": "4aabd26f5b623817ce90276ea3b27c852e471e42", "filename": "gcc/ch/typeck.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bae5261adbac2ef2c69532d85da0a224dfc2650d/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=bae5261adbac2ef2c69532d85da0a224dfc2650d", "patch": "@@ -1722,12 +1722,10 @@ chill_similar (mode1, mode2, chain)\n \n     default:\n       ;\n-#if 0\n       /* Need to handle row modes, instance modes,\n \t association modes, access modes, text modes,\n \t duration modes, absolute time modes, structure modes,\n \t parameterized structure modes */\n-#endif\n     }\n   return 1;\n }\n@@ -1809,9 +1807,9 @@ chill_l_equivalent (mode1, mode2, chain)\n     return 0;\n   if (TYPE_READONLY (mode1) != TYPE_READONLY (mode2))\n     return 0;\n-#if 0\n+/*\n   ... other conditions ...;\n-#endif\n+ */\n   return 1;\n }\n \n@@ -1837,9 +1835,9 @@ chill_read_compatible (modeM, modeN)\n \t{\n \t  return chill_l_equivalent (TREE_TYPE (modeM), TREE_TYPE (modeN), 0);\n \t}\n-#if 0\n+/*\n       ...;\n-#endif\n+*/\n     }\n   return 1;\n }\n@@ -1889,13 +1887,12 @@ chill_compatible (expr, mode)\n     case CH_REFERENCE_CLASS:\n       if (!CH_IS_REFERENCE_MODE (mode))\n \treturn 0;\n-#if 0\n-      /* FIXME! */\n+/* FIXME!\n       if (class.mode is a row mode)\n \t...;\n       else if (class.mode is not a static mode)\n-\treturn 0; /* is this possible? FIXME */\n-#endif\n+\treturn 0; is this possible?\n+*/\n       return !CH_IS_BOUND_REFERENCE_MODE(mode)\n \t|| CH_READ_COMPATIBLE (TREE_TYPE (mode), class.mode);\n     }"}]}