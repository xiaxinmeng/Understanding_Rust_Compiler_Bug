{"sha": "feb391fc5d47f7bd3860fe192a7a73531cbde77f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmViMzkxZmM1ZDQ3ZjdiZDM4NjBmZTE5MmE3YTczNTMxY2JkZTc3Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-21T22:30:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-21T22:30:28Z"}, "message": "lto-symtab.c (warn_type_compatibility_p): Do not set ODR mismatch flag for types that are not ODR...\n\n\t* lto-symtab.c (warn_type_compatibility_p): Do not set ODR mismatch\n\tflag for types that are not ODR; fix loop walking parameters.\n\nFrom-SVN: r230712", "tree": {"sha": "b381f3aa19eda847a8c3e955c2aca830ceae8444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b381f3aa19eda847a8c3e955c2aca830ceae8444"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feb391fc5d47f7bd3860fe192a7a73531cbde77f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb391fc5d47f7bd3860fe192a7a73531cbde77f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb391fc5d47f7bd3860fe192a7a73531cbde77f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb391fc5d47f7bd3860fe192a7a73531cbde77f/comments", "author": null, "committer": null, "parents": [{"sha": "fcae71a3687e8ff73c80293d1121655436f997dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcae71a3687e8ff73c80293d1121655436f997dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcae71a3687e8ff73c80293d1121655436f997dc"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "49adea611046ec18568f649431ae220683ad59d6", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb391fc5d47f7bd3860fe192a7a73531cbde77f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb391fc5d47f7bd3860fe192a7a73531cbde77f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=feb391fc5d47f7bd3860fe192a7a73531cbde77f", "patch": "@@ -1,3 +1,8 @@\n+2015-11-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c (warn_type_compatibility_p): Do not set ODR mismatch\n+\tflag for types that are not ODR; fix loop walking parameters.\n+\n 2015-11-11  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* lto-lang.c: Remove unused header files."}, {"sha": "cef7ad383c65479c2d16ece3ac98f71e1e34a01c", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb391fc5d47f7bd3860fe192a7a73531cbde77f/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb391fc5d47f7bd3860fe192a7a73531cbde77f/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=feb391fc5d47f7bd3860fe192a7a73531cbde77f", "patch": "@@ -180,16 +180,26 @@ lto_varpool_replace_node (varpool_node *vnode,\n /* Return non-zero if we want to output waring about T1 and T2.\n    Return value is a bitmask of reasons of violation:\n    Bit 0 indicates that types are not compatible of memory layout.\n-   Bot 1 indicates that types are not compatible because of C++ ODR rule.  */\n+   Bit 1 indicates that types are not compatible because of C++ ODR rule.  */\n \n static int\n warn_type_compatibility_p (tree prevailing_type, tree type)\n {\n   int lev = 0;\n+\n+  /* Get complete type.\n+     ???  We might want to emit a warning here if type qualification\n+     differences were spotted.  Do not do this unconditionally though.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+  prevailing_type = TYPE_MAIN_VARIANT (prevailing_type);\n+  if (prevailing_type == type)\n+    return 0;\n+\n+  bool odr_p = odr_or_derived_type_p (prevailing_type)\n+\t       && odr_or_derived_type_p (type);\n   /* C++ provide a robust way to check for type compatibility via the ODR\n      rule.  */\n-  if (odr_or_derived_type_p (prevailing_type) && odr_or_derived_type_p (type)\n-      && !odr_types_equivalent_p (prevailing_type, type))\n+  if (odr_p && !odr_types_equivalent_p (prevailing_type, type))\n     lev = 2;\n \n   /* Function types needs special care, because types_compatible_p never\n@@ -209,15 +219,15 @@ warn_type_compatibility_p (tree prevailing_type, tree type)\n \t  for (parm1 = TYPE_ARG_TYPES (prevailing_type),\n \t       parm2 = TYPE_ARG_TYPES (type);\n \t       parm1 && parm2;\n-\t       parm1 = TREE_CHAIN (prevailing_type),\n-\t       parm2 = TREE_CHAIN (type))\n+\t       parm1 = TREE_CHAIN (parm1),\n+\t       parm2 = TREE_CHAIN (parm2))\n \t    lev |= warn_type_compatibility_p (TREE_VALUE (parm1),\n \t\t\t\t\t      TREE_VALUE (parm2));\n \t  if (parm1 || parm2)\n-\t    lev = 3;\n+\t    lev = odr_p ? 3 : 1;\n \t}\n       if (comp_type_attributes (prevailing_type, type) == 0)\n-\tlev = 3;\n+\tlev = odr_p ? 3 : 1;\n       return lev;\n     }\n   /* Sharing a global symbol is a strong hint that two types are\n@@ -270,9 +280,6 @@ warn_type_compatibility_p (tree prevailing_type, tree type)\n       /* Fallthru.  Compatible enough.  */\n     }\n \n-  /* ???  We might want to emit a warning here if type qualification\n-     differences were spotted.  Do not do this unconditionally though.  */\n-\n   return lev;\n }\n "}]}