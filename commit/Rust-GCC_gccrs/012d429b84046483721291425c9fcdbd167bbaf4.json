{"sha": "012d429b84046483721291425c9fcdbd167bbaf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyZDQyOWI4NDA0NjQ4MzcyMTI5MTQyNWM5ZmNkYmQxNjdiYmFmNA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-08-16T17:05:19Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-08-16T17:05:19Z"}, "message": "Allow larger copies when not slow_unaligned_access and no padding.\n\nThis allows copy_blkmode_to_reg to perform larger copies when it is safe to do so by calculating\nthe bitsize per iteration doing the maximum copy allowed that does not read more\nthan the amount of bits left to copy.\n\nStrictly speaking, this copying is only done if:\n\n  1. the target supports fast unaligned access\n  2. no padding is being used.\n\nThis should avoid the issues of the first patch (PR85123) but still work for targets that are safe\nto do so.\n\nOriginal patch https://gcc.gnu.org/ml/gcc-patches/2017-11/msg01088.html\nPrevious respin https://gcc.gnu.org/ml/gcc-patches/2018-04/msg00239.html\n\ngcc/\n2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n\n\t* expr.c (copy_blkmode_to_reg): Perform larger copies when safe.\n\nFrom-SVN: r263594", "tree": {"sha": "95b131a8ef283f12cbd33ef4816f030a99581805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b131a8ef283f12cbd33ef4816f030a99581805"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012d429b84046483721291425c9fcdbd167bbaf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012d429b84046483721291425c9fcdbd167bbaf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012d429b84046483721291425c9fcdbd167bbaf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012d429b84046483721291425c9fcdbd167bbaf4/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "450f33d6ba630730e86ebabb361651e00ac7741f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/450f33d6ba630730e86ebabb361651e00ac7741f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/450f33d6ba630730e86ebabb361651e00ac7741f"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "62969666e092a783d8e5415b2dea911df4658ce5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012d429b84046483721291425c9fcdbd167bbaf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012d429b84046483721291425c9fcdbd167bbaf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=012d429b84046483721291425c9fcdbd167bbaf4", "patch": "@@ -1,3 +1,7 @@\n+2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* expr.c (copy_blkmode_to_reg): Perform larger copies when safe.\n+\n 2018-08-16  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* doc/rtl.texi: Replace old RTX class names with new names."}, {"sha": "e8a4f8831288ddc7a89151313515b0471587db22", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012d429b84046483721291425c9fcdbd167bbaf4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012d429b84046483721291425c9fcdbd167bbaf4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=012d429b84046483721291425c9fcdbd167bbaf4", "patch": "@@ -2767,6 +2767,7 @@ copy_blkmode_to_reg (machine_mode mode_in, tree src)\n   /* No current ABI uses variable-sized modes to pass a BLKmnode type.  */\n   fixed_size_mode mode = as_a <fixed_size_mode> (mode_in);\n   fixed_size_mode dst_mode;\n+  scalar_int_mode min_mode;\n \n   gcc_assert (TYPE_MODE (TREE_TYPE (src)) == BLKmode);\n \n@@ -2796,6 +2797,7 @@ copy_blkmode_to_reg (machine_mode mode_in, tree src)\n   n_regs = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   dst_words = XALLOCAVEC (rtx, n_regs);\n   bitsize = MIN (TYPE_ALIGN (TREE_TYPE (src)), BITS_PER_WORD);\n+  min_mode = smallest_int_mode_for_size (bitsize);\n \n   /* Copy the structure BITSIZE bits at a time.  */\n   for (bitpos = 0, xbitpos = padding_correction;\n@@ -2816,6 +2818,25 @@ copy_blkmode_to_reg (machine_mode mode_in, tree src)\n \t  emit_move_insn (dst_word, CONST0_RTX (word_mode));\n \t}\n \n+      /* Find the largest integer mode that can be used to copy all or as\n+\t many bits as possible of the structure if the target supports larger\n+\t copies.  There are too many corner cases here w.r.t to alignments on\n+\t the read/writes.  So if there is any padding just use single byte\n+\t operations.  */\n+      opt_scalar_int_mode mode_iter;\n+      if (padding_correction == 0 && !STRICT_ALIGNMENT)\n+\t{\n+\t  FOR_EACH_MODE_FROM (mode_iter, min_mode)\n+\t    {\n+\t      unsigned int msize = GET_MODE_BITSIZE (mode_iter.require ());\n+\t      if (msize <= ((bytes * BITS_PER_UNIT) - bitpos)\n+\t\t  && msize <= BITS_PER_WORD)\n+\t\tbitsize = msize;\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t}\n+\n       /* We need a new source operand each time bitpos is on a word\n \t boundary.  */\n       if (bitpos % BITS_PER_WORD == 0)"}]}