{"sha": "c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc5ZDc3MDI3MzdjOGNmNzdiN2QyN2JiYjZhMWU4Y2ZjMmExYjllZQ==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2003-02-12T23:40:31Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-02-12T23:40:31Z"}, "message": "jni.cc (_Jv_LookupJNIMethod): Modify to accept the size of the arguments for a JNI function.\n\n2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n\n\t* jni.cc (_Jv_LookupJNIMethod): Modify to accept the\n\tsize of the arguments for a JNI function. For Win32,\n\tmodify to search for all forms of possible exported\n\tnames of an stdcall JNI function.\n\t(_Jv_JNIMethod::call): Modify to calculate the size\n\tof the arguments passed to a JNI function and pass\n\tit to _Jv_LookupJNIMethod.\n\nFrom-SVN: r62796", "tree": {"sha": "2879c0f5114b01bdab7c9428aeac4b17b9481792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2879c0f5114b01bdab7c9428aeac4b17b9481792"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee/comments", "author": null, "committer": null, "parents": [{"sha": "697ec3260d91cf5b268fc2d33f45665806593ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697ec3260d91cf5b268fc2d33f45665806593ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/697ec3260d91cf5b268fc2d33f45665806593ad5"}], "stats": {"total": 97, "additions": 85, "deletions": 12}, "files": [{"sha": "4fbf40cfa756784a9fc1f42d3763b8b12dd3105f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "patch": "@@ -1,3 +1,13 @@\n+2003-02-12  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\t* jni.cc (_Jv_LookupJNIMethod): Modify to accept the\n+\tsize of the arguments for a JNI function. For Win32,\n+\tmodify to search for all forms of possible exported\n+\tnames of an stdcall JNI function.\n+\t(_Jv_JNIMethod::call): Modify to calculate the size\n+\tof the arguments passed to a JNI function and pass\n+\tit to _Jv_LookupJNIMethod.\n+\n 2003-02-12  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/channels/Channels.java: New file."}, {"sha": "7dd98364118751aa32edcd8e4760f4d94be409db", "filename": "libjava/jni.cc", "status": "modified", "additions": 75, "deletions": 12, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=c79d7702737c8cf77b7d27bbb6a1e8cfc2a1b9ee", "patch": "@@ -10,6 +10,7 @@ details.  */\n \n #include <config.h>\n \n+#include <stdio.h>\n #include <stddef.h>\n #include <string.h>\n \n@@ -2028,9 +2029,9 @@ _Jv_GetJNIEnvNewFrame (jclass klass)\n // This is `extern \"C\"' because the compiler uses it.\n extern \"C\" void *\n _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n-\t\t     _Jv_Utf8Const *signature)\n+\t\t     _Jv_Utf8Const *signature, int args_size)\n {\n-  char buf[10 + 6 * (name->length + signature->length)];\n+  char buf[10 + 6 * (name->length + signature->length) + 12];\n   int long_start;\n   void *function;\n \n@@ -2050,18 +2051,72 @@ _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n     return function;\n \n   // If there was no override, then look in the symbol table.\n-  mangled_name (klass, name, signature, buf, &long_start);\n-  char c = buf[long_start];\n-  buf[long_start] = '\\0';\n-  function = _Jv_FindSymbolInExecutable (buf);\n+  buf[0] = '_';\n+  mangled_name (klass, name, signature, buf + 1, &long_start);\n+  char c = buf[long_start + 1];\n+  buf[long_start + 1] = '\\0';\n+\n+  function = _Jv_FindSymbolInExecutable (buf + 1);\n+#ifdef WIN32\n+  // On Win32, we use the \"stdcall\" calling convention (see JNICALL\n+  // in jni.h).\n+  // \n+  // For a function named 'fooBar' that takes 'nn' bytes as arguments,\n+  // by default, MinGW GCC exports it as 'fooBar@nn', MSVC exports it\n+  // as '_fooBar@nn' and Borland C exports it as 'fooBar'. We try to\n+  // take care of all these variations here.\n+\n+  char asz_buf[12];    /* '@' + '2147483647' (32-bit INT_MAX) + '\\0' */\n+  char long_nm_sv[11]; /* Ditto, except for the '\\0'. */\n+\n   if (function == NULL)\n     {\n-      buf[long_start] = c;\n+      // We have tried searching for the 'fooBar' form (BCC) - now\n+      // try the others.\n+\n+      // First, save the part of the long name that will be damaged\n+      // by appending '@nn'.\n+      memcpy (long_nm_sv, (buf + long_start + 1 + 1), sizeof (long_nm_sv));\n+\n+      sprintf (asz_buf, \"@%d\", args_size);\n+      strcat (buf, asz_buf);\n+\n+      // Search for the '_fooBar@nn' form (MSVC).\n       function = _Jv_FindSymbolInExecutable (buf);\n+\n+      if (function == NULL)\n+        {\n+          // Search for the 'fooBar@nn' form (MinGW GCC).\n+          function = _Jv_FindSymbolInExecutable (buf + 1);\n+        }\n+    }\n+#else /* WIN32 */\n+  args_size;  /* Dummy statement to avoid unused parameter warning */\n+#endif /* ! WIN32 */\n+\n+  if (function == NULL)\n+    {\n+      buf[long_start + 1] = c;\n+#ifdef WIN32\n+      // Restore the part of the long name that was damaged by \n+      // appending the '@nn'.\n+      memcpy ((buf + long_start + 1 + 1), long_nm_sv, sizeof (long_nm_sv));\n+#endif /* WIN32 */\n+      function = _Jv_FindSymbolInExecutable (buf + 1);\n       if (function == NULL)\n \t{\n-\t  jstring str = JvNewStringUTF (name->data);\n-\t  throw new java::lang::UnsatisfiedLinkError (str);\n+#ifdef WIN32\n+          strcat (buf, asz_buf);\n+          function = _Jv_FindSymbolInExecutable (buf);\n+          if (function == NULL)\n+            function = _Jv_FindSymbolInExecutable (buf + 1);\n+\n+          if (function == NULL)\n+#endif /* WIN32 */\n+            {\n+              jstring str = JvNewStringUTF (name->data);\n+              throw new java::lang::UnsatisfiedLinkError (str);\n+            }\n \t}\n     }\n \n@@ -2092,9 +2147,17 @@ _Jv_JNIMethod::call (ffi_cif *, void *ret, ffi_raw *args, void *__this)\n     // time.\n     JvSynchronize sync (global_ref_table);\n     if (_this->function == NULL)\n-      _this->function = _Jv_LookupJNIMethod (_this->defining_class,\n-\t\t\t\t\t     _this->self->name,\n-\t\t\t\t\t     _this->self->signature);\n+      {\n+        int args_size = sizeof (JNIEnv *) + _this->args_raw_size;\n+\n+        if (_this->self->accflags & java::lang::reflect::Modifier::STATIC)\n+          args_size += sizeof (_this->defining_class);\n+\n+        _this->function = _Jv_LookupJNIMethod (_this->defining_class,\n+                                               _this->self->name,\n+                                               _this->self->signature,\n+                                               args_size);\n+      }\n   }\n \n   JvAssert (_this->args_raw_size % sizeof (ffi_raw) == 0);"}]}