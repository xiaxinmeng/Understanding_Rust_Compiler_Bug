{"sha": "53f3cd25de6706b1850650111a31c0ea0bb63406", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNmM2NkMjVkZTY3MDZiMTg1MDY1MDExMWEzMWMwZWEwYmI2MzQwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-10-15T09:50:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-10-15T09:50:07Z"}, "message": "PR67945: Fix oscillation between pow representations\n\nThis patch fixes some fallout from my patch to move the sqrt and cbrt\nfolding rules to match.pd.  The rules included canonicalisations like:\n\n       sqrt(sqrt(x))->pow(x,1/4)\n\nwhich in the original code was only ever done at the generic level.\nMy patch meant that we'd do it whenever we tried to fold a gimple\nstatement, and eventually it would win over the sincos optimisation\nthat replaces pow(x,1/4) with sqrt(sqrt(x)).\n\nFollowing a suggestion from Richard B, the patch adds a new\nPROP_gimple_* flag to say whether fp routines have been optimised\nfor the target.  If so, match.pd should only transform calls to math\nfunctions if the result is actually an optimisation, not just an\nIL simplification or canonicalisation.  The question then of course\nis: which rules are which?  I've added block comments that describe\nthe criteria I was using.\n\nA slight wart is that we need to use the cfun global to access\nthe PROP_gimple_* flag; there's no local function pointer available.\n\nBootstrapped & regression-tested on x86_64-linux-gnu.  Also tested\non powerc64-linux-gnu.\n\ngcc/\n\tPR tree-optimization/67945\n\t* tree-pass.h (PROP_gimple_opt_math): New property flag.\n\t* generic-match-head.c (canonicalize_math_p): New function.\n\t* gimple-match-head.c: Include tree-pass.h.\n\t(canonicalize_math_p): New function.\n\t* match.pd: Group math built-in rules into simplifications\n\tand canonicalizations.  Guard the latter with canonicalize_math_p.\n\t* tree-ssa-math-opts.c (pass_data_cse_sincos): Provide the\n\tPROP_gimple_opt_math property.\n\nFrom-SVN: r228840", "tree": {"sha": "f7cdb50a2dca660b3efaaa1ecd9e1098f74f7df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7cdb50a2dca660b3efaaa1ecd9e1098f74f7df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53f3cd25de6706b1850650111a31c0ea0bb63406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f3cd25de6706b1850650111a31c0ea0bb63406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f3cd25de6706b1850650111a31c0ea0bb63406", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f3cd25de6706b1850650111a31c0ea0bb63406/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "64da3a9a3f6f01f59be701b3ec55428abb563941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64da3a9a3f6f01f59be701b3ec55428abb563941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64da3a9a3f6f01f59be701b3ec55428abb563941"}], "stats": {"total": 276, "additions": 168, "deletions": 108}, "files": [{"sha": "75c4c17dd35d9751f1366fb2726bc76de5e773ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -1,3 +1,15 @@\n+2015-10-15  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/67945\n+\t* tree-pass.h (PROP_gimple_opt_math): New property flag.\n+\t* generic-match-head.c (canonicalize_math_p): New function.\n+\t* gimple-match-head.c: Include tree-pass.h.\n+\t(canonicalize_math_p): New function.\n+\t* match.pd: Group math built-in rules into simplifications\n+\tand canonicalizations.  Guard the latter with canonicalize_math_p.\n+\t* tree-ssa-math-opts.c (pass_data_cse_sincos): Provide the\n+\tPROP_gimple_opt_math property.\n+\n 2015-10-15  Marek Polacek  <polacek@redhat.com>\n \n \tPR tree-optimization/67953"}, {"sha": "94135b36555fbdd8765782843c8e064cefb096d6", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -73,3 +73,12 @@ single_use (tree t ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n+\n+/* Return true if math operations should be canonicalized,\n+   e.g. sqrt(sqrt(x)) -> pow(x, 0.25).  */\n+\n+static inline bool\n+canonicalize_math_p ()\n+{\n+  return true;\n+}"}, {"sha": "8f7291912c7a79ed06356773c55895cc31d6ee9e", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"gimple-match.h\"\n+#include \"tree-pass.h\"\n \n \n /* Forward declarations of the private auto-generated matchers.\n@@ -825,3 +826,12 @@ single_use (tree t)\n {\n   return TREE_CODE (t) != SSA_NAME || has_zero_uses (t) || has_single_use (t);\n }\n+\n+/* Return true if math operations should be canonicalized,\n+   e.g. sqrt(sqrt(x)) -> pow(x, 0.25).  */\n+\n+static inline bool\n+canonicalize_math_p ()\n+{\n+  return !cfun || (cfun->curr_properties & PROP_gimple_opt_math) == 0;\n+}"}, {"sha": "e0ecbe2e776587a3e08cb85e222987525b7ac647", "filename": "gcc/match.pd", "status": "modified", "additions": 132, "deletions": 107, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -2135,11 +2135,25 @@ along with GCC; see the file COPYING3.  If not see\n    clearly less optimal and which we'll transform again in forwprop.  */\n \n \n-/* Simplification of math builtins.  */\n+/* Simplification of math builtins.  These rules must all be optimizations\n+   as well as IL simplifications.  If there is a possibility that the new\n+   form could be a pessimization, the rule should go in the canonicalization\n+   section that follows this one.\n \n-/* fold_builtin_logarithm */\n-(if (flag_unsafe_math_optimizations)\n+   Rules can generally go in this section if they satisfy one of\n+   the following:\n+\n+   - the rule describes an identity\n+\n+   - the rule replaces calls with something as simple as addition or\n+     multiplication\n+\n+   - the rule contains unary calls only and simplifies the surrounding\n+     arithmetic.  (The idea here is to exclude non-unary calls in which\n+     one operand is constant and in which the call is known to be cheap\n+     when the operand has that value.)  */\n \n+(if (flag_unsafe_math_optimizations)\n  /* Simplify sqrt(x) * sqrt(x) -> x.  */\n  (simplify\n   (mult (SQRT@1 @0) @1)\n@@ -2152,63 +2166,12 @@ along with GCC; see the file COPYING3.  If not see\n    (mult (root:s @0) (root:s @1))\n     (root (mult @0 @1))))\n \n- /* Simplify pow(x,y) * pow(x,z) -> pow(x,y+z). */\n- (simplify\n-  (mult (POW:s @0 @1) (POW:s @0 @2))\n-   (POW @0 (plus @1 @2)))\n-\n- /* Simplify pow(x,y) * pow(z,y) -> pow(x*z,y). */\n- (simplify\n-  (mult (POW:s @0 @1) (POW:s @2 @1))\n-   (POW (mult @0 @2) @1))\n-\n  /* Simplify expN(x) * expN(y) -> expN(x+y). */\n  (for exps (EXP EXP2 EXP10 POW10)\n   (simplify\n    (mult (exps:s @0) (exps:s @1))\n     (exps (plus @0 @1))))\n \n- /* Simplify tan(x) * cos(x) -> sin(x). */\n- (simplify\n-  (mult:c (TAN:s @0) (COS:s @0))\n-   (SIN @0))\n-\n- /* Simplify x * pow(x,c) -> pow(x,c+1). */\n- (simplify\n-  (mult @0 (POW:s @0 REAL_CST@1))\n-  (if (!TREE_OVERFLOW (@1))\n-   (POW @0 (plus @1 { build_one_cst (type); }))))\n-\n- /* Simplify sin(x) / cos(x) -> tan(x). */\n- (simplify\n-  (rdiv (SIN:s @0) (COS:s @0))\n-   (TAN @0))\n-\n- /* Simplify cos(x) / sin(x) -> 1 / tan(x). */\n- (simplify\n-  (rdiv (COS:s @0) (SIN:s @0))\n-   (rdiv { build_one_cst (type); } (TAN @0)))\n-\n- /* Simplify sin(x) / tan(x) -> cos(x). */\n- (simplify\n-  (rdiv (SIN:s @0) (TAN:s @0))\n-  (if (! HONOR_NANS (@0)\n-       && ! HONOR_INFINITIES (@0))\n-   (cos @0)))\n-\n- /* Simplify tan(x) / sin(x) -> 1.0 / cos(x). */\n- (simplify\n-  (rdiv (TAN:s @0) (SIN:s @0))\n-  (if (! HONOR_NANS (@0)\n-       && ! HONOR_INFINITIES (@0))\n-   (rdiv { build_one_cst (type); } (COS @0))))\n-\n- /* Simplify pow(x,c) / x -> pow(x,c-1). */\n- (simplify\n-  (rdiv (POW:s @0 REAL_CST@1) @0)\n-  (if (!TREE_OVERFLOW (@1))\n-   (POW @0 (minus @1 { build_one_cst (type); }))))\n-\n  /* Simplify a/root(b/c) into a*root(c/b).  */\n  (for root (SQRT CBRT)\n   (simplify\n@@ -2221,17 +2184,13 @@ along with GCC; see the file COPYING3.  If not see\n    (rdiv @0 (exps:s @1))\n     (mult @0 (exps (negate @1)))))\n \n- /* Simplify x / pow (y,z) -> x * pow(y,-z). */\n- (simplify\n-  (rdiv @0 (POW:s @1 @2))\n-   (mult @0 (POW @1 (negate @2))))\n-\n  /* Special case, optimize logN(expN(x)) = x.  */\n  (for logs (LOG LOG2 LOG10 LOG10)\n       exps (EXP EXP2 EXP10 POW10)\n   (simplify\n    (logs (exps @0))\n     @0))\n+\n  /* Optimize logN(func()) for various exponential functions.  We\n     want to determine the value \"x\" and the power \"exponent\" in\n     order to transform logN(x**exponent) into exponent*logN(x).  */\n@@ -2244,16 +2203,16 @@ along with GCC; see the file COPYING3.  If not see\n      switch (exps)\n        {\n        CASE_FLT_FN (BUILT_IN_EXP):\n-         /* Prepare to do logN(exp(exponent) -> exponent*logN(e).  */\n+         /* Prepare to do logN(exp(exponent)) -> exponent*logN(e).  */\n \t x = build_real_truncate (type, dconst_e ());\n          break;\n        CASE_FLT_FN (BUILT_IN_EXP2):\n-         /* Prepare to do logN(exp2(exponent) -> exponent*logN(2).  */\n+         /* Prepare to do logN(exp2(exponent)) -> exponent*logN(2).  */\n          x = build_real (type, dconst2);\n          break;\n        CASE_FLT_FN (BUILT_IN_EXP10):\n        CASE_FLT_FN (BUILT_IN_POW10):\n-\t /* Prepare to do logN(exp10(exponent) -> exponent*logN(10).  */\n+\t /* Prepare to do logN(exp10(exponent)) -> exponent*logN(10).  */\n \t {\n \t   REAL_VALUE_TYPE dconst10;\n \t   real_from_integer (&dconst10, VOIDmode, 10, SIGNED);\n@@ -2265,6 +2224,7 @@ along with GCC; see the file COPYING3.  If not see\n        }\n      }\n     (mult (logs { x; }) @0))))\n+\n  (for logs (LOG LOG\n             LOG2 LOG2\n \t    LOG10 LOG10)\n@@ -2276,24 +2236,130 @@ along with GCC; see the file COPYING3.  If not see\n      switch (exps)\n        {\n        CASE_FLT_FN (BUILT_IN_SQRT):\n-\t /* Prepare to do logN(sqrt(x) -> 0.5*logN(x).  */\n+\t /* Prepare to do logN(sqrt(x)) -> 0.5*logN(x).  */\n \t x = build_real (type, dconsthalf);\n          break;\n        CASE_FLT_FN (BUILT_IN_CBRT):\n-\t /* Prepare to do logN(cbrt(x) -> (1/3)*logN(x).  */\n+\t /* Prepare to do logN(cbrt(x)) -> (1/3)*logN(x).  */\n          x = build_real_truncate (type, dconst_third ());\n          break;\n        default:\n \t gcc_unreachable ();\n        }\n      }\n     (mult { x; } (logs @0)))))\n- /* logN(pow(x,exponent) -> exponent*logN(x).  */\n+\n+ /* logN(pow(x,exponent)) -> exponent*logN(x).  */\n  (for logs (LOG LOG2 LOG10)\n       pows (POW)\n   (simplify\n    (logs (pows @0 @1))\n-   (mult @1 (logs @0)))))\n+   (mult @1 (logs @0))))\n+\n+ (for sqrts (SQRT)\n+      cbrts (CBRT)\n+      exps (EXP EXP2 EXP10 POW10)\n+  /* sqrt(expN(x)) -> expN(x*0.5).  */\n+  (simplify\n+   (sqrts (exps @0))\n+   (exps (mult @0 { build_real (type, dconsthalf); })))\n+  /* cbrt(expN(x)) -> expN(x/3).  */\n+  (simplify\n+   (cbrts (exps @0))\n+   (exps (mult @0 { build_real_truncate (type, dconst_third ()); })))))\n+\n+/* Canonicalization of sequences of math builtins.  These rules represent\n+   IL simplifications but are not necessarily optimizations.\n+\n+   The sincos pass is responsible for picking \"optimal\" implementations\n+   of math builtins, which may be more complicated and can sometimes go\n+   the other way, e.g. converting pow into a sequence of sqrts.\n+   We only want to do these canonicalizations before the pass has run.  */\n+\n+(if (flag_unsafe_math_optimizations && canonicalize_math_p ())\n+ /* Simplify tan(x) * cos(x) -> sin(x). */\n+ (simplify\n+  (mult:c (TAN:s @0) (COS:s @0))\n+   (SIN @0))\n+\n+ /* Simplify x * pow(x,c) -> pow(x,c+1). */\n+ (simplify\n+  (mult @0 (POW:s @0 REAL_CST@1))\n+  (if (!TREE_OVERFLOW (@1))\n+   (POW @0 (plus @1 { build_one_cst (type); }))))\n+\n+ /* Simplify sin(x) / cos(x) -> tan(x). */\n+ (simplify\n+  (rdiv (SIN:s @0) (COS:s @0))\n+   (TAN @0))\n+\n+ /* Simplify cos(x) / sin(x) -> 1 / tan(x). */\n+ (simplify\n+  (rdiv (COS:s @0) (SIN:s @0))\n+   (rdiv { build_one_cst (type); } (TAN @0)))\n+\n+ /* Simplify sin(x) / tan(x) -> cos(x). */\n+ (simplify\n+  (rdiv (SIN:s @0) (TAN:s @0))\n+  (if (! HONOR_NANS (@0)\n+       && ! HONOR_INFINITIES (@0))\n+   (cos @0)))\n+\n+ /* Simplify tan(x) / sin(x) -> 1.0 / cos(x). */\n+ (simplify\n+  (rdiv (TAN:s @0) (SIN:s @0))\n+  (if (! HONOR_NANS (@0)\n+       && ! HONOR_INFINITIES (@0))\n+   (rdiv { build_one_cst (type); } (COS @0))))\n+\n+ /* Simplify pow(x,y) * pow(x,z) -> pow(x,y+z). */\n+ (simplify\n+  (mult (POW:s @0 @1) (POW:s @0 @2))\n+   (POW @0 (plus @1 @2)))\n+\n+ /* Simplify pow(x,y) * pow(z,y) -> pow(x*z,y). */\n+ (simplify\n+  (mult (POW:s @0 @1) (POW:s @2 @1))\n+   (POW (mult @0 @2) @1))\n+\n+ /* Simplify pow(x,c) / x -> pow(x,c-1). */\n+ (simplify\n+  (rdiv (POW:s @0 REAL_CST@1) @0)\n+  (if (!TREE_OVERFLOW (@1))\n+   (POW @0 (minus @1 { build_one_cst (type); }))))\n+\n+ /* Simplify x / pow (y,z) -> x * pow(y,-z). */\n+ (simplify\n+  (rdiv @0 (POW:s @1 @2))\n+   (mult @0 (POW @1 (negate @2))))\n+\n+ (for sqrts (SQRT)\n+      cbrts (CBRT)\n+      pows (POW)\n+  /* sqrt(sqrt(x)) -> pow(x,1/4).  */\n+  (simplify\n+   (sqrts (sqrts @0))\n+   (pows @0 { build_real (type, dconst_quarter ()); }))\n+  /* sqrt(cbrt(x)) -> pow(x,1/6).  */\n+  (simplify\n+   (sqrts (cbrts @0))\n+   (pows @0 { build_real_truncate (type, dconst_sixth ()); }))\n+  /* cbrt(sqrt(x)) -> pow(x,1/6).  */\n+  (simplify\n+   (cbrts (sqrts @0))\n+   (pows @0 { build_real_truncate (type, dconst_sixth ()); }))\n+  /* cbrt(cbrt(x)) -> pow(x,1/9), iff x is nonnegative.  */\n+  (simplify\n+   (cbrts (cbrts tree_expr_nonnegative_p@0))\n+   (pows @0 { build_real_truncate (type, dconst_ninth ()); }))\n+  /* sqrt(pow(x,y)) -> pow(|x|,y*0.5).  */\n+  (simplify\n+   (sqrts (pows @0 @1))\n+   (pows (abs @0) (mult @1 { build_real (type, dconsthalf); })))\n+  /* cbrt(pow(x,y)) -> pow(x,y/3), iff x is nonnegative.  */\n+  (simplify\n+   (cbrts (pows tree_expr_nonnegative_p@0 @1))\n+   (pows @0 (mult @1 { build_real_truncate (type, dconst_third ()); })))))\n \n /* Narrowing of arithmetic and logical operations. \n \n@@ -2365,44 +2431,3 @@ along with GCC; see the file COPYING3.  If not see\n     (with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n      (convert (bit_and (op (convert:utype @0) (convert:utype @1))\n \t       (convert:utype @4))))))))\n-\n-(if (flag_unsafe_math_optimizations)\n- (for sqrts (SQRT)\n-      cbrts (CBRT)\n-      exps (EXP EXP2 EXP10 POW10)\n-  /* sqrt(expN(x)) -> expN(x*0.5).  */\n-  (simplify\n-   (sqrts (exps @0))\n-   (exps (mult @0 { build_real (type, dconsthalf); })))\n-  /* cbrt(expN(x)) -> expN(x/3).  */\n-  (simplify\n-   (cbrts (exps @0))\n-   (exps (mult @0 { build_real_truncate (type, dconst_third ()); }))))\n-\n- (for sqrts (SQRT)\n-      cbrts (CBRT)\n-      pows (POW)\n-  /* sqrt(sqrt(x)) -> pow(x,1/4).  */\n-  (simplify\n-   (sqrts (sqrts @0))\n-   (pows @0 { build_real (type, dconst_quarter ()); }))\n-  /* sqrt(cbrt(x)) -> pow(x,1/6).  */\n-  (simplify\n-   (sqrts (cbrts @0))\n-   (pows @0 { build_real_truncate (type, dconst_sixth ()); }))\n-  /* cbrt(sqrt(x)) -> pow(x,1/6).  */\n-  (simplify\n-   (cbrts (sqrts @0))\n-   (pows @0 { build_real_truncate (type, dconst_sixth ()); }))\n-  /* cbrt(cbrt(x)) -> pow(x,1/9), iff x is nonnegative.  */\n-  (simplify\n-   (cbrts (cbrts tree_expr_nonnegative_p@0))\n-   (pows @0 { build_real_truncate (type, dconst_ninth ()); }))\n-  /* sqrt(pow(x,y)) -> pow(|x|,y*0.5).  */\n-  (simplify\n-   (sqrts (pows @0 @1))\n-   (pows (abs @0) (mult @1 { build_real (type, dconsthalf); })))\n-  /* cbrt(pow(x,y)) -> pow(x,y/3), iff x is nonnegative.  */\n-  (simplify\n-   (cbrts (pows tree_expr_nonnegative_p@0 @1))\n-   (pows @0 (mult @1 { build_real_truncate (type, dconst_third ()); })))))"}, {"sha": "c37e4b2c2e9b8e485a0ed55e0c87db664293b8b7", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -222,6 +222,10 @@ class simple_ipa_opt_pass : public opt_pass\n #define PROP_gimple_lvec\t(1 << 12)       /* lowered vector */\n #define PROP_gimple_eomp\t(1 << 13)       /* no OpenMP directives */\n #define PROP_gimple_lva\t\t(1 << 14)       /* No va_arg internal function.  */\n+#define PROP_gimple_opt_math\t(1 << 15)\t/* Disable canonicalization\n+\t\t\t\t\t\t   of math functions; the\n+\t\t\t\t\t\t   current choices have\n+\t\t\t\t\t\t   been optimized.  */\n \n #define PROP_trees \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh | PROP_gimple_lomp)"}, {"sha": "92236422f2a7af05ef89b14099b77324944982ef", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53f3cd25de6706b1850650111a31c0ea0bb63406/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=53f3cd25de6706b1850650111a31c0ea0bb63406", "patch": "@@ -1689,7 +1689,7 @@ const pass_data pass_data_cse_sincos =\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n+  PROP_gimple_opt_math, /* properties_provided */\n   0, /* properties_destroyed */\n   0, /* todo_flags_start */\n   TODO_update_ssa, /* todo_flags_finish */"}]}