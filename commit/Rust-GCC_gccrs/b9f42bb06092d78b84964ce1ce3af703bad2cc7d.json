{"sha": "b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlmNDJiYjA2MDkyZDc4Yjg0OTY0Y2UxY2UzYWY3MDNiYWQyY2M3ZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-09-25T07:46:19Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-09-25T07:46:19Z"}, "message": "Proxy.java (generate): Uncomment protection domain code.\n\n\t* java/lang/reflect/Proxy.java (generate): Uncomment protection\n\tdomain code.\n\t* java/lang/natClassLoader.cc (defineClass): Added `loader'\n\targument.\n\t(linkClass0): Now in VMClassLoader.\n\t(markClassErrorState0): Likewise.\n\t(getSystemClassLoaderInternal): New method.\n\t* java/lang/natClass.cc (initializeClass): Use\n\tVMClassLoader::resolveClass.\n\t* java/lang/ClassLoader.java: New version, from Classpath.\n\t* java/lang/Class.java (getProtectionDomain):\n\tprotectionDomainPermission and unknownProtectionDomain now in\n\tVMClassLoader.\n\t* java/lang/Class.h: VMClassLoader now a friend class.\n\t* gnu/gcj/runtime/VMClassLoader.java (instance): Now\n\tpackage-private.\n\t* gcj/javaprims.h: Regenerated class list.\n\t* resolve.cc (_Jv_PrepareClass): Use VMClassLoader::resolveClass.\n\t* java/lang/VMClassLoader.java: New version from Classpath;\n\tmodified for libgcj use.\n\nFrom-SVN: r71765", "tree": {"sha": "c440653c21ba6d47253f60036888a563bd7f60a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c440653c21ba6d47253f60036888a563bd7f60a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/comments", "author": null, "committer": null, "parents": [{"sha": "d70f15d251b73bbddfd304f1f8ae2d7367dcc79f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70f15d251b73bbddfd304f1f8ae2d7367dcc79f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70f15d251b73bbddfd304f1f8ae2d7367dcc79f"}], "stats": {"total": 1570, "additions": 880, "deletions": 690}, "files": [{"sha": "c98cf130fab6c36a800fb1317d01c446175dc801", "filename": "libjava/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1,3 +1,26 @@\n+2003-09-25  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/reflect/Proxy.java (generate): Uncomment protection\n+\tdomain code.\n+\t* java/lang/natClassLoader.cc (defineClass): Added `loader'\n+\targument.\n+\t(linkClass0): Now in VMClassLoader.\n+\t(markClassErrorState0): Likewise.\n+\t(getSystemClassLoaderInternal): New method.\n+\t* java/lang/natClass.cc (initializeClass): Use\n+\tVMClassLoader::resolveClass.\n+\t* java/lang/ClassLoader.java: New version, from Classpath.\n+\t* java/lang/Class.java (getProtectionDomain):\n+\tprotectionDomainPermission and unknownProtectionDomain now in\n+\tVMClassLoader.\n+\t* java/lang/Class.h: VMClassLoader now a friend class.\n+\t* gnu/gcj/runtime/VMClassLoader.java (instance): Now\n+\tpackage-private.\n+\t* gcj/javaprims.h: Regenerated class list.\n+\t* resolve.cc (_Jv_PrepareClass): Use VMClassLoader::resolveClass.\n+\t* java/lang/VMClassLoader.java: New version from Classpath;\n+\tmodified for libgcj use.\n+\n 2003-09-25  Michael Koch  <konqueror@gmx.de>\n \n \t* java/nio/ByteBufferHelper.java:"}, {"sha": "b88b3fe3e71b11389e7bd805921422e360fb6630", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1,6 +1,6 @@\n // javaprims.h - Main external header file for libgcj.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -373,6 +373,39 @@ extern \"Java\"\n         class Manifest;\n       }\n \n+      namespace logging\n+      {\n+        class ConsoleHandler;\n+        class ErrorManager;\n+        class FileHandler;\n+        class Filter;\n+        class Formatter;\n+        class Handler;\n+        class Level;\n+        class LogManager;\n+        class LogRecord;\n+        class Logger;\n+        class LoggingPermission;\n+        class MemoryHandler;\n+        class SimpleFormatter;\n+        class SocketHandler;\n+        class StreamHandler;\n+        class XMLFormatter;\n+      }\n+\n+      namespace prefs\n+      {\n+        class AbstractPreferences;\n+        class BackingStoreException;\n+        class InvalidPreferencesFormatException;\n+        class NodeChangeEvent;\n+        class NodeChangeListener;\n+        class PreferenceChangeEvent;\n+        class PreferenceChangeListener;\n+        class Preferences;\n+        class PreferencesFactory;\n+      }\n+\n       namespace regex\n       {\n         class Matcher;"}, {"sha": "c5cb056570fe7605e1eac04afea78b5fab1fd0fe", "filename": "libjava/gnu/gcj/runtime/VMClassLoader.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -90,7 +90,7 @@ protected native Class findClass(String name)\n   private int lib_control;\n \n   // The only VMClassLoader that can exist.\n-  public static VMClassLoader instance = new VMClassLoader();\n+  static VMClassLoader instance = new VMClassLoader();\n \n   private static final int LIB_FULL = 0;\n   private static final int LIB_CACHE = 1;"}, {"sha": "7fe96d0a01fd63fd5dbbe14166ebd0eb855ce6a7", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -290,6 +290,7 @@ class java::lang::Class : public java::lang::Object\n \n   // Friends classes and functions to implement the ClassLoader\n   friend class java::lang::ClassLoader;\n+  friend class java::lang::VMClassLoader;\n \n   friend class java::io::ObjectOutputStream;\n   friend class java::io::ObjectInputStream;"}, {"sha": "86d52be4b87b18e79f3f6ac739d566821c5e379d", "filename": "libjava/java/lang/Class.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClass.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClass.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.java?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -227,12 +227,12 @@ public ProtectionDomain getProtectionDomain()\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n-      sm.checkPermission(ClassLoader.protectionDomainPermission);\n+      sm.checkPermission(VMClassLoader.protectionDomainPermission);\n     \n     ProtectionDomain protectionDomain = getProtectionDomain0();\n \n     if (protectionDomain == null)\n-      return ClassLoader.unknownProtectionDomain;\n+      return VMClassLoader.unknownProtectionDomain;\n     else\n       return protectionDomain;\n   }"}, {"sha": "103976758d7faacfa4e406fab4aedb0982925ab8", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 520, "deletions": 581, "changes": 1101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1,25 +1,56 @@\n-// ClassLoader.java - Define policies for loading Java classes.\n+/* ClassLoader.java -- responsible for loading classes into the VM\n+   Copyright (C) 1998, 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang;\n \n import java.io.InputStream;\n import java.io.IOException;\n+import java.lang.reflect.Constructor;\n import java.net.URL;\n-import java.security.AllPermission;\n import java.security.CodeSource;\n-import java.security.Permission;\n-import java.security.Permissions;\n+import java.security.PermissionCollection;\n import java.security.Policy;\n import java.security.ProtectionDomain;\n-import java.util.*;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import gnu.java.util.DoubleEnumeration;\n+import gnu.java.util.EmptyEnumeration;\n \n /**\n  * The ClassLoader is a way of customizing the way Java gets its classes\n@@ -30,11 +61,11 @@\n  * modification!\n  *\n  * <p>Every classloader has a parent classloader that is consulted before\n- * the 'child' classloader when classes or resources should be loaded.   \n+ * the 'child' classloader when classes or resources should be loaded.\n  * This is done to make sure that classes can be loaded from an hierarchy of\n- * multiple classloaders and classloaders do not accidentially redefine   \n+ * multiple classloaders and classloaders do not accidentially redefine\n  * already loaded classes by classloaders higher in the hierarchy.\n- *   \n+ *\n  * <p>The grandparent of all classloaders is the bootstrap classloader, which\n  * loads all the standard system classes as implemented by GNU Classpath. The\n  * other special classloader is the system classloader (also called\n@@ -78,8 +109,7 @@\n  *\n  * @author John Keiser\n  * @author Mark Wielaard\n- * @author Eric Blake\n- * @author Kresten Krab Thorup\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  * @see Class\n  * @since 1.0\n  * @status still missing 1.4 functionality\n@@ -94,6 +124,50 @@\n    */\n   final Map loadedClasses = new HashMap();\n \n+  /**\n+   * All packages defined by this classloader. It is not private in order to\n+   * allow native code (and trusted subclasses) access to this field.\n+   */\n+  final Map definedPackages = new HashMap();\n+\n+  /**\n+   * The classloader that is consulted before this classloader.\n+   * If null then the parent is the bootstrap classloader.\n+   */\n+  private final ClassLoader parent;\n+\n+  /**\n+   * This is true if this classloader was successfully initialized.\n+   * This flag is needed to avoid a class loader attack: even if the\n+   * security manager rejects an attempt to create a class loader, the\n+   * malicious class could have a finalize method which proceeds to\n+   * define classes.\n+   */\n+  private final boolean initialized;\n+\n+  /**\n+   * System/Application classloader: defaults to an instance of\n+   * gnu.java.lang.SystemClassLoader, unless the first invocation of\n+   * getSystemClassLoader loads another class loader because of the\n+   * java.system.class.loader property. The initialization of this field\n+   * is somewhat circular - getSystemClassLoader() checks whether this\n+   * field is null in order to bypass a security check.\n+   */\n+  static final ClassLoader systemClassLoader =\n+    VMClassLoader.getSystemClassLoader();\n+\n+  /**\n+   * The default protection domain, used when defining a class with a null\n+   * paramter for the domain.\n+   */\n+  static final ProtectionDomain defaultProtectionDomain;\n+  static\n+  {\n+    CodeSource cs = new CodeSource(null, null);\n+    PermissionCollection perm = Policy.getPolicy().getPermissions(cs);\n+    defaultProtectionDomain = new ProtectionDomain(cs, perm);\n+  }\n+\n   /**\n    * The desired assertion status of classes loaded by this loader, if not\n    * overridden by package or class instructions.\n@@ -136,157 +210,105 @@\n   Map classAssertionStatus;\n \n   /**\n-   * The classloader that is consulted before this classloader.\n-   * If null then the parent is the bootstrap classloader.\n-   */\n-  private final ClassLoader parent;\n-\n-  /**\n-   * All packages defined by this classloader. It is not private in order to\n-   * allow native code (and trusted subclasses) access to this field.\n-   */\n-  private HashMap definedPackages = new HashMap();\n-\n-  /**\n-   * Returns the parent of this classloader. If the parent of this\n-   * classloader is the bootstrap classloader then this method returns\n-   * <code>null</code>. A security check may be performed on\n-   * <code>RuntimePermission(\"getClassLoader\")</code>.\n+   * Create a new ClassLoader with as parent the system classloader. There\n+   * may be a security check for <code>checkCreateClassLoader</code>.\n    *\n    * @throws SecurityException if the security check fails\n-   * @since 1.2\n    */\n-  public final ClassLoader getParent ()\n+  protected ClassLoader() throws SecurityException\n   {\n-    // Check if we may return the parent classloader\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null)\n-      {\n-\tClass c = VMSecurityManager.getClassContext()[1];\n-\tClassLoader cl = c.getClassLoader();\n-\tif (cl != null && ! cl.isAncestorOf(this))\n-\t  sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n-      }\n-    return parent;\n+    this(systemClassLoader);\n   }\n \n   /**\n-   * Returns the system classloader. The system classloader (also called\n-   * the application classloader) is the classloader that was used to\n-   * load the application classes on the classpath (given by the system\n-   * property <code>java.class.path</code>. This is set as the context\n-   * class loader for a thread. The system property\n-   * <code>java.system.class.loader</code>, if defined, is taken to be the\n-   * name of the class to use as the system class loader, which must have\n-   * a public constructor which takes a ClassLoader as a parent; otherwise this\n-   * uses gnu.java.lang.SystemClassLoader.\n-   *\n-   * <p>Note that this is different from the bootstrap classloader that\n-   * actually loads all the real \"system\" classes (the bootstrap classloader\n-   * is the parent of the returned system classloader).\n+   * Create a new ClassLoader with the specified parent. The parent will\n+   * be consulted when a class or resource is requested through\n+   * <code>loadClass()</code> or <code>getResource()</code>. Only when the\n+   * parent classloader cannot provide the requested class or resource the\n+   * <code>findClass()</code> or <code>findResource()</code> method\n+   * of this classloader will be called. There may be a security check for\n+   * <code>checkCreateClassLoader</code>.\n    *\n-   * <p>A security check will be performed for\n-   * <code>RuntimePermission(\"getClassLoader\")</code> if the calling class\n-   * is not a parent of the system class loader.\n-   *\n-   * @return the system class loader\n+   * @param parent the classloader's parent, or null for the bootstrap\n+   *        classloader\n    * @throws SecurityException if the security check fails\n-   * @throws IllegalStateException if this is called recursively\n-   * @throws Error if <code>java.system.class.loader</code> fails to load\n    * @since 1.2\n    */\n-  public static ClassLoader getSystemClassLoader ()\n+  protected ClassLoader(ClassLoader parent)\n   {\n-    return gnu.gcj.runtime.VMClassLoader.instance;\n+    // May we create a new classloader?\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      sm.checkCreateClassLoader();\n+    this.parent = parent;\n+    this.initialized = true;\n   }\n \n   /**\n-   * Creates a <code>ClassLoader</code> with no parent.\n-   * @exception java.lang.SecurityException if not allowed\n+   * Load a class using this ClassLoader or its parent, without resolving\n+   * it. Calls <code>loadClass(name, false)</code>.\n+   *\n+   * <p>Subclasses should not override this method but should override\n+   * <code>findClass()</code> which is called by this method.\n+   *\n+   * @param name the name of the class relative to this ClassLoader\n+   * @return the loaded class\n+   * @throws ClassNotFoundException if the class cannot be found\n    */\n-  protected ClassLoader() \n+  public Class loadClass(String name) throws ClassNotFoundException\n   {\n-    this (null);\n+    return loadClass(name, false);\n   }\n \n   /**\n-   * Creates a <code>ClassLoader</code> with the given parent.   \n-   * The parent may be <code>null</code>.\n-   * The only thing this \n-   * constructor does, is to call\n-   * <code>checkCreateClassLoader</code> on the current \n-   * security manager. \n-   * @exception java.lang.SecurityException if not allowed\n-   * @since 1.2\n+   * Load a class using this ClassLoader or its parent, possibly resolving\n+   * it as well using <code>resolveClass()</code>. It first tries to find\n+   * out if the class has already been loaded through this classloader by\n+   * calling <code>findLoadedClass()</code>. Then it calls\n+   * <code>loadClass()</code> on the parent classloader (or when there is\n+   * no parent it uses the VM bootclassloader)</code>). If the class is still\n+   * not loaded it tries to create a new class by calling\n+   * <code>findClass()</code>. Finally when <code>resolve</code> is\n+   * <code>true</code> it also calls <code>resolveClass()</code> on the\n+   * newly loaded class.\n+   *\n+   * <p>Subclasses should not override this method but should override\n+   * <code>findClass()</code> which is called by this method.\n+   *\n+   * @param name the fully qualified name of the class to load\n+   * @param resolve whether or not to resolve the class\n+   * @return the loaded class\n+   * @throws ClassNotFoundException if the class cannot be found\n    */\n-  protected ClassLoader(ClassLoader parent) \n+  protected synchronized Class loadClass(String name, boolean resolve)\n+    throws ClassNotFoundException\n   {\n-    SecurityManager security = System.getSecurityManager ();\n-    if (security != null)\n-      security.checkCreateClassLoader ();\n-    this.parent = parent;\n-  }\n+    // Have we already loaded this class?\n+    Class c = findLoadedClass(name);\n+    if (c != null)\n+      return c;\n \n-  /** \n-   * Loads and link the class by the given name.\n-   * @param     name the name of the class.\n-   * @return    the class loaded.\n-   * @see       ClassLoader#loadClass(String,boolean)\n-   * @exception java.lang.ClassNotFoundException \n-   */ \n-  public Class loadClass(String name)\n-    throws java.lang.ClassNotFoundException\n-  { \n-    return loadClass (name, false);\n-  }\n-  \n-  /** \n-   * Loads the class by the given name.  The default implementation\n-   * will search for the class in the following order (similar to jdk 1.2)\n-   * <ul>\n-   *  <li> First <code>findLoadedClass</code>.\n-   *  <li> If parent is non-null, <code>parent.loadClass</code>;\n-   *       otherwise <code>findSystemClass</code>.\n-   *  <li> <code>findClass</code>.\n-   * </ul>\n-   * If <code>link</code> is true, <code>resolveClass</code> is then\n-   * called.  <p> Normally, this need not be overridden; override\n-   * <code>findClass</code> instead.\n-   * @param     name the name of the class.\n-   * @param     link if the class should be linked.\n-   * @return    the class loaded.\n-   * @exception java.lang.ClassNotFoundException \n-   */ \n-  protected Class loadClass(String name, boolean link)\n-    throws java.lang.ClassNotFoundException\n-  {\n-    Class c = findLoadedClass (name);\n-\n-    if (c == null)\n+    // Can the class be loaded by a parent?\n+    try\n       {\n-\ttry\n+\tif (parent == null)\n \t  {\n-\t    ClassLoader cl = parent;\n-\t    if (parent == null)\n-\t      cl = gnu.gcj.runtime.VMClassLoader.instance;\n-\t    if (cl != this)\n-\t      c = cl.loadClass (name, link);\n+\t    c = VMClassLoader.loadClass(name, resolve);\n+\t    if (c != null)\n+\t      return c;\n \t  }\n-\tcatch (ClassNotFoundException ex)\n+\telse\n \t  {\n-\t    /* ignore, we'll try findClass */;\n+\t    return parent.loadClass(name, resolve);\n \t  }\n       }\n-\n-    if (c == null)\n-      c = findClass (name);\n-\n-    if (c == null)\n-      throw new ClassNotFoundException (name);\n-\n-    if (link)\n-      resolveClass (c);\n-\n+    catch (ClassNotFoundException e)\n+      {\n+      }\n+    // Still not found, we have to do it ourself.\n+    c = findClass(name);\n+    if (resolve)\n+      resolveClass(c);\n     return c;\n   }\n \n@@ -331,59 +353,29 @@ protected Class loadClass(String name, boolean link)\n    * @return the requested Class\n    * @throws ClassNotFoundException when the class can not be found\n    * @since 1.2\n-   */   \n-  protected Class findClass (String name)\n-    throws ClassNotFoundException\n+   */\n+  protected Class findClass(String name) throws ClassNotFoundException\n   {\n-    throw new ClassNotFoundException (name);\n+    throw new ClassNotFoundException(name);\n   }\n \n-  // Protection Domain definitions \n-  // FIXME: should there be a special protection domain used for native code?\n-  \n-  // The permission required to check what a classes protection domain is.\n-  static final Permission protectionDomainPermission\n-    = new RuntimePermission(\"getProtectionDomain\");\n-  // The protection domain returned if we cannot determine it. \n-  static ProtectionDomain unknownProtectionDomain;\n-  // Protection domain to use when a class is defined without one specified.\n-  static ProtectionDomain defaultProtectionDomain;\n-\n-  static\n-  {\n-    Permissions permissions = new Permissions();\n-    permissions.add(new AllPermission());\n-    unknownProtectionDomain = new ProtectionDomain(null, permissions);  \n-\n-    CodeSource cs = new CodeSource(null, null);\n-    defaultProtectionDomain =\n-      new ProtectionDomain(cs, Policy.getPolicy().getPermissions(cs));\n-  }\n-\n-  /** \n-   * Defines a class, given the class-data.  According to the JVM, this\n-   * method should not be used; instead use the variant of this method\n-   * in which the name of the class being defined is specified\n-   * explicitly.   \n-   * <P>\n-   * If the name of the class, as specified (implicitly) in the class\n-   * data, denotes a class which has already been loaded by this class\n-   * loader, an instance of\n-   * <code>java.lang.ClassNotFoundException</code> will be thrown.\n-   *\n-   * @param     data    bytes in class file format.\n-   * @param     off     offset to start interpreting data.\n-   * @param     len     length of data in class file.\n-   * @return    the class defined.\n-   * @exception java.lang.ClassNotFoundException \n-   * @exception java.lang.LinkageError\n-   * @see ClassLoader#defineClass(String,byte[],int,int)\n+  /**\n+   * Helper to define a class using a string of bytes. This version is not\n+   * secure.\n+   *\n+   * @param data the data representing the classfile, in classfile format\n+   * @param offset the offset into the data where the classfile starts\n+   * @param len the length of the classfile data in the array\n+   * @return the class that was defined\n+   * @throws ClassFormatError if data is not in proper classfile format\n+   * @throws IndexOutOfBoundsException if offset or len is negative, or\n+   *         offset + len exceeds data\n    * @deprecated use {@link #defineClass(String, byte[], int, int)} instead\n    */\n-  protected final Class defineClass(byte[] data, int off, int len) \n+  protected final Class defineClass(byte[] data, int offset, int len)\n     throws ClassFormatError\n   {\n-    return defineClass (null, data, off, len, defaultProtectionDomain);\n+    return defineClass(null, data, offset, len);\n   }\n \n   /**\n@@ -405,351 +397,225 @@ protected final Class defineClass(byte[] data, int off, int len)\n    * @throws SecurityException if name starts with \"java.\"\n    * @since 1.1\n    */\n-  protected final Class defineClass(String name, byte[] data, int off, int len)\n-    throws ClassFormatError\n+  protected final Class defineClass(String name, byte[] data, int offset,\n+                                    int len) throws ClassFormatError\n   {\n-    return defineClass (name, data, off, len, defaultProtectionDomain);\n+    return defineClass(name, data, offset, len, null);\n   }\n-  \n-  /** \n-   * Defines a class, given the class-data.  This is preferable\n-   * over <code>defineClass(byte[],off,len)</code> since it is more\n-   * secure.  If the expected name does not match that of the class\n-   * file, <code>ClassNotFoundException</code> is thrown.  If\n-   * <code>name</code> denotes the name of an already loaded class, a\n-   * <code>LinkageError</code> is thrown.\n-   * <p>\n-   * \n-   * FIXME: How do we assure that the class-file data is not being\n-   * modified, simultaneously with the class loader running!?  If this\n-   * was done in some very clever way, it might break security.  \n-   * Right now I am thinking that defineclass should make sure never to\n-   * read an element of this array more than once, and that that would\n-   * assure the ``immutable'' appearance.  It is still to be determined\n-   * if this is in fact how defineClass operates.\n-   *\n-   * @param     name    the expected name.\n-   * @param     data    bytes in class file format.\n-   * @param     off     offset to start interpreting data.\n-   * @param     len     length of data in class file.\n-   * @param     protectionDomain security protection domain for the class.\n-   * @return    the class defined.\n-   * @exception java.lang.ClassNotFoundException \n-   * @exception java.lang.LinkageError\n-   */\n-  protected final synchronized Class defineClass(String name,\n-\t\t\t\t\t\t byte[] data,\n-\t\t\t\t\t\t int off,\n-\t\t\t\t\t\t int len,\n-\t\t\t\t\t\t ProtectionDomain protectionDomain)\n+\n+  /**\n+   * Helper to define a class using a string of bytes. Subclasses should call\n+   * this method from their <code>findClass()</code> implementation. If the\n+   * domain is null, the default of\n+   * <code>Policy.getPolicy().getPermissions(new CodeSource(null, null))<code>\n+   * is used. Once a class has been defined in a package, all further classes\n+   * in that package must have the same set of certificates or a\n+   * SecurityException is thrown.\n+   *\n+   * @param name the name to give the class.  null if unknown\n+   * @param data the data representing the classfile, in classfile format\n+   * @param offset the offset into the data where the classfile starts\n+   * @param len the length of the classfile data in the array\n+   * @param domain the ProtectionDomain to give to the class, null for the\n+   *        default protection domain\n+   * @return the class that was defined\n+   * @throws ClassFormatError if data is not in proper classfile format\n+   * @throws IndexOutOfBoundsException if offset or len is negative, or\n+   *         offset + len exceeds data\n+   * @throws SecurityException if name starts with \"java.\", or if certificates\n+   *         do not match up\n+   * @since 1.2\n+   */\n+  protected final synchronized Class defineClass(String name, byte[] data,\n+\t\t\t\t\t\t int offset, int len,\n+\t\t\t\t\t\t ProtectionDomain domain)\n     throws ClassFormatError\n   {\n-    if (data==null || data.length < off+len || off<0 || len<0)\n-      throw new ClassFormatError (\"arguments to defineClass \"\n-\t\t\t\t  + \"are meaningless\");\n-\n-    // as per 5.3.5.1\n-    if (name != null && findLoadedClass (name) != null)\n-      throw new java.lang.LinkageError (\"class \" \n-\t\t\t\t\t+ name \n-\t\t\t\t\t+ \" already loaded\");\n-\n-    if (protectionDomain == null)\n-      protectionDomain = defaultProtectionDomain;\n-\n-    try\n-      {\n-\tClass retval = defineClass0 (name, data, off, len, protectionDomain);\n-\tloadedClasses.put(retval.getName(), retval);\n-\treturn retval;\n-      }\n-    catch (LinkageError x)\n-      {\n-\tthrow x;\t\t// rethrow\n-      }\n-    catch (VirtualMachineError x)\n-      {\n-\tthrow x;\t\t// rethrow\n-      }\n-    catch (Throwable x)\n-      {\n-\t// This should never happen, or we are beyond spec.  \n-      \tInternalError r = new InternalError (\"Unexpected exception \"\n-\t\t\t\t\t     + \"while defining class \"\n-\t\t\t\t\t     + name);\n-\tr.initCause(x);\n-\tthrow r;\n-      }\n+    if (domain == null)\n+      domain = defaultProtectionDomain;\n+    if (! initialized)\n+      throw new SecurityException(\"attempt to define class from uninitialized class loader\");\n+    Class retval = VMClassLoader.defineClass(this, name, data,\n+                                             offset, len, domain);\n+    loadedClasses.put(retval.getName(), retval);\n+    return retval;\n   }\n \n-  /** This is the entry point of defineClass into the native code */\n-  private native Class defineClass0 (String name,\n-\t\t\t\t     byte[] data,\n-\t\t\t\t     int off,\n-\t\t\t\t     int len,\n-\t\t\t\t     ProtectionDomain protectionDomain)\n-    throws ClassFormatError;\n-\n-  /** \n-   * Link the given class.  This will bring the class to a state where\n-   * the class initializer can be run.  Linking involves the following\n-   * steps: \n-   * <UL>\n-   * <LI>  Prepare (allocate and internalize) the constant strings that\n-   *       are used in this class.\n-   * <LI>  Allocate storage for static fields, and define the layout\n-   *       of instance fields.\n-   * <LI>  Perform static initialization of ``static final'' int,\n-   *       long, float, double and String fields for which there is a\n-   *       compile-time constant initializer.\n-   * <LI>  Create the internal representation of the ``vtable''.\n-   * </UL>\n-   * For <code>gcj</code>-compiled classes, only the first step is\n-   * performed.  The compiler will have done the rest already.\n-   * <P>\n-   * This is called by the system automatically,\n-   * as part of class initialization; there is no reason to ever call\n-   * this method directly.  \n-   * <P> \n-   * For historical reasons, this method has a name which is easily\n-   * misunderstood.  Java classes are never ``resolved''.  Classes are\n-   * linked; whereas method and field references are resolved.\n-   *\n-   * @param     clazz the class to link.\n-   * @exception java.lang.LinkageError\n-   */\n-  protected final void resolveClass(Class clazz)\n-  {\n-    resolveClass0(clazz);\n-  }\n-\n-  static void resolveClass0(Class clazz)\n-  {\n-    synchronized (clazz)\n-      {\n-\ttry\n-\t  {\n-\t    linkClass0 (clazz);\n-\t  }\n-\tcatch (Throwable x)\n-\t  {\n-\t    markClassErrorState0 (clazz);\n-\n-\t    LinkageError e;\n-\t    if (x instanceof LinkageError)\n-\t      e = (LinkageError)x;\n-\t    else if (x instanceof ClassNotFoundException)\n-\t      {\n-\t\te = new NoClassDefFoundError(\"while resolving class: \"\n-\t\t\t\t\t     + clazz.getName());\n-\t\te.initCause (x);\n-\t      }\n-\t    else\n-\t      {\n-\t\te = new LinkageError (\"unexpected exception during linking: \"\n-\t\t\t\t      + clazz.getName());\n-\t\te.initCause (x);\n-\t      }\n-\t    throw e;\n-\t  }\n-      }\n+  /**\n+   * Links the class, if that has not already been done. Linking basically\n+   * resolves all references to other classes made by this class.\n+   *\n+   * @param c the class to resolve\n+   * @throws NullPointerException if c is null\n+   * @throws LinkageError if linking fails\n+   */\n+  protected final void resolveClass(Class c)\n+  {\n+    VMClassLoader.resolveClass(c);\n   }\n \n-  /** Internal method.  Calls _Jv_PrepareClass and\n-   * _Jv_PrepareCompiledClass.  This is only called from resolveClass.  */ \n-  private static native void linkClass0(Class clazz);\n-\n-  /** Internal method.  Marks the given clazz to be in an erroneous\n-   * state, and calls notifyAll() on the class object.  This should only\n-   * be called when the caller has the lock on the class object.  */\n-  private static native void markClassErrorState0(Class clazz);\n-\n   /**\n-   * Defines a new package and creates a Package object.\n-   * The package should be defined before any class in the package is\n-   * defined with <code>defineClass()</code>. The package should not yet\n-   * be defined before in this classloader or in one of its parents (which\n-   * means that <code>getPackage()</code> should return <code>null</code>).\n-   * All parameters except the <code>name</code> of the package may be\n-   * <code>null</code>.\n-   * <p>\n-   * Subclasses should call this method from their <code>findClass()</code>\n-   * implementation before calling <code>defineClass()</code> on a Class\n-   * in a not yet defined Package (which can be checked by calling\n-   * <code>getPackage()</code>).\n-   *\n-   * @param name The name of the Package\n-   * @param specTitle The name of the specification\n-   * @param specVendor The name of the specification designer\n-   * @param specVersion The version of this specification\n-   * @param implTitle The name of the implementation\n-   * @param implVendor The vendor that wrote this implementation\n-   * @param implVersion The version of this implementation\n-   * @param sealed If sealed the origin of the package classes\n-   * @return the Package object for the specified package\n+   * Helper to find a Class using the system classloader, possibly loading it.\n+   * A subclass usually does not need to call this, if it correctly\n+   * overrides <code>findClass(String)</code>.\n    *\n-   * @exception IllegalArgumentException if the package name is null or if\n-   * it was already defined by this classloader or one of its parents.\n-   *\n-   * @see Package\n-   * @since 1.2\n+   * @param name the name of the class to find\n+   * @return the found class\n+   * @throws ClassNotFoundException if the class cannot be found\n    */\n-  protected Package definePackage(String name,\n-\t\t\t\t  String specTitle, String specVendor,\n-\t\t\t\t  String specVersion, String implTitle,\n-\t\t\t\t  String implVendor, String implVersion,\n-\t\t\t\t  URL sealed)\n+  protected final Class findSystemClass(String name)\n+    throws ClassNotFoundException\n   {\n-    if (getPackage(name) != null)\n-      throw new IllegalArgumentException(\"Package \" + name\n-\t\t\t\t\t + \" already defined\");\n-    Package p = new Package(name,\n-\t\t\t    specTitle, specVendor, specVersion,\n-\t\t\t    implTitle, implVendor, implVersion,\n-\t\t\t    sealed);\n-    synchronized (definedPackages)\n-    {\n-      definedPackages.put(name, p);\n-    }\n-    return p;\n+    return Class.forName(name, false, systemClassLoader);\n   }\n \n   /**\n-   * Returns the Package object for the requested package name. It returns\n-   * null when the package is not defined by this classloader or one of its\n-   * parents.\n+   * Returns the parent of this classloader. If the parent of this\n+   * classloader is the bootstrap classloader then this method returns\n+   * <code>null</code>. A security check may be performed on\n+   * <code>RuntimePermission(\"getClassLoader\")</code>.\n    *\n-   * @param name the package name to find\n-   * @return the package, if defined\n+   * @throws SecurityException if the security check fails\n    * @since 1.2\n    */\n-  protected Package getPackage(String name)\n+  public final ClassLoader getParent()\n   {\n-    Package p;\n-    if (parent == null)\n-      // XXX - Should we use the bootstrap classloader?\n-      p = null;\n-    else\n-      p = parent.getPackage(name);\n-\n-    if (p == null)\n+    // Check if we may return the parent classloader.\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n       {\n-        synchronized (definedPackages)\n-\t{\n-\t  p = (Package) definedPackages.get(name);\n-\t}\n+        Class c = VMSecurityManager.getClassContext()[1];\n+        ClassLoader cl = c.getClassLoader();\n+\tif (cl != null && ! cl.isAncestorOf(this))\n+          sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n       }\n-\n-    return p;\n+    return parent;\n   }\n \n   /**\n-   * Returns all Package objects defined by this classloader and its parents.\n+   * Helper to set the signers of a class. This should be called after\n+   * defining the class.\n    *\n-   * @return an array of all defined packages\n-   * @since 1.2\n+   * @param c the Class to set signers of\n+   * @param signers the signers to set\n+   * @since 1.1\n    */\n-  protected Package[] getPackages()\n+  protected final void setSigners(Class c, Object[] signers)\n   {\n-    Package[] allPackages;\n-\n-    // Get all our packages.\n-    Package[] packages;\n-    synchronized(definedPackages)\n-    {\n-      packages = new Package[definedPackages.size()];\n-      definedPackages.values().toArray(packages);\n-    }\n-\n-    // If we have a parent get all packages defined by our parents.\n-    if (parent != null)\n-      {\n-\tPackage[] parentPackages = parent.getPackages();\n-\tallPackages = new Package[parentPackages.length + packages.length];\n-\tSystem.arraycopy(parentPackages, 0, allPackages, 0,\n-\t\t\t parentPackages.length);\n-\tSystem.arraycopy(packages, 0, allPackages, parentPackages.length,\n-\t\t\t packages.length);\n-      }\n-    else\n-      // XXX - Should we use the bootstrap classloader?\n-      allPackages = packages;\n-\n-    return allPackages;\n+    //    c.setSigners(signers);\n   }\n \n   /**\n-   * Called by <code>Runtime.loadLibrary()</code> to get an absolute path\n-   * to a (system specific) library that was requested by a class loaded\n-   * by this classloader. The default implementation returns\n-   * <code>null</code>. It should be implemented by subclasses when they\n-   * have a way to find the absolute path to a library. If this method\n-   * returns null the library is searched for in the default locations\n-   * (the directories listed in the <code>java.library.path</code> system\n-   * property).\n+   * Helper to find an already-loaded class in this ClassLoader.\n    *\n-   * @param name the (system specific) name of the requested library\n-   * @return the full pathname to the requested library, or null\n-   * @see Runtime#loadLibrary()\n-   * @since 1.2\n+   * @param name the name of the class to find\n+   * @return the found Class, or null if it is not found\n+   * @since 1.1\n    */\n-  protected String findLibrary(String name)\n+  protected final synchronized Class findLoadedClass(String name)\n   {\n-    return null;\n+    // NOTE: If the VM is keeping its own cache, it may make sense to have\n+    // this method be native.\n+    return (Class) loadedClasses.get(name);\n   }\n \n-  /** \n-   * Returns a class found in a system-specific way, typically\n-   * via the <code>java.class.path</code> system property.  Loads the \n-   * class if necessary.\n+  /**\n+   * Get the URL to a resource using this classloader or one of its parents.\n+   * First tries to get the resource by calling <code>getResource()</code>\n+   * on the parent classloader. If the parent classloader returns null then\n+   * it tries finding the resource by calling <code>findResource()</code> on\n+   * this classloader. The resource name should be separated by '/' for path\n+   * elements.\n+   *\n+   * <p>Subclasses should not override this method but should override\n+   * <code>findResource()</code> which is called by this method.\n    *\n-   * @param     name the class to resolve.\n-   * @return    the class loaded.\n-   * @exception java.lang.LinkageError \n-   * @exception java.lang.ClassNotFoundException \n+   * @param name the name of the resource relative to this classloader\n+   * @return the URL to the resource or null when not found\n    */\n-  protected final Class findSystemClass(String name) \n-    throws java.lang.ClassNotFoundException\n+  public URL getResource(String name)\n   {\n-    return gnu.gcj.runtime.VMClassLoader.instance.loadClass (name);\n+    URL result;\n+\n+    if (parent == null)\n+      result = VMClassLoader.getResource(name);\n+    else\n+      result = parent.getResource(name);\n+\n+    if (result == null)\n+      result = findResource(name);\n+    return result;\n   }\n \n   /**\n-   * Helper to set the signers of a class. This should be called after\n-   * defining the class.\n+   * Returns an Enumeration of all resources with a given name that can\n+   * be found by this classloader and its parents. Certain classloaders\n+   * (such as the URLClassLoader when given multiple jar files) can have\n+   * multiple resources with the same name that come from multiple locations.\n+   * It can also occur that a parent classloader offers a resource with a\n+   * certain name and the child classloader also offers a resource with that\n+   * same name. <code>getResource() only offers the first resource (of the\n+   * parent) with a given name. This method lists all resources with the\n+   * same name. The name should use '/' as path separators.\n    *\n-   * @param c the Class to set signers of\n-   * @param signers the signers to set\n-   * @since 1.1\n-   */   \n-  protected final void setSigners(Class c, Object[] signers)\n+   * <p>The Enumeration is created by first calling <code>getResources()</code>\n+   * on the parent classloader and then calling <code>findResources()</code>\n+   * on this classloader.\n+   *\n+   * @param name the resource name\n+   * @return an enumaration of all resources found\n+   * @throws IOException if I/O errors occur in the process\n+   * @since 1.2\n+   */\n+  public final Enumeration getResources(String name) throws IOException\n   {\n-    /*\n-     * Does currently nothing. FIXME.\n-     */ \n+    Enumeration parentResources;\n+    if (parent == null)\n+      parentResources = VMClassLoader.getResources(name);\n+    else\n+      parentResources = parent.getResources(name);\n+    return new DoubleEnumeration(parentResources, findResources(name));\n   }\n \n   /**\n-   * If a class named <code>name</code> was previously loaded using\n-   * this <code>ClassLoader</code>, then it is returned.  Otherwise\n-   * it returns <code>null</code>.\n-   * @param     name  class to find.\n-   * @return    the class loaded, or null.\n-   */ \n-  protected final synchronized Class findLoadedClass(String name)\n+   * Called whenever all locations of a named resource are needed.\n+   * It is called by <code>getResources()</code> after it has called\n+   * <code>parent.getResources()</code>. The results are combined by\n+   * the <code>getResources()</code> method.\n+   *\n+   * <p>The default implementation always returns an empty Enumeration.\n+   * Subclasses should override it when they can provide an Enumeration of\n+   * URLs (possibly just one element) to the named resource.\n+   * The first URL of the Enumeration should be the same as the one\n+   * returned by <code>findResource</code>.\n+   *\n+   * @param name the name of the resource to be found\n+   * @return a possibly empty Enumeration of URLs to the named resource\n+   * @throws IOException if I/O errors occur in the process\n+   * @since 1.2\n+   */\n+  protected Enumeration findResources(String name) throws IOException\n   {\n-    return (Class) loadedClasses.get(name);\n+    return EmptyEnumeration.getInstance();\n   }\n \n   /**\n-   * Get a resource using the system classloader.\n+   * Called whenever a resource is needed that could not be provided by\n+   * one of the parents of this classloader. It is called by\n+   * <code>getResource()</code> after <code>parent.getResource()</code>\n+   * couldn't provide the requested resource.\n    *\n-   * @param name the name of the resource relative to the system classloader\n-   * @return an input stream for the resource, or null\n-   * @since 1.1\n+   * <p>The default implementation always returns null. Subclasses should\n+   * override this method when they can provide a way to return a URL\n+   * to a named resource.\n+   *\n+   * @param name the name of the resource to be found\n+   * @return a URL to the named resource or null when not found\n+   * @since 1.2\n    */\n-  public static InputStream getSystemResourceAsStream(String name) {\n-    return getSystemClassLoader().getResourceAsStream (name);\n+  protected URL findResource(String name)\n+  {\n+    return null;\n   }\n \n   /**\n@@ -759,8 +625,9 @@ public static InputStream getSystemResourceAsStream(String name) {\n    * @return the URL to the resource\n    * @since 1.1\n    */\n-  public static URL getSystemResource(String name) {\n-    return getSystemClassLoader().getResource (name);\n+  public static final URL getSystemResource(String name)\n+  {\n+    return systemClassLoader.getResource(name);\n   }\n \n   /**\n@@ -776,149 +643,221 @@ public static URL getSystemResource(String name) {\n    */\n   public static Enumeration getSystemResources(String name) throws IOException\n   {\n-    return getSystemClassLoader().getResources(name);\n+    return systemClassLoader.getResources(name);\n   }\n \n   /**\n-   *   Return an InputStream representing the resource name.  \n-   *   This is essentially like \n-   *   <code>getResource(name).openStream()</code>, except\n-   *   it masks out any IOException and returns null on failure.\n-   * @param   name  resource to load\n-   * @return  an InputStream, or null\n-   * @see     java.lang.ClassLoader#getResource(String)\n-   * @see     java.io.InputStream\n+   * Get a resource as stream using this classloader or one of its parents.\n+   * First calls <code>getResource()</code> and if that returns a URL to\n+   * the resource then it calls and returns the InputStream given by\n+   * <code>URL.openStream()</code>.\n+   *\n+   * <p>Subclasses should not override this method but should override\n+   * <code>findResource()</code> which is called by this method.\n+   *\n+   * @param name the name of the resource relative to this classloader\n+   * @return an InputStream to the resource, or null\n+   * @since 1.1\n    */\n-  public InputStream getResourceAsStream(String name) \n+  public InputStream getResourceAsStream(String name)\n   {\n     try\n       {\n-\tURL res = getResource (name);\n-\tif (res == null)\n+        URL url = getResource(name);\n+        if (url == null)\n           return null;\n-\treturn res.openStream ();\n+        return url.openStream();\n       }\n-    catch (java.io.IOException x)\n+    catch (IOException e)\n       {\n-\treturn null;\n+        return null;\n       }\n   }\n- \n+\n   /**\n-   * Return an java.io.URL representing the resouce <code>name</code>.  \n-   * The default implementation just returns <code>null</code>.\n-   * @param   name  resource to load\n-   * @return  a URL, or null if there is no such resource.\n-   * @see     java.lang.ClassLoader#getResourceAsBytes(String)\n-   * @see     java.lang.ClassLoader#getResourceAsStream(String)\n-   * @see     java.io.URL\n+   * Get a resource using the system classloader.\n+   *\n+   * @param name the name of the resource relative to the system classloader\n+   * @return an input stream for the resource, or null\n+   * @since 1.1\n    */\n-  public URL getResource (String name) \n+  public static final InputStream getSystemResourceAsStream(String name)\n   {\n-    // The rules say search the parent class if non-null,\n-    // otherwise search the built-in class loader (assumed to be\n-    // the system ClassLoader).  If not found, call\n-    // findResource().\n-    URL result = null;\n-\n-    ClassLoader delegate = parent;\n+    try\n+      {\n+        URL url = getSystemResource(name);\n+        if (url == null)\n+          return null;\n+        return url.openStream();\n+      }\n+    catch (IOException e)\n+      {\n+        return null;\n+      }\n+  }\n \n-    if (delegate == null)\n-      delegate = getSystemClassLoader ();\n-\t\n-    // Protect ourselves from looping.\n-    if (this != delegate)\n-      result = delegate.getResource (name);\n+  /**\n+   * Returns the system classloader. The system classloader (also called\n+   * the application classloader) is the classloader that was used to\n+   * load the application classes on the classpath (given by the system\n+   * property <code>java.class.path</code>. This is set as the context\n+   * class loader for a thread. The system property\n+   * <code>java.system.class.loader</code>, if defined, is taken to be the\n+   * name of the class to use as the system class loader, which must have\n+   * a public constructor which takes a ClassLoader as a parent; otherwise this\n+   * uses gnu.java.lang.SystemClassLoader.\n+   *\n+   * <p>Note that this is different from the bootstrap classloader that\n+   * actually loads all the real \"system\" classes (the bootstrap classloader\n+   * is the parent of the returned system classloader).\n+   *\n+   * <p>A security check will be performed for\n+   * <code>RuntimePermission(\"getClassLoader\")</code> if the calling class\n+   * is not a parent of the system class loader.\n+   *\n+   * @return the system class loader\n+   * @throws SecurityException if the security check fails\n+   * @throws IllegalStateException if this is called recursively\n+   * @throws Error if <code>java.system.class.loader</code> fails to load\n+   * @since 1.2\n+   */\n+  public static ClassLoader getSystemClassLoader()\n+  {\n+    // Check if we may return the system classloader\n+    SecurityManager sm = System.getSecurityManager();\n+    if (sm != null)\n+      {\n+\tClass c = VMSecurityManager.getClassContext()[1];\n+\tClassLoader cl = c.getClassLoader();\n+\tif (cl != null && cl != systemClassLoader)\n+\t  sm.checkPermission(new RuntimePermission(\"getClassLoader\"));\n+      }\n \n-    if (result != null)\n-      return result;\n-    else\n-      return findResource (name);\n+    return systemClassLoader;\n   }\n \n   /**\n-   * Called whenever a resource is needed that could not be provided by\n-   * one of the parents of this classloader. It is called by\n-   * <code>getResource()</code> after <code>parent.getResource()</code>\n-   * couldn't provide the requested resource.\n+   * Defines a new package and creates a Package object. The package should\n+   * be defined before any class in the package is defined with\n+   * <code>defineClass()</code>. The package should not yet be defined\n+   * before in this classloader or in one of its parents (which means that\n+   * <code>getPackage()</code> should return <code>null</code>). All\n+   * parameters except the <code>name</code> of the package may be\n+   * <code>null</code>.\n    *\n-   * <p>The default implementation always returns null. Subclasses should\n-   * override this method when they can provide a way to return a URL\n-   * to a named resource.\n+   * <p>Subclasses should call this method from their <code>findClass()</code>\n+   * implementation before calling <code>defineClass()</code> on a Class\n+   * in a not yet defined Package (which can be checked by calling\n+   * <code>getPackage()</code>).\n    *\n-   * @param name the name of the resource to be found\n-   * @return a URL to the named resource or null when not found\n+   * @param name the name of the Package\n+   * @param specTitle the name of the specification\n+   * @param specVendor the name of the specification designer\n+   * @param specVersion the version of this specification\n+   * @param implTitle the name of the implementation\n+   * @param implVendor the vendor that wrote this implementation\n+   * @param implVersion the version of this implementation\n+   * @param sealed if sealed the origin of the package classes\n+   * @return the Package object for the specified package\n+   * @throws IllegalArgumentException if the package name is null or it\n+   *         was already defined by this classloader or one of its parents\n+   * @see Package\n    * @since 1.2\n    */\n-  protected URL findResource (String name)\n+  protected Package definePackage(String name, String specTitle,\n+                                  String specVendor, String specVersion,\n+                                  String implTitle, String implVendor,\n+                                  String implVersion, URL sealed)\n   {\n-    // Default to returning null.  Derived classes implement this.\n-    return null;\n+    if (getPackage(name) != null)\n+      throw new IllegalArgumentException(\"Package \" + name\n+                                         + \" already defined\");\n+    Package p = new Package(name, specTitle, specVendor, specVersion,\n+                            implTitle, implVendor, implVersion, sealed);\n+    synchronized (definedPackages)\n+      {\n+        definedPackages.put(name, p);\n+      }\n+    return p;\n   }\n \n   /**\n-   * Returns an Enumeration of all resources with a given name that can\n-   * be found by this classloader and its parents. Certain classloaders\n-   * (such as the URLClassLoader when given multiple jar files) can have\n-   * multiple resources with the same name that come from multiple locations.\n-   * It can also occur that a parent classloader offers a resource with a\n-   * certain name and the child classloader also offers a resource with that\n-   * same name. <code>getResource() only offers the first resource (of the\n-   * parent) with a given name. This method lists all resources with the\n-   * same name. The name should use '/' as path separators.\n-   *\n-   * <p>The Enumeration is created by first calling <code>getResources()</code>\n-   * on the parent classloader and then calling <code>findResources()</code>\n-   * on this classloader.\n+   * Returns the Package object for the requested package name. It returns\n+   * null when the package is not defined by this classloader or one of its\n+   * parents.\n    *\n-   * @param name the resource name\n-   * @return an enumaration of all resources found\n-   * @throws IOException if I/O errors occur in the process\n+   * @param name the package name to find\n+   * @return the package, if defined\n    * @since 1.2\n    */\n-  public final Enumeration getResources(String name) throws IOException\n+  protected Package getPackage(String name)\n   {\n-    // The rules say search the parent class if non-null,\n-    // otherwise search the built-in class loader (assumed to be\n-    // the system ClassLoader).  If not found, call\n-    // findResource().\n-    Enumeration result = null;\n+    Package p;\n+    if (parent == null)\n+      p = VMClassLoader.getPackage(name);\n+    else\n+      p = parent.getPackage(name);\n \n-    ClassLoader delegate = parent;\n+    if (p == null)\n+      {\n+\tsynchronized (definedPackages)\n+\t  {\n+\t    p = (Package) definedPackages.get(name);\n+\t  }\n+      }\n+    return p;\n+  }\n \n-    if (delegate == null)\n-      delegate = getSystemClassLoader ();\n-\t\n-    // Protect ourselves from looping.\n-    if (this != delegate)\n-      result = delegate.getResources (name);\n+  /**\n+   * Returns all Package objects defined by this classloader and its parents.\n+   *\n+   * @return an array of all defined packages\n+   * @since 1.2\n+   */\n+  protected Package[] getPackages()\n+  {\n+    // Get all our packages.\n+    Package[] packages;\n+    synchronized(definedPackages)\n+      {\n+        packages = new Package[definedPackages.size()];\n+        definedPackages.values().toArray(packages);\n+      }\n \n-    if (result != null)\n-      return result;\n+    // If we have a parent get all packages defined by our parents.\n+    Package[] parentPackages;\n+    if (parent == null)\n+      parentPackages = VMClassLoader.getPackages();\n     else\n-      return findResources (name);\n+      parentPackages = parent.getPackages();\n+\n+    Package[] allPackages = new Package[parentPackages.length\n+\t\t\t\t\t+ packages.length];\n+    System.arraycopy(parentPackages, 0, allPackages, 0,\n+                     parentPackages.length);\n+    System.arraycopy(packages, 0, allPackages, parentPackages.length,\n+                     packages.length);\n+    return allPackages;\n   }\n \n   /**\n-   * Called whenever all locations of a named resource are needed.\n-   * It is called by <code>getResources()</code> after it has called\n-   * <code>parent.getResources()</code>. The results are combined by\n-   * the <code>getResources()</code> method.\n-   *\n-   * <p>The default implementation always returns an empty Enumeration.\n-   * Subclasses should override it when they can provide an Enumeration of\n-   * URLs (possibly just one element) to the named resource.\n-   * The first URL of the Enumeration should be the same as the one\n-   * returned by <code>findResource</code>.\n+   * Called by <code>Runtime.loadLibrary()</code> to get an absolute path\n+   * to a (system specific) library that was requested by a class loaded\n+   * by this classloader. The default implementation returns\n+   * <code>null</code>. It should be implemented by subclasses when they\n+   * have a way to find the absolute path to a library. If this method\n+   * returns null the library is searched for in the default locations\n+   * (the directories listed in the <code>java.library.path</code> system\n+   * property).\n    *\n-   * @param name the name of the resource to be found\n-   * @return a possibly empty Enumeration of URLs to the named resource\n-   * @throws IOException if I/O errors occur in the process\n+   * @param name the (system specific) name of the requested library\n+   * @return the full pathname to the requested library, or null\n+   * @see Runtime#loadLibrary()\n    * @since 1.2\n    */\n-  protected Enumeration findResources(String name) throws IOException\n+  protected String findLibrary(String name)\n   {\n-    return Collections.enumeration(Collections.EMPTY_LIST);\n+    return null;\n   }\n \n   /**\n@@ -935,7 +874,7 @@ public void setDefaultAssertionStatus(boolean enabled)\n   {\n     defaultAssertionStatus = enabled;\n   }\n-\n+  \n   /**\n    * Set the default assertion status for packages, used unless overridden\n    * by a class request. This default also covers subpackages, unless they"}, {"sha": "b46b545aeedfae5fcc7eff7b0df0e64291034e03", "filename": "libjava/java/lang/VMClassLoader.java", "status": "modified", "additions": 253, "deletions": 52, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1,66 +1,237 @@\n-/*\n- * java.lang.ClassLoader: part of the Java Class Libraries project.\n- * Copyright (C) 1998, 2001, 2002 Free Software Foundation\n- *\n- * This library is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n- * Boston, MA  02111-1307, USA.\n- */\n+/* VMClassLoader.java -- Reference implementation of native interface\n+   required by ClassLoader\n+   Copyright (C) 1998, 2001, 2002, 2003 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n package java.lang;\n \n-import java.util.*;\n+import java.security.ProtectionDomain;\n+import java.net.URL;\n+import java.io.IOException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.reflect.Constructor;\n+import java.security.AllPermission;\n+import java.security.Permission;\n+import java.security.Permissions;\n+import java.security.ProtectionDomain;\n+\n+import gnu.java.util.EmptyEnumeration;\n \n /**\n  * java.lang.VMClassLoader is a package-private helper for VMs to implement\n  * on behalf of java.lang.ClassLoader.\n  *\n  * @author John Keiser\n- * @version 1.1.0, Sep 22 1998\n- * @since CP1.1\n+ * @author Mark Wielaard <mark@klomp.org>\n+ * @author Eric Blake <ebb9@email.byu.edu>\n  */\n+final class VMClassLoader\n+{\n+  // Protection Domain definitions \n+  // FIXME: should there be a special protection domain used for native code?\n+  \n+  // The permission required to check what a classes protection domain is.\n+  static final Permission protectionDomainPermission\n+    = new RuntimePermission(\"getProtectionDomain\");\n+  // The protection domain returned if we cannot determine it. \n+  static ProtectionDomain unknownProtectionDomain;\n+\n+  static\n+  {\n+    Permissions permissions = new Permissions();\n+    permissions.add(new AllPermission());\n+    unknownProtectionDomain = new ProtectionDomain(null, permissions);  \n+  }\n+\n+  /**\n+   * Helper to define a class using a string of bytes. This assumes that\n+   * the security checks have already been performed, if necessary.\n+   *\n+   * <strong>For backward compatibility, this just ignores the protection\n+   * domain; that is the wrong behavior, and you should directly implement\n+   * this method natively if you can.</strong>\n+   *\n+   * @param name the name to give the class, or null if unknown\n+   * @param data the data representing the classfile, in classfile format\n+   * @param offset the offset into the data where the classfile starts\n+   * @param len the length of the classfile data in the array\n+   * @param pd the protection domain\n+   * @return the class that was defined\n+   * @throws ClassFormatError if data is not in proper classfile format\n+   */\n+  static final native Class defineClass(ClassLoader cl, String name,\n+\t\t\t\t\tbyte[] data, int offset, int len,\n+\t\t\t\t\tProtectionDomain pd)\n+    throws ClassFormatError;\n+\n+  static final native void linkClass0 (Class klass);\n+  static final native void markClassErrorState0 (Class klass);\n+\n+  /**\n+   * Helper to resolve all references to other classes from this class.\n+   *\n+   * @param c the class to resolve\n+   */\n+  static final void resolveClass(Class clazz)\n+  {\n+    synchronized (clazz)\n+      {\n+\ttry\n+\t  {\n+\t    linkClass0 (clazz);\n+\t  }\n+\tcatch (Throwable x)\n+\t  {\n+\t    markClassErrorState0 (clazz);\n+\n+\t    LinkageError e;\n+\t    if (x instanceof LinkageError)\n+\t      e = (LinkageError) x;\n+\t    else if (x instanceof ClassNotFoundException)\n+\t      {\n+\t\te = new NoClassDefFoundError(\"while resolving class: \"\n+\t\t\t\t\t     + clazz.getName());\n+\t\te.initCause (x);\n+\t      }\n+\t    else\n+\t      {\n+\t\te = new LinkageError (\"unexpected exception during linking: \"\n+\t\t\t\t      + clazz.getName());\n+\t\te.initCause (x);\n+\t      }\n+\t    throw e;\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Helper to load a class from the bootstrap class loader.\n+   *\n+   * In libgcj, this does nothing, as the default system loader knows\n+   * how to find classes that have been linked in.\n+   *\n+   * @param name the class name to load\n+   * @param resolve whether to resolve it\n+   * @return the class, loaded by the bootstrap classloader or null\n+   * if the class wasn't found. Returning null is equivalent to throwing\n+   * a ClassNotFoundException (but a possible performance optimization).\n+   */\n+  static final Class loadClass(String name, boolean resolve)\n+    throws ClassNotFoundException\n+  {\n+    return null;\n+  }\n \n-class VMClassLoader {\n-\n-    /** \n-     * Helper to define a class using a string of bytes.\n-     * \n-     * @param name the name to give the class.  null if unknown.\n-     * @param data the data representing the classfile, in classfile format.\n-     * @param offset the offset into the data where the classfile starts.\n-     * @param len the length of the classfile data in the array.\n-     * @return the class that was defined.\n-     * @exception ClassFormatError if the byte array is not in proper classfile format.\n-     */\n-    final static native Class defineClass(ClassLoader cl, String name, \n-\t\t\t\t\t  byte[] data, int offset, int len) \n-\tthrows ClassFormatError;\n-\n-    /** \n-     * Helper to resolve all references to other classes from this class.\n-     * @param c the class to resolve.\n-     */\n-  // Not yet needed for libgcj.\n-  //    final static native void resolveClass(Class c);\n-\n-    /** \n-     * Helper for java.lang.Integer, Byte, etc. to get the TYPE class\n-     * at initialization time. \n-     *\n-     * @param type code for the primitive type.\n-     */\n-  static native Class getPrimitiveClass(char type);\n+  /**\n+   * Helper to load a resource from the bootstrap class loader.\n+   *\n+   * In libgcj, this does nothing, as the default system loader knows\n+   * how to find resources that have been linked in.\n+   *\n+   * @param name the resource to find\n+   * @return the URL to the resource\n+   */\n+  static URL getResource(String name)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Helper to get a list of resources from the bootstrap class loader.\n+   *\n+   * In libgcj, this does nothing, as the default system loader knows\n+   * how to find resources that have been linked in.\n+   *\n+   * @param name the resource to find\n+   * @return an enumeration of resources\n+   * @throws IOException if one occurs\n+   */\n+  static Enumeration getResources(String name) throws IOException\n+  {\n+    return EmptyEnumeration.getInstance();\n+  }\n+\n+  /**\n+   * Helper to get a package from the bootstrap class loader.  The default\n+   * implementation of returning null may be adequate, or you may decide\n+   * that this needs some native help.\n+   *\n+   * @param name the name to find\n+   * @return the named package, if it exists\n+   */\n+  static Package getPackage(String name)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Helper to get all packages from the bootstrap class loader.  The default\n+   * implementation of returning an empty array may be adequate, or you may\n+   * decide that this needs some native help.\n+   *\n+   * @return all named packages, if any exist\n+   */\n+  static Package[] getPackages()\n+  {\n+    return new Package[0];\n+  }\n+\n+  /**\n+   * Helper for java.lang.Integer, Byte, etc to get the TYPE class\n+   * at initialization time. The type code is one of the chars that\n+   * represents the primitive type as in JNI.\n+   *\n+   * <ul>\n+   * <li>'Z' - boolean</li>\n+   * <li>'B' - byte</li>\n+   * <li>'C' - char</li>\n+   * <li>'D' - double</li>\n+   * <li>'F' - float</li>\n+   * <li>'I' - int</li>\n+   * <li>'J' - long</li>\n+   * <li>'S' - short</li>\n+   * <li>'V' - void</li>\n+   * </ul>\n+   *\n+   * @param type the primitive type\n+   * @return a \"bogus\" class representing the primitive type\n+   */\n+  static final native Class getPrimitiveClass(char type);\n \n   /**\n    * The system default for assertion status. This is used for all system\n@@ -104,4 +275,34 @@ static final Map classAssertionStatus()\n   {\n     return new HashMap();\n   }\n+\n+  static native ClassLoader getSystemClassLoaderInternal();\n+\n+  static ClassLoader getSystemClassLoader()\n+  {\n+    // This method is called as the initialization of systemClassLoader,\n+    // so if there is a null value, this is the first call and we must check\n+    // for java.system.class.loader.\n+    String loader = System.getProperty(\"java.system.class.loader\");\n+    ClassLoader default_sys = getSystemClassLoaderInternal();\n+    if (loader != null)\n+      {\n+\ttry\n+\t  {\n+\t    Class load_class = Class.forName(loader, true, default_sys);\n+\t    Constructor c\n+\t      = load_class.getConstructor(new Class[] { ClassLoader.class });\n+\t    default_sys\n+\t      = (ClassLoader) c.newInstance(new Object[] { default_sys });\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    System.err.println(\"Requested system classloader \"\n+\t\t\t       + loader + \" failed, using \"\n+\t\t\t       + \"gnu.gcj.runtime.VMClassLoader\");\n+\t    e.printStackTrace();\n+\t  }\n+      }\n+    return default_sys;\n+  }\n }"}, {"sha": "551a5312fe56f59ea15285fad4f546159fc7c29a", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -48,6 +48,7 @@ details.  */\n #include <java/lang/System.h>\n #include <java/lang/SecurityManager.h>\n #include <java/lang/StringBuffer.h>\n+#include <java/lang/VMClassLoader.h>\n #include <gnu/gcj/runtime/StackTrace.h>\n #include <gcj/method.h>\n #include <gnu/gcj/runtime/MethodRef.h>\n@@ -758,7 +759,7 @@ java::lang::Class::initializeClass (void)\n \t{\n \t  // this can throw exceptions, so exit the monitor as a precaution.\n \t  _Jv_MonitorExit (this);\n-\t  java::lang::ClassLoader::resolveClass0 (this);\n+\t  java::lang::VMClassLoader::resolveClass (this);\n \t  _Jv_MonitorEnter (this);\n \t}\n       else"}, {"sha": "bfd1f095d9e0eddffe7cbbe81f340d8a24e646c3", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1,6 +1,6 @@\n // natClassLoader.cc - Implementation of java.lang.ClassLoader native methods.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -44,11 +44,12 @@ details.  */\n /////////// java.lang.ClassLoader native methods ////////////\n \n java::lang::Class *\n-java::lang::ClassLoader::defineClass0 (jstring name,\n-\t\t\t\t       jbyteArray data, \n-\t\t\t\t       jint offset,\n-\t\t\t\t       jint length,\n-\t\t\t\t       java::security::ProtectionDomain *pd)\n+java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *loader,\n+\t\t\t\t\tjstring name,\n+\t\t\t\t\tjbyteArray data, \n+\t\t\t\t\tjint offset,\n+\t\t\t\t\tjint length,\n+\t\t\t\t\tjava::security::ProtectionDomain *pd)\n {\n #ifdef INTERPRETER\n   jclass klass;\n@@ -62,8 +63,8 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n \n   // Record the defining loader.  For the system class loader, we\n   // record NULL.\n-  if (this != java::lang::ClassLoader::getSystemClassLoader())\n-    klass->loader = this;\n+  if (loader != java::lang::ClassLoader::getSystemClassLoader())\n+    klass->loader = loader;\n \n   if (name != 0)\n     {\n@@ -105,6 +106,36 @@ java::lang::ClassLoader::defineClass0 (jstring name,\n #endif\n }\n \n+// Finish linking a class.  Only called from ClassLoader::resolveClass.\n+void\n+java::lang::VMClassLoader::linkClass0 (java::lang::Class *klass)\n+{\n+  _Jv_WaitForState (klass, JV_STATE_LINKED);\n+}\n+\n+void\n+java::lang::VMClassLoader::markClassErrorState0 (java::lang::Class *klass)\n+{\n+  klass->state = JV_STATE_ERROR;\n+  klass->notifyAll ();\n+}\n+\n+java::lang::ClassLoader *\n+java::lang::VMClassLoader::getSystemClassLoaderInternal()\n+{\n+  _Jv_InitClass (&gnu::gcj::runtime::VMClassLoader::class$);\n+  return gnu::gcj::runtime::VMClassLoader::instance;\n+}\n+\n+jclass\n+java::lang::VMClassLoader::getPrimitiveClass (jchar type)\n+{\n+  char sig[2];\n+  sig[0] = (char) type;\n+  sig[1] = '\\0';\n+  return _Jv_FindClassFromSignature (sig, NULL);\n+}\n+\n void\n _Jv_WaitForState (jclass klass, int state)\n {\n@@ -141,39 +172,6 @@ _Jv_WaitForState (jclass klass, int state)\n     throw new java::lang::LinkageError;\n }\n \n-// Finish linking a class.  Only called from ClassLoader::resolveClass.\n-void\n-java::lang::ClassLoader::linkClass0 (java::lang::Class *klass)\n-{\n-  _Jv_WaitForState (klass, JV_STATE_LINKED);\n-}\n-\n-void\n-java::lang::ClassLoader::markClassErrorState0 (java::lang::Class *klass)\n-{\n-  klass->state = JV_STATE_ERROR;\n-  klass->notifyAll ();\n-}\n-\n-jclass\n-java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *cl, \n-\t\t\t\t\tjstring name,\n-\t\t\t\t\tjbyteArray data, \n-\t\t\t\t\tjint offset,\n-\t\t\t\t\tjint length)\n-{\n-  return cl->defineClass (name, data, offset, length);\n-}\n-\n-jclass\n-java::lang::VMClassLoader::getPrimitiveClass (jchar type)\n-{\n-  char sig[2];\n-  sig[0] = (char) type;\n-  sig[1] = '\\0';\n-  return _Jv_FindClassFromSignature (sig, NULL);\n-}\n-\n typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n \n /** This function does class-preparation for compiled classes.  \n@@ -281,7 +279,7 @@ _Jv_PrepareCompiledClass (jclass klass)\n //  The set of initiating class loaders are used to ensure\n //  safety of linking, and is maintained in the hash table\n //  \"initiated_classes\".  A defining classloader is by definition also\n-//  initiating, so we only store classes in this table, if they have more\n+//  initiating, so we only store classes in this table if they have more\n //  than one class loader associated.\n //\n "}, {"sha": "9009bc8031b54f7aa9d3e7211b132c424e2f5599", "filename": "libjava/java/lang/reflect/Proxy.java", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2Freflect%2FProxy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fjava%2Flang%2Freflect%2FProxy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FProxy.java?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -1335,17 +1335,10 @@ final Class generate(ClassLoader loader)\n         {\n           // XXX Do we require more native support here?\n \n-          // XXX Security hole - it is possible for another thread to grab the\n-          // VMClassLoader.defineClass Method object, and abuse it while we\n-          // have temporarily made it accessible. Do we need to add some\n-          // synchronization lock to prevent user reflection while we use it?\n-\n-          // XXX This is waiting on VM support for protection domains.\n-\n           Class vmClassLoader = Class.forName(\"java.lang.VMClassLoader\");\n           Class[] types = {ClassLoader.class, String.class,\n                            byte[].class, int.class, int.class,\n-                           /* ProtectionDomain.class */ };\n+                           ProtectionDomain.class };\n           Method m = vmClassLoader.getDeclaredMethod(\"defineClass\", types);\n \n           // Bypass the security check of setAccessible(true), since this\n@@ -1354,7 +1347,7 @@ final Class generate(ClassLoader loader)\n           m.flag = true;\n           Object[] args = {loader, qualName, bytecode, new Integer(0),\n                            new Integer(bytecode.length),\n-                           /* Object.class.getProtectionDomain() */ };\n+                           Object.class.getProtectionDomain() };\n           Class clazz = (Class) m.invoke(null, args);\n           m.flag = false;\n "}, {"sha": "ce1af8d2586e22e089c33977c8bc68cdf5d10f70", "filename": "libjava/resolve.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9f42bb06092d78b84964ce1ce3af703bad2cc7d/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=b9f42bb06092d78b84964ce1ce3af703bad2cc7d", "patch": "@@ -32,6 +32,7 @@ details.  */\n #include <java/lang/AbstractMethodError.h>\n #include <java/lang/NoClassDefFoundError.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/VMClassLoader.h>\n #include <java/lang/reflect/Modifier.h>\n \n using namespace gcj;\n@@ -435,7 +436,7 @@ _Jv_PrepareClass(jclass klass)\n   // resolved.\n \n   if (klass->superclass)\n-    java::lang::ClassLoader::resolveClass0 (klass->superclass);\n+    java::lang::VMClassLoader::resolveClass (klass->superclass);\n \n   _Jv_InterpClass *clz = (_Jv_InterpClass*)klass;\n "}]}