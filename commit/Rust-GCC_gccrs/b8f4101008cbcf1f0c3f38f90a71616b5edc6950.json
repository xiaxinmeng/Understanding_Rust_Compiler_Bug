{"sha": "b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmNDEwMTAwOGNiY2YxZjBjM2YzOGY5MGE3MTYxNmI1ZWRjNjk1MA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-05-07T08:49:08Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-05-07T08:49:08Z"}, "message": "cpplex.c: Move new lexer definitions and prototypes to top.\n\n\t* cpplex.c: Move new lexer definitions and prototypes\n\tto top.  Conditional include these and the code if\n\tNEW_LEXER is defined.  Rename functions whose names\n\tclash if this code included.\n\nFrom-SVN: r33758", "tree": {"sha": "ca0d04d485ce913f7ec39dd28ae48f0fcf90cd5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca0d04d485ce913f7ec39dd28ae48f0fcf90cd5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8f4101008cbcf1f0c3f38f90a71616b5edc6950/comments", "author": null, "committer": null, "parents": [{"sha": "973362bc6cdaa138b1f598015b0f4402632cc4ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973362bc6cdaa138b1f598015b0f4402632cc4ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973362bc6cdaa138b1f598015b0f4402632cc4ee"}], "stats": {"total": 215, "additions": 113, "deletions": 102}, "files": [{"sha": "833b1ee4a3badddd28fb994b817844b5d7275f41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4101008cbcf1f0c3f38f90a71616b5edc6950/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4101008cbcf1f0c3f38f90a71616b5edc6950/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "patch": "@@ -1,3 +1,10 @@\n+Sun  7 May 08:43:53 2000  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpplex.c: Move new lexer definitions and prototypes\n+\tto top.  Conditional include these and the code if\n+\tNEW_LEXER is defined.  Rename functions whose names\n+\tclash if this code included.\n+\n Sun May  7 00:54:57 EDT 2000  John Wehle  (john@feith.com)\n \n \t* rtl.def (COND_EXEC): Clarify."}, {"sha": "3199f34c4605bf33f9fc35b94eee7a9455983197", "filename": "gcc/cpplex.c", "status": "modified", "additions": 106, "deletions": 102, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8f4101008cbcf1f0c3f38f90a71616b5edc6950/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8f4101008cbcf1f0c3f38f90a71616b5edc6950/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=b8f4101008cbcf1f0c3f38f90a71616b5edc6950", "patch": "@@ -62,6 +62,98 @@ static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n #define auto_expand_name_space(list) \\\n     expand_name_space ((list), (list)->name_cap / 2)\n \n+#ifdef NEW_LEXER\n+\n+static void expand_comment_space PARAMS ((cpp_toklist *));\n+void init_trigraph_map PARAMS ((void));\n+static unsigned char* trigraph_replace PARAMS ((cpp_reader *, unsigned char *,\n+\t\t\t\t\t\tunsigned char *));\n+static const unsigned char *backslash_start PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t     const unsigned char *));\n+static int skip_block_comment2 PARAMS ((cpp_reader *));\n+static int skip_line_comment2 PARAMS ((cpp_reader *));\n+static void skip_whitespace PARAMS ((cpp_reader *, int));\n+static void parse_name PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n+static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n+static void parse_string2 PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *,\n+\t\t\t\t  unsigned int));\n+static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n+static void save_comment PARAMS ((cpp_toklist *, const unsigned char *,\n+\t\t\t\t  unsigned int, unsigned int, unsigned int));\n+void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n+\n+static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n+\n+unsigned int spell_string PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t   cpp_token *token));\n+unsigned int spell_comment PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t    cpp_token *token));\n+unsigned int spell_name PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t cpp_token *token));\n+\n+typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t\t  cpp_token *));\n+\n+/* Macros on a cpp_name.  */\n+#define INIT_NAME(list, name) \\\n+  do {(name).len = 0; (name).offset = (list)->name_used;} while (0)\n+\n+#define IS_DIRECTIVE(list) (TOK_TYPE (list, 0) == CPP_HASH)\n+#define COLUMN(cur) ((cur) - buffer->line_base)\n+\n+/* Maybe put these in the ISTABLE eventually.  */\n+#define IS_HSPACE(c) ((c) == ' ' || (c) == '\\t')\n+#define IS_NEWLINE(c) ((c) == '\\n' || (c) == '\\r')\n+\n+/* Handle LF, CR, CR-LF and LF-CR style newlines.  Assumes next\n+   character, if any, is in buffer.  */\n+#define handle_newline(cur, limit, c) \\\n+  do {\\\n+  if ((cur) < (limit) && *(cur) == '\\r' + '\\n' - c) \\\n+    (cur)++; \\\n+  CPP_BUMP_LINE_CUR (pfile, (cur)); \\\n+  } while (0)\n+\n+#define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITESPACE))\n+#define PREV_TOKEN_TYPE (cur_token[-1].type)\n+\n+#define SPELL_TEXT     0\n+#define SPELL_HANDLER  1\n+#define SPELL_CHAR     2\n+#define SPELL_NONE     3\n+#define SPELL_EOL      4\n+\n+#define T(e, s) {SPELL_TEXT, s},\n+#define H(e, s) {SPELL_HANDLER, (PTR) s},\n+#define C(e, s) {SPELL_CHAR, s},\n+#define N(e, s) {SPELL_NONE, s},\n+#define E(e, s) {SPELL_EOL, s},\n+\n+static const struct token_spelling\n+{\n+  unsigned char type;\n+  PTR  speller;\n+} token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n+\n+#undef T\n+#undef H\n+#undef C\n+#undef N\n+#undef E\n+\n+#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n+#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n+#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n+#define BACKUP_DIGRAPH(ttype) do { \\\n+  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n+\n+/* If there is this many bytes in a buffer, you have enough room to\n+   spell the token, not including preceding whitespace.  */\n+#define TOKEN_LEN(token) (4 + (token_spellings[token->type].type == \\\n+\t\t\t       SPELL_HANDLER ? token->val.name.len: 0))\n+\n+#endif\n+\n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n void\n@@ -2070,7 +2162,7 @@ cpp_idcmp (token, len, string)\n     return 1;\n }\n \n-#if 0\n+#ifdef NEW_LEXER\n \n /* Lexing algorithm.\n \n@@ -2163,85 +2255,9 @@ cpp_idcmp (token, len, string)\n \n */\n \n-static void expand_comment_space PARAMS ((cpp_toklist *));\n-void init_trigraph_map PARAMS ((void));\n-static unsigned char* trigraph_replace PARAMS ((cpp_reader *, unsigned char *,\n-\t\t\t\t\t\tunsigned char *));\n-static const unsigned char *backslash_start PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t     const unsigned char *));\n-static int skip_block_comment PARAMS ((cpp_reader *));\n-static int skip_line_comment PARAMS ((cpp_reader *));\n-static void skip_whitespace PARAMS ((cpp_reader *, int));\n-static void parse_name PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n-static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n-static void parse_string PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *,\n-\t\t\t\t  unsigned int));\n-static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n-static void copy_comment PARAMS ((cpp_toklist *, const unsigned char *,\n-\t\t\t\t  unsigned int, unsigned int, unsigned int));\n-void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n-\n-static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n-\n-unsigned int spell_string PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t   cpp_token *token));\n-unsigned int spell_comment PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t    cpp_token *token));\n-unsigned int spell_name PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t cpp_token *token));\n-\n-typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n-\t\t\t\t\t  cpp_token *));\n-\n-/* Macros on a cpp_name.  */\n-#define INIT_NAME(list, name) \\\n-  do {(name).len = 0; (name).offset = (list)->name_used;} while (0)\n-\n-#define IS_DIRECTIVE(list) (TOK_TYPE (list, 0) == CPP_HASH)\n-#define COLUMN(cur) ((cur) - buffer->line_base)\n-\n-/* Maybe put these in the ISTABLE eventually.  */\n-#define IS_HSPACE(c) ((c) == ' ' || (c) == '\\t')\n-#define IS_NEWLINE(c) ((c) == '\\n' || (c) == '\\r')\n-\n-/* Handle LF, CR, CR-LF and LF-CR style newlines.  Assumes next\n-   character, if any, is in buffer.  */\n-#define handle_newline(cur, limit, c) \\\n-  do {\\\n-  if ((cur) < (limit) && *(cur) == '\\r' + '\\n' - c) \\\n-    (cur)++; \\\n-  CPP_BUMP_LINE_CUR (pfile, (cur)); \\\n-  } while (0)\n-\n-#define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITESPACE))\n-#define PREV_TOKEN_TYPE (cur_token[-1].type)\n-\n-#define SPELL_TEXT     0\n-#define SPELL_HANDLER  1\n-#define SPELL_CHAR     2\n-#define SPELL_NONE     3\n-#define SPELL_EOL      4\n-\n-#define T(e, s) {SPELL_TEXT, s},\n-#define H(e, s) {SPELL_HANDLER, s},\n-#define C(e, s) {SPELL_CHAR, s},\n-#define N(e, s) {SPELL_NONE, s},\n-#define E(e, s) {SPELL_EOL, s},\n-\n-static const struct token_spelling\n-{\n-  unsigned char type;\n-  PTR  speller;\n-} token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n-\n-#undef T\n-#undef H\n-#undef C\n-#undef N\n-#undef E\n-\n-static const unsigned char *digraph_spellings [] = {\"%:\", \"%:%:\", \"<:\",\n-\t\t\t\t\t\t    \":>\", \"<%\", \"%>\"};\n+static const unsigned char *digraph_spellings [] = {U\"%:\", U\"%:%:\", U\"<:\",\n+\t\t\t\t\t\t    U\":>\", U\"<%\", U\"%>\"};\n+static unsigned char trigraph_map[256];\n \n static void\n expand_comment_space (list)\n@@ -2272,8 +2288,6 @@ cpp_free_token_list (list)\n   free (list);\n }\n \n-static unsigned char trigraph_map[256];\n-\n void\n init_trigraph_map ()\n {\n@@ -2390,7 +2404,7 @@ backslash_start (pfile, cur)\n    previous asterisk may be separated by one or more escaped newlines.\n    Returns non-zero if comment terminated by EOF, zero otherwise.  */\n static int\n-skip_block_comment (pfile)\n+skip_block_comment2 (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n@@ -2448,7 +2462,7 @@ skip_block_comment (pfile)\n /* Skip a C++ or Chill line comment.  Handles escaped newlines.\n    Returns non-zero if a multiline comment.  */\n static int\n-skip_line_comment (pfile)\n+skip_line_comment2 (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n@@ -2613,7 +2627,7 @@ parse_number (pfile, list, name)\n    constants ('\"'), angled headers ('>') and assertions (')').  */\n \n static void\n-parse_string (pfile, list, name, terminator)\n+parse_string2 (pfile, list, name, terminator)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n      cpp_name *name;\n@@ -2750,7 +2764,7 @@ parse_string (pfile, list, name, terminator)\n    '-' = Chill-style and '/' = C++ style.  For code simplicity, the\n    stored comment includes any C-style comment terminator.  */\n static void\n-copy_comment (list, from, len, tok_no, type)\n+save_comment (list, from, len, tok_no, type)\n      cpp_toklist *list;\n      const unsigned char *from;\n      unsigned int len;\n@@ -2789,12 +2803,6 @@ copy_comment (list, from, len, tok_no, type)\n  *  even when enabled.\n  */\n \n-#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n-#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n-#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n-#define BACKUP_DIGRAPH(ttype) do { \\\n-  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n-\n void\n _cpp_lex_line (pfile, list)\n      cpp_reader *pfile;\n@@ -2908,7 +2916,7 @@ _cpp_lex_line (pfile, list)\n \t  /* Here c is one of ' \" > or ).  */\n \t  INIT_NAME (list, cur_token->val.name);\n \t  buffer->cur = cur;\n-\t  parse_string (pfile, list, &cur_token->val.name, c);\n+\t  parse_string2 (pfile, list, &cur_token->val.name, c);\n \t  cur = buffer->cur;\n \t  cur_token++;\n \t  break;\n@@ -2942,12 +2950,12 @@ _cpp_lex_line (pfile, list)\n \t\t      if (cur[-2] != c)\n \t\t\tcpp_warning (pfile,\n \t\t\t\t     \"comment start split across lines\");\n-\t\t      if (skip_line_comment (pfile))\n+\t\t      if (skip_line_comment2 (pfile))\n \t\t\tcpp_error_with_line (pfile, list->line,\n \t\t\t\t\t     cur_token[-1].col,\n \t\t\t\t\t     \"multi-line comment\");\n \t\t      if (!CPP_OPTION (pfile, discard_comments))\n-\t\t\tcopy_comment (list, cur, buffer->cur - cur,\n+\t\t\tsave_comment (list, cur, buffer->cur - cur,\n \t\t\t\t      cur_token - 1 - list->tokens, c == '/'\n \t\t\t\t      ? CPP_CPP_COMMENT: CPP_CHILL_COMMENT);\n \t\t      cur = buffer->cur;\n@@ -2972,14 +2980,14 @@ _cpp_lex_line (pfile, list)\n \t\t  if (cur[-2] != '/')\n \t\t    cpp_warning (pfile,\n \t\t\t\t \"comment start '/*' split across lines\");\n-\t\t  if (skip_block_comment (pfile))\n+\t\t  if (skip_block_comment2 (pfile))\n \t\t    cpp_error_with_line (pfile, list->line, cur_token[-1].col,\n \t\t\t\t\t \"unterminated comment\");\n \t\t  else if (buffer->cur[-2] != '*')\n \t\t    cpp_warning (pfile,\n \t\t\t\t \"comment end '*/' split across lines\");\n \t\t  if (!CPP_OPTION (pfile, discard_comments))\n-\t\t    copy_comment (list, cur, buffer->cur - cur,\n+\t\t    save_comment (list, cur, buffer->cur - cur,\n \t\t\t\t cur_token - 1 - list->tokens, CPP_C_COMMENT);\n \t\t  cur = buffer->cur;\n \n@@ -3374,11 +3382,7 @@ _cpp_lex_file (pfile)\n     }\n }\n \n-/* This could be useful to other routines.  If you allocate this many\n-   bytes, you have enough room to spell the token.  */\n-#define TOKEN_LEN(token) (4 + (token_spellings[token->type].type == \\\n-\t\t\t       SPELL_HANDLER ? token->val.name.len: 0))\n-\n+/* Temporary function for illustrative purposes.  */\n static void\n _cpp_output_list (pfile, list)\n      cpp_reader *pfile;"}]}