{"sha": "dcc21c4c0ae5f44c048e5f016357730395491c8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNjMjFjNGMwYWU1ZjQ0YzA0OGU1ZjAxNjM1NzczMDM5NTQ5MWM4ZQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2006-01-22T15:01:02Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2006-01-22T15:01:02Z"}, "message": "m68k.md: Add Coldfire FPU support.\n\n2006-01-22  Paul Brook  <paul@codesourcery.com>\n\tPeter Barada  <peter@the-baradas.com>\n\n\t* config/m68k/m68k.md: Add Coldfire FPU support.\n\tDefine FP mode macro and associated attributes.\n\tUse it for float mode patterns.\n\t* config/m68k/linux.h (FUNCTION_VALUE): Use m68k_function_value.\n\t(LIBCALL_VALUE): Use m68k_libcall_value.\n\t* config/m68k/m68k-protos.h (m68k_libcall_value): Add prototype.\n\t(m68k_function_value): Ditto.\n\t(emit_move_sequence): Ditto.\n\t* config/m68k/m68kemb.h (LIBCALL_VALUE): Use m68k_libcall_value.\n\t* config/m68k/m68k-none.h (ASM_SPEC): Add mcfv4e.\n\t* config/m68k/t-m68kelf (MULTILIB_OPTIONS): Add mcfv4e.\n\t(MULTILIB_EXCEPTIONS): Ditto.\n\t* config/m68k/m68k.opt: Add mcfv4e.\n\t* config/m68k/m68k.c (m68k_handle_option): Handle OPT_mcfv4e.\n\t(m68k_compute_frame_layout): Include space for ColdFire FPU regs.\n\t(m68k_output_function_prologue): Save ColdFire FPU registers.\n\t(m68k_output_function_epilogue): Restore ColdFire FPU registers.\n\t(force_mode, fp_reg_operand, emit_move_sequence): New functions.\n\t(m68k_regno_mode_ok): Don't allow types larget than 8 bytes in\n\tColdFire FPU registers.\n\t(m68k_libcall_value, m68k_function_value): New functions.\n\t* config/m68k/netbsd-elf.h (FUNCTION_VALUE): Use m68k_function_value.\n\t(LIBCALL_VALUE): Use m68k_libcall_value.\n\t* config/m68k/m68k.h (TARGET_CPU_CPP_BUILTINS): Define __mcfv4e__.\n\t(MASK_COLDFIRE): Add MASK_CFV4E.\n\t(TARGET_COLDFIRE_FPU, TARGET_HARD_FLOAT, TARGET_FP_REG_SIZE): New.\n\t(MODES_TIEABLE_P): Use TARGET_HARD_FLOAT.\n\t(REG_CLASS_FROM_LETTER, PREFERRED_RELOAD_CLASS): Ditto.\n\t(GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS): Define.\n\t(GO_IF_LEGITIMATE_ADDRESS): Use it.\n\t(LEGITIMIZE_ADDRESS): Handle ColdFire FPU addresses.\n\t* doc/invoke.tex: Document -mcfv4e on m68k.\n\n\nCo-Authored-By: Peter Barada <peter@the-baradas.com>\n\nFrom-SVN: r110091", "tree": {"sha": "c6dcb5bb9c43aba31c2d1769effa3ba9552b9441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6dcb5bb9c43aba31c2d1769effa3ba9552b9441"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcc21c4c0ae5f44c048e5f016357730395491c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc21c4c0ae5f44c048e5f016357730395491c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcc21c4c0ae5f44c048e5f016357730395491c8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcc21c4c0ae5f44c048e5f016357730395491c8e/comments", "author": null, "committer": null, "parents": [{"sha": "d54d5437be89a983a0ee4671c4e5080a68e47769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54d5437be89a983a0ee4671c4e5080a68e47769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54d5437be89a983a0ee4671c4e5080a68e47769"}], "stats": {"total": 1987, "additions": 1115, "deletions": 872}, "files": [{"sha": "0c396413477d351523373d4cccbf5fb0c258a953", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,3 +1,39 @@\n+2006-01-22  Paul Brook  <paul@codesourcery.com>\n+\tPeter Barada  <peter@the-baradas.com>\n+\n+\t* config/m68k/m68k.md: Add Coldfire FPU support.\n+\tDefine FP mode macro and associated attributes.\n+\tUse it for float mode patterns.\n+\t* config/m68k/linux.h (FUNCTION_VALUE): Use m68k_function_value.\n+\t(LIBCALL_VALUE): Use m68k_libcall_value.\n+\t* config/m68k/m68k-protos.h (m68k_libcall_value): Add prototype.\n+\t(m68k_function_value): Ditto.\n+\t(emit_move_sequence): Ditto.\n+\t* config/m68k/m68kemb.h (LIBCALL_VALUE): Use m68k_libcall_value.\n+\t* config/m68k/m68k-none.h (ASM_SPEC): Add mcfv4e.\n+\t* config/m68k/t-m68kelf (MULTILIB_OPTIONS): Add mcfv4e.\n+\t(MULTILIB_EXCEPTIONS): Ditto.\n+\t* config/m68k/m68k.opt: Add mcfv4e.\n+\t* config/m68k/m68k.c (m68k_handle_option): Handle OPT_mcfv4e.\n+\t(m68k_compute_frame_layout): Include space for ColdFire FPU regs.\n+\t(m68k_output_function_prologue): Save ColdFire FPU registers.\n+\t(m68k_output_function_epilogue): Restore ColdFire FPU registers.\n+\t(force_mode, fp_reg_operand, emit_move_sequence): New functions.\n+\t(m68k_regno_mode_ok): Don't allow types larget than 8 bytes in\n+\tColdFire FPU registers.\n+\t(m68k_libcall_value, m68k_function_value): New functions.\n+\t* config/m68k/netbsd-elf.h (FUNCTION_VALUE): Use m68k_function_value.\n+\t(LIBCALL_VALUE): Use m68k_libcall_value.\n+\t* config/m68k/m68k.h (TARGET_CPU_CPP_BUILTINS): Define __mcfv4e__.\n+\t(MASK_COLDFIRE): Add MASK_CFV4E.\n+\t(TARGET_COLDFIRE_FPU, TARGET_HARD_FLOAT, TARGET_FP_REG_SIZE): New.\n+\t(MODES_TIEABLE_P): Use TARGET_HARD_FLOAT.\n+\t(REG_CLASS_FROM_LETTER, PREFERRED_RELOAD_CLASS): Ditto.\n+\t(GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS): Define.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Use it.\n+\t(LEGITIMIZE_ADDRESS): Handle ColdFire FPU addresses.\n+\t* doc/invoke.tex: Document -mcfv4e on m68k.\n+\n 2006-01-22  Ranjit Mathew  <rmathew@gcc.gnu.org>\n \n \t* doc/contribute.texi: Change CVS to SVN and update the corresponding"}, {"sha": "4f51a021af00bc24fb00331bd878f31269276031", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for Motorola 68k running Linux-based GNU systems with\n    ELF format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -224,11 +224,7 @@ Boston, MA 02110-1301, USA.  */\n \n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n-  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n-   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n-   : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\t\t\\\n-      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n-      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n+  m68k_function_value (VALTYPE, FUNC)\n \n /* For compatibility with the large body of existing code which does\n    not always properly declare external functions returning pointer\n@@ -251,10 +247,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)\t\t\\\n-    && TARGET_68881)\t\t\t\t\t\t\t\\\n-   ? gen_rtx_REG ((MODE), 16)\t\t\t\t\t\t\\\n-   : gen_rtx_REG ((MODE), 0))\n+  m68k_libcall_value (MODE)\n \n /* For m68k SVR4, structures are returned using the reentrant\n    technique.  */"}, {"sha": "a8618cd033779d8ccad7f36800a6ef2e877555d0", "filename": "gcc/config/m68k/m68k-none.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-none.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  \"naked\" 68020.\n-   Copyright (C) 1994, 1996, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 2003, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -81,7 +81,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n #undef ASM_SPEC\n #define ASM_SPEC \"\\\n-%{m68851}%{mno-68851}%{m68881}%{mno-68881}%{msoft-float:-mno-68881} %{m68000}%{m68302}%{mc68000}%{m68010}%{m68020}%{mc68020}%{m68030}%{m68040}%{m68020-40:-mc68040} %{m68020-60:-mc68040} %{m68060}%{mcpu32}%{m68332}%{m5200}%{m5206e}%{m528x}%{m5307}%{m5407}%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32:%{!m68332:%{!m5200:%{!m5206e:%{!m528x:%{!m5307:%{!m5407:%(asm_cpu_default)}}}}}}}}}}}}}}}}}} \\\n+%{m68851}%{mno-68851}%{m68881}%{mno-68881}%{msoft-float:-mno-68881} %{m68000}%{m68302}%{mc68000}%{m68010}%{m68020}%{mc68020}%{m68030}%{m68040}%{m68020-40:-mc68040} %{m68020-60:-mc68040} %{m68060}%{mcpu32}%{m68332}%{m5200}%{m5206e}%{m528x}%{m5307}%{m5407}%{mcfv4e}%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32:%{!m68332:%{!m5200:%{!m5206e:%{!m528x:%{!m5307:%{!m5407:%{!mcfv4e:%(asm_cpu_default)}}}}}}}}}}}}}}}}}}} \\\n %{fPIC:--pcrel} %{fpic:--pcrel} %{msep-data:--pcrel} %{mid-shared-library:--pcrel} \\\n \"\n "}, {"sha": "531c695871331f0fa0475b97a72a3378ef6fcf13", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n-   Copyright (C) 2000, 2002, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -51,6 +51,9 @@ extern void print_operand (FILE *, rtx, int);\n extern void notice_update_cc (rtx, rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n+extern rtx m68k_libcall_value (enum machine_mode);\n+extern rtx m68k_function_value (tree, tree);\n+extern int emit_move_sequence (rtx *, enum machine_mode, rtx);\n \n #endif /* RTX_CODE */\n "}, {"sha": "1e753dfcd66e534ea7ae9074e4ff29e6a8aaa713", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 324, "deletions": 21, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -240,6 +240,11 @@ m68k_handle_option (size_t code, const char *arg, int value)\n       target_flags |= MASK_CFV4 | MASK_CF_HWDIV;\n       return true;\n \n+    case OPT_mcfv4e:\n+      target_flags &= ~(MASK_ALL_CPU_BITS | MASK_68881);\n+      target_flags |= MASK_CFV4 | MASK_CF_HWDIV | MASK_CFV4E;\n+      return true;\n+\n     case OPT_m68000:\n     case OPT_mc68000:\n       target_flags &= ~(MASK_ALL_CPU_BITS | MASK_68881);\n@@ -411,7 +416,7 @@ m68k_compute_frame_layout (void)\n \n   current_frame.foffset = 0;\n   mask = rmask = saved = 0;\n-  if (TARGET_68881 /* || TARGET_CFV4E */)\n+  if (TARGET_HARD_FLOAT)\n     {\n       for (regno = 16; regno < 24; regno++)\n \tif (m68k_save_reg (regno, interrupt_handler))\n@@ -420,7 +425,7 @@ m68k_compute_frame_layout (void)\n \t    rmask |= 1 << (23 - regno);\n \t    saved++;\n \t  }\n-      current_frame.foffset = saved * 12 /* (TARGET_CFV4E ? 8 : 12) */;\n+      current_frame.foffset = saved * TARGET_FP_REG_SIZE;\n       current_frame.offset += current_frame.foffset;\n     }\n   current_frame.fpu_no = saved;\n@@ -535,8 +540,13 @@ m68k_output_function_prologue (FILE *stream,\n \n   /* On ColdFire add register save into initial stack frame setup, if possible.  */\n   fsize_with_regs = current_frame.size;\n-  if (TARGET_COLDFIRE && current_frame.reg_no > 2)\n-    fsize_with_regs += current_frame.reg_no * 4;\n+  if (TARGET_COLDFIRE)\n+    {\n+      if (current_frame.reg_no > 2)\n+\tfsize_with_regs += current_frame.reg_no * 4;\n+      if (current_frame.fpu_no)\n+\tfsize_with_regs += current_frame.fpu_no * 8;\n+    }\n \n   if (frame_pointer_needed)\n     {\n@@ -616,22 +626,46 @@ m68k_output_function_prologue (FILE *stream,\n \n   if (current_frame.fpu_mask)\n     {\n-      asm_fprintf (stream, (MOTOROLA\n-\t\t\t    ? \"\\tfmovm %I0x%x,-(%Rsp)\\n\"\n-\t\t\t    : \"\\tfmovem %I0x%x,%Rsp@-\\n\"),\n-\t\t   current_frame.fpu_mask);\n+      if (TARGET_68881)\n+\t{\n+\t  asm_fprintf (stream, (MOTOROLA\n+\t\t\t\t? \"\\tfmovm %I0x%x,-(%Rsp)\\n\"\n+\t\t\t\t: \"\\tfmovem %I0x%x,%Rsp@-\\n\"),\n+\t\t       current_frame.fpu_mask);\n+\t}\n+      else\n+\t{\n+\t  int offset;\n+\n+\t  /* stack already has registers in it.  Find the offset from\n+\t     the bottom of stack to where the FP registers go */\n+\t  if (current_frame.reg_no <= 2)\n+\t    offset = 0;\n+\t  else\n+\t    offset = current_frame.reg_no * 4;\n+\t  if (offset)\n+\t    asm_fprintf (stream,\n+\t\t\t \"\\tfmovem %I0x%x,%d(%Rsp)\\n\",\n+\t\t\t current_frame.fpu_rev_mask,\n+\t\t\t offset);\n+\t  else\n+\t    asm_fprintf (stream,\n+\t\t\t \"\\tfmovem %I0x%x,(%Rsp)\\n\",\n+\t\t\t current_frame.fpu_rev_mask);\n+\t}\n \n       if (dwarf2out_do_frame ())\n \t{\n \t  char *l = (char *) dwarf2out_cfi_label ();\n \t  int n_regs, regno;\n \n-\t  cfa_offset += current_frame.fpu_no * 12;\n+\t  cfa_offset += current_frame.fpu_no * TARGET_FP_REG_SIZE;\n \t  if (! frame_pointer_needed)\n \t    dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n \t  for (regno = 16, n_regs = 0; regno < 24; regno++)\n \t    if (current_frame.fpu_mask & (1 << (regno - 16)))\n-\t      dwarf2out_reg_save (l, regno, -cfa_offset + n_regs++ * 12);\n+\t      dwarf2out_reg_save (l, regno, -cfa_offset\n+\t\t\t\t  + n_regs++ * TARGET_FP_REG_SIZE);\n \t}\n     }\n \n@@ -799,8 +833,13 @@ m68k_output_function_epilogue (FILE *stream,\n      after restoring registers. When the frame pointer isn't used,\n      we can merge movem adjustment into frame unlinking\n      made immediately after it.  */\n-  if (TARGET_COLDFIRE && restore_from_sp && (current_frame.reg_no > 2))\n-    fsize_with_regs += current_frame.reg_no * 4;\n+  if (TARGET_COLDFIRE && restore_from_sp)\n+    {\n+      if (current_frame.reg_no > 2)\n+\tfsize_with_regs += current_frame.reg_no * 4;\n+      if (current_frame.fpu_no)\n+\tfsize_with_regs += current_frame.fpu_no * 8;\n+    }\n \n   if (current_frame.offset + fsize >= 0x8000\n       && ! restore_from_sp\n@@ -936,7 +975,21 @@ m68k_output_function_epilogue (FILE *stream,\n     {\n       if (big)\n \t{\n-\t  if (MOTOROLA)\n+\t  if (TARGET_COLDFIRE)\n+\t    {\n+\t      if (current_frame.reg_no)\n+\t\tasm_fprintf (stream, MOTOROLA ?\n+\t\t\t     \"\\tfmovem.d %d(%Ra1),%I0x%x\\n\" :\n+\t\t\t     \"\\tfmovmd (%d,%Ra1),%I0x%x\\n\",\n+\t\t\t     current_frame.reg_no * 4,\n+\t\t\t     current_frame.fpu_rev_mask);\n+\t      else\n+\t\tasm_fprintf (stream, MOTOROLA ?\n+\t\t\t     \"\\tfmovem.d (%Ra1),%I0x%x\\n\" :\n+\t\t\t     \"\\tfmovmd (%Ra1),%I0x%x\\n\",\n+\t\t\t     current_frame.fpu_rev_mask);\n+\t    }\n+\t  else if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s,%Ra1.l),%I0x%x\\n\",\n \t\t         current_frame.foffset + fsize,\n \t\t         M68K_REGNAME (FRAME_POINTER_REGNUM),\n@@ -949,16 +1002,34 @@ m68k_output_function_epilogue (FILE *stream,\n \t}\n       else if (restore_from_sp)\n \t{\n-\t  if (MOTOROLA)\n-\t    asm_fprintf (stream, \"\\tfmovm (%Rsp)+,%I0x%x\\n\",\n-\t\t\t current_frame.fpu_rev_mask);\n-\t  else\n-\t    asm_fprintf (stream, \"\\tfmovem %Rsp@+,%I0x%x\\n\",\n-\t\t\t current_frame.fpu_rev_mask);\n+\t  if (TARGET_COLDFIRE)\n+\t    {\n+\t      int offset;\n+\n+\t      /* stack already has registers in it.  Find the offset from\n+\t\t the bottom of stack to where the FP registers go */\n+\t      if (current_frame.reg_no <= 2)\n+\t\toffset = 0;\n+\t      else\n+\t\toffset = current_frame.reg_no * 4;\n+\t      if (offset)\n+\t\t asm_fprintf (stream,\n+\t\t\t     \"\\tfmovem %Rsp@(%wd), %I0x%x\\n\",\n+\t\t\t     offset, current_frame.fpu_rev_mask);\n+\t      else\n+\t\t asm_fprintf (stream,\n+\t\t\t     \"\\tfmovem %Rsp@, %I0x%x\\n\",\n+\t\t\t     current_frame.fpu_rev_mask);\n+\t    }\n+\t   else\n+\t\t  asm_fprintf (stream, MOTOROLA ?\n+\t\t\t       \"\\tfmovm (%Rsp)+,%I0x%x\\n\" :\n+\t\t\t       \"\\tfmovem %Rsp@+,%I0x%x\\n\",\n+\t\t\t       current_frame.fpu_rev_mask);\n \t}\n       else\n \t{\n-\t  if (MOTOROLA)\n+\t  if (MOTOROLA && !TARGET_COLDFIRE)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s),%I0x%x\\n\",\n \t\t\t current_frame.foffset + fsize,\n \t\t\t M68K_REGNAME (FRAME_POINTER_REGNUM),\n@@ -2242,6 +2313,192 @@ output_move_double (rtx *operands)\n   return \"\";\n }\n \n+\n+/* Ensure mode of ORIG, a REG rtx, is MODE.  Returns either ORIG or a\n+   new rtx with the correct mode.  */\n+\n+static rtx\n+force_mode (enum machine_mode mode, rtx orig)\n+{\n+  if (mode == GET_MODE (orig))\n+    return orig;\n+\n+  if (REGNO (orig) >= FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n+  return gen_rtx_REG (mode, REGNO (orig));\n+}\n+\n+static int\n+fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return reg_renumber && FP_REG_P (op);\n+}\n+\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.\n+\n+   Note SCRATCH_REG may not be in the proper mode depending on how it\n+   will be used.  This routine is resposible for creating a new copy\n+   of SCRATCH_REG in the proper mode.  */\n+\n+int\n+emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+  register rtx tem;\n+\n+  if (scratch_reg\n+      && reload_in_progress && GET_CODE (operand0) == REG\n+      && REGNO (operand0) >= FIRST_PSEUDO_REGISTER)\n+    operand0 = reg_equiv_mem[REGNO (operand0)];\n+  else if (scratch_reg\n+\t   && reload_in_progress && GET_CODE (operand0) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operand0)) == REG\n+\t   && REGNO (SUBREG_REG (operand0)) >= FIRST_PSEUDO_REGISTER)\n+    {\n+     /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n+\tthe code which tracks sets/uses for delete_output_reload.  */\n+      rtx temp = gen_rtx_SUBREG (GET_MODE (operand0),\n+\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand0))],\n+\t\t\t\t SUBREG_BYTE (operand0));\n+      operand0 = alter_subreg (&temp);\n+    }\n+\n+  if (scratch_reg\n+      && reload_in_progress && GET_CODE (operand1) == REG\n+      && REGNO (operand1) >= FIRST_PSEUDO_REGISTER)\n+    operand1 = reg_equiv_mem[REGNO (operand1)];\n+  else if (scratch_reg\n+\t   && reload_in_progress && GET_CODE (operand1) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operand1)) == REG\n+\t   && REGNO (SUBREG_REG (operand1)) >= FIRST_PSEUDO_REGISTER)\n+    {\n+     /* We must not alter SUBREG_BYTE (operand0) since that would confuse\n+\tthe code which tracks sets/uses for delete_output_reload.  */\n+      rtx temp = gen_rtx_SUBREG (GET_MODE (operand1),\n+\t\t\t\t reg_equiv_mem [REGNO (SUBREG_REG (operand1))],\n+\t\t\t\t SUBREG_BYTE (operand1));\n+      operand1 = alter_subreg (&temp);\n+    }\n+\n+  if (scratch_reg && reload_in_progress && GET_CODE (operand0) == MEM\n+      && ((tem = find_replacement (&XEXP (operand0, 0)))\n+\t  != XEXP (operand0, 0)))\n+    operand0 = gen_rtx_MEM (GET_MODE (operand0), tem);\n+  if (scratch_reg && reload_in_progress && GET_CODE (operand1) == MEM\n+      && ((tem = find_replacement (&XEXP (operand1, 0)))\n+\t  != XEXP (operand1, 0)))\n+    operand1 = gen_rtx_MEM (GET_MODE (operand1), tem);\n+\n+  /* Handle secondary reloads for loads/stores of FP registers where\n+     the address is symbolic by using the scratch register */\n+  if (fp_reg_operand (operand0, mode)\n+      && ((GET_CODE (operand1) == MEM\n+\t   && ! memory_address_p (DFmode, XEXP (operand1, 0)))\n+\t  || ((GET_CODE (operand1) == SUBREG\n+\t       && GET_CODE (XEXP (operand1, 0)) == MEM\n+\t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0)))))\n+      && scratch_reg)\n+    {\n+      if (GET_CODE (operand1) == SUBREG)\n+\toperand1 = XEXP (operand1, 0);\n+\n+      /* SCRATCH_REG will hold an address.  We want\n+\t it in SImode regardless of what mode it was originally given\n+\t to us.  */\n+      scratch_reg = force_mode (SImode, scratch_reg);\n+\n+      /* D might not fit in 14 bits either; for such cases load D into\n+\t scratch reg.  */\n+      if (!memory_address_p (Pmode, XEXP (operand1, 0)))\n+\t{\n+\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand1, 0), 1));\n+\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand1, 0)),\n+\t\t\t\t\t\t       Pmode,\n+\t\t\t\t\t\t       XEXP (XEXP (operand1, 0), 0),\n+\t\t\t\t\t\t       scratch_reg));\n+\t}\n+      else\n+\temit_move_insn (scratch_reg, XEXP (operand1, 0));\n+      emit_insn (gen_rtx_SET (VOIDmode, operand0,\n+\t\t\t      gen_rtx_MEM (mode, scratch_reg)));\n+      return 1;\n+    }\n+  else if (fp_reg_operand (operand1, mode)\n+\t   && ((GET_CODE (operand0) == MEM\n+\t\t&& ! memory_address_p (DFmode, XEXP (operand0, 0)))\n+\t       || ((GET_CODE (operand0) == SUBREG)\n+\t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n+\t\t   && !memory_address_p (DFmode, XEXP (XEXP (operand0, 0), 0))))\n+\t   && scratch_reg)\n+    {\n+      if (GET_CODE (operand0) == SUBREG)\n+\toperand0 = XEXP (operand0, 0);\n+\n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in SIMODE regardless of what mode it was originally given\n+\t to us.  */\n+      scratch_reg = force_mode (SImode, scratch_reg);\n+\n+      /* D might not fit in 14 bits either; for such cases load D into\n+\t scratch reg.  */\n+      if (!memory_address_p (Pmode, XEXP (operand0, 0)))\n+\t{\n+\t  emit_move_insn (scratch_reg, XEXP (XEXP (operand0, 0), 1));\n+\t  emit_move_insn (scratch_reg, gen_rtx_fmt_ee (GET_CODE (XEXP (operand0,\n+\t\t\t\t\t\t\t\t        0)),\n+\t\t\t\t\t\t       Pmode,\n+\t\t\t\t\t\t       XEXP (XEXP (operand0, 0),\n+\t\t\t\t\t\t\t\t   0),\n+\t\t\t\t\t\t       scratch_reg));\n+\t}\n+      else\n+\temit_move_insn (scratch_reg, XEXP (operand0, 0));\n+      emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_MEM (mode, scratch_reg),\n+\t\t\t      operand1));\n+      return 1;\n+    }\n+  /* Handle secondary reloads for loads of FP registers from constant\n+     expressions by forcing the constant into memory.\n+\n+     use scratch_reg to hold the address of the memory location.\n+\n+     The proper fix is to change PREFERRED_RELOAD_CLASS to return\n+     NO_REGS when presented with a const_int and an register class\n+     containing only FP registers.  Doing so unfortunately creates\n+     more problems than it solves.   Fix this for 2.5.  */\n+  else if (fp_reg_operand (operand0, mode)\n+\t   && CONSTANT_P (operand1)\n+\t   && scratch_reg)\n+    {\n+      rtx xoperands[2];\n+\n+      /* SCRATCH_REG will hold an address and maybe the actual data.  We want\n+\t it in SIMODE regardless of what mode it was originally given\n+\t to us.  */\n+      scratch_reg = force_mode (SImode, scratch_reg);\n+\n+      /* Force the constant into memory and put the address of the\n+\t memory location into scratch_reg.  */\n+      xoperands[0] = scratch_reg;\n+      xoperands[1] = XEXP (force_const_mem (mode, operand1), 0);\n+      emit_insn (gen_rtx_SET (mode, scratch_reg, xoperands[1]));\n+\n+      /* Now load the destination register.  */\n+      emit_insn (gen_rtx_SET (mode, operand0,\n+\t\t\t      gen_rtx_MEM (mode, scratch_reg)));\n+      return 1;\n+    }\n+\n+  /* Now have insn-emit do whatever it normally does.  */\n+  return 0;\n+}\n+\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG.  */\n \n@@ -3381,8 +3638,54 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n \t smaller.  */\n       if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n-\t  && GET_MODE_UNIT_SIZE (mode) <= 12)\n+\t  && GET_MODE_UNIT_SIZE (mode) <= TARGET_FP_REG_SIZE)\n \treturn true;\n     }\n   return false;\n }\n+\n+/* Return floating point values in a 68881 register.  This makes 68881 code\n+   a little bit faster.  It also makes -msoft-float code incompatible with\n+   hard-float code, so people have to be careful not to mix the two.\n+   For ColdFire it was decided the ABI incopmatibility is undesirable.\n+   If there is need for a hard-float ABI it is probably worth doing it\n+   properly and also passing function arguments in FP registers.  */\n+rtx\n+m68k_libcall_value (enum machine_mode mode)\n+{\n+  switch (mode) {\n+  case SFmode:\n+  case DFmode:\n+  case XFmode:\n+    if (TARGET_68881)\n+      return gen_rtx_REG (mode, 16);\n+    break;\n+  default:\n+    break;\n+  }\n+  return gen_rtx_REG (mode, 0);\n+}\n+\n+rtx\n+m68k_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode;\n+\n+  mode = TYPE_MODE (valtype);\n+  switch (mode) {\n+  case SFmode:\n+  case DFmode:\n+  case XFmode:\n+    if (TARGET_68881)\n+      return gen_rtx_REG (mode, 16);\n+    break;\n+  default:\n+    break;\n+  }\n+\n+  /* If the function returns a pointer, push that into %a0 */\n+  if (POINTER_TYPE_P (valtype))\n+    return gen_rtx_REG (mode, 8);\n+  else\n+    return gen_rtx_REG (mode, 0);\n+}"}, {"sha": "e4d92576f3d85f72ea892c38dd73ea542791f548", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GCC for Motorola 680x0/ColdFire.\n    Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -90,6 +90,10 @@ Boston, MA 02110-1301, USA.  */\n \t  builtin_define (\"__mcf5400__\");\t\\\n \t  builtin_define (\"__mcf5407__\");\t\\\n \t}\t\t\t\t\t\\\n+      if (TARGET_CFV4E)\t\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  builtin_define (\"__mcfv4e__\");\t\\\n+\t}\t\t\t\t\t\\\n       if (TARGET_CF_HWDIV)\t\t\t\\\n \tbuiltin_define (\"__mcfhwdiv__\");\t\\\n       builtin_assert (\"cpu=m68k\");\t\t\\\n@@ -112,9 +116,17 @@ Boston, MA 02110-1301, USA.  */\n #define TARGET_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n \n /* Is the target a ColdFire?  */\n-#define MASK_COLDFIRE\t(MASK_5200 | MASK_528x | MASK_CFV3 | MASK_CFV4)\n+#define MASK_COLDFIRE \\\n+  (MASK_5200 | MASK_528x | MASK_CFV3 | MASK_CFV4 | MASK_CFV4E)\n #define TARGET_COLDFIRE\t((target_flags & MASK_COLDFIRE) != 0)\n \n+#define TARGET_COLDFIRE_FPU\tTARGET_CFV4E\n+\n+#define TARGET_HARD_FLOAT\t(TARGET_68881 || TARGET_COLDFIRE_FPU)\n+/* Size (in bytes) of FPU registers.  */\n+#define TARGET_FP_REG_SIZE\t(TARGET_COLDFIRE ? 8 : 12)\n+\n+\n #define OVERRIDE_OPTIONS   override_options()\n \n /* These are meant to be redefined in the host dependent files */\n@@ -229,7 +241,7 @@ Boston, MA 02110-1301, USA.  */\n {\t\t\t\t\t\t\t\t\\\n   int i;\t\t\t\t\t\t\t\\\n   HARD_REG_SET x;\t\t\t\t\t\t\\\n-  if (! TARGET_68881)\t\t\t\t\t\t\\\n+  if (!TARGET_HARD_FLOAT)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\t\\\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\\\n@@ -262,7 +274,7 @@ Boston, MA 02110-1301, USA.  */\n   m68k_regno_mode_ok ((REGNO), (MODE))\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  (! TARGET_68881\t\t\t\t\t\\\n+  (! TARGET_HARD_FLOAT\t\t\t\t\t\\\n    || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n \t|| GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n        == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n@@ -336,8 +348,8 @@ extern enum reg_class regno_reg_class[];\n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n    ((C) == 'd' ? DATA_REGS :\t\t\t\\\n-    ((C) == 'f' ? (TARGET_68881 ? FP_REGS :\t\\\n-\t\t   NO_REGS) :\t\t\t\\\n+    ((C) == 'f' ? (TARGET_HARD_FLOAT ?\t\t\\\n+\t\t   FP_REGS : NO_REGS) :\t\t\\\n      NO_REGS)))\n \n /* For the m68k, `I' is used for the range 1 to 8\n@@ -407,7 +419,7 @@ extern enum reg_class regno_reg_class[];\n    ? DATA_REGS\t\t\t\t\t\\\n    : (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n       && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\t\t\\\n-   ? (TARGET_68881 && (CLASS == FP_REGS || CLASS == DATA_OR_FP_REGS)\t\\\n+   ? (TARGET_HARD_FLOAT && (CLASS == FP_REGS || CLASS == DATA_OR_FP_REGS) \\\n       ? FP_REGS : NO_REGS)\t\t\t\t\t\t\\\n    : (TARGET_PCREL\t\t\t\t\\\n       && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST \\\n@@ -752,16 +764,34 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n \t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n \t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n-\t    || (INTVAL (XEXP (X, 1)) == 8 && !TARGET_COLDFIRE))))\n+\t    || (INTVAL (XEXP (X, 1)) == 8\t\t\\\n+\t\t&& (TARGET_CFV4E || !TARGET_COLDFIRE)))))\n+\n+/* Coldfire FPU only accepts addressing modes 2-5 */\n+#define GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (LEGITIMATE_BASE_REG_P (X)\t\t\t\t\t\t\\\n+      || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n+          && LEGITIMATE_BASE_REG_P (XEXP (X, 0)))\t\t\t\\\n+      || ((GET_CODE (X) == PLUS) && LEGITIMATE_BASE_REG_P (XEXP (X, 0))\t\\\n+          && (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+          && ((((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000))))\t\\\n+  goto ADDR;}\n \n /* If pic, we accept INDEX+LABEL, which is what do_tablejump makes.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{ GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  GO_IF_INDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (flag_pic && MODE == CASE_VECTOR_MODE && GET_CODE (X) == PLUS\t\\\n-      && LEGITIMATE_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == LABEL_REF)\t\t\t\t\\\n-    goto ADDR; }\n+{ if (TARGET_COLDFIRE_FPU && (GET_MODE_CLASS (MODE) == MODE_FLOAT))\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      GO_IF_COLDFIRE_FPU_LEGITIMATE_ADDRESS (MODE, X, ADDR);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\\\n+      GO_IF_INDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n+      if (flag_pic && MODE == CASE_VECTOR_MODE && GET_CODE (X) == PLUS\t\\\n+\t  && LEGITIMATE_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == LABEL_REF)\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+    }}\n \n /* Don't call memory_address_noforce for the address to fetch\n    the switch offset.  This address is ok as it stands (see above),\n@@ -783,7 +813,9 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t{ COPY_ONCE (X); XEXP (X, 1) = force_operand (XEXP (X, 1), 0);}\t\\\n       if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n \t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n+\t{ if (TARGET_CFV4E && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\\\n+\t    { COPY_ONCE (X); X = force_operand (X, 0);}\t\t\t\\\n+\t  goto WIN; }\t\t\t\t\t\t\t\\\n       if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n       if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n \t       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND\t\t\\\n@@ -794,6 +826,9 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t  emit_move_insn (temp, val);\t\t\t\t\t\\\n \t  COPY_ONCE (X);\t\t\t\t\t\t\\\n \t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n+\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t      && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n+\t    X = force_operand (X, 0);\t\t\t\t\t\\\n \t  goto WIN; }\t\t\t\t\t\t\t\\\n       else if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n \t       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND\t\t\\\n@@ -804,6 +839,9 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \t  emit_move_insn (temp, val);\t\t\t\t\t\\\n \t  COPY_ONCE (X);\t\t\t\t\t\t\\\n \t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n+\t  if (TARGET_COLDFIRE_FPU && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t      && GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\\\n+\t    X = force_operand (X, 0);\t\t\t\t\t\\\n \t  goto WIN; }}}\n \n /* On the 68000, only predecrement and postincrement address depend thus"}, {"sha": "4c24756770cfbb689035ec3c6335b0e4be46f74e", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 673, "deletions": 800, "changes": 1473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for GNU compiler, Motorola 68000 Version\n ;;  Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001,\n-;;  2002, 2003, 2004, 2005\n+;;  2002, 2003, 2004, 2005, 2006\n ;;  Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n@@ -46,7 +46,7 @@\n ;;- Operand classes for the register allocator:\n ;;- 'a' one of the address registers can be used.\n ;;- 'd' one of the data registers can be used.\n-;;- 'f' one of the m68881 registers can be used\n+;;- 'f' one of the m68881/fpu registers can be used\n ;;- 'r' either a data or an address register can be used.\n \n ;;- Immediate Floating point operator constraints\n@@ -131,6 +131,20 @@\n \n (include \"predicates.md\")\n \f\n+;; Mode macros for floating point operations.\n+;; Valid floating point modes\n+(define_mode_macro FP [SF DF (XF \"TARGET_68881\")])\n+;; Mnemonic infix to round result\n+(define_mode_attr round [(SF \"%$\") (DF \"%&\") (XF \"\")])\n+;; Mnemonic infix to round result for mul or div instruction\n+(define_mode_attr round_mul [(SF \"sgl\") (DF \"%&\") (XF \"\")])\n+;; Suffix specifiying source operand format\n+(define_mode_attr prec [(SF \"s\") (DF \"d\") (XF \"x\")])\n+;; Allowable D registers\n+(define_mode_attr dreg [(SF \"d\") (DF \"\") (XF \"\")])\n+;; Allowable 68881 constant constraints\n+(define_mode_attr const [(SF \"F\") (DF \"G\") (XF \"\")])\n+\f\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=m\")\n \t(match_operand:DF 1 \"general_operand\" \"ro<>fyE\"))]\n@@ -237,43 +251,36 @@\n   \"\"\n   \"tst%.b %0\")\n \n-(define_expand \"tstsf\"\n+(define_expand \"tst<mode>\"\n   [(set (cc0)\n-\t(match_operand:SF 0 \"general_operand\" \"\"))]\n-  \"TARGET_68881\"\n+\t(match_operand:FP 0 \"general_operand\" \"\"))]\n+  \"TARGET_HARD_FLOAT\"\n {\n   m68k_last_compare_had_fp_operands = 1;\n })\n \n-(define_insn \"\"\n+(define_insn \"tst<mode>_68881\"\n   [(set (cc0)\n-\t(match_operand:SF 0 \"general_operand\" \"fdm\"))]\n+\t(match_operand:FP 0 \"general_operand\" \"f<FP:dreg>m\"))]\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n   if (FP_REG_P (operands[0]))\n     return \"ftst%.x %0\";\n-  return \"ftst%.s %0\";\n-})\n-\n-(define_expand \"tstdf\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"\"))]\n-  \"TARGET_68881\"\n-{\n-  m68k_last_compare_had_fp_operands = 1;\n+  return \"ftst%.<FP:prec> %0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"tst<mode>_cf\"\n   [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"fm\"))]\n-  \"TARGET_68881\"\n+\t(match_operand:FP 0 \"general_operand\" \"f<FP:dreg><Q>U\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n   cc_status.flags = CC_IN_68881;\n   if (FP_REG_P (operands[0]))\n-    return \"ftst%.x %0\";\n-  return \"ftst%.d %0\";\n+    return \"ftst%.d %0\";\n+  return \"ftst%.<FP:prec> %0\";\n })\n+\n \f\n ;; compare instructions.\n \n@@ -408,58 +415,51 @@\n   return \"cmp%.b %d1,%d0\";\n })\n \n-(define_expand \"cmpdf\"\n+(define_expand \"cmp<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+\t(compare (match_operand:FP 0 \"general_operand\" \"\")\n+\t\t (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n {\n   m68k_last_compare_had_fp_operands = 1;\n+  if (TARGET_COLDFIRE && !reload_completed)\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n })\n \n-(define_insn \"\"\n+(define_insn \"cmp<mode>_68881\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"f,mG\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"fmG,f\")))]\n+\t(compare (match_operand:FP 0 \"general_operand\" \"f,m<FP:const>\")\n+\t\t (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m<FP:const>,f\")))]\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n-  if (REG_P (operands[0]))\n+  if (FP_REG_P (operands[0]))\n     {\n-      if (REG_P (operands[1]))\n+      if (FP_REG_P (operands[1]))\n \treturn \"fcmp%.x %1,%0\";\n       else\n-        return \"fcmp%.d %f1,%0\";\n+        return \"fcmp%.<FP:prec> %f1,%0\";\n     }\n   cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.d %f0,%1\";\n+  return \"fcmp%.<FP:prec> %f0,%1\";\n })\n \n-(define_expand \"cmpsf\"\n- [(set (cc0)\n-       (compare (match_operand:SF 0 \"general_operand\" \"\")\n-\t\t(match_operand:SF 1 \"general_operand\" \"\")))]\n- \"TARGET_68881\"\n-{\n-  m68k_last_compare_had_fp_operands = 1;\n-})\n-\n-(define_insn \"\"\n+(define_insn \"cmp<mode>_cf\"\n   [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"f,mdG\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"fmdG,f\")))]\n-  \"TARGET_68881\"\n+\t(compare (match_operand:FP 0 \"general_operand\" \"f,<FP:dreg><Q>U\")\n+\t\t (match_operand:FP 1 \"general_operand\" \"f<FP:dreg><Q>U,f\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n   cc_status.flags = CC_IN_68881;\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n-\treturn \"fcmp%.x %1,%0\";\n+\treturn \"fcmp%.d %1,%0\";\n       else\n-        return \"fcmp%.s %f1,%0\";\n+\treturn \"fcmp%.<FP:prec> %f1,%0\";\n     }\n   cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.s %f0,%1\";\n+  return \"fcmp%.<FP:prec> %f0,%1\";\n })\n \f\n ;; Recognizers for btst instructions.\n@@ -782,6 +782,34 @@\n   \"!TARGET_COLDFIRE\"\n   \"\")\n \n+(define_expand \"reload_insf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n+        (match_operand:SF 1 \"general_operand\" \"mf\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (emit_move_sequence (operands, SFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves. */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"reload_outsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+        (match_operand:SF 1 \"register_operand\" \"f\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (emit_move_sequence (operands, SFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves. */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+})\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]\n@@ -833,19 +861,111 @@\n   return \"move%.l %1,%0\";\n })\n \n-(define_insn \"\"\n+(define_insn \"movsf_cf_soft\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:SF 1 \"general_operand\" \"g,r\"))]\n-  \"TARGET_COLDFIRE\"\n+  \"TARGET_COLDFIRE && !TARGET_COLDFIRE_FPU\"\n {\n   return \"move%.l %1,%0\";\n })\n \n+(define_insn \"movsf_cf_hard\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r<Q>U, f,    f,mr,f,r<Q>,f\n+,m\")\n+        (match_operand:SF 1 \"general_operand\"      \" f,     r<Q>U,f,rm,F,F,   m\n+,f\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (which_alternative == 4 || which_alternative == 5) {\n+    rtx xoperands[2];\n+    REAL_VALUE_TYPE r;\n+    long l;\n+    REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+    REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+    xoperands[0] = operands[0];\n+    xoperands[1] = GEN_INT (l);\n+    if (which_alternative == 5) {\n+      if (l == 0) {\n+        if (ADDRESS_REG_P (xoperands[0]))\n+          output_asm_insn (\"sub%.l %0,%0\", xoperands);\n+        else\n+          output_asm_insn (\"clr%.l %0\", xoperands);\n+      } else\n+        if (GET_CODE (operands[0]) == MEM\n+            && symbolic_operand (XEXP (operands[0], 0), SImode))\n+          output_asm_insn (\"move%.l %1,%-;move%.l %+,%0\", xoperands);\n+        else\n+          output_asm_insn (\"move%.l %1,%0\", xoperands);\n+      return \"\";\n+    }\n+    if (l != 0)\n+      output_asm_insn (\"move%.l %1,%-;fsmove%.s %+,%0\", xoperands);\n+    else\n+      output_asm_insn (\"clr%.l %-;fsmove%.s %+,%0\", xoperands);\n+    return \"\";\n+  }\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (ADDRESS_REG_P (operands[1]))\n+        return \"move%.l %1,%-;f%$smove%.s %+,%0\";\n+      if (FP_REG_P (operands[1]))\n+        return \"f%$move%.d %1,%0\";\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+        return output_move_const_single (operands);\n+      return \"f%$move%.s %f1,%0\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (ADDRESS_REG_P (operands[0]))\n+        return \"fmove%.s %1,%-;move%.l %+,%0\";\n+      return \"fmove%.s %f1,%0\";\n+    }\n+  if (operands[1] == CONST0_RTX (SFmode))\n+    {\n+      if (ADDRESS_REG_P (operands[0]))\n+\treturn \"sub%.l %0,%0\";\n+      return \"clr%.l %0\";\n+    }\n+  return \"move%.l %1,%0\";\n+})\n+\n+(define_expand \"reload_indf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n+        (match_operand:DF 1 \"general_operand\" \"mf\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (emit_move_sequence (operands, DFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves. */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"reload_outdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+        (match_operand:DF 1 \"register_operand\" \"f\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (emit_move_sequence (operands, DFmode, operands[2]))\n+    DONE;\n+\n+  /* We don't want the clobber emitted, so handle this ourselves. */\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+  DONE;\n+})\n+\n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DF 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\")\n+{\n+  if (TARGET_COLDFIRE_FPU)\n+    if (emit_move_sequence (operands, DFmode, 0))\n+      DONE;\n+})\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=rm,rf,rf,&rof<>\")\n@@ -884,14 +1004,55 @@\n   return output_move_double (operands);\n })\n \n-(define_insn \"\"\n+(define_insn \"movdf_cf_soft\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:DF 1 \"general_operand\" \"g,r\"))]\n-  \"TARGET_COLDFIRE\"\n+  \"TARGET_COLDFIRE && !TARGET_COLDFIRE_FPU\"\n {\n   return output_move_double (operands);\n })\n \n+(define_insn \"movdf_cf_hard\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,    <Q>U,r,f,r,r,m,f\")\n+        (match_operand:DF 1 \"general_operand\"      \" f<Q>U,f,   f,r,r,m,r,E\"))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  rtx xoperands[3];\n+  REAL_VALUE_TYPE r;\n+  long l[2];\n+\n+  switch (which_alternative)\n+    {\n+    default:\n+      return \"fmove%.d %1,%0\";\n+    case 2:\n+      return \"fmove%.d %1,%-;move%.l %+,%0;move%.l %+,%R0\";\n+    case 3:\n+      return \"move%.l %R1,%-;move%.l %1,%-;f%&move%.d %+,%0\";\n+    case 4:\n+      return \"move%.l %1,%0;move%.l %R1,%R0\";\n+    case 5: case 6:\n+      return output_move_double (operands);\n+    case 7:\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n+      xoperands[0] = operands[0];\n+      xoperands[1] = GEN_INT (l[0]);\n+      xoperands[2] = GEN_INT (l[1]);\n+      if (operands[1] == CONST0_RTX (DFmode))\n+\toutput_asm_insn (\"clr%.l %-;clr%.l %-;fdmove%.d %+,%0\",\n+\t\t\txoperands);\n+      else\n+\tif (l[1] == 0)\n+\t  output_asm_insn (\"clr%.l %-;move%.l %1,%-;fdmove%.d %+,%0\",\n+\t\t\t  xoperands);\n+\telse\n+\t  output_asm_insn (\"move%.l %2,%-;move%.l %1,%-;fdmove%.d %+,%0\",\n+\t\t\t  xoperands);\n+      return \"\";\n+    }\n+})\n+\n ;; ??? The XFmode patterns are schizophrenic about whether constants are\n ;; allowed.  Most but not all have predicates and constraint that disallow\n ;; constants.  Most but not all have output templates that handle constants.\n@@ -1434,7 +1595,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:DF\n \t (match_operand:SF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n (define_insn \"\"\n@@ -1466,13 +1627,34 @@\n   return \"fmove%.d %f1,%0\";\n })\n \n+(define_insn \"extendsfdf2_cf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"general_operand\" \"f,<Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (FP_REG_P (operands[0]) && FP_REG_P (operands[1]))\n+    {\n+      if (REGNO (operands[0]) == REGNO (operands[1]))\n+\t{\n+\t  /* Extending float to double in an fp-reg is a no-op.\n+\t     NOTICE_UPDATE_CC has already assumed that the\n+\t     cc will be set.  So cancel what it did.  */\n+\t  cc_status = cc_prev_status;\n+\t  return \"\";\n+\t}\n+      return \"f%&move%.d %1,%0\";\n+    }\n+  return \"f%&move%.s %f1,%0\";\n+})\n+\n ;; This cannot output into an f-reg because there is no way to be\n ;; sure of truncating in that case.\n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(float_truncate:SF\n \t  (match_operand:DF 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n ;; On the '040 we can truncate in a register accurately and easily.\n@@ -1487,6 +1669,15 @@\n   return \"f%$move%.d %f1,%0\";\n })\n \n+(define_insn \"truncdfsf2_cf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,d<Q>U\")\n+\t(float_truncate:SF\n+\t  (match_operand:DF 1 \"general_operand\" \"<Q>U,f\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"@\n+  f%$move%.d %1,%0\n+  fmove%.s %1,%0\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=dm\")\n \t(float_truncate:SF\n@@ -1502,53 +1693,62 @@\n ;; will be recognized as SImode (which is always valid)\n ;; rather than as QImode or HImode.\n \n-(define_expand \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(float:SF (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+(define_expand \"floatsi<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(float:FP (match_operand:SI 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:SF (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n+(define_insn \"floatsi<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(float:FP (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n   \"TARGET_68881\"\n-  \"f%$move%.l %1,%0\")\n+  \"f<FP:round>move%.l %1,%0\")\n \n-(define_expand \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(float:DF (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"\")\n+(define_insn \"floatsi<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(float:FP (match_operand:SI 1 \"general_operand\" \"d<Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"f<FP:prec>move%.l %1,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n-  \"TARGET_68881\"\n-  \"f%&move%.l %1,%0\")\n \n-(define_insn \"floathisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:SF (match_operand:HI 1 \"general_operand\" \"dmn\")))]\n-  \"TARGET_68881\"\n-  \"f%$move%.w %1,%0\")\n+(define_expand \"floathi<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(float:FP (match_operand:HI 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n \n-(define_insn \"floathidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:DF (match_operand:HI 1 \"general_operand\" \"dmn\")))]\n+(define_insn \"floathi<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(float:FP (match_operand:HI 1 \"general_operand\" \"dmn\")))]\n   \"TARGET_68881\"\n   \"fmove%.w %1,%0\")\n \n-(define_insn \"floatqisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:SF (match_operand:QI 1 \"general_operand\" \"dmn\")))]\n+(define_insn \"floathi<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+        (float:FP (match_operand:HI 1 \"general_operand\" \"d<Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"fmove%.w %1,%0\")\n+\n+\n+(define_expand \"floatqi<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(float:FP (match_operand:QI 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"floatqi<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(float:FP (match_operand:QI 1 \"general_operand\" \"dmn\")))]\n   \"TARGET_68881\"\n   \"fmove%.b %1,%0\")\n \n-(define_insn \"floatqidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:DF (match_operand:QI 1 \"general_operand\" \"dmn\")))]\n-  \"TARGET_68881\"\n-  \"f%&move%.b %1,%0\")\n+(define_insn \"floatqi<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(float:FP (match_operand:QI 1 \"general_operand\" \"d<Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"fmove%.b %1,%0\")\n+\n \n ;; New routines to convert floating-point values to integers\n ;; to be used on the '040.  These should be faster than trapping\n@@ -1591,63 +1791,88 @@\n ;; Convert a float to a float whose value is an integer.\n ;; This is the first stage of converting it to an integer type.\n \n-(define_insn \"ftruncdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(fix:DF (match_operand:DF 1 \"general_operand\" \"fFm\")))]\n+(define_expand \"ftrunc<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(fix:FP (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && !TARGET_68040\"\n+  \"\")\n+\n+(define_insn \"ftrunc<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(fix:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m\")))]\n   \"TARGET_68881 && !TARGET_68040\"\n {\n   if (FP_REG_P (operands[1]))\n     return \"fintrz%.x %f1,%0\";\n-  return \"fintrz%.d %f1,%0\";\n+  return \"fintrz%.<FP:prec> %f1,%0\";\n })\n \n-(define_insn \"ftruncsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(fix:SF (match_operand:SF 1 \"general_operand\" \"dfFm\")))]\n-  \"TARGET_68881 && !TARGET_68040\"\n+(define_insn \"ftrunc<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+        (fix:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg><Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n   if (FP_REG_P (operands[1]))\n-    return \"fintrz%.x %f1,%0\";\n-  return \"fintrz%.s %f1,%0\";\n+    return \"fintrz%.d %f1,%0\";\n+  return \"fintrz%.<FP:prec> %f1,%0\";\n })\n \n ;; Convert a float whose value is an integer\n ;; to an actual integer.  Second stage of converting float to integer type.\n-(define_insn \"fixsfqi2\"\n+(define_expand \"fix<mode>qi2\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:QI (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"fix<mode>qi2_68881\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:QI (match_operand:SF 1 \"general_operand\" \"f\")))]\n+\t(fix:QI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n   \"fmove%.b %1,%0\")\n \n-(define_insn \"fixsfhi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:HI (match_operand:SF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.w %1,%0\")\n-\n-(define_insn \"fixsfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:SI (match_operand:SF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.l %1,%0\")\n-\n-(define_insn \"fixdfqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:QI (match_operand:DF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n+(define_insn \"fix<mode>qi2_cf\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n+\t(fix:QI (match_operand:FP 1 \"general_operand\" \"f\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n   \"fmove%.b %1,%0\")\n \n-(define_insn \"fixdfhi2\"\n+(define_expand \"fix<mode>hi2\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:HI (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"fix<mode>hi2_68881\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:HI (match_operand:DF 1 \"general_operand\" \"f\")))]\n+\t(fix:HI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n   \"fmove%.w %1,%0\")\n \n-(define_insn \"fixdfsi2\"\n+(define_insn \"fix<mode>hi2_cf\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n+\t(fix:HI (match_operand:FP 1 \"general_operand\" \"f\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"fmove%.w %1,%0\")\n+\n+(define_expand \"fix<mode>si2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(fix:SI (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"fix<mode>si2_68881\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:SI (match_operand:DF 1 \"general_operand\" \"f\")))]\n+\t(fix:SI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n   \"fmove%.l %1,%0\")\n+\n+(define_insn \"fix<mode>si2_cf\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n+\t(fix:SI (match_operand:FP 1 \"general_operand\" \"f\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+  \"fmove%.l %1,%0\")\n+\n \f\n ;; add instructions\n \n@@ -2099,82 +2324,54 @@\n   return \"add%.b %1,%0\";\n })\n \n-(define_expand \"adddf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+(define_expand \"add<mode>3\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(plus:FP (match_operand:FP 1 \"general_operand\" \"\")\n+\t\t (match_operand:FP 2 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:DF (float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"add<mode>3_floatsi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(plus:FP (float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&add%.l %2,%0\")\n+  \"f<FP:round>add%.l %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:DF (float:DF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"add<mode>3_floathi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(plus:FP (float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&add%.w %2,%0\")\n+  \"f<FP:round>add%.w %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:DF (float:DF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"add<mode>3_floatqi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(plus:FP (float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&add%.b %2,%0\")\n+  \"f<FP:round>add%.b %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+(define_insn \"add<mode>3_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(plus:FP (match_operand:FP 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:FP 2 \"general_operand\" \"f<FP:dreg>m<FP:const>\")))]\n   \"TARGET_68881\"\n {\n-  if (REG_P (operands[2]))\n-    return \"f%&add%.x %2,%0\";\n-  return \"f%&add%.d %f2,%0\";\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:round>add%.x %2,%0\";\n+  return \"f<FP:round>add%.<FP:prec> %f2,%0\";\n })\n \n-(define_expand \"addsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(plus:SF (match_operand:SF 1 \"general_operand\" \"\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:SF (float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"f%$add%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:SF (float:SF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"f%$add%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:SF (float:SF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"f%$add%.b %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"fdmF\")))]\n-  \"TARGET_68881\"\n+(define_insn \"add<mode>3_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(plus:FP (match_operand:FP 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:FP 2 \"general_operand\" \"f<FP:dreg><Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n-  if (REG_P (operands[2]) && ! DATA_REG_P (operands[2]))\n-    return \"f%$add%.x %2,%0\";\n-  return \"f%$add%.s %f2,%0\";\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:round>add%.d %2,%0\";\n+  return \"f<FP:round>add%.<FP:prec> %2,%0\";\n })\n \f\n ;; subtract instructions\n@@ -2336,82 +2533,54 @@\n   \"!TARGET_COLDFIRE\"\n   \"sub%.b %1,%0\")\n \n-(define_expand \"subdf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+(define_expand \"sub<mode>3\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(minus:FP (match_operand:FP 1 \"general_operand\" \"\")\n+\t\t  (match_operand:FP 2 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n+(define_insn \"sub<mode>3_floatsi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t  (float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n   \"TARGET_68881\"\n-  \"f%&sub%.l %2,%0\")\n+  \"f<FP:round>sub%.l %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (float:DF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n+(define_insn \"sub<mode>3_floathi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t  (float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n-  \"f%&sub%.w %2,%0\")\n+  \"f<FP:round>sub%.w %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (float:DF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n+(define_insn \"sub<mode>3_floatqi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t  (float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n-  \"f%&sub%.b %2,%0\")\n+  \"f<FP:round>sub%.b %2,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n+(define_insn \"sub<mode>3_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t  (match_operand:FP 2 \"general_operand\" \"f<FP:dreg>m<FP:const>\")))]\n   \"TARGET_68881\"\n {\n-  if (REG_P (operands[2]))\n-    return \"f%&sub%.x %2,%0\";\n-  return \"f%&sub%.d %f2,%0\";\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:round>sub%.x %2,%0\";\n+  return \"f<FP:round>sub%.<FP:prec> %f2,%0\";\n })\n \n-(define_expand \"subsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t  (float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n-  \"TARGET_68881\"\n-  \"f%$sub%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t  (float:SF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"f%$sub%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t  (float:SF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"f%$sub%.b %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"fdmF\")))]\n-  \"TARGET_68881\"\n+(define_insn \"sub<mode>3_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+        (minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+                  (match_operand:FP 2 \"general_operand\" \"f<FP:dreg><Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n-  if (REG_P (operands[2]) && ! DATA_REG_P (operands[2]))\n-    return \"f%$sub%.x %2,%0\";\n-  return \"f%$sub%.s %f2,%0\";\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:round>sub%.d %2,%0\";\n+  return \"f<FP:round>sub%.<FP:prec> %2,%0\";\n })\n \f\n ;; multiply instructions\n@@ -2655,35 +2824,47 @@\n   \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %3,%0:%1\")\n \n-(define_expand \"muldf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+(define_expand \"mul<mode>3\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(mult:FP (match_operand:FP 1 \"general_operand\" \"\")\n+\t\t (match_operand:FP 2 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:DF (float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"mul<mode>3_floatsi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:FP (float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&mul%.l %2,%0\")\n+{\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>mul%.l %2,%0\"\n+\t : \"f<FP:round_mul>mul%.l %2,%0\";\n+})\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:DF (float:DF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"mul<mode>3_floathi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:FP (float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&mul%.w %2,%0\")\n+{\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>mul%.w %2,%0\"\n+\t : \"f<FP:round_mul>mul%.w %2,%0\";\n+})\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:DF (float:DF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:DF 1 \"general_operand\" \"0\")))]\n+(define_insn \"mul<mode>3_floatqi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:FP (float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))\n+\t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f%&mul%.b %2,%0\")\n+{\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>mul%.b %2,%0\"\n+\t : \"f<FP:round_mul>mul%.b %2,%0\";\n+})\n \n-(define_insn \"\"\n+(define_insn \"muldf_68881\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n \t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n@@ -2701,155 +2882,107 @@\n   return \"f%&mul%.d %f2,%0\";\n })\n \n-(define_expand \"mulsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(mult:SF (match_operand:SF 1 \"general_operand\" \"\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:SF (float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-{\n-  return (TARGET_68040_ONLY\n-          ? \"fsmul%.l %2,%0\"\n-          : \"fsglmul%.l %2,%0\");\n-})\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:SF (float:SF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-{\n-  return (TARGET_68040_ONLY\n-          ? \"fsmul%.w %2,%0\"\n-          : \"fsglmul%.w %2,%0\");\n-})\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:SF (float:SF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:SF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-{\n-  return (TARGET_68040_ONLY\n-          ? \"fsmul%.b %2,%0\"\n-          : \"fsglmul%.b %2,%0\");\n-})\n-\n-(define_insn \"\"\n+(define_insn \"mulsf_68881\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n \t\t (match_operand:SF 2 \"general_operand\" \"fdmF\")))]\n   \"TARGET_68881\"\n {\n-  if (REG_P (operands[2]) && ! DATA_REG_P (operands[2]))\n+  if (FP_REG_P (operands[2]))\n     return (TARGET_68040_ONLY\n \t    ? \"fsmul%.x %2,%0\"\n \t    : \"fsglmul%.x %2,%0\");\n   return (TARGET_68040_ONLY\n \t  ? \"fsmul%.s %f2,%0\"\n \t  : \"fsglmul%.s %f2,%0\");\n })\n-\f\n-;; divide instructions\n-\n-(define_expand \"divdf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(float:DF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n-  \"TARGET_68881\"\n-  \"f%&div%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(float:DF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"f%&div%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(float:DF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n+(define_insn \"mulxf3_68881\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:XF (match_operand:XF 1 \"nonimmediate_operand\" \"%0\")\n+\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"fm\")))]\n   \"TARGET_68881\"\n-  \"f%&div%.b %2,%0\")\n+{\n+  return \"fmul%.x %f2,%0\";\n+})\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_68881\"\n+(define_insn \"fmul<mode>3_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(mult:FP (match_operand:FP 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:FP 2 \"general_operand\" \"f<Q>U<FP:dreg>\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n-  if (REG_P (operands[2]))\n-    return \"f%&div%.x %2,%0\";\n-  return \"f%&div%.d %f2,%0\";\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:prec>mul%.d %2,%0\";\n+  return \"f<FP:prec>mul%.<FP:prec> %2,%0\";\n })\n+\f\n+;; divide instructions\n \n-(define_expand \"divsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"\")))]\n-  \"TARGET_68881\"\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"\")\n+\t\t(match_operand:FP 2 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t(float:SF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n+(define_insn \"div<mode>3_floatsi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t(float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n   \"TARGET_68881\"\n {\n-  return (TARGET_68040_ONLY\n-          ? \"fsdiv%.l %2,%0\"\n-          : \"fsgldiv%.l %2,%0\");\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>div%.l %2,%0\"\n+\t : \"f<FP:round_mul>div%.l %2,%0\";\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t(float:SF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n+(define_insn \"div<mode>3_floathi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t(float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n {\n-  return (TARGET_68040_ONLY\n-          ? \"fsdiv%.w %2,%0\"\n-          : \"fsgldiv%.w %2,%0\");\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>div%.w %2,%0\"\n+\t : \"f<FP:round_mul>div%.w %2,%0\";\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t(float:SF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n+(define_insn \"div<mode>3_floatqi_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t(float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n {\n-  return (TARGET_68040_ONLY\n-          ? \"fsdiv%.b %2,%0\"\n-          : \"fsgldiv%.b %2,%0\");\n+  return TARGET_68040_ONLY\n+\t ? \"f<FP:round>div%.b %2,%0\"\n+\t : \"f<FP:round_mul>div%.b %2,%0\";\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"fdmF\")))]\n+(define_insn \"div<mode>3_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t(match_operand:FP 2 \"general_operand\" \"f<FP:dreg>m<FP:const>\")))]\n   \"TARGET_68881\"\n {\n-  if (REG_P (operands[2]) && ! DATA_REG_P (operands[2]))\n+  if (FP_REG_P (operands[2]))\n     return (TARGET_68040_ONLY\n-\t    ? \"fsdiv%.x %2,%0\"\n-\t    : \"fsgldiv%.x %2,%0\");\n+\t    ? \"f<FP:round>div%.x %2,%0\"\n+\t    : \"f<FP:round_mul>div%.x %2,%0\");\n   return (TARGET_68040_ONLY\n-\t  ? \"fsdiv%.s %f2,%0\"\n-\t  : \"fsgldiv%.s %f2,%0\");\n+\t  ? \"f<FP:round>div%.<FP:prec> %f2,%0\"\n+\t  : \"f<FP:round_mul>div%.<FP:prec> %f2,%0\");\n+})\n+\n+(define_insn \"div<mode>3_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(div:FP (match_operand:FP 1 \"general_operand\" \"0\")\n+\t\t(match_operand:FP 2 \"general_operand\" \"f<Q>U<FP:dreg>\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (FP_REG_P (operands[2]))\n+    return \"f<FP:prec>div%.d %2,%0\";\n+  return \"f<FP:prec>div%.<FP:prec> %2,%0\";\n })\n \f\n ;; Remainder instructions.\n@@ -3580,7 +3713,7 @@\n \t(neg:SF (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_68881)\n+  if (!TARGET_HARD_FLOAT)\n     {\n       rtx result;\n       rtx target;\n@@ -3600,27 +3733,12 @@\n     }\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,d\")\n-\t(neg:SF (match_operand:SF 1 \"general_operand\" \"fdmF,0\")))]\n-  \"TARGET_68881\"\n-{\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      operands[1] = GEN_INT (31);\n-      return \"bchg %1,%0\";\n-    }\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"f%$neg%.x %1,%0\";\n-  return \"f%$neg%.s %f1,%0\";\n-})\n-\n (define_expand \"negdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"general_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_68881)\n+  if (!TARGET_HARD_FLOAT)\n     {\n       rtx result;\n       rtx target;\n@@ -3647,45 +3765,97 @@\n     }\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,d\")\n-\t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF,0\")))]\n+(define_expand \"negxf2\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, XFmode);\n+      result = expand_binop (SImode, xor_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n+\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n+      gcc_assert (result);\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 1, XFmode));\n+      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 2, XFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"neg<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f,d\")\n+\t(neg:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m<FP:const>,0\")))]\n   \"TARGET_68881\"\n {\n   if (DATA_REG_P (operands[0]))\n     {\n       operands[1] = GEN_INT (31);\n       return \"bchg %1,%0\";\n     }\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"f%&neg%.x %1,%0\";\n-  return \"f%&neg%.d %f1,%0\";\n+  if (FP_REG_P (operands[1]))\n+    return \"f<FP:round>neg%.x %1,%0\";\n+  return \"f<FP:round>neg%.<FP:prec> %f1,%0\";\n+})\n+\n+(define_insn \"neg<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f,d\")\n+\t(neg:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg><Q>U,0\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n+{\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      operands[1] = GEN_INT (31);\n+      return \"bchg %1,%0\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    return \"f<FP:prec>neg%.d %1,%0\";\n+  return \"f<FP:prec>neg%.<FP:prec> %1,%0\";\n })\n \f\n ;; Sqrt instruction for the 68881\n \n-(define_insn \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(sqrt:SF (match_operand:SF 1 \"general_operand\" \"fm\")))]\n+(define_expand \"sqrt<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"\")\n+\t(sqrt:FP (match_operand:FP 1 \"general_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\")\n+\n+(define_insn \"sqrt<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(sqrt:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m\")))]\n   \"TARGET_68881\"\n {\n   if (FP_REG_P (operands[1]))\n-    return \"f%$sqrt%.x %1,%0\";\n-  else\n-    return \"f%$sqrt%.s %1,%0\";\n+    return \"f<FP:round>sqrt%.x %1,%0\";\n+  return \"f<FP:round>sqrt%.<FP:prec> %1,%0\";\n })\n \n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(sqrt:DF (match_operand:DF 1 \"general_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n+(define_insn \"sqrt<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(sqrt:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg><Q>U\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n   if (FP_REG_P (operands[1]))\n-    return \"f%&sqrt%.x %1,%0\";\n-  else\n-    return \"f%&sqrt%.d %1,%0\";\n+    return \"f<FP:prec>sqrt%.d %1,%0\";\n+  return \"f<FP:prec>sqrt%.<FP:prec> %1,%0\";\n })\n-\n ;; Absolute value instructions\n ;; If using software floating point, just zero the sign bit.\n \n@@ -3694,7 +3864,7 @@\n \t(abs:SF (match_operand:SF 1 \"general_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_68881)\n+  if (!TARGET_HARD_FLOAT)\n     {\n       rtx result;\n       rtx target;\n@@ -3714,22 +3884,12 @@\n     }\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"general_operand\" \"fdmF\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"f%$abs%.x %1,%0\";\n-  return \"f%$abs%.s %f1,%0\";\n-})\n-\n (define_expand \"absdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(abs:DF (match_operand:DF 1 \"general_operand\" \"\")))]\n   \"\"\n {\n-  if (!TARGET_68881)\n+  if (!TARGET_HARD_FLOAT)\n     {\n       rtx result;\n       rtx target;\n@@ -3756,14 +3916,68 @@\n     }\n })\n \n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n-  \"TARGET_68881\"\n+(define_expand \"absxf2\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_68881)\n+    {\n+      rtx result;\n+      rtx target;\n+      rtx insns;\n+\n+      start_sequence ();\n+      target = operand_subword (operands[0], 0, 1, XFmode);\n+      result = expand_binop (SImode, and_optab,\n+\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n+\t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n+      gcc_assert (result);\n+\n+      if (result != target)\n+\temit_move_insn (result, target);\n+\n+      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 1, XFmode));\n+      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n+\t\t      operand_subword_force (operands[1], 2, XFmode));\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"abs<mode>2_68881\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f,d\")\n+\t(abs:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m<FP:const>,0\")))]\n+  \"TARGET_68881\"\n+{\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      operands[1] = GEN_INT (31);\n+      return \"bclr %1,%0\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    return \"f<FP:round>abs%.x %1,%0\";\n+  return \"f<FP:round>abs%.<FP:prec> %f1,%0\";\n+})\n+\n+(define_insn \"abs<mode>2_cf\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f,d\")\n+\t(abs:FP (match_operand:FP 1 \"general_operand\" \"f<FP:dreg><Q>U,0\")))]\n+  \"TARGET_COLDFIRE_FPU\"\n {\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"f%&abs%.x %1,%0\";\n-  return \"f%&abs%.d %f1,%0\";\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      operands[1] = GEN_INT (31);\n+      return \"bclr %1,%0\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    return \"f<FP:prec>abs%.d %1,%0\";\n+  return \"f<FP:prec>abs%.<FP:prec> %1,%0\";\n })\n \f\n ;; one complement instructions\n@@ -4987,7 +5201,8 @@\n \t(eq:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -5008,7 +5223,8 @@\n \t(ne:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -5029,7 +5245,8 @@\n \t(gt:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -5065,7 +5282,8 @@\n \t(lt:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -5101,7 +5319,8 @@\n \t(ge:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -5137,7 +5356,8 @@\n \t(le:QI (cc0) (const_int 0)))]\n   \"\"\n {\n-  if (TARGET_68060 && m68k_last_compare_had_fp_operands)\n+  if ((TARGET_68060 || TARGET_COLDFIRE_FPU)\n+      && m68k_last_compare_had_fp_operands)\n     {\n       m68k_last_compare_had_fp_operands = 0;\n       FAIL;\n@@ -6614,46 +6834,6 @@\n })\n \n \f\n-(define_expand \"tstxf\"\n-  [(set (cc0)\n-\t(match_operand:XF 0 \"nonimmediate_operand\" \"\"))]\n-  \"TARGET_68881\"\n-  \"m68k_last_compare_had_fp_operands = 1;\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(match_operand:XF 0 \"nonimmediate_operand\" \"fm\"))]\n-  \"TARGET_68881\"\n-{\n-  cc_status.flags = CC_IN_68881;\n-  return \"ftst%.x %0\";\n-})\n-\n-(define_expand \"cmpxf\"\n-  [(set (cc0)\n-\t(compare (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_68881\"\n-  \"m68k_last_compare_had_fp_operands = 1;\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:XF 0 \"nonimmediate_operand\" \"f,m\")\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"fm,f\")))]\n-  \"TARGET_68881\"\n-{\n-  cc_status.flags = CC_IN_68881;\n-  if (REG_P (operands[0]))\n-    {\n-      if (REG_P (operands[1]))\n-\treturn \"fcmp%.x %1,%0\";\n-      else\n-        return \"fcmp%.x %f1,%0\";\n-    }\n-  cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.x %f0,%1\";\n-})\n-\n (define_insn \"extendsfxf2\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=fm,f\")\n \t(float_extend:XF (match_operand:SF 1 \"general_operand\" \"f,rmF\")))]\n@@ -6735,337 +6915,30 @@\n   return \"fmove%.d %f1,%0\";\n })\n \n-(define_insn \"truncxfsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=dm\")\n-\t(float_truncate:SF\n-\t  (match_operand:XF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.s %f1,%0\")\n-\n-(define_insn \"floatsixf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:XF (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.l %1,%0\")\n-\n-(define_insn \"floathixf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:XF (match_operand:HI 1 \"general_operand\" \"dmn\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.w %1,%0\")\n-\n-(define_insn \"floatqixf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(float:XF (match_operand:QI 1 \"general_operand\" \"dmn\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.b %1,%0\")\n-\n-(define_insn \"ftruncxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(fix:XF (match_operand:XF 1 \"general_operand\" \"fFm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (FP_REG_P (operands[1]))\n-    return \"fintrz%.x %f1,%0\";\n-  return \"fintrz%.x %f1,%0\";\n-})\n-\n-(define_insn \"fixxfqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:QI (match_operand:XF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.b %1,%0\")\n-\n-(define_insn \"fixxfhi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:HI (match_operand:XF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.w %1,%0\")\n-\n-(define_insn \"fixxfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n-\t(fix:SI (match_operand:XF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_68881\"\n-  \"fmove%.l %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:XF (float:XF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fadd%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:XF (float:XF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fadd%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:XF (float:XF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:XF 1 \"general_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fadd%.b %2,%0\")\n-\n-(define_insn \"addxf3\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(plus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"%0\")\n-\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"fadd%.x %2,%0\";\n-  return \"fadd%.x %f2,%0\";\n-})\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t  (float:XF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n-  \"TARGET_68881\"\n-  \"fsub%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t  (float:XF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"fsub%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t  (float:XF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"fsub%.b %2,%0\")\n-\n-(define_insn \"subxf3\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(minus:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t  (match_operand:XF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"fsub%.x %2,%0\";\n-  return \"fsub%.x %f2,%0\";\n-})\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:XF (float:XF (match_operand:SI 2 \"general_operand\" \"dmi\"))\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fmul%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:XF (float:XF (match_operand:HI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fmul%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:XF (float:XF (match_operand:QI 2 \"general_operand\" \"dmn\"))\n-\t\t (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68881\"\n-  \"fmul%.b %2,%0\")\n-\n-(define_insn \"mulxf3\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(mult:XF (match_operand:XF 1 \"nonimmediate_operand\" \"%0\")\n-\t\t (match_operand:XF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"fmul%.x %2,%0\";\n-  return \"fmul%.x %f2,%0\";\n-})\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t(float:XF (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n-  \"TARGET_68881\"\n-  \"fdiv%.l %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t(float:XF (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"fdiv%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t(float:XF (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n-  \"TARGET_68881\"\n-  \"fdiv%.b %2,%0\")\n-\n-(define_insn \"divxf3\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(div:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")\n-\t\t(match_operand:XF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[2]))\n-    return \"fdiv%.x %2,%0\";\n-  return \"fdiv%.x %f2,%0\";\n-})\n-\n-(define_expand \"negxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_68881)\n-    {\n-      rtx result;\n-      rtx target;\n-      rtx insns;\n-\n-      start_sequence ();\n-      target = operand_subword (operands[0], 0, 1, XFmode);\n-      result = expand_binop (SImode, xor_optab,\n-\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n-\t\t\t     GEN_INT (0x80000000), target, 0, OPTAB_WIDEN);\n-      gcc_assert (result);\n-\n-      if (result != target)\n-\temit_move_insn (result, target);\n-\n-      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n-\t\t      operand_subword_force (operands[1], 1, XFmode));\n-      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n-\t\t      operand_subword_force (operands[1], 2, XFmode));\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"negxf2_68881\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"fneg%.x %1,%0\";\n-  return \"fneg%.x %f1,%0\";\n-})\n-\n-(define_expand \"absxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-{\n-  if (!TARGET_68881)\n-    {\n-      rtx result;\n-      rtx target;\n-      rtx insns;\n-\n-      start_sequence ();\n-      target = operand_subword (operands[0], 0, 1, XFmode);\n-      result = expand_binop (SImode, and_optab,\n-\t\t\t     operand_subword_force (operands[1], 0, XFmode),\n-\t\t\t     GEN_INT (0x7fffffff), target, 0, OPTAB_WIDEN);\n-      gcc_assert (result);\n-\n-      if (result != target)\n-\temit_move_insn (result, target);\n-\n-      emit_move_insn (operand_subword (operands[0], 1, 1, XFmode),\n-\t\t      operand_subword_force (operands[1], 1, XFmode));\n-      emit_move_insn (operand_subword (operands[0], 2, 1, XFmode),\n-\t\t      operand_subword_force (operands[1], 2, XFmode));\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"absxf2_68881\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-{\n-  if (REG_P (operands[1]) && ! DATA_REG_P (operands[1]))\n-    return \"fabs%.x %1,%0\";\n-  return \"fabs%.x %f1,%0\";\n-})\n-\n-(define_insn \"sqrtxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(sqrt:XF (match_operand:XF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_68881\"\n-  \"fsqrt%.x %1,%0\")\n-\n-(define_insn \"sinsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"general_operand\" \"fm\")] UNSPEC_SIN))]\n-  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n-{\n-  if (FP_REG_P (operands[1]))\n-    return \"fsin%.x %1,%0\";\n-  else\n-    return \"fsin%.s %1,%0\";\n-})\n-\n-(define_insn \"sindf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:DF 1 \"general_operand\" \"fm\")] UNSPEC_SIN))]\n+(define_insn \"sin<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(unspec:FP\n+\t  [(match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m\")] UNSPEC_SIN))]\n   \"TARGET_68881 && flag_unsafe_math_optimizations\"\n {\n   if (FP_REG_P (operands[1]))\n     return \"fsin%.x %1,%0\";\n   else\n-    return \"fsin%.d %1,%0\";\n-})\n-\n-(define_insn \"sinxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:XF [(match_operand:XF 1 \"nonimmediate_operand\" \"fm\")] UNSPEC_SIN))]\n-  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n-  \"fsin%.x %1,%0\")\n-\n-(define_insn \"cossf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 1 \"general_operand\" \"fm\")] UNSPEC_COS))]\n-  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n-{\n-  if (FP_REG_P (operands[1]))\n-    return \"fcos%.x %1,%0\";\n-  else\n-    return \"fcos%.s %1,%0\";\n+    return \"fsin%.<FP:prec> %1,%0\";\n })\n \n-(define_insn \"cosdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:DF 1 \"general_operand\" \"fm\")] UNSPEC_COS))]\n+(define_insn \"cos<mode>2\"\n+  [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n+\t(unspec:FP\n+\t  [(match_operand:FP 1 \"general_operand\" \"f<FP:dreg>m\")] UNSPEC_COS))]\n   \"TARGET_68881 && flag_unsafe_math_optimizations\"\n {\n   if (FP_REG_P (operands[1]))\n     return \"fcos%.x %1,%0\";\n   else\n-    return \"fcos%.d %1,%0\";\n+    return \"fcos%.<FP:prec> %1,%0\";\n })\n \n-(define_insn \"cosxf2\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f\")\n-\t(unspec:XF [(match_operand:XF 1 \"nonimmediate_operand\" \"fm\")] UNSPEC_COS))]\n-  \"TARGET_68881 && flag_unsafe_math_optimizations\"\n-  \"fcos%.x %1,%0\")\n-\n (define_insn \"trap\"\n   [(trap_if (const_int -1) (const_int 7))]\n   \"\""}, {"sha": "ec2c46655e77b538e2ba2ad123b9fba91e6ebe9e", "filename": "gcc/config/m68k/m68k.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68k.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.opt?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,6 +1,6 @@\n ; Options for the Motorola 68000 port of the compiler.\n \n-; Copyright (C) 2005 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -39,6 +39,10 @@ m5407\n Target RejectNegative Mask(CFV4)\n Generate code for a 5407\n \n+mcfv4e\n+Target RejectNegative Mask(CFV4E)\n+Generate code for a ColdFire v4e\n+\n m68000\n Target RejectNegative\n Generate code for a 68000"}, {"sha": "f7beb90b0af2defc8c4a680e7cb7ff0f7ce71e64", "filename": "gcc/config/m68k/m68kemb.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68kemb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fm68kemb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kemb.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,6 +1,7 @@\n /* Definitions of target machine for GNU compiler.  \"embedded\" 68XXX.\n    This is meant to be included after m68k.h.\n-   Copyright (C) 1994, 1995, 1998, 1999, 2004 Free Software Foundation, Inc.  */\n+   Copyright (C) 1994, 1995, 1998, 1999, 2004, 2006\n+   Free Software Foundation, Inc.  */\n \n /* Override the SVR4 ABI for this target.  */\n \n@@ -21,19 +22,12 @@\n    and unions in registers, which is slightly more efficient.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-/* Return floating point values in a fp register.  This make fp code a\n-   little bit faster.  It also makes -msoft-float code incompatible with\n-   -m68881 code, so people have to be careful not to mix the two.  */\n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE,FUNC) LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n \n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n- gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t      ((TARGET_68881\t\t\t\t\t\\\n-\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n-\t\t    || (MODE) == XFmode))\t\t\t\\\n-           ? 16 : 0))\n+  m68k_libcall_value (MODE)\n \n #undef FUNCTION_VALUE_REGNO_P\n #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (TARGET_68881 && (N) == 16))"}, {"sha": "afec0bb3e57c1ac77e07123cbd530bfb25e245df", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler,\n    for m68k (including m68010) NetBSD platforms using the\n    ELF object format.\n-   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2006 Free Software Foundation, Inc.\n    Contributed by Wasabi Systems. Inc.\n \n    This file is derived from <m68k/m68kv4.h>, <m68k/m68kelf.h>,\n@@ -307,11 +307,7 @@ while (0)\n \n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n-  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n-   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\t\t\\\n-   : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\t\t\\\n-      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\t\t\\\n-      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n+  m68k_function_value (VALTYPE, FUNC)\n \n \n /* For compatibility with the large body of existing code which does\n@@ -339,10 +335,7 @@ while (0)\n \n #undef LIBCALL_VALUE\n #define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  ((((MODE) == SFmode || (MODE) == DFmode || (MODE) == XFmode)\t\t\\\n-    && TARGET_68881)\t\t\t\t\t\t\t\\\n-   ? gen_rtx_REG (MODE, 16)\t\t\t\t\t\t\\\n-   : gen_rtx_REG (MODE, 0))\n+  m68k_libcall_value (MODE)\n \n \n /* Boundary (in *bits*) on which stack pointer should be aligned."}, {"sha": "ecf738f491991a50fed9d641f74587a7e38879a5", "filename": "gcc/config/m68k/t-m68kelf", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-m68kelf?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -12,14 +12,15 @@ xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n \techo '#define EXTFLOAT' > xfgnulib.c\n \tcat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c\n \n-MULTILIB_OPTIONS = m68000/m68020/m5200/m5206e/m528x/m5307/m5407/mcpu32/m68040/m68060 m68881/msoft-float\n+MULTILIB_OPTIONS = m68000/m68020/m5200/m5206e/m528x/m5307/m5407/mcfv4e/mcpu32/m68040/m68060 m68881/msoft-float\n MULTILIB_DIRNAMES =\n MULTILIB_MATCHES = m68000=mc68000 m68000=m68302 mcpu32=m68332 m68020=mc68020 m5206e=m5272\n MULTILIB_EXCEPTIONS = m68000/msoft-float m5200/m68881 m5200/msoft-float \\\n \t\t    m5206e/m68881 m5206e/msoft-float m528x/m68881 m528x/msoft-float \\\n \t\t    m5307/m68881 m5307/msoft-float m5407/m68881 m5407/msoft-float \\\n \t\t    mcpu32/m68881 mcpu32/msoft-float m68040/m68881 m68040/msoft-float \\\n-\t\t    m68060/m68881 m68060/msoft-float \n+\t\t    m68060/m68881 m68060/msoft-float \\\n+\t\t    mcfv4e/msoft-float mcfv4e/m68881\n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n "}, {"sha": "1a21c00105b553e62379fdc70869805e4a604548", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcc21c4c0ae5f44c048e5f016357730395491c8e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dcc21c4c0ae5f44c048e5f016357730395491c8e", "patch": "@@ -565,7 +565,8 @@ Objective-C and Objective-C++ Dialects}.\n \n @emph{M680x0 Options}\n @gccoptlist{-m68000  -m68020  -m68020-40  -m68020-60  -m68030  -m68040 @gol\n--m68060  -mcpu32  -m5200  -m68881  -mbitfield  -mc68000  -mc68020   @gol\n+-m68060  -mcpu32  -m5200  -mcfv4e -m68881  -mbitfield  @gol\n+-mc68000  -mc68020   @gol\n -mnobitfield  -mrtd  -mshort  -msoft-float  -mpcrel @gol\n -malign-int  -mstrict-align  -msep-data  -mno-sep-data @gol\n -mshared-library-id=n  -mid-shared-library  -mno-id-shared-library}\n@@ -9906,6 +9907,10 @@ when the compiler is configured for 520X-based systems.\n Use this option for microcontroller with a 5200 core, including\n the MCF5202, MCF5203, MCF5204 and MCF5202.\n \n+@item -mcfv4e\n+@opindex mcfv4e\n+Generate output for a ColdFire V4e family cpu (e.g.@: 547x/548x).\n+This includes use of hardware floating point instructions.\n \n @item -m68020-40\n @opindex m68020-40"}]}