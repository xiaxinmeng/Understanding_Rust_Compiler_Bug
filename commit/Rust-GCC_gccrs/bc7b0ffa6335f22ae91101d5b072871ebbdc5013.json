{"sha": "bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM3YjBmZmE2MzM1ZjIyYWU5MTEwMWQ1YjA3Mjg3MWViYmRjNTAxMw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-03-08T08:27:56Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-03-08T08:27:56Z"}, "message": "[LVU] reset view at function entry, omit views at line zero\n\nLocation views might be associated with locations that lack line\nnumber information (line number zero), but since we omit .loc\ndirectives that would have been issued with line number zero, we also\nomit the symbolic view numbers that would have been issued at such\npoints.\n\nResetting views at function entry points address some of these issues,\nand alleviate the huge chains of symbolic views that have burdened\nassemblers since we disabled -ginternal-reset-location-views by\ndefault, but other problems of undefined views remain when it's not\nthe whole function that lacks line number info, just parts of it.\n\nSo, when we encounter a request to output a view that may have been\nreferenced, but we decide to omit the .loc because the line is zero,\nwe will now omit the view as well, i.e., we will internally regard\nthat view as zero-numbered.\n\nfor  gcc/ChangeLog\n\n\tPR debug/84404\n\tPR debug/84408\n\t* dwarf2out.c (struct dw_line_info_table): Update comments for\n\tview == -1.\n\t(FORCE_RESET_NEXT_VIEW): New.\n\t(FORCE_RESETTING_VIEW_P): New.\n\t(RESETTING_VIEW_P): Check for -1 too.\n\t(ZERO_VIEW_P): Likewise.\n\t(new_line_info_table): Force-reset next view.\n\t(dwarf2out_begin_function): Likewise.\n\t(dwarf2out_source_line): Simplify zero_view_p initialization.\n\tTest FORCE_RESETTING_VIEW_P and RESETTING_VIEW_P instead of\n\tview directly.  Omit view when omitting .loc at line 0.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR debug/84404\n\tPR debug/84408\n\t* gcc.dg/graphite/pr84404.c: New.\n\nFrom-SVN: r258355", "tree": {"sha": "a829480cefdbd86c13e092a243152e08c035a61f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a829480cefdbd86c13e092a243152e08c035a61f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/comments", "author": null, "committer": null, "parents": [{"sha": "ce8b1a1f132aff97d670bd326dd89ae318cd3c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce8b1a1f132aff97d670bd326dd89ae318cd3c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce8b1a1f132aff97d670bd326dd89ae318cd3c68"}], "stats": {"total": 129, "additions": 109, "deletions": 20}, "files": [{"sha": "17ca051686e1b937d0c9b2c1073abfc90f31d1d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "patch": "@@ -1,3 +1,19 @@\n+2018-03-08  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/84404\n+\tPR debug/84408\n+\t* dwarf2out.c (struct dw_line_info_table): Update comments for\n+\tview == -1.\n+\t(FORCE_RESET_NEXT_VIEW): New.\n+\t(FORCE_RESETTING_VIEW_P): New.\n+\t(RESETTING_VIEW_P): Check for -1 too.\n+\t(ZERO_VIEW_P): Likewise.\n+\t(new_line_info_table): Force-reset next view.\n+\t(dwarf2out_begin_function): Likewise.\n+\t(dwarf2out_source_line): Simplify zero_view_p initialization.\n+\tTest FORCE_RESETTING_VIEW_P and RESETTING_VIEW_P instead of\n+\tview directly.  Omit view when omitting .loc at line 0.\n+\n 2018-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84740"}, {"sha": "0348f4460e983e12480e0f68a4f70721625731e5", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "patch": "@@ -2940,8 +2940,8 @@ struct GTY(()) dw_line_info_table {\n      If it is 0, it is known that the NEXT view will be the first view\n      at the given PC.\n \n-     If it is -1, we've advanced PC but we haven't emitted a line location yet,\n-     so we shouldn't use this view number.\n+     If it is -1, we're forcing the view number to be reset, e.g. at a\n+     function entry.\n \n      The meaning of other nonzero values depends on whether we're\n      computing views internally or leaving it for the assembler to do\n@@ -2951,8 +2951,10 @@ struct GTY(()) dw_line_info_table {\n      going to ask the assembler to assign.  */\n   var_loc_view view;\n \n+#define FORCE_RESET_NEXT_VIEW(x) ((x) = (var_loc_view)-1)\n #define RESET_NEXT_VIEW(x) ((x) = (var_loc_view)0)\n-#define RESETTING_VIEW_P(x) ((x) == (var_loc_view)0)\n+#define FORCE_RESETTING_VIEW_P(x) ((x) == (var_loc_view)-1)\n+#define RESETTING_VIEW_P(x) ((x) == (var_loc_view)0 || FORCE_RESETTING_VIEW_P (x))\n \n   vec<dw_line_info_entry, va_gc> *entries;\n };\n@@ -2985,7 +2987,7 @@ maybe_reset_location_view (rtx_insn *insn, dw_line_info_table *table)\n   else if (get_attr_min_length (insn) > 0)\n     reset = 1;\n \n-  if (reset > 0)\n+  if (reset > 0 && !RESETTING_VIEW_P (table->view))\n     RESET_NEXT_VIEW (table->view);\n }\n \n@@ -3235,9 +3237,10 @@ static GTY(()) bitmap zero_view_p;\n    that must be view number zero.  Otherwise, ZERO_VIEW_P is allocated\n    and views label numbers recorded in it are the ones known to be\n    zero.  */\n-#define ZERO_VIEW_P(N) (zero_view_p\t\t\t\t\\\n-\t\t\t? bitmap_bit_p (zero_view_p, (N))\t\\\n-\t\t\t: (N) == 0)\n+#define ZERO_VIEW_P(N) ((N) == (var_loc_view)0\t\t\t\t\\\n+\t\t\t|| (N) == (var_loc_view)-1\t\t\t\\\n+\t\t\t|| (zero_view_p\t\t\t\t\t\\\n+\t\t\t    && bitmap_bit_p (zero_view_p, (N))))\n \n /* Return true iff we're to emit .loc directives for the assembler to\n    generate line number sections.\n@@ -27212,6 +27215,18 @@ dwarf2out_var_location (rtx_insn *loc_note)\n \t  last_postcall_label = ggc_strdup (loclabel);\n \t}\n       newloc->label = last_postcall_label;\n+      /* ??? This view is at last_label, not last_label-1, but we\n+\t could only assume view at last_label-1 is zero if we could\n+\t assume calls always have length greater than one.  This is\n+\t probably true in general, though there might be a rare\n+\t exception to this rule, e.g. if a call insn is optimized out\n+\t by target magic.  Then, even the -1 in the label will be\n+\t wrong, which might invalidate the range.  Anyway, using view,\n+\t though technically possibly incorrect, will work as far as\n+\t ranges go: since L-1 is in the middle of the call insn,\n+\t (L-1).0 and (L-1).V shouldn't make any difference, and having\n+\t the loclist entry refer to the .loc entry might be useful, so\n+\t leave it like this.  */\n       newloc->view = view;\n     }\n \n@@ -27393,7 +27408,7 @@ new_line_info_table (void)\n   table->file_num = 1;\n   table->line_num = 1;\n   table->is_stmt = DWARF_LINE_DEFAULT_IS_STMT_START;\n-  RESET_NEXT_VIEW (table->view);\n+  FORCE_RESET_NEXT_VIEW (table->view);\n \n   return table;\n }\n@@ -27477,6 +27492,7 @@ dwarf2out_begin_function (tree fun)\n   tail_call_site_count = 0;\n \n   set_cur_line_info_table (sec);\n+  FORCE_RESET_NEXT_VIEW (cur_line_info_table->view);\n }\n \n /* Helper function of dwarf2out_end_function, called only after emitting\n@@ -27574,10 +27590,44 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n {\n   unsigned int file_num;\n   dw_line_info_table *table;\n+  static var_loc_view lvugid;\n \n-  if (debug_info_level < DINFO_LEVEL_TERSE || line == 0)\n+  if (debug_info_level < DINFO_LEVEL_TERSE)\n     return;\n \n+  table = cur_line_info_table;\n+\n+  if (line == 0)\n+    {\n+      if (debug_variable_location_views\n+\t  && output_asm_line_debug_info ()\n+\t  && table && !RESETTING_VIEW_P (table->view))\n+\t{\n+\t  /* If we're using the assembler to compute view numbers, we\n+\t     can't issue a .loc directive for line zero, so we can't\n+\t     get a view number at this point.  We might attempt to\n+\t     compute it from the previous view, but since we're\n+\t     omitting the line number entry, we might as well omit the\n+\t     view number as well.  That means pretending it's a view\n+\t     number zero, which might very well turn out to be\n+\t     correct.  */\n+\t  if (!zero_view_p)\n+\t    zero_view_p = BITMAP_GGC_ALLOC ();\n+\t  bitmap_set_bit (zero_view_p, table->view);\n+\t  if (flag_debug_asm)\n+\t    {\n+\t      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t      ASM_GENERATE_INTERNAL_LABEL (label, \"LVU\", table->view);\n+\t      fprintf (asm_out_file, \"\\t%s line 0, omitted view \",\n+\t\t       ASM_COMMENT_START);\n+\t      assemble_name (asm_out_file, label);\n+\t      putc ('\\n', asm_out_file);\n+\t    }\n+\t  table->view = ++lvugid;\n+\t}\n+      return;\n+    }\n+\n   /* The discriminator column was added in dwarf4.  Simplify the below\n      by simply removing it if we're not supposed to output it.  */\n   if (dwarf_version < 4 && dwarf_strict)\n@@ -27586,7 +27636,6 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n   if (!debug_column_info)\n     column = 0;\n \n-  table = cur_line_info_table;\n   file_num = maybe_emit_file (lookup_filename (filename));\n \n   /* ??? TODO: Elide duplicate line number entries.  Traditionally,\n@@ -27648,13 +27697,6 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t}\n       if (debug_variable_location_views)\n \t{\n-\t  static var_loc_view lvugid;\n-\t  if (!lvugid)\n-\t    {\n-\t      gcc_assert (!zero_view_p);\n-\t      zero_view_p = BITMAP_GGC_ALLOC ();\n-\t      bitmap_set_bit (zero_view_p, 0);\n-\t    }\n \t  if (!RESETTING_VIEW_P (table->view))\n \t    {\n \t      /* When we're using the assembler to compute view\n@@ -27675,7 +27717,7 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t    }\n \t  else\n \t    {\n-\t      if (!table->in_use)\n+\t      if (FORCE_RESETTING_VIEW_P (table->view))\n \t\tfputs (\" view -0\", asm_out_file);\n \t      else\n \t\tfputs (\" view 0\", asm_out_file);\n@@ -27686,6 +27728,8 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \t\t known to be zero, because then we may be able to\n \t\t optimize out locviews that are all zeros, so take\n \t\t note of it in zero_view_p.  */\n+\t      if (!zero_view_p)\n+\t\tzero_view_p = BITMAP_GGC_ALLOC ();\n \t      bitmap_set_bit (zero_view_p, lvugid);\n \t      table->view = ++lvugid;\n \t    }\n@@ -27698,17 +27742,22 @@ dwarf2out_source_line (unsigned int line, unsigned int column,\n \n       targetm.asm_out.internal_label (asm_out_file, LINE_CODE_LABEL, label_num);\n \n-      if (debug_variable_location_views && table->view)\n+      if (debug_variable_location_views && !RESETTING_VIEW_P (table->view))\n \tpush_dw_line_info_entry (table, LI_adv_address, label_num);\n       else\n \tpush_dw_line_info_entry (table, LI_set_address, label_num);\n       if (debug_variable_location_views)\n \t{\n+\t  bool resetting = FORCE_RESETTING_VIEW_P (table->view);\n+\t  if (resetting)\n+\t    table->view = 0;\n+\n \t  if (flag_debug_asm)\n \t    fprintf (asm_out_file, \"\\t%s view %s%d\\n\",\n \t\t     ASM_COMMENT_START,\n-\t\t     table->in_use ? \"\" : \"-\",\n+\t\t     resetting ? \"-\" : \"\",\n \t\t     table->view);\n+\n \t  table->view++;\n \t}\n       if (file_num != table->file_num)"}, {"sha": "7ba355575798cb7feb5098cb22eb55fd7623cbb0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "patch": "@@ -1,3 +1,9 @@\n+2018-03-08  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/84404\n+\tPR debug/84408\n+\t* gcc.dg/graphite/pr84404.c: New.\n+\n 2018-03-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/84740"}, {"sha": "858e651cfab7ba1ad948a0f56c5555d5765b866c", "filename": "gcc/testsuite/gcc.dg/graphite/pr84404.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr84404.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc7b0ffa6335f22ae91101d5b072871ebbdc5013/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr84404.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr84404.c?ref=bc7b0ffa6335f22ae91101d5b072871ebbdc5013", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=2 -floop-nest-optimize -g\" } */\n+\n+int te[9];\n+\n+void\n+dt (int cz)\n+{\n+  while (cz < 1)\n+    {\n+      int xy;\n+\n+      for (xy = 0; xy < 9; ++xy)\n+        te[xy] = 0;\n+\n+      ++cz;\n+    }\n+}"}]}