{"sha": "ff76d1ee8676697b5ddccca40330b96efde1c07e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY3NmQxZWU4Njc2Njk3YjVkZGNjY2E0MDMzMGI5NmVmZGUxYzA3ZQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "1999-08-07T06:02:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-07T06:02:05Z"}, "message": "iostream.cc: Add missing calls to isfx and setup a cleanup region for the locked stream.\n\n\n\t* iostream.cc: Add missing calls to isfx and setup a cleanup\n\tregion for the locked stream.\n\t* iostream.h: Likewise.\n\t* isgetline.cc: Likewise.\n\t* isgetsb.cc: Likewise.\n\t* isscan.cc: Likewise.\n\nFrom-SVN: r28573", "tree": {"sha": "5df4b9dddad86b6545449ec8cde791905904c826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5df4b9dddad86b6545449ec8cde791905904c826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff76d1ee8676697b5ddccca40330b96efde1c07e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff76d1ee8676697b5ddccca40330b96efde1c07e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff76d1ee8676697b5ddccca40330b96efde1c07e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff76d1ee8676697b5ddccca40330b96efde1c07e/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80832cf27b6c195056027267acf456a5ef96a17f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80832cf27b6c195056027267acf456a5ef96a17f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80832cf27b6c195056027267acf456a5ef96a17f"}], "stats": {"total": 101, "additions": 94, "deletions": 7}, "files": [{"sha": "36150ed49ead5b8b88015db1ea5ba2ea979789ad", "filename": "libio/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2FChangeLog?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -1,3 +1,12 @@\n+1999-08-07  Andreas Schwab  <schwab@suse.de>\n+\n+\t* iostream.cc: Add missing calls to isfx and setup a cleanup\n+\tregion for the locked stream.\n+\t* iostream.h: Likewise.\n+\t* isgetline.cc: Likewise.\n+\t* isgetsb.cc: Likewise.\n+\t* isscan.cc: Likewise.\n+\n Mon Jun 28 09:25:23 1999  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* configure.in (post-target): Use \"$(topsrcdir)\", not \"$(srcdir)/..\"."}, {"sha": "4b75fca764dd25782addb95b64fcc16b5ebca23d", "filename": "libio/iostream.cc", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.cc?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -71,6 +71,8 @@ int skip_ws(streambuf* sb)\n istream& istream::get(char& c)\n {\n     if (ipfx1()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tint ch = _strbuf->sbumpc();\n \tif (ch == EOF) {\n \t  set(ios::eofbit|ios::failbit);\n@@ -80,6 +82,8 @@ istream& istream::get(char& c)\n \t  c = (char)ch;\n \t  _gcount = 1;\n \t}\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     else\n       _gcount = 0;\n@@ -102,10 +106,12 @@ istream& istream::ignore(int n /* = 1 */, int delim /* = EOF */)\n {\n     _gcount = 0;\n     if (ipfx1()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tregister streambuf* sb = _strbuf;\n \tif (delim == EOF) {\n \t    _gcount = sb->ignore(n);\n-\t    return *this;\n+\t    goto unlock;\n \t}\n \tfor (;;) {\n #if 0\n@@ -122,16 +128,23 @@ istream& istream::ignore(int n /* = 1 */, int delim /* = EOF */)\n \t    if (ch == delim)\n \t\tbreak;\n \t}\n+    unlock:\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n istream& istream::read(char *s, streamsize n)\n {\n     if (ipfx1()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \t_gcount = _strbuf->sgetn(s, n);\n \tif (_gcount != n)\n \t    set(ios::failbit|ios::eofbit);\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     else\n       _gcount = 0;\n@@ -184,11 +197,15 @@ streampos istream::tellg()\n istream& istream::operator>>(char& c)\n {\n     if (ipfx0()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tint ch = _strbuf->sbumpc();\n \tif (ch == EOF)\n \t    set(ios::eofbit|ios::failbit);\n \telse\n \t    c = (char)ch;\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n@@ -200,6 +217,8 @@ istream::operator>> (char* ptr)\n   int w = width(0);\n   if (ipfx0())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       register streambuf* sb = _strbuf;\n       for (;;)\n \t{\n@@ -219,6 +238,8 @@ istream::operator>> (char* ptr)\n \t}\n       if (p == ptr)\n \tset(ios::failbit);\n+      isfx();\n+      _IO_cleanup_region_end (0);\n     }\n   *p = '\\0';\n   return *this;\n@@ -234,6 +255,9 @@ static int read_int(istream& stream, unsigned LONGEST& val, int& neg)\n {\n     if (!stream.ipfx0())\n       return 0;\n+    int retval;\n+    _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t      stream._strbuf);\n     register streambuf* sb = stream.rdbuf();\n     int base = 10;\n     int ndigits = 0;\n@@ -254,7 +278,7 @@ static int read_int(istream& stream, unsigned LONGEST& val, int& neg)\n \t    ch = sb->sbumpc();\n \t    if (ch == EOF) {\n \t\tval = 0;\n-\t\treturn 1;\n+\t\tgoto unlock;\n \t    }\n \t    if (ch == 'x' || ch == 'X') {\n \t\tbase = 16;\n@@ -290,19 +314,26 @@ static int read_int(istream& stream, unsigned LONGEST& val, int& neg)\n \t    if (ndigits == 0)\n \t\tgoto fail;\n \t    else\n-\t\treturn 1;\n+\t\tgoto unlock;\n \t}\n \tndigits++;\n \tval = base * val + digit;\n \tch = sb->sbumpc();\n     }\n-    return 1;\n+  unlock:\n+    retval = 1;\n+    goto out;\n   fail:\n     stream.set(ios::failbit);\n-    return 0;\n+    retval = 0;\n+    goto out;\n   eof_fail:\n     stream.set(ios::failbit|ios::eofbit);\n-    return 0;\n+    retval = 0;\n+  out:\n+    stream.isfx();\n+    _IO_cleanup_region_end (0);\n+    return retval;\n }\n \n #define READ_INT(TYPE) \\\n@@ -334,34 +365,52 @@ istream& istream::operator>>(long double& x)\n {\n     if (ipfx0())\n       {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n #if _G_HAVE_LONG_DOUBLE_IO\n \tscan(\"%Lg\", &x);\n #else\n \tdouble y;\n \tscan(\"%lg\", &y);\n \tx = y;\n #endif\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n       }\n     return *this;\n }\n \n istream& istream::operator>>(double& x)\n {\n     if (ipfx0())\n+      {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tscan(\"%lg\", &x);\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n+      }\n     return *this;\n }\n \n istream& istream::operator>>(float& x)\n {\n     if (ipfx0())\n+      {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tscan(\"%g\", &x);\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n+      }\n     return *this;\n }\n \n istream& istream::operator>>(register streambuf* sbuf)\n {\n     if (ipfx0()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tregister streambuf* inbuf = rdbuf();\n \t// FIXME: Should optimize!\n \tfor (;;) {\n@@ -375,6 +424,8 @@ istream& istream::operator>>(register streambuf* sbuf)\n \t\tbreak;\n \t    }\n \t}\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n@@ -789,8 +840,8 @@ ostream& ostream::operator<<(const char *s)\n       if (flags() & ios::left && padding > 0) // Left adjustment.\n \tif (_IO_padn(sbuf, fill_char, padding) != padding)\n \t  set(ios::badbit);\n-      osfx();\n      failed:\n+      osfx();\n       _IO_cleanup_region_end (0);\n     }\n   return *this;"}, {"sha": "19fbf8a4d95ca2bdd74c2543dd9e704108c3a3e3", "filename": "libio/iostream.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fiostream.h?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -173,6 +173,7 @@ class istream : virtual public ios\n     int get() { if (!ipfx1()) return EOF;\n \t\telse { int ch = _strbuf->sbumpc();\n \t\t       if (ch == EOF) set(ios::eofbit);\n+\t\t       isfx();\n \t\t       return ch;\n \t\t     } }\n     int peek();"}, {"sha": "5e48a000c09ab9b35a0091bdf1f56a026f523849", "filename": "libio/isgetline.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisgetline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisgetline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisgetline.cc?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -37,6 +37,8 @@ istream& istream::getline(char* buf, int len, char delim)\n   int ch;\n   if (ipfx1())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       streambuf *sb = rdbuf();\n       _gcount = _IO_getline_info(sb, buf, len - 1, delim, -1, &ch);\n       if (ch != EOF)\n@@ -48,6 +50,8 @@ istream& istream::getline(char* buf, int len, char delim)\n \t  set(ios::failbit);\n \t  sb->sungetc(); // Leave delimiter unread.\n \t}\n+      isfx();\n+      _IO_cleanup_region_end (0);\n     }\n   else\n     ch = EOF;\n@@ -67,11 +71,15 @@ istream& istream::get(char* buf, int len, char delim)\n     }\n   if (ipfx1())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       streambuf *sbuf = rdbuf();\n       int ch;\n       _gcount = _IO_getline_info(sbuf, buf, len - 1, delim, -1, &ch);\n       if (_gcount == 0 && ch == EOF)\n \tset(ios::failbit|ios::eofbit);\n+      isfx();\n+      _IO_cleanup_region_end (0);\n     }\n   buf[_gcount] = '\\0';\n   return *this;\n@@ -123,6 +131,8 @@ char *_sb_readline (streambuf *sb, long& total, char terminator)\n istream& istream::gets(char **s, char delim /* = '\\n' */)\n {\n     if (ipfx1()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tlong size = 0;\n \tstreambuf *sb = rdbuf();\n \t*s = _sb_readline (sb, size, delim);\n@@ -132,6 +142,8 @@ istream& istream::gets(char **s, char delim /* = '\\n' */)\n \t    if (_gcount == 0)\n \t\tset(ios::failbit);\n \t}\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     else {\n \t_gcount = 0;"}, {"sha": "655c972589ab0c76e47ee914bb0797a1aac40250", "filename": "libio/isgetsb.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisgetsb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisgetsb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisgetsb.cc?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -31,6 +31,8 @@ istream& istream::get(streambuf& sb, char delim /* = '\\n' */)\n   _gcount = 0;\n   if (ipfx1())\n     {\n+      _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t_strbuf);\n       register streambuf* isb = rdbuf();\n       for (;;)\n \t{\n@@ -54,6 +56,8 @@ istream& istream::get(streambuf& sb, char delim /* = '\\n' */)\n \t  if (delimp != NULL)\n \t    break;\n \t}\n+      isfx();\n+      _IO_cleanup_region_end (0);\n     }\n   return *this;\n }"}, {"sha": "977559c2cba55e3def9e0c3485b9b493bd0ed20d", "filename": "libio/isscan.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisscan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff76d1ee8676697b5ddccca40330b96efde1c07e/libio%2Fisscan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fisscan.cc?ref=ff76d1ee8676697b5ddccca40330b96efde1c07e", "patch": "@@ -29,17 +29,27 @@ the executable file might be covered by the GNU General Public License. */\n istream& istream::scan(const char *format ...)\n {\n     if (ipfx0()) {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \tva_list ap;\n \tva_start(ap, format);\n \t_strbuf->vscan(format, ap, this);\n \tva_end(ap);\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n     }\n     return *this;\n }\n \n istream& istream::vscan(const char *format, _IO_va_list args)\n {\n     if (ipfx0())\n+      {\n+\t_IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile,\n+\t\t\t\t  _strbuf);\n \t_strbuf->vscan(format, args, this);\n+\tisfx();\n+\t_IO_cleanup_region_end (0);\n+      }\n     return *this;\n }"}]}