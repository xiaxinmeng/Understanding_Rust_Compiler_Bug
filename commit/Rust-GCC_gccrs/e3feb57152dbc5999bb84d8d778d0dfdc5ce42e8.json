{"sha": "e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNmZWI1NzE1MmRiYzU5OTliYjg0ZDhkNzc4ZDBkZmRjNWNlNDJlOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-21T10:13:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-21T10:13:38Z"}, "message": "optabs.c (gen_condiational_trap): Remove #define.\n\n\t* optabs.c (gen_condiational_trap): Remove #define.\n\t(add_equal_note): Assertify. Remove explicit indirection from\n\tcall via function pointer.\n\t(expand_ternary_op, expand_simple_binop, expand_binop,\n\texpand_twoval_unop, expand_twoval_binop,\n\texpand_twoval_binop_libfunc, expand_simple_unop expand_unop,\n\temit_unop_insn,  emit_no_conflict_block,  prepare_cmp_insn,\n\tprepare_operand emit_cmp_and_jump_insn_1, emit_cmp_and_jump_insns,\n\tprepare_float_lib_cmp, emit_conditional_move,\n\temit_conditional_add, gen_add2_insn, gen_add3_insn,\n\thave_add2_insn, gen_sub2_insn, gen_sub3_insn, have_sub2_insn,\n\texpand_float, expand_fix, debug_optab_libfuncs, gen_cond_trap,\n\tvector_compare_rtx, expand_vec_cond_expr): Likewise.\n\nFrom-SVN: r98499", "tree": {"sha": "13719338a8b4624e6f1cd2f84649f9e01033c094", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13719338a8b4624e6f1cd2f84649f9e01033c094"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8/comments", "author": null, "committer": null, "parents": [{"sha": "d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e6fecb8fa3f91bf3dfd1a117e0f8e837943853"}], "stats": {"total": 258, "additions": 121, "deletions": 137}, "files": [{"sha": "3a7dba7cbeee3dee6053ef5bb077e7ad7f523923", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "patch": "@@ -1,3 +1,19 @@\n+2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* optabs.c (gen_condiational_trap): Remove #define.\n+\t(add_equal_note): Assertify. Remove explicit indirection from\n+\tcall via function pointer.\n+\t(expand_ternary_op, expand_simple_binop, expand_binop,\n+\texpand_twoval_unop, expand_twoval_binop,\n+\texpand_twoval_binop_libfunc, expand_simple_unop expand_unop,\n+\temit_unop_insn,  emit_no_conflict_block,  prepare_cmp_insn,\n+\tprepare_operand emit_cmp_and_jump_insn_1, emit_cmp_and_jump_insns,\n+\tprepare_float_lib_cmp, emit_conditional_move,\n+\temit_conditional_add, gen_add2_insn, gen_add3_insn,\n+\thave_add2_insn, gen_sub2_insn, gen_sub3_insn, have_sub2_insn,\n+\texpand_float, expand_fix, debug_optab_libfuncs, gen_cond_trap,\n+\tvector_compare_rtx, expand_vec_cond_expr): Likewise.\n+\n 2005-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h: Update API to separate allocation mechanism from type."}, {"sha": "8d20ad770a073da8b26167a013421c27c63816ba", "filename": "gcc/optabs.c", "status": "modified", "additions": 105, "deletions": 137, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e3feb57152dbc5999bb84d8d778d0dfdc5ce42e8", "patch": "@@ -127,7 +127,6 @@ static rtx vector_compare_rtx (tree, bool, enum insn_code);\n \n #ifndef HAVE_conditional_trap\n #define HAVE_conditional_trap 0\n-#define gen_conditional_trap(a,b) (abort (), NULL_RTX)\n #endif\n \f\n /* Add a REG_EQUAL note to the last insn in INSNS.  TARGET is being set to\n@@ -146,10 +145,7 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n   rtx last_insn, insn, set;\n   rtx note;\n \n-  if (! insns\n-      || ! INSN_P (insns)\n-      || NEXT_INSN (insns) == NULL_RTX)\n-    abort ();\n+  gcc_assert (insns && INSN_P (insns) && NEXT_INSN (insns));\n \n   if (GET_RTX_CLASS (code) != RTX_COMM_ARITH\n       && GET_RTX_CLASS (code) != RTX_BIN_ARITH\n@@ -348,11 +344,10 @@ expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n   rtx pat;\n   rtx xop0 = op0, xop1 = op1, xop2 = op2;\n \n-  if (ternary_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing)\n-    abort ();\n+  gcc_assert (ternary_optab->handlers[(int) mode].insn_code\n+\t      != CODE_FOR_nothing);\n \n-  if (!target\n-      || ! (*insn_data[icode].operand[0].predicate) (target, mode))\n+  if (!target || !insn_data[icode].operand[0].predicate (target, mode))\n     temp = gen_reg_rtx (mode);\n   else\n     temp = target;\n@@ -387,15 +382,15 @@ expand_ternary_op (enum machine_mode mode, optab ternary_optab, rtx op0,\n   /* Now, if insn's predicates don't allow our operands, put them into\n      pseudo regs.  */\n   \n-  if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0)\n+  if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n       && mode0 != VOIDmode) \n     xop0 = copy_to_mode_reg (mode0, xop0);\n   \n-  if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1)\n+  if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n       && mode1 != VOIDmode)\n     xop1 = copy_to_mode_reg (mode1, xop1);\n     \n-  if (! (*insn_data[icode].operand[3].predicate) (xop2, mode2)\n+  if (!insn_data[icode].operand[3].predicate (xop2, mode2)\n       && mode2 != VOIDmode)\n     xop2 = copy_to_mode_reg (mode2, xop2);\n     \n@@ -927,8 +922,7 @@ expand_simple_binop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t     enum optab_methods methods)\n {\n   optab binop = code_to_optab[(int) code];\n-  if (binop == 0)\n-    abort ();\n+  gcc_assert (binop);\n \n   return expand_binop (mode, binop, op0, op1, target, unsignedp, methods);\n }\n@@ -1088,15 +1082,15 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       /* Now, if insn's predicates don't allow our operands, put them into\n \t pseudo regs.  */\n \n-      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0)\n+      if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n \t  && mode0 != VOIDmode)\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1)\n+      if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n \t  && mode1 != VOIDmode)\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (temp, mode))\n+      if (!insn_data[icode].operand[0].predicate (temp, mode))\n \ttemp = gen_reg_rtx (mode);\n \n       pat = GEN_FCN (icode) (temp, xop0, xop1);\n@@ -1829,14 +1823,13 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \txop0 = convert_to_mode (mode0, xop0, unsignedp);\n \n       /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (! (*insn_data[icode].operand[2].predicate) (xop0, mode0))\n+      if (!insn_data[icode].operand[2].predicate (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n       /* We could handle this, but we should always be called with a pseudo\n \t for our targets and all insns should take them as outputs.  */\n-      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n-\t  || ! (*insn_data[icode].operand[1].predicate) (targ1, mode))\n-\tabort ();\n+      gcc_assert (insn_data[icode].operand[0].predicate (targ0, mode));\n+      gcc_assert (insn_data[icode].operand[1].predicate (targ1, mode));\n \n       pat = GEN_FCN (icode) (targ0, targ1, xop0);\n       if (pat)\n@@ -1955,17 +1948,16 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \t\t\t      xop1, unsignedp);\n \n       /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n-      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n+      if (!insn_data[icode].operand[1].predicate (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_data[icode].operand[2].predicate) (xop1, mode1))\n+      if (!insn_data[icode].operand[2].predicate (xop1, mode1))\n \txop1 = copy_to_mode_reg (mode1, xop1);\n \n       /* We could handle this, but we should always be called with a pseudo\n \t for our targets and all insns should take them as outputs.  */\n-      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n-\t  || ! (*insn_data[icode].operand[3].predicate) (targ1, mode))\n-\tabort ();\n+      gcc_assert (insn_data[icode].operand[0].predicate (targ0, mode));\n+      gcc_assert (insn_data[icode].operand[3].predicate (targ1, mode));\n \n       pat = GEN_FCN (icode) (targ0, xop0, xop1, targ1);\n       if (pat)\n@@ -2028,8 +2020,7 @@ expand_twoval_binop_libfunc (optab binoptab, rtx op0, rtx op1,\n   rtx insns;\n \n   /* Exactly one of TARG0 or TARG1 should be non-NULL.  */\n-  if (!((targ0 != NULL_RTX) ^ (targ1 != NULL_RTX)))\n-    abort ();\n+  gcc_assert (!targ0 != !targ1);\n \n   mode = GET_MODE (op0);\n   if (!binoptab->handlers[(int) mode].libfunc)\n@@ -2066,8 +2057,7 @@ expand_simple_unop (enum machine_mode mode, enum rtx_code code, rtx op0,\n \t\t    rtx target, int unsignedp)\n {\n   optab unop = code_to_optab[(int) code];\n-  if (unop == 0)\n-    abort ();\n+  gcc_assert (unop);\n \n   return expand_unop (mode, unop, op0, target, unsignedp);\n }\n@@ -2317,10 +2307,10 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n       /* Now, if insn doesn't accept our operand, put it into a pseudo.  */\n \n-      if (! (*insn_data[icode].operand[1].predicate) (xop0, mode0))\n+      if (!insn_data[icode].operand[1].predicate (xop0, mode0))\n \txop0 = copy_to_mode_reg (mode0, xop0);\n \n-      if (! (*insn_data[icode].operand[0].predicate) (temp, mode))\n+      if (!insn_data[icode].operand[0].predicate (temp, mode))\n \ttemp = gen_reg_rtx (mode);\n \n       pat = GEN_FCN (icode) (temp, xop0);\n@@ -2934,10 +2924,10 @@ emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n \n   /* Now, if insn does not accept our operands, put them into pseudos.  */\n \n-  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+  if (!insn_data[icode].operand[1].predicate (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n \n-  if (! (*insn_data[icode].operand[0].predicate) (temp, GET_MODE (temp))\n+  if (!insn_data[icode].operand[0].predicate (temp, GET_MODE (temp))\n       || (flag_force_mem && MEM_P (temp)))\n     temp = gen_reg_rtx (GET_MODE (temp));\n \n@@ -3022,8 +3012,7 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n \t      }\n \t}\n \n-      if (set == 0)\n-\tabort ();\n+      gcc_assert (set);\n \n       if (! reg_overlap_mentioned_p (target, SET_DEST (set)))\n \t{\n@@ -3365,8 +3354,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n   /* Abort if we have a non-canonical comparison.  The RTL documentation\n      states that canonical comparisons are required only for targets which\n      have cc0.  */\n-  if (CONSTANT_P (x) && ! CONSTANT_P (y))\n-    abort ();\n+  gcc_assert (!CONSTANT_P (x) || CONSTANT_P (y));\n #endif\n \n   /* Don't let both operands fail to indicate the mode.  */\n@@ -3385,8 +3373,7 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       rtx opalign\n \t= GEN_INT (MIN (MEM_ALIGN (x), MEM_ALIGN (y)) / BITS_PER_UNIT);\n \n-      if (size == 0)\n-\tabort ();\n+      gcc_assert (size);\n \n       /* Try to use a memory block compare insn - either cmpstr\n \t or cmpmem will do.  */\n@@ -3483,11 +3470,8 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n       return;\n     }\n \n-  if (class == MODE_FLOAT)\n-    prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n-\n-  else\n-    abort ();\n+  gcc_assert (class == MODE_FLOAT);\n+  prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp);\n }\n \n /* Before emitting an insn with code ICODE, make sure that X, which is going\n@@ -3502,7 +3486,7 @@ prepare_operand (int icode, rtx x, int opnum, enum machine_mode mode,\n   if (mode != wider_mode)\n     x = convert_modes (wider_mode, mode, x, unsignedp);\n \n-  if (! (*insn_data[icode].operand[opnum].predicate)\n+  if (!insn_data[icode].operand[opnum].predicate\n       (x, insn_data[icode].operand[opnum].mode))\n     {\n       if (no_new_pseudos)\n@@ -3537,7 +3521,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  icode = cbranch_optab->handlers[(int) wider_mode].insn_code;\n \n \t  if (icode != CODE_FOR_nothing\n-\t      && (*insn_data[icode].operand[0].predicate) (test, wider_mode))\n+\t      && insn_data[icode].operand[0].predicate (test, wider_mode))\n \t    {\n \t      x = prepare_operand (icode, x, 1, mode, wider_mode, unsignedp);\n \t      y = prepare_operand (icode, y, 2, mode, wider_mode, unsignedp);\n@@ -3553,7 +3537,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  x = prepare_operand (icode, x, 0, mode, wider_mode, unsignedp);\n \t  emit_insn (GEN_FCN (icode) (x));\n \t  if (label)\n-\t    emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+\t    emit_jump_insn (bcc_gen_fctn[(int) comparison] (label));\n \t  return;\n \t}\n \n@@ -3566,7 +3550,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  y = prepare_operand (icode, y, 1, mode, wider_mode, unsignedp);\n \t  emit_insn (GEN_FCN (icode) (x, y));\n \t  if (label)\n-\t    emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n+\t    emit_jump_insn (bcc_gen_fctn[(int) comparison] (label));\n \t  return;\n \t}\n \n@@ -3578,7 +3562,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n     }\n   while (wider_mode != VOIDmode);\n \n-  abort ();\n+  gcc_unreachable ();\n }\n \n /* Generate code to compare X with Y so that the condition codes are\n@@ -3609,8 +3593,7 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n     {\n       /* If we're not emitting a branch, this means some caller\n          is out of sync.  */\n-      if (! label)\n-\tabort ();\n+      gcc_assert (label);\n \n       op0 = y, op1 = x;\n       comparison = swap_condition (comparison);\n@@ -3681,8 +3664,7 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n \t}\n     }\n \n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   if (mode != orig_mode)\n     {\n@@ -3740,7 +3722,7 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode, word_mode,\n \t\t\t\t\tequiv, true_rtx, false_rtx);\n@@ -3772,8 +3754,8 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n void\n emit_indirect_jump (rtx loc)\n {\n-  if (! ((*insn_data[(int) CODE_FOR_indirect_jump].operand[0].predicate)\n-\t (loc, Pmode)))\n+  if (!insn_data[(int) CODE_FOR_indirect_jump].operand[0].predicate\n+      (loc, Pmode))\n     loc = copy_to_mode_reg (Pmode, loc);\n \n   emit_jump_insn (gen_indirect_jump (loc));\n@@ -3858,15 +3840,15 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* If the insn doesn't accept these operands, put them in pseudos.  */\n \n-  if (! (*insn_data[icode].operand[0].predicate)\n+  if (!insn_data[icode].operand[0].predicate\n       (subtarget, insn_data[icode].operand[0].mode))\n     subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n \n-  if (! (*insn_data[icode].operand[2].predicate)\n+  if (!insn_data[icode].operand[2].predicate\n       (op2, insn_data[icode].operand[2].mode))\n     op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n \n-  if (! (*insn_data[icode].operand[3].predicate)\n+  if (!insn_data[icode].operand[3].predicate\n       (op3, insn_data[icode].operand[3].mode))\n     op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n \n@@ -3990,17 +3972,17 @@ emit_conditional_add (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   /* If the insn doesn't accept these operands, put them in pseudos.  */\n \n-  if (! (*insn_data[icode].operand[0].predicate)\n+  if (!insn_data[icode].operand[0].predicate\n       (target, insn_data[icode].operand[0].mode))\n     subtarget = gen_reg_rtx (insn_data[icode].operand[0].mode);\n   else\n     subtarget = target;\n \n-  if (! (*insn_data[icode].operand[2].predicate)\n+  if (!insn_data[icode].operand[2].predicate\n       (op2, insn_data[icode].operand[2].mode))\n     op2 = copy_to_mode_reg (insn_data[icode].operand[2].mode, op2);\n \n-  if (! (*insn_data[icode].operand[3].predicate)\n+  if (!insn_data[icode].operand[3].predicate\n       (op3, insn_data[icode].operand[3].mode))\n     op3 = copy_to_mode_reg (insn_data[icode].operand[3].mode, op3);\n \n@@ -4042,15 +4024,14 @@ gen_add2_insn (rtx x, rtx y)\n {\n   int icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n-    abort ();\n+  gcc_assert (insn_data[icode].operand[0].predicate\n+\t      (x, insn_data[icode].operand[0].mode));\n+  gcc_assert (insn_data[icode].operand[1].predicate\n+\t      (x, insn_data[icode].operand[1].mode));\n+  gcc_assert (insn_data[icode].operand[2].predicate\n+\t      (y, insn_data[icode].operand[2].mode));\n \n-  return (GEN_FCN (icode) (x, x, y));\n+  return GEN_FCN (icode) (x, x, y);\n }\n \n /* Generate and return an insn body to add r1 and c,\n@@ -4061,36 +4042,35 @@ gen_add3_insn (rtx r0, rtx r1, rtx c)\n   int icode = (int) add_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n   if (icode == CODE_FOR_nothing\n-      || ! ((*insn_data[icode].operand[0].predicate)\n-\t    (r0, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (r1, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (c, insn_data[icode].operand[2].mode)))\n+      || !(insn_data[icode].operand[0].predicate\n+\t   (r0, insn_data[icode].operand[0].mode))\n+      || !(insn_data[icode].operand[1].predicate\n+\t   (r1, insn_data[icode].operand[1].mode))\n+      || !(insn_data[icode].operand[2].predicate\n+\t   (c, insn_data[icode].operand[2].mode)))\n     return NULL_RTX;\n \n-  return (GEN_FCN (icode) (r0, r1, c));\n+  return GEN_FCN (icode) (r0, r1, c);\n }\n \n int\n have_add2_insn (rtx x, rtx y)\n {\n   int icode;\n \n-  if (GET_MODE (x) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (x) != VOIDmode);\n \n   icode = (int) add_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n+  if (!(insn_data[icode].operand[0].predicate\n+\t(x, insn_data[icode].operand[0].mode))\n+      || !(insn_data[icode].operand[1].predicate\n+\t   (x, insn_data[icode].operand[1].mode))\n+      || !(insn_data[icode].operand[2].predicate\n+\t   (y, insn_data[icode].operand[2].mode)))\n     return 0;\n \n   return 1;\n@@ -4103,15 +4083,14 @@ gen_sub2_insn (rtx x, rtx y)\n {\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n-    abort ();\n+  gcc_assert (insn_data[icode].operand[0].predicate\n+\t      (x, insn_data[icode].operand[0].mode));\n+  gcc_assert (insn_data[icode].operand[1].predicate\n+\t      (x, insn_data[icode].operand[1].mode));\n+  gcc_assert  (insn_data[icode].operand[2].predicate\n+\t       (y, insn_data[icode].operand[2].mode));\n \n-  return (GEN_FCN (icode) (x, x, y));\n+  return GEN_FCN (icode) (x, x, y);\n }\n \n /* Generate and return an insn body to subtract r1 and c,\n@@ -4122,36 +4101,35 @@ gen_sub3_insn (rtx r0, rtx r1, rtx c)\n   int icode = (int) sub_optab->handlers[(int) GET_MODE (r0)].insn_code;\n \n   if (icode == CODE_FOR_nothing\n-      || ! ((*insn_data[icode].operand[0].predicate)\n-\t    (r0, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (r1, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (c, insn_data[icode].operand[2].mode)))\n+      || !(insn_data[icode].operand[0].predicate\n+\t   (r0, insn_data[icode].operand[0].mode))\n+      || !(insn_data[icode].operand[1].predicate\n+\t   (r1, insn_data[icode].operand[1].mode))\n+      || !(insn_data[icode].operand[2].predicate\n+\t   (c, insn_data[icode].operand[2].mode)))\n     return NULL_RTX;\n \n-  return (GEN_FCN (icode) (r0, r1, c));\n+  return GEN_FCN (icode) (r0, r1, c);\n }\n \n int\n have_sub2_insn (rtx x, rtx y)\n {\n   int icode;\n \n-  if (GET_MODE (x) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (x) != VOIDmode);\n \n   icode = (int) sub_optab->handlers[(int) GET_MODE (x)].insn_code;\n \n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  if (! ((*insn_data[icode].operand[0].predicate)\n-\t (x, insn_data[icode].operand[0].mode))\n-      || ! ((*insn_data[icode].operand[1].predicate)\n-\t    (x, insn_data[icode].operand[1].mode))\n-      || ! ((*insn_data[icode].operand[2].predicate)\n-\t    (y, insn_data[icode].operand[2].mode)))\n+  if (!(insn_data[icode].operand[0].predicate\n+\t(x, insn_data[icode].operand[0].mode))\n+      || !(insn_data[icode].operand[1].predicate\n+\t   (x, insn_data[icode].operand[1].mode))\n+      || !(insn_data[icode].operand[2].predicate\n+\t   (y, insn_data[icode].operand[2].mode)))\n     return 0;\n \n   return 1;\n@@ -4265,8 +4243,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n   enum machine_mode fmode, imode;\n \n   /* Crash now, because we won't be able to decide which mode to use.  */\n-  if (GET_MODE (from) == VOIDmode)\n-    abort ();\n+  gcc_assert (GET_MODE (from) != VOIDmode);\n \n   /* Look for an insn to do the conversion.  Do it in the specified\n      modes if possible; otherwise convert either input, output or both to\n@@ -4427,8 +4404,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n \tfrom = force_not_mem (from);\n \n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n-      if (!libfunc)\n-\tabort ();\n+      gcc_assert (libfunc);\n \n       start_sequence ();\n \n@@ -4611,8 +4587,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n \n       convert_optab tab = unsignedp ? ufix_optab : sfix_optab;\n       libfunc = tab->handlers[GET_MODE (to)][GET_MODE (from)].libfunc;\n-      if (!libfunc)\n-\tabort ();\n+      gcc_assert (libfunc);\n \n       if (flag_force_mem)\n \tfrom = force_not_mem (from);\n@@ -5267,8 +5242,7 @@ debug_optab_libfuncs (void)\n \th = &o->handlers[j];\n \tif (h->libfunc)\n \t  {\n-\t    if (GET_CODE (h->libfunc) != SYMBOL_REF)\n-\t      abort ();\n+\t    gcc_assert (GET_CODE (h->libfunc) = SYMBOL_REF);\n \t    fprintf (stderr, \"%s\\t%s:\\t%s\\n\",\n \t\t     GET_RTX_NAME (o->code),\n \t\t     GET_MODE_NAME (j),\n@@ -5288,8 +5262,7 @@ debug_optab_libfuncs (void)\n \t  h = &o->handlers[j][k];\n \t  if (h->libfunc)\n \t    {\n-\t      if (GET_CODE (h->libfunc) != SYMBOL_REF)\n-\t\tabort ();\n+\t      gcc_assert (GET_CODE (h->libfunc) = SYMBOL_REF);\n \t      fprintf (stderr, \"%s\\t%s\\t%s:\\t%s\\n\",\n \t\t       GET_RTX_NAME (o->code),\n \t\t       GET_MODE_NAME (j),\n@@ -5334,6 +5307,7 @@ gen_cond_trap (enum rtx_code code ATTRIBUTE_UNUSED, rtx op1,\n   emit_insn (GEN_FCN (icode) (op1, op2));\n \n   PUT_CODE (trap_rtx, code);\n+  gcc_assert (HAVE_conditional_trap);\n   insn = gen_conditional_trap (trap_rtx, tcode);\n   if (insn)\n     {\n@@ -5399,7 +5373,7 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   return code;\n }\n@@ -5414,29 +5388,23 @@ vector_compare_rtx (tree cond, bool unsignedp, enum insn_code icode)\n   tree t_op0, t_op1;\n   rtx rtx_op0, rtx_op1;\n \n-  if (!COMPARISON_CLASS_P (cond))\n-    {\n-      /* This is unlikely. While generating VEC_COND_EXPR,\n-\t auto vectorizer ensures that condition is a relational\n-\t operation.  */\n-      abort ();\n-    }\n-  else\n-    {\n-      rcode = get_rtx_code (TREE_CODE (cond), unsignedp); \n-      t_op0 = TREE_OPERAND (cond, 0);\n-      t_op1 = TREE_OPERAND (cond, 1);\n-    }\n+  /* This is unlikely. While generating VEC_COND_EXPR, auto vectorizer\n+     ensures that condition is a relational operation.  */\n+  gcc_assert (COMPARISON_CLASS_P (cond));\n \n+  rcode = get_rtx_code (TREE_CODE (cond), unsignedp); \n+  t_op0 = TREE_OPERAND (cond, 0);\n+  t_op1 = TREE_OPERAND (cond, 1);\n+  \n   /* Expand operands.  */\n   rtx_op0 = expand_expr (t_op0, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op0)), 1);\n   rtx_op1 = expand_expr (t_op1, NULL_RTX, TYPE_MODE (TREE_TYPE (t_op1)), 1);\n \n-  if (!(*insn_data[icode].operand[4].predicate) (rtx_op0, GET_MODE (rtx_op0))\n+  if (!insn_data[icode].operand[4].predicate (rtx_op0, GET_MODE (rtx_op0))\n       && GET_MODE (rtx_op0) != VOIDmode)\n     rtx_op0 = force_reg (GET_MODE (rtx_op0), rtx_op0);\n   \n-  if (!(*insn_data[icode].operand[5].predicate) (rtx_op1, GET_MODE (rtx_op1))\n+  if (!insn_data[icode].operand[5].predicate (rtx_op1, GET_MODE (rtx_op1))\n       && GET_MODE (rtx_op1) != VOIDmode)\n     rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n \n@@ -5493,13 +5461,13 @@ expand_vec_cond_expr (tree vec_cond_expr, rtx target)\n   /* Expand both operands and force them in reg, if required.  */\n   rtx_op1 = expand_expr (TREE_OPERAND (vec_cond_expr, 1),\n \t\t\t NULL_RTX, VOIDmode, 1);\n-  if (!(*insn_data[icode].operand[1].predicate) (rtx_op1, mode)\n+  if (!insn_data[icode].operand[1].predicate (rtx_op1, mode)\n       && mode != VOIDmode)\n     rtx_op1 = force_reg (mode, rtx_op1);\n \n   rtx_op2 = expand_expr (TREE_OPERAND (vec_cond_expr, 2),\n \t\t\t NULL_RTX, VOIDmode, 1);\n-  if (!(*insn_data[icode].operand[2].predicate) (rtx_op2, mode)\n+  if (!insn_data[icode].operand[2].predicate (rtx_op2, mode)\n       && mode != VOIDmode)\n     rtx_op2 = force_reg (mode, rtx_op2);\n "}]}