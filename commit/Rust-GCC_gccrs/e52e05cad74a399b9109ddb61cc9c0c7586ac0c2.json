{"sha": "e52e05cad74a399b9109ddb61cc9c0c7586ac0c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyZTA1Y2FkNzRhMzk5YjkxMDlkZGI2MWNjOWMwYzc1ODZhYzBjMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-03-29T19:38:55Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-03-29T19:38:55Z"}, "message": "Do not move float values through memory to get to/from gp registers if -msoft-float.\n\nFrom-SVN: r9242", "tree": {"sha": "51efd4ab9c2942d17632bf0a9dde197f8807b04d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51efd4ab9c2942d17632bf0a9dde197f8807b04d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2/comments", "author": null, "committer": null, "parents": [{"sha": "515f0e729a0c0c84f6b6faa4305ff06d7de60cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515f0e729a0c0c84f6b6faa4305ff06d7de60cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515f0e729a0c0c84f6b6faa4305ff06d7de60cbf"}], "stats": {"total": 123, "additions": 63, "deletions": 60}, "files": [{"sha": "1b253616ca0bc4a3c965bc94ebbbc01d755b3869", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 63, "deletions": 60, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52e05cad74a399b9109ddb61cc9c0c7586ac0c2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=e52e05cad74a399b9109ddb61cc9c0c7586ac0c2", "patch": "@@ -3901,11 +3901,11 @@\n   [(set_attr \"type\" \"*,*,*,compare,*,*,load,*\")\n    (set_attr \"length\" \"*,*,12,*,8,*,*,*\")])\n \f\n-;; For floating-point, we normally deal with the floating-point registers.\n-;; The sole exception is that parameter passing can produce floating-point\n-;; values in fixed-point registers.  Unless the value is a simple constant\n-;; or already in memory, we deal with this by allocating memory and copying\n-;; the value explicitly via that memory location.\n+;; For floating-point, we normally deal with the floating-point registers\n+;; unless -msoft-float is used.  The sole exception is that parameter passing\n+;; can produce floating-point values in fixed-point registers.  Unless the\n+;; value is a simple constant or already in memory, we deal with this by\n+;; allocating memory and copying the value explicitly via that memory location.\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"any_operand\" \"\"))]\n@@ -3923,70 +3923,73 @@\n       && REGNO (SUBREG_REG (operands[1])) < FIRST_PSEUDO_REGISTER)\n     operands[1] = alter_subreg (operands[1]);\n \n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n+  if (TARGET_HARD_FLOAT)\n     {\n-      /* If this is a store to memory or another integer register do the\n-\t move directly.  Otherwise store to a temporary stack slot and\n-\t load from there into a floating point register.  */\n-\n-      if (GET_CODE (operands[0]) == MEM\n-\t  || (GET_CODE (operands[0]) == REG\n-\t      && (REGNO (operands[0]) < 32\n-\t\t  || (reload_in_progress\n-\t\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))))\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n \t{\n-\t  emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n-\t\t\t  operand_subword (operands[1], 0, 0, SFmode));\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  rtx stack_slot = assign_stack_temp (SFmode, 4, 0);\n-\n-\t  emit_move_insn (stack_slot, operands[1]);\n-\t  emit_move_insn (operands[0], stack_slot);\n-\t  DONE;\n+\t  /* If this is a store to memory or another integer register do the\n+\t     move directly.  Otherwise store to a temporary stack slot and\n+\t     load from there into a floating point register.  */\n+\n+\t  if (GET_CODE (operands[0]) == MEM\n+\t      || (GET_CODE (operands[0]) == REG\n+\t\t  && (REGNO (operands[0]) < 32\n+\t\t      || (reload_in_progress\n+\t\t\t  && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))))\n+\t    {\n+\t      emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n+\t\t\t      operand_subword (operands[1], 0, 0, SFmode));\n+\t      DONE;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx stack_slot = assign_stack_temp (SFmode, 4, 0);\n+\n+\t      emit_move_insn (stack_slot, operands[1]);\n+\t      emit_move_insn (operands[0], stack_slot);\n+\t      DONE;\n+\t    }\n \t}\n-    }\n \n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      /* If operands[1] is a register, it may have double-precision data\n-\t in it, so truncate it to single precision.  We need not do\n-\t this for POWERPC.  */\n-      if (! TARGET_POWERPC && TARGET_HARD_FLOAT && GET_CODE (operands[1]) == REG)\n+      if (GET_CODE (operands[0]) == MEM)\n \t{\n-\t  rtx newreg = reload_in_progress ? operands[1] : gen_reg_rtx (SFmode);\n-\t  emit_insn (gen_truncdfsf2 (newreg,\n-\t\t\t\t     gen_rtx (SUBREG, DFmode, operands[1], 0)));\n-\t  operands[1] = newreg;\n+\t  /* If operands[1] is a register, it may have double-precision data\n+\t     in it, so truncate it to single precision.  We need not do\n+\t     this for POWERPC.  */\n+\t  if (! TARGET_POWERPC && TARGET_HARD_FLOAT && GET_CODE (operands[1]) == REG)\n+\t    {\n+\t      rtx newreg = reload_in_progress ? operands[1] : gen_reg_rtx (SFmode);\n+\t      emit_insn (gen_truncdfsf2 (newreg,\n+\t\t\t\t\t gen_rtx (SUBREG, DFmode, operands[1], 0)));\n+\t      operands[1] = newreg;\n+\t    }\n+\n+\t  operands[1] = force_reg (SFmode, operands[1]);\n \t}\n \n-      operands[1] = force_reg (SFmode, operands[1]);\n-    }\n-\n-  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 32)\n-    {\n-      if (GET_CODE (operands[1]) == MEM\n+      if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 32)\n+\t{\n+\t  if (GET_CODE (operands[1]) == MEM\n #if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && ! defined(REAL_IS_NOT_DOUBLE)\n-\t  || GET_CODE (operands[1]) == CONST_DOUBLE\n+\t      || GET_CODE (operands[1]) == CONST_DOUBLE\n #endif\n-\t  || (GET_CODE (operands[1]) == REG\n-\t      && (REGNO (operands[1]) < 32\n-\t\t  || (reload_in_progress\n-\t\t      && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))))\n-\t{\n-\t  emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n-\t\t\t  operand_subword (operands[1], 0, 0, SFmode));\n-\t  DONE;\n-\t}\n-      else\n-\t{\n-\t  rtx stack_slot = assign_stack_temp (SFmode, 4, 0);\n-\n-\t  emit_move_insn (stack_slot, operands[1]);\n-\t  emit_move_insn (operands[0], stack_slot);\n-\t  DONE;\n+\t      || (GET_CODE (operands[1]) == REG\n+\t\t  && (REGNO (operands[1]) < 32\n+\t\t      || (reload_in_progress\n+\t\t\t  && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))))\n+\t    {\n+\t      emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n+\t\t\t      operand_subword (operands[1], 0, 0, SFmode));\n+\t      DONE;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx stack_slot = assign_stack_temp (SFmode, 4, 0);\n+\n+\t      emit_move_insn (stack_slot, operands[1]);\n+\t      emit_move_insn (operands[0], stack_slot);\n+\t      DONE;\n+\t    }\n \t}\n     }\n "}]}