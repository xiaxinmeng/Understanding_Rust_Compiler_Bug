{"sha": "63c8f7d6a082b1cd0519fe06d4ed506b04280921", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNjOGY3ZDZhMDgyYjFjZDA1MTlmZTA2ZDRlZDUwNmIwNDI4MDkyMQ==", "commit": {"author": {"name": "Srinath Parvathaneni", "email": "srinath.parvathaneni@arm.com", "date": "2020-03-16T17:06:29Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-03-16T17:06:29Z"}, "message": "[ARM][GCC][1/x]: MVE ACLE intrinsics framework patch.\n\nThis patch creates the required framework for MVE ACLE intrinsics.\n\nThe following changes are done in this patch to support MVE ACLE intrinsics.\n\nHeader file arm_mve.h is added to source code, which contains the definitions of MVE ACLE intrinsics\nand different data types used in MVE. Machine description file mve.md is also added which contains the\nRTL patterns defined for MVE.\n\nA new reigster \"p0\" is added which is used in by MVE predicated patterns. A new register class \"VPR_REG\"\nis added and its contents are defined in REG_CLASS_CONTENTS.\n\nThe vec-common.md file is modified to support the standard move patterns. The prefix of neon functions\nwhich are also used by MVE is changed from \"neon_\" to \"simd_\".\neg: neon_immediate_valid_for_move changed to simd_immediate_valid_for_move.\n\nIn the patch standard patterns mve_move, mve_store and move_load for MVE are added and neon.md and vfp.md\nfiles are modified to support this common patterns.\n\nPlease refer to Arm reference manual [1] for more details.\n\n[1] https://developer.arm.com/docs/ddi0553/latest\n\n2020-03-06  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Mihail Ionescu  <mihail.ionescu@arm.com>\n\t    Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* config.gcc (arm_mve.h): Include mve intrinsics header file.\n\t* config/arm/aout.h (p0): Add new register name for MVE predicated\n\tcases.\n\t* config/arm-builtins.c (ARM_BUILTIN_SIMD_LANE_CHECK): Define macro\n\tcommon to Neon and MVE.\n\t(ARM_BUILTIN_NEON_LANE_CHECK): Renamed to ARM_BUILTIN_SIMD_LANE_CHECK.\n\t(arm_init_simd_builtin_types): Disable poly types for MVE.\n\t(arm_init_neon_builtins): Move a check to arm_init_builtins function.\n\t(arm_init_builtins): Use ARM_BUILTIN_SIMD_LANE_CHECK instead of\n\tARM_BUILTIN_NEON_LANE_CHECK.\n\t(mve_dereference_pointer): Add function.\n\t(arm_expand_builtin_args): Call to mve_dereference_pointer when MVE is\n\tenabled.\n\t(arm_expand_neon_builtin): Moved to arm_expand_builtin function.\n\t(arm_expand_builtin): Moved from arm_expand_neon_builtin function.\n\t* config/arm/arm-c.c (__ARM_FEATURE_MVE): Define macro for MVE and MVE\n\twith floating point enabled.\n\t* config/arm/arm-protos.h (neon_immediate_valid_for_move): Renamed to\n\tsimd_immediate_valid_for_move.\n\t(simd_immediate_valid_for_move): Renamed from\n\tneon_immediate_valid_for_move function.\n\t* config/arm/arm.c (arm_options_perform_arch_sanity_checks): Generate\n\terror if vfpv2 feature bit is disabled and mve feature bit is also\n\tdisabled for HARD_FLOAT_ABI.\n\t(use_return_insn): Check to not push VFP regs for MVE.\n\t(aapcs_vfp_allocate): Add MVE check to have same Procedure Call Standard\n\tas Neon.\n\t(aapcs_vfp_allocate_return_reg): Likewise.\n\t(thumb2_legitimate_address_p): Check to return 0 on valid Thumb-2\n\taddress operand for MVE.\n\t(arm_rtx_costs_internal): MVE check to determine cost of rtx.\n\t(neon_valid_immediate): Rename to simd_valid_immediate.\n\t(simd_valid_immediate): Rename from neon_valid_immediate.\n\t(simd_valid_immediate): MVE check on size of vector is 128 bits.\n\t(neon_immediate_valid_for_move): Rename to\n\tsimd_immediate_valid_for_move.\n\t(simd_immediate_valid_for_move): Rename from\n\tneon_immediate_valid_for_move.\n\t(neon_immediate_valid_for_logic): Modify call to neon_valid_immediate\n\tfunction.\n\t(neon_make_constant): Modify call to neon_valid_immediate function.\n\t(neon_vector_mem_operand): Return VFP register for POST_INC or PRE_DEC\n\tfor MVE.\n\t(output_move_neon): Add MVE check to generate vldm/vstm instrcutions.\n\t(arm_compute_frame_layout): Calculate space for saved VFP registers for\n\tMVE.\n\t(arm_save_coproc_regs): Save coproc registers for MVE.\n\t(arm_print_operand): Add case 'E' to print memory operands for MVE.\n\t(arm_print_operand_address): Check to print register number for MVE.\n\t(arm_hard_regno_mode_ok): Check for arm hard regno mode ok for MVE.\n\t(arm_modes_tieable_p): Check to allow structure mode for MVE.\n\t(arm_regno_class): Add VPR_REGNUM check.\n\t(arm_expand_epilogue_apcs_frame): MVE check to calculate epilogue code\n\tfor APCS frame.\n\t(arm_expand_epilogue): MVE check for enabling pop instructions in\n\tepilogue.\n\t(arm_print_asm_arch_directives): Modify function to disable print of\n\t.arch_extension \"mve\" and \"fp\" for cases where MVE is enabled with\n\t\"SOFT FLOAT ABI\".\n\t(arm_vector_mode_supported_p): Check for modes available in MVE interger\n\tand MVE floating point.\n\t(arm_array_mode_supported_p): Add TARGET_HAVE_MVE check for array mode\n\tpointer support.\n\t(arm_conditional_register_usage): Enable usage of conditional regsiter\n\tfor MVE.\n\t(fixed_regs[VPR_REGNUM]): Enable VPR_REG for MVE.\n\t(arm_declare_function_name): Modify function to disable print of\n\t.arch_extension \"mve\" and \"fp\" for cases where MVE is enabled with\n\t\"SOFT FLOAT ABI\".\n\t* config/arm/arm.h (TARGET_HAVE_MVE): Disable for soft float abi and\n\twhen target general registers are required.\n\t(TARGET_HAVE_MVE_FLOAT): Likewise.\n\t(FIXED_REGISTERS): Add bit for VFP_REG class which is enabled in arm.c\n\tfor MVE.\n\t(CALL_USED_REGISTERS): Set bit for VFP_REG class in CALL_USED_REGISTERS\n\twhich indicate this is not available for across function calls.\n\t(FIRST_PSEUDO_REGISTER): Modify.\n\t(VALID_MVE_MODE): Define valid MVE mode.\n\t(VALID_MVE_SI_MODE): Define valid MVE SI mode.\n\t(VALID_MVE_SF_MODE): Define valid MVE SF mode.\n\t(VALID_MVE_STRUCT_MODE): Define valid MVE struct mode.\n\t(VPR_REGNUM): Add Vector Predication Register in arm_regs_in_sequence\n\tfor MVE.\n\t(IS_VPR_REGNUM): Macro to check for VPR_REG register.\n\t(REG_ALLOC_ORDER): Add VPR_REGNUM entry.\n\t(enum reg_class): Add VPR_REG entry.\n\t(REG_CLASS_NAMES): Add VPR_REG entry.\n\t* config/arm/arm.md (VPR_REGNUM): Define.\n\t(conds): Check is_mve_type attrbiute to differentiate \"conditional\" and\n\t\"unconditional\" instructions.\n\t(arm_movsf_soft_insn): Modify RTL to not allow for MVE.\n\t(movdf_soft_insn): Modify RTL to not allow for MVE.\n\t(vfp_pop_multiple_with_writeback): Enable for MVE.\n\t(include \"mve.md\"): Include mve.md file.\n\t* config/arm/arm_mve.h: Add MVE intrinsics head file.\n\t* config/arm/constraints.md (Up): Constraint to enable \"p0\" register in MVE\n\tfor vector predicated operands.\n\t* config/arm/iterators.md (VNIM1): Define.\n\t(VNINOTM1): Define.\n\t(VHFBF_split): Define\n\t* config/arm/mve.md: New file.\n\t(mve_mov<mode>): Define RTL for move, store and load in MVE.\n\t(mve_mov<mode>): Define move RTL pattern with vec_duplicate operator for\n\tsecond operand.\n\t* config/arm/neon.md (neon_immediate_valid_for_move): Rename with\n\tsimd_immediate_valid_for_move.\n\t(neon_mov<mode>): Split pattern and move expand pattern \"movv8hf\" which\n\tis common to MVE and  NEON to vec-common.md file.\n\t(vec_init<mode><V_elem_l>): Add TARGET_HAVE_MVE check.\n\t* config/arm/predicates.md (vpr_register_operand): Define.\n\t* config/arm/t-arm: Add mve.md file.\n\t* config/arm/types.md (mve_move): Add MVE instructions mve_move to\n\tattribute \"type\".\n\t(mve_store): Add MVE instructions mve_store to attribute \"type\".\n\t(mve_load): Add MVE instructions mve_load to attribute \"type\".\n\t(is_mve_type): Define attribute.\n\t* config/arm/vec-common.md (mov<mode>): Modify RTL expand to support\n\tstandard move patterns in MVE along with NEON and IWMMXT with mode\n\titerator VNIM1.\n\t(mov<mode>): Modify RTL expand to support standard move patterns in NEON\n\tand IWMMXT with mode iterator V8HF.\n\t(movv8hf): Define RTL expand to support standard \"movv8hf\" pattern in\n\tNEON and MVE.\n\t* config/arm/vfp.md (neon_immediate_valid_for_move): Rename to\n\tsimd_immediate_valid_for_move.\n\n2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n            Mihail Ionescu  <mihail.ionescu@arm.com>\n            Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n\n\t* gcc.target/arm/mve/intrinsics/mve_vector_float.c: New test.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_float1.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_float2.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_int.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_int1.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_int2.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_uint.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_uint1.c: Likewise.\n\t* gcc.target/arm/mve/intrinsics/mve_vector_uint2.c: Likewise.\n\t* gcc.target/arm/mve/mve.exp: New file.\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_v8_1m_mve_fp_ok_nocache): Proc to check\n\tarmv8.1-m.main+mve.fp and returning corresponding options.\n\t(check_effective_target_arm_v8_1m_mve_fp_ok): Proc to call\n\tcheck_effective_target_arm_v8_1m_mve_fp_ok_nocache to check support of\n\tMVE with floating point on the current target.\n\t(add_options_for_arm_v8_1m_mve_fp): Proc to call\n\tcheck_effective_target_arm_v8_1m_mve_fp_ok to return corresponding\n\tcompiler options for MVE with floating point.\n\t(check_effective_target_arm_v8_1m_mve_ok_nocache): Modify to test and\n\treturn hard float-abi on success.", "tree": {"sha": "ef39c54629381d015e2e30ff240d3fa4f406a0fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef39c54629381d015e2e30ff240d3fa4f406a0fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63c8f7d6a082b1cd0519fe06d4ed506b04280921", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c8f7d6a082b1cd0519fe06d4ed506b04280921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63c8f7d6a082b1cd0519fe06d4ed506b04280921", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63c8f7d6a082b1cd0519fe06d4ed506b04280921/comments", "author": {"login": "sripar01", "id": 115715849, "node_id": "U_kgDOBuWvCQ", "avatar_url": "https://avatars.githubusercontent.com/u/115715849?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sripar01", "html_url": "https://github.com/sripar01", "followers_url": "https://api.github.com/users/sripar01/followers", "following_url": "https://api.github.com/users/sripar01/following{/other_user}", "gists_url": "https://api.github.com/users/sripar01/gists{/gist_id}", "starred_url": "https://api.github.com/users/sripar01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sripar01/subscriptions", "organizations_url": "https://api.github.com/users/sripar01/orgs", "repos_url": "https://api.github.com/users/sripar01/repos", "events_url": "https://api.github.com/users/sripar01/events{/privacy}", "received_events_url": "https://api.github.com/users/sripar01/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc093503d74b02f5372373bfaf052fb1bac3d553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc093503d74b02f5372373bfaf052fb1bac3d553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc093503d74b02f5372373bfaf052fb1bac3d553"}], "stats": {"total": 1401, "additions": 1249, "deletions": 152}, "files": [{"sha": "e814da15eb8358473dadb60c16c75572f009ceac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -1,3 +1,134 @@\n+2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+            Mihail Ionescu  <mihail.ionescu@arm.com>\n+            Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* config.gcc (arm_mve.h): Include mve intrinsics header file.\n+\t* config/arm/aout.h (p0): Add new register name for MVE predicated\n+\tcases.\n+\t* config/arm-builtins.c (ARM_BUILTIN_SIMD_LANE_CHECK): Define macro\n+\tcommon to Neon and MVE.\n+\t(ARM_BUILTIN_NEON_LANE_CHECK): Renamed to ARM_BUILTIN_SIMD_LANE_CHECK.\n+\t(arm_init_simd_builtin_types): Disable poly types for MVE.\n+\t(arm_init_neon_builtins): Move a check to arm_init_builtins function.\n+\t(arm_init_builtins): Use ARM_BUILTIN_SIMD_LANE_CHECK instead of\n+\tARM_BUILTIN_NEON_LANE_CHECK.\n+\t(mve_dereference_pointer): Add function.\n+\t(arm_expand_builtin_args): Call to mve_dereference_pointer when MVE is\n+\tenabled.\n+\t(arm_expand_neon_builtin): Moved to arm_expand_builtin function.\n+\t(arm_expand_builtin): Moved from arm_expand_neon_builtin function.\n+\t* config/arm/arm-c.c (__ARM_FEATURE_MVE): Define macro for MVE and MVE\n+\twith floating point enabled.\n+\t* config/arm/arm-protos.h (neon_immediate_valid_for_move): Renamed to\n+\tsimd_immediate_valid_for_move.\n+\t(simd_immediate_valid_for_move): Renamed from\n+\tneon_immediate_valid_for_move function.\n+\t* config/arm/arm.c (arm_options_perform_arch_sanity_checks): Generate\n+\terror if vfpv2 feature bit is disabled and mve feature bit is also\n+\tdisabled for HARD_FLOAT_ABI.\n+\t(use_return_insn): Check to not push VFP regs for MVE.\n+\t(aapcs_vfp_allocate): Add MVE check to have same Procedure Call Standard\n+\tas Neon.\n+\t(aapcs_vfp_allocate_return_reg): Likewise.\n+\t(thumb2_legitimate_address_p): Check to return 0 on valid Thumb-2\n+\taddress operand for MVE.\n+\t(arm_rtx_costs_internal): MVE check to determine cost of rtx.\n+\t(neon_valid_immediate): Rename to simd_valid_immediate.\n+\t(simd_valid_immediate): Rename from neon_valid_immediate.\n+\t(simd_valid_immediate): MVE check on size of vector is 128 bits.\n+\t(neon_immediate_valid_for_move): Rename to\n+\tsimd_immediate_valid_for_move.\n+\t(simd_immediate_valid_for_move): Rename from\n+\tneon_immediate_valid_for_move.\n+\t(neon_immediate_valid_for_logic): Modify call to neon_valid_immediate\n+\tfunction.\n+\t(neon_make_constant): Modify call to neon_valid_immediate function.\n+\t(neon_vector_mem_operand): Return VFP register for POST_INC or PRE_DEC\n+\tfor MVE.\n+\t(output_move_neon): Add MVE check to generate vldm/vstm instrcutions.\n+\t(arm_compute_frame_layout): Calculate space for saved VFP registers for\n+\tMVE.\n+\t(arm_save_coproc_regs): Save coproc registers for MVE.\n+\t(arm_print_operand): Add case 'E' to print memory operands for MVE.\n+\t(arm_print_operand_address): Check to print register number for MVE.\n+\t(arm_hard_regno_mode_ok): Check for arm hard regno mode ok for MVE.\n+\t(arm_modes_tieable_p): Check to allow structure mode for MVE.\n+\t(arm_regno_class): Add VPR_REGNUM check.\n+\t(arm_expand_epilogue_apcs_frame): MVE check to calculate epilogue code\n+\tfor APCS frame.\n+\t(arm_expand_epilogue): MVE check for enabling pop instructions in\n+\tepilogue.\n+\t(arm_print_asm_arch_directives): Modify function to disable print of\n+\t.arch_extension \"mve\" and \"fp\" for cases where MVE is enabled with\n+\t\"SOFT FLOAT ABI\".\n+\t(arm_vector_mode_supported_p): Check for modes available in MVE interger\n+\tand MVE floating point.\n+\t(arm_array_mode_supported_p): Add TARGET_HAVE_MVE check for array mode\n+\tpointer support.\n+\t(arm_conditional_register_usage): Enable usage of conditional regsiter\n+\tfor MVE.\n+\t(fixed_regs[VPR_REGNUM]): Enable VPR_REG for MVE.\n+\t(arm_declare_function_name): Modify function to disable print of\n+\t.arch_extension \"mve\" and \"fp\" for cases where MVE is enabled with\n+\t\"SOFT FLOAT ABI\".\n+\t* config/arm/arm.h (TARGET_HAVE_MVE): Disable for soft float abi and\n+\twhen target general registers are required.\n+\t(TARGET_HAVE_MVE_FLOAT): Likewise.\n+\t(FIXED_REGISTERS): Add bit for VFP_REG class which is enabled in arm.c\n+\tfor MVE.\n+\t(CALL_USED_REGISTERS): Set bit for VFP_REG class in CALL_USED_REGISTERS\n+\twhich indicate this is not available for across function calls.\n+\t(FIRST_PSEUDO_REGISTER): Modify.\n+\t(VALID_MVE_MODE): Define valid MVE mode.\n+\t(VALID_MVE_SI_MODE): Define valid MVE SI mode.\n+\t(VALID_MVE_SF_MODE): Define valid MVE SF mode.\n+\t(VALID_MVE_STRUCT_MODE): Define valid MVE struct mode.\n+\t(VPR_REGNUM): Add Vector Predication Register in arm_regs_in_sequence\n+\tfor MVE.\n+\t(IS_VPR_REGNUM): Macro to check for VPR_REG register.\n+\t(REG_ALLOC_ORDER): Add VPR_REGNUM entry.\n+\t(enum reg_class): Add VPR_REG entry.\n+\t(REG_CLASS_NAMES): Add VPR_REG entry.\n+\t* config/arm/arm.md (VPR_REGNUM): Define.\n+\t(conds): Check is_mve_type attrbiute to differentiate \"conditional\" and\n+\t\"unconditional\" instructions.\n+\t(arm_movsf_soft_insn): Modify RTL to not allow for MVE.\n+\t(movdf_soft_insn): Modify RTL to not allow for MVE.\n+\t(vfp_pop_multiple_with_writeback): Enable for MVE.\n+\t(include \"mve.md\"): Include mve.md file.\n+\t* config/arm/arm_mve.h: Add MVE intrinsics head file.\n+\t* config/arm/constraints.md (Up): Constraint to enable \"p0\" register in MVE\n+\tfor vector predicated operands.\n+\t* config/arm/iterators.md (VNIM1): Define.\n+\t(VNINOTM1): Define.\n+\t(VHFBF_split): Define\n+\t* config/arm/mve.md: New file.\n+\t(mve_mov<mode>): Define RTL for move, store and load in MVE.\n+\t(mve_mov<mode>): Define move RTL pattern with vec_duplicate operator for\n+\tsecond operand.\n+\t* config/arm/neon.md (neon_immediate_valid_for_move): Rename with\n+\tsimd_immediate_valid_for_move.\n+\t(neon_mov<mode>): Split pattern and move expand pattern \"movv8hf\" which\n+\tis common to MVE and  NEON to vec-common.md file.\n+\t(vec_init<mode><V_elem_l>): Add TARGET_HAVE_MVE check.\n+\t* config/arm/predicates.md (vpr_register_operand): Define.\n+\t* config/arm/t-arm: Add mve.md file.\n+\t* config/arm/types.md (mve_move): Add MVE instructions mve_move to\n+\tattribute \"type\".\n+\t(mve_store): Add MVE instructions mve_store to attribute \"type\".\n+\t(mve_load): Add MVE instructions mve_load to attribute \"type\".\n+\t(is_mve_type): Define attribute.\n+\t* config/arm/vec-common.md (mov<mode>): Modify RTL expand to support\n+\tstandard move patterns in MVE along with NEON and IWMMXT with mode\n+\titerator VNIM1.\n+\t(mov<mode>): Modify RTL expand to support standard move patterns in NEON\n+\tand IWMMXT with mode iterator V8HF.\n+\t(movv8hf): Define RTL expand to support standard \"movv8hf\" pattern in\n+\tNEON and MVE.\n+\t* config/arm/vfp.md (neon_immediate_valid_for_move): Rename to\n+\tsimd_immediate_valid_for_move.\n+\n+\n 2020-03-16  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/89229"}, {"sha": "13e3cb753e2c6b9b326d182ffb38944fb44454a5", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -346,7 +346,7 @@ arc*-*-*)\n arm*-*-*)\n \tcpu_type=arm\n \textra_objs=\"arm-builtins.o aarch-common.o\"\n-\textra_headers=\"mmintrin.h arm_neon.h arm_acle.h arm_fp16.h arm_cmse.h arm_bf16.h\"\n+\textra_headers=\"mmintrin.h arm_neon.h arm_acle.h arm_fp16.h arm_cmse.h arm_bf16.h arm_mve.h\"\n \ttarget_type_format_char='%'\n \tc_target_objs=\"arm-c.o\"\n \tcxx_target_objs=\"arm-c.o\""}, {"sha": "afcef1d415dbe790c49f4df314632eb1cbcf090c", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -53,7 +53,9 @@\n /* The assembler's names for the registers.  Note that the ?xx registers are\n    there so that VFPv3/NEON registers D16-D31 have the same spacing as D0-D15\n    (each of which is overlaid on two S registers), although there are no\n-   actual single-precision registers which correspond to D16-D31.  */\n+   actual single-precision registers which correspond to D16-D31.  New register\n+   p0 is added which is used for MVE predicated cases.  */\n+\n #ifndef REGISTER_NAMES\n #define REGISTER_NAMES\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n@@ -72,7 +74,7 @@\n   \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\t\t\\\n   \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\",\t\t\t\t\\\n   \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\t\t\\\n-  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\"\t\t\\\n+  \"cc\", \"vfpcc\", \"sfp\", \"afp\", \"apsrq\", \"apsrge\", \"p0\"\t\t\\\n }\n #endif\n "}, {"sha": "1a9a38d0117c618dfa199fe274b387774d867ca5", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 110, "deletions": 56, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -698,6 +698,7 @@ enum arm_builtins\n   ARM_BUILTIN_SET_FPSCR,\n \n   ARM_BUILTIN_CMSE_NONSECURE_CALLER,\n+  ARM_BUILTIN_SIMD_LANE_CHECK,\n \n #undef CRYPTO1\n #undef CRYPTO2\n@@ -723,7 +724,6 @@ enum arm_builtins\n #include \"arm_vfp_builtins.def\"\n \n   ARM_BUILTIN_NEON_BASE,\n-  ARM_BUILTIN_NEON_LANE_CHECK = ARM_BUILTIN_NEON_BASE,\n \n #include \"arm_neon_builtins.def\"\n \n@@ -987,28 +987,37 @@ arm_init_simd_builtin_types (void)\n      an entry in our mangling table, consequently, they get default\n      mangling.  As a further gotcha, poly8_t and poly16_t are signed\n      types, poly64_t and poly128_t are unsigned types.  */\n-  arm_simd_polyQI_type_node\n-    = build_distinct_type_copy (intQI_type_node);\n-  (*lang_hooks.types.register_builtin_type) (arm_simd_polyQI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly8\");\n-  arm_simd_polyHI_type_node\n-    = build_distinct_type_copy (intHI_type_node);\n-  (*lang_hooks.types.register_builtin_type) (arm_simd_polyHI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly16\");\n-  arm_simd_polyDI_type_node\n-    = build_distinct_type_copy (unsigned_intDI_type_node);\n-  (*lang_hooks.types.register_builtin_type) (arm_simd_polyDI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly64\");\n-  arm_simd_polyTI_type_node\n-    = build_distinct_type_copy (unsigned_intTI_type_node);\n-  (*lang_hooks.types.register_builtin_type) (arm_simd_polyTI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly128\");\n-\n-  /* Prevent front-ends from transforming poly vectors into string\n-     literals.  */\n-  TYPE_STRING_FLAG (arm_simd_polyQI_type_node) = false;\n-  TYPE_STRING_FLAG (arm_simd_polyHI_type_node) = false;\n-\n+  if (!TARGET_HAVE_MVE)\n+    {\n+      arm_simd_polyQI_type_node\n+\t= build_distinct_type_copy (intQI_type_node);\n+      (*lang_hooks.types.register_builtin_type) (arm_simd_polyQI_type_node,\n+\t\t\t\t\t\t \"__builtin_neon_poly8\");\n+      arm_simd_polyHI_type_node\n+\t= build_distinct_type_copy (intHI_type_node);\n+      (*lang_hooks.types.register_builtin_type) (arm_simd_polyHI_type_node,\n+\t\t\t\t\t\t \"__builtin_neon_poly16\");\n+      arm_simd_polyDI_type_node\n+\t= build_distinct_type_copy (unsigned_intDI_type_node);\n+      (*lang_hooks.types.register_builtin_type) (arm_simd_polyDI_type_node,\n+\t\t\t\t\t\t \"__builtin_neon_poly64\");\n+      arm_simd_polyTI_type_node\n+\t= build_distinct_type_copy (unsigned_intTI_type_node);\n+      (*lang_hooks.types.register_builtin_type) (arm_simd_polyTI_type_node,\n+\t\t\t\t\t\t \"__builtin_neon_poly128\");\n+      /* Init poly vector element types with scalar poly types.  */\n+      arm_simd_types[Poly8x8_t].eltype = arm_simd_polyQI_type_node;\n+      arm_simd_types[Poly8x16_t].eltype = arm_simd_polyQI_type_node;\n+      arm_simd_types[Poly16x4_t].eltype = arm_simd_polyHI_type_node;\n+      arm_simd_types[Poly16x8_t].eltype = arm_simd_polyHI_type_node;\n+      /* Note: poly64x2_t is defined in arm_neon.h, to ensure it gets default\n+\t mangling.  */\n+\n+      /* Prevent front-ends from transforming poly vectors into string\n+\t literals.  */\n+      TYPE_STRING_FLAG (arm_simd_polyQI_type_node) = false;\n+      TYPE_STRING_FLAG (arm_simd_polyHI_type_node) = false;\n+    }\n   /* Init all the element types built by the front-end.  */\n   arm_simd_types[Int8x8_t].eltype = intQI_type_node;\n   arm_simd_types[Int8x16_t].eltype = intQI_type_node;\n@@ -1025,11 +1034,6 @@ arm_init_simd_builtin_types (void)\n   arm_simd_types[Uint32x4_t].eltype = unsigned_intSI_type_node;\n   arm_simd_types[Uint64x2_t].eltype = unsigned_intDI_type_node;\n \n-  /* Init poly vector element types with scalar poly types.  */\n-  arm_simd_types[Poly8x8_t].eltype = arm_simd_polyQI_type_node;\n-  arm_simd_types[Poly8x16_t].eltype = arm_simd_polyQI_type_node;\n-  arm_simd_types[Poly16x4_t].eltype = arm_simd_polyHI_type_node;\n-  arm_simd_types[Poly16x8_t].eltype = arm_simd_polyHI_type_node;\n   /* Note: poly64x2_t is defined in arm_neon.h, to ensure it gets default\n      mangling.  */\n \n@@ -1051,6 +1055,8 @@ arm_init_simd_builtin_types (void)\n       tree eltype = arm_simd_types[i].eltype;\n       machine_mode mode = arm_simd_types[i].mode;\n \n+      if (eltype == NULL)\n+\tcontinue;\n       if (arm_simd_types[i].itype == NULL)\n \tarm_simd_types[i].itype =\n \t  build_distinct_type_copy\n@@ -1290,15 +1296,6 @@ arm_init_neon_builtins (void)\n      system.  */\n   arm_init_simd_builtin_scalar_types ();\n \n-  tree lane_check_fpr = build_function_type_list (void_type_node,\n-\t\t\t\t\t\t  intSI_type_node,\n-\t\t\t\t\t\t  intSI_type_node,\n-\t\t\t\t\t\t  NULL);\n-  arm_builtin_decls[ARM_BUILTIN_NEON_LANE_CHECK] =\n-      add_builtin_function (\"__builtin_arm_lane_check\", lane_check_fpr,\n-\t\t\t    ARM_BUILTIN_NEON_LANE_CHECK, BUILT_IN_MD,\n-\t\t\t    NULL, NULL_TREE);\n-\n   for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++, fcode++)\n     {\n       arm_builtin_datum *d = &neon_builtin_data[i];\n@@ -2017,6 +2014,15 @@ arm_init_builtins (void)\n \n   if (TARGET_MAYBE_HARD_FLOAT)\n     {\n+      tree lane_check_fpr = build_function_type_list (void_type_node,\n+\t\t\t\t\t\t      intSI_type_node,\n+\t\t\t\t\t\t      intSI_type_node,\n+\t\t\t\t\t\t      NULL);\n+      arm_builtin_decls[ARM_BUILTIN_SIMD_LANE_CHECK]\n+      = add_builtin_function (\"__builtin_arm_lane_check\", lane_check_fpr,\n+\t\t\t      ARM_BUILTIN_SIMD_LANE_CHECK, BUILT_IN_MD,\n+\t\t\t      NULL, NULL_TREE);\n+\n       arm_init_neon_builtins ();\n       arm_init_vfp_builtins ();\n       arm_init_crypto_builtins ();\n@@ -2263,6 +2269,47 @@ neon_dereference_pointer (tree exp, tree type, machine_mode mem_mode,\n \t\t      build_int_cst (build_pointer_type (array_type), 0));\n }\n \n+/* EXP is a pointer argument to a vector scatter store intrinsics.\n+\n+   Consider the following example:\n+\tVSTRW<v>.<dt> Qd, [Qm{, #+/-<imm>}]!\n+   When <Qm> used as the base register for the target address,\n+   this function is used to derive and return an expression for the\n+   accessed memory.\n+\n+   The intrinsic function operates on a block of registers that has mode\n+   REG_MODE.  This block contains vectors of type TYPE_MODE.  The function\n+   references the memory at EXP of type TYPE and in mode MEM_MODE.  This\n+   mode may be BLKmode if no more suitable mode is available.  */\n+\n+static tree\n+mve_dereference_pointer (tree exp, tree type, machine_mode reg_mode,\n+\t\t\t machine_mode vector_mode)\n+{\n+  HOST_WIDE_INT reg_size, vector_size, nelems;\n+  tree elem_type, upper_bound, array_type;\n+\n+  /* Work out the size of each vector in bytes.  */\n+  vector_size = GET_MODE_SIZE (vector_mode);\n+\n+  /* Work out the size of the register block in bytes.  */\n+  reg_size = GET_MODE_SIZE (reg_mode);\n+\n+  /* Work out the type of each element.  */\n+  gcc_assert (POINTER_TYPE_P (type));\n+  elem_type = TREE_TYPE (type);\n+\n+  nelems = reg_size / vector_size;\n+\n+  /* Create a type that describes the full access.  */\n+  upper_bound = build_int_cst (size_type_node, nelems - 1);\n+  array_type = build_array_type (elem_type, build_index_type (upper_bound));\n+\n+  /* Dereference EXP using that type.  */\n+  return fold_build2 (MEM_REF, array_type, exp,\n+\t\t      build_int_cst (build_pointer_type (array_type), 0));\n+}\n+\n /* Expand a builtin.  */\n static rtx\n arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n@@ -2301,10 +2348,17 @@ arm_expand_builtin_args (rtx target, machine_mode map_mode, int fcode,\n             {\n               machine_mode other_mode\n \t\t= insn_data[icode].operand[1 - opno].mode;\n-              arg[argc] = neon_dereference_pointer (arg[argc],\n+\t      if (TARGET_HAVE_MVE && mode[argc] != other_mode)\n+\t\t{\n+\t\t  arg[argc] = mve_dereference_pointer (arg[argc],\n \t\t\t\t\t\t    TREE_VALUE (formals),\n-\t\t\t\t\t\t    mode[argc], other_mode,\n-\t\t\t\t\t\t    map_mode);\n+\t\t\t\t\t\t    other_mode, map_mode);\n+\t\t}\n+\t      else\n+\t\targ[argc] = neon_dereference_pointer (arg[argc],\n+\t\t\t\t\t\t      TREE_VALUE (formals),\n+\t\t\t\t\t\t      mode[argc], other_mode,\n+\t\t\t\t\t\t      map_mode);\n             }\n \n \t  /* Use EXPAND_MEMORY for ARG_BUILTIN_MEMORY and\n@@ -2625,22 +2679,6 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n       return const0_rtx;\n     }\n \n-  if (fcode == ARM_BUILTIN_NEON_LANE_CHECK)\n-    {\n-      /* Builtin is only to check bounds of the lane passed to some intrinsics\n-\t that are implemented with gcc vector extensions in arm_neon.h.  */\n-\n-      tree nlanes = CALL_EXPR_ARG (exp, 0);\n-      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);\n-      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));\n-      if (CONST_INT_P (lane_idx))\n-\tneon_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);\n-      else\n-\terror (\"%Klane index must be a constant immediate\", exp);\n-      /* Don't generate any RTL.  */\n-      return const0_rtx;\n-    }\n-\n   arm_builtin_datum *d\n     = &neon_builtin_data[fcode - ARM_BUILTIN_NEON_PATTERN_START];\n \n@@ -2702,6 +2740,22 @@ arm_expand_builtin (tree exp,\n   int mask;\n   int imm;\n \n+  if (fcode == ARM_BUILTIN_SIMD_LANE_CHECK)\n+    {\n+      /* Builtin is only to check bounds of the lane passed to some intrinsics\n+\t that are implemented with gcc vector extensions in arm_neon.h.  */\n+\n+      tree nlanes = CALL_EXPR_ARG (exp, 0);\n+      gcc_assert (TREE_CODE (nlanes) == INTEGER_CST);\n+      rtx lane_idx = expand_normal (CALL_EXPR_ARG (exp, 1));\n+      if (CONST_INT_P (lane_idx))\n+\tneon_lane_bounds (lane_idx, 0, TREE_INT_CST_LOW (nlanes), exp);\n+      else\n+\terror (\"%Klane index must be a constant immediate\", exp);\n+      /* Don't generate any RTL.  */\n+      return const0_rtx;\n+    }\n+\n   if (fcode >= ARM_BUILTIN_ACLE_BASE)\n     return arm_expand_acle_builtin (fcode, exp, target);\n "}, {"sha": "73bdb9cfae03f51e6fd5ef260900c0a6bf165486", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -79,6 +79,16 @@ arm_cpu_builtins (struct cpp_reader* pfile)\n   def_or_undef_macro (pfile, \"__ARM_FEATURE_COMPLEX\", TARGET_COMPLEX);\n   def_or_undef_macro (pfile, \"__ARM_32BIT_STATE\", TARGET_32BIT);\n \n+  cpp_undef (pfile, \"__ARM_FEATURE_MVE\");\n+  if (TARGET_HAVE_MVE && TARGET_HAVE_MVE_FLOAT)\n+    {\n+      builtin_define_with_int_value (\"__ARM_FEATURE_MVE\", 3);\n+    }\n+  else if (TARGET_HAVE_MVE)\n+    {\n+      builtin_define_with_int_value (\"__ARM_FEATURE_MVE\", 1);\n+    }\n+\n   cpp_undef (pfile, \"__ARM_FEATURE_CMSE\");\n   if (arm_arch8 && !arm_arch_notm)\n     {"}, {"sha": "b6710a6e214c72133248c4e47e2d12738b3a731e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -86,7 +86,7 @@ extern bool ldm_stm_operation_p (rtx, bool, machine_mode mode,\n extern bool clear_operation_p (rtx, bool);\n extern int arm_const_double_rtx (rtx);\n extern int vfp3_const_double_rtx (rtx);\n-extern int neon_immediate_valid_for_move (rtx, machine_mode, rtx *, int *);\n+extern int simd_immediate_valid_for_move (rtx, machine_mode, rtx *, int *);\n extern int neon_immediate_valid_for_logic (rtx, machine_mode, int, rtx *,\n \t\t\t\t\t   int *);\n extern int neon_immediate_valid_for_shift (rtx, machine_mode, rtx *,"}, {"sha": "c769104a93746cd7c02b46b82f1a8f8057b9ae62", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 201, "deletions": 60, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -3823,7 +3823,8 @@ arm_options_perform_arch_sanity_checks (void)\n       else if (TARGET_HARD_FLOAT_ABI)\n \t{\n \t  arm_pcs_default = ARM_PCS_AAPCS_VFP;\n-\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2))\n+\t  if (!bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv2)\n+\t      && !bitmap_bit_p (arm_active_target.isa, isa_bit_mve))\n \t    error (\"%<-mfloat-abi=hard%>: selected processor lacks an FPU\");\n \t}\n       else\n@@ -4294,7 +4295,7 @@ use_return_insn (int iscond, rtx sibling)\n \n   /* Can't be done if any of the VFP regs are pushed,\n      since this also requires an insn.  */\n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n     for (regno = FIRST_VFP_REGNUM; regno <= LAST_VFP_REGNUM; regno++)\n       if (df_regs_ever_live_p (regno) && !call_used_or_fixed_reg_p (regno))\n \treturn 0;\n@@ -6385,15 +6386,15 @@ aapcs_vfp_allocate (CUMULATIVE_ARGS *pcum, machine_mode mode,\n       {\n \tpcum->aapcs_vfp_reg_alloc = mask << regno;\n \tif (mode == BLKmode\n-\t    || (mode == TImode && ! TARGET_NEON)\n+\t    || (mode == TImode && ! (TARGET_NEON || TARGET_HAVE_MVE))\n \t    || ! arm_hard_regno_mode_ok (FIRST_VFP_REGNUM + regno, mode))\n \t  {\n \t    int i;\n \t    int rcount = pcum->aapcs_vfp_rcount;\n \t    int rshift = shift;\n \t    machine_mode rmode = pcum->aapcs_vfp_rmode;\n \t    rtx par;\n-\t    if (!TARGET_NEON)\n+\t    if (!(TARGET_NEON || TARGET_HAVE_MVE))\n \t      {\n \t\t/* Avoid using unsupported vector modes.  */\n \t\tif (rmode == V2SImode)\n@@ -6439,7 +6440,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n   if (mode == BLKmode\n       || (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_SIZE (mode) >= GET_MODE_SIZE (TImode)\n-\t  && !TARGET_NEON))\n+\t  && !(TARGET_NEON || TARGET_HAVE_MVE)))\n     {\n       int count;\n       machine_mode ag_mode;\n@@ -6450,7 +6451,7 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n       aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,\n \t\t\t\t\t     &ag_mode, &count);\n \n-      if (!TARGET_NEON)\n+      if (!(TARGET_NEON || TARGET_HAVE_MVE))\n \t{\n \t  if (ag_mode == V2SImode)\n \t    ag_mode = DImode;\n@@ -8349,7 +8350,9 @@ thumb2_legitimate_address_p (machine_mode mode, rtx x, int strict_p)\n \t\t   && CONST_INT_P (XEXP (XEXP (x, 0), 1)))))\n     return 1;\n \n-  else if (mode == TImode || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode)))\n+  else if (mode == TImode\n+\t   || (TARGET_NEON && VALID_NEON_STRUCT_MODE (mode))\n+\t   || (TARGET_HAVE_MVE && VALID_MVE_STRUCT_MODE (mode)))\n     return 0;\n \n   else if (code == PLUS)\n@@ -9902,7 +9905,7 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \t  /* Assume that most copies can be done with a single insn,\n \t     unless we don't have HW FP, in which case everything\n \t     larger than word mode will require two insns.  */\n-\t  *cost = COSTS_N_INSNS (((!TARGET_HARD_FLOAT\n+\t  *cost = COSTS_N_INSNS (((!(TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n \t\t\t\t   && GET_MODE_SIZE (mode) > 4)\n \t\t\t\t  || mode == DImode)\n \t\t\t\t ? 2 : 1);\n@@ -11383,10 +11386,10 @@ arm_rtx_costs_internal (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n     case CONST_VECTOR:\n       /* Fixme.  */\n-      if (TARGET_NEON\n-\t  && TARGET_HARD_FLOAT\n-\t  && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))\n-\t  && neon_immediate_valid_for_move (x, mode, NULL, NULL))\n+      if (((TARGET_NEON && TARGET_HARD_FLOAT\n+\t    && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode)))\n+\t   || TARGET_HAVE_MVE)\n+\t  && simd_immediate_valid_for_move (x, mode, NULL, NULL))\n \t*cost = COSTS_N_INSNS (1);\n       else\n \t*cost = COSTS_N_INSNS (4);\n@@ -12430,8 +12433,8 @@ vfp3_const_double_rtx (rtx x)\n   return vfp3_const_double_index (x) != -1;\n }\n \n-/* Recognize immediates which can be used in various Neon instructions. Legal\n-   immediates are described by the following table (for VMVN variants, the\n+/* Recognize immediates which can be used in various Neon and MVE instructions.\n+   Legal immediates are described by the following table (for VMVN variants, the\n    bitwise inverse of the constant shown is recognized. In either case, VMOV\n    is output and the correct instruction to use for a given constant is chosen\n    by the assembler). The constant shown is replicated across all elements of\n@@ -12482,7 +12485,7 @@ vfp3_const_double_rtx (rtx x)\n    -1 if the given value doesn't match any of the listed patterns.\n */\n static int\n-neon_valid_immediate (rtx op, machine_mode mode, int inverse,\n+simd_valid_immediate (rtx op, machine_mode mode, int inverse,\n \t\t      rtx *modconst, int *elementwidth)\n {\n #define CHECK(STRIDE, ELSIZE, CLASS, TEST)\t\\\n@@ -12514,6 +12517,10 @@ neon_valid_immediate (rtx op, machine_mode mode, int inverse,\n \n   innersize = GET_MODE_UNIT_SIZE (mode);\n \n+  /* Only support 128-bit vectors for MVE.  */\n+  if (TARGET_HAVE_MVE && (!vector || n_elts * innersize != 16))\n+    return -1;\n+\n   /* Vectors of float constants.  */\n   if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n     {\n@@ -12662,18 +12669,19 @@ neon_valid_immediate (rtx op, machine_mode mode, int inverse,\n #undef CHECK\n }\n \n-/* Return TRUE if rtx X is legal for use as either a Neon VMOV (or, implicitly,\n-   VMVN) immediate. Write back width per element to *ELEMENTWIDTH (or zero for\n-   float elements), and a modified constant (whatever should be output for a\n-   VMOV) in *MODCONST.  */\n-\n+/* Return TRUE if rtx X is legal for use as either a Neon or MVE VMOV (or,\n+   implicitly, VMVN) immediate.  Write back width per element to *ELEMENTWIDTH\n+   (or zero for float elements), and a modified constant (whatever should be\n+   output for a VMOV) in *MODCONST.  \"neon_immediate_valid_for_move\" function is\n+   modified to \"simd_immediate_valid_for_move\" as this function will be used\n+   both by neon and mve.  */\n int\n-neon_immediate_valid_for_move (rtx op, machine_mode mode,\n+simd_immediate_valid_for_move (rtx op, machine_mode mode,\n \t\t\t       rtx *modconst, int *elementwidth)\n {\n   rtx tmpconst;\n   int tmpwidth;\n-  int retval = neon_valid_immediate (op, mode, 0, &tmpconst, &tmpwidth);\n+  int retval = simd_valid_immediate (op, mode, 0, &tmpconst, &tmpwidth);\n \n   if (retval == -1)\n     return 0;\n@@ -12690,15 +12698,15 @@ neon_immediate_valid_for_move (rtx op, machine_mode mode,\n /* Return TRUE if rtx X is legal for use in a VORR or VBIC instruction.  If\n    the immediate is valid, write a constant suitable for using as an operand\n    to VORR/VBIC/VAND/VORN to *MODCONST and the corresponding element width to\n-   *ELEMENTWIDTH. See neon_valid_immediate for description of INVERSE.  */\n+   *ELEMENTWIDTH.  See simd_valid_immediate for description of INVERSE.  */\n \n int\n neon_immediate_valid_for_logic (rtx op, machine_mode mode, int inverse,\n \t\t\t\trtx *modconst, int *elementwidth)\n {\n   rtx tmpconst;\n   int tmpwidth;\n-  int retval = neon_valid_immediate (op, mode, inverse, &tmpconst, &tmpwidth);\n+  int retval = simd_valid_immediate (op, mode, inverse, &tmpconst, &tmpwidth);\n \n   if (retval < 0 || retval > 5)\n     return 0;\n@@ -12905,7 +12913,7 @@ neon_make_constant (rtx vals)\n     gcc_unreachable ();\n \n   if (const_vec != NULL\n-      && neon_immediate_valid_for_move (const_vec, mode, NULL, NULL))\n+      && simd_immediate_valid_for_move (const_vec, mode, NULL, NULL))\n     /* Load using VMOV.  On Cortex-A8 this takes one cycle.  */\n     return const_vec;\n   else if ((target = neon_vdup_constant (vals)) != NULL_RTX)\n@@ -13182,6 +13190,15 @@ neon_vector_mem_operand (rtx op, int type, bool strict)\n       && (INTVAL (XEXP (ind, 1)) & 3) == 0)\n     return TRUE;\n \n+  if (type == 1 && TARGET_HAVE_MVE\n+      && (GET_CODE (ind) == POST_INC || GET_CODE (ind) == PRE_DEC))\n+    {\n+      rtx ind1 = XEXP (ind, 0);\n+      if (!REG_P (ind1))\n+\treturn 0;\n+      return VFP_REGNO_OK_FOR_SINGLE (REGNO (ind1));\n+    }\n+\n   return FALSE;\n }\n \n@@ -20050,7 +20067,7 @@ output_move_neon (rtx *operands)\n     {\n     case POST_INC:\n       /* We have to use vldm / vstm for too-large modes.  */\n-      if (nregs > 4)\n+      if (nregs > 4 || (TARGET_HAVE_MVE && nregs >= 2))\n \t{\n \t  templ = \"v%smia%%?\\t%%0!, %%h1\";\n \t  ops[0] = XEXP (addr, 0);\n@@ -20079,7 +20096,7 @@ output_move_neon (rtx *operands)\n       /* We have to use vldm / vstm for too-large modes.  */\n       if (nregs > 1)\n \t{\n-\t  if (nregs > 4)\n+\t  if (nregs > 4 || (TARGET_HAVE_MVE && nregs >= 2))\n \t    templ = \"v%smia%%?\\t%%m0, %%h1\";\n \t  else\n \t    templ = \"v%s1.64\\t%%h1, %%A0\";\n@@ -20094,29 +20111,47 @@ output_move_neon (rtx *operands)\n       {\n \tint i;\n \tint overlap = -1;\n-\tfor (i = 0; i < nregs; i++)\n+\tif (TARGET_HAVE_MVE && !BYTES_BIG_ENDIAN\n+\t    && GET_CODE (addr) != LABEL_REF)\n+\t  {\n+\t    sprintf (buff, \"v%srw.32\\t%%q0, %%1\", load ? \"ld\" : \"st\");\n+\t    ops[0] = reg;\n+\t    ops[1] = mem;\n+\t    output_asm_insn (buff, ops);\n+\t  }\n+\telse\n \t  {\n-\t    /* We're only using DImode here because it's a convenient size.  */\n-\t    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);\n-\t    ops[1] = adjust_address (mem, DImode, 8 * i);\n-\t    if (reg_overlap_mentioned_p (ops[0], mem))\n+\t    for (i = 0; i < nregs; i++)\n \t      {\n-\t\tgcc_assert (overlap == -1);\n-\t\toverlap = i;\n+\t\t/* We're only using DImode here because it's a convenient\n+\t\t   size.  */\n+\t\tops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * i);\n+\t\tops[1] = adjust_address (mem, DImode, 8 * i);\n+\t\tif (reg_overlap_mentioned_p (ops[0], mem))\n+\t\t  {\n+\t\t    gcc_assert (overlap == -1);\n+\t\t    overlap = i;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (TARGET_HAVE_MVE && GET_CODE (addr) == LABEL_REF)\n+\t\t      sprintf (buff, \"v%sr.64\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t\t    else\n+\t\t      sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t\t    output_asm_insn (buff, ops);\n+\t\t  }\n \t      }\n-\t    else\n+\t    if (overlap != -1)\n \t      {\n-\t\tsprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t\tops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * overlap);\n+\t\tops[1] = adjust_address (mem, SImode, 8 * overlap);\n+\t\tif (TARGET_HAVE_MVE && GET_CODE (addr) == LABEL_REF)\n+\t\t  sprintf (buff, \"v%sr.32\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n+\t\telse\n+\t\t  sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n \t\toutput_asm_insn (buff, ops);\n \t      }\n \t  }\n-\tif (overlap != -1)\n-\t  {\n-\t    ops[0] = gen_rtx_REG (DImode, REGNO (reg) + 2 * overlap);\n-\t    ops[1] = adjust_address (mem, SImode, 8 * overlap);\n-\t    sprintf (buff, \"v%sr%%?\\t%%P0, %%1\", load ? \"ld\" : \"st\");\n-\t    output_asm_insn (buff, ops);\n-\t  }\n \n         return \"\";\n       }\n@@ -22329,7 +22364,7 @@ arm_compute_frame_layout (void)\n       func_type = arm_current_func_type ();\n       /* Space for saved VFP registers.  */\n       if (! IS_VOLATILE (func_type)\n-\t  && TARGET_HARD_FLOAT)\n+\t  && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE))\n \tsaved += arm_get_vfp_saved_size ();\n \n       /* Allocate space for saving/restoring FPCXTNS in Armv8.1-M Mainline\n@@ -22553,7 +22588,7 @@ arm_save_coproc_regs(void)\n \tsaved_size += 8;\n       }\n \n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n     {\n       start_reg = FIRST_VFP_REGNUM;\n \n@@ -23858,6 +23893,53 @@ arm_print_operand (FILE *stream, rtx x, int code)\n       }\n       return;\n \n+    /* To print the memory operand with \"Us\" constraint.  Based on the rtx_code\n+       the memory operands output looks like following.\n+       1. [Rn], #+/-<imm>\n+       2. [Rn, #+/-<imm>]!\n+       3. [Rn].  */\n+    case 'E':\n+      {\n+\trtx addr;\n+\trtx postinc_reg = NULL;\n+\tunsigned inc_val = 0;\n+\tenum rtx_code code;\n+\n+\tgcc_assert (MEM_P (x));\n+\taddr = XEXP (x, 0);\n+\tcode = GET_CODE (addr);\n+\tif (code == POST_INC || code == POST_DEC || code == PRE_INC\n+\t    || code  == PRE_DEC)\n+\t  {\n+\t    asm_fprintf (stream, \"[%r\", REGNO (XEXP (addr, 0)));\n+\t    inc_val = GET_MODE_SIZE (GET_MODE (x));\n+\t    if (code == POST_INC || code == POST_DEC)\n+\t      asm_fprintf (stream, \"], #%s%d\",(code == POST_INC)\n+\t\t\t\t\t      ? \"\": \"-\", inc_val);\n+\t    else\n+\t      asm_fprintf (stream, \", #%s%d]!\",(code == PRE_INC)\n+\t\t\t\t\t       ? \"\": \"-\", inc_val);\n+\t  }\n+\telse if (code == POST_MODIFY || code == PRE_MODIFY)\n+\t  {\n+\t    asm_fprintf (stream, \"[%r\", REGNO (XEXP (addr, 0)));\n+\t    postinc_reg = XEXP ( XEXP (x, 1), 1);\n+\t    if (postinc_reg && CONST_INT_P (postinc_reg))\n+\t      {\n+\t\tif (code == POST_MODIFY)\n+\t\t  asm_fprintf (stream, \"], #%wd\",INTVAL (postinc_reg));\n+\t\telse\n+\t\t  asm_fprintf (stream, \", #%wd]!\",INTVAL (postinc_reg));\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    gcc_assert (REG_P (addr));\n+\t    asm_fprintf (stream, \"[%r]\",REGNO (addr));\n+\t  }\n+      }\n+      return;\n+\n     case 'C':\n       {\n \trtx addr;\n@@ -24035,9 +24117,10 @@ arm_print_operand_address (FILE *stream, machine_mode mode, rtx x)\n \t\t\t REGNO (XEXP (x, 0)),\n \t\t\t GET_CODE (x) == PRE_DEC ? \"-\" : \"\",\n \t\t\t GET_MODE_SIZE (mode));\n+\t  else if (TARGET_HAVE_MVE && (mode == OImode || mode == XImode))\n+\t    asm_fprintf (stream, \"[%r]!\", REGNO (XEXP (x,0)));\n \t  else\n-\t    asm_fprintf (stream, \"[%r], #%s%d\",\n-\t\t\t REGNO (XEXP (x, 0)),\n+\t    asm_fprintf (stream, \"[%r], #%s%d\", REGNO (XEXP (x, 0)),\n \t\t\t GET_CODE (x) == POST_DEC ? \"-\" : \"\",\n \t\t\t GET_MODE_SIZE (mode));\n \t}\n@@ -24882,12 +24965,15 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n     return (regno == CC_REGNUM\n-\t    || (TARGET_HARD_FLOAT\n+\t    || ((TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n \t\t&& regno == VFPCC_REGNUM));\n \n   if (regno == CC_REGNUM && GET_MODE_CLASS (mode) != MODE_CC)\n     return false;\n \n+  if (IS_VPR_REGNUM (regno))\n+    return true;\n+\n   if (TARGET_THUMB1)\n     /* For the Thumb we only allow values bigger than SImode in\n        registers 0 - 6, so that there is always a second low\n@@ -24896,7 +24982,7 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n-  if (TARGET_HARD_FLOAT && IS_VFP_REGNUM (regno))\n+  if ((TARGET_HARD_FLOAT || TARGET_HAVE_MVE) && IS_VFP_REGNUM (regno))\n     {\n       if (mode == DFmode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n@@ -24914,6 +25000,10 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t       || (mode == OImode && NEON_REGNO_OK_FOR_NREGS (regno, 4))\n \t       || (mode == CImode && NEON_REGNO_OK_FOR_NREGS (regno, 6))\n \t       || (mode == XImode && NEON_REGNO_OK_FOR_NREGS (regno, 8));\n+     if (TARGET_HAVE_MVE)\n+       return ((VALID_MVE_MODE (mode) && NEON_REGNO_OK_FOR_QUAD (regno))\n+\t       || (mode == OImode && NEON_REGNO_OK_FOR_NREGS (regno, 4))\n+\t       || (mode == XImode && NEON_REGNO_OK_FOR_NREGS (regno, 8)));\n \n       return false;\n     }\n@@ -24963,13 +25053,18 @@ arm_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n   /* We specifically want to allow elements of \"structure\" modes to\n      be tieable to the structure.  This more general condition allows\n      other rarer situations too.  */\n-  if (TARGET_NEON\n-      && (VALID_NEON_DREG_MODE (mode1)\n-\t  || VALID_NEON_QREG_MODE (mode1)\n-\t  || VALID_NEON_STRUCT_MODE (mode1))\n-      && (VALID_NEON_DREG_MODE (mode2)\n-\t  || VALID_NEON_QREG_MODE (mode2)\n-\t  || VALID_NEON_STRUCT_MODE (mode2)))\n+  if ((TARGET_NEON\n+       && (VALID_NEON_DREG_MODE (mode1)\n+\t   || VALID_NEON_QREG_MODE (mode1)\n+\t   || VALID_NEON_STRUCT_MODE (mode1))\n+       && (VALID_NEON_DREG_MODE (mode2)\n+\t   || VALID_NEON_QREG_MODE (mode2)\n+\t   || VALID_NEON_STRUCT_MODE (mode2)))\n+      || (TARGET_HAVE_MVE\n+\t  && (VALID_MVE_MODE (mode1)\n+\t      || VALID_MVE_STRUCT_MODE (mode1))\n+\t  && (VALID_MVE_MODE (mode2)\n+\t      || VALID_MVE_STRUCT_MODE (mode2))))\n     return true;\n \n   return false;\n@@ -24984,6 +25079,9 @@ arm_regno_class (int regno)\n   if (regno == PC_REGNUM)\n     return NO_REGS;\n \n+  if (IS_VPR_REGNUM (regno))\n+    return VPR_REG;\n+\n   if (TARGET_THUMB1)\n     {\n       if (regno == STACK_POINTER_REGNUM)\n@@ -26835,7 +26933,7 @@ arm_expand_epilogue_apcs_frame (bool really_return)\n         floats_from_frame += 4;\n       }\n \n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n     {\n       int start_reg;\n       rtx ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n@@ -27081,7 +27179,7 @@ arm_expand_epilogue (bool really_return)\n         }\n     }\n \n-  if (TARGET_HARD_FLOAT)\n+  if (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\n     {\n       /* Generate VFP register multi-pop.  */\n       int end_reg = LAST_VFP_REGNUM + 1;\n@@ -27255,7 +27353,7 @@ arm_expand_epilogue (bool really_return)\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-      }\n+    }\n \n   if (!really_return)\n     return;\n@@ -27696,6 +27794,20 @@ arm_print_asm_arch_directives ()\n \t{\n \t  arm_initialize_isa (opt_bits, opt->isa_bits);\n \n+\t  /* For the cases \"-march=armv8.1-m.main+mve -mfloat-abi=soft\" and\n+\t     \"-march=armv8.1-m.main+mve.fp -mfloat-abi=soft\" MVE and MVE with\n+\t     floating point instructions is disabled.  So the following check\n+\t     restricts the printing of \".arch_extension mve\" and\n+\t     \".arch_extension fp\" (for mve.fp) in the assembly file.  MVE needs\n+\t     this special behaviour because the feature bit \"mve\" and\n+\t     \"mve_float\" are not part of \"fpu bits\", so they are not cleared\n+\t     when -mfloat-abi=soft (i.e nofp) but the marco TARGET_HAVE_MVE and\n+\t     TARGET_HAVE_MVE_FLOAT are disabled.  */\n+\t  if ((bitmap_bit_p (opt_bits, isa_bit_mve) && !TARGET_HAVE_MVE)\n+\t      || (bitmap_bit_p (opt_bits, isa_bit_mve_float)\n+\t\t  && !TARGET_HAVE_MVE_FLOAT))\n+\t    continue;\n+\n \t  /* If every feature bit of this option is set in the target\n \t     ISA specification, print out the option name.  However,\n \t     don't print anything if all the bits are part of the\n@@ -28505,6 +28617,15 @@ arm_vector_mode_supported_p (machine_mode mode)\n       || mode == V2HAmode))\n     return true;\n \n+  if (TARGET_HAVE_MVE\n+      && (mode == V2DImode || mode == V4SImode || mode == V8HImode\n+\t  || mode == V16QImode))\n+      return true;\n+\n+  if (TARGET_HAVE_MVE_FLOAT\n+      && (mode == V2DFmode || mode == V4SFmode || mode == V8HFmode))\n+      return true;\n+\n   return false;\n }\n \n@@ -28522,6 +28643,10 @@ arm_array_mode_supported_p (machine_mode mode,\n       && (nelems >= 2 && nelems <= 4))\n     return true;\n \n+  if (TARGET_HAVE_MVE && !BYTES_BIG_ENDIAN\n+      && VALID_MVE_MODE (mode) && (nelems == 2 || nelems == 4))\n+    return true;\n+\n   return false;\n }\n \n@@ -29574,7 +29699,7 @@ arm_conditional_register_usage (void)\n   if (TARGET_THUMB1)\n     fixed_regs[LR_REGNUM] = call_used_regs[LR_REGNUM] = 1;\n \n-  if (TARGET_32BIT && TARGET_HARD_FLOAT)\n+  if (TARGET_32BIT && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE))\n     {\n       /* VFPv3 registers are disabled when earlier VFP\n \t versions are selected due to the definition of\n@@ -29586,6 +29711,8 @@ arm_conditional_register_usage (void)\n \t  call_used_regs[regno] = regno < FIRST_VFP_REGNUM + 16\n \t    || regno >= FIRST_VFP_REGNUM + 32;\n \t}\n+      if (TARGET_HAVE_MVE)\n+\tfixed_regs[VPR_REGNUM] = 0;\n     }\n \n   if (TARGET_REALLY_IWMMXT && !TARGET_GENERAL_REGS_ONLY)\n@@ -32306,6 +32433,20 @@ arm_declare_function_name (FILE *stream, const char *name, tree decl)\n \t      if (!opt->remove)\n \t\t{\n \t\t  arm_initialize_isa (opt_bits, opt->isa_bits);\n+\t\t  /* For the cases \"-march=armv8.1-m.main+mve -mfloat-abi=soft\"\n+\t\t     and \"-march=armv8.1-m.main+mve.fp -mfloat-abi=soft\" MVE and\n+\t\t     MVE with floating point instructions is disabled.  So the\n+\t\t     following check restricts the printing of \".arch_extension\n+\t\t     mve\" and \".arch_extension fp\" (for mve.fp) in the assembly\n+\t\t     file.    MVE needs this special behaviour because the\n+\t\t     feature bit \"mve\" and \"mve_float\" are not part of\n+\t\t     \"fpu bits\", so they are not cleared when -mfloat-abi=soft\n+\t\t     (i.e nofp) but the marco TARGET_HAVE_MVE and\n+\t\t     TARGET_HAVE_MVE_FLOAT are disabled.  */\n+\t\t  if ((bitmap_bit_p (opt_bits, isa_bit_mve) && !TARGET_HAVE_MVE)\n+\t\t      || (bitmap_bit_p (opt_bits, isa_bit_mve_float)\n+\t\t\t  && !TARGET_HAVE_MVE_FLOAT))\n+\t\t    continue;\n \t\t  if (bitmap_subset_p (opt_bits, arm_active_target.isa)\n \t\t      && !bitmap_subset_p (opt_bits, isa_all_fpubits_internal))\n \t\t    asm_fprintf (asm_out_file, \"\\t.arch_extension %s\\n\","}, {"sha": "a0283ed62c8047fe1ccbbb9b639ad34771fe46c2", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -324,11 +324,15 @@ emission of floating point pcs attributes.  */\n    instructions (most are floating-point related).  */\n #define TARGET_HAVE_FPCXT_CMSE\t(arm_arch8_1m_main)\n \n-#define TARGET_HAVE_MVE (bitmap_bit_p (arm_active_target.isa, \\\n-\t\t\t\t       isa_bit_mve))\n+#define TARGET_HAVE_MVE (arm_float_abi != ARM_FLOAT_ABI_SOFT \\\n+\t\t\t && bitmap_bit_p (arm_active_target.isa, \\\n+\t\t\t\t\t  isa_bit_mve) \\\n+\t\t\t && !TARGET_GENERAL_REGS_ONLY)\n \n-#define TARGET_HAVE_MVE_FLOAT (bitmap_bit_p (arm_active_target.isa, \\\n-\t\t\t\t\t     isa_bit_mve_float))\n+#define TARGET_HAVE_MVE_FLOAT (arm_float_abi != ARM_FLOAT_ABI_SOFT \\\n+\t\t\t       && bitmap_bit_p (arm_active_target.isa, \\\n+\t\t\t\t\t\tisa_bit_mve_float) \\\n+\t\t\t       && !TARGET_GENERAL_REGS_ONLY)\n \n /* Nonzero if integer division instructions supported.  */\n #define TARGET_IDIV\t((TARGET_ARM && arm_arch_arm_hwdiv)\t\\\n@@ -767,7 +771,8 @@ extern int arm_arch_bf16;\n /*\ts0-s15\t\tVFP scratch (aka d0-d7).\n \ts16-s31\t      S\tVFP variable (aka d8-d15).\n \tvfpcc\t\tNot a real register.  Represents the VFP condition\n-\t\t\tcode flags.  */\n+\t\t\tcode flags.\n+\tvpr\t\tUsed to represent MVE VPR predication.  */\n \n /* The stack backtrace structure is as follows:\n   fp points to here:  |  save code pointer  |      [fp]\n@@ -808,7 +813,7 @@ extern int arm_arch_bf16;\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -838,7 +843,7 @@ extern int arm_arch_bf16;\n   1,1,1,1,1,1,1,1,\t\t\\\n   1,1,1,1,\t\t\t\\\n   /* Specials.  */\t\t\\\n-  1,1,1,1,1,1\t\t\t\\\n+  1,1,1,1,1,1,1\t\t\t\\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -1014,10 +1019,10 @@ extern int arm_arch_bf16;\n    && (LAST_VFP_REGNUM - (REGNUM) >= 2 * (N) - 1))\n \n /* The number of hard registers is 16 ARM + 1 CC + 1 SFP + 1 AFP\n-   + 1 APSRQ + 1 APSRGE.  */\n+   + 1 APSRQ + 1 APSRGE + 1 VPR.  */\n /* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n /* VFP (VFP3) adds 32 (64) + 1 VFPCC.  */\n-#define FIRST_PSEUDO_REGISTER   106\n+#define FIRST_PSEUDO_REGISTER   107\n \n #define DBX_REGISTER_NUMBER(REGNO) arm_dbx_register_number (REGNO)\n \n@@ -1047,11 +1052,26 @@ extern int arm_arch_bf16;\n    || (MODE) == V8HFmode || (MODE) == V4SFmode || (MODE) == V2DImode \\\n    || (MODE) == V8BFmode)\n \n+#define VALID_MVE_MODE(MODE) \\\n+  ((MODE) == V2DImode ||(MODE) == V4SImode || (MODE) == V8HImode \\\n+   || (MODE) == V16QImode || (MODE) == V8HFmode || (MODE) == V4SFmode \\\n+   || (MODE) == V2DFmode)\n+\n+#define VALID_MVE_SI_MODE(MODE) \\\n+  ((MODE) == V2DImode ||(MODE) == V4SImode || (MODE) == V8HImode \\\n+   || (MODE) == V16QImode)\n+\n+#define VALID_MVE_SF_MODE(MODE) \\\n+  ((MODE) == V8HFmode || (MODE) == V4SFmode || (MODE) == V2DFmode)\n+\n /* Structure modes valid for Neon registers.  */\n #define VALID_NEON_STRUCT_MODE(MODE) \\\n   ((MODE) == TImode || (MODE) == EImode || (MODE) == OImode \\\n    || (MODE) == CImode || (MODE) == XImode)\n \n+#define VALID_MVE_STRUCT_MODE(MODE) \\\n+  ((MODE) == TImode || (MODE) == OImode || (MODE) == XImode)\n+\n /* The register numbers in sequence, for passing to arm_gen_load_multiple.  */\n extern int arm_regs_in_sequence[];\n \n@@ -1103,9 +1123,13 @@ extern int arm_regs_in_sequence[];\n   /* Registers not for general use.  */\t\t\\\n   CC_REGNUM, VFPCC_REGNUM,\t\t\t\\\n   FRAME_POINTER_REGNUM, ARG_POINTER_REGNUM,\t\\\n-  SP_REGNUM, PC_REGNUM, APSRQ_REGNUM, APSRGE_REGNUM\t\\\n+  SP_REGNUM, PC_REGNUM, APSRQ_REGNUM,\t\t\\\n+  APSRGE_REGNUM, VPR_REGNUM\t\t\t\\\n }\n \n+#define IS_VPR_REGNUM(REGNUM) \\\n+  ((REGNUM) == VPR_REGNUM)\n+\n /* Use different register alloc ordering for Thumb.  */\n #define ADJUST_REG_ALLOC_ORDER arm_order_regs_for_local_alloc ()\n \n@@ -1142,14 +1166,15 @@ enum reg_class\n   VFPCC_REG,\n   SFP_REG,\n   AFP_REG,\n+  VPR_REG,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES  (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n-#define REG_CLASS_NAMES  \\\n+#define REG_CLASS_NAMES \\\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n   \"LO_REGS\",\t\t\\\n@@ -1169,6 +1194,7 @@ enum reg_class\n   \"VFPCC_REG\",\t\t\\\n   \"SFP_REG\",\t\t\\\n   \"AFP_REG\",\t\t\\\n+  \"VPR_REG\",\t\t\\\n   \"ALL_REGS\"\t\t\\\n }\n \n@@ -1195,7 +1221,8 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000020 }, /* VFPCC_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000040 }, /* SFP_REG */\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000080 }, /* AFP_REG */\t\\\n-  { 0xFFFF7FFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000F }  /* ALL_REGS */\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000400 }, /* VPR_REG.  */\t\\\n+  { 0xFFFF7FFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000F }  /* ALL_REGS.  */\t\\\n }\n \n #define FP_SYSREGS \\"}, {"sha": "8f8c91d5fe146ed64cd4eb5450f04b3cf0c0ed18", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -41,6 +41,7 @@\n    (VFPCC_REGNUM    101)\t; VFP Condition code pseudo register\n    (APSRQ_REGNUM    104)\t; Q bit pseudo register\n    (APSRGE_REGNUM   105)\t; GE bits pseudo register\n+   (VPR_REGNUM      106)\t; Vector Predication Register - MVE register.\n   ]\n )\n ;; 3rd operand to select_dominance_cc_mode\n@@ -300,9 +301,11 @@\n \t (ior (eq_attr \"is_thumb1\" \"yes\")\n \t      (eq_attr \"type\" \"call\"))\n \t (const_string \"clob\")\n-\t (if_then_else (eq_attr \"is_neon_type\" \"no\")\n-\t (const_string \"nocond\")\n-\t (const_string \"unconditional\"))))\n+         (if_then_else\n+\t  (ior (eq_attr \"is_neon_type\" \"no\")\n+\t       (eq_attr \"is_mve_type\" \"no\"))\n+\t  (const_string \"nocond\")\n+\t  (const_string \"unconditional\"))))\n \n ; Predicable means that the insn can be conditionally executed based on\n ; an automatically added predicate (additional patterns are generated by \n@@ -7307,7 +7310,7 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:SF 1 \"general_operand\"  \"r,mE,r\"))]\n   \"TARGET_32BIT\n-   && TARGET_SOFT_FLOAT\n+   && TARGET_SOFT_FLOAT && !TARGET_HAVE_MVE\n    && (!MEM_P (operands[0])\n        || register_operand (operands[1], SFmode))\"\n {\n@@ -7430,8 +7433,8 @@\n \n (define_insn \"*movdf_soft_insn\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:DF 1 \"soft_df_operand\" \"rDa,Db,Dc,mF,r\"))]\n-  \"TARGET_32BIT && TARGET_SOFT_FLOAT\n+       (match_operand:DF 1 \"soft_df_operand\" \"rDa,Db,Dc,mF,r\"))]\n+  \"TARGET_32BIT && TARGET_SOFT_FLOAT && !TARGET_HAVE_MVE\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"*\n@@ -11755,7 +11758,7 @@\n                    (match_operand:SI 2 \"const_int_I_operand\" \"I\")))\n      (set (match_operand:DF 3 \"vfp_hard_register_operand\" \"\")\n           (mem:DF (match_dup 1)))])]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && (TARGET_HARD_FLOAT || TARGET_HAVE_MVE)\"\n   \"*\n   {\n     int num_regs = XVECLEN (operands[0], 0);\n@@ -12698,7 +12701,7 @@\n    (set_attr \"length\" \"8\")]\n )\n \n-;; Vector bits common to IWMMXT and Neon\n+;; Vector bits common to IWMMXT, Neon and MVE\n (include \"vec-common.md\")\n ;; Load the Intel Wireless Multimedia Extension patterns\n (include \"iwmmxt.md\")\n@@ -12716,3 +12719,5 @@\n (include \"sync.md\")\n ;; Fixed-point patterns\n (include \"arm-fixed.md\")\n+;; M-profile Vector Extension\n+(include \"mve.md\")"}, {"sha": "7347d46b837d2a4d5d92e87487080379b9e41ea4", "filename": "gcc/config/arm/arm_mve.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm_mve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Farm_mve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_mve.h?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,59 @@\n+/* Arm MVE intrinsics include file.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by Arm.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _GCC_ARM_MVE_H\n+#define _GCC_ARM_MVE_H\n+\n+#if !__ARM_FEATURE_MVE\n+#error \"MVE feature not supported\"\n+#endif\n+\n+#include <stdint.h>\n+#ifndef  __cplusplus\n+#include <stdbool.h>\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if (__ARM_FEATURE_MVE & 2) /* MVE Floating point.  */\n+typedef __fp16 float16_t;\n+typedef float float32_t;\n+typedef __simd128_float16_t float16x8_t;\n+typedef __simd128_float32_t float32x4_t;\n+#endif\n+\n+typedef uint16_t mve_pred16_t;\n+typedef __simd128_uint8_t uint8x16_t;\n+typedef __simd128_uint16_t uint16x8_t;\n+typedef __simd128_uint32_t uint32x4_t;\n+typedef __simd128_uint64_t uint64x2_t;\n+typedef __simd128_int8_t int8x16_t;\n+typedef __simd128_int16_t int16x8_t;\n+typedef __simd128_int32_t int32x4_t;\n+typedef __simd128_int64_t int64x2_t;\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* _GCC_ARM_MVE_H.  */"}, {"sha": "a12de97cdaab589e0c8704b408ac4c329def416d", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -38,11 +38,13 @@\n ;; in all states: Pf, Pg\n \n ;; The following memory constraints have been used:\n-;; in ARM/Thumb-2 state: Uh, Ut, Uv, Uy, Un, Um, Us\n+;; in ARM/Thumb-2 state: Uh, Ut, Uv, Uy, Un, Um, Us, Up\n ;; in ARM state: Uq\n ;; in Thumb state: Uu, Uw\n ;; in all states: Q\n \n+(define_register_constraint \"Up\" \"TARGET_HAVE_MVE ? VPR_REG : NO_REGS\"\n+  \"MVE VPR register\")\n \n (define_register_constraint \"t\" \"TARGET_32BIT ? VFP_LO_REGS : NO_REGS\"\n  \"The VFP registers @code{s0}-@code{s31}.\")"}, {"sha": "6af76580c0c5d0a6efd47eb1409061c74dca6378", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -66,6 +66,12 @@\n ;; Integer and float modes supported by Neon and IWMMXT.\n (define_mode_iterator VALL [V2DI V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n \n+;; Integer and float modes supported by Neon, IWMMXT and MVE.\n+(define_mode_iterator VNIM1 [V16QI V8HI V4SI V4SF V2DI])\n+\n+;; Integer and float modes supported by Neon and IWMMXT but not MVE.\n+(define_mode_iterator VNINOTM1 [V2SI V4HI V8QI V2SF])\n+\n ;; Integer and float modes supported by Neon and IWMMXT, except V2DI.\n (define_mode_iterator VALLW [V2SI V4HI V8QI V2SF V4SI V8HI V16QI V4SF])\n \n@@ -224,6 +230,10 @@\n ;; 16-bit floating-point vector modes suitable for moving (includes BFmode).\n (define_mode_iterator VHFBF [V8HF V4HF V4BF V8BF])\n \n+;; 16-bit floating-point vector modes suitable for moving (includes BFmode,\n+;; without V8HF ).\n+(define_mode_iterator VHFBF_split [V4HF V4BF V8BF])\n+\n ;; 16-bit floating-point scalar modes suitable for moving (includes BFmode).\n (define_mode_iterator HFBF [HF BF])\n "}, {"sha": "c32adf15cca4b207164e3d3e3fff90cb1cc3d9fd", "filename": "gcc/config/arm/mve.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,85 @@\n+;; Arm M-profile Vector Extension Machine Description\n+;; Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_mode_iterator MVE_types [V16QI V8HI V4SI V2DI TI V8HF V4SF V2DF])\n+(define_mode_attr V_sz_elem2 [(V16QI \"s8\") (V8HI \"u16\") (V4SI \"u32\")\n+\t\t\t      (V2DI \"u64\")])\n+\n+(define_insn \"*mve_mov<mode>\"\n+  [(set (match_operand:MVE_types 0 \"nonimmediate_operand\" \"=w,w,r,w,w,r,w,Us\")\n+\t(match_operand:MVE_types 1 \"general_operand\" \"w,r,w,Dn,Usi,r,Dm,w\"))]\n+  \"TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT\"\n+{\n+  if (which_alternative == 3 || which_alternative == 6)\n+    {\n+      int width, is_valid;\n+      static char templ[40];\n+\n+      is_valid = simd_immediate_valid_for_move (operands[1], <MODE>mode,\n+\t&operands[1], &width);\n+\n+      gcc_assert (is_valid != 0);\n+\n+      if (width == 0)\n+\treturn \"vmov.f32\\t%q0, %1  @ <mode>\";\n+      else\n+\tsprintf (templ, \"vmov.i%d\\t%%q0, %%x1  @ <mode>\", width);\n+      return templ;\n+    }\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"vmov\\t%q0, %q1\";\n+    case 1:\n+      return \"vmov\\t%e0, %Q1, %R1  @ <mode>\\;vmov\\t%f0, %J1, %K1\";\n+    case 2:\n+      return \"vmov\\t%Q0, %R0, %e1  @ <mode>\\;vmov\\t%J0, %K0, %f1\";\n+    case 4:\n+      if ((TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode))\n+\t  || (MEM_P (operands[1])\n+\t      && GET_CODE (XEXP (operands[1], 0)) == LABEL_REF))\n+\treturn output_move_neon (operands);\n+      else\n+\treturn \"vldrb.8 %q0, %E1\";\n+    case 5:\n+      return output_move_neon (operands);\n+    case 7:\n+      return \"vstrb.8 %q1, %E0\";\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    }\n+}\n+  [(set_attr \"type\" \"mve_move,mve_move,mve_move,mve_move,mve_load,mve_move,mve_move,mve_store\")\n+   (set_attr \"length\" \"4,8,8,4,8,8,4,4\")\n+   (set_attr \"thumb2_pool_range\" \"*,*,*,*,1018,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,*,*,996,*,*,*\")])\n+\n+(define_insn \"*mve_mov<mode>\"\n+  [(set (match_operand:MVE_types 0 \"s_register_operand\" \"=w,w\")\n+\t(vec_duplicate:MVE_types\n+\t  (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")))]\n+  \"TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT\"\n+{\n+  if (which_alternative == 0)\n+    return \"vdup.<V_sz_elem>\\t%q0, %1\";\n+  return \"vmov.<V_sz_elem>\\t%q0, %1\";\n+}\n+  [(set_attr \"length\" \"4,4\")\n+   (set_attr \"type\" \"mve_move,mve_move\")])"}, {"sha": "b6a8eb62c8ff05fc32805029fea8f682402d7399", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -47,7 +47,7 @@\n       int width, is_valid;\n       static char templ[40];\n \n-      is_valid = neon_immediate_valid_for_move (operands[1], <MODE>mode,\n+      is_valid = simd_immediate_valid_for_move (operands[1], <MODE>mode,\n         &operands[1], &width);\n \n       gcc_assert (is_valid != 0);\n@@ -94,7 +94,7 @@\n       int width, is_valid;\n       static char templ[40];\n \n-      is_valid = neon_immediate_valid_for_move (operands[1], <MODE>mode,\n+      is_valid = simd_immediate_valid_for_move (operands[1], <MODE>mode,\n         &operands[1], &width);\n \n       gcc_assert (is_valid != 0);\n@@ -160,9 +160,13 @@\n     }\n })\n \n+;; The pattern mov<mode> where mode is v8hf, v4hf, v4bf and v8bf are split into\n+;; two groups.  The pattern movv8hf is common for MVE and NEON, so it is moved\n+;; into vec-common.md file.  Remaining mov expand patterns with half float and\n+;; bfloats are implemented below.\n (define_expand \"mov<mode>\"\n-  [(set (match_operand:VHFBF 0 \"s_register_operand\")\n-\t(match_operand:VHFBF 1 \"s_register_operand\"))]\n+  [(set (match_operand:VHFBF_split 0 \"s_register_operand\")\n+\t(match_operand:VHFBF_split 1 \"s_register_operand\"))]\n   \"TARGET_NEON\"\n {\n   gcc_checking_assert (aligned_operand (operands[0], <MODE>mode));\n@@ -489,7 +493,7 @@\n (define_expand \"vec_init<mode><V_elem_l>\"\n   [(match_operand:VDQ 0 \"s_register_operand\")\n    (match_operand 1 \"\" \"\")]\n-  \"TARGET_NEON\"\n+  \"TARGET_NEON || TARGET_HAVE_MVE\"\n {\n   neon_expand_vector_init (operands[0], operands[1]);\n   DONE;"}, {"sha": "fb12371134a4f51fe4ec50afb786c65b64af1f96", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -48,6 +48,14 @@\n   return guard_addr_operand (XEXP (op, 0), mode);\n })\n \n+(define_predicate \"vpr_register_operand\"\n+  (match_code \"reg\")\n+{\n+  return REG_P (op)\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || IS_VPR_REGNUM (REGNO (op)));\n+})\n+\n (define_predicate \"imm_for_neon_inv_logic_operand\"\n   (match_code \"const_vector\")\n {\n@@ -688,7 +696,7 @@\n (define_predicate \"imm_for_neon_mov_operand\"\n   (match_code \"const_vector,const_int\")\n {\n-  return neon_immediate_valid_for_move (op, mode, NULL, NULL);\n+  return simd_immediate_valid_for_move (op, mode, NULL, NULL);\n })\n \n (define_predicate \"imm_for_neon_lshift_operand\""}, {"sha": "2d980830e7669e60d6f2cb61014389d121bfbcb1", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -55,6 +55,7 @@ MD_INCLUDES=\t$(srcdir)/config/arm/arm1020e.md \\\n \t\t$(srcdir)/config/arm/ldmstm.md \\\n \t\t$(srcdir)/config/arm/ldrdstrd.md \\\n \t\t$(srcdir)/config/arm/marvell-f-iwmmxt.md \\\n+\t\t$(srcdir)/config/arm/mve.md \\\n \t\t$(srcdir)/config/arm/neon.md \\\n \t\t$(srcdir)/config/arm/predicates.md \\\n \t\t$(srcdir)/config/arm/sync.md \\"}, {"sha": "83983452f524b154b1fc1794413b799a1779580c", "filename": "gcc/config/arm/types.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Ftypes.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Ftypes.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftypes.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -550,6 +550,11 @@\n ; The classification below is for TME instructions\n ;\n ; tme\n+; The classification below is for M-profile Vector Extension instructions\n+;\n+; mve_move\n+; mve_store\n+; mve_load\n \n (define_attr \"type\"\n  \"adc_imm,\\\n@@ -1097,7 +1102,10 @@\n   crypto_sm4,\\\n   coproc,\\\n   tme,\\\n-  memtag\"\n+  memtag,\\\n+  mve_move,\\\n+  mve_store,\\\n+  mve_load\"\n    (const_string \"untyped\"))\n \n ; Is this an (integer side) multiply with a 32-bit (or smaller) result?\n@@ -1222,6 +1230,14 @@\n         (const_string \"yes\")\n         (const_string \"no\")))\n \n+;; YES if the \"type\" attribute assigned to the insn denotes an MVE instruction,\n+;; No otherwise.\n+(define_attr \"is_mve_type\" \"yes,no\"\n+        (if_then_else (eq_attr \"type\"\n+        \"mve_move, mve_load, mve_store, mrs\")\n+        (const_string \"yes\")\n+        (const_string \"no\")))\n+\n (define_insn_reservation \"no_reservation\" 0\n   (eq_attr \"type\" \"no_insn\")\n   \"nothing\")"}, {"sha": "916e4914a6267f928c3d3229cb9907e6fb79b222", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -21,8 +21,31 @@\n ;; Vector Moves\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:VALL 0 \"nonimmediate_operand\")\n-\t(match_operand:VALL 1 \"general_operand\"))]\n+  [(set (match_operand:VNIM1 0 \"nonimmediate_operand\")\n+\t(match_operand:VNIM1 1 \"general_operand\"))]\n+  \"TARGET_NEON\n+   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\n+   || (TARGET_HAVE_MVE && VALID_MVE_SI_MODE (<MODE>mode))\n+   || (TARGET_HAVE_MVE_FLOAT && VALID_MVE_SF_MODE (<MODE>mode))\"\n+   {\n+  gcc_checking_assert (aligned_operand (operands[0], <MODE>mode));\n+  gcc_checking_assert (aligned_operand (operands[1], <MODE>mode));\n+  if (can_create_pseudo_p ())\n+    {\n+      if (!REG_P (operands[0]))\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n+      else if ((TARGET_NEON || TARGET_HAVE_MVE || TARGET_HAVE_MVE_FLOAT)\n+\t       && (CONSTANT_P (operands[1])))\n+\t{\n+\t  operands[1] = neon_make_constant (operands[1]);\n+\t  gcc_assert (operands[1] != NULL_RTX);\n+\t}\n+    }\n+})\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VNINOTM1 0 \"nonimmediate_operand\")\n+\t(match_operand:VNINOTM1 1 \"general_operand\"))]\n   \"TARGET_NEON\n    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n {\n@@ -40,6 +63,20 @@\n     }\n })\n \n+(define_expand \"movv8hf\"\n+  [(set (match_operand:V8HF 0 \"s_register_operand\")\n+       (match_operand:V8HF 1 \"s_register_operand\"))]\n+   \"TARGET_NEON || TARGET_HAVE_MVE_FLOAT\"\n+{\n+  gcc_checking_assert (aligned_operand (operands[0], E_V8HFmode));\n+  gcc_checking_assert (aligned_operand (operands[1], E_V8HFmode));\n+   if (can_create_pseudo_p ())\n+     {\n+       if (!REG_P (operands[0]))\n+\t operands[1] = force_reg (E_V8HFmode, operands[1]);\n+     }\n+})\n+\n ;; Vector arithmetic. Expanders are blank, then unnamed insns implement\n ;; patterns separately for IWMMXT and Neon.\n "}, {"sha": "ab16a6b0eac822b4e1a1ae4dcbe39491a82cc9fe", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -311,7 +311,7 @@\n    && (   register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode))\n    && !(TARGET_NEON && CONST_INT_P (operands[1])\n-        && neon_immediate_valid_for_move (operands[1], DImode, NULL, NULL))\"\n+\t&& simd_immediate_valid_for_move (operands[1], DImode, NULL, NULL))\"\n   \"*\n   switch (which_alternative)\n     {"}, {"sha": "82bfc054d91a5bbef49e11ce2cc5f63737ff699b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -1,3 +1,29 @@\n+2020-03-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+            Mihail Ionescu  <mihail.ionescu@arm.com>\n+            Srinath Parvathaneni  <srinath.parvathaneni@arm.com>\n+\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_float.c: New test.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_float1.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_float2.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_int.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_int1.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_int2.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_uint.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_uint1.c: Likewise.\n+\t* gcc.target/arm/mve/intrinsics/mve_vector_uint2.c: Likewise.\n+\t* gcc.target/arm/mve/mve.exp: New file.\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_v8_1m_mve_fp_ok_nocache): Proc to check\n+\tarmv8.1-m.main+mve.fp and returning corresponding options.\n+\t(check_effective_target_arm_v8_1m_mve_fp_ok): Proc to call\n+\tcheck_effective_target_arm_v8_1m_mve_fp_ok_nocache to check support of\n+\tMVE with floating point on the current target.\n+\t(add_options_for_arm_v8_1m_mve_fp): Proc to call\n+\tcheck_effective_target_arm_v8_1m_mve_fp_ok to return corresponding\n+\tcompiler options for MVE with floating point.\n+\t(check_effective_target_arm_v8_1m_mve_ok_nocache): Modify to test and\n+\treturn hard float-abi on success.\n+\n 2020-03-16  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/89229"}, {"sha": "ac51f7ff4be1d9a24c9a8657541b2d2273539d50", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_float.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#include \"arm_mve.h\"\n+\n+float32x4_t\n+foo32 (float32x4_t value)\n+{\n+  float32x4_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldmia.*\" }  } */\n+\n+float16x8_t\n+foo16 (float16x8_t value)\n+{\n+  float16x8_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldmia.*\" }  } */"}, {"sha": "d41900c20ea533519bc0da729ef01bf0925083fa", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_float1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float1.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#include \"arm_mve.h\"\n+\n+float32x4_t value;\n+\n+float32x4_t\n+foo32 ()\n+{\n+  float32x4_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldmia.*\" }  } */\n+\n+float16x8_t value1;\n+\n+float16x8_t\n+foo16 ()\n+{\n+  float16x8_t b = value1;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldmia.*\" }  } */"}, {"sha": "f02dd8b5f15e86356512d0f2c02d0f59a53c6d4b", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_float2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_float2.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_fp_ok } */\n+/* { dg-add-options arm_v8_1m_mve_fp } */\n+\n+#include \"arm_mve.h\"\n+\n+float32x4_t\n+foo32 ()\n+{\n+  float32x4_t b = {10.0, 12.0, 14.0, 16.0};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64*\" }  } */\n+\n+float16x8_t\n+foo16 ()\n+{\n+  float16x8_t b = {32.01};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */"}, {"sha": "dfe08b9c9f53db4ee3ae62e1a9eec863675fcba8", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_int.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo8 (int8x16_t value)\n+{\n+  int8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+int16x8_t\n+foo16 (int16x8_t value)\n+{\n+  int16x8_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+int32x4_t\n+foo32 (int32x4_t value)\n+{\n+  int32x4_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+int64x2_t\n+foo64 (int64x2_t value)\n+{\n+  int64x2_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */"}, {"sha": "cb96eb8d3ab5ced754ebf12724c0b692be114fd3", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_int1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int1.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t value1;\n+int16x8_t value2;\n+int32x4_t value3;\n+int64x2_t value4;\n+\n+int8x16_t\n+foo8 ()\n+{\n+  int8x16_t b = value1;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+int16x8_t\n+foo16 ()\n+{\n+  int16x8_t b = value2;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+int32x4_t\n+foo32 ()\n+{\n+  int32x4_t b = value3;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8\" }  } */\n+\n+int64x2_t\n+foo64 ()\n+{\n+  int64x2_t b = value4;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8\" }  } */"}, {"sha": "32f589aad528314b7f2bf4cb680ab70b66a19514", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_int2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_int2.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+int8x16_t\n+foo8 ()\n+{\n+  int8x16_t b = {1, 2, 3, 4};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+int16x8_t\n+foo16 (int16x8_t value)\n+{\n+  int16x8_t b = {1, 2, 3};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+int32x4_t\n+foo32 (int32x4_t value)\n+{\n+  int32x4_t b = {1, 2};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+int64x2_t\n+foo64 (int64x2_t value)\n+{\n+  int64x2_t b = {1};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */"}, {"sha": "1957d384ca0b5a273d8182e77b592d732694690c", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_uint.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+uint8x16_t\n+foo8 (uint8x16_t value)\n+{\n+  uint8x16_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint16x8_t\n+foo16 (uint16x8_t value)\n+{\n+  uint16x8_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint32x4_t\n+foo32 (uint32x4_t value)\n+{\n+  uint32x4_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint64x2_t\n+foo64 (uint64x2_t value)\n+{\n+  uint64x2_t b = value;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */"}, {"sha": "0561178a8d3b5c1f4952da62aa6a2c1692fea849", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_uint1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint1.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+uint8x16_t value1;\n+uint16x8_t value2;\n+uint32x4_t value3;\n+uint64x2_t value4;\n+\n+uint8x16_t\n+foo8 ()\n+{\n+  uint8x16_t b = value1;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint16x8_t\n+foo16 ()\n+{\n+  uint16x8_t b = value2;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint32x4_t\n+foo32 ()\n+{\n+  uint32x4_t b = value3;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */\n+\n+uint64x2_t\n+foo64 ()\n+{\n+  uint64x2_t b = value4;\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldrb.8*\" }  } */"}, {"sha": "8b4f4cbb8cde8372044fa39dba96fdf29fd9eeb8", "filename": "gcc/testsuite/gcc.target/arm/mve/intrinsics/mve_vector_uint2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fintrinsics%2Fmve_vector_uint2.c?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile  } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+\n+#include \"arm_mve.h\"\n+\n+uint8x16_t\n+foo8 (uint8x16_t value)\n+{\n+  uint8x16_t b = {1, 2, 3, 4};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+uint16x8_t\n+foo16 (uint16x8_t value)\n+{\n+  uint16x8_t b = {1, 2, 3};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+uint32x4_t\n+foo32 (uint32x4_t value)\n+{\n+  uint32x4_t b = {1, 2};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */\n+\n+uint64x2_t\n+foo64 (uint64x2_t value)\n+{\n+  uint64x2_t b = {1};\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"vmov\\\\tq\\[0-7\\], q\\[0-7\\]\"  }  } */\n+/* { dg-final { scan-assembler \"vstrb.*\" }  } */\n+/* { dg-final { scan-assembler \"vldr.64.*\" }  } */"}, {"sha": "e841d56ba940f25626a0957dc970ab1062d25194", "filename": "gcc/testsuite/gcc.target/arm/mve/mve.exp", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fmve.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fmve.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fmve%2Fmve.exp?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -0,0 +1,47 @@\n+# Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an ARM target.\n+if ![istarget arm*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# This variable should only apply to tests called in this exp file.\n+global dg_runtest_extra_prunes\n+set dg_runtest_extra_prunes \"\"\n+lappend dg_runtest_extra_prunes \"warning: switch -m(cpu|arch)=.* conflicts with -m(cpu|arch)=.* switch\"\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/intrinsics/*.\\[cCS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+set dg_runtest_extra_prunes \"\"\n+dg-finish"}, {"sha": "4413c26fbc970268703195d0f635ae67475eb0bd", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63c8f7d6a082b1cd0519fe06d4ed506b04280921/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=63c8f7d6a082b1cd0519fe06d4ed506b04280921", "patch": "@@ -4691,6 +4691,49 @@ proc check_effective_target_default_branch_protection { } {\n     return [check_configured_with \"enable-standard-branch-protection\"]\n }\n \n+# Return 1 if the target supports ARMv8.1-M MVE with floating point\n+# instructions, 0 otherwise.  The test is valid for ARM.\n+# Record the command line options needed.\n+\n+proc check_effective_target_arm_v8_1m_mve_fp_ok_nocache { } {\n+    global et_arm_v8_1m_mve_fp_flags\n+    set et_arm_v8_1m_mve_fp_flags \"\"\n+\n+    if { ![istarget arm*-*-*] } {\n+\treturn 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfloat-abi=hard -mfpu=auto -march=armv8.1-m.main+mve.fp\" \"-mfloat-abi=softfp -mfpu=auto -march=armv8.1-m.main+mve.fp\"} {\n+\tif { [check_no_compiler_messages_nocache \\\n+\t\t  arm_v8_1m_mve_fp_ok object {\n+\t    #include <arm_mve.h>\n+\t    #if !(__ARM_FEATURE_MVE & 2)\n+\t    #error \"__ARM_FEATURE_MVE for floating point not defined\"\n+\t    #endif\n+\t} \"$flags -mthumb\"] } {\n+\t    set et_arm_v8_1m_mve_fp_flags \"$flags -mthumb\"\n+\t    return 1\n+\t}\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_1m_mve_fp_ok { } {\n+    return [check_cached_effective_target arm_v8_1m_mve_fp_ok \\\n+\t\tcheck_effective_target_arm_v8_1m_mve_fp_ok_nocache]\n+}\n+\n+proc add_options_for_arm_v8_1m_mve_fp { flags } {\n+    if { ! [check_effective_target_arm_v8_1m_mve_fp_ok] } {\n+\treturn \"$flags\"\n+    }\n+    global et_arm_v8_1m_mve_fp_flags\n+    return \"$flags $et_arm_v8_1m_mve_fp_flags\"\n+}\n+\n # Return 1 if the target supports the ARMv8.1 Adv.SIMD extension, 0\n # otherwise.  The test is valid for AArch64 and ARM.  Record the command\n # line options needed.\n@@ -4842,7 +4885,7 @@ proc check_effective_target_arm_v8_1m_mve_ok_nocache { } {\n \n     # Iterate through sets of options to find the compiler flags that\n     # need to be added to the -march option.\n-    foreach flags {\"\" \"-mfloat-abi=softfp -mfpu=auto\" \"-mfloat-abi=hard -mfpu=auto\"} {\n+    foreach flags {\"\" \"-mfloat-abi=hard -mfpu=auto -march=armv8.1-m.main+mve\" \"-mfloat-abi=softfp -mfpu=auto -march=armv8.1-m.main+mve\"} {\n         if { [check_no_compiler_messages_nocache \\\n                   arm_v8_1m_mve_ok object {\n             #if !defined (__ARM_FEATURE_MVE)"}]}