{"sha": "e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVkZGFhMjRiZWFlOGFlMDZlMmE4ZTk2MjEzMWExYmM1NWY3MTQ2ZQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-30T12:48:51Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-30T12:48:51Z"}, "message": "re PR fortran/16161 ([gfortran] IMPLICIT CHARACTER not implemented)\n\nfortran/\nPR fortran/16161\n* decl.c (gfc_match_type_spec): Rename second argument to\n'implicit_flag', reverse meaning. Don't match_char_spec if\n'implicit_flag' is set. Rename to ...\n(match_type_spec): ... this.\n(gfc_match_implicit_none, match_implicit_range): Move here\nfrom match.c.\n(gfc_match_implicit): Move here from match.c, try to\nmatch_char_len if match_implicit_range doesn't succeed for\nCHARACTER implicits. Call renamed fucntion match_type_spec.\n(gfc_match_data_decl, match_prefix): Call renamed function\nmatch_type_spec.\n* match.c (gfc_match_implicit_none, match_implicit_range,\ngfc_match_implicit): Move to decl.c.\n* match.h (gfc_match_implicit_none, gfc_match_implicit):\nMove protoypes to section 'decl.c'.\n(gfc_match_type_spec): Remove prototype.\n\ntestsuite/\nPR fortran/16161\n* gfortran.fortran-torture/compile/implicit.f90: Add test\nfor implicit character.\n\nFrom-SVN: r83907", "tree": {"sha": "a6d66573bee1bb3198bebe0b03b27908d2034442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6d66573bee1bb3198bebe0b03b27908d2034442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "521903292cec2da89e5804e420245a006affd240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/521903292cec2da89e5804e420245a006affd240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/521903292cec2da89e5804e420245a006affd240"}], "stats": {"total": 460, "additions": 250, "deletions": 210}, "files": [{"sha": "8e65b697e04789cab1329eaaaeb338345bec6aa5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -1,3 +1,23 @@\n+2004-06-30  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/16161\n+\t* decl.c (gfc_match_type_spec): Rename second argument to\n+\t'implicit_flag', reverse meaning. Don't match_char_spec if\n+\t'implicit_flag' is set. Rename to ...\n+\t(match_type_spec): ... this.\n+\t(gfc_match_implicit_none, match_implicit_range): Move here\n+\tfrom match.c.\n+\t(gfc_match_implicit): Move here from match.c, try to\n+\tmatch_char_len if match_implicit_range doesn't succeed for\n+\tCHARACTER implicits. Call renamed fucntion match_type_spec.\n+\t(gfc_match_data_decl, match_prefix): Call renamed function\n+\tmatch_type_spec.\n+\t* match.c (gfc_match_implicit_none, match_implicit_range,\n+\tgfc_match_implicit): Move to decl.c.\n+\t* match.h (gfc_match_implicit_none, gfc_match_implicit):\n+\tMove protoypes to section 'decl.c'.\n+\t(gfc_match_type_spec): Remove prototype.\n+\n 2004-06-29  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* decl.c, interface.c, symbol.c, trans-common.c: Add 2004 to "}, {"sha": "5c5b7281115b26667bc3bfa819a134451e2e9461", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 215, "deletions": 8, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -874,12 +874,12 @@ match_char_spec (gfc_typespec * ts)\n    to the matched specification.  This is necessary for FUNCTION and\n    IMPLICIT statements.\n \n-   If kind_flag is nonzero, then we check for the optional kind\n-   specification.  Not doing so is needed for matching an IMPLICIT\n+   If implicit_flag is nonzero, then we don't check for the optional \n+   kind specification.  Not doing so is needed for matching an IMPLICIT\n    statement correctly.  */\n \n-match\n-gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n+static match\n+match_type_spec (gfc_typespec * ts, int implicit_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -898,7 +898,10 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n   if (gfc_match (\" character\") == MATCH_YES)\n     {\n       ts->type = BT_CHARACTER;\n-      return match_char_spec (ts);\n+      if (implicit_flag == 0)\n+\treturn match_char_spec (ts);\n+      else\n+\treturn MATCH_YES;\n     }\n \n   if (gfc_match (\" real\") == MATCH_YES)\n@@ -960,7 +963,7 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n get_kind:\n   /* For all types except double, derived and character, look for an\n      optional kind specifier.  MATCH_NO is actually OK at this point.  */\n-  if (kind_flag == 0)\n+  if (implicit_flag == 1)\n     return MATCH_YES;\n \n   if (gfc_current_form == FORM_FREE)\n@@ -982,6 +985,210 @@ gfc_match_type_spec (gfc_typespec * ts, int kind_flag)\n }\n \n \n+/* Match an IMPLICIT NONE statement.  Actually, this statement is\n+   already matched in parse.c, or we would not end up here in the\n+   first place.  So the only thing we need to check, is if there is\n+   trailing garbage.  If not, the match is successful.  */\n+\n+match\n+gfc_match_implicit_none (void)\n+{\n+\n+  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n+}\n+\n+\n+/* Match the letter range(s) of an IMPLICIT statement.  */\n+\n+static match\n+match_implicit_range (gfc_typespec * ts)\n+{\n+  int c, c1, c2, inner;\n+  locus cur_loc;\n+\n+  cur_loc = gfc_current_locus;\n+\n+  gfc_gobble_whitespace ();\n+  c = gfc_next_char ();\n+  if (c != '(')\n+    {\n+      gfc_error (\"Missing character range in IMPLICIT at %C\");\n+      goto bad;\n+    }\n+\n+  inner = 1;\n+  while (inner)\n+    {\n+      gfc_gobble_whitespace ();\n+      c1 = gfc_next_char ();\n+      if (!ISALPHA (c1))\n+\tgoto bad;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+\n+      switch (c)\n+\t{\n+\tcase ')':\n+\t  inner = 0;\t\t/* Fall through */\n+\n+\tcase ',':\n+\t  c2 = c1;\n+\t  break;\n+\n+\tcase '-':\n+\t  gfc_gobble_whitespace ();\n+\t  c2 = gfc_next_char ();\n+\t  if (!ISALPHA (c2))\n+\t    goto bad;\n+\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\n+\t  if ((c != ',') && (c != ')'))\n+\t    goto bad;\n+\t  if (c == ')')\n+\t    inner = 0;\n+\n+\t  break;\n+\n+\tdefault:\n+\t  goto bad;\n+\t}\n+\n+      if (c1 > c2)\n+\t{\n+\t  gfc_error (\"Letters must be in alphabetic order in \"\n+\t\t     \"IMPLICIT statement at %C\");\n+\t  goto bad;\n+\t}\n+\n+      /* See if we can add the newly matched range to the pending\n+         implicits from this IMPLICIT statement.  We do not check for\n+         conflicts with whatever earlier IMPLICIT statements may have\n+         set.  This is done when we've successfully finished matching\n+         the current one.  */\n+      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n+\tgoto bad;\n+    }\n+\n+  return MATCH_YES;\n+\n+bad:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+  gfc_current_locus = cur_loc;\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match an IMPLICIT statement, storing the types for\n+   gfc_set_implicit() if the statement is accepted by the parser.\n+   There is a strange looking, but legal syntactic construction\n+   possible.  It looks like:\n+\n+     IMPLICIT INTEGER (a-b) (c-d)\n+\n+   This is legal if \"a-b\" is a constant expression that happens to\n+   equal one of the legal kinds for integers.  The real problem\n+   happens with an implicit specification that looks like:\n+\n+     IMPLICIT INTEGER (a-b)\n+\n+   In this case, a typespec matcher that is \"greedy\" (as most of the\n+   matchers are) gobbles the character range as a kindspec, leaving\n+   nothing left.  We therefore have to go a bit more slowly in the\n+   matching process by inhibiting the kindspec checking during\n+   typespec matching and checking for a kind later.  */\n+\n+match\n+gfc_match_implicit (void)\n+{\n+  gfc_typespec ts;\n+  locus cur_loc;\n+  int c;\n+  match m;\n+\n+  /* We don't allow empty implicit statements.  */\n+  if (gfc_match_eos () == MATCH_YES)\n+    {\n+      gfc_error (\"Empty IMPLICIT statement at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  /* First cleanup.  */\n+  gfc_clear_new_implicit ();\n+\n+  do\n+    {\n+      /* A basic type is mandatory here.  */\n+      m = match_type_spec (&ts, 1);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      cur_loc = gfc_current_locus;\n+      m = match_implicit_range (&ts);\n+\n+      if (m != MATCH_YES && ts.type == BT_CHARACTER)\n+\t{\n+\t  /* looks like we are matching CHARACTER (<len>) (<range>)  */\n+\t  m = match_char_spec (&ts);\n+\t}\t  \n+\n+      if (m == MATCH_YES)\n+\t{\n+\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n+\t  gfc_gobble_whitespace ();\n+\t  c = gfc_next_char ();\n+\t  if ((c == '\\n') || (c == ','))\n+\t    continue;\n+\n+\t  gfc_current_locus = cur_loc;\n+\t}\n+\n+      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n+      m = gfc_match_kind_spec (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\t{\n+\t  m = gfc_match_old_kind_spec (&ts);\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_NO)\n+\t    goto syntax;\n+\t}\n+\n+      m = match_implicit_range (&ts);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      gfc_gobble_whitespace ();\n+      c = gfc_next_char ();\n+      if ((c != '\\n') && (c != ','))\n+\tgoto syntax;\n+\n+    }\n+  while (c == ',');\n+\n+  /* All we need to now is try to merge the new implicit types back\n+     into the existing types.  This will fail if another implicit\n+     type is already defined for a letter.  */\n+  return (gfc_merge_new_implicit () == SUCCESS) ?\n+      MATCH_YES : MATCH_ERROR;\n+\n+syntax:\n+  gfc_syntax_error (ST_IMPLICIT);\n+\n+error:\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Matches an attribute specification including array specs.  If\n    successful, leaves the variables current_attr and current_as\n    holding the specification.  Also sets the colon_seen variable for\n@@ -1242,7 +1449,7 @@ gfc_match_data_decl (void)\n   gfc_symbol *sym;\n   match m;\n \n-  m = gfc_match_type_spec (&current_ts, 1);\n+  m = match_type_spec (&current_ts, 0);\n   if (m != MATCH_YES)\n     return m;\n \n@@ -1332,7 +1539,7 @@ match_prefix (gfc_typespec * ts)\n \n loop:\n   if (!seen_type && ts != NULL\n-      && gfc_match_type_spec (ts, 1) == MATCH_YES\n+      && match_type_spec (ts, 0) == MATCH_YES\n       && gfc_match_space () == MATCH_YES)\n     {\n "}, {"sha": "9bc1f4fbe634f7a5a9b39e11aaf33f03b61692d2", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -2048,204 +2048,6 @@ gfc_match_call (void)\n }\n \n \n-/* Match an IMPLICIT NONE statement.  Actually, this statement is\n-   already matched in parse.c, or we would not end up here in the\n-   first place.  So the only thing we need to check, is if there is\n-   trailing garbage.  If not, the match is successful.  */\n-\n-match\n-gfc_match_implicit_none (void)\n-{\n-\n-  return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n-}\n-\n-\n-/* Match the letter range(s) of an IMPLICIT statement.  */\n-\n-static match\n-match_implicit_range (gfc_typespec * ts)\n-{\n-  int c, c1, c2, inner;\n-  locus cur_loc;\n-\n-  cur_loc = gfc_current_locus;\n-\n-  gfc_gobble_whitespace ();\n-  c = gfc_next_char ();\n-  if (c != '(')\n-    {\n-      gfc_error (\"Missing character range in IMPLICIT at %C\");\n-      goto bad;\n-    }\n-\n-  inner = 1;\n-  while (inner)\n-    {\n-      gfc_gobble_whitespace ();\n-      c1 = gfc_next_char ();\n-      if (!ISALPHA (c1))\n-\tgoto bad;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-\n-      switch (c)\n-\t{\n-\tcase ')':\n-\t  inner = 0;\t\t/* Fall through */\n-\n-\tcase ',':\n-\t  c2 = c1;\n-\t  break;\n-\n-\tcase '-':\n-\t  gfc_gobble_whitespace ();\n-\t  c2 = gfc_next_char ();\n-\t  if (!ISALPHA (c2))\n-\t    goto bad;\n-\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\n-\t  if ((c != ',') && (c != ')'))\n-\t    goto bad;\n-\t  if (c == ')')\n-\t    inner = 0;\n-\n-\t  break;\n-\n-\tdefault:\n-\t  goto bad;\n-\t}\n-\n-      if (c1 > c2)\n-\t{\n-\t  gfc_error (\"Letters must be in alphabetic order in \"\n-\t\t     \"IMPLICIT statement at %C\");\n-\t  goto bad;\n-\t}\n-\n-      /* See if we can add the newly matched range to the pending\n-         implicits from this IMPLICIT statement.  We do not check for\n-         conflicts with whatever earlier IMPLICIT statements may have\n-         set.  This is done when we've successfully finished matching\n-         the current one.  */\n-      if (gfc_add_new_implicit_range (c1, c2, ts) != SUCCESS)\n-\tgoto bad;\n-    }\n-\n-  return MATCH_YES;\n-\n-bad:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-  gfc_current_locus = cur_loc;\n-  return MATCH_ERROR;\n-}\n-\n-\n-/* Match an IMPLICIT statement, storing the types for\n-   gfc_set_implicit() if the statement is accepted by the parser.\n-   There is a strange looking, but legal syntactic construction\n-   possible.  It looks like:\n-\n-     IMPLICIT INTEGER (a-b) (c-d)\n-\n-   This is legal if \"a-b\" is a constant expression that happens to\n-   equal one of the legal kinds for integers.  The real problem\n-   happens with an implicit specification that looks like:\n-\n-     IMPLICIT INTEGER (a-b)\n-\n-   In this case, a typespec matcher that is \"greedy\" (as most of the\n-   matchers are) gobbles the character range as a kindspec, leaving\n-   nothing left.  We therefore have to go a bit more slowly in the\n-   matching process by inhibiting the kindspec checking during\n-   typespec matching and checking for a kind later.  */\n-\n-match\n-gfc_match_implicit (void)\n-{\n-  gfc_typespec ts;\n-  locus cur_loc;\n-  int c;\n-  match m;\n-\n-  /* We don't allow empty implicit statements.  */\n-  if (gfc_match_eos () == MATCH_YES)\n-    {\n-      gfc_error (\"Empty IMPLICIT statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-\n-  /* First cleanup.  */\n-  gfc_clear_new_implicit ();\n-\n-  do\n-    {\n-      /* A basic type is mandatory here.  */\n-      m = gfc_match_type_spec (&ts, 0);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      cur_loc = gfc_current_locus;\n-      m = match_implicit_range (&ts);\n-\n-      if (m == MATCH_YES)\n-\t{\n-\t  /* Looks like we have the <TYPE> (<RANGE>).  */\n-\t  gfc_gobble_whitespace ();\n-\t  c = gfc_next_char ();\n-\t  if ((c == '\\n') || (c == ','))\n-\t    continue;\n-\n-\t  gfc_current_locus = cur_loc;\n-\t}\n-\n-      /* Last chance -- check <TYPE> (<KIND>) (<RANGE>).  */\n-      m = gfc_match_kind_spec (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\t{\n-\t  m = gfc_match_old_kind_spec (&ts);\n-\t  if (m == MATCH_ERROR)\n-\t    goto error;\n-\t  if (m == MATCH_NO)\n-\t    goto syntax;\n-\t}\n-\n-      m = match_implicit_range (&ts);\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_NO)\n-\tgoto syntax;\n-\n-      gfc_gobble_whitespace ();\n-      c = gfc_next_char ();\n-      if ((c != '\\n') && (c != ','))\n-\tgoto syntax;\n-\n-    }\n-  while (c == ',');\n-\n-  /* All we need to now is try to merge the new implicit types back\n-     into the existing types.  This will fail if another implicit\n-     type is already defined for a letter.  */\n-  return (gfc_merge_new_implicit () == SUCCESS) ?\n-      MATCH_YES : MATCH_ERROR;\n-\n-syntax:\n-  gfc_syntax_error (ST_IMPLICIT);\n-\n-error:\n-  return MATCH_ERROR;\n-}\n-\n-\n /* Given a name, return a pointer to the common head structure,\n    creating it if it does not exist.\n    TODO: Add to global symbol tree.  */"}, {"sha": "4b8f87232ec82676fcc760849789b6d671c81b8f", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -75,8 +75,6 @@ match gfc_match_deallocate (void);\n match gfc_match_return (void);\n match gfc_match_call (void);\n match gfc_match_common (void);\n-match gfc_match_implicit_none (void);\n-match gfc_match_implicit (void);\n match gfc_match_block_data (void);\n match gfc_match_namelist (void);\n match gfc_match_module (void);\n@@ -98,7 +96,6 @@ gfc_common_head *gfc_get_common (char *);\n match gfc_match_null (gfc_expr **);\n match gfc_match_kind_spec (gfc_typespec *);\n match gfc_match_old_kind_spec (gfc_typespec *);\n-match gfc_match_type_spec (gfc_typespec *, int);\n \n match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n@@ -108,6 +105,9 @@ match gfc_match_entry (void);\n match gfc_match_subroutine (void);\n match gfc_match_derived_decl (void);\n \n+match gfc_match_implicit_none (void);\n+match gfc_match_implicit (void);\n+\n /* Matchers for attribute declarations */\n match gfc_match_allocatable (void);\n match gfc_match_dimension (void);"}, {"sha": "e043aaac3d692cb707a338371b786b179eea270a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -1,4 +1,10 @@\n- 2004-06-30  David Billinghurst (David.Billinghurst@riotinto.com)\n+2004-06-30  Tobias Schlueter  <tobias.shclueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/16161\n+\t* gfortran.fortran-torture/compile/implicit.f90: Add test\n+\tfor implicit character.\n+\n+2004-06-30  David Billinghurst (David.Billinghurst@riotinto.com)\n \n  \tPR fortran/16289\n  \t* gfortran.fortran-torture/execute/intrinsic_nearest.f90"}, {"sha": "8a6c4f56d165c46bea823d676118fc80402d74e7", "filename": "gcc/testsuite/gfortran.fortran-torture/compile/implicit.f90", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5ddaa24beae8ae06e2a8e962131a1bc55f7146e/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fcompile%2Fimplicit.f90?ref=e5ddaa24beae8ae06e2a8e962131a1bc55f7146e", "patch": "@@ -6,3 +6,8 @@\n y = d\n z = a\n end\n+! test prompted by PR 16161\n+! we used to match \"character (c)\" wrongly in the below, confusing the parser\n+subroutine b\n+implicit character (c)\n+end"}]}