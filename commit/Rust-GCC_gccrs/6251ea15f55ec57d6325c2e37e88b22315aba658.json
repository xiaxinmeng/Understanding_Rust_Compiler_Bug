{"sha": "6251ea15f55ec57d6325c2e37e88b22315aba658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1MWVhMTVmNTVlYzU3ZDYzMjVjMmUzN2U4OGIyMjMxNWFiYTY1OA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-06T15:16:33Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-06T17:26:45Z"}, "message": "libstdc++: Adjust overflow prevention to operator>>\n\nThis adjusts the overflow prevention added to operator>> so that we can\ndistinguish \"unknown size\" from \"zero size\", and avoid writing anything\nat all in to zero sized buffers.\n\nThis also removes the incorrect comment saying extraction stops at a\nnull byte.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/istream (operator>>(istream&, char*)): Add\n\tattributes to get warnings for pointers that are null or known\n\tto point to the end of a buffer. Request upper bound from\n\t__builtin_object_size check and handle zero-sized buffer case.\n\t(operator>>(istream&, signed char))\n\t(operator>>(istream&, unsigned char*)): Add attributes.\n\t* testsuite/27_io/basic_istream/extractors_character/char/overflow.cc:\n\tCheck extracting into the middle of a buffer.\n\t* testsuite/27_io/basic_istream/extractors_character/wchar_t/overflow.cc: New test.", "tree": {"sha": "0f44c42a6daea85c951e58e781fb2a6c7f4bf37b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f44c42a6daea85c951e58e781fb2a6c7f4bf37b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6251ea15f55ec57d6325c2e37e88b22315aba658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6251ea15f55ec57d6325c2e37e88b22315aba658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6251ea15f55ec57d6325c2e37e88b22315aba658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6251ea15f55ec57d6325c2e37e88b22315aba658/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c376d1c166e7c8b10bba6f1675d2471ffe8447f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c376d1c166e7c8b10bba6f1675d2471ffe8447f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c376d1c166e7c8b10bba6f1675d2471ffe8447f"}], "stats": {"total": 104, "additions": 94, "deletions": 10}, "files": [{"sha": "20a455a0ef1d45ad294cf294b628e48c78727a49", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=6251ea15f55ec57d6325c2e37e88b22315aba658", "patch": "@@ -790,7 +790,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  - `n - 1` characters are stored\n    *  - EOF is reached\n    *  - the next character is whitespace according to the current locale\n-   *  - the next character is a null byte (i.e., `charT()`)\n    *\n    *  `width(0)` is then called for the input stream.\n    *\n@@ -799,25 +798,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #if __cplusplus <= 201703L\n   template<typename _CharT, typename _Traits>\n+    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n     inline basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n     {\n-      streamsize __n = __builtin_object_size(__s, 2) / sizeof(_CharT);\n-      if (__n == 0)\n-\t__n = __gnu_cxx::__numeric_traits<streamsize>::__max / sizeof(_CharT);\n-      std::__istream_extract(__in, __s, __n);\n+      size_t __n = __builtin_object_size(__s, 0);\n+      if (__builtin_expect(__n < sizeof(_CharT), false))\n+\t{\n+\t  // There is not even space for the required null terminator.\n+\t  __glibcxx_assert(__n >= sizeof(_CharT));\n+\t  __in.width(0);\n+\t  __in.setstate(ios_base::failbit);\n+\t}\n+      else\n+\t{\n+\t  if (__n == (size_t)-1)\n+\t    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t  std::__istream_extract(__in, __s, __n / sizeof(_CharT));\n+\t}\n       return __in;\n     }\n \n   template<class _Traits>\n+    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n     inline basic_istream<char, _Traits>&\n     operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)\n-    { return (__in >> reinterpret_cast<char*>(__s)); }\n+    { return __in >> reinterpret_cast<char*>(__s); }\n \n   template<class _Traits>\n+    __attribute__((__nonnull__(2), __access__(__write_only__, 2)))\n     inline basic_istream<char, _Traits>&\n     operator>>(basic_istream<char, _Traits>& __in, signed char* __s)\n-    { return (__in >> reinterpret_cast<char*>(__s)); }\n+    { return __in >> reinterpret_cast<char*>(__s); }\n #else\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 2499. operator>>(istream&, char*) makes it hard to avoid buffer overflows"}, {"sha": "abbba8bb09bc5c7f8720112cf0089f9f04b8c7e1", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/overflow.cc", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Foverflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Foverflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Foverflow.cc?ref=6251ea15f55ec57d6325c2e37e88b22315aba658", "patch": "@@ -15,26 +15,39 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-O2 -std=gnu++98\" }\n+// { dg-options \"-O2\" }\n // { dg-do run }\n \n // This test checks that operator>> will avoid a buffer overflow when\n // reading into a buffer with a size that is known at compile time.\n \n // Since C++20 this is guaranteed (see LWG 2499), for previous standards\n-// we try to check the buffer size as an extension (which depends on -O2).\n+// checking the buffer size is an extension and depends on optimisation.\n \n #include <sstream>\n #include <testsuite_hooks.h>\n \n void\n test01()\n {\n-  std::istringstream in(\"foolish child\");\n+  std::istringstream in(\"foolishly\");\n   char pc[5];\n   in >> pc;\n   VERIFY( in.good() );\n   VERIFY( std::string(pc) == \"fool\" );\n+\n+#if __cplusplus <= 201703L\n+  char* p = pc + 1;\n+  in >> p;\n+  VERIFY( in.good() );\n+  VERIFY( std::string(pc) == \"fish\" );\n+\n+  p = pc + 4;\n+  *p = '#';\n+  in >> p;\n+  VERIFY( in.fail() ); // if no characters are extracted, failbit is set\n+  VERIFY( *p == '\\0' );\n+#endif\n }\n \n void\n@@ -61,4 +74,6 @@ int\n main()\n {\n   test01();\n+  test02();\n+  test03();\n }"}, {"sha": "6a23f1305a335a0cdac202089099632e1585201d", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/overflow.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Foverflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6251ea15f55ec57d6325c2e37e88b22315aba658/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Foverflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Foverflow.cc?ref=6251ea15f55ec57d6325c2e37e88b22315aba658", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-O2\" }\n+// { dg-do run }\n+\n+// This test checks that operator>> will avoid a buffer overflow when\n+// reading into a buffer with a size that is known at compile time.\n+\n+// Since C++20 this is guaranteed (see LWG 2499), for previous standards\n+// checking the buffer size is an extension and depends on optimisation.\n+\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::wistringstream in(L\"foolishly\");\n+  wchar_t pc[5];\n+  in >> pc;\n+  VERIFY( in.good() );\n+  VERIFY( std::wstring(pc) == L\"fool\" );\n+\n+#if __cplusplus <= 201703L\n+  wchar_t* p = pc + 1;\n+  in >> p;\n+  VERIFY( in.good() );\n+  VERIFY( std::wstring(pc) == L\"fish\" );\n+\n+  p = pc + 4;\n+  *p = L'#';\n+  in >> p;\n+  VERIFY( in.fail() ); // if no characters are extracted, failbit is set\n+  VERIFY( *p == L'\\0' );\n+#endif\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}