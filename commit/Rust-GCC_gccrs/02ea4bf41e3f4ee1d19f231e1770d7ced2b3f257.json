{"sha": "02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlYTRiZjQxZTNmNGVlMWQxOWYyMzFlMTc3MGQ3Y2VkMmIzZjI1Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-26T06:38:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-26T06:38:23Z"}, "message": "lra-constraints.c (get_index_scale, [...]): New functions.\n\ngcc/\n\t* lra-constraints.c (get_index_scale, can_add_disp_p): New functions.\n\t(equiv_address_substitution): Use them.\n\nFrom-SVN: r192835", "tree": {"sha": "f825b0646fb2440cbf7c5ca772ad65ec1824ea21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f825b0646fb2440cbf7c5ca772ad65ec1824ea21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bf9b489845a6b0b462c6d2a8e2a17cd42d90023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf9b489845a6b0b462c6d2a8e2a17cd42d90023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf9b489845a6b0b462c6d2a8e2a17cd42d90023"}], "stats": {"total": 74, "additions": 66, "deletions": 8}, "files": [{"sha": "4a93aa6e9224711d0849fb90c36f2aa866f40c5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "patch": "@@ -1,3 +1,8 @@\n+2012-10-26  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lra-constraints.c (get_index_scale, can_add_disp_p): New functions.\n+\t(equiv_address_substitution): Use them.\n+\n 2012-10-26  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* lra-constraints.c (valid_address_p): New function, split out from..."}, {"sha": "84c9e1511c99103f6faddd0c31a928c530be703d", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=02ea4bf41e3f4ee1d19f231e1770d7ced2b3f257", "patch": "@@ -756,6 +756,28 @@ extract_address_regs (enum machine_mode mem_mode, addr_space_t as,\n     ad->index_loc = ad->index_reg_loc;\n }\n \n+/* Return the scale applied to *AD->INDEX_REG_LOC, or 0 if the index is\n+   more complicated than that.  */\n+static HOST_WIDE_INT\n+get_index_scale (struct address *ad)\n+{\n+  rtx index = *ad->index_loc;\n+  if (GET_CODE (index) == MULT\n+      && CONST_INT_P (XEXP (index, 1))\n+      && ad->index_reg_loc == &XEXP (index, 0))\n+    return INTVAL (XEXP (index, 1));\n+\n+  if (GET_CODE (index) == ASHIFT\n+      && CONST_INT_P (XEXP (index, 1))\n+      && ad->index_reg_loc == &XEXP (index, 0))\n+    return (HOST_WIDE_INT) 1 << INTVAL (XEXP (index, 1));\n+\n+  if (ad->index_reg_loc == ad->index_loc)\n+    return 1;\n+\n+  return 0;\n+}\n+\n \f\n \n /* The page contains major code to choose the current insn alternative\n@@ -2428,6 +2450,40 @@ base_plus_disp_to_reg (enum machine_mode mode, addr_space_t as,\n   return new_reg;\n }\n \n+/* Return true if we can add a displacement to address ADDR_LOC,\n+   which is described by AD, even if that makes the address invalid.\n+   The fix-up code requires any new address to be the sum of the base,\n+   index and displacement fields of an AD-like structure.  */\n+static bool\n+can_add_disp_p (struct address *ad, rtx *addr_loc)\n+{\n+  /* Automodified addresses have a fixed form.  */\n+  if (ad->base_modify_p)\n+    return false;\n+\n+  /* If the address already has a displacement, and is not an UNSPEC,\n+     we can simply add the new displacement to it.  */\n+  if (ad->disp_loc && GET_CODE (*ad->disp_loc) == UNSPEC)\n+    return true;\n+\n+  /* If the address is entirely a base or index, we can try adding\n+     a constant to it.  */\n+  if (addr_loc == ad->base_reg_loc || addr_loc == ad->index_loc)\n+    return true;\n+\n+  /* Likewise if the address is entirely a sum of the base and index.  */\n+  if (GET_CODE (*addr_loc) == PLUS)\n+    {\n+      rtx *op0 = &XEXP (*addr_loc, 0);\n+      rtx *op1 = &XEXP (*addr_loc, 1);\n+      if (op0 == ad->base_reg_loc && op1 == ad->index_loc)\n+\treturn true;\n+      if (op1 == ad->base_reg_loc && op0 == ad->index_loc)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Make substitution in address AD in space AS with location ADDR_LOC.\n    Update AD and ADDR_LOC if it is necessary.  Return true if a\n    substitution was made.  */\n@@ -2473,7 +2529,8 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n \t}\n       else if (GET_CODE (new_base_reg) == PLUS\n \t       && REG_P (XEXP (new_base_reg, 0))\n-\t       && CONST_INT_P (XEXP (new_base_reg, 1)))\n+\t       && CONST_INT_P (XEXP (new_base_reg, 1))\n+\t       && can_add_disp_p (ad, addr_loc))\n \t{\n \t  disp += INTVAL (XEXP (new_base_reg, 1));\n \t  *ad->base_reg_loc = XEXP (new_base_reg, 0);\n@@ -2482,12 +2539,6 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n       if (ad->base_reg_loc2 != NULL)\n \t*ad->base_reg_loc2 = *ad->base_reg_loc;\n     }\n-  scale = 1;\n-  if (ad->index_loc != NULL && GET_CODE (*ad->index_loc) == MULT)\n-    {\n-      lra_assert (CONST_INT_P (XEXP (*ad->index_loc, 1)));\n-      scale = INTVAL (XEXP (*ad->index_loc, 1));\n-    }\n   if (index_reg != new_index_reg)\n     {\n       if (REG_P (new_index_reg))\n@@ -2497,7 +2548,9 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n \t}\n       else if (GET_CODE (new_index_reg) == PLUS\n \t       && REG_P (XEXP (new_index_reg, 0))\n-\t       && CONST_INT_P (XEXP (new_index_reg, 1)))\n+\t       && CONST_INT_P (XEXP (new_index_reg, 1))\n+\t       && can_add_disp_p (ad, addr_loc)\n+\t       && (scale = get_index_scale (ad)))\n \t{\n \t  disp += INTVAL (XEXP (new_index_reg, 1)) * scale;\n \t  *ad->index_reg_loc = XEXP (new_index_reg, 0);"}]}