{"sha": "1158fe43407568f20415b16575ddbfff216bf8b6", "node_id": "C_kwDOANBUbNoAKDExNThmZTQzNDA3NTY4ZjIwNDE1YjE2NTc1ZGRiZmZmMjE2YmY4YjY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-13T11:42:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-06-13T12:02:37Z"}, "message": "openmp: Conforming device numbers and omp_{initial,invalid}_device\n\nOpenMP 5.2 changed once more what device numbers are allowed.\nIn 5.1, valid device numbers were [0, omp_get_num_devices()].\n5.2 makes also -1 valid (calls it omp_initial_device), which is equivalent\nin behavior to omp_get_num_devices() number but has the advantage that it\nis a constant.  And it also introduces omp_invalid_device which is\nalso a constant with implementation defined value < -1.  That value should\nact like sNaN, any time any device construct (GOMP_target*) or OpenMP runtime\nAPI routine is asked for such a device, the program is terminated.\nAnd if OMP_TARGET_OFFLOAD=mandatory, all non-conforming device numbers (which\nis all but [-1, omp_get_num_devices()] other than omp_invalid_device)\nmust be treated like omp_invalid_device.\n\nFor device constructs, we have a compatibility problem, we've historically\nused 2 magic negative values to mean something special.\nGOMP_DEVICE_ICV (-1) means device clause wasn't present, pick the\n\t\t     omp_get_default_device () number\nGOMP_DEVICE_FALLBACK (-2) means the host device (this is used e.g. for\n\t\t\t  #pragma omp target if (cond)\n\t\t\t  where if cond is false, we pass -2\nBut 5.2 requires that omp_initial_device is -1 (there were discussions\nabout it, advantage of -1 is that one can say iterate over the\n[-1, omp_get_num_devices()-1] range to get all devices starting with\nthe host/initial one.\nAnd also, if user passes -2, unless it is omp_invalid_device, we need to\ntreat it like non-conforming with OMP_TARGET_OFFLOAD=mandatory.\n\nSo, the patch does on the compiler side some number remapping,\nuser_device_num >= -2U ? user_device_num - 1 : user_device_num.\nThis remapping is done at compile time if device clause has constant\nargument, otherwise at runtime, and means that for user -1 (omp_initial_device)\nwe pass -2 to GOMP_* in the runtime library where it treats it like host\nfallback, while -2 is remapped to -3 (one of the non-conforming device numbers,\nfor those it doesn't matter which one is which).\nomp_invalid_device is then -4.\nFor the OpenMP device runtime APIs, no remapping is done.\n\nThis patch doesn't deal with the initial default-device-var for\nOMP_TARGET_OFFLOAD=mandatory , the spec says that the inital ICV value\nfor that should in that case depend on whether there are any offloading\ndevices or not (if not, should be omp_invalid_device), but that means\nwe can't determine the number of devices lazily (and let libraries have the\npossibility to register their offloading data etc.).\n\n2022-06-13  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* omp-expand.cc (expand_omp_target): Remap user provided\n\tdevice clause arguments, -1 to -2 and -2 to -3, either\n\tat compile time if constant, or at runtime.\ninclude/\n\t* gomp-constants.h (GOMP_DEVICE_INVALID): Define.\nlibgomp/\n\t* omp.h.in (omp_initial_device, omp_invalid_device): New enumerators.\n\t* omp_lib.f90.in (omp_initial_device, omp_invalid_device): New\n\tparameters.\n\t* omp_lib.h.in (omp_initial_device, omp_invalid_device): Likewise.\n\t* target.c (resolve_device): Add remapped argument, handle\n\tGOMP_DEVICE_ICV only if remapped is true (and clear remapped),\n\tfor negative values, treat GOMP_DEVICE_FALLBACK as fallback only\n\tif remapped, otherwise treat omp_initial_device that way.  For\n\tomp_invalid_device, always emit gomp_fatal, even when\n\tOMP_TARGET_OFFLOAD isn't mandatory.\n\t(GOMP_target, GOMP_target_ext, GOMP_target_data, GOMP_target_data_ext,\n\tGOMP_target_update, GOMP_target_update_ext,\n\tGOMP_target_enter_exit_data): Pass true as remapped argument to\n\tresolve_device.\n\t(omp_target_alloc, omp_target_free, omp_target_is_present,\n\tomp_target_memcpy_check, omp_target_associate_ptr,\n\tomp_target_disassociate_ptr, omp_get_mapped_ptr,\n\tomp_target_is_accessible): Pass false as remapped argument to\n\tresolve_device.  Treat omp_initial_device the same as\n\tgomp_get_num_devices ().  Don't bypass resolve_device calls if\n\tdevice_num is negative.\n\t(omp_pause_resource): Treat omp_initial_device the same as\n\tgomp_get_num_devices ().  Call resolve_device.\n\t* icv-device.c (omp_set_default_device): Always set to device_num\n\teven when it is negative.\n\t* libgomp.texi: Document that Conforming device numbers,\n\tomp_initial_device and omp_invalid_device is implemented.\n\t* testsuite/libgomp.c/target-41.c (main): Add test with\n\tomp_initial_device.\n\t* testsuite/libgomp.c/target-45.c: New test.\n\t* testsuite/libgomp.c/target-46.c: New test.\n\t* testsuite/libgomp.c/target-47.c: New test.\n\t* testsuite/libgomp.c-c++-common/target-is-accessible-1.c (main): Add\n\ttest with omp_initial_device.  Use -5 instead of -1 for negative value\n\ttest.\n\t* testsuite/libgomp.fortran/target-is-accessible-1.f90 (main):\n\tLikewise.  Reorder stop numbers.", "tree": {"sha": "f6d81a2caaae787317901639f42144396f359b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d81a2caaae787317901639f42144396f359b40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1158fe43407568f20415b16575ddbfff216bf8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1158fe43407568f20415b16575ddbfff216bf8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1158fe43407568f20415b16575ddbfff216bf8b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1158fe43407568f20415b16575ddbfff216bf8b6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b598848f6fdbf7e76eaf2beec1ce94fc3a14b9b"}], "stats": {"total": 311, "additions": 223, "deletions": 88}, "files": [{"sha": "e7a8af4ff9d3d3d91beba16cd3bd38f10bf75beb", "filename": "gcc/omp-expand.cc", "status": "modified", "additions": 64, "deletions": 10, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/gcc%2Fomp-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/gcc%2Fomp-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.cc?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -9983,6 +9983,8 @@ expand_omp_target (struct omp_region *region)\n   tree device = NULL_TREE;\n   location_t device_loc = UNKNOWN_LOCATION;\n   tree goacc_flags = NULL_TREE;\n+  bool need_device_adjustment = false;\n+  gimple_stmt_iterator adj_gsi;\n   if (is_gimple_omp_oacc (entry_stmt))\n     {\n       /* By default, no GOACC_FLAGs are set.  */\n@@ -9994,6 +9996,19 @@ expand_omp_target (struct omp_region *region)\n       if (c)\n \t{\n \t  device = OMP_CLAUSE_DEVICE_ID (c);\n+\t  /* Ensure 'device' is of the correct type.  */\n+\t  device = fold_convert_loc (device_loc, integer_type_node, device);\n+\t  if (TREE_CODE (device) == INTEGER_CST)\n+\t    {\n+\t      if (wi::to_wide (device) == GOMP_DEVICE_ICV)\n+\t\tdevice = build_int_cst (integer_type_node,\n+\t\t\t\t\tGOMP_DEVICE_HOST_FALLBACK);\n+\t      else if (wi::to_wide (device) == GOMP_DEVICE_HOST_FALLBACK)\n+\t\tdevice = build_int_cst (integer_type_node,\n+\t\t\t\t\tGOMP_DEVICE_HOST_FALLBACK - 1);\n+\t    }\n+\t  else\n+\t    need_device_adjustment = true;\n \t  device_loc = OMP_CLAUSE_LOCATION (c);\n \t  if (OMP_CLAUSE_DEVICE_ANCESTOR (c))\n \t    sorry_at (device_loc, \"%<ancestor%> not yet supported\");\n@@ -10021,28 +10036,22 @@ expand_omp_target (struct omp_region *region)\n   if (c)\n     cond = OMP_CLAUSE_IF_EXPR (c);\n   /* If we found the clause 'if (cond)', build:\n-     OpenACC: goacc_flags = (cond ? goacc_flags : flags | GOACC_FLAG_HOST_FALLBACK)\n+     OpenACC: goacc_flags = (cond ? goacc_flags\n+\t\t\t\t  : goacc_flags | GOACC_FLAG_HOST_FALLBACK)\n      OpenMP: device = (cond ? device : GOMP_DEVICE_HOST_FALLBACK) */\n   if (cond)\n     {\n       tree *tp;\n       if (is_gimple_omp_oacc (entry_stmt))\n \ttp = &goacc_flags;\n       else\n-\t{\n-\t  /* Ensure 'device' is of the correct type.  */\n-\t  device = fold_convert_loc (device_loc, integer_type_node, device);\n-\n-\t  tp = &device;\n-\t}\n+\ttp = &device;\n \n       cond = gimple_boolify (cond);\n \n       basic_block cond_bb, then_bb, else_bb;\n       edge e;\n-      tree tmp_var;\n-\n-      tmp_var = create_tmp_var (TREE_TYPE (*tp));\n+      tree tmp_var = create_tmp_var (TREE_TYPE (*tp));\n       if (offloaded)\n \te = split_block_after_labels (new_bb);\n       else\n@@ -10067,6 +10076,7 @@ expand_omp_target (struct omp_region *region)\n       gsi = gsi_start_bb (then_bb);\n       stmt = gimple_build_assign (tmp_var, *tp);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      adj_gsi = gsi;\n \n       gsi = gsi_start_bb (else_bb);\n       if (is_gimple_omp_oacc (entry_stmt))\n@@ -10099,6 +10109,50 @@ expand_omp_target (struct omp_region *region)\n       if (device != NULL_TREE)\n \tdevice = force_gimple_operand_gsi (&gsi, device, true, NULL_TREE,\n \t\t\t\t\t   true, GSI_SAME_STMT);\n+      if (need_device_adjustment)\n+\t{\n+\t  tree tmp_var = create_tmp_var (TREE_TYPE (device));\n+\t  stmt = gimple_build_assign (tmp_var, device);\n+\t  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  adj_gsi = gsi_for_stmt (stmt);\n+\t  device = tmp_var;\n+\t}\n+    }\n+\n+  if (need_device_adjustment)\n+    {\n+      tree uns = fold_convert (unsigned_type_node, device);\n+      uns = force_gimple_operand_gsi (&adj_gsi, uns, true, NULL_TREE,\n+\t\t\t\t      false, GSI_CONTINUE_LINKING);\n+      edge e = split_block (gsi_bb (adj_gsi), gsi_stmt (adj_gsi));\n+      basic_block cond_bb = e->src;\n+      basic_block else_bb = e->dest;\n+      if (gsi_bb (adj_gsi) == new_bb)\n+\t{\n+\t  new_bb = else_bb;\n+\t  gsi = gsi_last_nondebug_bb (new_bb);\n+\t}\n+\n+      basic_block then_bb = create_empty_bb (cond_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+\n+      cond = build2 (GT_EXPR, boolean_type_node, uns,\n+\t\t     build_int_cst (unsigned_type_node,\n+\t\t\t\t    GOMP_DEVICE_HOST_FALLBACK - 1));\n+      stmt = gimple_build_cond_empty (cond);\n+      adj_gsi = gsi_last_bb (cond_bb);\n+      gsi_insert_after (&adj_gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      adj_gsi = gsi_start_bb (then_bb);\n+      tree add = build2 (PLUS_EXPR, integer_type_node, device,\n+\t\t\t build_int_cst (integer_type_node, -1));\n+      stmt = gimple_build_assign (device, add);\n+      gsi_insert_after (&adj_gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+      make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+      e->flags = EDGE_FALSE_VALUE;\n+      add_bb_to_loop (then_bb, cond_bb->loop_father);\n+      make_edge (then_bb, else_bb, EDGE_FALLTHRU);\n     }\n \n   t = gimple_omp_target_data_arg (entry_stmt);"}, {"sha": "e4dd8ef3e1d892edbc80168081e93bbec37a66f1", "filename": "include/gomp-constants.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -233,8 +233,19 @@ enum gomp_map_kind\n #define GOMP_DEVICE_HSA\t\t\t7\n #define GOMP_DEVICE_GCN\t\t\t8\n \n+/* We have a compatibility issue.  OpenMP 5.2 introduced\n+   omp_initial_device with value of -1 which clashes with our\n+   GOMP_DEVICE_ICV, so we need to remap user supplied device\n+   ids, -1 (aka omp_initial_device) to GOMP_DEVICE_HOST_FALLBACK,\n+   and -2 (one of many non-conforming device numbers, but with\n+   OMP_TARGET_OFFLOAD=mandatory needs to be treated a\n+   omp_invalid_device) to -3 (so that for dev_num >= -2U we can\n+   subtract 1).  -4 is then what we use for omp_invalid_device,\n+   which unlike the other non-conforming device numbers results\n+   in fatal error regardless of OMP_TARGET_OFFLOAD.  */\n #define GOMP_DEVICE_ICV\t\t\t-1\n #define GOMP_DEVICE_HOST_FALLBACK\t-2\n+#define GOMP_DEVICE_INVALID\t\t-4\n \n /* GOMP_task/GOMP_taskloop* flags argument.  */\n #define GOMP_TASK_FLAG_UNTIED\t\t(1 << 0)"}, {"sha": "11ceb304bbdb1d6e9e3a85d962fb1ba840971006", "filename": "libgomp/icv-device.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ficv-device.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ficv-device.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ficv-device.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -32,7 +32,7 @@ void\n omp_set_default_device (int device_num)\n {\n   struct gomp_task_icv *icv = gomp_icv (true);\n-  icv->default_device_var = device_num >= 0 ? device_num : 0;\n+  icv->default_device_var = device_num;\n }\n \n ialias (omp_set_default_device)"}, {"sha": "a5e54456746ce17277e5a9cb270d70ad2a9d7314", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -403,7 +403,7 @@ The OpenMP 4.5 specification is fully supported.\n @headitem Description @tab Status @tab Comments\n @item For Fortran, optional comma between directive and clause @tab N @tab\n @item Conforming device numbers and @code{omp_initial_device} and\n-      @code{omp_invalid_device} enum/PARAMETER @tab N @tab\n+      @code{omp_invalid_device} enum/PARAMETER @tab Y @tab\n @item Initial value of @emph{default-device-var} ICV with\n       @code{OMP_TARGET_OFFLOAD=mandatory} @tab N @tab\n @item @emph{interop_types} in any position of the modifier list for the @code{init} clause"}, {"sha": "925a650135e99374b5f67bd77b7c5db51ef6f369", "filename": "libgomp/omp.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp.h.in?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -184,6 +184,12 @@ typedef enum omp_event_handle_t __GOMP_UINTPTR_T_ENUM\n   __omp_event_handle_t_max__ = __UINTPTR_MAX__\n } omp_event_handle_t;\n \n+enum\n+{\n+  omp_initial_device = -1,\n+  omp_invalid_device = -4\n+};\n+\n #ifdef __cplusplus\n extern \"C\" {\n # define __GOMP_NOTHROW throw ()"}, {"sha": "7ba115f3a1aba034b8593f95c1d9684b99f05c93", "filename": "libgomp/omp_lib.f90.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp_lib.f90.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp_lib.f90.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.f90.in?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -168,6 +168,8 @@\n                  parameter :: omp_high_bw_mem_space = 3\n         integer (omp_memspace_handle_kind), &\n                  parameter :: omp_low_lat_mem_space = 4\n+        integer, parameter :: omp_initial_device = -1\n+        integer, parameter :: omp_invalid_device = -4\n \n         type omp_alloctrait\n           integer (kind=omp_alloctrait_key_kind) key"}, {"sha": "362683638593ac6cf13687c98cb9d3f41eb2752a", "filename": "libgomp/omp_lib.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp_lib.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Fomp_lib.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fomp_lib.h.in?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -174,6 +174,9 @@\n       parameter (omp_const_mem_space = 2)\n       parameter (omp_high_bw_mem_space = 3)\n       parameter (omp_low_lat_mem_space = 4)\n+      integer omp_initial_device, omp_invalid_device\n+      parameter (omp_initial_device = -1)\n+      parameter (omp_invalid_device = -4)\n \n       type omp_alloctrait\n         integer (omp_alloctrait_key_kind) key"}, {"sha": "c0844f2265a6b3b4c2887d66a0cdf654d55c8876", "filename": "libgomp/target.c", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -126,18 +126,31 @@ gomp_get_num_devices (void)\n }\n \n static struct gomp_device_descr *\n-resolve_device (int device_id)\n+resolve_device (int device_id, bool remapped)\n {\n-  if (device_id == GOMP_DEVICE_ICV)\n+  if (remapped && device_id == GOMP_DEVICE_ICV)\n     {\n       struct gomp_task_icv *icv = gomp_icv (false);\n       device_id = icv->default_device_var;\n+      remapped = false;\n     }\n \n-  if (device_id < 0 || device_id >= gomp_get_num_devices ())\n+  if (device_id < 0)\n+    {\n+      if (device_id == (remapped ? GOMP_DEVICE_HOST_FALLBACK\n+\t\t\t\t : omp_initial_device))\n+\treturn NULL;\n+      if (device_id == omp_invalid_device)\n+\tgomp_fatal (\"omp_invalid_device encountered\");\n+      else if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY)\n+\tgomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, \"\n+\t\t    \"but device not found\");\n+\n+      return NULL;\n+    }\n+  else if (device_id >= gomp_get_num_devices ())\n     {\n       if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY\n-\t  && device_id != GOMP_DEVICE_HOST_FALLBACK\n \t  && device_id != num_devices_openmp)\n \tgomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, \"\n \t\t    \"but device not found\");\n@@ -2588,7 +2601,7 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n \t     size_t mapnum, void **hostaddrs, size_t *sizes,\n \t     unsigned char *kinds)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   void *fn_addr;\n   if (devicep == NULL\n@@ -2647,7 +2660,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t void **hostaddrs, size_t *sizes, unsigned short *kinds,\n \t\t unsigned int flags, void **depend, void **args)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n   size_t tgt_align = 0, tgt_size = 0;\n   bool fpc_done = false;\n \n@@ -2805,7 +2818,7 @@ void\n GOMP_target_data (int device, const void *unused, size_t mapnum,\n \t\t  void **hostaddrs, size_t *sizes, unsigned char *kinds)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n@@ -2824,7 +2837,7 @@ void\n GOMP_target_data_ext (int device, size_t mapnum, void **hostaddrs,\n \t\t      size_t *sizes, unsigned short *kinds)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n@@ -2855,7 +2868,7 @@ void\n GOMP_target_update (int device, const void *unused, size_t mapnum,\n \t\t    void **hostaddrs, size_t *sizes, unsigned char *kinds)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n@@ -2870,7 +2883,7 @@ GOMP_target_update_ext (int device, size_t mapnum, void **hostaddrs,\n \t\t\tsize_t *sizes, unsigned short *kinds,\n \t\t\tunsigned int flags, void **depend)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   /* If there are depend clauses, but nowait is not present,\n      block the parent task until the dependencies are resolved\n@@ -3063,7 +3076,7 @@ GOMP_target_enter_exit_data (int device, size_t mapnum, void **hostaddrs,\n \t\t\t     size_t *sizes, unsigned short *kinds,\n \t\t\t     unsigned int flags, void **depend)\n {\n-  struct gomp_device_descr *devicep = resolve_device (device);\n+  struct gomp_device_descr *devicep = resolve_device (device, true);\n \n   /* If there are depend clauses, but nowait is not present,\n      block the parent task until the dependencies are resolved\n@@ -3296,13 +3309,11 @@ GOMP_teams4 (unsigned int num_teams_low, unsigned int num_teams_high,\n void *\n omp_target_alloc (size_t size, int device_num)\n {\n-  if (device_num == gomp_get_num_devices ())\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     return malloc (size);\n \n-  if (device_num < 0)\n-    return NULL;\n-\n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return NULL;\n \n@@ -3319,20 +3330,15 @@ omp_target_alloc (size_t size, int device_num)\n void\n omp_target_free (void *device_ptr, int device_num)\n {\n-  if (device_ptr == NULL)\n-    return;\n-\n-  if (device_num == gomp_get_num_devices ())\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     {\n       free (device_ptr);\n       return;\n     }\n \n-  if (device_num < 0)\n-    return;\n-\n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n-  if (devicep == NULL)\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n+  if (devicep == NULL || device_ptr == NULL)\n     return;\n \n   if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n@@ -3350,19 +3356,17 @@ omp_target_free (void *device_ptr, int device_num)\n int\n omp_target_is_present (const void *ptr, int device_num)\n {\n-  if (ptr == NULL)\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     return 1;\n \n-  if (device_num == gomp_get_num_devices ())\n-    return 1;\n-\n-  if (device_num < 0)\n-    return 0;\n-\n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return 0;\n \n+  if (ptr == NULL)\n+    return 1;\n+\n   if (!(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n       || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n     return 1;\n@@ -3384,12 +3388,11 @@ omp_target_memcpy_check (int dst_device_num, int src_device_num,\n \t\t\t struct gomp_device_descr **dst_devicep,\n \t\t\t struct gomp_device_descr **src_devicep)\n {\n-  if (dst_device_num != gomp_get_num_devices ())\n+  if (dst_device_num != gomp_get_num_devices ()\n+      /* Above gomp_get_num_devices has to be called unconditionally.  */\n+      && dst_device_num != omp_initial_device)\n     {\n-      if (dst_device_num < 0)\n-\treturn EINVAL;\n-\n-      *dst_devicep = resolve_device (dst_device_num);\n+      *dst_devicep = resolve_device (dst_device_num, false);\n       if (*dst_devicep == NULL)\n \treturn EINVAL;\n \n@@ -3398,12 +3401,10 @@ omp_target_memcpy_check (int dst_device_num, int src_device_num,\n \t*dst_devicep = NULL;\n     }\n \n-  if (src_device_num != num_devices_openmp)\n+  if (src_device_num != num_devices_openmp\n+      && src_device_num != omp_initial_device)\n     {\n-      if (src_device_num < 0)\n-\treturn EINVAL;\n-\n-      *src_devicep = resolve_device (src_device_num);\n+      *src_devicep = resolve_device (src_device_num, false);\n       if (*src_devicep == NULL)\n \treturn EINVAL;\n \n@@ -3767,13 +3768,11 @@ int\n omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,\n \t\t\t  size_t size, size_t device_offset, int device_num)\n {\n-  if (device_num == gomp_get_num_devices ())\n-    return EINVAL;\n-\n-  if (device_num < 0)\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     return EINVAL;\n \n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return EINVAL;\n \n@@ -3830,13 +3829,7 @@ omp_target_associate_ptr (const void *host_ptr, const void *device_ptr,\n int\n omp_target_disassociate_ptr (const void *ptr, int device_num)\n {\n-  if (device_num == gomp_get_num_devices ())\n-    return EINVAL;\n-\n-  if (device_num < 0)\n-    return EINVAL;\n-\n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return EINVAL;\n \n@@ -3872,13 +3865,11 @@ omp_target_disassociate_ptr (const void *ptr, int device_num)\n void *\n omp_get_mapped_ptr (const void *ptr, int device_num)\n {\n-  if (device_num < 0 || device_num > gomp_get_num_devices ())\n-    return NULL;\n-\n-  if (device_num == omp_get_initial_device ())\n+  if (device_num == omp_initial_device\n+      || device_num == omp_get_initial_device ())\n     return (void *) ptr;\n \n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return NULL;\n \n@@ -3910,13 +3901,11 @@ omp_get_mapped_ptr (const void *ptr, int device_num)\n int\n omp_target_is_accessible (const void *ptr, size_t size, int device_num)\n {\n-  if (device_num < 0 || device_num > gomp_get_num_devices ())\n-    return false;\n-\n-  if (device_num == gomp_get_num_devices ())\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     return true;\n \n-  struct gomp_device_descr *devicep = resolve_device (device_num);\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n   if (devicep == NULL)\n     return false;\n \n@@ -3929,10 +3918,14 @@ int\n omp_pause_resource (omp_pause_resource_t kind, int device_num)\n {\n   (void) kind;\n-  if (device_num == gomp_get_num_devices ())\n+  if (device_num == omp_initial_device\n+      || device_num == gomp_get_num_devices ())\n     return gomp_pause_host ();\n-  if (device_num < 0 || device_num >= num_devices_openmp)\n+\n+  struct gomp_device_descr *devicep = resolve_device (device_num, false);\n+  if (devicep == NULL)\n     return -1;\n+\n   /* Do nothing for target devices for now.  */\n   return 0;\n }"}, {"sha": "2e75c6300ae622ae495106d39be886a08e37ad26", "filename": "libgomp/testsuite/libgomp.c-c++-common/target-is-accessible-1.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-is-accessible-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-is-accessible-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftarget-is-accessible-1.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -17,7 +17,10 @@ main ()\n   if (!omp_target_is_accessible (p, sizeof (int), id))\n     __builtin_abort ();\n \n-  if (omp_target_is_accessible (p, sizeof (int), -1))\n+  if (!omp_target_is_accessible (p, sizeof (int), omp_initial_device))\n+    __builtin_abort ();\n+\n+  if (omp_target_is_accessible (p, sizeof (int), -5))\n     __builtin_abort ();\n \n   if (omp_target_is_accessible (p, sizeof (int), n + 1))"}, {"sha": "a300de4d009ebd3323e6f9709a1bc3a927333f7a", "filename": "libgomp/testsuite/libgomp.c/target-41.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-41.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -18,16 +18,18 @@ main ()\n {\n   /* OMP_TARGET_OFFLOAD=mandatory shouldn't fail for host fallback\n      if it is because the program explicitly asked for the host\n-     fallback through if(false) or omp_get_initial_device () as\n-     the device.  */\n+     fallback through if(false) or omp_get_initial_device () or\n+     omp_initial_device as the device.  */\n   #pragma omp target if (v)\n   foo ();\n+  #pragma omp target device (omp_initial_device)\n+  foo ();\n   #pragma omp target device (omp_get_initial_device ())\n   foo ();\n   omp_set_default_device (omp_get_initial_device ());\n   #pragma omp target\n   foo ();\n-  if (v != 3)\n+  if (v != 4)\n     abort ();\n   return 0;\n }"}, {"sha": "e5e4291bddeb45564832f6f68a2edce61902da70", "filename": "libgomp/testsuite/libgomp.c/target-45.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-45.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-shouldfail \"omp_invalid_device\" } */\n+\n+#include <omp.h>\n+\n+void\n+foo (void)\n+{\n+}\n+#pragma omp declare target enter (foo)\n+\n+int\n+main ()\n+{\n+  #pragma omp target device (omp_invalid_device)\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-output \"omp_invalid_device\" } */"}, {"sha": "982615f1b4cf25a373796c209a8c2b9983ea7fac", "filename": "libgomp/testsuite/libgomp.c/target-46.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-46.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-shouldfail \"omp_invalid_device\" } */\n+\n+#include <omp.h>\n+\n+void\n+foo (void)\n+{\n+}\n+\n+volatile int dev = omp_invalid_device;\n+\n+int\n+main ()\n+{\n+  #pragma omp target device (dev)\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-output \"omp_invalid_device\" } */"}, {"sha": "aa19fcb8276f2180b6b966f82dfe734ed530b5f9", "filename": "libgomp/testsuite/libgomp.c/target-47.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Ftarget-47.c?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-shouldfail \"omp_invalid_device\" } */\n+\n+#include <omp.h>\n+\n+void\n+foo (void)\n+{\n+}\n+\n+int\n+main ()\n+{\n+  omp_set_default_device (omp_invalid_device);\n+  #pragma omp target\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-output \"omp_invalid_device\" } */"}, {"sha": "150df6f8a4ff8411b89b3c5a093de817c548efb2", "filename": "libgomp/testsuite/libgomp.fortran/target-is-accessible-1.f90", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-is-accessible-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1158fe43407568f20415b16575ddbfff216bf8b6/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-is-accessible-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftarget-is-accessible-1.f90?ref=1158fe43407568f20415b16575ddbfff216bf8b6", "patch": "@@ -19,12 +19,15 @@ program main\n   if (omp_target_is_accessible (p, c_sizeof (d), id) /= 1) &\n     stop 2\n \n-  if (omp_target_is_accessible (p, c_sizeof (d), -1) /= 0) &\n+  if (omp_target_is_accessible (p, c_sizeof (d), omp_initial_device) /= 1) &\n     stop 3\n \n-  if (omp_target_is_accessible (p, c_sizeof (d), n + 1) /= 0) &\n+  if (omp_target_is_accessible (p, c_sizeof (d), -5) /= 0) &\n     stop 4\n \n+  if (omp_target_is_accessible (p, c_sizeof (d), n + 1) /= 0) &\n+    stop 5\n+\n   ! Currently, a host pointer is accessible if the device supports shared\n   ! memory or omp_target_is_accessible is executed on the host. This\n   ! test case must be adapted when unified shared memory is avialable.\n@@ -35,14 +38,14 @@ program main\n     !$omp end target\n \n     if (omp_target_is_accessible (p, c_sizeof (d), d) /= shared_mem) &\n-      stop 5;\n+      stop 6;\n \n     if (omp_target_is_accessible (c_loc (a), 128 * sizeof (a(1)), d) /= shared_mem) &\n-      stop 6;\n+      stop 7;\n \n     do i = 1, 128\n       if (omp_target_is_accessible (c_loc (a(i)), sizeof (a(i)), d) /= shared_mem) &\n-        stop 7;\n+        stop 8;\n     end do\n \n   end do"}]}