{"sha": "fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI3ZmI3MDEwYTEwNTNlMGU4ZGUxZjBhZjM5ZDU0Njk5M2ZiNWY5Zg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-08-09T00:53:48Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-08-09T00:53:48Z"}, "message": "* gcc-interface/decl.c (rec_variant).  Declare.  Declare a VEC of it.\n\n\t(build_variant_list): Return a VEC instead of a tree.  Take a\n\tVEC instead of a tree.\n\t(create_variant_part_from): Take a VEC instead of a tree for\n\tvariant_list.  Adjust accordingly.\n\t(gnat_to_gnu_entity): Adjust for changes to previous functions.\n\nFrom-SVN: r163025", "tree": {"sha": "059505b958e2fbfb28f2e73a11b28c1d76684622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/059505b958e2fbfb28f2e73a11b28c1d76684622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f/comments", "author": null, "committer": null, "parents": [{"sha": "0ec11839957f925b7db59c4c03c667ac0e99570f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec11839957f925b7db59c4c03c667ac0e99570f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec11839957f925b7db59c4c03c667ac0e99570f"}], "stats": {"total": 121, "additions": 85, "deletions": 36}, "files": [{"sha": "de988ca2f0f8f03e97f1f8a492209d06fa70055c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "patch": "@@ -1,3 +1,12 @@\n+2010-08-08  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/decl.c (rec_variant).  Declare.  Declare a VEC of it.\n+\t(build_variant_list): Return a VEC instead of a tree.  Take a\n+\tVEC instead of a tree.\n+\t(create_variant_part_from): Take a VEC instead of a tree for\n+\tvariant_list.  Adjust accordingly.\n+\t(gnat_to_gnu_entity): Adjust for changes to previous functions.\n+\n 2010-08-07  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Use XALLOCAVEC instead"}, {"sha": "88d57167bf24dfb35ebeb3612d717df01c85fc94", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7fb7010a1053e0e8de1f0af39d546993fb5f9f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fb7fb7010a1053e0e8de1f0af39d546993fb5f9f", "patch": "@@ -112,6 +112,23 @@ typedef struct GTY(()) subst_pair_d {\n DEF_VEC_O(subst_pair);\n DEF_VEC_ALLOC_O(subst_pair,heap);\n \n+typedef struct GTY(()) variant_desc_d {\n+  /* The type of the variant.  */\n+  tree type;\n+\n+  /* The associated field.  */\n+  tree field;\n+\n+  /* The value of the qualifier.  */\n+  tree qual;\n+\n+  /* The record associated with this variant.  */\n+  tree record;\n+} variant_desc;\n+\n+DEF_VEC_O(variant_desc);\n+DEF_VEC_ALLOC_O(variant_desc,heap);\n+\n /* A hash table used to cache the result of annotate_value.  */\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n@@ -150,7 +167,9 @@ static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n static VEC(subst_pair,heap) *build_subst_list (Entity_Id, Entity_Id, bool);\n-static tree build_variant_list (tree, VEC(subst_pair,heap) *, tree);\n+static VEC(variant_desc,heap) *build_variant_list (tree,\n+\t\t\t\t\t\t   VEC(subst_pair,heap) *,\n+\t\t\t\t\t\t   VEC(variant_desc,heap) *);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, bool);\n@@ -161,8 +180,8 @@ static tree create_field_decl_from (tree, tree, tree, tree, tree,\n \t\t\t\t    VEC(subst_pair,heap) *);\n static tree get_rep_part (tree);\n static tree get_variant_part (tree);\n-static tree create_variant_part_from (tree, tree, tree, tree,\n-\t\t\t\t      VEC(subst_pair,heap) *);\n+static tree create_variant_part_from (tree, VEC(variant_desc,heap) *, tree,\n+\t\t\t\t      tree, VEC(subst_pair,heap) *);\n static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n static void rest_of_type_decl_compilation_no_defer (tree);\n \n@@ -3045,9 +3064,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      VEC(subst_pair,heap) *gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n \t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part, t;\n-\t      tree gnu_variant_list, gnu_pos_list, gnu_field_list = NULL_TREE;\n+\t      tree gnu_pos_list, gnu_field_list = NULL_TREE;\n \t      bool selected_variant = false;\n \t      Entity_Id gnat_field;\n+\t      VEC(variant_desc,heap) *gnu_variant_list;\n \n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n@@ -3075,36 +3095,41 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t union for the variants that are still relevant.  */\n \t      if (gnu_variant_part)\n \t\t{\n+\t\t  variant_desc *v;\n+\t\t  unsigned ix;\n+\n \t\t  gnu_variant_list\n \t\t    = build_variant_list (TREE_TYPE (gnu_variant_part),\n-\t\t\t\t\t  gnu_subst_list, NULL_TREE);\n+\t\t\t\t\t  gnu_subst_list, NULL);\n \n \t\t  /* If all the qualifiers are unconditionally true, the\n \t\t     innermost variant is statically selected.  */\n \t\t  selected_variant = true;\n-\t\t  for (t = gnu_variant_list; t; t = TREE_CHAIN (t))\n-\t\t    if (!integer_onep (TREE_VEC_ELT (TREE_VALUE (t), 1)))\n+\t\t  FOR_EACH_VEC_ELT_REVERSE (variant_desc, gnu_variant_list,\n+\t\t\t\t\t    ix, v)\n+\t\t    if (!integer_onep (v->qual))\n \t\t      {\n \t\t\tselected_variant = false;\n \t\t\tbreak;\n \t\t      }\n \n \t\t  /* Otherwise, create the new variants.  */\n \t\t  if (!selected_variant)\n-\t\t    for (t = gnu_variant_list; t; t = TREE_CHAIN (t))\n+\t\t    FOR_EACH_VEC_ELT_REVERSE (variant_desc, gnu_variant_list,\n+\t\t\t\t\t      ix, v)\n \t\t      {\n-\t\t\ttree old_variant = TREE_PURPOSE (t);\n+\t\t\ttree old_variant = v->type;\n \t\t\ttree new_variant = make_node (RECORD_TYPE);\n \t\t\tTYPE_NAME (new_variant)\n \t\t\t  = DECL_NAME (TYPE_NAME (old_variant));\n \t\t\tcopy_and_substitute_in_size (new_variant, old_variant,\n \t\t\t\t\t\t     gnu_subst_list);\n-\t\t\tTREE_VEC_ELT (TREE_VALUE (t), 2) = new_variant;\n+\t\t\tv->record = new_variant;\n \t\t      }\n \t\t}\n \t      else\n \t\t{\n-\t\t  gnu_variant_list = NULL_TREE;\n+\t\t  gnu_variant_list = NULL;\n \t\t  selected_variant = false;\n \t\t}\n \n@@ -3187,13 +3212,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      gnu_cont_type = gnu_type;\n \t\t    else\n \t\t      {\n-\t\t\tt = purpose_member (gnu_context, gnu_variant_list);\n+\t\t\tvariant_desc *v;\n+\t\t\tunsigned ix;\n+\n+\t\t\tt = NULL_TREE;\n+\t\t\tFOR_EACH_VEC_ELT_REVERSE (variant_desc,\n+\t\t\t\t\t\t  gnu_variant_list, ix, v)\n+\t\t\t  if (v->type == gnu_context)\n+\t\t\t    {\n+\t\t\t      t = v->type;\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\tif (t)\n \t\t\t  {\n \t\t\t    if (selected_variant)\n \t\t\t      gnu_cont_type = gnu_type;\n \t\t\t    else\n-\t\t\t      gnu_cont_type = TREE_VEC_ELT (TREE_VALUE (t), 2);\n+\t\t\t      gnu_cont_type = v->record;\n \t\t\t  }\n \t\t\telse\n \t\t\t  /* The front-end may pass us \"ghost\" components if\n@@ -3319,6 +3354,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnat_entity);\n \t\t}\n \n+\t      VEC_free (variant_desc, heap, gnu_variant_list);\n \t      VEC_free (subst_pair, heap, gnu_subst_list);\n \n \t      /* Now we can finalize it.  */\n@@ -7547,16 +7583,15 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n   return gnu_vec;\n }\n \n-/* Scan all fields in QUAL_UNION_TYPE and return a TREE_LIST describing the\n-   variants of QUAL_UNION_TYPE that are still relevant after applying the\n-   substitutions described in SUBST_LIST.  TREE_PURPOSE is the type of the\n-   variant and TREE_VALUE is a TREE_VEC containing the field, the new value\n-   of the qualifier and NULL_TREE respectively.  GNU_LIST is a pre-existing\n-   list to be chained to the newly created entries.  */\n+/* Scan all fields in QUAL_UNION_TYPE and return a VEC describing the\n+   variants of QUAL_UNION_TYPE that are still relevant after applying\n+   the substitutions described in SUBST_LIST.  VARIANT_LIST is a\n+   pre-existing VEC onto which newly created entries should be\n+   pushed.  */\n \n-static tree\n+static VEC(variant_desc,heap) *\n build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n-\t\t    tree gnu_list)\n+\t\t    VEC(variant_desc,heap) *variant_list)\n {\n   tree gnu_field;\n \n@@ -7575,18 +7610,20 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t still be accessed.  */\n       if (!integer_zerop (qual))\n \t{\n+\t  variant_desc *v;\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n-\t  tree v = make_tree_vec (3);\n-\t  TREE_VEC_ELT (v, 0) = gnu_field;\n-\t  TREE_VEC_ELT (v, 1) = qual;\n-\t  TREE_VEC_ELT (v, 2) = NULL_TREE;\n-\t  gnu_list = tree_cons (variant_type, v, gnu_list);\n+\n+\t  v = VEC_safe_push (variant_desc, heap, variant_list, NULL);\n+\t  v->type = variant_type;\n+\t  v->field = gnu_field;\n+\t  v->qual = qual;\n+\t  v->record = NULL_TREE;\n \n \t  /* Recurse on the variant subpart of the variant, if any.  */\n \t  variant_subpart = get_variant_part (variant_type);\n \t  if (variant_subpart)\n-\t    gnu_list = build_variant_list (TREE_TYPE (variant_subpart),\n-\t\t\t\t\t   subst_list, gnu_list);\n+\t    variant_list = build_variant_list (TREE_TYPE (variant_subpart),\n+\t\t\t\t\t       subst_list, variant_list);\n \n \t  /* If the new qualifier is unconditionally true, the subsequent\n \t     variants cannot be accessed.  */\n@@ -7595,7 +7632,7 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t}\n     }\n \n-  return gnu_list;\n+  return variant_list;\n }\n \f\n /* UINT_SIZE is a Uint giving the specified size for an object of GNU_TYPE\n@@ -8319,14 +8356,17 @@ get_variant_part (tree record_type)\n    layout.  */\n \n static tree\n-create_variant_part_from (tree old_variant_part, tree variant_list,\n+create_variant_part_from (tree old_variant_part,\n+\t\t\t  VEC(variant_desc,heap) *variant_list,\n \t\t\t  tree record_type, tree pos_list,\n \t\t\t  VEC(subst_pair,heap) *subst_list)\n {\n   tree offset = DECL_FIELD_OFFSET (old_variant_part);\n   tree old_union_type = TREE_TYPE (old_variant_part);\n-  tree new_union_type, new_variant_part, t;\n+  tree new_union_type, new_variant_part;\n   tree union_field_list = NULL_TREE;\n+  variant_desc *v;\n+  unsigned ix;\n \n   /* First create the type of the variant part from that of the old one.  */\n   new_union_type = make_node (QUAL_UNION_TYPE);\n@@ -8354,22 +8394,22 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n     copy_and_substitute_in_size (new_union_type, old_union_type, subst_list);\n \n   /* Now finish up the new variants and populate the union type.  */\n-  for (t = variant_list; t; t = TREE_CHAIN (t))\n+  FOR_EACH_VEC_ELT_REVERSE (variant_desc, variant_list, ix, v)\n     {\n-      tree old_field = TREE_VEC_ELT (TREE_VALUE (t), 0), new_field;\n+      tree old_field = v->field, new_field;\n       tree old_variant, old_variant_subpart, new_variant, field_list;\n \n       /* Skip variants that don't belong to this nesting level.  */\n       if (DECL_CONTEXT (old_field) != old_union_type)\n \tcontinue;\n \n       /* Retrieve the list of fields already added to the new variant.  */\n-      new_variant = TREE_VEC_ELT (TREE_VALUE (t), 2);\n+      new_variant = v->record;\n       field_list = TYPE_FIELDS (new_variant);\n \n       /* If the old variant had a variant subpart, we need to create a new\n \t variant subpart and add it to the field list.  */\n-      old_variant = TREE_PURPOSE (t);\n+      old_variant = v->type;\n       old_variant_subpart = get_variant_part (old_variant);\n       if (old_variant_subpart)\n \t{\n@@ -8391,7 +8431,7 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n \t= create_field_decl_from (old_field, new_variant, new_union_type,\n \t\t\t\t  TYPE_SIZE (new_variant),\n \t\t\t\t  pos_list, subst_list);\n-      DECL_QUALIFIER (new_field) = TREE_VEC_ELT (TREE_VALUE (t), 1);\n+      DECL_QUALIFIER (new_field) = v->qual;\n       DECL_INTERNAL_P (new_field) = 1;\n       DECL_CHAIN (new_field) = union_field_list;\n       union_field_list = new_field;"}]}