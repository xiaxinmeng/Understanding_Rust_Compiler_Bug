{"sha": "66f95f60458a1da2e82c4b879357ebe36fcdb879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZmOTVmNjA0NThhMWRhMmU4MmM0Yjg3OTM1N2ViZTM2ZmNkYjg3OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T11:56:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-06T11:56:31Z"}, "message": "[multiple changes]\n\n2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_ch7.adb: Update comment.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* einfo.adb, einfo.ads (Is_Subprogram_Or_Entry): New predicate.\n\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Use new function.\n\t* sem_util.adb, sem_util.ads (Within_Protected_Type): Renaming\n\twith slight modification from Is_Subp_Or_Entry_Inside_Protected,\n\tso that applies to any entity.\n\n2017-09-06  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch3.adb (Derived_Type_Declaration): Use\n\tIncomplete_Or_Partial_View rather than local Find_Partial_View.\n\n2017-09-06  Javier Miranda  <miranda@adacore.com>\n\n\t* g-catiio.ads, g-catiio.adb (Value): Extended to parse an UTC time\n\tfollowing ISO-8861.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension): In an instance, a type\n\tconversion takes its dimensions from the expression, not from\n\tthe context type.\n\t(Dimensions_Of_Operand): Ditto.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call_Helper): Do not optimize calls to\n\tnull procedures when GNAT coverage is used, so that their (empty)\n\tbodies are properly covered.\n\n2017-09-06  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch13.adb (Resolve_Aspect_Expressions): If\n\tthe entity is a type with discriminants, make the discriminants\n\tdirectly visible in aspect clauses.\n\n2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Arithmentic_Op): If both operands are\n\tUniversal_Real and the context is a floating-point type, resolve\n\tboth operands to the target type.\n\nFrom-SVN: r251783", "tree": {"sha": "c9da704bda48577d1975d5baf566552d6ac64a69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9da704bda48577d1975d5baf566552d6ac64a69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66f95f60458a1da2e82c4b879357ebe36fcdb879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f95f60458a1da2e82c4b879357ebe36fcdb879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66f95f60458a1da2e82c4b879357ebe36fcdb879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f95f60458a1da2e82c4b879357ebe36fcdb879/comments", "author": null, "committer": null, "parents": [{"sha": "7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec25b2bf17ebafa1ce9a7066e5e52b9eb7e68d2"}], "stats": {"total": 900, "additions": 694, "deletions": 206}, "files": [{"sha": "fd11670e146f5921408db5fa802f57c0ebbceb7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -1,3 +1,50 @@\n+2017-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch7.adb: Update comment.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* einfo.adb, einfo.ads (Is_Subprogram_Or_Entry): New predicate.\n+\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Use new function.\n+\t* sem_util.adb, sem_util.ads (Within_Protected_Type): Renaming\n+\twith slight modification from Is_Subp_Or_Entry_Inside_Protected,\n+\tso that applies to any entity.\n+\n+2017-09-06  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch3.adb (Derived_Type_Declaration): Use\n+\tIncomplete_Or_Partial_View rather than local Find_Partial_View.\n+\n+2017-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* g-catiio.ads, g-catiio.adb (Value): Extended to parse an UTC time\n+\tfollowing ISO-8861.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension): In an instance, a type\n+\tconversion takes its dimensions from the expression, not from\n+\tthe context type.\n+\t(Dimensions_Of_Operand): Ditto.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call_Helper): Do not optimize calls to\n+\tnull procedures when GNAT coverage is used, so that their (empty)\n+\tbodies are properly covered.\n+\n+2017-09-06  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch13.adb (Resolve_Aspect_Expressions): If\n+\tthe entity is a type with discriminants, make the discriminants\n+\tdirectly visible in aspect clauses.\n+\n+2017-09-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Arithmentic_Op): If both operands are\n+\tUniversal_Real and the context is a floating-point type, resolve\n+\tboth operands to the target type.\n+\n 2017-09-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* a-comlin.adb, exp_aggr.adb, exp_ch6.adb, frontend.adb, gnatbind.adb,"}, {"sha": "6d9ae1da7feda03c912cf40998fed6a4bbae6e25", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -3764,6 +3764,13 @@ package body Einfo is\n       return Ekind (Id) in Subprogram_Kind;\n    end Is_Subprogram;\n \n+   function Is_Subprogram_Or_Entry              (Id : E) return B is\n+   begin\n+      return Ekind (Id) in Subprogram_Kind\n+               or else\n+             Ekind (Id) in Entry_Kind;\n+   end Is_Subprogram_Or_Entry;\n+\n    function Is_Subprogram_Or_Generic_Subprogram (Id : E) return B is\n    begin\n       return Ekind (Id) in Subprogram_Kind"}, {"sha": "cf472ee53e9528a4d4bd852cad8a959dc5d1e209", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -7445,6 +7445,7 @@ package Einfo is\n    function Is_Scalar_Type                      (Id : E) return B;\n    function Is_Signed_Integer_Type              (Id : E) return B;\n    function Is_Subprogram                       (Id : E) return B;\n+   function Is_Subprogram_Or_Entry              (Id : E) return B;\n    function Is_Subprogram_Or_Generic_Subprogram (Id : E) return B;\n    function Is_Task_Type                        (Id : E) return B;\n    function Is_Type                             (Id : E) return B;"}, {"sha": "58ced4760ef9718014e754bcc09ad4e906d9bce3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -3955,8 +3955,11 @@ package body Exp_Ch6 is\n          --  A call to a null procedure is replaced by a null statement, but we\n          --  are not allowed to ignore possible side effects of the call, so we\n          --  make sure that actuals are evaluated.\n+         --  We also suppress this optimization for GNATCoverage.\n \n-         elsif Is_Null_Procedure (Subp) then\n+         elsif Is_Null_Procedure (Subp)\n+           and then not Opt.Suppress_Control_Flow_Optimizations\n+         then\n             Actual := First_Actual (Call_Node);\n             while Present (Actual) loop\n                Remove_Side_Effects (Actual);"}, {"sha": "17ce098ab9eea9ead3d0eb1c16aff1af891bd1e3", "filename": "gcc/ada/g-catiio.adb", "status": "modified", "additions": 417, "deletions": 2, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fg-catiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fg-catiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2016, AdaCore                     --\n+--                     Copyright (C) 1999-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -93,6 +93,26 @@ package body GNAT.Calendar.Time_IO is\n       Length  : Natural := 0) return String;\n    --  As above with N provided in Integer format\n \n+   procedure Parse_ISO_8861_UTC\n+      (Date    : String;\n+       Time    : out Ada.Calendar.Time;\n+       Success : out Boolean);\n+   --  Subsidiary of function Value. It parses the string Date, interpreted as\n+   --  an ISO 8861 time representation, and returns corresponding Time value.\n+   --  Success is set to False when the string is not a supported ISO 8861\n+   --  date. The following regular expression defines the supported format:\n+   --\n+   --    (yyyymmdd | yyyy'-'mm'-'dd)'T'(hhmmss | hh':'mm':'ss)\n+   --      [ ('Z' | ('.' | ',') s{s} | ('+'|'-')hh':'mm) ]\n+   --\n+   --  Trailing characters (in particular spaces) are not allowed.\n+   --\n+   --  Examples:\n+   --\n+   --    2017-04-14T14:47:06    20170414T14:47:06    20170414T144706\n+   --    2017-04-14T14:47:06,12 20170414T14:47:06.12\n+   --    2017-04-14T19:47:06+05 20170414T09:00:06-05:47\n+\n    -----------\n    -- Am_Pm --\n    -----------\n@@ -531,7 +551,7 @@ package body GNAT.Calendar.Time_IO is\n           \"JUL\", \"AUG\", \"SEP\", \"OCT\", \"NOV\", \"DEC\");\n       --  Short version of the month names, used when parsing date strings\n \n-      S                                                     : String := Str;\n+      S : String := Str;\n \n    begin\n       GNAT.Case_Util.To_Upper (S);\n@@ -545,6 +565,390 @@ package body GNAT.Calendar.Time_IO is\n       return Abbrev_Upper_Month_Names'First;\n    end Month_Name_To_Number;\n \n+   ------------------------\n+   -- Parse_ISO_8861_UTC --\n+   ------------------------\n+\n+   procedure Parse_ISO_8861_UTC\n+      (Date    : String;\n+       Time    : out Ada.Calendar.Time;\n+       Success : out Boolean)\n+   is\n+      Index                 : Positive := Date'First;\n+      --  The current character scan index. After a call to Advance, Index\n+      --  points to the next character.\n+\n+      End_Of_Source_Reached : exception;\n+      --  An exception used to signal that the scan pointer has reached the\n+      --  end of the source string.\n+\n+      Wrong_Syntax          : exception;\n+      --  An exception used to signal that the scan pointer has reached an\n+      --  unexpected character in the source string.\n+\n+      procedure Advance;\n+      pragma Inline (Advance);\n+      --  Past the current character of Date\n+\n+      procedure Advance_Digits (Num_Digits : Positive);\n+      pragma Inline (Advance_Digits);\n+      --  Past the given number of digit characters\n+\n+      function Scan_Day return Day_Number;\n+      pragma Inline (Scan_Day);\n+      --  Scan the two digits of a day number and return its value\n+\n+      function Scan_Hour return Hour_Number;\n+      pragma Inline (Scan_Hour);\n+      --  Scan the two digits of an hour number and return its value\n+\n+      function Scan_Minute return Minute_Number;\n+      pragma Inline (Scan_Minute);\n+      --  Scan the two digits of a minute number and return its value\n+\n+      function Scan_Month return Month_Number;\n+      pragma Inline (Scan_Month);\n+      --  Scan the two digits of a month number and return its value\n+\n+      function Scan_Second return Second_Number;\n+      pragma Inline (Scan_Second);\n+      --  Scan the two digits of a second number and return its value\n+\n+      function Scan_Separator (Expected_Symbol : Character) return Boolean;\n+      pragma Inline (Scan_Separator);\n+      --  If the current symbol matches the Expected_Symbol then advance the\n+      --  scanner index and return True; otherwise do nothing and return False\n+\n+      procedure Scan_Separator (Required : Boolean; Separator : Character);\n+      pragma Inline (Scan_Separator);\n+      --  If Required then check that the current character matches Separator\n+      --  and advance the scanner index; if not Required then do nothing.\n+\n+      function Scan_Subsecond return Second_Duration;\n+      pragma Inline (Scan_Subsecond);\n+      --  Scan all the digits of a subsecond number and return its value\n+\n+      function Scan_Year return Year_Number;\n+      pragma Inline (Scan_Year);\n+      --  Scan the four digits of a year number and return its value\n+\n+      function Symbol return Character;\n+      pragma Inline (Symbol);\n+      --  Return the current character being scanned\n+\n+      -------------\n+      -- Advance --\n+      -------------\n+\n+      procedure Advance is\n+      begin\n+         --  Signal the end of the source string. This stops a complex scan by\n+         --  bottoming up any recursive calls till control reaches routine Scan\n+         --  which handles the exception. Certain scanning scenarios may handle\n+         --  this exception on their own.\n+\n+         if Index > Date'Last then\n+            raise End_Of_Source_Reached;\n+\n+         --  Advance the scan pointer as long as there are characters to scan,\n+         --  in other words, the scan pointer has not passed the end of the\n+         --  source string.\n+\n+         else\n+            Index := Index + 1;\n+         end if;\n+      end Advance;\n+\n+      --------------------\n+      -- Advance_Digits --\n+      --------------------\n+\n+      procedure Advance_Digits (Num_Digits : Positive) is\n+      begin\n+         for J in 1 .. Num_Digits loop\n+            if Symbol not in '0' .. '9' then\n+               raise Wrong_Syntax;\n+            end if;\n+\n+            Advance; --  past digit\n+         end loop;\n+      end Advance_Digits;\n+\n+      --------------\n+      -- Scan_Day --\n+      --------------\n+\n+      function Scan_Day return Day_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 2);\n+         return Day_Number'Value (Date (From .. Index - 1));\n+      end Scan_Day;\n+\n+      ---------------\n+      -- Scan_Hour --\n+      ---------------\n+\n+      function Scan_Hour return Hour_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 2);\n+         return Hour_Number'Value (Date (From .. Index - 1));\n+      end Scan_Hour;\n+\n+      -----------------\n+      -- Scan_Minute --\n+      -----------------\n+\n+      function Scan_Minute return Minute_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 2);\n+         return Minute_Number'Value (Date (From .. Index - 1));\n+      end Scan_Minute;\n+\n+      ----------------\n+      -- Scan_Month --\n+      ----------------\n+\n+      function Scan_Month return Month_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 2);\n+         return Month_Number'Value (Date (From .. Index - 1));\n+      end Scan_Month;\n+\n+      -----------------\n+      -- Scan_Second --\n+      -----------------\n+\n+      function Scan_Second return Second_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 2);\n+         return Second_Number'Value (Date (From .. Index - 1));\n+      end Scan_Second;\n+\n+      --------------------\n+      -- Scan_Separator --\n+      --------------------\n+\n+      function Scan_Separator (Expected_Symbol : Character) return Boolean is\n+      begin\n+         if Symbol = Expected_Symbol then\n+            Advance;\n+            return True;\n+         else\n+            return False;\n+         end if;\n+      end Scan_Separator;\n+\n+      --------------------\n+      -- Scan_Separator --\n+      --------------------\n+\n+      procedure Scan_Separator (Required : Boolean; Separator : Character) is\n+      begin\n+         if Required then\n+            if Symbol /= Separator then\n+               raise Wrong_Syntax;\n+            end if;\n+\n+            Advance; --  Past the separator\n+         end if;\n+      end Scan_Separator;\n+\n+      --------------------\n+      -- Scan_Subsecond --\n+      --------------------\n+\n+      function Scan_Subsecond return Second_Duration is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 1);\n+\n+         while Symbol in '0' .. '9'\n+           and then Index < Date'Length\n+         loop\n+            Advance;\n+         end loop;\n+\n+         if Symbol not in '0' .. '9' then\n+            raise Wrong_Syntax;\n+         end if;\n+\n+         Advance;\n+         return Second_Duration'Value (\"0.\" & Date (From .. Index - 1));\n+      end Scan_Subsecond;\n+\n+      ---------------\n+      -- Scan_Year --\n+      ---------------\n+\n+      function Scan_Year return Year_Number is\n+         From : constant Positive := Index;\n+      begin\n+         Advance_Digits (Num_Digits => 4);\n+         return Year_Number'Value (Date (From .. Index - 1));\n+      end Scan_Year;\n+\n+      ------------\n+      -- Symbol --\n+      ------------\n+\n+      function Symbol return Character is\n+      begin\n+         --  Signal the end of the source string. This stops a complex scan by\n+         --  bottoming up any recursive calls till control reaches routine Scan\n+         --  which handles the exception. Certain scanning scenarios may handle\n+         --  this exception on their own.\n+\n+         if Index > Date'Last then\n+            raise End_Of_Source_Reached;\n+\n+         else\n+            return Date (Index);\n+         end if;\n+      end Symbol;\n+\n+      --  Local variables\n+\n+      Date_Separator : constant Character := '-';\n+      Hour_Separator : constant Character := ':';\n+      Day            : Day_Number;\n+      Month          : Month_Number;\n+      Year           : Year_Number;\n+      Hour           : Hour_Number     := 0;\n+      Minute         : Minute_Number   := 0;\n+      Second         : Second_Number   := 0;\n+      Subsec         : Second_Duration := 0.0;\n+\n+      Local_Hour     : Hour_Number     := 0;\n+      Local_Minute   : Minute_Number   := 0;\n+      Local_Sign     : Character       := ' ';\n+      Local_Disp     : Duration;\n+\n+      Sep_Required   : Boolean := False;\n+      --  True if a separator is seen (and therefore required after it!)\n+\n+   begin\n+      --  Parse date\n+\n+      Year := Scan_Year;\n+      Sep_Required := Scan_Separator (Date_Separator);\n+\n+      Month := Scan_Month;\n+      Scan_Separator (Sep_Required, Date_Separator);\n+\n+      Day := Scan_Day;\n+\n+      if Index < Date'Last and then Symbol = 'T' then\n+         Advance;\n+\n+         --  Parse time\n+\n+         Hour := Scan_Hour;\n+         Sep_Required := Scan_Separator (Hour_Separator);\n+\n+         Minute := Scan_Minute;\n+         Scan_Separator (Sep_Required, Hour_Separator);\n+\n+         Second := Scan_Second;\n+\n+         --  [('Z' | ('.' | ',') s{s} | ('+'|'-')hh:mm)]\n+\n+         if Index <= Date'Last then\n+\n+            --  Suffix 'Z' just confirms that this is an UTC time. No further\n+            --  action needed.\n+\n+            if Symbol = 'Z' then\n+               Advance;\n+\n+            --  A decimal fraction shall have at least one digit, and has as\n+            --  many digits as supported by the underlying implementation.\n+            --  The valid decimal separators are those specified in ISO 31-0,\n+            --  i.e. the comma [,] or full stop [.]. Of these, the comma is\n+            --  the preferred separator of ISO-8861.\n+\n+            elsif Symbol = ',' or else Symbol = '.' then\n+               Advance; --  past decimal separator\n+               Subsec := Scan_Subsecond;\n+\n+            --  Difference between local time and UTC: It shall be expressed\n+            --  as positive (i.e. with the leading plus sign [+]) if the local\n+            --  time is ahead of or equal to UTC of day and as negative (i.e.\n+            --  with the leading minus sign [-]) if it is behind UTC of day.\n+            --  The minutes time element of the difference may only be omitted\n+            --  if the difference between the time scales is exactly an\n+            --  integral number of hours.\n+\n+            elsif Symbol = '+' or else Symbol = '-' then\n+               Local_Sign := Symbol;\n+               Advance;\n+               Local_Hour := Scan_Hour;\n+\n+               --  Past ':'\n+\n+               if Index < Date'Last and then Symbol = Hour_Separator then\n+                  Advance;\n+                  Local_Minute := Scan_Minute;\n+               end if;\n+\n+               --  Compute local displacement\n+\n+               Local_Disp := Local_Hour * 3600.0 + Local_Minute * 60.0;\n+            else\n+               raise Wrong_Syntax;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Sanity checks. The check on Index ensures that there are no trailing\n+      --  characters.\n+\n+      if Index /= Date'Length + 1\n+        or else not Year'Valid\n+        or else not Month'Valid\n+        or else not Day'Valid\n+        or else not Hour'Valid\n+        or else not Minute'Valid\n+        or else not Second'Valid\n+        or else not Subsec'Valid\n+        or else not Local_Hour'Valid\n+        or else not Local_Minute'Valid\n+      then\n+         raise Wrong_Syntax;\n+      end if;\n+\n+      --  Compute time without local displacement\n+\n+      if Local_Sign = ' ' then\n+         Time := Time_Of (Year, Month, Day, Hour, Minute, Second, Subsec);\n+\n+      --  Compute time with positive local displacement\n+\n+      elsif Local_Sign = '+' then\n+         Time := Time_Of (Year, Month, Day, Hour, Minute, Second, Subsec)\n+                   - Local_Disp;\n+\n+      --  Compute time with negative local displacement\n+\n+      elsif Local_Sign = '-' then\n+         Time := Time_Of (Year, Month, Day, Hour, Minute, Second, Subsec)\n+                   + Local_Disp;\n+      end if;\n+\n+      --  Notify that the input string was successfully parsed\n+\n+      Success := True;\n+\n+   exception\n+      when End_Of_Source_Reached |\n+           Wrong_Syntax          =>\n+         Success := False;\n+   end Parse_ISO_8861_UTC;\n+\n    -----------\n    -- Value --\n    -----------\n@@ -757,11 +1161,22 @@ package body GNAT.Calendar.Time_IO is\n \n       --  Local Declarations\n \n+      Success    : Boolean;\n       Time_Start : Natural := 1;\n+      Time       : Ada.Calendar.Time;\n \n    --  Start of processing for Value\n \n    begin\n+      --  Let's try parsing Date as a supported ISO-8861 format. If we do not\n+      --  succeed, then retry using all the other GNAT supported formats.\n+\n+      Parse_ISO_8861_UTC (Date, Time, Success);\n+\n+      if Success then\n+         return Time;\n+      end if;\n+\n       --  Length checks\n \n       if D_Length /= 8"}, {"sha": "8b93518f5295d1ea5613640fb47c7193de19da88", "filename": "gcc/ada/g-catiio.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fg-catiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fg-catiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.ads?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2013, AdaCore                     --\n+--                     Copyright (C) 1999-2017, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -141,6 +141,18 @@ package GNAT.Calendar.Time_IO is\n    --     mmm dd, yyyy         - month spelled out\n    --     dd mmm yyyy          - month spelled out\n    --\n+   --  The following ISO-8861 format expressed as a regular expression is also\n+   --  supported:\n+   --\n+   --    (yyyymmdd | yyyy'-'mm'-'dd)'T'(hhmmss | hh':'mm':'ss)\n+   --      [ ('Z' | ('.' | ',') s{s} | ('+'|'-')hh':'mm) ]\n+   --\n+   --  Examples:\n+   --\n+   --    2017-04-14T14:47:06      20170414T14:47:06       20170414T144706\n+   --    2017-04-14T14:47:06,1234 20170414T14:47:06.1234\n+   --    2017-04-14T19:47:06+05   20170414T09:00:06-05:47\n+\n    --  Constraint_Error is raised if the input string is malformed (does not\n    --  conform to one of the above dates, or has an invalid time string), or\n    --  the resulting time is not valid."}, {"sha": "15efcef5519cd28cc3bbd7dad6e5a71d04f0da5a", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 71, "deletions": 68, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -1053,7 +1053,7 @@ package body Inline is\n       --  generic, so that the proper global references are preserved.\n \n       --  Note that we do not do this at the library level, because it is not\n-      --  needed, and furthermore this causes trouble if front end inlining\n+      --  needed, and furthermore this causes trouble if front-end inlining\n       --  is activated (-gnatN).\n \n       if In_Instance and then Scope (Current_Scope) /= Standard_Standard then\n@@ -1417,7 +1417,7 @@ package body Inline is\n       --  which typically are not helper subprograms, which also avoids getting\n       --  spurious messages on calls that cannot be inlined.\n \n-      elsif Is_Subp_Or_Entry_Inside_Protected (Id) then\n+      elsif Within_Protected_Type (Id) then\n          return False;\n \n       --  Do not inline predicate functions (treated specially by GNATprove)\n@@ -1481,7 +1481,7 @@ package body Inline is\n \n       pragma Assert (Msg (Msg'Last) = '?');\n \n-      --  Legacy front end inlining model\n+      --  Legacy front-end inlining model\n \n       if not Back_End_Inlining then\n \n@@ -1514,7 +1514,7 @@ package body Inline is\n             Error_Msg_NE (Msg & \"p?\", N, Subp);\n          end if;\n \n-      --  New semantics relying on back end inlining\n+      --  New semantics relying on back-end inlining\n \n       elsif Is_Serious then\n \n@@ -1592,15 +1592,6 @@ package body Inline is\n       --  body N has no local declarations and its unique statement is a single\n       --  extended return statement with a handled statements sequence.\n \n-      procedure Generate_Subprogram_Body\n-        (N              : Node_Id;\n-         Body_To_Inline : out Node_Id);\n-      --  Generate a parameterless duplicate of subprogram body N. Occurrences\n-      --  of pragmas referencing the formals are removed since they have no\n-      --  meaning when the body is inlined and the formals are rewritten (the\n-      --  analysis of the non-inlined body will handle these pragmas properly).\n-      --  A new internal name is associated with Body_To_Inline.\n-\n       procedure Split_Unconstrained_Function\n         (N       : Node_Id;\n          Spec_Id : Entity_Id);\n@@ -1616,6 +1607,63 @@ package body Inline is\n       --------------------------\n \n       procedure Build_Body_To_Inline (N : Node_Id; Spec_Id : Entity_Id) is\n+\n+         procedure Generate_Subprogram_Body\n+           (N              : Node_Id;\n+            Body_To_Inline : out Node_Id);\n+         --  Generate a parameterless duplicate of subprogram body N. Note that\n+         --  occurrences of pragmas referencing the formals are removed since\n+         --  they have no meaning when the body is inlined and the formals are\n+         --  rewritten (the analysis of the non-inlined body will handle these\n+         --  pragmas).  A new internal name is associated with Body_To_Inline.\n+\n+         -----------------------------\n+         -- Generate_Body_To_Inline --\n+         -----------------------------\n+\n+         procedure Generate_Subprogram_Body\n+           (N              : Node_Id;\n+            Body_To_Inline : out Node_Id)\n+         is\n+         begin\n+            --  Within an instance, the body to inline must be treated as a\n+            --  nested generic so that proper global references are preserved.\n+\n+            --  Note that we do not do this at the library level, because it\n+            --  is not needed, and furthermore this causes trouble if front\n+            --  end inlining is activated (-gnatN).\n+\n+            if In_Instance\n+              and then Scope (Current_Scope) /= Standard_Standard\n+            then\n+               Body_To_Inline := Copy_Generic_Node (N, Empty, True);\n+            else\n+               Body_To_Inline := Copy_Separate_Tree (N);\n+            end if;\n+\n+            --  Remove aspects/pragmas that have no meaning in an inlined body\n+\n+            Remove_Aspects_And_Pragmas (Body_To_Inline);\n+\n+            --  We need to capture references to the formals in order\n+            --  to substitute the actuals at the point of inlining, i.e.\n+            --  instantiation. To treat the formals as globals to the body to\n+            --  inline, we nest it within a dummy parameterless subprogram,\n+            --  declared within the real one.\n+\n+            Set_Parameter_Specifications\n+              (Specification (Body_To_Inline), No_List);\n+\n+            --  A new internal name is associated with Body_To_Inline to avoid\n+            --  conflicts when the non-inlined body N is analyzed.\n+\n+            Set_Defining_Unit_Name (Specification (Body_To_Inline),\n+               Make_Defining_Identifier (Sloc (N), New_Internal_Name ('P')));\n+            Set_Corresponding_Spec (Body_To_Inline, Empty);\n+         end Generate_Subprogram_Body;\n+\n+         --  Local variables\n+\n          Decl            : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n          Original_Body   : Node_Id;\n          Body_To_Analyze : Node_Id;\n@@ -1626,7 +1674,7 @@ package body Inline is\n          --  Within an instance, the body to inline must be treated as a nested\n          --  generic, so that the proper global references are preserved. We\n          --  do not do this at the library level, because it is not needed, and\n-         --  furthermore this causes trouble if front end inlining is activated\n+         --  furthermore this causes trouble if front-end inlining is activated\n          --  (-gnatN).\n \n          if In_Instance\n@@ -1716,51 +1764,6 @@ package body Inline is\n            and then Present (Handled_Statement_Sequence (Ret_Node));\n       end Can_Split_Unconstrained_Function;\n \n-      -----------------------------\n-      -- Generate_Body_To_Inline --\n-      -----------------------------\n-\n-      procedure Generate_Subprogram_Body\n-        (N              : Node_Id;\n-         Body_To_Inline : out Node_Id)\n-      is\n-      begin\n-         --  Within an instance, the body to inline must be treated as a nested\n-         --  generic, so that the proper global references are preserved.\n-\n-         --  Note that we do not do this at the library level, because it\n-         --  is not needed, and furthermore this causes trouble if front\n-         --  end inlining is activated (-gnatN).\n-\n-         if In_Instance\n-           and then Scope (Current_Scope) /= Standard_Standard\n-         then\n-            Body_To_Inline := Copy_Generic_Node (N, Empty, True);\n-         else\n-            Body_To_Inline := Copy_Separate_Tree (N);\n-         end if;\n-\n-         --  Remove all aspects/pragmas that have no meaning in an inlined body\n-\n-         Remove_Aspects_And_Pragmas (Body_To_Inline);\n-\n-         --  We need to capture references to the formals in order\n-         --  to substitute the actuals at the point of inlining, i.e.\n-         --  instantiation. To treat the formals as globals to the body to\n-         --  inline, we nest it within a dummy parameterless subprogram,\n-         --  declared within the real one.\n-\n-         Set_Parameter_Specifications\n-           (Specification (Body_To_Inline), No_List);\n-\n-         --  A new internal name is associated with Body_To_Inline to avoid\n-         --  conflicts when the non-inlined body N is analyzed.\n-\n-         Set_Defining_Unit_Name (Specification (Body_To_Inline),\n-            Make_Defining_Identifier (Sloc (N), New_Internal_Name ('P')));\n-         Set_Corresponding_Spec (Body_To_Inline, Empty);\n-      end Generate_Subprogram_Body;\n-\n       ----------------------------------\n       -- Split_Unconstrained_Function --\n       ----------------------------------\n@@ -1945,14 +1948,14 @@ package body Inline is\n                 Parameter_Associations => Actual_List);\n          end;\n \n-         --  Generate\n+         --  Generate:\n \n          --    declare\n          --       New_Obj : ...\n          --    begin\n-         --       main_1__F1b (New_Obj, ...);\n-         --       return Obj;\n-         --    end B10b;\n+         --       Proc (New_Obj, ...);\n+         --       return New_Obj;\n+         --    end;\n \n          Blk_Stmt :=\n            Make_Block_Statement (Loc,\n@@ -2922,8 +2925,8 @@ package body Inline is\n             --  The semantic analyzer checked that frontend-inlined functions\n             --  returning unconstrained types have no declarations and have\n             --  a single extended return statement. As part of its processing\n-            --  the function was split in two subprograms: a procedure P and\n-            --  a function F that has a block with a call to procedure P (see\n+            --  the function was split in two subprograms: a procedure P' and\n+            --  a function F' that has a block with a call to procedure P' (see\n             --  Split_Unconstrained_Function).\n \n             else\n@@ -3269,15 +3272,15 @@ package body Inline is\n          --  avoid generating undesired extra calls and goto statements.\n \n          --     Given:\n-         --                 function Func (...) return ...\n+         --                 function Func (...) return String is\n          --                 begin\n          --                    declare\n          --                       Result : String (1 .. 4);\n          --                    begin\n          --                       Proc (Result, ...);\n          --                       return Result;\n          --                    end;\n-         --                 end F;\n+         --                 end Func;\n \n          --                 Result : String := Func (...);\n \n@@ -3526,7 +3529,7 @@ package body Inline is\n             return True;\n          end if;\n \n-         --  Then declarations excluded only for front end inlining\n+         --  Then declarations excluded only for front-end inlining\n \n          if Back_End_Inlining then\n             null;"}, {"sha": "441dad584cc43544db4bac31f27e0265617c53cb", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -12649,9 +12649,6 @@ package body Sem_Ch13 is\n    --------------------------------\n \n    procedure Resolve_Aspect_Expressions (E : Entity_Id) is\n-      ASN  : Node_Id;\n-      A_Id : Aspect_Id;\n-      Expr : Node_Id;\n \n       function Resolve_Name (N : Node_Id) return Traverse_Result;\n       --  Verify that all identifiers in the expression, with the exception\n@@ -12696,84 +12693,92 @@ package body Sem_Ch13 is\n \n       procedure Resolve_Aspect_Expression is new Traverse_Proc (Resolve_Name);\n \n+      ASN : Node_Id := First_Rep_Item (E);\n+\n    --  Start of processing for Resolve_Aspect_Expressions\n \n    begin\n-      ASN := First_Rep_Item (E);\n-      while Present (ASN) loop\n-         if Nkind (ASN) = N_Aspect_Specification and then Entity (ASN) = E then\n-            A_Id := Get_Aspect_Id (ASN);\n-            Expr := Expression (ASN);\n+      --  Need to make sure discriminants, if any, are directly visible\n \n-            case A_Id is\n+      Push_Scope_And_Install_Discriminants (E);\n \n-               --  For now we only deal with aspects that do not generate\n-               --  subprograms, or that may mention current instances of\n-               --  types. These will require special handling (???TBD).\n+      while Present (ASN) loop\n+         if Nkind (ASN) = N_Aspect_Specification and then Entity (ASN) = E then\n+            declare\n+               A_Id : constant Aspect_Id := Get_Aspect_Id (ASN);\n+               Expr : constant Node_Id   := Expression (ASN);\n+            begin\n+               case A_Id is\n+                  --  For now we only deal with aspects that do not generate\n+                  --  subprograms, or that may mention current instances of\n+                  --  types. These will require special handling (???TBD).\n \n-               when Aspect_Invariant\n-                  | Aspect_Predicate\n-                  | Aspect_Predicate_Failure\n-               =>\n-                  null;\n+                  when Aspect_Invariant\n+                     | Aspect_Predicate\n+                     | Aspect_Predicate_Failure\n+                  =>\n+                     null;\n \n-               when Aspect_Dynamic_Predicate\n-                  | Aspect_Static_Predicate\n-               =>\n-                  --  Build predicate function specification and preanalyze\n-                  --  expression after type replacement.\n+                  when Aspect_Dynamic_Predicate\n+                     | Aspect_Static_Predicate\n+                  =>\n+                     --  Build predicate function specification and preanalyze\n+                     --  expression after type replacement.\n \n-                  if No (Predicate_Function (E)) then\n-                     declare\n-                        FDecl : constant Node_Id :=\n-                                  Build_Predicate_Function_Declaration (E);\n-                        pragma Unreferenced (FDecl);\n-                     begin\n-                        Resolve_Aspect_Expression (Expr);\n-                     end;\n-                  end if;\n+                     if No (Predicate_Function (E)) then\n+                        declare\n+                           FDecl : constant Node_Id :=\n+                                     Build_Predicate_Function_Declaration (E);\n+                           pragma Unreferenced (FDecl);\n+                        begin\n+                           Resolve_Aspect_Expression (Expr);\n+                        end;\n+                     end if;\n \n-               when Pre_Post_Aspects =>\n-                  null;\n+                  when Pre_Post_Aspects =>\n+                     null;\n \n-               when Aspect_Iterable =>\n-                  if Nkind (Expr) = N_Aggregate then\n-                     declare\n-                        Assoc : Node_Id;\n+                  when Aspect_Iterable =>\n+                     if Nkind (Expr) = N_Aggregate then\n+                        declare\n+                           Assoc : Node_Id;\n \n-                     begin\n-                        Assoc := First (Component_Associations (Expr));\n-                        while Present (Assoc) loop\n-                           Find_Direct_Name (Expression (Assoc));\n-                           Next (Assoc);\n-                        end loop;\n-                     end;\n-                  end if;\n+                        begin\n+                           Assoc := First (Component_Associations (Expr));\n+                           while Present (Assoc) loop\n+                              Find_Direct_Name (Expression (Assoc));\n+                              Next (Assoc);\n+                           end loop;\n+                        end;\n+                     end if;\n \n-               when others =>\n-                  if Present (Expr) then\n-                     case Aspect_Argument (A_Id) is\n-                        when Expression\n-                           | Optional_Expression\n-                        =>\n-                           Analyze_And_Resolve (Expression (ASN));\n-\n-                        when Name\n-                           | Optional_Name\n-                        =>\n-                           if Nkind (Expr) = N_Identifier then\n-                              Find_Direct_Name (Expr);\n-\n-                           elsif Nkind (Expr) = N_Selected_Component then\n-                              Find_Selected_Component (Expr);\n-                           end if;\n-                     end case;\n-                  end if;\n-            end case;\n+                  when others =>\n+                     if Present (Expr) then\n+                        case Aspect_Argument (A_Id) is\n+                           when Expression\n+                              | Optional_Expression\n+                           =>\n+                              Analyze_And_Resolve (Expr);\n+\n+                           when Name\n+                              | Optional_Name\n+                           =>\n+                              if Nkind (Expr) = N_Identifier then\n+                                 Find_Direct_Name (Expr);\n+\n+                              elsif Nkind (Expr) = N_Selected_Component then\n+                                 Find_Selected_Component (Expr);\n+                              end if;\n+                        end case;\n+                     end if;\n+               end case;\n+            end;\n          end if;\n \n          ASN := Next_Rep_Item (ASN);\n       end loop;\n+\n+      Uninstall_Discriminants_And_Pop_Scope (E);\n    end Resolve_Aspect_Expressions;\n \n    -------------------------"}, {"sha": "90abf1a8ede18705ad893a09e1f5629d3f2be330", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -16241,9 +16241,6 @@ package body Sem_Ch3 is\n       --  Check whether the parent type is a generic formal, or derives\n       --  directly or indirectly from one.\n \n-      function Find_Partial_View (T : Entity_Id) return Entity_Id;\n-      --  Return the partial view for a type entity T, when there is one\n-\n       ------------------------\n       -- Comes_From_Generic --\n       ------------------------\n@@ -16270,28 +16267,6 @@ package body Sem_Ch3 is\n          end if;\n       end Comes_From_Generic;\n \n-      -----------------------\n-      -- Find_Partial_View --\n-      -----------------------\n-\n-      function Find_Partial_View (T : Entity_Id) return Entity_Id is\n-         Partial_View : Entity_Id;\n-\n-      begin\n-         --  Look for the associated private type declaration\n-\n-         Partial_View := First_Entity (Scope (T));\n-         loop\n-            exit when No (Partial_View)\n-              or else (Has_Private_Declaration (Partial_View)\n-                        and then Full_View (Partial_View) = T);\n-\n-            Next_Entity (Partial_View);\n-         end loop;\n-\n-         return Partial_View;\n-      end Find_Partial_View;\n-\n       --  Local variables\n \n       Def          : constant Node_Id := Type_Definition (N);\n@@ -16311,14 +16286,15 @@ package body Sem_Ch3 is\n       then\n          declare\n             Partial_View : constant Entity_Id :=\n-                             Find_Partial_View (Parent_Type);\n+                             Incomplete_Or_Partial_View (Parent_Type);\n \n          begin\n-            --  If the partial view was not found then the parent type is not a\n-            --  private type. Otherwise check that the partial view is declared\n-            --  as tagged.\n+            --  If the partial view was not found then the parent type is not\n+            --  a private type. Otherwise check if the partial view is a tagged\n+            --  private type.\n \n             if Present (Partial_View)\n+              and then Is_Private_Type (Partial_View)\n               and then not Is_Tagged_Type (Partial_View)\n             then\n                Error_Msg_NE\n@@ -16515,7 +16491,7 @@ package body Sem_Ch3 is\n          begin\n             --  Look for the associated private type declaration\n \n-            Partial_View := Find_Partial_View (T);\n+            Partial_View := Incomplete_Or_Partial_View (T);\n \n             --  If the partial view was not found then the source code has\n             --  errors and the transformation is not needed."}, {"sha": "3da7987fa57590caff52c330788cfa49d98ab86a", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -527,10 +527,11 @@ package body Sem_Ch7 is\n          --  processing for inlined bodies. For them, we traverse the syntactic\n          --  tree and record which subprograms are actually referenced from it.\n          --  This makes it possible to compute a much smaller set of externally\n-         --  visible subprograms, which can have a significant impact on the\n-         --  inlining decisions made in the back end. We do it only for inlined\n-         --  bodies because they are supposed to be reasonably small and tree\n-         --  traversal is very expensive.\n+         --  visible subprograms in the absence of generic bodies, which can\n+         --  have a significant impact on the inlining decisions made in the\n+         --  back end and the removal of out-of-line bodies from the object\n+         --  code. We do it only for inlined bodies because they are supposed\n+         --  to be reasonably small and tree traversal is very expensive.\n \n          --  Note that even this special processing is not optimal for inlined\n          --  bodies, because we treat all inlined subprograms alike. An optimal"}, {"sha": "d5f724d5e63534e6203363bf0fda1ef228ed2fc8", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -1161,7 +1161,6 @@ package body Sem_Dim is\n             | N_Qualified_Expression\n             | N_Selected_Component\n             | N_Slice\n-            | N_Type_Conversion\n             | N_Unchecked_Type_Conversion\n          =>\n             Analyze_Dimension_Has_Etype (N);\n@@ -1191,7 +1190,17 @@ package body Sem_Dim is\n          when N_Subtype_Declaration =>\n             Analyze_Dimension_Subtype_Declaration (N);\n \n+         when  N_Type_Conversion =>\n+            if In_Instance\n+              and then Exists (Dimensions_Of (Expression (N)))\n+            then\n+               Set_Dimensions (N, Dimensions_Of (Expression (N)));\n+            else\n+               Analyze_Dimension_Has_Etype (N);\n+            end if;\n+\n          when N_Unary_Op =>\n+\n             Analyze_Dimension_Unary_Op (N);\n \n          when others =>\n@@ -1378,10 +1387,23 @@ package body Sem_Dim is\n \n          --  A type conversion may have been inserted to rewrite other\n          --  expressions, e.g. function returns. Dimensions are those of\n-         --  the target type.\n+         --  the target type, unless this is a conversion in an instance,\n+         --  in which case the proper dimensions are those of the operand,\n \n          elsif Nkind (N) = N_Type_Conversion then\n-            return Dimensions_Of (Etype (N));\n+            if In_Instance\n+              and then Is_Generic_Actual_Type (Etype (Expression (N)))\n+            then\n+               return Dimensions_Of (Etype (Expression (N)));\n+\n+            elsif In_Instance\n+              and then Exists (Dimensions_Of (Expression (N)))\n+            then\n+               return Dimensions_Of (Expression (N));\n+\n+            else\n+               return Dimensions_Of (Etype (N));\n+            end if;\n \n          --  Otherwise return the default dimensions\n "}, {"sha": "28713c23d68e066de4808f6e47153c59dfbfd33b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -5455,6 +5455,13 @@ package body Sem_Res is\n             Resolve (L, B_Typ);\n             Resolve (R, TR);\n \n+         --  If both operands are universal and the context is a floating\n+         --  point type, the operands are resolved to the type of the context.\n+\n+         elsif Is_Floating_Point_Type (B_Typ) then\n+            Resolve (L, B_Typ);\n+            Resolve (R, B_Typ);\n+\n          else\n             Set_Mixed_Mode_Operand (L, TR);\n             Set_Mixed_Mode_Operand (R, TL);"}, {"sha": "0440d89edd23f57d16d809d876346962f7925f6a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -15545,34 +15545,6 @@ package body Sem_Util is\n         and then Ekind (Defining_Entity (N)) /= E_Subprogram_Body;\n    end Is_Subprogram_Stub_Without_Prior_Declaration;\n \n-   ---------------------------------------\n-   -- Is_Subp_Or_Entry_Inside_Protected --\n-   ---------------------------------------\n-\n-   function Is_Subp_Or_Entry_Inside_Protected (E : Entity_Id) return Boolean is\n-      Scop : Entity_Id;\n-\n-   begin\n-      case Ekind (E) is\n-         when Entry_Kind\n-            | Subprogram_Kind\n-         =>\n-            Scop := Scope (E);\n-\n-            while Present (Scop) loop\n-               if Ekind (Scop) = E_Protected_Type then\n-                  return True;\n-               end if;\n-               Scop := Scope (Scop);\n-            end loop;\n-\n-            return False;\n-\n-         when others =>\n-            return False;\n-      end case;\n-   end Is_Subp_Or_Entry_Inside_Protected;\n-\n    --------------------------\n    -- Is_Suspension_Object --\n    --------------------------\n@@ -22585,6 +22557,24 @@ package body Sem_Util is\n       return Is_Init_Proc (S);\n    end Within_Init_Proc;\n \n+   ---------------------------\n+   -- Within_Protected_Type --\n+   ---------------------------\n+\n+   function Within_Protected_Type (E : Entity_Id) return Boolean is\n+      Scop : Entity_Id := Scope (E);\n+\n+   begin\n+      while Present (Scop) loop\n+         if Ekind (Scop) = E_Protected_Type then\n+            return True;\n+         end if;\n+         Scop := Scope (Scop);\n+      end loop;\n+\n+      return False;\n+   end Within_Protected_Type;\n+\n    ------------------\n    -- Within_Scope --\n    ------------------"}, {"sha": "7d3bd0920d71ccc2a2aa15d917e2761bc783c63c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66f95f60458a1da2e82c4b879357ebe36fcdb879/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=66f95f60458a1da2e82c4b879357ebe36fcdb879", "patch": "@@ -1839,10 +1839,6 @@ package Sem_Util is\n    --  Return True if N is a subprogram stub with no prior subprogram\n    --  declaration.\n \n-   function Is_Subp_Or_Entry_Inside_Protected (E : Entity_Id) return Boolean;\n-   --  Return True if E is an entry or a subprogram that is part (directly or\n-   --  in a nested way) of a protected type.\n-\n    function Is_Suspension_Object (Id : Entity_Id) return Boolean;\n    --  Determine whether arbitrary entity Id denotes Suspension_Object defined\n    --  in Ada.Synchronous_Task_Control.\n@@ -2584,6 +2580,9 @@ package Sem_Util is\n    function Within_Init_Proc return Boolean;\n    --  Determines if Current_Scope is within an init proc\n \n+   function Within_Protected_Type (E : Entity_Id) return Boolean;\n+   --  Returns True if entity E is declared within a protected type\n+\n    function Within_Scope (E : Entity_Id; S : Entity_Id) return Boolean;\n    --  Returns True if entity E is declared within scope S\n "}]}