{"sha": "7da4bf7dd7624094cd3422246af9f10c8538eb51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhNGJmN2RkNzYyNDA5NGNkMzQyMjI0NmFmOWYxMGM4NTM4ZWI1MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-24T14:15:13Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-24T14:15:13Z"}, "message": "tree-ssa-copy.c (copy_prop_visit_cond_stmt): Use COMPARISON_CLASS_P.\n\n\t* tree-ssa-copy.c (copy_prop_visit_cond_stmt): Use\n\tCOMPARISON_CLASS_P.\n\t* tree-ssa-pre.c (create_value_expr_from): Use\n\tCONSTANT_CLASS_P and REFERENCE_CLASS_P.\n\t* tree-ssa-propagate.c (stmt_makes_single_load,\n\tstmt_makes_single_store): Use REFERENCE_CLASS_P.\n\t* tree-vect-transform.c (vect_is_simple_cond): Use\n\tCOMPARISON_CLASS_P.\n\t* tree-vrp.c (extract_range_from_assert,\n\tbuild_assert_expr_for, fp_predicate, has_assert_expr): Use\n\tCOMPARISON_CLASS_P.\n\nFrom-SVN: r98664", "tree": {"sha": "d39b03eb88580af5d5c56eb4f89cfa856b69909c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d39b03eb88580af5d5c56eb4f89cfa856b69909c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7da4bf7dd7624094cd3422246af9f10c8538eb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da4bf7dd7624094cd3422246af9f10c8538eb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da4bf7dd7624094cd3422246af9f10c8538eb51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da4bf7dd7624094cd3422246af9f10c8538eb51/comments", "author": null, "committer": null, "parents": [{"sha": "d29f81b69c996b2c916861c5b14fe7aa461d8e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d29f81b69c996b2c916861c5b14fe7aa461d8e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d29f81b69c996b2c916861c5b14fe7aa461d8e60"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "388f5bf3ea92ce68c6207ac0c65b50c7a5d2d9ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -1,3 +1,17 @@\n+2005-04-24  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-ssa-copy.c (copy_prop_visit_cond_stmt): Use\n+\tCOMPARISON_CLASS_P.\n+\t* tree-ssa-pre.c (create_value_expr_from): Use\n+\tCONSTANT_CLASS_P and REFERENCE_CLASS_P.\n+\t* tree-ssa-propagate.c (stmt_makes_single_load,\n+\tstmt_makes_single_store): Use REFERENCE_CLASS_P.\n+\t* tree-vect-transform.c (vect_is_simple_cond): Use\n+\tCOMPARISON_CLASS_P.\n+\t* tree-vrp.c (extract_range_from_assert,\n+\tbuild_assert_expr_for, fp_predicate, has_assert_expr): Use\n+\tCOMPARISON_CLASS_P.\n+\n 2005-04-24  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* tree.h (TREE_THIS_VOLATILE): Document the effect on a"}, {"sha": "1b646384cb5e4f548db8e05b631de11acbd1d587", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -604,7 +604,7 @@ copy_prop_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n \n   /* The only conditionals that we may be able to compute statically\n      are predicates involving at least one SSA_NAME.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n+  if (COMPARISON_CLASS_P (cond)\n       && NUM_USES (uses) >= 1)\n     {\n       unsigned i;"}, {"sha": "87e1dcde10e320ab1b947631620676015d670fd8", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -1851,15 +1851,15 @@ create_value_expr_from (tree expr, basic_block block,\n \n       /* If OP is a constant that has overflowed, do not value number\n \t this expression.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (op)) == tcc_constant\n+      if (CONSTANT_CLASS_P (op)\n \t  && TREE_OVERFLOW (op))\n \t{\n \t  pool_free (pool, vexpr);\n \t  return NULL;\n \t}\n \n       /* Recursively value-numberize reference ops */\n-      if (TREE_CODE_CLASS (TREE_CODE (op)) == tcc_reference)\n+      if (REFERENCE_CLASS_P (op))\n \t{\n \t  tree tempop = create_value_expr_from (op, block, vuses);\n \t  op = tempop ? tempop : op;"}, {"sha": "69f41bab91d78cba3545ea7c65c1652cc61977cb", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -709,7 +709,7 @@ stmt_makes_single_load (tree stmt)\n \n   return (!TREE_THIS_VOLATILE (rhs)\n \t  && (DECL_P (rhs)\n-\t      || TREE_CODE_CLASS (TREE_CODE (rhs)) == tcc_reference));\n+\t      || REFERENCE_CLASS_P (rhs)));\n }\n \n \n@@ -735,7 +735,7 @@ stmt_makes_single_store (tree stmt)\n \n   return (!TREE_THIS_VOLATILE (lhs)\n           && (DECL_P (lhs)\n-\t      || TREE_CODE_CLASS (TREE_CODE (lhs)) == tcc_reference));\n+\t      || REFERENCE_CLASS_P (lhs)));\n }\n \n "}, {"sha": "e51d56f7491fc8ae35465030464c62eae38448de", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -1151,7 +1151,7 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo)\n {\n   tree lhs, rhs;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) != tcc_comparison)\n+  if (!COMPARISON_CLASS_P (cond))\n     return false;\n \n   lhs = TREE_OPERAND (cond, 0);"}, {"sha": "4d0b034f7544626b123892473b745e3392a5dfa3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da4bf7dd7624094cd3422246af9f10c8538eb51/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=7da4bf7dd7624094cd3422246af9f10c8538eb51", "patch": "@@ -481,7 +481,7 @@ extract_range_from_assert (value_range *vr_p, tree expr)\n   var = ASSERT_EXPR_VAR (expr);\n   cond = ASSERT_EXPR_COND (expr);\n \n-  gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n+  gcc_assert (COMPARISON_CLASS_P (cond));\n \n   /* Find VAR in the ASSERT_EXPR conditional.  */\n   limit = get_opposite_operand (cond, var);\n@@ -1228,7 +1228,7 @@ build_assert_expr_for (tree cond, tree v)\n   gcc_assert (TREE_CODE (v) == SSA_NAME);\n   n = duplicate_ssa_name (v, NULL_TREE);\n \n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison)\n+  if (COMPARISON_CLASS_P (cond))\n     {\n       /* Build N = ASSERT_EXPR <V, COND>.  As a special case, if the\n \t conditional is an EQ_EXPR (V == Z), just build the assignment\n@@ -1276,8 +1276,8 @@ build_assert_expr_for (tree cond, tree v)\n static inline bool\n fp_predicate (tree expr)\n {\n-  return TREE_CODE_CLASS (TREE_CODE (expr)) == tcc_comparison\n-         && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+  return (COMPARISON_CLASS_P (expr)\n+\t  && FLOAT_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0))));\n }\n \n \n@@ -1335,7 +1335,7 @@ has_assert_expr (tree op, tree cond)\n       tree t1, t2;\n \n       /* If COND is not a comparison predicate, something is wrong.  */\n-      gcc_assert (TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n+      gcc_assert (COMPARISON_CLASS_P (cond));\n \n       /* Note that we only need to compare against one of the operands\n \t of OTHER_COND.  "}]}