{"sha": "b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjllYjNhYThhMmY5YzA5YWRlNTkxZWQxYTFlZGMxMmYwZTczZWQ3Mw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-05-26T09:20:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T09:20:53Z"}, "message": "exp_ch6.adb (Process_Contract_Cases_For): Update the call to Expand_Pragma_Contract_Cases.\n\n2015-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Process_Contract_Cases_For): Update the call to\n\tExpand_Pragma_Contract_Cases.\n\t* exp_prag.ads, exp_prag.adb (Expand_Contract_Cases): Rename to\n\tExpand_Pragma_Contract_Cases.\n\t* sem_ch13.adb (Add_Invariants): Use the original aspect name\n\twhen creating the arguments of pragma Check. This ensures that\n\t'Class is properly recognized and handled.\n\nFrom-SVN: r223671", "tree": {"sha": "b85c114cf0fec62a3131a2f88f521949d4895149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b85c114cf0fec62a3131a2f88f521949d4895149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a12e42fc3dc64fb4183ee30e32906d3111552a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12e42fc3dc64fb4183ee30e32906d3111552a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a12e42fc3dc64fb4183ee30e32906d3111552a17"}], "stats": {"total": 1713, "additions": 859, "deletions": 854}, "files": [{"sha": "f1c76f6c3295cf420bf51f9af178bdfae4ecfa13", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "patch": "@@ -1,3 +1,13 @@\n+2015-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Process_Contract_Cases_For): Update the call to\n+\tExpand_Pragma_Contract_Cases.\n+\t* exp_prag.ads, exp_prag.adb (Expand_Contract_Cases): Rename to\n+\tExpand_Pragma_Contract_Cases.\n+\t* sem_ch13.adb (Add_Invariants): Use the original aspect name\n+\twhen creating the arguments of pragma Check. This ensures that\n+\t'Class is properly recognized and handled.\n+\n 2015-05-26  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat1drv.adb: Minor adjustments."}, {"sha": "016264162bda0b36614ffa5d0dc0e215a9d72652", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "patch": "@@ -1856,7 +1856,7 @@ package body Exp_Ch6 is\n                   and then\n                     Nkind (Parent (Subp)) = N_Private_Extension_Declaration\n                then\n-                  if  Comes_From_Source (N) and then Is_Public_Subp then\n+                  if Comes_From_Source (N) and then Is_Public_Subp then\n                      Append_To (Post_Call, Make_Invariant_Call (Actual));\n                   end if;\n \n@@ -7292,7 +7292,7 @@ package body Exp_Ch6 is\n                Prag := Contract_Test_Cases (Items);\n                while Present (Prag) loop\n                   if Pragma_Name (Prag) = Name_Contract_Cases then\n-                     Expand_Contract_Cases\n+                     Expand_Pragma_Contract_Cases\n                        (CCs     => Prag,\n                         Subp_Id => Subp_Id,\n                         Decls   => Declarations (N),"}, {"sha": "2df57f485036dc325e971ffc92450d92120aea29", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 842, "deletions": 844, "changes": 1686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "patch": "@@ -156,1081 +156,1081 @@ package body Exp_Prag is\n       end if;\n    end Arg3;\n \n-   ---------------------------\n-   -- Expand_Contract_Cases --\n-   ---------------------------\n-\n-   --  Pragma Contract_Cases is expanded in the following manner:\n+   ---------------------\n+   -- Expand_N_Pragma --\n+   ---------------------\n \n-   --    subprogram S is\n-   --       Count    : Natural := 0;\n-   --       Flag_1   : Boolean := False;\n-   --       . . .\n-   --       Flag_N   : Boolean := False;\n-   --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n-   --       Pref_1   : ...;\n-   --       . . .\n-   --       Pref_M   : ...;\n+   procedure Expand_N_Pragma (N : Node_Id) is\n+      Pname : constant Name_Id := Pragma_Name (N);\n \n-   --       <preconditions (if any)>\n+   begin\n+      --  Rewrite pragma ignored by Ignore_Pragma to null statement, so that\n+      --  the back end or the expander here does not get over-enthusiastic and\n+      --  start processing such a pragma!\n \n-   --       --  Evaluate all case guards\n+      if Get_Name_Table_Boolean3 (Pname) then\n+         Rewrite (N, Make_Null_Statement (Sloc (N)));\n+         return;\n+      end if;\n \n-   --       if Case_Guard_1 then\n-   --          Flag_1 := True;\n-   --          Count  := Count + 1;\n-   --       end if;\n-   --       . . .\n-   --       if Case_Guard_N then\n-   --          Flag_N := True;\n-   --          Count  := Count + 1;\n-   --       end if;\n+      --  Note: we may have a pragma whose Pragma_Identifier field is not a\n+      --  recognized pragma, and we must ignore it at this stage.\n \n-   --       --  Emit errors depending on the number of case guards that\n-   --       --  evaluated to True.\n+      if Is_Pragma_Name (Pname) then\n+         case Get_Pragma_Id (Pname) is\n \n-   --       if Count = 0 then\n-   --          raise Assertion_Error with \"xxx contract cases incomplete\";\n-   --            <or>\n-   --          Flag_N+1 := True;  --  when \"others\" present\n+            --  Pragmas requiring special expander action\n \n-   --       elsif Count > 1 then\n-   --          declare\n-   --             Str0 : constant String :=\n-   --                      \"contract cases overlap for subprogram ABC\";\n-   --             Str1 : constant String :=\n-   --                      (if Flag_1 then\n-   --                         Str0 & \"case guard at xxx evaluates to True\"\n-   --                       else Str0);\n-   --             StrN : constant String :=\n-   --                      (if Flag_N then\n-   --                         StrN-1 & \"case guard at xxx evaluates to True\"\n-   --                       else StrN-1);\n-   --          begin\n-   --             raise Assertion_Error with StrN;\n-   --          end;\n-   --       end if;\n+            when Pragma_Abort_Defer =>\n+               Expand_Pragma_Abort_Defer (N);\n \n-   --       --  Evaluate all attribute 'Old prefixes found in the selected\n-   --       --  consequence.\n+            when Pragma_Check =>\n+               Expand_Pragma_Check (N);\n \n-   --       if Flag_1 then\n-   --          Pref_1 := <prefix of 'Old found in Consequence_1>\n-   --       . . .\n-   --       elsif Flag_N then\n-   --          Pref_M := <prefix of 'Old found in Consequence_N>\n-   --       end if;\n+            when Pragma_Common_Object =>\n+               Expand_Pragma_Common_Object (N);\n \n-   --       procedure _Postconditions is\n-   --       begin\n-   --          <postconditions (if any)>\n+            when Pragma_Import =>\n+               Expand_Pragma_Import_Or_Interface (N);\n \n-   --          if Flag_1 and then not Consequence_1 then\n-   --             raise Assertion_Error with \"failed contract case at xxx\";\n-   --          end if;\n-   --          . . .\n-   --          if Flag_N[+1] and then not Consequence_N[+1] then\n-   --             raise Assertion_Error with \"failed contract case at xxx\";\n-   --          end if;\n-   --       end _Postconditions;\n-   --    begin\n-   --       . . .\n-   --    end S;\n+            when Pragma_Inspection_Point =>\n+               Expand_Pragma_Inspection_Point (N);\n \n-   procedure Expand_Contract_Cases\n-     (CCs     : Node_Id;\n-      Subp_Id : Entity_Id;\n-      Decls   : List_Id;\n-      Stmts   : in out List_Id)\n-   is\n-      Loc : constant Source_Ptr := Sloc (CCs);\n+            when Pragma_Interface =>\n+               Expand_Pragma_Import_Or_Interface (N);\n \n-      procedure Case_Guard_Error\n-        (Decls     : List_Id;\n-         Flag      : Entity_Id;\n-         Error_Loc : Source_Ptr;\n-         Msg       : in out Entity_Id);\n-      --  Given a declarative list Decls, status flag Flag, the location of the\n-      --  error and a string Msg, construct the following check:\n-      --    Msg : constant String :=\n-      --            (if Flag then\n-      --                Msg & \"case guard at Error_Loc evaluates to True\"\n-      --             else Msg);\n-      --  The resulting code is added to Decls\n+            when Pragma_Interrupt_Priority =>\n+               Expand_Pragma_Interrupt_Priority (N);\n \n-      procedure Consequence_Error\n-        (Checks : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id);\n-      --  Given an if statement Checks, status flag Flag and a consequence\n-      --  Conseq, construct the following check:\n-      --    [els]if Flag and then not Conseq then\n-      --       raise Assertion_Error\n-      --         with \"failed contract case at Sloc (Conseq)\";\n-      --    [end if;]\n-      --  The resulting code is added to Checks\n+            when Pragma_Loop_Variant =>\n+               Expand_Pragma_Loop_Variant (N);\n \n-      function Declaration_Of (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a boolean flag, generate:\n-      --    Id : Boolean := False;\n+            when Pragma_Psect_Object =>\n+               Expand_Pragma_Psect_Object (N);\n \n-      procedure Expand_Attributes_In_Consequence\n-        (Decls  : List_Id;\n-         Evals  : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id);\n-      --  Perform specialized expansion of all attribute 'Old references found\n-      --  in consequence Conseq such that at runtime only prefixes coming from\n-      --  the selected consequence are evaluated. Similarly expand attribute\n-      --  'Result references by replacing them with identifier _result which\n-      --  resolves to the sole formal parameter of procedure _Postconditions.\n-      --  Any temporaries generated in the process are added to declarations\n-      --  Decls. Evals is a complex if statement tasked with the evaluation of\n-      --  all prefixes coming from a single selected consequence. Flag is the\n-      --  corresponding case guard flag. Conseq is the consequence expression.\n+            when Pragma_Relative_Deadline =>\n+               Expand_Pragma_Relative_Deadline (N);\n \n-      function Increment (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a numerical variable, generate:\n-      --    Id := Id + 1;\n+            when Pragma_Suppress_Initialization =>\n+               Expand_Pragma_Suppress_Initialization (N);\n \n-      function Set (Id : Entity_Id) return Node_Id;\n-      --  Given the entity Id of a boolean variable, generate:\n-      --    Id := True;\n+            --  All other pragmas need no expander action\n \n-      ----------------------\n-      -- Case_Guard_Error --\n-      ----------------------\n+            when others => null;\n+         end case;\n+      end if;\n \n-      procedure Case_Guard_Error\n-        (Decls     : List_Id;\n-         Flag      : Entity_Id;\n-         Error_Loc : Source_Ptr;\n-         Msg       : in out Entity_Id)\n-      is\n-         New_Line : constant Character := Character'Val (10);\n-         New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n+   end Expand_N_Pragma;\n \n-      begin\n-         Start_String;\n-         Store_String_Char  (New_Line);\n-         Store_String_Chars (\"  case guard at \");\n-         Store_String_Chars (Build_Location_String (Error_Loc));\n-         Store_String_Chars (\" evaluates to True\");\n+   -------------------------------\n+   -- Expand_Pragma_Abort_Defer --\n+   -------------------------------\n \n-         --  Generate:\n-         --    New_Msg : constant String :=\n-         --      (if Flag then\n-         --          Msg & \"case guard at Error_Loc evaluates to True\"\n-         --       else Msg);\n+   --  An Abort_Defer pragma appears as the first statement in a handled\n+   --  statement sequence (right after the begin). It defers aborts for\n+   --  the entire statement sequence, but not for any declarations or\n+   --  handlers (if any) associated with this statement sequence.\n \n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => New_Msg,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n-             Expression          =>\n-               Make_If_Expression (Loc,\n-                 Expressions => New_List (\n-                   New_Occurrence_Of (Flag, Loc),\n+   --  The transformation is to transform\n \n-                   Make_Op_Concat (Loc,\n-                     Left_Opnd  => New_Occurrence_Of (Msg, Loc),\n-                     Right_Opnd => Make_String_Literal (Loc, End_String)),\n+   --    pragma Abort_Defer;\n+   --    statements;\n \n-                   New_Occurrence_Of (Msg, Loc)))));\n+   --  into\n \n-         Msg := New_Msg;\n-      end Case_Guard_Error;\n+   --    begin\n+   --       Abort_Defer.all;\n+   --       statements\n+   --    exception\n+   --       when all others =>\n+   --          Abort_Undefer.all;\n+   --          raise;\n+   --    at end\n+   --       Abort_Undefer_Direct;\n+   --    end;\n \n-      -----------------------\n-      -- Consequence_Error --\n-      -----------------------\n+   procedure Expand_Pragma_Abort_Defer (N : Node_Id) is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Stm  : Node_Id;\n+      Stms : List_Id;\n+      HSS  : Node_Id;\n+      Blk  : constant Entity_Id :=\n+               New_Internal_Entity (E_Block, Current_Scope, Sloc (N), 'B');\n+      AUD : constant Entity_Id := RTE (RE_Abort_Undefer_Direct);\n \n-      procedure Consequence_Error\n-        (Checks : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id)\n-      is\n-         Cond  : Node_Id;\n-         Error : Node_Id;\n+   begin\n+      Stms := New_List (Build_Runtime_Call (Loc, RE_Abort_Defer));\n+      loop\n+         Stm := Remove_Next (N);\n+         exit when No (Stm);\n+         Append (Stm, Stms);\n+      end loop;\n \n-      begin\n-         --  Generate:\n-         --    Flag and then not Conseq\n+      HSS :=\n+        Make_Handled_Sequence_Of_Statements (Loc,\n+          Statements  => Stms,\n+          At_End_Proc => New_Occurrence_Of (AUD, Loc));\n \n-         Cond :=\n-           Make_And_Then (Loc,\n-             Left_Opnd  => New_Occurrence_Of (Flag, Loc),\n-             Right_Opnd =>\n-               Make_Op_Not (Loc,\n-                 Right_Opnd => Relocate_Node (Conseq)));\n+      --  Present the Abort_Undefer_Direct function to the backend so that it\n+      --  can inline the call to the function.\n \n-         --  Generate:\n-         --    raise Assertion_Error\n-         --      with \"failed contract case at Sloc (Conseq)\";\n+      Add_Inlined_Body (AUD, N);\n \n-         Start_String;\n-         Store_String_Chars (\"failed contract case at \");\n-         Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n+      Rewrite (N,\n+        Make_Block_Statement (Loc,\n+          Handled_Statement_Sequence => HSS));\n \n-         Error :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n-             Parameter_Associations => New_List (\n-               Make_String_Literal (Loc, End_String)));\n+      Set_Scope (Blk, Current_Scope);\n+      Set_Etype (Blk, Standard_Void_Type);\n+      Set_Identifier (N, New_Occurrence_Of (Blk, Sloc (N)));\n+      Expand_At_End_Handler (HSS, Blk);\n+      Analyze (N);\n+   end Expand_Pragma_Abort_Defer;\n \n-         if No (Checks) then\n-            Checks :=\n-              Make_Implicit_If_Statement (CCs,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Error));\n+   --------------------------\n+   -- Expand_Pragma_Check --\n+   --------------------------\n \n-         else\n-            if No (Elsif_Parts (Checks)) then\n-               Set_Elsif_Parts (Checks, New_List);\n-            end if;\n+   procedure Expand_Pragma_Check (N : Node_Id) is\n+      Cond : constant Node_Id := Arg2 (N);\n+      Nam  : constant Name_Id := Chars (Arg1 (N));\n+      Msg  : Node_Id;\n \n-            Append_To (Elsif_Parts (Checks),\n-              Make_Elsif_Part (Loc,\n-                Condition       => Cond,\n-                Then_Statements => New_List (Error)));\n-         end if;\n-      end Consequence_Error;\n+      Loc : constant Source_Ptr := Sloc (First_Node (Cond));\n+      --  Source location used in the case of a failed assertion: point to the\n+      --  failing condition, not Loc. Note that the source location of the\n+      --  expression is not usually the best choice here, because it points to\n+      --  the location of the topmost tree node, which may be an operator in\n+      --  the middle of the source text of the expression. For example, it gets\n+      --  located on the last AND keyword in a chain of boolean expressiond\n+      --  AND'ed together. It is best to put the message on the first character\n+      --  of the condition, which is the effect of the First_Node call here.\n+      --  This source location is used to build the default exception message,\n+      --  and also as the sloc of the call to the runtime subprogram raising\n+      --  Assert_Failure, so that coverage analysis tools can relate the\n+      --  call to the failed check.\n \n-      --------------------\n-      -- Declaration_Of --\n-      --------------------\n+   begin\n+      --  Nothing to do if pragma is ignored\n \n-      function Declaration_Of (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Id,\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc));\n-      end Declaration_Of;\n+      if Is_Ignored (N) then\n+         return;\n+      end if;\n \n-      --------------------------------------\n-      -- Expand_Attributes_In_Consequence --\n-      --------------------------------------\n+      --  Since this check is active, we rewrite the pragma into a\n+      --  corresponding if statement, and then analyze the statement\n \n-      procedure Expand_Attributes_In_Consequence\n-        (Decls  : List_Id;\n-         Evals  : in out Node_Id;\n-         Flag   : Entity_Id;\n-         Conseq : Node_Id)\n-      is\n-         Eval_Stmts : List_Id := No_List;\n-         --  The evaluation sequence expressed as assignment statements of all\n-         --  prefixes of attribute 'Old found in the current consequence.\n+      --  The normal case expansion transforms:\n \n-         function Expand_Attributes (N : Node_Id) return Traverse_Result;\n-         --  Determine whether an arbitrary node denotes attribute 'Old or\n-         --  'Result and if it does, perform all expansion-related actions.\n+      --    pragma Check (name, condition [,message]);\n \n-         -----------------------\n-         -- Expand_Attributes --\n-         -----------------------\n+      --  into\n \n-         function Expand_Attributes (N : Node_Id) return Traverse_Result is\n-            Decl : Node_Id;\n-            Pref : Node_Id;\n-            Temp : Entity_Id;\n+      --    if not condition then\n+      --       System.Assertions.Raise_Assert_Failure (Str);\n+      --    end if;\n \n-         begin\n-            --  Attribute 'Old\n+      --  where Str is the message if one is present, or the default of\n+      --  name failed at file:line if no message is given (the \"name failed\n+      --  at\" is omitted for name = Assertion, since it is redundant, given\n+      --  that the name of the exception is Assert_Failure.)\n \n-            if Nkind (N) = N_Attribute_Reference\n-              and then Attribute_Name (N) = Name_Old\n-            then\n-               Pref := Prefix (N);\n-               Temp := Make_Temporary (Loc, 'T', Pref);\n-               Set_Etype (Temp, Etype (Pref));\n+      --  Also, instead of \"XXX failed at\", we generate slightly\n+      --  different messages for some of the contract assertions (see\n+      --  code below for details).\n \n-               --  Generate a temporary to capture the value of the prefix:\n-               --    Temp : <Pref type>;\n-               --  Place that temporary at the beginning of declarations, to\n-               --  prevent anomalies in the GNATprove flow-analysis pass in\n-               --  the precondition procedure that follows.\n+      --  An alternative expansion is used when the No_Exception_Propagation\n+      --  restriction is active and there is a local Assert_Failure handler.\n+      --  This is not a common combination of circumstances, but it occurs in\n+      --  the context of Aunit and the zero footprint profile. In this case we\n+      --  generate:\n \n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of (Etype (Pref), Loc));\n-               Set_No_Initialization (Decl);\n+      --    if not condition then\n+      --       raise Assert_Failure;\n+      --    end if;\n \n-               Prepend_To (Decls, Decl);\n-               Analyze (Decl);\n+      --  This will then be transformed into a goto, and the local handler will\n+      --  be able to handle the assert error (which would not be the case if a\n+      --  call is made to the Raise_Assert_Failure procedure).\n \n-               --  Evaluate the prefix, generate:\n-               --    Temp := <Pref>;\n+      --  We also generate the direct raise if the Suppress_Exception_Locations\n+      --  is active, since we don't want to generate messages in this case.\n \n-               if No (Eval_Stmts) then\n-                  Eval_Stmts := New_List;\n-               end if;\n+      --  Note that the reason we do not always generate a direct raise is that\n+      --  the form in which the procedure is called allows for more efficient\n+      --  breakpointing of assertion errors.\n \n-               Append_To (Eval_Stmts,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => New_Occurrence_Of (Temp, Loc),\n-                   Expression => Pref));\n+      --  Generate the appropriate if statement. Note that we consider this to\n+      --  be an explicit conditional in the source, not an implicit if, so we\n+      --  do not call Make_Implicit_If_Statement.\n \n-               --  Ensure that the prefix is valid\n+      --  Case where we generate a direct raise\n \n-               if Validity_Checks_On and then Validity_Check_Operands then\n-                  Ensure_Valid (Pref);\n-               end if;\n+      if ((Debug_Flag_Dot_G\n+            or else Restriction_Active (No_Exception_Propagation))\n+           and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N)))\n+        or else (Opt.Exception_Locations_Suppressed and then No (Arg3 (N)))\n+      then\n+         Rewrite (N,\n+           Make_If_Statement (Loc,\n+             Condition       => Make_Op_Not (Loc, Right_Opnd => Cond),\n+             Then_Statements => New_List (\n+               Make_Raise_Statement (Loc,\n+                 Name => New_Occurrence_Of (RTE (RE_Assert_Failure), Loc)))));\n \n-               --  Replace the original attribute 'Old by a reference to the\n-               --  generated temporary.\n+      --  Case where we call the procedure\n \n-               Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+      else\n+         --  If we have a message given, use it\n \n-            --  Attribute 'Result\n+         if Present (Arg3 (N)) then\n+            Msg := Get_Pragma_Arg (Arg3 (N));\n \n-            elsif Is_Attribute_Result (N) then\n-               Rewrite (N, Make_Identifier (Loc, Name_uResult));\n-            end if;\n+         --  Here we have no string, so prepare one\n \n-            return OK;\n-         end Expand_Attributes;\n+         else\n+            declare\n+               Loc_Str : constant String := Build_Location_String (Loc);\n \n-         procedure Expand_Attributes_In is\n-           new Traverse_Proc (Expand_Attributes);\n+            begin\n+               Name_Len := 0;\n \n-      --  Start of processing for Expand_Attributes_In_Consequence\n+               --  For Assert, we just use the location\n \n-      begin\n-         --  Inspect the consequence and expand any attribute 'Old and 'Result\n-         --  references found within.\n+               if Nam = Name_Assert then\n+                  null;\n \n-         Expand_Attributes_In (Conseq);\n+               --  For predicate, we generate the string \"predicate failed at\n+               --  yyy\". We prefer all lower case for predicate.\n \n-         --  The consequence does not contain any attribute 'Old references\n+               elsif Nam = Name_Predicate then\n+                  Add_Str_To_Name_Buffer (\"predicate failed at \");\n \n-         if No (Eval_Stmts) then\n-            return;\n-         end if;\n+               --  For special case of Precondition/Postcondition the string is\n+               --  \"failed xx from yy\" where xx is precondition/postcondition\n+               --  in all lower case. The reason for this different wording is\n+               --  that the failure is not at the point of occurrence of the\n+               --  pragma, unlike the other Check cases.\n \n-         --  Augment the machinery to trigger the evaluation of all prefixes\n-         --  found in the step above. If Eval is empty, then this is the first\n-         --  consequence to yield expansion of 'Old. Generate:\n+               elsif Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n+                  Get_Name_String (Nam);\n+                  Insert_Str_In_Name_Buffer (\"failed \", 1);\n+                  Add_Str_To_Name_Buffer (\" from \");\n \n-         --    if Flag then\n-         --       <evaluation statements>\n-         --    end if;\n+               --  For special case of Invariant, the string is \"failed\n+               --  invariant from yy\", to be consistent with the string that is\n+               --  generated for the aspect case (the code later on checks for\n+               --  this specific string to modify it in some cases, so this is\n+               --  functionally important).\n \n-         if No (Evals) then\n-            Evals :=\n-              Make_Implicit_If_Statement (CCs,\n-                Condition       => New_Occurrence_Of (Flag, Loc),\n-                Then_Statements => Eval_Stmts);\n+               elsif Nam = Name_Invariant then\n+                  Add_Str_To_Name_Buffer (\"failed invariant from \");\n \n-         --  Otherwise generate:\n-         --    elsif Flag then\n-         --       <evaluation statements>\n-         --    end if;\n+               --  For all other checks, the string is \"xxx failed at yyy\"\n+               --  where xxx is the check name with current source file casing.\n \n-         else\n-            if No (Elsif_Parts (Evals)) then\n-               Set_Elsif_Parts (Evals, New_List);\n-            end if;\n+               else\n+                  Get_Name_String (Nam);\n+                  Set_Casing (Identifier_Casing (Current_Source_File));\n+                  Add_Str_To_Name_Buffer (\" failed at \");\n+               end if;\n \n-            Append_To (Elsif_Parts (Evals),\n-              Make_Elsif_Part (Loc,\n-                Condition       => New_Occurrence_Of (Flag, Loc),\n-                Then_Statements => Eval_Stmts));\n-         end if;\n-      end Expand_Attributes_In_Consequence;\n+               --  In all cases, add location string\n \n-      ---------------\n-      -- Increment --\n-      ---------------\n+               Add_Str_To_Name_Buffer (Loc_Str);\n \n-      function Increment (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Occurrence_Of (Id, Loc),\n-             Expression =>\n-               Make_Op_Add (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Id, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n-      end Increment;\n+               --  Build the message\n \n-      ---------\n-      -- Set --\n-      ---------\n+               Msg := Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len));\n+            end;\n+         end if;\n \n-      function Set (Id : Entity_Id) return Node_Id is\n-      begin\n-         return\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Occurrence_Of (Id, Loc),\n-             Expression => New_Occurrence_Of (Standard_True, Loc));\n-      end Set;\n+         --  Now rewrite as an if statement\n \n-      --  Local variables\n+         Rewrite (N,\n+           Make_If_Statement (Loc,\n+             Condition       => Make_Op_Not (Loc, Right_Opnd => Cond),\n+             Then_Statements => New_List (\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n+                 Parameter_Associations => New_List (Relocate_Node (Msg))))));\n+      end if;\n \n-      Aggr          : constant Node_Id :=\n-                        Expression (First\n-                          (Pragma_Argument_Associations (CCs)));\n-      Case_Guard    : Node_Id;\n-      CG_Checks     : Node_Id;\n-      CG_Stmts      : List_Id;\n-      Conseq        : Node_Id;\n-      Conseq_Checks : Node_Id   := Empty;\n-      Count         : Entity_Id;\n-      Count_Decl    : Node_Id;\n-      Error_Decls   : List_Id;\n-      Flag          : Entity_Id;\n-      Flag_Decl     : Node_Id;\n-      If_Stmt       : Node_Id;\n-      Msg_Str       : Entity_Id;\n-      Multiple_PCs  : Boolean;\n-      Old_Evals     : Node_Id   := Empty;\n-      Others_Decl   : Node_Id;\n-      Others_Flag   : Entity_Id := Empty;\n-      Post_Case     : Node_Id;\n+      Analyze (N);\n \n-   --  Start of processing for Expand_Contract_Cases\n+      --  If new condition is always false, give a warning\n \n-   begin\n-      --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n-      --  already been rewritten as a Null statement.\n+      if Warn_On_Assertion_Failure\n+        and then Nkind (N) = N_Procedure_Call_Statement\n+        and then Is_RTE (Entity (Name (N)), RE_Raise_Assert_Failure)\n+      then\n+         --  If original condition was a Standard.False, we assume that this is\n+         --  indeed intended to raise assert error and no warning is required.\n \n-      if Is_Ignored (CCs) then\n-         return;\n+         if Is_Entity_Name (Original_Node (Cond))\n+           and then Entity (Original_Node (Cond)) = Standard_False\n+         then\n+            return;\n \n-      --  Guard against malformed contract cases\n+         elsif Nam = Name_Assert then\n+            Error_Msg_N (\"?A?assertion will fail at run time\", N);\n+         else\n \n-      elsif Nkind (Aggr) /= N_Aggregate then\n-         return;\n+            Error_Msg_N (\"?A?check will fail at run time\", N);\n+         end if;\n       end if;\n+   end Expand_Pragma_Check;\n \n-      Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n+   ---------------------------------\n+   -- Expand_Pragma_Common_Object --\n+   ---------------------------------\n \n-      --  Create the counter which tracks the number of case guards that\n-      --  evaluate to True.\n+   --  Use a machine attribute to replicate semantic effect in DEC Ada\n \n-      --    Count : Natural := 0;\n+   --    pragma Machine_Attribute (intern_name, \"common_object\", extern_name);\n \n-      Count := Make_Temporary (Loc, 'C');\n-      Count_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Count,\n-          Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc),\n-          Expression          => Make_Integer_Literal (Loc, 0));\n+   --  For now we do nothing with the size attribute ???\n \n-      Prepend_To (Decls, Count_Decl);\n-      Analyze (Count_Decl);\n+   --  Note: Psect_Object shares this processing\n \n-      --  Create the base error message for multiple overlapping case guards\n+   procedure Expand_Pragma_Common_Object (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n \n-      --    Msg_Str : constant String :=\n-      --                \"contract cases overlap for subprogram Subp_Id\";\n+      Internal : constant Node_Id := Arg1 (N);\n+      External : constant Node_Id := Arg2 (N);\n \n-      if Multiple_PCs then\n-         Msg_Str := Make_Temporary (Loc, 'S');\n+      Psect : Node_Id;\n+      --  Psect value upper cased as string literal\n \n-         Start_String;\n-         Store_String_Chars (\"contract cases overlap for subprogram \");\n-         Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n+      Iloc : constant Source_Ptr := Sloc (Internal);\n+      Eloc : constant Source_Ptr := Sloc (External);\n+      Ploc : Source_Ptr;\n \n-         Error_Decls := New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Msg_Str,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n-             Expression          => Make_String_Literal (Loc, End_String)));\n-      end if;\n+   begin\n+      --  Acquire Psect value and fold to upper case\n \n-      --  Process individual post cases\n+      if Present (External) then\n+         if Nkind (External) = N_String_Literal then\n+            String_To_Name_Buffer (Strval (External));\n+         else\n+            Get_Name_String (Chars (External));\n+         end if;\n \n-      Post_Case := First (Component_Associations (Aggr));\n-      while Present (Post_Case) loop\n-         Case_Guard := First (Choices (Post_Case));\n-         Conseq     := Expression (Post_Case);\n+         Set_All_Upper_Case;\n \n-         --  The \"others\" choice requires special processing\n+         Psect :=\n+           Make_String_Literal (Eloc, Strval => String_From_Name_Buffer);\n \n-         if Nkind (Case_Guard) = N_Others_Choice then\n-            Others_Flag := Make_Temporary (Loc, 'F');\n-            Others_Decl := Declaration_Of (Others_Flag);\n+      else\n+         Get_Name_String (Chars (Internal));\n+         Set_All_Upper_Case;\n+         Psect :=\n+           Make_String_Literal (Iloc, Strval => String_From_Name_Buffer);\n+      end if;\n \n-            Prepend_To (Decls, Others_Decl);\n-            Analyze (Others_Decl);\n+      Ploc := Sloc (Psect);\n \n-            --  Check possible overlap between a case guard and \"others\"\n+      --  Insert the pragma\n \n-            if Multiple_PCs and Exception_Extra_Info then\n-               Case_Guard_Error\n-                 (Decls     => Error_Decls,\n-                  Flag      => Others_Flag,\n-                  Error_Loc => Sloc (Case_Guard),\n-                  Msg       => Msg_Str);\n-            end if;\n+      Insert_After_And_Analyze (N,\n+        Make_Pragma (Loc,\n+          Chars                        => Name_Machine_Attribute,\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Iloc,\n+              Expression => New_Copy_Tree (Internal)),\n+            Make_Pragma_Argument_Association (Eloc,\n+              Expression =>\n+                Make_String_Literal (Sloc => Ploc, Strval => \"common_object\")),\n+            Make_Pragma_Argument_Association (Ploc,\n+              Expression => New_Copy_Tree (Psect)))));\n+   end Expand_Pragma_Common_Object;\n \n-            --  Inspect the consequence and perform special expansion of any\n-            --  attribute 'Old and 'Result references found within.\n+   ----------------------------------\n+   -- Expand_Pragma_Contract_Cases --\n+   ----------------------------------\n \n-            Expand_Attributes_In_Consequence\n-              (Decls  => Decls,\n-               Evals  => Old_Evals,\n-               Flag   => Others_Flag,\n-               Conseq => Conseq);\n+   --  Pragma Contract_Cases is expanded in the following manner:\n \n-            --  Check the corresponding consequence of \"others\"\n+   --    subprogram S is\n+   --       Count    : Natural := 0;\n+   --       Flag_1   : Boolean := False;\n+   --       . . .\n+   --       Flag_N   : Boolean := False;\n+   --       Flag_N+1 : Boolean := False;  --  when \"others\" present\n+   --       Pref_1   : ...;\n+   --       . . .\n+   --       Pref_M   : ...;\n \n-            Consequence_Error\n-              (Checks => Conseq_Checks,\n-               Flag   => Others_Flag,\n-               Conseq => Conseq);\n+   --       <preconditions (if any)>\n \n-         --  Regular post case\n+   --       --  Evaluate all case guards\n \n-         else\n-            --  Create the flag which tracks the state of its associated case\n-            --  guard.\n+   --       if Case_Guard_1 then\n+   --          Flag_1 := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n+   --       . . .\n+   --       if Case_Guard_N then\n+   --          Flag_N := True;\n+   --          Count  := Count + 1;\n+   --       end if;\n \n-            Flag := Make_Temporary (Loc, 'F');\n-            Flag_Decl := Declaration_Of (Flag);\n+   --       --  Emit errors depending on the number of case guards that\n+   --       --  evaluated to True.\n \n-            Prepend_To (Decls, Flag_Decl);\n-            Analyze (Flag_Decl);\n+   --       if Count = 0 then\n+   --          raise Assertion_Error with \"xxx contract cases incomplete\";\n+   --            <or>\n+   --          Flag_N+1 := True;  --  when \"others\" present\n \n-            --  The flag is set when the case guard is evaluated to True\n-            --    if Case_Guard then\n-            --       Flag  := True;\n-            --       Count := Count + 1;\n-            --    end if;\n+   --       elsif Count > 1 then\n+   --          declare\n+   --             Str0 : constant String :=\n+   --                      \"contract cases overlap for subprogram ABC\";\n+   --             Str1 : constant String :=\n+   --                      (if Flag_1 then\n+   --                         Str0 & \"case guard at xxx evaluates to True\"\n+   --                       else Str0);\n+   --             StrN : constant String :=\n+   --                      (if Flag_N then\n+   --                         StrN-1 & \"case guard at xxx evaluates to True\"\n+   --                       else StrN-1);\n+   --          begin\n+   --             raise Assertion_Error with StrN;\n+   --          end;\n+   --       end if;\n \n-            If_Stmt :=\n-              Make_Implicit_If_Statement (CCs,\n-                Condition       => Relocate_Node (Case_Guard),\n-                Then_Statements => New_List (\n-                  Set (Flag),\n-                  Increment (Count)));\n+   --       --  Evaluate all attribute 'Old prefixes found in the selected\n+   --       --  consequence.\n \n-            Append_To (Decls, If_Stmt);\n-            Analyze (If_Stmt);\n+   --       if Flag_1 then\n+   --          Pref_1 := <prefix of 'Old found in Consequence_1>\n+   --       . . .\n+   --       elsif Flag_N then\n+   --          Pref_M := <prefix of 'Old found in Consequence_N>\n+   --       end if;\n \n-            --  Check whether this case guard overlaps with another one\n+   --       procedure _Postconditions is\n+   --       begin\n+   --          <postconditions (if any)>\n \n-            if Multiple_PCs and Exception_Extra_Info then\n-               Case_Guard_Error\n-                 (Decls     => Error_Decls,\n-                  Flag      => Flag,\n-                  Error_Loc => Sloc (Case_Guard),\n-                  Msg       => Msg_Str);\n-            end if;\n+   --          if Flag_1 and then not Consequence_1 then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --          . . .\n+   --          if Flag_N[+1] and then not Consequence_N[+1] then\n+   --             raise Assertion_Error with \"failed contract case at xxx\";\n+   --          end if;\n+   --       end _Postconditions;\n+   --    begin\n+   --       . . .\n+   --    end S;\n \n-            --  Inspect the consequence and perform special expansion of any\n-            --  attribute 'Old and 'Result references found within.\n+   procedure Expand_Pragma_Contract_Cases\n+     (CCs     : Node_Id;\n+      Subp_Id : Entity_Id;\n+      Decls   : List_Id;\n+      Stmts   : in out List_Id)\n+   is\n+      Loc : constant Source_Ptr := Sloc (CCs);\n \n-            Expand_Attributes_In_Consequence\n-              (Decls  => Decls,\n-               Evals  => Old_Evals,\n-               Flag   => Flag,\n-               Conseq => Conseq);\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id);\n+      --  Given a declarative list Decls, status flag Flag, the location of the\n+      --  error and a string Msg, construct the following check:\n+      --    Msg : constant String :=\n+      --            (if Flag then\n+      --                Msg & \"case guard at Error_Loc evaluates to True\"\n+      --             else Msg);\n+      --  The resulting code is added to Decls\n \n-            --  The corresponding consequence of the case guard which evaluated\n-            --  to True must hold on exit from the subprogram.\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id);\n+      --  Given an if statement Checks, status flag Flag and a consequence\n+      --  Conseq, construct the following check:\n+      --    [els]if Flag and then not Conseq then\n+      --       raise Assertion_Error\n+      --         with \"failed contract case at Sloc (Conseq)\";\n+      --    [end if;]\n+      --  The resulting code is added to Checks\n \n-            Consequence_Error\n-              (Checks => Conseq_Checks,\n-               Flag   => Flag,\n-               Conseq => Conseq);\n-         end if;\n+      function Declaration_Of (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean flag, generate:\n+      --    Id : Boolean := False;\n \n-         Next (Post_Case);\n-      end loop;\n+      procedure Expand_Attributes_In_Consequence\n+        (Decls  : List_Id;\n+         Evals  : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id);\n+      --  Perform specialized expansion of all attribute 'Old references found\n+      --  in consequence Conseq such that at runtime only prefixes coming from\n+      --  the selected consequence are evaluated. Similarly expand attribute\n+      --  'Result references by replacing them with identifier _result which\n+      --  resolves to the sole formal parameter of procedure _Postconditions.\n+      --  Any temporaries generated in the process are added to declarations\n+      --  Decls. Evals is a complex if statement tasked with the evaluation of\n+      --  all prefixes coming from a single selected consequence. Flag is the\n+      --  corresponding case guard flag. Conseq is the consequence expression.\n \n-      --  Raise Assertion_Error when none of the case guards evaluate to True.\n-      --  The only exception is when we have \"others\", in which case there is\n-      --  no error because \"others\" acts as a default True.\n+      function Increment (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a numerical variable, generate:\n+      --    Id := Id + 1;\n \n-      --  Generate:\n-      --    Flag := True;\n+      function Set (Id : Entity_Id) return Node_Id;\n+      --  Given the entity Id of a boolean variable, generate:\n+      --    Id := True;\n \n-      if Present (Others_Flag) then\n-         CG_Stmts := New_List (Set (Others_Flag));\n+      ----------------------\n+      -- Case_Guard_Error --\n+      ----------------------\n \n-      --  Generate:\n-      --    raise Assertion_Error with \"xxx contract cases incomplete\";\n+      procedure Case_Guard_Error\n+        (Decls     : List_Id;\n+         Flag      : Entity_Id;\n+         Error_Loc : Source_Ptr;\n+         Msg       : in out Entity_Id)\n+      is\n+         New_Line : constant Character := Character'Val (10);\n+         New_Msg  : constant Entity_Id := Make_Temporary (Loc, 'S');\n \n-      else\n+      begin\n          Start_String;\n-         Store_String_Chars (Build_Location_String (Loc));\n-         Store_String_Chars (\" contract cases incomplete\");\n-\n-         CG_Stmts := New_List (\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n-             Parameter_Associations => New_List (\n-               Make_String_Literal (Loc, End_String))));\n-      end if;\n+         Store_String_Char  (New_Line);\n+         Store_String_Chars (\"  case guard at \");\n+         Store_String_Chars (Build_Location_String (Error_Loc));\n+         Store_String_Chars (\" evaluates to True\");\n \n-      CG_Checks :=\n-        Make_Implicit_If_Statement (CCs,\n-          Condition       =>\n-            Make_Op_Eq (Loc,\n-              Left_Opnd  => New_Occurrence_Of (Count, Loc),\n-              Right_Opnd => Make_Integer_Literal (Loc, 0)),\n-          Then_Statements => CG_Stmts);\n+         --  Generate:\n+         --    New_Msg : constant String :=\n+         --      (if Flag then\n+         --          Msg & \"case guard at Error_Loc evaluates to True\"\n+         --       else Msg);\n \n-      --  Detect a possible failure due to several case guards evaluating to\n-      --  True.\n+         Append_To (Decls,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => New_Msg,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n+             Expression          =>\n+               Make_If_Expression (Loc,\n+                 Expressions => New_List (\n+                   New_Occurrence_Of (Flag, Loc),\n \n-      --  Generate:\n-      --    elsif Count > 0 then\n-      --       declare\n-      --          <Error_Decls>\n-      --       begin\n-      --          raise Assertion_Error with <Msg_Str>;\n-      --    end if;\n+                   Make_Op_Concat (Loc,\n+                     Left_Opnd  => New_Occurrence_Of (Msg, Loc),\n+                     Right_Opnd => Make_String_Literal (Loc, End_String)),\n \n-      if Multiple_PCs then\n-         Set_Elsif_Parts (CG_Checks, New_List (\n-           Make_Elsif_Part (Loc,\n-             Condition       =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd  => New_Occurrence_Of (Count, Loc),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 1)),\n+                   New_Occurrence_Of (Msg, Loc)))));\n \n-             Then_Statements => New_List (\n-               Make_Block_Statement (Loc,\n-                 Declarations               => Error_Decls,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements => New_List (\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name                   =>\n-                           New_Occurrence_Of\n-                             (RTE (RE_Raise_Assert_Failure), Loc),\n-                         Parameter_Associations => New_List (\n-                           New_Occurrence_Of (Msg_Str, Loc))))))))));\n-      end if;\n+         Msg := New_Msg;\n+      end Case_Guard_Error;\n \n-      Append_To (Decls, CG_Checks);\n-      Analyze (CG_Checks);\n+      -----------------------\n+      -- Consequence_Error --\n+      -----------------------\n \n-      --  Once all case guards are evaluated and checked, evaluate any prefixes\n-      --  of attribute 'Old founds in the selected consequence.\n+      procedure Consequence_Error\n+        (Checks : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id)\n+      is\n+         Cond  : Node_Id;\n+         Error : Node_Id;\n \n-      if Present (Old_Evals) then\n-         Append_To (Decls, Old_Evals);\n-         Analyze (Old_Evals);\n-      end if;\n+      begin\n+         --  Generate:\n+         --    Flag and then not Conseq\n \n-      --  Raise Assertion_Error when the corresponding consequence of a case\n-      --  guard that evaluated to True fails.\n+         Cond :=\n+           Make_And_Then (Loc,\n+             Left_Opnd  => New_Occurrence_Of (Flag, Loc),\n+             Right_Opnd =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd => Relocate_Node (Conseq)));\n \n-      if No (Stmts) then\n-         Stmts := New_List;\n-      end if;\n+         --  Generate:\n+         --    raise Assertion_Error\n+         --      with \"failed contract case at Sloc (Conseq)\";\n \n-      Append_To (Stmts, Conseq_Checks);\n-   end Expand_Contract_Cases;\n+         Start_String;\n+         Store_String_Chars (\"failed contract case at \");\n+         Store_String_Chars (Build_Location_String (Sloc (Conseq)));\n \n-   ---------------------\n-   -- Expand_N_Pragma --\n-   ---------------------\n+         Error :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String)));\n \n-   procedure Expand_N_Pragma (N : Node_Id) is\n-      Pname : constant Name_Id := Pragma_Name (N);\n+         if No (Checks) then\n+            Checks :=\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error));\n \n-   begin\n-      --  Rewrite pragma ignored by Ignore_Pragma to null statement, so that/\n-      --  back end or the expander here does not get over-enthusiastic and\n-      --  start processing such a pragma!\n+         else\n+            if No (Elsif_Parts (Checks)) then\n+               Set_Elsif_Parts (Checks, New_List);\n+            end if;\n \n-      if Get_Name_Table_Boolean3 (Pname) then\n-         Rewrite (N, Make_Null_Statement (Sloc (N)));\n-         return;\n-      end if;\n+            Append_To (Elsif_Parts (Checks),\n+              Make_Elsif_Part (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Error)));\n+         end if;\n+      end Consequence_Error;\n \n-      --  Note: we may have a pragma whose Pragma_Identifier field is not a\n-      --  recognized pragma, and we must ignore it at this stage.\n+      --------------------\n+      -- Declaration_Of --\n+      --------------------\n \n-      if Is_Pragma_Name (Pname) then\n-         case Get_Pragma_Id (Pname) is\n+      function Declaration_Of (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression          => New_Occurrence_Of (Standard_False, Loc));\n+      end Declaration_Of;\n \n-            --  Pragmas requiring special expander action\n+      --------------------------------------\n+      -- Expand_Attributes_In_Consequence --\n+      --------------------------------------\n \n-            when Pragma_Abort_Defer =>\n-               Expand_Pragma_Abort_Defer (N);\n+      procedure Expand_Attributes_In_Consequence\n+        (Decls  : List_Id;\n+         Evals  : in out Node_Id;\n+         Flag   : Entity_Id;\n+         Conseq : Node_Id)\n+      is\n+         Eval_Stmts : List_Id := No_List;\n+         --  The evaluation sequence expressed as assignment statements of all\n+         --  prefixes of attribute 'Old found in the current consequence.\n \n-            when Pragma_Check =>\n-               Expand_Pragma_Check (N);\n+         function Expand_Attributes (N : Node_Id) return Traverse_Result;\n+         --  Determine whether an arbitrary node denotes attribute 'Old or\n+         --  'Result and if it does, perform all expansion-related actions.\n \n-            when Pragma_Common_Object =>\n-               Expand_Pragma_Common_Object (N);\n+         -----------------------\n+         -- Expand_Attributes --\n+         -----------------------\n \n-            when Pragma_Import =>\n-               Expand_Pragma_Import_Or_Interface (N);\n+         function Expand_Attributes (N : Node_Id) return Traverse_Result is\n+            Decl : Node_Id;\n+            Pref : Node_Id;\n+            Temp : Entity_Id;\n \n-            when Pragma_Inspection_Point =>\n-               Expand_Pragma_Inspection_Point (N);\n+         begin\n+            --  Attribute 'Old\n \n-            when Pragma_Interface =>\n-               Expand_Pragma_Import_Or_Interface (N);\n+            if Nkind (N) = N_Attribute_Reference\n+              and then Attribute_Name (N) = Name_Old\n+            then\n+               Pref := Prefix (N);\n+               Temp := Make_Temporary (Loc, 'T', Pref);\n+               Set_Etype (Temp, Etype (Pref));\n \n-            when Pragma_Interrupt_Priority =>\n-               Expand_Pragma_Interrupt_Priority (N);\n+               --  Generate a temporary to capture the value of the prefix:\n+               --    Temp : <Pref type>;\n+               --  Place that temporary at the beginning of declarations, to\n+               --  prevent anomalies in the GNATprove flow-analysis pass in\n+               --  the precondition procedure that follows.\n \n-            when Pragma_Loop_Variant =>\n-               Expand_Pragma_Loop_Variant (N);\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Etype (Pref), Loc));\n+               Set_No_Initialization (Decl);\n \n-            when Pragma_Psect_Object =>\n-               Expand_Pragma_Psect_Object (N);\n+               Prepend_To (Decls, Decl);\n+               Analyze (Decl);\n \n-            when Pragma_Relative_Deadline =>\n-               Expand_Pragma_Relative_Deadline (N);\n+               --  Evaluate the prefix, generate:\n+               --    Temp := <Pref>;\n \n-            when Pragma_Suppress_Initialization =>\n-               Expand_Pragma_Suppress_Initialization (N);\n+               if No (Eval_Stmts) then\n+                  Eval_Stmts := New_List;\n+               end if;\n \n-            --  All other pragmas need no expander action\n+               Append_To (Eval_Stmts,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => New_Occurrence_Of (Temp, Loc),\n+                   Expression => Pref));\n \n-            when others => null;\n-         end case;\n-      end if;\n+               --  Ensure that the prefix is valid\n \n-   end Expand_N_Pragma;\n+               if Validity_Checks_On and then Validity_Check_Operands then\n+                  Ensure_Valid (Pref);\n+               end if;\n \n-   -------------------------------\n-   -- Expand_Pragma_Abort_Defer --\n-   -------------------------------\n+               --  Replace the original attribute 'Old by a reference to the\n+               --  generated temporary.\n \n-   --  An Abort_Defer pragma appears as the first statement in a handled\n-   --  statement sequence (right after the begin). It defers aborts for\n-   --  the entire statement sequence, but not for any declarations or\n-   --  handlers (if any) associated with this statement sequence.\n+               Rewrite (N, New_Occurrence_Of (Temp, Loc));\n \n-   --  The transformation is to transform\n+            --  Attribute 'Result\n \n-   --    pragma Abort_Defer;\n-   --    statements;\n+            elsif Is_Attribute_Result (N) then\n+               Rewrite (N, Make_Identifier (Loc, Name_uResult));\n+            end if;\n \n-   --  into\n+            return OK;\n+         end Expand_Attributes;\n \n-   --    begin\n-   --       Abort_Defer.all;\n-   --       statements\n-   --    exception\n-   --       when all others =>\n-   --          Abort_Undefer.all;\n-   --          raise;\n-   --    at end\n-   --       Abort_Undefer_Direct;\n-   --    end;\n+         procedure Expand_Attributes_In is\n+           new Traverse_Proc (Expand_Attributes);\n \n-   procedure Expand_Pragma_Abort_Defer (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Stm  : Node_Id;\n-      Stms : List_Id;\n-      HSS  : Node_Id;\n-      Blk  : constant Entity_Id :=\n-               New_Internal_Entity (E_Block, Current_Scope, Sloc (N), 'B');\n-      AUD : constant Entity_Id := RTE (RE_Abort_Undefer_Direct);\n+      --  Start of processing for Expand_Attributes_In_Consequence\n \n-   begin\n-      Stms := New_List (Build_Runtime_Call (Loc, RE_Abort_Defer));\n-      loop\n-         Stm := Remove_Next (N);\n-         exit when No (Stm);\n-         Append (Stm, Stms);\n-      end loop;\n+      begin\n+         --  Inspect the consequence and expand any attribute 'Old and 'Result\n+         --  references found within.\n \n-      HSS :=\n-        Make_Handled_Sequence_Of_Statements (Loc,\n-          Statements  => Stms,\n-          At_End_Proc => New_Occurrence_Of (AUD, Loc));\n+         Expand_Attributes_In (Conseq);\n \n-      --  Present the Abort_Undefer_Direct function to the backend so that it\n-      --  can inline the call to the function.\n+         --  The consequence does not contain any attribute 'Old references\n \n-      Add_Inlined_Body (AUD, N);\n+         if No (Eval_Stmts) then\n+            return;\n+         end if;\n \n-      Rewrite (N,\n-        Make_Block_Statement (Loc,\n-          Handled_Statement_Sequence => HSS));\n+         --  Augment the machinery to trigger the evaluation of all prefixes\n+         --  found in the step above. If Eval is empty, then this is the first\n+         --  consequence to yield expansion of 'Old. Generate:\n \n-      Set_Scope (Blk, Current_Scope);\n-      Set_Etype (Blk, Standard_Void_Type);\n-      Set_Identifier (N, New_Occurrence_Of (Blk, Sloc (N)));\n-      Expand_At_End_Handler (HSS, Blk);\n-      Analyze (N);\n-   end Expand_Pragma_Abort_Defer;\n+         --    if Flag then\n+         --       <evaluation statements>\n+         --    end if;\n \n-   --------------------------\n-   -- Expand_Pragma_Check --\n-   --------------------------\n+         if No (Evals) then\n+            Evals :=\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => New_Occurrence_Of (Flag, Loc),\n+                Then_Statements => Eval_Stmts);\n \n-   procedure Expand_Pragma_Check (N : Node_Id) is\n-      Cond : constant Node_Id := Arg2 (N);\n-      Nam  : constant Name_Id := Chars (Arg1 (N));\n-      Msg  : Node_Id;\n+         --  Otherwise generate:\n+         --    elsif Flag then\n+         --       <evaluation statements>\n+         --    end if;\n \n-      Loc : constant Source_Ptr := Sloc (First_Node (Cond));\n-      --  Source location used in the case of a failed assertion: point to the\n-      --  failing condition, not Loc. Note that the source location of the\n-      --  expression is not usually the best choice here, because it points to\n-      --  the location of the topmost tree node, which may be an operator in\n-      --  the middle of the source text of the expression. For example, it gets\n-      --  located on the last AND keyword in a chain of boolean expressiond\n-      --  AND'ed together. It is best to put the message on the first character\n-      --  of the condition, which is the effect of the First_Node call here.\n-      --  This source location is used to build the default exception message,\n-      --  and also as the sloc of the call to the runtime subprogram raising\n-      --  Assert_Failure, so that coverage analysis tools can relate the\n-      --  call to the failed check.\n+         else\n+            if No (Elsif_Parts (Evals)) then\n+               Set_Elsif_Parts (Evals, New_List);\n+            end if;\n \n-   begin\n-      --  Nothing to do if pragma is ignored\n+            Append_To (Elsif_Parts (Evals),\n+              Make_Elsif_Part (Loc,\n+                Condition       => New_Occurrence_Of (Flag, Loc),\n+                Then_Statements => Eval_Stmts));\n+         end if;\n+      end Expand_Attributes_In_Consequence;\n \n-      if Is_Ignored (N) then\n-         return;\n-      end if;\n+      ---------------\n+      -- Increment --\n+      ---------------\n \n-      --  Since this check is active, we rewrite the pragma into a\n-      --  corresponding if statement, and then analyze the statement\n+      function Increment (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Occurrence_Of (Id, Loc),\n+             Expression =>\n+               Make_Op_Add (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Id, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+      end Increment;\n \n-      --  The normal case expansion transforms:\n+      ---------\n+      -- Set --\n+      ---------\n \n-      --    pragma Check (name, condition [,message]);\n+      function Set (Id : Entity_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Assignment_Statement (Loc,\n+             Name       => New_Occurrence_Of (Id, Loc),\n+             Expression => New_Occurrence_Of (Standard_True, Loc));\n+      end Set;\n \n-      --  into\n+      --  Local variables\n \n-      --    if not condition then\n-      --       System.Assertions.Raise_Assert_Failure (Str);\n-      --    end if;\n+      Aggr          : constant Node_Id :=\n+                        Expression (First\n+                          (Pragma_Argument_Associations (CCs)));\n+      Case_Guard    : Node_Id;\n+      CG_Checks     : Node_Id;\n+      CG_Stmts      : List_Id;\n+      Conseq        : Node_Id;\n+      Conseq_Checks : Node_Id   := Empty;\n+      Count         : Entity_Id;\n+      Count_Decl    : Node_Id;\n+      Error_Decls   : List_Id;\n+      Flag          : Entity_Id;\n+      Flag_Decl     : Node_Id;\n+      If_Stmt       : Node_Id;\n+      Msg_Str       : Entity_Id;\n+      Multiple_PCs  : Boolean;\n+      Old_Evals     : Node_Id   := Empty;\n+      Others_Decl   : Node_Id;\n+      Others_Flag   : Entity_Id := Empty;\n+      Post_Case     : Node_Id;\n \n-      --  where Str is the message if one is present, or the default of\n-      --  name failed at file:line if no message is given (the \"name failed\n-      --  at\" is omitted for name = Assertion, since it is redundant, given\n-      --  that the name of the exception is Assert_Failure.)\n+   --  Start of processing for Expand_Pragma_Contract_Cases\n \n-      --  Also, instead of \"XXX failed at\", we generate slightly\n-      --  different messages for some of the contract assertions (see\n-      --  code below for details).\n+   begin\n+      --  Do nothing if pragma is not enabled. If pragma is disabled, it has\n+      --  already been rewritten as a Null statement.\n \n-      --  An alternative expansion is used when the No_Exception_Propagation\n-      --  restriction is active and there is a local Assert_Failure handler.\n-      --  This is not a common combination of circumstances, but it occurs in\n-      --  the context of Aunit and the zero footprint profile. In this case we\n-      --  generate:\n+      if Is_Ignored (CCs) then\n+         return;\n \n-      --    if not condition then\n-      --       raise Assert_Failure;\n-      --    end if;\n+      --  Guard against malformed contract cases\n \n-      --  This will then be transformed into a goto, and the local handler will\n-      --  be able to handle the assert error (which would not be the case if a\n-      --  call is made to the Raise_Assert_Failure procedure).\n+      elsif Nkind (Aggr) /= N_Aggregate then\n+         return;\n+      end if;\n \n-      --  We also generate the direct raise if the Suppress_Exception_Locations\n-      --  is active, since we don't want to generate messages in this case.\n+      Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n \n-      --  Note that the reason we do not always generate a direct raise is that\n-      --  the form in which the procedure is called allows for more efficient\n-      --  breakpointing of assertion errors.\n+      --  Create the counter which tracks the number of case guards that\n+      --  evaluate to True.\n \n-      --  Generate the appropriate if statement. Note that we consider this to\n-      --  be an explicit conditional in the source, not an implicit if, so we\n-      --  do not call Make_Implicit_If_Statement.\n+      --    Count : Natural := 0;\n \n-      --  Case where we generate a direct raise\n+      Count := Make_Temporary (Loc, 'C');\n+      Count_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Count,\n+          Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc),\n+          Expression          => Make_Integer_Literal (Loc, 0));\n \n-      if ((Debug_Flag_Dot_G\n-             or else Restriction_Active (No_Exception_Propagation))\n-           and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N)))\n-        or else (Opt.Exception_Locations_Suppressed and then No (Arg3 (N)))\n-      then\n-         Rewrite (N,\n-           Make_If_Statement (Loc,\n-             Condition       => Make_Op_Not (Loc, Right_Opnd => Cond),\n-             Then_Statements => New_List (\n-               Make_Raise_Statement (Loc,\n-                 Name => New_Occurrence_Of (RTE (RE_Assert_Failure), Loc)))));\n+      Prepend_To (Decls, Count_Decl);\n+      Analyze (Count_Decl);\n \n-      --  Case where we call the procedure\n+      --  Create the base error message for multiple overlapping case guards\n \n-      else\n-         --  If we have a message given, use it\n+      --    Msg_Str : constant String :=\n+      --                \"contract cases overlap for subprogram Subp_Id\";\n \n-         if Present (Arg3 (N)) then\n-            Msg := Get_Pragma_Arg (Arg3 (N));\n+      if Multiple_PCs then\n+         Msg_Str := Make_Temporary (Loc, 'S');\n \n-         --  Here we have no string, so prepare one\n+         Start_String;\n+         Store_String_Chars (\"contract cases overlap for subprogram \");\n+         Store_String_Chars (Get_Name_String (Chars (Subp_Id)));\n \n-         else\n-            declare\n-               Loc_Str : constant String := Build_Location_String (Loc);\n+         Error_Decls := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Msg_Str,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n+             Expression          => Make_String_Literal (Loc, End_String)));\n+      end if;\n \n-            begin\n-               Name_Len := 0;\n+      --  Process individual post cases\n \n-               --  For Assert, we just use the location\n+      Post_Case := First (Component_Associations (Aggr));\n+      while Present (Post_Case) loop\n+         Case_Guard := First (Choices (Post_Case));\n+         Conseq     := Expression (Post_Case);\n \n-               if Nam = Name_Assert then\n-                  null;\n+         --  The \"others\" choice requires special processing\n \n-               --  For predicate, we generate the string \"predicate failed\n-               --  at yyy\". We prefer all lower case for predicate.\n+         if Nkind (Case_Guard) = N_Others_Choice then\n+            Others_Flag := Make_Temporary (Loc, 'F');\n+            Others_Decl := Declaration_Of (Others_Flag);\n \n-               elsif Nam = Name_Predicate then\n-                  Add_Str_To_Name_Buffer (\"predicate failed at \");\n+            Prepend_To (Decls, Others_Decl);\n+            Analyze (Others_Decl);\n \n-               --  For special case of Precondition/Postcondition the string is\n-               --  \"failed xx from yy\" where xx is precondition/postcondition\n-               --  in all lower case. The reason for this different wording is\n-               --  that the failure is not at the point of occurrence of the\n-               --  pragma, unlike the other Check cases.\n+            --  Check possible overlap between a case guard and \"others\"\n \n-               elsif Nam_In (Nam, Name_Precondition, Name_Postcondition) then\n-                  Get_Name_String (Nam);\n-                  Insert_Str_In_Name_Buffer (\"failed \", 1);\n-                  Add_Str_To_Name_Buffer (\" from \");\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Others_Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n \n-               --  For special case of Invariant, the string is \"failed\n-               --  invariant from yy\", to be consistent with the string that is\n-               --  generated for the aspect case (the code later on checks for\n-               --  this specific string to modify it in some cases, so this is\n-               --  functionally important).\n+            --  Inspect the consequence and perform special expansion of any\n+            --  attribute 'Old and 'Result references found within.\n \n-               elsif Nam = Name_Invariant then\n-                  Add_Str_To_Name_Buffer (\"failed invariant from \");\n+            Expand_Attributes_In_Consequence\n+              (Decls  => Decls,\n+               Evals  => Old_Evals,\n+               Flag   => Others_Flag,\n+               Conseq => Conseq);\n \n-               --  For all other checks, the string is \"xxx failed at yyy\"\n-               --  where xxx is the check name with current source file casing.\n+            --  Check the corresponding consequence of \"others\"\n \n-               else\n-                  Get_Name_String (Nam);\n-                  Set_Casing (Identifier_Casing (Current_Source_File));\n-                  Add_Str_To_Name_Buffer (\" failed at \");\n-               end if;\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Others_Flag,\n+               Conseq => Conseq);\n \n-               --  In all cases, add location string\n+         --  Regular post case\n \n-               Add_Str_To_Name_Buffer (Loc_Str);\n+         else\n+            --  Create the flag which tracks the state of its associated case\n+            --  guard.\n \n-               --  Build the message\n+            Flag := Make_Temporary (Loc, 'F');\n+            Flag_Decl := Declaration_Of (Flag);\n \n-               Msg := Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len));\n-            end;\n-         end if;\n+            Prepend_To (Decls, Flag_Decl);\n+            Analyze (Flag_Decl);\n \n-         --  Now rewrite as an if statement\n+            --  The flag is set when the case guard is evaluated to True\n+            --    if Case_Guard then\n+            --       Flag  := True;\n+            --       Count := Count + 1;\n+            --    end if;\n \n-         Rewrite (N,\n-           Make_If_Statement (Loc,\n-             Condition       => Make_Op_Not (Loc, Right_Opnd => Cond),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name                   =>\n-                   New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n-                 Parameter_Associations => New_List (Relocate_Node (Msg))))));\n-      end if;\n+            If_Stmt :=\n+              Make_Implicit_If_Statement (CCs,\n+                Condition       => Relocate_Node (Case_Guard),\n+                Then_Statements => New_List (\n+                  Set (Flag),\n+                  Increment (Count)));\n \n-      Analyze (N);\n+            Append_To (Decls, If_Stmt);\n+            Analyze (If_Stmt);\n \n-      --  If new condition is always false, give a warning\n+            --  Check whether this case guard overlaps with another one\n \n-      if Warn_On_Assertion_Failure\n-        and then Nkind (N) = N_Procedure_Call_Statement\n-        and then Is_RTE (Entity (Name (N)), RE_Raise_Assert_Failure)\n-      then\n-         --  If original condition was a Standard.False, we assume that this is\n-         --  indeed intended to raise assert error and no warning is required.\n+            if Multiple_PCs and Exception_Extra_Info then\n+               Case_Guard_Error\n+                 (Decls     => Error_Decls,\n+                  Flag      => Flag,\n+                  Error_Loc => Sloc (Case_Guard),\n+                  Msg       => Msg_Str);\n+            end if;\n \n-         if Is_Entity_Name (Original_Node (Cond))\n-           and then Entity (Original_Node (Cond)) = Standard_False\n-         then\n-            return;\n+            --  Inspect the consequence and perform special expansion of any\n+            --  attribute 'Old and 'Result references found within.\n \n-         elsif Nam = Name_Assert then\n-            Error_Msg_N (\"?A?assertion will fail at run time\", N);\n-         else\n+            Expand_Attributes_In_Consequence\n+              (Decls  => Decls,\n+               Evals  => Old_Evals,\n+               Flag   => Flag,\n+               Conseq => Conseq);\n \n-            Error_Msg_N (\"?A?check will fail at run time\", N);\n+            --  The corresponding consequence of the case guard which evaluated\n+            --  to True must hold on exit from the subprogram.\n+\n+            Consequence_Error\n+              (Checks => Conseq_Checks,\n+               Flag   => Flag,\n+               Conseq => Conseq);\n          end if;\n-      end if;\n-   end Expand_Pragma_Check;\n \n-   ---------------------------------\n-   -- Expand_Pragma_Common_Object --\n-   ---------------------------------\n+         Next (Post_Case);\n+      end loop;\n \n-   --  Use a machine attribute to replicate semantic effect in DEC Ada\n+      --  Raise Assertion_Error when none of the case guards evaluate to True.\n+      --  The only exception is when we have \"others\", in which case there is\n+      --  no error because \"others\" acts as a default True.\n \n-   --    pragma Machine_Attribute (intern_name, \"common_object\", extern_name);\n+      --  Generate:\n+      --    Flag := True;\n \n-   --  For now we do nothing with the size attribute ???\n+      if Present (Others_Flag) then\n+         CG_Stmts := New_List (Set (Others_Flag));\n \n-   --  Note: Psect_Object shares this processing\n+      --  Generate:\n+      --    raise Assertion_Error with \"xxx contract cases incomplete\";\n \n-   procedure Expand_Pragma_Common_Object (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n+      else\n+         Start_String;\n+         Store_String_Chars (Build_Location_String (Loc));\n+         Store_String_Chars (\" contract cases incomplete\");\n \n-      Internal : constant Node_Id := Arg1 (N);\n-      External : constant Node_Id := Arg2 (N);\n+         CG_Stmts := New_List (\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n+             Parameter_Associations => New_List (\n+               Make_String_Literal (Loc, End_String))));\n+      end if;\n \n-      Psect : Node_Id;\n-      --  Psect value upper cased as string literal\n+      CG_Checks :=\n+        Make_Implicit_If_Statement (CCs,\n+          Condition       =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd  => New_Occurrence_Of (Count, Loc),\n+              Right_Opnd => Make_Integer_Literal (Loc, 0)),\n+          Then_Statements => CG_Stmts);\n \n-      Iloc : constant Source_Ptr := Sloc (Internal);\n-      Eloc : constant Source_Ptr := Sloc (External);\n-      Ploc : Source_Ptr;\n+      --  Detect a possible failure due to several case guards evaluating to\n+      --  True.\n \n-   begin\n-      --  Acquire Psect value and fold to upper case\n+      --  Generate:\n+      --    elsif Count > 0 then\n+      --       declare\n+      --          <Error_Decls>\n+      --       begin\n+      --          raise Assertion_Error with <Msg_Str>;\n+      --    end if;\n \n-      if Present (External) then\n-         if Nkind (External) = N_String_Literal then\n-            String_To_Name_Buffer (Strval (External));\n-         else\n-            Get_Name_String (Chars (External));\n-         end if;\n+      if Multiple_PCs then\n+         Set_Elsif_Parts (CG_Checks, New_List (\n+           Make_Elsif_Part (Loc,\n+             Condition       =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd  => New_Occurrence_Of (Count, Loc),\n+                 Right_Opnd => Make_Integer_Literal (Loc, 1)),\n \n-         Set_All_Upper_Case;\n+             Then_Statements => New_List (\n+               Make_Block_Statement (Loc,\n+                 Declarations               => Error_Decls,\n+                 Handled_Statement_Sequence =>\n+                   Make_Handled_Sequence_Of_Statements (Loc,\n+                     Statements => New_List (\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name                   =>\n+                           New_Occurrence_Of\n+                             (RTE (RE_Raise_Assert_Failure), Loc),\n+                         Parameter_Associations => New_List (\n+                           New_Occurrence_Of (Msg_Str, Loc))))))))));\n+      end if;\n \n-         Psect :=\n-           Make_String_Literal (Eloc, Strval => String_From_Name_Buffer);\n+      Append_To (Decls, CG_Checks);\n+      Analyze (CG_Checks);\n \n-      else\n-         Get_Name_String (Chars (Internal));\n-         Set_All_Upper_Case;\n-         Psect :=\n-           Make_String_Literal (Iloc, Strval => String_From_Name_Buffer);\n+      --  Once all case guards are evaluated and checked, evaluate any prefixes\n+      --  of attribute 'Old founds in the selected consequence.\n+\n+      if Present (Old_Evals) then\n+         Append_To (Decls, Old_Evals);\n+         Analyze (Old_Evals);\n       end if;\n \n-      Ploc := Sloc (Psect);\n+      --  Raise Assertion_Error when the corresponding consequence of a case\n+      --  guard that evaluated to True fails.\n \n-      --  Insert the pragma\n+      if No (Stmts) then\n+         Stmts := New_List;\n+      end if;\n \n-      Insert_After_And_Analyze (N,\n-        Make_Pragma (Loc,\n-          Chars                        => Name_Machine_Attribute,\n-          Pragma_Argument_Associations => New_List (\n-            Make_Pragma_Argument_Association (Iloc,\n-              Expression => New_Copy_Tree (Internal)),\n-            Make_Pragma_Argument_Association (Eloc,\n-              Expression =>\n-                Make_String_Literal (Sloc => Ploc, Strval => \"common_object\")),\n-            Make_Pragma_Argument_Association (Ploc,\n-              Expression => New_Copy_Tree (Psect)))));\n-   end Expand_Pragma_Common_Object;\n+      Append_To (Stmts, Conseq_Checks);\n+   end Expand_Pragma_Contract_Cases;\n \n    ---------------------------------------\n    -- Expand_Pragma_Import_Or_Interface --\n    ---------------------------------------\n \n    procedure Expand_Pragma_Import_Or_Interface (N : Node_Id) is\n-      Def_Id    : Entity_Id;\n+      Def_Id : Entity_Id;\n \n    begin\n       --  In Relaxed_RM_Semantics, support old Ada 83 style:\n@@ -1391,7 +1391,6 @@ package body Exp_Prag is\n           Pragma_Argument_Associations => New_List (\n             Make_Pragma_Argument_Association (Loc,\n               Expression => Make_Identifier (Loc, Name_Initial_Condition)),\n-\n             Make_Pragma_Argument_Association (Loc,\n               Expression => New_Copy_Tree (Expr))));\n \n@@ -1450,7 +1449,6 @@ package body Exp_Prag is\n       --  Are there other pragmas that may require this ???\n \n       Assoc := First (Pragma_Argument_Associations (N));\n-\n       while Present (Assoc) loop\n          Expand (Expression (Assoc));\n          Next (Assoc);\n@@ -1465,14 +1463,13 @@ package body Exp_Prag is\n \n    procedure Expand_Pragma_Interrupt_Priority (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n-\n    begin\n       if No (Pragma_Argument_Associations (N)) then\n          Set_Pragma_Argument_Associations (N, New_List (\n            Make_Pragma_Argument_Association (Loc,\n              Expression =>\n                Make_Attribute_Reference (Loc,\n-                 Prefix =>\n+                 Prefix         =>\n                    New_Occurrence_Of (RTE (RE_Interrupt_Priority), Loc),\n                  Attribute_Name => Name_Last))));\n       end if;\n@@ -1531,10 +1528,10 @@ package body Exp_Prag is\n \n       Last_Var : constant Node_Id := Last (Pragma_Argument_Associations (N));\n \n-      Curr_Assign : List_Id             := No_List;\n-      Flag_Id     : Entity_Id           := Empty;\n-      If_Stmt     : Node_Id             := Empty;\n-      Old_Assign  : List_Id             := No_List;\n+      Curr_Assign : List_Id   := No_List;\n+      Flag_Id     : Entity_Id := Empty;\n+      If_Stmt     : Node_Id   := Empty;\n+      Old_Assign  : List_Id   := No_List;\n       Loop_Scop   : Entity_Id;\n       Loop_Stmt   : Node_Id;\n       Variant     : Node_Id;\n@@ -1857,8 +1854,9 @@ package body Exp_Prag is\n                     Left_Opnd  =>\n                       Make_Function_Call (Loc,\n                         New_Occurrence_Of (RTE (RO_RT_To_Duration), Loc),\n-                        New_List (Make_Function_Call (Loc,\n-                          New_Occurrence_Of (RTE (RE_Clock), Loc)))),\n+                        New_List\n+                          (Make_Function_Call\n+                             (Loc, New_Occurrence_Of (RTE (RE_Clock), Loc)))),\n                     Right_Opnd  =>\n                       Unchecked_Convert_To (Standard_Duration, Arg1 (N)))))));\n "}, {"sha": "48d1c2f6b5462d8701a60d20e28b4b7d976df7ae", "filename": "gcc/ada/exp_prag.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fexp_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.ads?ref=b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@ package Exp_Prag is\n \n    procedure Expand_N_Pragma (N : Node_Id);\n \n-   procedure Expand_Contract_Cases\n+   procedure Expand_Pragma_Contract_Cases\n      (CCs     : Node_Id;\n       Subp_Id : Entity_Id;\n       Decls   : List_Id;"}, {"sha": "f7dadef57017d262d100eebe629b26bb5a906d4d", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b9eb3aa8a2f9c09ade591ed1a1edc12f0e73ed73", "patch": "@@ -8045,13 +8045,10 @@ package body Sem_Ch13 is\n                   end;\n                end if;\n \n-               --  Get name to be used for Check pragma\n+               --  Get name to be used for Check pragma. Using the original\n+               --  name ensures that 'Class case is properly handled.\n \n-               if not From_Aspect_Specification (Ritem) then\n-                  Nam := Name_Invariant;\n-               else\n-                  Nam := Chars (Identifier (Corresponding_Aspect (Ritem)));\n-               end if;\n+               Nam := Original_Aspect_Pragma_Name (Ritem);\n \n                --  Build first two arguments for Check pragma\n "}]}