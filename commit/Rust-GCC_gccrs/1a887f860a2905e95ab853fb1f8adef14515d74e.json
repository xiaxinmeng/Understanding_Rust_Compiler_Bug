{"sha": "1a887f860a2905e95ab853fb1f8adef14515d74e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4ODdmODYwYTI5MDVlOTVhYjg1M2ZiMWY4YWRlZjE0NTE1ZDc0ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-04-23T10:17:37Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2002-04-23T10:17:37Z"}, "message": "builtins.c (builtin_memset_gen_str): New function.\n\n2002-04-23  Roger Sayle  <roger@eyesopen.com>\n\n\t* builtins.c (builtin_memset_gen_str): New function.\n\t(expand_builtin_memset): Optimize the case of constant length, but\n\tunknown value.\ntestsuite:\n\t* gcc.c-torture/execute/string-opt-17.c: New test case.\n\t* gcc.c-torture/execute/memset-2.c: New test case.\n\nFrom-SVN: r52662", "tree": {"sha": "5c7e4a7521145a5c59ecb25c52fa10c1cb4acc39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c7e4a7521145a5c59ecb25c52fa10c1cb4acc39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a887f860a2905e95ab853fb1f8adef14515d74e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a887f860a2905e95ab853fb1f8adef14515d74e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a887f860a2905e95ab853fb1f8adef14515d74e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a887f860a2905e95ab853fb1f8adef14515d74e/comments", "author": null, "committer": null, "parents": [{"sha": "77adef8498fb09947e889abbacb1d2bd8ece0929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77adef8498fb09947e889abbacb1d2bd8ece0929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77adef8498fb09947e889abbacb1d2bd8ece0929"}], "stats": {"total": 458, "additions": 455, "deletions": 3}, "files": [{"sha": "571ba0375f3bdbbeaaf0c339915374a395282c8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a887f860a2905e95ab853fb1f8adef14515d74e", "patch": "@@ -1,3 +1,9 @@\n+2002-04-23  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (builtin_memset_gen_str): New function.\n+\t(expand_builtin_memset): Optimize the case of constant length, but\n+\tunknown value.\n+\n 2002-04-23  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/altivec.h (vec_step): Remove extraneous"}, {"sha": "84d47dda87b29cbac8bde367fea3943da47d5fd1", "filename": "gcc/builtins.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1a887f860a2905e95ab853fb1f8adef14515d74e", "patch": "@@ -126,6 +126,8 @@ static rtx expand_builtin_strncpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx builtin_memset_read_str\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n+static rtx builtin_memset_gen_str\tPARAMS ((PTR, HOST_WIDE_INT,\n+\t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memset\tPARAMS ((tree, rtx,\n                                                  enum machine_mode));\n static rtx expand_builtin_bzero\t\tPARAMS ((tree));\n@@ -2134,6 +2136,34 @@ builtin_memset_read_str (data, offset, mode)\n   return c_readstr (p, mode);\n }\n \n+/* Callback routine for store_by_pieces.  Return the RTL of a register\n+   containing GET_MODE_SIZE (MODE) consecutive copies of the unsigned\n+   char value given in the RTL register data.  For example, if mode is\n+   4 bytes wide, return the RTL for 0x01010101*data.  */\n+\n+static rtx\n+builtin_memset_gen_str (data, offset, mode)\n+     PTR data;\n+     HOST_WIDE_INT offset ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n+{\n+  rtx target, coeff;\n+  size_t size;\n+  char *p;\n+\n+  size = GET_MODE_SIZE (mode);\n+  if (size==1)\n+    return (rtx)data;\n+\n+  p = alloca (size);\n+  memset (p, 1, size);\n+  coeff = c_readstr (p, mode);\n+\n+  target = convert_to_mode (mode, (rtx)data, 1);\n+  target = expand_mult (mode, target, coeff, NULL_RTX, 1);\n+  return force_reg (mode, target);\n+}\n+\n /* Expand expression EXP, which is a call to the memset builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient (and in mode MODE if that's\n@@ -2175,7 +2205,34 @@ expand_builtin_memset (exp, target, mode)\n         }\n \n       if (TREE_CODE (val) != INTEGER_CST)\n-\treturn 0;\n+        {\n+          rtx val_rtx;\n+\n+          if (!host_integerp (len, 1))\n+            return 0;\n+\n+          if (optimize_size && tree_low_cst (len, 1) > 1)\n+            return 0;\n+\n+          /* Assume that we can memset by pieces if we can store the\n+           * the coefficients by pieces (in the required modes).\n+           * We can't pass builtin_memset_gen_str as that emits RTL.  */\n+          c = 1;\n+\t  if (!can_store_by_pieces (tree_low_cst (len, 1),\n+\t\t\t\t    builtin_memset_read_str,\n+                                    (PTR) &c, dest_align))\n+\t    return 0;\n+\n+          val = fold (build1 (CONVERT_EXPR, unsigned_char_type_node, val));\n+          val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n+          val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n+                               val_rtx);\n+\t  dest_mem = get_memory_rtx (dest);\n+\t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n+\t\t\t   builtin_memset_gen_str,\n+\t\t\t   (PTR)val_rtx, dest_align);\n+\t  return force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+        }\n \n       if (target_char_cast (val, &c))\n \treturn 0;"}, {"sha": "c1641dd041eb24407e61b26fac8c843d42098d80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a887f860a2905e95ab853fb1f8adef14515d74e", "patch": "@@ -1,3 +1,8 @@\n+2002-04-23  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/string-opt-17.c: New test case.\n+\t* gcc.c-torture/execute/memset-2.c: New test case.\n+\n 2002-04-23  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/6256:\n@@ -167,7 +172,7 @@\n \t* g++.dg/opt/const1.C: New test.\n \n 2002-04-10  Lars Brinkhoff  <lars@nocrew.org>\n- \n+\n \t* gcc.c-torture/execute/20020406-1.c: Declare malloc.\n \n 2002-04-10  Nathan Sidwell  <nathan@codesourcery.com>\n@@ -330,7 +335,7 @@\n 2002-03-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/init/new2.C: New test.\n-\t\n+\n 2002-03-26  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/pragma-re-2.c: Avoid empty source file warning."}, {"sha": "07c3db378af4b522645c6d92c3432554ec44824d", "filename": "gcc/testsuite/gcc.c-torture/execute/memset-2.c", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemset-2.c?ref=1a887f860a2905e95ab853fb1f8adef14515d74e", "patch": "@@ -0,0 +1,334 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Test memset with various combinations of pointer alignments and constant\n+   lengths to make sure any optimizations in the compiler are correct.\n+\n+   Written by Roger Sayle, April 22, 2002.  */\n+\n+#ifndef MAX_OFFSET\n+#define MAX_OFFSET (sizeof (long long))\n+#endif\n+\n+#ifndef MAX_COPY\n+#define MAX_COPY 15\n+#endif\n+\n+#ifndef MAX_EXTRA\n+#define MAX_EXTRA (sizeof (long long))\n+#endif\n+\n+#define MAX_LENGTH (MAX_OFFSET + MAX_COPY + MAX_EXTRA)\n+\n+static union {\n+  char buf[MAX_LENGTH];\n+  long long align_int;\n+  long double align_fp;\n+} u;\n+\n+char A = 'A';\n+\n+void reset ()\n+{\n+  int i;\n+\n+  for (i = 0; i < MAX_LENGTH; i++)\n+    u.buf[i] = 'a';\n+}\n+\n+void check (int off, int len, int ch)\n+{\n+  char *q;\n+  int i;\n+\n+  q = u.buf;\n+  for (i = 0; i < off; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+\n+  for (i = 0; i < len; i++, q++)\n+    if (*q != ch)\n+      abort ();\n+\n+  for (i = 0; i < MAX_EXTRA; i++, q++)\n+    if (*q != 'a')\n+      abort ();\n+}\n+\n+int main ()\n+{\n+  int off;\n+  char *p;\n+\n+  /* len == 1 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 1);\n+      if (p != u.buf + off) abort ();\n+      check (off, 1, '\\0');\n+\n+      p = memset (u.buf + off, A, 1);\n+      if (p != u.buf + off) abort ();\n+      check (off, 1, 'A');\n+\n+      p = memset (u.buf + off, 'B', 1);\n+      if (p != u.buf + off) abort ();\n+      check (off, 1, 'B');\n+    }\n+\n+  /* len == 2 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 2);\n+      if (p != u.buf + off) abort ();\n+      check (off, 2, '\\0');\n+\n+      p = memset (u.buf + off, A, 2);\n+      if (p != u.buf + off) abort ();\n+      check (off, 2, 'A');\n+\n+      p = memset (u.buf + off, 'B', 2);\n+      if (p != u.buf + off) abort ();\n+      check (off, 2, 'B');\n+    }\n+\n+  /* len == 3 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 3);\n+      if (p != u.buf + off) abort ();\n+      check (off, 3, '\\0');\n+\n+      p = memset (u.buf + off, A, 3);\n+      if (p != u.buf + off) abort ();\n+      check (off, 3, 'A');\n+\n+      p = memset (u.buf + off, 'B', 3);\n+      if (p != u.buf + off) abort ();\n+      check (off, 3, 'B');\n+    }\n+\n+  /* len == 4 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 4);\n+      if (p != u.buf + off) abort ();\n+      check (off, 4, '\\0');\n+\n+      p = memset (u.buf + off, A, 4);\n+      if (p != u.buf + off) abort ();\n+      check (off, 4, 'A');\n+\n+      p = memset (u.buf + off, 'B', 4);\n+      if (p != u.buf + off) abort ();\n+      check (off, 4, 'B');\n+    }\n+\n+  /* len == 5 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 5);\n+      if (p != u.buf + off) abort ();\n+      check (off, 5, '\\0');\n+\n+      p = memset (u.buf + off, A, 5);\n+      if (p != u.buf + off) abort ();\n+      check (off, 5, 'A');\n+\n+      p = memset (u.buf + off, 'B', 5);\n+      if (p != u.buf + off) abort ();\n+      check (off, 5, 'B');\n+    }\n+\n+  /* len == 6 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 6);\n+      if (p != u.buf + off) abort ();\n+      check (off, 6, '\\0');\n+\n+      p = memset (u.buf + off, A, 6);\n+      if (p != u.buf + off) abort ();\n+      check (off, 6, 'A');\n+\n+      p = memset (u.buf + off, 'B', 6);\n+      if (p != u.buf + off) abort ();\n+      check (off, 6, 'B');\n+    }\n+\n+  /* len == 7 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 7);\n+      if (p != u.buf + off) abort ();\n+      check (off, 7, '\\0');\n+\n+      p = memset (u.buf + off, A, 7);\n+      if (p != u.buf + off) abort ();\n+      check (off, 7, 'A');\n+\n+      p = memset (u.buf + off, 'B', 7);\n+      if (p != u.buf + off) abort ();\n+      check (off, 7, 'B');\n+    }\n+\n+  /* len == 8 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 8);\n+      if (p != u.buf + off) abort ();\n+      check (off, 8, '\\0');\n+\n+      p = memset (u.buf + off, A, 8);\n+      if (p != u.buf + off) abort ();\n+      check (off, 8, 'A');\n+\n+      p = memset (u.buf + off, 'B', 8);\n+      if (p != u.buf + off) abort ();\n+      check (off, 8, 'B');\n+    }\n+\n+  /* len == 9 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 9);\n+      if (p != u.buf + off) abort ();\n+      check (off, 9, '\\0');\n+\n+      p = memset (u.buf + off, A, 9);\n+      if (p != u.buf + off) abort ();\n+      check (off, 9, 'A');\n+\n+      p = memset (u.buf + off, 'B', 9);\n+      if (p != u.buf + off) abort ();\n+      check (off, 9, 'B');\n+    }\n+\n+  /* len == 10 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 10);\n+      if (p != u.buf + off) abort ();\n+      check (off, 10, '\\0');\n+\n+      p = memset (u.buf + off, A, 10);\n+      if (p != u.buf + off) abort ();\n+      check (off, 10, 'A');\n+\n+      p = memset (u.buf + off, 'B', 10);\n+      if (p != u.buf + off) abort ();\n+      check (off, 10, 'B');\n+    }\n+\n+  /* len == 11 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 11);\n+      if (p != u.buf + off) abort ();\n+      check (off, 11, '\\0');\n+\n+      p = memset (u.buf + off, A, 11);\n+      if (p != u.buf + off) abort ();\n+      check (off, 11, 'A');\n+\n+      p = memset (u.buf + off, 'B', 11);\n+      if (p != u.buf + off) abort ();\n+      check (off, 11, 'B');\n+    }\n+\n+  /* len == 12 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 12);\n+      if (p != u.buf + off) abort ();\n+      check (off, 12, '\\0');\n+\n+      p = memset (u.buf + off, A, 12);\n+      if (p != u.buf + off) abort ();\n+      check (off, 12, 'A');\n+\n+      p = memset (u.buf + off, 'B', 12);\n+      if (p != u.buf + off) abort ();\n+      check (off, 12, 'B');\n+    }\n+\n+  /* len == 13 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 13);\n+      if (p != u.buf + off) abort ();\n+      check (off, 13, '\\0');\n+\n+      p = memset (u.buf + off, A, 13);\n+      if (p != u.buf + off) abort ();\n+      check (off, 13, 'A');\n+\n+      p = memset (u.buf + off, 'B', 13);\n+      if (p != u.buf + off) abort ();\n+      check (off, 13, 'B');\n+    }\n+\n+  /* len == 14 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 14);\n+      if (p != u.buf + off) abort ();\n+      check (off, 14, '\\0');\n+\n+      p = memset (u.buf + off, A, 14);\n+      if (p != u.buf + off) abort ();\n+      check (off, 14, 'A');\n+\n+      p = memset (u.buf + off, 'B', 14);\n+      if (p != u.buf + off) abort ();\n+      check (off, 14, 'B');\n+    }\n+\n+  /* len == 15 */\n+  for (off = 0; off < MAX_OFFSET; off++)\n+    {\n+      reset ();\n+\n+      p = memset (u.buf + off, '\\0', 15);\n+      if (p != u.buf + off) abort ();\n+      check (off, 15, '\\0');\n+\n+      p = memset (u.buf + off, A, 15);\n+      if (p != u.buf + off) abort ();\n+      check (off, 15, 'A');\n+\n+      p = memset (u.buf + off, 'B', 15);\n+      if (p != u.buf + off) abort ();\n+      check (off, 15, 'B');\n+    }\n+\n+  exit (0);\n+}\n+"}, {"sha": "47fe42db62865716ff137d0a64c20c76c9cd351f", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-17.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a887f860a2905e95ab853fb1f8adef14515d74e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-17.c?ref=1a887f860a2905e95ab853fb1f8adef14515d74e", "patch": "@@ -0,0 +1,50 @@\n+/* Copyright (C) 2002  Free Software Foundation.\n+\n+   Ensure that builtin memset operations for constant length and\n+   non-constant assigned value don't cause compiler problems.\n+\n+   Written by Roger Sayle, 21 April 2002.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memset (void *, int, size_t);\n+\n+char buffer[32];\n+\n+int\n+main (int argc)\n+{\n+  memset (buffer, argc, 0);\n+  memset (buffer, argc, 1);\n+  memset (buffer, argc, 2);\n+  memset (buffer, argc, 3);\n+  memset (buffer, argc, 4);\n+  memset (buffer, argc, 5);\n+  memset (buffer, argc, 6);\n+  memset (buffer, argc, 7);\n+  memset (buffer, argc, 8);\n+  memset (buffer, argc, 9);\n+  memset (buffer, argc, 10);\n+  memset (buffer, argc, 11);\n+  memset (buffer, argc, 12);\n+  memset (buffer, argc, 13);\n+  memset (buffer, argc, 14);\n+  memset (buffer, argc, 15);\n+  memset (buffer, argc, 16);\n+  memset (buffer, argc, 17);\n+\n+  return 0;\n+}\n+\n+#ifdef __OPTIMIZE__\n+/* When optimizing, most of the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   for short lengths should abort.  */\n+static void *\n+memset (void *dst, int c, size_t len)\n+{\n+  if (len < 2)\n+    abort ();\n+}\n+#endif\n+"}]}