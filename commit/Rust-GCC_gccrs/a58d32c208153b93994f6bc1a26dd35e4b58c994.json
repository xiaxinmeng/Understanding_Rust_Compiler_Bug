{"sha": "a58d32c208153b93994f6bc1a26dd35e4b58c994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU4ZDMyYzIwODE1M2I5Mzk5NGY2YmMxYTI2ZGQzNWU0YjU4Yzk5NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-09-12T03:42:30Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-09-12T03:42:30Z"}, "message": "cppfiles.c: Move all default-#defines to top of file.\n\n\t* cppfiles.c: Move all default-#defines to top of file.\n\t(open_include_file): Replace by lookup_include_file.\n\t(read_with_read, read_file): Merged into read_include_file.\n\t(stack_include_file, purge_cache): New functions.\n\t(close_cached_fd): Delete.\n\t(lookup_include_file, read_include_file, _cpp_pop_file_buffer):\n\tCache the in-memory buffer, not the file descriptor.\n\n\t* cpphash.h (struct include_file): Add buffer, st, refcnt,\n\tmapped fields.\n\t(xcnew): New utility macro.\n\t(DO_NOT_REREAD, NEVER_REREAD): Move up by struct include_file.\n\t* cpplib.h (struct cpp_buffer): Remove mapped field.\n\n\t* cpplex.c (parse_string): Accept backslash space newline as a\n\tline continuation.\n\t(lex_line): Likewise.\n\t(_cpp_get_token): Remove hard limit on macro nesting.\n\ntestsuite:\n\t* gcc.dg/cpp/backslash.c: New test.\n\nFrom-SVN: r36347", "tree": {"sha": "b6a034134f9f646df618389e79a9becaa26938a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6a034134f9f646df618389e79a9becaa26938a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a58d32c208153b93994f6bc1a26dd35e4b58c994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58d32c208153b93994f6bc1a26dd35e4b58c994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58d32c208153b93994f6bc1a26dd35e4b58c994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58d32c208153b93994f6bc1a26dd35e4b58c994/comments", "author": null, "committer": null, "parents": [{"sha": "4ba01ed2ae8beb00e653be369f423a452ed6f363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba01ed2ae8beb00e653be369f423a452ed6f363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba01ed2ae8beb00e653be369f423a452ed6f363"}], "stats": {"total": 748, "additions": 366, "deletions": 382}, "files": [{"sha": "debb2191b28b85d16c7e4eab0d4b93000ea1eff7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -1,3 +1,26 @@\n+2000-09-11  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c: Move all default-#defines to top of file.\n+\t(open_include_file): Replace by lookup_include_file.\n+\t(read_with_read, read_file): Merged into read_include_file.\n+\t(stack_include_file, purge_cache): New functions.\n+\t(close_cached_fd): Delete.\n+\t(lookup_include_file, read_include_file, _cpp_pop_file_buffer): \n+\tCache the in-memory buffer, not the file descriptor.\n+\n+\t* cpphash.h (struct include_file): Add buffer, st, refcnt,\n+\tmapped fields.\n+\t(xcnew): New utility macro.\n+\t(DO_NOT_REREAD, NEVER_REREAD): Move up by struct include_file.\n+\t* cpplib.h (struct cpp_buffer): Remove mapped field.\n+\n+2000-09-11  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (parse_string): Accept backslash space newline as a\n+\tline continuation.\n+\t(lex_line): Likewise.\n+\t(_cpp_get_token): Remove hard limit on macro nesting.\n+\n 2000-09-12  Philipp Thomas  <pthomas@suse.de>\n \n \t* aclocal.m4 (AM_WITH_NLS): Don't force use of included gettext."}, {"sha": "7f5c731c40375f916c307d013d7ca19a6a60662c", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 262, "deletions": 334, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -43,6 +43,22 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define O_BINARY 0\n #endif\n \n+#ifndef INCLUDE_LEN_FUDGE\n+# define INCLUDE_LEN_FUDGE 0\n+#endif\n+\n+/* If errno is inspected immediately after a system call fails, it will be\n+   nonzero, and no error number will ever be zero.  */\n+#ifndef ENOENT\n+# define ENOENT 0\n+#endif\n+#ifndef ENOTDIR\n+# define ENOTDIR 0\n+#endif\n+#ifndef ENOMEM\n+# define ENOMEM 0\n+#endif\n+\n /* Suppress warning about function macros used w/o arguments in traditional\n    C.  It is unlikely that glibc's strcmp macro helps this file at all.  */\n #undef strcmp\n@@ -57,24 +73,18 @@ static struct file_name_list *actual_directory\n static struct include_file *find_include_file\n \t\t\t\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t struct file_name_list *));\n-static struct include_file *open_include_file\n+static struct include_file *lookup_include_file\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n-static ssize_t read_with_read\tPARAMS ((cpp_buffer *, int, ssize_t));\n-static ssize_t read_file\tPARAMS ((cpp_buffer *, int, ssize_t));\n-\n+static int stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n+static void purge_cache \tPARAMS ((struct include_file *));\n static void destroy_include_file_node\tPARAMS ((splay_tree_value));\n-static int close_cached_fd\t\tPARAMS ((splay_tree_node, void *));\n static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n #endif\n \n-#ifndef INCLUDE_LEN_FUDGE\n-#define INCLUDE_LEN_FUDGE 0\n-#endif\n-\n /* We use a splay tree to store information about all the include\n    files seen in this compilation.  The key of each tree node is the\n    physical path to the file.  The value is 0 if the file does not\n@@ -87,26 +97,11 @@ destroy_include_file_node (v)\n   struct include_file *f = (struct include_file *)v;\n   if (f)\n     {\n-      if (f->fd != -1)\n-\tclose (f->fd);\n+      purge_cache (f);\n       free (f);\n     }\n }\n \n-static int\n-close_cached_fd (n, dummy)\n-     splay_tree_node n;\n-     void *dummy ATTRIBUTE_UNUSED;\n-{\n-  struct include_file *f = (struct include_file *)n->value;\n-  if (f && f->fd != -1)\n-    {\n-      close (f->fd);\n-      f->fd = -1;\n-    }\n-  return 0;\n-}\n-\n void\n _cpp_init_includes (pfile)\n      cpp_reader *pfile;\n@@ -124,48 +119,24 @@ _cpp_cleanup_includes (pfile)\n   splay_tree_delete (pfile->all_include_files);\n }\n \n-/* Given a filename, look it up and possibly open it.  If the file\n-   does not exist, return NULL.  If the file does exist but doesn't\n-   need to be reread, return an include_file entry with fd == -1.\n-   If it needs to be (re)read, return an include_file entry with\n-   fd a file descriptor open on the file. */\n+/* Given a file name, look it up in the cache; if there is no entry,\n+   create one.  Returns 0 if the file doesn't exist or is\n+   inaccessible, otherwise the cache entry.  */\n \n static struct include_file *\n-open_include_file (pfile, filename)\n+lookup_include_file (pfile, filename)\n      cpp_reader *pfile;\n      const char *filename;\n-{\n+{     \n   splay_tree_node nd;\n   struct include_file *file = 0;\n   int fd;\n+  struct stat st;\n \n-  nd = splay_tree_lookup (pfile->all_include_files,\n-\t\t\t  (splay_tree_key) filename);\n+  nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) filename);\n \n   if (nd)\n-    {\n-      if (nd->value == 0)\n-\treturn 0;\n-\n-      file = (struct include_file *)nd->value;\n-\n-      if (DO_NOT_REREAD (file))\n-\t{\n-\t  if (file->fd != -1)\n-\t    {\n-\t      close (file->fd);\n-\t      file->fd = -1;\n-\t    }\n-\t  return file;\n-\t}\n-\n-      /* File descriptors are cached for files that might be reread.  */\n-      if (file->fd != -1)\n-\t{\n-\t  lseek (file->fd, 0, SEEK_SET);\n-\t  return file;\n-\t}\n-    }\n+    return (struct include_file *)nd->value;\n \n   /* We used to open files in nonblocking mode, but that caused more\n      problems than it solved.  Do take care not to acquire a\n@@ -180,67 +151,224 @@ open_include_file (pfile, filename)\n      ourselves.\n \n      Special case: the empty string is translated to stdin.  */\n- retry:\n \n   if (filename[0] == '\\0')\n     fd = 0;\n   else\n     fd = open (filename, O_RDONLY|O_NOCTTY|O_BINARY, 0666);\n-\n   if (fd == -1)\n+    goto fail;\n+\n+  if (fstat (fd, &st) < 0)\n+    goto fail;\n+  \n+  file = xcnew (struct include_file);\n+  file->name = xstrdup (filename);\n+  file->st = st;\n+  file->fd = fd;\n+\n+  /* If the file is plain and zero length, mark it never-reread now.  */\n+  if (S_ISREG (st.st_mode) && st.st_size == 0)\n+    file->cmacro = NEVER_REREAD;\n+\n+  splay_tree_insert (pfile->all_include_files,\n+\t\t     (splay_tree_key) file->name, (splay_tree_value) file);\n+  return file;\n+\n+ fail:\n+\n+  /* Don't issue an error message if the file doesn't exist.  */\n+  if (errno != ENOENT && errno != ENOTDIR)\n+    cpp_error_from_errno (pfile, filename);\n+\n+  /* Create a negative node for this path.  */\n+  splay_tree_insert (pfile->all_include_files,\n+\t\t     (splay_tree_key) xstrdup (filename), 0);\n+  return 0;\n+}\n+\n+/* Place the file referenced by INC into a new buffer on PFILE's stack.\n+   Return 1 if successful, 0 if not.  */\n+\n+static int\n+stack_include_file (pfile, inc)\n+     cpp_reader *pfile;\n+     struct include_file *inc;\n+{\n+  cpp_buffer *fp;\n+\n+  if (DO_NOT_REREAD (inc))\n+    return 0;\n+\n+  if (inc->buffer == NULL)\n+    if (read_include_file (pfile, inc) == 0)\n+      return 0;\n+\n+  fp = cpp_push_buffer (pfile, NULL, 0);\n+  if (fp == 0)\n+    return 0;\n+\n+  fp->inc = inc;\n+  fp->nominal_fname = inc->name;\n+  fp->buf = inc->buffer;\n+  fp->rlimit = fp->buf + inc->st.st_size;\n+  fp->cur = fp->buf;\n+  fp->lineno = 1;\n+  fp->line_base = fp->buf;\n+\n+  /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n+     see do_include */\n+  if (!CPP_OPTION (pfile, ignore_srcdir))\n+    fp->actual_dir = actual_directory (pfile, inc->name);\n+\n+  fp->inc->refcnt++;\n+  pfile->include_depth++;\n+  pfile->input_stack_listing_current = 0;\n+  if (pfile->cb.enter_file)\n+    (*pfile->cb.enter_file) (pfile);\n+  return 1;\n+}\n+\n+/* Read the file referenced by INC into the file cache.\n+\n+   If fd points to a plain file, we might be able to mmap it; we can\n+   definitely allocate the buffer all at once.  If fd is a pipe or\n+   terminal, we can't do either.  If fd is something weird, like a\n+   block device or a directory, we don't want to read it at all.\n+\n+   Unfortunately, different systems use different st.st_mode values\n+   for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n+   zero the entire struct stat except a couple fields.  Hence we don't\n+   even try to figure out what something is, except for plain files,\n+   directories, and block devices.\n+\n+   FIXME: Flush file cache and try again if we run out of memory.  */\n+\n+static int\n+read_include_file (pfile, inc)\n+     cpp_reader *pfile;\n+     struct include_file *inc;\n+{\n+  ssize_t size, offset, count;\n+  U_CHAR *buf;\n+#if MMAP_THRESHOLD\n+  static int pagesize = -1;\n+#endif\n+\n+  if (S_ISREG (inc->st.st_mode))\n     {\n-#ifdef EACCES\n-      if (errno == EACCES)\n+      /* off_t might have a wider range than ssize_t - in other words,\n+\t the max size of a file might be bigger than the address\n+\t space.  We can't handle a file that large.  (Anyone with\n+\t a single source file bigger than 2GB needs to rethink\n+\t their coding style.)  Some systems (e.g. AIX 4.1) define\n+\t SSIZE_MAX to be much smaller than the actual range of the\n+\t type.  Use INTTYPE_MAXIMUM unconditionally to ensure this\n+\t does not bite us.  */\n+      if (inc->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, \"included file \\\"%s\\\" exists but is not readable\",\n-\t\t     filename);\n+\t  cpp_error (pfile, \"%s is too large\", inc->name);\n+\t  goto fail;\n \t}\n+      size = inc->st.st_size;\n+\n+#if MMAP_THRESHOLD\n+      if (pagesize == -1)\n+\tpagesize = getpagesize ();\n+\n+      if (size / pagesize >= MMAP_THRESHOLD)\n+\t{\n+\t  buf = (U_CHAR *) mmap (0, size, PROT_READ, MAP_PRIVATE, inc->fd, 0);\n+\t  if (buf == (U_CHAR *)-1)\n+\t    goto perror_fail;\n+\t  inc->mapped = 1;\n+\t}\n+      else\n #endif\n-      if (0\n-#ifdef EMFILE\n-\t  || errno == EMFILE\n-#endif\n-#ifdef ENFILE\n-\t  || errno == ENFILE\n-#endif\n-\t  )\n \t{\n-\t  /* Too many files open.  Close all cached file descriptors and\n-\t     try again.  */\n-\t  splay_tree_foreach (pfile->all_include_files, close_cached_fd, 0);\n-\t  goto retry;\n+\t  buf = (U_CHAR *) xmalloc (size);\n+\t  offset = 0;\n+\t  while (offset < size)\n+\t    {\n+\t      count = read (inc->fd, buf + offset, size - offset);\n+\t      if (count < 0)\n+\t\tgoto perror_fail;\n+\t      if (count == 0)\n+\t\t{\n+\t\t  cpp_warning (pfile, \"%s is shorter than expected\", inc->name);\n+\t\t  break;\n+\t\t}\n+\t      offset += count;\n+\t    }\n+\t  inc->mapped = 0;\n+\t}\n+    }\n+  else if (S_ISBLK (inc->st.st_mode))\n+    {\n+      cpp_error (pfile, \"%s is a block device\", inc->name);\n+      goto fail;\n+    }\n+  else if (S_ISDIR (inc->st.st_mode))\n+    {\n+      cpp_error (pfile, \"%s is a directory\", inc->name);\n+      goto fail;\n+    }\n+  else\n+    {\n+      /* 8 kilobytes is a sensible starting size.  It ought to be\n+\t bigger than the kernel pipe buffer, and it's definitely\n+\t bigger than the majority of C source files.  */\n+      size = 8 * 1024;\n+\n+      buf = (U_CHAR *) xmalloc (size);\n+      offset = 0;\n+      while ((count = read (inc->fd, buf + offset, size - offset)) > 0)\n+\t{\n+\t  offset += count;\n+\t  if (offset == size)\n+\t    buf = xrealloc (buf, (size *= 2));\n \t}\n+      if (count < 0)\n+\tgoto perror_fail;\n \n-      /* Nonexistent or inaccessible file.  Create a negative node for it.  */\n-      if (nd)\n+      if (offset == 0)\n \t{\n-\t  cpp_ice (pfile,\n-\t\t   \"node for '%s' exists, open failed, error '%s', value %lx\\n\",\n-\t\t   filename, strerror (errno), nd->value);\n-\t  destroy_include_file_node (nd->value);\n+\t  free (buf);\n+\t  return 0;\n \t}\n-      splay_tree_insert (pfile->all_include_files,\n-\t\t\t (splay_tree_key) xstrdup (filename), 0);\n-      return 0;\n+\n+      if (offset < size)\n+\tbuf = xrealloc (buf, offset);\n+      inc->st.st_size = offset;\n     }\n \n-  /* If we haven't seen this file before, create a positive node for it.  */\n-  if (!nd)\n+  close (inc->fd);\n+  inc->buffer = buf;\n+  inc->fd = -1;\n+  return 1;\n+\n+ perror_fail:\n+  cpp_error_from_errno (pfile, inc->name);\n+ fail:\n+  /* Do not try to read this file again.  */\n+  close (inc->fd);\n+  inc->fd = -1;\n+  inc->cmacro = NEVER_REREAD;\n+  return 0;\n+}\n+\n+static void\n+purge_cache (inc)\n+     struct include_file *inc;\n+{\n+  if (inc->buffer)\n     {\n-      file = xnew (struct include_file);\n-      file->cmacro = 0;\n-      file->include_count = 0;\n-      file->sysp = 0;\n-      file->foundhere = 0;\n-      file->name = xstrdup (filename);\n-      splay_tree_insert (pfile->all_include_files,\n-\t\t\t (splay_tree_key) file->name,\n-\t\t\t (splay_tree_value) file);\n+      if (inc->mapped)\n+\tmunmap ((caddr_t) inc->buffer, inc->st.st_size);\n+      else\n+\tfree ((PTR) inc->buffer);\n+      inc->buffer = NULL;\n     }\n-\n-  file->fd = fd;\n-  file->date = (time_t) -1;\n-  return file;\n }\n \n /* Return 1 if the file named by FNAME has been included before in\n@@ -282,8 +410,7 @@ cpp_included (pfile, fname)\n \n /* Search for include file FNAME in the include chain starting at\n    SEARCH_START.  Return 0 if there is no such file (or it's un-openable),\n-   otherwise an include_file structure, possibly with a file descriptor\n-   open on the file.  */\n+   otherwise an include_file structure.  */\n \n static struct include_file *\n find_include_file (pfile, fname, search_start)\n@@ -296,7 +423,7 @@ find_include_file (pfile, fname, search_start)\n   struct include_file *file;\n \n   if (fname[0] == '/')\n-    return open_include_file (pfile, fname);\n+    return lookup_include_file (pfile, fname);\n       \n   /* Search directory path for the file.  */\n   name = (char *) alloca (strlen (fname) + pfile->max_include_len\n@@ -310,7 +437,7 @@ find_include_file (pfile, fname, search_start)\n       if (CPP_OPTION (pfile, remap))\n \tname = remap_filename (pfile, name, path);\n \n-      file = open_include_file (pfile, name);\n+      file = lookup_include_file (pfile, name);\n       if (file)\n \t{\n \t  file->sysp = path->sysp;\n@@ -321,9 +448,9 @@ find_include_file (pfile, fname, search_start)\n   return 0;\n }\n \n-/* #line uses this to save artificial file names.  We have to try\n-   opening the file because an all_include_files entry is always\n-   either + or -, there's no 'I don't know' value.  */\n+/* #line uses this to save artificial file names.  We have to stat the\n+   file because an all_include_files entry is always either + or -,\n+   there's no 'I don't know' value.  */\n const char *\n _cpp_fake_include (pfile, fname)\n      cpp_reader *pfile;\n@@ -335,7 +462,14 @@ _cpp_fake_include (pfile, fname)\n \n   file = find_include_file (pfile, fname, CPP_OPTION (pfile, quote_include));\n   if (file)\n-    return file->name;\n+    {\n+      if (file->fd > 0)\n+\t{\n+\t  close (file->fd);\n+\t  file->fd = -1;\n+\t}\n+      return file->name;\n+    }\n \n   name = xstrdup (fname);\n   _cpp_simplify_pathname (name);\n@@ -453,31 +587,28 @@ _cpp_execute_include (pfile, f, len, no_reinclude, search_start, angle_brackets)\n \n   if (inc)\n     {\n-      if (inc->fd == -1)\n-\treturn;\n-\n       /* For -M, add the file to the dependencies on its first inclusion. */\n       if (!inc->include_count && PRINT_THIS_DEP (pfile, angle_brackets))\n \tdeps_add_dep (pfile->deps, inc->name);\n       inc->include_count++;\n \n-      /* Handle -H option.  */\n-      if (CPP_OPTION (pfile, print_include_names))\n-\t{\n-\t  cpp_buffer *fp = CPP_BUFFER (pfile);\n-\t  while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n-\t    putc ('.', stderr);\n-\t  fprintf (stderr, \" %s\\n\", inc->name);\n-\t}\n-\n       /* Actually process the file.  */\n-      if (no_reinclude)\n-\tinc->cmacro = NEVER_REREAD;\n-  \n-      if (read_include_file (pfile, inc))\n+      if (stack_include_file (pfile, inc))\n \t{\n \t  if (angle_brackets)\n \t    pfile->system_include_depth++;\n+\n+\t  if (no_reinclude)\n+\t    inc->cmacro = NEVER_REREAD;\n+\n+\t  /* Handle -H option.  */\n+\t  if (CPP_OPTION (pfile, print_include_names))\n+\t    {\n+\t      cpp_buffer *fp = CPP_BUFFER (pfile);\n+\t      while ((fp = CPP_PREV_BUFFER (fp)) != NULL)\n+\t\tputc ('.', stderr);\n+\t      fprintf (stderr, \" %s\\n\", inc->name);\n+\t    }\n \t}\n       return;\n     }\n@@ -552,23 +683,13 @@ _cpp_compare_file_date (pfile, f, len, angle_brackets)\n   \n   if (!inc)\n     return -1;\n-  if (inc->fd >= 0)\n+  if (inc->fd > 0)\n     {\n-      struct stat source;\n-      \n-      if (fstat (inc->fd, &source) < 0)\n-        {\n-          close (inc->fd);\n-          inc->fd = -1;\n-          return -1;\n-        }\n-      inc->date = source.st_mtime;\n       close (inc->fd);\n       inc->fd = -1;\n     }\n-  if (inc->date == (time_t)-1 || current_include->date == (time_t)-1)\n-    return -1;\n-  return inc->date > current_include->date;\n+    \n+  return inc->st.st_mtime > current_include->st.st_mtime;\n }\n \n \n@@ -584,196 +705,15 @@ cpp_read_file (pfile, fname)\n   if (fname == NULL)\n     fname = \"\";\n \n-  f = open_include_file (pfile, fname);\n+  f = lookup_include_file (pfile, fname);\n \n   if (f == NULL)\n     {\n       cpp_error_from_errno (pfile, fname);\n       return 0;\n     }\n \n-  return read_include_file (pfile, f);\n-}\n-\n-/* Read the file referenced by INC into a new buffer on PFILE's stack.\n-   Return 1 if successful, 0 if not.  */\n-\n-static int\n-read_include_file (pfile, inc)\n-     cpp_reader *pfile;\n-     struct include_file *inc;\n-{\n-  struct stat st;\n-  ssize_t length;\n-  cpp_buffer *fp;\n-  int fd = inc->fd;\n-\n-  fp = cpp_push_buffer (pfile, NULL, 0);\n-\n-  if (fp == 0)\n-    goto push_fail;\n-\n-  if (fd < 0 || fstat (fd, &st) < 0)\n-    goto perror_fail;\n-  \n-  /* These must be set right away.  */\n-  inc->date = st.st_mtime;\n-  fp->inc = inc;\n-  fp->nominal_fname = inc->name;\n-\n-  /* If fd points to a plain file, we might be able to mmap it; we can\n-     definitely allocate the buffer all at once.  If fd is a pipe or\n-     terminal, we can't do either.  If fd is something weird, like a\n-     block device or a directory, we don't want to read it at all.\n-\n-     Unfortunately, different systems use different st.st_mode values\n-     for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n-     zero the entire struct stat except a couple fields.  Hence we don't\n-     even try to figure out what something is, except for plain files,\n-     directories, and block devices.  */\n-\n-  if (S_ISREG (st.st_mode))\n-    {\n-      ssize_t st_size;\n-\n-      /* off_t might have a wider range than ssize_t - in other words,\n-\t the max size of a file might be bigger than the address\n-\t space.  We can't handle a file that large.  (Anyone with\n-\t a single source file bigger than 2GB needs to rethink\n-\t their coding style.)  Some systems (e.g. AIX 4.1) define\n-\t SSIZE_MAX to be much smaller than the actual range of the\n-\t type.  Use INTTYPE_MAXIMUM unconditionally to ensure this\n-\t does not bite us.  */\n-      if (st.st_size > INTTYPE_MAXIMUM (ssize_t))\n-\t{\n-\t  cpp_error (pfile, \"%s is too large\", inc->name);\n-\t  goto fail;\n-\t}\n-      st_size = st.st_size;\n-      length = read_file (fp, fd, st_size);\n-      if (length == -1)\n-\tgoto perror_fail;\n-      if (length < st_size)\n-\tcpp_warning (pfile, \"%s is shorter than expected\\n\", inc->name);\n-    }\n-  else if (S_ISBLK (st.st_mode))\n-    {\n-      cpp_error (pfile, \"%s is a block device\", inc->name);\n-      goto fail;\n-    }\n-  else if (S_ISDIR (st.st_mode))\n-    {\n-      cpp_error (pfile, \"%s is a directory\", inc->name);\n-      goto fail;\n-    }\n-  else\n-    {\n-      /* 8 kilobytes is a sensible starting size.  It ought to be\n-\t bigger than the kernel pipe buffer, and it's definitely\n-\t bigger than the majority of C source files.  */\n-      length = read_with_read (fp, fd, 8 * 1024);\n-      if (length == -1)\n-\tgoto perror_fail;\n-    }\n-\n-  if (length == 0)\n-    inc->cmacro = NEVER_REREAD;\n-\n-  fp->rlimit = fp->buf + length;\n-  fp->cur = fp->buf;\n-  fp->lineno = 1;\n-  fp->line_base = fp->buf;\n-\n-  /* The ->actual_dir field is only used when ignore_srcdir is not in effect;\n-     see do_include */\n-  if (!CPP_OPTION (pfile, ignore_srcdir))\n-    fp->actual_dir = actual_directory (pfile, inc->name);\n-\n-  pfile->include_depth++;\n-  pfile->input_stack_listing_current = 0;\n-  if (pfile->cb.enter_file)\n-    (*pfile->cb.enter_file) (pfile);\n-  return 1;\n-\n- perror_fail:\n-  cpp_error_from_errno (pfile, inc->name);\n-  /* Do not try to read this file again.  */\n-  if (fd != -1)\n-    close (fd);\n-  inc->fd = -1;\n-  inc->cmacro = NEVER_REREAD;\n- fail:\n-  cpp_pop_buffer (pfile);\n- push_fail:\n-  return 0;\n-}\n-\n-static ssize_t\n-read_file (fp, fd, size)\n-     cpp_buffer *fp;\n-     int fd;\n-     ssize_t size;\n-{\n-  static int pagesize = -1;\n-\n-  if (size == 0)\n-    return 0;\n-\n-  if (pagesize == -1)\n-    pagesize = getpagesize ();\n-\n-#if MMAP_THRESHOLD\n-  if (size / pagesize >= MMAP_THRESHOLD)\n-    {\n-      const U_CHAR *result\n-\t= (const U_CHAR *) mmap (0, size, PROT_READ, MAP_PRIVATE, fd, 0);\n-      if (result != (const U_CHAR *)-1)\n-\t{\n-\t  fp->buf = result;\n-\t  fp->mapped = 1;\n-\t  return size;\n-\t}\n-    }\n-  /* If mmap fails, try read.  If there's really a problem, read will\n-     fail too.  */\n-#endif\n-\n-  return read_with_read (fp, fd, size);\n-}\n-\n-static ssize_t\n-read_with_read (fp, fd, size)\n-     cpp_buffer *fp;\n-     int fd;\n-     ssize_t size;\n-{\n-  ssize_t offset, count;\n-  U_CHAR *buf;\n-\n-  buf = (U_CHAR *) xmalloc (size);\n-  offset = 0;\n-  while ((count = read (fd, buf + offset, size - offset)) > 0)\n-    {\n-      offset += count;\n-      if (offset == size)\n-\tbuf = xrealloc (buf, (size *= 2));\n-    }\n-  if (count < 0)\n-    {\n-      free (buf);\n-      return -1;\n-    }\n-  if (offset == 0)\n-    {\n-      free (buf);\n-      return 0;\n-    }\n-\n-  if (offset < size)\n-    buf = xrealloc (buf, offset);\n-  fp->buf = buf;\n-  fp->mapped = 0;\n-  return offset;\n+  return stack_include_file (pfile, f);\n }\n \n /* Do appropriate cleanup when a file buffer is popped off the input\n@@ -797,21 +737,9 @@ _cpp_pop_file_buffer (pfile, buf)\n     }\n   pfile->input_stack_listing_current = 0;\n \n-  /* Discard file buffer.  XXX Would be better to cache these instead\n-     of the file descriptors.  */\n-#ifdef HAVE_MMAP_FILE\n-  if (buf->mapped)\n-    munmap ((caddr_t) buf->buf, buf->rlimit - buf->buf);\n-  else\n-#endif\n-    free ((PTR) buf->buf);\n-\n-  /* If the file will not be included again, close it.  */\n-  if (DO_NOT_REREAD (inc))\n-    {\n-      close (inc->fd);\n-      inc->fd = -1;\n-    }\n+  inc->refcnt--;\n+  if (inc->refcnt == 0 && DO_NOT_REREAD (inc))\n+    purge_cache (inc);\n }\n \n /* The file_name_map structure holds a mapping of file names for a"}, {"sha": "41d5b9e5a7f13dd08607f2a21c3c2302c1718679", "filename": "gcc/cpphash.h", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -115,12 +115,24 @@ struct include_file\n   const struct file_name_list *foundhere;\n \t\t\t\t/* location in search path where file was\n \t\t\t\t   found, for #include_next */\n-  int fd;\t\t\t/* file descriptor possibly open on file */\n+  const unsigned char *buffer;\t/* pointer to cached file contents */\n+  struct stat st;\t\t/* copy of stat(2) data for file */\n+  int fd;\t\t\t/* fd open on file (short term storage only) */\n   unsigned short include_count;\t/* number of times file has been read */\n-  unsigned short sysp;\t\t/* file is a system header */\n-  time_t  date;                 /* modification date of file, if known */\n+  unsigned short refcnt;\t/* number of stacked buffers using this file */\n+  unsigned char sysp;\t\t/* file is a system header */\n+  unsigned char mapped;\t\t/* file buffer is mmapped */\n };\n \n+/* The cmacro works like this: If it's NULL, the file is to be\n+   included again.  If it's NEVER_REREAD, the file is never to be\n+   included again.  Otherwise it is a macro hashnode, and the file is\n+   to be included again if the macro is not defined.  */\n+#define NEVER_REREAD ((const cpp_hashnode *)-1)\n+#define DO_NOT_REREAD(inc) \\\n+((inc)->cmacro && \\\n+ ((inc)->cmacro == NEVER_REREAD || (inc)->cmacro->type != T_VOID))\n+\n /* Special nodes - identifiers with predefined significance.\n    Note that the array length of dirs[] must be kept in sync with\n    cpplib.c's dtable[].  */\n@@ -133,16 +145,6 @@ struct spec_nodes\n   cpp_hashnode *dirs[19];\t\t/* 19 directives counting #sccs */\n };\n \n-\n-/* The cmacro works like this: If it's NULL, the file is to be\n-   included again.  If it's NEVER_REREAD, the file is never to be\n-   included again.  Otherwise it is a macro hashnode, and the file is\n-   to be included again if the macro is not defined.  */\n-#define NEVER_REREAD ((const cpp_hashnode *)-1)\n-#define DO_NOT_REREAD(inc) \\\n-((inc)->cmacro && \\\n- ((inc)->cmacro == NEVER_REREAD || (inc)->cmacro->type != T_VOID))\n-\n /* Character classes.\n    If the definition of `numchar' looks odd to you, please look up the\n    definition of a pp-number in the C standard [section 6.4.8 of C99].\n@@ -293,6 +295,7 @@ extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n+#define xcnew(T)\t(T *) xcalloc (1, sizeof(T))\n #define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n #define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n #define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))"}, {"sha": "5cb6b7f7611f3c25b0513f3e43732b1b8ad62571", "filename": "gcc/cpplex.c", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -1106,12 +1106,23 @@ parse_string (pfile, list, token, terminator)\n \t  if (is_vspace (c))\n \t    {\n \t      /* Drop a backslash newline, and continue. */\n+\t      U_CHAR *old = namebuf;\n+\t      while (namebuf > list->namebuf && is_hspace (namebuf[-1]))\n+\t\tnamebuf--;\n \t      if (namebuf > list->namebuf && namebuf[-1] == '\\\\')\n \t\t{\n \t\t  handle_newline (cur, buffer->rlimit, c);\n \t\t  namebuf--;\n+\t\t  if (old[-1] != '\\\\')\n+\t\t    {\n+\t\t      buffer->cur = cur;\n+\t\t      cpp_warning (pfile,\n+\t\t\t\t   \"backslash and newline separated by space\");\n+\t\t    }\n \t\t  continue;\n \t\t}\n+\t      else\n+\t\tnamebuf = old;\n \n \t      cur--;\n \n@@ -1516,37 +1527,40 @@ lex_line (pfile, list)\n \t  handle_newline (cur, buffer->rlimit, c);\n \t  if (PREV_TOKEN_TYPE == CPP_BACKSLASH)\n \t    {\n-\t      if (IMMED_TOKEN ())\n-\t\t{\n-\t\t  /* Remove the escaped newline.  Then continue to process\n-\t\t     any interrupted name or number.  */\n-\t\t  cur_token--;\n-\t\t  /* Backslash-newline may not be immediately followed by\n-\t\t     EOF (C99 5.1.1.2).  */\n-\t\t  if (cur >= buffer->rlimit)\n-\t\t    {\n-\t\t      cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n-\t\t      break;\n-\t\t    }\n-\t\t  if (IMMED_TOKEN ())\n-\t\t    {\n-\t\t      cur_token--;\n-\t\t      if (cur_token->type == CPP_NAME)\n-\t\t\tgoto continue_name;\n-\t\t      else if (cur_token->type == CPP_NUMBER)\n-\t\t\tgoto continue_number;\n-\t\t      cur_token++;\n-\t\t    }\n-\t\t  /* Remember whitespace setting.  */\n-\t\t  flags = cur_token->flags;\n-\t\t  break;\n-\t\t}\n-\t      else\n+\t      /* backslash space newline is still treated as backslash-newline;\n+\t\t we think this is standard conforming, with some reservations\n+\t\t about actually _using_ the weasel words in C99 5.1.1.2\n+\t\t (translation phase 1 is allowed to do whatever it wants to\n+\t\t your input as long as it's documented).  */\n+\t      if (! IMMED_TOKEN ())\n \t\t{\n \t\t  buffer->cur = cur;\n \t\t  cpp_warning (pfile,\n \t\t\t       \"backslash and newline separated by space\");\n \t\t}\n+\t      \n+\t      /* Remove the escaped newline.  Then continue to process\n+\t\t any interrupted name or number.  */\n+\t      cur_token--;\n+\t      /* Backslash-newline may not be immediately followed by\n+\t\t EOF (C99 5.1.1.2).  */\n+\t      if (cur >= buffer->rlimit)\n+\t\t{\n+\t\t  cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n+\t\t  break;\n+\t\t}\n+\t      if (IMMED_TOKEN ())\n+\t\t{\n+\t\t  cur_token--;\n+\t\t  if (cur_token->type == CPP_NAME)\n+\t\t    goto continue_name;\n+\t\t  else if (cur_token->type == CPP_NUMBER)\n+\t\t    goto continue_number;\n+\t\t  cur_token++;\n+\t\t}\n+\t      /* Remember whitespace setting.  */\n+\t      flags = cur_token->flags;\n+\t      break;\n \t    }\n \t  else if (MIGHT_BE_DIRECTIVE ())\n \t    {\n@@ -3187,12 +3201,6 @@ _cpp_get_token (pfile)\n       if (is_macro_disabled (pfile, node->value.expansion, token))\n \treturn token;\n \n-      if (pfile->cur_context > CPP_STACK_MAX)\n-\t{\n-\t  cpp_error (pfile, \"macros nested too deep invoking '%s'\", node->name);\n-\t  return token;\n-\t}\n-\n       if (push_macro_context (pfile, token))\n \treturn token;\n       /* else loop */"}, {"sha": "9793bc0e92228494ecc6a22bc4de8f82cbabd7bb", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -246,9 +246,6 @@ struct cpp_buffer\n      or for -Wtraditional, and only once per file (otherwise it would\n      be far too noisy).  */\n   char warned_cplusplus_comments;\n-\n-  /* True if this buffer's data is mmapped.  */\n-  char mapped;\n };\n \n struct file_name_map_list;"}, {"sha": "d654affba1c845c6d5bc63417e47d8d41b3125e1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -1,3 +1,7 @@\n+2000-09-11  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* gcc.dg/cpp/backslash.c: New test.\n+\n 2000-09-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* gcc.c-torture/execute/20000910-1.c: New test."}, {"sha": "f1b094a0b844d0b040f2d956ad82f14ae10edd8f", "filename": "gcc/testsuite/gcc.dg/cpp/backslash.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbackslash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a58d32c208153b93994f6bc1a26dd35e4b58c994/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbackslash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fbackslash.c?ref=a58d32c208153b93994f6bc1a26dd35e4b58c994", "patch": "@@ -0,0 +1,21 @@\n+/* Test backslash newline with and without trailing spaces.  */\n+\n+#define alpha(a, b, c) \\\n+\ta, \\\n+\tb, \\\n+\tc\n+\n+/* Note the trailing whitespace on the next three lines.  */\n+#define beta(a, b, c) \\ \n+\ta, \\\t\n+\tb, \\ \t\n+\tc\n+\n+/* { dg-warning \"separated by space\" \"space\" { target *-*-* } 9 } */\n+/* { dg-warning \"separated by space\" \"tab\" { target *-*-* } 10 } */\n+/* { dg-warning \"separated by space\" \"space and tab\" { target *-*-* } 11 } */\n+\n+int x[] = {\n+   alpha(1, 2, 3),\n+   beta(4, 5, 6)\n+};"}]}