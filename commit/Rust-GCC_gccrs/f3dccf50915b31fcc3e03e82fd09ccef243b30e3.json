{"sha": "f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNkY2NmNTA5MTViMzFmY2MzZTAzZTgyZmQwOWNjZWYyNDNiMzBlMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-24T09:24:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-24T09:24:26Z"}, "message": "re PR tree-optimization/55334 (mgrid regression (ipa-cp disables vectorization))\n\n2014-11-24  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/55334\n\t* function.h (struct function): Add last_clique member.\n\t* tree-inline.c (remap_dependence_clique): New function.\n\t(remap_gimple_op_r): Remap dependence cliques in MEM_REFs.\n\t(copy_tree_body_r): Likewise.\n\t(copy_cfg_body): Free dependence map.\n\t(copy_gimple_seq_and_replace_locals): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Dump\n\tdependence info.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Use dependence info\n\tto answer alias query.\n\t* tree-ssa-structalias.c: Include tree-phinodes.h, ssa-iterators.h,\n\ttree-pretty-print.h and gimple-walk.h.\n\t(struct variable_info): Add is_restrict_var flag and ruid\n\tmember.\n\t(new_var_info): Initialize is_restrict_var.\n\t(make_constraint_from_restrict): Likewise.\n\t(create_variable_info_for): Exclude restricts from global vars\n\tfrom new handling.\n\t(intra_create_variable_infos): But not those from parameters.\n\t(visit_loadstore): New function.\n\t(maybe_set_dependence_info): Likewise.\n\t(compute_dependence_clique): Likewise.\n\t(compute_may_aliases): Call compute_dependence_clique.\n\t* tree-data-ref.c (dr_analyze_indices): Copy dependence info\n\tto fake MEM_REF.\n\t(dr_may_alias_p): Use recorded dependence info to answer\n\talias query.\n\t* tree-core.h (struct tree_base): Add clique, base struct in\n\tunion.\n\t* tree.h (MR_DEPENDENCE_CLIQUE): New macro.\n\t(MR_DEPENDENCE_BASE): Likewise.\n\t* tree-inline.h (dependence_hasher): New hash-map kind.\n\t(struct copy_body_data): Add dependence_map pointer.\n\t* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Avoid\n\tthrowing away dependence info.\n\t* tree-streamer-in.c (unpack_value_fields): Stream dependence info.\n\t* tree-streamer-out.c (streamer_pack_tree_bitfields): Likewise.\n\n\t* gcc.dg/tree-ssa/restrict-5.c: New testcase.\n\nFrom-SVN: r218004", "tree": {"sha": "0be6bb876980671d95c871e28f5d9cd9ae32a175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0be6bb876980671d95c871e28f5d9cd9ae32a175"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f901c12f41dd917c47f10cf7ba85e5884b04882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f901c12f41dd917c47f10cf7ba85e5884b04882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f901c12f41dd917c47f10cf7ba85e5884b04882"}], "stats": {"total": 231, "additions": 226, "deletions": 5}, "files": [{"sha": "d9507500dd4788c33237319a87787912d61d7ac3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -1,3 +1,44 @@\n+2014-11-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55334\n+\t* function.h (struct function): Add last_clique member.\n+\t* tree-inline.c (remap_dependence_clique): New function.\n+\t(remap_gimple_op_r): Remap dependence cliques in MEM_REFs.\n+\t(copy_tree_body_r): Likewise.\n+\t(copy_cfg_body): Free dependence map.\n+\t(copy_gimple_seq_and_replace_locals): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Dump\n+\tdependence info.\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Use dependence info\n+\tto answer alias query.\n+\t* tree-ssa-structalias.c: Include tree-phinodes.h, ssa-iterators.h,\n+\ttree-pretty-print.h and gimple-walk.h.\n+\t(struct variable_info): Add is_restrict_var flag and ruid\n+\tmember.\n+\t(new_var_info): Initialize is_restrict_var.\n+\t(make_constraint_from_restrict): Likewise.\n+\t(create_variable_info_for): Exclude restricts from global vars\n+\tfrom new handling.\n+\t(intra_create_variable_infos): But not those from parameters.\n+\t(visit_loadstore): New function.\n+\t(maybe_set_dependence_info): Likewise.\n+\t(compute_dependence_clique): Likewise.\n+\t(compute_may_aliases): Call compute_dependence_clique.\n+\t* tree-data-ref.c (dr_analyze_indices): Copy dependence info\n+\tto fake MEM_REF.\n+\t(dr_may_alias_p): Use recorded dependence info to answer\n+\talias query.\n+\t* tree-core.h (struct tree_base): Add clique, base struct in\n+\tunion.\n+\t* tree.h (MR_DEPENDENCE_CLIQUE): New macro.\n+\t(MR_DEPENDENCE_BASE): Likewise.\n+\t* tree-inline.h (dependence_hasher): New hash-map kind.\n+\t(struct copy_body_data): Add dependence_map pointer.\n+\t* gimple-fold.c (maybe_canonicalize_mem_ref_addr): Avoid\n+\tthrowing away dependence info.\n+\t* tree-streamer-in.c (unpack_value_fields): Stream dependence info.\n+\t* tree-streamer-out.c (streamer_pack_tree_bitfields): Likewise.\n+\n 2014-11-23  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/53976"}, {"sha": "a93090164ee87df6bc741627dd333aa399915594", "filename": "gcc/function.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -589,6 +589,9 @@ struct GTY(()) function {\n      a string describing the reason for failure.  */\n   const char * GTY((skip)) cannot_be_copied_reason;\n \n+  /* Last assigned dependence info clique.  */\n+  unsigned short last_clique;\n+\n   /* Collected bit flags.  */\n \n   /* Number of units of general registers that need saving in stdarg"}, {"sha": "91b9b0c12827444fed74c47cba6e6adb9e66926f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -3062,7 +3062,8 @@ maybe_canonicalize_mem_ref_addr (tree *t)\n      accessed is a decl that has the same access semantics as the MEM_REF.  */\n   if (TREE_CODE (*t) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR\n-      && integer_zerop (TREE_OPERAND (*t, 1)))\n+      && integer_zerop (TREE_OPERAND (*t, 1))\n+      && MR_DEPENDENCE_CLIQUE (*t) == 0)\n     {\n       tree decl = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n       tree alias_type = TREE_TYPE (TREE_OPERAND (*t, 1));"}, {"sha": "363e26d42d4fceca30559afa80b0e3eee4c2c003", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -1,3 +1,8 @@\n+2014-11-24  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/55334\n+\t* gcc.dg/tree-ssa/restrict-5.c: New testcase.\n+\n 2014-11-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt45.adb: New test."}, {"sha": "d6c240aae0340ad380bada2a92e28d2de790e222", "filename": "gcc/testsuite/gcc.dg/tree-ssa/restrict-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-5.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-strict-aliasing -fdump-tree-lim1-details\" } */\n+\n+static inline __attribute__((always_inline))\n+void f(int * __restrict__ r,\n+       int a[__restrict__ 16][16],\n+       int b[__restrict__ 16][16],\n+       int i, int j)\n+{\n+  int x;\n+  *r = 0;\n+  for (x = 1; x < 16; ++x)\n+    *r = *r + a[i][x] * b[x][j];\n+}\n+\n+void g(int *r, int a[16][16], int b[16][16], int i, int j)\n+{\n+  f (r, a, b, i ,j);\n+}\n+\n+/* We should apply store motion to the store to *r.  */\n+\n+/* { dg-final { scan-tree-dump \"Executing store motion of \\\\\\*r\" \"lim1\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "0d122307456ec627c9145266583a402b35453912", "filename": "gcc/tree-core.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -820,6 +820,16 @@ struct GTY(()) tree_base {\n \n     /* Internal function code.  */\n     enum internal_fn ifn;\n+\n+    /* The following two fields are used for MEM_REF and TARGET_MEM_REF\n+       expression trees and specify known data non-dependences.  For\n+       two memory references in a function they are known to not\n+       alias if dependence_info.clique are equal and dependence_info.base\n+       are distinct.  */\n+    struct {\n+      unsigned short clique;\n+      unsigned short base;\n+    } dependence_info;\n   } GTY((skip(\"\"))) u;\n };\n "}, {"sha": "909751c8ff3a31f25da419a9afc9126a92fb72a1", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -991,9 +991,12 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n \t     guaranteed.\n \t     As a band-aid, mark the access so we can special-case\n \t     it in dr_may_alias_p.  */\n+\t  tree old = ref;\n \t  ref = fold_build2_loc (EXPR_LOCATION (ref),\n \t\t\t\t MEM_REF, TREE_TYPE (ref),\n \t\t\t\t base, memoff);\n+\t  MR_DEPENDENCE_CLIQUE (ref) = MR_DEPENDENCE_CLIQUE (old);\n+\t  MR_DEPENDENCE_BASE (ref) = MR_DEPENDENCE_BASE (old);\n \t  access_fns.safe_push (access_fn);\n \t}\n     }\n@@ -1400,6 +1403,12 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n \treturn false;\n     }\n \n+  if ((TREE_CODE (addr_a) == MEM_REF || TREE_CODE (addr_a) == TARGET_MEM_REF)\n+      && (TREE_CODE (addr_b) == MEM_REF || TREE_CODE (addr_b) == TARGET_MEM_REF)\n+      && MR_DEPENDENCE_CLIQUE (addr_a) == MR_DEPENDENCE_CLIQUE (addr_b)\n+      && MR_DEPENDENCE_BASE (addr_a) != MR_DEPENDENCE_BASE (addr_b))\n+    return false;\n+\n   /* If we had an evolution in a pointer-based MEM_REF BASE_OBJECT we\n      do not know the size of the base-object.  So we cannot do any\n      offset/overlap based analysis but have to rely on points-to"}, {"sha": "d4864ae27317161eccf3679b0558c18ae61abe02", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -849,6 +849,24 @@ is_parm (tree decl)\n   return (TREE_CODE (decl) == PARM_DECL);\n }\n \n+/* Remap the dependence CLIQUE from the source to the destination function\n+   as specified in ID.  */\n+\n+static unsigned short\n+remap_dependence_clique (copy_body_data *id, unsigned short clique)\n+{\n+  if (clique == 0)\n+    return 0;\n+  if (!id->dependence_map)\n+    id->dependence_map\n+      = new hash_map<unsigned short, unsigned short, dependence_hasher>;\n+  bool existed;\n+  unsigned short &newc = id->dependence_map->get_or_insert (clique, &existed);\n+  if (!existed)\n+    newc = ++cfun->last_clique;\n+  return newc;\n+}\n+\n /* Remap the GIMPLE operand pointed to by *TP.  DATA is really a\n    'struct walk_stmt_info *'.  DATA->INFO is a 'copy_body_data *'.\n    WALK_SUBTREES is used to indicate walk_gimple_op whether to keep\n@@ -947,6 +965,12 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  if (MR_DEPENDENCE_CLIQUE (old) != 0)\n+\t    {\n+\t      MR_DEPENDENCE_CLIQUE (*tp)\n+\t        = remap_dependence_clique (id, MR_DEPENDENCE_CLIQUE (old));\n+\t      MR_DEPENDENCE_BASE (*tp) = MR_DEPENDENCE_BASE (old);\n+\t    }\n \t  /* We cannot propagate the TREE_THIS_NOTRAP flag if we have\n \t     remapped a parameter as the property might be valid only\n \t     for the parameter itself.  */\n@@ -1198,6 +1222,12 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t  TREE_SIDE_EFFECTS (*tp) = TREE_SIDE_EFFECTS (old);\n \t  TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t  if (MR_DEPENDENCE_CLIQUE (old) != 0)\n+\t    {\n+\t      MR_DEPENDENCE_CLIQUE (*tp)\n+\t\t= remap_dependence_clique (id, MR_DEPENDENCE_CLIQUE (old));\n+\t      MR_DEPENDENCE_BASE (*tp) = MR_DEPENDENCE_BASE (old);\n+\t    }\n \t  /* We cannot propagate the TREE_THIS_NOTRAP flag if we have\n \t     remapped a parameter as the property might be valid only\n \t     for the parameter itself.  */\n@@ -2762,6 +2792,11 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       delete id->eh_map;\n       id->eh_map = NULL;\n     }\n+  if (id->dependence_map)\n+    {\n+      delete id->dependence_map;\n+      id->dependence_map = NULL;\n+    }\n \n   return new_fndecl;\n }\n@@ -5147,6 +5182,11 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   delete id.decl_map;\n   if (id.debug_map)\n     delete id.debug_map;\n+  if (id.dependence_map)\n+    {\n+      delete id.dependence_map;\n+      id.dependence_map = NULL;\n+    }\n \n   return copy;\n }"}, {"sha": "3271ba434e433636d2924c4a6d1bdc7695021eba", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -37,6 +37,26 @@ enum copy_body_cge_which\n   CB_CGE_MOVE_CLONES\n };\n \n+struct dependence_hasher : default_hashmap_traits\n+{\n+  template<typename T>\n+  static void\n+  mark_deleted (T &e)\n+    { gcc_unreachable (); }\n+\n+  template<typename T>\n+  static void\n+  mark_empty (T &e)\n+    { e.m_key = 0; }\n+\n+  template<typename T>\n+  static bool\n+  is_deleted (T &)\n+    { return false; }\n+\n+  template<typename T> static bool is_empty (T &e) { return e.m_key == 0; }\n+};\n+\n /* Data required for function body duplication.  */\n \n struct copy_body_data\n@@ -144,6 +164,10 @@ struct copy_body_data\n   /* Cilk keywords currently need to replace some variables that\n      ordinary nested functions do not.  */ \n   bool remap_var_for_cilk;\n+\n+  /* A map from the inlined functions dependence info cliques to\n+     equivalents in the function into which it is being inlined.  */\n+  hash_map<unsigned short, unsigned short, dependence_hasher> *dependence_map;\n };\n \n /* Weights of constructions for estimate_num_insns.  */"}, {"sha": "df72abb64cd3b0e199f4f5e142316fde90591847", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -1093,7 +1093,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t    /* Same value types ignoring qualifiers.  */\n \t    && (TYPE_MAIN_VARIANT (TREE_TYPE (node))\n \t\t== TYPE_MAIN_VARIANT\n-\t\t    (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 1))))))\n+\t\t    (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 1)))))\n+\t    && (!(flags & TDF_ALIAS)\n+\t\t|| MR_DEPENDENCE_CLIQUE (node) == 0))\n \t  {\n \t    if (TREE_CODE (TREE_OPERAND (node, 0)) != ADDR_EXPR)\n \t      {\n@@ -1124,6 +1126,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t\tdump_generic_node (buffer, TREE_OPERAND (node, 1),\n \t\t\t\t   spc, flags, false);\n \t      }\n+\t    if ((flags & TDF_ALIAS)\n+\t\t&& MR_DEPENDENCE_CLIQUE (node) != 0)\n+\t      {\n+\t\tpp_string (buffer, \" clique \");\n+\t\tpp_unsigned_wide_integer (buffer, MR_DEPENDENCE_CLIQUE (node));\n+\t\tpp_string (buffer, \" base \");\n+\t\tpp_unsigned_wide_integer (buffer, MR_DEPENDENCE_BASE (node));\n+\t      }\n \t    pp_right_bracket (buffer);\n \t  }\n \tbreak;\n@@ -1462,7 +1472,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t\t  /* Same value types ignoring qualifiers.  */\n \t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (op0))\n \t\t      == TYPE_MAIN_VARIANT\n-\t\t          (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 1))))))))\n+\t\t          (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 1)))))\n+\t\t  && MR_DEPENDENCE_CLIQUE (op0) == 0)))\n \t{\n \t  op0 = TREE_OPERAND (op0, 0);\n \t  str = \"->\";"}, {"sha": "17e84149c7aa66adfa0eccf0367d3e21574f4e43", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -1384,6 +1384,34 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return decl_refs_may_alias_p (ref1->ref, base1, offset1, max_size1,\n \t\t\t\t  ref2->ref, base2, offset2, max_size2);\n \n+  /* Handle restrict based accesses.\n+     ???  ao_ref_base strips inner MEM_REF [&decl], recover from that\n+     here.  */\n+  tree rbase1 = base1;\n+  tree rbase2 = base2;\n+  if (var1_p)\n+    {\n+      rbase1 = ref1->ref;\n+      if (rbase1)\n+\twhile (handled_component_p (rbase1))\n+\t  rbase1 = TREE_OPERAND (rbase1, 0);\n+    }\n+  if (var2_p)\n+    {\n+      rbase2 = ref2->ref;\n+      if (rbase2)\n+\twhile (handled_component_p (rbase2))\n+\t  rbase2 = TREE_OPERAND (rbase2, 0);\n+    }\n+  if (rbase1 && rbase2\n+      && (TREE_CODE (base1) == MEM_REF || TREE_CODE (base1) == TARGET_MEM_REF)\n+      && (TREE_CODE (base2) == MEM_REF || TREE_CODE (base2) == TARGET_MEM_REF)\n+      /* If the accesses are in the same restrict clique... */\n+      && MR_DEPENDENCE_CLIQUE (base1) == MR_DEPENDENCE_CLIQUE (base2)\n+      /* But based on different pointers they do not alias.  */\n+      && MR_DEPENDENCE_BASE (base1) != MR_DEPENDENCE_BASE (base2))\n+    return false;\n+\n   ind1_p = (TREE_CODE (base1) == MEM_REF\n \t    || TREE_CODE (base1) == TARGET_MEM_REF);\n   ind2_p = (TREE_CODE (base2) == MEM_REF"}, {"sha": "99448dd33f3f00f86256aa0672b7d1047cc90783", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -484,7 +484,18 @@ unpack_value_fields (struct data_in *data_in, struct bitpack_d *bp, tree expr)\n     unpack_ts_type_common_value_fields (bp, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    SET_EXPR_LOCATION (expr, stream_input_location (bp, data_in));\n+    {\n+      SET_EXPR_LOCATION (expr, stream_input_location (bp, data_in));\n+      if (code == MEM_REF\n+\t  || code == TARGET_MEM_REF)\n+\t{\n+\t  MR_DEPENDENCE_CLIQUE (expr)\n+\t    = (unsigned)bp_unpack_value (bp, sizeof (short) * 8);\n+\t  if (MR_DEPENDENCE_CLIQUE (expr) != 0)\n+\t    MR_DEPENDENCE_BASE (expr)\n+\t      = (unsigned)bp_unpack_value (bp, sizeof (short) * 8);\n+\t}\n+    }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n     unpack_ts_block_value_fields (data_in, bp, expr);"}, {"sha": "ad58b849f791dd9cd33d0fb1b8a7ab0eac5d40fc", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -446,7 +446,16 @@ streamer_pack_tree_bitfields (struct output_block *ob,\n     pack_ts_type_common_value_fields (bp, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    stream_output_location (ob, bp, EXPR_LOCATION (expr));\n+    {\n+      stream_output_location (ob, bp, EXPR_LOCATION (expr));\n+      if (code == MEM_REF\n+\t  || code == TARGET_MEM_REF)\n+\t{\n+\t  bp_pack_value (bp, MR_DEPENDENCE_CLIQUE (expr), sizeof (short) * 8);\n+\t  if (MR_DEPENDENCE_CLIQUE (expr) != 0)\n+\t    bp_pack_value (bp, MR_DEPENDENCE_BASE (expr), sizeof (short) * 8);\n+\t}\n+    }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n     pack_ts_block_value_fields (ob, bp, expr);"}, {"sha": "45214d690c053a70a9b886984b874dba57ae81e6", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3dccf50915b31fcc3e03e82fd09ccef243b30e3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f3dccf50915b31fcc3e03e82fd09ccef243b30e3", "patch": "@@ -1105,6 +1105,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define TMR_STEP(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 3))\n #define TMR_INDEX2(NODE) (TREE_OPERAND (TARGET_MEM_REF_CHECK (NODE), 4))\n \n+#define MR_DEPENDENCE_CLIQUE(NODE) \\\n+  (TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)->base.u.dependence_info.clique)\n+#define MR_DEPENDENCE_BASE(NODE) \\\n+  (TREE_CHECK2 (NODE, MEM_REF, TARGET_MEM_REF)->base.u.dependence_info.base)\n+\n /* The operands of a BIND_EXPR.  */\n #define BIND_EXPR_VARS(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 0))\n #define BIND_EXPR_BODY(NODE) (TREE_OPERAND (BIND_EXPR_CHECK (NODE), 1))"}]}