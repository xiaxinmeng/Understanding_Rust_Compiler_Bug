{"sha": "235d5a96cb8dad0b4c427602346fcf966a4ec914", "node_id": "C_kwDOANBUbNoAKDIzNWQ1YTk2Y2I4ZGFkMGI0YzQyNzYwMjM0NmZjZjk2NmE0ZWM5MTQ", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-03-29T14:57:10Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-04-02T21:56:52Z"}, "message": "d: Merge upstream dmd 47871363d, druntime, c52e28b7, phobos 99e9c1b77.\n\nD front-end changes:\n\n    - Import dmd v2.099.1-beta.1.\n    - The address of NRVO variables is now stored in scoped closures\n      when they have nested references.\n    - Using `__traits(parameters)' in foreach loops now always returns\n      the parameters to the function the foreach appears within.\n      Previously, when used inside a `foreach' using an overloaded\n      `opApply', the trait would yield the parameters to the delegate.\n    - The deprecation period of unannotated `asm' blocks has been ended.\n    - The `inout' attribute no longer implies the `return' attribute.\n    - Added new `D_PreConditions', `D_PostConditions', and\n      `D_Invariants' version identifiers.\n\nD runtime changes:\n\n    - Import druntime v2.099.1-beta.1.\n\nPhobos changes:\n\n    - Import phobos v2.099.1-beta.1.\n    - `Nullable' in `std.typecons' can now act as a range.\n    - std.experimental.logger default level changed to `info' instead of\n      `warning'.\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 47871363d.\n\t* d-builtins.cc (d_init_versions): Add predefined version identifiers\n\tD_PreConditions, D_PostConditions, and D_Invariants.\n\t* d-codegen.cc (d_build_call): Update for new front-end interface.\n\t(build_frame_type): Generate reference field for NRVO variables with\n\tnested references.\n\t(build_closure): Generate assignment of return address to closure.\n\t* d-tree.h (DECL_INSTANTIATED): Use DECL_LANG_FLAG_2.\n\t(bind_expr): Remove.\n\t* decl.cc (DeclVisitor::visit (FuncDeclaration *)): Update for new\n\tfront-end interface.\n\t(get_symbol_decl): Likewise.\n\t(get_decl_tree): Check DECL_LANG_FRAME_FIELD before DECL_LANG_NRVO.\n\tDereference the field when both are set.\n\t* expr.cc (ExprVisitor::visit (DeleteExp *)): Update for new front-end\n\tinterface.\n\t* modules.cc (get_internal_fn): Likewise.\n\t* toir.cc (IRVisitor::visit (ReturnStatement *)): Likewise.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime c52e28b7.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES_OPENBSD): Add\n\tcore/sys/openbsd/pwd.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 99e9c1b77.\n\t* testsuite/libphobos.exceptions/message_with_null.d: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/nrvo1.d: New test.", "tree": {"sha": "ca19c774a19ad923e5d6f09d43ee8d89c275a96e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca19c774a19ad923e5d6f09d43ee8d89c275a96e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235d5a96cb8dad0b4c427602346fcf966a4ec914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235d5a96cb8dad0b4c427602346fcf966a4ec914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235d5a96cb8dad0b4c427602346fcf966a4ec914", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235d5a96cb8dad0b4c427602346fcf966a4ec914/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be07535d0f43390b8906826cc119473dea514b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be07535d0f43390b8906826cc119473dea514b54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be07535d0f43390b8906826cc119473dea514b54"}], "stats": {"total": 4641, "additions": 2728, "deletions": 1913}, "files": [{"sha": "7e7fb75bdc5c8a336a694940ec8dcb4b0f990864", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -484,6 +484,15 @@ d_init_versions (void)\n   if (global.params.useAssert == CHECKENABLEon)\n     VersionCondition::addPredefinedGlobalIdent (\"assert\");\n \n+  if (global.params.useIn == CHECKENABLEon)\n+    VersionCondition::addPredefinedGlobalIdent(\"D_PreConditions\");\n+\n+  if (global.params.useOut == CHECKENABLEon)\n+    VersionCondition::addPredefinedGlobalIdent(\"D_PostConditions\");\n+\n+  if (global.params.useInvariants == CHECKENABLEon)\n+    VersionCondition::addPredefinedGlobalIdent(\"D_Invariants\");\n+\n   if (global.params.useArrayBounds == CHECKENABLEoff)\n     VersionCondition::addPredefinedGlobalIdent (\"D_NoBoundsChecks\");\n "}, {"sha": "bb96b2f8d28f9c197a90a878d8cfe9343a871265", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -2207,9 +2207,9 @@ d_build_call (TypeFunction *tf, tree callable, tree object,\n \t\t\t      build_address (targ));\n \t    }\n \n-  \t  /* Type `noreturn` is a terminator, as no other arguments can possibly\n-  \t     be evaluated after it.  */\n-  \t  if (TREE_TYPE (targ) == noreturn_type_node)\n+\t  /* Type `noreturn` is a terminator, as no other arguments can possibly\n+\t     be evaluated after it.  */\n+\t  if (TREE_TYPE (targ) == noreturn_type_node)\n \t    noreturn_call = true;\n \n \t  vec_safe_push (args, targ);\n@@ -2690,9 +2690,15 @@ build_frame_type (tree ffi, FuncDeclaration *fd)\n       DECL_NONADDRESSABLE_P (field) = !TREE_ADDRESSABLE (vsym);\n       TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (vsym);\n \n-      /* Can't do nrvo if the variable is put in a frame.  */\n-      if (fd->nrvo_can && fd->nrvo_var == v)\n-\tfd->nrvo_can = 0;\n+      if (DECL_LANG_NRVO (vsym))\n+\t{\n+\t  /* Store the nrvo variable in the frame by reference.  */\n+\t  TREE_TYPE (field) = build_reference_type (TREE_TYPE (field));\n+\n+\t  /* Can't do nrvo if the variable is put in a closure, since what the\n+\t     return slot points to may no longer exist.  */\n+\t  gcc_assert (!FRAMEINFO_IS_CLOSURE (ffi));\n+\t}\n \n       if (FRAMEINFO_IS_CLOSURE (ffi))\n \t{\n@@ -2769,13 +2775,17 @@ build_closure (FuncDeclaration *fd)\n   for (size_t i = 0; i < fd->closureVars.length; i++)\n     {\n       VarDeclaration *v = fd->closureVars[i];\n+      tree vsym = get_symbol_decl (v);\n \n-      if (!v->isParameter ())\n+      if (TREE_CODE (vsym) != PARM_DECL && !DECL_LANG_NRVO (vsym))\n \tcontinue;\n \n-      tree vsym = get_symbol_decl (v);\n-\n       tree field = component_ref (decl_ref, DECL_LANG_FRAME_FIELD (vsym));\n+\n+      /* Variable is an alias for the NRVO slot, store the reference.  */\n+      if (DECL_LANG_NRVO (vsym))\n+\tvsym = build_address (DECL_LANG_NRVO (vsym));\n+\n       tree expr = modify_expr (field, vsym);\n       add_stmt (expr);\n     }"}, {"sha": "d93d02c29540a78a27d6b0aa01489eac772cca4f", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -392,7 +392,7 @@ lang_tree_node\n \n /* True if the decl comes from a template instance.  */\n #define DECL_INSTANTIATED(NODE) \\\n-  (DECL_LANG_FLAG_1 (VAR_OR_FUNCTION_DECL_CHECK (NODE)))\n+  (DECL_LANG_FLAG_2 (VAR_OR_FUNCTION_DECL_CHECK (NODE)))\n \n enum d_tree_index\n {\n@@ -580,7 +580,6 @@ extern tree build_bounds_index_condition (IndexExp *, tree, tree);\n extern tree build_bounds_slice_condition (SliceExp *, tree, tree, tree);\n extern bool array_bounds_check (void);\n extern bool checkaction_trap_p (void);\n-extern tree bind_expr (tree, tree);\n extern TypeFunction *get_function_type (Type *);\n extern bool call_by_alias_p (FuncDeclaration *, FuncDeclaration *);\n extern tree d_build_call_expr (FuncDeclaration *, tree, Expressions *);"}, {"sha": "ea8baef588c075e039121f55b7ee1981a724ea29", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -791,7 +791,7 @@ class DeclVisitor : public Visitor\n \t  return;\n       }\n \n-    if (d->semantic3Errors)\n+    if (d->hasSemantic3Errors ())\n       return;\n \n     if (d->isNested ())\n@@ -805,7 +805,7 @@ class DeclVisitor : public Visitor\n \t      break;\n \n \t    /* Parent failed to compile, but errors were gagged.  */\n-\t    if (fdp->semantic3Errors)\n+\t    if (fdp->hasSemantic3Errors ())\n \t      return;\n \t  }\n       }\n@@ -921,15 +921,6 @@ class DeclVisitor : public Visitor\n \t  }\n       }\n \n-    /* May change cfun->static_chain.  */\n-    build_closure (d);\n-\n-    if (d->vresult)\n-      declare_local_var (d->vresult);\n-\n-    if (d->v_argptr)\n-      push_stmt_list ();\n-\n     /* Named return value optimisation support for D.\n        Implemented by overriding all the RETURN_EXPRs and replacing all\n        occurrences of VAR with the RESULT_DECL for the function.\n@@ -951,7 +942,7 @@ class DeclVisitor : public Visitor\n \telse\n \t  d->shidden = resdecl;\n \n-\tif (d->nrvo_can && d->nrvo_var)\n+\tif (d->isNRVO () && d->nrvo_var)\n \t  {\n \t    tree var = get_symbol_decl (d->nrvo_var);\n \n@@ -966,6 +957,15 @@ class DeclVisitor : public Visitor\n \t  }\n       }\n \n+    /* May change cfun->static_chain.  */\n+    build_closure (d);\n+\n+    if (d->vresult)\n+      declare_local_var (d->vresult);\n+\n+    if (d->v_argptr)\n+      push_stmt_list ();\n+\n     build_function_body (d);\n \n     /* Initialize the _argptr variable.  */\n@@ -1284,26 +1284,26 @@ get_symbol_decl (Declaration *decl)\n       /* In [pragma/crtctor], Annotates a function so it is run after the C\n \t runtime library is initialized and before the D runtime library is\n \t initialized.  */\n-      if (fd->isCrtCtorDtor == 1)\n+      if (fd->isCrtCtor ())\n \t{\n \t  DECL_STATIC_CONSTRUCTOR (decl->csym) = 1;\n \t  decl_init_priority_insert (decl->csym, DEFAULT_INIT_PRIORITY);\n \t}\n-      else if (fd->isCrtCtorDtor == 2)\n+      else if (fd->isCrtDtor ())\n \t{\n \t  DECL_STATIC_DESTRUCTOR (decl->csym) = 1;\n \t  decl_fini_priority_insert (decl->csym, DEFAULT_INIT_PRIORITY);\n-       \t}\n+\t}\n \n       /* Function was declared `naked'.  */\n-      if (fd->naked)\n+      if (fd->isNaked ())\n \t{\n \t  insert_decl_attribute (decl->csym, \"naked\");\n \t  DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl->csym) = 1;\n \t}\n \n       /* Mark compiler generated functions as artificial.  */\n-      if (fd->generated)\n+      if (fd->isGenerated ())\n \tDECL_ARTIFICIAL (decl->csym) = 1;\n \n       /* Ensure and require contracts are lexically nested in the function they\n@@ -1486,20 +1486,26 @@ get_decl_tree (Declaration *decl)\n   if (vd == NULL || fd == NULL)\n     return t;\n \n-  /* Get the named return value.  */\n-  if (DECL_LANG_NRVO (t))\n-    return DECL_LANG_NRVO (t);\n-\n   /* Get the closure holding the var decl.  */\n   if (DECL_LANG_FRAME_FIELD (t))\n     {\n       FuncDeclaration *parent = vd->toParent2 ()->isFuncDeclaration ();\n       tree frame_ref = get_framedecl (fd, parent);\n \n-      return component_ref (build_deref (frame_ref),\n-\t\t\t    DECL_LANG_FRAME_FIELD (t));\n+      tree field = component_ref (build_deref (frame_ref),\n+\t\t\t\t  DECL_LANG_FRAME_FIELD (t));\n+      /* Frame field can also be a reference to the DECL_RESULT of a function.\n+\t Dereference it to get the value.  */\n+      if (DECL_LANG_NRVO (t))\n+\tfield = build_deref (field);\n+\n+      return field;\n     }\n \n+  /* Get the named return value.  */\n+  if (DECL_LANG_NRVO (t))\n+    return DECL_LANG_NRVO (t);\n+\n   /* Get the non-local `this' value by going through parent link\n      of nested classes, this routine pretty much undoes what\n      getRightThis in the frontend removes from codegen.  */"}, {"sha": "ca409df346dcdeed69138d03c11cd599903a3337", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,4 @@\n-2503f17e5767bc4fcd0cf3889c90fa0415b0edaa\n+47871363d804f54b29ccfd444b082c19716c2301\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "16f49a73f4d971826ffc8ed54df4fe85347c5211", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1 +1 @@\n-v2.099.0\n+v2.099.1-beta.1"}, {"sha": "8895aa5e2bdb0ece72d29341e75bdec2602ba81c", "filename": "gcc/d/dmd/aggregate.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Faggregate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Faggregate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faggregate.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -547,7 +547,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n         if (overflow) assert(0);\n \n         // Skip no-op for noreturn without custom aligment\n-        if (memsize != 0 || !alignment.isDefault())\n+        if (memalignsize != 0 || !alignment.isDefault())\n             alignmember(alignment, memalignsize, &ofs);\n \n         uint memoffset = ofs;\n@@ -570,7 +570,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n          * definitions exposed some issues in their TypeInfo generation in DMD.\n          * Related PR: https://github.com/dlang/dmd/pull/13312\n          */\n-        if (semanticRun == PASS.init && !isInterfaceDeclaration())\n+        if (semanticRun == PASS.initial && !isInterfaceDeclaration())\n         {\n             auto stc = storage_class;\n             if (_scope)\n@@ -747,7 +747,7 @@ extern (C++) abstract class AggregateDeclaration : ScopeDsymbol\n                 extern (C++) static int fp(Dsymbol s, void* ctxt)\n                 {\n                     auto f = s.isCtorDeclaration();\n-                    if (f && f.semanticRun == PASS.init)\n+                    if (f && f.semanticRun == PASS.initial)\n                         f.dsymbolSemantic(null);\n                     return 0;\n                 }"}, {"sha": "2771071baa7d0114b9417b946e2334267b0aaa98", "filename": "gcc/d/dmd/aliasthis.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Faliasthis.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Faliasthis.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faliasthis.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -100,9 +100,9 @@ Expression resolveAliasThis(Scope* sc, Expression e, bool gag = false, bool find\n \n             if (tthis && ad.aliasthis.sym.needThis())\n             {\n-                if (e.op == EXP.variable)\n+                if (auto ve = e.isVarExp())\n                 {\n-                    if (auto fd = (cast(VarExp)e).var.isFuncDeclaration())\n+                    if (auto fd = ve.var.isFuncDeclaration())\n                     {\n                         // https://issues.dlang.org/show_bug.cgi?id=13009\n                         // Support better match for the overloaded alias this."}, {"sha": "52f39d34d0f0b2afa3638300341726da56d0d712", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -52,16 +52,16 @@ bool isArrayOpValid(Expression e)\n     {\n         if (isUnaArrayOp(e.op))\n         {\n-            return isArrayOpValid((cast(UnaExp)e).e1);\n+            return isArrayOpValid(e.isUnaExp().e1);\n         }\n         if (isBinArrayOp(e.op) || isBinAssignArrayOp(e.op) || e.op == EXP.assign)\n         {\n-            BinExp be = cast(BinExp)e;\n+            BinExp be = e.isBinExp();\n             return isArrayOpValid(be.e1) && isArrayOpValid(be.e2);\n         }\n         if (e.op == EXP.construct)\n         {\n-            BinExp be = cast(BinExp)e;\n+            BinExp be = e.isBinExp();\n             return be.e1.op == EXP.slice && isArrayOpValid(be.e2);\n         }\n         // if (e.op == EXP.call)\n@@ -76,7 +76,7 @@ bool isArrayOpValid(Expression e)\n bool isNonAssignmentArrayOp(Expression e)\n {\n     if (e.op == EXP.slice)\n-        return isNonAssignmentArrayOp((cast(SliceExp)e).e1);\n+        return isNonAssignmentArrayOp(e.isSliceExp().e1);\n \n     Type tb = e.type.toBasetype();\n     if (tb.ty == Tarray || tb.ty == Tsarray)\n@@ -176,7 +176,7 @@ Expression arrayOp(BinAssignExp e, Scope* sc)\n         return e.e1.modifiableLvalue(sc, e.e1);\n     }\n \n-    return arrayOp(cast(BinExp)e, sc);\n+    return arrayOp(e.isBinExp(), sc);\n }\n \n /******************************************"}, {"sha": "29b3a3ddc33c08b85f2a23528b37d0f94af5db54", "filename": "gcc/d/dmd/arraytypes.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farraytypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farraytypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -54,4 +54,3 @@ alias TemplateInstances = Array!(TemplateInstance);\n alias Ensures = Array!(Ensure);\n alias Designators = Array!(Designator);\n alias DesigInits = Array!(DesigInit);\n-"}, {"sha": "ca2051cf5f4a89e46d41409fdadf0f2ae6780405", "filename": "gcc/d/dmd/arraytypes.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farraytypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Farraytypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farraytypes.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -67,4 +67,3 @@ typedef Array<struct Ensure> Ensures;\n typedef Array<struct Designator> Designators;\n \n typedef Array<struct DesigInit> DesigInits;\n-"}, {"sha": "afd7ac052adfa865bc751644507f794487b021e4", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -99,9 +99,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                     result = BE.halt;\n                     return;\n                 }\n-                if (s.exp.op == EXP.assert_)\n+                if (AssertExp a = s.exp.isAssertExp())\n                 {\n-                    AssertExp a = cast(AssertExp)s.exp;\n                     if (a.e1.toBool().hasValue(false)) // if it's an assert(0)\n                     {\n                         result = BE.halt;\n@@ -505,7 +504,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             if (!(s.stc & STC.nothrow_))\n             {\n                 if (mustNotThrow && !(s.stc & STC.nothrow_))\n-                    s.deprecation(\"`asm` statement is assumed to throw - mark it with `nothrow` if it does not\");\n+                    s.error(\"`asm` statement is assumed to throw - mark it with `nothrow` if it does not\");\n                 else\n                     result |= BE.throw_;\n             }"}, {"sha": "2ed0dc7bdd1cd52990b277451282e33fcfa0318f", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -301,7 +301,7 @@ FuncDeclaration buildOpAssign(StructDeclaration sd, Scope* sc)\n     auto tf = new TypeFunction(ParameterList(fparams), sd.handleType(), LINK.d, stc | STC.ref_);\n     auto fop = new FuncDeclaration(declLoc, Loc.initial, Id.assign, stc, tf);\n     fop.storage_class |= STC.inference;\n-    fop.generated = true;\n+    fop.flags  |= FUNCFLAG.generated;\n     Expression e;\n     if (stc & STC.disable)\n     {\n@@ -575,7 +575,7 @@ FuncDeclaration buildXopEquals(StructDeclaration sd, Scope* sc)\n     tf = tf.addSTC(STC.const_).toTypeFunction();\n     Identifier id = Id.xopEquals;\n     auto fop = new FuncDeclaration(declLoc, Loc.initial, id, 0, tf);\n-    fop.generated = true;\n+    fop.flags |= FUNCFLAG.generated;\n     fop.parent = sd;\n     Expression e1 = new IdentifierExp(loc, Id.This);\n     Expression e2 = new IdentifierExp(loc, Id.p);\n@@ -644,13 +644,13 @@ FuncDeclaration buildXopCmp(StructDeclaration sd, Scope* sc)\n                 switch (e.op)\n                 {\n                 case EXP.overloadSet:\n-                    s = (cast(OverExp)e).vars;\n+                    s = e.isOverExp().vars;\n                     break;\n                 case EXP.scope_:\n-                    s = (cast(ScopeExp)e).sds;\n+                    s = e.isScopeExp().sds;\n                     break;\n                 case EXP.variable:\n-                    s = (cast(VarExp)e).var;\n+                    s = e.isVarExp().var;\n                     break;\n                 default:\n                     break;\n@@ -696,7 +696,7 @@ FuncDeclaration buildXopCmp(StructDeclaration sd, Scope* sc)\n     tf = tf.addSTC(STC.const_).toTypeFunction();\n     Identifier id = Id.xopCmp;\n     auto fop = new FuncDeclaration(declLoc, Loc.initial, id, 0, tf);\n-    fop.generated = true;\n+    fop.flags |= FUNCFLAG.generated;\n     fop.parent = sd;\n     Expression e1 = new IdentifierExp(loc, Id.This);\n     Expression e2 = new IdentifierExp(loc, Id.p);\n@@ -814,7 +814,7 @@ FuncDeclaration buildXtoHash(StructDeclaration sd, Scope* sc)\n     auto tf = new TypeFunction(ParameterList(parameters), Type.thash_t, LINK.d, STC.nothrow_ | STC.trusted);\n     Identifier id = Id.xtoHash;\n     auto fop = new FuncDeclaration(declLoc, Loc.initial, id, STC.static_, tf);\n-    fop.generated = true;\n+    fop.flags |= FUNCFLAG.generated;\n \n     /* Do memberwise hashing.\n      *\n@@ -937,13 +937,13 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n                 if (stc & STC.safe)\n                     stc = (stc & ~STC.safe) | STC.trusted;\n \n-                ex = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type.tsize_t),\n+                SliceExp se = new SliceExp(loc, ex, new IntegerExp(loc, 0, Type.tsize_t),\n                                            new IntegerExp(loc, n, Type.tsize_t));\n                 // Prevent redundant bounds check\n-                (cast(SliceExp)ex).upperIsInBounds = true;\n-                (cast(SliceExp)ex).lowerIsLessThanUpper = true;\n+                se.upperIsInBounds = true;\n+                se.lowerIsLessThanUpper = true;\n \n-                ex = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), ex);\n+                ex = new CallExp(loc, new IdentifierExp(loc, Id.__ArrayDtor), se);\n             }\n             e = Expression.combine(ex, e); // combine in reverse order\n         }\n@@ -952,7 +952,7 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n         {\n             //printf(\"Building __fieldDtor(), %s\\n\", e.toChars());\n             auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__fieldDtor);\n-            dd.generated = true;\n+            dd.flags |= FUNCFLAG.generated;\n             dd.storage_class |= STC.inference;\n             dd.fbody = new ExpStatement(loc, e);\n             ad.members.push(dd);\n@@ -1008,7 +1008,7 @@ void buildDtors(AggregateDeclaration ad, Scope* sc)\n             e = Expression.combine(e, ce);\n         }\n         auto dd = new DtorDeclaration(declLoc, Loc.initial, stc, Id.__aggrDtor);\n-        dd.generated = true;\n+        dd.flags |= FUNCFLAG.generated;\n         dd.storage_class |= STC.inference;\n         dd.fbody = new ExpStatement(loc, e);\n         ad.members.push(dd);\n@@ -1079,7 +1079,7 @@ private DtorDeclaration buildWindowsCppDtor(AggregateDeclaration ad, DtorDeclara\n     stmts.push(new ExpStatement(loc, call));\n     stmts.push(new ReturnStatement(loc, new CastExp(loc, new ThisExp(loc), Type.tvoidptr)));\n     func.fbody = new CompoundStatement(loc, stmts);\n-    func.generated = true;\n+    func.flags |= FUNCFLAG.generated;\n \n     auto sc2 = sc.push();\n     sc2.stc &= ~STC.static_; // not a static destructor\n@@ -1127,7 +1127,7 @@ private DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n     auto call = new CallExp(dtor.loc, dtor, null);\n     call.directcall = true;                   // non-virtual call Class.__dtor();\n     func.fbody = new ExpStatement(dtor.loc, call);\n-    func.generated = true;\n+    func.flags |= FUNCFLAG.generated;\n     func.storage_class |= STC.inference;\n \n     auto sc2 = sc.push();\n@@ -1403,7 +1403,7 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n         //printf(\"Building __fieldPostBlit()\\n\");\n         checkShared();\n         auto dd = new PostBlitDeclaration(declLoc, Loc.initial, stc, Id.__fieldPostblit);\n-        dd.generated = true;\n+        dd.flags |= FUNCFLAG.generated;\n         dd.storage_class |= STC.inference | STC.scope_;\n         dd.fbody = (stc & STC.disable) ? null : new CompoundStatement(loc, postblitCalls);\n         sd.postblits.shift(dd);\n@@ -1441,7 +1441,7 @@ FuncDeclaration buildPostBlit(StructDeclaration sd, Scope* sc)\n \n         checkShared();\n         auto dd = new PostBlitDeclaration(declLoc, Loc.initial, stc, Id.__aggrPostblit);\n-        dd.generated = true;\n+        dd.flags |= FUNCFLAG.generated;\n         dd.storage_class |= STC.inference;\n         dd.fbody = new ExpStatement(loc, e);\n         sd.members.push(dd);\n@@ -1504,7 +1504,7 @@ private CtorDeclaration generateCopyCtorDeclaration(StructDeclaration sd, const\n     auto ccd = new CtorDeclaration(sd.loc, Loc.initial, STC.ref_, tf, true);\n     ccd.storage_class |= funcStc;\n     ccd.storage_class |= STC.inference;\n-    ccd.generated = true;\n+    ccd.flags |= FUNCFLAG.generated;\n     return ccd;\n }\n \n@@ -1691,5 +1691,3 @@ bool buildCopyCtor(StructDeclaration sd, Scope* sc)\n     }\n     return true;\n }\n-\n-"}, {"sha": "75ba9ea1e0a3470d59b986cd822732e0cd42884f", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 60, "deletions": 75, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -217,15 +217,13 @@ UnionExp Add(const ref Loc loc, Type type, Expression e1, Expression e2)\n         }\n         emplaceExp!(ComplexExp)(&ue, loc, v, type);\n     }\n-    else if (e1.op == EXP.symbolOffset)\n+    else if (SymOffExp soe = e1.isSymOffExp())\n     {\n-        SymOffExp soe = cast(SymOffExp)e1;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset + e2.toInteger());\n         ue.exp().type = type;\n     }\n-    else if (e2.op == EXP.symbolOffset)\n+    else if (SymOffExp soe = e2.isSymOffExp())\n     {\n-        SymOffExp soe = cast(SymOffExp)e2;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset + e1.toInteger());\n         ue.exp().type = type;\n     }\n@@ -320,9 +318,8 @@ UnionExp Min(const ref Loc loc, Type type, Expression e1, Expression e2)\n         }\n         emplaceExp!(ComplexExp)(&ue, loc, v, type);\n     }\n-    else if (e1.op == EXP.symbolOffset)\n+    else if (SymOffExp soe = e1.isSymOffExp())\n     {\n-        SymOffExp soe = cast(SymOffExp)e1;\n         emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset - e2.toInteger());\n         ue.exp().type = type;\n     }\n@@ -731,14 +728,12 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     {\n         if (e2.op == EXP.null_)\n             cmp = 1;\n-        else if (e2.op == EXP.string_)\n+        else if (StringExp es2 = e2.isStringExp())\n         {\n-            StringExp es2 = cast(StringExp)e2;\n             cmp = (0 == es2.len);\n         }\n-        else if (e2.op == EXP.arrayLiteral)\n+        else if (ArrayLiteralExp es2 = e2.isArrayLiteralExp())\n         {\n-            ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n             cmp = !es2.elements || (0 == es2.elements.dim);\n         }\n         else\n@@ -749,14 +744,12 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     }\n     else if (e2.op == EXP.null_)\n     {\n-        if (e1.op == EXP.string_)\n+        if (StringExp es1 = e1.isStringExp())\n         {\n-            StringExp es1 = cast(StringExp)e1;\n             cmp = (0 == es1.len);\n         }\n-        else if (e1.op == EXP.arrayLiteral)\n+        else if (ArrayLiteralExp es1 = e1.isArrayLiteralExp())\n         {\n-            ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n             cmp = !es1.elements || (0 == es1.elements.dim);\n         }\n         else\n@@ -767,8 +760,8 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     }\n     else if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n-        StringExp es1 = cast(StringExp)e1;\n-        StringExp es2 = cast(StringExp)e2;\n+        StringExp es1 = e1.isStringExp();\n+        StringExp es2 = e2.isStringExp();\n         if (es1.sz != es2.sz)\n         {\n             assert(global.errors);\n@@ -784,8 +777,8 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     }\n     else if (e1.op == EXP.arrayLiteral && e2.op == EXP.arrayLiteral)\n     {\n-        ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n-        ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n+        ArrayLiteralExp es1 = e1.isArrayLiteralExp();\n+        ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         if ((!es1.elements || !es1.elements.dim) && (!es2.elements || !es2.elements.dim))\n             cmp = 1; // both arrays are empty\n         else if (!es1.elements || !es2.elements)\n@@ -818,8 +811,8 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     else if (e1.op == EXP.string_ && e2.op == EXP.arrayLiteral)\n     {\n     Lsa:\n-        StringExp es1 = cast(StringExp)e1;\n-        ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n+        StringExp es1 = e1.isStringExp();\n+        ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         size_t dim1 = es1.len;\n         size_t dim2 = es2.elements ? es2.elements.dim : 0;\n         if (dim1 != dim2)\n@@ -844,8 +837,8 @@ UnionExp Equal(EXP op, const ref Loc loc, Type type, Expression e1, Expression e\n     }\n     else if (e1.op == EXP.structLiteral && e2.op == EXP.structLiteral)\n     {\n-        StructLiteralExp es1 = cast(StructLiteralExp)e1;\n-        StructLiteralExp es2 = cast(StructLiteralExp)e2;\n+        StructLiteralExp es1 = e1.isStructLiteralExp();\n+        StructLiteralExp es2 = e2.isStructLiteralExp();\n         if (es1.sd != es2.sd)\n             cmp = 0;\n         else if ((!es1.elements || !es1.elements.dim) && (!es2.elements || !es2.elements.dim))\n@@ -935,8 +928,8 @@ UnionExp Identity(EXP op, const ref Loc loc, Type type, Expression e1, Expressio\n     }\n     else if (e1.op == EXP.symbolOffset && e2.op == EXP.symbolOffset)\n     {\n-        SymOffExp es1 = cast(SymOffExp)e1;\n-        SymOffExp es2 = cast(SymOffExp)e2;\n+        SymOffExp es1 = e1.isSymOffExp();\n+        SymOffExp es2 = e2.isSymOffExp();\n         cmp = (es1.var == es2.var && es1.offset == es2.offset);\n     }\n     else\n@@ -976,8 +969,8 @@ UnionExp Cmp(EXP op, const ref Loc loc, Type type, Expression e1, Expression e2)\n     //printf(\"Cmp(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n     if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n-        StringExp es1 = cast(StringExp)e1;\n-        StringExp es2 = cast(StringExp)e2;\n+        StringExp es1 = e1.isStringExp();\n+        StringExp es2 = e2.isStringExp();\n         size_t sz = es1.sz;\n         assert(sz == es2.sz);\n         size_t len = es1.len;\n@@ -1045,7 +1038,7 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n     }\n     if (e1.op == EXP.vector && (cast(TypeVector)e1.type).basetype.equals(type) && type.equals(to))\n     {\n-        Expression ex = (cast(VectorExp)e1).e1;\n+        Expression ex = e1.isVectorExp().e1;\n         emplaceExp!(UnionExp)(&ue, ex);\n         return ue;\n     }\n@@ -1201,20 +1194,17 @@ UnionExp ArrayLength(Type type, Expression e1)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n-    if (e1.op == EXP.string_)\n+    if (StringExp es1 = e1.isStringExp())\n     {\n-        StringExp es1 = cast(StringExp)e1;\n         emplaceExp!(IntegerExp)(&ue, loc, es1.len, type);\n     }\n-    else if (e1.op == EXP.arrayLiteral)\n+    else if (ArrayLiteralExp ale = e1.isArrayLiteralExp())\n     {\n-        ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n         size_t dim = ale.elements ? ale.elements.dim : 0;\n         emplaceExp!(IntegerExp)(&ue, loc, dim, type);\n     }\n-    else if (e1.op == EXP.assocArrayLiteral)\n+    else if (AssocArrayLiteralExp ale = e1.isAssocArrayLiteralExp)\n     {\n-        AssocArrayLiteralExp ale = cast(AssocArrayLiteralExp)e1;\n         size_t dim = ale.keys.dim;\n         emplaceExp!(IntegerExp)(&ue, loc, dim, type);\n     }\n@@ -1238,7 +1228,7 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n     assert(e1.type);\n     if (e1.op == EXP.string_ && e2.op == EXP.int64)\n     {\n-        StringExp es1 = cast(StringExp)e1;\n+        StringExp es1 = e1.isStringExp();\n         uinteger_t i = e2.toInteger();\n         if (i >= es1.len)\n         {\n@@ -1261,9 +1251,8 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n             e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), length);\n             emplaceExp!(ErrorExp)(&ue);\n         }\n-        else if (e1.op == EXP.arrayLiteral)\n+        else if (ArrayLiteralExp ale = e1.isArrayLiteralExp())\n         {\n-            ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n             auto e = ale[cast(size_t)i];\n             e.type = type;\n             e.loc = loc;\n@@ -1278,9 +1267,8 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n     else if (e1.type.toBasetype().ty == Tarray && e2.op == EXP.int64)\n     {\n         uinteger_t i = e2.toInteger();\n-        if (e1.op == EXP.arrayLiteral)\n+        if (ArrayLiteralExp ale = e1.isArrayLiteralExp())\n         {\n-            ArrayLiteralExp ale = cast(ArrayLiteralExp)e1;\n             if (i >= ale.elements.dim)\n             {\n                 e1.error(\"array index %llu is out of bounds `%s[0 .. %llu]`\", i, e1.toChars(), cast(ulong) ale.elements.dim);\n@@ -1300,9 +1288,8 @@ UnionExp Index(Type type, Expression e1, Expression e2, bool indexIsInBounds)\n         else\n             cantExp(ue);\n     }\n-    else if (e1.op == EXP.assocArrayLiteral)\n+    else if (AssocArrayLiteralExp ae = e1.isAssocArrayLiteralExp())\n     {\n-        AssocArrayLiteralExp ae = cast(AssocArrayLiteralExp)e1;\n         /* Search the keys backwards, in case there are duplicate keys\n          */\n         for (size_t i = ae.keys.dim; i;)\n@@ -1350,7 +1337,7 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n \n     if (e1.op == EXP.string_ && lwr.op == EXP.int64 && upr.op == EXP.int64)\n     {\n-        StringExp es1 = cast(StringExp)e1;\n+        StringExp es1 = e1.isStringExp();\n         const uinteger_t ilwr = lwr.toInteger();\n         const uinteger_t iupr = upr.toInteger();\n         if (sliceBoundsCheck(0, es1.len, ilwr, iupr))\n@@ -1363,14 +1350,14 @@ UnionExp Slice(Type type, Expression e1, Expression lwr, Expression upr)\n             const data1 = es1.peekData();\n             memcpy(s, data1.ptr + ilwr * sz, len * sz);\n             emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz, es1.postfix);\n-            StringExp es = cast(StringExp)ue.exp();\n+            StringExp es = ue.exp().isStringExp();\n             es.committed = es1.committed;\n             es.type = type;\n         }\n     }\n     else if (e1.op == EXP.arrayLiteral && lwr.op == EXP.int64 && upr.op == EXP.int64 && !hasSideEffect(e1))\n     {\n-        ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n+        ArrayLiteralExp es1 = e1.isArrayLiteralExp();\n         const uinteger_t ilwr = lwr.toInteger();\n         const uinteger_t iupr = upr.toInteger();\n         if (sliceBoundsCheck(0, es1.elements.dim, ilwr, iupr))\n@@ -1491,15 +1478,15 @@ private Expressions* copyElements(Expression e1, Expression e2 = null)\n         }\n     }\n \n-    if (e1.op == EXP.arrayLiteral)\n-        append(cast(ArrayLiteralExp)e1);\n+    if (auto ale = e1.isArrayLiteralExp())\n+        append(ale);\n     else\n         elems.push(e1);\n \n     if (e2)\n     {\n-        if (e2.op == EXP.arrayLiteral)\n-            append(cast(ArrayLiteralExp)e2);\n+        if (auto ale = e2.isArrayLiteralExp())\n+            append(ale);\n         else\n             elems.push(e2);\n     }\n@@ -1544,7 +1531,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n             else\n                 utf_encode(sz, s, cast(dchar)v);\n             emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-            StringExp es = cast(StringExp)ue.exp();\n+            StringExp es = ue.exp().isStringExp();\n             es.type = type;\n             es.committed = 1;\n         }\n@@ -1589,8 +1576,8 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     else if (e1.op == EXP.string_ && e2.op == EXP.string_)\n     {\n         // Concatenate the strings\n-        StringExp es1 = cast(StringExp)e1;\n-        StringExp es2 = cast(StringExp)e2;\n+        StringExp es1 = e1.isStringExp();\n+        StringExp es2 = e2.isStringExp();\n         size_t len = es1.len + es2.len;\n         ubyte sz = es1.sz;\n         if (sz != es2.sz)\n@@ -1609,7 +1596,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         memcpy(cast(char*)s, data1.ptr, es1.len * sz);\n         memcpy(cast(char*)s + es1.len * sz, data2.ptr, es2.len * sz);\n         emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-        StringExp es = cast(StringExp)ue.exp();\n+        StringExp es = ue.exp().isStringExp();\n         es.committed = es1.committed | es2.committed;\n         es.type = type;\n         assert(ue.exp().type);\n@@ -1618,41 +1605,41 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     else if (e2.op == EXP.string_ && e1.op == EXP.arrayLiteral && t1.nextOf().isintegral())\n     {\n         // [chars] ~ string --> [chars]\n-        StringExp es = cast(StringExp)e2;\n-        ArrayLiteralExp ea = cast(ArrayLiteralExp)e1;\n+        StringExp es = e2.isStringExp();\n+        ArrayLiteralExp ea = e1.isArrayLiteralExp();\n         size_t len = es.len + ea.elements.dim;\n         auto elems = new Expressions(len);\n         for (size_t i = 0; i < ea.elements.dim; ++i)\n         {\n             (*elems)[i] = ea[i];\n         }\n         emplaceExp!(ArrayLiteralExp)(&ue, e1.loc, type, elems);\n-        ArrayLiteralExp dest = cast(ArrayLiteralExp)ue.exp();\n+        ArrayLiteralExp dest = ue.exp().isArrayLiteralExp();\n         sliceAssignArrayLiteralFromString(dest, es, ea.elements.dim);\n         assert(ue.exp().type);\n         return ue;\n     }\n     else if (e1.op == EXP.string_ && e2.op == EXP.arrayLiteral && t2.nextOf().isintegral())\n     {\n         // string ~ [chars] --> [chars]\n-        StringExp es = cast(StringExp)e1;\n-        ArrayLiteralExp ea = cast(ArrayLiteralExp)e2;\n+        StringExp es = e1.isStringExp();\n+        ArrayLiteralExp ea = e2.isArrayLiteralExp();\n         size_t len = es.len + ea.elements.dim;\n         auto elems = new Expressions(len);\n         for (size_t i = 0; i < ea.elements.dim; ++i)\n         {\n             (*elems)[es.len + i] = ea[i];\n         }\n         emplaceExp!(ArrayLiteralExp)(&ue, e1.loc, type, elems);\n-        ArrayLiteralExp dest = cast(ArrayLiteralExp)ue.exp();\n+        ArrayLiteralExp dest = ue.exp().isArrayLiteralExp();\n         sliceAssignArrayLiteralFromString(dest, es, 0);\n         assert(ue.exp().type);\n         return ue;\n     }\n     else if (e1.op == EXP.string_ && e2.op == EXP.int64)\n     {\n         // string ~ char --> string\n-        StringExp es1 = cast(StringExp)e1;\n+        StringExp es1 = e1.isStringExp();\n         StringExp es;\n         const sz = es1.sz;\n         dinteger_t v = e2.toInteger();\n@@ -1668,7 +1655,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         else\n             utf_encode(sz, cast(char*)s + (sz * es1.len), cast(dchar)v);\n         emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-        es = cast(StringExp)ue.exp();\n+        es = ue.exp().isStringExp();\n         es.committed = es1.committed;\n         es.type = type;\n         assert(ue.exp().type);\n@@ -1679,7 +1666,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // [w|d]?char ~ string --> string\n         // We assume that we only ever prepend one char of the same type\n         // (wchar,dchar) as the string's characters.\n-        StringExp es2 = cast(StringExp)e2;\n+        StringExp es2 = e2.isStringExp();\n         const len = 1 + es2.len;\n         const sz = es2.sz;\n         dinteger_t v = e1.toInteger();\n@@ -1688,7 +1675,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         const data2 = es2.peekData();\n         memcpy(cast(char*)s + sz, data2.ptr, data2.length);\n         emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-        StringExp es = cast(StringExp)ue.exp();\n+        StringExp es = ue.exp().isStringExp();\n         es.sz = sz;\n         es.committed = es2.committed;\n         es.type = type;\n@@ -1796,7 +1783,7 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         }\n         if (!e.type.equals(type))\n         {\n-            StringExp se = cast(StringExp)e.copy();\n+            StringExp se = e.copy().isStringExp();\n             e = se.castTo(null, type);\n             emplaceExp!(UnionExp)(&ue, e);\n             e = ue.exp();\n@@ -1812,23 +1799,21 @@ UnionExp Ptr(Type type, Expression e1)\n {\n     //printf(\"Ptr(e1 = %s)\\n\", e1.toChars());\n     UnionExp ue = void;\n-    if (e1.op == EXP.add)\n+    if (AddExp ae = e1.isAddExp())\n     {\n-        AddExp ae = cast(AddExp)e1;\n-        if (ae.e1.op == EXP.address && ae.e2.op == EXP.int64)\n+        if (AddrExp ade = ae.e1.isAddrExp())\n         {\n-            AddrExp ade = cast(AddrExp)ae.e1;\n-            if (ade.e1.op == EXP.structLiteral)\n-            {\n-                StructLiteralExp se = cast(StructLiteralExp)ade.e1;\n-                uint offset = cast(uint)ae.e2.toInteger();\n-                Expression e = se.getField(type, offset);\n-                if (e)\n+            if (ae.e2.op == EXP.int64)\n+                if (StructLiteralExp se = ade.e1.isStructLiteralExp())\n                 {\n-                    emplaceExp!(UnionExp)(&ue, e);\n-                    return ue;\n+                    uint offset = cast(uint)ae.e2.toInteger();\n+                    Expression e = se.getField(type, offset);\n+                    if (e)\n+                    {\n+                        emplaceExp!(UnionExp)(&ue, e);\n+                        return ue;\n+                    }\n                 }\n-            }\n         }\n     }\n     cantExp(ue);"}, {"sha": "bb12aa7c995da8df852711e15fcf67ca03c0676e", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -981,7 +981,12 @@ final class CParser(AST) : Parser!AST\n                     e = new AST.DotIdExp(loc, e, Id.__sizeof);\n                     break;\n                 }\n+                // must be an expression\n+                e = cparsePrimaryExp();\n+                e = new AST.DotIdExp(loc, e, Id.__sizeof);\n+                break;\n             }\n+\n             e = cparseUnaryExp();\n             e = new AST.DotIdExp(loc, e, Id.__sizeof);\n             break;\n@@ -1016,10 +1021,16 @@ final class CParser(AST) : Parser!AST\n     {\n         if (token.value == TOK.leftParenthesis)\n         {\n+            //printf(\"cparseCastExp()\\n\");\n             auto tk = peek(&token);\n-            if (tk.value == TOK.identifier &&\n-                !isTypedef(tk.ident) &&\n-                peek(tk).value == TOK.rightParenthesis)\n+            bool iscast;\n+            bool isexp;\n+            if (tk.value == TOK.identifier)\n+            {\n+                iscast = isTypedef(tk.ident);\n+                isexp = !iscast;\n+            }\n+            if (isexp)\n             {\n                 // ( identifier ) is an expression\n                 return cparseUnaryExp();\n@@ -1045,9 +1056,18 @@ final class CParser(AST) : Parser!AST\n                     auto ce = new AST.CompoundLiteralExp(loc, t, ci);\n                     return cparsePostfixOperators(ce);\n                 }\n-                else if (t.isTypeIdentifier() &&\n-                         token.value == TOK.leftParenthesis &&\n-                         !isCastExpression(pt))\n+\n+                if (iscast)\n+                {\n+                    // ( type-name ) cast-expression\n+                    auto ce = cparseCastExp();\n+                    return new AST.CastExp(loc, ce, t);\n+                }\n+\n+                if (t.isTypeIdentifier() &&\n+                    isexp &&\n+                    token.value == TOK.leftParenthesis &&\n+                    !isCastExpression(pt))\n                 {\n                     /* (t)(...)... might be a cast expression or a function call,\n                      * with different grammars: a cast would be cparseCastExp(),\n@@ -1061,12 +1081,10 @@ final class CParser(AST) : Parser!AST\n                     AST.Expression e = new AST.CallExp(loc, ie, cparseArguments());\n                     return cparsePostfixOperators(e);\n                 }\n-                else\n-                {\n-                    // ( type-name ) cast-expression\n-                    auto ce = cparseCastExp();\n-                    return new AST.CastExp(loc, ce, t);\n-                }\n+\n+                // ( type-name ) cast-expression\n+                auto ce = cparseCastExp();\n+                return new AST.CastExp(loc, ce, t);\n             }\n         }\n         return cparseUnaryExp();\n@@ -1764,8 +1782,6 @@ final class CParser(AST) : Parser!AST\n                         symbols.push(stag);\n                         if (tt.tok == TOK.enum_)\n                         {\n-                            if (!stag.members)\n-                                error(tt.loc, \"`enum %s` has no members\", stag.toChars());\n                             isalias = false;\n                             s = new AST.AliasDeclaration(token.loc, id, stag);\n                         }\n@@ -2382,7 +2398,19 @@ final class CParser(AST) : Parser!AST\n                 const idx = previd.toString();\n                 if (idx.length > 2 && idx[0] == '_' && idx[1] == '_')  // leading double underscore\n                     importBuiltins = true;  // probably one of those compiler extensions\n-                t = new AST.TypeIdentifier(loc, previd);\n+                t = null;\n+                if (scw & SCW.xtypedef)\n+                {\n+                    /* Punch through to what the typedef is, to support things like:\n+                     *  typedef T* T;\n+                     */\n+                    auto pt = lookupTypedef(previd);\n+                    if (pt && *pt)      // if previd is a known typedef\n+                        t = *pt;\n+                }\n+\n+                if (!t)\n+                    t = new AST.TypeIdentifier(loc, previd);\n                 break;\n             }\n \n@@ -4767,7 +4795,8 @@ final class CParser(AST) : Parser!AST\n         scan(&n);\n         if (n.value == TOK.identifier && n.ident == Id.pack)\n             return pragmaPack(loc);\n-        skipToNextLine();\n+        if (n.value != TOK.endOfLine)\n+            skipToNextLine();\n     }\n \n     /*********\n@@ -4786,7 +4815,8 @@ final class CParser(AST) : Parser!AST\n         if (n.value != TOK.leftParenthesis)\n         {\n             error(loc, \"left parenthesis expected to follow `#pragma pack`\");\n-            skipToNextLine();\n+            if (n.value != TOK.endOfLine)\n+                skipToNextLine();\n             return;\n         }\n \n@@ -4796,7 +4826,8 @@ final class CParser(AST) : Parser!AST\n             {\n                 error(loc, \"right parenthesis expected to close `#pragma pack(`\");\n             }\n-            skipToNextLine();\n+            if (n.value != TOK.endOfLine)\n+                skipToNextLine();\n         }\n \n         void setPackAlign(ref const Token t)\n@@ -4923,7 +4954,8 @@ final class CParser(AST) : Parser!AST\n         }\n \n         error(loc, \"unrecognized `#pragma pack(%s)`\", n.toChars());\n-        skipToNextLine();\n+        if (n.value != TOK.endOfLine)\n+            skipToNextLine();\n     }\n \n     //}"}, {"sha": "32aed16e79693f2d65f64ef055db5f7282c3c6b2", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -232,11 +232,11 @@ bool needToCopyLiteral(const Expression expr)\n         switch (e.op)\n         {\n         case EXP.arrayLiteral:\n-            return (cast(ArrayLiteralExp)e).ownedByCtfe == OwnedBy.code;\n+            return e.isArrayLiteralExp().ownedByCtfe == OwnedBy.code;\n         case EXP.assocArrayLiteral:\n-            return (cast(AssocArrayLiteralExp)e).ownedByCtfe == OwnedBy.code;\n+            return e.isAssocArrayLiteralExp().ownedByCtfe == OwnedBy.code;\n         case EXP.structLiteral:\n-            return (cast(StructLiteralExp)e).ownedByCtfe == OwnedBy.code;\n+            return e.isStructLiteralExp().ownedByCtfe == OwnedBy.code;\n         case EXP.string_:\n         case EXP.this_:\n         case EXP.variable:\n@@ -247,14 +247,14 @@ bool needToCopyLiteral(const Expression expr)\n         case EXP.dotVariable:\n         case EXP.slice:\n         case EXP.cast_:\n-            e = (cast(UnaExp)e).e1;\n+            e = e.isUnaExp().e1;\n             continue;\n         case EXP.concatenate:\n-            return needToCopyLiteral((cast(BinExp)e).e1) || needToCopyLiteral((cast(BinExp)e).e2);\n+            return needToCopyLiteral(e.isBinExp().e1) || needToCopyLiteral(e.isBinExp().e2);\n         case EXP.concatenateAssign:\n         case EXP.concatenateElemAssign:\n         case EXP.concatenateDcharAssign:\n-            e = (cast(BinExp)e).e2;\n+            e = e.isBinExp().e2;\n             continue;\n         default:\n             return false;\n@@ -286,7 +286,7 @@ UnionExp copyLiteral(Expression e)\n         const slice = se.peekData();\n         memcpy(s, slice.ptr, slice.length);\n         emplaceExp!(StringExp)(&ue, se.loc, s[0 .. se.len * se.sz], se.len, se.sz);\n-        StringExp se2 = cast(StringExp)ue.exp();\n+        StringExp se2 = ue.exp().isStringExp();\n         se2.committed = se.committed;\n         se2.postfix = se.postfix;\n         se2.type = se.type;\n@@ -299,14 +299,14 @@ UnionExp copyLiteral(Expression e)\n \n         emplaceExp!(ArrayLiteralExp)(&ue, e.loc, e.type, elements);\n \n-        ArrayLiteralExp r = cast(ArrayLiteralExp)ue.exp();\n+        ArrayLiteralExp r = ue.exp().isArrayLiteralExp();\n         r.ownedByCtfe = OwnedBy.ctfe;\n         return ue;\n     }\n     if (auto aae = e.isAssocArrayLiteralExp())\n     {\n         emplaceExp!(AssocArrayLiteralExp)(&ue, e.loc, copyLiteralArray(aae.keys), copyLiteralArray(aae.values));\n-        AssocArrayLiteralExp r = cast(AssocArrayLiteralExp)ue.exp();\n+        AssocArrayLiteralExp r = ue.exp().isAssocArrayLiteralExp();\n         r.type = e.type;\n         r.ownedByCtfe = OwnedBy.ctfe;\n         return ue;\n@@ -482,7 +482,7 @@ private UnionExp paintTypeOntoLiteralCopy(Type type, Expression lit)\n         // just a ref to the keys and values.\n         OwnedBy wasOwned = aae.ownedByCtfe;\n         emplaceExp!(AssocArrayLiteralExp)(&ue, lit.loc, aae.keys, aae.values);\n-        aae = cast(AssocArrayLiteralExp)ue.exp();\n+        aae = ue.exp().isAssocArrayLiteralExp();\n         aae.ownedByCtfe = wasOwned;\n     }\n     else\n@@ -526,7 +526,7 @@ Expression resolveSlice(Expression e, UnionExp* pue = null)\n  * It's very wasteful to resolve the slice when we only\n  * need the length.\n  */\n-uinteger_t resolveArrayLength(const Expression e)\n+uinteger_t resolveArrayLength(Expression e)\n {\n     switch (e.op)\n     {\n@@ -538,7 +538,7 @@ uinteger_t resolveArrayLength(const Expression e)\n \n         case EXP.slice:\n         {\n-            auto se = cast(SliceExp)e;\n+            auto se = e.isSliceExp();\n             const ilo = se.lwr.toInteger();\n             const iup = se.upr.toInteger();\n             return iup - ilo;\n@@ -720,16 +720,16 @@ Expression getAggregateFromPointer(Expression e, dinteger_t* ofs)\n         *ofs = soe.offset;\n     if (auto dve = e.isDotVarExp())\n     {\n-        const ex = dve.e1;\n+        auto ex = dve.e1;\n         const v = dve.var.isVarDeclaration();\n         assert(v);\n         StructLiteralExp se = (ex.op == EXP.classReference)\n-            ? (cast(ClassReferenceExp)ex).value\n-            : cast(StructLiteralExp)ex;\n+            ? ex.isClassReferenceExp().value\n+            : ex.isStructLiteralExp();\n \n         // We can't use getField, because it makes a copy\n         const i = (ex.op == EXP.classReference)\n-            ? (cast(ClassReferenceExp)ex).getFieldIndex(e.type, v.offset)\n+            ? ex.isClassReferenceExp().getFieldIndex(e.type, v.offset)\n             : se.getFieldIndex(e.type, v.offset);\n         e = (*se.elements)[i];\n     }\n@@ -777,11 +777,11 @@ bool pointToSameMemoryBlock(Expression agg1, Expression agg2)\n     }\n     // Note that type painting can occur with VarExp, so we\n     // must compare the variables being pointed to.\n-    if (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var)\n+    if (agg1.op == EXP.variable && agg2.op == EXP.variable && agg1.isVarExp().var == agg2.isVarExp().var)\n     {\n         return true;\n     }\n-    if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset && (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n+    if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset && agg1.isSymOffExp().var == agg2.isSymOffExp().var)\n     {\n         return true;\n     }\n@@ -801,14 +801,14 @@ Expression pointerDifference(UnionExp* pue, const ref Loc loc, Type type, Expres\n         emplaceExp!(IntegerExp)(pue, loc, (ofs1 - ofs2) * sz, type);\n     }\n     else if (agg1.op == EXP.string_ && agg2.op == EXP.string_ &&\n-             (cast(StringExp)agg1).peekString().ptr == (cast(StringExp)agg2).peekString().ptr)\n+             agg1.isStringExp().peekString().ptr == agg2.isStringExp().peekString().ptr)\n     {\n         Type pointee = (cast(TypePointer)agg1.type).next;\n         const sz = pointee.size();\n         emplaceExp!(IntegerExp)(pue, loc, (ofs1 - ofs2) * sz, type);\n     }\n     else if (agg1.op == EXP.symbolOffset && agg2.op == EXP.symbolOffset &&\n-             (cast(SymOffExp)agg1).var == (cast(SymOffExp)agg2).var)\n+             agg1.isSymOffExp().var == agg2.isSymOffExp().var)\n     {\n         emplaceExp!(IntegerExp)(pue, loc, ofs1 - ofs2, type);\n     }\n@@ -832,12 +832,12 @@ Expression pointerArithmetic(UnionExp* pue, const ref Loc loc, EXP op, Type type\n         return pue.exp();\n     }\n     if (eptr.op == EXP.address)\n-        eptr = (cast(AddrExp)eptr).e1;\n+        eptr = eptr.isAddrExp().e1;\n     dinteger_t ofs1;\n     Expression agg1 = getAggregateFromPointer(eptr, &ofs1);\n     if (agg1.op == EXP.symbolOffset)\n     {\n-        if ((cast(SymOffExp)agg1).var.type.ty != Tsarray)\n+        if (agg1.isSymOffExp().var.type.ty != Tsarray)\n         {\n             error(loc, \"cannot perform pointer arithmetic on arrays of unknown length at compile time\");\n             goto Lcant;\n@@ -856,7 +856,7 @@ Expression pointerArithmetic(UnionExp* pue, const ref Loc loc, EXP op, Type type\n     if (agg1.op == EXP.symbolOffset)\n     {\n         indx = ofs1 / sz;\n-        len = (cast(TypeSArray)(cast(SymOffExp)agg1).var.type).dim.toInteger();\n+        len = (cast(TypeSArray)agg1.isSymOffExp().var.type).dim.toInteger();\n     }\n     else\n     {\n@@ -881,8 +881,8 @@ Expression pointerArithmetic(UnionExp* pue, const ref Loc loc, EXP op, Type type\n     }\n     if (agg1.op == EXP.symbolOffset)\n     {\n-        emplaceExp!(SymOffExp)(pue, loc, (cast(SymOffExp)agg1).var, indx * sz);\n-        SymOffExp se = cast(SymOffExp)pue.exp();\n+        emplaceExp!(SymOffExp)(pue, loc, agg1.isSymOffExp().var, indx * sz);\n+        SymOffExp se = pue.exp().isSymOffExp();\n         se.type = type;\n         return pue.exp();\n     }\n@@ -1016,7 +1016,7 @@ Expression paintFloatInt(UnionExp* pue, Expression fromVal, Type to)\n bool isCtfeComparable(Expression e)\n {\n     if (e.op == EXP.slice)\n-        e = (cast(SliceExp)e).e1;\n+        e = e.isSliceExp().e1;\n     if (e.isConst() != 1)\n     {\n         if (e.op == EXP.null_ || e.op == EXP.string_ || e.op == EXP.function_ || e.op == EXP.delegate_ || e.op == EXP.arrayLiteral || e.op == EXP.structLiteral || e.op == EXP.assocArrayLiteral || e.op == EXP.classReference)\n@@ -1191,16 +1191,16 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     if (e1.op == EXP.classReference || e2.op == EXP.classReference)\n     {\n         if (e1.op == EXP.classReference && e2.op == EXP.classReference &&\n-            (cast(ClassReferenceExp)e1).value == (cast(ClassReferenceExp)e2).value)\n+            e1.isClassReferenceExp().value == e2.isClassReferenceExp().value)\n             return 0;\n         return 1;\n     }\n     if (e1.op == EXP.typeid_ && e2.op == EXP.typeid_)\n     {\n         // printf(\"e1: %s\\n\", e1.toChars());\n         // printf(\"e2: %s\\n\", e2.toChars());\n-        Type t1 = isType((cast(TypeidExp)e1).obj);\n-        Type t2 = isType((cast(TypeidExp)e2).obj);\n+        Type t1 = isType(e1.isTypeidExp().obj);\n+        Type t2 = isType(e2.isTypeidExp().obj);\n         assert(t1);\n         assert(t2);\n         return t1 != t2;\n@@ -1214,7 +1214,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n         dinteger_t ofs1, ofs2;\n         Expression agg1 = getAggregateFromPointer(e1, &ofs1);\n         Expression agg2 = getAggregateFromPointer(e2, &ofs2);\n-        if ((agg1 == agg2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n+        if ((agg1 == agg2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && agg1.isVarExp().var == agg2.isVarExp().var))\n         {\n             if (ofs1 == ofs2)\n                 return 0;\n@@ -1232,13 +1232,13 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n             return 0;\n         assert(e1.op == EXP.delegate_ && e2.op == EXP.delegate_);\n         // Same .funcptr. Do they have the same .ptr?\n-        Expression ptr1 = (cast(DelegateExp)e1).e1;\n-        Expression ptr2 = (cast(DelegateExp)e2).e1;\n+        Expression ptr1 = e1.isDelegateExp().e1;\n+        Expression ptr2 = e2.isDelegateExp().e1;\n         dinteger_t ofs1, ofs2;\n         Expression agg1 = getAggregateFromPointer(ptr1, &ofs1);\n         Expression agg2 = getAggregateFromPointer(ptr2, &ofs2);\n         // If they are EXP.variable, it means they are FuncDeclarations\n-        if ((agg1 == agg2 && ofs1 == ofs2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && (cast(VarExp)agg1).var == (cast(VarExp)agg2).var))\n+        if ((agg1 == agg2 && ofs1 == ofs2) || (agg1.op == EXP.variable && agg2.op == EXP.variable && agg1.isVarExp().var == agg2.isVarExp().var))\n         {\n             return 0;\n         }\n@@ -1291,8 +1291,8 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     }\n     if (e1.op == EXP.structLiteral && e2.op == EXP.structLiteral)\n     {\n-        StructLiteralExp es1 = cast(StructLiteralExp)e1;\n-        StructLiteralExp es2 = cast(StructLiteralExp)e2;\n+        StructLiteralExp es1 = e1.isStructLiteralExp();\n+        StructLiteralExp es2 = e2.isStructLiteralExp();\n         // For structs, we only need to return 0 or 1 (< and > aren't legal).\n         if (es1.sd != es2.sd)\n             return 1;\n@@ -1326,8 +1326,8 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n     }\n     if (e1.op == EXP.assocArrayLiteral && e2.op == EXP.assocArrayLiteral)\n     {\n-        AssocArrayLiteralExp es1 = cast(AssocArrayLiteralExp)e1;\n-        AssocArrayLiteralExp es2 = cast(AssocArrayLiteralExp)e2;\n+        AssocArrayLiteralExp es1 = e1.isAssocArrayLiteralExp();\n+        AssocArrayLiteralExp es2 = e2.isAssocArrayLiteralExp();\n         size_t dim = es1.keys.dim;\n         if (es2.keys.dim != dim)\n             return 1;\n@@ -1394,8 +1394,8 @@ bool ctfeIdentity(const ref Loc loc, EXP op, Expression e1, Expression e2)\n     }\n     else if (e1.op == EXP.symbolOffset && e2.op == EXP.symbolOffset)\n     {\n-        SymOffExp es1 = cast(SymOffExp)e1;\n-        SymOffExp es2 = cast(SymOffExp)e2;\n+        SymOffExp es1 = e1.isSymOffExp();\n+        SymOffExp es2 = e2.isSymOffExp();\n         cmp = (es1.var == es2.var && es1.offset == es2.offset);\n     }\n     else if (e1.type.isreal())\n@@ -1443,8 +1443,8 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     if (e2.op == EXP.string_ && e1.op == EXP.arrayLiteral && t1.nextOf().isintegral())\n     {\n         // [chars] ~ string => string (only valid for CTFE)\n-        StringExp es1 = cast(StringExp)e2;\n-        ArrayLiteralExp es2 = cast(ArrayLiteralExp)e1;\n+        StringExp es1 = e2.isStringExp();\n+        ArrayLiteralExp es2 = e1.isArrayLiteralExp();\n         const len = es1.len + es2.elements.dim;\n         const sz = es1.sz;\n         void* s = mem.xmalloc((len + 1) * sz);\n@@ -1464,7 +1464,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // Add terminating 0\n         memset(cast(char*)s + len * sz, 0, sz);\n         emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-        StringExp es = cast(StringExp)ue.exp();\n+        StringExp es = ue.exp().isStringExp();\n         es.committed = 0;\n         es.type = type;\n         return ue;\n@@ -1473,8 +1473,8 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     {\n         // string ~ [chars] => string (only valid for CTFE)\n         // Concatenate the strings\n-        StringExp es1 = cast(StringExp)e1;\n-        ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n+        StringExp es1 = e1.isStringExp();\n+        ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         const len = es1.len + es2.elements.dim;\n         const sz = es1.sz;\n         void* s = mem.xmalloc((len + 1) * sz);\n@@ -1494,7 +1494,7 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         // Add terminating 0\n         memset(cast(char*)s + len * sz, 0, sz);\n         emplaceExp!(StringExp)(&ue, loc, s[0 .. len * sz], len, sz);\n-        StringExp es = cast(StringExp)ue.exp();\n+        StringExp es = ue.exp().isStringExp();\n         es.sz = sz;\n         es.committed = 0; //es1.committed;\n         es.type = type;\n@@ -1503,10 +1503,10 @@ UnionExp ctfeCat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     if (e1.op == EXP.arrayLiteral && e2.op == EXP.arrayLiteral && t1.nextOf().equals(t2.nextOf()))\n     {\n         //  [ e1 ] ~ [ e2 ] ---> [ e1, e2 ]\n-        ArrayLiteralExp es1 = cast(ArrayLiteralExp)e1;\n-        ArrayLiteralExp es2 = cast(ArrayLiteralExp)e2;\n+        ArrayLiteralExp es1 = e1.isArrayLiteralExp();\n+        ArrayLiteralExp es2 = e2.isArrayLiteralExp();\n         emplaceExp!(ArrayLiteralExp)(&ue, es1.loc, type, copyLiteralArray(es1.elements));\n-        es1 = cast(ArrayLiteralExp)ue.exp();\n+        es1 = ue.exp().isArrayLiteralExp();\n         es1.elements.insert(es1.elements.dim, copyLiteralArray(es2.elements));\n         return ue;\n     }\n@@ -1594,7 +1594,7 @@ Expression ctfeCast(UnionExp* pue, const ref Loc loc, Type type, Type to, Expres\n         // Disallow reinterpreting class casts. Do this by ensuring that\n         // the original class can implicitly convert to the target class.\n         // Also do not check 'alias this' for explicit cast expressions.\n-        auto tclass = (cast(ClassReferenceExp)e).originalClass().type.isTypeClass();\n+        auto tclass = e.isClassReferenceExp().originalClass().type.isTypeClass();\n         auto match = explicitCast ? tclass.implicitConvToWithoutAliasThis(to.mutableOf())\n                                   : tclass.implicitConvTo(to.mutableOf());\n         if (match)\n@@ -1665,9 +1665,9 @@ void assignInPlace(Expression dest, Expression src)\n     if (dest.op == EXP.structLiteral)\n     {\n         assert(dest.op == src.op);\n-        oldelems = (cast(StructLiteralExp)dest).elements;\n-        newelems = (cast(StructLiteralExp)src).elements;\n-        auto sd = (cast(StructLiteralExp)dest).sd;\n+        oldelems = dest.isStructLiteralExp().elements;\n+        newelems = src.isStructLiteralExp().elements;\n+        auto sd = dest.isStructLiteralExp().sd;\n         const nfields = sd.nonHiddenFields();\n         const nvthis = sd.fields.dim - nfields;\n         if (nvthis && oldelems.dim >= nfields && oldelems.dim < newelems.dim)\n@@ -1676,22 +1676,22 @@ void assignInPlace(Expression dest, Expression src)\n     }\n     else if (dest.op == EXP.arrayLiteral && src.op == EXP.arrayLiteral)\n     {\n-        oldelems = (cast(ArrayLiteralExp)dest).elements;\n-        newelems = (cast(ArrayLiteralExp)src).elements;\n+        oldelems = dest.isArrayLiteralExp().elements;\n+        newelems = src.isArrayLiteralExp().elements;\n     }\n     else if (dest.op == EXP.string_ && src.op == EXP.string_)\n     {\n-        sliceAssignStringFromString(cast(StringExp)dest, cast(StringExp)src, 0);\n+        sliceAssignStringFromString(dest.isStringExp(), src.isStringExp(), 0);\n         return;\n     }\n     else if (dest.op == EXP.arrayLiteral && src.op == EXP.string_)\n     {\n-        sliceAssignArrayLiteralFromString(cast(ArrayLiteralExp)dest, cast(StringExp)src, 0);\n+        sliceAssignArrayLiteralFromString(dest.isArrayLiteralExp(), src.isStringExp(), 0);\n         return;\n     }\n     else if (src.op == EXP.arrayLiteral && dest.op == EXP.string_)\n     {\n-        sliceAssignStringFromArrayLiteral(cast(StringExp)dest, cast(ArrayLiteralExp)src, 0);\n+        sliceAssignStringFromArrayLiteral(dest.isStringExp(), src.isArrayLiteralExp(), 0);\n         return;\n     }\n     else\n@@ -1761,13 +1761,13 @@ Expression changeArrayLiteralLength(UnionExp* pue, const ref Loc loc, TypeArray\n     size_t indxlo = 0;\n     if (oldval.op == EXP.slice)\n     {\n-        indxlo = cast(size_t)(cast(SliceExp)oldval).lwr.toInteger();\n-        oldval = (cast(SliceExp)oldval).e1;\n+        indxlo = cast(size_t)oldval.isSliceExp().lwr.toInteger();\n+        oldval = oldval.isSliceExp().e1;\n     }\n     size_t copylen = oldlen < newlen ? oldlen : newlen;\n     if (oldval.op == EXP.string_)\n     {\n-        StringExp oldse = cast(StringExp)oldval;\n+        StringExp oldse = oldval.isStringExp();\n         void* s = mem.xcalloc(newlen + 1, oldse.sz);\n         const data = oldse.peekData();\n         memcpy(s, data.ptr, copylen * oldse.sz);\n@@ -1790,7 +1790,7 @@ Expression changeArrayLiteralLength(UnionExp* pue, const ref Loc loc, TypeArray\n             }\n         }\n         emplaceExp!(StringExp)(pue, loc, s[0 .. newlen * oldse.sz], newlen, oldse.sz);\n-        StringExp se = cast(StringExp)pue.exp();\n+        StringExp se = pue.exp().isStringExp();\n         se.type = arrayType;\n         se.sz = oldse.sz;\n         se.committed = oldse.committed;\n@@ -1801,7 +1801,7 @@ Expression changeArrayLiteralLength(UnionExp* pue, const ref Loc loc, TypeArray\n         if (oldlen != 0)\n         {\n             assert(oldval.op == EXP.arrayLiteral);\n-            ArrayLiteralExp ae = cast(ArrayLiteralExp)oldval;\n+            ArrayLiteralExp ae = oldval.isArrayLiteralExp();\n             foreach (size_t i; 0 .. copylen)\n                 (*elements)[i] = (*ae.elements)[indxlo + i];\n         }\n@@ -1819,7 +1819,7 @@ Expression changeArrayLiteralLength(UnionExp* pue, const ref Loc loc, TypeArray\n                 (*elements)[i] = defaultElem;\n         }\n         emplaceExp!(ArrayLiteralExp)(pue, loc, arrayType, elements);\n-        ArrayLiteralExp aae = cast(ArrayLiteralExp)pue.exp();\n+        ArrayLiteralExp aae = pue.exp().isArrayLiteralExp();\n         aae.ownedByCtfe = OwnedBy.ctfe;\n     }\n     return pue.exp();\n@@ -1874,14 +1874,14 @@ bool isCtfeValueValid(Expression newval)\n         {\n             // &struct.func or &clasinst.func\n             // &nestedfunc\n-            Expression ethis = (cast(DelegateExp)newval).e1;\n-            return (ethis.op == EXP.structLiteral || ethis.op == EXP.classReference || ethis.op == EXP.variable && (cast(VarExp)ethis).var == (cast(DelegateExp)newval).func);\n+            Expression ethis = newval.isDelegateExp().e1;\n+            return (ethis.op == EXP.structLiteral || ethis.op == EXP.classReference || ethis.op == EXP.variable && ethis.isVarExp().var == newval.isDelegateExp().func);\n         }\n \n         case EXP.symbolOffset:\n         {\n             // function pointer, or pointer to static variable\n-            Declaration d = (cast(SymOffExp)newval).var;\n+            Declaration d = newval.isSymOffExp().var;\n             return d.isFuncDeclaration() || d.isDataseg();\n         }\n \n@@ -1894,7 +1894,7 @@ bool isCtfeValueValid(Expression newval)\n         case EXP.address:\n         {\n             // e1 should be a CTFE reference\n-            Expression e1 = (cast(AddrExp)newval).e1;\n+            Expression e1 = newval.isAddrExp().e1;\n             return tb.ty == Tpointer &&\n             (\n                 (e1.op == EXP.structLiteral || e1.op == EXP.arrayLiteral) && isCtfeValueValid(e1) ||\n@@ -1908,7 +1908,7 @@ bool isCtfeValueValid(Expression newval)\n         case EXP.slice:\n         {\n             // e1 should be an array aggregate\n-            const SliceExp se = cast(SliceExp)newval;\n+            const SliceExp se = newval.isSliceExp();\n             assert(se.lwr && se.lwr.op == EXP.int64);\n             assert(se.upr && se.upr.op == EXP.int64);\n             return (tb.ty == Tarray || tb.ty == Tsarray) && (se.e1.op == EXP.string_ || se.e1.op == EXP.arrayLiteral);\n@@ -1932,21 +1932,21 @@ bool isCtfeReferenceValid(Expression newval)\n \n         case EXP.variable:\n         {\n-            const VarDeclaration v = (cast(VarExp)newval).var.isVarDeclaration();\n+            const VarDeclaration v = newval.isVarExp().var.isVarDeclaration();\n             assert(v);\n             // Must not be a reference to a reference\n             return true;\n         }\n \n         case EXP.index:\n         {\n-            const Expression eagg = (cast(IndexExp)newval).e1;\n+            const Expression eagg = newval.isIndexExp().e1;\n             return eagg.op == EXP.string_ || eagg.op == EXP.arrayLiteral || eagg.op == EXP.assocArrayLiteral;\n         }\n \n         case EXP.dotVariable:\n         {\n-            Expression eagg = (cast(DotVarExp)newval).e1;\n+            Expression eagg = newval.isDotVarExp().e1;\n             return (eagg.op == EXP.structLiteral || eagg.op == EXP.classReference) && isCtfeValueValid(eagg);\n         }\n \n@@ -1968,19 +1968,19 @@ void showCtfeExpr(Expression e, int level = 0)\n     ClassDeclaration cd = null;\n     if (e.op == EXP.structLiteral)\n     {\n-        elements = (cast(StructLiteralExp)e).elements;\n-        sd = (cast(StructLiteralExp)e).sd;\n+        elements = e.isStructLiteralExp().elements;\n+        sd = e.isStructLiteralExp().sd;\n         printf(\"STRUCT type = %s %p:\\n\", e.type.toChars(), e);\n     }\n     else if (e.op == EXP.classReference)\n     {\n-        elements = (cast(ClassReferenceExp)e).value.elements;\n-        cd = (cast(ClassReferenceExp)e).originalClass();\n-        printf(\"CLASS type = %s %p:\\n\", e.type.toChars(), (cast(ClassReferenceExp)e).value);\n+        elements = e.isClassReferenceExp().value.elements;\n+        cd = e.isClassReferenceExp().originalClass();\n+        printf(\"CLASS type = %s %p:\\n\", e.type.toChars(), e.isClassReferenceExp().value);\n     }\n     else if (e.op == EXP.arrayLiteral)\n     {\n-        elements = (cast(ArrayLiteralExp)e).elements;\n+        elements = e.isArrayLiteralExp().elements;\n         printf(\"ARRAY LITERAL type=%s %p:\\n\", e.type.toChars(), e);\n     }\n     else if (e.op == EXP.assocArrayLiteral)\n@@ -1994,19 +1994,19 @@ void showCtfeExpr(Expression e, int level = 0)\n     else if (e.op == EXP.slice)\n     {\n         printf(\"SLICE %p: %s\\n\", e, e.toChars());\n-        showCtfeExpr((cast(SliceExp)e).e1, level + 1);\n+        showCtfeExpr(e.isSliceExp().e1, level + 1);\n     }\n     else if (e.op == EXP.variable)\n     {\n         printf(\"VAR %p %s\\n\", e, e.toChars());\n-        VarDeclaration v = (cast(VarExp)e).var.isVarDeclaration();\n+        VarDeclaration v = e.isVarExp().var.isVarDeclaration();\n         if (v && getValue(v))\n             showCtfeExpr(getValue(v), level + 1);\n     }\n     else if (e.op == EXP.address)\n     {\n         // This is potentially recursive. We mustn't try to print the thing we're pointing to.\n-        printf(\"POINTER %p to %p: %s\\n\", e, (cast(AddrExp)e).e1, e.toChars());\n+        printf(\"POINTER %p to %p: %s\\n\", e, e.isAddrExp().e1, e.toChars());\n     }\n     else\n         printf(\"VALUE %p: %s\\n\", e, e.toChars());\n@@ -2086,7 +2086,7 @@ UnionExp voidInitLiteral(Type t, VarDeclaration var)\n             (*elements)[i] = elem;\n         }\n         emplaceExp!(ArrayLiteralExp)(&ue, var.loc, tsa, elements);\n-        ArrayLiteralExp ae = cast(ArrayLiteralExp)ue.exp();\n+        ArrayLiteralExp ae = ue.exp().isArrayLiteralExp();\n         ae.ownedByCtfe = OwnedBy.ctfe;\n     }\n     else if (t.ty == Tstruct)\n@@ -2098,7 +2098,7 @@ UnionExp voidInitLiteral(Type t, VarDeclaration var)\n             (*exps)[i] = voidInitLiteral(ts.sym.fields[i].type, ts.sym.fields[i]).copy();\n         }\n         emplaceExp!(StructLiteralExp)(&ue, var.loc, ts.sym, exps);\n-        StructLiteralExp se = cast(StructLiteralExp)ue.exp();\n+        StructLiteralExp se = ue.exp().isStructLiteralExp();\n         se.type = ts;\n         se.ownedByCtfe = OwnedBy.ctfe;\n     }"}, {"sha": "c04793dfb18bee330acc37243675cfff0e25af51", "filename": "gcc/d/dmd/ctorflow.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fctorflow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fctorflow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctorflow.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -222,4 +222,3 @@ bool mergeFieldInit(ref CSX a, const CSX b) pure nothrow\n     }\n     return ok;\n }\n-"}, {"sha": "685987b734d42a38bf3c0cf0a538a93dfbe8f69a", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3880,4 +3880,3 @@ IntRange getIntRange(Expression e)\n         case EXP.negate             : return visitNeg(e.isNegExp());\n     }\n }\n-"}, {"sha": "c0e40a5263a08f70405951f7a6865d9fb16d7982", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 42, "deletions": 73, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -292,7 +292,7 @@ extern (C++) abstract class Declaration : Dsymbol\n                  * postblit. Print the first field that has\n                  * a disabled postblit.\n                  */\n-                if (postblit.generated)\n+                if (postblit.isGenerated())\n                 {\n                     auto sd = p.isStructDeclaration();\n                     assert(sd);\n@@ -334,7 +334,7 @@ extern (C++) abstract class Declaration : Dsymbol\n \n         if (auto ctor = isCtorDeclaration())\n         {\n-            if (ctor.isCpCtor && ctor.generated)\n+            if (ctor.isCpCtor && ctor.isGenerated())\n             {\n                 .error(loc, \"Generating an `inout` copy constructor for `struct %s` failed, therefore instances of it are uncopyable\", parent.toPrettyChars());\n                 return true;\n@@ -1060,24 +1060,51 @@ extern (C++) class VarDeclaration : Declaration\n     enum AdrOnStackNone = ~0u;\n     uint ctfeAdrOnStack;\n \n-    bool isargptr;                  // if parameter that _argptr points to\n-    bool ctorinit;                  // it has been initialized in a ctor\n-    bool iscatchvar;                // this is the exception object variable in catch() clause\n-    bool isowner;                   // this is an Owner, despite it being `scope`\n-    bool setInCtorOnly;             // field can only be set in a constructor, as it is const or immutable\n+    // `bool` fields that are compacted into bit fields in a string mixin\n+    private extern (D) static struct BitFields\n+    {\n+        bool isargptr;          /// if parameter that _argptr points to\n+        bool ctorinit;          /// it has been initialized in a ctor\n+        bool iscatchvar;        /// this is the exception object variable in catch() clause\n+        bool isowner;           /// this is an Owner, despite it being `scope`\n+        bool setInCtorOnly;     /// field can only be set in a constructor, as it is const or immutable\n+\n+        /// It is a class that was allocated on the stack\n+        ///\n+        /// This means the var is not rebindable once assigned,\n+        /// and the destructor gets run when it goes out of scope\n+        bool onstack;\n \n-    // Both these mean the var is not rebindable once assigned,\n-    // and the destructor gets run when it goes out of scope\n-    bool onstack;                   // it is a class that was allocated on the stack\n+        bool overlapped;        /// if it is a field and has overlapping\n+        bool overlapUnsafe;     /// if it is an overlapping field and the overlaps are unsafe\n+        bool doNotInferScope;   /// do not infer 'scope' for this variable\n+        bool doNotInferReturn;  /// do not infer 'return' for this variable\n+\n+        bool isArgDtorVar;      /// temporary created to handle scope destruction of a function argument\n+    }\n \n+    private ushort bitFields;       // stores multiple booleans for BitFields\n     byte canassign;                 // it can be assigned to\n-    bool overlapped;                // if it is a field and has overlapping\n-    bool overlapUnsafe;             // if it is an overlapping field and the overlaps are unsafe\n-    bool doNotInferScope;           // do not infer 'scope' for this variable\n-    bool doNotInferReturn;          // do not infer 'return' for this variable\n     ubyte isdataseg;                // private data for isDataseg 0 unset, 1 true, 2 false\n \n-    bool isArgDtorVar;              // temporary created to handle scope destruction of a function argument\n+    // Generate getter and setter functions for `bitFields`\n+    extern (D) mixin(() {\n+        string result = \"extern (C++) pure nothrow @nogc @safe final {\";\n+        foreach (size_t i, mem; __traits(allMembers, BitFields))\n+        {\n+            result ~= \"\n+            /// set or get the corresponding BitFields member\n+            bool \"~mem~\"() const { return !!(bitFields & (1 << \"~i.stringof~\")); }\n+            /// ditto\n+            bool \"~mem~\"(bool v)\n+            {\n+                v ? (bitFields |= (1 << \"~i.stringof~\")) : (bitFields &= ~(1 << \"~i.stringof~\"));\n+                return v;\n+            }\";\n+        }\n+        return result ~ \"}\";\n+    }());\n+\n \n     final extern (D) this(const ref Loc loc, Type type, Identifier ident, Initializer _init, StorageClass storage_class = STC.undefined_)\n     in\n@@ -1642,64 +1669,6 @@ extern (C++) class VarDeclaration : Declaration\n     {\n         v.visit(this);\n     }\n-\n-    /**********************************\n-     * Determine if `this` has a lifetime that lasts past\n-     * the destruction of `v`\n-     * Params:\n-     *  v = variable to test against\n-     * Returns:\n-     *  true if it does\n-     */\n-    final bool enclosesLifetimeOf(VarDeclaration v) const pure\n-    {\n-        // VarDeclaration's with these STC's need special treatment\n-        enum special = STC.temp | STC.foreach_;\n-\n-        // Sequence numbers work when there are no special VarDeclaration's involved\n-        if (!((this.storage_class | v.storage_class) & special))\n-        {\n-            assert(this.sequenceNumber != this.sequenceNumber.init);\n-            assert(v.sequenceNumber != v.sequenceNumber.init);\n-\n-            return (this.sequenceNumber < v.sequenceNumber);\n-        }\n-\n-        // Assume that semantic produces temporaries according to their lifetime\n-        // (It won't create a temporary before the actual content)\n-        if ((this.storage_class & special) && (v.storage_class & special))\n-            return this.sequenceNumber < v.sequenceNumber;\n-\n-        // Fall back to lexical order\n-        assert(this.loc != Loc.initial);\n-        assert(v.loc != Loc.initial);\n-\n-        if (this.loc.linnum != v.loc.linnum)\n-            return this.loc.linnum < v.loc.linnum;\n-\n-        if (this.loc.charnum != v.loc.charnum)\n-            return this.loc.charnum < v.loc.charnum;\n-\n-        // Default fallback\n-        return this.sequenceNumber < v.sequenceNumber;\n-    }\n-\n-    /***************************************\n-     * Add variable to maybes[].\n-     * When a maybescope variable `v` is assigned to a maybescope variable `this`,\n-     * we cannot determine if `this` is actually scope until the semantic\n-     * analysis for the function is completed. Thus, we save the data\n-     * until then.\n-     * Params:\n-     *  v = an STC.maybescope variable that was assigned to `this`\n-     */\n-    final void addMaybe(VarDeclaration v)\n-    {\n-        //printf(\"add %s to %s's list of dependencies\\n\", v.toChars(), toChars());\n-        if (!maybes)\n-            maybes = new VarDeclarations();\n-        maybes.push(v);\n-    }\n }\n \n /*******************************************************"}, {"sha": "441a966cf4d21295bc38546976430d5fbbc014fd", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -241,22 +241,33 @@ class VarDeclaration : public Declaration\n     // When interpreting, these point to the value (NULL if value not determinable)\n     // The index of this variable on the CTFE stack, ~0u if not allocated\n     unsigned ctfeAdrOnStack;\n-\n-    bool isargptr;              // if parameter that _argptr points to\n-    bool ctorinit;              // it has been initialized in a ctor\n-    bool iscatchvar;            // this is the exception object variable in catch() clause\n-    bool isowner;               // this is an Owner, despite it being `scope`\n-    bool setInCtorOnly;         // field can only be set in a constructor, as it is const or immutable\n-    bool onstack;               // it is a class that was allocated on the stack\n-    char canassign;             // it can be assigned to\n-    bool overlapped;            // if it is a field and has overlapping\n-    bool overlapUnsafe;         // if it is an overlapping field and the overlaps are unsafe\n-    bool doNotInferScope;       // do not infer 'scope' for this variable\n-    bool doNotInferReturn;      // do not infer 'return' for this variable\n-    unsigned char isdataseg;    // private data for isDataseg\n-    bool isArgDtorVar;          // temporary created to handle scope destruction of a function argument\n-\n-public:\n+private:\n+    uint16_t bitFields;\n+public:\n+    int8_t canassign; // // it can be assigned to\n+    uint8_t isdataseg; // private data for isDataseg\n+    bool isargptr() const; // if parameter that _argptr points to\n+    bool isargptr(bool v);\n+    bool ctorinit() const; // it has been initialized in a ctor\n+    bool ctorinit(bool v);\n+    bool iscatchvar() const; // this is the exception object variable in catch() clause\n+    bool iscatchvar(bool v);\n+    bool isowner() const; // this is an Owner, despite it being `scope`\n+    bool isowner(bool v);\n+    bool setInCtorOnly() const; // field can only be set in a constructor, as it is const or immutable\n+    bool setInCtorOnly(bool v);\n+    bool onstack() const; // it is a class that was allocated on the stack\n+    bool onstack(bool v);\n+    bool overlapped() const; // if it is a field and has overlapping\n+    bool overlapped(bool v);\n+    bool overlapUnsafe() const; // if it is an overlapping field and the overlaps are unsafe\n+    bool overlapUnsafe(bool v);\n+    bool doNotInferScope() const; // do not infer 'scope' for this variable\n+    bool doNotInferScope(bool v);\n+    bool doNotInferReturn() const; // do not infer 'return' for this variable\n+    bool doNotInferReturn(bool v);\n+    bool isArgDtorVar() const; // temporary created to handle scope destruction of a function argument\n+    bool isArgDtorVar(bool v);\n     static VarDeclaration *create(const Loc &loc, Type *t, Identifier *id, Initializer *init, StorageClass storage_class = STCundefined);\n     VarDeclaration *syntaxCopy(Dsymbol *);\n     void setFieldOffset(AggregateDeclaration *ad, FieldState& fieldState, bool isunion);\n@@ -273,7 +284,6 @@ class VarDeclaration : public Declaration\n     bool hasPointers();\n     bool canTakeAddressOf();\n     bool needsScopeDtor();\n-    bool enclosesLifetimeOf(VarDeclaration *v) const;\n     void checkCtorConstInit();\n     Dsymbol *toAlias();\n     // Eliminate need for dynamic_cast\n@@ -541,7 +551,6 @@ class FuncDeclaration : public Declaration\n     // scopes from having the same name\n     DsymbolTable *localsymtab;\n     VarDeclaration *vthis;              // 'this' parameter (member and nested)\n-    bool isThis2;                       // has a dual-context 'this' parameter\n     VarDeclaration *v_arguments;        // '_arguments' parameter\n \n     VarDeclaration *v_argptr;           // '_argptr' variable\n@@ -551,29 +560,20 @@ class FuncDeclaration : public Declaration\n     FuncDeclaration *overnext0;         // next in overload list (only used during IFTI)\n     Loc endloc;                         // location of closing curly bracket\n     int vtblIndex;                      // for member functions, index into vtbl[]\n-    bool naked;                         // true if naked\n-    bool generated;                     // true if function was generated by the compiler rather than\n-                                        // supplied by the user\n-    bool hasAlwaysInlines;              // contains references to functions that must be inlined\n-    unsigned char isCrtCtorDtor;        // has attribute pragma(crt_constructor(1)/crt_destructor(2))\n-                                        // not set before the glue layer\n+\n     ILS inlineStatusStmt;\n     ILS inlineStatusExp;\n     PINLINE inlining;\n \n     int inlineNest;                     // !=0 if nested inline\n-    bool eh_none;                       /// true if no exception unwinding is needed\n \n     // true if errors in semantic3 this function's frame ptr\n-    bool semantic3Errors;\n     ForeachStatement *fes;              // if foreach body, this is the foreach\n     BaseClass* interfaceVirtual;        // if virtual, but only appears in interface vtbl[]\n-    bool introducing;                   // true if 'introducing' function\n     // if !=NULL, then this is the type\n     // of the 'introducing' function\n     // this one is overriding\n     Type *tintro;\n-    bool inferRetType;                  // true if return type is to be inferred\n     StorageClass storage_class2;        // storage class for template onemember's\n \n     // Things that should really go into Scope\n@@ -585,8 +585,6 @@ class FuncDeclaration : public Declaration\n     // 16 if there are multiple return statements\n     int hasReturnExp;\n \n-    // Support for NRVO (named return value optimization)\n-    bool nrvo_can;                      // true means we can do it\n     VarDeclaration *nrvo_var;           // variable to replace with shidden\n     Symbol *shidden;                    // hidden pointer passed to function\n \n@@ -654,6 +652,19 @@ class FuncDeclaration : public Declaration\n \n     bool isNogc();\n     bool isNogcBypassingInference();\n+    bool isNRVO() const;\n+    void isNRVO(bool v);\n+    bool isNaked() const;\n+    bool isGenerated() const;\n+    void isGenerated(bool v);\n+    bool isIntroducing() const;\n+    bool hasSemantic3Errors() const;\n+    bool hasNoEH() const;\n+    bool inferRetType() const;\n+    bool hasDualContext() const;\n+    bool hasAlwaysInlines() const;\n+    bool isCrtCtor() const;\n+    bool isCrtDtor() const;\n \n     virtual bool isNested() const;\n     AggregateDeclaration *isThis();"}, {"sha": "aba290bed05c12547c7271691a7246bfb9b15f32", "filename": "gcc/d/dmd/denum.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdenum.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdenum.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -96,7 +96,7 @@ extern (C++) final class EnumDeclaration : ScopeDsymbol\n \n     override void setScope(Scope* sc)\n     {\n-        if (semanticRun > PASS.init)\n+        if (semanticRun > PASS.initial)\n             return;\n         ScopeDsymbol.setScope(sc);\n     }\n@@ -163,6 +163,9 @@ extern (C++) final class EnumDeclaration : ScopeDsymbol\n         if (defaultval)\n             return defaultval;\n \n+        if (isCsymbol())\n+            return memtype.defaultInit(loc, true);\n+\n         if (_scope)\n             dsymbolSemantic(this, _scope);\n         if (errors)"}, {"sha": "3cfc07ab9105a5104ede390609d7363c7734e9ef", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 76, "deletions": 74, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -535,7 +535,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n     istatex.caller = istate;\n     istatex.fd = fd;\n \n-    if (fd.isThis2)\n+    if (fd.hasDualContext())\n     {\n         Expression arg0 = thisarg;\n         if (arg0 && arg0.type.ty == Tstruct)\n@@ -678,7 +678,7 @@ private Expression interpretFunction(UnionExp* pue, FuncDeclaration fd, InterSta\n         e = CTFEExp.voidexp;\n     if (tf.isref && e.op == EXP.variable && e.isVarExp().var == fd.vthis)\n         e = thisarg;\n-    if (tf.isref && fd.isThis2 && e.op == EXP.index)\n+    if (tf.isref && fd.hasDualContext() && e.op == EXP.index)\n     {\n         auto ie = e.isIndexExp();\n         auto pe = ie.e1.isPtrExp();\n@@ -944,7 +944,7 @@ public:\n             if (auto eaddr = e.isAddrExp())\n                 x = eaddr.e1;\n             VarDeclaration v;\n-            while (x.op == EXP.variable && (v = (cast(VarExp)x).var.isVarDeclaration()) !is null)\n+            while (x.op == EXP.variable && (v = x.isVarExp().var.isVarDeclaration()) !is null)\n             {\n                 if (v.storage_class & STC.ref_)\n                 {\n@@ -1526,7 +1526,7 @@ public:\n         }\n         while ((*boss.value.elements)[next].op == EXP.classReference)\n         {\n-            boss = cast(ClassReferenceExp)(*boss.value.elements)[next];\n+            boss = (*boss.value.elements)[next].isClassReferenceExp();\n         }\n         (*boss.value.elements)[next] = collateral;\n         return oldest;\n@@ -1752,7 +1752,7 @@ public:\n             if (istate && istate.fd.vthis)\n             {\n                 result = ctfeEmplaceExp!VarExp(e.loc, istate.fd.vthis);\n-                if (istate.fd.isThis2)\n+                if (istate.fd.hasDualContext())\n                 {\n                     result = ctfeEmplaceExp!PtrExp(e.loc, result);\n                     result.type = Type.tvoidptr.sarrayOf(2);\n@@ -1768,15 +1768,15 @@ public:\n         result = ctfeGlobals.stack.getThis();\n         if (result)\n         {\n-            if (istate && istate.fd.isThis2)\n+            if (istate && istate.fd.hasDualContext())\n             {\n                 assert(result.op == EXP.address);\n-                result = (cast(AddrExp)result).e1;\n+                result = result.isAddrExp().e1;\n                 assert(result.op == EXP.arrayLiteral);\n-                result = (*(cast(ArrayLiteralExp)result).elements)[0];\n+                result = (*result.isArrayLiteralExp().elements)[0];\n                 if (e.type.ty == Tstruct)\n                 {\n-                    result = (cast(AddrExp)result).e1;\n+                    result = result.isAddrExp().e1;\n                 }\n                 return;\n             }\n@@ -1873,7 +1873,9 @@ public:\n         {\n             fromType = (cast(TypeArray)e.var.type).next;\n         }\n-        if (e.var.isDataseg() && ((e.offset == 0 && isSafePointerCast(e.var.type, pointee)) || (fromType && isSafePointerCast(fromType, pointee))))\n+        if (e.var.isDataseg() && ((e.offset == 0 && isSafePointerCast(e.var.type, pointee)) ||\n+                                  (fromType && isSafePointerCast(fromType, pointee)) ||\n+                                  (e.var.isCsymbol() && e.offset + pointee.size() <= e.var.type.size())))\n         {\n             result = e;\n             return;\n@@ -1980,7 +1982,7 @@ public:\n             if (decl.isDataseg()) {\n                 // Normally this is already done by optimize()\n                 // Do it here in case optimize(WANTvalue) wasn't run before CTFE\n-                emplaceExp!(SymOffExp)(pue, e.loc, (cast(VarExp)e.e1).var, 0);\n+                emplaceExp!(SymOffExp)(pue, e.loc, e.e1.isVarExp().var, 0);\n                 result = pue.exp();\n                 result.type = e.type;\n                 return;\n@@ -2399,7 +2401,7 @@ public:\n                 return;\n             }\n \n-            ClassDeclaration cd = (cast(ClassReferenceExp)result).originalClass();\n+            ClassDeclaration cd = result.isClassReferenceExp().originalClass();\n             assert(cd);\n \n             emplaceExp!(TypeidExp)(pue, e.loc, cd.type);\n@@ -2487,7 +2489,7 @@ public:\n             else\n             {\n                 // segfault bug 6250\n-                assert(exp.op != EXP.index || (cast(IndexExp)exp).e1 != e);\n+                assert(exp.op != EXP.index || exp.isIndexExp().e1 != e);\n \n                 ex = interpretRegion(exp, istate);\n                 if (exceptionOrCant(ex))\n@@ -2521,7 +2523,7 @@ public:\n                 return;\n             }\n             emplaceExp!(ArrayLiteralExp)(pue, e.loc, e.type, basis, expsx);\n-            auto ale = cast(ArrayLiteralExp)pue.exp();\n+            auto ale = pue.exp().isArrayLiteralExp();\n             ale.ownedByCtfe = OwnedBy.ctfe;\n             result = ale;\n         }\n@@ -2705,7 +2707,7 @@ public:\n                 return;\n             }\n             emplaceExp!(StructLiteralExp)(pue, e.loc, e.sd, expsx);\n-            auto sle = cast(StructLiteralExp)pue.exp();\n+            auto sle = pue.exp().isStructLiteralExp();\n             sle.type = e.type;\n             sle.ownedByCtfe = OwnedBy.ctfe;\n             sle.origin = e.origin;\n@@ -2737,7 +2739,7 @@ public:\n             foreach (ref element; *elements)\n                 element = copyLiteral(elem).copy();\n             emplaceExp!(ArrayLiteralExp)(pue, loc, newtype, elements);\n-            auto ae = cast(ArrayLiteralExp)pue.exp();\n+            auto ae = pue.exp().isArrayLiteralExp();\n             ae.ownedByCtfe = OwnedBy.ctfe;\n             return ae;\n         }\n@@ -2959,7 +2961,7 @@ public:\n             result = e; // optimize: reuse this CTFE reference\n         else\n         {\n-            auto edt = cast(DotTypeExp)e.copy();\n+            auto edt = e.copy().isDotTypeExp();\n             edt.e1 = (e1 == ue.exp()) ? e1.copy() : e1; // don't return pointer to ue\n             result = edt;\n         }\n@@ -3335,7 +3337,7 @@ public:\n             if (exceptionOrCant(newval))\n                 return;\n \n-            VarDeclaration v = (cast(VarExp)e1).var.isVarDeclaration();\n+            VarDeclaration v = e1.isVarExp().var.isVarDeclaration();\n             setValue(v, newval);\n \n             // Get the value to return. Note that 'newval' is an Lvalue,\n@@ -3351,7 +3353,7 @@ public:\n         {\n             while (e1.op == EXP.cast_)\n             {\n-                CastExp ce = cast(CastExp)e1;\n+                CastExp ce = e1.isCastExp();\n                 e1 = ce.e1;\n             }\n         }\n@@ -3362,7 +3364,7 @@ public:\n         AssocArrayLiteralExp existingAA = null;\n         Expression lastIndex = null;\n         Expression oldval = null;\n-        if (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+        if (e1.op == EXP.index && e1.isIndexExp().e1.type.toBasetype().ty == Taarray)\n         {\n             // ---------------------------------------\n             //      Deal with AA index assignment\n@@ -3374,12 +3376,12 @@ public:\n              * (2) If the ultimate AA is null, no insertion happens at all. Instead,\n              *     we create nested AA literals, and change it into a assignment.\n              */\n-            IndexExp ie = cast(IndexExp)e1;\n+            IndexExp ie = e1.isIndexExp();\n             int depth = 0; // how many nested AA indices are there?\n-            while (ie.e1.op == EXP.index && (cast(IndexExp)ie.e1).e1.type.toBasetype().ty == Taarray)\n+            while (ie.e1.op == EXP.index && ie.e1.isIndexExp().e1.type.toBasetype().ty == Taarray)\n             {\n                 assert(ie.modifiable);\n-                ie = cast(IndexExp)ie.e1;\n+                ie = ie.e1.isIndexExp();\n                 ++depth;\n             }\n \n@@ -3392,17 +3394,17 @@ public:\n                 // Normal case, ultimate parent AA already exists\n                 // We need to walk from the deepest index up, checking that an AA literal\n                 // already exists on each level.\n-                lastIndex = interpretRegion((cast(IndexExp)e1).e2, istate);\n+                lastIndex = interpretRegion(e1.isIndexExp().e2, istate);\n                 lastIndex = resolveSlice(lastIndex); // only happens with AA assignment\n                 if (exceptionOrCant(lastIndex))\n                     return;\n \n                 while (depth > 0)\n                 {\n                     // Walk the syntax tree to find the indexExp at this depth\n-                    IndexExp xe = cast(IndexExp)e1;\n+                    IndexExp xe = e1.isIndexExp();\n                     foreach (d; 0 .. depth)\n-                        xe = cast(IndexExp)xe.e1;\n+                        xe = xe.e1.isIndexExp();\n \n                     Expression ekey = interpretRegion(xe.e2, istate);\n                     if (exceptionOrCant(ekey))\n@@ -3450,9 +3452,9 @@ public:\n                 oldval = copyLiteral(e.e1.type.defaultInitLiteral(e.loc)).copy();\n \n                 Expression newaae = oldval;\n-                while (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+                while (e1.op == EXP.index && e1.isIndexExp().e1.type.toBasetype().ty == Taarray)\n                 {\n-                    Expression ekey = interpretRegion((cast(IndexExp)e1).e2, istate);\n+                    Expression ekey = interpretRegion(e1.isIndexExp().e2, istate);\n                     if (exceptionOrCant(ekey))\n                         return;\n                     ekey = resolveSlice(ekey); // only happens with AA assignment\n@@ -3463,15 +3465,15 @@ public:\n                     valuesx.push(newaae);\n \n                     auto aae = ctfeEmplaceExp!AssocArrayLiteralExp(e.loc, keysx, valuesx);\n-                    aae.type = (cast(IndexExp)e1).e1.type;\n+                    aae.type = e1.isIndexExp().e1.type;\n                     aae.ownedByCtfe = OwnedBy.ctfe;\n                     if (!existingAA)\n                     {\n                         existingAA = aae;\n                         lastIndex = ekey;\n                     }\n                     newaae = aae;\n-                    e1 = (cast(IndexExp)e1).e1;\n+                    e1 = e1.isIndexExp().e1;\n                 }\n \n                 // We must set to aggregate with newaae\n@@ -3521,11 +3523,11 @@ public:\n             if (exceptionOrCant(e1))\n                 return;\n \n-            if (e1.op == EXP.index && (cast(IndexExp)e1).e1.type.toBasetype().ty == Taarray)\n+            if (e1.op == EXP.index && e1.isIndexExp().e1.type.toBasetype().ty == Taarray)\n             {\n-                IndexExp ie = cast(IndexExp)e1;\n+                IndexExp ie = e1.isIndexExp();\n                 assert(ie.e1.op == EXP.assocArrayLiteral);\n-                existingAA = cast(AssocArrayLiteralExp)ie.e1;\n+                existingAA = ie.e1.isAssocArrayLiteralExp();\n                 lastIndex = ie.e2;\n             }\n         }\n@@ -3657,7 +3659,7 @@ public:\n \n             // We have changed it into a reference assignment\n             // Note that returnValue is still the new length.\n-            e1 = (cast(ArrayLengthExp)e1).e1;\n+            e1 = e1.isArrayLengthExp().e1;\n             Type t = e1.type.toBasetype();\n             if (t.ty != Tarray)\n             {\n@@ -3733,8 +3735,8 @@ public:\n                 if (auto dve = e1x.isDotVarExp())\n                 {\n                     auto ex = dve.e1;\n-                    auto sle = ex.op == EXP.structLiteral ? (cast(StructLiteralExp)ex)\n-                             : ex.op == EXP.classReference ? (cast(ClassReferenceExp)ex).value\n+                    auto sle = ex.op == EXP.structLiteral ? ex.isStructLiteralExp()\n+                             : ex.op == EXP.classReference ? ex.isClassReferenceExp().value\n                              : null;\n                     auto v = dve.var.isVarDeclaration();\n                     if (!sle || !v)\n@@ -3792,10 +3794,10 @@ public:\n              *  e.v = newval\n              */\n             auto ex = dve.e1;\n-            auto sle = ex.op == EXP.structLiteral ? (cast(StructLiteralExp)ex)\n-                     : ex.op == EXP.classReference ? (cast(ClassReferenceExp)ex).value\n+            auto sle = ex.op == EXP.structLiteral ? ex.isStructLiteralExp()\n+                     : ex.op == EXP.classReference ? ex.isClassReferenceExp().value\n                      : null;\n-            auto v = (cast(DotVarExp)e1).var.isVarDeclaration();\n+            auto v = e1.isDotVarExp().var.isVarDeclaration();\n             if (!sle || !v)\n             {\n                 e.error(\"CTFE internal error: dotvar assignment\");\n@@ -3808,7 +3810,7 @@ public:\n             }\n \n             int fieldi = ex.op == EXP.structLiteral ? findFieldIndexByName(sle.sd, v)\n-                       : (cast(ClassReferenceExp)ex).findFieldIndexByName(v);\n+                       : ex.isClassReferenceExp().findFieldIndexByName(v);\n             if (fieldi == -1)\n             {\n                 e.error(\"CTFE internal error: cannot find field `%s` in `%s`\", v.toChars(), ex.toChars());\n@@ -3865,7 +3867,7 @@ public:\n                 return CTFEExp.cantexp;\n             }\n \n-            ArrayLiteralExp existingAE = cast(ArrayLiteralExp)aggregate;\n+            ArrayLiteralExp existingAE = aggregate.isArrayLiteralExp();\n             if (existingAE.ownedByCtfe != OwnedBy.ctfe)\n             {\n                 e.error(\"cannot modify read-only constant `%s`\", existingAE.toChars());\n@@ -3920,8 +3922,8 @@ public:\n             assert(oldval.op == EXP.arrayLiteral);\n             assert(newval.op == EXP.arrayLiteral);\n \n-            Expressions* oldelems = (cast(ArrayLiteralExp)oldval).elements;\n-            Expressions* newelems = (cast(ArrayLiteralExp)newval).elements;\n+            Expressions* oldelems = oldval.isArrayLiteralExp().elements;\n+            Expressions* newelems = newval.isArrayLiteralExp().elements;\n             assert(oldelems.dim == newelems.dim);\n \n             Type elemtype = oldval.type.nextOf();\n@@ -4124,7 +4126,7 @@ public:\n \n             if (newval.op == EXP.slice && !isBlockAssignment)\n             {\n-                auto se = cast(SliceExp)newval;\n+                auto se = newval.isSliceExp();\n                 auto aggr2 = se.e1;\n                 const srclower = se.lwr.toInteger();\n                 const srcupper = se.upr.toInteger();\n@@ -4140,7 +4142,7 @@ public:\n                     // https://issues.dlang.org/show_bug.cgi?id=14024\n                     assert(aggr2.op == EXP.arrayLiteral);\n                     Expressions* oldelems = existingAE.elements;\n-                    Expressions* newelems = (cast(ArrayLiteralExp)aggr2).elements;\n+                    Expressions* newelems = aggr2.isArrayLiteralExp().elements;\n \n                     Type elemtype = aggregate.type.nextOf();\n                     bool needsPostblit = e.e2.isLvalue();\n@@ -4213,13 +4215,13 @@ public:\n                 /* Mixed slice: it was initialized as an array literal of chars/integers.\n                  * Now a slice of it is being set with a string.\n                  */\n-                sliceAssignArrayLiteralFromString(existingAE, cast(StringExp)newval, cast(size_t)firstIndex);\n+                sliceAssignArrayLiteralFromString(existingAE, newval.isStringExp(), cast(size_t)firstIndex);\n                 return newval;\n             }\n             if (newval.op == EXP.arrayLiteral && !isBlockAssignment)\n             {\n                 Expressions* oldelems = existingAE.elements;\n-                Expressions* newelems = (cast(ArrayLiteralExp)newval).elements;\n+                Expressions* newelems = newval.isArrayLiteralExp().elements;\n                 Type elemtype = existingAE.type.nextOf();\n                 bool needsPostblit = e.op != EXP.blit && e.e2.isLvalue();\n                 foreach (j, newelem; *newelems)\n@@ -4264,7 +4266,7 @@ public:\n                         if (!directblk && (*w)[k].op == EXP.arrayLiteral)\n                         {\n                             // Multidimensional array block assign\n-                            if (Expression ex = assignTo(cast(ArrayLiteralExp)(*w)[k]))\n+                            if (Expression ex = assignTo((*w)[k].isArrayLiteralExp()))\n                                 return ex;\n                         }\n                         else if (refCopy)\n@@ -4420,7 +4422,7 @@ public:\n         while (e.op == EXP.not)\n         {\n             ret *= -1;\n-            e = (cast(NotExp)e).e1;\n+            e = e.isNotExp().e1;\n         }\n         switch (e.op)\n         {\n@@ -4430,8 +4432,8 @@ public:\n             goto case; /+ fall through +/\n         case EXP.greaterThan:\n         case EXP.greaterOrEqual:\n-            *p1 = (cast(BinExp)e).e1;\n-            *p2 = (cast(BinExp)e).e2;\n+            *p1 = e.isBinExp().e1;\n+            *p2 = e.isBinExp().e2;\n             if (!(isPointer((*p1).type) && isPointer((*p2).type)))\n                 ret = 0;\n             break;\n@@ -4898,7 +4900,7 @@ public:\n             }\n         }\n \n-        if (fd && fd.semanticRun >= PASS.semantic3done && fd.semantic3Errors)\n+        if (fd && fd.semanticRun >= PASS.semantic3done && fd.hasSemantic3Errors())\n         {\n             e.error(\"CTFE failed because of previous errors in `%s`\", fd.toChars());\n             result = CTFEExp.cantexp;\n@@ -5201,7 +5203,7 @@ public:\n             // Pointer to a non-array variable\n             if (agg.op == EXP.symbolOffset)\n             {\n-                e.error(\"mutable variable `%s` cannot be %s at compile time, even through a pointer\", cast(char*)(modify ? \"modified\" : \"read\"), (cast(SymOffExp)agg).var.toChars());\n+                e.error(\"mutable variable `%s` cannot be %s at compile time, even through a pointer\", cast(char*)(modify ? \"modified\" : \"read\"), agg.isSymOffExp().var.toChars());\n                 return false;\n             }\n \n@@ -5285,7 +5287,7 @@ public:\n                 e.error(\"index %llu exceeds array length %llu\", index, iupr - ilwr);\n                 return false;\n             }\n-            *pagg = (cast(SliceExp)e1).e1;\n+            *pagg = e1.isSliceExp().e1;\n             *pidx = index + ilwr;\n         }\n         else\n@@ -5377,7 +5379,7 @@ public:\n             assert(e1.op == EXP.assocArrayLiteral);\n             UnionExp e2tmp = void;\n             e2 = resolveSlice(e2, &e2tmp);\n-            result = findKeyInAA(e.loc, cast(AssocArrayLiteralExp)e1, e2);\n+            result = findKeyInAA(e.loc, e1.isAssocArrayLiteralExp(), e2);\n             if (!result)\n             {\n                 e.error(\"key `%s` not found in associative array `%s`\", e2.toChars(), e.e1.toChars());\n@@ -5637,7 +5639,7 @@ public:\n         }\n \n         e1 = resolveSlice(e1);\n-        result = findKeyInAA(e.loc, cast(AssocArrayLiteralExp)e2, e1);\n+        result = findKeyInAA(e.loc, e2.isAssocArrayLiteralExp(), e1);\n         if (exceptionOrCant(result))\n             return;\n         if (!result)\n@@ -5742,7 +5744,7 @@ public:\n                 return;\n             }\n \n-            auto cre = cast(ClassReferenceExp)result;\n+            auto cre = result.isClassReferenceExp();\n             auto cd = cre.originalClass();\n \n             // Find dtor(s) in inheritance chain\n@@ -5859,18 +5861,18 @@ public:\n                 result = pue.exp();\n                 return;\n             }\n-            if (e1.op == EXP.index && !(cast(IndexExp)e1).e1.type.equals(e1.type))\n+            if (e1.op == EXP.index && !e1.isIndexExp().e1.type.equals(e1.type))\n             {\n                 // type painting operation\n-                IndexExp ie = cast(IndexExp)e1;\n+                IndexExp ie = e1.isIndexExp();\n                 if (castBackFromVoid)\n                 {\n                     // get the original type. For strings, it's just the type...\n                     Type origType = ie.e1.type.nextOf();\n                     // ..but for arrays of type void*, it's the type of the element\n                     if (ie.e1.op == EXP.arrayLiteral && ie.e2.op == EXP.int64)\n                     {\n-                        ArrayLiteralExp ale = cast(ArrayLiteralExp)ie.e1;\n+                        ArrayLiteralExp ale = ie.e1.isArrayLiteralExp();\n                         const indx = cast(size_t)ie.e2.toInteger();\n                         if (indx < ale.elements.dim)\n                         {\n@@ -5912,7 +5914,7 @@ public:\n                 {\n                     // &val[idx]\n                     dinteger_t dim = (cast(TypeSArray)pointee.toBasetype()).dim.toInteger();\n-                    IndexExp ie = cast(IndexExp)ae.e1;\n+                    IndexExp ie = ae.e1.isIndexExp();\n                     Expression lwr = ie.e2;\n                     Expression upr = ctfeEmplaceExp!IntegerExp(ie.e2.loc, ie.e2.toInteger() + dim, Type.tsize_t);\n \n@@ -5938,7 +5940,7 @@ public:\n                 if (auto ve = e1.isVarExp())\n                     emplaceExp!(VarExp)(pue, e.loc, ve.var);\n                 else\n-                    emplaceExp!(SymOffExp)(pue, e.loc, (cast(SymOffExp)e1).var, (cast(SymOffExp)e1).offset);\n+                    emplaceExp!(SymOffExp)(pue, e.loc, e1.isSymOffExp().var, e1.isSymOffExp().offset);\n                 result = pue.exp();\n                 result.type = e.to;\n                 return;\n@@ -5966,7 +5968,7 @@ public:\n         {\n             // Note that the slice may be void[], so when checking for dangerous\n             // casts, we need to use the original type, which is se.e1.\n-            SliceExp se = cast(SliceExp)e1;\n+            SliceExp se = e1.isSliceExp();\n             if (!isSafePointerCast(se.e1.type.nextOf(), e.to.nextOf()))\n             {\n                 e.error(\"array cast from `%s` to `%s` is not supported at compile time\", se.e1.type.toChars(), e.to.toChars());\n@@ -6086,7 +6088,7 @@ public:\n         {\n             if (ae.e1.op == EXP.address && ae.e2.op == EXP.int64)\n             {\n-                AddrExp ade = cast(AddrExp)ae.e1;\n+                AddrExp ade = ae.e1.isAddrExp();\n                 Expression ex = interpretRegion(ade.e1, istate);\n                 if (exceptionOrCant(ex))\n                     return;\n@@ -6131,7 +6133,7 @@ public:\n         }\n \n         // *(&x) ==> x\n-        result = (cast(AddrExp)result).e1;\n+        result = result.isAddrExp().e1;\n \n         if (result.op == EXP.slice && e.type.toBasetype().ty == Tsarray)\n         {\n@@ -6211,8 +6213,8 @@ public:\n         // We can't use getField, because it makes a copy\n         if (ex.op == EXP.classReference)\n         {\n-            se = (cast(ClassReferenceExp)ex).value;\n-            i = (cast(ClassReferenceExp)ex).findFieldIndexByName(v);\n+            se = ex.isClassReferenceExp().value;\n+            i = ex.isClassReferenceExp().findFieldIndexByName(v);\n         }\n         else if (ex.op == EXP.typeid_)\n         {\n@@ -6233,7 +6235,7 @@ public:\n         }\n         else\n         {\n-            se = cast(StructLiteralExp)ex;\n+            se = ex.isStructLiteralExp();\n             i = findFieldIndexByName(se.sd, v);\n         }\n         if (i == -1)\n@@ -6540,7 +6542,7 @@ private Expression scrubReturnValue(const ref Loc loc, Expression e)\n \n     if (e.op == EXP.classReference)\n     {\n-        StructLiteralExp sle = (cast(ClassReferenceExp)e).value;\n+        StructLiteralExp sle = e.isClassReferenceExp().value;\n         if (auto ex = scrubSE(sle))\n             return ex;\n     }\n@@ -6620,7 +6622,7 @@ private Expression scrubCacheValue(Expression e)\n \n     if (e.op == EXP.classReference)\n     {\n-        if (auto ex = scrubSE((cast(ClassReferenceExp)e).value))\n+        if (auto ex = scrubSE(e.isClassReferenceExp().value))\n             return ex;\n     }\n     else if (auto sle = e.isStructLiteralExp())\n@@ -6767,14 +6769,14 @@ private Expression copyRegionExp(Expression e)\n         case EXP.vector:\n         case EXP.dotVariable:\n         {\n-            UnaExp ue = cast(UnaExp)e;\n+            UnaExp ue = e.isUnaExp();\n             ue.e1 = copyRegionExp(ue.e1);\n             break;\n         }\n \n         case EXP.index:\n         {\n-            BinExp be = cast(BinExp)e;\n+            BinExp be = e.isBinExp();\n             be.e1 = copyRegionExp(be.e1);\n             be.e2 = copyRegionExp(be.e2);\n             break;\n@@ -6939,7 +6941,7 @@ private Expression interpret_aaApply(UnionExp* pue, InterState* istate, Expressi\n \n     Expressions args = Expressions(numParams);\n \n-    AssocArrayLiteralExp ae = cast(AssocArrayLiteralExp)aa;\n+    AssocArrayLiteralExp ae = aa.isAssocArrayLiteralExp();\n     if (!ae.keys || ae.keys.dim == 0)\n         return ctfeEmplaceExp!IntegerExp(deleg.loc, 0, Type.tsize_t);\n     Expression eresult;\n@@ -7298,7 +7300,7 @@ private Expression evaluateIfBuiltin(UnionExp* pue, InterState* istate, const re\n         {\n             // At present, the constructors just copy their arguments into the struct.\n             // But we might need some magic if stack tracing gets added to druntime.\n-            StructLiteralExp se = (cast(ClassReferenceExp)pthis).value;\n+            StructLiteralExp se = pthis.isClassReferenceExp().value;\n             assert(arguments.dim <= se.elements.dim);\n             foreach (i, arg; *arguments)\n             {"}, {"sha": "c3662a734d85f94f90ff6a700e2e94fdcb587c9a", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -991,10 +991,6 @@ public:\n         if (stc & STC.returninferred)\n             stc &= ~(STC.return_ | STC.returninferred);\n \n-        // 'return inout ref' is the same as 'inout ref'\n-        if ((stc & (STC.return_ | STC.wild)) == (STC.return_ | STC.wild))\n-            stc &= ~STC.return_;\n-\n         // much like hdrgen.stcToBuffer()\n         string rrs;\n         const isout = (stc & STC.out_) != 0;\n@@ -1365,5 +1361,3 @@ extern (D) const(char)[] externallyMangledIdentifier(Declaration d)\n     }\n     return null;\n }\n-\n-"}, {"sha": "c7e6418bf46b35b51744d09e4170cd5b4fecf5e3", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -662,7 +662,7 @@ extern (C++) final class Module : Package\n             return true; // already read\n \n         //printf(\"Module::read('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n-        if (auto result = FileManager.fileManager.lookup(srcfile))\n+        if (auto result = global.fileManager.lookup(srcfile))\n         {\n             this.src = result.data;\n             if (global.params.emitMakeDeps)"}, {"sha": "c3a1d05cd7bf33b7216f2e504ff4fa78abd1ac5a", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -708,6 +708,31 @@ struct Scope\n         return null;\n     }\n \n+    /********************************************\n+     * Find the lexically enclosing function (if any).\n+     *\n+     * This function skips through generated FuncDeclarations,\n+     * e.g. rewritten foreach bodies.\n+     *\n+     * Returns: the function or null\n+     */\n+    inout(FuncDeclaration) getEnclosingFunction() inout\n+    {\n+        if (!this.func)\n+            return null;\n+\n+        auto fd = cast(FuncDeclaration) this.func;\n+\n+        // Look through foreach bodies rewritten as delegates\n+        while (fd.fes)\n+        {\n+            assert(fd.fes.func);\n+            fd = fd.fes.func;\n+        }\n+\n+        return cast(inout(FuncDeclaration)) fd;\n+    }\n+\n     /*******************************************\n      * For TemplateDeclarations, we need to remember the Scope\n      * where it was declared. So mark the Scope as not"}, {"sha": "cb6c278fc4409f0fc11b720e2f7f29c79e12332f", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -190,7 +190,7 @@ struct Visibility\n \n enum PASS : ubyte\n {\n-    init,           // initial state\n+    initial,        // initial state\n     semantic,       // semantic() started\n     semanticdone,   // semantic() done\n     semantic2,      // semantic2() started\n@@ -249,7 +249,7 @@ extern (C++) class Dsymbol : ASTNode\n     Scope* _scope;          // !=null means context to use for semantic()\n     const(char)* prettystring;  // cached value of toPrettyChars()\n     bool errors;            // this symbol failed to pass semantic()\n-    PASS semanticRun = PASS.init;\n+    PASS semanticRun = PASS.initial;\n     ushort localNum;        /// perturb mangled name to avoid collisions with those in FuncDeclaration.localsymtab\n \n     DeprecatedDeclaration depdecl;           // customized deprecation message\n@@ -621,7 +621,7 @@ extern (C++) class Dsymbol : ASTNode\n         static bool has2This(Dsymbol s)\n         {\n             if (auto f = s.isFuncDeclaration())\n-                return f.isThis2;\n+                return f.hasDualContext();\n             if (auto ad = s.isAggregateDeclaration())\n                 return ad.vthis2 !is null;\n             return false;\n@@ -2399,6 +2399,7 @@ Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n {\n     enum log = false;\n     if (log) printf(\"handleTagSymbols('%s') add %p existing %p\\n\", s.toChars(), s, s2);\n+    if (log) printf(\"  add %s %s, existing %s %s\\n\", s.kind(), s.toChars(), s2.kind(), s2.toChars());\n     auto sd = s.isScopeDsymbol(); // new declaration\n     auto sd2 = s2.isScopeDsymbol(); // existing declaration\n \n@@ -2457,6 +2458,7 @@ Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n         sc._module.tagSymTab[cast(void*)s] = s2;\n         return s;\n     }\n+    // neither s2 nor s is a tag\n     if (log) printf(\" collision\\n\");\n     return null;\n }\n@@ -2483,6 +2485,7 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n {\n     enum log = false;\n     if (log) printf(\"handleSymbolRedeclarations('%s')\\n\", s.toChars());\n+    if (log) printf(\"  add %s %s, existing %s %s\\n\", s.kind(), s.toChars(), s2.kind(), s2.toChars());\n \n     static Dsymbol collision()\n     {\n@@ -2552,8 +2555,16 @@ Dsymbol handleSymbolRedeclarations(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsy\n \n         if (fd.fbody)                   // fd is the definition\n         {\n+            if (log) printf(\" replace existing with new\\n\");\n             sds.symtab.update(fd);      // replace fd2 in symbol table with fd\n             fd.overnext = fd2;\n+\n+            /* If fd2 is covering a tag symbol, then fd has to cover the same one\n+             */\n+            auto ps = cast(void*)fd2 in sc._module.tagSymTab;\n+            if (ps)\n+                sc._module.tagSymTab[cast(void*)fd] = *ps;\n+\n             return fd;\n         }\n "}, {"sha": "35500af454897d946c59a9db9bf559006938ec43", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -111,7 +111,7 @@ struct Visibility\n  */\n enum class PASS : uint8_t\n {\n-    init,           // initial state\n+    initial,        // initial state\n     semantic,       // semantic() started\n     semanticdone,   // semantic() done\n     semantic2,      // semantic2() started"}, {"sha": "c9906363cc8cd396be353b831a120f6c1fc33686", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 39, "deletions": 57, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -231,7 +231,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(AliasThis dsym)\n     {\n-        if (dsym.semanticRun != PASS.init)\n+        if (dsym.semanticRun != PASS.initial)\n             return;\n \n         if (dsym._scope)\n@@ -346,7 +346,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             printf(\"linkage = %d\\n\", dsym.linkage);\n             //if (strcmp(toChars(), \"mul\") == 0) assert(0);\n         }\n-        //if (semanticRun > PASS.init)\n+        //if (semanticRun > PASS.initial)\n         //    return;\n         //semanticRun = PSSsemantic;\n \n@@ -417,7 +417,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n             //printf(\"inferring type for %s with init %s\\n\", dsym.toChars(), dsym._init.toChars());\n             dsym._init = dsym._init.inferType(sc);\n-            dsym.type = dsym._init.initializerToExpression().type;\n+            dsym.type = dsym._init.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0).type;\n             if (needctfe)\n                 sc = sc.endCTFE();\n \n@@ -527,7 +527,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n              * and add those.\n              */\n             size_t nelems = Parameter.dim(tt.arguments);\n-            Expression ie = (dsym._init && !dsym._init.isVoidInitializer()) ? dsym._init.initializerToExpression() : null;\n+            Expression ie = (dsym._init && !dsym._init.isVoidInitializer()) ? dsym._init.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0) : null;\n             if (ie)\n                 ie = ie.expressionSemantic(sc);\n             if (nelems > 0 && ie)\n@@ -987,12 +987,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         if (ai && tb.ty == Taarray)\n                             e = ai.toAssocArrayLiteral();\n                         else\n-                            e = dsym._init.initializerToExpression();\n+                            e = dsym._init.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n                         if (!e)\n                         {\n                             // Run semantic, but don't need to interpret\n                             dsym._init = dsym._init.initializerSemantic(sc, dsym.type, INITnointerpret);\n-                            e = dsym._init.initializerToExpression();\n+                            e = dsym._init.initializerToExpression(null, (sc.flags & SCOPE.Cfile) != 0);\n                             if (!e)\n                             {\n                                 dsym.error(\"is not a static and cannot have static initializer\");\n@@ -1162,23 +1162,6 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         dsym.edtor = dsym.callScopeDtor(sc);\n         if (dsym.edtor)\n         {\n-            /* If dsym is a local variable, who's type is a struct with a scope destructor,\n-             * then make dsym scope, too.\n-             */\n-            if (global.params.useDIP1000 == FeatureState.enabled &&\n-                !(dsym.storage_class & (STC.parameter | STC.temp | STC.field | STC.in_ | STC.foreach_ | STC.result | STC.manifest)) &&\n-                !dsym.isDataseg() &&\n-                !dsym.doNotInferScope &&\n-                dsym.type.hasPointers())\n-            {\n-                auto tv = dsym.type.baseElemOf();\n-                if (tv.ty == Tstruct &&\n-                    tv.isTypeStruct().sym.dtor.storage_class & STC.scope_)\n-                {\n-                    dsym.storage_class |= STC.scope_;\n-                }\n-            }\n-\n             if (sc.func && dsym.storage_class & (STC.static_ | STC.gshared))\n                 dsym.edtor = dsym.edtor.expressionSemantic(sc._module._scope);\n             else\n@@ -1256,7 +1239,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n     override void visit(Import imp)\n     {\n         //printf(\"Import::semantic('%s') %s\\n\", toPrettyChars(), id.toChars());\n-        if (imp.semanticRun > PASS.init)\n+        if (imp.semanticRun > PASS.initial)\n             return;\n \n         if (imp._scope)\n@@ -1433,7 +1416,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     void attribSemantic(AttribDeclaration ad)\n     {\n-        if (ad.semanticRun != PASS.init)\n+        if (ad.semanticRun != PASS.initial)\n             return;\n         ad.semanticRun = PASS.semantic;\n         Dsymbols* d = ad.include(sc);\n@@ -1776,7 +1759,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     }\n                     else if (auto f = s.isFuncDeclaration())\n                     {\n-                        f.isCrtCtorDtor |= isCtor ? 1 : 2;\n+                        f.flags |= isCtor ? FUNCFLAG.CRTCtor : FUNCFLAG.CRTDtor;\n                         return 1;\n                     }\n                     else\n@@ -1990,7 +1973,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(Module m)\n     {\n-        if (m.semanticRun != PASS.init)\n+        if (m.semanticRun != PASS.initial)\n             return;\n         //printf(\"+Module::semantic(this = %p, '%s'): parent = %p\\n\", this, toChars(), parent);\n         m.semanticRun = PASS.semantic;\n@@ -2099,7 +2082,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     deferDsymbolSemantic(ed, scx);\n                     Module.dprogress = dprogress_save;\n                     //printf(\"\\tdeferring %s\\n\", toChars());\n-                    ed.semanticRun = PASS.init;\n+                    ed.semanticRun = PASS.initial;\n                     return;\n                 }\n                 else\n@@ -2503,7 +2486,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             printf(\"sc.stc = %llx\\n\", sc.stc);\n             printf(\"sc.module = %s\\n\", sc._module.toChars());\n         }\n-        if (tempdecl.semanticRun != PASS.init)\n+        if (tempdecl.semanticRun != PASS.initial)\n             return; // semantic() already run\n \n         if (tempdecl._scope)\n@@ -2648,11 +2631,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             printf(\"+TemplateMixin.dsymbolSemantic('%s', this=%p)\\n\", tm.toChars(), tm);\n             fflush(stdout);\n         }\n-        if (tm.semanticRun != PASS.init)\n+        if (tm.semanticRun != PASS.initial)\n         {\n             // When a class/struct contains mixin members, and is done over\n             // because of forward references, never reach here so semanticRun\n-            // has been reset to PASS.init.\n+            // has been reset to PASS.initial.\n             static if (LOG)\n             {\n                 printf(\"\\tsemantic done\\n\");\n@@ -2678,7 +2661,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n          */\n         if (!tm.findTempDecl(sc) || !tm.semanticTiargs(sc) || !tm.findBestMatch(sc, null))\n         {\n-            if (tm.semanticRun == PASS.init) // forward reference had occurred\n+            if (tm.semanticRun == PASS.initial) // forward reference had occurred\n             {\n                 //printf(\"forward reference - deferring\\n\");\n                 return deferDsymbolSemantic(tm, scx);\n@@ -2865,7 +2848,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n     override void visit(Nspace ns)\n     {\n-        if (ns.semanticRun != PASS.init)\n+        if (ns.semanticRun != PASS.initial)\n             return;\n         static if (LOG)\n         {\n@@ -2989,7 +2972,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             printf(\"type: %p, %s\\n\", funcdecl.type, funcdecl.type.toChars());\n         }\n \n-        if (funcdecl.semanticRun != PASS.init && funcdecl.isFuncLiteralDeclaration())\n+        if (funcdecl.semanticRun != PASS.initial && funcdecl.isFuncLiteralDeclaration())\n         {\n             /* Member functions that have return types that are\n              * forward references can have semantic() run more than\n@@ -3023,7 +3006,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         AggregateDeclaration ad = funcdecl.isThis();\n         // Don't nest structs b/c of generated methods which should not access the outer scopes.\n         // https://issues.dlang.org/show_bug.cgi?id=16627\n-        if (ad && !funcdecl.generated)\n+        if (ad && !funcdecl.isGenerated())\n         {\n             funcdecl.storage_class |= ad.storage_class & (STC.TYPECTOR | STC.synchronized_);\n             ad.makeNested();\n@@ -3061,12 +3044,12 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             funcdecl.inlining = pragmadecl.evalPragmaInline(sc);\n \n         // check pragma(crt_constructor)\n-        if (funcdecl.isCrtCtorDtor)\n+        if (funcdecl.flags & (FUNCFLAG.CRTCtor | FUNCFLAG.CRTDtor))\n         {\n             if (funcdecl.linkage != LINK.c)\n             {\n                 funcdecl.error(\"must be `extern(C)` for `pragma(%s)`\",\n-                    funcdecl.isCrtCtorDtor == 1 ? \"crt_constructor\".ptr : \"crt_destructor\".ptr);\n+                    (funcdecl.flags & FUNCFLAG.CRTCtor) ? \"crt_constructor\".ptr : \"crt_destructor\".ptr);\n             }\n         }\n \n@@ -3293,7 +3276,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             if (sc.scopesym && sc.scopesym.isAggregateDeclaration())\n                 funcdecl.error(\"`static` member has no `this` to which `return` can apply\");\n             else\n-                error(funcdecl.loc, \"Top-level function `%s` has no `this` to which `return` can apply\", funcdecl.toChars());\n+                error(funcdecl.loc, \"top-level function `%s` has no `this` to which `return` can apply\", funcdecl.toChars());\n         }\n \n         if (funcdecl.isAbstract() && !funcdecl.isVirtual())\n@@ -3524,7 +3507,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 else\n                 {\n                     //printf(\"\\tintroducing function %s\\n\", funcdecl.toChars());\n-                    funcdecl.introducing = 1;\n+                    funcdecl.flags |= FUNCFLAG.introducing;\n                     if (cd.classKind == ClassKind.cpp && target.cpp.reverseOverloads)\n                     {\n                         /* Overloaded functions with same name are grouped and in reverse order.\n@@ -3916,8 +3899,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n             }\n         }\n \n-        if (funcdecl.isMain())\n-            funcdecl.checkDmain();       // Check main() parameters and return type\n+        funcdecl.checkMain();       // Check main() parameters and return type\n \n         /* Purity and safety can be inferred for some functions by examining\n          * the function body.\n@@ -4525,7 +4507,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (sd.errors)\n             sd.type = Type.terror;\n-        if (sd.semanticRun == PASS.init)\n+        if (sd.semanticRun == PASS.initial)\n             sd.type = sd.type.addSTC(sc.stc | sd.storage_class);\n         sd.type = sd.type.typeSemantic(sd.loc, sc);\n         if (auto ts = sd.type.isTypeStruct())\n@@ -4539,7 +4521,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // Ungag errors when not speculative\n         Ungag ungag = sd.ungagSpeculative();\n \n-        if (sd.semanticRun == PASS.init)\n+        if (sd.semanticRun == PASS.initial)\n         {\n             sd.visibility = sc.visibility;\n \n@@ -4747,7 +4729,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         if (cldec.errors)\n             cldec.type = Type.terror;\n-        if (cldec.semanticRun == PASS.init)\n+        if (cldec.semanticRun == PASS.initial)\n             cldec.type = cldec.type.addSTC(sc.stc | cldec.storage_class);\n         cldec.type = cldec.type.typeSemantic(cldec.loc, sc);\n         if (auto tc = cldec.type.isTypeClass())\n@@ -4761,7 +4743,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // Ungag errors when not speculative\n         Ungag ungag = cldec.ungagSpeculative();\n \n-        if (cldec.semanticRun == PASS.init)\n+        if (cldec.semanticRun == PASS.initial)\n         {\n             cldec.visibility = sc.visibility;\n \n@@ -5259,7 +5241,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n                 auto ctor = new CtorDeclaration(cldec.loc, Loc.initial, 0, tf);\n                 ctor.storage_class |= STC.inference;\n-                ctor.generated = true;\n+                ctor.flags |= FUNCFLAG.generated;\n                 ctor.fbody = new CompoundStatement(Loc.initial, new Statements());\n \n                 cldec.members.push(ctor);\n@@ -5416,7 +5398,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         // Ungag errors when not speculative\n         Ungag ungag = idec.ungagSpeculative();\n \n-        if (idec.semanticRun == PASS.init)\n+        if (idec.semanticRun == PASS.initial)\n         {\n             idec.visibility = sc.visibility;\n \n@@ -5750,7 +5732,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         }\n         return;\n     }\n-    if (tempinst.semanticRun != PASS.init)\n+    if (tempinst.semanticRun != PASS.initial)\n     {\n         static if (LOG)\n         {\n@@ -5761,7 +5743,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n             global.gag = 0;\n         tempinst.error(tempinst.loc, \"recursive template expansion\");\n         if (tempinst.gagged)\n-            tempinst.semanticRun = PASS.init;\n+            tempinst.semanticRun = PASS.initial;\n         else\n             tempinst.inst = tempinst;\n         tempinst.errors = true;\n@@ -5800,7 +5782,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n         {\n             // https://issues.dlang.org/show_bug.cgi?id=13220\n             // Roll back status for later semantic re-running\n-            tempinst.semanticRun = PASS.init;\n+            tempinst.semanticRun = PASS.initial;\n         }\n         else\n             tempinst.inst = tempinst;\n@@ -6034,7 +6016,7 @@ void templateInstanceSemantic(TemplateInstance tempinst, Scope* sc, Expressions*\n \n     // Create our own scope for the template parameters\n     Scope* _scope = tempdecl._scope;\n-    if (tempdecl.semanticRun == PASS.init)\n+    if (tempdecl.semanticRun == PASS.initial)\n     {\n         tempinst.error(\"template instantiation `%s` forward references template declaration `%s`\", tempinst.toChars(), tempdecl.toChars());\n         return;\n@@ -6332,7 +6314,7 @@ Laftersemantic:\n                 target_symbol_list.remove(target_symbol_list_idx);\n                 tempinst.memberOf = null;                    // no longer a member\n             }\n-            tempinst.semanticRun = PASS.init;\n+            tempinst.semanticRun = PASS.initial;\n             tempinst.inst = null;\n             tempinst.symtab = null;\n         }\n@@ -6495,10 +6477,10 @@ void aliasSemantic(AliasDeclaration ds, Scope* sc)\n \n     // Ungag errors when not instantiated DeclDefs scope alias\n     auto ungag = Ungag(global.gag);\n-    //printf(\"%s parent = %s, gag = %d, instantiated = %d\\n\", toChars(), parent, global.gag, isInstantiated());\n-    if (ds.parent && global.gag && !ds.isInstantiated() && !ds.toParent2().isFuncDeclaration())\n+    //printf(\"%s parent = %s, gag = %d, instantiated = %d\\n\", ds.toChars(), ds.parent.toChars(), global.gag, ds.isInstantiated() !is null);\n+    if (ds.parent && global.gag && !ds.isInstantiated() && !ds.toParent2().isFuncDeclaration() && (sc.minst || sc.tinst))\n     {\n-        //printf(\"%s type = %s\\n\", toPrettyChars(), type.toChars());\n+        //printf(\"%s type = %s\\n\", ds.toPrettyChars(), ds.type.toChars());\n         global.gag = 0;\n     }\n \n@@ -6572,13 +6554,13 @@ void aliasSemantic(AliasDeclaration ds, Scope* sc)\n     }\n     if (s) // it's a symbolic alias\n     {\n-        //printf(\"alias %s resolved to %s %s\\n\", toChars(), s.kind(), s.toChars());\n+        //printf(\"alias %s resolved to %s %s\\n\", ds.toChars(), s.kind(), s.toChars());\n         ds.type = null;\n         ds.aliassym = s;\n     }\n     else    // it's a type alias\n     {\n-        //printf(\"alias %s resolved to type %s\\n\", toChars(), type.toChars());\n+        //printf(\"alias %s resolved to type %s\\n\", ds.toChars(), ds.type.toChars());\n         ds.type = ds.type.typeSemantic(ds.loc, sc);\n         ds.aliassym = null;\n     }"}, {"sha": "a5ec63ca763e0177ff8236e50b2bce8ab973dace", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1173,7 +1173,7 @@ extern (C++) final class TemplateDeclaration : ScopeDsymbol\n \n                 fd = new FuncDeclaration(fd.loc, fd.endloc, fd.ident, fd.storage_class, tf);\n                 fd.parent = ti;\n-                fd.inferRetType = true;\n+                fd.flags |= FUNCFLAG.inferRetType;\n \n                 // Shouldn't run semantic on default arguments and return type.\n                 foreach (ref param; *tf.parameterList.parameters)\n@@ -2827,13 +2827,13 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n         if (!sc)\n             sc = td._scope; // workaround for Type.aliasthisOf\n \n-        if (td.semanticRun == PASS.init && td._scope)\n+        if (td.semanticRun == PASS.initial && td._scope)\n         {\n             // Try to fix forward reference. Ungag errors while doing so.\n             Ungag ungag = td.ungagSpeculative();\n             td.dsymbolSemantic(td._scope);\n         }\n-        if (td.semanticRun == PASS.init)\n+        if (td.semanticRun == PASS.initial)\n         {\n             .error(loc, \"forward reference to template `%s`\", td.toChars());\n         Lerror:\n@@ -2851,7 +2851,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n                 tiargs = new Objects();\n             auto ti = new TemplateInstance(loc, td, tiargs);\n             Objects dedtypes = Objects(td.parameters.dim);\n-            assert(td.semanticRun != PASS.init);\n+            assert(td.semanticRun != PASS.initial);\n             MATCH mta = td.matchWithInstance(sc, ti, &dedtypes, fargs, 0);\n             //printf(\"matchWithInstance = %d\\n\", mta);\n             if (mta == MATCH.nomatch || mta < ta_last)   // no match or less match\n@@ -6425,15 +6425,15 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 if (!td)\n                     return 0;\n \n-                if (td.semanticRun == PASS.init)\n+                if (td.semanticRun == PASS.initial)\n                 {\n                     if (td._scope)\n                     {\n                         // Try to fix forward reference. Ungag errors while doing so.\n                         Ungag ungag = td.ungagSpeculative();\n                         td.dsymbolSemantic(td._scope);\n                     }\n-                    if (td.semanticRun == PASS.init)\n+                    if (td.semanticRun == PASS.initial)\n                     {\n                         error(\"`%s` forward references template declaration `%s`\",\n                             toChars(), td.toChars());\n@@ -6786,7 +6786,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 (*tiargs)[j] = sa;\n \n                 TemplateDeclaration td = sa.isTemplateDeclaration();\n-                if (td && td.semanticRun == PASS.init && td.literal)\n+                if (td && td.semanticRun == PASS.initial && td.literal)\n                 {\n                     td.dsymbolSemantic(sc);\n                 }\n@@ -6915,7 +6915,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n \n                 dedtypes.setDim(td.parameters.dim);\n                 dedtypes.zero();\n-                assert(td.semanticRun != PASS.init);\n+                assert(td.semanticRun != PASS.initial);\n \n                 MATCH m = td.matchWithInstance(sc, this, &dedtypes, fargs, 0);\n                 //printf(\"matchWithInstance = %d\\n\", m);\n@@ -7093,7 +7093,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n     extern (D) final bool needsTypeInference(Scope* sc, int flag = 0)\n     {\n         //printf(\"TemplateInstance.needsTypeInference() %s\\n\", toChars());\n-        if (semanticRun != PASS.init)\n+        if (semanticRun != PASS.initial)\n             return false;\n \n         uint olderrs = global.errors;\n@@ -7174,15 +7174,15 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                      */\n                     dedtypes.setDim(td.parameters.dim);\n                     dedtypes.zero();\n-                    if (td.semanticRun == PASS.init)\n+                    if (td.semanticRun == PASS.initial)\n                     {\n                         if (td._scope)\n                         {\n                             // Try to fix forward reference. Ungag errors while doing so.\n                             Ungag ungag = td.ungagSpeculative();\n                             td.dsymbolSemantic(td._scope);\n                         }\n-                        if (td.semanticRun == PASS.init)\n+                        if (td.semanticRun == PASS.initial)\n                         {\n                             error(\"`%s` forward references template declaration `%s`\", toChars(), td.toChars());\n                             return 1;\n@@ -7740,13 +7740,13 @@ extern (C++) final class TemplateMixin : TemplateInstance\n                 if (!td)\n                     return 0;\n \n-                if (td.semanticRun == PASS.init)\n+                if (td.semanticRun == PASS.initial)\n                 {\n                     if (td._scope)\n                         td.dsymbolSemantic(td._scope);\n                     else\n                     {\n-                        semanticRun = PASS.init;\n+                        semanticRun = PASS.initial;\n                         return 1;\n                     }\n                 }"}, {"sha": "41fb82b8266f7fd13851667f296aed7b33abef86", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -445,6 +445,9 @@ public:\n      */\n     private void writeIdentifier(const AST.Dsymbol s, const bool canFix = false)\n     {\n+        if (const mn = getMangleOverride(s))\n+            return buf.writestring(mn);\n+\n         writeIdentifier(s.ident, s.loc, s.kind(), canFix);\n     }\n \n@@ -719,15 +722,20 @@ public:\n         visited[cast(void*)fd] = true;\n \n         // silently ignore non-user-defined destructors\n-        if (fd.generated && fd.isDtorDeclaration())\n+        if (fd.isGenerated && fd.isDtorDeclaration())\n             return;\n \n         // Note that tf might be null for templated (member) functions\n         auto tf = cast(AST.TypeFunction)fd.type;\n-        if ((tf && tf.linkage != LINK.c && tf.linkage != LINK.cpp) || (!tf && fd.isPostBlitDeclaration()))\n+        if ((tf && (tf.linkage != LINK.c || adparent) && tf.linkage != LINK.cpp) || (!tf && fd.isPostBlitDeclaration()))\n         {\n             ignored(\"function %s because of linkage\", fd.toPrettyChars());\n-            return checkVirtualFunction(fd);\n+            return checkFunctionNeedsPlaceholder(fd);\n+        }\n+        if (fd.mangleOverride && tf && tf.linkage != LINK.c)\n+        {\n+            ignored(\"function %s because C++ doesn't support explicit mangling\", fd.toPrettyChars());\n+            return checkFunctionNeedsPlaceholder(fd);\n         }\n         if (!adparent && !fd.fbody)\n         {\n@@ -742,15 +750,15 @@ public:\n         if (tf && !isSupportedType(tf.next))\n         {\n             ignored(\"function %s because its return type cannot be mapped to C++\", fd.toPrettyChars());\n-            return checkVirtualFunction(fd);\n+            return checkFunctionNeedsPlaceholder(fd);\n         }\n         if (tf) foreach (i, fparam; tf.parameterList)\n         {\n             if (!isSupportedType(fparam.type))\n             {\n                 ignored(\"function %s because one of its parameters has type `%s` which cannot be mapped to C++\",\n                         fd.toPrettyChars(), fparam.type.toChars());\n-                return checkVirtualFunction(fd);\n+                return checkFunctionNeedsPlaceholder(fd);\n             }\n         }\n \n@@ -822,13 +830,19 @@ public:\n \n     }\n \n-    /// Checks whether `fd` is a virtual function and emits a dummy declaration\n-    /// if required to ensure proper vtable layout\n-    private void checkVirtualFunction(AST.FuncDeclaration fd)\n+    /++\n+     + Checks whether `fd` is a function that requires a dummy declaration\n+     + instead of simply emitting the declaration (because it would cause\n+     + ABI / behaviour issues). This includes:\n+     +\n+     + - virtual functions to ensure proper vtable layout\n+     + - destructors that would break RAII\n+     +/\n+    private void checkFunctionNeedsPlaceholder(AST.FuncDeclaration fd)\n     {\n         // Omit redundant declarations - the slot was already\n         // reserved in the base class\n-        if (fd.isVirtual() && fd.introducing)\n+        if (fd.isVirtual() && fd.isIntroducing())\n         {\n             // Hide placeholders because they are not ABI compatible\n             writeProtection(AST.Visibility.Kind.private_);\n@@ -837,6 +851,15 @@ public:\n             buf.printf(\"virtual void __vtable_slot_%u();\", counter++);\n             buf.writenl();\n         }\n+        else if (fd.isDtorDeclaration())\n+        {\n+            // Create inaccessible dtor to prevent code from keeping instances that\n+            // need to be destroyed on the C++ side (but cannot call the dtor)\n+            writeProtection(AST.Visibility.Kind.private_);\n+            buf.writeByte('~');\n+            buf.writestring(adparent.ident.toString());\n+            buf.writestringln(\"();\");\n+        }\n     }\n \n     override void visit(AST.UnitTestDeclaration utd)\n@@ -948,6 +971,11 @@ public:\n                 ignored(\"variable %s because of linkage\", vd.toPrettyChars());\n                 return;\n             }\n+            if (vd.mangleOverride && vd.linkage != LINK.c)\n+            {\n+                ignored(\"variable %s because C++ doesn't support explicit mangling\", vd.toPrettyChars());\n+                return;\n+            }\n             if (!isSupportedType(type))\n             {\n                 ignored(\"variable %s because its type cannot be mapped to C++\", vd.toPrettyChars());\n@@ -1073,7 +1101,7 @@ public:\n \n         auto fd = ad.aliassym.isFuncDeclaration();\n \n-        if (fd && (fd.generated || fd.isDtorDeclaration()))\n+        if (fd && (fd.isGenerated() || fd.isDtorDeclaration()))\n         {\n             // Ignore. It's taken care of while visiting FuncDeclaration\n             return;\n@@ -1106,7 +1134,7 @@ public:\n                 // Print prefix of the base class if this function originates from a superclass\n                 // because alias might be resolved through multiple classes, e.g.\n                 // e.g. for alias visit = typeof(super).visit in the visitors\n-                if (!fd.introducing)\n+                if (!fd.isIntroducing())\n                     printPrefix(ad.toParent().isClassDeclaration().baseClass);\n                 else\n                     printPrefix(pd);\n@@ -1655,7 +1683,16 @@ public:\n             scope(exit) printf(\"[typeToBuffer(AST.Type, AST.Dsymbol) exit] %s sym %s\\n\", t.toChars(), s.toChars());\n         }\n \n-        this.ident = s.ident;\n+        // The context pointer (represented as `ThisDeclaration`) is named\n+        // `this` but accessible via `outer`\n+        if (auto td = s.isThisDeclaration())\n+        {\n+            import dmd.id;\n+            this.ident = Id.outer;\n+        }\n+        else\n+            this.ident = s.ident;\n+\n         auto type = origType !is null ? origType : t;\n         AST.Dsymbol customLength;\n \n@@ -1702,7 +1739,12 @@ public:\n         if (this.ident)\n         {\n             buf.writeByte(' ');\n-            writeIdentifier(s, canFixup);\n+            // Custom identifier doesn't need further checks\n+            if (this.ident !is s.ident)\n+                buf.writestring(this.ident.toString());\n+            else\n+                writeIdentifier(s, canFixup);\n+\n         }\n         this.ident = null;\n \n@@ -2922,6 +2964,10 @@ public:\n             scope(exit) printf(\"[writeFullName exit] %s\\n\", sym.toPrettyChars());\n         }\n \n+        // Explicit `pragma(mangle, \"<some string>` overrides the declared name\n+        if (auto mn = getMangleOverride(sym))\n+            return buf.writestring(mn);\n+\n         /// Checks whether `sym` is nested in `par` and hence doesn't need the FQN\n         static bool isNestedIn(AST.Dsymbol sym, AST.Dsymbol par)\n         {\n@@ -2970,6 +3016,15 @@ public:\n         else\n             buf.writestring(sym.ident.toString());\n     }\n+\n+    /// Returns: Explicit mangling for `sym` if present\n+    extern(D) static const(char)[] getMangleOverride(const AST.Dsymbol sym)\n+    {\n+        if (auto decl = sym.isDeclaration())\n+            return decl.mangleOverride;\n+\n+        return null;\n+    }\n }\n \n /// Namespace for identifiers used to represent special enums in C++\n@@ -3037,7 +3092,7 @@ void hashEndIf(ref OutBuffer buf)\n /// Writes `#define <content>` into the supplied buffer\n void hashDefine(ref OutBuffer buf, string content)\n {\n-    buf.writestring(\"# define \");\n+    buf.writestring(\"#define \");\n     buf.writestringln(content);\n }\n "}, {"sha": "4196c05489d25a519329b2637fd893aff18a6be1", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -692,9 +692,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n             // If va's lifetime encloses v's, then error\n             if (va && !va.isDataseg() &&\n-                (va.enclosesLifetimeOf(v) && !(v.storage_class & STC.temp) ||\n-                 vaIsRef ||\n-                 va.isReference() && !(v.storage_class & (STC.parameter | STC.temp))) &&\n+                ((va.enclosesLifetimeOf(v) && !(v.storage_class & STC.temp)) || vaIsRef) &&\n                 fd.setUnsafe())\n             {\n                 if (!gag)\n@@ -793,7 +791,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n         // If va's lifetime encloses v's, then error\n         if (va &&\n-            (va.enclosesLifetimeOf(v) || (va.isRef() && !(va.storage_class & STC.temp)) || va.isDataseg()) &&\n+            (va.enclosesLifetimeOf(v) || (va.isReference() && !(va.storage_class & STC.temp)) || va.isDataseg()) &&\n             fd.setUnsafe())\n         {\n             if (!gag)\n@@ -1284,27 +1282,24 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n         {\n             if (!gag)\n             {\n-                const(char)* msg, supplemental;\n-                if (v.storage_class & STC.parameter &&\n-                    (v.type.hasPointers() || v.storage_class & STC.ref_))\n-                {\n-                    msg = \"returning `%s` escapes a reference to parameter `%s`\";\n-                    supplemental = vsr == ScopeRef.Ref_ReturnScope\n-                                              ? \"perhaps remove `scope` parameter annotation so `return` applies to `ref`\"\n-                                              : v.ident is Id.This\n-                                                    ? \"perhaps annotate the function with `return`\"\n-                                                    : \"perhaps annotate the parameter with `return`\";\n-                }\n-                else\n+                const(char)* varKind = v.isParameter() ? \"parameter\" : \"local variable\";\n+                previewErrorFunc(sc.isDeprecated(), featureState)(e.loc,\n+                    \"returning `%s` escapes a reference to %s `%s`\", e.toChars(), varKind, v.toChars());\n+\n+                if (v.isParameter() && v.isReference())\n                 {\n-                    msg = \"returning `%s` escapes a reference to local variable `%s`\";\n-                    if (v.ident is Id.This)\n-                        supplemental = \"perhaps annotate the function with `return`\";\n+                    if (v.storage_class & STC.returnScope)\n+                    {\n+                        previewSupplementalFunc(sc.isDeprecated(), featureState)(v.loc,\n+                            \"perhaps change the `return scope` into `scope return`\");\n+                    }\n+                    else\n+                    {\n+                        const(char)* annotateKind = (v.ident is Id.This) ? \"function\" : \"parameter\";\n+                        previewSupplementalFunc(sc.isDeprecated(), featureState)(v.loc,\n+                            \"perhaps annotate the %s with `return`\", annotateKind);\n+                    }\n                 }\n-\n-                previewErrorFunc(sc.isDeprecated(), featureState)(e.loc, msg, e.toChars(), v.toChars());\n-                if (supplemental)\n-                    previewSupplementalFunc(sc.isDeprecated(), featureState)(e.loc, supplemental);\n             }\n             result = true;\n         }\n@@ -1897,7 +1892,7 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false)\n \n         override void visit(ThisExp e)\n         {\n-            if (e.var && e.var.toParent2().isFuncDeclaration().isThis2)\n+            if (e.var && e.var.toParent2().isFuncDeclaration().hasDualContext())\n                 escapeByValue(e, er, live);\n             else if (e.var)\n                 er.byref.push(e.var);\n@@ -2297,3 +2292,37 @@ bool isReferenceToMutable(Parameter p, Type t)\n     }\n     return isReferenceToMutable(p.type);\n }\n+\n+/**********************************\n+* Determine if `va` has a lifetime that lasts past\n+* the destruction of `v`\n+* Params:\n+*     va = variable assigned to\n+*     v = variable being assigned\n+* Returns:\n+*     true if it does\n+*/\n+private bool enclosesLifetimeOf(const VarDeclaration va, const VarDeclaration v) pure\n+{\n+    assert(va.sequenceNumber != va.sequenceNumber.init);\n+    assert(v.sequenceNumber != v.sequenceNumber.init);\n+    return va.sequenceNumber < v.sequenceNumber;\n+}\n+\n+/***************************************\n+ * Add variable `v` to maybes[]\n+ *\n+ * When a maybescope variable `v` is assigned to a maybescope variable `va`,\n+ * we cannot determine if `this` is actually scope until the semantic\n+ * analysis for the function is completed. Thus, we save the data\n+ * until then.\n+ * Params:\n+ *     v = an `STC.maybescope` variable that was assigned to `this`\n+ */\n+private void addMaybe(VarDeclaration va, VarDeclaration v)\n+{\n+    //printf(\"add %s to %s's list of dependencies\\n\", v.toChars(), toChars());\n+    if (!va.maybes)\n+        va.maybes = new VarDeclarations();\n+    va.maybes.push(v);\n+}"}, {"sha": "07d885b0beef5bae9fa4f60f234a7471511dc830", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -170,7 +170,7 @@ FuncDeclaration hasThis(Scope* sc)\n         {\n             return null;\n         }\n-        if (!fd.isNested() || fd.isThis() || (fd.isThis2 && fd.isMember2()))\n+        if (!fd.isNested() || fd.isThis() || (fd.hasDualContext() && fd.isMember2()))\n             break;\n \n         Dsymbol parent = fd.parent;\n@@ -187,7 +187,7 @@ FuncDeclaration hasThis(Scope* sc)\n         fd = parent.isFuncDeclaration();\n     }\n \n-    if (!fd.isThis() && !(fd.isThis2 && fd.isMember2()))\n+    if (!fd.isThis() && !(fd.hasDualContext() && fd.isMember2()))\n     {\n         return null;\n     }\n@@ -1210,7 +1210,7 @@ extern (C++) abstract class Expression : ASTNode\n                 scope bool function(DtorDeclaration) check, const string checkName\n     ) {\n         auto dd = f.isDtorDeclaration();\n-        if (!dd || !dd.generated)\n+        if (!dd || !dd.isGenerated())\n             return;\n \n         // DtorDeclaration without parents should fail at an earlier stage\n@@ -1227,7 +1227,7 @@ extern (C++) abstract class Expression : ASTNode\n         }\n \n         dd.loc.errorSupplemental(\"%s`%s.~this` is %.*s because of the following field's destructors:\",\n-                            dd.generated ? \"generated \" : \"\".ptr,\n+                            dd.isGenerated() ? \"generated \" : \"\".ptr,\n                             ad.toChars,\n                             cast(int) checkName.length, checkName.ptr);\n \n@@ -1258,7 +1258,7 @@ extern (C++) abstract class Expression : ASTNode\n             {\n                 field.loc.errorSupplemental(\" - %s %s\", field.type.toChars(), field.toChars());\n \n-                if (fieldSd.dtor.generated)\n+                if (fieldSd.dtor.isGenerated())\n                     checkOverridenDtor(sc, fieldSd.dtor, check, checkName);\n                 else\n                     fieldSd.dtor.loc.errorSupplemental(\"   %.*s `%s.~this` is declared here\",\n@@ -1288,7 +1288,7 @@ extern (C++) abstract class Expression : ASTNode\n             return false; // magic variable never violates pure and safe\n         if (v.isImmutable())\n             return false; // always safe and pure to access immutables...\n-        if (v.isConst() && !v.isRef() && (v.isDataseg() || v.isParameter()) && v.type.implicitConvTo(v.type.immutableOf()))\n+        if (v.isConst() && !v.isReference() && (v.isDataseg() || v.isParameter()) && v.type.implicitConvTo(v.type.immutableOf()))\n             return false; // or const global/parameter values which have no mutable indirections\n         if (v.storage_class & STC.manifest)\n             return false; // ...or manifest constants\n@@ -3461,7 +3461,7 @@ extern (C++) final class ScopeExp : Expression\n             //assert(ti.needsTypeInference(sc));\n             if (ti.tempdecl &&\n                 ti.semantictiargsdone &&\n-                ti.semanticRun == PASS.init)\n+                ti.semanticRun == PASS.initial)\n             {\n                 error(\"partial %s `%s` has no type\", sds.kind(), toChars());\n                 return true;\n@@ -3859,7 +3859,7 @@ extern (C++) final class FuncExp : Expression\n     {\n         if (td)\n             return new FuncExp(loc, td.syntaxCopy(null));\n-        else if (fd.semanticRun == PASS.init)\n+        else if (fd.semanticRun == PASS.initial)\n             return new FuncExp(loc, fd.syntaxCopy(null));\n         else // https://issues.dlang.org/show_bug.cgi?id=13481\n              // Prevent multiple semantic analysis of lambda body.\n@@ -4950,7 +4950,7 @@ extern (C++) final class DotTemplateInstanceExp : UnaExp\n         // Same logic as ScopeExp.checkType()\n         if (ti.tempdecl &&\n             ti.semantictiargsdone &&\n-            ti.semanticRun == PASS.init)\n+            ti.semanticRun == PASS.initial)\n         {\n             error(\"partial %s `%s` has no type\", ti.kind(), toChars());\n             return true;\n@@ -4962,7 +4962,7 @@ extern (C++) final class DotTemplateInstanceExp : UnaExp\n     {\n         if (ti.tempdecl &&\n             ti.semantictiargsdone &&\n-            ti.semanticRun == PASS.init)\n+            ti.semanticRun == PASS.initial)\n \n             error(\"partial %s `%s` has no value\", ti.kind(), toChars());\n         else"}, {"sha": "7b7c489295a9df76fe6bbd2b158280885ed4db8e", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 82, "deletions": 79, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1046,7 +1046,7 @@ L1:\n     if (e1.op == EXP.this_)\n     {\n         FuncDeclaration f = hasThis(sc);\n-        if (f && f.isThis2)\n+        if (f && f.hasDualContext())\n         {\n             if (f.followInstantiationContext(ad))\n             {\n@@ -1444,13 +1444,6 @@ private Type arrayExpressionToCommonType(Scope* sc, ref Expressions exps)\n             Expression ex = condexp.expressionSemantic(sc);\n             if (ex.op == EXP.error)\n                 e = ex;\n-            else if (e.op == EXP.function_ || e.op == EXP.delegate_)\n-            {\n-                // https://issues.dlang.org/show_bug.cgi?id=21285\n-                // Functions and delegates don't convert correctly with castTo below\n-                exps[i] = condexp.e1;\n-                e = condexp.e2;\n-            }\n             else\n             {\n                 // Convert to common type\n@@ -1723,7 +1716,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n         if (sc._module)\n             sc._module.hasAlwaysInlines = true;\n         if (sc.func)\n-            sc.func.hasAlwaysInlines = true;\n+            sc.func.flags |= FUNCFLAG.hasAlwaysInline;\n     }\n \n     const isCtorCall = fd && fd.needThis() && fd.isCtorDeclaration();\n@@ -3743,7 +3736,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 return setError();\n             }\n \n-            if (sd.hasRegularCtor() && nargs)\n+            // https://issues.dlang.org/show_bug.cgi?id=22639\n+            // If the new expression has arguments, we either should call a\n+            // regular constructor of a copy constructor if the first argument\n+            // is the same type as the struct\n+            if (nargs && (sd.hasRegularCtor() || (sd.ctor && (*exp.arguments)[0].type.mutableOf() == sd.type.mutableOf())))\n             {\n                 FuncDeclaration f = resolveFuncCall(exp.loc, sc, sd.ctor, null, tb, exp.arguments, FuncResolveFlag.standard);\n                 if (!f || f.errors)\n@@ -4201,30 +4198,27 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         Type tthis = null;\n         Expression e1org = exp.e1;\n \n-        if (exp.e1.op == EXP.comma)\n+        if (auto ce = exp.e1.isCommaExp())\n         {\n             /* Rewrite (a,b)(args) as (a,(b(args)))\n              */\n-            auto ce = cast(CommaExp)exp.e1;\n             exp.e1 = ce.e2;\n             ce.e2 = exp;\n             result = ce.expressionSemantic(sc);\n             return;\n         }\n-        if (exp.e1.op == EXP.delegate_)\n+        if (DelegateExp de = exp.e1.isDelegateExp())\n         {\n-            DelegateExp de = cast(DelegateExp)exp.e1;\n             exp.e1 = new DotVarExp(de.loc, de.e1, de.func, de.hasOverloads);\n             visit(exp);\n             return;\n         }\n-        if (exp.e1.op == EXP.function_)\n+        if (FuncExp fe = exp.e1.isFuncExp())\n         {\n             if (arrayExpressionSemantic(exp.arguments, sc) || preFunctionParameters(sc, exp.arguments))\n                 return setError();\n \n             // Run e1 semantic even if arguments have any errors\n-            FuncExp fe = cast(FuncExp)exp.e1;\n             exp.e1 = callExpSemantic(fe, sc, exp.arguments);\n             if (exp.e1.op == EXP.error)\n             {\n@@ -4252,9 +4246,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         /* This recognizes:\n          *  foo!(tiargs)(funcargs)\n          */\n-        if (exp.e1.op == EXP.scope_)\n+        if (ScopeExp se = exp.e1.isScopeExp())\n         {\n-            ScopeExp se = cast(ScopeExp)exp.e1;\n             TemplateInstance ti = se.sds.isTemplateInstance();\n             if (ti)\n             {\n@@ -4300,9 +4293,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n          *  expr.foo!(tiargs)(funcargs)\n          */\n     Ldotti:\n-        if (exp.e1.op == EXP.dotTemplateInstance)\n+        if (DotTemplateInstanceExp se = exp.e1.isDotTemplateInstanceExp())\n         {\n-            DotTemplateInstanceExp se = cast(DotTemplateInstanceExp)exp.e1;\n             TemplateInstance ti = se.ti;\n             {\n                 /* Attempt to instantiate ti. If that works, go with it.\n@@ -4347,9 +4339,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         else\n         {\n-            if (exp.e1.op == EXP.dotIdentifier)\n+            if (DotIdExp die = exp.e1.isDotIdExp())\n             {\n-                DotIdExp die = cast(DotIdExp)exp.e1;\n                 exp.e1 = die.expressionSemantic(sc);\n                 /* Look for e1 having been rewritten to expr.opDispatch!(string)\n                  * We handle such earlier, so go back.\n@@ -4380,9 +4371,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n             /* Look for e1 being a lazy parameter\n              */\n-            if (exp.e1.op == EXP.variable)\n+            if (VarExp ve = exp.e1.isVarExp())\n             {\n-                VarExp ve = cast(VarExp)exp.e1;\n                 if (ve.var.storage_class & STC.lazy_)\n                 {\n                     // lazy parameters can be called without violating purity and safety\n@@ -4404,10 +4394,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 exp.e1 = new VarExp(se.loc, se.var, true);\n                 exp.e1 = exp.e1.expressionSemantic(sc);\n             }\n-            else if (exp.e1.op == EXP.dot)\n+            else if (DotExp de = exp.e1.isDotExp())\n             {\n-                DotExp de = cast(DotExp)exp.e1;\n-\n                 if (de.e2.op == EXP.overloadSet)\n                 {\n                     ethis = de.e1;\n@@ -4490,7 +4478,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 if (sd.ctor)\n                 {\n                     auto ctor = sd.ctor.isCtorDeclaration();\n-                    if (ctor && ctor.isCpCtor && ctor.generated)\n+                    if (ctor && ctor.isCpCtor && ctor.isGenerated())\n                         sd.ctor = null;\n                 }\n \n@@ -4504,7 +4492,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                        If all constructors are copy constructors, then\n                        try default construction.\n                      */\n-                    if (!sd.hasRegularCtor)\n+                    if (!sd.hasRegularCtor &&\n+                        // https://issues.dlang.org/show_bug.cgi?id=22639\n+                        // we might still have a copy constructor that could be called\n+                        (*exp.arguments)[0].type.mutableOf != sd.type.mutableOf())\n                         goto Lx;\n \n                     auto sle = new StructLiteralExp(exp.loc, sd, null, exp.e1.type);\n@@ -4850,10 +4841,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 return setError();\n             }\n         }\n-        else if (exp.e1.op == EXP.overloadSet)\n+        else if (auto oe = exp.e1.isOverExp())\n         {\n-            auto os = (cast(OverExp)exp.e1).vars;\n-            exp.f = resolveOverloadSet(exp.loc, sc, os, tiargs, tthis, exp.arguments);\n+            exp.f = resolveOverloadSet(exp.loc, sc, oe.vars, tiargs, tthis, exp.arguments);\n             if (!exp.f)\n                 return setError();\n             if (ethis)\n@@ -4877,11 +4867,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             const(char)* p;\n             Dsymbol s;\n             exp.f = null;\n-            if (exp.e1.op == EXP.function_)\n+            if (auto fe = exp.e1.isFuncExp())\n             {\n                 // function literal that direct called is always inferred.\n-                assert((cast(FuncExp)exp.e1).fd);\n-                exp.f = (cast(FuncExp)exp.e1).fd;\n+                assert(fe.fd);\n+                exp.f = fe.fd;\n                 tf = cast(TypeFunction)exp.f.type;\n                 p = \"function literal\";\n             }\n@@ -5011,11 +5001,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             t1 = tf;\n         }\n-        else if (exp.e1.op == EXP.variable)\n+        else if (VarExp ve = exp.e1.isVarExp())\n         {\n             // Do overload resolution\n-            VarExp ve = cast(VarExp)exp.e1;\n-\n             exp.f = ve.var.isFuncDeclaration();\n             assert(exp.f);\n             tiargs = null;\n@@ -5162,7 +5150,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         // declare dual-context container\n-        if (exp.f && exp.f.isThis2 && !sc.intypeof && sc.func)\n+        if (exp.f && exp.f.hasDualContext() && !sc.intypeof && sc.func)\n         {\n             // check access to second `this`\n             if (AggregateDeclaration ad2 = exp.f.isMember2())\n@@ -6042,13 +6030,13 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         {\n             auto fileName = FileName(name.toDString);\n-            if (auto fmResult = FileManager.fileManager.lookup(fileName))\n+            if (auto fmResult = global.fileManager.lookup(fileName))\n             {\n                 se = new StringExp(e.loc, fmResult.data);\n             }\n             else\n             {\n-                auto readResult = File.read(name);\n+                auto readResult = File.read(name.toDString);\n                 if (!readResult.success)\n                 {\n                     e.error(\"cannot read file `%s`\", name);\n@@ -6060,9 +6048,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     auto data = readResult.extractSlice();\n                     se = new StringExp(e.loc, data);\n \n-                    FileBuffer* fileBuffer = FileBuffer.create();\n-                    fileBuffer.data = data;\n-                    FileManager.fileManager.add(fileName, fileBuffer);\n+                    FileBuffer* fileBuffer = new FileBuffer(data);\n+                    global.fileManager.add(fileName, fileBuffer);\n                 }\n             }\n         }\n@@ -6200,10 +6187,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n             const op = exp.e1.op;\n             bool isEqualsCallExpression;\n-            if (op == EXP.call)\n+            if (const callExp = exp.e1.isCallExp())\n             {\n-                const callExp = cast(CallExp) exp.e1;\n-\n                 // https://issues.dlang.org/show_bug.cgi?id=20331\n                 // callExp.f may be null if the assert contains a call to\n                 // a function pointer or literal\n@@ -6436,7 +6421,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 }\n                 else if (t)\n                 {\n-                    result = new IntegerExp(exp.loc, t.alignsize, Type.tsize_t);\n+                    // Note similarity to getProperty() implementation of __xalignof\n+                    const explicitAlignment = t.alignment();\n+                    const naturalAlignment = t.alignsize();\n+                    const actualAlignment = (explicitAlignment.isDefault() ? naturalAlignment : explicitAlignment.get());\n+                    result = new IntegerExp(exp.loc, actualAlignment, Type.tsize_t);\n                 }\n                 else if (s)\n                 {\n@@ -6643,7 +6632,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n \n             if (v && (v.isDataseg() || // fix https://issues.dlang.org/show_bug.cgi?id=8238\n-                      (!v.needThis() && v.semanticRun > PASS.init)))  // fix https://issues.dlang.org/show_bug.cgi?id=17258\n+                      (!v.needThis() && v.semanticRun > PASS.initial)))  // fix https://issues.dlang.org/show_bug.cgi?id=17258\n             {\n                 // (e1, v)\n                 checkAccess(exp.loc, sc, exp.e1, v);\n@@ -6736,7 +6725,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n         result = e;\n         // declare dual-context container\n-        if (f.isThis2 && !sc.intypeof && sc.func)\n+        if (f.hasDualContext() && !sc.intypeof && sc.func)\n         {\n             // check access to second `this`\n             if (AggregateDeclaration ad2 = f.isMember2())\n@@ -7311,7 +7300,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (checkNonAssignmentArrayOp(e.e1))\n             return setError();\n \n-        e.type = Type.tbool;\n+        e.type = (sc && sc.flags & SCOPE.Cfile) ? Type.tint32 : Type.tbool;\n         result = e;\n     }\n \n@@ -7323,7 +7312,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         // 3. Removal of keyword, \"delete\" can be used for other identities\n         if (!exp.isRAII)\n         {\n-            error(exp.loc, \"The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\");\n+            error(exp.loc, \"the `delete` keyword is obsolete\");\n+            errorSupplemental(exp.loc, \"use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\");\n             return setError();\n         }\n \n@@ -7847,9 +7837,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                  */\n                 if (VarDeclaration v = expToVariable(exp.e1))\n                 {\n-                    if (exp.e1.op == EXP.dotVariable)\n+                    if (DotVarExp dve = exp.e1.isDotVarExp())\n                     {\n-                        DotVarExp dve = cast(DotVarExp)exp.e1;\n+\n                         if ((dve.e1.op == EXP.this_ || dve.e1.op == EXP.super_) &&\n                             !(v.storage_class & STC.ref_))\n                         {\n@@ -8140,10 +8130,9 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             result = exp.e2;\n             return;\n         }\n-        if (exp.e2.op == EXP.template_)\n+        if (auto te = exp.e2.isTemplateExp())\n         {\n-            auto td = (cast(TemplateExp)exp.e2).td;\n-            Expression e = new DotTemplateExp(exp.loc, exp.e1, td);\n+            Expression e = new DotTemplateExp(exp.loc, exp.e1, te.td);\n             result = e.expressionSemantic(sc);\n             return;\n         }\n@@ -8182,11 +8171,15 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         e.e2 = e.e2.arrayFuncConv(sc);\n \n         e.type = e.e2.type;\n+        result = e;\n+\n+        if (sc.flags & SCOPE.Cfile)\n+            return;\n+\n         if (e.type is Type.tvoid)\n             discardValue(e.e1);\n-        else if (!e.allowCommaExp && !e.isGenerated && !(sc.flags & SCOPE.Cfile))\n+        else if (!e.allowCommaExp && !e.isGenerated)\n             e.error(\"Using the result of a comma expression is not allowed\");\n-        result = e;\n     }\n \n     override void visit(IntervalExp e)\n@@ -8472,6 +8465,19 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     // OR it in, because it might already be set for C array indexing\n                     exp.indexIsInBounds |= bounds.contains(getIntRange(exp.e2));\n                 }\n+                else if (sc.flags & SCOPE.Cfile && t1b.ty == Tsarray)\n+                {\n+                    if (auto ve = exp.e1.isVarExp())\n+                    {\n+                        /* Rewrite 0-length C array ve[exp.e2] as *(ve + exp.e2)\n+                         */\n+                        auto vp = ve.castTo(sc, t1b.isTypeSArray().next.pointerTo());\n+                        auto e = new AddExp(exp.loc, vp, exp.e2);\n+                        auto pe = new PtrExp(exp.loc, e);\n+                        result = pe.expressionSemantic(sc).optimize(WANTvalue);\n+                        return;\n+                    }\n+                }\n             }\n         }\n \n@@ -10024,9 +10030,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n-        if (exp.e1.op == EXP.slice)\n+        if (SliceExp se = exp.e1.isSliceExp())\n         {\n-            SliceExp se = cast(SliceExp)exp.e1;\n             if (se.e1.type.toBasetype().ty == Tsarray)\n             {\n                 exp.error(\"cannot append to static array `%s`\", se.e1.type.toChars());\n@@ -11270,7 +11275,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             e1x = e1x.optimize(WANTvalue);\n             if (e1x.toBool().hasValue(exp.op == EXP.orOr))\n             {\n-                result = IntegerExp.createBool(exp.op == EXP.orOr);\n+                if (sc.flags & SCOPE.Cfile)\n+                    result = new IntegerExp(exp.op == EXP.orOr);\n+                else\n+                    result = IntegerExp.createBool(exp.op == EXP.orOr);\n                 return;\n             }\n         }\n@@ -11315,7 +11323,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (e2x.type.ty == Tvoid)\n             exp.type = Type.tvoid;\n         else\n-            exp.type = Type.tbool;\n+            exp.type = (sc && sc.flags & SCOPE.Cfile) ? Type.tint32 : Type.tbool;\n \n         exp.e1 = e1x;\n         exp.e2 = e2x;\n@@ -11412,7 +11420,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (f1 || f2)\n             return setError();\n \n-        exp.type = Type.tbool;\n+        exp.type = (sc && sc.flags & SCOPE.Cfile) ? Type.tint32 : Type.tbool;\n \n         // Special handling for array comparisons\n         Expression arrayLowering = null;\n@@ -11690,7 +11698,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (f1 || f2)\n             return setError();\n \n-        exp.type = Type.tbool;\n+        exp.type = (sc && sc.flags & SCOPE.Cfile) ? Type.tint32 : Type.tbool;\n \n         if (!isArrayComparison)\n         {\n@@ -11825,8 +11833,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n         }\n \n-        if (exp.econd.op == EXP.dotIdentifier)\n-            (cast(DotIdExp)exp.econd).noderef = true;\n+        if (auto die = exp.econd.isDotIdExp())\n+            die.noderef = true;\n \n         Expression ec = exp.econd.expressionSemantic(sc);\n         ec = resolveProperties(sc, ec);\n@@ -12654,9 +12662,8 @@ Expression semanticY(DotTemplateInstanceExp exp, Scope* sc, int flag)\n \n     if (e.op == EXP.error)\n         return e;\n-    if (e.op == EXP.dotVariable)\n+    if (DotVarExp dve = e.isDotVarExp())\n     {\n-        DotVarExp dve = cast(DotVarExp)e;\n         if (FuncDeclaration fd = dve.var.isFuncDeclaration())\n         {\n             if (TemplateDeclaration td = fd.findTemplateDeclRoot())\n@@ -12707,9 +12714,8 @@ Expression semanticY(DotTemplateInstanceExp exp, Scope* sc, int flag)\n         }\n     }\n \n-    if (e.op == EXP.dotTemplateDeclaration)\n+    if (DotTemplateExp dte = e.isDotTemplateExp())\n     {\n-        DotTemplateExp dte = cast(DotTemplateExp)e;\n         exp.e1 = dte.e1; // pull semantic() result\n \n         exp.ti.tempdecl = dte.td;\n@@ -12738,10 +12744,8 @@ Expression semanticY(DotTemplateInstanceExp exp, Scope* sc, int flag)\n         return new ScopeExp(exp.loc, exp.ti)\n                .expressionSemantic(sc);\n     }\n-    else if (e.op == EXP.dot)\n+    else if (DotExp de = e.isDotExp())\n     {\n-        DotExp de = cast(DotExp)e;\n-\n         if (de.e2.op == EXP.overloadSet)\n         {\n             if (!exp.findTempDecl(sc) || !exp.ti.semanticTiargs(sc))\n@@ -12765,9 +12769,8 @@ Expression semanticY(DotTemplateInstanceExp exp, Scope* sc, int flag)\n                    .expressionSemantic(sc);\n         }\n     }\n-    else if (e.op == EXP.overloadSet)\n+    else if (OverExp oe = e.isOverExp())\n     {\n-        OverExp oe = cast(OverExp)e;\n         exp.ti.tempdecl = oe.vars;\n         return new ScopeExp(exp.loc, exp.ti)\n                .expressionSemantic(sc);\n@@ -13055,7 +13058,7 @@ Expression getThisSkipNestedFuncs(const ref Loc loc, Scope* sc, Dsymbol s, Aggre\n         {\n             n++;\n             e1 = new VarExp(loc, f.vthis);\n-            if (f.isThis2)\n+            if (f.hasDualContext())\n             {\n                 // (*__this)[i]\n                 if (n > 1)\n@@ -13355,8 +13358,8 @@ Expression toBoolean(Expression exp, Scope* sc)\n \n         default:\n             // Default is 'yes' - do nothing\n-            Expression e = exp;\n-            Type t = exp.type;\n+            Expression e = arrayFuncConv(exp, sc);\n+            Type t = e.type;\n             Type tb = t.toBasetype();\n             Type att = null;\n "}, {"sha": "b86c7995562670a2e9ff67c5031149150f263b7a", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,10 +20,15 @@ import dmd.identifier;\n enum package_d  = \"package.\" ~ mars_ext;\n enum package_di = \"package.\" ~ hdr_ext;\n \n-struct FileManager\n+final class FileManager\n {\n     private StringTable!(FileBuffer*) files;\n-    private __gshared bool initialized = false;\n+\n+    ///\n+    public this () nothrow\n+    {\n+        this.files._init();\n+    }\n \n nothrow:\n     /********************************************\n@@ -143,9 +148,6 @@ nothrow:\n      */\n     const(FileBuffer)* lookup(FileName filename)\n     {\n-        if (!initialized)\n-            FileManager._init();\n-\n         const name = filename.toString;\n         if (auto val = files.lookup(name))\n             return val.value;\n@@ -182,9 +184,6 @@ nothrow:\n      */\n     const(char)[][] getLines(FileName file)\n     {\n-        if (!initialized)\n-            FileManager._init();\n-\n         const(char)[][] lines;\n         if (const buffer = lookup(file))\n         {\n@@ -241,29 +240,9 @@ nothrow:\n      */\n     FileBuffer* add(FileName filename, FileBuffer* filebuffer)\n     {\n-        if (!initialized)\n-            FileManager._init();\n-\n         auto val = files.insert(filename.toString, filebuffer);\n         return val == null ? null : val.value;\n     }\n-\n-    __gshared fileManager = FileManager();\n-\n-    // Initialize the global FileManager singleton\n-    private void _init()\n-    {\n-        if (!initialized)\n-        {\n-            fileManager.initialize();\n-            initialized = true;\n-        }\n-    }\n-\n-    void initialize()\n-    {\n-        files._init();\n-    }\n }\n \n private FileBuffer readFromStdin() nothrow"}, {"sha": "53ed62efd70d21b244c407e52c76fccdbbe52166", "filename": "gcc/d/dmd/foreachvar.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fforeachvar.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fforeachvar.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fforeachvar.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -320,4 +320,3 @@ void foreachExpAndVar(Statement s,\n \n     visit(s);\n }\n-"}, {"sha": "8d8395188b63d4ec5f737d3f2bdb817b2d244cbe", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 212, "deletions": 78, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -140,7 +140,7 @@ public:\n     override void visit(TryFinallyStatement s)\n     {\n         DtorExpStatement des;\n-        if (fd.nrvo_can && s.finalbody && (des = s.finalbody.isDtorExpStatement()) !is null &&\n+        if (fd.isNRVO() && s.finalbody && (des = s.finalbody.isDtorExpStatement()) !is null &&\n             fd.nrvo_var == des.var)\n         {\n             if (!(global.params.useExceptions && ClassDeclaration.throwable))\n@@ -182,7 +182,7 @@ public:\n             catches.push(ctch);\n \n             Statement s2 = new TryCatchStatement(Loc.initial, s._body, catches);\n-            fd.eh_none = false;\n+            fd.flags &= ~FUNCFLAG.noEH;\n             replaceCurrent(s2);\n             s2.accept(this);\n         }\n@@ -205,6 +205,17 @@ enum FUNCFLAG : uint\n     printf           = 0x200,  /// is a printf-like function\n     scanf            = 0x400,  /// is a scanf-like function\n     noreturn         = 0x800,  /// the function does not return\n+    NRVO             = 0x1000, /// Support for named return value optimization\n+    naked            = 0x2000, /// The function is 'naked' (see inline ASM)\n+    generated        = 0x4000, /// The function is compiler generated (e.g. `opCmp`)\n+    introducing      = 0x8000, /// If this function introduces the overload set\n+    semantic3Errors  = 0x10000, /// If errors in semantic3 this function's frame ptr\n+    noEH             = 0x20000, /// No exception unwinding is needed\n+    inferRetType     = 0x40000, /// Return type is to be inferred\n+    dualContext      = 0x80000, /// has a dual-context 'this' parameter\n+    hasAlwaysInline  = 0x100000, /// Contains references to functions that must be inlined\n+    CRTCtor          = 0x200000, /// Has attribute pragma(crt_constructor)\n+    CRTDtor          = 0x400000, /// Has attribute pragma(crt_destructor)\n }\n \n /***********************************************************\n@@ -268,7 +279,6 @@ extern (C++) class FuncDeclaration : Declaration\n     // scopes from having the same name\n     DsymbolTable localsymtab;\n     VarDeclaration vthis;               /// 'this' parameter (member and nested)\n-    bool isThis2;                       /// has a dual-context 'this' parameter\n     VarDeclaration v_arguments;         /// '_arguments' parameter\n \n     VarDeclaration v_argptr;            /// '_argptr' variable\n@@ -278,31 +288,21 @@ extern (C++) class FuncDeclaration : Declaration\n     FuncDeclaration overnext0;          /// next in overload list (only used during IFTI)\n     Loc endloc;                         /// location of closing curly bracket\n     int vtblIndex = -1;                 /// for member functions, index into vtbl[]\n-    bool naked;                         /// true if naked\n-    bool generated;                     /// true if function was generated by the compiler rather than\n-                                        /// supplied by the user\n-    bool hasAlwaysInlines;              /// contains references to functions that must be inlined\n-    ubyte isCrtCtorDtor;                /// has attribute pragma(crt_constructor(1)/crt_destructor(2))\n-                                        /// not set before the glue layer\n \n     ILS inlineStatusStmt = ILS.uninitialized;\n     ILS inlineStatusExp = ILS.uninitialized;\n     PINLINE inlining = PINLINE.default_;\n \n     int inlineNest;                     /// !=0 if nested inline\n-    bool eh_none;                       /// true if no exception unwinding is needed\n \n-    bool semantic3Errors;               /// true if errors in semantic3 this function's frame ptr\n     ForeachStatement fes;               /// if foreach body, this is the foreach\n     BaseClass* interfaceVirtual;        /// if virtual, but only appears in base interface vtbl[]\n-    bool introducing;                   /// true if 'introducing' function\n     /** if !=NULL, then this is the type\n     of the 'introducing' function\n     this one is overriding\n     */\n     Type tintro;\n \n-    bool inferRetType;                  /// true if return type is to be inferred\n     StorageClass storage_class2;        /// storage class for template onemember's\n \n     // Things that should really go into Scope\n@@ -314,8 +314,6 @@ extern (C++) class FuncDeclaration : Declaration\n     /// 16 if there are multiple return statements\n     int hasReturnExp;\n \n-    // Support for NRVO (named return value optimization)\n-    bool nrvo_can = true;               /// true means we can do NRVO\n     VarDeclaration nrvo_var;            /// variable to replace with shidden\n     Symbol* shidden;                    /// hidden pointer passed to function\n \n@@ -346,7 +344,9 @@ extern (C++) class FuncDeclaration : Declaration\n \n     FuncDeclarations *inlinedNestedCallees;\n \n-    uint flags;                        /// FUNCFLAG.xxxxx\n+    /// Function flags: A collection of boolean packed for memory efficiency\n+    /// See the `FUNCFLAG` enum\n+    uint flags = FUNCFLAG.NRVO;\n \n     /**\n      * Data for a function declaration that is needed for the Objective-C\n@@ -374,7 +374,8 @@ extern (C++) class FuncDeclaration : Declaration\n         /* The type given for \"infer the return type\" is a TypeFunction with\n          * NULL for the return type.\n          */\n-        inferRetType = (type && type.nextOf() is null);\n+        if (type && type.nextOf() is null)\n+            this.flags |= FUNCFLAG.inferRetType;\n     }\n \n     static FuncDeclaration create(const ref Loc loc, const ref Loc endloc, Identifier id, StorageClass storage_class, Type type, bool noreturn = false)\n@@ -480,7 +481,7 @@ extern (C++) class FuncDeclaration : Declaration\n                 return false;\n         }\n \n-        return !errors && !semantic3Errors;\n+        return !errors && !this.hasSemantic3Errors();\n     }\n \n     /****************************************************\n@@ -515,9 +516,11 @@ extern (C++) class FuncDeclaration : Declaration\n      */\n     extern (D) final void declareThis(Scope* sc)\n     {\n-        isThis2 = toParent2() != toParentLocal();\n+        const bool dualCtx = (toParent2() != toParentLocal());\n+        if (dualCtx)\n+            this.flags |= FUNCFLAG.dualContext;\n         auto ad = isThis();\n-        if (!isThis2 && !ad && !isNested())\n+        if (!dualCtx && !ad && !isNested())\n         {\n             vthis = null;\n             objc.selectorParameter = null;\n@@ -529,16 +532,16 @@ extern (C++) class FuncDeclaration : Declaration\n             return t.addMod(type.mod).addStorageClass(storage_class);\n         }\n \n-        if (isThis2 || isNested())\n+        if (dualCtx || isNested())\n         {\n             /* The 'this' for a nested function is the link to the\n              * enclosing function's stack frame.\n              * Note that nested functions and member functions are disjoint.\n              */\n-            Type tthis = addModStc(isThis2 ?\n+            Type tthis = addModStc(dualCtx ?\n                                    Type.tvoidptr.sarrayOf(2).pointerTo() :\n                                    Type.tvoid.pointerTo());\n-            vthis = new VarDeclaration(loc, tthis, isThis2 ? Id.this2 : Id.capture, null);\n+            vthis = new VarDeclaration(loc, tthis, dualCtx ? Id.this2 : Id.capture, null);\n             vthis.storage_class |= STC.parameter | STC.nodtor;\n         }\n         else if (ad)\n@@ -549,22 +552,6 @@ extern (C++) class FuncDeclaration : Declaration\n             if (thandle.ty == Tstruct)\n             {\n                 vthis.storage_class |= STC.ref_;\n-\n-                /* if member function is marked 'inout', then 'this' is 'return ref'\n-                 * The same thing is done for `ref inout` parameters in TypeFunction's semantic routine.\n-                 */\n-                if (auto tf = type.isTypeFunction())\n-                {\n-                    /* This feature was a mistake, but existing code relies on it.\n-                     * So only disable it in @safe code and DIP1000 code\n-                     */\n-                    if (!(global.params.useDIP1000 == FeatureState.enabled &&\n-                          tf.trust == TRUST.safe))\n-                    {\n-                        if (tf.isInOutQual())\n-                            vthis.storage_class |= STC.return_;\n-                    }\n-                }\n             }\n         }\n \n@@ -574,19 +561,8 @@ extern (C++) class FuncDeclaration : Declaration\n                 vthis.storage_class |= STC.return_;\n             if (tf.isScopeQual)\n                 vthis.storage_class |= STC.scope_;\n-\n-            /* Add STC.returnScope like typesem.d does for TypeFunction parameters,\n-             * at least it should be the same. At the moment, we'll just\n-             * do existing practice. But we should examine how TypeFunction does\n-             * it, for consistency.\n-             */\n-            if (global.params.useDIP1000 != FeatureState.enabled &&\n-                !tf.isref && isRefReturnScope(vthis.storage_class))\n-            {\n-                /* if `ref return scope`, evaluate to `ref` `return scope`\n-                 */\n+            if (tf.isreturnscope)\n                 vthis.storage_class |= STC.returnScope;\n-            }\n         }\n         if (flags & FUNCFLAG.inferScope && !(vthis.storage_class & STC.scope_))\n             vthis.storage_class |= STC.maybescope;\n@@ -1369,7 +1345,7 @@ extern (C++) class FuncDeclaration : Declaration\n         if (!tf.isnogc)\n             flags |= FUNCFLAG.nogcInprocess;\n \n-        if (!isVirtual() || introducing)\n+        if (!isVirtual() || this.isIntroducing())\n             flags |= FUNCFLAG.returnInprocess;\n \n         // Initialize for inferring STC.scope_\n@@ -1482,6 +1458,73 @@ extern (C++) class FuncDeclaration : Declaration\n         return !(flags & FUNCFLAG.nogcInprocess) && isNogc();\n     }\n \n+    final bool isNRVO() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.NRVO);\n+    }\n+\n+    final void isNRVO(bool v) pure nothrow @safe @nogc\n+    {\n+        if (v) this.flags |= FUNCFLAG.NRVO;\n+        else this.flags &= ~FUNCFLAG.NRVO;\n+    }\n+\n+    final bool isNaked() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.naked);\n+    }\n+\n+    final bool isGenerated() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.generated);\n+    }\n+\n+    final void isGenerated(bool v) pure nothrow @safe @nogc\n+    {\n+        if (v) this.flags |= FUNCFLAG.generated;\n+        else this.flags &= ~FUNCFLAG.generated;\n+    }\n+\n+    final bool isIntroducing() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.introducing);\n+    }\n+\n+    final bool hasSemantic3Errors() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.semantic3Errors);\n+    }\n+\n+    final bool hasNoEH() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.noEH);\n+    }\n+\n+    final bool inferRetType() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.inferRetType);\n+    }\n+\n+    final bool hasDualContext() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.dualContext);\n+    }\n+\n+    final bool hasAlwaysInlines() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.hasAlwaysInline);\n+    }\n+\n+    final bool isCrtCtor() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.CRTCtor);\n+    }\n+\n+    final bool isCrtDtor() const scope @safe pure nothrow @nogc\n+    {\n+        return !!(this.flags & FUNCFLAG.CRTDtor);\n+    }\n+\n     /**************************************\n      * The function is doing something that may allocate with the GC,\n      * so mark it as not nogc (not no-how).\n@@ -1809,19 +1852,19 @@ extern (C++) class FuncDeclaration : Declaration\n     {\n         auto ad = isThis();\n         ClassDeclaration cd = ad ? ad.isClassDeclaration() : null;\n-        return (ad && !(cd && cd.isCPPclass()) && global.params.useInvariants == CHECKENABLE.on && (visibility.kind == Visibility.Kind.protected_ || visibility.kind == Visibility.Kind.public_ || visibility.kind == Visibility.Kind.export_) && !naked);\n+        return (ad && !(cd && cd.isCPPclass()) && global.params.useInvariants == CHECKENABLE.on && (visibility.kind == Visibility.Kind.protected_ || visibility.kind == Visibility.Kind.public_ || visibility.kind == Visibility.Kind.export_) && !this.isNaked());\n     }\n \n     bool addPostInvariant()\n     {\n         auto ad = isThis();\n         ClassDeclaration cd = ad ? ad.isClassDeclaration() : null;\n-        return (ad && !(cd && cd.isCPPclass()) && ad.inv && global.params.useInvariants == CHECKENABLE.on && (visibility.kind == Visibility.Kind.protected_ || visibility.kind == Visibility.Kind.public_ || visibility.kind == Visibility.Kind.export_) && !naked);\n+        return (ad && !(cd && cd.isCPPclass()) && ad.inv && global.params.useInvariants == CHECKENABLE.on && (visibility.kind == Visibility.Kind.protected_ || visibility.kind == Visibility.Kind.public_ || visibility.kind == Visibility.Kind.export_) && !this.isNaked());\n     }\n \n     override const(char)* kind() const\n     {\n-        return generated ? \"generated function\" : \"function\";\n+        return this.isGenerated() ? \"generated function\" : \"function\";\n     }\n \n     /********************************************\n@@ -2163,7 +2206,7 @@ extern (C++) class FuncDeclaration : Declaration\n             vresult.parent = this;\n         }\n \n-        if (sc && vresult.semanticRun == PASS.init)\n+        if (sc && vresult.semanticRun == PASS.initial)\n         {\n             TypeFunction tf = type.toTypeFunction();\n             if (tf.isref)\n@@ -2609,35 +2652,124 @@ extern (C++) class FuncDeclaration : Declaration\n         return fd;\n     }\n \n-    /******************\n-     * Check parameters and return type of D main() function.\n-     * Issue error messages.\n-     */\n-    extern (D) final void checkDmain()\n-    {\n+    /+\n+     + Checks the parameter and return types iff this is a `main` function.\n+     +\n+     + The following signatures are allowed for a `D main`:\n+     + - Either no or a single parameter of type `string[]`\n+     + - Return type is either `void`, `int` or `noreturn`\n+     +\n+     + The following signatures are standard C:\n+     + - `int main()`\n+     + - `int main(int, char**)`\n+     +\n+     + This function accepts the following non-standard extensions:\n+     + - `char** envp` as a third parameter\n+     + - `void` / `noreturn` as return type\n+     +\n+     + This function will issue errors for unexpected arguments / return types.\n+     +/\n+    extern (D) final void checkMain()\n+    {\n+        if (ident != Id.main || isMember() || isNested())\n+            return; // Not a main function\n+\n         TypeFunction tf = type.toTypeFunction();\n+\n+        Type retType = tf.nextOf();\n+        if (!retType)\n+        {\n+            // auto main(), check after semantic\n+            assert(this.inferRetType);\n+            return;\n+        }\n+\n+        /// Checks whether `t` is equivalent to `char**`\n+        /// Ignores qualifiers and treats enums according to their base type\n+        static bool isCharPtrPtr(Type t)\n+        {\n+            auto tp = t.toBasetype().isTypePointer();\n+            if (!tp)\n+                return false;\n+\n+            tp = tp.next.toBasetype().isTypePointer();\n+            if (!tp)\n+                return false;\n+\n+            return tp.next.toBasetype().ty == Tchar;\n+        }\n+\n+        // Neither of these qualifiers is allowed because they affect the ABI\n+        enum invalidSTC = STC.out_ | STC.ref_ | STC.lazy_;\n+\n         const nparams = tf.parameterList.length;\n         bool argerr;\n-        if (nparams == 1)\n+\n+        if (linkage == LINK.d)\n         {\n-            auto fparam0 = tf.parameterList[0];\n-            auto t = fparam0.type.toBasetype();\n-            if (t.ty != Tarray ||\n-                t.nextOf().ty != Tarray ||\n-                t.nextOf().nextOf().ty != Tchar ||\n-                fparam0.storageClass & (STC.out_ | STC.ref_ | STC.lazy_))\n+            if (nparams == 1)\n             {\n-                argerr = true;\n+                auto fparam0 = tf.parameterList[0];\n+                auto t = fparam0.type.toBasetype();\n+                if (t.ty != Tarray ||\n+                    t.nextOf().ty != Tarray ||\n+                    t.nextOf().nextOf().ty != Tchar ||\n+                    fparam0.storageClass & invalidSTC)\n+                {\n+                    argerr = true;\n+                }\n             }\n+\n+            if (tf.parameterList.varargs || nparams >= 2 || argerr)\n+                error(\"parameter list must be empty or accept one parameter of type `string[]`\");\n         }\n \n-        if (!tf.nextOf())\n-            // auto main(), check after semantic\n-            assert(this.inferRetType);\n-        else if (tf.nextOf().ty != Tint32 && tf.nextOf().ty != Tvoid && tf.nextOf().ty != Tnoreturn)\n+        else if (linkage == LINK.c)\n+        {\n+            if (nparams == 2 || nparams == 3)\n+            {\n+                // Argument count must be int\n+                auto argCount = tf.parameterList[0];\n+                argerr |= !!(argCount.storageClass & invalidSTC);\n+                argerr |= argCount.type.toBasetype().ty != Tint32;\n+\n+                // Argument pointer must be char**\n+                auto argPtr = tf.parameterList[1];\n+                argerr |= !!(argPtr.storageClass & invalidSTC);\n+                argerr |= !isCharPtrPtr(argPtr.type);\n+\n+                // `char** environ` is a common extension, see J.5.1 of the C standard\n+                if (nparams == 3)\n+                {\n+                    auto envPtr = tf.parameterList[2];\n+                    argerr |= !!(envPtr.storageClass & invalidSTC);\n+                    argerr |= !isCharPtrPtr(envPtr.type);\n+                }\n+            }\n+            else\n+                argerr = nparams != 0;\n+\n+            // Disallow variadic main() - except for K&R declarations in C files.\n+            // E.g. int main(), int main(argc, argv) int argc, char** argc { ... }\n+            if (tf.parameterList.varargs && (!this.isCsymbol() || (!tf.parameterList.hasIdentifierList && nparams)))\n+                argerr |= true;\n+\n+            if (argerr)\n+            {\n+                error(\"parameters must match one of the following signatures\");\n+                loc.errorSupplemental(\"`main()`\");\n+                loc.errorSupplemental(\"`main(int argc, char** argv)`\");\n+                loc.errorSupplemental(\"`main(int argc, char** argv, char** environ)` [POSIX extension]\");\n+            }\n+        }\n+        else\n+            return; // Neither C nor D main, ignore (should probably be an error)\n+\n+        // Allow enums with appropriate base types (same ABI)\n+        retType = retType.toBasetype();\n+\n+        if (retType.ty != Tint32 && retType.ty != Tvoid && retType.ty != Tnoreturn)\n             error(\"must return `int`, `void` or `noreturn`, not `%s`\", tf.nextOf().toChars());\n-        else if (tf.parameterList.varargs || nparams >= 2 || argerr)\n-            error(\"parameters must be `main()` or `main(string[] args)`\");\n     }\n \n     /***********************************************\n@@ -2649,7 +2781,7 @@ extern (C++) class FuncDeclaration : Declaration\n      */\n     final bool checkNRVO()\n     {\n-        if (!nrvo_can || returns is null)\n+        if (!isNRVO() || returns is null)\n             return false;\n \n         auto tf = type.toTypeFunction();\n@@ -2661,14 +2793,16 @@ extern (C++) class FuncDeclaration : Declaration\n             if (auto ve = rs.exp.isVarExp())\n             {\n                 auto v = ve.var.isVarDeclaration();\n-                if (!v || v.isOut() || v.isRef())\n+                if (!v || v.isReference())\n                     return false;\n                 else if (nrvo_var is null)\n                 {\n                     // Variables in the data segment (e.g. globals, TLS or not),\n                     // parameters and closure variables cannot be NRVOed.\n                     if (v.isDataseg() || v.isParameter() || v.toParent2() != this)\n                         return false;\n+                    if (v.nestedrefs.length && needsClosure())\n+                        return false;\n                     // The variable type needs to be equivalent to the return type.\n                     if (!v.type.equivalent(tf.next))\n                         return false;"}, {"sha": "6b6655c2ea226b6e6381466a8471ad1a9f758cb2", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -15,6 +15,7 @@ import core.stdc.stdint;\n import dmd.root.array;\n import dmd.root.filename;\n import dmd.common.outbuffer;\n+import dmd.file_manager;\n import dmd.identifier;\n \n /// Defines a setting for how compiler warnings and deprecations are handled\n@@ -329,6 +330,9 @@ extern (C++) struct Global\n     bool hasMainFunction; /// Whether a main function has already been compiled in (for -main switch)\n     uint varSequenceNumber = 1; /// Relative lifetime of `VarDeclaration` within a function, used for `scope` checks\n \n+    /// Cache files read from disk\n+    FileManager fileManager;\n+\n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n   nothrow:\n@@ -383,6 +387,7 @@ extern (C++) struct Global\n \n     extern (C++) void _init()\n     {\n+        this.fileManager = new FileManager();\n         version (MARS)\n         {\n             vendor = \"Digital Mars D\";"}, {"sha": "2a33692380ebcd9639b156903c3f2d0641b2857f", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,6 +19,8 @@\n // Can't include arraytypes.h here, need to declare these directly.\n template <typename TYPE> struct Array;\n \n+class FileManager;\n+\n typedef unsigned char Diagnostic;\n enum\n {\n@@ -292,6 +294,8 @@ struct Global\n     bool hasMainFunction;\n     unsigned varSequenceNumber;\n \n+    FileManager* fileManager;\n+\n     /* Start gagging. Return the current number of gagged errors\n      */\n     unsigned startGagging();"}, {"sha": "a3afbe50796a02caf14bc26dd11e33dcc7dd7537", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1836,25 +1836,12 @@ public:\n                     t = te.sym.memtype;\n                     goto L1;\n                 }\n+            case Tchar:\n             case Twchar:\n-                // BUG: need to cast(wchar)\n             case Tdchar:\n-                // BUG: need to cast(dchar)\n-                if (cast(uinteger_t)v > 0xFF)\n-                {\n-                    buf.printf(\"'\\\\U%08llx'\", cast(long)v);\n-                    break;\n-                }\n-                goto case;\n-            case Tchar:\n                 {\n-                    size_t o = buf.length;\n-                    if (v == '\\'')\n-                        buf.writestring(\"'\\\\''\");\n-                    else if (isprint(cast(int)v) && v != '\\\\')\n-                        buf.printf(\"'%c'\", cast(int)v);\n-                    else\n-                        buf.printf(\"'\\\\x%02x'\", cast(int)v);\n+                    const o = buf.length;\n+                    writeSingleCharLiteral(*buf, cast(dchar) v);\n                     if (hgs.ddoc)\n                         escapeDdocString(buf, o);\n                     break;\n@@ -2761,9 +2748,15 @@ bool stcToBuffer(OutBuffer* buf, StorageClass stc)\n     bool result = false;\n \n     if (stc & STC.scopeinferred)\n+    {\n+        //buf.writestring(\"scope-inferred \");\n         stc &= ~(STC.scope_ | STC.scopeinferred);\n+    }\n     if (stc & STC.returninferred)\n+    {\n+        //buf.writestring(\"return-inferred \");\n         stc &= ~(STC.return_ | STC.returninferred);\n+    }\n \n     /* Put scope ref return into a standard order\n      */"}, {"sha": "bcfbd9a122cca035ed79f645e1e8111ec2b31d77", "filename": "gcc/d/dmd/importc.d", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fimportc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fimportc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimportc.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -285,7 +285,7 @@ bool cFuncEquivalence(TypeFunction tf1, TypeFunction tf2)\n     if (tf1.parameterList.length == 0 && tf2.parameterList.length == 0)\n         return true;\n \n-    if (!tf1.nextOf().equals(tf2.nextOf()))\n+    if (!cTypeEquivalence(tf1.next, tf2.next))\n         return false;   // function return types don't match\n \n     if (tf1.parameterList.length != tf2.parameterList.length)\n@@ -318,3 +318,40 @@ bool cFuncEquivalence(TypeFunction tf1, TypeFunction tf2)\n     //printf(\"t2: %s\\n\", tf2.toChars());\n     return true;\n }\n+\n+/*******************************\n+ * Types haven't been merged yet, because we haven't done\n+ * semantic() yet.\n+ * But we still need to see if t1 and t2 are the same type.\n+ * Params:\n+ *      t1 = first type\n+ *      t2 = second type\n+ * Returns:\n+ *      true if they are equivalent types\n+ */\n+bool cTypeEquivalence(Type t1, Type t2)\n+{\n+    if (t1.equals(t2))\n+        return true;    // that was easy\n+\n+    if (t1.ty != t2.ty || t1.mod != t2.mod)\n+        return false;\n+\n+    if (auto tp = t1.isTypePointer())\n+        return cTypeEquivalence(tp.next, t2.nextOf());\n+\n+    if (auto ta = t1.isTypeSArray())\n+        // Bug: should check array dimension\n+        return cTypeEquivalence(ta.next, t2.nextOf());\n+\n+    if (auto ts = t1.isTypeStruct())\n+        return ts.sym is t2.isTypeStruct().sym;\n+\n+    if (auto te = t1.isTypeEnum())\n+        return te.sym is t2.isTypeEnum().sym;\n+\n+    if (auto tf = t1.isTypeFunction())\n+        return cFuncEquivalence(tf, tf.isTypeFunction());\n+\n+    return false;\n+}"}, {"sha": "73dc4bba2e4f414cf6e6059333fc19179a588eda", "filename": "gcc/d/dmd/init.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Finit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Finit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -114,4 +114,4 @@ class CInitializer : public Initializer\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n-Expression *initializerToExpression(Initializer *init, Type *t = NULL);\n+Expression *initializerToExpression(Initializer *init, Type *t = NULL, const bool isCfile = false);"}, {"sha": "649d88e3d592d75a9cc5f704b84f1fff48fc2d97", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1080,10 +1080,11 @@ Initializer inferType(Initializer init, Scope* sc)\n  * Params:\n  *      init = `Initializer` AST node\n  *      itype = if not `null`, type to coerce expression to\n+ *      isCfile = default initializers are different with C\n  * Returns:\n  *      `Expression` created, `null` if cannot, `ErrorExp` for other errors\n  */\n-extern (C++) Expression initializerToExpression(Initializer init, Type itype = null)\n+extern (C++) Expression initializerToExpression(Initializer init, Type itype = null, const bool isCfile = false)\n {\n     Expression visitVoid(VoidInitializer)\n     {\n@@ -1204,7 +1205,7 @@ extern (C++) Expression initializerToExpression(Initializer init, Type itype = n\n                 if (!init.type) // don't know what type to use\n                     return null;\n                 if (!defaultInit)\n-                    defaultInit = (cast(TypeNext)t).next.defaultInit(Loc.initial);\n+                    defaultInit = (cast(TypeNext)t).next.defaultInit(Loc.initial, isCfile);\n                 element = defaultInit;\n             }\n         }"}, {"sha": "7cd4bfd59227247b8c1fd61134d9f9ff204413ef", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 69, "deletions": 86, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -77,6 +77,7 @@ class Lexer\n         bool doDocComment;      // collect doc comment information\n         bool anyToken;          // seen at least one token\n         bool commentToken;      // comments are TOK.comment's\n+        bool tokenizeNewlines;  // newlines are turned into TOK.endOfLine's\n \n         version (DMDLIB)\n         {\n@@ -116,6 +117,7 @@ class Lexer\n         line = p;\n         this.doDocComment = doDocComment;\n         this.commentToken = commentToken;\n+        this.tokenizeNewlines = false;\n         this.inTokenStringConstant = 0;\n         this.lastDocLine = 0;\n         //initKeywords();\n@@ -227,6 +229,8 @@ class Lexer\n \n     /****************************\n      * Turn next token in buffer into a token.\n+     * Params:\n+     *  t = the token to set the resulting Token to\n      */\n     final void scan(Token* t)\n     {\n@@ -286,7 +290,15 @@ class Lexer\n             case '\\r':\n                 p++;\n                 if (*p != '\\n') // if CR stands by itself\n+                {\n                     endOfLine();\n+                    if (tokenizeNewlines)\n+                    {\n+                        t.value = TOK.endOfLine;\n+                        tokenizeNewlines = false;\n+                        return;\n+                    }\n+                }\n                 version (DMDLIB)\n                 {\n                     if (whitespaceToken)\n@@ -299,6 +311,12 @@ class Lexer\n             case '\\n':\n                 p++;\n                 endOfLine();\n+                if (tokenizeNewlines)\n+                {\n+                    t.value = TOK.endOfLine;\n+                    tokenizeNewlines = false;\n+                    return;\n+                }\n                 version (DMDLIB)\n                 {\n                     if (whitespaceToken)\n@@ -1045,6 +1063,10 @@ class Lexer\n                 return;\n             case '#':\n                 {\n+                    // https://issues.dlang.org/show_bug.cgi?id=22825\n+                    // Special token sequences are terminated by newlines,\n+                    // and should not be skipped over.\n+                    this.tokenizeNewlines = true;\n                     p++;\n                     if (parseSpecialTokenSequence())\n                         continue;\n@@ -1064,6 +1086,12 @@ class Lexer\n                         {\n                             endOfLine();\n                             p++;\n+                            if (tokenizeNewlines)\n+                            {\n+                                t.value = TOK.endOfLine;\n+                                tokenizeNewlines = false;\n+                                return;\n+                            }\n                             continue;\n                         }\n                     }\n@@ -2607,126 +2635,80 @@ class Lexer\n     {\n         auto linnum = this.scanloc.linnum;\n         const(char)* filespec = null;\n-        const loc = this.loc();\n         bool flags;\n \n         if (!linemarker)\n             scan(&tok);\n         if (tok.value == TOK.int32Literal || tok.value == TOK.int64Literal)\n         {\n-            const lin = cast(int)(tok.unsvalue - 1);\n-            if (lin != tok.unsvalue - 1)\n-                error(\"line number `%lld` out of range\", cast(ulong)tok.unsvalue);\n+            const lin = cast(int)(tok.unsvalue);\n+            if (lin != tok.unsvalue)\n+            {\n+                error(tok.loc, \"line number `%lld` out of range\", cast(ulong)tok.unsvalue);\n+                skipToNextLine();\n+                return;\n+            }\n             else\n                 linnum = lin;\n         }\n         else if (tok.value == TOK.line)  // #line __LINE__\n         {\n         }\n         else\n-            goto Lerr;\n+        {\n+            error(tok.loc, \"positive integer argument expected following `#line`\");\n+            if (tok.value != TOK.endOfLine)\n+                skipToNextLine();\n+            return;\n+        }\n         while (1)\n         {\n-            switch (*p)\n+            scan(&tok);\n+            switch (tok.value)\n             {\n-            case 0:\n-            case 0x1A:\n-            case '\\n':\n-            Lnewline:\n+            case TOK.endOfFile:\n+            case TOK.endOfLine:\n                 if (!inTokenStringConstant)\n                 {\n                     this.scanloc.linnum = linnum;\n                     if (filespec)\n                         this.scanloc.filename = filespec;\n                 }\n                 return;\n-            case '\\r':\n-                p++;\n-                if (*p != '\\n')\n-                {\n-                    p--;\n-                    goto Lnewline;\n-                }\n-                continue;\n-            case ' ':\n-            case '\\t':\n-            case '\\v':\n-            case '\\f':\n-                p++;\n-                continue; // skip white space\n-            case '_':\n+            case TOK.file:\n                 if (filespec || flags)\n                     goto Lerr;\n-                if (memcmp(p, \"__FILE__\".ptr, 8) == 0)\n-                {\n-                    p += 8;\n-                    filespec = mem.xstrdup(scanloc.filename);\n-                    continue;\n-                }\n-                goto Lerr;\n-            case '\"':\n+                filespec = mem.xstrdup(scanloc.filename);\n+                continue;\n+            case TOK.string_:\n                 if (filespec || flags)\n                     goto Lerr;\n-                stringbuffer.setsize(0);\n-                p++;\n-                while (1)\n-                {\n-                    uint c;\n-                    c = *p;\n-                    switch (c)\n-                    {\n-                    case '\\n':\n-                    case '\\r':\n-                    case 0:\n-                    case 0x1A:\n-                        goto Lerr;\n-                    case '\"':\n-                        stringbuffer.writeByte(0);\n-                        filespec = mem.xstrdup(cast(const(char)*)stringbuffer[].ptr);\n-                        p++;\n-                        break;\n-                    default:\n-                        if (c & 0x80)\n-                        {\n-                            uint u = decodeUTF();\n-                            if (u == PS || u == LS)\n-                                goto Lerr;\n-                        }\n-                        stringbuffer.writeByte(c);\n-                        p++;\n-                        continue;\n-                    }\n-                    break;\n-                }\n-                continue;\n-\n-            case '1':\n-            case '2':\n-            case '3':\n-            case '4':\n-                if (!linemarker)\n+                if (tok.ptr[0] != '\"' || tok.postfix != 0)\n                     goto Lerr;\n-                flags = true;   // linemarker flags seen\n-                ++p;\n-                if ('0' <= *p && *p <= '9')\n-                    goto Lerr;  // only one digit allowed\n+                filespec = tok.ustring;\n                 continue;\n-\n-            default:\n-                if (*p & 0x80)\n+            case TOK.int32Literal:\n+                if (!filespec)\n+                    goto Lerr;\n+                if (linemarker && tok.unsvalue >= 1 && tok.unsvalue <= 4)\n                 {\n-                    uint u = decodeUTF();\n-                    if (u == PS || u == LS)\n-                        goto Lnewline;\n+                    flags = true;   // linemarker flags seen\n+                    continue;\n                 }\n                 goto Lerr;\n+            default:\n+                goto Lerr;\n             }\n         }\n     Lerr:\n-        if (linemarker)\n-            error(loc, \"# integer [\\\"filespec\\\"] { 1 | 2 | 3 | 4 }\\\\n expected\");\n-        else\n-            error(loc, \"#line integer [\\\"filespec\\\"]\\\\n expected\");\n+        if (filespec is null)\n+            error(tok.loc, \"invalid filename for `#line` directive\");\n+        else if (linemarker)\n+            error(tok.loc, \"invalid flag for line marker directive\");\n+        else if (!Ccompile)\n+            error(tok.loc, \"found `%s` when expecting new line following `#line` directive\", tok.toChars());\n+        if (tok.value != TOK.endOfLine)\n+            skipToNextLine();\n     }\n \n     /***************************************\n@@ -2768,6 +2750,7 @@ class Lexer\n             break;\n         }\n         endOfLine();\n+        tokenizeNewlines = false;\n     }\n \n     /********************************************\n@@ -3004,7 +2987,7 @@ private struct TimeStampInfo\n         if (auto p = getenv(\"SOURCE_DATE_EPOCH\"))\n         {\n             if (!ct.parseDigits(p.toDString()))\n-                error(loc, \"Value of environment variable `SOURCE_DATE_EPOCH` should be a valid UNIX timestamp, not: `%s`\", p);\n+                error(loc, \"value of environment variable `SOURCE_DATE_EPOCH` should be a valid UNIX timestamp, not: `%s`\", p);\n         }\n         else\n             .time(&ct);"}, {"sha": "b2c7aa461ca5948acfb079a15e9c5e80b76e1f48", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 36, "deletions": 174, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -4198,6 +4198,8 @@ extern (C++) final class TypeFunction : TypeNext\n \n     ParameterList parameterList;   // function parameters\n \n+    // These flags can be accessed like `bool` properties,\n+    // getters and setters are generated for them\n     private enum FunctionFlag : uint\n     {\n         none            = 0,\n@@ -4206,13 +4208,13 @@ extern (C++) final class TypeFunction : TypeNext\n         isproperty      = 0x0004, // can be called without parentheses\n         isref           = 0x0008, // returns a reference\n         isreturn        = 0x0010, // 'this' is returned by ref\n-        isscope         = 0x0020, // 'this' is scope\n+        isScopeQual     = 0x0020, // 'this' is scope\n         isreturninferred= 0x0040, // 'this' is return from inference\n         isscopeinferred = 0x0080, // 'this' is scope from inference\n         islive          = 0x0100, // is @live\n         incomplete      = 0x0200, // return type or default arguments removed\n-        inoutParam      = 0x0400, // inout on the parameters\n-        inoutQual       = 0x0800, // inout on the qualifier\n+        isInOutParam    = 0x0400, // inout on the parameters\n+        isInOutQual     = 0x0800, // inout on the qualifier\n         isctor          = 0x1000, // the function is a constructor\n         isreturnscope   = 0x2000, // `this` is returned by value\n     }\n@@ -4480,7 +4482,7 @@ extern (C++) final class TypeFunction : TypeNext\n         {\n             // Check escaping through return value\n             Type tret = nextOf().toBasetype();\n-            if (isref || tret.hasPointers())\n+            if (isref || tret.hasPointers() || !isnothrow())\n             {\n                 return stc;\n             }\n@@ -5084,177 +5086,29 @@ extern (C++) final class TypeFunction : TypeNext\n         return false;\n     }\n \n-    /// set or get if the function has the `nothrow` attribute\n-    bool isnothrow() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isnothrow) != 0;\n-    }\n-    /// ditto\n-    void isnothrow(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isnothrow;\n-        else funcFlags &= ~FunctionFlag.isnothrow;\n-    }\n-\n-    /// set or get if the function has the `@nogc` attribute\n-    bool isnogc() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isnogc) != 0;\n-    }\n-    /// ditto\n-    void isnogc(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isnogc;\n-        else funcFlags &= ~FunctionFlag.isnogc;\n-    }\n-\n-    /// set or get if the function has the `@property` attribute\n-    bool isproperty() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isproperty) != 0;\n-    }\n-    /// ditto\n-    void isproperty(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isproperty;\n-        else funcFlags &= ~FunctionFlag.isproperty;\n-    }\n-\n-    /// set or get if the function has the `ref` attribute\n-    bool isref() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isref) != 0;\n-    }\n-    /// ditto\n-    void isref(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isref;\n-        else funcFlags &= ~FunctionFlag.isref;\n-    }\n-\n-    /// set or get if the function has the `return` attribute\n-    bool isreturn() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isreturn) != 0;\n-    }\n-    /// ditto\n-    void isreturn(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isreturn;\n-        else funcFlags &= ~FunctionFlag.isreturn;\n-    }\n-\n-    /// set or get if the function has the `returnscope` attribute\n-    bool isreturnscope() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isreturnscope) != 0;\n-    }\n-    /// ditto\n-    void isreturnscope(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isreturnscope;\n-        else funcFlags &= ~FunctionFlag.isreturnscope;\n-    }\n-\n-    /// set or get if the function has the `scope` attribute\n-    bool isScopeQual() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isscope) != 0;\n-    }\n-    /// ditto\n-    void isScopeQual(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isscope;\n-        else funcFlags &= ~FunctionFlag.isscope;\n-    }\n-\n-    /// set or get if the function has the `return` attribute inferred\n-    bool isreturninferred() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isreturninferred) != 0;\n-    }\n-    /// ditto\n-    void isreturninferred(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isreturninferred;\n-        else funcFlags &= ~FunctionFlag.isreturninferred;\n-    }\n-\n-    /// set or get if the function has the `scope` attribute inferred\n-    bool isscopeinferred() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isscopeinferred) != 0;\n-    }\n-    /// ditoo\n-    void isscopeinferred(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isscopeinferred;\n-        else funcFlags &= ~FunctionFlag.isscopeinferred;\n-    }\n-\n-    /// set or get if the function has the `@live` attribute\n-    bool islive() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.islive) != 0;\n-    }\n-    /// ditto\n-    void islive(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.islive;\n-        else funcFlags &= ~FunctionFlag.islive;\n-    }\n-\n-    /// set or get if the return type or the default arguments are removed\n-    bool incomplete() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.incomplete) != 0;\n-    }\n-    /// ditto\n-    void incomplete(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.incomplete;\n-        else funcFlags &= ~FunctionFlag.incomplete;\n-    }\n-\n-    /// set or get if the function has the `inout` on the parameters\n-    bool isInOutParam() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.inoutParam) != 0;\n-    }\n-    /// ditto\n-    void isInOutParam(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.inoutParam;\n-        else funcFlags &= ~FunctionFlag.inoutParam;\n-    }\n+    // Generate getter / setter functions for `FunctionFlag` members so they can be\n+    // treated like regular `bool` fields, instead of requiring bit twiddling to read/write\n+    extern (D) mixin(() {\n+        string result = \"extern(C++) pure nothrow @safe @nogc {\";\n+        foreach (string mem; __traits(allMembers, FunctionFlag))\n+        {\n+            result ~= \"\n+            /// set or get if the function has the FunctionFlag attribute of the same name\n+            bool \"~mem~\"() const { return (funcFlags & FunctionFlag.\"~mem~\") != 0; }\n+            /// ditto\n+            void \"~mem~\"(bool v)\n+            {\n+                if (v) funcFlags |= FunctionFlag.\"~mem~\";\n+                else funcFlags &= ~FunctionFlag.\"~mem~\";\n+            }\";\n+        }\n+        return result ~ \"}\\n\";\n+    }());\n \n-    /// set or get if the function has the `inout` on the parameters\n-    bool isInOutQual() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.inoutQual) != 0;\n-    }\n-    /// ditto\n-    void isInOutQual(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.inoutQual;\n-        else funcFlags &= ~FunctionFlag.inoutQual;\n-    }\n     /// Returns: `true` the function is `isInOutQual` or `isInOutParam` ,`false` otherwise.\n     bool iswild() const pure nothrow @safe @nogc\n     {\n-        return (funcFlags & (FunctionFlag.inoutParam | FunctionFlag.inoutQual)) != 0;\n-    }\n-\n-    /// set or get if the function is a constructor\n-    bool isctor() const pure nothrow @safe @nogc\n-    {\n-        return (funcFlags & FunctionFlag.isctor) != 0;\n-    }\n-    /// ditto\n-    void isctor(bool v) pure nothrow @safe @nogc\n-    {\n-        if (v) funcFlags |= FunctionFlag.isctor;\n-        else funcFlags &= ~FunctionFlag.isctor;\n+        return (funcFlags & (FunctionFlag.isInOutParam | FunctionFlag.isInOutQual)) != 0;\n     }\n \n     /// Returns: whether `this` function type has the same attributes (`@safe`,...) as `other`\n@@ -6418,9 +6272,6 @@ extern (C++) final class TypeClass : Type\n \n     override MOD deduceWild(Type t, bool isRef)\n     {\n-        // If sym is forward referenced:\n-        if (sym.semanticRun < PASS.semanticdone && !sym.isBaseInfoComplete())\n-            sym.dsymbolSemantic(null);\n         ClassDeclaration cd = t.isClassHandle();\n         if (cd && (sym == cd || cd.isBaseOf(sym, null)))\n             return Type.deduceWild(t, isRef);\n@@ -7176,6 +7027,17 @@ extern (C++) final class Parameter : ASTNode\n \n     extern (D) private static bool isCovariantScope(bool returnByRef, StorageClass from, StorageClass to) pure nothrow @nogc @safe\n     {\n+        // Workaround for failing covariance when finding a common type of delegates,\n+        // some of which have parameters with inferred scope\n+        // https://issues.dlang.org/show_bug.cgi?id=21285\n+        // The root cause is that scopeinferred is not part of the mangle, and mangle\n+        // is used for type equality checks\n+        if (to & STC.returninferred)\n+            to &= ~STC.return_;\n+        // note: f(return int* x) currently 'infers' scope without inferring `return`, in that case keep STC.scope\n+        if (to & STC.scopeinferred && !(to & STC.return_))\n+            to &= ~STC.scope_;\n+\n         if (from == to)\n             return true;\n "}, {"sha": "2957b3abfab3b73ee11901af3e869aef14aa37da", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -137,9 +137,9 @@ public:\n \n     override void visit(DeleteExp e)\n     {\n-        if (e.e1.op == EXP.variable)\n+        if (VarExp ve = e.e1.isVarExp())\n         {\n-            VarDeclaration v = (cast(VarExp)e.e1).var.isVarDeclaration();\n+            VarDeclaration v = ve.var.isVarDeclaration();\n             if (v && v.onstack)\n                 return; // delete for scope allocated class object\n         }"}, {"sha": "121a266b4283ebb64206acc53ba4dd378809142a", "filename": "gcc/d/dmd/ob.d", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fob.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fob.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fob.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1747,7 +1747,7 @@ PtrState toPtrState(VarDeclaration v)\n      */\n \n     auto t = v.type;\n-    if (v.isRef())\n+    if (v.isReference())\n     {\n         return t.hasMutableFields() ? PtrState.Borrowed : PtrState.Readonly;\n     }\n@@ -1775,7 +1775,7 @@ bool hasPointersToMutableFields(Type t)\n     {\n         foreach (v; ts.sym.fields)\n         {\n-            if (v.isRef())\n+            if (v.isReference())\n             {\n                 if (v.type.hasMutableFields())\n                     return true;\n@@ -1977,7 +1977,12 @@ void checkObErrors(ref ObState obstate)\n             else if (isReadonlyPtr(v))\n                 pvs.state = PtrState.Readonly;\n             else\n+            {\n+                if (pvs.state == PtrState.Owner && v.type.hasPointersToMutableFields())\n+                    v.error(e.loc, \"assigning to Owner without disposing of owned value\");\n+\n                 pvs.state = PtrState.Owner;\n+            }\n             pvs.deps.zero();\n \n             EscapeByResults er;"}, {"sha": "dbd761fed2f4955ad3c621f578c4a2b6a7f89ad5", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -711,7 +711,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 if (s)\n                 {\n                     functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n-                    if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+                    if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                     {\n                         return ErrorExp.get();\n                     }\n@@ -720,7 +720,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 if (s_r)\n                 {\n                     functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, &args1);\n-                    if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+                    if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                     {\n                         return ErrorExp.get();\n                     }\n@@ -793,7 +793,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         if (s_r)\n                         {\n                             functionResolve(m, s_r, e.loc, sc, tiargs, e.e1.type, &args2);\n-                            if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+                            if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                             {\n                                 return ErrorExp.get();\n                             }\n@@ -802,7 +802,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         if (s)\n                         {\n                             functionResolve(m, s, e.loc, sc, tiargs, e.e2.type, &args1);\n-                            if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+                            if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                             {\n                                 return ErrorExp.get();\n                             }\n@@ -1250,7 +1250,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 if (s)\n                 {\n                     functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n-                    if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+                    if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                     {\n                         return ErrorExp.get();\n                     }\n@@ -1344,15 +1344,15 @@ private Expression compare_overload(BinExp e, Scope* sc, Identifier id, EXP* pop\n         if (s)\n         {\n             functionResolve(m, s, e.loc, sc, tiargs, e.e1.type, &args2);\n-            if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+            if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 return ErrorExp.get();\n         }\n         FuncDeclaration lastf = m.lastf;\n         int count = m.count;\n         if (s_r)\n         {\n             functionResolve(m, s_r, e.loc, sc, tiargs, e.e2.type, &args1);\n-            if (m.lastf && (m.lastf.errors || m.lastf.semantic3Errors))\n+            if (m.lastf && (m.lastf.errors || m.lastf.hasSemantic3Errors()))\n                 return ErrorExp.get();\n         }\n         if (m.count > 1)"}, {"sha": "3745a15da421c5e7305f3da6e2418dad161bcfba", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -504,6 +504,16 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     {\n                         eint = ei;\n                     }\n+                    else if (auto se = ep.e1.isSymOffExp())\n+                    {\n+                        if (!se.var.isReference() &&\n+                            !se.var.isImportedSymbol() &&\n+                            se.var.isDataseg())\n+                        {\n+                            var = se.var.isVarDeclaration();\n+                            offset += se.offset;\n+                        }\n+                    }\n                 }\n                 return false;\n             }\n@@ -531,7 +541,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         if (auto ae = e.e1.isIndexExp())\n         {\n             // Convert &array[n] to &array+n\n-            if (ae.e2.op == EXP.int64 && ae.e1.isVarExp())\n+            if (ae.e2.isIntegerExp() && ae.e1.isVarExp())\n             {\n                 sinteger_t index = ae.e2.toInteger();\n                 VarExp ve = ae.e1.isVarExp();\n@@ -541,8 +551,13 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     sinteger_t dim = ts.dim.toInteger();\n                     if (index < 0 || index >= dim)\n                     {\n-                        e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n-                        return error();\n+                        /* 0 for C static arrays means size is unknown, no need to check\n+                         */\n+                        if (!(dim == 0 && ve.var.isCsymbol()))\n+                        {\n+                            e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n+                            return error();\n+                        }\n                     }\n \n                     import core.checkedint : mulu;\n@@ -559,6 +574,33 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     return;\n                 }\n             }\n+            // Convert &((a.b)[n]) to (&a.b)+n\n+            else if (ae.e2.isIntegerExp() && ae.e1.isDotVarExp())\n+            {\n+                sinteger_t index = ae.e2.toInteger();\n+                DotVarExp ve = ae.e1.isDotVarExp();\n+                if (ve.type.isTypeSArray() && ve.var.isField() && ve.e1.isPtrExp())\n+                {\n+                    TypeSArray ts = ve.type.isTypeSArray();\n+                    sinteger_t dim = ts.dim.toInteger();\n+                    if (index < 0 || index >= dim)\n+                    {\n+                        /* 0 for C static arrays means size is unknown, no need to check\n+                         */\n+                        if (!(dim == 0 && ve.var.isCsymbol()))\n+                        {\n+                            e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n+                            return error();\n+                        }\n+                    }\n+\n+                    auto pe = new AddrExp(e.loc, ve);\n+                    pe.type = e.type;\n+                    ret = new AddExp(e.loc, pe, ae.e2);\n+                    ret.type = e.type;\n+                    return;\n+                }\n+            }\n         }\n     }\n "}, {"sha": "7b1b63cba824100d203517568a9456122dacd4c1", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3651,7 +3651,7 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n \n         case TOK.traits:\n             if (AST.TraitsExp te = cast(AST.TraitsExp) parsePrimaryExp())\n-                if (te.ident && te.args)\n+                if (te.ident)\n                 {\n                     t = new AST.TypeTraits(token.loc, te);\n                     break;"}, {"sha": "bba34814472f826e353c9595059123af6ba9b0d4", "filename": "gcc/d/dmd/printast.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fprintast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fprintast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fprintast.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -209,5 +209,3 @@ extern (C++) final class PrintASTVisitor : Visitor\n             putc(' ', stdout);\n     }\n }\n-\n-"}, {"sha": "ba5d3312d8a5dccf2ff24340db8d2b8a9d46e33f", "filename": "gcc/d/dmd/root/aav.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,7 +20,7 @@ private size_t hash(size_t a) pure nothrow @nogc @safe\n     return a ^ (a >> 7) ^ (a >> 4);\n }\n \n-struct KeyValueTemplate(K,V)\n+private struct KeyValueTemplate(K,V)\n {\n     K key;\n     V value;\n@@ -31,15 +31,17 @@ alias Value = void*;\n \n alias KeyValue = KeyValueTemplate!(Key, Value);\n \n-struct aaA\n+private struct aaA\n {\n+private:\n     aaA* next;\n     KeyValue keyValue;\n     alias keyValue this;\n }\n \n-struct AA\n+private struct AA\n {\n+private:\n     aaA** b;\n     size_t b_length;\n     size_t nodes; // total number of aaA nodes"}, {"sha": "52bed5e9d7f6d8c7442c9bf37e2630af065529f8", "filename": "gcc/d/dmd/root/array.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -205,4 +205,3 @@ struct Array\n         return data.ptr[--length];\n     }\n };\n-"}, {"sha": "90cbaed49815b80bbbc1839d1be71c414081cbc7", "filename": "gcc/d/dmd/root/bitarray.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fbitarray.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -187,6 +187,3 @@ nothrow pure unittest\n     a = b;\n     assert(a == b);\n }\n-\n-\n-"}, {"sha": "a01cfdc2aacef4b42b0de4a289970e6eab5e1313", "filename": "gcc/d/dmd/root/file.d", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -45,11 +45,6 @@ struct FileBuffer\n         data = null;\n         return result;\n     }\n-\n-    extern (C++) static FileBuffer* create() pure nothrow @safe\n-    {\n-        return new FileBuffer();\n-    }\n }\n \n ///\n@@ -78,12 +73,6 @@ struct File\n \n nothrow:\n     /// Read the full content of a file.\n-    extern (C++) static ReadResult read(const(char)* name)\n-    {\n-        return read(name.toDString());\n-    }\n-\n-    /// Ditto\n     static ReadResult read(const(char)[] name)\n     {\n         ReadResult result;\n@@ -179,24 +168,18 @@ nothrow:\n     }\n \n     /// Write a file, returning `true` on success.\n-    extern (D) static bool write(const(char)* name, const void[] data)\n+    static bool write(const(char)* name, const void[] data)\n     {\n         import dmd.common.file : writeFile;\n         return writeFile(name, data);\n     }\n \n     ///ditto\n-    extern(D) static bool write(const(char)[] name, const void[] data)\n+    static bool write(const(char)[] name, const void[] data)\n     {\n         return name.toCStringThen!((fname) => write(fname.ptr, data));\n     }\n \n-    /// ditto\n-    extern (C++) static bool write(const(char)* name, const(void)* data, size_t size)\n-    {\n-        return write(name, data[0 .. size]);\n-    }\n-\n     /// Delete a file.\n     extern (C++) static void remove(const(char)* name)\n     {\n@@ -229,7 +212,7 @@ nothrow:\n      * Returns:\n      *  `true` on success\n      */\n-    extern (D) static bool update(const(char)* namez, const void[] data)\n+    static bool update(const(char)* namez, const void[] data)\n     {\n         enum log = false;\n         if (log) printf(\"update %s\\n\", namez);\n@@ -252,17 +235,11 @@ nothrow:\n     }\n \n     ///ditto\n-    extern(D) static bool update(const(char)[] name, const void[] data)\n+    static bool update(const(char)[] name, const void[] data)\n     {\n         return name.toCStringThen!(fname => update(fname.ptr, data));\n     }\n \n-    /// ditto\n-    extern (C++) static bool update(const(char)* name, const(void)* data, size_t size)\n-    {\n-        return update(name, data[0 .. size]);\n-    }\n-\n     /// Size of a file in bytes.\n     /// Params: namez = null-terminated filename\n     /// Returns: `ulong.max` on any error, the length otherwise."}, {"sha": "20316faeccf8280e2fa9f4ad0dd9c37eac25d052", "filename": "gcc/d/dmd/root/stringtable.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstringtable.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -224,7 +224,7 @@ public:\n     }\n \n     /// ditto\n-    extern(D) int opApply(scope int delegate(const(StringValue!T)*) nothrow dg) nothrow\n+    int opApply(scope int delegate(const(StringValue!T)*) nothrow dg) nothrow\n     {\n         foreach (const se; table)\n         {"}, {"sha": "26fba8f3864e44b0b51491cafa0c156a23ab80f7", "filename": "gcc/d/dmd/sapply.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fsapply.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fsapply.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsapply.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -177,4 +177,3 @@ public:\n         doCond(s.statement) || applyTo(s);\n     }\n }\n-"}, {"sha": "511957649f7fe7f507a4abbccbe06c540b7ae4e9", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -275,7 +275,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     // Disable generated opAssign, because some members forbid identity assignment.\n                     funcdecl.storage_class |= STC.disable;\n                     funcdecl.fbody = null;   // remove fbody which contains the error\n-                    funcdecl.semantic3Errors = false;\n+                    funcdecl.flags &= ~FUNCFLAG.semantic3Errors;\n                 }\n                 return;\n             }\n@@ -285,7 +285,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         if (funcdecl.semanticRun >= PASS.semantic3)\n             return;\n         funcdecl.semanticRun = PASS.semantic3;\n-        funcdecl.semantic3Errors = false;\n+        funcdecl.flags &= ~FUNCFLAG.semantic3Errors;\n \n         if (!funcdecl.type || funcdecl.type.ty != Tfunction)\n             return;\n@@ -386,7 +386,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             // functions may be widely used by dmd-compiled projects.\n             // It also gives more time for the implementation of dual-context\n             // functions to be reworked as a frontend-only feature.\n-            if (funcdecl.isThis2)\n+            if (funcdecl.hasDualContext())\n             {\n                 funcdecl.deprecation(\"function requires a dual-context, which is deprecated\");\n                 if (auto ti = sc2.parent ? sc2.parent.isInstantiated() : null)\n@@ -603,7 +603,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 if (!funcdecl.fbody)\n                     funcdecl.fbody = new CompoundStatement(Loc.initial, new Statements());\n \n-                if (funcdecl.naked)\n+                if (funcdecl.isNaked())\n                 {\n                     fpreinv = null;         // can't accommodate with no stack frame\n                     fpostinv = null;\n@@ -619,8 +619,8 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                         f.next = Type.tvoid;\n                     if (f.checkRetType(funcdecl.loc))\n                         funcdecl.fbody = new ErrorStatement();\n-                    else if (funcdecl.isMain())\n-                        funcdecl.checkDmain();       // Check main() parameters and return type\n+                    else\n+                        funcdecl.checkMain(); // Check main() parameters and return type\n                 }\n \n                 if (f.next !is null)\n@@ -654,7 +654,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n \n                 // handle NRVO\n                 if (!target.isReturnOnStack(f, funcdecl.needThis()) || !funcdecl.checkNRVO())\n-                    funcdecl.nrvo_can = 0;\n+                    funcdecl.flags &= ~FUNCFLAG.NRVO;\n \n                 if (funcdecl.fbody.isErrorStatement())\n                 {\n@@ -762,7 +762,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     /* Don't generate unwind tables for this function\n                      * https://issues.dlang.org/show_bug.cgi?id=17997\n                      */\n-                    funcdecl.eh_none = true;\n+                    funcdecl.flags |= FUNCFLAG.noEH;\n                 }\n \n                 if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n@@ -927,7 +927,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                             /* https://issues.dlang.org/show_bug.cgi?id=10789\n                              * If NRVO is not possible, all returned lvalues should call their postblits.\n                              */\n-                            if (!funcdecl.nrvo_can)\n+                            if (!funcdecl.isNRVO())\n                                 exp = doCopyOrMove(sc2, exp, f.next);\n \n                             if (tret.hasPointers())\n@@ -996,7 +996,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 freq = freq.statementSemantic(sc2);\n                 freq.blockExit(funcdecl, false);\n \n-                funcdecl.eh_none = false;\n+                funcdecl.flags &= ~FUNCFLAG.noEH;\n \n                 sc2 = sc2.pop();\n \n@@ -1030,7 +1030,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 fens = fens.statementSemantic(sc2);\n                 fens.blockExit(funcdecl, false);\n \n-                funcdecl.eh_none = false;\n+                funcdecl.flags &= ~FUNCFLAG.noEH;\n \n                 sc2 = sc2.pop();\n \n@@ -1159,7 +1159,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                             const blockexit = s.blockExit(funcdecl, isnothrow);\n                             if (blockexit & BE.throw_)\n                             {\n-                                funcdecl.eh_none = false;\n+                                funcdecl.flags &= ~FUNCFLAG.noEH;\n                                 if (isnothrow)\n                                     error(funcdecl.loc, \"%s `%s` may throw but is marked as `nothrow`\", funcdecl.kind(), funcdecl.toPrettyChars());\n                                 else if (funcdecl.flags & FUNCFLAG.nothrowInprocess)\n@@ -1195,7 +1195,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                             {\n                                 // 'this' is the monitor\n                                 vsync = new VarExp(funcdecl.loc, funcdecl.vthis);\n-                                if (funcdecl.isThis2)\n+                                if (funcdecl.hasDualContext())\n                                 {\n                                     vsync = new PtrExp(funcdecl.loc, vsync);\n                                     vsync = new IndexExp(funcdecl.loc, vsync, IntegerExp.literal!0);\n@@ -1230,15 +1230,15 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                 }\n \n             // Fix up forward-referenced gotos\n-            if (funcdecl.gotos)\n+            if (funcdecl.gotos && !funcdecl.isCsymbol())\n             {\n                 for (size_t i = 0; i < funcdecl.gotos.dim; ++i)\n                 {\n                     (*funcdecl.gotos)[i].checkLabel();\n                 }\n             }\n \n-            if (funcdecl.naked && (funcdecl.fensures || funcdecl.frequires))\n+            if (funcdecl.isNaked() && (funcdecl.fensures || funcdecl.frequires))\n                 funcdecl.error(\"naked assembly functions with contracts are not supported\");\n \n             sc2.ctorflow.callSuper = CSX.none;\n@@ -1370,7 +1370,10 @@ private extern(C++) final class Semantic3Visitor : Visitor\n          * Otherwise, error gagging should be temporarily ungagged by functionSemantic3.\n          */\n         funcdecl.semanticRun = PASS.semantic3done;\n-        funcdecl.semantic3Errors = (global.errors != oldErrors) || (funcdecl.fbody && funcdecl.fbody.isErrorStatement());\n+        if ((global.errors != oldErrors) || (funcdecl.fbody && funcdecl.fbody.isErrorStatement()))\n+            funcdecl.flags |= FUNCFLAG.semantic3Errors;\n+        else\n+            funcdecl.flags &= ~FUNCFLAG.semantic3Errors;\n         if (funcdecl.type.ty == Terror)\n             funcdecl.errors = true;\n         //printf(\"-FuncDeclaration::semantic3('%s.%s', sc = %p, loc = %s)\\n\", parent.toChars(), toChars(), sc, loc.toChars());"}, {"sha": "ae03b8a4c52527c5592e530b5f8c47e2f139f651", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1761,6 +1761,9 @@ extern (C++) final class GotoStatement : Statement\n         return new GotoStatement(loc, ident);\n     }\n \n+    /**************\n+     * Returns: true for error\n+     */\n     extern (D) bool checkLabel()\n     {\n         if (!label.statement)"}, {"sha": "c2967d65d5f4a7d5b52bd4cec6481fd44b1153d2", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -211,7 +211,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             if (f.checkForwardRef(s.exp.loc))\n                 s.exp = ErrorExp.get();\n         }\n-        if (discardValue(s.exp))\n+\n+        if (!(sc.flags & SCOPE.Cfile) && discardValue(s.exp))\n             s.exp = ErrorExp.get();\n \n         s.exp = s.exp.optimize(WANTvalue);\n@@ -728,12 +729,12 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         Dsymbol sapply = null;                  // the inferred opApply() or front() function\n         if (!inferForeachAggregate(sc, fs.op == TOK.foreach_, fs.aggr, sapply))\n         {\n-            const(char)* msg = \"\";\n-            if (fs.aggr.type && isAggregate(fs.aggr.type))\n-            {\n-                msg = \", define `opApply()`, range primitives, or use `.tupleof`\";\n-            }\n-            fs.error(\"invalid `foreach` aggregate `%s`%s\", oaggr.toChars(), msg);\n+            assert(oaggr.type);\n+\n+            fs.error(\"invalid `foreach` aggregate `%s` of type `%s`\", oaggr.toChars(), oaggr.type.toPrettyChars());\n+            if (isAggregate(fs.aggr.type))\n+                fs.loc.errorSupplemental(\"maybe define `opApply()`, range primitives, or use `.tupleof`\");\n+\n             return setError();\n         }\n \n@@ -2310,20 +2311,24 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 needswitcherror = true;\n         }\n \n-        if (!sc.sw.sdefault && !(sc.flags & SCOPE.Cfile) &&\n+        if (!sc.sw.sdefault &&\n             (!ss.isFinal || needswitcherror || global.params.useAssert == CHECKENABLE.on))\n         {\n             ss.hasNoDefault = 1;\n \n-            if (!ss.isFinal && (!ss._body || !ss._body.isErrorStatement()))\n+            if (!ss.isFinal && (!ss._body || !ss._body.isErrorStatement()) && !(sc.flags & SCOPE.Cfile))\n                 ss.error(\"`switch` statement without a `default`; use `final switch` or add `default: assert(0);` or add `default: break;`\");\n \n             // Generate runtime error if the default is hit\n             auto a = new Statements();\n             CompoundStatement cs;\n             Statement s;\n \n-            if (global.params.useSwitchError == CHECKENABLE.on &&\n+            if (sc.flags & SCOPE.Cfile)\n+            {\n+                s = new BreakStatement(ss.loc, null);   // default for C is `default: break;`\n+            }\n+            else if (global.params.useSwitchError == CHECKENABLE.on &&\n                 global.params.checkAction != CHECKACTION.halt)\n             {\n                 if (global.params.checkAction == CHECKACTION.C)\n@@ -2365,7 +2370,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             ss._body = cs;\n         }\n \n-        if (ss.checkLabel())\n+        if (!(sc.flags & SCOPE.Cfile) && ss.checkLabel())\n         {\n             sc.pop();\n             return setError();\n@@ -3840,7 +3845,7 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                 fd.gotos = new GotoStatements();\n             fd.gotos.push(gs);\n         }\n-        else if (gs.checkLabel())\n+        else if (!(sc.flags & SCOPE.Cfile) && gs.checkLabel())\n             return setError();\n \n         result = gs;\n@@ -3916,12 +3921,10 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         }\n \n         assert(sc.func);\n-        // use setImpure/setGC when the deprecation cycle is over\n-        PURE purity;\n-        if (!(cas.stc & STC.pure_) && (purity = sc.func.isPureBypassingInference()) != PURE.impure && purity != PURE.fwdref)\n-            cas.deprecation(\"`asm` statement is assumed to be impure - mark it with `pure` if it is not\");\n-        if (!(cas.stc & STC.nogc) && sc.func.isNogcBypassingInference())\n-            cas.deprecation(\"`asm` statement is assumed to use the GC - mark it with `@nogc` if it does not\");\n+        if (!(cas.stc & STC.pure_) && sc.func.setImpure())\n+            cas.error(\"`asm` statement is assumed to be impure - mark it with `pure` if it is not\");\n+        if (!(cas.stc & STC.nogc) && sc.func.setGC())\n+            cas.error(\"`asm` statement is assumed to use the GC - mark it with `@nogc` if it does not\");\n         if (!(cas.stc & (STC.trusted | STC.safe)) && sc.func.setUnsafe())\n             cas.error(\"`asm` statement is assumed to be `@system` - mark it with `@trusted` if it is not\");\n "}, {"sha": "43feab15f22543dcc83f7c7e0dd745baf37c4d99", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -245,6 +245,7 @@ enum TOK : ubyte\n     arrow,      // ->\n     colonColon, // ::\n     wchar_tLiteral,\n+    endOfLine,  // \\n, \\r, \\u2028, \\u2029\n     whitespace,\n \n     // C only keywords\n@@ -851,6 +852,7 @@ extern (C++) struct Token\n         TOK.wcharLiteral: \"wcharv\",\n         TOK.dcharLiteral: \"dcharv\",\n         TOK.wchar_tLiteral: \"wchar_tv\",\n+        TOK.endOfLine: \"\\\\n\",\n         TOK.whitespace: \"whitespace\",\n \n         // C only keywords\n@@ -945,20 +947,19 @@ nothrow:\n             sprintf(&buffer[0], \"%d\", cast(int)intvalue);\n             break;\n         case TOK.uns32Literal:\n-        case TOK.wcharLiteral:\n-        case TOK.dcharLiteral:\n         case TOK.wchar_tLiteral:\n             sprintf(&buffer[0], \"%uU\", cast(uint)unsvalue);\n             break;\n+        case TOK.wcharLiteral:\n+        case TOK.dcharLiteral:\n         case TOK.charLiteral:\n-        {\n-            const v = cast(int)intvalue;\n-            if (v >= ' ' && v <= '~')\n-                sprintf(&buffer[0], \"'%c'\", v);\n-            else\n-                sprintf(&buffer[0], \"'\\\\x%02x'\", v);\n+            {\n+                OutBuffer buf;\n+                buf.writeSingleCharLiteral(cast(dchar) intvalue);\n+                buf.writeByte('\\0');\n+                p = buf.extractSlice().ptr;\n+            }\n             break;\n-        }\n         case TOK.int64Literal:\n             sprintf(&buffer[0], \"%lldL\", cast(long)intvalue);\n             break;\n@@ -1090,7 +1091,7 @@ void writeCharLiteral(ref OutBuffer buf, dchar c)\n             buf.writeByte('\\\\');\n             goto default;\n         default:\n-            if (c <= 0x7F)\n+            if (c <= 0xFF)\n             {\n                 if (isprint(c))\n                     buf.writeByte(c);\n@@ -1114,3 +1115,40 @@ unittest\n     }\n     assert(buf.extractSlice() == `a\\n\\r\\t\\b\\f\\0\\x11\\u7233\\U00017233`);\n }\n+\n+/**\n+ * Write a single-quoted character literal\n+ *\n+ * Useful for printing '' char literals in e.g. error messages, ddoc, or the `.stringof` property\n+ *\n+ * Params:\n+ *   buf = buffer to append character in\n+ *   c = code point to write\n+ */\n+nothrow\n+void writeSingleCharLiteral(ref OutBuffer buf, dchar c)\n+{\n+    buf.writeByte('\\'');\n+    if (c == '\\'')\n+        buf.writeByte('\\\\');\n+\n+    if (c == '\"')\n+        buf.writeByte('\"');\n+    else\n+        writeCharLiteral(buf, c);\n+\n+    buf.writeByte('\\'');\n+}\n+\n+unittest\n+{\n+    OutBuffer buf;\n+    writeSingleCharLiteral(buf, '\\'');\n+    assert(buf.extractSlice() == `'\\''`);\n+    buf.reset();\n+    writeSingleCharLiteral(buf, '\"');\n+    assert(buf.extractSlice() == `'\"'`);\n+    buf.reset();\n+    writeSingleCharLiteral(buf, '\\n');\n+    assert(buf.extractSlice() == `'\\n'`);\n+}"}, {"sha": "f9b606256bc8f1a342d67d8d3d3ca59a1e2b96db", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -254,6 +254,7 @@ enum class TOK : unsigned char\n     arrow,      // ->\n     colonColon, // ::\n     wchar_tLiteral,\n+    endOfLine,  // \\n, \\r, \\u2028, \\u2029\n     whitespace,\n \n     // C only keywords"}, {"sha": "4b15e8c4739a4ab5edebbdae4cc714304169345c", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -80,10 +80,10 @@ private Dsymbol getDsymbolWithoutExpCtx(RootObject oarg)\n {\n     if (auto e = isExpression(oarg))\n     {\n-        if (e.op == EXP.dotVariable)\n-            return (cast(DotVarExp)e).var;\n-        if (e.op == EXP.dotTemplateDeclaration)\n-            return (cast(DotTemplateExp)e).td;\n+        if (auto dve = e.isDotVarExp())\n+            return dve.var;\n+        if (auto dte = e.isDotTemplateExp())\n+            return dte.td;\n     }\n     return getDsymbol(oarg);\n }\n@@ -833,7 +833,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 e.error(\"argument `%s` has no visibility\", o.toChars());\n             return ErrorExp.get();\n         }\n-        if (s.semanticRun == PASS.init)\n+        if (s.semanticRun == PASS.initial)\n             s.dsymbolSemantic(null);\n \n         auto protName = visibilityToString(s.visible().kind); // TODO: How about package(names)\n@@ -1053,9 +1053,9 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         }\n         else if (e.ident == Id.getMember)\n         {\n-            if (ex.op == EXP.dotIdentifier)\n+            if (auto die = ex.isDotIdExp())\n                 // Prevent semantic() from replacing Symbol with its initializer\n-                (cast(DotIdExp)ex).wantsym = true;\n+                die.wantsym = true;\n             ex = ex.expressionSemantic(scx);\n             return ex;\n         }\n@@ -2101,13 +2101,14 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             return ErrorExp.get();\n         }\n \n-        if (sc.func is null)\n+        auto fd = sc.getEnclosingFunction();\n+        if (!fd)\n         {\n             e.error(\"`__traits(parameters)` may only be used inside a function\");\n             return ErrorExp.get();\n         }\n-        assert(sc.func && sc.parent.isFuncDeclaration());\n-        auto tf = sc.parent.isFuncDeclaration.type.isTypeFunction();\n+\n+        auto tf = fd.type.isTypeFunction();\n         assert(tf);\n         auto exps = new Expressions(0);\n         int addParameterDG(size_t idx, Parameter x)\n@@ -2162,7 +2163,7 @@ private bool isSame(RootObject o1, RootObject o2, Scope* sc)\n         {\n             if (ea.op == EXP.function_)\n             {\n-                if (auto fe = cast(FuncExp)ea)\n+                if (auto fe = ea.isFuncExp())\n                     return fe.fd;\n             }\n         }"}, {"sha": "bcdbec5fe2d5b5a3fd61b46016afefa37c4c2178", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -978,7 +978,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             // duplicate a part of StructDeclaration::semanticTypeInfoMembers\n             //printf(\"AA = %s, key: xeq = %p, xerreq = %p xhash = %p\\n\", toChars(), sd.xeq, sd.xerreq, sd.xhash);\n \n-            if (sd.xeq && sd.xeq.generated && sd.xeq._scope && sd.xeq.semanticRun < PASS.semantic3done)\n+            if (sd.xeq && sd.xeq.isGenerated() && sd.xeq._scope && sd.xeq.semanticRun < PASS.semantic3done)\n             {\n                 uint errors = global.startGagging();\n                 sd.xeq.semantic3(sd.xeq._scope);\n@@ -1431,12 +1431,6 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                     errors = true;\n                 }\n \n-                if ((fparam.storageClass & (STC.ref_ | STC.wild)) == (STC.ref_ | STC.wild))\n-                {\n-                    // 'ref inout' implies 'return'\n-                    fparam.storageClass |= STC.return_;\n-                }\n-\n                 if (fparam.storageClass & STC.return_)\n                 {\n                     if (fparam.isReference())\n@@ -1799,6 +1793,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             mtype.exp.ident != Id.derivedMembers &&\n             mtype.exp.ident != Id.getMember &&\n             mtype.exp.ident != Id.parent &&\n+            mtype.exp.ident != Id.parameters &&\n             mtype.exp.ident != Id.child &&\n             mtype.exp.ident != Id.toType &&\n             mtype.exp.ident != Id.getOverloads &&\n@@ -3088,7 +3083,7 @@ void resolve(Type mt, const ref Loc loc, Scope* sc, out Expression pe, out Type\n         //static int nest; if (++nest == 50) *(char*)0=0;\n         if (sc is null)\n         {\n-            error(loc, \"Invalid scope.\");\n+            error(loc, \"invalid scope\");\n             return returnError();\n         }\n         if (mt.inuse)\n@@ -4076,7 +4071,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                     return e.expressionSemantic(sc);\n                 }\n             }\n-            if (d.semanticRun == PASS.init)\n+            if (d.semanticRun == PASS.initial)\n                 d.dsymbolSemantic(null);\n             checkAccess(e.loc, sc, e, d);\n             auto ve = new VarExp(e.loc, d);\n@@ -4307,7 +4302,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n             if (ident == Id.outer && mt.sym.vthis)\n             {\n-                if (mt.sym.vthis.semanticRun == PASS.init)\n+                if (mt.sym.vthis.semanticRun == PASS.initial)\n                     mt.sym.vthis.dsymbolSemantic(null);\n \n                 if (auto cdp = mt.sym.toParentLocal().isClassDeclaration())\n@@ -4503,7 +4498,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                     Expression e1;\n                     Type t;\n                     /* returns: true to continue, false to return */\n-                    if (f.isThis2)\n+                    if (f.hasDualContext())\n                     {\n                         if (f.followInstantiationContext(ad))\n                         {\n@@ -4560,7 +4555,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 }\n             }\n             //printf(\"e = %s, d = %s\\n\", e.toChars(), d.toChars());\n-            if (d.semanticRun == PASS.init)\n+            if (d.semanticRun == PASS.initial)\n                 d.dsymbolSemantic(null);\n \n             // If static function, get the most visible overload."}, {"sha": "67e4d86a43e194655822104a41eefd2f1afcde4f", "filename": "gcc/d/dmd/utils.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fdmd%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -63,7 +63,7 @@ FileBuffer readFile(Loc loc, const(char)[] filename)\n     auto result = File.read(filename);\n     if (!result.success)\n     {\n-        error(loc, \"Error reading file `%.*s`\", cast(int)filename.length, filename.ptr);\n+        error(loc, \"error reading file `%.*s`\", cast(int)filename.length, filename.ptr);\n         fatal();\n     }\n     return FileBuffer(result.extractSlice());"}, {"sha": "61a2b50b149105b5aa6136f13d2324f7016f2043", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1441,7 +1441,7 @@ class ExprVisitor : public Visitor\n \tgcc_assert (e->e1->op == EXP::variable);\n \n \tVarDeclaration *v = e->e1->isVarExp ()->var->isVarDeclaration ();\n-\tgcc_assert (v && v->onstack);\n+\tgcc_assert (v && v->onstack ());\n \n \tlibcall_fn libcall = tb1->isClassHandle ()->isInterfaceDeclaration ()\n \t  ? LIBCALL_CALLINTERFACEFINALIZER : LIBCALL_CALLFINALIZER;"}, {"sha": "edc7912236549cee10f750f07e3d4bc77b4140aa", "filename": "gcc/d/modules.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fmodules.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Fmodules.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fmodules.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -141,7 +141,7 @@ get_internal_fn (tree ident, const Visibility &visibility)\n \n   FuncDeclaration *fd = FuncDeclaration::genCfunc (NULL, Type::tvoid,\n \t\t\t\t\t\t   Identifier::idPool (name));\n-  fd->generated = true;\n+  fd->isGenerated (true);\n   fd->loc = Loc (mod->srcfile.toChars (), 1, 0);\n   fd->parent = mod;\n   fd->visibility = visibility;"}, {"sha": "d20c5c3b92729f3afaf1713c0d4dbe5b650441a8", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -958,7 +958,7 @@ class IRVisitor : public Visitor\n \t/* If returning via NRVO, just refer to the DECL_RESULT; this differs\n \t   from using NULL_TREE in that it indicates that we care about the\n \t   value of the DECL_RESULT.  */\n-\tif (this->func_->nrvo_can && this->func_->nrvo_var)\n+\tif (this->func_->isNRVO () && this->func_->nrvo_var)\n \t  {\n \t    add_stmt (return_expr (decl));\n \t    return;"}, {"sha": "d93edfb200cc82e6298bcfc486f227447a8aa632", "filename": "gcc/testsuite/gdc.dg/nrvo1.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.dg%2Fnrvo1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.dg%2Fnrvo1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fnrvo1.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fpreview=dip1000\" }\n+ThreadInfo* ptr;\n+\n+ThreadInfo receiveOnly()\n+{\n+    ThreadInfo ret;\n+\n+    get({ptr = &ret;});\n+    return ret;\n+}\n+\n+struct ThreadInfo\n+{\n+    ThreadInfo* next;\n+}\n+\n+bool get(T)(T)\n+{\n+    return false;\n+}\n+\n+void main()\n+{\n+    auto t = receiveOnly();\n+    assert(&t == ptr);\n+}"}, {"sha": "c52c7100c2886f78faf9b631a6f7b0167e720672", "filename": "gcc/testsuite/gdc.test/compilable/Test16206.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FTest16206.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -25,4 +25,4 @@ static assert(S.foo!([]) == 0);\n \n alias fooFuns = AliasSeq!(__traits(getOverloads, S, \"foo\"));\n static assert(fooFuns.length == 1);\n-static assert(fooFuns[0](\"\") == 2);\n\\ No newline at end of file\n+static assert(fooFuns[0](\"\") == 2);"}, {"sha": "a29836eef47cb1c7cf768196a1a672fa9fe5b01f", "filename": "gcc/testsuite/gdc.test/compilable/aliasassign.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Faliasassign.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -38,4 +38,3 @@ alias TK2 = reverse!(int, const uint, X2);\n static assert(TK2[0] == 3);\n static assert(is(TK2[1] == const(uint)));\n static assert(is(TK2[2] == int));\n-"}, {"sha": "062960616731055f38c5eb9edf5ac37ec7bd0eed", "filename": "gcc/testsuite/gdc.test/compilable/art4769.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fart4769.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fart4769.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fart4769.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ struct Vector(T)\n \t{\n \t}\n }\n-"}, {"sha": "fb14fee5c0ad7232c7fa51a2dfe331158ca9c08a", "filename": "gcc/testsuite/gdc.test/compilable/b21285.d", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb21285.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb21285.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb21285.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,5 @@\n // REQUIRED_ARGS: -unittest\n+// PERMUTE_ARGS: -preview=dip1000\n // Issue 21285 - Delegate covariance broken between 2.092 and 2.094 (git master).\n unittest\n {\n@@ -25,3 +26,36 @@ unittest\n     static assert(is(typeof(a[0]) == dg));\n     static assert(is(typeof(ab[0]) == fn));\n }\n+\n+int f(string s) { throw new Exception(\"\"); }\n+void main()\n+{\n+    string path;\n+    int bank, preset;\n+    void delegate(string value)[string] aa = [\n+        \"path\": (string arg) {\n+            path = arg;\n+        },\n+        \"bank\": (string arg) {\n+            bank = f(arg);\n+        },\n+        \"preset\": (string arg) {\n+            preset = f(arg);\n+        },\n+    ];\n+\n+    string delegate(string value)[string] aa2 = [\n+        \"path\": (string arg) {\n+            path = arg;\n+            return arg;\n+        },\n+        \"bank\": (string arg) {\n+            bank = f(arg);\n+            return arg;\n+        },\n+        \"preset\": (string arg) {\n+            preset = f(arg);\n+            return arg;\n+        },\n+    ];\n+}"}, {"sha": "72452b62e882d1261d55ab68282c201f29f3fb7a", "filename": "gcc/testsuite/gdc.test/compilable/b33.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb33.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb33.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb33.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ size_t fn()\n {\n     return find( \"123\" );\n }\n-"}, {"sha": "3910ffa76ea8f6fb84997332caf97b06bc980758", "filename": "gcc/testsuite/gdc.test/compilable/b6395.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb6395.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb6395.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb6395.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,4 +22,3 @@ void applyNoRemoveRegex()\n     auto a = find!((a){return match(e);})(map!regex(noRemoveStr));\n   }\n }\n-"}, {"sha": "433163db6ccce9f781af163f168cfe482f590c61", "filename": "gcc/testsuite/gdc.test/compilable/b9490.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb9490.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb9490.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb9490.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -36,4 +36,3 @@ void main()\n     f(s1.s.tupleof); // OK\n     f((s1.s).tupleof); // Error: need 'this' to access member s\n }\n-"}, {"sha": "3e9a881c3d666aca0331594df743111171377ea1", "filename": "gcc/testsuite/gdc.test/compilable/betterCarray.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCarray.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -4,7 +4,8 @@\n \n import core.stdc.stdio;\n \n-extern (C) int main(char** argv, int argc) {\n+extern (C) int main()\n+{\n     printf(\"hello world\\n\");\n     int[3] a;\n     foo(a[], 3);"}, {"sha": "a140ea9963a7e08dc5b8369b5e7a787d60e792d9", "filename": "gcc/testsuite/gdc.test/compilable/betterCswitch.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCswitch.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCswitch.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FbetterCswitch.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,6 +1,7 @@\n import core.stdc.stdio;\n \n-extern (C) int main(char** argv, int argc) {\n+extern (C) int main()\n+{\n     printf(\"hello world\\n\");\n     foo(3);\n     return 0;"}, {"sha": "cb6e3de8205c3be07dfd8418a42eaf4379cd8dbc", "filename": "gcc/testsuite/gdc.test/compilable/ccompile.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fccompile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fccompile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fccompile.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -32,5 +32,3 @@ void funchds(char *p_adults)\n          }\n    }\n }\n-\n-"}, {"sha": "305f097bd81f595800faf5d01b9ba51d0dbb80b9", "filename": "gcc/testsuite/gdc.test/compilable/cdcmp.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcdcmp.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -145,4 +145,3 @@ bool test_eq(double x, double y) { return x == y; }\n bool test_ne(double x, double y) { return x != y; }\n bool test_ge(double x, double y) { return x >= y; }\n bool test_gt(double x, double y) { return x >  y; }\n-"}, {"sha": "dc3d471b021b92fcbf6c9711e77032ef7cfd7d4d", "filename": "gcc/testsuite/gdc.test/compilable/const.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fconst.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fconst.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fconst.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -37,5 +37,3 @@ static assert(6.0 % 4.0 == 2);\n static assert(6.0i % 2.0i == 0);\n static assert(6.0i % 3.0i == 0);\n static assert(6.0i % 4.0i == 2i);\n-\n-"}, {"sha": "0a27eda26e5e7cbe9a5a320ee722e89f46e1e999", "filename": "gcc/testsuite/gdc.test/compilable/ddoc1.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc1.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -47,7 +47,7 @@ wchar YY;\t/// ditto\n  *\targulid = the argument\n  *\tu = the other argument\n  */\n-int foo(char c, int argulid, char u);\n+int foo(char c, int argulid, char u = '\\'', wchar v = '\\u7233', dchar y = '\\U00017233');\n \n int barr() { return 3; } /// doc for barr()\n "}, {"sha": "683cd5f677b8b3f49a2d9473ce3b9c9669e62b41", "filename": "gcc/testsuite/gdc.test/compilable/ddoc11.d", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc11.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc11.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc11.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -62,8 +62,3 @@ private:\n void test1()\n {\n }\n-\n-\n-\n-\n-"}, {"sha": "a0c9b3ff7e58471410ff6472296b95aaaf613c43", "filename": "gcc/testsuite/gdc.test/compilable/ddoc12706.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12706.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12706.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12706.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -6,4 +6,3 @@\n void test()(string[] args) if (args[$])\n {\n }\n-"}, {"sha": "c4bd7fb643249baa2838e7791a74977e6d627bdb", "filename": "gcc/testsuite/gdc.test/compilable/ddoc12745.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12745.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12745.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc12745.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,4 +22,4 @@ $(BR)\n 1__a $(BR)\n 2__b\n */\n-int i;\n\\ No newline at end of file\n+int i;"}, {"sha": "cc69a25017c1d0cb7ed291f9c1338e72f6424bc9", "filename": "gcc/testsuite/gdc.test/compilable/ddoc13.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc13.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc13.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc13.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,4 +23,3 @@ struct Bug4107b(T) {\n         }\n     }\n }\n-"}, {"sha": "ed71d05c68ce96f25573c84e1f9fb963e3304806", "filename": "gcc/testsuite/gdc.test/compilable/ddoc14.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc14.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc14.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc14.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -92,6 +92,3 @@ pure nothrow auto mAutoPrefix(ref P p) { return p; } /// 7\n auto mAutoTemplateSuffix(alias T)(ref T t) pure nothrow { return p; } /// 9\n pure nothrow:\n V mColon(lazy P p) {} /// 10\n-\n-\n-"}, {"sha": "5a56141140889029c0b16cb54d25d9ca7737b028", "filename": "gcc/testsuite/gdc.test/compilable/ddoc2.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -39,4 +39,3 @@ class StreamException: Exception {\n     /********** stars ***************/\n     int stars;\n }\n-"}, {"sha": "4a1b075456afe44194a006da12cf9457646ee4b0", "filename": "gcc/testsuite/gdc.test/compilable/ddoc2273.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2273.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2273.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc2273.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -34,4 +34,3 @@ template staticIndexOf(T, TList...) { alias int staticIndexOf; }\n alias staticIndexOf IndexOf;\n \n void main() { }\n-"}, {"sha": "ad4c214135cc37c4082f47f741b666c1064a1131", "filename": "gcc/testsuite/gdc.test/compilable/ddoc3.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc3.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -68,4 +68,3 @@ class StreamException: Exception {\n     /********** stars ***************/\n     int stars;\n }\n-"}, {"sha": "d0b56557fb3288bf9292570bba6f53c0b267228f", "filename": "gcc/testsuite/gdc.test/compilable/ddoc5.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc5.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc5.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc5.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -28,4 +28,3 @@ class TestMembers(TemplateArg)\n void main()\n {\n }\n-"}, {"sha": "a229dc5e064307d19f6f29debc4171529f6b01d5", "filename": "gcc/testsuite/gdc.test/compilable/ddoc6.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,4 +22,3 @@ void main()\n C:\\code\\d\\bugs>dmd -D -o- 148_1.d\n 148_1.d(6): Error: static if conditional cannot be at global scope\n +/\n-"}, {"sha": "cf93399686440e677f15a483973f60dbacb9f614", "filename": "gcc/testsuite/gdc.test/compilable/ddoc6491.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6491.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6491.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc6491.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,5 +10,3 @@ enum int c6491 = 4;\n \n /// test\n void bug6491a(int a = ddoc6491.c6491, string b = core.cpuid.vendor);\n-\n-"}, {"sha": "eba3680df546e75d74774d07ed572b6bfc763302", "filename": "gcc/testsuite/gdc.test/compilable/ddoc7.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc7.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc7.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc7.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -56,4 +56,3 @@ class C\n     /// Some doc\n     abstract void foo();\n }\n-"}, {"sha": "30b4c115c2979aa17475ac6e5ac98bf11c2fea83", "filename": "gcc/testsuite/gdc.test/compilable/ddoc9369.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9369.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9369.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9369.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -13,6 +13,3 @@ writeln(&a);\n ---\n */\n void foo() { }\n-\n-\n-"}, {"sha": "396bdb1a2b780b52e2198379a6a121bf65d267b1", "filename": "gcc/testsuite/gdc.test/compilable/ddoc9475.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9475.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9475.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fddoc9475.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -26,4 +26,3 @@ unittest\n {\n     // bar comment\n }\n-"}, {"sha": "9d686312800f53cb94b60a0ac81f4f91b0221cb1", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_AnonDeclaration.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AnonDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AnonDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_AnonDeclaration.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -50,7 +50,6 @@ struct S final\n     {\n         int32_t y;\n         double z;\n-        extern \"C\" void foo();\n         void bar();\n     };\n     struct"}, {"sha": "4f13d2bc9e18588752dd89e80805c8c23b317def", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_ClassDeclaration.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ClassDeclaration.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -82,7 +82,9 @@ public:\n     int32_t a;\n     C* c;\n     virtual void foo();\n-    extern \"C\" virtual void bar();\n+private:\n+    virtual void __vtable_slot_0();\n+public:\n     virtual void baz(int32_t x = 42);\n     struct\n     {\n@@ -116,7 +118,7 @@ public:\n     {\n     public:\n         int32_t x;\n-        A* this;\n+        A* outer;\n     };\n \n     typedef Inner I;\n@@ -146,8 +148,8 @@ public:\n \n class Parent\n {\n-    virtual void __vtable_slot_0();\n     virtual void __vtable_slot_1();\n+    virtual void __vtable_slot_2();\n public:\n     virtual void foo();\n };"}, {"sha": "4d56c7c556942d2e84cd93387e1227c8c925750a", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_StructDeclaration.d", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_StructDeclaration.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -45,6 +45,9 @@ struct S final\n     int32_t b;\n     int64_t c;\n     _d_dynamicArray< int32_t > arr;\n+private:\n+    ~S();\n+public:\n     S() :\n         a(),\n         b(),\n@@ -81,7 +84,6 @@ struct S3 final\n     int32_t a;\n     int32_t b;\n     int64_t c;\n-    extern \"C\" S3(int32_t a);\n     S3() :\n         a(42),\n         b(),\n@@ -143,7 +145,6 @@ struct A final\n {\n     int32_t a;\n     S s;\n-    extern \"C\" void bar();\n     void baz(int32_t x = 42);\n     struct\n     {\n@@ -232,6 +233,7 @@ extern (C++) struct S\n     int b;\n     long c;\n     int[] arr;\n+    extern(D) ~this() {}\n }\n \n extern (C++) struct S2"}, {"sha": "7356ba3f6bd849253fb41d095bbe2be916df51da", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_VarDeclaration.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_VarDeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_VarDeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_VarDeclaration.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -39,7 +39,7 @@ struct _d_dynamicArray final\n };\n #endif\n #if !defined(_d_real)\n-# define _d_real long double\n+#define _d_real long double\n #endif\n \n extern \"C\" int32_t z;"}, {"sha": "0426a5e9dfe80e26c559efa8a3bae0907aa7b9ea", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_extern_type.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_extern_type.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_extern_type.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_extern_type.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -40,7 +40,7 @@ struct _d_dynamicArray final\n };\n #endif\n #if !defined(_d_real)\n-# define _d_real long double\n+#define _d_real long double\n #endif\n \n class ClassFromStruct final"}, {"sha": "d687673accea14ce9bc0803f35513f736c52d093", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_ignored.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_ignored.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -39,7 +39,7 @@ struct _d_dynamicArray final\n };\n #endif\n #if !defined(_d_real)\n-# define _d_real long double\n+#define _d_real long double\n #endif\n \n class WithImaginary"}, {"sha": "44d0dd5be9b36a811b1a330eab0fb907de5fb945", "filename": "gcc/testsuite/gdc.test/compilable/dtoh_mangling.d", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_mangling.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_mangling.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdtoh_mangling.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,118 @@\n+/++\n+REQUIRED_ARGS: -HC=verbose\n+TEST_OUTPUT:\n+---\n+// Automatically generated by Digital Mars D Compiler v$n$\n+\n+#pragma once\n+\n+#include <assert.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <math.h>\n+\n+#ifdef CUSTOM_D_ARRAY_TYPE\n+#define _d_dynamicArray CUSTOM_D_ARRAY_TYPE\n+#else\n+/// Represents a D [] array\n+template<typename T>\n+struct _d_dynamicArray final\n+{\n+    size_t length;\n+    T *ptr;\n+\n+    _d_dynamicArray() : length(0), ptr(NULL) { }\n+\n+    _d_dynamicArray(size_t length_in, T *ptr_in)\n+        : length(length_in), ptr(ptr_in) { }\n+\n+    T& operator[](const size_t idx) {\n+        assert(idx < length);\n+        return ptr[idx];\n+    }\n+\n+    const T& operator[](const size_t idx) const {\n+        assert(idx < length);\n+        return ptr[idx];\n+    }\n+};\n+#endif\n+\n+extern \"C\" int32_t freeC();\n+\n+// Ignored function dtoh_mangling.bar because C++ doesn't support explicit mangling\n+struct Data final\n+{\n+    // Ignored function dtoh_mangling.Data.foo because of linkage\n+    // Ignored function dtoh_mangling.Data.bar because C++ doesn't support explicit mangling\n+    Data()\n+    {\n+    }\n+};\n+\n+extern void accept(Data data);\n+\n+extern \"C\" void hasDefault(int32_t i = freeC());\n+\n+extern \"C\" void hasDefaultMember(int32_t i = memberC());\n+\n+extern \"C\" int32_t someVarC;\n+\n+// Ignored variable dtoh_mangling.var2 because C++ doesn't support explicit mangling\n+struct HasMangleMember final\n+{\n+    int32_t someAttrC;\n+    int32_t someAttrCpp;\n+    void hasDefaultVar(int32_t i = someAttrC);\n+    HasMangleMember()\n+    {\n+    }\n+};\n+\n+extern \"C\" void hasDefaultVar(int32_t i = someVarC);\n+---\n+++/\n+\n+extern(C):\n+\n+pragma(mangle, \"freeC\")\n+int foo() { return 0; }\n+\n+pragma(mangle, \"freeCpp\")\n+extern (C++) void bar() {}\n+\n+pragma(mangle, \"Aggregate\")\n+struct Data\n+{\n+    pragma(mangle, \"memberC\")\n+    static int foo() { return 0; }\n+\n+    pragma(mangle, \"memberCpp\")\n+    extern (C++) void bar() {}\n+}\n+\n+extern(C++)\n+void accept(Data data) {}\n+\n+void hasDefault(int i = foo()) {}\n+\n+void hasDefaultMember(int i = Data.foo()) {}\n+\n+pragma(mangle, \"someVarC\")\n+__gshared int var;\n+\n+pragma(mangle, \"someVarCpp\")\n+extern(C++) __gshared int var2;\n+\n+struct HasMangleMember\n+{\n+    pragma(mangle, \"someAttrC\")\n+    int var;\n+\n+    pragma(mangle, \"someAttrCpp\")\n+    extern(C++) int var2;\n+\n+    extern(C++) void hasDefaultVar(int i = var) {}\n+}\n+\n+void hasDefaultVar(int i = var) {}"}, {"sha": "3c2e90ab8acb82d7872ce68fc25278594fe5b6de", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header1.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -577,7 +577,8 @@ struct SafeS\n \n     ref SafeS foo3() return scope\n     {\n-        return this;\n+        static SafeS s;\n+        return s;\n     }\n \n     int* p;"}, {"sha": "1d49be68a11ba2f9337cd906016202d451463bcc", "filename": "gcc/testsuite/gdc.test/compilable/fail137.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffail137.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffail137.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffail137.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,4 +23,3 @@ void main()\n     TypeTuple!(int, long) T;\n     printf( \"%u\\n\", cast(uint)IndexOf!(long, T) );\n }\n-"}, {"sha": "76730ed143b4072aa3fcc6da69db1a2c4bbb0323", "filename": "gcc/testsuite/gdc.test/compilable/fix17686.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17686.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17686.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17686.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -42,4 +42,3 @@ void main()\n {\n \talias aaa = DOMImplementation!string;\n }\n-"}, {"sha": "341eec36c3f6f9855226e0eaafa455f6b17b285a", "filename": "gcc/testsuite/gdc.test/compilable/fix20416.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix20416.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix20416.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix20416.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -33,4 +33,3 @@ S bar2()\n    S result;\n    return result.foo();\n }\n-"}, {"sha": "58f144045d32f6d7812943d8bc263e552272640d", "filename": "gcc/testsuite/gdc.test/compilable/fix21647.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix21647.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -35,4 +35,3 @@ pragma(msg, V);\n struct G {}\n struct F(T) { void f(ref T) {} }\n pragma(msg, F!G().f(G.init));\n-"}, {"sha": "36baef532318d0d0c08d815aa7c7af95f29e9083", "filename": "gcc/testsuite/gdc.test/compilable/fix22291.d", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,6 +20,33 @@ int echoPlusOne(int x)\n     return x;\n }\n static assert(echoPlusOne(1) == 2);\n+\n+void nesting(double d, int i)\n+{\n+    alias EXP = AliasSeq!(d, i);\n+\n+    if (d)\n+    {\n+        static assert(__traits(isSame, __traits(parameters), EXP));\n+\n+        while (d)\n+        {\n+            static assert(__traits(isSame, __traits(parameters), EXP));\n+            switch (i)\n+            {\n+                static assert(__traits(isSame, __traits(parameters), EXP));\n+                case 1:\n+                    static assert(__traits(isSame, __traits(parameters), EXP));\n+                    break;\n+\n+                default:\n+                    static assert(__traits(isSame, __traits(parameters), EXP));\n+                    break;\n+            }\n+        }\n+    }\n+}\n+\n class Tree {\n     int opApply(int delegate(size_t, Tree) dg) {\n         if (dg(0, this)) return 1;\n@@ -34,7 +61,22 @@ void useOpApply(Tree top, int x)\n     }\n     foreach(idx, elem; top)\n     {\n-        static assert(is(typeof(__traits(parameters)) == AliasSeq!(size_t, Tree)));\n+        static assert(is(typeof(__traits(parameters)) == AliasSeq!(Tree, int)));\n+    }\n+\n+    foreach(idx, elem; top)\n+    {\n+        foreach (idx2, elem2; elem)\n+            static assert(is(typeof(__traits(parameters)) == AliasSeq!(Tree, int)));\n+    }\n+\n+    foreach(idx, elem; top)\n+    {\n+        static void foo(char[] text)\n+        {\n+            foreach (const char c; text)\n+                static assert(is(typeof(__traits(parameters)) == AliasSeq!(char[])));\n+        }\n     }\n }\n class Test\n@@ -132,3 +174,64 @@ T testTemplate(T)(scope T input)\n \n static assert(testTemplate!long(420) == 0);\n \n+void qualifiers(immutable int a, const bool b)\n+{\n+    static assert(is(typeof(__traits(parameters)) == AliasSeq!(immutable int, const bool)));\n+}\n+\n+int makeAggregate(int a, bool b)\n+{\n+    struct S\n+    {\n+        typeof(__traits(parameters)) members;\n+    }\n+\n+    S s = S(__traits(parameters));\n+    assert(s.members[0] == a);\n+    assert(s.members[1] == b);\n+    return 1;\n+}\n+\n+static assert(makeAggregate(5, true));\n+\n+int makeAlias(int a, bool b)\n+{\n+    alias Params = __traits(parameters);\n+    assert(Params[0] == 3);\n+    assert(Params[1] == true);\n+    return 1;\n+}\n+\n+static assert(makeAlias(3, true));\n+\n+\n+mixin template nestedCheckParameters(int unique)\n+{\n+    alias NestedNames = __traits(parameters);\n+    version (Fixed)\n+    alias Types = typeof(Names);\n+}\n+\n+mixin template checkParameters(int unique)\n+{\n+    mixin nestedCheckParameters!unique;\n+\n+    alias Names = __traits(parameters);\n+    alias Types = typeof(Names);\n+}\n+\n+int makeAggregateMixin(immutable int a, const bool b)\n+{\n+    mixin checkParameters!0;\n+\n+    struct S\n+    {\n+        mixin checkParameters!1;\n+        typeof(Names) members;\n+    }\n+\n+    S s = S(Names);\n+    assert(s.members[0] == a);\n+    assert(s.members[1] == b);\n+    return 1;\n+}"}, {"sha": "5deef96b39ff4943943e05ec147a4c8899ee12bf", "filename": "gcc/testsuite/gdc.test/compilable/ice20092.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -7,4 +7,3 @@ void front(T)(T[] a)\n {\n     static assert(is(T == void));\n }\n-"}, {"sha": "e7f59ec9a00fef08f3772c0fb3345e53b0dc8566", "filename": "gcc/testsuite/gdc.test/compilable/imports/art4769a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ template DataStreamability(T)\n        printf(\"hallo\\n\");\n      }\n }\n-"}, {"sha": "a94f837385698f6bbae1af0b2fd6c550cbaf3c37", "filename": "gcc/testsuite/gdc.test/compilable/imports/art4769b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fart4769b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -6,4 +6,3 @@ int main(char [][] args)\n    Vector!(wchar) str;\n    return 0;\n }\n-"}, {"sha": "dc5f094ad9bc13f8306da05c682e4f5308013b99", "filename": "gcc/testsuite/gdc.test/compilable/imports/b33a.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb33a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb33a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb33a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,6 +23,3 @@ template find()\n         return find_!(char).fn( buf );\n     }\n }\n-\n-\n-"}, {"sha": "ab0a09aebdd66bf18108fa92cb873a9c8c780716", "filename": "gcc/testsuite/gdc.test/compilable/imports/b3682.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb3682.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb3682.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fb3682.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -2,4 +2,3 @@ module imports.b3682;\n \n import a3682;\n alias Tuple!(int) tint;\n-"}, {"sha": "e0be575821c78195a1e2226f4bcd0ad232ef5acc", "filename": "gcc/testsuite/gdc.test/compilable/imports/defaa.d", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefaa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefaa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefaa.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,6 +10,3 @@ class Display\n \n \tthis() { }\n }\n-\n-\n-"}, {"sha": "901dbd24462d6e79223ac7b756535b96ab8ab46c", "filename": "gcc/testsuite/gdc.test/compilable/imports/defab.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefab.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefab.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fdefab.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ public class B : A\n \n \tthis() {}\n }\n-"}, {"sha": "9a8ca4701a19327cbe723fef95dec3b2ea10f83a", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp16080.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp16080.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp16080.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp16080.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,3 @@\n struct A() {\n \tstatic immutable A a;\n }\n-"}, {"sha": "3befca402e0d51eb14ef8a0fff7e9010e1eef69b", "filename": "gcc/testsuite/gdc.test/compilable/imports/plainpackage/plainmodule.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fplainpackage%2Fplainmodule.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,3 @@\n /// Used to test is(x == module)\n \n module imports.plainpackage.plainmodule;\n-"}, {"sha": "807c6e76d4ab686ac586e86aad8d4e4d04f98e5e", "filename": "gcc/testsuite/gdc.test/compilable/imports/test11563std_traits.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest11563std_traits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest11563std_traits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest11563std_traits.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,4 +19,3 @@ template moduleName(alias T)\n         enum moduleName = \"--error--\";\n     }\n }\n-"}, {"sha": "c5599fd7a094e2aa07b20c629529c4837de7d97e", "filename": "gcc/testsuite/gdc.test/compilable/imports/test16709c.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709c.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,2 +1 @@\n void to(string units, D)(D td) { }\n-"}, {"sha": "922f59e0269309c4c0e963ac13eb5b985a388b15", "filename": "gcc/testsuite/gdc.test/compilable/imports/test16709d.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709d.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709d.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest16709d.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,2 +1 @@\n void to(T, D)(D td) { }\n-"}, {"sha": "827a56e71c452f99c86a777abf39e7203b207c4e", "filename": "gcc/testsuite/gdc.test/compilable/imports/test4003a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest4003a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest4003a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest4003a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,4 +3,3 @@ module imports.test4003a;\n import imports.typecons4003;\n \n Tuple!(string) t;\n-"}, {"sha": "9ec43dd12ae7929d45679723bfa95555bccce7b0", "filename": "gcc/testsuite/gdc.test/compilable/imports/test50a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest50a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest50a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest50a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,4 +3,3 @@ module imports.test50a;\n class Foo {\n         protected int a;\n }\n-"}, {"sha": "399e850c6d352fec04bba5cd02fe6477fdae8db7", "filename": "gcc/testsuite/gdc.test/compilable/imports/test55a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest55a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest55a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest55a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ class Arm2 {\n   alias int ListHead;\n   Queue2.ListHead mqueue;\n }\n-"}, {"sha": "36c838d1acae02ed70c2f41d42a1c62105bd410e", "filename": "gcc/testsuite/gdc.test/compilable/imports/test62a.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest62a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest62a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest62a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,5 +11,3 @@ struct T()\n }\n \n alias T!() instance;\n-\n-"}, {"sha": "c60d8b4d0a6b0eccf0aabc24b902b1e352d3ddc7", "filename": "gcc/testsuite/gdc.test/compilable/imports/test63a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest63a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest63a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest63a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -7,4 +7,3 @@ struct s {\n     char[SIZE] a;\n \n }\n-"}, {"sha": "15fd6446cab96c382ac6ede4980269ca7c4418e0", "filename": "gcc/testsuite/gdc.test/compilable/imports/test67a.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest67a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest67a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest67a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -15,5 +15,3 @@ class Derived : Base\n         return null;\n     }\n }\n-\n-"}, {"sha": "c7176f0dcccc40fcc228107318a1d5bdda8c99d4", "filename": "gcc/testsuite/gdc.test/compilable/imports/test68a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest68a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest68a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest68a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -6,4 +6,3 @@ class OtherModuleClass\n         {\n         }\n }\n-"}, {"sha": "c774616ceb3f47e755da100627220ab692eff3ca", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276decl.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276decl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276decl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276decl.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ class TemplateDecl : OverloadableDecl\n {\n     mixin Visitors;\n }\n-"}, {"sha": "72e5e2e00ec2df56200676715cd931ef90e8130e", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276expr.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276expr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276expr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276expr.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ class Node\n class Expression : Node\n {\n }\n-"}, {"sha": "8b9473ecb5d221b4c1d59c6de987ceee796cbd97", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276parser.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276parser.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276parser.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276parser.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,3 @@\n module imports.test9276parser;\n \n public import imports.test9276expr, imports.test9276decl;\n-"}, {"sha": "0631683dc1f2ee45811a6e63c0c383ca13c2af67", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276sem.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276sem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276sem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276sem.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,4 +22,3 @@ import imports.test9276visitors;\n class OverloadableDecl : Declaration\n {\n }\n-"}, {"sha": "ede9261d96515e2b014384fcc668cb81d423b271", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276type.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276type.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276type.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276type.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ class Type : Expression     // <- note to Walter.\n class BasicType : Type\n {\n }\n-"}, {"sha": "22acb3e263688dcfda25bf79c4183a8979b2a991", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276util.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276util.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276util.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276util.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ template DownCastMethods(T...)\n {\n     enum x = _dgliteral!T;\n }\n-"}, {"sha": "8165104198b293b7e2b5a0d43b62041f26de8662", "filename": "gcc/testsuite/gdc.test/compilable/imports/test9276visitors.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276visitors.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276visitors.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest9276visitors.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -13,4 +13,3 @@ template DeepDup(T) if (is(T : BasicType))\n \n template DeepDup(T)\n {}\n-"}, {"sha": "268038c49ad13fd546a69ed6b0616c0176241df2", "filename": "gcc/testsuite/gdc.test/compilable/imports/wax16798.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fwax16798.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fwax16798.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fwax16798.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,3 @@\n module its.a.floorwax.wax16798;\n \n pragma(msg, \"it's a floor wax\");\n-"}, {"sha": "d41f123f3788be52a566086f42f3631fec702b5f", "filename": "gcc/testsuite/gdc.test/compilable/isreturnonstack.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fisreturnonstack.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -5,4 +5,3 @@ S test2();\n \n static assert(__traits(isReturnOnStack, test1) == false);\n static assert(__traits(isReturnOnStack, test2) == true);\n-"}, {"sha": "7bc16c806ffb357112583f69d25fb07147f2e53e", "filename": "gcc/testsuite/gdc.test/compilable/issue15478.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue15478.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue15478.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue15478.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -52,4 +52,3 @@ void test15478_3()\n     enum foo_bug = foo.bug;\n     Foo15478!int[foo_bug] baz; // OK\n }\n-"}, {"sha": "cdc9077fcdf8e6452f2c2162f0492a259fdd0255", "filename": "gcc/testsuite/gdc.test/compilable/issue21813b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21813b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21813b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21813b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ struct Target\n     OS os = defaultTargetOS();\n     @property isPOSIX() scope @nogc { }\n }\n-"}, {"sha": "73d3101b8356bfb33116c3e19c92822af1054648", "filename": "gcc/testsuite/gdc.test/compilable/json.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -191,7 +191,7 @@ struct SafeS\n \n     ref SafeS foo3() return scope\n     {\n-        return this;\n+        static SafeS s; return s;\n     }\n \n \tint* p;"}, {"sha": "419447d51438675986d4a8810e287480c028ea81", "filename": "gcc/testsuite/gdc.test/compilable/line.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fline.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -26,5 +26,3 @@ static assert(__FILE_FULL_PATH__[$ - 9 .. $] == \"newfile.d\");\n static assert(__LINE__ == 201);\n static assert(__FILE__ == \"newfile.d\");\n static assert(__FILE_FULL_PATH__[$ - 9 .. $] == \"newfile.d\");\n-\n-"}, {"sha": "a53805b4066f912e1ee3c613f7a161456b86c8e5", "filename": "gcc/testsuite/gdc.test/compilable/mixintype.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -52,4 +52,3 @@ void test4()\n     enum getStuff = q{ __traits(getMember,sb,\"fieldb\") };\n     auto b = Foo4!(mixin(getStuff));\n }\n-"}, {"sha": "1e0c5466353807f3ada5139b66d6097f1ac03173", "filename": "gcc/testsuite/gdc.test/compilable/test10073.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10073.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10073.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest10073.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -21,4 +21,3 @@ class Bar\n }\n \n class Foo {}    // NG\n-"}, {"sha": "46a41b207e6ed3798ea2687d64b3efb95ed79440", "filename": "gcc/testsuite/gdc.test/compilable/test1238.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest1238.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest1238.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest1238.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ void foo()\n {\n     int qwert = zuiop;\n }\n-"}, {"sha": "d99c69b4ed43809070135664a2c696dc0551344d", "filename": "gcc/testsuite/gdc.test/compilable/test12527.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest12527.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest12527.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest12527.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -5,4 +5,3 @@\n     static assert(Fun.stringof == \"void function() @safe\");\n     alias Del = void delegate() @safe;\n     static assert(Del.stringof == \"void delegate() @safe\");\n-"}, {"sha": "e4451b8ed9e282a2442b0d25a37ca842550a409f", "filename": "gcc/testsuite/gdc.test/compilable/test13193.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13193.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13193.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13193.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -123,4 +123,3 @@ void bindFunc() {ssllib.getSymbol();}\n     bindFunc();\n     bindFunc(); /* 100 */\n }\n-"}, {"sha": "47c8a83a23c035b0fb49c51e2543c0746465b6ad", "filename": "gcc/testsuite/gdc.test/compilable/test13194.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13194.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13194.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13194.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ union U13194\n {\n     static Object o = void;\n }\n-"}, {"sha": "9b09aac6a5e3ad84af202ecb33e84bd8dcc0ebf7", "filename": "gcc/testsuite/gdc.test/compilable/test13600.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13600.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13600.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13600.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ class Retry\n     {\n     }\n }\n-"}, {"sha": "557cec8aa575b6624e13fd3c9563a05eb9f79231", "filename": "gcc/testsuite/gdc.test/compilable/test13858.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13858.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13858.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13858.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void main()\n \n     foo();\n }\n-"}, {"sha": "d676d61de515a60f573e44ca74d583055235b16a", "filename": "gcc/testsuite/gdc.test/compilable/test15019.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15019.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15019.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15019.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -72,4 +72,3 @@ struct Vector(T, int N)\n             assert(false);\n     }\n }\n-"}, {"sha": "d546ad8ef17824548ef65f481c0ed3746ba5aebc", "filename": "gcc/testsuite/gdc.test/compilable/test15389_y.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15389_y.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15389_y.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15389_y.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -6,4 +6,3 @@ extern (C++, ns)\n {\n     class Y { test15389_x.ns.X b; }\n }\n-"}, {"sha": "46d6e664e067549d6710302039e1bf2bcf2d43fb", "filename": "gcc/testsuite/gdc.test/compilable/test15464.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15464.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15464.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15464.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,5 +18,3 @@ void main()\n {\n     issue15464!C15464();\n }\n-\n-"}, {"sha": "211a59530e73d20f70bab73380862d0200586ed1", "filename": "gcc/testsuite/gdc.test/compilable/test15565.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15565.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15565.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15565.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,3 +1,2 @@\n alias X2 = X;\n extern (C++, ns) struct X {}\n-"}, {"sha": "78cb420c84f73fe9a63b5e2c1b12b44bfd25baec", "filename": "gcc/testsuite/gdc.test/compilable/test15578.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15578.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15578.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15578.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -7,4 +7,3 @@ void f()\n     j = 0; // works as expected\n     k = 0; // Error: variable foo.ns.k is private\n }\n-"}, {"sha": "0271c0f567de68af64760be97ae04b26cb30efa5", "filename": "gcc/testsuite/gdc.test/compilable/test15762.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15762.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15762.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15762.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ void main() @safe {\n \tauto d = cast(const(ubyte)[]) c;\n \tauto e = cast(const(Windows1252Char)[]) c;\n }\n-"}, {"sha": "8649efa6019ebeea05368d1511285305523ee468", "filename": "gcc/testsuite/gdc.test/compilable/test15898.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15898.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15898.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest15898.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -24,4 +24,3 @@ void mulKaratsuba(int[] result, const(int)[] x, const(int)[] y, int[] )\n \n     addAssignSimple(resultHigh[1..$], newscratchbuff[0..y1.length]);\n }\n-"}, {"sha": "2b0ebc94839a75440f8a25183a5b2449a2413240", "filename": "gcc/testsuite/gdc.test/compilable/test16037.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16037.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16037.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16037.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,5 +19,3 @@ auto f() @nogc\n     scope h=&g;\n     h();\n }\n-\n-"}, {"sha": "6520127726ed3573ff07c03d5670679cef21a9bd", "filename": "gcc/testsuite/gdc.test/compilable/test16080.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16080.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16080.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16080.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -4,4 +4,3 @@\n // https://issues.dlang.org/show_bug.cgi?id=16080\n \n import imp16080;\n-"}, {"sha": "777dcee9c69c6e649e4182a1427d86f00c9e0eff", "filename": "gcc/testsuite/gdc.test/compilable/test16225.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16225.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16225.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16225.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ struct C\n         return ((cast(ubyte*)&y)[1]);\n     }\n }\n-"}, {"sha": "5d5d4dac8b18deab6ef3b85962f64c312efd5597", "filename": "gcc/testsuite/gdc.test/compilable/test16798.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16798.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16798.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest16798.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ it's a dessert topping\n \n import its.a.floorwax.wax16798;\n import its.a.dessert.topping;\n-"}, {"sha": "0e615c8049ef9238dfe38d88421ad5d8e3407ff0", "filename": "gcc/testsuite/gdc.test/compilable/test17057.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17057.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17057.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17057.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ void main()\n {\n     static assert([__traits(allMembers, LeClass)] == [\"toString\", \"toHash\", \"opCmp\", \"opEquals\", \"Monitor\", \"factory\"]);\n }\n-"}, {"sha": "81884227a298698c2200f82210fadfb76cf75043", "filename": "gcc/testsuite/gdc.test/compilable/test17421.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17421.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17421.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17421.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ static assert(__traits(getFunctionVariadicStyle, typesafe) == \"typesafe\");\n \n static assert(__traits(getFunctionVariadicStyle, (int[] a...) {}) == \"typesafe\");\n static assert(__traits(getFunctionVariadicStyle, typeof(cstyle)) == \"stdarg\");\n-"}, {"sha": "14aceaaf006e12ead670c5986bec9d4cea23dbe6", "filename": "gcc/testsuite/gdc.test/compilable/test17468.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17468.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17468.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17468.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ struct S\n         }\n }\n const S CONST_S = S(\"/tmp\".ptr);\n-"}, {"sha": "641943612fdaa1f04fbab5f228959f4b3e521395", "filename": "gcc/testsuite/gdc.test/compilable/test17512.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17512.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17512.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17512.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,4 +23,3 @@ struct S0(T)\n }\n \n alias B = S0!int;\n-"}, {"sha": "8d7ec3952f9e493af03b5532169baad6d7ee951c", "filename": "gcc/testsuite/gdc.test/compilable/test17942.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17942.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17942.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17942.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ void test()\n enum B = AliasSeq!(2);\n \n enum C = AliasSeq!();\n-"}, {"sha": "6a7a36a1a6ae54e2684764bb20a7443253f1ebb6", "filename": "gcc/testsuite/gdc.test/compilable/test18020.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18020.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18020.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18020.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -5,4 +5,4 @@ void bug(T)(T t)\n     t.opCmp(t);\n }\n \n-alias bugi = bug!(typeof(new class{}));\n\\ No newline at end of file\n+alias bugi = bug!(typeof(new class{}));"}, {"sha": "2007c831aa2753252916e8131469359ab4943c66", "filename": "gcc/testsuite/gdc.test/compilable/test18584.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18584.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18584.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18584.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ struct S {\n struct tmp(alias fns) {\n     alias fun = fns!int;\n }\n-"}, {"sha": "82dff1b14800cc58e000ea73d28178bbc5986743", "filename": "gcc/testsuite/gdc.test/compilable/test18936.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18936.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18936.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18936.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -28,4 +28,3 @@ struct S\n         return c;\n     }\n }\n-"}, {"sha": "4cbe6b8934ca1265d4b08c8acdb0cd3febdc103f", "filename": "gcc/testsuite/gdc.test/compilable/test19203.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19203.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19203.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19203.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -24,4 +24,3 @@ void test()\n     static assert(!hasPopBack!Bar);\n     static assert( hasPopBack!Foo && !hasPopBack!Bar);\n }\n-"}, {"sha": "6ff5349f3338b1a48a6b24230c38632dce046053", "filename": "gcc/testsuite/gdc.test/compilable/test19227.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19227.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19227.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19227.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -26,4 +26,3 @@ void main()\n     static assert(T.init is T.init);\n     static assert(T.init != T.init);\n }\n-"}, {"sha": "4d7854e87bb7cd6b7dce0694372a593a3c3ccd43", "filename": "gcc/testsuite/gdc.test/compilable/test20596.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20596.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20596.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20596.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -27,5 +27,3 @@ void test3032() @nogc\n     scope fp = (){ n = 10; };       // no closure\n     fp();\n }\n-\n-"}, {"sha": "0e9b8f3ecdc1b5b8d38f1fb960b5ad462bc55238", "filename": "gcc/testsuite/gdc.test/compilable/test20653.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20653.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20653.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20653.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void main ()\n {\n     assert(myFunc!int() == 0);\n }\n-"}, {"sha": "d45801ead1f0564830804a1cf317a1936ab2ea28", "filename": "gcc/testsuite/gdc.test/compilable/test20717.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20717.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20717.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20717.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,17 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20717\n+\n+/*\n+TEST_OUTPUT:\n+---\n+false\n+---\n+*/\n+\n+pragma(msg, is(typeof({\n+    struct S\n+    {\n+        struct Foo {}\n+        struct Bar() {}\n+        alias Bar = Foo;\n+    }\n+})));"}, {"sha": "e5426314858d159099def00b227a3c33e2db6e70", "filename": "gcc/testsuite/gdc.test/compilable/test20906.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20906.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20906.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20906.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ int test12()\n     int d = !x ? 1 : 1 / x;\n     return a | b | c;\n }\n-"}, {"sha": "0036e1441caa2880cf740272e35fde6c31bbfc99", "filename": "gcc/testsuite/gdc.test/compilable/test20990.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20990.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20990.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20990.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void bar(int* ptr)\n     assert(ptr);\n     *ptr = 42;\n }\n-"}, {"sha": "a889aa9c8d2ba322ee7147fd30e0794772d7d560", "filename": "gcc/testsuite/gdc.test/compilable/test22639.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22639.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22639.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22639.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,26 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22639\n+\n+struct A\n+{\n+    this(ref return scope A rhs) inout {}\n+    this(ref return scope const A rhs, int b = 7) inout\n+    {\n+        if (b != 7) {\n+            this.b = b;\n+        }\n+    }\n+\n+    this(this) @disable;\n+\n+    int a=4;\n+    int b=3;\n+}\n+\n+void main()\n+{\n+    A a = A();\n+    A c = A(a, 10);\n+    A d = void;\n+    d.__ctor(a, 200);\n+    A* b = new A(a, 10);\n+}"}, {"sha": "4da6fd145666219a70bf0113556bb73024c29130", "filename": "gcc/testsuite/gdc.test/compilable/test22665.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,5 +18,3 @@ E foo3(E e)\n {\n     return E.A; // with qualification, it is an enum\n }\n-\n-"}, {"sha": "7820eae348a42741903fb81748d29c4b68255408", "filename": "gcc/testsuite/gdc.test/compilable/test22825.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22825.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22825.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22825.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,4 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22825\n+#line /*\n+         multi-line comment\n+*/ 42"}, {"sha": "b5b318c329e0d6f91718ab786e369268cb817e58", "filename": "gcc/testsuite/gdc.test/compilable/test22859.d", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22859.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22859.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22859.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,40 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22859\n+private struct __InoutWorkaroundStruct {}\n+@property T rvalueOf(T)(T val) { return val; }\n+@property T rvalueOf(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);\n+@property ref T lvalueOf(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init);\n+\n+// taken from std.traits.isAssignable\n+template isAssignable(Lhs, Rhs = Lhs)\n+{\n+    enum isAssignable = __traits(compiles, lvalueOf!Lhs = rvalueOf!Rhs) && __traits(compiles, lvalueOf!Lhs = lvalueOf!Rhs);\n+}\n+\n+// taken from std.meta.allSatisfy\n+template allSatisfy(alias F, T...)\n+{\n+    static foreach (Ti; T)\n+    {\n+        static if (!is(typeof(allSatisfy) == bool) && // not yet defined\n+                   !F!(Ti))\n+        {\n+            enum allSatisfy = false;\n+        }\n+    }\n+    static if (!is(typeof(allSatisfy) == bool)) // if not yet defined\n+    {\n+        enum allSatisfy = true;\n+    }\n+}\n+\n+struct None{}\n+\n+class C1\n+{\n+    static if(allSatisfy!(isAssignable, None, C2)) {}\n+}\n+\n+class C2\n+{\n+    static if(allSatisfy!(isAssignable, None, C1, C2)) {}\n+}"}, {"sha": "543dd88d0e9bdeff322c4696122a66e9d5ba0679", "filename": "gcc/testsuite/gdc.test/compilable/test22860.d", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22860.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22860.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22860.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,62 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22860\n+class C1\n+{\n+    SumType!(C1, C2) field;\n+}\n+\n+class C2\n+{\n+    SumType!(SumType!(C1, C2)) field;\n+}\n+\n+alias AliasSeq(TList...) = TList;\n+\n+template allSatisfy(alias F, T...)\n+{\n+    static foreach (Ti; T)\n+    {\n+        static if (!F!Ti)\n+            enum allSatisfy = false;\n+    }\n+}\n+\n+struct This {}\n+\n+enum isAssignableTo(T) = isAssignable!T;\n+enum isHashable(T) = __traits(compiles, { T.init; });\n+\n+struct SumType(Types...)\n+{\n+    alias Types = AliasSeq!(ReplaceTypeUnless!(isSumTypeInstance, This, typeof(this), TemplateArgsOf!SumType));\n+\n+    static foreach (T; Types)\n+    {\n+        static if (isAssignableTo!T)\n+        {\n+        }\n+    }\n+\n+    static if (allSatisfy!(isAssignableTo, Types))\n+    {\n+    }\n+\n+    static if (allSatisfy!(isHashable, Types))\n+        size_t toHash;\n+}\n+\n+bool isSumTypeInstance;\n+\n+alias TemplateArgsOf(T : Base!Args, alias Base, Args...) = Args;\n+enum isAssignable(Lhs, Rhs = Lhs) = isRvalueAssignable!(Lhs, Rhs) ;\n+enum isRvalueAssignable(Lhs, Rhs ) = __traits(compiles, { lvalueOf!Lhs = Rhs; });\n+\n+struct __InoutWorkaroundStruct{}\n+T lvalueOf(T)(__InoutWorkaroundStruct );\n+\n+template ReplaceTypeUnless(alias pred, From, To, T...)\n+{\n+    static if (T.length == 1)\n+        alias ReplaceTypeUnless = T;\n+    static if (T.length > 1)\n+        alias ReplaceTypeUnless = AliasSeq!(ReplaceTypeUnless!(pred, From, To, T[1 ]));\n+}"}, {"sha": "8844ed0e9414f0b81a495814d575abf4d078c667", "filename": "gcc/testsuite/gdc.test/compilable/test22919.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22919.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22919.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22919.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,17 @@\n+// REQUIRED_ARGS: -checkaction=context -preview=dip1000\n+\n+// Issue 22919 - [dip1000] -checkaction=context gives \"assigned to `__assertOp2` with longer lifetime\" (\n+// https://issues.dlang.org/show_bug.cgi?id=22919\n+\n+@safe:\n+struct S\n+{\n+    int* p;\n+    ref S get() scope return {return this;}\n+}\n+\n+void main()\n+{\n+    scope S arr = S();\n+    assert(arr == arr.get());\n+}"}, {"sha": "da05dc58454088e6d945268098363a3f4c404051", "filename": "gcc/testsuite/gdc.test/compilable/test3775.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3775.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3775.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest3775.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -5,5 +5,3 @@ struct Bug3775 {\n }\n \n static assert(cast(int)Bug3775.byLine == 1);\n-\n-"}, {"sha": "08bf7b370c69b1a618e503611827b578908fe432", "filename": "gcc/testsuite/gdc.test/compilable/test4003.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4003.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4003.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4003.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -4,4 +4,3 @@\n \n import imports.stdio4003;\n void main(){}\n-"}, {"sha": "2a132fb109dea9e8ad04d0ada246f2f60c3a3232", "filename": "gcc/testsuite/gdc.test/compilable/test4375.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest4375.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -471,4 +471,3 @@ void f() {\n     else\n         x = null;\n }\n-"}, {"sha": "356b3536e8ab453aa0b04b880b512cb79ba91502", "filename": "gcc/testsuite/gdc.test/compilable/test50.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest50.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest50.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest50.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -6,5 +6,3 @@ import imports.test50a;\n class Bar : Foo {\n         alias typeof(Foo.tupleof) Bleh;\n }\n-\n-"}, {"sha": "befb947ad277a127a5e479259157af91f1f17fc6", "filename": "gcc/testsuite/gdc.test/compilable/test5227.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5227.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5227.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest5227.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -128,5 +128,3 @@ pragma(msg, \"fma()\");\n enum fmaf = fma(-3.2f, 5.2f, 3.8f); //pragma(msg, fmaf);\n enum fmad = fma(-3.2 , 5.2 , 3.8 ); //pragma(msg, fmad);\n enum fmar = fma(-3.2L, 5.2L, 3.8L); pragma(msg, fmar);\n-\n-"}, {"sha": "c87f88308c66d4d9eefbdfff610d021cbaea4bd6", "filename": "gcc/testsuite/gdc.test/compilable/test602.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest602.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest602.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest602.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -409,4 +409,3 @@ void test13321(bool b)\n     x = Foo(1);\n   EXIT:\n }\n-"}, {"sha": "603348c76b3d1a7c32a1e3b79d6876b3659e86b3", "filename": "gcc/testsuite/gdc.test/compilable/test6089.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6089.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6089.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6089.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,4 +3,3 @@ void main()\n {\n     extern int[1][1] foo;\n }\n-"}, {"sha": "55b2e478bed7d1d4f3b198bf43b90f3060946892", "filename": "gcc/testsuite/gdc.test/compilable/test63.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest63.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest63.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest63.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -4,4 +4,3 @@\n private import imports.test63a;\n \n const int SIZE = 7;\n-"}, {"sha": "6504097d4994371d05b92ec19cfb1004cb19d387", "filename": "gcc/testsuite/gdc.test/compilable/test6395.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6395.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6395.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest6395.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -5,4 +5,3 @@\n // https://issues.dlang.org/show_bug.cgi?id=6395\n \n import c6395;\n-"}, {"sha": "bedbd26768c56cd745d37ca07f300ebfc0c66552", "filename": "gcc/testsuite/gdc.test/compilable/test66.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest66.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest66.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest66.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ class Lexer\n {\n     Token token;\n }\n-"}, {"sha": "bafc567d21523e9490c7b2fad297c673d87a8d59", "filename": "gcc/testsuite/gdc.test/compilable/test67.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest67.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest67.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest67.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ interface I\n interface SubI : I\n {\n }\n-"}, {"sha": "1631642fb3eaca06758029dff1ea1fa4a15df5d3", "filename": "gcc/testsuite/gdc.test/compilable/test68.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest68.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest68.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest68.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main()\n {\n         new Foo();\n }\n-"}, {"sha": "8961ba1a71520a7bf2a4b8105b6e077b5f0cd6b5", "filename": "gcc/testsuite/gdc.test/compilable/test7399.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7399.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7399.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7399.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,4 +3,3 @@ static assert(!__traits(compiles, { import non.existing.file; }));\n \n // https://issues.dlang.org/show_bug.cgi?id=7400\n static assert(!is(typeof({import non_existing_file;})));\n-"}, {"sha": "d29c9ed995ecafe7dd182a258e73aec0f09f96a0", "filename": "gcc/testsuite/gdc.test/compilable/test8296.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8296.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8296.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8296.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -30,4 +30,4 @@ class Foo\n void main(string[] args)\n {\n   auto foo = new Foo();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "408c6e9571dcb386a7224f0d6f1e5510ef72f65d", "filename": "gcc/testsuite/gdc.test/compilable/test8922b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -7,4 +7,3 @@ void test()\n     enum x = __traits(parent, imports.bug8922).stringof;\n     static assert(x == \"package imports\");\n }\n-"}, {"sha": "87ec51adfd82fa508463d4a30af8a65974762e85", "filename": "gcc/testsuite/gdc.test/compilable/test8922d.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922d.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922d.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest8922d.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ void test()\n     enum x = __traits(parent, imports.bug8922).stringof;\n     static assert(x == \"package imports\");\n }\n-"}, {"sha": "ca2acb6733a9d334bd98b1ff0ace297339c23e3a", "filename": "gcc/testsuite/gdc.test/compilable/test9057.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9057.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9057.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9057.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,5 +16,3 @@ void test9507_2() {\n     import imp9057_2;\n     Bug9057!(BugInt) xxx;\n }\n-\n-"}, {"sha": "2b3f8dcef33e70811b755fb2163e4d4b05ff7894", "filename": "gcc/testsuite/gdc.test/compilable/test9436.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9436.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9436.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest9436.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,4 +1,3 @@\n // EXTRA_SOURCES: imports/test9436interp.d\n // EXTRA_FILES: imports/test9436aggr.d imports/test9436node.d imports/test9436type.d\n // this is a dummy module for test 9436.\n-"}, {"sha": "a7f698dc8521b69199737f76d98a6c31c1547c4a", "filename": "gcc/testsuite/gdc.test/compilable/testAliasLookup.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestAliasLookup.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestAliasLookup.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestAliasLookup.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -57,4 +57,3 @@ struct S16082\n         return aliasthis;  // Line 20\n     }\n }\n-"}, {"sha": "31b10494148f6510b9cc0018abce357312718487", "filename": "gcc/testsuite/gdc.test/compilable/testInference.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2FtestInference.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -818,4 +818,3 @@ void test13840() nothrow\n }\n \n // Add more tests regarding inferences later.\n-"}, {"sha": "6b0f775c5bcf76e1229ce5c41d1294a736c4288b", "filename": "gcc/testsuite/gdc.test/compilable/testprofile.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestprofile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestprofile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestprofile.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,4 +20,3 @@ void main() {\n                 \"lala\", \"lala\", \"lala\", \"lala\");\n \n }\n-"}, {"sha": "0d0af2e61f0609eea2b932bd796dac68c3f7317c", "filename": "gcc/testsuite/gdc.test/compilable/testsctreturn.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestsctreturn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestsctreturn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestsctreturn.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -32,4 +32,3 @@ struct S\n         return &i;\n     }\n }\n-"}, {"sha": "a0aa0526a2271f993a94291e2dca729a474cbd70", "filename": "gcc/testsuite/gdc.test/compilable/typeid_name.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftypeid_name.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftypeid_name.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftypeid_name.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ class Tiger : Panzer {}\n static assert (() {\n     Panzer p = new Tiger(); return classname(p);\n } () == \"Tiger\");\n-"}, {"sha": "46736772730a33b89a4ae5f31be262e6b5f79143", "filename": "gcc/testsuite/gdc.test/compilable/vcg-ast.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fvcg-ast.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -61,4 +61,3 @@ void main()\n {\n     values!wchar_t;\n }\n-"}, {"sha": "86d06cbd5237690f2a62009a7d4e3659e40d82b1", "filename": "gcc/testsuite/gdc.test/compilable/version.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fversion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fversion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fversion.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,4 +20,4 @@ version (D_TypeInfo)\n else\n {\n     static assert(0);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "44e4c80e806689ebd6856e2f44fa9a243f6ed351", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug5.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ int test1()\n     if (false)\n         return 0;\n }\n-"}, {"sha": "487f22efde12dd6d57a288b23dbe9880babd141e", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug5b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ fail_compilation/bug5b.d(8): Error: function `bug5b.test1` has no `return` state\n int test1()\n {\n }\n-"}, {"sha": "f456454fe8716a4063c74bed9a5460e572f1c669", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug9631.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -108,4 +108,3 @@ void targ()\n     void ft2(T)(S, T){}\n     ft2(y, 1);\n }\n-"}, {"sha": "176295fea71f466ab6d1878a68287767de9ec2ee", "filename": "gcc/testsuite/gdc.test/fail_compilation/circ10280.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcirc10280.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcirc10280.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcirc10280.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ fail_compilation/circ10280.d(10):        called from here: `foo10280()`\n \n const int q10280 = foo10280();\n int foo10280() { return q10280; }\n-"}, {"sha": "aa61e2bb21c2c486bbe9645ccbdb4064267e23f8", "filename": "gcc/testsuite/gdc.test/fail_compilation/ctfe11467.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfe11467.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfe11467.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fctfe11467.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -49,4 +49,3 @@ int test11467d()\n }\n static assert(test11467c());\n static assert(test11467d());\n-"}, {"sha": "553a0c64a20af59cde7821d4fa75c6feaffd21e0", "filename": "gcc/testsuite/gdc.test/fail_compilation/dephexstrings.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdephexstrings.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -7,4 +7,3 @@ fail_compilation/dephexstrings.d(9): Error: declaration expected, not `\"60\"`\n ---\n */\n enum xstr = x\"60\";\n-"}, {"sha": "7b219cb48bb21fea0c7bec4739a6a3f18e18eddb", "filename": "gcc/testsuite/gdc.test/fail_compilation/deprecated6760.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecated6760.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecated6760.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdeprecated6760.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ class Bar\n {\n     deprecated override bool opEquals(Object);\n }\n-"}, {"sha": "526e185b6ac1ff6d3c432821f0a64b42e0842055", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag12640.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12640.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12640.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12640.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -27,4 +27,3 @@ void main()\n     }\n \n }\n-"}, {"sha": "6447f5e59962c577815ce13bb171e7d8c21a8948", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14145.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14145.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -34,5 +34,3 @@ struct Capture(alias c)\n         return *ptr;\n     }\n }\n-\n-"}, {"sha": "1677fafa0d3969bcf0ea2bcb099abb39c10ef332", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag16271.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ void main()\n {\n     auto fun = ref x;\n }\n-"}, {"sha": "0ab51422ba1c055740af31c64481f7f1ccf41b85", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag1730.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag1730.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag1730.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag1730.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -100,4 +100,3 @@ void main()\n     scObj.scFunc();\n     scObj.wFunc(); // ng\n }\n-"}, {"sha": "f051d075da249a6009743c4bc018b3e6aaed2649", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag18574.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag18574.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag18574.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag18574.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ class Bar {}\n class Baz { int a; }\n \n class Test : Foo, Bar, Baz, int {}\n-"}, {"sha": "de994719852643e23285b2dc289f3129182b7163", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8510.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8510.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8510.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8510.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ struct S {\n     alias g a;\n     alias g a;\n }\n-"}, {"sha": "4f8ea23a91d22f7810fc93ef4d46cabd757781ef", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip25.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,8 +3,8 @@ REQUIRED_ARGS: -de\n TEST_OUTPUT:\n ---\n fail_compilation/dip25.d(17): Deprecation: returning `this.buffer[]` escapes a reference to parameter `this`\n-fail_compilation/dip25.d(17):        perhaps annotate the function with `return`\n-fail_compilation/dip25.d(22): Error: returning `identity(x)` escapes a reference to local variable `x`\n+fail_compilation/dip25.d(15):        perhaps annotate the function with `return`\n+fail_compilation/dip25.d(22): Error: returning `identity(x)` escapes a reference to parameter `x`\n fail_compilation/dip25.d(23): Deprecation: returning `identity(x)` escapes a reference to parameter `x`\n fail_compilation/dip25.d(23):        perhaps annotate the parameter with `return`\n ---"}, {"sha": "52b5285b83b8347a9fdc756d0ea78db04f50dd2e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10905.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10905.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10905.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10905.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,4 +20,3 @@ struct Bar\n         return x == Foo.y;\n     }\n }\n-"}, {"sha": "41cddbf33dd3634e825f94de010af2f83ec4237d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11163.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11163.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11163.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11163.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ void main() {\n     immutable a = foo();\n     pragma(msg, a);\n }\n-"}, {"sha": "3df797d6b8fbaf6baa3b4e9be3f04051c2823541", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail118.d", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,8 +1,15 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail118.d(26): Error: invalid `foreach` aggregate `Iter`, define `opApply()`, range primitives, or use `.tupleof`\n-fail_compilation/fail118.d(27): Error: invalid `foreach` aggregate `Iter`, define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/fail118.d(43): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n+fail_compilation/fail118.d(43):        maybe define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/fail118.d(44): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n+fail_compilation/fail118.d(44):        maybe define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/fail118.d(47): Error: invalid `foreach` aggregate `s` of type `S*`\n+fail_compilation/fail118.d(49): Error: undefined identifier `unknown`\n+fail_compilation/fail118.d(37): Error: undefined identifier `doesNotExist`\n+fail_compilation/fail118.d(51): Error: template instance `fail118.error!()` error instantiating\n+fail_compilation/fail118.d(51): Error: invalid `foreach` aggregate `error()` of type `void`\n ---\n */\n \n@@ -20,9 +27,26 @@ class Foo\n     mixin opHackedApply!() oldIterMix;\n }\n \n+struct S\n+{\n+    int opApply(scope int delegate(const int) dg);\n+}\n+\n+auto error()()\n+{\n+    doesNotExist();\n+}\n+\n void main()\n {\n     Foo f = new Foo;\n     foreach (int i; f.oldIterMix.Iter) {}\n     foreach (    i; f.oldIterMix.Iter) {}\n+\n+    S* s;\n+    foreach (const i; s) {}\n+\n+    foreach(const i; unknown) {}\n+\n+    foreach (const i; error()) {}\n }"}, {"sha": "d752d3822caf3c500711f1b817b0b8441d96a7bb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail12.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main()\n     mixin Foo!(y);\n     assert(abc() == 8);\n }\n-"}, {"sha": "78176e84f436d98b58359f25b1bc23d0c217c49b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail131.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail131.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail131.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail131.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail131.d(8): Error: function `D main` parameters must be `main()` or `main(string[] args)`\n+fail_compilation/fail131.d(8): Error: function `D main` parameter list must be empty or accept one parameter of type `string[]`\n ---\n */\n "}, {"sha": "12a6b6e42f41e8011ca04f60fb6b4f56e12d072e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail13902.d", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13902.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13902.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail13902.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -54,14 +54,14 @@ int* testEscape1()\n TEST_OUTPUT:\n ---\n fail_compilation/fail13902.d(88): Error: Using the result of a comma expression is not allowed\n-fail_compilation/fail13902.d(75): Error: returning `& x` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(76): Error: returning `&s1.v` escapes a reference to local variable `s1`\n-fail_compilation/fail13902.d(81): Error: returning `& sa1` escapes a reference to local variable `sa1`\n-fail_compilation/fail13902.d(82): Error: returning `&sa2[0][0]` escapes a reference to local variable `sa2`\n-fail_compilation/fail13902.d(83): Error: returning `& x` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(84): Error: returning `(& x+4)` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(85): Error: returning `& x + cast(long)x * 4L` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(88): Error: returning `& y` escapes a reference to local variable `y`\n+fail_compilation/fail13902.d(75): Error: returning `& x` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(76): Error: returning `&s1.v` escapes a reference to parameter `s1`\n+fail_compilation/fail13902.d(81): Error: returning `& sa1` escapes a reference to parameter `sa1`\n+fail_compilation/fail13902.d(82): Error: returning `&sa2[0][0]` escapes a reference to parameter `sa2`\n+fail_compilation/fail13902.d(83): Error: returning `& x` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(84): Error: returning `(& x+4)` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(85): Error: returning `& x + cast(long)x * 4L` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(88): Error: returning `& y` escapes a reference to parameter `y`\n ---\n */\n int* testEscape2(\n@@ -134,9 +134,9 @@ int* testEscape3(\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail13902.d(150): Error: returning `cast(int[])sa1` escapes a reference to local variable `sa1`\n-fail_compilation/fail13902.d(151): Error: returning `cast(int[])sa1` escapes a reference to local variable `sa1`\n-fail_compilation/fail13902.d(152): Error: returning `sa1[]` escapes a reference to local variable `sa1`\n+fail_compilation/fail13902.d(150): Error: returning `cast(int[])sa1` escapes a reference to parameter `sa1`\n+fail_compilation/fail13902.d(151): Error: returning `cast(int[])sa1` escapes a reference to parameter `sa1`\n+fail_compilation/fail13902.d(152): Error: returning `sa1[]` escapes a reference to parameter `sa1`\n fail_compilation/fail13902.d(155): Error: returning `cast(int[])sa2` escapes a reference to local variable `sa2`\n fail_compilation/fail13902.d(156): Error: returning `cast(int[])sa2` escapes a reference to local variable `sa2`\n fail_compilation/fail13902.d(157): Error: returning `sa2[]` escapes a reference to local variable `sa2`\n@@ -223,14 +223,14 @@ ref int testEscapeRef1()\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail13902.d(240): Error: returning `x` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(241): Error: returning `s1.v` escapes a reference to local variable `s1`\n-fail_compilation/fail13902.d(245): Error: returning `sa1[0]` escapes a reference to local variable `sa1`\n-fail_compilation/fail13902.d(246): Error: returning `sa2[0][0]` escapes a reference to local variable `sa2`\n-fail_compilation/fail13902.d(247): Error: returning `x = 1` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(248): Error: returning `x += 1` escapes a reference to local variable `x`\n-fail_compilation/fail13902.d(249): Error: returning `s1.v = 1` escapes a reference to local variable `s1`\n-fail_compilation/fail13902.d(250): Error: returning `s1.v += 1` escapes a reference to local variable `s1`\n+fail_compilation/fail13902.d(240): Error: returning `x` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(241): Error: returning `s1.v` escapes a reference to parameter `s1`\n+fail_compilation/fail13902.d(245): Error: returning `sa1[0]` escapes a reference to parameter `sa1`\n+fail_compilation/fail13902.d(246): Error: returning `sa2[0][0]` escapes a reference to parameter `sa2`\n+fail_compilation/fail13902.d(247): Error: returning `x = 1` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(248): Error: returning `x += 1` escapes a reference to parameter `x`\n+fail_compilation/fail13902.d(249): Error: returning `s1.v = 1` escapes a reference to parameter `s1`\n+fail_compilation/fail13902.d(250): Error: returning `s1.v += 1` escapes a reference to parameter `s1`\n ---\n */\n ref int testEscapeRef2(\n@@ -324,8 +324,8 @@ int[] testSlice2() { int[3] sa; int n; return sa[n..2][1..2]; }\n TEST_OUTPUT:\n ---\n fail_compilation/fail13902.d(324): Error: returning `vda[0]` escapes a reference to parameter `vda`\n-fail_compilation/fail13902.d(324):        perhaps annotate the parameter with `return`\n ---\n+\n */\n ref int testDynamicArrayVariadic1(int[] vda...) { return vda[0]; }\n @safe int[]   testDynamicArrayVariadic2(int[] vda...) { return vda[]; }\n@@ -334,7 +334,7 @@ int[3]  testDynamicArrayVariadic3(int[] vda...) { return vda[0..3]; }   // no er\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail13902.d(335): Error: returning `vsa[0]` escapes a reference to local variable `vsa`\n+fail_compilation/fail13902.d(335): Error: returning `vsa[0]` escapes a reference to parameter `vsa`\n fail_compilation/fail13902.d(336): Error: returning `vsa[]` escapes a reference to variadic parameter `vsa`\n ---\n */"}, {"sha": "35312454960b7c61649deac829fd5a46e5f9b2dc", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail14486.d", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14486.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14486.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14486.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -3,18 +3,30 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail14486.d(35): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(36): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(41): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(42): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(47): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(48): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(53): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(54): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(59): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(60): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(65): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n-fail_compilation/fail14486.d(66): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n+fail_compilation/fail14486.d(47): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(47):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(48): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(48):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(53): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(53):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(54): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(54):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(59): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(59):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(60): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(60):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(65): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(65):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(66): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(66):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(71): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(71):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(72): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(72):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(77): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(77):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n+fail_compilation/fail14486.d(78): Error: the `delete` keyword is obsolete\n+fail_compilation/fail14486.d(78):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n ---\n */\n "}, {"sha": "9d226de11265c3cde656f8ff6890e36819002ff2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,5 +23,3 @@ void main()\n     mixin Test!() xs;\n     bool x = xs[false];\n }\n-\n-"}, {"sha": "10033edaf210d28aebd8106d1195c72aba4db46a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail15691.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15691.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15691.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail15691.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,5 +20,3 @@ void main()\n             bc: 4, // line 20\n         };\n }\n-\n-"}, {"sha": "f462a13a585203c1fc7cff0a099252b98761062b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -24,4 +24,3 @@ void main()\n {\n   foo!(i);\n }\n-"}, {"sha": "9abe59f835b90657007cdbe0ec5debf83ddce9c7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail160.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail160.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail160.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail160.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -23,4 +23,3 @@ int main(char[][] args)\n \n     return 0;\n }\n-"}, {"sha": "dc480cffb5668295541eb48701f6fe05df729ec4", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16001.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16001.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16001.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16001.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ void main() {\n \tauto fail = () => {};\n \tauto ok = () => () {};\n }\n-"}, {"sha": "eb341c64af5f86277a7b0aa49be350b4c7a7039c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail16600.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16600.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16600.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail16600.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,5 +22,3 @@ void main()\n     auto a = const(S)(\"abc\");\n     assert(a.i == 2);\n }\n-\n-"}, {"sha": "daec0f26d9c44ab9309a81fcd0f1cd27f3d11a23", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,5 +12,3 @@ struct A(T)\n }\n \n A!(int) x;\n-\n-"}, {"sha": "6ab31efabc3081bb053dc41784e9b2ed6df49f89", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17275.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17275.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17275.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17275.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ struct ThreadDSO\n     DSO* _pdso;\n     void[] _tlsRange;\n }\n-"}, {"sha": "97ee3624839bcb23cbb43077180df82516e90269", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17419.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17419.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17419.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17419.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ fail_compilation/fail17419.d(11): Error: expected 1 arguments for `getLinkage` b\n \n enum s = __traits(getLinkage, 8 * 8);\n enum t = __traits(getLinkage, 8, 8);\n-"}, {"sha": "f18193798de53af53c266a9b36f075d259cae5f3", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17421.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17421.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17421.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17421.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -13,4 +13,3 @@ alias int* x;\n \n static assert(__traits(getFunctionVariadicStyle, 1) == \"none\");\n static assert(__traits(getFunctionVariadicStyle, x) == \"none\");\n-"}, {"sha": "734f8d795e072ca40145be4b6a428ceba77fd752", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17842.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17842.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17842.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17842.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -25,5 +25,3 @@ Object testobj(scope Object obj) @safe\n     array ~= arr;\n     return array[0];\n }\n-\n-"}, {"sha": "41f7465557fbd3af1147ed0f7e5361b30e00438a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17906.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17906.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17906.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17906.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,8 @@\n // REQUIRED_ARGS: -de\n /* TEST_OUTPUT:\n ---\n-fail_compilation/fail17906.d(11): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n+fail_compilation/fail17906.d(12): Error: the `delete` keyword is obsolete\n+fail_compilation/fail17906.d(12):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n ---\n */\n // https://issues.dlang.org/show_bug.cgi?id=18647"}, {"sha": "410f307770661eead7096f158389aebfd53d2f73", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17927.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,8 +11,8 @@ fail_compilation/fail17927.d(23): Error: scope variable `ptr` may not be returne\n \n struct String {\n     const(char)* mem1() const scope @safe { return ptr; }\n-\n-    inout(char)* mem2() inout scope @safe { return ptr; } // no error because `ref inout` implies `return`\n+    // https://issues.dlang.org/show_bug.cgi?id=22027\n+    inout(char)* mem2() inout scope @safe { return ptr; }\n \n     char* ptr;\n }\n@@ -21,4 +21,3 @@ struct String {\n const(char)* foo1(scope const(char)* ptr) @safe { return ptr; }\n \n inout(char)* foo2(scope inout(char)* ptr) @safe { return ptr; }\n-"}, {"sha": "36611bbffd6789fd5f342cbd7bba39606840f9b0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19441.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19441.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19441.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19441.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -46,4 +46,3 @@ void main()\n         assert(wrap[0].s.test());  // failure\n     }\n }\n-"}, {"sha": "abc4fea2e99bc0cacfe7e5367fab1e7d48125297", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19744.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19744.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19744.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19744.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail19744.d(8): Error: Top-level function `test` has no `this` to which `return` can apply\n+fail_compilation/fail19744.d(8): Error: top-level function `test` has no `this` to which `return` can apply\n ---\n */\n "}, {"sha": "ccdbb5708176bc85c162cfb7add64a6f505f56d1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19898a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ void f (__vector(int[4]) n)\n     foreach (i; 0 .. n)\n         cast(void)n;\n }\n-"}, {"sha": "254c2cad02818b75c3d3572c7ebae138c4cfbafd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19898b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19898b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void f (__vector(int[4]) n, S m)\n     foreach (i; m .. n)\n         cast(void)n;\n }\n-"}, {"sha": "a7309fecc718d24d50a169f212555556dd043363", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19922.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19922.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19922.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19922.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -15,4 +15,3 @@ void test()\n     Object o;\n     auto ti = typeid(o);\n }\n-"}, {"sha": "e118d3d61e391b18c006b2626a87c54352b42219", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19923.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19923.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19923.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19923.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -15,4 +15,3 @@ void test()\n     Object o;\n     auto ti = o.classinfo;\n }\n-"}, {"sha": "22f64337a91dcaf3070ea1d491cf6be82cb86149", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20084.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20084.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20084.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20084.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,7 @@\n /* REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/fail20084.d(109): Error: returning `v.front()` escapes a reference to local variable `v`\n+fail_compilation/fail20084.d(109): Error: returning `v.front()` escapes a reference to parameter `v`\n ---\n */\n "}, {"sha": "6e51706adde8da232891c057b1888df8efe65c31", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail201.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail201.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail201.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail201.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ void main() {\n         int c;\n         c = c >>> 33;\n }\n-"}, {"sha": "ebd806052366b101327a2e74802f98819cd345be", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail202.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail202.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail202.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail202.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ void main() {\n         int c;\n         c = c >> 33;\n }\n-"}, {"sha": "ecbe5952992a3b8b11777554599ce0d9ed463414", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail203.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail203.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail203.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail203.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -9,4 +9,3 @@ void main() {\n         int c;\n         c = c << 33;\n }\n-"}, {"sha": "79a8206cfd05e63045eb2ba3f39aca750e2afc2c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail204.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail204.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail204.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail204.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ void main() {\n         long c;\n         c >>= 65;\n }\n-"}, {"sha": "916ee8bbc077b1139d042f901a0ef70c04dfd44f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20448.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20448.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20448.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20448.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail20448.d(16): Error: returning `p.x` escapes a reference to local variable `p`\n+fail_compilation/fail20448.d(16): Error: returning `p.x` escapes a reference to parameter `p`\n fail_compilation/fail20448.d(22): Error: template instance `fail20448.member!\"x\"` error instantiating\n ---\n */"}, {"sha": "2e8a6262fa27266bb4d8f782e639f52da4351535", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail205.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail205.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail205.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail205.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ void main() {\n         long c;\n         c <<= 65;\n }\n-"}, {"sha": "88c90cb7ee015dcfe31bd86c02d75e30f9077ef0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail206.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail206.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail206.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail206.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -8,4 +8,3 @@ void main() {\n         long c;\n         c >>>= 65;\n }\n-"}, {"sha": "026b7c2df0a3c805555ba6387d958b92af5cbaa1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20800.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20800.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20800.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20800.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -21,4 +21,3 @@ void initCommands()\n {\n     fun(m.index);\n }\n-"}, {"sha": "11ad76fabdcdaa72d17157226b48fd186ed684b0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail217.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail217.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail217.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail217.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -22,4 +22,3 @@ main()\n     auto m2 = new immutable(Message)(2);\n     m2.notifier = 3;\n   }\n-"}, {"sha": "687a727263447b57f064235c10549c3ba71c7c7f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21868b.d", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21868b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21868b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21868b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail21868b.d(19): Error: returning `&s.x` escapes a reference to parameter `s`\n-fail_compilation/fail21868b.d(19):        perhaps remove `scope` parameter annotation so `return` applies to `ref`\n+fail_compilation/fail21868b.d(17):        perhaps change the `return scope` into `scope return`\n ---\n */\n \n@@ -18,5 +18,3 @@ int* test(ref return scope S s)\n {\n     return &s.x;\n }\n-\n-"}, {"sha": "bd34c56ebcc5758e978a00702dc6f4c63d41fd6b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22118.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22118.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22118.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22118.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -33,4 +33,3 @@ struct S\n         v.a = arg;   // this should not\n     }\n }\n-"}, {"sha": "d8d1093fe043a9838da0bcb470b31ec0c9b52a88", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22825a.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22825\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail22825a.d(10): Error: positive integer argument expected following `#line`\n+fail_compilation/fail22825a.d(11): Error: declaration expected, not `42`\n+---\n+*/\n+#line /*\n+         multi-line comment\n+*/\n+42"}, {"sha": "faac8b4045e473dbcd474427f8cb5137840331fc", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22825b.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22825b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -0,0 +1,13 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22825\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail22825b.d(7): Error: declaration expected, not `#`\n+---\n+*/\n+#\n+                 line\n+\n+\n+\n+\n+12"}, {"sha": "ffc12f1631ee53248733bbd8b8f5495e15b52b57", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail2361.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2361.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2361.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2361.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail2361.d(13): Error: The `delete` keyword is obsolete.  Use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.\n+fail_compilation/fail2361.d(14): Error: the `delete` keyword is obsolete\n+fail_compilation/fail2361.d(14):        use `object.destroy()` (and `core.memory.GC.free()` if applicable) instead\n ---\n */\n "}, {"sha": "a0d1940908e7a00a750115763ce4ae12d06a0806", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail249.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail249.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail249.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail249.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail249.d(16): Error: invalid `foreach` aggregate `bar()`\n+fail_compilation/fail249.d(16): Error: invalid `foreach` aggregate `bar()` of type `void`\n ---\n */\n "}, {"sha": "dd1d2f32769a333d0f18d6bff4713d6b504eed55", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail258.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail258.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail258.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail258.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ q\"\n X\n \n X\"\n-"}, {"sha": "cbada7c5d4396bb5cf783a892c12d359e6a01dfd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail259.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail259.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail259.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail259.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ class C\n     final\n         override void foo(){}\n }\n-"}, {"sha": "85da957290ce1c62e24345bdf1340de0fe8178be", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail261.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,7 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail261.d(18): Error: invalid `foreach` aggregate `range`, define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/fail261.d(19): Error: invalid `foreach` aggregate `range` of type `MyRange`\n+fail_compilation/fail261.d(19):        maybe define `opApply()`, range primitives, or use `.tupleof`\n ---\n */\n "}, {"sha": "77042cc111bec33a4c3e687fa89b639e747a9968", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail346.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail346.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -21,4 +21,3 @@ template V(R,int val){\n }\n \n const S x = V!(S,0);\n-"}, {"sha": "71e9143ab0bf98c74c9008403e385213d00b22ca", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail359.d", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail359.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail359.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail359.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -1,10 +1,8 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail359.d(8): Error: #line integer [\"filespec\"]\\n expected\n-fail_compilation/fail359.d(9): Error: no identifier for declarator `_BOOM`\n+fail_compilation/fail359.d(7): Error: invalid filename for `#line` directive\n ---\n */\n #line 5 _BOOM\n void main() { }\n-"}, {"sha": "1aafd96947c65f06987ceb5c642ad58cf4a982e1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail3895.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3895.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3895.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail3895.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ void main() {\n     float[] otherStuff;\n     otherStuff ~= stuff;\n }\n-"}, {"sha": "be59e1f72b00272f86c950b14499bc586b3390bf", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4269a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ interface A {\n     B blah;\n     void foo(B b){}\n }\n-"}, {"sha": "7c371d1d170eccb9a22195b6bff554e43ba9bdad", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4269b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ struct A {\n     B blah;\n     void foo(B b){}\n }\n-"}, {"sha": "c12f9b60b2cb0cb57c54db885a420c4efc5c533a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4269c.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269c.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -11,4 +11,3 @@ class A {\n     B blah;\n     void foo(B b){}\n }\n-"}, {"sha": "322bcb3289bbf79a57a375175487051265d4bbfe", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375a.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main() {\n     else\n         assert(4);\n }\n-"}, {"sha": "6e6b9b09262225bf4df973bbf428c94307320e59", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375b.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375b.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n     else\n         assert(6);\n }\n-"}, {"sha": "ef7a79272c9e2e319d387b576df1e7d51a0c185f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375c.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375c.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n         assert(6.2);\n     }\n }\n-"}, {"sha": "7b2740ac5207033558d2b22fe7d9e50c397f5500", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375d.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375d.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375d.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375d.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ label2:\n     else\n         assert(16);\n }\n-"}, {"sha": "1b7f7d29cfe5fd3c0b2f1de340a0c004885e5041", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375e.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375e.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375e.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375e.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main() {\n     else\n         assert(25);\n }\n-"}, {"sha": "c603bfa2262fe2f160e50826eb3770917db1cf75", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375f.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375f.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375f.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375f.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main() {\n     else\n         assert(25.2);\n }\n-"}, {"sha": "a3d7c85f7a5f8cb5e200d5d3f8cc0a2447de8066", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375g.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375g.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375g.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375g.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ void main() {\n     else\n         assert(34);\n }\n-"}, {"sha": "04833b1bc7385d7ef4388bb6fa201f68d701db35", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375h.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375h.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375h.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375h.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -20,4 +20,3 @@ void main() {\n             break;\n     }\n }\n-"}, {"sha": "2fe2bb718b1c8a1b4b427bae511e9623c246c2bd", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375i.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375i.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375i.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375i.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n     else\n         assert(116);\n }\n-"}, {"sha": "89ad096dc7bcbe31830b2b1a7213ccc109bc223c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375j.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375j.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375j.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375j.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n     else\n         assert(120);\n }\n-"}, {"sha": "05ceb06c70c858900d2b2e860043a1b3c0b1ab94", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375k.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375k.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375k.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375k.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n             assert(55);\n     });\n }\n-"}, {"sha": "731ead64cc27183b2b599c8784d263fa713c3cc5", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375l.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375l.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375l.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375l.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void main() {\n     else\n         assert(71);\n }\n-"}, {"sha": "b5d1c1683161d28111acf18edd19c06ebfe560bb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375m.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375m.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375m.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375m.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void main() {\n             assert(77);\n     while (false);\n }\n-"}, {"sha": "3112de7d10f72cc28b4ca44b94358589f5eee885", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375o.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375o.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375o.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375o.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void main() {\n     else\n         assert(83);\n }\n-"}, {"sha": "62c61a4cb7a42de78cd7c2c73e7c301051cca132", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375p.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375p.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375p.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375p.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,4 +19,3 @@ void main() {\n     else\n         assert(89);\n }\n-"}, {"sha": "b02fbb169b749dfcde62f5023aa43b2dc0f7502d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375q.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375q.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375q.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375q.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ void main() {\n     else\n         assert(91);\n }\n-"}, {"sha": "865bd6dae8e35f04ef246b33c11a0de41645fc74", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375r.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375r.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375r.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375r.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,4 +19,3 @@ void main() {\n     else\n         assert(105);\n }\n-"}, {"sha": "972f27643af174c66a9fb8650b0428d18ae06e5f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375s.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375s.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375s.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375s.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -19,4 +19,3 @@ void main() {\n     else\n         assert(108);\n }\n-"}, {"sha": "07a79e57200f140838679e42f8e7fe5b62279562", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375t.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375t.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375t.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375t.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -16,4 +16,3 @@ unittest {  // disallowed\n     else\n         assert(53);\n }\n-"}, {"sha": "a3b22e950743fc80a0990fc8e4aa55873b9920db", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375u.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375u.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375u.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375u.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ static if (true)\n         struct G1 {}\n else\n     struct G2 {}\n-"}, {"sha": "2be98a61fbf3b8ddbaf5d234954a76bcc7066ed2", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375v.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375v.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375v.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375v.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ version (A)\n         struct G3 {}\n else\n     struct G4 {}\n-"}, {"sha": "eb0779f9c0e3a0d91dbb0bbf7dbe70dd89241053", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375w.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375w.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375w.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375w.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -14,4 +14,3 @@ static if (true)\n         struct G1 {}\n else\n     struct G2 {}\n-"}, {"sha": "6a5f9dbefd69dbf910fe08ad82fd8d55a348963a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375x.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375x.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375x.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375x.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -15,4 +15,3 @@ abstract:\n         class G5 {}\n else\n     class G6 {}\n-"}, {"sha": "28dc991469eec3083f6342152ea3a275410fac8e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4375y.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375y.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375y.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4375y.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -17,4 +17,3 @@ static if (true)\n                     void G10(){}\n else\n     void G11(){}\n-"}, {"sha": "826bdba6af104a34e4f461600f24070a09f8e337", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail44.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail44.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail44.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail44.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -18,4 +18,3 @@ void Foo()\n     foo[i] = bar[i];\n   }\n }\n-"}, {"sha": "c45a99031b548958973271db5f00eeec788603b9", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail47.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail47.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail47.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail47.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -12,4 +12,3 @@ void main()\n {\n     foo = 1;\n }\n-"}, {"sha": "15570554fac3bb455a594628d1f8aff1e2f4f350", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail58.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -33,4 +33,3 @@ int main(char[][] pArgs)\n     assert(sp == -1);\n     return 0;\n }\n-"}, {"sha": "42fb4acd0c9d8eec5ee7a1664f0f4f18728578a5", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail60.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -13,4 +13,3 @@ class A\n \n  B b=new B;\n }\n-"}, {"sha": "a21fbb78f2f0a0ff3503b6e1c760be341c7cc91d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail6107.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6107.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6107.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6107.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -13,4 +13,3 @@ class Bar\n {\n     int __ctor = 4;\n }\n-"}, {"sha": "38c4b007684c5a8c05a306bbf6d1e3e8a8a6a98f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7178.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7178.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235d5a96cb8dad0b4c427602346fcf966a4ec914/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7178.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7178.d?ref=235d5a96cb8dad0b4c427602346fcf966a4ec914", "patch": "@@ -10,4 +10,3 @@ template populate(overloads...)\n     mixin populate!(.contents);\n }\n public mixin populate!int;\n-"}]}