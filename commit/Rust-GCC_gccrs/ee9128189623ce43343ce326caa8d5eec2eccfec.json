{"sha": "ee9128189623ce43343ce326caa8d5eec2eccfec", "node_id": "C_kwDOANBUbNoAKGVlOTEyODE4OTYyM2NlNDMzNDNjZTMyNmNhYThkNWVlYzJlY2NmZWM", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-05-03T23:01:19Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-05-05T21:34:28Z"}, "message": "c++: wrong error with MVP and pushdecl [PR64679]\n\nThis patch fixes the second half of 64679.  Here we issue a wrong\n\"redefinition of 'int x'\" for the following:\n\n  struct Bar {\n    Bar(int, int, int);\n  };\n\n  int x = 1;\n  Bar bar(int(x), int(x), int{x}); // #1\n\ncp_parser_parameter_declaration_list does pushdecl every time it sees\na named parameter, so the second \"int(x)\" causes the error.  That's\npremature, since this turns out to be a constructor call after the\nthird argument!\n\nIf the first parameter is parenthesized, we can't push until we've\nestablished we're looking at a function declaration.  Therefore this\ncould be fixed by some kind of lookahead.  I thought about introducing a\nlightweight variant of cp_parser_parameter_declaration_list that would\nnot have any side effects and would return as soon as it figures out\nwhether it's looking at a declaration or expression.  Since that would\nrequire fairly nontrivial changes, I wanted something simpler.\n\nSomething like delaying the pushdecl until we've reached the ')'\nfollowing the parameter-declaration-clause.  But we must push the\nparameters before processing a default argument, as in:\n\n  Bar bar(int(a), int(b), int c = sizeof(a));  // valid\n\nMoreover, this code should still be accepted\n\n  Bar f(int(i), decltype(i) j = 42);\n\nso this patch stashes parameters into a vector when parsing tentatively\nonly when pushdecl-ing a parameter would result in a clash and an error\nabout redefinition/redeclaration.  The stashed parameters are pushed at\nthe end of a parameter-declaration-clause if it's followed by a ')', so\nthat we still diagnose redefining a parameter.\n\n\tPR c++/64679\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_parameter_declaration_clause): Maintain\n\ta vector of parameters that haven't been pushed yet.  Push them at the\n\tend of a valid parameter-declaration-clause.\n\t(cp_parser_parameter_declaration_list): Take a new auto_vec parameter.\n\tDo not pushdecl while parsing tentatively when pushdecl-ing a parameter\n\twould result in a hard error.\n\t(cp_parser_cache_defarg): Adjust the call to\n\tcp_parser_parameter_declaration_list.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/parse/ambig11.C: New test.\n\t* g++.dg/parse/ambig12.C: New test.\n\t* g++.dg/parse/ambig13.C: New test.\n\t* g++.dg/parse/ambig14.C: New test.", "tree": {"sha": "ef58825d663c7b9f11e105a11fd6deda7fc5a248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef58825d663c7b9f11e105a11fd6deda7fc5a248"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee9128189623ce43343ce326caa8d5eec2eccfec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9128189623ce43343ce326caa8d5eec2eccfec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee9128189623ce43343ce326caa8d5eec2eccfec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee9128189623ce43343ce326caa8d5eec2eccfec/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a48be2e513d9ddb2fa8800a158f18502a0923aec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a48be2e513d9ddb2fa8800a158f18502a0923aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a48be2e513d9ddb2fa8800a158f18502a0923aec"}], "stats": {"total": 161, "additions": 156, "deletions": 5}, "files": [{"sha": "3ebaa414a3dfb1ad331fd3e97d9bb598e0c94f86", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=ee9128189623ce43343ce326caa8d5eec2eccfec", "patch": "@@ -2391,7 +2391,7 @@ static void cp_parser_type_specifier_seq\n static tree cp_parser_parameter_declaration_clause\n   (cp_parser *, cp_parser_flags);\n static tree cp_parser_parameter_declaration_list\n-  (cp_parser *, cp_parser_flags);\n+  (cp_parser *, cp_parser_flags, auto_vec<tree> *);\n static cp_parameter_declarator *cp_parser_parameter_declaration\n   (cp_parser *, cp_parser_flags, bool, bool *);\n static tree cp_parser_default_argument\n@@ -24517,8 +24517,12 @@ cp_parser_parameter_declaration_clause (cp_parser* parser,\n       return explicit_void_list_node;\n     }\n \n+  /* A vector of parameters that haven't been pushed yet.  */\n+  auto_vec<tree> pending_decls;\n+\n   /* Parse the parameter-declaration-list.  */\n-  parameters = cp_parser_parameter_declaration_list (parser, flags);\n+  parameters = cp_parser_parameter_declaration_list (parser, flags,\n+\t\t\t\t\t\t     &pending_decls);\n   /* If a parse error occurred while parsing the\n      parameter-declaration-list, then the entire\n      parameter-declaration-clause is erroneous.  */\n@@ -24548,6 +24552,15 @@ cp_parser_parameter_declaration_clause (cp_parser* parser,\n   else\n     ellipsis_p = false;\n \n+  /* A valid parameter-declaration-clause can only be followed by a ')'.\n+     So it's time to push all the parameters we have seen now that we\n+     know we have a valid declaration.  Note that here we may not have\n+     committed yet, nor should we.  Pushing here will detect the error\n+     of redefining a parameter.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+    for (tree p : pending_decls)\n+      pushdecl (p);\n+\n   /* Finish the parameter list.  */\n   if (!ellipsis_p)\n     parameters = chainon (parameters, void_list_node);\n@@ -24562,13 +24575,16 @@ cp_parser_parameter_declaration_clause (cp_parser* parser,\n      parameter-declaration-list , parameter-declaration\n \n    The parser flags FLAGS is used to control type-specifier parsing.\n+   PENDING_DECLS is a vector of parameters that haven't been pushed yet.\n \n    Returns a representation of the parameter-declaration-list, as for\n    cp_parser_parameter_declaration_clause.  However, the\n    `void_list_node' is never appended to the list.  */\n \n static tree\n-cp_parser_parameter_declaration_list (cp_parser* parser, cp_parser_flags flags)\n+cp_parser_parameter_declaration_list (cp_parser* parser,\n+\t\t\t\t      cp_parser_flags flags,\n+\t\t\t\t      auto_vec<tree> *pending_decls)\n {\n   tree parameters = NULL_TREE;\n   tree *tail = &parameters;\n@@ -24625,7 +24641,37 @@ cp_parser_parameter_declaration_list (cp_parser* parser, cp_parser_flags flags)\n \t\t\t       parameter->decl_specifiers.attributes,\n \t\t\t       0);\n       if (DECL_NAME (decl))\n-\tdecl = pushdecl (decl);\n+\t{\n+\t  /* We cannot always pushdecl while parsing tentatively because\n+\t     it may have side effects and we can't be sure yet if we're\n+\t     parsing a declaration, e.g.:\n+\n+\t       S foo(int(x), int(x), int{x});\n+\n+\t     where it's not clear if we're dealing with a constructor call\n+\t     or a function declaration until we've seen the last argument\n+\t     which breaks it up.\n+\t     It's safe to pushdecl so long as it doesn't result in a clash\n+\t     with an already-pushed parameter.  But we don't delay pushing\n+\t     different parameters to handle\n+\n+\t       S foo(int(i), decltype(i) j = 42);\n+\n+\t     which is valid.  */\n+\t  if (pending_decls\n+\t      && cp_parser_uncommitted_to_tentative_parse_p (parser)\n+\t      /* See if PARAMETERS already contains a parameter with the same\n+\t\t DECL_NAME as DECL.  */\n+\t      && [parameters, decl] {\n+\t\t   for (tree p = parameters; p; p = TREE_CHAIN (p))\n+\t\t     if (DECL_NAME (decl) == DECL_NAME (TREE_VALUE (p)))\n+\t\t       return true;\n+\t\t   return false;\n+\t\t }())\n+\t    pending_decls->safe_push (decl);\n+\t  else\n+\t    decl = pushdecl (decl);\n+\t}\n \n       if (decl != error_mark_node)\n \t{\n@@ -34072,7 +34118,8 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t  begin_scope (sk_function_parms, NULL_TREE);\n \t\t  tree t = cp_parser_parameter_declaration_list\n-\t\t\t    (parser, CP_PARSER_FLAGS_NONE);\n+\t\t\t    (parser, CP_PARSER_FLAGS_NONE,\n+\t\t\t     /*pending_decls*/nullptr);\n \t\t  if (t == error_mark_node)\n \t\t    error = true;\n \t\t  pop_bindings_and_leave_scope ();"}, {"sha": "51a586f40b0de6621eed37cf5591f2c81cf456ca", "filename": "gcc/testsuite/g++.dg/parse/ambig11.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig11.C?ref=ee9128189623ce43343ce326caa8d5eec2eccfec", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/64679\n+// { dg-do run { target c++11 } }\n+\n+struct Bar {\n+  int a, b, c;\n+  Bar(int a, int b, int c) : a(a), b(b), c(c) { }\n+};\n+\n+void\n+f ()\n+{\n+  Bar fn1(int(a), int(b), int c = sizeof(a));\n+  Bar fn2(int(x), int(y), int(z)); // { dg-warning \"function declaration\" }\n+  Bar fn3(int(x), int(y), int);\n+  Bar fn4(int (*p)(int(x), int(y))); // { dg-warning \"function declaration\" }\n+  Bar fn5(int (x), int (*p)(int(x), int(y)), int);\n+}\n+\n+int\n+main ()\n+{\n+  int x = 1;\n+  // This ain't a decl.\n+  Bar v1(int(x), int(x), int{x});\n+  if (v1.a != 1 || v1.b != v1.a || v1.c != v1.a)\n+    __builtin_abort ();\n+  Bar v2(int(x), int(x), 1);\n+  if (v2.a != 1 || v2.b != v2.a || v2.c != 1)\n+    __builtin_abort ();\n+  Bar v3(int(x), int(x), int(1));\n+  if (v3.a != 1 || v3.b != v3.a || v3.c != 1)\n+    __builtin_abort ();\n+  Bar v4(int(1), int(x), int{x});\n+  if (v4.a != 1 || v4.b != 1 || v4.c != 1)\n+    __builtin_abort ();\n+  Bar v5(int{x}, int(x), int{x});\n+  if (v5.a != 1 || v5.b != v5.a || v5.c != v5.a)\n+    __builtin_abort ();\n+}"}, {"sha": "981f35f32a2cf4c6bfa7158c75cfd80d3356a53c", "filename": "gcc/testsuite/g++.dg/parse/ambig12.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig12.C?ref=ee9128189623ce43343ce326caa8d5eec2eccfec", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/64679\n+\n+struct Bar {\n+  Bar (int, int, int);\n+};\n+\n+void\n+g ()\n+{\n+  Bar e1(int(x), int(x), int); // { dg-error \"redefinition\" }\n+  Bar e2(int (*p)(int(x), int(x)), int); // { dg-error \"redefinition\" }\n+}"}, {"sha": "5f6a3b934c2ee91daeac3d4722a5d8a5abb50f94", "filename": "gcc/testsuite/g++.dg/parse/ambig13.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig13.C?ref=ee9128189623ce43343ce326caa8d5eec2eccfec", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/64679\n+// { dg-do compile { target c++11 } }\n+\n+struct Bar {\n+  Bar (int, int, int);\n+};\n+\n+template<typename T>\n+void\n+g ()\n+{\n+  int x = 1;\n+  Bar v1(T(x), T(x), T{x});\n+  Bar v2(T(x), T(x), T(1));\n+}\n+\n+void\n+invoke (Bar (*p)) noexcept(noexcept(*p))\n+{\n+}\n+\n+auto\n+pmf (int (Bar::*p)) -> decltype(p)\n+{\n+  return nullptr;\n+}\n+\n+void\n+f ()\n+{\n+  g<int>();\n+}"}, {"sha": "0305596a8354c6260f9f0226be34e6f4768b4f67", "filename": "gcc/testsuite/g++.dg/parse/ambig14.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee9128189623ce43343ce326caa8d5eec2eccfec/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fambig14.C?ref=ee9128189623ce43343ce326caa8d5eec2eccfec", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/64679\n+// { dg-do compile { target c++11 } }\n+\n+struct F {\n+  F(int, int);\n+};\n+\n+void\n+g ()\n+{\n+  int x = 42;\n+  \n+  F v1(int(x), decltype(x)(42));\n+\n+  F f1(int(i), decltype(i) j = 42);\n+  F f2(int(i), decltype(i) j);\n+  F f3(int(i), decltype(i)(j));\t// { dg-warning \"function declaration\" }\n+  F f4(int(i), decltype(i)(j) = 42); // { dg-warning \"function declaration\" }\n+  F f5(int (i), bool b = true, decltype(i) j = 42);\n+  F f6(int(i), decltype(x)(x)); // { dg-warning \"function declaration\" }\n+}"}]}