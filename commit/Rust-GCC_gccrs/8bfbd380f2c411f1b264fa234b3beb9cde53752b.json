{"sha": "8bfbd380f2c411f1b264fa234b3beb9cde53752b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJmYmQzODBmMmM0MTFmMWIyNjRmYTIzNGIzYmViOWNkZTUzNzUyYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:25:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:25:16Z"}, "message": "[multiple changes]\n\n2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb: Minor code clean up.\n\n2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n\n\t* debug.adb, sem_ch13.adb (Analyze_Enumeration_Representation_Clause):\n\tIgnore enumeration rep clauses by default in CodePeer mode, unless\n\t-gnatd.I is specified.\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Safe_To_Capture_Value): If the node belongs to\n\tan expression that has been attached to the else_actions of an\n\tif-expression, the capture is not safe.\n\n2013-04-11  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb (Apply_Type_Conversion_Checks): Put check mark on type\n\tconversion for arrays.\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb: Minor reformatting.\n\n2013-04-11  Johannes Kanig  <kanig@adacore.com>\n\n\t* adabkend.adb: Minor comment addition.\n\nFrom-SVN: r197773", "tree": {"sha": "add533dd995b0231de167243dc46dd6fa2c83c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/add533dd995b0231de167243dc46dd6fa2c83c3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bfbd380f2c411f1b264fa234b3beb9cde53752b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bfbd380f2c411f1b264fa234b3beb9cde53752b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bfbd380f2c411f1b264fa234b3beb9cde53752b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bfbd380f2c411f1b264fa234b3beb9cde53752b/comments", "author": null, "committer": null, "parents": [{"sha": "256f384717333836e09eb881ecbb787ee6916191", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/256f384717333836e09eb881ecbb787ee6916191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/256f384717333836e09eb881ecbb787ee6916191"}], "stats": {"total": 1126, "additions": 587, "deletions": 539}, "files": [{"sha": "547ca6859830a4866e176a1acec613c0ea87609b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -1,3 +1,32 @@\n+2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb: Minor code clean up.\n+\n+2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* debug.adb, sem_ch13.adb (Analyze_Enumeration_Representation_Clause):\n+\tIgnore enumeration rep clauses by default in CodePeer mode, unless\n+\t-gnatd.I is specified.\n+\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Safe_To_Capture_Value): If the node belongs to\n+\tan expression that has been attached to the else_actions of an\n+\tif-expression, the capture is not safe.\n+\n+2013-04-11  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb (Apply_Type_Conversion_Checks): Put check mark on type\n+\tconversion for arrays.\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb: Minor reformatting.\n+\n+2013-04-11  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* adabkend.adb: Minor comment addition.\n+\n 2013-04-11  Matthew Heaney  <heaney@adacore.com>\n \n \t* a-cdlili.adb, a-cidlli.adb, a-cbdlli.adb (\"=\"): Increment"}, {"sha": "f3e8c8bee30c586eff3b05e2d7da22d1f17f40ee", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 74, "deletions": 84, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -156,6 +156,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       LR := LR - 1;\n \n       return Result;\n+\n    exception\n       when others =>\n          BL := BL - 1;\n@@ -359,20 +360,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n-      declare\n-         N : Node_Type renames Container.Nodes (Position.Node);\n-      begin\n-         return (Element => N.Element'Access);\n-      end;\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end if;\n    end Constant_Reference;\n \n    --------------\n@@ -397,10 +398,8 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Capacity = 0 then\n          C := Source.Length;\n-\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-\n       else\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n@@ -508,7 +507,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.First;\n          pragma Assert (N (N (X).Next).Prev = Container.First);\n \n@@ -547,7 +546,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.Last;\n          pragma Assert (N (N (X).Prev).Next = Container.Last);\n \n@@ -569,11 +568,12 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       if Position.Node = 0 then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Element\");\n \n-      return Position.Container.Nodes (Position.Node).Element;\n+         return Position.Container.Nodes (Position.Node).Element;\n+      end if;\n    end Element;\n \n    --------------\n@@ -585,7 +585,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       if Object.Container /= null then\n          declare\n             B : Natural renames Object.Container.all.Busy;\n-\n          begin\n             B := B - 1;\n          end;\n@@ -648,6 +647,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -664,9 +664,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Container.First = 0 then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.First);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.First);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -699,9 +699,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Container.First = 0 then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Nodes (Container.First).Element;\n       end if;\n-\n-      return Container.Nodes (Container.First).Element;\n    end First_Element;\n \n    ----------\n@@ -858,6 +858,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          L := L - 1;\n \n          return Result;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -962,6 +963,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n             SB := SB - 1;\n             SL := SL - 1;\n+\n          exception\n             when others =>\n                TB := TB - 1;\n@@ -1076,6 +1078,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n             B := B - 1;\n             L := L - 1;\n+\n          exception\n             when others =>\n                B := B - 1;\n@@ -1287,7 +1290,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             Process (Cursor'(Container'Unrestricted_Access, Node));\n             Node := Container.Nodes (Node).Next;\n          end loop;\n-\n       exception\n          when others =>\n             B := B - 1;\n@@ -1315,9 +1317,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       --  for a reverse iterator, Container.Last is the beginning.\n \n       return It : constant Iterator :=\n-        Iterator'(Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => 0)\n+                    Iterator'(Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                                Node      => 0)\n       do\n          B := B + 1;\n       end return;\n@@ -1380,9 +1382,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Container.Last = 0 then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.Last);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Last);\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n@@ -1415,9 +1417,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Container.Last = 0 then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Nodes (Container.Last).Element;\n       end if;\n-\n-      return Container.Nodes (Container.Last).Element;\n    end Last_Element;\n \n    ------------\n@@ -1536,13 +1538,12 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       declare\n          Nodes : Node_Array renames Position.Container.Nodes;\n          Node  : constant Count_Type := Nodes (Position.Node).Next;\n-\n       begin\n          if Node = 0 then\n             return No_Element;\n+         else\n+            return Cursor'(Position.Container, Node);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n    end Next;\n \n@@ -1553,14 +1554,12 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1599,9 +1598,9 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n       begin\n          if Node = 0 then\n             return No_Element;\n+         else\n+            return Cursor'(Position.Container, Node);\n          end if;\n-\n-         return Cursor'(Position.Container, Node);\n       end;\n    end Previous;\n \n@@ -1612,14 +1611,12 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -1680,20 +1677,19 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n       if N < 0 then\n          raise Program_Error with \"bad list length (corrupt stream)\";\n-      end if;\n \n-      if N = 0 then\n+      elsif N = 0 then\n          return;\n-      end if;\n \n-      if N > Item.Capacity then\n+      elsif N > Item.Capacity then\n          raise Constraint_Error with \"length exceeds capacity\";\n-      end if;\n \n-      for Idx in 1 .. N loop\n-         Allocate (Item, Stream, New_Node => X);\n-         Insert_Internal (Item, Before => 0, New_Node => X);\n-      end loop;\n+      else\n+         for Idx in 1 .. N loop\n+            Allocate (Item, Stream, New_Node => X);\n+            Insert_Internal (Item, Before => 0, New_Node => X);\n+         end loop;\n+      end if;\n    end Read;\n \n    procedure Read\n@@ -1731,20 +1727,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-      declare\n-         N : Node_Type renames Container.Nodes (Position.Node);\n-      begin\n-         return (Element => N.Element'Access);\n-      end;\n+         declare\n+            N : Node_Type renames Container.Nodes (Position.Node);\n+         begin\n+            return (Element => N.Element'Access);\n+         end;\n+      end if;\n    end Reference;\n \n    ---------------------\n@@ -1759,21 +1755,20 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      elsif Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is locked)\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-      Container.Nodes (Position.Node).Element := New_Item;\n+         Container.Nodes (Position.Node).Element := New_Item;\n+      end if;\n    end Replace_Element;\n \n    ----------------------\n@@ -1919,6 +1914,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1948,7 +1944,6 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n             Process (Cursor'(Container'Unrestricted_Access, Node));\n             Node := Container.Nodes (Node).Prev;\n          end loop;\n-\n       exception\n          when others =>\n             B := B - 1;\n@@ -1977,31 +1972,26 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n          pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n-      if Target'Address = Source'Address\n-        or else Source.Length = 0\n-      then\n+      if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n-      end if;\n \n-      if Target.Length > Count_Type'Last - Source.Length then\n+      elsif Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n \n-      if Target.Length + Source.Length > Target.Capacity then\n+      elsif Target.Length + Source.Length > Target.Capacity then\n          raise Capacity_Error with \"new length exceeds target capacity\";\n-      end if;\n \n-      if Target.Busy > 0 then\n+      elsif Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n \n-      if Source.Busy > 0 then\n+      elsif Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n \n-      Splice_Internal (Target, Before.Node, Source);\n+      else\n+         Splice_Internal (Target, Before.Node, Source);\n+      end if;\n    end Splice;\n \n    procedure Splice\n@@ -2583,7 +2573,7 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n \n          pragma Assert (N (Position.Node).Prev /= 0);\n \n-         --  ELiminate another possibility\n+         --  Eliminate another possibility\n \n          if Position.Node = L.Last then\n             return True;"}, {"sha": "e7333d8927575630b52128edd921de2b985ac9be", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 195, "deletions": 198, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -135,6 +135,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       LR := LR - 1;\n \n       return Result;\n+\n    exception\n       when others =>\n          BL := BL - 1;\n@@ -404,6 +405,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          Free (X);\n       end loop;\n \n+      --  The following comment is unacceptable, more detail needed ???\n+\n       Position := No_Element;  --  Post-York behavior\n    end Delete;\n \n@@ -432,7 +435,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n            \"attempt to tamper with cursors (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.First;\n          pragma Assert (X.Next.Prev = Container.First);\n \n@@ -470,7 +473,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n            \"attempt to tamper with cursors (list is busy)\";\n       end if;\n \n-      for I in 1 .. Count loop\n+      for J in 1 .. Count loop\n          X := Container.Last;\n          pragma Assert (X.Prev.Next = Container.Last);\n \n@@ -492,11 +495,11 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       if Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Element\");\n \n-      return Position.Node.Element;\n+         return Position.Node.Element;\n+      end if;\n    end Element;\n \n    --------------\n@@ -549,9 +552,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n+         else\n+            pragma Assert (Vet (Position), \"bad cursor in Find\");\n          end if;\n-\n-         pragma Assert (Vet (Position), \"bad cursor in Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n@@ -572,9 +575,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             if Node.Element = Item then\n                Result := Node;\n                exit;\n+            else\n+               Node := Node.Next;\n             end if;\n-\n-            Node := Node.Next;\n          end loop;\n \n          B := B - 1;\n@@ -585,6 +588,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -601,9 +605,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Container.First = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.First);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.First);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -636,9 +640,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Container.First = null then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.First.Element;\n       end if;\n-\n-      return Container.First.Element;\n    end First_Element;\n \n    ----------\n@@ -647,7 +651,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    procedure Free (X : in out Node_Access) is\n       procedure Deallocate is\n-         new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+        new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n+\n    begin\n       --  While a node is in use, as an active link in a list, its Previous and\n       --  Next components must be null, or designate a different node; this is\n@@ -708,6 +713,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          L := L - 1;\n \n          return Result;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -803,6 +809,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n             SB := SB - 1;\n             SL := SL - 1;\n+\n          exception\n             when others =>\n                TB := TB - 1;\n@@ -830,9 +837,10 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          ---------------\n \n          procedure Partition (Pivot : Node_Access; Back : Node_Access) is\n-            Node : Node_Access := Pivot.Next;\n+            Node : Node_Access;\n \n          begin\n+            Node := Pivot.Next;\n             while Node /= Back loop\n                if Node.Element < Pivot.Element then\n                   declare\n@@ -913,6 +921,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n             B := B - 1;\n             L := L - 1;\n+\n          exception\n             when others =>\n                B := B - 1;\n@@ -954,34 +963,33 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Before.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong list\";\n+         else\n+            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n          end if;\n-\n-         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n          Position := Before;\n          return;\n-      end if;\n \n-      if Container.Length > Count_Type'Last - Count then\n+      elsif Container.Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n \n-      if Container.Busy > 0 then\n+      elsif Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n-\n-      New_Node := new Node_Type'(New_Item, null, null);\n-      Insert_Internal (Container, Before.Node, New_Node);\n \n-      Position := Cursor'(Container'Unchecked_Access, New_Node);\n-\n-      for J in Count_Type'(2) .. Count loop\n+      else\n          New_Node := new Node_Type'(New_Item, null, null);\n          Insert_Internal (Container, Before.Node, New_Node);\n-      end loop;\n+\n+         Position := Cursor'(Container'Unchecked_Access, New_Node);\n+\n+         for J in 2 .. Count loop\n+            New_Node := new Node_Type'(New_Item, null, null);\n+            Insert_Internal (Container, Before.Node, New_Node);\n+         end loop;\n+      end if;\n    end Insert;\n \n    procedure Insert\n@@ -1009,9 +1017,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Before.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong list\";\n+         else\n+            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n          end if;\n-\n-         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n       end if;\n \n       if Count = 0 then\n@@ -1021,22 +1029,22 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       if Container.Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n \n-      if Container.Busy > 0 then\n+      elsif Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n-\n-      New_Node := new Node_Type;\n-      Insert_Internal (Container, Before.Node, New_Node);\n \n-      Position := Cursor'(Container'Unchecked_Access, New_Node);\n-\n-      for J in Count_Type'(2) .. Count loop\n+      else\n          New_Node := new Node_Type;\n          Insert_Internal (Container, Before.Node, New_Node);\n-      end loop;\n+\n+         Position := Cursor'(Container'Unchecked_Access, New_Node);\n+\n+         for J in 2 .. Count loop\n+            New_Node := new Node_Type;\n+            Insert_Internal (Container, Before.Node, New_Node);\n+         end loop;\n+      end if;\n    end Insert;\n \n    ---------------------\n@@ -1141,9 +1149,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       --  for a reverse iterator, Container.Last is the beginning.\n \n       return It : constant Iterator :=\n-        Iterator'(Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => null)\n+                    Iterator'(Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                                Node      => null)\n       do\n          B := B + 1;\n       end return;\n@@ -1169,31 +1177,31 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       if Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n-      end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      elsif Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong list\";\n-      end if;\n-\n-      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n \n-      --  The value of the Node component influences the behavior of the First\n-      --  and Last selector functions of the iterator object. When the Node\n-      --  component is non-null (as is the case here), it means that this\n-      --  is a partial iteration, over a subset of the complete sequence of\n-      --  items. The iterator object was constructed with a start expression,\n-      --  indicating the position from which the iteration begins. Note that\n-      --  the start position has the same value irrespective of whether this\n-      --  is a forward or reverse iteration.\n-\n-      return It : constant Iterator :=\n-        Iterator'(Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => Start.Node)\n-      do\n-         B := B + 1;\n-      end return;\n+      else\n+         pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+         --  The value of the Node component influences the behavior of the\n+         --  First and Last selector functions of the iterator object. When\n+         --  the Node component is non-null (as is the case here), it means\n+         --  that this is a partial iteration, over a subset of the complete\n+         --  sequence of items. The iterator object was constructed with\n+         --  a start expression, indicating the position from which the\n+         --  iteration begins. Note that the start position has the same value\n+         --  irrespective of whether this is a forward or reverse iteration.\n+\n+         return It : constant Iterator :=\n+                       Iterator'(Limited_Controlled with\n+                                   Container => Container'Unrestricted_Access,\n+                                 Node      => Start.Node)\n+         do\n+            B := B + 1;\n+         end return;\n+      end if;\n    end Iterate;\n \n    ----------\n@@ -1204,9 +1212,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Container.Last = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.Last);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Last);\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n@@ -1239,9 +1247,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Container.Last = null then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Last.Element;\n       end if;\n-\n-      return Container.Last.Element;\n    end Last_Element;\n \n    ------------\n@@ -1264,23 +1272,23 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Target'Address = Source'Address then\n          return;\n-      end if;\n \n-      if Source.Busy > 0 then\n+      elsif Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n \n-      Clear (Target);\n+      else\n+         Clear (Target);\n \n-      Target.First := Source.First;\n-      Source.First := null;\n+         Target.First := Source.First;\n+         Source.First := null;\n \n-      Target.Last := Source.Last;\n-      Source.Last := null;\n+         Target.Last := Source.Last;\n+         Source.Last := null;\n \n-      Target.Length := Source.Length;\n-      Source.Length := 0;\n+         Target.Length := Source.Length;\n+         Source.Length := 0;\n+      end if;\n    end Move;\n \n    ----------\n@@ -1296,20 +1304,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Node = null then\n          return No_Element;\n-      end if;\n-\n-      pragma Assert (Vet (Position), \"bad cursor in Next\");\n \n-      declare\n-         Next_Node : constant Node_Access := Position.Node.Next;\n-\n-      begin\n-         if Next_Node = null then\n-            return No_Element;\n-         end if;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Next\");\n \n-         return Cursor'(Position.Container, Next_Node);\n-      end;\n+         declare\n+            Next_Node : constant Node_Access := Position.Node.Next;\n+         begin\n+            if Next_Node = null then\n+               return No_Element;\n+            else\n+               return Cursor'(Position.Container, Next_Node);\n+            end if;\n+         end;\n+      end if;\n    end Next;\n \n    function Next\n@@ -1319,14 +1327,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1355,20 +1361,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Node = null then\n          return No_Element;\n-      end if;\n-\n-      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n \n-      declare\n-         Prev_Node : constant Node_Access := Position.Node.Prev;\n-\n-      begin\n-         if Prev_Node = null then\n-            return No_Element;\n-         end if;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Previous\");\n \n-         return Cursor'(Position.Container, Prev_Node);\n-      end;\n+         declare\n+            Prev_Node : constant Node_Access := Position.Node.Prev;\n+         begin\n+            if Prev_Node = null then\n+               return No_Element;\n+            else\n+               return Cursor'(Position.Container, Prev_Node);\n+            end if;\n+         end;\n+      end if;\n    end Previous;\n \n    function Previous\n@@ -1378,14 +1384,12 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -1514,28 +1518,28 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      elsif Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-      declare\n-         C : List renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n-         return R : constant Reference_Type :=\n-           (Element => Position.Node.Element'Access,\n-            Control => (Controlled with Position.Container))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+         declare\n+            C : List renames Position.Container.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n+         begin\n+            return R : constant Reference_Type :=\n+                         (Element => Position.Node.Element'Access,\n+                          Control => (Controlled with Position.Container))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n+      end if;\n    end Reference;\n \n    ---------------------\n@@ -1550,21 +1554,20 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      elsif Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is locked)\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-      Position.Node.Element := New_Item;\n+         Position.Node.Element := New_Item;\n+      end if;\n    end Replace_Element;\n \n    ----------------------\n@@ -1673,9 +1676,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n+         else\n+            pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n          end if;\n-\n-         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n@@ -1709,6 +1712,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1738,7 +1742,6 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             Process (Cursor'(Container'Unrestricted_Access, Node));\n             Node := Node.Prev;\n          end loop;\n-\n       exception\n          when others =>\n             B := B - 1;\n@@ -1762,32 +1765,28 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n+         else\n+            pragma Assert (Vet (Before), \"bad cursor in Splice\");\n          end if;\n-\n-         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n       end if;\n \n-      if Target'Address = Source'Address\n-        or else Source.Length = 0\n-      then\n+      if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n-      end if;\n \n-      if Target.Length > Count_Type'Last - Source.Length then\n+      elsif Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n \n-      if Target.Busy > 0 then\n+      elsif Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n \n-      if Source.Busy > 0 then\n+      elsif Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n \n-      Splice_Internal (Target, Before.Node, Source);\n+      else\n+         Splice_Internal (Target, Before.Node, Source);\n+      end if;\n    end Splice;\n \n    procedure Splice\n@@ -1800,9 +1799,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n+         else\n+            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n          end if;\n-\n-         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n@@ -1908,38 +1907,37 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          if Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n+         else\n+            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n          end if;\n-\n-         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n       end if;\n \n       if Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Source'Unrestricted_Access then\n+      elsif Position.Container /= Source'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n+      else\n+         pragma Assert (Vet (Position), \"bad Position cursor in Splice\");\n \n-      if Target.Length = Count_Type'Last then\n-         raise Constraint_Error with \"Target is full\";\n-      end if;\n+         if Target.Length = Count_Type'Last then\n+            raise Constraint_Error with \"Target is full\";\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n+         elsif Target.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Target (list is busy)\";\n \n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n+         elsif Source.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors of Source (list is busy)\";\n \n-      Splice_Internal (Target, Before.Node, Source, Position.Node);\n-      Position.Container := Target'Unchecked_Access;\n+         else\n+            Splice_Internal (Target, Before.Node, Source, Position.Node);\n+            Position.Container := Target'Unchecked_Access;\n+         end if;\n+      end if;\n    end Splice;\n \n    ---------------------\n@@ -2210,35 +2208,35 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    begin\n       if Position.Node = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      elsif Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n-\n-      declare\n-         B : Natural renames Container.Busy;\n-         L : Natural renames Container.Lock;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Update_Element\");\n \n-      begin\n-         B := B + 1;\n-         L := L + 1;\n+         declare\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n \n          begin\n-            Process (Position.Node.Element);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n+            B := B + 1;\n+            L := L + 1;\n \n-         L := L - 1;\n-         B := B - 1;\n-      end;\n+            begin\n+               Process (Position.Node.Element);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+         end;\n+      end if;\n    end Update_Element;\n \n    ---------\n@@ -2305,8 +2303,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          end if;\n \n          pragma Assert\n-           (Position.Node.Prev /= null\n-             or else Position.Node = L.First);\n+           (Position.Node.Prev /= null or else Position.Node = L.First);\n \n          if Position.Node.Next = null and then Position.Node /= L.Last then\n             return False;"}, {"sha": "9907406ebdf75cb5ee2437f5c0d360d94e1284e0", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 234, "deletions": 246, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -138,6 +138,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       LR := LR - 1;\n \n       return Result;\n+\n    exception\n       when others =>\n          BL := BL - 1;\n@@ -247,15 +248,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Target'Address = Source'Address then\n          return;\n-      end if;\n \n-      Target.Clear;\n+      else\n+         Target.Clear;\n \n-      Node := Source.First;\n-      while Node /= null loop\n-         Target.Append (Node.Element.all);\n-         Node := Node.Next;\n-      end loop;\n+         Node := Source.First;\n+         while Node /= null loop\n+            Target.Append (Node.Element.all);\n+            Node := Node.Next;\n+         end loop;\n+      end if;\n    end Assign;\n \n    -----------\n@@ -316,32 +318,30 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n-\n-      if Position.Node.Element = null then\n+      elsif Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Constant_Reference\");\n \n-      declare\n-         C : List renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n-         return R : constant Constant_Reference_Type :=\n-           (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Position.Container))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+         declare\n+            C : List renames Position.Container.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n+         begin\n+            return R : constant Constant_Reference_Type :=\n+                         (Element => Position.Node.Element.all'Access,\n+                          Control => (Controlled with Position.Container))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n+      end if;\n    end Constant_Reference;\n \n    --------------\n@@ -434,6 +434,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          Free (X);\n       end loop;\n \n+      --  Fix this junk comment ???\n+\n       Position := No_Element;  --  Post-York behavior\n    end Delete;\n \n@@ -451,28 +453,27 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n-      end if;\n \n-      if Count = 0 then\n+      elsif Count = 0 then\n          return;\n-      end if;\n \n-      if Container.Busy > 0 then\n+      elsif Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n \n-      for I in 1 .. Count loop\n-         X := Container.First;\n-         pragma Assert (X.Next.Prev = Container.First);\n+      else\n+         for J in 1 .. Count loop\n+            X := Container.First;\n+            pragma Assert (X.Next.Prev = Container.First);\n \n-         Container.First := X.Next;\n-         Container.First.Prev := null;\n+            Container.First := X.Next;\n+            Container.First.Prev := null;\n \n-         Container.Length := Container.Length - 1;\n+            Container.Length := Container.Length - 1;\n \n-         Free (X);\n-      end loop;\n+            Free (X);\n+         end loop;\n+      end if;\n    end Delete_First;\n \n    -----------------\n@@ -489,28 +490,27 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Count >= Container.Length then\n          Clear (Container);\n          return;\n-      end if;\n \n-      if Count = 0 then\n+      elsif Count = 0 then\n          return;\n-      end if;\n \n-      if Container.Busy > 0 then\n+      elsif Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (list is busy)\";\n-      end if;\n \n-      for I in 1 .. Count loop\n-         X := Container.Last;\n-         pragma Assert (X.Prev.Next = Container.Last);\n+      else\n+         for J in 1 .. Count loop\n+            X := Container.Last;\n+            pragma Assert (X.Prev.Next = Container.Last);\n \n-         Container.Last := X.Prev;\n-         Container.Last.Next := null;\n+            Container.Last := X.Prev;\n+            Container.Last.Next := null;\n \n-         Container.Length := Container.Length - 1;\n+            Container.Length := Container.Length - 1;\n \n-         Free (X);\n-      end loop;\n+            Free (X);\n+         end loop;\n+      end if;\n    end Delete_Last;\n \n    -------------\n@@ -522,16 +522,16 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Node.Element = null then\n+      elsif Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Element\");\n \n-      return Position.Node.Element.all;\n+         return Position.Node.Element.all;\n+      end if;\n    end Element;\n \n    --------------\n@@ -583,14 +583,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       else\n          if Node.Element = null then\n             raise Program_Error;\n-         end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         elsif Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-         end if;\n \n-         pragma Assert (Vet (Position), \"bad cursor in Find\");\n+         else\n+            pragma Assert (Vet (Position), \"bad cursor in Find\");\n+         end if;\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n@@ -624,6 +624,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -640,9 +641,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Container.First = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.First);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.First);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -675,9 +676,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Container.First = null then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.First.Element.all;\n       end if;\n-\n-      return Container.First.Element.all;\n    end First_Element;\n \n    ----------\n@@ -747,7 +748,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          Node := Container.First;\n          Result := True;\n-         for I in 2 .. Container.Length loop\n+         for J in 2 .. Container.Length loop\n             if Node.Next.Element.all < Node.Element.all then\n                Result := False;\n                exit;\n@@ -760,6 +761,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          L := L - 1;\n \n          return Result;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -786,23 +788,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n          if Source.Is_Empty then\n             return;\n-         end if;\n \n-         if Target'Address = Source'Address then\n+         elsif Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n-         end if;\n \n-         if Target.Length > Count_Type'Last - Source.Length then\n+         elsif Target.Length > Count_Type'Last - Source.Length then\n             raise Constraint_Error with \"new length exceeds maximum\";\n-         end if;\n \n-         if Target.Busy > 0 then\n+         elsif Target.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors of Target (list is busy)\";\n-         end if;\n \n-         if Source.Busy > 0 then\n+         elsif Source.Busy > 0 then\n             raise Program_Error with\n               \"attempt to tamper with cursors of Source (list is busy)\";\n          end if;\n@@ -827,17 +825,17 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n             RI := Source.First;\n             while RI /= null loop\n                pragma Assert (RI.Next = null\n-                                or else not (RI.Next.Element.all <\n-                                               RI.Element.all));\n+                               or else not (RI.Next.Element.all <\n+                                              RI.Element.all));\n \n                if LI = null then\n                   Splice_Internal (Target, null, Source);\n                   exit;\n                end if;\n \n                pragma Assert (LI.Next = null\n-                                or else not (LI.Next.Element.all <\n-                                               LI.Element.all));\n+                               or else not (LI.Next.Element.all <\n+                                              LI.Element.all));\n \n                if RI.Element.all < LI.Element.all then\n                   RJ := RI;\n@@ -854,6 +852,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n             SB := SB - 1;\n             SL := SL - 1;\n+\n          exception\n             when others =>\n                TB := TB - 1;\n@@ -872,22 +871,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       procedure Sort (Container : in out List) is\n          procedure Partition (Pivot : Node_Access; Back  : Node_Access);\n+         --  Comment ???\n \n          procedure Sort (Front, Back : Node_Access);\n+         --  Comment??? Confusing name??? change name???\n \n          ---------------\n          -- Partition --\n          ---------------\n \n          procedure Partition (Pivot : Node_Access; Back : Node_Access) is\n-            Node : Node_Access := Pivot.Next;\n+            Node : Node_Access;\n \n          begin\n+            Node := Pivot.Next;\n             while Node /= Back loop\n                if Node.Element.all < Pivot.Element.all then\n                   declare\n                      Prev : constant Node_Access := Node.Prev;\n                      Next : constant Node_Access := Node.Next;\n+\n                   begin\n                      Prev.Next := Next;\n \n@@ -1003,16 +1006,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          if Before.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"attempt to tamper with cursors (list is busy)\";\n-         end if;\n \n-         if Before.Node = null\n-           or else Before.Node.Element = null\n-         then\n+         elsif Before.Node = null or else Before.Node.Element = null then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-         end if;\n \n-         pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+         else\n+            pragma Assert (Vet (Before), \"bad cursor in Insert\");\n+         end if;\n       end if;\n \n       if Count = 0 then\n@@ -1052,8 +1053,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Insert_Internal (Container, Before.Node, New_Node);\n       Position := Cursor'(Container'Unchecked_Access, New_Node);\n \n-      for J in Count_Type'(2) .. Count loop\n-\n+      for J in 2 .. Count loop\n          declare\n             Element : Element_Access := new Element_Type'(New_Item);\n          begin\n@@ -1183,9 +1183,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       --  for a reverse iterator, Container.Last is the beginning.\n \n       return It : constant Iterator :=\n-        Iterator'(Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => null)\n+                    Iterator'(Limited_Controlled with\n+                                Container => Container'Unrestricted_Access,\n+                                Node      => null)\n       do\n          B := B + 1;\n       end return;\n@@ -1213,31 +1213,31 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Start = No_Element then\n          raise Constraint_Error with\n            \"Start position for iterator equals No_Element\";\n-      end if;\n \n-      if Start.Container /= Container'Unrestricted_Access then\n+      elsif Start.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Start cursor of Iterate designates wrong list\";\n-      end if;\n \n-      pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n-\n-      --  The value of the Node component influences the behavior of the First\n-      --  and Last selector functions of the iterator object. When the Node\n-      --  component is non-null (as is the case here), it means that this\n-      --  is a partial iteration, over a subset of the complete sequence of\n-      --  items. The iterator object was constructed with a start expression,\n-      --  indicating the position from which the iteration begins. Note that\n-      --  the start position has the same value irrespective of whether this\n-      --  is a forward or reverse iteration.\n-\n-      return It : constant Iterator :=\n-        Iterator'(Limited_Controlled with\n-                    Container => Container'Unrestricted_Access,\n-                    Node      => Start.Node)\n-      do\n-         B := B + 1;\n-      end return;\n+      else\n+         pragma Assert (Vet (Start), \"Start cursor of Iterate is bad\");\n+\n+         --  The value of the Node component influences the behavior of the\n+         --  First and Last selector functions of the iterator object. When\n+         --  the Node component is non-null (as is the case here), it means\n+         --  that this is a partial iteration, over a subset of the complete\n+         --  sequence of items. The iterator object was constructed with\n+         --  a start expression, indicating the position from which the\n+         --  iteration begins. Note that the start position has the same value\n+         --  irrespective of whether this is a forward or reverse iteration.\n+\n+         return It : constant Iterator :=\n+                       Iterator'(Limited_Controlled with\n+                                   Container => Container'Unrestricted_Access,\n+                                 Node      => Start.Node)\n+         do\n+            B := B + 1;\n+         end return;\n+      end if;\n    end Iterate;\n \n    ----------\n@@ -1248,9 +1248,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Container.Last = null then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unrestricted_Access, Container.Last);\n       end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Last);\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n@@ -1283,9 +1283,9 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Container.Last = null then\n          raise Constraint_Error with \"list is empty\";\n+      else\n+         return Container.Last.Element.all;\n       end if;\n-\n-      return Container.Last.Element.all;\n    end Last_Element;\n \n    ------------\n@@ -1305,23 +1305,23 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Target'Address = Source'Address then\n          return;\n-      end if;\n \n-      if Source.Busy > 0 then\n+      elsif Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n \n-      Clear (Target);\n+      else\n+         Clear (Target);\n \n-      Target.First := Source.First;\n-      Source.First := null;\n+         Target.First := Source.First;\n+         Source.First := null;\n \n-      Target.Last := Source.Last;\n-      Source.Last := null;\n+         Target.Last := Source.Last;\n+         Source.Last := null;\n \n-      Target.Length := Source.Length;\n-      Source.Length := 0;\n+         Target.Length := Source.Length;\n+         Source.Length := 0;\n+      end if;\n    end Move;\n \n    ----------\n@@ -1337,33 +1337,32 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Node = null then\n          return No_Element;\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Next\");\n-\n-      declare\n-         Next_Node : constant Node_Access := Position.Node.Next;\n-      begin\n-         if Next_Node = null then\n-            return No_Element;\n-         end if;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Next\");\n \n-         return Cursor'(Position.Container, Next_Node);\n-      end;\n+         declare\n+            Next_Node : constant Node_Access := Position.Node.Next;\n+         begin\n+            if Next_Node = null then\n+               return No_Element;\n+            else\n+               return Cursor'(Position.Container, Next_Node);\n+            end if;\n+         end;\n+      end if;\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong list\";\n+      else\n+         return Next (Position);\n       end if;\n-\n-      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1392,33 +1391,32 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Node = null then\n          return No_Element;\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Previous\");\n-\n-      declare\n-         Prev_Node : constant Node_Access := Position.Node.Prev;\n-      begin\n-         if Prev_Node = null then\n-            return No_Element;\n-         end if;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Previous\");\n \n-         return Cursor'(Position.Container, Prev_Node);\n-      end;\n+         declare\n+            Prev_Node : constant Node_Access := Position.Node.Prev;\n+         begin\n+            if Prev_Node = null then\n+               return No_Element;\n+            else\n+               return Cursor'(Position.Container, Prev_Node);\n+            end if;\n+         end;\n+      end if;\n    end Previous;\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Container /= Object.Container then\n+      elsif Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong list\";\n+      else\n+         return Previous (Position);\n       end if;\n-\n-      return Previous (Position);\n    end Previous;\n \n    -------------------\n@@ -1433,36 +1431,36 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       if Position.Node = null then\n          raise Constraint_Error with\n            \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Node.Element = null then\n+      elsif Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      declare\n-         C : List renames Position.Container.all'Unrestricted_Access.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Query_Element\");\n \n-      begin\n-         B := B + 1;\n-         L := L + 1;\n+         declare\n+            C : List renames Position.Container.all'Unrestricted_Access.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n \n          begin\n-            Process (Position.Node.Element.all);\n-         exception\n-            when others =>\n-               L := L - 1;\n-               B := B - 1;\n-               raise;\n-         end;\n+            B := B + 1;\n+            L := L + 1;\n \n-         L := L - 1;\n-         B := B - 1;\n-      end;\n+            begin\n+               Process (Position.Node.Element.all);\n+            exception\n+               when others =>\n+                  L := L - 1;\n+                  B := B - 1;\n+                  raise;\n+            end;\n+\n+            L := L - 1;\n+            B := B - 1;\n+         end;\n+      end if;\n    end Query_Element;\n \n    ----------\n@@ -1487,7 +1485,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       declare\n          Element : Element_Access :=\n-           new Element_Type'(Element_Type'Input (Stream));\n+                     new Element_Type'(Element_Type'Input (Stream));\n       begin\n          Dst := new Node_Type'(Element, null, null);\n       exception\n@@ -1503,7 +1501,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       while Item.Length < N loop\n          declare\n             Element : Element_Access :=\n-              new Element_Type'(Element_Type'Input (Stream));\n+                        new Element_Type'(Element_Type'Input (Stream));\n          begin\n             Dst := new Node_Type'(Element, Next => null, Prev => Item.Last);\n          exception\n@@ -1553,32 +1551,31 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n+      elsif Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      if Position.Node.Element = null then\n+      elsif Position.Node.Element = null then\n          raise Program_Error with \"Node has no element\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in function Reference\");\n \n-      declare\n-         C : List renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n-         return R : constant Reference_Type :=\n-           (Element => Position.Node.Element.all'Access,\n-            Control => (Controlled with Position.Container))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+         declare\n+            C : List renames Position.Container.all;\n+            B : Natural renames C.Busy;\n+            L : Natural renames C.Lock;\n+         begin\n+            return R : constant Reference_Type :=\n+                         (Element => Position.Node.Element.all'Access,\n+                          Control => (Controlled with Position.Container))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n+      end if;\n    end Reference;\n \n    ---------------------\n@@ -1593,38 +1590,36 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n \n-      if Position.Container /= Container'Unchecked_Access then\n+      elsif Position.Container /= Container'Unchecked_Access then\n          raise Program_Error with\n            \"Position cursor designates wrong container\";\n-      end if;\n \n-      if Container.Lock > 0 then\n+      elsif Container.Lock > 0 then\n          raise Program_Error with\n            \"attempt to tamper with elements (list is locked)\";\n-      end if;\n \n-      if Position.Node.Element = null then\n+      elsif Position.Node.Element = null then\n          raise Program_Error with\n            \"Position cursor has no element\";\n-      end if;\n \n-      pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n+      else\n+         pragma Assert (Vet (Position), \"bad cursor in Replace_Element\");\n \n-      declare\n-         --  The element allocator may need an accessibility check in the case\n-         --  the actual type is class-wide or has access discriminants (see\n-         --  RM 4.8(10.1) and AI12-0035).\n+         declare\n+            --  The element allocator may need an accessibility check in the\n+            --  case the actual type is class-wide or has access discriminants\n+            --  (see RM 4.8(10.1) and AI12-0035).\n \n-         pragma Unsuppress (Accessibility_Check);\n+            pragma Unsuppress (Accessibility_Check);\n \n-         X : Element_Access := Position.Node.Element;\n+            X : Element_Access := Position.Node.Element;\n \n-      begin\n-         Position.Node.Element := new Element_Type'(New_Item);\n-         Free (X);\n-      end;\n+         begin\n+            Position.Node.Element := new Element_Type'(New_Item);\n+            Free (X);\n+         end;\n+      end if;\n    end Replace_Element;\n \n    ----------------------\n@@ -1732,14 +1727,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       else\n          if Node.Element = null then\n             raise Program_Error with \"Position cursor has no element\";\n-         end if;\n \n-         if Position.Container /= Container'Unrestricted_Access then\n+         elsif Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with\n               \"Position cursor designates wrong container\";\n-         end if;\n \n-         pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+         else\n+            pragma Assert (Vet (Position), \"bad cursor in Reverse_Find\");\n+         end if;\n       end if;\n \n       --  Per AI05-0022, the container implementation is required to detect\n@@ -1773,6 +1768,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          else\n             return Cursor'(Container'Unrestricted_Access, Result);\n          end if;\n+\n       exception\n          when others =>\n             B := B - 1;\n@@ -1825,39 +1821,33 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          if Before.Container /= Target'Unrestricted_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n-         end if;\n \n-         if Before.Node = null\n-           or else Before.Node.Element = null\n-         then\n+         elsif Before.Node = null or else Before.Node.Element = null then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-         end if;\n \n-         pragma Assert (Vet (Before), \"bad cursor in Splice\");\n+         else\n+            pragma Assert (Vet (Before), \"bad cursor in Splice\");\n+         end if;\n       end if;\n \n-      if Target'Address = Source'Address\n-        or else Source.Length = 0\n-      then\n+      if Target'Address = Source'Address or else Source.Length = 0 then\n          return;\n-      end if;\n \n-      if Target.Length > Count_Type'Last - Source.Length then\n+      elsif Target.Length > Count_Type'Last - Source.Length then\n          raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n \n-      if Target.Busy > 0 then\n+      elsif Target.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Target (list is busy)\";\n-      end if;\n \n-      if Source.Busy > 0 then\n+      elsif Source.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors of Source (list is busy)\";\n-      end if;\n \n-      Splice_Internal (Target, Before.Node, Source);\n+      else\n+         Splice_Internal (Target, Before.Node, Source);\n+      end if;\n    end Splice;\n \n    procedure Splice\n@@ -1870,16 +1860,14 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          if Before.Container /= Container'Unchecked_Access then\n             raise Program_Error with\n               \"Before cursor designates wrong container\";\n-         end if;\n \n-         if Before.Node = null\n-           or else Before.Node.Element = null\n-         then\n+         elsif Before.Node = null or else Before.Node.Element = null then\n             raise Program_Error with\n               \"Before cursor has no element\";\n-         end if;\n \n-         pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+         else\n+            pragma Assert (Vet (Before), \"bad Before cursor in Splice\");\n+         end if;\n       end if;\n \n       if Position.Node = null then"}, {"sha": "6588b4f3f9cca0579f3cb70e292162594c859966", "filename": "gcc/ada/adabkend.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fadabkend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fadabkend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadabkend.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -234,8 +234,15 @@ package body Adabkend is\n             then\n                if Is_Switch (Argv) then\n                   Fail (\"Object file name missing after -gnatO\");\n+\n+               --  In Alfa_Mode, such an object file is never written, and the\n+               --  call to Set_Output_Object_File_Name may fail (e.g. when the\n+               --  object file name does not have the expected suffix). So we\n+               --  skip that call when Alfa_Mode is set.\n+\n                elsif Alfa_Mode then\n                   Output_File_Name_Seen := True;\n+\n                else\n                   Set_Output_Object_File_Name (Argv);\n                   Output_File_Name_Seen := True;"}, {"sha": "05a0c6f8c30cf778541f5e9e2aab85db40676fdd", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -3244,13 +3244,18 @@ package body Checks is\n                 Reason    => CE_Discriminant_Check_Failed));\n          end;\n \n-      --  For arrays, conversions are applied during expansion, to take into\n-      --  accounts changes of representation. The checks become range checks on\n-      --  the base type or length checks on the subtype, depending on whether\n-      --  the target type is unconstrained or constrained.\n-\n-      else\n-         null;\n+      --  For arrays, checks are set now, but conversions are applied during\n+      --  expansion, to take into accounts changes of representation. The\n+      --  checks become range checks on the base type or length checks on the\n+      --  subtype, depending on whether the target type is unconstrained or\n+      --  constrained.\n+\n+      elsif Is_Array_Type (Target_Type) then\n+         if Is_Constrained (Target_Type) then\n+            Set_Do_Length_Check (N);\n+         else\n+            Set_Do_Range_Check (Expr);\n+         end if;\n       end if;\n    end Apply_Type_Conversion_Checks;\n "}, {"sha": "cd6d30339a723dc2f73cc2c52351aa2186044507", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -126,7 +126,7 @@ package body Debug is\n    --  d.F  Alfa mode\n    --  d.G  Frame condition mode for gnat2why\n    --  d.H  Standard package only mode for gnat2why\n-   --  d.I\n+   --  d.I  Do not ignore enum representation clauses in CodePeer mode\n    --  d.J  Disable parallel SCIL generation mode\n    --  d.K  Alfa detection only mode for gnat2why\n    --  d.L  Depend on back end for limited types in if and case expressions\n@@ -614,6 +614,12 @@ package body Debug is\n    --       will only generate Why code for package Standard. Any given input\n    --       file will be ignored.\n \n+   --  d.I  Do not ignore enum representation clauses in CodePeer mode.\n+   --       The default of ignoring representation clauses for enumeration\n+   --       types in CodePeer is good for the majority of Ada code, but in some\n+   --       cases being able to change this default might be useful to remove\n+   --       some false positives.\n+\n    --  d.J  Disable parallel SCIL generation. Normally SCIL file generation is\n    --       done in parallel to speed processing. This switch disables this\n    --       behavior."}, {"sha": "0fd6b1a7d213ceb9808f072f5cae3a2c8342000a", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -293,11 +293,15 @@ procedure Gnat1drv is\n          Formal_Extensions := True;\n       end if;\n \n-      --  Alfa_Mode is activated by default in the gnat2why executable, but\n-      --  can also be activated using the -gnatd.F switch.\n+      --  Enable Alfa_Mode when using -gnatd.F switch\n \n-      if Debug_Flag_Dot_FF or else Alfa_Mode then\n+      if Debug_Flag_Dot_FF then\n          Alfa_Mode := True;\n+      end if;\n+\n+      --  Alfa_Mode is also activated by default in the gnat2why executable\n+\n+      if Alfa_Mode then\n \n          --  Set strict standard interpretation of compiler permissions\n "}, {"sha": "56bc0fecc761123a4295b82690de9dada068abf9", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -26,6 +26,7 @@\n with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -4253,6 +4254,14 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n+      --  Ignore enumeration rep clauses by default in CodePeer mode,\n+      --  unless -gnatd.I is specified, as a work around for potential false\n+      --  positive messages.\n+\n+      if CodePeer_Mode and not Debug_Flag_Dot_II then\n+         return;\n+      end if;\n+\n       --  First some basic error checks\n \n       Find_Type (Ident);"}, {"sha": "d964d0feb90054c67bb8ba7f29a3b626ffc2206b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bfbd380f2c411f1b264fa234b3beb9cde53752b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8bfbd380f2c411f1b264fa234b3beb9cde53752b", "patch": "@@ -12984,6 +12984,19 @@ package body Sem_Util is\n             else\n                Desc := P;\n                P    := Parent (P);\n+\n+               --  A special Ada 2012 case: the original node may be part\n+               --  of the else_actions of a conditional expression, in which\n+               --  case it might not have been expanded yet, and appears in\n+               --  a non-syntactic list of actions. In that case it is clearly\n+               --  not safe to save a value.\n+\n+               if No (P)\n+                 and then Is_List_Member (Desc)\n+                 and then No (Parent (List_Containing (Desc)))\n+               then\n+                  return False;\n+               end if;\n             end if;\n          end loop;\n       end;"}]}