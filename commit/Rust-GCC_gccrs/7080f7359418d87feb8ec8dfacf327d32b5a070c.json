{"sha": "7080f7359418d87feb8ec8dfacf327d32b5a070c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4MGY3MzU5NDE4ZDg3ZmViOGVjOGRmYWNmMzI3ZDMyYjVhMDcwYw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-29T15:19:13Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-29T15:19:13Z"}, "message": "cse.c: Convert prototypes to ISO C90.\n\n\t* cse.c: Convert prototypes to ISO C90.\n\t* cselib.c: Likewise.\n\t* cselib.h: Likewise.\n\t* dbxout.c: Likewise.\n\t* debug.c: Likewise.\n\t* df.c: Likewise.\n\t* df.h: Likewise.\n\t* dojump.c: Likewise.\n\t* doloop.c: Likewise.\n\t* dominance.c: Likewise.\n\t* dwarf2asm.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarf2out.h: Likewise.\n\t* dwarfout.c: Likewise.\n\nFrom-SVN: r68673", "tree": {"sha": "69a7605e420c2a4c3192a22cb99dabe1df635fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69a7605e420c2a4c3192a22cb99dabe1df635fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7080f7359418d87feb8ec8dfacf327d32b5a070c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7080f7359418d87feb8ec8dfacf327d32b5a070c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7080f7359418d87feb8ec8dfacf327d32b5a070c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7080f7359418d87feb8ec8dfacf327d32b5a070c/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9da50645221cfa880519542a1c5e37c53837bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9da50645221cfa880519542a1c5e37c53837bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9da50645221cfa880519542a1c5e37c53837bef"}], "stats": {"total": 4466, "additions": 1610, "deletions": 2856}, "files": [{"sha": "b5681d5bc0efb381d2ad6ec14f5f3678ccaf4f54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,3 +1,20 @@\n+2003-06-29  Andreas Jaeger  <aj@suse.de>\n+\n+\t* cse.c: Convert prototypes to ISO C90.\n+\t* cselib.c: Likewise.\n+\t* cselib.h: Likewise.\n+\t* dbxout.c: Likewise.\n+\t* debug.c: Likewise.\n+\t* df.c: Likewise.\n+\t* df.h: Likewise.\n+\t* dojump.c: Likewise.\n+\t* doloop.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* dwarf2asm.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarf2out.h: Likewise.\n+\t* dwarfout.c: Likewise.\n+\n 2003-06-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* alloc-pool.c: Fix comment formatting."}, {"sha": "f01c81201694b3657e2857c5d8328c35e36c4c49", "filename": "gcc/cse.c", "status": "modified", "additions": 139, "deletions": 255, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -503,9 +503,9 @@ struct table_elt\n    a cost of 2.  Aside from these special cases, call `rtx_cost'.  */\n \n #define CHEAP_REGNO(N) \\\n-  ((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM \t\\\n-   || (N) == STACK_POINTER_REGNUM || (N) == ARG_POINTER_REGNUM\t     \t\\\n-   || ((N) >= FIRST_VIRTUAL_REGISTER && (N) <= LAST_VIRTUAL_REGISTER) \t\\\n+  ((N) == FRAME_POINTER_REGNUM || (N) == HARD_FRAME_POINTER_REGNUM\t\\\n+   || (N) == STACK_POINTER_REGNUM || (N) == ARG_POINTER_REGNUM\t\t\\\n+   || ((N) >= FIRST_VIRTUAL_REGISTER && (N) <= LAST_VIRTUAL_REGISTER)\t\\\n    || ((N) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n        && FIXED_REGNO_P (N) && REGNO_REG_CLASS (N) != NO_REGS))\n \n@@ -514,7 +514,7 @@ struct table_elt\n \n /* Get the info associated with register N.  */\n \n-#define GET_CSE_REG_INFO(N) \t\t\t\\\n+#define GET_CSE_REG_INFO(N)\t\t\t\\\n   (((N) == cached_regno && cached_cse_reg_info)\t\\\n    ? cached_cse_reg_info : get_cse_reg_info ((N)))\n \n@@ -596,76 +596,74 @@ struct cse_basic_block_data\n     } *path;\n };\n \n-static bool fixed_base_plus_p\tPARAMS ((rtx x));\n-static int notreg_cost\t\tPARAMS ((rtx, enum rtx_code));\n-static int approx_reg_cost_1\tPARAMS ((rtx *, void *));\n-static int approx_reg_cost\tPARAMS ((rtx));\n-static int preferrable\t\tPARAMS ((int, int, int, int));\n-static void new_basic_block\tPARAMS ((void));\n-static void make_new_qty\tPARAMS ((unsigned int, enum machine_mode));\n-static void make_regs_eqv\tPARAMS ((unsigned int, unsigned int));\n-static void delete_reg_equiv\tPARAMS ((unsigned int));\n-static int mention_regs\t\tPARAMS ((rtx));\n-static int insert_regs\t\tPARAMS ((rtx, struct table_elt *, int));\n-static void remove_from_table\tPARAMS ((struct table_elt *, unsigned));\n-static struct table_elt *lookup\tPARAMS ((rtx, unsigned, enum machine_mode)),\n-       *lookup_for_remove PARAMS ((rtx, unsigned, enum machine_mode));\n-static rtx lookup_as_function\tPARAMS ((rtx, enum rtx_code));\n-static struct table_elt *insert PARAMS ((rtx, struct table_elt *, unsigned,\n-\t\t\t\t\t enum machine_mode));\n-static void merge_equiv_classes PARAMS ((struct table_elt *,\n-\t\t\t\t\t struct table_elt *));\n-static void invalidate\t\tPARAMS ((rtx, enum machine_mode));\n-static int cse_rtx_varies_p\tPARAMS ((rtx, int));\n-static void remove_invalid_refs\tPARAMS ((unsigned int));\n-static void remove_invalid_subreg_refs\tPARAMS ((unsigned int, unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static void rehash_using_reg\tPARAMS ((rtx));\n-static void invalidate_memory\tPARAMS ((void));\n-static void invalidate_for_call\tPARAMS ((void));\n-static rtx use_related_value\tPARAMS ((rtx, struct table_elt *));\n-static unsigned canon_hash\tPARAMS ((rtx, enum machine_mode));\n-static unsigned canon_hash_string PARAMS ((const char *));\n-static unsigned safe_hash\tPARAMS ((rtx, enum machine_mode));\n-static int exp_equiv_p\t\tPARAMS ((rtx, rtx, int, int));\n-static rtx canon_reg\t\tPARAMS ((rtx, rtx));\n-static void find_best_addr\tPARAMS ((rtx, rtx *, enum machine_mode));\n-static enum rtx_code find_comparison_args PARAMS ((enum rtx_code, rtx *, rtx *,\n-\t\t\t\t\t\t   enum machine_mode *,\n-\t\t\t\t\t\t   enum machine_mode *));\n-static rtx fold_rtx\t\tPARAMS ((rtx, rtx));\n-static rtx equiv_constant\tPARAMS ((rtx));\n-static void record_jump_equiv\tPARAMS ((rtx, int));\n-static void record_jump_cond\tPARAMS ((enum rtx_code, enum machine_mode,\n-\t\t\t\t\t rtx, rtx, int));\n-static void cse_insn\t\tPARAMS ((rtx, rtx));\n-static int addr_affects_sp_p\tPARAMS ((rtx));\n-static void invalidate_from_clobbers PARAMS ((rtx));\n-static rtx cse_process_notes\tPARAMS ((rtx, rtx));\n-static void cse_around_loop\tPARAMS ((rtx));\n-static void invalidate_skipped_set PARAMS ((rtx, rtx, void *));\n-static void invalidate_skipped_block PARAMS ((rtx));\n-static void cse_check_loop_start PARAMS ((rtx, rtx, void *));\n-static void cse_set_around_loop\tPARAMS ((rtx, rtx, rtx));\n-static rtx cse_basic_block\tPARAMS ((rtx, rtx, struct branch_path *, int));\n-static void count_reg_usage\tPARAMS ((rtx, int *, rtx, int));\n-static int check_for_label_ref\tPARAMS ((rtx *, void *));\n-extern void dump_class          PARAMS ((struct table_elt*));\n-static struct cse_reg_info * get_cse_reg_info PARAMS ((unsigned int));\n-static int check_dependence\tPARAMS ((rtx *, void *));\n-\n-static void flush_hash_table\tPARAMS ((void));\n-static bool insn_live_p\t\tPARAMS ((rtx, int *));\n-static bool set_live_p\t\tPARAMS ((rtx, rtx, int *));\n-static bool dead_libcall_p\tPARAMS ((rtx, int *));\n+static bool fixed_base_plus_p (rtx x);\n+static int notreg_cost (rtx, enum rtx_code);\n+static int approx_reg_cost_1 (rtx *, void *);\n+static int approx_reg_cost (rtx);\n+static int preferrable (int, int, int, int);\n+static void new_basic_block (void);\n+static void make_new_qty (unsigned int, enum machine_mode);\n+static void make_regs_eqv (unsigned int, unsigned int);\n+static void delete_reg_equiv (unsigned int);\n+static int mention_regs (rtx);\n+static int insert_regs (rtx, struct table_elt *, int);\n+static void remove_from_table (struct table_elt *, unsigned);\n+static struct table_elt *lookup\t(rtx, unsigned, enum machine_mode);\n+static struct table_elt *lookup_for_remove (rtx, unsigned, enum machine_mode);\n+static rtx lookup_as_function (rtx, enum rtx_code);\n+static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n+\t\t\t\t enum machine_mode);\n+static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n+static void invalidate (rtx, enum machine_mode);\n+static int cse_rtx_varies_p (rtx, int);\n+static void remove_invalid_refs (unsigned int);\n+static void remove_invalid_subreg_refs (unsigned int, unsigned int,\n+\t\t\t\t\tenum machine_mode);\n+static void rehash_using_reg (rtx);\n+static void invalidate_memory (void);\n+static void invalidate_for_call (void);\n+static rtx use_related_value (rtx, struct table_elt *);\n+static unsigned canon_hash (rtx, enum machine_mode);\n+static unsigned canon_hash_string (const char *);\n+static unsigned safe_hash (rtx, enum machine_mode);\n+static int exp_equiv_p (rtx, rtx, int, int);\n+static rtx canon_reg (rtx, rtx);\n+static void find_best_addr (rtx, rtx *, enum machine_mode);\n+static enum rtx_code find_comparison_args (enum rtx_code, rtx *, rtx *,\n+\t\t\t\t\t   enum machine_mode *,\n+\t\t\t\t\t   enum machine_mode *);\n+static rtx fold_rtx (rtx, rtx);\n+static rtx equiv_constant (rtx);\n+static void record_jump_equiv (rtx, int);\n+static void record_jump_cond (enum rtx_code, enum machine_mode, rtx, rtx,\n+\t\t\t      int);\n+static void cse_insn (rtx, rtx);\n+static int addr_affects_sp_p (rtx);\n+static void invalidate_from_clobbers (rtx);\n+static rtx cse_process_notes (rtx, rtx);\n+static void cse_around_loop (rtx);\n+static void invalidate_skipped_set (rtx, rtx, void *);\n+static void invalidate_skipped_block (rtx);\n+static void cse_check_loop_start (rtx, rtx, void *);\n+static void cse_set_around_loop (rtx, rtx, rtx);\n+static rtx cse_basic_block (rtx, rtx, struct branch_path *, int);\n+static void count_reg_usage (rtx, int *, rtx, int);\n+static int check_for_label_ref (rtx *, void *);\n+extern void dump_class (struct table_elt*);\n+static struct cse_reg_info * get_cse_reg_info (unsigned int);\n+static int check_dependence (rtx *, void *);\n+\n+static void flush_hash_table (void);\n+static bool insn_live_p (rtx, int *);\n+static bool set_live_p (rtx, rtx, int *);\n+static bool dead_libcall_p (rtx, int *);\n \f\n /* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n    virtual regs here because the simplify_*_operation routines are called\n    by integrate.c, which is called before virtual register instantiation.  */\n \n static bool\n-fixed_base_plus_p (x)\n-     rtx x;\n+fixed_base_plus_p (rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -695,8 +693,7 @@ fixed_base_plus_p (x)\n /* Dump the expressions in the equivalence class indicated by CLASSP.\n    This function is used only for debugging.  */\n void\n-dump_class (classp)\n-     struct table_elt *classp;\n+dump_class (struct table_elt *classp)\n {\n   struct table_elt *elt;\n \n@@ -714,9 +711,7 @@ dump_class (classp)\n /* Subroutine of approx_reg_cost; called through for_each_rtx.  */\n \n static int\n-approx_reg_cost_1 (xp, data)\n-     rtx *xp;\n-     void *data;\n+approx_reg_cost_1 (rtx *xp, void *data)\n {\n   rtx x = *xp;\n   int *cost_p = data;\n@@ -747,8 +742,7 @@ approx_reg_cost_1 (xp, data)\n    0.  If any other hard register reference occurs, return MAX_COST.  */\n \n static int\n-approx_reg_cost (x)\n-     rtx x;\n+approx_reg_cost (rtx x)\n {\n   int cost = 0;\n \n@@ -763,8 +757,7 @@ approx_reg_cost (x)\n    Return a positive value if A is less desirable, or 0 if the two are\n    equally good.  */\n static int\n-preferrable (cost_a, regcost_a, cost_b, regcost_b)\n-     int cost_a, regcost_a, cost_b, regcost_b;\n+preferrable (int cost_a, int regcost_a, int cost_b, int regcost_b)\n {\n   /* First, get rid of cases involving expressions that are entirely\n      unwanted.  */\n@@ -798,9 +791,7 @@ preferrable (cost_a, regcost_a, cost_b, regcost_b)\n    from COST macro to keep it simple.  */\n \n static int\n-notreg_cost (x, outer)\n-     rtx x;\n-     enum rtx_code outer;\n+notreg_cost (rtx x, enum rtx_code outer)\n {\n   return ((GET_CODE (x) == SUBREG\n \t   && GET_CODE (SUBREG_REG (x)) == REG\n@@ -821,9 +812,7 @@ notreg_cost (x, outer)\n    Other uses like the latter are expected in the future.  */\n \n int\n-rtx_cost (x, outer_code)\n-     rtx x;\n-     enum rtx_code outer_code ATTRIBUTE_UNUSED;\n+rtx_cost (rtx x, enum rtx_code outer_code ATTRIBUTE_UNUSED)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -893,9 +882,7 @@ rtx_cost (x, outer_code)\n    Expect that X is properly formed address reference.  */\n \n int\n-address_cost (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+address_cost (rtx x, enum machine_mode mode)\n {\n   /* The address_cost target hook does not deal with ADDRESSOF nodes.  But,\n      during CSE, such nodes are present.  Using an ADDRESSOF node which\n@@ -918,15 +905,13 @@ address_cost (x, mode)\n /* If the target doesn't override, compute the cost as with arithmetic.  */\n \n int\n-default_address_cost (x)\n-     rtx x;\n+default_address_cost (rtx x)\n {\n   return rtx_cost (x, MEM);\n }\n \f\n static struct cse_reg_info *\n-get_cse_reg_info (regno)\n-     unsigned int regno;\n+get_cse_reg_info (unsigned int regno)\n {\n   struct cse_reg_info **hash_head = &reg_hash[REGHASH_FN (regno)];\n   struct cse_reg_info *p;\n@@ -974,7 +959,7 @@ get_cse_reg_info (regno)\n    for a new basic block.  */\n \n static void\n-new_basic_block ()\n+new_basic_block (void)\n {\n   int i;\n \n@@ -1029,9 +1014,7 @@ new_basic_block ()\n    register before and initialize that quantity.  */\n \n static void\n-make_new_qty (reg, mode)\n-     unsigned int reg;\n-     enum machine_mode mode;\n+make_new_qty (unsigned int reg, enum machine_mode mode)\n {\n   int q;\n   struct qty_table_elem *ent;\n@@ -1056,8 +1039,7 @@ make_new_qty (reg, mode)\n    OLD is not changing; NEW is.  */\n \n static void\n-make_regs_eqv (new, old)\n-     unsigned int new, old;\n+make_regs_eqv (unsigned int new, unsigned int old)\n {\n   unsigned int lastr, firstr;\n   int q = REG_QTY (old);\n@@ -1120,8 +1102,7 @@ make_regs_eqv (new, old)\n /* Remove REG from its equivalence class.  */\n \n static void\n-delete_reg_equiv (reg)\n-     unsigned int reg;\n+delete_reg_equiv (unsigned int reg)\n {\n   struct qty_table_elem *ent;\n   int q = REG_QTY (reg);\n@@ -1161,8 +1142,7 @@ delete_reg_equiv (reg)\n    of X.  */\n \n static int\n-mention_regs (x)\n-     rtx x;\n+mention_regs (rtx x)\n {\n   enum rtx_code code;\n   int i, j;\n@@ -1271,10 +1251,7 @@ mention_regs (x)\n    so X's hash code may be different.  */\n \n static int\n-insert_regs (x, classp, modified)\n-     rtx x;\n-     struct table_elt *classp;\n-     int modified;\n+insert_regs (rtx x, struct table_elt *classp, int modified)\n {\n   if (GET_CODE (x) == REG)\n     {\n@@ -1351,9 +1328,7 @@ insert_regs (x, classp, modified)\n    and we save much time not recomputing it.  */\n \n static void\n-remove_from_table (elt, hash)\n-     struct table_elt *elt;\n-     unsigned hash;\n+remove_from_table (struct table_elt *elt, unsigned int hash)\n {\n   if (elt == 0)\n     return;\n@@ -1436,10 +1411,7 @@ remove_from_table (elt, hash)\n    looks like X.  */\n \n static struct table_elt *\n-lookup (x, hash, mode)\n-     rtx x;\n-     unsigned hash;\n-     enum machine_mode mode;\n+lookup (rtx x, unsigned int hash, enum machine_mode mode)\n {\n   struct table_elt *p;\n \n@@ -1455,10 +1427,7 @@ lookup (x, hash, mode)\n    Also ignore discrepancies in the machine mode of a register.  */\n \n static struct table_elt *\n-lookup_for_remove (x, hash, mode)\n-     rtx x;\n-     unsigned hash;\n-     enum machine_mode mode;\n+lookup_for_remove (rtx x, unsigned int hash, enum machine_mode mode)\n {\n   struct table_elt *p;\n \n@@ -1487,9 +1456,7 @@ lookup_for_remove (x, hash, mode)\n    If one is found, return that expression.  */\n \n static rtx\n-lookup_as_function (x, code)\n-     rtx x;\n-     enum rtx_code code;\n+lookup_as_function (rtx x, enum rtx_code code)\n {\n   struct table_elt *p\n     = lookup (x, safe_hash (x, VOIDmode) & HASH_MASK, GET_MODE (x));\n@@ -1545,11 +1512,7 @@ lookup_as_function (x, code)\n  (preferrable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n \n static struct table_elt *\n-insert (x, classp, hash, mode)\n-     rtx x;\n-     struct table_elt *classp;\n-     unsigned hash;\n-     enum machine_mode mode;\n+insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mode)\n {\n   struct table_elt *elt;\n \n@@ -1735,8 +1698,7 @@ insert (x, classp, hash, mode)\n    Any invalid entries in CLASS2 will not be copied.  */\n \n static void\n-merge_equiv_classes (class1, class2)\n-     struct table_elt *class1, *class2;\n+merge_equiv_classes (struct table_elt *class1, struct table_elt *class2)\n {\n   struct table_elt *elt, *next, *new;\n \n@@ -1783,7 +1745,7 @@ merge_equiv_classes (class1, class2)\n /* Flush the entire hash table.  */\n \n static void\n-flush_hash_table ()\n+flush_hash_table (void)\n {\n   int i;\n   struct table_elt *p;\n@@ -1808,9 +1770,7 @@ struct check_dependence_data\n };\n \n static int\n-check_dependence (x, data)\n-     rtx *x;\n-     void *data;\n+check_dependence (rtx *x, void *data)\n {\n   struct check_dependence_data *d = (struct check_dependence_data *) data;\n   if (*x && GET_CODE (*x) == MEM)\n@@ -1832,9 +1792,7 @@ check_dependence (x, data)\n    or it may be either of those plus a numeric offset.  */\n \n static void\n-invalidate (x, full_mode)\n-     rtx x;\n-     enum machine_mode full_mode;\n+invalidate (rtx x, enum machine_mode full_mode)\n {\n   int i;\n   struct table_elt *p;\n@@ -1974,8 +1932,7 @@ invalidate (x, full_mode)\n    expressions to reappear as valid.  */\n \n static void\n-remove_invalid_refs (regno)\n-     unsigned int regno;\n+remove_invalid_refs (unsigned int regno)\n {\n   unsigned int i;\n   struct table_elt *p, *next;\n@@ -1993,10 +1950,8 @@ remove_invalid_refs (regno)\n /* Likewise for a subreg with subreg_reg REGNO, subreg_byte OFFSET,\n    and mode MODE.  */\n static void\n-remove_invalid_subreg_refs (regno, offset, mode)\n-     unsigned int regno;\n-     unsigned int offset;\n-     enum machine_mode mode;\n+remove_invalid_subreg_refs (unsigned int regno, unsigned int offset,\n+\t\t\t    enum machine_mode mode)\n {\n   unsigned int i;\n   struct table_elt *p, *next;\n@@ -2026,8 +1981,7 @@ remove_invalid_subreg_refs (regno, offset, mode)\n    This is called when we make a jump equivalence.  */\n \n static void\n-rehash_using_reg (x)\n-     rtx x;\n+rehash_using_reg (rtx x)\n {\n   unsigned int i;\n   struct table_elt *p, *next;\n@@ -2077,7 +2031,7 @@ rehash_using_reg (x)\n    register.  Also update their TICK values.  */\n \n static void\n-invalidate_for_call ()\n+invalidate_for_call (void)\n {\n   unsigned int regno, endregno;\n   unsigned int i;\n@@ -2136,9 +2090,7 @@ invalidate_for_call ()\n    If none can be found, return 0.  */\n \n static rtx\n-use_related_value (x, elt)\n-     rtx x;\n-     struct table_elt *elt;\n+use_related_value (rtx x, struct table_elt *elt)\n {\n   struct table_elt *relt = 0;\n   struct table_elt *p, *q;\n@@ -2206,8 +2158,7 @@ use_related_value (x, elt)\n \f\n /* Hash a string.  Just add its bytes up.  */\n static inline unsigned\n-canon_hash_string (ps)\n-     const char *ps;\n+canon_hash_string (const char *ps)\n {\n   unsigned hash = 0;\n   const unsigned char *p = (const unsigned char *) ps;\n@@ -2233,9 +2184,7 @@ canon_hash_string (ps)\n    is just (int) MEM plus the hash code of the address.  */\n \n static unsigned\n-canon_hash (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+canon_hash (rtx x, enum machine_mode mode)\n {\n   int i, j;\n   unsigned hash = 0;\n@@ -2287,7 +2236,7 @@ canon_hash (x, mode)\n \t  record = false;\n \telse\n \t  record = true;\n-\t    \n+\n \tif (!record)\n \t  {\n \t    do_not_record = 1;\n@@ -2487,9 +2436,7 @@ canon_hash (x, mode)\n /* Like canon_hash but with no side effects.  */\n \n static unsigned\n-safe_hash (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n+safe_hash (rtx x, enum machine_mode mode)\n {\n   int save_do_not_record = do_not_record;\n   int save_hash_arg_in_memory = hash_arg_in_memory;\n@@ -2515,10 +2462,7 @@ safe_hash (x, mode)\n    is the same as that of the given value is pure luck.  */\n \n static int\n-exp_equiv_p (x, y, validate, equal_values)\n-     rtx x, y;\n-     int validate;\n-     int equal_values;\n+exp_equiv_p (rtx x, rtx y, int validate, int equal_values)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -2710,9 +2654,7 @@ exp_equiv_p (x, y, validate, equal_values)\n    against certain constants or near-constants.  */\n \n static int\n-cse_rtx_varies_p (x, from_alias)\n-     rtx x;\n-     int from_alias;\n+cse_rtx_varies_p (rtx x, int from_alias)\n {\n   /* We need not check for X and the equivalence class being of the same\n      mode because if X is equivalent to a constant in some mode, it\n@@ -2780,9 +2722,7 @@ cse_rtx_varies_p (x, from_alias)\n    generally be discarded since the changes we are making are optional.  */\n \n static rtx\n-canon_reg (x, insn)\n-     rtx x;\n-     rtx insn;\n+canon_reg (rtx x, rtx insn)\n {\n   int i;\n   enum rtx_code code;\n@@ -2879,10 +2819,7 @@ canon_reg (x, insn)\n    hard registers here because we would also prefer the pseudo registers.  */\n \n static void\n-find_best_addr (insn, loc, mode)\n-     rtx insn;\n-     rtx *loc;\n-     enum machine_mode mode;\n+find_best_addr (rtx insn, rtx *loc, enum machine_mode mode)\n {\n   struct table_elt *elt;\n   rtx addr = *loc;\n@@ -3095,10 +3032,8 @@ find_best_addr (insn, loc, mode)\n    A or the code corresponding to the inverse of the comparison.  */\n \n static enum rtx_code\n-find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n-     enum rtx_code code;\n-     rtx *parg1, *parg2;\n-     enum machine_mode *pmode1, *pmode2;\n+find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n+\t\t      enum machine_mode *pmode1, enum machine_mode *pmode2)\n {\n   rtx arg1, arg2;\n \n@@ -3293,9 +3228,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n    of X before modifying it.  */\n \n static rtx\n-fold_rtx (x, insn)\n-     rtx x;\n-     rtx insn;\n+fold_rtx (rtx x, rtx insn)\n {\n   enum rtx_code code;\n   enum machine_mode mode;\n@@ -3851,8 +3784,8 @@ fold_rtx (x, insn)\n       || code == UNORDERED)\n     {\n       if (must_swap || (const_arg0\n-\t  \t\t&& (const_arg1 == 0\n-\t      \t\t    || (GET_CODE (const_arg0) == CONST_INT\n+\t\t\t&& (const_arg1 == 0\n+\t\t\t    || (GET_CODE (const_arg0) == CONST_INT\n \t\t\t        && GET_CODE (const_arg1) != CONST_INT))))\n \t{\n \t  rtx tem = XEXP (x, 0);\n@@ -4323,8 +4256,7 @@ fold_rtx (x, insn)\n    Return 0 if we don't know one.  */\n \n static rtx\n-equiv_constant (x)\n-     rtx x;\n+equiv_constant (rtx x)\n {\n   if (GET_CODE (x) == REG\n       && REGNO_QTY_VALID_P (REGNO (x)))\n@@ -4374,9 +4306,7 @@ equiv_constant (x)\n    This is similar to gen_lowpart in emit-rtl.c.  */\n \n rtx\n-gen_lowpart_if_possible (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_lowpart_if_possible (enum machine_mode mode, rtx x)\n {\n   rtx result = gen_lowpart_common (mode, x);\n \n@@ -4412,16 +4342,14 @@ gen_lowpart_if_possible (mode, x)\n \n    In certain cases, this can cause us to add an equivalence.  For example,\n    if we are following the taken case of\n-   \tif (i == 2)\n+\tif (i == 2)\n    we can add the fact that `i' and '2' are now equivalent.\n \n    In any case, we can record that this comparison was passed.  If the same\n    comparison is seen later, we will know its value.  */\n \n static void\n-record_jump_equiv (insn, taken)\n-     rtx insn;\n-     int taken;\n+record_jump_equiv (rtx insn, int taken)\n {\n   int cond_known_true;\n   rtx op0, op1;\n@@ -4472,11 +4400,8 @@ record_jump_equiv (insn, taken)\n    above function and called recursively.  */\n \n static void\n-record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n-     enum rtx_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1;\n-     int reversed_nonequality;\n+record_jump_cond (enum rtx_code code, enum machine_mode mode, rtx op0,\n+\t\t  rtx op1, int reversed_nonequality)\n {\n   unsigned op0_hash, op1_hash;\n   int op0_in_memory, op1_in_memory;\n@@ -4727,9 +4652,7 @@ struct set\n };\n \n static void\n-cse_insn (insn, libcall_insn)\n-     rtx insn;\n-     rtx libcall_insn;\n+cse_insn (rtx insn, rtx libcall_insn)\n {\n   rtx x = PATTERN (insn);\n   int i;\n@@ -6288,7 +6211,7 @@ cse_insn (insn, libcall_insn)\n \t    }\n \t  while (prev && GET_CODE (prev) == NOTE\n \t\t && NOTE_LINE_NUMBER (prev) != NOTE_INSN_BASIC_BLOCK);\n-\t    \n+\n \t  /* Do not swap the registers around if the previous instruction\n \t     attaches a REG_EQUIV note to REG1.\n \n@@ -6370,7 +6293,7 @@ cse_insn (insn, libcall_insn)\n /* Remove from the hash table all expressions that reference memory.  */\n \n static void\n-invalidate_memory ()\n+invalidate_memory (void)\n {\n   int i;\n   struct table_elt *p, *next;\n@@ -6388,8 +6311,7 @@ invalidate_memory ()\n    1 and update the register tables to show the effect.  Else, return 0.  */\n \n static int\n-addr_affects_sp_p (addr)\n-     rtx addr;\n+addr_affects_sp_p (rtx addr)\n {\n   if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n       && GET_CODE (XEXP (addr, 0)) == REG\n@@ -6420,8 +6342,7 @@ addr_affects_sp_p (addr)\n    X is the pattern of the insn.  */\n \n static void\n-invalidate_from_clobbers (x)\n-     rtx x;\n+invalidate_from_clobbers (rtx x)\n {\n   if (GET_CODE (x) == CLOBBER)\n     {\n@@ -6466,9 +6387,7 @@ invalidate_from_clobbers (x)\n    Return the replacement for X.  */\n \n static rtx\n-cse_process_notes (x, object)\n-     rtx x;\n-     rtx object;\n+cse_process_notes (rtx x, rtx object)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -6560,8 +6479,7 @@ cse_process_notes (x, object)\n    jumps to a label used only once.  */\n \n static void\n-cse_around_loop (loop_start)\n-     rtx loop_start;\n+cse_around_loop (rtx loop_start)\n {\n   rtx insn;\n   int i;\n@@ -6632,10 +6550,7 @@ cse_around_loop (loop_start)\n    since they are done elsewhere.  This function is called via note_stores.  */\n \n static void\n-invalidate_skipped_set (dest, set, data)\n-     rtx set;\n-     rtx dest;\n-     void *data ATTRIBUTE_UNUSED;\n+invalidate_skipped_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (dest);\n \n@@ -6669,8 +6584,7 @@ invalidate_skipped_set (dest, set, data)\n    conditionally executed.  */\n \n static void\n-invalidate_skipped_block (start)\n-     rtx start;\n+invalidate_skipped_block (rtx start)\n {\n   rtx insn;\n \n@@ -6697,10 +6611,7 @@ invalidate_skipped_block (start)\n    NULL_RTX.  */\n \n static void\n-cse_check_loop_start (x, set, data)\n-     rtx x;\n-     rtx set ATTRIBUTE_UNUSED;\n-     void *data;\n+cse_check_loop_start (rtx x, rtx set ATTRIBUTE_UNUSED, void *data)\n {\n   rtx *cse_check_loop_start_value = (rtx *) data;\n \n@@ -6731,10 +6642,7 @@ cse_check_loop_start (x, set, data)\n    In any event, we invalidate whatever this SET or CLOBBER modifies.  */\n \n static void\n-cse_set_around_loop (x, insn, loop_start)\n-     rtx x;\n-     rtx insn;\n-     rtx loop_start;\n+cse_set_around_loop (rtx x, rtx insn, rtx loop_start)\n {\n   struct table_elt *src_elt;\n \n@@ -6841,12 +6749,8 @@ cse_set_around_loop (x, insn, loop_start)\n    to construct the output branch path.  */\n \n void\n-cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n-     rtx insn;\n-     struct cse_basic_block_data *data;\n-     int follow_jumps;\n-     int after_loop;\n-     int skip_blocks;\n+cse_end_of_basic_block (rtx insn, struct cse_basic_block_data *data,\n+\t\t\tint follow_jumps, int after_loop, int skip_blocks)\n {\n   rtx p = insn, q;\n   int nsets = 0;\n@@ -7063,11 +6967,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n    in conditional jump instructions.  */\n \n int\n-cse_main (f, nregs, after_loop, file)\n-     rtx f;\n-     int nregs;\n-     int after_loop;\n-     FILE *file;\n+cse_main (rtx f, int nregs, int after_loop, FILE *file)\n {\n   struct cse_basic_block_data val;\n   rtx insn = f;\n@@ -7213,10 +7113,8 @@ cse_main (f, nregs, after_loop, file)\n    block and this CSE pass is before loop.c.  */\n \n static rtx\n-cse_basic_block (from, to, next_branch, around_loop)\n-     rtx from, to;\n-     struct branch_path *next_branch;\n-     int around_loop;\n+cse_basic_block (rtx from, rtx to, struct branch_path *next_branch,\n+\t\t int around_loop)\n {\n   rtx insn;\n   int to_usage = 0;\n@@ -7429,9 +7327,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n    there isn't a REG_LABEL note.  Return one if so.  DATA is the insn.  */\n \n static int\n-check_for_label_ref (rtl, data)\n-     rtx *rtl;\n-     void *data;\n+check_for_label_ref (rtx *rtl, void *data)\n {\n   rtx insn = (rtx) data;\n \n@@ -7455,11 +7351,7 @@ check_for_label_ref (rtl, data)\n    modify the liveness of DEST.  */\n \n static void\n-count_reg_usage (x, counts, dest, incr)\n-     rtx x;\n-     int *counts;\n-     rtx dest;\n-     int incr;\n+count_reg_usage (rtx x, int *counts, rtx dest, int incr)\n {\n   enum rtx_code code;\n   rtx note;\n@@ -7563,10 +7455,8 @@ count_reg_usage (x, counts, dest, incr)\n \f\n /* Return true if set is live.  */\n static bool\n-set_live_p (set, insn, counts)\n-     rtx set;\n-     rtx insn ATTRIBUTE_UNUSED;\t/* Only used with HAVE_cc0.  */\n-     int *counts;\n+set_live_p (rtx set, rtx insn ATTRIBUTE_UNUSED, /* Only used with HAVE_cc0.  */\n+\t    int *counts)\n {\n #ifdef HAVE_cc0\n   rtx tem;\n@@ -7599,9 +7489,7 @@ set_live_p (set, insn, counts)\n /* Return true if insn is live.  */\n \n static bool\n-insn_live_p (insn, counts)\n-     rtx insn;\n-     int *counts;\n+insn_live_p (rtx insn, int *counts)\n {\n   int i;\n   if (flag_non_call_exceptions && may_trap_p (PATTERN (insn)))\n@@ -7631,9 +7519,7 @@ insn_live_p (insn, counts)\n /* Return true if libcall is dead as a whole.  */\n \n static bool\n-dead_libcall_p (insn, counts)\n-     rtx insn;\n-     int *counts;\n+dead_libcall_p (rtx insn, int *counts)\n {\n   rtx note, set, new;\n \n@@ -7676,7 +7562,7 @@ dead_libcall_p (insn, counts)\n \t  return true;\n \t}\n     }\n-      \n+\n   count_reg_usage (insn, counts, NULL_RTX, 1);\n   return false;\n }\n@@ -7690,9 +7576,7 @@ dead_libcall_p (insn, counts)\n    remaining passes of the compilation are also sped up.  */\n \n int\n-delete_trivially_dead_insns (insns, nreg)\n-     rtx insns;\n-     int nreg;\n+delete_trivially_dead_insns (rtx insns, int nreg)\n {\n   int *counts;\n   rtx insn, prev;"}, {"sha": "91c63b66b0e8b38f48774c706855facc37728d58", "filename": "gcc/cselib.c", "status": "modified", "additions": 64, "deletions": 113, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -40,34 +40,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hashtab.h\"\n #include \"cselib.h\"\n \n-static int entry_and_rtx_equal_p\tPARAMS ((const void *, const void *));\n-static hashval_t get_value_hash\t\tPARAMS ((const void *));\n-static struct elt_list *new_elt_list\tPARAMS ((struct elt_list *,\n-\t\t\t\t\t\t cselib_val *));\n-static struct elt_loc_list *new_elt_loc_list PARAMS ((struct elt_loc_list *,\n-\t\t\t\t\t\t      rtx));\n-static void unchain_one_value\t\tPARAMS ((cselib_val *));\n-static void unchain_one_elt_list\tPARAMS ((struct elt_list **));\n-static void unchain_one_elt_loc_list\tPARAMS ((struct elt_loc_list **));\n-static void clear_table\t\t\tPARAMS ((void));\n-static int discard_useless_locs\t\tPARAMS ((void **, void *));\n-static int discard_useless_values\tPARAMS ((void **, void *));\n-static void remove_useless_values\tPARAMS ((void));\n-static rtx wrap_constant\t\tPARAMS ((enum machine_mode, rtx));\n-static unsigned int hash_rtx\t\tPARAMS ((rtx, enum machine_mode, int));\n-static cselib_val *new_cselib_val\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static void add_mem_for_addr\t\tPARAMS ((cselib_val *, cselib_val *,\n-\t\t\t\t\t\t rtx));\n-static cselib_val *cselib_lookup_mem\tPARAMS ((rtx, int));\n-static void cselib_invalidate_regno\tPARAMS ((unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static int cselib_mem_conflict_p\tPARAMS ((rtx, rtx));\n-static void cselib_invalidate_mem\tPARAMS ((rtx));\n-static void cselib_invalidate_rtx\tPARAMS ((rtx, rtx, void *));\n-static void cselib_record_set\t\tPARAMS ((rtx, cselib_val *,\n-\t\t\t\t\t\t cselib_val *));\n-static void cselib_record_sets\t\tPARAMS ((rtx));\n+static int entry_and_rtx_equal_p (const void *, const void *);\n+static hashval_t get_value_hash (const void *);\n+static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n+static struct elt_loc_list *new_elt_loc_list (struct elt_loc_list *, rtx);\n+static void unchain_one_value (cselib_val *);\n+static void unchain_one_elt_list (struct elt_list **);\n+static void unchain_one_elt_loc_list (struct elt_loc_list **);\n+static void clear_table (void);\n+static int discard_useless_locs (void **, void *);\n+static int discard_useless_values (void **, void *);\n+static void remove_useless_values (void);\n+static rtx wrap_constant (enum machine_mode, rtx);\n+static unsigned int hash_rtx (rtx, enum machine_mode, int);\n+static cselib_val *new_cselib_val (unsigned int, enum machine_mode);\n+static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n+static cselib_val *cselib_lookup_mem (rtx, int);\n+static void cselib_invalidate_regno (unsigned int, enum machine_mode);\n+static int cselib_mem_conflict_p (rtx, rtx);\n+static void cselib_invalidate_mem (rtx);\n+static void cselib_invalidate_rtx (rtx, rtx, void *);\n+static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n+static void cselib_record_sets (rtx);\n \n /* There are three ways in which cselib can look up an rtx:\n    - for a REG, the reg_values table (which is indexed by regno) is used\n@@ -136,7 +130,7 @@ static int values_became_useless;\n    presence in the list by checking the next pointer.  */\n static cselib_val dummy_val;\n \n-/* Used to list all values that contain memory reference. \n+/* Used to list all values that contain memory reference.\n    May or may not contain the useless values - the list is compacted\n    each time memory is invalidated.  */\n static cselib_val *first_containing_mem = &dummy_val;\n@@ -146,9 +140,7 @@ static cselib_val *first_containing_mem = &dummy_val;\n    arguments.  */\n \n static struct elt_list *\n-new_elt_list (next, elt)\n-     struct elt_list *next;\n-     cselib_val *elt;\n+new_elt_list (struct elt_list *next, cselib_val *elt)\n {\n   struct elt_list *el = empty_elt_lists;\n \n@@ -165,9 +157,7 @@ new_elt_list (next, elt)\n    arguments.  */\n \n static struct elt_loc_list *\n-new_elt_loc_list (next, loc)\n-     struct elt_loc_list *next;\n-     rtx loc;\n+new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n {\n   struct elt_loc_list *el = empty_elt_loc_lists;\n \n@@ -186,8 +176,7 @@ new_elt_loc_list (next, loc)\n    storage.  */\n \n static void\n-unchain_one_elt_list (pl)\n-     struct elt_list **pl;\n+unchain_one_elt_list (struct elt_list **pl)\n {\n   struct elt_list *l = *pl;\n \n@@ -199,8 +188,7 @@ unchain_one_elt_list (pl)\n /* Likewise for elt_loc_lists.  */\n \n static void\n-unchain_one_elt_loc_list (pl)\n-     struct elt_loc_list **pl;\n+unchain_one_elt_loc_list (struct elt_loc_list **pl)\n {\n   struct elt_loc_list *l = *pl;\n \n@@ -213,8 +201,7 @@ unchain_one_elt_loc_list (pl)\n    V.  */\n \n static void\n-unchain_one_value (v)\n-     cselib_val *v;\n+unchain_one_value (cselib_val *v)\n {\n   while (v->addr_list)\n     unchain_one_elt_list (&v->addr_list);\n@@ -228,7 +215,7 @@ unchain_one_value (v)\n    which are known to have been used.  */\n \n static void\n-clear_table ()\n+clear_table (void)\n {\n   unsigned int i;\n \n@@ -254,8 +241,7 @@ clear_table ()\n    CONST of an appropriate mode.  */\n \n static int\n-entry_and_rtx_equal_p (entry, x_arg)\n-     const void *entry, *x_arg;\n+entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n {\n   struct elt_loc_list *l;\n   const cselib_val *v = (const cselib_val *) entry;\n@@ -273,7 +259,7 @@ entry_and_rtx_equal_p (entry, x_arg)\n       && (GET_CODE (XEXP (x, 0)) == CONST_INT\n \t  || GET_CODE (XEXP (x, 0)) == CONST_DOUBLE))\n     x = XEXP (x, 0);\n-  \n+\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n@@ -288,8 +274,7 @@ entry_and_rtx_equal_p (entry, x_arg)\n    value from a cselib_val structure.  */\n \n static hashval_t\n-get_value_hash (entry)\n-     const void *entry;\n+get_value_hash (const void *entry)\n {\n   const cselib_val *v = (const cselib_val *) entry;\n   return v->value;\n@@ -301,9 +286,7 @@ get_value_hash (entry)\n    removed.  */\n \n int\n-references_value_p (x, only_useless)\n-     rtx x;\n-     int only_useless;\n+references_value_p (rtx x, int only_useless)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -331,9 +314,7 @@ references_value_p (x, only_useless)\n    htab_traverse.  */\n \n static int\n-discard_useless_locs (x, info)\n-     void **x;\n-     void *info ATTRIBUTE_UNUSED;\n+discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = (cselib_val *)*x;\n   struct elt_loc_list **p = &v->locs;\n@@ -358,9 +339,7 @@ discard_useless_locs (x, info)\n /* If X is a value with no locations, remove it from the hashtable.  */\n \n static int\n-discard_useless_values (x, info)\n-     void **x;\n-     void *info ATTRIBUTE_UNUSED;\n+discard_useless_values (void **x, void *info ATTRIBUTE_UNUSED)\n {\n   cselib_val *v = (cselib_val *)*x;\n \n@@ -378,7 +357,7 @@ discard_useless_values (x, info)\n    associated with them) from the hash table.  */\n \n static void\n-remove_useless_values ()\n+remove_useless_values (void)\n {\n   cselib_val **p, *v;\n   /* First pass: eliminate locations that reference the value.  That in\n@@ -412,8 +391,7 @@ remove_useless_values ()\n    VOIDmode.  */\n \n enum machine_mode\n-cselib_reg_set_mode (x)\n-     rtx x;\n+cselib_reg_set_mode (rtx x)\n {\n   if (GET_CODE (x) != REG)\n     return GET_MODE (x);\n@@ -429,13 +407,12 @@ cselib_reg_set_mode (x)\n    our gathered information into account.  */\n \n int\n-rtx_equal_for_cselib_p (x, y)\n-     rtx x, y;\n+rtx_equal_for_cselib_p (rtx x, rtx y)\n {\n   enum rtx_code code;\n   const char *fmt;\n   int i;\n-  \n+\n   if (GET_CODE (x) == REG || GET_CODE (x) == MEM)\n     {\n       cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n@@ -473,7 +450,7 @@ rtx_equal_for_cselib_p (x, y)\n \t  else if (rtx_equal_for_cselib_p (t, y))\n \t    return 1;\n \t}\n-      \n+\n       return 0;\n     }\n \n@@ -491,7 +468,7 @@ rtx_equal_for_cselib_p (x, y)\n \t  else if (rtx_equal_for_cselib_p (x, t))\n \t    return 1;\n \t}\n-      \n+\n       return 0;\n     }\n \n@@ -501,7 +478,7 @@ rtx_equal_for_cselib_p (x, y)\n   /* This won't be handled correctly by the code below.  */\n   if (GET_CODE (x) == LABEL_REF)\n     return XEXP (x, 0) == XEXP (y, 0);\n-  \n+\n   code = GET_CODE (x);\n   fmt = GET_RTX_FORMAT (code);\n \n@@ -568,9 +545,7 @@ rtx_equal_for_cselib_p (x, y)\n    functions.  For that purpose, wrap them in a CONST of the appropriate\n    mode.  */\n static rtx\n-wrap_constant (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+wrap_constant (enum machine_mode mode, rtx x)\n {\n   if (GET_CODE (x) != CONST_INT\n       && (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != VOIDmode))\n@@ -590,10 +565,7 @@ wrap_constant (mode, x)\n    otherwise the mode of X is used.  */\n \n static unsigned int\n-hash_rtx (x, mode, create)\n-     rtx x;\n-     enum machine_mode mode;\n-     int create;\n+hash_rtx (rtx x, enum machine_mode mode, int create)\n {\n   cselib_val *e;\n   int i, j;\n@@ -673,7 +645,7 @@ hash_rtx (x, mode, create)\n \treturn 0;\n \n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -725,9 +697,7 @@ hash_rtx (x, mode, create)\n    value is MODE.  */\n \n static cselib_val *\n-new_cselib_val (value, mode)\n-     unsigned int value;\n-     enum machine_mode mode;\n+new_cselib_val (unsigned int value, enum machine_mode mode)\n {\n   cselib_val *e = empty_vals;\n \n@@ -753,9 +723,7 @@ new_cselib_val (value, mode)\n    value.  Update the two value structures to represent this situation.  */\n \n static void\n-add_mem_for_addr (addr_elt, mem_elt, x)\n-     cselib_val *addr_elt, *mem_elt;\n-     rtx x;\n+add_mem_for_addr (cselib_val *addr_elt, cselib_val *mem_elt, rtx x)\n {\n   struct elt_loc_list *l;\n \n@@ -780,9 +748,7 @@ add_mem_for_addr (addr_elt, mem_elt, x)\n    If CREATE, make a new one if we haven't seen it before.  */\n \n static cselib_val *\n-cselib_lookup_mem (x, create)\n-     rtx x;\n-     int create;\n+cselib_lookup_mem (rtx x, int create)\n {\n   enum machine_mode mode = GET_MODE (x);\n   void **slot;\n@@ -822,8 +788,7 @@ cselib_lookup_mem (x, create)\n    allocated.  However, the return value can share rtl with X.  */\n \n rtx\n-cselib_subst_to_values (x)\n-     rtx x;\n+cselib_subst_to_values (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -867,7 +832,7 @@ cselib_subst_to_values (x)\n     case PRE_MODIFY:\n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n       return e->u.val_rtx;\n-      \n+\n     default:\n       break;\n     }\n@@ -915,10 +880,7 @@ cselib_subst_to_values (x)\n    (i.e. because it's a constant).  */\n \n cselib_val *\n-cselib_lookup (x, mode, create)\n-     rtx x;\n-     enum machine_mode mode;\n-     int create;\n+cselib_lookup (rtx x, enum machine_mode mode, int create)\n {\n   void **slot;\n   cselib_val *e;\n@@ -1003,9 +965,7 @@ cselib_lookup (x, mode, create)\n    invalidating call clobbered registers across a call.  */\n \n static void\n-cselib_invalidate_regno (regno, mode)\n-     unsigned int regno;\n-     enum machine_mode mode;\n+cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n {\n   unsigned int endregno;\n   unsigned int i;\n@@ -1023,7 +983,7 @@ cselib_invalidate_regno (regno, mode)\n     {\n       if (mode == VOIDmode)\n \tabort ();\n-      \n+\n       if (regno < max_value_regs)\n \ti = 0;\n       else\n@@ -1094,9 +1054,7 @@ cselib_invalidate_regno (regno, mode)\n    Return whether this change will invalidate VAL.  */\n \n static int\n-cselib_mem_conflict_p (mem_base, val)\n-     rtx mem_base;\n-     rtx val;\n+cselib_mem_conflict_p (rtx mem_base, rtx val)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -1153,8 +1111,7 @@ cselib_mem_conflict_p (mem_base, val)\n    instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n \n static void\n-cselib_invalidate_mem (mem_rtx)\n-     rtx mem_rtx;\n+cselib_invalidate_mem (rtx mem_rtx)\n {\n   cselib_val **vp, *v, *next;\n \n@@ -1224,10 +1181,8 @@ cselib_invalidate_mem (mem_rtx)\n    note_stores; they are ignored.  */\n \n static void\n-cselib_invalidate_rtx (dest, ignore, data)\n-     rtx dest;\n-     rtx ignore ATTRIBUTE_UNUSED;\n-     void *data ATTRIBUTE_UNUSED;\n+cselib_invalidate_rtx (rtx dest, rtx ignore ATTRIBUTE_UNUSED,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n {\n   while (GET_CODE (dest) == STRICT_LOW_PART || GET_CODE (dest) == SIGN_EXTRACT\n \t || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG)\n@@ -1251,9 +1206,7 @@ cselib_invalidate_rtx (dest, ignore, data)\n    describes its address.  */\n \n static void\n-cselib_record_set (dest, src_elt, dest_addr_elt)\n-     rtx dest;\n-     cselib_val *src_elt, *dest_addr_elt;\n+cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n {\n   int dreg = GET_CODE (dest) == REG ? (int) REGNO (dest) : -1;\n \n@@ -1311,8 +1264,7 @@ struct set\n \n /* Record the effects of any sets in INSN.  */\n static void\n-cselib_record_sets (insn)\n-     rtx insn;\n+cselib_record_sets (rtx insn)\n {\n   int n_sets = 0;\n   int i;\n@@ -1393,8 +1345,7 @@ cselib_record_sets (insn)\n /* Record the effects of INSN.  */\n \n void\n-cselib_process_insn (insn)\n-     rtx insn;\n+cselib_process_insn (rtx insn)\n {\n   int i;\n   rtx x;\n@@ -1464,7 +1415,7 @@ cselib_process_insn (insn)\n    it must be called by the user if it allocated new registers.  */\n \n void\n-cselib_update_varray_sizes ()\n+cselib_update_varray_sizes (void)\n {\n   unsigned int nregs = max_reg_num ();\n \n@@ -1480,7 +1431,7 @@ cselib_update_varray_sizes ()\n    init_alias_analysis.  */\n \n void\n-cselib_init ()\n+cselib_init (void)\n {\n   /* This is only created once.  */\n   if (! callmem)\n@@ -1497,15 +1448,15 @@ cselib_init ()\n       VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n       VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n     }\n-  hash_table = htab_create_ggc (31, get_value_hash, entry_and_rtx_equal_p, \n+  hash_table = htab_create_ggc (31, get_value_hash, entry_and_rtx_equal_p,\n \t\t\t\tNULL);\n   cselib_current_insn_in_libcall = false;\n }\n \n /* Called when the current user is done with cselib.  */\n \n void\n-cselib_finish ()\n+cselib_finish (void)\n {\n   clear_table ();\n   reg_values_old = reg_values;"}, {"sha": "7af779406d1ad7af0b0da3f0ea83c51beb494af0", "filename": "gcc/cselib.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -62,12 +62,12 @@ struct elt_list GTY(())\n   cselib_val *elt;\n };\n \n-extern cselib_val *cselib_lookup\tPARAMS ((rtx, enum machine_mode, int));\n-extern void cselib_update_varray_sizes\tPARAMS ((void));\n-extern void cselib_init\t\t\tPARAMS ((void));\n-extern void cselib_finish\t\tPARAMS ((void));\n-extern void cselib_process_insn\t\tPARAMS ((rtx));\n-extern enum machine_mode cselib_reg_set_mode PARAMS ((rtx));\n-extern int rtx_equal_for_cselib_p\tPARAMS ((rtx, rtx));\n-extern int references_value_p\t\tPARAMS ((rtx, int));\n-extern rtx cselib_subst_to_values\tPARAMS ((rtx));\n+extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n+extern void cselib_update_varray_sizes (void);\n+extern void cselib_init (void);\n+extern void cselib_finish (void);\n+extern void cselib_process_insn (rtx);\n+extern enum machine_mode cselib_reg_set_mode (rtx);\n+extern int rtx_equal_for_cselib_p (rtx, rtx);\n+extern int references_value_p (rtx, int);\n+extern rtx cselib_subst_to_values (rtx);"}, {"sha": "4265c9c0a507b67b8c5275a3568b5e5d1602d3a9", "filename": "gcc/dbxout.c", "status": "modified", "additions": 83, "deletions": 132, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -307,46 +307,46 @@ static int current_sym_nchars;\n #define CONTIN do { } while (0)\n #endif\n \n-static void dbxout_init\t\t\tPARAMS ((const char *));\n-static void dbxout_finish\t\tPARAMS ((const char *));\n-static void dbxout_start_source_file\tPARAMS ((unsigned, const char *));\n-static void dbxout_end_source_file\tPARAMS ((unsigned));\n-static void dbxout_typedefs\t\tPARAMS ((tree));\n-static void dbxout_fptype_value\t\tPARAMS ((tree));\n-static void dbxout_type_index\t\tPARAMS ((tree));\n+static void dbxout_init (const char *);\n+static void dbxout_finish (const char *);\n+static void dbxout_start_source_file (unsigned, const char *);\n+static void dbxout_end_source_file (unsigned);\n+static void dbxout_typedefs (tree);\n+static void dbxout_fptype_value (tree);\n+static void dbxout_type_index (tree);\n #if DBX_CONTIN_LENGTH > 0\n-static void dbxout_continue\t\tPARAMS ((void));\n+static void dbxout_continue (void);\n #endif\n-static void dbxout_args\t\t\tPARAMS ((tree));\n-static void dbxout_type_fields\t\tPARAMS ((tree));\n-static void dbxout_type_method_1\tPARAMS ((tree, const char *));\n-static void dbxout_type_methods\t\tPARAMS ((tree));\n-static void dbxout_range_type\t\tPARAMS ((tree));\n-static void dbxout_type\t\t\tPARAMS ((tree, int));\n-static bool print_int_cst_bounds_in_octal_p\tPARAMS ((tree));\n-static void print_int_cst_octal\t\tPARAMS ((tree));\n-static void print_octal\t\t\tPARAMS ((unsigned HOST_WIDE_INT, int));\n-static void print_wide_int\t\tPARAMS ((HOST_WIDE_INT));\n-static void dbxout_type_name\t\tPARAMS ((tree));\n-static void dbxout_class_name_qualifiers PARAMS ((tree));\n-static int dbxout_symbol_location\tPARAMS ((tree, tree, const char *, rtx));\n-static void dbxout_symbol_name\t\tPARAMS ((tree, const char *, int));\n-static void dbxout_prepare_symbol\tPARAMS ((tree));\n-static void dbxout_finish_symbol\tPARAMS ((tree));\n-static void dbxout_block\t\tPARAMS ((tree, int, tree));\n-static void dbxout_global_decl\t\tPARAMS ((tree));\n-static void dbxout_handle_pch\t\tPARAMS ((unsigned));\n+static void dbxout_args (tree);\n+static void dbxout_type_fields (tree);\n+static void dbxout_type_method_1 (tree, const char *);\n+static void dbxout_type_methods (tree);\n+static void dbxout_range_type (tree);\n+static void dbxout_type (tree, int);\n+static bool print_int_cst_bounds_in_octal_p (tree);\n+static void print_int_cst_octal (tree);\n+static void print_octal (unsigned HOST_WIDE_INT, int);\n+static void print_wide_int (HOST_WIDE_INT);\n+static void dbxout_type_name (tree);\n+static void dbxout_class_name_qualifiers (tree);\n+static int dbxout_symbol_location (tree, tree, const char *, rtx);\n+static void dbxout_symbol_name (tree, const char *, int);\n+static void dbxout_prepare_symbol (tree);\n+static void dbxout_finish_symbol (tree);\n+static void dbxout_block (tree, int, tree);\n+static void dbxout_global_decl (tree);\n+static void dbxout_handle_pch (unsigned);\n \f\n /* The debug hooks structure.  */\n #if defined (DBX_DEBUGGING_INFO)\n \n-static void dbxout_source_line\t\tPARAMS ((unsigned int, const char *));\n-static void dbxout_source_file\t\tPARAMS ((FILE *, const char *));\n-static void dbxout_function_end\t\tPARAMS ((void));\n-static void dbxout_begin_function\tPARAMS ((tree));\n-static void dbxout_begin_block\t\tPARAMS ((unsigned, unsigned));\n-static void dbxout_end_block\t\tPARAMS ((unsigned, unsigned));\n-static void dbxout_function_decl\tPARAMS ((tree));\n+static void dbxout_source_line (unsigned int, const char *);\n+static void dbxout_source_file (FILE *, const char *);\n+static void dbxout_function_end (void);\n+static void dbxout_begin_function (tree);\n+static void dbxout_begin_block (unsigned, unsigned);\n+static void dbxout_end_block (unsigned, unsigned);\n+static void dbxout_function_decl (tree);\n \n const struct gcc_debug_hooks dbx_debug_hooks =\n {\n@@ -407,7 +407,7 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n \f\n #if defined (DBX_DEBUGGING_INFO)\n static void\n-dbxout_function_end ()\n+dbxout_function_end (void)\n {\n   char lscope_label_name[100];\n   /* Convert Ltext into the appropriate format for local labels in case\n@@ -435,8 +435,7 @@ dbxout_function_end ()\n    Initialize `typevec' and output the standard data types of C.  */\n \n static void\n-dbxout_init (input_file_name)\n-     const char *input_file_name;\n+dbxout_init (const char *input_file_name)\n {\n   char ltext_label_name[100];\n   tree syms = (*lang_hooks.decls.getdecls) ();\n@@ -526,8 +525,7 @@ dbxout_init (input_file_name)\n    in the reverse order from that which is found in SYMS.  */\n \n static void\n-dbxout_typedefs (syms)\n-     tree syms;\n+dbxout_typedefs (tree syms)\n {\n   if (syms)\n     {\n@@ -547,9 +545,8 @@ dbxout_typedefs (syms)\n /* Change to reading from a new source file.  Generate a N_BINCL stab.  */\n \n static void\n-dbxout_start_source_file (line, filename)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *filename ATTRIBUTE_UNUSED;\n+dbxout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t\t  const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_USE_BINCL\n   struct dbx_file *n = (struct dbx_file *) ggc_alloc (sizeof *n);\n@@ -567,8 +564,7 @@ dbxout_start_source_file (line, filename)\n /* Revert to reading a previous source file.  Generate a N_EINCL stab.  */\n \n static void\n-dbxout_end_source_file (line)\n-     unsigned int line ATTRIBUTE_UNUSED;\n+dbxout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_USE_BINCL\n   fprintf (asmfile, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n@@ -605,9 +601,7 @@ dbxout_handle_pch (unsigned at_end)\n /* Output debugging info to FILE to switch to sourcefile FILENAME.  */\n \n static void\n-dbxout_source_file (file, filename)\n-     FILE *file;\n-     const char *filename;\n+dbxout_source_file (FILE *file, const char *filename)\n {\n   if (lastfile == 0 && lastfile_is_base)\n     {\n@@ -641,9 +635,7 @@ dbxout_source_file (file, filename)\n    number LINENO.  */\n \n static void\n-dbxout_source_line (lineno, filename)\n-     unsigned int lineno;\n-     const char *filename;\n+dbxout_source_line (unsigned int lineno, const char *filename)\n {\n   dbxout_source_file (asmfile, filename);\n \n@@ -658,19 +650,15 @@ dbxout_source_line (lineno, filename)\n /* Describe the beginning of an internal block within a function.  */\n \n static void\n-dbxout_begin_block (line, n)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     unsigned int n;\n+dbxout_begin_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   (*targetm.asm_out.internal_label) (asmfile, \"LBB\", n);\n }\n \n /* Describe the end line-number of an internal block within a function.  */\n \n static void\n-dbxout_end_block (line, n)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     unsigned int n;\n+dbxout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int n)\n {\n   (*targetm.asm_out.internal_label) (asmfile, \"LBE\", n);\n }\n@@ -682,8 +670,7 @@ dbxout_end_block (line, n)\n    (including all the auto variables of the function).  */\n \n static void\n-dbxout_function_decl (decl)\n-     tree decl;\n+dbxout_function_decl (tree decl)\n {\n #ifndef DBX_FUNCTION_FIRST\n   dbxout_begin_function (decl);\n@@ -705,8 +692,7 @@ dbxout_function_decl (decl)\n /* Debug information for a global DECL.  Called from toplev.c after\n    compilation proper has finished.  */\n static void\n-dbxout_global_decl (decl)\n-     tree decl;\n+dbxout_global_decl (tree decl)\n {\n   if (TREE_CODE (decl) == VAR_DECL\n       && ! DECL_EXTERNAL (decl)\n@@ -724,8 +710,7 @@ dbxout_global_decl (decl)\n    to do nothing.  */\n \n static void\n-dbxout_finish (filename)\n-     const char *filename ATTRIBUTE_UNUSED;\n+dbxout_finish (const char *filename ATTRIBUTE_UNUSED)\n {\n #ifdef DBX_OUTPUT_MAIN_SOURCE_FILE_END\n   DBX_OUTPUT_MAIN_SOURCE_FILE_END (asmfile, filename);\n@@ -752,8 +737,7 @@ dbxout_finish (filename)\n    them.  */\n \n static void\n-dbxout_fptype_value (type)\n-     tree type;\n+dbxout_fptype_value (tree type)\n {\n   char value = '0';\n   enum machine_mode mode = TYPE_MODE (type);\n@@ -792,8 +776,7 @@ dbxout_fptype_value (type)\n /* Output the index of a type.  */\n \n static void\n-dbxout_type_index (type)\n-     tree type;\n+dbxout_type_index (tree type)\n {\n #ifndef DBX_USE_BINCL\n   fprintf (asmfile, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n@@ -813,7 +796,7 @@ dbxout_type_index (type)\n    .stabs \"...rest\",code,0,value   */\n \n static void\n-dbxout_continue ()\n+dbxout_continue (void)\n {\n #ifdef DBX_CONTIN_CHAR\n   fprintf (asmfile, \"%c\", DBX_CONTIN_CHAR);\n@@ -831,8 +814,7 @@ dbxout_continue ()\n    recursive calls.  */\n \n static void\n-dbxout_type_fields (type)\n-     tree type;\n+dbxout_type_fields (tree type)\n {\n   tree tem;\n \n@@ -922,9 +904,7 @@ dbxout_type_fields (type)\n    now.  */\n \n static void\n-dbxout_type_method_1 (decl, debug_name)\n-     tree decl;\n-     const char *debug_name;\n+dbxout_type_method_1 (tree decl, const char *debug_name)\n {\n   char c1 = 'A', c2;\n \n@@ -969,8 +949,7 @@ dbxout_type_method_1 (decl, debug_name)\n    in TYPE.  */\n \n static void\n-dbxout_type_methods (type)\n-     tree type;\n+dbxout_type_methods (tree type)\n {\n   /* C++: put out the method names and their parameter lists */\n   tree methods = TYPE_METHODS (type);\n@@ -1075,8 +1054,7 @@ dbxout_type_methods (type)\n    TYPE is an INTEGER_TYPE.  */\n \n static void\n-dbxout_range_type (type)\n-     tree type;\n+dbxout_range_type (tree type)\n {\n   fprintf (asmfile, \"r\");\n   if (TREE_TYPE (type))\n@@ -1150,9 +1128,7 @@ dbxout_range_type (type)\n    using the number previously allocated.  */\n \n static void\n-dbxout_type (type, full)\n-     tree type;\n-     int full;\n+dbxout_type (tree type, int full)\n {\n   tree tem;\n   tree main_variant;\n@@ -1199,7 +1175,7 @@ dbxout_type (type, full)\n \t{\n \t  typevec\n \t    = (struct typeinfo *) ggc_realloc (typevec,\n-\t\t\t\t\t       (typevec_len * 2 \n+\t\t\t\t\t       (typevec_len * 2\n \t\t\t\t\t\t* sizeof typevec[0]));\n \t  memset ((char *) (typevec + typevec_len), 0,\n \t\t typevec_len * sizeof typevec[0]);\n@@ -1228,7 +1204,7 @@ dbxout_type (type, full)\n \t       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n \tdebug_queue_symbol (TYPE_NAME (type));\n     }\n-  \n+\n   /* Output the number of this type, to refer to it.  */\n   dbxout_type_index (type);\n \n@@ -1316,7 +1292,7 @@ dbxout_type (type, full)\n         {\n           tree orig_type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));\n \n-          if ((TREE_CODE (orig_type) == RECORD_TYPE  \n+          if ((TREE_CODE (orig_type) == RECORD_TYPE\n                || TREE_CODE (orig_type) == UNION_TYPE\n                || TREE_CODE (orig_type) == QUAL_UNION_TYPE\n                || TREE_CODE (orig_type) == ENUMERAL_TYPE)\n@@ -1389,7 +1365,7 @@ dbxout_type (type, full)\n \t      CHARS (5);\n \t    }\n \n- \t  if (print_int_cst_bounds_in_octal_p (type))\n+\t  if (print_int_cst_bounds_in_octal_p (type))\n \t    {\n \t      fprintf (asmfile, \"r\");\n \t      CHARS (1);\n@@ -1654,7 +1630,7 @@ dbxout_type (type, full)\n \t    tree child = BINFO_BASETYPE (binfo, i);\n \t    tree access = (BINFO_BASEACCESSES (binfo)\n \t\t\t   ? BINFO_BASEACCESS (binfo, i) : access_public_node);\n-\t    \n+\n \t    if (use_gnu_debug_info_extensions)\n \t      {\n \t\thave_used_extensions = 1;\n@@ -1854,16 +1830,15 @@ dbxout_type (type, full)\n    should be printed in octal format.  */\n \n static bool\n-print_int_cst_bounds_in_octal_p (type)\n-     tree type;\n+print_int_cst_bounds_in_octal_p (tree type)\n {\n   /* If we can use GDB extensions and the size is wider than a long\n      (the size used by GDB to read them) or we may have trouble writing\n      the bounds the usual way, write them in octal.  Note the test is for\n      the *target's* size of \"long\", not that of the host.  The host test\n      is just to make sure we can write it out in case the host wide int\n      is narrower than the target \"long\".\n-  \n+\n      For unsigned types, we use octal if they are the same size or larger.\n      This is because we print the bounds as signed decimal, and hence they\n      can't span same size unsigned types.  */\n@@ -1888,8 +1863,7 @@ print_int_cst_bounds_in_octal_p (type)\n    handling double precision.  */\n \n static void\n-print_int_cst_octal (c)\n-     tree c;\n+print_int_cst_octal (tree c)\n {\n   unsigned HOST_WIDE_INT high = TREE_INT_CST_HIGH (c);\n   unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (c);\n@@ -1934,9 +1908,7 @@ print_int_cst_octal (c)\n }\n \n static void\n-print_octal (value, digits)\n-     unsigned HOST_WIDE_INT value;\n-     int digits;\n+print_octal (unsigned HOST_WIDE_INT value, int digits)\n {\n   int i;\n \n@@ -1949,8 +1921,7 @@ print_octal (value, digits)\n /* Output C in decimal while adjusting the number of digits written.  */\n \n static void\n-print_wide_int (c)\n-     HOST_WIDE_INT c;\n+print_wide_int (HOST_WIDE_INT c)\n {\n   int digs = 0;\n \n@@ -1970,8 +1941,7 @@ print_wide_int (c)\n    or by struct, enum and union tags.  */\n \n static void\n-dbxout_type_name (type)\n-     tree type;\n+dbxout_type_name (tree type)\n {\n   tree t;\n   if (TYPE_NAME (type) == 0)\n@@ -1995,14 +1965,13 @@ dbxout_type_name (type)\n    type whose scope is limited to a struct or class.  */\n \n static void\n-dbxout_class_name_qualifiers (decl)\n-     tree decl;\n+dbxout_class_name_qualifiers (tree decl)\n {\n   tree context = decl_type_context (decl);\n \n-  if (context != NULL_TREE \n+  if (context != NULL_TREE\n       && TREE_CODE(context) == RECORD_TYPE\n-      && TYPE_NAME (context) != 0 \n+      && TYPE_NAME (context) != 0\n       && (TREE_CODE (TYPE_NAME (context)) == IDENTIFIER_NODE\n           || (DECL_NAME (TYPE_NAME (context)) != 0)))\n     {\n@@ -2025,9 +1994,7 @@ dbxout_class_name_qualifiers (decl)\n    Return 1 if a stabs might have been emitted.  */\n \n int\n-dbxout_symbol (decl, local)\n-     tree decl;\n-     int local ATTRIBUTE_UNUSED;\n+dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n {\n   tree type = TREE_TYPE (decl);\n   tree context = NULL_TREE;\n@@ -2050,7 +2017,7 @@ dbxout_symbol (decl, local)\n   /* If we are to generate only the symbols actualy used then such\n      symbol nodees are flagged with TREE_USED.  Ignore any that\n      aren't flaged as TREE_USED.  */\n-    \n+\n   if (flag_debug_only_used_symbols)\n     {\n       tree t;\n@@ -2069,7 +2036,7 @@ dbxout_symbol (decl, local)\n          pointer to a named type we need to look for the first name\n          we see following the TREE_TYPE chain.  */\n \n-      t = type;    \n+      t = type;\n       while (POINTER_TYPE_P (t))\n         t = TREE_TYPE (t);\n \n@@ -2369,10 +2336,7 @@ dbxout_symbol (decl, local)\n    Returns 1 if the stab was really emitted.  */\n \n static int\n-dbxout_symbol_location (decl, type, suffix, home)\n-     tree decl, type;\n-     const char *suffix;\n-     rtx home;\n+dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n {\n   int letter = 0;\n   int regno = -1;\n@@ -2605,10 +2569,7 @@ dbxout_symbol_location (decl, type, suffix, home)\n    Then output LETTER to indicate the kind of location the symbol has.  */\n \n static void\n-dbxout_symbol_name (decl, suffix, letter)\n-     tree decl;\n-     const char *suffix;\n-     int letter;\n+dbxout_symbol_name (tree decl, const char *suffix, int letter)\n {\n   const char *name;\n \n@@ -2633,8 +2594,7 @@ dbxout_symbol_name (decl, suffix, letter)\n }\n \n static void\n-dbxout_prepare_symbol (decl)\n-     tree decl ATTRIBUTE_UNUSED;\n+dbxout_prepare_symbol (tree decl ATTRIBUTE_UNUSED)\n {\n #ifdef WINNING_GDB\n   const char *filename = DECL_SOURCE_FILE (decl);\n@@ -2644,8 +2604,7 @@ dbxout_prepare_symbol (decl)\n }\n \n static void\n-dbxout_finish_symbol (sym)\n-     tree sym;\n+dbxout_finish_symbol (tree sym)\n {\n #ifdef DBX_FINISH_SYMBOL\n   DBX_FINISH_SYMBOL (sym);\n@@ -2667,8 +2626,7 @@ dbxout_finish_symbol (sym)\n    anything was output */\n \n int\n-dbxout_syms (syms)\n-     tree syms;\n+dbxout_syms (tree syms)\n {\n   int result = 0;\n   while (syms)\n@@ -2692,8 +2650,7 @@ dbxout_syms (syms)\n    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */\n \n void\n-dbxout_parms (parms)\n-     tree parms;\n+dbxout_parms (tree parms)\n {\n   ++debug_nesting;\n \n@@ -2969,8 +2926,7 @@ dbxout_parms (parms)\n    PARMS is a chain of PARM_DECL nodes.  */\n \n void\n-dbxout_reg_parms (parms)\n-     tree parms;\n+dbxout_reg_parms (tree parms)\n {\n   ++debug_nesting;\n \n@@ -3001,8 +2957,7 @@ dbxout_reg_parms (parms)\n    output definitions of those names, in raw form */\n \n static void\n-dbxout_args (args)\n-     tree args;\n+dbxout_args (tree args)\n {\n   while (args)\n     {\n@@ -3031,10 +2986,7 @@ dbxout_args (args)\n    We handle them all in sequence.  */\n \n static void\n-dbxout_block (block, depth, args)\n-     tree block;\n-     int depth;\n-     tree args;\n+dbxout_block (tree block, int depth, tree args)\n {\n   int blocknum = -1;\n \n@@ -3129,14 +3081,13 @@ dbxout_block (block, depth, args)\n \n #if defined (DBX_DEBUGGING_INFO)\n static void\n-dbxout_begin_function (decl)\n-     tree decl;\n+dbxout_begin_function (tree decl)\n {\n   int saved_tree_used1 = TREE_USED (decl);\n   TREE_USED (decl) = 1;\n   if (DECL_NAME (DECL_RESULT (decl)) != 0)\n     {\n-      int saved_tree_used2 = TREE_USED (DECL_RESULT (decl));       \n+      int saved_tree_used2 = TREE_USED (DECL_RESULT (decl));\n       TREE_USED (DECL_RESULT (decl)) = 1;\n       dbxout_symbol (decl, 0);\n       TREE_USED (DECL_RESULT (decl)) = saved_tree_used2;"}, {"sha": "e18ce55448c36fa16301a7fb0dc33e667c0a23db", "filename": "gcc/debug.c", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,5 @@\n /* Do-nothing debug hooks for GCC.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -51,51 +51,44 @@ const struct gcc_debug_hooks do_nothing_debug_hooks =\n    nothing.  */\n \n void\n-debug_nothing_void ()\n+debug_nothing_void (void)\n {\n }\n \n void\n-debug_nothing_tree (decl)\n-     tree decl ATTRIBUTE_UNUSED;\n+debug_nothing_tree (tree decl ATTRIBUTE_UNUSED)\n {\n }\n \n bool\n-debug_true_tree (block)\n-     tree block ATTRIBUTE_UNUSED;\n+debug_true_tree (tree block ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n \n void\n-debug_nothing_rtx (insn)\n-     rtx insn ATTRIBUTE_UNUSED;\n+debug_nothing_rtx (rtx insn ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-debug_nothing_charstar (main_filename)\n-     const char *main_filename ATTRIBUTE_UNUSED;\n+debug_nothing_charstar (const char *main_filename ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-debug_nothing_int_charstar (line, text)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *text ATTRIBUTE_UNUSED;\n+debug_nothing_int_charstar (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t\t    const char *text ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-debug_nothing_int (line)\n-     unsigned int line ATTRIBUTE_UNUSED;\n+debug_nothing_int (unsigned int line ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-debug_nothing_int_int (line, n)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     unsigned int n ATTRIBUTE_UNUSED;\n+debug_nothing_int_int (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t       unsigned int n ATTRIBUTE_UNUSED)\n {\n }"}, {"sha": "b60b428972096bf59e60b7acc095467ea178e19f", "filename": "gcc/df.c", "status": "modified", "additions": 235, "deletions": 540, "changes": 775, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -201,113 +201,103 @@ static alloc_pool df_ref_pool;\n static alloc_pool df_link_pool;\n static struct df *ddf;\n \n-static void df_reg_table_realloc PARAMS((struct df *, int));\n-static void df_insn_table_realloc PARAMS((struct df *, unsigned int));\n-static void df_bitmaps_alloc PARAMS((struct df *, int));\n-static void df_bitmaps_free PARAMS((struct df *, int));\n-static void df_free PARAMS((struct df *));\n-static void df_alloc PARAMS((struct df *, int));\n-\n-static rtx df_reg_clobber_gen PARAMS((unsigned int));\n-static rtx df_reg_use_gen PARAMS((unsigned int));\n-\n-static inline struct df_link *df_link_create PARAMS((struct ref *,\n-\t\t\t\t\t\t     struct df_link *));\n-static struct df_link *df_ref_unlink PARAMS((struct df_link **, struct ref *));\n-static void df_def_unlink PARAMS((struct df *, struct ref *));\n-static void df_use_unlink PARAMS((struct df *, struct ref *));\n-static void df_insn_refs_unlink PARAMS ((struct df *, basic_block, rtx));\n+static void df_reg_table_realloc (struct df *, int);\n+static void df_insn_table_realloc (struct df *, unsigned int);\n+static void df_bitmaps_alloc (struct df *, int);\n+static void df_bitmaps_free (struct df *, int);\n+static void df_free (struct df *);\n+static void df_alloc (struct df *, int);\n+\n+static rtx df_reg_clobber_gen (unsigned int);\n+static rtx df_reg_use_gen (unsigned int);\n+\n+static inline struct df_link *df_link_create (struct ref *, struct df_link *);\n+static struct df_link *df_ref_unlink (struct df_link **, struct ref *);\n+static void df_def_unlink (struct df *, struct ref *);\n+static void df_use_unlink (struct df *, struct ref *);\n+static void df_insn_refs_unlink (struct df *, basic_block, rtx);\n #if 0\n-static void df_bb_refs_unlink PARAMS ((struct df *, basic_block));\n-static void df_refs_unlink PARAMS ((struct df *, bitmap));\n+static void df_bb_refs_unlink (struct df *, basic_block);\n+static void df_refs_unlink (struct df *, bitmap);\n #endif\n \n-static struct ref *df_ref_create PARAMS((struct df *,\n-\t\t\t\t\t rtx, rtx *, rtx,\n-\t\t\t\t\t enum df_ref_type, enum df_ref_flags));\n-static void df_ref_record_1 PARAMS((struct df *, rtx, rtx *,\n-\t\t\t\t    rtx, enum df_ref_type,\n-\t\t\t\t    enum df_ref_flags));\n-static void df_ref_record PARAMS((struct df *, rtx, rtx *,\n-\t\t\t\t  rtx, enum df_ref_type,\n-\t\t\t\t  enum df_ref_flags));\n-static void df_def_record_1 PARAMS((struct df *, rtx, basic_block, rtx));\n-static void df_defs_record PARAMS((struct df *, rtx, basic_block, rtx));\n-static void df_uses_record PARAMS((struct df *, rtx *,\n-\t\t\t\t   enum df_ref_type, basic_block, rtx,\n-\t\t\t\t   enum df_ref_flags));\n-static void df_insn_refs_record PARAMS((struct df *, basic_block, rtx));\n-static void df_bb_refs_record PARAMS((struct df *, basic_block));\n-static void df_refs_record PARAMS((struct df *, bitmap));\n-\n-static void df_bb_reg_def_chain_create PARAMS((struct df *, basic_block));\n-static void df_reg_def_chain_create PARAMS((struct df *, bitmap));\n-static void df_bb_reg_use_chain_create PARAMS((struct df *, basic_block));\n-static void df_reg_use_chain_create PARAMS((struct df *, bitmap));\n-static void df_bb_du_chain_create PARAMS((struct df *, basic_block, bitmap));\n-static void df_du_chain_create PARAMS((struct df *, bitmap));\n-static void df_bb_ud_chain_create PARAMS((struct df *, basic_block));\n-static void df_ud_chain_create PARAMS((struct df *, bitmap));\n-static void df_bb_rd_local_compute PARAMS((struct df *, basic_block));\n-static void df_rd_local_compute PARAMS((struct df *, bitmap));\n-static void df_bb_ru_local_compute PARAMS((struct df *, basic_block));\n-static void df_ru_local_compute PARAMS((struct df *, bitmap));\n-static void df_bb_lr_local_compute PARAMS((struct df *, basic_block));\n-static void df_lr_local_compute PARAMS((struct df *, bitmap));\n-static void df_bb_reg_info_compute PARAMS((struct df *, basic_block, bitmap));\n-static void df_reg_info_compute PARAMS((struct df *, bitmap));\n-\n-static int df_bb_luids_set PARAMS((struct df *df, basic_block));\n-static int df_luids_set PARAMS((struct df *df, bitmap));\n-\n-static int df_modified_p PARAMS ((struct df *, bitmap));\n-static int df_refs_queue PARAMS ((struct df *));\n-static int df_refs_process PARAMS ((struct df *));\n-static int df_bb_refs_update PARAMS ((struct df *, basic_block));\n-static int df_refs_update PARAMS ((struct df *));\n-static void df_analyse_1 PARAMS((struct df *, bitmap, int, int));\n-\n-static void df_insns_modify PARAMS((struct df *, basic_block,\n-\t\t\t\t    rtx, rtx));\n-static int df_rtx_mem_replace PARAMS ((rtx *, void *));\n-static int df_rtx_reg_replace PARAMS ((rtx *, void *));\n-void df_refs_reg_replace PARAMS ((struct df *, bitmap,\n-\t\t\t\t\t struct df_link *, rtx, rtx));\n-\n-static int df_def_dominates_all_uses_p PARAMS((struct df *, struct ref *def));\n-static int df_def_dominates_uses_p PARAMS((struct df *,\n-\t\t\t\t\t   struct ref *def, bitmap));\n-static struct ref *df_bb_regno_last_use_find PARAMS((struct df *, basic_block,\n-\t\t\t\t\t\t     unsigned int));\n-static struct ref *df_bb_regno_first_def_find PARAMS((struct df *, basic_block,\n-\t\t\t\t\t\t      unsigned int));\n-static struct ref *df_bb_insn_regno_last_use_find PARAMS((struct df *,\n-\t\t\t\t\t\t\t  basic_block,\n-\t\t\t\t\t\t\t  rtx, unsigned int));\n-static struct ref *df_bb_insn_regno_first_def_find PARAMS((struct df *,\n-\t\t\t\t\t\t\t   basic_block,\n-\t\t\t\t\t\t\t   rtx, unsigned int));\n-\n-static void df_chain_dump PARAMS((struct df_link *, FILE *file));\n-static void df_chain_dump_regno PARAMS((struct df_link *, FILE *file));\n-static void df_regno_debug PARAMS ((struct df *, unsigned int, FILE *));\n-static void df_ref_debug PARAMS ((struct df *, struct ref *, FILE *));\n-static void df_rd_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n-\t\t\t\t\t     bitmap, bitmap, void *));\n-static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n-\t\t\t\t\t     bitmap, bitmap, void *));\n-static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n-\t\t\t\t\t     bitmap, bitmap, void *));\n-static void hybrid_search_bitmap PARAMS ((basic_block, bitmap *, bitmap *,\n-\t\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir,\n-\t\t\t\t\t  enum df_confluence_op,\n-\t\t\t\t\t  transfer_function_bitmap,\n-\t\t\t\t\t  sbitmap, sbitmap, void *));\n-static void hybrid_search_sbitmap PARAMS ((basic_block, sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap *, enum df_flow_dir,\n-\t\t\t\t\t   enum df_confluence_op,\n-\t\t\t\t\t   transfer_function_sbitmap,\n-\t\t\t\t\t   sbitmap, sbitmap, void *));\n+static struct ref *df_ref_create (struct df *, rtx, rtx *, rtx,\n+\t\t\t\t  enum df_ref_type, enum df_ref_flags);\n+static void df_ref_record_1 (struct df *, rtx, rtx *, rtx, enum df_ref_type,\n+\t\t\t     enum df_ref_flags);\n+static void df_ref_record (struct df *, rtx, rtx *, rtx, enum df_ref_type,\n+\t\t\t   enum df_ref_flags);\n+static void df_def_record_1 (struct df *, rtx, basic_block, rtx);\n+static void df_defs_record (struct df *, rtx, basic_block, rtx);\n+static void df_uses_record (struct df *, rtx *, enum df_ref_type,\n+\t\t\t    basic_block, rtx, enum df_ref_flags);\n+static void df_insn_refs_record (struct df *, basic_block, rtx);\n+static void df_bb_refs_record (struct df *, basic_block);\n+static void df_refs_record (struct df *, bitmap);\n+\n+static void df_bb_reg_def_chain_create (struct df *, basic_block);\n+static void df_reg_def_chain_create (struct df *, bitmap);\n+static void df_bb_reg_use_chain_create (struct df *, basic_block);\n+static void df_reg_use_chain_create (struct df *, bitmap);\n+static void df_bb_du_chain_create (struct df *, basic_block, bitmap);\n+static void df_du_chain_create (struct df *, bitmap);\n+static void df_bb_ud_chain_create (struct df *, basic_block);\n+static void df_ud_chain_create (struct df *, bitmap);\n+static void df_bb_rd_local_compute (struct df *, basic_block);\n+static void df_rd_local_compute (struct df *, bitmap);\n+static void df_bb_ru_local_compute (struct df *, basic_block);\n+static void df_ru_local_compute (struct df *, bitmap);\n+static void df_bb_lr_local_compute (struct df *, basic_block);\n+static void df_lr_local_compute (struct df *, bitmap);\n+static void df_bb_reg_info_compute (struct df *, basic_block, bitmap);\n+static void df_reg_info_compute (struct df *, bitmap);\n+\n+static int df_bb_luids_set (struct df *df, basic_block);\n+static int df_luids_set (struct df *df, bitmap);\n+\n+static int df_modified_p (struct df *, bitmap);\n+static int df_refs_queue (struct df *);\n+static int df_refs_process (struct df *);\n+static int df_bb_refs_update (struct df *, basic_block);\n+static int df_refs_update (struct df *);\n+static void df_analyse_1 (struct df *, bitmap, int, int);\n+\n+static void df_insns_modify (struct df *, basic_block, rtx, rtx);\n+static int df_rtx_mem_replace (rtx *, void *);\n+static int df_rtx_reg_replace (rtx *, void *);\n+void df_refs_reg_replace (struct df *, bitmap, struct df_link *, rtx, rtx);\n+\n+static int df_def_dominates_all_uses_p (struct df *, struct ref *def);\n+static int df_def_dominates_uses_p (struct df *, struct ref *def, bitmap);\n+static struct ref *df_bb_regno_last_use_find (struct df *, basic_block,\n+\t\t\t\t\t      unsigned int);\n+static struct ref *df_bb_regno_first_def_find (struct df *, basic_block,\n+\t\t\t\t\t       unsigned int);\n+static struct ref *df_bb_insn_regno_last_use_find (struct df *, basic_block,\n+\t\t\t\t\t\t   rtx, unsigned int);\n+static struct ref *df_bb_insn_regno_first_def_find (struct df *, basic_block,\n+\t\t\t\t\t\t    rtx, unsigned int);\n+\n+static void df_chain_dump (struct df_link *, FILE *file);\n+static void df_chain_dump_regno (struct df_link *, FILE *file);\n+static void df_regno_debug (struct df *, unsigned int, FILE *);\n+static void df_ref_debug (struct df *, struct ref *, FILE *);\n+static void df_rd_transfer_function (int, int *, bitmap, bitmap, bitmap,\n+\t\t\t\t     bitmap, void *);\n+static void df_ru_transfer_function (int, int *, bitmap, bitmap, bitmap,\n+\t\t\t\t     bitmap, void *);\n+static void df_lr_transfer_function (int, int *, bitmap, bitmap, bitmap,\n+\t\t\t\t     bitmap, void *);\n+static void hybrid_search_bitmap (basic_block, bitmap *, bitmap *,\n+\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir,\n+\t\t\t\t  enum df_confluence_op,\n+\t\t\t\t  transfer_function_bitmap,\n+\t\t\t\t  sbitmap, sbitmap, void *);\n+static void hybrid_search_sbitmap (basic_block, sbitmap *, sbitmap *,\n+\t\t\t\t   sbitmap *, sbitmap *, enum df_flow_dir,\n+\t\t\t\t   enum df_confluence_op,\n+\t\t\t\t   transfer_function_sbitmap,\n+\t\t\t\t   sbitmap, sbitmap, void *);\n \n \f\n /* Local memory allocation/deallocation routines.  */\n@@ -316,9 +306,7 @@ static void hybrid_search_sbitmap PARAMS ((basic_block, sbitmap *, sbitmap *,\n /* Increase the insn info table to have space for at least SIZE + 1\n    elements.  */\n static void\n-df_insn_table_realloc (df, size)\n-     struct df *df;\n-     unsigned int size;\n+df_insn_table_realloc (struct df *df, unsigned int size)\n {\n   size++;\n   if (size <= df->insn_size)\n@@ -346,9 +334,7 @@ df_insn_table_realloc (df, size)\n \n /* Increase the reg info table by SIZE more elements.  */\n static void\n-df_reg_table_realloc (df, size)\n-     struct df *df;\n-     int size;\n+df_reg_table_realloc (struct df *df, int size)\n {\n   /* Make table 25 percent larger by default.  */\n   if (! size)\n@@ -371,9 +357,7 @@ df_reg_table_realloc (df, size)\n \n /* Allocate bitmaps for each basic block.  */\n static void\n-df_bitmaps_alloc (df, flags)\n-     struct df *df;\n-     int flags;\n+df_bitmaps_alloc (struct df *df, int flags)\n {\n   int dflags = 0;\n   basic_block bb;\n@@ -438,9 +422,7 @@ df_bitmaps_alloc (df, flags)\n \n /* Free bitmaps for each basic block.  */\n static void\n-df_bitmaps_free (df, flags)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     int flags;\n+df_bitmaps_free (struct df *df, int flags)\n {\n   basic_block bb;\n \n@@ -496,9 +478,7 @@ df_bitmaps_free (df, flags)\n \n /* Allocate and initialize dataflow memory.  */\n static void\n-df_alloc (df, n_regs)\n-     struct df *df;\n-     int n_regs;\n+df_alloc (struct df *df, int n_regs)\n {\n   int n_insns;\n   basic_block bb;\n@@ -548,8 +528,7 @@ df_alloc (df, n_regs)\n \n /* Free all the dataflow info.  */\n static void\n-df_free (df)\n-     struct df *df;\n+df_free (struct df *df)\n {\n   df_bitmaps_free (df, DF_ALL);\n \n@@ -598,8 +577,7 @@ df_free (df)\n /* Local miscellaneous routines.  */\n \n /* Return a USE for register REGNO.  */\n-static rtx df_reg_use_gen (regno)\n-     unsigned int regno;\n+static rtx df_reg_use_gen (unsigned int regno)\n {\n   rtx reg;\n   rtx use;\n@@ -612,8 +590,7 @@ static rtx df_reg_use_gen (regno)\n \n \n /* Return a CLOBBER for register REGNO.  */\n-static rtx df_reg_clobber_gen (regno)\n-     unsigned int regno;\n+static rtx df_reg_clobber_gen (unsigned int regno)\n {\n   rtx reg;\n   rtx use;\n@@ -628,9 +605,7 @@ static rtx df_reg_clobber_gen (regno)\n \n /* Create a link in a def-use or use-def chain.  */\n static inline struct df_link *\n-df_link_create (ref, next)\n-     struct ref *ref;\n-     struct df_link *next;\n+df_link_create (struct ref *ref, struct df_link *next)\n {\n   struct df_link *link;\n \n@@ -643,9 +618,7 @@ df_link_create (ref, next)\n \n /* Add REF to chain head pointed to by PHEAD.  */\n static struct df_link *\n-df_ref_unlink (phead, ref)\n-     struct df_link **phead;\n-     struct ref *ref;\n+df_ref_unlink (struct df_link **phead, struct ref *ref)\n {\n   struct df_link *link = *phead;\n \n@@ -687,9 +660,7 @@ df_ref_unlink (phead, ref)\n \n /* Unlink REF from all def-use/use-def chains, etc.  */\n int\n-df_ref_remove (df, ref)\n-     struct df *df;\n-     struct ref *ref;\n+df_ref_remove (struct df *df, struct ref *ref)\n {\n   if (DF_REF_REG_DEF_P (ref))\n     {\n@@ -707,9 +678,7 @@ df_ref_remove (df, ref)\n \n /* Unlink DEF from use-def and reg-def chains.  */\n static void\n-df_def_unlink (df, def)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     struct ref *def;\n+df_def_unlink (struct df *df ATTRIBUTE_UNUSED, struct ref *def)\n {\n   struct df_link *du_link;\n   unsigned int dregno = DF_REF_REGNO (def);\n@@ -733,9 +702,7 @@ df_def_unlink (df, def)\n \n /* Unlink use from def-use and reg-use chains.  */\n static void\n-df_use_unlink (df, use)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     struct ref *use;\n+df_use_unlink (struct df *df ATTRIBUTE_UNUSED, struct ref *use)\n {\n   struct df_link *ud_link;\n   unsigned int uregno = DF_REF_REGNO (use);\n@@ -762,13 +729,8 @@ df_use_unlink (df, use)\n /* Create a new ref of type DF_REF_TYPE for register REG at address\n    LOC within INSN of BB.  */\n static struct ref *\n-df_ref_create (df, reg, loc, insn, ref_type, ref_flags)\n-     struct df *df;\n-     rtx reg;\n-     rtx *loc;\n-     rtx insn;\n-     enum df_ref_type ref_type;\n-     enum df_ref_flags ref_flags;\n+df_ref_create (struct df *df, rtx reg, rtx *loc, rtx insn,\n+\t       enum df_ref_type ref_type, enum df_ref_flags ref_flags)\n {\n   struct ref *this_ref;\n \n@@ -811,13 +773,8 @@ df_ref_create (df, reg, loc, insn, ref_type, ref_flags)\n /* Create a new reference of type DF_REF_TYPE for a single register REG,\n    used inside the LOC rtx of INSN.  */\n static void\n-df_ref_record_1 (df, reg, loc, insn, ref_type, ref_flags)\n-     struct df *df;\n-     rtx reg;\n-     rtx *loc;\n-     rtx insn;\n-     enum df_ref_type ref_type;\n-     enum df_ref_flags ref_flags;\n+df_ref_record_1 (struct df *df, rtx reg, rtx *loc, rtx insn,\n+\t\t enum df_ref_type ref_type, enum df_ref_flags ref_flags)\n {\n   df_ref_create (df, reg, loc, insn, ref_type, ref_flags);\n }\n@@ -826,13 +783,8 @@ df_ref_record_1 (df, reg, loc, insn, ref_type, ref_flags)\n /* Create new references of type DF_REF_TYPE for each part of register REG\n    at address LOC within INSN of BB.  */\n static void\n-df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n-     struct df *df;\n-     rtx reg;\n-     rtx *loc;\n-     rtx insn;\n-     enum df_ref_type ref_type;\n-     enum df_ref_flags ref_flags;\n+df_ref_record (struct df *df, rtx reg, rtx *loc, rtx insn,\n+\t       enum df_ref_type ref_type, enum df_ref_flags ref_flags)\n {\n   unsigned int regno;\n \n@@ -888,8 +840,7 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n /* Return nonzero if writes to paradoxical SUBREGs, or SUBREGs which\n    are too narrow, are read-modify-write.  */\n bool\n-read_modify_subreg_p (x)\n-     rtx x;\n+read_modify_subreg_p (rtx x)\n {\n   unsigned int isize, osize;\n   if (GET_CODE (x) != SUBREG)\n@@ -903,18 +854,14 @@ read_modify_subreg_p (x)\n \n /* Process all the registers defined in the rtx, X.  */\n static void\n-df_def_record_1 (df, x, bb, insn)\n-     struct df *df;\n-     rtx x;\n-     basic_block bb;\n-     rtx insn;\n+df_def_record_1 (struct df *df, rtx x, basic_block bb, rtx insn)\n {\n   rtx *loc;\n   rtx dst;\n   enum df_ref_flags flags = 0;\n \n  /* We may recursivly call ourselves on EXPR_LIST when dealing with PARALLEL\n-     construct.  */  \n+     construct.  */\n   if (GET_CODE (x) == EXPR_LIST || GET_CODE (x) == CLOBBER)\n     loc = &XEXP (x, 0);\n   else\n@@ -937,13 +884,6 @@ df_def_record_1 (df, x, bb, insn)\n       return;\n     }\n \n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-  if (GET_CODE (dst) == SUBREG\n-      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n-\t\t\t\t     GET_MODE (SUBREG_REG (dst))))\n-    flags |= DF_REF_MODE_CHANGE;\n-#endif\n-\n   /* Maybe, we should flag the use of STRICT_LOW_PART somehow.  It might\n      be handy for the reg allocator.  */\n   while (GET_CODE (dst) == STRICT_LOW_PART\n@@ -959,12 +899,6 @@ df_def_record_1 (df, x, bb, insn)\n \t  loc = &XEXP (dst, 0);\n \t  dst = *loc;\n \t}\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-      if (GET_CODE (dst) == SUBREG\n-\t  && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n-\t\t\t\t         GET_MODE (SUBREG_REG (dst))))\n-        flags |= DF_REF_MODE_CHANGE;\n-#endif\n       loc = &XEXP (dst, 0);\n       dst = *loc;\n       flags |= DF_REF_READ_WRITE;\n@@ -978,11 +912,7 @@ df_def_record_1 (df, x, bb, insn)\n \n /* Process all the registers defined in the pattern rtx, X.  */\n static void\n-df_defs_record (df, x, bb, insn)\n-     struct df *df;\n-     rtx x;\n-     basic_block bb;\n-     rtx insn;\n+df_defs_record (struct df *df, rtx x, basic_block bb, rtx insn)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -1008,13 +938,8 @@ df_defs_record (df, x, bb, insn)\n \n /* Process all the registers used in the rtx at address LOC.  */\n static void\n-df_uses_record (df, loc, ref_type, bb, insn, flags)\n-     struct df *df;\n-     rtx *loc;\n-     enum df_ref_type ref_type;\n-     basic_block bb;\n-     rtx insn;\n-     enum df_ref_flags flags;\n+df_uses_record (struct df *df, rtx *loc, enum df_ref_type ref_type,\n+\t\tbasic_block bb, rtx insn, enum df_ref_flags flags)\n {\n   RTX_CODE code;\n   rtx x;\n@@ -1061,12 +986,6 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t  df_uses_record (df, loc, ref_type, bb, insn, flags);\n \t  return;\n \t}\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-      if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (x),\n-\t\t\t\t      GET_MODE (SUBREG_REG (x))))\n-        flags |= DF_REF_MODE_CHANGE;\n-#endif\n-\n       /* ... Fall through ...  */\n \n     case REG:\n@@ -1088,11 +1007,6 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n                   && read_modify_subreg_p (dst))\n \t\t{\n \t\t  use_flags = DF_REF_READ_WRITE;\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t\t  if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n-\t\t\t\t\t\t  GET_MODE (SUBREG_REG (dst))))\n-\t\t    use_flags |= DF_REF_MODE_CHANGE;\n-#endif\n \t\t  df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n \t\t\t\t  insn, use_flags);\n \t\t  break;\n@@ -1114,11 +1028,6 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t      if (GET_CODE (dst) != SUBREG)\n \t\tabort ();\n \t      use_flags = DF_REF_READ_WRITE;\n-#ifdef CLASS_CANNOT_CHANGE_MODE\n-\t      if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n-\t\t\t\t\t      GET_MODE (SUBREG_REG (dst))))\n-  \t        use_flags |= DF_REF_MODE_CHANGE;\n-#endif\n \t      df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n \t\t\t     insn, use_flags);\n \t      break;\n@@ -1217,10 +1126,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \n /* Record all the df within INSN of basic block BB.  */\n static void\n-df_insn_refs_record (df, bb, insn)\n-     struct df *df;\n-     basic_block bb;\n-     rtx insn;\n+df_insn_refs_record (struct df *df, basic_block bb, rtx insn)\n {\n   int i;\n \n@@ -1310,9 +1216,7 @@ df_insn_refs_record (df, bb, insn)\n \n /* Record all the refs within the basic block BB.  */\n static void\n-df_bb_refs_record (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_refs_record (struct df *df, basic_block bb)\n {\n   rtx insn;\n \n@@ -1332,9 +1236,7 @@ df_bb_refs_record (df, bb)\n \n /* Record all the refs in the basic blocks specified by BLOCKS.  */\n static void\n-df_refs_record (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_refs_record (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1350,9 +1252,7 @@ df_refs_record (df, blocks)\n /* Create reg-def chains for basic block BB.  These are a list of\n    definitions for each register.  */\n static void\n-df_bb_reg_def_chain_create (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_reg_def_chain_create (struct df *df, basic_block bb)\n {\n   rtx insn;\n \n@@ -1392,9 +1292,7 @@ df_bb_reg_def_chain_create (df, bb)\n /* Create reg-def chains for each basic block within BLOCKS.  These\n    are a list of definitions for each register.  */\n static void\n-df_reg_def_chain_create (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_reg_def_chain_create (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1408,9 +1306,7 @@ df_reg_def_chain_create (df, blocks)\n /* Create reg-use chains for basic block BB.  These are a list of uses\n    for each register.  */\n static void\n-df_bb_reg_use_chain_create (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_reg_use_chain_create (struct df *df, basic_block bb)\n {\n   rtx insn;\n \n@@ -1448,9 +1344,7 @@ df_bb_reg_use_chain_create (df, bb)\n /* Create reg-use chains for each basic block within BLOCKS.  These\n    are a list of uses for each register.  */\n static void\n-df_reg_use_chain_create (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_reg_use_chain_create (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1463,10 +1357,7 @@ df_reg_use_chain_create (df, blocks)\n \n /* Create def-use chains from reaching use bitmaps for basic block BB.  */\n static void\n-df_bb_du_chain_create (df, bb, ru)\n-     struct df *df;\n-     basic_block bb;\n-     bitmap ru;\n+df_bb_du_chain_create (struct df *df, basic_block bb, bitmap ru)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n@@ -1524,9 +1415,7 @@ df_bb_du_chain_create (df, bb, ru)\n /* Create def-use chains from reaching use bitmaps for basic blocks\n    in BLOCKS.  */\n static void\n-df_du_chain_create (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_du_chain_create (struct df *df, bitmap blocks)\n {\n   bitmap ru;\n   basic_block bb;\n@@ -1544,9 +1433,7 @@ df_du_chain_create (df, blocks)\n \n /* Create use-def chains from reaching def bitmaps for basic block BB.  */\n static void\n-df_bb_ud_chain_create (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_ud_chain_create (struct df *df, basic_block bb)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   struct ref **reg_def_last = df->reg_def_last;\n@@ -1620,9 +1507,7 @@ df_bb_ud_chain_create (df, bb)\n /* Create use-def chains from reaching def bitmaps for basic blocks\n    within BLOCKS.  */\n static void\n-df_ud_chain_create (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_ud_chain_create (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1635,43 +1520,35 @@ df_ud_chain_create (df, blocks)\n \n \n static void\n-df_rd_transfer_function (bb, changed, in, out, gen, kill, data)\n-     int bb ATTRIBUTE_UNUSED;\n-     int *changed;\n-     bitmap in, out, gen, kill;\n-     void *data ATTRIBUTE_UNUSED;\n+df_rd_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n+\t\t\t bitmap out, bitmap gen, bitmap kill,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (out, gen, in, kill);\n }\n \n \n static void\n-df_ru_transfer_function (bb, changed, in, out, gen, kill, data)\n-     int bb ATTRIBUTE_UNUSED;\n-     int *changed;\n-     bitmap in, out, gen, kill;\n-     void *data ATTRIBUTE_UNUSED;\n+df_ru_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n+\t\t\t bitmap out, bitmap gen, bitmap kill,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (in, gen, out, kill);\n }\n \n \n static void\n-df_lr_transfer_function (bb, changed, in, out, use, def, data)\n-     int bb ATTRIBUTE_UNUSED;\n-     int *changed;\n-     bitmap in, out, use, def;\n-     void *data ATTRIBUTE_UNUSED;\n+df_lr_transfer_function (int bb ATTRIBUTE_UNUSED, int *changed, bitmap in,\n+\t\t\t bitmap out, bitmap use, bitmap def,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   *changed = bitmap_union_of_diff (in, use, out, def);\n }\n \n \n /* Compute local reaching def info for basic block BB.  */\n static void\n-df_bb_rd_local_compute (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_rd_local_compute (struct df *df, basic_block bb)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n@@ -1716,9 +1593,7 @@ df_bb_rd_local_compute (df, bb)\n \n /* Compute local reaching def info for each basic block within BLOCKS.  */\n static void\n-df_rd_local_compute (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_rd_local_compute (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1732,9 +1607,7 @@ df_rd_local_compute (df, blocks)\n /* Compute local reaching use (upward exposed use) info for basic\n    block BB.  */\n static void\n-df_bb_ru_local_compute (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_ru_local_compute (struct df *df, basic_block bb)\n {\n   /* This is much more tricky than computing reaching defs.  With\n      reaching defs, defs get killed by other defs.  With upwards\n@@ -1789,9 +1662,7 @@ df_bb_ru_local_compute (df, bb)\n /* Compute local reaching use (upward exposed use) info for each basic\n    block within BLOCKS.  */\n static void\n-df_ru_local_compute (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_ru_local_compute (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1804,9 +1675,7 @@ df_ru_local_compute (df, blocks)\n \n /* Compute local live variable info for basic block BB.  */\n static void\n-df_bb_lr_local_compute (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_lr_local_compute (struct df *df, basic_block bb)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n@@ -1844,9 +1713,7 @@ df_bb_lr_local_compute (df, bb)\n \n /* Compute local live variable info for each basic block within BLOCKS.  */\n static void\n-df_lr_local_compute (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_lr_local_compute (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -1860,10 +1727,7 @@ df_lr_local_compute (df, blocks)\n /* Compute register info: lifetime, bb, and number of defs and uses\n    for basic block BB.  */\n static void\n-df_bb_reg_info_compute (df, bb, live)\n-     struct df *df;\n-     basic_block bb;\n-     bitmap live;\n+df_bb_reg_info_compute (struct df *df, basic_block bb, bitmap live)\n {\n   struct reg_info *reg_info = df->regs;\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n@@ -1912,9 +1776,7 @@ df_bb_reg_info_compute (df, bb, live)\n \n /* Compute register info: lifetime, bb, and number of defs and uses.  */\n static void\n-df_reg_info_compute (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_reg_info_compute (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n   bitmap live;\n@@ -1932,9 +1794,7 @@ df_reg_info_compute (df, blocks)\n \n /* Assign LUIDs for BB.  */\n static int\n-df_bb_luids_set (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_luids_set (struct df *df, basic_block bb)\n {\n   rtx insn;\n   int luid = 0;\n@@ -1956,9 +1816,7 @@ df_bb_luids_set (df, bb)\n \n /* Assign LUIDs for each basic block within BLOCKS.  */\n static int\n-df_luids_set (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_luids_set (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n   int total = 0;\n@@ -1974,11 +1832,7 @@ df_luids_set (df, blocks)\n /* Perform dataflow analysis using existing DF structure for blocks\n    within BLOCKS.  If BLOCKS is zero, use all basic blocks in the CFG.  */\n static void\n-df_analyse_1 (df, blocks, flags, update)\n-     struct df *df;\n-     bitmap blocks;\n-     int flags;\n-     int update;\n+df_analyse_1 (struct df *df, bitmap blocks, int flags, int update)\n {\n   int aflags;\n   int dflags;\n@@ -2168,7 +2022,7 @@ df_analyse_1 (df, blocks, flags, update)\n     {\n       df_reg_info_compute (df, df->all_blocks);\n     }\n-  \n+\n   free (df->dfs_order);\n   free (df->rc_order);\n   free (df->rts_order);\n@@ -2180,7 +2034,7 @@ df_analyse_1 (df, blocks, flags, update)\n \n /* Initialize dataflow analysis.  */\n struct df *\n-df_init ()\n+df_init (void)\n {\n   struct df *df;\n \n@@ -2195,8 +2049,7 @@ df_init ()\n \n /* Start queuing refs.  */\n static int\n-df_refs_queue (df)\n-     struct df *df;\n+df_refs_queue (struct df *df)\n {\n   df->def_id_save = df->def_id;\n   df->use_id_save = df->use_id;\n@@ -2208,8 +2061,7 @@ df_refs_queue (df)\n \n /* Process queued refs.  */\n static int\n-df_refs_process (df)\n-     struct df *df;\n+df_refs_process (struct df *df)\n {\n   unsigned int i;\n \n@@ -2240,9 +2092,7 @@ df_refs_process (df)\n \n /* Update refs for basic block BB.  */\n static int\n-df_bb_refs_update (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_refs_update (struct df *df, basic_block bb)\n {\n   rtx insn;\n   int count = 0;\n@@ -2277,8 +2127,7 @@ df_bb_refs_update (df, bb)\n \n /* Process all the modified/deleted insns that were queued.  */\n static int\n-df_refs_update (df)\n-     struct df *df;\n+df_refs_update (struct df *df)\n {\n   basic_block bb;\n   int count = 0;\n@@ -2301,9 +2150,7 @@ df_refs_update (df)\n /* Return nonzero if any of the requested blocks in the bitmap\n    BLOCKS have been modified.  */\n static int\n-df_modified_p (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_modified_p (struct df *df, bitmap blocks)\n {\n   int update = 0;\n   basic_block bb;\n@@ -2327,10 +2174,7 @@ df_modified_p (df, blocks)\n    BLOCKS, or for the whole CFG if BLOCKS is zero, or just for the\n    modified blocks if BLOCKS is -1.  */\n int\n-df_analyse (df, blocks, flags)\n-     struct df *df;\n-     bitmap blocks;\n-     int flags;\n+df_analyse (struct df *df, bitmap blocks, int flags)\n {\n   int update;\n \n@@ -2373,8 +2217,7 @@ df_analyse (df, blocks, flags)\n \n /* Free all the dataflow info and the DF structure.  */\n void\n-df_finish (df)\n-     struct df *df;\n+df_finish (struct df *df)\n {\n   df_free (df);\n   free (df);\n@@ -2383,10 +2226,7 @@ df_finish (df)\n \n /* Unlink INSN from its reference information.  */\n static void\n-df_insn_refs_unlink (df, bb, insn)\n-     struct df *df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n+df_insn_refs_unlink (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n {\n   struct df_link *link;\n   unsigned int uid;\n@@ -2409,9 +2249,7 @@ df_insn_refs_unlink (df, bb, insn)\n #if 0\n /* Unlink all the insns within BB from their reference information.  */\n static void\n-df_bb_refs_unlink (df, bb)\n-     struct df *df;\n-     basic_block bb;\n+df_bb_refs_unlink (struct df *df, basic_block bb)\n {\n   rtx insn;\n \n@@ -2432,9 +2270,7 @@ df_bb_refs_unlink (df, bb)\n /* Unlink all the refs in the basic blocks specified by BLOCKS.\n    Not currently used.  */\n static void\n-df_refs_unlink (df, blocks)\n-     struct df *df;\n-     bitmap blocks;\n+df_refs_unlink (struct df *df, bitmap blocks)\n {\n   basic_block bb;\n \n@@ -2458,10 +2294,7 @@ df_refs_unlink (df, blocks)\n \n /* Delete INSN and all its reference information.  */\n rtx\n-df_insn_delete (df, bb, insn)\n-     struct df *df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n+df_insn_delete (struct df *df, basic_block bb ATTRIBUTE_UNUSED, rtx insn)\n {\n   /* If the insn is a jump, we should perhaps call delete_insn to\n      handle the JUMP_LABEL?  */\n@@ -2484,10 +2317,7 @@ df_insn_delete (df, bb, insn)\n    harm calling this function if the insn wasn't changed; it will just\n    slow down the rescanning of refs.  */\n void\n-df_insn_modify (df, bb, insn)\n-     struct df *df;\n-     basic_block bb;\n-     rtx insn;\n+df_insn_modify (struct df *df, basic_block bb, rtx insn)\n {\n   unsigned int uid;\n \n@@ -2520,9 +2350,7 @@ typedef struct replace_args\n    instruction currently being scanned and the MEM we are currently\n    replacing.  */\n static int\n-df_rtx_mem_replace (px, data)\n-     rtx *px;\n-     void *data;\n+df_rtx_mem_replace (rtx *px, void *data)\n {\n   replace_args *args = (replace_args *) data;\n   rtx mem = *px;\n@@ -2558,12 +2386,7 @@ df_rtx_mem_replace (px, data)\n \n \n int\n-df_insn_mem_replace (df, bb, insn, mem, reg)\n-     struct df *df;\n-     basic_block bb;\n-     rtx insn;\n-     rtx mem;\n-     rtx reg;\n+df_insn_mem_replace (struct df *df, basic_block bb, rtx insn, rtx mem, rtx reg)\n {\n   replace_args args;\n \n@@ -2591,9 +2414,7 @@ df_insn_mem_replace (df, bb, insn, mem, reg)\n    points to the rtx being scanned.  DATA is actually a pointer to a\n    structure of arguments.  */\n static int\n-df_rtx_reg_replace (px, data)\n-     rtx *px;\n-     void *data;\n+df_rtx_reg_replace (rtx *px, void *data)\n {\n   rtx x = *px;\n   replace_args *args = (replace_args *) data;\n@@ -2615,12 +2436,7 @@ df_rtx_reg_replace (px, data)\n    BLOCKS of basic blocks with NEWREG.  Also update the regs within\n    REG_NOTES.  */\n void\n-df_refs_reg_replace (df, blocks, chain, oldreg, newreg)\n-     struct df *df;\n-     bitmap blocks;\n-     struct df_link *chain;\n-     rtx oldreg;\n-     rtx newreg;\n+df_refs_reg_replace (struct df *df, bitmap blocks, struct df_link *chain, rtx oldreg, rtx newreg)\n {\n   struct df_link *link;\n   replace_args args;\n@@ -2668,11 +2484,7 @@ df_refs_reg_replace (df, blocks, chain, oldreg, newreg)\n    OLDREG in the REG_NOTES but only for insns containing OLDREG.  This\n    routine expects the reg-use and reg-def chains to be valid.  */\n int\n-df_reg_replace (df, blocks, oldreg, newreg)\n-     struct df *df;\n-     bitmap blocks;\n-     rtx oldreg;\n-     rtx newreg;\n+df_reg_replace (struct df *df, bitmap blocks, rtx oldreg, rtx newreg)\n {\n   unsigned int oldregno = REGNO (oldreg);\n \n@@ -2685,11 +2497,7 @@ df_reg_replace (df, blocks, oldreg, newreg)\n /* Try replacing the reg within REF with NEWREG.  Do not modify\n    def-use/use-def chains.  */\n int\n-df_ref_reg_replace (df, ref, oldreg, newreg)\n-     struct df *df;\n-     struct ref *ref;\n-     rtx oldreg;\n-     rtx newreg;\n+df_ref_reg_replace (struct df *df, struct ref *ref, rtx oldreg, rtx newreg)\n {\n   /* Check that insn was deleted by being converted into a NOTE.  If\n    so ignore this insn.  */\n@@ -2708,12 +2516,7 @@ df_ref_reg_replace (df, ref, oldreg, newreg)\n \n \n struct ref*\n-df_bb_def_use_swap (df, bb, def_insn, use_insn, regno)\n-     struct df * df;\n-     basic_block bb;\n-     rtx def_insn;\n-     rtx use_insn;\n-     unsigned int regno;\n+df_bb_def_use_swap (struct df *df, basic_block bb, rtx def_insn, rtx use_insn, unsigned int regno)\n {\n   struct ref *def;\n   struct ref *use;\n@@ -2757,11 +2560,7 @@ df_bb_def_use_swap (df, bb, def_insn, use_insn, regno)\n /* Record df between FIRST_INSN and LAST_INSN inclusive.  All new\n    insns must be processed by this routine.  */\n static void\n-df_insns_modify (df, bb, first_insn, last_insn)\n-     struct df *df;\n-     basic_block bb;\n-     rtx first_insn;\n-     rtx last_insn;\n+df_insns_modify (struct df *df, basic_block bb, rtx first_insn, rtx last_insn)\n {\n   rtx insn;\n \n@@ -2792,11 +2591,7 @@ df_insns_modify (df, bb, first_insn, last_insn)\n \n /* Emit PATTERN before INSN within BB.  */\n rtx\n-df_pattern_emit_before (df, pattern, bb, insn)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     rtx pattern;\n-     basic_block bb;\n-     rtx insn;\n+df_pattern_emit_before (struct df *df, rtx pattern, basic_block bb, rtx insn)\n {\n   rtx ret_insn;\n   rtx prev_insn = PREV_INSN (insn);\n@@ -2815,11 +2610,7 @@ df_pattern_emit_before (df, pattern, bb, insn)\n \n /* Emit PATTERN after INSN within BB.  */\n rtx\n-df_pattern_emit_after (df, pattern, bb, insn)\n-     struct df *df;\n-     rtx pattern;\n-     basic_block bb;\n-     rtx insn;\n+df_pattern_emit_after (struct df *df, rtx pattern, basic_block bb, rtx insn)\n {\n   rtx ret_insn;\n \n@@ -2834,11 +2625,7 @@ df_pattern_emit_after (df, pattern, bb, insn)\n \n /* Emit jump PATTERN after INSN within BB.  */\n rtx\n-df_jump_pattern_emit_after (df, pattern, bb, insn)\n-     struct df *df;\n-     rtx pattern;\n-     basic_block bb;\n-     rtx insn;\n+df_jump_pattern_emit_after (struct df *df, rtx pattern, basic_block bb, rtx insn)\n {\n   rtx ret_insn;\n \n@@ -2857,12 +2644,7 @@ df_jump_pattern_emit_after (df, pattern, bb, insn)\n    out of a loop where it has been proven that the def-use info\n    will still be valid.  */\n rtx\n-df_insn_move_before (df, bb, insn, before_bb, before_insn)\n-     struct df *df;\n-     basic_block bb;\n-     rtx insn;\n-     basic_block before_bb;\n-     rtx before_insn;\n+df_insn_move_before (struct df *df, basic_block bb, rtx insn, basic_block before_bb, rtx before_insn)\n {\n   struct df_link *link;\n   unsigned int uid;\n@@ -2892,11 +2674,8 @@ df_insn_move_before (df, bb, insn, before_bb, before_insn)\n \n \n int\n-df_insn_regno_def_p (df, bb, insn, regno)\n-     struct df *df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     unsigned int regno;\n+df_insn_regno_def_p (struct df *df, basic_block bb ATTRIBUTE_UNUSED,\n+\t\t     rtx insn, unsigned int regno)\n {\n   unsigned int uid;\n   struct df_link *link;\n@@ -2916,9 +2695,7 @@ df_insn_regno_def_p (df, bb, insn, regno)\n \n \n static int\n-df_def_dominates_all_uses_p (df, def)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     struct ref *def;\n+df_def_dominates_all_uses_p (struct df *df ATTRIBUTE_UNUSED, struct ref *def)\n {\n   struct df_link *du_link;\n \n@@ -2938,10 +2715,8 @@ df_def_dominates_all_uses_p (df, def)\n \n \n int\n-df_insn_dominates_all_uses_p (df, bb, insn)\n-     struct df *df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n+df_insn_dominates_all_uses_p (struct df *df, basic_block bb ATTRIBUTE_UNUSED,\n+\t\t\t      rtx insn)\n {\n   unsigned int uid;\n   struct df_link *link;\n@@ -2963,10 +2738,8 @@ df_insn_dominates_all_uses_p (df, bb, insn)\n /* Return nonzero if all DF dominates all the uses within the bitmap\n    BLOCKS.  */\n static int\n-df_def_dominates_uses_p (df, def, blocks)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     struct ref *def;\n-     bitmap blocks;\n+df_def_dominates_uses_p (struct df *df ATTRIBUTE_UNUSED, struct ref *def,\n+\t\t\t bitmap blocks)\n {\n   struct df_link *du_link;\n \n@@ -2994,11 +2767,8 @@ df_def_dominates_uses_p (df, def, blocks)\n /* Return nonzero if all the defs of INSN within BB dominates\n    all the corresponding uses.  */\n int\n-df_insn_dominates_uses_p (df, bb, insn, blocks)\n-     struct df *df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     bitmap blocks;\n+df_insn_dominates_uses_p (struct df *df, basic_block bb ATTRIBUTE_UNUSED,\n+\t\t\t  rtx insn, bitmap blocks)\n {\n   unsigned int uid;\n   struct df_link *link;\n@@ -3021,9 +2791,7 @@ df_insn_dominates_uses_p (df, bb, insn, blocks)\n /* Return the basic block that REG referenced in or NULL if referenced\n    in multiple basic blocks.  */\n basic_block\n-df_regno_bb (df, regno)\n-     struct df *df;\n-     unsigned int regno;\n+df_regno_bb (struct df *df, unsigned int regno)\n {\n   struct df_link *defs = df->regs[regno].defs;\n   struct df_link *uses = df->regs[regno].uses;\n@@ -3040,30 +2808,23 @@ df_regno_bb (df, regno)\n \n /* Return nonzero if REG used in multiple basic blocks.  */\n int\n-df_reg_global_p (df, reg)\n-     struct df *df;\n-     rtx reg;\n+df_reg_global_p (struct df *df, rtx reg)\n {\n   return df_regno_bb (df, REGNO (reg)) != 0;\n }\n \n \n /* Return total lifetime (in insns) of REG.  */\n int\n-df_reg_lifetime (df, reg)\n-     struct df *df;\n-     rtx reg;\n+df_reg_lifetime (struct df *df, rtx reg)\n {\n   return df->regs[REGNO (reg)].lifetime;\n }\n \n \n /* Return nonzero if REG live at start of BB.  */\n int\n-df_bb_reg_live_start_p (df, bb, reg)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     basic_block bb;\n-     rtx reg;\n+df_bb_reg_live_start_p (struct df *df, basic_block bb, rtx reg)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n@@ -3078,10 +2839,7 @@ df_bb_reg_live_start_p (df, bb, reg)\n \n /* Return nonzero if REG live at end of BB.  */\n int\n-df_bb_reg_live_end_p (df, bb, reg)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     basic_block bb;\n-     rtx reg;\n+df_bb_reg_live_end_p (struct df *df, basic_block bb, rtx reg)\n {\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n \n@@ -3097,11 +2855,7 @@ df_bb_reg_live_end_p (df, bb, reg)\n /* Return -1 if life of REG1 before life of REG2, 1 if life of REG1\n    after life of REG2, or 0, if the lives overlap.  */\n int\n-df_bb_regs_lives_compare (df, bb, reg1, reg2)\n-     struct df *df;\n-     basic_block bb;\n-     rtx reg1;\n-     rtx reg2;\n+df_bb_regs_lives_compare (struct df *df, basic_block bb, rtx reg1, rtx reg2)\n {\n   unsigned int regno1 = REGNO (reg1);\n   unsigned int regno2 = REGNO (reg2);\n@@ -3136,10 +2890,7 @@ df_bb_regs_lives_compare (df, bb, reg1, reg2)\n \n /* Return last use of REGNO within BB.  */\n static struct ref *\n-df_bb_regno_last_use_find (df, bb, regno)\n-     struct df * df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     unsigned int regno;\n+df_bb_regno_last_use_find (struct df *df, basic_block bb, unsigned int regno)\n {\n   struct df_link *link;\n \n@@ -3160,10 +2911,7 @@ df_bb_regno_last_use_find (df, bb, regno)\n \n /* Return first def of REGNO within BB.  */\n static struct ref *\n-df_bb_regno_first_def_find (df, bb, regno)\n-     struct df * df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     unsigned int regno;\n+df_bb_regno_first_def_find (struct df *df, basic_block bb, unsigned int regno)\n {\n   struct df_link *link;\n \n@@ -3184,11 +2932,9 @@ df_bb_regno_first_def_find (df, bb, regno)\n \n /* Return first use of REGNO inside INSN within BB.  */\n static struct ref *\n-df_bb_insn_regno_last_use_find (df, bb, insn, regno)\n-     struct df * df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     unsigned int regno;\n+df_bb_insn_regno_last_use_find (struct df *df,\n+\t\t\t\tbasic_block bb ATTRIBUTE_UNUSED, rtx insn,\n+\t\t\t\tunsigned int regno)\n {\n   unsigned int uid;\n   struct df_link *link;\n@@ -3209,11 +2955,9 @@ df_bb_insn_regno_last_use_find (df, bb, insn, regno)\n \n /* Return first def of REGNO inside INSN within BB.  */\n static struct ref *\n-df_bb_insn_regno_first_def_find (df, bb, insn, regno)\n-     struct df * df;\n-     basic_block bb ATTRIBUTE_UNUSED;\n-     rtx insn;\n-     unsigned int regno;\n+df_bb_insn_regno_first_def_find (struct df *df,\n+\t\t\t\t basic_block bb ATTRIBUTE_UNUSED, rtx insn,\n+\t\t\t\t unsigned int regno)\n {\n   unsigned int uid;\n   struct df_link *link;\n@@ -3235,11 +2979,7 @@ df_bb_insn_regno_first_def_find (df, bb, insn, regno)\n /* Return insn using REG if the BB contains only a single\n    use and def of REG.  */\n rtx\n-df_bb_single_def_use_insn_find (df, bb, insn, reg)\n-     struct df * df;\n-     basic_block bb;\n-     rtx insn;\n-     rtx reg;\n+df_bb_single_def_use_insn_find (struct df *df, basic_block bb, rtx insn, rtx reg)\n {\n   struct ref *def;\n   struct ref *use;\n@@ -3273,9 +3013,7 @@ df_bb_single_def_use_insn_find (df, bb, insn, reg)\n \n /* Dump a def-use or use-def chain for REF to FILE.  */\n static void\n-df_chain_dump (link, file)\n-     struct df_link *link;\n-     FILE *file;\n+df_chain_dump (struct df_link *link, FILE *file)\n {\n   fprintf (file, \"{ \");\n   for (; link; link = link->next)\n@@ -3290,9 +3028,7 @@ df_chain_dump (link, file)\n \n /* Dump a chain of refs with the associated regno.  */\n static void\n-df_chain_dump_regno (link, file)\n-     struct df_link *link;\n-     FILE *file;\n+df_chain_dump_regno (struct df_link *link, FILE *file)\n {\n   fprintf (file, \"{ \");\n   for (; link; link = link->next)\n@@ -3308,10 +3044,7 @@ df_chain_dump_regno (link, file)\n \n /* Dump dataflow info.  */\n void\n-df_dump (df, flags, file)\n-     struct df *df;\n-     int flags;\n-     FILE *file;\n+df_dump (struct df *df, int flags, FILE *file)\n {\n   unsigned int j;\n   basic_block bb;\n@@ -3482,10 +3215,7 @@ df_dump (df, flags, file)\n \n \n void\n-df_insn_debug (df, insn, file)\n-     struct df *df;\n-     rtx insn;\n-     FILE *file;\n+df_insn_debug (struct df *df, rtx insn, FILE *file)\n {\n   unsigned int uid;\n   int bbi;\n@@ -3511,10 +3241,7 @@ df_insn_debug (df, insn, file)\n \n \n void\n-df_insn_debug_regno (df, insn, file)\n-     struct df *df;\n-     rtx insn;\n-     FILE *file;\n+df_insn_debug_regno (struct df *df, rtx insn, FILE *file)\n {\n   unsigned int uid;\n   int bbi;\n@@ -3540,10 +3267,7 @@ df_insn_debug_regno (df, insn, file)\n \n \n static void\n-df_regno_debug (df, regno, file)\n-     struct df *df;\n-     unsigned int regno;\n-     FILE *file;\n+df_regno_debug (struct df *df, unsigned int regno, FILE *file)\n {\n   if (regno >= df->reg_size)\n     return;\n@@ -3558,10 +3282,7 @@ df_regno_debug (df, regno, file)\n \n \n static void\n-df_ref_debug (df, ref, file)\n-     struct df *df;\n-     struct ref *ref;\n-     FILE *file;\n+df_ref_debug (struct df *df, struct ref *ref, FILE *file)\n {\n   fprintf (file, \"%c%d \",\n \t   DF_REF_REG_DEF_P (ref) ? 'd' : 'u',\n@@ -3578,57 +3299,50 @@ df_ref_debug (df, ref, file)\n /* Functions for debugging from GDB.  */\n \n void\n-debug_df_insn (insn)\n-     rtx insn;\n+debug_df_insn (rtx insn)\n {\n   df_insn_debug (ddf, insn, stderr);\n   debug_rtx (insn);\n }\n \n \n void\n-debug_df_reg (reg)\n-     rtx reg;\n+debug_df_reg (rtx reg)\n {\n   df_regno_debug (ddf, REGNO (reg), stderr);\n }\n \n \n void\n-debug_df_regno (regno)\n-     unsigned int regno;\n+debug_df_regno (unsigned int regno)\n {\n   df_regno_debug (ddf, regno, stderr);\n }\n \n \n void\n-debug_df_ref (ref)\n-     struct ref *ref;\n+debug_df_ref (struct ref *ref)\n {\n   df_ref_debug (ddf, ref, stderr);\n }\n \n \n void\n-debug_df_defno (defno)\n-     unsigned int defno;\n+debug_df_defno (unsigned int defno)\n {\n   df_ref_debug (ddf, ddf->defs[defno], stderr);\n }\n \n \n void\n-debug_df_useno (defno)\n-     unsigned int defno;\n+debug_df_useno (unsigned int defno)\n {\n   df_ref_debug (ddf, ddf->uses[defno], stderr);\n }\n \n \n void\n-debug_df_chain (link)\n-     struct df_link *link;\n+debug_df_chain (struct df_link *link)\n {\n   df_chain_dump (link, stderr);\n   fputc ('\\n', stderr);\n@@ -3638,17 +3352,11 @@ debug_df_chain (link)\n /* Hybrid search algorithm from \"Implementation Techniques for\n    Efficient Data-Flow Analysis of Large Programs\".  */\n static void\n-hybrid_search_bitmap (block, in, out, gen, kill, dir,\n-\t\t      conf_op, transfun, visited, pending,\n-\t\t      data)\n-     basic_block block;\n-     bitmap *in, *out, *gen, *kill;\n-     enum df_flow_dir dir;\n-     enum df_confluence_op conf_op;\n-     transfer_function_bitmap transfun;\n-     sbitmap visited;\n-     sbitmap pending;\n-     void *data;\n+hybrid_search_bitmap (basic_block block, bitmap *in, bitmap *out, bitmap *gen,\n+\t\t      bitmap *kill, enum df_flow_dir dir,\n+\t\t      enum df_confluence_op conf_op,\n+\t\t      transfer_function_bitmap transfun, sbitmap visited,\n+\t\t      sbitmap pending, void *data)\n {\n   int changed;\n   int i = block->index;\n@@ -3750,17 +3458,11 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \n /* Hybrid search for sbitmaps, rather than bitmaps.  */\n static void\n-hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n-\t\t       conf_op, transfun, visited, pending,\n-\t\t       data)\n-     basic_block block;\n-     sbitmap *in, *out, *gen, *kill;\n-     enum df_flow_dir dir;\n-     enum df_confluence_op conf_op;\n-     transfer_function_sbitmap transfun;\n-     sbitmap visited;\n-     sbitmap pending;\n-     void *data;\n+hybrid_search_sbitmap (basic_block block, sbitmap *in, sbitmap *out,\n+\t\t       sbitmap *gen, sbitmap *kill, enum df_flow_dir dir,\n+\t\t       enum df_confluence_op conf_op,\n+\t\t       transfer_function_sbitmap transfun, sbitmap visited,\n+\t\t       sbitmap pending, void *data)\n {\n   int changed;\n   int i = block->index;\n@@ -3881,15 +3583,12 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n    block number to rc_order (like df->inverse_rc_map).\n */\n void\n-iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n-\t\t\t    dir, conf_op, transfun, order, data)\n-     sbitmap *in, *out, *gen, *kill;\n-     bitmap blocks;\n-     enum df_flow_dir dir;\n-     enum df_confluence_op conf_op;\n-     transfer_function_sbitmap transfun;\n-     int *order;\n-     void *data;\n+iterative_dataflow_sbitmap (sbitmap *in, sbitmap *out, sbitmap *gen,\n+\t\t\t    sbitmap *kill, bitmap blocks,\n+\t\t\t    enum df_flow_dir dir,\n+\t\t\t    enum df_confluence_op conf_op,\n+\t\t\t    transfer_function_sbitmap transfun, int *order,\n+\t\t\t    void *data)\n {\n   int i;\n   fibheap_t worklist;\n@@ -3946,15 +3645,11 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n /* Exactly the same as iterative_dataflow_sbitmap, except it works on\n    bitmaps instead.  */\n void\n-iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n-\t\t\t   dir, conf_op, transfun, order, data)\n-     bitmap *in, *out, *gen, *kill;\n-     bitmap blocks;\n-     enum df_flow_dir dir;\n-     enum df_confluence_op conf_op;\n-     transfer_function_bitmap transfun;\n-     int *order;\n-     void *data;\n+iterative_dataflow_bitmap (bitmap *in, bitmap *out, bitmap *gen, bitmap *kill,\n+\t\t\t   bitmap blocks, enum df_flow_dir dir,\n+\t\t\t   enum df_confluence_op conf_op,\n+\t\t\t   transfer_function_bitmap transfun, int *order,\n+\t\t\t   void *data)\n {\n   int i;\n   fibheap_t worklist;"}, {"sha": "93cb0c016675887130569a975a48d6ea91ef2a87", "filename": "gcc/df.h", "status": "modified", "additions": 57, "deletions": 67, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,5 @@\n /* Form lists of pseudo register references for autoinc optimization\n-   for GNU compiler.  This is part of flow optimization.  \n+   for GNU compiler.  This is part of flow optimization.\n    Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n \n@@ -51,7 +51,7 @@ enum df_ref_flags\n        these are marked with this flag to show that they are not\n        independent.  */\n     DF_REF_READ_WRITE = 1,\n-    \n+\n     /* This flag is set on register references inside a subreg on\n        machines which have CANNOT_CHANGE_MODE_CLASS.\n        Note, that this flag can also be set on df_refs representing\n@@ -157,7 +157,7 @@ struct df\n   bitmap insns_modified;\t/* Insns that (may) have changed.  */\n   bitmap bbs_modified;\t\t/* Blocks that (may) have changed.  */\n   bitmap all_blocks;\t\t/* All blocks in CFG.  */\n-  /* The sbitmap vector of dominators or NULL if not computed. \n+  /* The sbitmap vector of dominators or NULL if not computed.\n      Ideally, this should be a pointer to a CFG object.  */\n   sbitmap *dom;\n   int *dfs_order;\t\t/* DFS order -> block number.  */\n@@ -231,96 +231,87 @@ struct df_map\n \n /* Functions to build and analyse dataflow information.  */\n \n-extern struct df *df_init PARAMS ((void));\n+extern struct df *df_init (void);\n \n-extern int df_analyse PARAMS ((struct df *, bitmap, int));\n+extern int df_analyse (struct df *, bitmap, int);\n \n-extern void df_finish PARAMS ((struct df *));\n+extern void df_finish (struct df *);\n \n-extern void df_dump PARAMS ((struct df *, int, FILE *));\n+extern void df_dump (struct df *, int, FILE *);\n \n \n /* Functions to modify insns.  */\n \n-extern void df_insn_modify PARAMS ((struct df *, basic_block, rtx));\n+extern void df_insn_modify (struct df *, basic_block, rtx);\n \n-extern rtx df_insn_delete PARAMS ((struct df *, basic_block, rtx));\n+extern rtx df_insn_delete (struct df *, basic_block, rtx);\n \n-extern rtx df_pattern_emit_before PARAMS ((struct df *, rtx, \n-\t\t\t\t\t   basic_block, rtx));\n+extern rtx df_pattern_emit_before (struct df *, rtx, basic_block, rtx);\n \n-extern rtx df_jump_pattern_emit_after PARAMS ((struct df *, rtx, \n-\t\t\t\t\t       basic_block, rtx));\n+extern rtx df_jump_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n \n-extern rtx df_pattern_emit_after PARAMS ((struct df *, rtx, \n-\t\t\t\t\t  basic_block, rtx));\n+extern rtx df_pattern_emit_after (struct df *, rtx, basic_block, rtx);\n \n-extern rtx df_insn_move_before PARAMS ((struct df *, basic_block, rtx,\n-\t\t\t\t\tbasic_block, rtx));\n+extern rtx df_insn_move_before (struct df *, basic_block, rtx, basic_block,\n+\t\t\t\trtx);\n \n-extern int df_reg_replace PARAMS ((struct df *, bitmap, rtx, rtx));\n+extern int df_reg_replace (struct df *, bitmap, rtx, rtx);\n \n-extern int df_ref_reg_replace PARAMS ((struct df *, struct ref *, rtx, rtx));\n+extern int df_ref_reg_replace (struct df *, struct ref *, rtx, rtx);\n \n-extern int df_ref_remove PARAMS ((struct df *, struct ref *));\n+extern int df_ref_remove (struct df *, struct ref *);\n \n-extern int df_insn_reg_replace PARAMS ((struct df *, basic_block,\n-\t\t\t\t\trtx, rtx, rtx));\n+extern int df_insn_reg_replace (struct df *, basic_block, rtx, rtx, rtx);\n \n-extern int df_insn_mem_replace PARAMS ((struct df *, basic_block,\n-\t\t\t\t\trtx, rtx, rtx));\n+extern int df_insn_mem_replace (struct df *, basic_block, rtx, rtx, rtx);\n \n-extern struct ref *df_bb_def_use_swap PARAMS ((struct df *, basic_block, \n-\t\t\t\t\t       rtx, rtx, unsigned int));\n+extern struct ref *df_bb_def_use_swap (struct df *, basic_block, rtx, rtx,\n+\t\t\t\t       unsigned int);\n \n \n /* Functions to query dataflow information.  */\n \n-extern basic_block df_regno_bb PARAMS((struct df *, unsigned int));\n+extern basic_block df_regno_bb (struct df *, unsigned int);\n \n-extern int df_reg_lifetime PARAMS ((struct df *, rtx));\n+extern int df_reg_lifetime (struct df *, rtx);\n \n-extern int df_reg_global_p PARAMS ((struct df *, rtx));\n+extern int df_reg_global_p (struct df *, rtx);\n \n-extern int df_insn_regno_def_p PARAMS ((struct df *, \n-\t\t\t\t\tbasic_block, rtx, unsigned int));\n+extern int df_insn_regno_def_p (struct df *, basic_block, rtx, unsigned int);\n \n-extern int df_insn_dominates_all_uses_p PARAMS ((struct df *, \n-\t\t\t\t\t\t basic_block, rtx));\n+extern int df_insn_dominates_all_uses_p (struct df *, basic_block, rtx);\n \n-extern int df_insn_dominates_uses_p PARAMS ((struct df *, basic_block,\n-\t\t\t\t\t     rtx, bitmap));\n+extern int df_insn_dominates_uses_p (struct df *, basic_block, rtx, bitmap);\n \n-extern int df_bb_reg_live_start_p PARAMS ((struct df *, basic_block, rtx));\n+extern int df_bb_reg_live_start_p (struct df *, basic_block, rtx);\n \n-extern int df_bb_reg_live_end_p PARAMS ((struct df *, basic_block, rtx));\n+extern int df_bb_reg_live_end_p (struct df *, basic_block, rtx);\n \n-extern int df_bb_regs_lives_compare PARAMS ((struct df *, basic_block,\n-\t\t\t\t\t     rtx, rtx));\n+extern int df_bb_regs_lives_compare (struct df *, basic_block, rtx, rtx);\n \n-extern rtx df_bb_single_def_use_insn_find PARAMS((struct df *, basic_block,\n-\t\t\t\t\t\t  rtx, rtx));\n+extern rtx df_bb_single_def_use_insn_find (struct df *, basic_block, rtx,\n+\t\t\t\t\t   rtx);\n \n \n /* Functions for debugging from GDB.  */\n \n-extern void debug_df_insn PARAMS ((rtx));\n+extern void debug_df_insn (rtx);\n \n-extern void debug_df_regno PARAMS ((unsigned int));\n+extern void debug_df_regno (unsigned int);\n \n-extern void debug_df_reg PARAMS ((rtx));\n+extern void debug_df_reg (rtx);\n \n-extern void debug_df_defno PARAMS ((unsigned int));\n+extern void debug_df_defno (unsigned int);\n \n-extern void debug_df_useno PARAMS ((unsigned int));\n+extern void debug_df_useno (unsigned int);\n \n-extern void debug_df_ref PARAMS ((struct ref *));\n+extern void debug_df_ref (struct ref *);\n \n-extern void debug_df_chain PARAMS ((struct df_link *));\n+extern void debug_df_chain (struct df_link *);\n \n-extern void df_insn_debug PARAMS ((struct df *, rtx, FILE *));\n+extern void df_insn_debug (struct df *, rtx, FILE *);\n \n-extern void df_insn_debug_regno PARAMS ((struct df *, rtx, FILE *));\n+extern void df_insn_debug_regno (struct df *, rtx, FILE *);\n \n \n /* Meet over any path (UNION) or meet over all paths (INTERSECTION).  */\n@@ -339,23 +330,22 @@ enum df_flow_dir\n   };\n \n \n-typedef void (*transfer_function_sbitmap) PARAMS ((int, int *, sbitmap, sbitmap, \n-\t\t\t\t\t\t   sbitmap, sbitmap, void *));\n+typedef void (*transfer_function_sbitmap) (int, int *, sbitmap, sbitmap,\n+\t\t\t\t\t   sbitmap, sbitmap, void *);\n \n-typedef void (*transfer_function_bitmap) PARAMS ((int, int *, bitmap, bitmap,\n-\t\t\t\t\t\t  bitmap, bitmap, void *));\n+typedef void (*transfer_function_bitmap) (int, int *, bitmap, bitmap,\n+\t\t\t\t\t  bitmap, bitmap, void *);\n \n-extern void iterative_dataflow_sbitmap PARAMS ((sbitmap *, sbitmap *, \n-\t\t\t\t\t\tsbitmap *, sbitmap *, \n-\t\t\t\t\t\tbitmap, enum df_flow_dir, \n-\t\t\t\t\t\tenum df_confluence_op, \n-\t\t\t\t\t\ttransfer_function_sbitmap, \n-\t\t\t\t\t\tint *, void *));\n+extern void iterative_dataflow_sbitmap (sbitmap *, sbitmap *, sbitmap *,\n+\t\t\t\t\tsbitmap *, bitmap, enum df_flow_dir,\n+\t\t\t\t\tenum df_confluence_op,\n+\t\t\t\t\ttransfer_function_sbitmap,\n+\t\t\t\t\tint *, void *);\n \n-extern void iterative_dataflow_bitmap PARAMS ((bitmap *, bitmap *, bitmap *, \n-\t\t\t\t\t       bitmap *, bitmap, \n-\t\t\t\t\t       enum df_flow_dir, \n-\t\t\t\t\t       enum df_confluence_op, \n-\t\t\t\t\t       transfer_function_bitmap, \n-\t\t\t\t\t       int *, void *));\n-extern bool read_modify_subreg_p PARAMS ((rtx));\n+extern void iterative_dataflow_bitmap (bitmap *, bitmap *, bitmap *,\n+\t\t\t\t       bitmap *, bitmap,\n+\t\t\t\t       enum df_flow_dir,\n+\t\t\t\t       enum df_confluence_op,\n+\t\t\t\t       transfer_function_bitmap,\n+\t\t\t\t       int *, void *);\n+extern bool read_modify_subreg_p (rtx);"}, {"sha": "5d5e5a6b55a7cd561afcbdf8524ada83a831f4b1", "filename": "gcc/dojump.c", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -34,16 +34,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"optabs.h\"\n #include \"langhooks.h\"\n \n-static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n-static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n-static void do_compare_and_jump\tPARAMS ((tree, enum rtx_code, enum rtx_code,\n-\t\t\t\t\t rtx, rtx));\n+static void do_jump_by_parts_greater (tree, int, rtx, rtx);\n+static void do_jump_by_parts_equality (tree, rtx, rtx);\n+static void do_compare_and_jump\t(tree, enum rtx_code, enum rtx_code, rtx,\n+\t\t\t\t rtx);\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n \n void\n-init_pending_stack_adjust ()\n+init_pending_stack_adjust (void)\n {\n   pending_stack_adjust = 0;\n }\n@@ -55,7 +55,7 @@ init_pending_stack_adjust ()\n    frame pointer regardless of the value of flag_omit_frame_pointer.  */\n \n void\n-clear_pending_stack_adjust ()\n+clear_pending_stack_adjust (void)\n {\n #ifdef EXIT_IGNORE_STACK\n   if (optimize > 0\n@@ -73,7 +73,7 @@ clear_pending_stack_adjust ()\n /* Pop any previously-pushed arguments that have not been popped yet.  */\n \n void\n-do_pending_stack_adjust ()\n+do_pending_stack_adjust (void)\n {\n   if (inhibit_defer_pop == 0)\n     {\n@@ -90,19 +90,15 @@ do_pending_stack_adjust ()\n    functions here.  */\n \n void\n-jumpifnot (exp, label)\n-     tree exp;\n-     rtx label;\n+jumpifnot (tree exp, rtx label)\n {\n   do_jump (exp, label, NULL_RTX);\n }\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n \n void\n-jumpif (exp, label)\n-     tree exp;\n-     rtx label;\n+jumpif (tree exp, rtx label)\n {\n   do_jump (exp, NULL_RTX, label);\n }\n@@ -120,9 +116,7 @@ jumpif (exp, label)\n    &&, || and comparison operators in EXP.  */\n \n void\n-do_jump (exp, if_false_label, if_true_label)\n-     tree exp;\n-     rtx if_false_label, if_true_label;\n+do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n {\n   enum tree_code code = TREE_CODE (exp);\n   /* Some cases need to create a label to jump to\n@@ -617,10 +611,8 @@ do_jump (exp, if_false_label, if_true_label)\n    and LT if SWAP is 1.  */\n \n static void\n-do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n-     tree exp;\n-     int swap;\n-     rtx if_false_label, if_true_label;\n+do_jump_by_parts_greater (tree exp, int swap, rtx if_false_label,\n+\t\t\t  rtx if_true_label)\n {\n   rtx op0 = expand_expr (TREE_OPERAND (exp, swap), NULL_RTX, VOIDmode, 0);\n   rtx op1 = expand_expr (TREE_OPERAND (exp, !swap), NULL_RTX, VOIDmode, 0);\n@@ -635,11 +627,8 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */\n \n void\n-do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true_label)\n-     enum machine_mode mode;\n-     int unsignedp;\n-     rtx op0, op1;\n-     rtx if_false_label, if_true_label;\n+do_jump_by_parts_greater_rtx (enum machine_mode mode, int unsignedp, rtx op0,\n+\t\t\t      rtx op1, rtx if_false_label, rtx if_true_label)\n {\n   int nwords = (GET_MODE_SIZE (mode) / UNITS_PER_WORD);\n   rtx drop_through_label = 0;\n@@ -688,9 +677,7 @@ do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true\n    with one insn, test the comparison and jump to the appropriate label.  */\n \n static void\n-do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n-     tree exp;\n-     rtx if_false_label, if_true_label;\n+do_jump_by_parts_equality (tree exp, rtx if_false_label, rtx if_true_label)\n {\n   rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n   rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n@@ -719,9 +706,7 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n    for the available compare insns.  */\n \n void\n-do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n-     rtx op0;\n-     rtx if_false_label, if_true_label;\n+do_jump_by_parts_equality_rtx (rtx op0, rtx if_false_label, rtx if_true_label)\n {\n   int nwords = GET_MODE_SIZE (GET_MODE (op0)) / UNITS_PER_WORD;\n   rtx part;\n@@ -776,12 +761,8 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n    compared.  */\n \n rtx\n-compare_from_rtx (op0, op1, code, unsignedp, mode, size)\n-     rtx op0, op1;\n-     enum rtx_code code;\n-     int unsignedp;\n-     enum machine_mode mode;\n-     rtx size;\n+compare_from_rtx (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n+\t\t  enum machine_mode mode, rtx size)\n {\n   enum rtx_code ucode;\n   rtx tem;\n@@ -847,14 +828,9 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size)\n    compared.  */\n \n void\n-do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size,\n-                         if_false_label, if_true_label)\n-     rtx op0, op1;\n-     enum rtx_code code;\n-     int unsignedp;\n-     enum machine_mode mode;\n-     rtx size;\n-     rtx if_false_label, if_true_label;\n+do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n+\t\t\t enum machine_mode mode, rtx size, rtx if_false_label,\n+\t\t\t rtx if_true_label)\n {\n   enum rtx_code ucode;\n   rtx tem;\n@@ -952,11 +928,9 @@ do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size,\n    things pushed on the stack that aren't yet used.  */\n \n static void\n-do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n-                     if_true_label)\n-     tree exp;\n-     enum rtx_code signed_code, unsigned_code;\n-     rtx if_false_label, if_true_label;\n+do_compare_and_jump (tree exp, enum rtx_code signed_code,\n+\t\t     enum rtx_code unsigned_code, rtx if_false_label,\n+\t\t     rtx if_true_label)\n {\n   rtx op0, op1;\n   tree type;"}, {"sha": "3ae628105c8aa28daf4a1ebe7292137b0f5d83f5", "filename": "gcc/doloop.c", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,6 @@\n /* Perform doloop optimizations\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n \n This file is part of GCC.\n@@ -59,23 +60,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #ifdef HAVE_doloop_end\n \n-static rtx doloop_condition_get\n-  PARAMS ((rtx));\n-static unsigned HOST_WIDE_INT doloop_iterations_max\n-  PARAMS ((const struct loop_info *, enum machine_mode, int));\n-static int doloop_valid_p\n-  PARAMS ((const struct loop *, rtx));\n-static int doloop_modify\n-  PARAMS ((const struct loop *, rtx, rtx, rtx, rtx, rtx));\n-static int doloop_modify_runtime\n-  PARAMS ((const struct loop *, rtx, rtx, rtx, enum machine_mode, rtx));\n+static rtx doloop_condition_get (rtx);\n+static unsigned HOST_WIDE_INT doloop_iterations_max (const struct loop_info *,\n+\t\t\t\t\t\t     enum machine_mode, int);\n+static int doloop_valid_p (const struct loop *, rtx);\n+static int doloop_modify (const struct loop *, rtx, rtx, rtx, rtx, rtx);\n+static int doloop_modify_runtime (const struct loop *, rtx, rtx, rtx,\n+\t\t\t\t  enum machine_mode, rtx);\n \n \n /* Return the loop termination condition for PATTERN or zero\n    if it is not a decrement and branch jump insn.  */\n static rtx\n-doloop_condition_get (pattern)\n-     rtx pattern;\n+doloop_condition_get (rtx pattern)\n {\n   rtx cmp;\n   rtx inc;\n@@ -146,10 +143,8 @@ doloop_condition_get (pattern)\n    MODE is the mode of the iteration count and NONNEG is nonzero if\n    the iteration count has been proved to be non-negative.  */\n static unsigned HOST_WIDE_INT\n-doloop_iterations_max (loop_info, mode, nonneg)\n-     const struct loop_info *loop_info;\n-     enum machine_mode mode;\n-     int nonneg;\n+doloop_iterations_max (const struct loop_info *loop_info,\n+\t\t       enum machine_mode mode, int nonneg)\n {\n   unsigned HOST_WIDE_INT n_iterations_max;\n   enum rtx_code code;\n@@ -255,9 +250,7 @@ doloop_iterations_max (loop_info, mode, nonneg)\n /* Return nonzero if the loop specified by LOOP is suitable for\n    the use of special low-overhead looping instructions.  */\n static int\n-doloop_valid_p (loop, jump_insn)\n-     const struct loop *loop;\n-     rtx jump_insn;\n+doloop_valid_p (const struct loop *loop, rtx jump_insn)\n {\n   const struct loop_info *loop_info = LOOP_INFO (loop);\n \n@@ -405,14 +398,8 @@ doloop_valid_p (loop, jump_insn)\n    low-overhead looping insn to emit at the end of the loop.  This\n    returns nonzero if it was successful.  */\n static int\n-doloop_modify (loop, iterations, iterations_max,\n-\t       doloop_seq, start_label, condition)\n-     const struct loop *loop;\n-     rtx iterations;\n-     rtx iterations_max;\n-     rtx doloop_seq;\n-     rtx start_label;\n-     rtx condition;\n+doloop_modify (const struct loop *loop, rtx iterations, rtx iterations_max,\n+\t       rtx doloop_seq, rtx start_label, rtx condition)\n {\n   rtx counter_reg;\n   rtx count;\n@@ -545,14 +532,9 @@ doloop_modify (loop, iterations, iterations_max,\n    number of loop iterations.  DOLOOP_INSN is the low-overhead looping\n    insn to insert.  Returns nonzero if loop successfully modified.  */\n static int\n-doloop_modify_runtime (loop, iterations_max,\n-\t\t       doloop_seq, start_label, mode, condition)\n-     const struct loop *loop;\n-     rtx iterations_max;\n-     rtx doloop_seq;\n-     rtx start_label;\n-     enum machine_mode mode;\n-     rtx condition;\n+doloop_modify_runtime (const struct loop *loop, rtx iterations_max,\n+\t\t       rtx doloop_seq, rtx start_label,\n+\t\t       enum machine_mode mode, rtx condition)\n {\n   const struct loop_info *loop_info = LOOP_INFO (loop);\n   HOST_WIDE_INT abs_inc;\n@@ -759,8 +741,7 @@ doloop_modify_runtime (loop, iterations_max,\n    is a candidate for this optimization.  Returns nonzero if loop\n    successfully modified.  */\n int\n-doloop_optimize (loop)\n-     const struct loop *loop;\n+doloop_optimize (const struct loop *loop)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx initial_value;"}, {"sha": "a9411d40431badae6bafb3374afd2bb9e77c2b68", "filename": "gcc/dominance.c", "status": "modified", "additions": 33, "deletions": 80, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,5 @@\n /* Calculate (post)dominators in slightly super-linear time.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Matz (matz@ifh.de).\n \n    This file is part of GCC.\n@@ -115,19 +115,16 @@ struct dom_info\n   unsigned int nodes;\n };\n \n-static void init_dom_info\t\tPARAMS ((struct dom_info *));\n-static void free_dom_info\t\tPARAMS ((struct dom_info *));\n-static void calc_dfs_tree_nonrec\tPARAMS ((struct dom_info *,\n-\t\t\t\t\t\t basic_block,\n-\t\t\t\t\t\t enum cdi_direction));\n-static void calc_dfs_tree\t\tPARAMS ((struct dom_info *,\n-\t\t\t\t\t\t enum cdi_direction));\n-static void compress\t\t\tPARAMS ((struct dom_info *, TBB));\n-static TBB eval\t\t\t\tPARAMS ((struct dom_info *, TBB));\n-static void link_roots\t\t\tPARAMS ((struct dom_info *, TBB, TBB));\n-static void calc_idoms\t\t\tPARAMS ((struct dom_info *,\n-\t\t\t\t\t\t enum cdi_direction));\n-void debug_dominance_info\t\tPARAMS ((dominance_info));\n+static void init_dom_info (struct dom_info *);\n+static void free_dom_info (struct dom_info *);\n+static void calc_dfs_tree_nonrec (struct dom_info *, basic_block,\n+\t\t\t\t  enum cdi_direction);\n+static void calc_dfs_tree (struct dom_info *, enum cdi_direction);\n+static void compress (struct dom_info *, TBB);\n+static TBB eval (struct dom_info *, TBB);\n+static void link_roots (struct dom_info *, TBB, TBB);\n+static void calc_idoms (struct dom_info *, enum cdi_direction);\n+void debug_dominance_info (dominance_info);\n \n /* Helper macro for allocating and initializing an array,\n    for aesthetic reasons.  */\n@@ -150,8 +147,7 @@ void debug_dominance_info\t\tPARAMS ((dominance_info));\n    This initializes the contents of DI, which already must be allocated.  */\n \n static void\n-init_dom_info (di)\n-     struct dom_info *di;\n+init_dom_info (struct dom_info *di)\n {\n   /* We need memory for n_basic_blocks nodes and the ENTRY_BLOCK or\n      EXIT_BLOCK.  */\n@@ -180,8 +176,7 @@ init_dom_info (di)\n /* Free all allocated memory in DI, but not DI itself.  */\n \n static void\n-free_dom_info (di)\n-     struct dom_info *di;\n+free_dom_info (struct dom_info *di)\n {\n   free (di->dfs_parent);\n   free (di->path_min);\n@@ -203,10 +198,7 @@ free_dom_info (di)\n    assigned their dfs number and are linked together to form a tree.  */\n \n static void\n-calc_dfs_tree_nonrec (di, bb, reverse)\n-     struct dom_info *di;\n-     basic_block bb;\n-     enum cdi_direction reverse;\n+calc_dfs_tree_nonrec (struct dom_info *di, basic_block bb, enum cdi_direction reverse)\n {\n   /* We never call this with bb==EXIT_BLOCK_PTR (ENTRY_BLOCK_PTR if REVERSE).  */\n   /* We call this _only_ if bb is not already visited.  */\n@@ -321,9 +313,7 @@ calc_dfs_tree_nonrec (di, bb, reverse)\n    because there may be nodes from which the EXIT_BLOCK is unreachable.  */\n \n static void\n-calc_dfs_tree (di, reverse)\n-     struct dom_info *di;\n-     enum cdi_direction reverse;\n+calc_dfs_tree (struct dom_info *di, enum cdi_direction reverse)\n {\n   /* The first block is the ENTRY_BLOCK (or EXIT_BLOCK if REVERSE).  */\n   basic_block begin = reverse ? EXIT_BLOCK_PTR : ENTRY_BLOCK_PTR;\n@@ -364,9 +354,7 @@ calc_dfs_tree (di, reverse)\n    from V to that root.  */\n \n static void\n-compress (di, v)\n-     struct dom_info *di;\n-     TBB v;\n+compress (struct dom_info *di, TBB v)\n {\n   /* Btw. It's not worth to unrecurse compress() as the depth is usually not\n      greater than 5 even for huge graphs (I've not seen call depth > 4).\n@@ -386,9 +374,7 @@ compress (di, v)\n    value on the path from V to the root.  */\n \n static inline TBB\n-eval (di, v)\n-     struct dom_info *di;\n-     TBB v;\n+eval (struct dom_info *di, TBB v)\n {\n   /* The representant of the set V is in, also called root (as the set\n      representation is a tree).  */\n@@ -417,9 +403,7 @@ eval (di, v)\n    of W.  */\n \n static void\n-link_roots (di, v, w)\n-     struct dom_info *di;\n-     TBB v, w;\n+link_roots (struct dom_info *di, TBB v, TBB w)\n {\n   TBB s = w;\n \n@@ -461,9 +445,7 @@ link_roots (di, v, w)\n    On return the immediate dominator to node V is in di->dom[V].  */\n \n static void\n-calc_idoms (di, reverse)\n-     struct dom_info *di;\n-     enum cdi_direction reverse;\n+calc_idoms (struct dom_info *di, enum cdi_direction reverse)\n {\n   TBB v, w, k, par;\n   basic_block en_block;\n@@ -557,8 +539,7 @@ calc_idoms (di, reverse)\n    immediate resp. all dominators).  */\n \n dominance_info\n-calculate_dominance_info (reverse)\n-     enum cdi_direction reverse;\n+calculate_dominance_info (enum cdi_direction reverse)\n {\n   struct dom_info di;\n   dominance_info info;\n@@ -596,8 +577,7 @@ calculate_dominance_info (reverse)\n \n /* Free dominance information.  */\n void\n-free_dominance_info (info)\n-     dominance_info info;\n+free_dominance_info (dominance_info info)\n {\n   basic_block bb;\n \n@@ -616,9 +596,7 @@ free_dominance_info (info)\n \n /* Return the immediate dominator of basic block BB.  */\n basic_block\n-get_immediate_dominator (dom, bb)\n-     dominance_info dom;\n-     basic_block bb;\n+get_immediate_dominator (dominance_info dom, basic_block bb)\n {\n   return et_forest_node_value (dom->forest,\n \t\t\t       et_forest_parent (dom->forest,\n@@ -628,9 +606,7 @@ get_immediate_dominator (dom, bb)\n /* Set the immediate dominator of the block possibly removing\n    existing edge.  NULL can be used to remove any edge.  */\n inline void\n-set_immediate_dominator (dom, bb, dominated_by)\n-     dominance_info dom;\n-     basic_block bb, dominated_by;\n+set_immediate_dominator (dominance_info dom, basic_block bb, basic_block dominated_by)\n {\n   void *aux_bb_node;\n   et_forest_node_t bb_node = BB_NODE (dom, bb);\n@@ -649,10 +625,7 @@ set_immediate_dominator (dom, bb, dominated_by)\n \n /* Store all basic blocks dominated by BB into BBS and return their number.  */\n int\n-get_dominated_by (dom, bb, bbs)\n-     dominance_info dom;\n-     basic_block bb;\n-     basic_block **bbs;\n+get_dominated_by (dominance_info dom, basic_block bb, basic_block **bbs)\n {\n   int n, i;\n \n@@ -665,10 +638,7 @@ get_dominated_by (dom, bb, bbs)\n \n /* Redirect all edges pointing to BB to TO.  */\n void\n-redirect_immediate_dominators (dom, bb, to)\n-     dominance_info dom;\n-     basic_block bb;\n-     basic_block to;\n+redirect_immediate_dominators (dominance_info dom, basic_block bb, basic_block to)\n {\n   et_forest_node_t *bbs = xmalloc (n_basic_blocks * sizeof (basic_block));\n   et_forest_node_t node = BB_NODE (dom, bb);\n@@ -686,10 +656,7 @@ redirect_immediate_dominators (dom, bb, to)\n \n /* Find first basic block in the tree dominating both BB1 and BB2.  */\n basic_block\n-nearest_common_dominator (dom, bb1, bb2)\n-     dominance_info dom;\n-     basic_block bb1;\n-     basic_block bb2;\n+nearest_common_dominator (dominance_info dom, basic_block bb1, basic_block bb2)\n {\n   if (!bb1)\n     return bb2;\n@@ -704,18 +671,14 @@ nearest_common_dominator (dom, bb1, bb2)\n \n /* Return TRUE in case BB1 is dominated by BB2.  */\n bool\n-dominated_by_p (dom, bb1, bb2)\n-     dominance_info dom;\n-     basic_block bb1;\n-     basic_block bb2;\n+dominated_by_p (dominance_info dom, basic_block bb1, basic_block bb2)\n {\n   return nearest_common_dominator (dom, bb1, bb2) == bb2;\n }\n \n /* Verify invariants of dominator structure.  */\n void\n-verify_dominators (dom)\n-     dominance_info dom;\n+verify_dominators (dominance_info dom)\n {\n   int err = 0;\n   basic_block bb;\n@@ -738,9 +701,7 @@ verify_dominators (dom)\n \n /* Recount dominator of BB.  */\n basic_block\n-recount_dominator (dom, bb)\n-     dominance_info dom;\n-     basic_block bb;\n+recount_dominator (dominance_info dom, basic_block bb)\n {\n    basic_block dom_bb = NULL;\n    edge e;\n@@ -757,10 +718,7 @@ recount_dominator (dom, bb)\n /* Iteratively recount dominators of BBS. The change is supposed to be local\n    and not to grow further.  */\n void\n-iterate_fix_dominators (dom, bbs, n)\n-     dominance_info dom;\n-     basic_block *bbs;\n-     int n;\n+iterate_fix_dominators (dominance_info dom, basic_block *bbs, int n)\n {\n   int i, changed = 1;\n   basic_block old_dom, new_dom;\n@@ -782,9 +740,7 @@ iterate_fix_dominators (dom, bbs, n)\n }\n \n void\n-add_to_dominance_info (dom, bb)\n-     dominance_info dom;\n-     basic_block bb;\n+add_to_dominance_info (dominance_info dom, basic_block bb)\n {\n   VARRAY_GROW (dom->varray, last_basic_block + 3);\n #ifdef ENABLE_CHECKING\n@@ -795,17 +751,14 @@ add_to_dominance_info (dom, bb)\n }\n \n void\n-delete_from_dominance_info (dom, bb)\n-     dominance_info dom;\n-     basic_block bb;\n+delete_from_dominance_info (dominance_info dom, basic_block bb)\n {\n   et_forest_remove_node (dom->forest, BB_NODE (dom, bb));\n   SET_BB_NODE (dom, bb, NULL);\n }\n \n void\n-debug_dominance_info (dom)\n-  dominance_info dom;\n+debug_dominance_info (dominance_info dom)\n {\n   basic_block bb, bb2;\n   FOR_EACH_BB (bb)"}, {"sha": "cd1b91af8d81d568393f5587f239fd9d01fae4a3", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,5 @@\n /* Dwarf2 assembler output helper routines.\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -45,9 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    to print a newline, since the caller may want to add a comment.  */\n \n void\n-dw2_assemble_integer (size, x)\n-     int size;\n-     rtx x;\n+dw2_assemble_integer (int size, rtx x)\n {\n   const char *op = integer_asm_op (size, FALSE);\n \n@@ -71,7 +69,7 @@ dw2_asm_output_data (int size, unsigned HOST_WIDE_INT value,\n \t\t     const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n   if (size * 8 < HOST_BITS_PER_WIDE_INT)\n@@ -100,7 +98,7 @@ dw2_asm_output_delta (int size, const char *lab1, const char *lab2,\n \t\t      const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef ASM_OUTPUT_DWARF_DELTA\n@@ -132,7 +130,7 @@ dw2_asm_output_offset (int size, const char *label,\n \t\t       const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef ASM_OUTPUT_DWARF_OFFSET\n@@ -160,7 +158,7 @@ dw2_asm_output_pcrel (int size ATTRIBUTE_UNUSED,\n \t\t      const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef ASM_OUTPUT_DWARF_PCREL\n@@ -189,7 +187,7 @@ dw2_asm_output_addr (int size, const char *label,\n \t\t     const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n   dw2_assemble_integer (size, gen_rtx_SYMBOL_REF (Pmode, label));\n@@ -211,7 +209,7 @@ dw2_asm_output_addr_rtx (int size, rtx addr,\n \t\t\t const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n   dw2_assemble_integer (size, addr);\n@@ -275,8 +273,7 @@ dw2_asm_output_nstring (const char *str, size_t orig_len,\n /* Return the size of an unsigned LEB128 quantity.  */\n \n int\n-size_of_uleb128 (value)\n-     unsigned HOST_WIDE_INT value;\n+size_of_uleb128 (unsigned HOST_WIDE_INT value)\n {\n   int size = 0;\n \n@@ -293,8 +290,7 @@ size_of_uleb128 (value)\n /* Return the size of a signed LEB128 quantity.  */\n \n int\n-size_of_sleb128 (value)\n-     HOST_WIDE_INT value;\n+size_of_sleb128 (HOST_WIDE_INT value)\n {\n   int size = 0, byte;\n \n@@ -315,8 +311,7 @@ size_of_sleb128 (value)\n    include leb128.  */\n \n int\n-size_of_encoded_value (encoding)\n-     int encoding;\n+size_of_encoded_value (int encoding)\n {\n   if (encoding == DW_EH_PE_omit)\n     return 0;\n@@ -338,8 +333,7 @@ size_of_encoded_value (encoding)\n /* Yield a name for a given pointer encoding.  */\n \n const char *\n-eh_data_format_name (format)\n-     int format;\n+eh_data_format_name (int format)\n {\n #if HAVE_DESIGNATED_INITIALIZERS\n #define S(p, v)\t\t[p] = v,\n@@ -501,7 +495,7 @@ dw2_asm_output_data_uleb128 (unsigned HOST_WIDE_INT value,\n \t\t\t     const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef HAVE_AS_LEB128\n@@ -562,7 +556,7 @@ dw2_asm_output_data_sleb128 (HOST_WIDE_INT value,\n \t\t\t     const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef HAVE_AS_LEB128\n@@ -653,7 +647,7 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n \t\t\t      const char *comment, ...)\n {\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n #ifdef HAVE_AS_LEB128\n@@ -675,8 +669,8 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n   va_end (ap);\n }\n \f\n-static rtx dw2_force_const_mem PARAMS ((rtx));\n-static int dw2_output_indirect_constant_1 PARAMS ((splay_tree_node, void *));\n+static rtx dw2_force_const_mem (rtx);\n+static int dw2_output_indirect_constant_1 (splay_tree_node, void *);\n \n static GTY((param1_is (char *), param2_is (tree))) splay_tree indirect_pool;\n \n@@ -694,8 +688,7 @@ static GTY(()) int dw2_const_labelno;\n    \"near\" the function in any interesting sense.  */\n \n static rtx\n-dw2_force_const_mem (x)\n-     rtx x;\n+dw2_force_const_mem (rtx x)\n {\n   splay_tree_node node;\n   const char *str;\n@@ -755,9 +748,8 @@ dw2_force_const_mem (x)\n    splay_tree_foreach.  Emit one queued constant to memory.  */\n \n static int\n-dw2_output_indirect_constant_1 (node, data)\n-     splay_tree_node node;\n-     void* data ATTRIBUTE_UNUSED;\n+dw2_output_indirect_constant_1 (splay_tree_node node,\n+\t\t\t\tvoid *data ATTRIBUTE_UNUSED)\n {\n   const char *sym;\n   rtx sym_ref;\n@@ -775,7 +767,7 @@ dw2_output_indirect_constant_1 (node, data)\n /* Emit the constants queued through dw2_force_const_mem.  */\n \n void\n-dw2_output_indirect_constants ()\n+dw2_output_indirect_constants (void)\n {\n   if (indirect_pool)\n     splay_tree_foreach (indirect_pool, dw2_output_indirect_constant_1, NULL);\n@@ -789,7 +781,7 @@ dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr,\n {\n   int size;\n   va_list ap;\n-  \n+\n   va_start (ap, comment);\n \n   size = size_of_encoded_value (encoding);"}, {"sha": "5c104987ef96f8f161126a50746b29f929f0a9c6", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 600, "deletions": 1065, "changes": 1665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c"}, {"sha": "e6bf532ff0867760709a82663265fcd9a7c85377", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -1,5 +1,6 @@\n /* dwarf2out.h - Various declarations for functions found in dwarf2out.c\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -18,11 +19,11 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n-extern void dwarf2out_decl\t\tPARAMS ((tree));\t\n-extern void dwarf2out_frame_debug\tPARAMS ((rtx));\n+extern void dwarf2out_decl (tree);\n+extern void dwarf2out_frame_debug (rtx);\n \n-extern void debug_dwarf\t\t\tPARAMS ((void));\n+extern void debug_dwarf (void);\n struct die_struct;\n-extern void debug_dwarf_die\t\tPARAMS ((struct die_struct *));\n-extern void dwarf2out_set_demangle_name_func PARAMS ((const char *(*) (const char *)));\n-extern void dwarf2out_add_library_unit_info PARAMS ((const char *, const char *));\n+extern void debug_dwarf_die (struct die_struct *);\n+extern void dwarf2out_set_demangle_name_func (const char *(*) (const char *));\n+extern void dwarf2out_add_library_unit_info (const char *, const char *);"}, {"sha": "02159a9d75086379cada10bd454ba9528b9aa445", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 289, "deletions": 452, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7080f7359418d87feb8ec8dfacf327d32b5a070c/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=7080f7359418d87feb8ec8dfacf327d32b5a070c", "patch": "@@ -775,158 +775,157 @@ static int in_class;\n \n /* Forward declarations for functions defined in this file.  */\n \n-static void dwarfout_init \t\tPARAMS ((const char *));\n-static void dwarfout_finish\t\tPARAMS ((const char *));\n-static void dwarfout_define\t        PARAMS ((unsigned int, const char *));\n-static void dwarfout_undef\t        PARAMS ((unsigned int, const char *));\n-static void dwarfout_start_source_file\tPARAMS ((unsigned, const char *));\n-static void dwarfout_start_source_file_check PARAMS ((unsigned, const char *));\n-static void dwarfout_end_source_file\tPARAMS ((unsigned));\n-static void dwarfout_end_source_file_check PARAMS ((unsigned));\n-static void dwarfout_begin_block\tPARAMS ((unsigned, unsigned));\n-static void dwarfout_end_block\t\tPARAMS ((unsigned, unsigned));\n-static void dwarfout_end_epilogue\tPARAMS ((unsigned int, const char *));\n-static void dwarfout_source_line\tPARAMS ((unsigned int, const char *));\n-static void dwarfout_end_prologue\tPARAMS ((unsigned int, const char *));\n-static void dwarfout_end_function\tPARAMS ((unsigned int));\n-static void dwarfout_function_decl\tPARAMS ((tree));\n-static void dwarfout_global_decl\tPARAMS ((tree));\n-static void dwarfout_deferred_inline_function\tPARAMS ((tree));\n-static void dwarfout_file_scope_decl \tPARAMS ((tree , int));\n-static const char *dwarf_tag_name\tPARAMS ((unsigned));\n-static const char *dwarf_attr_name\tPARAMS ((unsigned));\n-static const char *dwarf_stack_op_name\tPARAMS ((unsigned));\n-static const char *dwarf_typemod_name\tPARAMS ((unsigned));\n-static const char *dwarf_fmt_byte_name\tPARAMS ((unsigned));\n-static const char *dwarf_fund_type_name\tPARAMS ((unsigned));\n-static tree decl_ultimate_origin\tPARAMS ((tree));\n-static tree block_ultimate_origin\tPARAMS ((tree));\n-static tree decl_class_context \t\tPARAMS ((tree));\n+static void dwarfout_init (const char *);\n+static void dwarfout_finish (const char *);\n+static void dwarfout_define (unsigned int, const char *);\n+static void dwarfout_undef (unsigned int, const char *);\n+static void dwarfout_start_source_file (unsigned, const char *);\n+static void dwarfout_start_source_file_check (unsigned, const char *);\n+static void dwarfout_end_source_file (unsigned);\n+static void dwarfout_end_source_file_check (unsigned);\n+static void dwarfout_begin_block (unsigned, unsigned);\n+static void dwarfout_end_block (unsigned, unsigned);\n+static void dwarfout_end_epilogue (unsigned int, const char *);\n+static void dwarfout_source_line (unsigned int, const char *);\n+static void dwarfout_end_prologue (unsigned int, const char *);\n+static void dwarfout_end_function (unsigned int);\n+static void dwarfout_function_decl (tree);\n+static void dwarfout_global_decl (tree);\n+static void dwarfout_deferred_inline_function (tree);\n+static void dwarfout_file_scope_decl (tree , int);\n+static const char *dwarf_tag_name (unsigned);\n+static const char *dwarf_attr_name (unsigned);\n+static const char *dwarf_stack_op_name (unsigned);\n+static const char *dwarf_typemod_name (unsigned);\n+static const char *dwarf_fmt_byte_name (unsigned);\n+static const char *dwarf_fund_type_name (unsigned);\n+static tree decl_ultimate_origin (tree);\n+static tree block_ultimate_origin (tree);\n+static tree decl_class_context (tree);\n #if 0\n-static void output_unsigned_leb128\tPARAMS ((unsigned long));\n-static void output_signed_leb128\tPARAMS ((long));\n+static void output_unsigned_leb128 (unsigned long);\n+static void output_signed_leb128 (long);\n #endif\n-static int fundamental_type_code\tPARAMS ((tree));\n-static tree root_type_1\t\t\tPARAMS ((tree, int));\n-static tree root_type\t\t\tPARAMS ((tree));\n-static void write_modifier_bytes_1\tPARAMS ((tree, int, int, int));\n-static void write_modifier_bytes\tPARAMS ((tree, int, int));\n-static inline int type_is_fundamental\tPARAMS ((tree));\n-static void equate_decl_number_to_die_number PARAMS ((tree));\n-static inline void equate_type_number_to_die_number PARAMS ((tree));\n-static void output_reg_number\t\tPARAMS ((rtx));\n-static void output_mem_loc_descriptor\tPARAMS ((rtx));\n-static void output_loc_descriptor\tPARAMS ((rtx));\n-static void output_bound_representation\tPARAMS ((tree, unsigned, int));\n-static void output_enumeral_list\tPARAMS ((tree));\n-static inline HOST_WIDE_INT ceiling\tPARAMS ((HOST_WIDE_INT, unsigned int));\n-static inline tree field_type\t\tPARAMS ((tree));\n-static inline unsigned int simple_type_align_in_bits PARAMS ((tree));\n-static inline unsigned HOST_WIDE_INT simple_type_size_in_bits  PARAMS ((tree));\n-static HOST_WIDE_INT field_byte_offset\tPARAMS ((tree));\n-static inline void sibling_attribute\tPARAMS ((void));\n-static void location_attribute\t\tPARAMS ((rtx));\n-static void data_member_location_attribute PARAMS ((tree));\n-static void const_value_attribute\tPARAMS ((rtx));\n-static void location_or_const_value_attribute PARAMS ((tree));\n-static inline void name_attribute\tPARAMS ((const char *));\n-static inline void fund_type_attribute\tPARAMS ((unsigned));\n-static void mod_fund_type_attribute\tPARAMS ((tree, int, int));\n-static inline void user_def_type_attribute PARAMS ((tree));\n-static void mod_u_d_type_attribute\tPARAMS ((tree, int, int));\n+static int fundamental_type_code (tree);\n+static tree root_type_1 (tree, int);\n+static tree root_type (tree);\n+static void write_modifier_bytes_1 (tree, int, int, int);\n+static void write_modifier_bytes (tree, int, int);\n+static inline int type_is_fundamental (tree);\n+static void equate_decl_number_to_die_number (tree);\n+static inline void equate_type_number_to_die_number (tree);\n+static void output_reg_number (rtx);\n+static void output_mem_loc_descriptor (rtx);\n+static void output_loc_descriptor (rtx);\n+static void output_bound_representation (tree, unsigned, char);\n+static void output_enumeral_list (tree);\n+static inline HOST_WIDE_INT ceiling (HOST_WIDE_INT, unsigned int);\n+static inline tree field_type (tree);\n+static inline unsigned int simple_type_align_in_bits (tree);\n+static inline unsigned HOST_WIDE_INT simple_type_size_in_bits (tree);\n+static HOST_WIDE_INT field_byte_offset (tree);\n+static inline void sibling_attribute (void);\n+static void location_attribute (rtx);\n+static void data_member_location_attribute (tree);\n+static void const_value_attribute (rtx);\n+static void location_or_const_value_attribute (tree);\n+static inline void name_attribute (const char *);\n+static inline void fund_type_attribute (unsigned);\n+static void mod_fund_type_attribute (tree, int, int);\n+static inline void user_def_type_attribute (tree);\n+static void mod_u_d_type_attribute (tree, int, int);\n #ifdef USE_ORDERING_ATTRIBUTE\n-static inline void ordering_attribute\tPARAMS ((unsigned));\n+static inline void ordering_attribute (unsigned);\n #endif /* defined(USE_ORDERING_ATTRIBUTE) */\n-static void subscript_data_attribute\tPARAMS ((tree));\n-static void byte_size_attribute\t\tPARAMS ((tree));\n-static inline void bit_offset_attribute\tPARAMS ((tree));\n-static inline void bit_size_attribute\tPARAMS ((tree));\n-static inline void element_list_attribute PARAMS ((tree));\n-static inline void stmt_list_attribute\tPARAMS ((const char *));\n-static inline void low_pc_attribute\tPARAMS ((const char *));\n-static inline void high_pc_attribute\tPARAMS ((const char *));\n-static inline void body_begin_attribute\tPARAMS ((const char *));\n-static inline void body_end_attribute\tPARAMS ((const char *));\n-static inline void language_attribute\tPARAMS ((unsigned));\n-static inline void member_attribute\tPARAMS ((tree));\n+static void subscript_data_attribute (tree);\n+static void byte_size_attribute (tree);\n+static inline void bit_offset_attribute (tree);\n+static inline void bit_size_attribute (tree);\n+static inline void element_list_attribute (tree);\n+static inline void stmt_list_attribute (const char *);\n+static inline void low_pc_attribute (const char *);\n+static inline void high_pc_attribute (const char *);\n+static inline void body_begin_attribute (const char *);\n+static inline void body_end_attribute (const char *);\n+static inline void language_attribute (unsigned);\n+static inline void member_attribute (tree);\n #if 0\n-static inline void string_length_attribute PARAMS ((tree));\n+static inline void string_length_attribute (tree);\n #endif\n-static inline void comp_dir_attribute\tPARAMS ((const char *));\n-static inline void sf_names_attribute\tPARAMS ((const char *));\n-static inline void src_info_attribute\tPARAMS ((const char *));\n-static inline void mac_info_attribute\tPARAMS ((const char *));\n-static inline void prototyped_attribute\tPARAMS ((tree));\n-static inline void producer_attribute\tPARAMS ((const char *));\n-static inline void inline_attribute\tPARAMS ((tree));\n-static inline void containing_type_attribute PARAMS ((tree));\n-static inline void abstract_origin_attribute PARAMS ((tree));\n+static inline void comp_dir_attribute (const char *);\n+static inline void sf_names_attribute (const char *);\n+static inline void src_info_attribute (const char *);\n+static inline void mac_info_attribute (const char *);\n+static inline void prototyped_attribute (tree);\n+static inline void producer_attribute (const char *);\n+static inline void inline_attribute (tree);\n+static inline void containing_type_attribute (tree);\n+static inline void abstract_origin_attribute (tree);\n #ifdef DWARF_DECL_COORDINATES\n-static inline void src_coords_attribute PARAMS ((unsigned, unsigned));\n+static inline void src_coords_attribute (unsigned, unsigned);\n #endif /* defined(DWARF_DECL_COORDINATES) */\n-static inline void pure_or_virtual_attribute PARAMS ((tree));\n-static void name_and_src_coords_attributes PARAMS ((tree));\n-static void type_attribute\t\tPARAMS ((tree, int, int));\n-static const char *type_tag\t\tPARAMS ((tree));\n-static inline void dienum_push\t\tPARAMS ((void));\n-static inline void dienum_pop\t\tPARAMS ((void));\n-static inline tree member_declared_type PARAMS ((tree));\n-static const char *function_start_label\tPARAMS ((tree));\n-static void output_array_type_die\tPARAMS ((void *));\n-static void output_set_type_die\t\tPARAMS ((void *));\n+static inline void pure_or_virtual_attribute (tree);\n+static void name_and_src_coords_attributes (tree);\n+static void type_attribute (tree, int, int);\n+static const char *type_tag (tree);\n+static inline void dienum_push (void);\n+static inline void dienum_pop (void);\n+static inline tree member_declared_type (tree);\n+static const char *function_start_label (tree);\n+static void output_array_type_die (void *);\n+static void output_set_type_die (void *);\n #if 0\n-static void output_entry_point_die\tPARAMS ((void *));\n+static void output_entry_point_die (void *);\n #endif\n-static void output_inlined_enumeration_type_die PARAMS ((void *));\n-static void output_inlined_structure_type_die PARAMS ((void *));\n-static void output_inlined_union_type_die PARAMS ((void *));\n-static void output_enumeration_type_die\tPARAMS ((void *));\n-static void output_formal_parameter_die\tPARAMS ((void *));\n-static void output_global_subroutine_die PARAMS ((void *));\n-static void output_global_variable_die\tPARAMS ((void *));\n-static void output_label_die\t\tPARAMS ((void *));\n-static void output_lexical_block_die\tPARAMS ((void *));\n-static void output_inlined_subroutine_die PARAMS ((void *));\n-static void output_local_variable_die\tPARAMS ((void *));\n-static void output_member_die\t\tPARAMS ((void *));\n+static void output_inlined_enumeration_type_die (void *);\n+static void output_inlined_structure_type_die (void *);\n+static void output_inlined_union_type_die (void *);\n+static void output_enumeration_type_die (void *);\n+static void output_formal_parameter_die (void *);\n+static void output_global_subroutine_die (void *);\n+static void output_global_variable_die (void *);\n+static void output_label_die (void *);\n+static void output_lexical_block_die (void *);\n+static void output_inlined_subroutine_die (void *);\n+static void output_local_variable_die (void *);\n+static void output_member_die (void *);\n #if 0\n-static void output_pointer_type_die\tPARAMS ((void *));\n-static void output_reference_type_die\tPARAMS ((void *));\n+static void output_pointer_type_die (void *);\n+static void output_reference_type_die (void *);\n #endif\n-static void output_ptr_to_mbr_type_die\tPARAMS ((void *));\n-static void output_compile_unit_die\tPARAMS ((void *));\n-static void output_string_type_die\tPARAMS ((void *));\n-static void output_inheritance_die\tPARAMS ((void *));\n-static void output_structure_type_die\tPARAMS ((void *));\n-static void output_local_subroutine_die PARAMS ((void *));\n-static void output_subroutine_type_die\tPARAMS ((void *));\n-static void output_typedef_die\t\tPARAMS ((void *));\n-static void output_union_type_die\tPARAMS ((void *));\n-static void output_unspecified_parameters_die PARAMS ((void *));\n-static void output_padded_null_die\tPARAMS ((void *));\n-static void output_die\t\t\tPARAMS ((void (*)(void *), void *));\n-static void end_sibling_chain\t\tPARAMS ((void));\n-static void output_formal_types\t\tPARAMS ((tree));\n-static void pend_type\t\t\tPARAMS ((tree));\n-static int type_ok_for_scope\t\tPARAMS ((tree, tree));\n-static void output_pending_types_for_scope PARAMS ((tree));\n-static void output_type\t\t\tPARAMS ((tree, tree));\n-static void output_tagged_type_instantiation PARAMS ((tree));\n-static void output_block\t\tPARAMS ((tree, int));\n-static void output_decls_for_scope\tPARAMS ((tree, int));\n-static void output_decl\t\t\tPARAMS ((tree, tree));\n-static void shuffle_filename_entry\tPARAMS ((filename_entry *));\n-static void generate_new_sfname_entry\tPARAMS ((void));\n-static unsigned lookup_filename\t\tPARAMS ((const char *));\n-static void generate_srcinfo_entry\tPARAMS ((unsigned, unsigned));\n-static void generate_macinfo_entry\tPARAMS ((unsigned int, rtx,\n-\t\t\t\t\t\t const char *));\n-static int is_pseudo_reg\t\tPARAMS ((rtx));\n-static tree type_main_variant\t\tPARAMS ((tree));\n-static int is_tagged_type\t\tPARAMS ((tree));\n-static int is_redundant_typedef\t\tPARAMS ((tree));\n-static void add_incomplete_type\t\tPARAMS ((tree));\n-static void retry_incomplete_types\tPARAMS ((void));\n+static void output_ptr_to_mbr_type_die (void *);\n+static void output_compile_unit_die (void *);\n+static void output_string_type_die (void *);\n+static void output_inheritance_die (void *);\n+static void output_structure_type_die (void *);\n+static void output_local_subroutine_die (void *);\n+static void output_subroutine_type_die (void *);\n+static void output_typedef_die (void *);\n+static void output_union_type_die (void *);\n+static void output_unspecified_parameters_die (void *);\n+static void output_padded_null_die (void *);\n+static void output_die (void (*)(void *), void *);\n+static void end_sibling_chain (void);\n+static void output_formal_types (tree);\n+static void pend_type (tree);\n+static int type_ok_for_scope (tree, tree);\n+static void output_pending_types_for_scope (tree);\n+static void output_type (tree, tree);\n+static void output_tagged_type_instantiation (tree);\n+static void output_block (tree, int);\n+static void output_decls_for_scope (tree, int);\n+static void output_decl (tree, tree);\n+static void shuffle_filename_entry (filename_entry *);\n+static void generate_new_sfname_entry (void);\n+static unsigned lookup_filename (const char *);\n+static void generate_srcinfo_entry (unsigned, unsigned);\n+static void generate_macinfo_entry (unsigned int, rtx, const char *);\n+static int is_pseudo_reg (rtx);\n+static tree type_main_variant (tree);\n+static int is_tagged_type (tree);\n+static int is_redundant_typedef (tree);\n+static void add_incomplete_type (tree);\n+static void retry_incomplete_types (void);\n \f\n /* Definitions of defaults for assembler-dependent names of various\n    pseudo-ops and section names.\n@@ -1301,17 +1300,15 @@ const struct gcc_debug_hooks dwarf_debug_hooks =\n /************************ general utility functions **************************/\n \n static inline int\n-is_pseudo_reg (rtl)\n-     rtx rtl;\n+is_pseudo_reg (rtx rtl)\n {\n   return (((GET_CODE (rtl) == REG) && (REGNO (rtl) >= FIRST_PSEUDO_REGISTER))\n \t  || ((GET_CODE (rtl) == SUBREG)\n \t      && (REGNO (SUBREG_REG (rtl)) >= FIRST_PSEUDO_REGISTER)));\n }\n \n static inline tree\n-type_main_variant (type)\n-     tree type;\n+type_main_variant (tree type)\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n@@ -1332,8 +1329,7 @@ type_main_variant (type)\n /* Return nonzero if the given type node represents a tagged type.  */\n \n static inline int\n-is_tagged_type (type)\n-     tree type;\n+is_tagged_type (tree type)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -1342,8 +1338,7 @@ is_tagged_type (type)\n }\n \n static const char *\n-dwarf_tag_name (tag)\n-     unsigned tag;\n+dwarf_tag_name (unsigned int tag)\n {\n   switch (tag)\n     {\n@@ -1392,8 +1387,7 @@ dwarf_tag_name (tag)\n }\n \n static const char *\n-dwarf_attr_name (attr)\n-     unsigned attr;\n+dwarf_attr_name (unsigned int attr)\n {\n   switch (attr)\n     {\n@@ -1470,8 +1464,7 @@ dwarf_attr_name (attr)\n }\n \n static const char *\n-dwarf_stack_op_name (op)\n-     unsigned op;\n+dwarf_stack_op_name (unsigned int op)\n {\n   switch (op)\n     {\n@@ -1487,8 +1480,7 @@ dwarf_stack_op_name (op)\n }\n \n static const char *\n-dwarf_typemod_name (mod)\n-     unsigned mod;\n+dwarf_typemod_name (unsigned int mod)\n {\n   switch (mod)\n     {\n@@ -1501,8 +1493,7 @@ dwarf_typemod_name (mod)\n }\n \n static const char *\n-dwarf_fmt_byte_name (fmt)\n-     unsigned fmt;\n+dwarf_fmt_byte_name (unsigned int fmt)\n {\n   switch (fmt)\n     {\n@@ -1520,8 +1511,7 @@ dwarf_fmt_byte_name (fmt)\n }\n \n static const char *\n-dwarf_fund_type_name (ft)\n-     unsigned ft;\n+dwarf_fund_type_name (unsigned int ft)\n {\n   switch (ft)\n     {\n@@ -1586,8 +1576,7 @@ dwarf_fund_type_name (ft)\n    served as the original seed for the given block.  */\n \n static tree\n-decl_ultimate_origin (decl)\n-     tree decl;\n+decl_ultimate_origin (tree decl)\n {\n #ifdef ENABLE_CHECKING\n   if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n@@ -1606,8 +1595,7 @@ decl_ultimate_origin (decl)\n    served as the original seed for the given block.  */\n \n static tree\n-block_ultimate_origin (block)\n-     tree block;\n+block_ultimate_origin (tree block)\n {\n   tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n@@ -1635,8 +1623,7 @@ block_ultimate_origin (block)\n    parameter.  */\n \n static tree\n-decl_class_context (decl)\n-     tree decl;\n+decl_class_context (tree decl)\n {\n   tree context = NULL_TREE;\n   if (TREE_CODE (decl) != FUNCTION_DECL || ! DECL_VINDEX (decl))\n@@ -1653,8 +1640,7 @@ decl_class_context (decl)\n \n #if 0\n static void\n-output_unsigned_leb128 (value)\n-     unsigned long value;\n+output_unsigned_leb128 (unsigned long value)\n {\n   unsigned long orig_value = value;\n \n@@ -1672,8 +1658,7 @@ output_unsigned_leb128 (value)\n }\n \n static void\n-output_signed_leb128 (value)\n-     long value;\n+output_signed_leb128 (long value)\n {\n   long orig_value = value;\n   int negative = (value < 0);\n@@ -1728,8 +1713,7 @@ output_signed_leb128 (value)\n    draft specification is probably never even useful in practice.  */\n \n static int\n-fundamental_type_code (type)\n-     tree type;\n+fundamental_type_code (tree type)\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return 0;\n@@ -1870,9 +1854,7 @@ fundamental_type_code (type)\n    qualifiers.  */\n \n static tree\n-root_type_1 (type, count)\n-     tree type;\n-     int count;\n+root_type_1 (tree type, int count)\n {\n   /* Give up after searching 1000 levels, in case this is a recursive\n      pointer type.  Such types are possible in Ada, but it is not possible\n@@ -1895,8 +1877,7 @@ root_type_1 (type, count)\n }\n \n static tree\n-root_type (type)\n-     tree type;\n+root_type (tree type)\n {\n   type = root_type_1 (type, 0);\n   if (type != error_mark_node)\n@@ -1908,11 +1889,7 @@ root_type (type)\n    of zero or more Dwarf \"type-modifier\" bytes applicable to the type.\t*/\n \n static void\n-write_modifier_bytes_1 (type, decl_const, decl_volatile, count)\n-     tree type;\n-     int decl_const;\n-     int decl_volatile;\n-     int count;\n+write_modifier_bytes_1 (tree type, int decl_const, int decl_volatile, int count)\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n@@ -1946,10 +1923,7 @@ write_modifier_bytes_1 (type, decl_const, decl_volatile, count)\n }\n \n static void\n-write_modifier_bytes (type, decl_const, decl_volatile)\n-     tree type;\n-     int decl_const;\n-     int decl_volatile;\n+write_modifier_bytes (tree type, int decl_const, int decl_volatile)\n {\n   write_modifier_bytes_1 (type, decl_const, decl_volatile, 0);\n }\n@@ -1958,8 +1932,7 @@ write_modifier_bytes (type, decl_const, decl_volatile)\n    given input type is a Dwarf \"fundamental\" type.  Otherwise return zero.  */\n \n static inline int\n-type_is_fundamental (type)\n-     tree type;\n+type_is_fundamental (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -2008,8 +1981,7 @@ type_is_fundamental (type)\n    UID number.\t*/\n \n static void\n-equate_decl_number_to_die_number (decl)\n-     tree decl;\n+equate_decl_number_to_die_number (tree decl)\n {\n   /* In the case where we are generating a DIE for some ..._DECL node\n      which represents either some inline function declaration or some\n@@ -2040,8 +2012,7 @@ equate_decl_number_to_die_number (decl)\n    UID number.\t*/\n \n static inline void\n-equate_type_number_to_die_number (type)\n-     tree type;\n+equate_type_number_to_die_number (tree type)\n {\n   char type_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char die_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2059,14 +2030,13 @@ equate_type_number_to_die_number (type)\n }\n \n static void\n-output_reg_number (rtl)\n-     rtx rtl;\n+output_reg_number (rtx rtl)\n {\n   unsigned regno = REGNO (rtl);\n \n   if (regno >= DWARF_FRAME_REGISTERS)\n     {\n-      warning_with_decl (dwarf_last_decl, \n+      warning_with_decl (dwarf_last_decl,\n \t\t\t \"internal regno botch: `%s' has regno = %d\\n\",\n \t\t\t regno);\n       regno = 0;\n@@ -2091,8 +2061,7 @@ output_reg_number (rtl)\n    RTL tree, turning it into Dwarf postfix code as it goes.  */\n \n static void\n-output_mem_loc_descriptor (rtl)\n-     rtx rtl;\n+output_mem_loc_descriptor (rtx rtl)\n {\n   /* Note that for a dynamically sized array, the location we will\n      generate a description of here will be the lowest numbered location\n@@ -2182,8 +2151,7 @@ output_mem_loc_descriptor (rtl)\n    generate the (dynamic) address of the object onto the address stack.  */\n \n static void\n-output_loc_descriptor (rtl)\n-     rtx rtl;\n+output_loc_descriptor (rtx rtl)\n {\n   switch (GET_CODE (rtl))\n     {\n@@ -2213,13 +2181,12 @@ output_loc_descriptor (rtl)\n }\n \n /* Given a tree node describing an array bound (either lower or upper)\n-   output a representation for that bound.  */\n+   output a representation for that bound.  DIM_NUM is used for\n+   multi-dimensional arrays and U_OR_L disgnates upper or lower\n+   bound.  */\n \n static void\n-output_bound_representation (bound, dim_num, u_or_l)\n-     tree bound;\n-     unsigned dim_num; /* For multi-dimensional arrays.  */\n-     char u_or_l;\t/* Designates upper or lower bound.  */\n+output_bound_representation (tree bound, unsigned int dim_num, char u_or_l)\n {\n   switch (TREE_CODE (bound))\n     {\n@@ -2282,7 +2249,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \t\t   || TREE_CODE (bound) == CONVERT_EXPR)\n \t      bound = TREE_OPERAND (bound, 0);\n \n-\t    if (TREE_CODE (bound) == SAVE_EXPR \n+\t    if (TREE_CODE (bound) == SAVE_EXPR\n \t\t&& SAVE_EXPR_RTL (bound))\n \t      output_loc_descriptor\n \t\t(eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n@@ -2300,8 +2267,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n    enumeration_type_die.  */\n \n static void\n-output_enumeral_list (link)\n-     tree link;\n+output_enumeral_list (tree link)\n {\n   if (link)\n     {\n@@ -2320,9 +2286,7 @@ output_enumeral_list (link)\n    which is not less than the value itself.  */\n \n static inline HOST_WIDE_INT\n-ceiling (value, boundary)\n-     HOST_WIDE_INT value;\n-     unsigned int boundary;\n+ceiling (HOST_WIDE_INT value, unsigned int boundary)\n {\n   return (((value + boundary - 1) / boundary) * boundary);\n }\n@@ -2332,8 +2296,7 @@ ceiling (value, boundary)\n    `integer_type_node' if the given node turns out to be an ERROR_MARK node.  */\n \n static inline tree\n-field_type (decl)\n-     tree decl;\n+field_type (tree decl)\n {\n   tree type;\n \n@@ -2351,8 +2314,7 @@ field_type (decl)\n    BITS_PER_WORD if the node actually turns out to be an ERROR_MARK node.  */\n \n static inline unsigned int\n-simple_type_align_in_bits (type)\n-     tree type;\n+simple_type_align_in_bits (tree type)\n {\n   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n }\n@@ -2364,8 +2326,7 @@ simple_type_align_in_bits (type)\n    to be an ERROR_MARK node.  */\n \n static inline unsigned HOST_WIDE_INT\n-simple_type_size_in_bits (type)\n-     tree type;\n+simple_type_size_in_bits (tree type)\n {\n   tree type_size_tree;\n \n@@ -2388,8 +2349,7 @@ simple_type_size_in_bits (type)\n    (We can't handle the latter case just yet.)  */\n \n static HOST_WIDE_INT\n-field_byte_offset (decl)\n-     tree decl;\n+field_byte_offset (tree decl)\n {\n   unsigned int type_align_in_bytes;\n   unsigned int type_align_in_bits;\n@@ -2534,7 +2494,7 @@ field_byte_offset (decl)\n /* Generate an AT_sibling attribute.  */\n \n static inline void\n-sibling_attribute ()\n+sibling_attribute (void)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -2548,8 +2508,7 @@ sibling_attribute ()\n    are generated by the routine `data_member_location_attribute' below.  */\n \n static void\n-location_attribute (rtl)\n-     rtx rtl;\n+location_attribute (rtx rtl)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2611,8 +2570,7 @@ location_attribute (rtl)\n    (See the `bit_offset_attribute' function below.)  */\n \n static void\n-data_member_location_attribute (t)\n-     tree t;\n+data_member_location_attribute (tree t)\n {\n   unsigned object_offset_in_bytes;\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2641,8 +2599,7 @@ data_member_location_attribute (t)\n    declared constants do not necessarily get memory \"homes\".  */\n \n static void\n-const_value_attribute (rtl)\n-     rtx rtl;\n+const_value_attribute (rtx rtl)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2726,8 +2683,7 @@ const_value_attribute (rtl)\n    call evaluates to a compile-time constant address.  */\n \n static void\n-location_or_const_value_attribute (decl)\n-     tree decl;\n+location_or_const_value_attribute (tree decl)\n {\n   rtx rtl;\n \n@@ -2886,8 +2842,7 @@ location_or_const_value_attribute (decl)\n    the value of the attribute.\t*/\n \n static inline void\n-name_attribute (name_string)\n-     const char *name_string;\n+name_attribute (const char *name_string)\n {\n   if (name_string && *name_string)\n     {\n@@ -2897,18 +2852,14 @@ name_attribute (name_string)\n }\n \n static inline void\n-fund_type_attribute (ft_code)\n-     unsigned ft_code;\n+fund_type_attribute (unsigned int ft_code)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_fund_type);\n   ASM_OUTPUT_DWARF_FUND_TYPE (asm_out_file, ft_code);\n }\n \n static void\n-mod_fund_type_attribute (type, decl_const, decl_volatile)\n-     tree type;\n-     int decl_const;\n-     int decl_volatile;\n+mod_fund_type_attribute (tree type, int decl_const, int decl_volatile)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2925,8 +2876,7 @@ mod_fund_type_attribute (type, decl_const, decl_volatile)\n }\n \n static inline void\n-user_def_type_attribute (type)\n-     tree type;\n+user_def_type_attribute (tree type)\n {\n   char ud_type_name[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -2936,10 +2886,7 @@ user_def_type_attribute (type)\n }\n \n static void\n-mod_u_d_type_attribute (type, decl_const, decl_volatile)\n-     tree type;\n-     int decl_const;\n-     int decl_volatile;\n+mod_u_d_type_attribute (tree type, int decl_const, int decl_volatile)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2958,8 +2905,7 @@ mod_u_d_type_attribute (type, decl_const, decl_volatile)\n \n #ifdef USE_ORDERING_ATTRIBUTE\n static inline void\n-ordering_attribute (ordering)\n-     unsigned ordering;\n+ordering_attribute (unsigned ordering)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_ordering);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, ordering);\n@@ -2970,8 +2916,7 @@ ordering_attribute (ordering)\n    includes information about the element type of type given array type.  */\n \n static void\n-subscript_data_attribute (type)\n-     tree type;\n+subscript_data_attribute (tree type)\n {\n   unsigned dimension_number;\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3069,8 +3014,7 @@ subscript_data_attribute (type)\n }\n \n static void\n-byte_size_attribute (tree_node)\n-     tree tree_node;\n+byte_size_attribute (tree tree_node)\n {\n   unsigned size;\n \n@@ -3129,8 +3073,7 @@ byte_size_attribute (tree_node)\n    bit-field.  (See `byte_size_attribute' above.) */\n \n static inline void\n-bit_offset_attribute (decl)\n-     tree decl;\n+bit_offset_attribute (tree decl)\n {\n   HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n   tree type = DECL_BIT_FIELD_TYPE (decl);\n@@ -3182,8 +3125,7 @@ bit_offset_attribute (decl)\n    which specifies the length in bits of the given field.  */\n \n static inline void\n-bit_size_attribute (decl)\n-    tree decl;\n+bit_size_attribute (tree decl)\n {\n   /* Must be a field and a bit field.  */\n   if (TREE_CODE (decl) != FIELD_DECL\n@@ -3204,8 +3146,7 @@ bit_size_attribute (decl)\n    type.  */\n \n static inline void\n-element_list_attribute (element)\n-     tree element;\n+element_list_attribute (tree element)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3230,8 +3171,7 @@ element_list_attribute (element)\n    DIEs with a TAG_compile_unit tag.  */\n \n static inline void\n-stmt_list_attribute (label)\n-    const char *label;\n+stmt_list_attribute (const char *label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_stmt_list);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n@@ -3242,8 +3182,7 @@ stmt_list_attribute (label)\n    for a subroutine DIE.  */\n \n static inline void\n-low_pc_attribute (asm_low_label)\n-     const char *asm_low_label;\n+low_pc_attribute (const char *asm_low_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_low_pc);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_low_label);\n@@ -3253,8 +3192,7 @@ low_pc_attribute (asm_low_label)\n    subroutine DIE.  */\n \n static inline void\n-high_pc_attribute (asm_high_label)\n-     const char *asm_high_label;\n+high_pc_attribute (const char *asm_high_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_high_pc);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_high_label);\n@@ -3263,8 +3201,7 @@ high_pc_attribute (asm_high_label)\n /* Generate an AT_body_begin attribute for a subroutine DIE.  */\n \n static inline void\n-body_begin_attribute (asm_begin_label)\n-     const char *asm_begin_label;\n+body_begin_attribute (const char *asm_begin_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_body_begin);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_begin_label);\n@@ -3273,8 +3210,7 @@ body_begin_attribute (asm_begin_label)\n /* Generate an AT_body_end attribute for a subroutine DIE.  */\n \n static inline void\n-body_end_attribute (asm_end_label)\n-     const char *asm_end_label;\n+body_end_attribute (const char *asm_end_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_body_end);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_end_label);\n@@ -3284,16 +3220,14 @@ body_end_attribute (asm_end_label)\n    are used only within TAG_compile_unit DIEs.  */\n \n static inline void\n-language_attribute (language_code)\n-     unsigned language_code;\n+language_attribute (unsigned int language_code)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_language);\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, language_code);\n }\n \n static inline void\n-member_attribute (context)\n-     tree context;\n+member_attribute (tree context)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3316,8 +3250,7 @@ member_attribute (context)\n #endif\n \n static inline void\n-string_length_attribute (upper_bound)\n-     tree upper_bound;\n+string_length_attribute (tree upper_bound)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3333,43 +3266,38 @@ string_length_attribute (upper_bound)\n #endif\n \n static inline void\n-comp_dir_attribute (dirname)\n-     const char *dirname;\n+comp_dir_attribute (const char *dirname)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_comp_dir);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, dirname);\n }\n \n static inline void\n-sf_names_attribute (sf_names_start_label)\n-     const char *sf_names_start_label;\n+sf_names_attribute (const char *sf_names_start_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_sf_names);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, sf_names_start_label);\n }\n \n static inline void\n-src_info_attribute (src_info_start_label)\n-     const char *src_info_start_label;\n+src_info_attribute (const char *src_info_start_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_src_info);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, src_info_start_label);\n }\n \n static inline void\n-mac_info_attribute (mac_info_start_label)\n-     const char *mac_info_start_label;\n+mac_info_attribute (const char *mac_info_start_label)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_mac_info);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, mac_info_start_label);\n }\n \n static inline void\n-prototyped_attribute (func_type)\n-     tree func_type;\n+prototyped_attribute (tree func_type)\n {\n   if ((strcmp (lang_hooks.name, \"GNU C\") == 0)\n       && (TYPE_ARG_TYPES (func_type) != NULL))\n@@ -3380,16 +3308,14 @@ prototyped_attribute (func_type)\n }\n \n static inline void\n-producer_attribute (producer)\n-     const char *producer;\n+producer_attribute (const char *producer)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_producer);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, producer);\n }\n \n static inline void\n-inline_attribute (decl)\n-     tree decl;\n+inline_attribute (tree decl)\n {\n   if (DECL_INLINE (decl))\n     {\n@@ -3399,8 +3325,7 @@ inline_attribute (decl)\n }\n \n static inline void\n-containing_type_attribute (containing_type)\n-     tree containing_type;\n+containing_type_attribute (tree containing_type)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3410,8 +3335,7 @@ containing_type_attribute (containing_type)\n }\n \n static inline void\n-abstract_origin_attribute (origin)\n-     tree origin;\n+abstract_origin_attribute (tree origin)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3435,9 +3359,7 @@ abstract_origin_attribute (origin)\n \n #ifdef DWARF_DECL_COORDINATES\n static inline void\n-src_coords_attribute (src_fileno, src_lineno)\n-     unsigned src_fileno;\n-     unsigned src_lineno;\n+src_coords_attribute (unsigned src_fileno, unsigned src_lineno)\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_src_coords);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_fileno);\n@@ -3446,8 +3368,7 @@ src_coords_attribute (src_fileno, src_lineno)\n #endif /* defined(DWARF_DECL_COORDINATES) */\n \n static inline void\n-pure_or_virtual_attribute (func_decl)\n-     tree func_decl;\n+pure_or_virtual_attribute (tree func_decl)\n {\n   if (DECL_VIRTUAL_P (func_decl))\n     {\n@@ -3469,8 +3390,7 @@ pure_or_virtual_attribute (func_decl)\n    given decl, but only if it actually has a name.  */\n \n static void\n-name_and_src_coords_attributes (decl)\n-    tree decl;\n+name_and_src_coords_attributes (tree decl)\n {\n   tree decl_name = DECL_NAME (decl);\n \n@@ -3505,10 +3425,7 @@ name_and_src_coords_attributes (decl)\n    routine writes out these \"type descriptor\" parts.  */\n \n static void\n-type_attribute (type, decl_const, decl_volatile)\n-     tree type;\n-     int decl_const;\n-     int decl_volatile;\n+type_attribute (tree type, int decl_const, int decl_volatile)\n {\n   enum tree_code code = TREE_CODE (type);\n   int root_type_modified;\n@@ -3563,8 +3480,7 @@ type_attribute (type, decl_const, decl_volatile)\n    type was declared without a tag.  */\n \n static const char *\n-type_tag (type)\n-     tree type;\n+type_tag (tree type)\n {\n   const char *name = 0;\n \n@@ -3592,7 +3508,7 @@ type_tag (type)\n }\n \n static inline void\n-dienum_push ()\n+dienum_push (void)\n {\n   /* Start by checking if the pending_sibling_stack needs to be expanded.\n      If necessary, expand it.  */\n@@ -3613,14 +3529,13 @@ dienum_push ()\n    NEXT_DIE_NUM.  */\n \n static inline void\n-dienum_pop ()\n+dienum_pop (void)\n {\n   pending_siblings--;\n }\n \n static inline tree\n-member_declared_type (member)\n-     tree member;\n+member_declared_type (tree member)\n {\n   return (DECL_BIT_FIELD_TYPE (member))\n \t   ? DECL_BIT_FIELD_TYPE (member)\n@@ -3632,8 +3547,7 @@ member_declared_type (member)\n    in the source file.  */\n \n static const char *\n-function_start_label (decl)\n-    tree decl;\n+function_start_label (tree decl)\n {\n   rtx x;\n   const char *fnname;\n@@ -3656,8 +3570,7 @@ function_start_label (decl)\n /* Note that every type of DIE (except a null DIE) gets a sibling.  */\n \n static void\n-output_array_type_die (arg)\n-     void *arg;\n+output_array_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3683,8 +3596,7 @@ output_array_type_die (arg)\n }\n \n static void\n-output_set_type_die (arg)\n-     void *arg;\n+output_set_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3699,8 +3611,7 @@ output_set_type_die (arg)\n /* Implement this when there is a GNU FORTRAN or GNU Ada front end.  */\n \n static void\n-output_entry_point_die (arg)\n-     void *arg;\n+output_entry_point_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -3726,8 +3637,7 @@ output_entry_point_die (arg)\n /* Output a DIE to represent an inlined instance of an enumeration type.  */\n \n static void\n-output_inlined_enumeration_type_die (arg)\n-     void *arg;\n+output_inlined_enumeration_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3741,8 +3651,7 @@ output_inlined_enumeration_type_die (arg)\n /* Output a DIE to represent an inlined instance of a structure type.  */\n \n static void\n-output_inlined_structure_type_die (arg)\n-     void *arg;\n+output_inlined_structure_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3756,8 +3665,7 @@ output_inlined_structure_type_die (arg)\n /* Output a DIE to represent an inlined instance of a union type.  */\n \n static void\n-output_inlined_union_type_die (arg)\n-     void *arg;\n+output_inlined_union_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3773,8 +3681,7 @@ output_inlined_union_type_die (arg)\n    This information is encoded into the element_list attribute.\t */\n \n static void\n-output_enumeration_type_die (arg)\n-     void *arg;\n+output_enumeration_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -3809,8 +3716,7 @@ output_enumeration_type_die (arg)\n    formal argument type of some subprogram type.  */\n \n static void\n-output_formal_parameter_die (arg)\n-     void *arg;\n+output_formal_parameter_die (void *arg)\n {\n   tree node = arg;\n \n@@ -3851,8 +3757,7 @@ output_formal_parameter_die (arg)\n    or block-local) which has \"external linkage\" (according to ANSI-C).  */\n \n static void\n-output_global_subroutine_die (arg)\n-     void *arg;\n+output_global_subroutine_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -3901,8 +3806,7 @@ output_global_subroutine_die (arg)\n    or block-local) which has \"external linkage\" (according to ANSI-C).  */\n \n static void\n-output_global_variable_die (arg)\n-     void *arg;\n+output_global_variable_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -3929,8 +3833,7 @@ output_global_variable_die (arg)\n }\n \n static void\n-output_label_die (arg)\n-     void *arg;\n+output_label_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -3972,8 +3875,7 @@ output_label_die (arg)\n }\n \n static void\n-output_lexical_block_die (arg)\n-     void *arg;\n+output_lexical_block_die (void *arg)\n {\n   tree stmt = arg;\n \n@@ -3993,8 +3895,7 @@ output_lexical_block_die (arg)\n }\n \n static void\n-output_inlined_subroutine_die (arg)\n-     void *arg;\n+output_inlined_subroutine_die (void *arg)\n {\n   tree stmt = arg;\n \n@@ -4018,8 +3919,7 @@ output_inlined_subroutine_die (arg)\n    or block-local) which has \"internal linkage\" (according to ANSI-C).  */\n \n static void\n-output_local_variable_die (arg)\n-     void *arg;\n+output_local_variable_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -4042,8 +3942,7 @@ output_local_variable_die (arg)\n }\n \n static void\n-output_member_die (arg)\n-     void *arg;\n+output_member_die (void *arg)\n {\n   tree decl = arg;\n \n@@ -4071,8 +3970,7 @@ output_member_die (arg)\n    someday.  */\n \n static void\n-output_pointer_type_die (arg)\n-     void *arg;\n+output_pointer_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4084,8 +3982,7 @@ output_pointer_type_die (arg)\n }\n \n static void\n-output_reference_type_die (arg)\n-     void *arg;\n+output_reference_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4098,8 +3995,7 @@ output_reference_type_die (arg)\n #endif\n \n static void\n-output_ptr_to_mbr_type_die (arg)\n-     void *arg;\n+output_ptr_to_mbr_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4112,8 +4008,7 @@ output_ptr_to_mbr_type_die (arg)\n }\n \n static void\n-output_compile_unit_die (arg)\n-     void *arg;\n+output_compile_unit_die (void *arg)\n {\n   const char *main_input_filename = arg;\n   const char *language_string = lang_hooks.name;\n@@ -4163,8 +4058,7 @@ output_compile_unit_die (arg)\n }\n \n static void\n-output_string_type_die (arg)\n-     void *arg;\n+output_string_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4177,8 +4071,7 @@ output_string_type_die (arg)\n }\n \n static void\n-output_inheritance_die (arg)\n-     void *arg;\n+output_inheritance_die (void *arg)\n {\n   tree binfo = ((tree *)arg)[0];\n   tree access = ((tree *)arg)[1];\n@@ -4205,8 +4098,7 @@ output_inheritance_die (arg)\n }\n \n static void\n-output_structure_type_die (arg)\n-     void *arg;\n+output_structure_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4233,8 +4125,7 @@ output_structure_type_die (arg)\n    or block-local) which has \"internal linkage\" (according to ANSI-C).  */\n \n static void\n-output_local_subroutine_die (arg)\n-     void *arg;\n+output_local_subroutine_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -4281,8 +4172,7 @@ output_local_subroutine_die (arg)\n }\n \n static void\n-output_subroutine_type_die (arg)\n-     void *arg;\n+output_subroutine_type_die (void *arg)\n {\n   tree type = arg;\n   tree return_type = TREE_TYPE (type);\n@@ -4297,8 +4187,7 @@ output_subroutine_type_die (arg)\n }\n \n static void\n-output_typedef_die (arg)\n-     void *arg;\n+output_typedef_die (void *arg)\n {\n   tree decl = arg;\n   tree origin = decl_ultimate_origin (decl);\n@@ -4319,8 +4208,7 @@ output_typedef_die (arg)\n }\n \n static void\n-output_union_type_die (arg)\n-     void *arg;\n+output_union_type_die (void *arg)\n {\n   tree type = arg;\n \n@@ -4347,8 +4235,7 @@ output_union_type_die (arg)\n    at the end of an (ANSI prototyped) formal parameters list.  */\n \n static void\n-output_unspecified_parameters_die (arg)\n-     void *arg;\n+output_unspecified_parameters_die (void *arg)\n {\n   tree decl_or_type = arg;\n \n@@ -4373,8 +4260,7 @@ output_unspecified_parameters_die (arg)\n }\n \n static void\n-output_padded_null_die (arg)\n-     void *arg ATTRIBUTE_UNUSED;\n+output_padded_null_die (void *arg ATTRIBUTE_UNUSED)\n {\n   ASM_OUTPUT_ALIGN (asm_out_file, 2);\t/* 2**2 == 4 */\n }\n@@ -4388,9 +4274,7 @@ output_padded_null_die (arg)\n    of the DIE, there must always be a terminator label for the DIE.  */\n \n static void\n-output_die (die_specific_output_function, param)\n-     void (*die_specific_output_function) PARAMS ((void *));\n-     void *param;\n+output_die (void (*die_specific_output_function) (void *), void *param)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -4420,7 +4304,7 @@ output_die (die_specific_output_function, param)\n }\n \n static void\n-end_sibling_chain ()\n+end_sibling_chain (void)\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -4452,8 +4336,7 @@ end_sibling_chain ()\n    the formal parameter list.  */\n \n static void\n-output_formal_types (function_or_method_type)\n-     tree function_or_method_type;\n+output_formal_types (tree function_or_method_type)\n {\n   tree link;\n   tree formal_type = NULL;\n@@ -4517,8 +4400,7 @@ output_formal_types (function_or_method_type)\n /* Remember a type in the pending_types_list.  */\n \n static void\n-pend_type (type)\n-     tree type;\n+pend_type (tree type)\n {\n   if (pending_types == pending_types_allocated)\n     {\n@@ -4573,9 +4455,7 @@ pend_type (type)\n    true scope of the types we temporarily pended.  */\n \n static inline int\n-type_ok_for_scope (type, scope)\n-    tree type;\n-    tree scope;\n+type_ok_for_scope (tree type, tree scope)\n {\n   /* Tagged types (i.e. struct, union, and enum types) must always be\n      output only in the scopes where they actually belong (or else the\n@@ -4610,8 +4490,7 @@ type_ok_for_scope (type, scope)\n    of them too.  */\n \n static void\n-output_pending_types_for_scope (containing_scope)\n-     tree containing_scope;\n+output_pending_types_for_scope (tree containing_scope)\n {\n   unsigned i;\n \n@@ -4648,8 +4527,7 @@ output_pending_types_for_scope (containing_scope)\n /* Remember a type in the incomplete_types_list.  */\n \n static void\n-add_incomplete_type (type)\n-     tree type;\n+add_incomplete_type (tree type)\n {\n   if (incomplete_types == incomplete_types_allocated)\n     {\n@@ -4666,7 +4544,7 @@ add_incomplete_type (type)\n    emit full debugging info for them.  */\n \n static void\n-retry_incomplete_types ()\n+retry_incomplete_types (void)\n {\n   tree type;\n \n@@ -4680,9 +4558,7 @@ retry_incomplete_types ()\n }\n \n static void\n-output_type (type, containing_scope)\n-     tree type;\n-     tree containing_scope;\n+output_type (tree type, tree containing_scope)\n {\n   if (type == 0 || type == error_mark_node)\n     return;\n@@ -4899,7 +4775,7 @@ output_type (type, containing_scope)\n \tif (COMPLETE_TYPE_P (type))\n \t  {\n \t    tree binfo = TYPE_BINFO (type);\n-\t    \n+\n \t    /* First output info about the base classes.  */\n \t    if (binfo)\n \t      {\n@@ -4982,8 +4858,7 @@ output_type (type, containing_scope)\n }\n \n static void\n-output_tagged_type_instantiation (type)\n-     tree type;\n+output_tagged_type_instantiation (tree type)\n {\n   if (type == 0 || type == error_mark_node)\n     return;\n@@ -5026,9 +4901,7 @@ output_tagged_type_instantiation (type)\n    the things which are local to the given block.  */\n \n static void\n-output_block (stmt, depth)\n-    tree stmt;\n-    int depth;\n+output_block (tree stmt, int depth)\n {\n   int must_output_die = 0;\n   tree origin;\n@@ -5120,9 +4993,7 @@ output_block (stmt, depth)\n    a `binding contour') and (recursively) all of it's sub-blocks.  */\n \n static void\n-output_decls_for_scope (stmt, depth)\n-     tree stmt;\n-     int depth;\n+output_decls_for_scope (tree stmt, int depth)\n {\n   /* Ignore blocks never really used to make RTL.  */\n \n@@ -5158,8 +5029,7 @@ output_decls_for_scope (stmt, depth)\n /* Is this a typedef we can avoid emitting?  */\n \n static inline int\n-is_redundant_typedef (decl)\n-     tree decl;\n+is_redundant_typedef (tree decl)\n {\n   if (TYPE_DECL_IS_STUB (decl))\n     return 1;\n@@ -5176,9 +5046,7 @@ is_redundant_typedef (decl)\n /* Output Dwarf .debug information for a decl described by DECL.  */\n \n static void\n-output_decl (decl, containing_scope)\n-     tree decl;\n-     tree containing_scope;\n+output_decl (tree decl, tree containing_scope)\n {\n   /* Make a note of the decl node we are going to be working on.  We may\n      need to give the user the source coordinates of where it appeared in\n@@ -5501,7 +5369,7 @@ output_decl (decl, containing_scope)\n \t function.  */\n \n       {\n-\tvoid (*func) PARAMS ((void *));\n+\tvoid (*func) (void *);\n \tregister tree origin = decl_ultimate_origin (decl);\n \n \tif (origin != NULL && TREE_CODE (origin) == PARM_DECL)\n@@ -5547,17 +5415,15 @@ output_decl (decl, containing_scope)\n \f\n /* Output debug information for a function.  */\n static void\n-dwarfout_function_decl (decl)\n-     tree decl;\n+dwarfout_function_decl (tree decl)\n {\n   dwarfout_file_scope_decl (decl, 0);\n }\n \n /* Debug information for a global DECL.  Called from toplev.c after\n    compilation proper has finished.  */\n static void\n-dwarfout_global_decl (decl)\n-     tree decl;\n+dwarfout_global_decl (tree decl)\n {\n   /* Output DWARF information for file-scope tentative data object\n      declarations, file-scope (extern) function declarations (which\n@@ -5572,8 +5438,7 @@ dwarfout_global_decl (decl)\n    being output at this point.  (We're putting that off until we need\n    to do it.)  */\n static void\n-dwarfout_deferred_inline_function (decl)\n-     tree decl;\n+dwarfout_deferred_inline_function (tree decl)\n {\n   /* Generate the DWARF info for the \"abstract\" instance of a function\n      which we may later generate inlined and/or out-of-line instances\n@@ -5601,9 +5466,7 @@ dwarfout_deferred_inline_function (decl)\n }\n \n static void\n-dwarfout_file_scope_decl (decl, set_finalizing)\n-     tree decl;\n-     int set_finalizing;\n+dwarfout_file_scope_decl (tree decl, int set_finalizing)\n {\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -5814,9 +5677,8 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n    for a lexical block.\t */\n \n static void\n-dwarfout_begin_block (line, blocknum)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     unsigned int blocknum;\n+dwarfout_begin_block (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t      unsigned int blocknum)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5829,9 +5691,7 @@ dwarfout_begin_block (line, blocknum)\n    for a lexical block.\t */\n \n static void\n-dwarfout_end_block (line, blocknum)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     unsigned int blocknum;\n+dwarfout_end_block (unsigned int line ATTRIBUTE_UNUSED, unsigned int blocknum)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5845,9 +5705,8 @@ dwarfout_end_block (line, blocknum)\n    to their home locations).  */\n \n static void\n-dwarfout_end_prologue (line, file)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *file ATTRIBUTE_UNUSED;\n+dwarfout_end_prologue (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t       const char *file ATTRIBUTE_UNUSED)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5863,8 +5722,7 @@ dwarfout_end_prologue (line, file)\n    the real body of the function ends (just before the epilogue code).  */\n \n static void\n-dwarfout_end_function (line)\n-     unsigned int line ATTRIBUTE_UNUSED;\n+dwarfout_end_function (unsigned int line ATTRIBUTE_UNUSED)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5880,9 +5738,8 @@ dwarfout_end_function (line)\n    has been generated.\t*/\n \n static void\n-dwarfout_end_epilogue (line, file)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *file ATTRIBUTE_UNUSED;\n+dwarfout_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t       const char *file ATTRIBUTE_UNUSED)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5894,8 +5751,7 @@ dwarfout_end_epilogue (line, file)\n }\n \n static void\n-shuffle_filename_entry (new_zeroth)\n-     filename_entry *new_zeroth;\n+shuffle_filename_entry (filename_entry *new_zeroth)\n {\n   filename_entry temp_entry;\n   filename_entry *limit_p;\n@@ -5920,7 +5776,7 @@ shuffle_filename_entry (new_zeroth)\n /* Create a new (string) entry for the .debug_sfnames section.  */\n \n static void\n-generate_new_sfname_entry ()\n+generate_new_sfname_entry (void)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -5967,8 +5823,7 @@ generate_new_sfname_entry ()\n    before them.) */\n \n static unsigned\n-lookup_filename (file_name)\n-     const char *file_name;\n+lookup_filename (const char *file_name)\n {\n   filename_entry *search_p;\n   filename_entry *limit_p = &filename_table[ft_entries];\n@@ -6018,9 +5873,7 @@ lookup_filename (file_name)\n }\n \n static void\n-generate_srcinfo_entry (line_entry_num, files_entry_num)\n-     unsigned line_entry_num;\n-     unsigned files_entry_num;\n+generate_srcinfo_entry (unsigned int line_entry_num, unsigned int files_entry_num)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -6034,9 +5887,7 @@ generate_srcinfo_entry (line_entry_num, files_entry_num)\n }\n \n static void\n-dwarfout_source_line (line, filename)\n-     unsigned int line;\n-     const char *filename;\n+dwarfout_source_line (unsigned int line, const char *filename)\n {\n   if (debug_info_level >= DINFO_LEVEL_NORMAL\n       /* We can't emit line number info for functions in separate sections,\n@@ -6089,10 +5940,7 @@ dwarfout_source_line (line, filename)\n /* Generate an entry in the .debug_macinfo section.  */\n \n static void\n-generate_macinfo_entry (type, offset, string)\n-     unsigned int type;\n-     rtx offset;\n-     const char *string;\n+generate_macinfo_entry (unsigned int type, rtx offset, const char *string)\n {\n   if (! use_gnu_debug_info_extensions)\n     return;\n@@ -6107,18 +5955,15 @@ generate_macinfo_entry (type, offset, string)\n \n /* Wrapper for toplev.c callback to check debug info level.  */\n static void\n-dwarfout_start_source_file_check (line, filename)\n-     unsigned int line;\n-     const char *filename;\n+dwarfout_start_source_file_check (unsigned int line, const char *filename)\n {\n   if (debug_info_level == DINFO_LEVEL_VERBOSE)\n     dwarfout_start_source_file (line, filename);\n }\n \n static void\n-dwarfout_start_source_file (line, filename)\n-     unsigned int line ATTRIBUTE_UNUSED;\n-     const char *filename;\n+dwarfout_start_source_file (unsigned int line ATTRIBUTE_UNUSED,\n+\t\t\t    const char *filename)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   const char *label1, *label2;\n@@ -6135,16 +5980,14 @@ dwarfout_start_source_file (line, filename)\n \n /* Wrapper for toplev.c callback to check debug info level.  */\n static void\n-dwarfout_end_source_file_check (lineno)\n-     unsigned lineno;\n+dwarfout_end_source_file_check (unsigned int lineno)\n {\n   if (debug_info_level == DINFO_LEVEL_VERBOSE)\n     dwarfout_end_source_file (lineno);\n }\n \n static void\n-dwarfout_end_source_file (lineno)\n-     unsigned lineno;\n+dwarfout_end_source_file (unsigned int lineno)\n {\n   generate_macinfo_entry (MACINFO_resume, GEN_INT (lineno), \"\");\n }\n@@ -6155,9 +5998,7 @@ dwarfout_end_source_file (lineno)\n    whitespace part.  */\n \n static void\n-dwarfout_define (lineno, buffer)\n-     unsigned lineno;\n-     const char *buffer;\n+dwarfout_define (unsigned int lineno, const char *buffer)\n {\n   static int initialized = 0;\n \n@@ -6175,18 +6016,15 @@ dwarfout_define (lineno, buffer)\n    whitespace part.  */\n \n static void\n-dwarfout_undef (lineno, buffer)\n-     unsigned lineno;\n-     const char *buffer;\n+dwarfout_undef (unsigned int lineno, const char *buffer)\n {\n   generate_macinfo_entry (MACINFO_undef, GEN_INT (lineno), buffer);\n }\n \n /* Set up for Dwarf output at the start of compilation.\t */\n \n static void\n-dwarfout_init (main_input_filename)\n-     const char *main_input_filename;\n+dwarfout_init (const char *main_input_filename)\n {\n   warning (\"support for the DWARF1 debugging format is deprecated\");\n \n@@ -6376,8 +6214,7 @@ dwarfout_init (main_input_filename)\n /* Output stuff that dwarf requires at the end of every file.  */\n \n static void\n-dwarfout_finish (main_input_filename)\n-     const char *main_input_filename ATTRIBUTE_UNUSED;\n+dwarfout_finish (const char *main_input_filename ATTRIBUTE_UNUSED)\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n "}]}