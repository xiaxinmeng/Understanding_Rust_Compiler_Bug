{"sha": "08793a386ad3f3365bd891dc793eedc59f8c5ee5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg3OTNhMzg2YWQzZjMzNjViZDg5MWRjNzkzZWVkYzU5ZjhjNWVlNQ==", "commit": {"author": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2015-05-26T14:06:17Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2015-05-26T14:06:17Z"}, "message": "re PR target/52144 (ARM should support arm/thumb function attribute to permit different instruction sets in the same source)\n\n 2015-05-13  Christian Bruel  <christian.bruel@st.com>\n\n\tPR target/52144\n\t* config/arm/arm.c (arm_option_check_internal)\n\t(arm_option_params_internal): Check opts->target_flags to set macros.\n\t(TREE_TARGET_ARM, TREE_TARGET_THUMB)\n\t(TREE_TARGET_THUMB1, TREE_TARGET_THUMB2) Replace with...\n\t(TARGET_ARM_P, TARGET_THUMB_P, TARGET_THUMB1_P, TARGET_THUMB2_P)\n\t(builtin_define): Replaced with def_or_undef_macro.\n\t* config/arm/arm.h (TREE_TARGET_ARM, TREE_TARGET_THUMB)\n\tTREE_TARGET_THUMB1, TREE_TARGET_THUMB2) Redefine with...\n\t(TARGET_ARM_P, TARGET_THUMB_P, TARGET_THUMB1_P, TARGET_THUMB2_P)\n\t(TARGET_32BIT_P, TARGET_ARM_QBIT_P, TARGET_ARM_SAT_P, TARGET_IDIV_P)\n\t(TARGET_HAVE_LDREX_P, TARGET_HAVE_LDREXBH_P, TARGET_HAVE_LDREXD_P)\n\t(TARGET_ARM_FEATURE_LDREX_P)\n\t(TARGET_DSP_MULTIPLY_P, TARGET_INT_SIMD_P): New macros.\n\t(def_or_undef_macro): New function.\n\nFrom-SVN: r223699", "tree": {"sha": "a3d0dee1ac6951de5df21bb271ec538bb598ca71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d0dee1ac6951de5df21bb271ec538bb598ca71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08793a386ad3f3365bd891dc793eedc59f8c5ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08793a386ad3f3365bd891dc793eedc59f8c5ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08793a386ad3f3365bd891dc793eedc59f8c5ee5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08793a386ad3f3365bd891dc793eedc59f8c5ee5/comments", "author": null, "committer": null, "parents": [{"sha": "7049e4eb334cfdd6c13897caa1559e8e8211954c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7049e4eb334cfdd6c13897caa1559e8e8211954c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7049e4eb334cfdd6c13897caa1559e8e8211954c"}], "stats": {"total": 197, "additions": 128, "deletions": 69}, "files": [{"sha": "a9bdd6c24c578d3027f649c54d7ffd6f7625b341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08793a386ad3f3365bd891dc793eedc59f8c5ee5", "patch": "@@ -1,3 +1,21 @@\n+ 2015-05-13  Christian Bruel  <christian.bruel@st.com>\n+\n+\tPR target/52144\n+\t* config/arm/arm.c (arm_option_check_internal)\n+\t(arm_option_params_internal): Check opts->target_flags to set macros.\n+\t(TREE_TARGET_ARM, TREE_TARGET_THUMB)\n+\t(TREE_TARGET_THUMB1, TREE_TARGET_THUMB2) Replace with...\n+\t(TARGET_ARM_P, TARGET_THUMB_P, TARGET_THUMB1_P, TARGET_THUMB2_P)\n+\t(builtin_define): Replaced with def_or_undef_macro.\n+\t* config/arm/arm.h (TREE_TARGET_ARM, TREE_TARGET_THUMB)\n+\tTREE_TARGET_THUMB1, TREE_TARGET_THUMB2) Redefine with...\n+\t(TARGET_ARM_P, TARGET_THUMB_P, TARGET_THUMB1_P, TARGET_THUMB2_P)\n+\t(TARGET_32BIT_P, TARGET_ARM_QBIT_P, TARGET_ARM_SAT_P, TARGET_IDIV_P)\n+\t(TARGET_HAVE_LDREX_P, TARGET_HAVE_LDREXBH_P, TARGET_HAVE_LDREXD_P)\n+\t(TARGET_ARM_FEATURE_LDREX_P)\n+\t(TARGET_DSP_MULTIPLY_P, TARGET_INT_SIMD_P): New macros.\n+\t(def_or_undef_macro): New function.\n+\n 2015-05-26  Christian Bruel  <christian.bruel@st.com>\n \n \t* c-common.h (builtin_define_with_int_value)"}, {"sha": "8f9a867a989ab53b84f07848d20203cd5d86ce59", "filename": "gcc/config/arm/arm-c.c", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-c.c?ref=08793a386ad3f3365bd891dc793eedc59f8c5ee5", "patch": "@@ -55,31 +55,49 @@ arm_lang_object_attributes_init (void)\n #define builtin_define(TXT) cpp_define (pfile, TXT)\n #define builtin_assert(TXT) cpp_assert (pfile, TXT)\n \n+/* Define or undefine macros based on the current target.  If the user does\n+   #pragma GCC target, we need to adjust the macros dynamically.  */\n+\n+static void\n+def_or_undef_macro(struct cpp_reader* pfile, const char *name, bool def_p) \n+{\n+  if (def_p)\n+    cpp_define (pfile, name); \n+  else  \n+    cpp_undef (pfile, name); \n+} \n+\n void\n arm_cpu_cpp_builtins (struct cpp_reader * pfile)\n {\n-  if (TARGET_DSP_MULTIPLY)\n-    builtin_define (\"__ARM_FEATURE_DSP\");\n-  if (TARGET_ARM_QBIT)\n-    builtin_define (\"__ARM_FEATURE_QBIT\");\n-  if (TARGET_ARM_SAT)\n-    builtin_define (\"__ARM_FEATURE_SAT\");\n+  int flags = target_flags;\n+\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_DSP\",\n+\t\t      TARGET_DSP_MULTIPLY_P (flags));\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_QBIT\",\n+\t\t      TARGET_ARM_QBIT_P (flags)); \n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_SAT\",\n+\t\t      TARGET_ARM_SAT_P (flags));\n   if (TARGET_CRYPTO)\n     builtin_define (\"__ARM_FEATURE_CRYPTO\");\n   if (unaligned_access)\n     builtin_define (\"__ARM_FEATURE_UNALIGNED\");\n   if (TARGET_CRC32)\n     builtin_define (\"__ARM_FEATURE_CRC32\");\n-  if (TARGET_32BIT)\n-    builtin_define (\"__ARM_32BIT_STATE\");\n-  if (TARGET_ARM_FEATURE_LDREX)\n+\n+  def_or_undef_macro (pfile, \"__ARM_32BIT_STATE\", TARGET_32BIT_P (flags)); \n+\n+  if (TARGET_ARM_FEATURE_LDREX_P (flags))\n     builtin_define_with_int_value (\"__ARM_FEATURE_LDREX\", \n-\t\t\t\t   TARGET_ARM_FEATURE_LDREX);\n-  if ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB)\n-      || TARGET_ARM_ARCH_ISA_THUMB >=2)\n-    builtin_define (\"__ARM_FEATURE_CLZ\");\n-  if (TARGET_INT_SIMD)\n-    builtin_define (\"__ARM_FEATURE_SIMD32\");\n+\t\t\t\t   TARGET_ARM_FEATURE_LDREX_P (flags));\n+  else\n+    cpp_undef (pfile, \"__ARM_FEATURE_LDREX\");\n+\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_CLZ\",\n+\t\t      ((TARGET_ARM_ARCH >= 5 && !TARGET_THUMB_P (flags))\n+\t\t       || TARGET_ARM_ARCH_ISA_THUMB >=2));\n+\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_SIMD32\", TARGET_INT_SIMD_P (flags));\n \n   builtin_define_with_int_value (\"__ARM_SIZEOF_MINIMAL_ENUM\",\n \t\t\t\t flag_short_enums ? 1 : 4);\n@@ -96,10 +114,14 @@ arm_cpu_cpp_builtins (struct cpp_reader * pfile)\n   if (arm_arch_notm)\n     builtin_define (\"__ARM_ARCH_ISA_ARM\");\n   builtin_define (\"__APCS_32__\");\n-  if (TARGET_THUMB)\n-    builtin_define (\"__thumb__\");\n-  if (TARGET_THUMB2)\n-    builtin_define (\"__thumb2__\");\n+\n+  def_or_undef_macro (pfile, \"__thumb__\", TARGET_THUMB_P (flags));\n+  def_or_undef_macro (pfile, \"__thumb2__\", TARGET_THUMB2_P (flags));\n+  if (TARGET_BIG_END)\n+    def_or_undef_macro (pfile, \"__THUMBEB__\", TARGET_THUMB_P (flags));\n+  else\n+    def_or_undef_macro (pfile, \"__THUMBEL__\", TARGET_THUMB_P (flags));\n+\n   if (TARGET_ARM_ARCH_ISA_THUMB)\n     builtin_define_with_int_value (\"__ARM_ARCH_ISA_THUMB\",\n \t\t\t\t   TARGET_ARM_ARCH_ISA_THUMB);\n@@ -108,14 +130,10 @@ arm_cpu_cpp_builtins (struct cpp_reader * pfile)\n     {\n       builtin_define (\"__ARMEB__\");\n       builtin_define (\"__ARM_BIG_ENDIAN\");\n-      if (TARGET_THUMB)\n-\tbuiltin_define (\"__THUMBEB__\");\n     }\n   else\n     {\n       builtin_define (\"__ARMEL__\");\n-      if (TARGET_THUMB)\n-\tbuiltin_define (\"__THUMBEL__\");\n     }\n \n   if (TARGET_SOFT_FLOAT)\n@@ -166,11 +184,11 @@ arm_cpu_cpp_builtins (struct cpp_reader * pfile)\n \tbuiltin_define (\"__ARM_PCS\");\n       builtin_define (\"__ARM_EABI__\");\n     }\n-  if (TARGET_IDIV)\n-    {\n-      builtin_define (\"__ARM_ARCH_EXT_IDIV__\");\n-      builtin_define (\"__ARM_FEATURE_IDIV\");\n-    }\n-  if (inline_asm_unified)\n-    builtin_define (\"__ARM_ASM_SYNTAX_UNIFIED__\");\n+\n+\n+\n+  def_or_undef_macro (pfile, \"__ARM_ARCH_EXT_IDIV__\", TARGET_IDIV_P (flags));\n+  def_or_undef_macro (pfile, \"__ARM_FEATURE_IDIV\", TARGET_IDIV_P (flags));\n+\n+  def_or_undef_macro (pfile, \"__ARM_ASM_SYNTAX_UNIFIED__\", inline_asm_unified);\n }"}, {"sha": "888813b9c43f2f3b6a7f5eb9143a29c14a84eb0a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=08793a386ad3f3365bd891dc793eedc59f8c5ee5", "patch": "@@ -2702,35 +2702,37 @@ arm_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n static void\n arm_option_check_internal (struct gcc_options *opts)\n {\n+  int flags = opts->x_target_flags;\n+\n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n-  if (TREE_TARGET_ARM (opts) && !(insn_flags & FL_NOTM))\n+  if (TARGET_ARM_P (flags) && !(insn_flags & FL_NOTM))\n     error (\"target CPU does not support ARM mode\");\n \n   /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n      from here where no function is being compiled currently.  */\n-  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TREE_TARGET_ARM (opts))\n+  if ((TARGET_TPCS_FRAME || TARGET_TPCS_LEAF_FRAME) && TARGET_ARM_P (flags))\n     warning (0, \"enabling backtrace support is only meaningful when compiling for the Thumb\");\n \n-  if (TREE_TARGET_ARM (opts) && TARGET_CALLEE_INTERWORKING)\n+  if (TARGET_ARM_P (flags) && TARGET_CALLEE_INTERWORKING)\n     warning (0, \"enabling callee interworking support is only meaningful when compiling for the Thumb\");\n \n   /* If this target is normally configured to use APCS frames, warn if they\n      are turned off and debugging is turned on.  */\n-  if (TREE_TARGET_ARM (opts)\n+  if (TARGET_ARM_P (flags)\n       && write_symbols != NO_DEBUG\n       && !TARGET_APCS_FRAME\n       && (TARGET_DEFAULT & MASK_APCS_FRAME))\n     warning (0, \"-g with -mno-apcs-frame may not give sensible debugging\");\n \n   /* iWMMXt unsupported under Thumb mode.  */\n-  if (TREE_TARGET_THUMB (opts) && TARGET_IWMMXT)\n+  if (TARGET_THUMB_P (flags) && TARGET_IWMMXT)\n     error (\"iWMMXt unsupported under Thumb mode\");\n \n-  if (TARGET_HARD_TP && TREE_TARGET_THUMB1 (opts))\n+  if (TARGET_HARD_TP && TARGET_THUMB1_P (flags))\n     error (\"can not use -mtp=cp15 with 16-bit Thumb\");\n \n-  if (TREE_TARGET_THUMB (opts) && TARGET_VXWORKS_RTP && flag_pic)\n+  if (TARGET_THUMB_P (flags) && TARGET_VXWORKS_RTP && flag_pic)\n     {\n       error (\"RTP PIC is incompatible with Thumb\");\n       flag_pic = 0;\n@@ -2739,17 +2741,19 @@ arm_option_check_internal (struct gcc_options *opts)\n   /* We only support -mslow-flash-data on armv7-m targets.  */\n   if (target_slow_flash_data\n       && ((!(arm_arch7 && !arm_arch_notm) && !arm_arch7em)\n-\t  || (TREE_TARGET_THUMB1 (opts) || flag_pic || TARGET_NEON)))\n+\t  || (TARGET_THUMB1_P (flags) || flag_pic || TARGET_NEON)))\n     error (\"-mslow-flash-data only supports non-pic code on armv7-m targets\");\n }\n \n /* Set params depending on attributes and optimization options.  */\n static void\n arm_option_params_internal (struct gcc_options *opts)\n {\n+  int flags = opts->x_target_flags;\n+\n  /* If we are not using the default (ARM mode) section anchor offset\n      ranges, then set the correct ranges now.  */\n-  if (TREE_TARGET_THUMB1 (opts))\n+  if (TARGET_THUMB1_P (flags))\n     {\n       /* Thumb-1 LDR instructions cannot have negative offsets.\n          Permissible positive offset ranges are 5-bit (for byte loads),\n@@ -2759,7 +2763,7 @@ arm_option_params_internal (struct gcc_options *opts)\n       targetm.min_anchor_offset = 0;\n       targetm.max_anchor_offset = 127;\n     }\n-  else if (TREE_TARGET_THUMB2 (opts))\n+  else if (TARGET_THUMB2_P (flags))\n     {\n       /* The minimum is set such that the total size of the block\n          for a particular anchor is 248 + 1 + 4095 bytes, which is\n@@ -2780,7 +2784,7 @@ arm_option_params_internal (struct gcc_options *opts)\n       max_insns_skipped = 6;\n \n       /* For THUMB2, we limit the conditional sequence to one IT block.  */\n-      if (TREE_TARGET_THUMB2 (opts))\n+      if (TARGET_THUMB2_P (flags))\n         max_insns_skipped = opts->x_arm_restrict_it ? 1 : 4;\n     }\n   else\n@@ -2792,38 +2796,39 @@ static void\n arm_option_override_internal (struct gcc_options *opts,\n \t\t\t      struct gcc_options *opts_set)\n {\n-  if (TREE_TARGET_THUMB (opts) && !(insn_flags & FL_THUMB))\n+  if (TARGET_THUMB_P (opts->x_target_flags) && !(insn_flags & FL_THUMB))\n     {\n       warning (0, \"target CPU does not support THUMB instructions\");\n       opts->x_target_flags &= ~MASK_THUMB;\n     }\n \n-  if (TARGET_APCS_FRAME && TREE_TARGET_THUMB (opts))\n+  if (TARGET_APCS_FRAME && TARGET_THUMB_P (opts->x_target_flags))\n     {\n       /* warning (0, \"ignoring -mapcs-frame because -mthumb was used\"); */\n       opts->x_target_flags &= ~MASK_APCS_FRAME;\n     }\n \n   /* Callee super interworking implies thumb interworking.  Adding\n      this to the flags here simplifies the logic elsewhere.  */\n-  if (TREE_TARGET_THUMB (opts) && TARGET_CALLEE_INTERWORKING)\n+  if (TARGET_THUMB_P (opts->x_target_flags) && TARGET_CALLEE_INTERWORKING)\n     opts->x_target_flags |= MASK_INTERWORK;\n \n   if (! opts_set->x_arm_restrict_it)\n     opts->x_arm_restrict_it = arm_arch8;\n \n-  if (!TREE_TARGET_THUMB2 (opts))\n+  if (!TARGET_THUMB2_P (opts->x_target_flags))\n     opts->x_arm_restrict_it = 0;\n \n-  if (TREE_TARGET_THUMB1 (opts))\n+  if (TARGET_THUMB1_P (opts->x_target_flags))\n     {\n       /* Don't warn since it's on by default in -O2.  */\n       opts->x_flag_schedule_insns = 0;\n     }\n \n   /* Disable shrink-wrap when optimizing function for size, since it tends to\n      generate additional returns.  */\n-  if (optimize_function_for_size_p (cfun) && TREE_TARGET_THUMB2 (opts))\n+  if (optimize_function_for_size_p (cfun)\n+      && TARGET_THUMB2_P (opts->x_target_flags))\n     opts->x_flag_shrink_wrap = false;\n \n   /* In Thumb1 mode, we emit the epilogue in RTL, but the last insn\n@@ -2834,12 +2839,12 @@ arm_option_override_internal (struct gcc_options *opts,\n      finding out about it.  Therefore, disable fipa-ra in Thumb1 mode.\n      TODO: Accurately model clobbers for epilogue_insns and reenable\n      fipa-ra.  */\n-  if (TREE_TARGET_THUMB1 (opts))\n+  if (TARGET_THUMB1_P (opts->x_target_flags))\n     opts->x_flag_ipa_ra = 0;\n \n   /* Thumb2 inline assembly code should always use unified syntax.\n      This will apply to ARM and Thumb1 eventually.  */\n-  opts->x_inline_asm_unified = TREE_TARGET_THUMB2 (opts);\n+  opts->x_inline_asm_unified = TARGET_THUMB2_P (opts->x_target_flags);\n }\n \n /* Fix up any incompatible options that the user has specified.  */"}, {"sha": "df0aeb4a825503cc7f941cc7768ab51a4971d839", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08793a386ad3f3365bd891dc793eedc59f8c5ee5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=08793a386ad3f3365bd891dc793eedc59f8c5ee5", "patch": "@@ -128,12 +128,10 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #endif\n \f\n /* Tree Target Specification.  */\n-#define TREE_TARGET_THUMB(opts)  (TARGET_THUMB_P (opts->x_target_flags))\n-#define TREE_TARGET_ARM(opts)    (!TARGET_THUMB_P (opts->x_target_flags))\n-#define TREE_TARGET_THUMB1(opts) (TARGET_THUMB_P (opts->x_target_flags) \\\n-\t\t\t\t  && !arm_arch_thumb2)\n-#define TREE_TARGET_THUMB2(opts) (TARGET_THUMB_P (opts->x_target_flags) \\\n-\t\t\t\t  && arm_arch_thumb2)\n+#define TARGET_ARM_P(flags)    (!TARGET_THUMB_P (flags))\n+#define TARGET_THUMB1_P(flags) (TARGET_THUMB_P (flags) && !arm_arch_thumb2)\n+#define TARGET_THUMB2_P(flags) (TARGET_THUMB_P (flags) && arm_arch_thumb2)\n+\n /* Run-time Target Specification.  */\n #define TARGET_SOFT_FLOAT\t\t(arm_float_abi == ARM_FLOAT_ABI_SOFT)\n /* Use hardware floating point instructions. */\n@@ -162,6 +160,8 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_THUMB1\t\t\t(TARGET_THUMB && !arm_arch_thumb2)\n /* Arm or Thumb-2 32-bit code.  */\n #define TARGET_32BIT\t\t\t(TARGET_ARM || arm_arch_thumb2)\n+#define TARGET_32BIT_P(flags)\t\t(TARGET_ARM_P (flags) \\\n+\t\t\t\t\t || arm_arch_thumb2)\n /* 32-bit Thumb-2 code.  */\n #define TARGET_THUMB2\t\t\t(TARGET_THUMB && arm_arch_thumb2)\n /* Thumb-1 only.  */\n@@ -216,17 +216,21 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n \t\t     && TARGET_VFP && arm_fpu_desc->neon)\n \n /* Q-bit is present.  */\n-#define TARGET_ARM_QBIT \\\n-  (TARGET_32BIT && arm_arch5e && (arm_arch_notm || arm_arch7))\n+#define TARGET_ARM_QBIT_P(flags) \\\n+  (TARGET_32BIT_P (flags) && arm_arch5e && (arm_arch_notm || arm_arch7))\n+#define TARGET_ARM_QBIT TARGET_ARM_QBIT_P(target_flags)\n /* Saturation operation, e.g. SSAT.  */\n-#define TARGET_ARM_SAT \\\n-  (TARGET_32BIT && arm_arch6 && (arm_arch_notm || arm_arch7))\n+#define TARGET_ARM_SAT_P(flags) \\\n+  (TARGET_32BIT_P (flags) && arm_arch6 && (arm_arch_notm || arm_arch7))\n+#define TARGET_ARM_SAT TARGET_ARM_SAT_P(target_flags)\n /* \"DSP\" multiply instructions, eg. SMULxy.  */\n-#define TARGET_DSP_MULTIPLY \\\n-  (TARGET_32BIT && arm_arch5e && (arm_arch_notm || arm_arch7em))\n+#define TARGET_DSP_MULTIPLY_P(flags) \\\n+  (TARGET_32BIT_P (flags) && arm_arch5e && (arm_arch_notm || arm_arch7em))\n+#define TARGET_DSP_MULTIPLY TARGET_DSP_MULTIPLY_P(target_flags)\n /* Integer SIMD instructions, and extend-accumulate instructions.  */\n-#define TARGET_INT_SIMD \\\n-  (TARGET_32BIT && arm_arch6 && (arm_arch_notm || arm_arch7em))\n+#define TARGET_INT_SIMD_P(flags) \\\n+  (TARGET_32BIT_P (flags) && arm_arch6 && (arm_arch_notm || arm_arch7em))\n+#define TARGET_INT_SIMD TARGET_INT_SIMD_P(target_flags)\n \n /* Should MOVW/MOVT be used in preference to a constant pool.  */\n #define TARGET_USE_MOVT \\\n@@ -249,21 +253,30 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n #define TARGET_HAVE_MEMORY_BARRIER (TARGET_HAVE_DMB || TARGET_HAVE_DMB_MCR)\n \n /* Nonzero if this chip supports ldrex and strex */\n-#define TARGET_HAVE_LDREX\t((arm_arch6 && TARGET_ARM) || arm_arch7)\n+#define TARGET_HAVE_LDREX_P(flags) ((arm_arch6 && TARGET_ARM_P (flags)) \\\n+\t\t\t\t    || arm_arch7)\n+#define TARGET_HAVE_LDREX\t  TARGET_HAVE_LDREX_P (target_flags) \n \n /* Nonzero if this chip supports ldrex{bh} and strex{bh}.  */\n-#define TARGET_HAVE_LDREXBH\t((arm_arch6k && TARGET_ARM) || arm_arch7)\n+#define TARGET_HAVE_LDREXBH_P(flags) ((arm_arch6k && TARGET_ARM_P (flags)) \\\n+\t\t\t\t      || arm_arch7)\n+#define TARGET_HAVE_LDREXBH\t     TARGET_HAVE_LDREXBH_P (target_flags)\n \n /* Nonzero if this chip supports ldrexd and strexd.  */\n-#define TARGET_HAVE_LDREXD\t(((arm_arch6k && TARGET_ARM) || arm_arch7) \\\n-\t\t\t\t && arm_arch_notm)\n+#define TARGET_HAVE_LDREXD_P(flags) (((arm_arch6k && TARGET_ARM_P (flags)) \\\n+\t\t\t\t      || arm_arch7) && arm_arch_notm)\n+#define TARGET_HAVE_LDREXD\t    TARGET_HAVE_LDREXD_P (target_flags)\n+\t\t\t\t\n \n /* Nonzero if this chip supports load-acquire and store-release.  */\n #define TARGET_HAVE_LDACQ\t(TARGET_ARM_ARCH >= 8)\n \n /* Nonzero if integer division instructions supported.  */\n-#define TARGET_IDIV\t\t((TARGET_ARM && arm_arch_arm_hwdiv) \\\n-\t\t\t\t || (TARGET_THUMB2 && arm_arch_thumb_hwdiv))\n+#define TARGET_IDIV_P(flags)\t((TARGET_ARM_P (flags) && arm_arch_arm_hwdiv) \\\n+\t\t\t\t || (TARGET_THUMB2_P (flags)                  \\\n+\t\t\t\t     && arm_arch_thumb_hwdiv))\n+#define TARGET_IDIV             TARGET_IDIV_P (target_flags)\t\t\n+\n \n /* Nonzero if disallow volatile memory access in IT block.  */\n #define TARGET_NO_VOLATILE_CE\t\t(arm_arch_no_volatile_ce)\n@@ -2189,6 +2202,11 @@ extern int making_const_table;\n    | (TARGET_HAVE_LDREXBH ? 3 : 0)\t\t\t\t\\\n    | (TARGET_HAVE_LDREXD ? 8 : 0))\n \n+#define TARGET_ARM_FEATURE_LDREX_P(flags)\t\t\t\\\n+  ((TARGET_HAVE_LDREX_P (flags) ? 4 : 0)\t\t\t\\\n+   | (TARGET_HAVE_LDREXBH_P (flags) ? 3 : 0)\t\t\t\\\n+   | (TARGET_HAVE_LDREXD_P (flags) ? 8 : 0))\n+\n /* Set as a bit mask indicating the available widths of hardware floating\n    point types.  Where bit 1 indicates 16-bit support, bit 2 indicates\n    32-bit support, bit 3 indicates 64-bit support.  */"}]}