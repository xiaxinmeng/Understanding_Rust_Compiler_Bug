{"sha": "0f1462579e348656b9a5549721f926d6f5894e1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYxNDYyNTc5ZTM0ODY1NmI5YTU1NDk3MjFmOTI2ZDZmNTg5NGUxYw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-01-09T21:05:10Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-01-09T21:05:10Z"}, "message": "re PR libstdc++/83709 (Inserting duplicates into an unordered associative containers causes the container to invalidate iterators)\n\n2018-01-09  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/83709\n\t* include/bits/hashtable_policy.h\n\t(__distance_fwd(_Iterator, _Iterator, input_iterator_tag)): Return 1 if\n\t__first != __last.\n\t(_Insert_base::_M_insert_range(_Ite, _Ite, _NodeGetter, true_type)): New.\n\t(_Insert_base::_M_insert_range(_Ite, _Ite, _NodeGetter, false_type)):\n\tAdd false_type parameter.\n\t(_Insert_base::insert): Adapt.\n\t* include/bits/hashtable.h (_Hashtable::operator=(initializzr_list<>)):\n\tAdapt.\n\t(_Hashtable::_M_insert(_Arg&&, const _NodeGen&, true_type, size_t)):\n\t Add __n_elt parameter, defaulted to 1.\n\t(_Hashtable::_M_insert_unique_node): Likewise. Use it to call rehash\n\tpolicy _M_need_rehash.\n\t(_Hashtable::_M_merge_unique): Pass target number of elements to add to\n\tproduce only 1 rehash if necessary.\n\t* testsuite/23_containers/unordered_map/insert/83709.cc: New.\n\t* testsuite/23_containers/unordered_set/insert/83709.cc: New.\n\nFrom-SVN: r256396", "tree": {"sha": "f299bb47be49fefdcc1c4f42f77dac57c278a88f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f299bb47be49fefdcc1c4f42f77dac57c278a88f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1462579e348656b9a5549721f926d6f5894e1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1462579e348656b9a5549721f926d6f5894e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1462579e348656b9a5549721f926d6f5894e1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1462579e348656b9a5549721f926d6f5894e1c/comments", "author": null, "committer": null, "parents": [{"sha": "19d22f7c90d87eb9a3c5715cfa59407e2baeabbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d22f7c90d87eb9a3c5715cfa59407e2baeabbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d22f7c90d87eb9a3c5715cfa59407e2baeabbc"}], "stats": {"total": 185, "additions": 164, "deletions": 21}, "files": [{"sha": "07dbb5faf46d0d9e7191afb7a2c1e767046597a4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0f1462579e348656b9a5549721f926d6f5894e1c", "patch": "@@ -1,3 +1,24 @@\n+2018-01-09  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/83709\n+\t* include/bits/hashtable_policy.h\n+\t(__distance_fwd(_Iterator, _Iterator, input_iterator_tag)): Return 1 if\n+\t__first != __last.\n+\t(_Insert_base::_M_insert_range(_Ite, _Ite, _NodeGetter, true_type)): New.\n+\t(_Insert_base::_M_insert_range(_Ite, _Ite, _NodeGetter, false_type)):\n+\tAdd false_type parameter.\n+\t(_Insert_base::insert): Adapt.\n+\t* include/bits/hashtable.h (_Hashtable::operator=(initializzr_list<>)):\n+\tAdapt.\n+\t(_Hashtable::_M_insert(_Arg&&, const _NodeGen&, true_type, size_t)):\n+\t Add __n_elt parameter, defaulted to 1.\n+\t(_Hashtable::_M_insert_unique_node): Likewise. Use it to call rehash\n+\tpolicy _M_need_rehash.\n+\t(_Hashtable::_M_merge_unique): Pass target number of elements to add to\n+\tproduce only 1 rehash if necessary.\n+\t* testsuite/23_containers/unordered_map/insert/83709.cc: New.\n+\t* testsuite/23_containers/unordered_set/insert/83709.cc: New.\n+\n 2018-01-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/59253 (partial)"}, {"sha": "af16e2c03cb6fbb7d4542b3f8767856c34cd2056", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=0f1462579e348656b9a5549721f926d6f5894e1c", "patch": "@@ -487,7 +487,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__reuse_or_alloc_node_type __roan(_M_begin(), *this);\n \t_M_before_begin._M_nxt = nullptr;\n \tclear();\n-\tthis->_M_insert_range(__l.begin(), __l.end(), __roan);\n+\tthis->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());\n \treturn *this;\n       }\n \n@@ -675,7 +675,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // deallocate it on exception.\n       iterator\n       _M_insert_unique_node(size_type __bkt, __hash_code __code,\n-\t\t\t    __node_type* __n);\n+\t\t\t    __node_type* __n, size_type __n_elt = 1);\n \n       // Insert node with hash code __code. Take ownership of the node,\n       // deallocate it on exception.\n@@ -704,12 +704,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n-\t_M_insert(_Arg&&, const _NodeGenerator&, std::true_type);\n+\t_M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);\n \n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n-\t\t  std::false_type __uk)\n+\t\t  false_type __uk)\n \t{\n \t  return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,\n \t\t\t   __uk);\n@@ -719,7 +719,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(const_iterator, _Arg&& __arg,\n-\t\t  const _NodeGenerator& __node_gen, std::true_type __uk)\n+\t\t  const _NodeGenerator& __node_gen, true_type __uk)\n \t{\n \t  return\n \t    _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;\n@@ -729,7 +729,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n \t_M_insert(const_iterator, _Arg&&,\n-\t\t  const _NodeGenerator&, std::false_type);\n+\t\t  const _NodeGenerator&, false_type);\n \n       size_type\n       _M_erase(std::true_type, const key_type&);\n@@ -881,6 +881,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      node_type>, \"Node types are compatible\");\n \t  __glibcxx_assert(get_allocator() == __src.get_allocator());\n \n+\t  auto __n_elt = __src.size();\n \t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n \t    {\n \t      auto __pos = __i++;\n@@ -890,9 +891,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      if (_M_find_node(__bkt, __k, __code) == nullptr)\n \t\t{\n \t\t  auto __nh = __src.extract(__pos);\n-\t\t  _M_insert_unique_node(__bkt, __code, __nh._M_ptr);\n+\t\t  _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);\n \t\t  __nh._M_ptr = nullptr;\n+\t\t  __n_elt = 1;\n \t\t}\n+\t      else if (__n_elt != 1)\n+\t\t--__n_elt;\n \t    }\n \t}\n \n@@ -1713,12 +1717,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n     _M_insert_unique_node(size_type __bkt, __hash_code __code,\n-\t\t\t  __node_type* __node)\n+\t\t\t  __node_type* __node, size_type __n_elt)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n-\t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);\n+\t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,\n+\t\t\t\t\t  __n_elt);\n \n       __try\n \t{\n@@ -1816,7 +1821,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)\n+      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,\n+\t\tsize_type __n_elt)\n       -> pair<iterator, bool>\n       {\n \tconst key_type& __k = this->_M_extract()(__v);\n@@ -1828,7 +1834,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return std::make_pair(iterator(__n), false);\n \n \t__n = __node_gen(std::forward<_Arg>(__v));\n-\treturn std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);\n+\treturn { _M_insert_unique_node(__bkt, __code, __n, __n_elt), true };\n       }\n \n   // Insert v unconditionally.\n@@ -1841,7 +1847,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n       _M_insert(const_iterator __hint, _Arg&& __v,\n-\t\tconst _NodeGenerator& __node_gen, std::false_type)\n+\t\tconst _NodeGenerator& __node_gen, false_type)\n       -> iterator\n       {\n \t// First compute the hash code so that we don't do anything if it"}, {"sha": "3ff6b14a90f9ac4a6cc0a538450471accb5e9c73", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=0f1462579e348656b9a5549721f926d6f5894e1c", "patch": "@@ -58,12 +58,12 @@ namespace __detail\n     struct _Hashtable_base;\n \n   // Helper function: return distance(first, last) for forward\n-  // iterators, or 0 for input iterators.\n+  // iterators, or 0/1 for input iterators.\n   template<class _Iterator>\n     inline typename std::iterator_traits<_Iterator>::difference_type\n     __distance_fw(_Iterator __first, _Iterator __last,\n \t\t  std::input_iterator_tag)\n-    { return 0; }\n+    { return __first != __last ? 1 : 0; }\n \n   template<class _Iterator>\n     inline typename std::iterator_traits<_Iterator>::difference_type\n@@ -74,10 +74,8 @@ namespace __detail\n   template<class _Iterator>\n     inline typename std::iterator_traits<_Iterator>::difference_type\n     __distance_fw(_Iterator __first, _Iterator __last)\n-    {\n-      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;\n-      return __distance_fw(__first, __last, _Tag());\n-    }\n+    { return __distance_fw(__first, __last,\n+\t\t\t   std::__iterator_category(__first)); }\n \n   struct _Identity\n   {\n@@ -820,7 +818,12 @@ namespace __detail\n       template<typename _InputIterator, typename _NodeGetter>\n \tvoid\n \t_M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t\tconst _NodeGetter&);\n+\t\t\tconst _NodeGetter&, true_type);\n+\n+      template<typename _InputIterator, typename _NodeGetter>\n+\tvoid\n+\t_M_insert_range(_InputIterator __first, _InputIterator __last,\n+\t\t\tconst _NodeGetter&, false_type);\n \n     public:\n       __ireturn_type\n@@ -849,7 +852,7 @@ namespace __detail\n \t{\n \t  __hashtable& __h = _M_conjure_hashtable();\n \t  __node_gen_type __node_gen(__h);\n-\t  return _M_insert_range(__first, __last, __node_gen);\n+\t  return _M_insert_range(__first, __last, __node_gen, __unique_keys());\n \t}\n     };\n \n@@ -862,13 +865,41 @@ namespace __detail\n       _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n \t\t    _RehashPolicy, _Traits>::\n       _M_insert_range(_InputIterator __first, _InputIterator __last,\n-\t\t      const _NodeGetter& __node_gen)\n+\t\t      const _NodeGetter& __node_gen, true_type)\n+      {\n+\tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tif (__n_elt == 0)\n+\t  return;\n+\n+\t__hashtable& __h = _M_conjure_hashtable();\n+\tfor (; __first != __last; ++__first)\n+\t  {\n+\t    if (__h._M_insert(*__first, __node_gen, __unique_keys(),\n+\t\t\t      __n_elt).second)\n+\t      __n_elt = 1;\n+\t    else if (__n_elt != 1)\n+\t      --__n_elt;\n+\t  }\n+      }\n+\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    template<typename _InputIterator, typename _NodeGetter>\n+      void\n+      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+\t\t    _RehashPolicy, _Traits>::\n+      _M_insert_range(_InputIterator __first, _InputIterator __last,\n+\t\t      const _NodeGetter& __node_gen, false_type)\n       {\n \tusing __rehash_type = typename __hashtable::__rehash_type;\n \tusing __rehash_state = typename __hashtable::__rehash_state;\n \tusing pair_type = std::pair<bool, std::size_t>;\n \n \tsize_type __n_elt = __detail::__distance_fw(__first, __last);\n+\tif (__n_elt == 0)\n+\t  return;\n \n \t__hashtable& __h = _M_conjure_hashtable();\n \t__rehash_type& __rehash = __h._M_rehash_policy;"}, {"sha": "16e4f033a48d6fe4c7b71fe1a5c2a375d4616711", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/83709.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F83709.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F83709.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2F83709.cc?ref=0f1462579e348656b9a5549721f926d6f5894e1c", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run { target c++11 } }\n+//\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::unordered_map<std::string, std::string> m\n+  { {\"E\", \"E\" }, { \"T\", \"T\" } };\n+\n+  VERIFY( m.size() == 2 );\n+\n+  auto bcount = m.bucket_count();\n+\n+  m.insert({ {\"E\", \"E\" }, { \"T\", \"T\" } });\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m.bucket_count() == bcount );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0a5a520122fe95aef1ab9580f3c63734090fda9a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/83709.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F83709.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1462579e348656b9a5549721f926d6f5894e1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F83709.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2F83709.cc?ref=0f1462579e348656b9a5549721f926d6f5894e1c", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run { target c++11 } }\n+//\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  std::unordered_set<std::string> s { \"E\", \"T\" };\n+\n+  VERIFY( s.size() == 2 );\n+\n+  auto bcount = s.bucket_count();\n+\n+  s.insert({\"E\", \"T\" });\n+\n+  VERIFY( s.size() == 2 );\n+  VERIFY( s.bucket_count() == bcount );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}