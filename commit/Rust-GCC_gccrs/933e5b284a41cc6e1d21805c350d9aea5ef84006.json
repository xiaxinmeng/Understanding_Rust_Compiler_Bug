{"sha": "933e5b284a41cc6e1d21805c350d9aea5ef84006", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMzZTViMjg0YTQxY2M2ZTFkMjE4MDVjMzUwZDlhZWE1ZWY4NDAwNg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-02-22T00:58:36Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-02-22T00:58:36Z"}, "message": "[multiple changes]\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t* gnu/java/locale/LocaleInformation_en.java: Extend\n\tlocalPatternChars to \"GyMdkHmsSEDFwWahKzYeugAZ\".\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t* java/text/SimpleDateFormat.java\n\t(SimpleDateFormat(String, DateFormatSymbols)): Throw\n\tNullPointerException when formatData is null.\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t* java/util/SimpleTimeZone.java (getOffset): Calculate beforeEnd by\n\ttaking dstSavings into account.\n\n2005-02-21  Sven de Marothy <sven@physto.se>\n\n\t* java/text/SimpleDateFormat.java,\n\t(parse): Set correct DST_OFFSET to the correct value.\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t* java/util/SimpleTimeZone.java (checkRule): Throw\n\tIllegalArgumentException when month out of range.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/GregorianCalendar.java,\n\t(add): Don't set fields directly anymore. Use set()\n\n2005-02-21  Mark Wielaard  <mark@klomp.org>\n\n\t* java/text/SimpleDateFormat.java (CompiledField.toString):\n\tUse StringBuffer, not StringBuilder.\n\t(toString): Likewise.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/Calendar.java\n\t(clear): Dates should clear to local time.\n\t* java/util/GregorianCalendar.java\n\t(computeTime): Fix priority problem with DAY_OF_WEEK,\n\tHandle non-sunday-startig weeks and minimumDaysInFirstWeek.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/Calendar.java\n\t(Calendar): Constructor should clear fields.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/text/SimpleDateFormat.java\n\t(parse): Tweak handling of 2-year dates\n\t* java/util/Calendar.java\n\t(clear): Clear fields to correct value.\n\t* java/util/GregorianCalendar.java\n\t(computeTime): Correct handling of time zones.\n\tCorrect field minimum values.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/Calendar.java\n\t(set) Invalidate all fields on first call to set().\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/GregorianCalendar.java\n\t(computeTime): Fixed handling of time zones.\n\n2005-02-21  Sven de Marothy  <sven@physto.se>\n\n\t* java/util/Calendar.java\n\t(clear): Set values to Epoch instead of zero.\n\t(set): Set isSet to the relevant field pattern instead of just\n\tthe field.\n\t* java/util/GregorianCalendar.java\n\t(getBundle): Removed.\n\t(getDayOfYear): Removed.\n\t(getFirstDayOfMonth): New private method.\n\t(nonLeniencyCheck): New private method.\n\t(computeTime): Correct handling of insufficient data.\n\n2005-02-21  Sven de Marothy <sven@physto.se>\n\n\t* java/util/Calendar.java: Invalidate ERA field on setting\n\tthe YEAR.\n\t* java/util/SimpleTimeZone.java:\n\t(getDaysInMonth): Reimplemented.\n\t* java/util/GregorianCalendar.java:\n\t(getLinearTime): Removed.\n\t(isLeapYear(int,boolean)): Removed.\n\t(before(), after()): Removed.\n\t(computeTime): Reimplemented.\n\n2005-02-21  Sven de Marothy <sven@physto.se>\n\n\t* java/util/Calendar.java: Reformatted.\n\t* java/util/GregorianCalendar.java: Reformatted.\n\t* java/util/SimpleTimeZone.java: Reformatted.\n\n2005-02-21  Sven de Marothy <sven@physto.se>\n\n        * java/util/GregorianCalendar.java\n        (GregorianCalendar): Update fields in the constructor\n\n2005-02-21  Noa Resare  <noa@resare.com>\n\n        * java/util/Calendar.java (explicitDSTOffset): New instance field.\n        (set(int,int)): Set and use new field.\n        (set(int,int,int)): Check new field.\n\n2005-02-21  Noa Resare  <address@hidden>\n\n\t* java/util/Calendar.java(set):\n\tFix for DST related regression.\n\n2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/util/Calendar.java\n\t(setTimeInMillis): Added call to clear, removed computeFields call.\n\t* java/util/Date.java\n\t(Date(int,int,int,int,int,int)): Removed workaround for\n\tGregorianCalendar bug.\n\t* java/util/GregorianCalendar.java\n\t(GregorianCalendar): Chained all constructors to a (new)\n\tcommon constructor.\n\t(computeTime): Fixed support for lenient month treatment.\n\t(getLinearDay): Return long instead of int.\n\t(calculateDay): Added fields argument and changed day argument\n\tto long.\n\n2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n\n\t* java/text/SimpleDateFormat.java\n\tLots of documentation updates.\n\t(readObject(java.io.ObjectInputStream)): Wraps\n\tIllegalArgumentException as specified.\n\t(compileFormat(String)): Uses standardChars\n\trather than the local pattern characters.\n\tThrows IllegalArgumentException rather than\n\tstoring a -1 field.\n\t(toString()): Extended to include all variables\n\tin a better format.\n\t(translateLocalizedPattern(String, String, String)):\n\tRenamed to better define the use of this method.\n\n2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n\n\t* java/text/DateFormat.java:\n\tDocumented pattern character offset constants and\n\tadded new ones.\n\t(Field): Added new static fields for new pattern chars.\n\t* java/text/SimpleDateFormat.java:\n\t(CompiledField): Changed name of FieldSizePair class\n\tto CompiledField after adding the character as an\n\tattribute.  Changed fields to private and added\n\taccessors to give encapsulation.\n\t(CompiledField.CompiledField(int,int,char)): Extended\n\twith character field.\n\t(CompiledField.getField()): New accessor method.\n\t(CompiledField.getSize()): New acceessor method.\n\t(CompiledField.getCharacter()): New accessor method.\n\t(CompiledField.toString()): Added primarily for debugging.\n\t(standardChars): Now uses extended 24 character sequence.\n\t(compileFormat(String)): Changed to use CompiledField.\n\t(formatWithAttribute(java.util.Date, gnu.java.text.FormatBuffer,\n\tjava.text.FieldPosition)): Changed to use CompiledField.\n\tNew handler for RFC 822 timezones added.\n\n2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n\n\t* java/text/SimpleDateFormat.java:\n\t(parse(String, java.text.ParsePosition)):\n\tChanged 'E' and 'M' cases to use both\n\tshort and long names.  Extended 'z'\n\tcase to also handle 'Z', and deal\n\twith simple GMT offsets such as +0100.\n\t(computeOffset(String)): New private method,\n\twhich converts a GMT offset specification,\n\tsuch as GMT-0500 to a numeric offset in\n\tmilliseconds.\n\t* java/util/TimeZone.java:\n\t(timezones()): Added \"CEST\", the daylight\n\tsavings time version of \"CET\", or Central\n\tEuropean Time.\n\n2005-02-21  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n\n\t* java/text/SimpleDateFormat.java:\n\t(parse): Set the DST offset to 0 when parsing\n\tGMT offset timezones.\n\n2005-02-21  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n\n\t* java/text/SimpleDateFormat.java:\n\t(parse): Use offset to set ZONE_OFFSET\n\trather than the DST_OFFSET, so that\n\tGMT offset timezones change the right\n\tone.\n\n2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n\n\t* java/text/SimpleDateFormat.java:\n\t(getDateFormatSymbols()): return a copy\n\t(setDateFormatSymbols(java.text.DateFormatSymbols)):\n\tthrow exception on null input\n\t(clone()): implemented to clone\n\tinternal fields\n\n2005-02-21  Sven de Marothy <sven@physto.se>\n\n\t* java/text/SimpleDateFormat.java\n\t(parse): comparison should be case-insensitive, ignore null\n\tstrings.\n\nFrom-SVN: r95368", "tree": {"sha": "1ef9e4a70e8658f5a1afafb0f811039fb753f321", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ef9e4a70e8658f5a1afafb0f811039fb753f321"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/933e5b284a41cc6e1d21805c350d9aea5ef84006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933e5b284a41cc6e1d21805c350d9aea5ef84006", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933e5b284a41cc6e1d21805c350d9aea5ef84006", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933e5b284a41cc6e1d21805c350d9aea5ef84006/comments", "author": null, "committer": null, "parents": [{"sha": "665794a6c42fc7a9eb31cd12522db01ff4c652e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/665794a6c42fc7a9eb31cd12522db01ff4c652e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/665794a6c42fc7a9eb31cd12522db01ff4c652e1"}], "stats": {"total": 2742, "additions": 1839, "deletions": 903}, "files": [{"sha": "99183fff96867675651347912b9be9060f9ffed9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -1,3 +1,219 @@\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* gnu/java/locale/LocaleInformation_en.java: Extend\n+\tlocalPatternChars to \"GyMdkHmsSEDFwWahKzYeugAZ\".\n+\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/text/SimpleDateFormat.java\n+\t(SimpleDateFormat(String, DateFormatSymbols)): Throw\n+\tNullPointerException when formatData is null.\n+\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/SimpleTimeZone.java (getOffset): Calculate beforeEnd by\n+\ttaking dstSavings into account.\n+\n+2005-02-21  Sven de Marothy <sven@physto.se>\n+\n+\t* java/text/SimpleDateFormat.java,\n+\t(parse): Set correct DST_OFFSET to the correct value.\n+\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/SimpleTimeZone.java (checkRule): Throw\n+\tIllegalArgumentException when month out of range.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/GregorianCalendar.java,\n+\t(add): Don't set fields directly anymore. Use set()\n+\n+2005-02-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/text/SimpleDateFormat.java (CompiledField.toString):\n+\tUse StringBuffer, not StringBuilder.\n+\t(toString): Likewise.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/Calendar.java \n+\t(clear): Dates should clear to local time.\n+\t* java/util/GregorianCalendar.java      \n+\t(computeTime): Fix priority problem with DAY_OF_WEEK,\n+\tHandle non-sunday-startig weeks and minimumDaysInFirstWeek.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/Calendar.java \n+\t(Calendar): Constructor should clear fields.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/text/SimpleDateFormat.java\n+\t(parse): Tweak handling of 2-year dates\n+\t* java/util/Calendar.java\n+\t(clear): Clear fields to correct value.\n+\t* java/util/GregorianCalendar.java\n+\t(computeTime): Correct handling of time zones.\n+\tCorrect field minimum values.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/Calendar.java\n+\t(set) Invalidate all fields on first call to set().\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/GregorianCalendar.java\n+\t(computeTime): Fixed handling of time zones.\n+\n+2005-02-21  Sven de Marothy  <sven@physto.se>\n+\n+\t* java/util/Calendar.java\n+\t(clear): Set values to Epoch instead of zero.\n+\t(set): Set isSet to the relevant field pattern instead of just\n+\tthe field.\n+\t* java/util/GregorianCalendar.java\n+\t(getBundle): Removed.\n+\t(getDayOfYear): Removed.\n+\t(getFirstDayOfMonth): New private method.\n+\t(nonLeniencyCheck): New private method.\n+\t(computeTime): Correct handling of insufficient data.\n+\n+2005-02-21  Sven de Marothy <sven@physto.se>\n+\n+\t* java/util/Calendar.java: Invalidate ERA field on setting\n+\tthe YEAR.\n+\t* java/util/SimpleTimeZone.java:\n+\t(getDaysInMonth): Reimplemented.\n+\t* java/util/GregorianCalendar.java:\n+\t(getLinearTime): Removed.\n+\t(isLeapYear(int,boolean)): Removed.\n+\t(before(), after()): Removed.\n+\t(computeTime): Reimplemented.\n+\n+2005-02-21  Sven de Marothy <sven@physto.se>\n+\n+\t* java/util/Calendar.java: Reformatted.\n+\t* java/util/GregorianCalendar.java: Reformatted.\n+\t* java/util/SimpleTimeZone.java: Reformatted.\n+\n+2005-02-21  Sven de Marothy <sven@physto.se>\n+\n+        * java/util/GregorianCalendar.java\n+        (GregorianCalendar): Update fields in the constructor\n+\n+2005-02-21  Noa Resare  <noa@resare.com>\n+\n+        * java/util/Calendar.java (explicitDSTOffset): New instance field.\n+        (set(int,int)): Set and use new field.\n+        (set(int,int,int)): Check new field.\n+\n+2005-02-21  Noa Resare  <address@hidden>\n+\n+\t* java/util/Calendar.java(set):\n+\tFix for DST related regression.\n+\n+2005-02-21  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/util/Calendar.java\n+\t(setTimeInMillis): Added call to clear, removed computeFields call.\n+\t* java/util/Date.java\n+\t(Date(int,int,int,int,int,int)): Removed workaround for\n+\tGregorianCalendar bug.\n+\t* java/util/GregorianCalendar.java\n+\t(GregorianCalendar): Chained all constructors to a (new)\n+\tcommon constructor.\n+\t(computeTime): Fixed support for lenient month treatment.\n+\t(getLinearDay): Return long instead of int.\n+\t(calculateDay): Added fields argument and changed day argument\n+\tto long.\n+\n+2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n+\n+\t* java/text/SimpleDateFormat.java\n+\tLots of documentation updates.\n+\t(readObject(java.io.ObjectInputStream)): Wraps\n+\tIllegalArgumentException as specified.\n+\t(compileFormat(String)): Uses standardChars\n+\trather than the local pattern characters.\n+\tThrows IllegalArgumentException rather than\n+\tstoring a -1 field.\n+\t(toString()): Extended to include all variables\n+\tin a better format.\n+\t(translateLocalizedPattern(String, String, String)):\n+\tRenamed to better define the use of this method.\n+\n+2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n+\n+\t* java/text/DateFormat.java:\n+\tDocumented pattern character offset constants and\n+\tadded new ones.\n+\t(Field): Added new static fields for new pattern chars.\n+\t* java/text/SimpleDateFormat.java:\n+\t(CompiledField): Changed name of FieldSizePair class\n+\tto CompiledField after adding the character as an\n+\tattribute.  Changed fields to private and added\n+\taccessors to give encapsulation.\n+\t(CompiledField.CompiledField(int,int,char)): Extended\n+\twith character field.\n+\t(CompiledField.getField()): New accessor method.\n+\t(CompiledField.getSize()): New acceessor method.\n+\t(CompiledField.getCharacter()): New accessor method.\n+\t(CompiledField.toString()): Added primarily for debugging.\n+\t(standardChars): Now uses extended 24 character sequence.\n+\t(compileFormat(String)): Changed to use CompiledField.\n+\t(formatWithAttribute(java.util.Date, gnu.java.text.FormatBuffer,\n+\tjava.text.FieldPosition)): Changed to use CompiledField.\n+\tNew handler for RFC 822 timezones added.\n+\n+2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n+\n+\t* java/text/SimpleDateFormat.java:\n+\t(parse(String, java.text.ParsePosition)):\n+\tChanged 'E' and 'M' cases to use both\n+\tshort and long names.  Extended 'z'\n+\tcase to also handle 'Z', and deal\n+\twith simple GMT offsets such as +0100.\n+\t(computeOffset(String)): New private method,\n+\twhich converts a GMT offset specification,\n+\tsuch as GMT-0500 to a numeric offset in\n+\tmilliseconds.\n+\t* java/util/TimeZone.java:\n+\t(timezones()): Added \"CEST\", the daylight\n+\tsavings time version of \"CET\", or Central\n+\tEuropean Time.\n+\n+2005-02-21  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n+\n+\t* java/text/SimpleDateFormat.java:\n+\t(parse): Set the DST offset to 0 when parsing\n+\tGMT offset timezones.\n+\n+2005-02-21  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n+\n+\t* java/text/SimpleDateFormat.java:\n+\t(parse): Use offset to set ZONE_OFFSET\n+\trather than the DST_OFFSET, so that\n+\tGMT offset timezones change the right\n+\tone.\n+\n+2005-02-21  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n+\n+\t* java/text/SimpleDateFormat.java:\n+\t(getDateFormatSymbols()): return a copy\n+\t(setDateFormatSymbols(java.text.DateFormatSymbols)):\n+\tthrow exception on null input\n+\t(clone()): implemented to clone\n+\tinternal fields\n+\n+2005-02-21  Sven de Marothy <sven@physto.se>\n+\n+\t* java/text/SimpleDateFormat.java\n+\t(parse): comparison should be case-insensitive, ignore null\n+\tstrings.\n+\n 2005-02-21  Robert Schuster  <theBohemian@gmx.net>\n \n \t* gnu/java/beans/IntrospectionIncubator.java"}, {"sha": "df258095c1be4d535abcaea78d215f98ad119ff9", "filename": "libjava/gnu/java/locale/LocaleInformation_en.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flocale%2FLocaleInformation_en.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -159,7 +159,7 @@ public class LocaleInformation_en extends ListResourceBundle\n     { \"shortWeekdays\", shortWeekdays },\n     { \"ampms\", ampms },\n     { \"eras\", eras },\n-    { \"localPatternChars\", \"GyMdkHmsSEDFwWahKz\" },\n+    { \"localPatternChars\", \"GyMdkHmsSEDFwWahKzYeugAZ\" },\n     { \"zoneStrings\", zoneStrings },\n \n     { \"shortDateFormat\", \"M/d/yy\" },         // Java's Y2K bug."}, {"sha": "f19817ee2da6de919c5dad4884467135a4cfb0fb", "filename": "libjava/java/text/DateFormat.java", "status": "modified", "additions": 212, "deletions": 6, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Ftext%2FDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Ftext%2FDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FDateFormat.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -70,29 +70,221 @@ public abstract class DateFormat extends Format implements Cloneable\n \n   /* These constants need to have these exact values.  They\n    * correspond to index positions within the localPatternChars\n-   * string for a given locale.  For example, the US locale uses\n-   * the string \"GyMdkHmsSEDFwWahKz\", where 'G' is the character\n-   * for era, 'y' for year, and so on down to 'z' for time zone.\n+   * string for a given locale.  Each locale may specify its\n+   * own character for a particular field, but the position\n+   * of these characters must correspond to an appropriate field\n+   * number (as listed below), in order for their meaning to\n+   * be determined.  For example, the US locale uses\n+   * the string \"GyMdkHmsSEDFwWahKzYeugAZ\", where 'G' is the character\n+   * for era, 'y' for year, and so on down to 'Z' for time zone.\n    */\n+  /**\n+   * Represents the position of the era\n+   * pattern character in the array of\n+   * localized pattern characters. \n+   * For example, 'AD' is an era used\n+   * in the Gregorian calendar system.\n+   * In the U.S. locale, this is 'G'.\n+   */  \n   public static final int ERA_FIELD = 0;\n+  /**\n+   * Represents the position of the year\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'y'.\n+   */\n   public static final int YEAR_FIELD = 1;\n+  /**\n+   * Represents the position of the month\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'M'.\n+   */\n   public static final int MONTH_FIELD = 2;\n+  /**\n+   * Represents the position of the date\n+   * or day of the month pattern character\n+   * in the array of localized pattern\n+   * characters.  In the U.S. locale,\n+   * this is 'd'.\n+   */\n   public static final int DATE_FIELD = 3;\n+  /**\n+   * Represents the position of the 24\n+   * hour pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'k'.\n+   * This field numbers hours from 1 to 24.\n+   */\n   public static final int HOUR_OF_DAY1_FIELD = 4;\n+  /**\n+   * Represents the position of the 24\n+   * hour pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'H'.\n+   * This field numbers hours from 0 to 23.\n+   */\n   public static final int HOUR_OF_DAY0_FIELD = 5;\n+  /**\n+   * Represents the position of the minute\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'm'.\n+   */\n   public static final int MINUTE_FIELD = 6;\n+  /**\n+   * Represents the position of the second\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 's'.\n+   */\n   public static final int SECOND_FIELD = 7;\n+  /**\n+   * Represents the position of the millisecond\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'S'.\n+   */\n   public static final int MILLISECOND_FIELD = 8;\n+  /**\n+   * Represents the position of the day of the\n+   * week pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'E'.\n+   */\n   public static final int DAY_OF_WEEK_FIELD = 9;\n+  /**\n+   * Represents the position of the day of the\n+   * year pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'D'.\n+   */\n   public static final int DAY_OF_YEAR_FIELD = 10;\n+  /**\n+   * Represents the position of the day of the\n+   * week in the month pattern character in the\n+   * array of localized pattern characters.\n+   * In the U.S. locale, this is 'F'.\n+   */\n   public static final int DAY_OF_WEEK_IN_MONTH_FIELD = 11;\n+  /**\n+   * Represents the position of the week of the\n+   * year pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'w'.\n+   */\n   public static final int WEEK_OF_YEAR_FIELD = 12;\n+  /**\n+   * Represents the position of the week of the\n+   * month pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'W'.\n+   */\n   public static final int WEEK_OF_MONTH_FIELD = 13;\n+  /**\n+   * Represents the position of the am/pm\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'a'.\n+   */\n   public static final int AM_PM_FIELD = 14;\n+  /**\n+   * Represents the position of the 12 \n+   * hour pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'h'.\n+   * This field numbers hours from 1 to 12.\n+   */\n   public static final int HOUR1_FIELD = 15;\n+  /**\n+   * Represents the position of the 12 \n+   * hour pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'K'.\n+   * This field numbers hours from 0 to 11.\n+   */\n   public static final int HOUR0_FIELD = 16;\n+  /**\n+   * Represents the position of the generic\n+   * timezone pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'z'.\n+   */\n   public static final int TIMEZONE_FIELD = 17;\n-\n+  /**\n+   * Represents the position of the ISO year\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'Y'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  This value may\n+   * differ from the normal year value.\n+   */\n+  public static final int ISO_YEAR_FIELD = 18;\n+  /**\n+   * Represents the position of the localized\n+   * day of the week pattern character in the\n+   * array of localized pattern characters.\n+   * In the U.S. locale, this is 'e'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  This value only\n+   * differs from the day of the week with\n+   * numeric formatting, in which case the\n+   * locale's first day of the week is used.\n+   */\n+  public static final int LOCALIZED_DAY_OF_WEEK_FIELD = 19;\n+  /**\n+   * Represents the position of the extended year\n+   * pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'u'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  This value modifies\n+   * the year value, so as to incorporate the era.\n+   * For example, in the Gregorian calendar system,\n+   * the extended year is negative instead of being\n+   * marked as BC.\n+   */\n+  public static final int EXTENDED_YEAR_FIELD = 20;\n+  /**\n+   * Represents the position of the modified Julian\n+   * day pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'g'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  This value differs\n+   * from the standard Julian day in that days\n+   * are marked from midnight onwards rather than\n+   * noon, and the local time zone affects the value.\n+   * In simple terms, it can be thought of as all\n+   * the date fields represented as a single number.\n+   */\n+  public static final int MODIFIED_JULIAN_DAY_FIELD = 21;\n+  /**\n+   * Represents the position of the millisecond\n+   * in the day pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'A'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  This value represents\n+   * all the time fields (excluding the time zone)\n+   * numerically, giving the number of milliseconds\n+   * into the day (e.g. 10 in the morning would\n+   * be 10 * 60 * 60 * 1000).  Any daylight savings\n+   * offset also affects this value.\n+   */\n+  public static final int MILLISECOND_IN_DAY_FIELD = 22;\n+  /**\n+   * Represents the position of the RFC822\n+   * timezone pattern character in the array of\n+   * localized pattern characters.\n+   * In the U.S. locale, this is 'Z'.\n+   * This is a GNU extension in accordance with\n+   * the CLDR data used.  The value is the offset\n+   * of the current time from GMT e.g. -0500 would\n+   * be five hours prior to GMT.\n+   */\n+  public static final int RFC822_TIMEZONE_FIELD = 23;\n \n   public static class Field extends Format.Field\n   {\n@@ -136,14 +328,28 @@ public static class Field extends Format.Field\n \t= new Field(\"hour0\", Calendar.HOUR);\n     public static final DateFormat.Field TIME_ZONE\n \t= new Field(\"timezone\", Calendar.ZONE_OFFSET);\n- \n+    public static final DateFormat.Field ISO_YEAR\n+\t= new Field(\"iso year\", Calendar.YEAR);\n+    public static final DateFormat.Field LOCALIZED_DAY_OF_WEEK\n+\t= new Field(\"localized day of week\", Calendar.DAY_OF_WEEK);\n+    public static final DateFormat.Field EXTENDED_YEAR\n+      = new Field(\"extended year\", Calendar.YEAR);\n+    public static final DateFormat.Field MODIFIED_JULIAN_DAY\n+\t= new Field(\"julian day\", -1);\n+    public static final DateFormat.Field MILLISECOND_IN_DAY\n+\t= new Field(\"millisecond in day\", -1);\n+    public static final DateFormat.Field RFC822_TIME_ZONE\n+\t= new Field(\"rfc822 timezone\", Calendar.ZONE_OFFSET);\n+\n     static final DateFormat.Field[] allFields =\n     {\n       ERA, YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY1,\n       HOUR_OF_DAY0, MINUTE, SECOND, MILLISECOND,\n       DAY_OF_WEEK, DAY_OF_YEAR, DAY_OF_WEEK_IN_MONTH,\n       WEEK_OF_YEAR, WEEK_OF_MONTH, AM_PM, HOUR1, HOUR0,\n-      TIME_ZONE\n+      TIME_ZONE, ISO_YEAR, LOCALIZED_DAY_OF_WEEK,\n+      EXTENDED_YEAR, MODIFIED_JULIAN_DAY, MILLISECOND_IN_DAY,\n+      RFC822_TIME_ZONE\n     };\n \n     // For deserialization"}, {"sha": "d8e15f2aecae983d920427821dababdfb8716910", "filename": "libjava/java/text/SimpleDateFormat.java", "status": "modified", "additions": 624, "deletions": 266, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -1,6 +1,6 @@\n /* SimpleDateFormat.java -- A class for parsing/formating simple \n    date constructs\n-   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -45,6 +45,7 @@\n import gnu.java.text.FormatCharacterIterator;\n import gnu.java.text.StringFormatBuffer;\n \n+import java.io.InvalidObjectException;\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.util.ArrayList;\n@@ -55,41 +56,198 @@\n import java.util.Locale;\n import java.util.SimpleTimeZone;\n import java.util.TimeZone;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n /**\n  * SimpleDateFormat provides convenient methods for parsing and formatting\n  * dates using Gregorian calendars (see java.util.GregorianCalendar). \n  */\n public class SimpleDateFormat extends DateFormat \n {\n-  /** A pair class used by SimpleDateFormat as a compiled representation\n-   *  of a format string.\n+  /** \n+   * This class is used by <code>SimpleDateFormat</code> as a\n+   * compiled representation of a format string.  The field\n+   * ID, size, and character used are stored for each sequence\n+   * of pattern characters.\n    */\n-  private class FieldSizePair \n+  private class CompiledField\n   {\n-    public int field;\n-    public int size;\n+    /**\n+     * The ID of the field within the local pattern characters,\n+     */\n+    private int field;\n+\n+    /**\n+     * The size of the character sequence.\n+     */\n+    private int size;\n+\n+    /**\n+     * The character used.\n+     */\n+    private char character;\n \n-    /** Constructs a pair with the given field and size values */\n-    public FieldSizePair(int f, int s) {\n+    /** \n+     * Constructs a compiled field using the\n+     * the given field ID, size and character\n+     * values.\n+     *\n+     * @param f the field ID.\n+     * @param s the size of the field.\n+     * @param c the character used.\n+     */\n+    public CompiledField(int f, int s, char c) {\n       field = f;\n       size = s;\n+      character = c;\n+    }\n+\n+    /**\n+     * Retrieves the ID of the field relative to\n+     * the local pattern characters.\n+     */\n+    public int getField()\n+    {\n+      return field;\n+    }\n+\n+    /**\n+     * Retrieves the size of the character sequence.\n+     */\n+    public int getSize()\n+    {\n+      return size;\n+    }\n+\n+    /**\n+     * Retrieves the character used in the sequence.\n+     */\n+    public char getCharacter()\n+    {\n+      return character;\n+    }\n+\n+    /**\n+     * Returns a <code>String</code> representation\n+     * of the compiled field, primarily for debugging\n+     * purposes.\n+     *\n+     * @return a <code>String</code> representation.\n+     */\n+    public String toString()\n+    {\n+      StringBuffer builder;\n+\n+      builder = new StringBuffer(getClass().getName());\n+      builder.append(\"[field=\");\n+      builder.append(field);\n+      builder.append(\", size=\");\n+      builder.append(size);\n+      builder.append(\", character=\");\n+      builder.append(character);\n+      builder.append(\"]\");\n+\n+      return builder.toString();\n     }\n   }\n \n+  /**\n+   * A list of <code>CompiledField</code>s,\n+   * representing the compiled version of the pattern.\n+   *\n+   * @see CompiledField\n+   * @serial Ignored.\n+   */\n   private transient ArrayList tokens;\n+\n+  /**\n+   * The localised data used in formatting,\n+   * such as the day and month names in the local\n+   * language, and the localized pattern characters.\n+   *\n+   * @see DateFormatSymbols\n+   * @serial The localisation data.  May not be null.\n+   */\n   private DateFormatSymbols formatData;  // formatData\n+\n+  /**\n+   * The date representing the start of the century\n+   * used for interpreting two digit years.  For\n+   * example, 24/10/2004 would cause two digit\n+   * years to be interpreted as representing\n+   * the years between 2004 and 2104.\n+   *\n+   * @see get2DigitYearStart()\n+   * @see set2DigitYearStart(java.util.Date)\n+   * @see Date\n+   * @serial The start date of the century for parsing two digit years.\n+   *         May not be null.\n+   */\n   private Date defaultCenturyStart;\n+\n+  /**\n+   * The year at which interpretation of two\n+   * digit years starts.\n+   *\n+   * @see get2DigitYearStart()\n+   * @see set2DigitYearStart(java.util.Date)\n+   * @serial Ignored.\n+   */\n   private transient int defaultCentury;\n+\n+  /**\n+   * The non-localized pattern string.  This\n+   * only ever contains the pattern characters\n+   * stored in standardChars.  Localized patterns\n+   * are translated to this form.\n+   *\n+   * @see applyPattern(String)\n+   * @see applyLocalizedPattern(String)\n+   * @see toPattern()\n+   * @see toLocalizedPattern()\n+   * @serial The non-localized pattern string.  May not be null.\n+   */\n   private String pattern;\n+\n+  /**\n+   * The version of serialized data used by this class.\n+   * Version 0 only includes the pattern and formatting\n+   * data.  Version 1 adds the start date for interpreting\n+   * two digit years.\n+   *\n+   * @serial This specifies the version of the data being serialized.\n+   *         Version 0 (or no version) specifies just <code>pattern</code>\n+   *         and <code>formatData</code>.  Version 1 adds\n+   *         the <code>defaultCenturyStart</code>.  This implementation\n+   *         always writes out version 1 data.\n+   */\n   private int serialVersionOnStream = 1; // 0 indicates JDK1.1.3 or earlier\n+\n+  /**\n+   * For compatability.\n+   */\n   private static final long serialVersionUID = 4774881970558875024L;\n \n-  // This string is specified in the JCL.  We set it here rather than\n-  // do a DateFormatSymbols(Locale.US).getLocalPatternChars() since\n-  // someone could theoretically change those values (though unlikely).\n-  private static final String standardChars = \"GyMdkHmsSEDFwWahKzZ\";\n+  // This string is specified in the root of the CLDR.  We set it here\n+  // rather than doing a DateFormatSymbols(Locale.US).getLocalPatternChars()\n+  // since someone could theoretically change those values (though unlikely).\n+  private static final String standardChars = \"GyMdkHmsSEDFwWahKzYeugAZ\";\n \n+  /**\n+   * Reads the serialized version of this object.\n+   * If the serialized data is only version 0,\n+   * then the date for the start of the century\n+   * for interpreting two digit years is computed.\n+   * The pattern is parsed and compiled following the process\n+   * of reading in the serialized data.\n+   *\n+   * @param stream the object stream to read the data from.\n+   * @throws IOException if an I/O error occurs.\n+   * @throws ClassNotFoundException if the class of the serialized data\n+   *         could not be found.\n+   * @throws InvalidObjectException if the pattern is invalid.\n+   */ \n   private void readObject(ObjectInputStream stream)\n     throws IOException, ClassNotFoundException\n   {\n@@ -105,9 +263,25 @@ private void readObject(ObjectInputStream stream)\n \n     // Set up items normally taken care of by the constructor.\n     tokens = new ArrayList();\n-    compileFormat(pattern);\n+    try\n+      {\n+\tcompileFormat(pattern);\n+      }\n+    catch (IllegalArgumentException e)\n+      {\n+\tthrow new InvalidObjectException(\"The stream pattern was invalid.\");\n+      }\n   }\n \n+  /**\n+   * Compiles the supplied non-localized pattern into a form\n+   * from which formatting and parsing can be performed.\n+   * This also detects errors in the pattern, which will\n+   * be raised on later use of the compiled data.\n+   *\n+   * @param pattern the non-localized pattern to compile.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n+   */\n   private void compileFormat(String pattern) \n   {\n     // Any alphabetical characters are treated as pattern characters\n@@ -116,24 +290,25 @@ private void compileFormat(String pattern)\n     char thisChar;\n     int pos;\n     int field;\n-    FieldSizePair current = null;\n+    CompiledField current = null;\n \n     for (int i=0; i<pattern.length(); i++) {\n       thisChar = pattern.charAt(i);\n-      field = formatData.getLocalPatternChars().indexOf(thisChar);\n+      field = standardChars.indexOf(thisChar);\n       if (field == -1) {\n \tcurrent = null;\n \tif ((thisChar >= 'A' && thisChar <= 'Z')\n \t    || (thisChar >= 'a' && thisChar <= 'z')) {\n-\t  // Not a valid letter\n-\t  tokens.add(new FieldSizePair(-1,0));\n+ \t  // Not a valid letter\n+\t  throw new IllegalArgumentException(\"Invalid letter \" + thisChar +\n+\t\t\t\t\t     \"encountered at character \" + i\n+\t\t\t\t\t     + \".\");\n \t} else if (thisChar == '\\'') {\n \t  // Quoted text section; skip to next single quote\n \t  pos = pattern.indexOf('\\'',i+1);\n \t  if (pos == -1) {\n-\t    // This ought to be an exception, but spec does not\n-\t    // let us throw one.\n-\t    tokens.add(new FieldSizePair(-1,0));\n+\t    throw new IllegalArgumentException(\"Quotes starting at character \"\n+\t\t\t\t\t       + i + \" not closed.\");\n \t  }\n \t  if ((pos+1 < pattern.length()) && (pattern.charAt(pos+1) == '\\'')) {\n \t    tokens.add(pattern.substring(i+1,pos+1));\n@@ -150,20 +325,38 @@ private void compileFormat(String pattern)\n \tif ((current != null) && (field == current.field)) {\n \t  current.size++;\n \t} else {\n-\t  current = new FieldSizePair(field,1);\n+\t  current = new CompiledField(field,1,thisChar);\n \t  tokens.add(current);\n \t}\n       }\n     }\n   }\n \n+  /**\n+   * Returns a string representation of this\n+   * class.\n+   *\n+   * @return a string representation of the <code>SimpleDateFormat</code>\n+   *         instance.\n+   */\n   public String toString() \n   {\n-    StringBuffer output = new StringBuffer();\n-    Iterator i = tokens.iterator();\n-    while (i.hasNext()) {\n-      output.append(i.next().toString());\n-    }\n+    StringBuffer output = new StringBuffer(getClass().getName());\n+    output.append(\"[tokens=\");\n+    output.append(tokens);\n+    output.append(\", formatData=\");\n+    output.append(formatData);\n+    output.append(\", defaultCenturyStart=\");\n+    output.append(defaultCenturyStart);\n+    output.append(\", defaultCentury=\");\n+    output.append(defaultCentury);\n+    output.append(\", pattern=\");\n+    output.append(pattern);\n+    output.append(\", serialVersionOnStream=\");\n+    output.append(serialVersionOnStream);\n+    output.append(\", standardChars=\");\n+    output.append(standardChars);\n+    output.append(\"]\");\n     return output.toString();\n   }\n \n@@ -194,17 +387,26 @@ public SimpleDateFormat()\n   }\n   \n   /**\n-   * Creates a date formatter using the specified pattern, with the default\n-   * DateFormatSymbols for the default locale.\n+   * Creates a date formatter using the specified non-localized pattern,\n+   * with the default DateFormatSymbols for the default locale.\n+   *\n+   * @param pattern the pattern to use.\n+   * @throws NullPointerException if the pattern is null.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n    */\n   public SimpleDateFormat(String pattern) \n   {\n     this(pattern, Locale.getDefault());\n   }\n \n   /**\n-   * Creates a date formatter using the specified pattern, with the default\n-   * DateFormatSymbols for the given locale.\n+   * Creates a date formatter using the specified non-localized pattern,\n+   * with the default DateFormatSymbols for the given locale.\n+   *\n+   * @param pattern the non-localized pattern to use.\n+   * @param locale the locale to use for the formatting symbols.\n+   * @throws NullPointerException if the pattern is null.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n    */\n   public SimpleDateFormat(String pattern, Locale locale) \n   {\n@@ -222,15 +424,23 @@ public SimpleDateFormat(String pattern, Locale locale)\n   }\n \n   /**\n-   * Creates a date formatter using the specified pattern. The\n-   * specified DateFormatSymbols will be used when formatting.\n+   * Creates a date formatter using the specified non-localized\n+   * pattern. The specified DateFormatSymbols will be used when\n+   * formatting.\n+   *\n+   * @param pattern the non-localized pattern to use.\n+   * @param formatData the formatting symbols to use.\n+   * @throws NullPointerException if the pattern or formatData is null.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n    */\n   public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n   {\n     super();\n     calendar = new GregorianCalendar();\n     computeCenturyStart ();\n     tokens = new ArrayList();\n+    if (formatData == null)\n+      throw new NullPointerException(\"formatData\");\n     this.formatData = formatData;\n     compileFormat(pattern);\n     this.pattern = pattern;\n@@ -240,9 +450,6 @@ public SimpleDateFormat(String pattern, DateFormatSymbols formatData)\n     numberFormat.setMaximumFractionDigits (0);\n   }\n \n-  // What is the difference between localized and unlocalized?  The\n-  // docs don't say.\n-\n   /**\n    * This method returns a string with the formatting pattern being used\n    * by this object.  This string is unlocalized.\n@@ -263,14 +470,16 @@ public String toPattern()\n   public String toLocalizedPattern()\n   {\n     String localChars = formatData.getLocalPatternChars();\n-    return applyLocalizedPattern (pattern, standardChars, localChars);\n+    return translateLocalizedPattern(pattern, standardChars, localChars);\n   }\n \n   /**\n    * This method sets the formatting pattern that should be used by this\n    * object.  This string is not localized.\n    *\n    * @param pattern The new format pattern.\n+   * @throws NullPointerException if the pattern is null.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n    */\n   public void applyPattern(String pattern)\n   {\n@@ -284,16 +493,34 @@ public void applyPattern(String pattern)\n    * object.  This string is localized.\n    *\n    * @param pattern The new format pattern.\n+   * @throws NullPointerException if the pattern is null.\n+   * @throws IllegalArgumentException if the pattern is invalid.\n    */\n   public void applyLocalizedPattern(String pattern)\n   {\n     String localChars = formatData.getLocalPatternChars();\n-    pattern = applyLocalizedPattern (pattern, localChars, standardChars);\n+    pattern = translateLocalizedPattern(pattern, localChars, standardChars);\n     applyPattern(pattern);\n   }\n \n-  private String applyLocalizedPattern(String pattern,\n-\t\t\t\t       String oldChars, String newChars)\n+  /**\n+   * Translates either from or to a localized variant of the pattern\n+   * string.  For example, in the German locale, 't' (for 'tag') is\n+   * used instead of 'd' (for 'date').  This method translates\n+   * a localized pattern (such as 'ttt') to a non-localized pattern\n+   * (such as 'ddd'), or vice versa.  Non-localized patterns use\n+   * a standard set of characters, which match those of the U.S. English\n+   * locale.\n+   *\n+   * @param pattern the pattern to translate.\n+   * @param oldChars the old set of characters (used in the pattern).\n+   * @param newChars the new set of characters (which will be used in the\n+   *                 pattern).\n+   * @return a version of the pattern using the characters in\n+   *         <code>newChars</code>.\n+   */\n+  private String translateLocalizedPattern(String pattern,\n+\t\t\t\t\t   String oldChars, String newChars)\n   {\n     int len = pattern.length();\n     StringBuffer buf = new StringBuffer(len);\n@@ -341,24 +568,30 @@ public void set2DigitYearStart(Date date)\n   }\n \n   /**\n-   * This method returns the format symbol information used for parsing\n-   * and formatting dates.\n+   * This method returns a copy of the format symbol information used\n+   * for parsing and formatting dates.\n    *\n-   * @return The date format symbols.\n+   * @return a copy of the date format symbols.\n    */\n   public DateFormatSymbols getDateFormatSymbols()\n   {\n-    return formatData;\n+    return (DateFormatSymbols) formatData.clone();\n   }\n \n   /**\n    * This method sets the format symbols information used for parsing\n    * and formatting dates.\n    *\n    * @param formatData The date format symbols.\n+   * @throws NullPointerException if <code>formatData</code> is null.\n    */\n    public void setDateFormatSymbols(DateFormatSymbols formatData)\n    {\n+     if (formatData == null)\n+       {\n+\t throw new\n+\t   NullPointerException(\"The supplied format data was null.\");\n+       }\n      this.formatData = formatData;\n    }\n \n@@ -431,12 +664,12 @@ private void formatWithAttribute(Date date, FormatBuffer buffer, FieldPosition p\n     while (iter.hasNext())\n       {\n \tObject o = iter.next();\n-\tif (o instanceof FieldSizePair)\n+\tif (o instanceof CompiledField)\n \t  {\n-\t    FieldSizePair p = (FieldSizePair) o;\n+\t    CompiledField cf = (CompiledField) o;\n \t    int beginIndex = buffer.length();\n \t    \n-\t    switch (p.field)\n+\t    switch (cf.getField())\n \t      {\n \t      case ERA_FIELD:\n \t\tbuffer.append (formatData.eras[calendar.get (Calendar.ERA)], DateFormat.Field.ERA);\n@@ -445,101 +678,115 @@ private void formatWithAttribute(Date date, FormatBuffer buffer, FieldPosition p\n \t\t// If we have two digits, then we truncate.  Otherwise, we\n \t\t// use the size of the pattern, and zero pad.\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.YEAR);\n-\t\tif (p.size == 2)\n+\t\tif (cf.getSize() == 2)\n \t\t  {\n \t\t    temp = String.valueOf (calendar.get (Calendar.YEAR));\n \t\t    buffer.append (temp.substring (temp.length() - 2));\n \t\t  }\n \t\telse\n-\t\t  withLeadingZeros (calendar.get (Calendar.YEAR), p.size, buffer);\n+\t\t  withLeadingZeros (calendar.get (Calendar.YEAR), cf.getSize(), buffer);\n \t\tbreak;\n \t      case MONTH_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.MONTH);\n-\t\tif (p.size < 3)\n-\t\t  withLeadingZeros (calendar.get (Calendar.MONTH) + 1, p.size, buffer);\n-\t\telse if (p.size < 4)\n+\t\tif (cf.getSize() < 3)\n+\t\t  withLeadingZeros (calendar.get (Calendar.MONTH) + 1, cf.getSize(), buffer);\n+\t\telse if (cf.getSize() < 4)\n \t\t  buffer.append (formatData.shortMonths[calendar.get (Calendar.MONTH)]);\n \t\telse\n \t\t  buffer.append (formatData.months[calendar.get (Calendar.MONTH)]);\n \t\tbreak;\n \t      case DATE_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_MONTH);\n-\t\twithLeadingZeros (calendar.get (Calendar.DATE), p.size, buffer);\n+\t\twithLeadingZeros (calendar.get (Calendar.DATE), cf.getSize(), buffer);\n \t\tbreak;\n \t      case HOUR_OF_DAY1_FIELD: // 1-24\n \t\tbuffer.setDefaultAttribute(DateFormat.Field.HOUR_OF_DAY1);\n \t\twithLeadingZeros ( ((calendar.get (Calendar.HOUR_OF_DAY) + 23) % 24) + 1, \n-\t\t\t\t   p.size, buffer);\n+\t\t\t\t   cf.getSize(), buffer);\n \t\tbreak;\n \t      case HOUR_OF_DAY0_FIELD: // 0-23\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR_OF_DAY0);\n-\t\twithLeadingZeros (calendar.get (Calendar.HOUR_OF_DAY), p.size, buffer);\n+\t\twithLeadingZeros (calendar.get (Calendar.HOUR_OF_DAY), cf.getSize(), buffer);\n \t\tbreak;\n \t      case MINUTE_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.MINUTE);\n \t\twithLeadingZeros (calendar.get (Calendar.MINUTE),\n-\t\t\t\t  p.size, buffer);\n+\t\t\t\t  cf.getSize(), buffer);\n \t\tbreak;\n \t      case SECOND_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.SECOND);\n \t\twithLeadingZeros(calendar.get (Calendar.SECOND), \n-\t\t\t\t p.size, buffer);\n+\t\t\t\t cf.getSize(), buffer);\n \t\tbreak;\n \t      case MILLISECOND_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.MILLISECOND);\n-\t\twithLeadingZeros (calendar.get (Calendar.MILLISECOND), p.size, buffer);\n+\t\twithLeadingZeros (calendar.get (Calendar.MILLISECOND), cf.getSize(), buffer);\n \t\tbreak;\n \t      case DAY_OF_WEEK_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK);\n-\t\tif (p.size < 4)\n+\t\tif (cf.getSize() < 4)\n \t\t  buffer.append (formatData.shortWeekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n \t\telse\n \t\t  buffer.append (formatData.weekdays[calendar.get (Calendar.DAY_OF_WEEK)]);\n \t\tbreak;\n \t      case DAY_OF_YEAR_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_YEAR);\n-\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_YEAR), p.size, buffer);\n+\t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_YEAR), cf.getSize(), buffer);\n \t\tbreak;\n \t      case DAY_OF_WEEK_IN_MONTH_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.DAY_OF_WEEK_IN_MONTH);\n \t\twithLeadingZeros (calendar.get (Calendar.DAY_OF_WEEK_IN_MONTH), \n-\t\t\t\t p.size, buffer);\n+\t\t\t\t cf.getSize(), buffer);\n \t\tbreak;\n \t      case WEEK_OF_YEAR_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_YEAR);\n \t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_YEAR),\n-\t\t\t\t  p.size, buffer);\n+\t\t\t\t  cf.getSize(), buffer);\n \t\tbreak;\n \t      case WEEK_OF_MONTH_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.WEEK_OF_MONTH);\n \t\twithLeadingZeros (calendar.get (Calendar.WEEK_OF_MONTH),\n-\t\t\t\t  p.size, buffer);\n+\t\t\t\t  cf.getSize(), buffer);\n \t\tbreak;\n \t      case AM_PM_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.AM_PM);\n \t\tbuffer.append (formatData.ampms[calendar.get (Calendar.AM_PM)]);\n \t\tbreak;\n \t      case HOUR1_FIELD: // 1-12\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR1);\n-\t\twithLeadingZeros (((calendar.get (Calendar.HOUR) + 11) % 12) + 1, p.size, buffer);\n+\t\twithLeadingZeros (((calendar.get (Calendar.HOUR) + 11) % 12) + 1,\n+\t\t\t\t  cf.getSize(), buffer);\n \t\tbreak;\n \t      case HOUR0_FIELD: // 0-11\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.HOUR0);\n-\t\twithLeadingZeros (calendar.get (Calendar.HOUR), p.size, buffer);\n+\t\twithLeadingZeros (calendar.get (Calendar.HOUR), cf.getSize(), buffer);\n \t\tbreak;\n \t      case TIMEZONE_FIELD:\n \t\tbuffer.setDefaultAttribute (DateFormat.Field.TIME_ZONE);\n \t\tTimeZone zone = calendar.getTimeZone();\n \t\tboolean isDST = calendar.get (Calendar.DST_OFFSET) != 0;\n \t\t// FIXME: XXX: This should be a localized time zone.\n-\t\tString zoneID = zone.getDisplayName (isDST, p.size > 3 ? TimeZone.LONG : TimeZone.SHORT);\n+\t\tString zoneID = zone.getDisplayName\n+\t\t  (isDST, cf.getSize() > 3 ? TimeZone.LONG : TimeZone.SHORT);\n \t\tbuffer.append (zoneID);\n \t\tbreak;\n+\t      case RFC822_TIMEZONE_FIELD:\n+\t\tbuffer.setDefaultAttribute(DateFormat.Field.RFC822_TIME_ZONE);\n+\t\tint pureMinutes = (calendar.get(Calendar.ZONE_OFFSET) +\n+\t\t\t\t   calendar.get(Calendar.DST_OFFSET)) / (1000 * 60);\n+\t\tString sign = (pureMinutes < 0) ? \"-\" : \"+\";\t  \n+\t\tint hours = pureMinutes / 60;\n+\t\tint minutes = pureMinutes % 60;\n+\t\tbuffer.append(sign);\n+\t\twithLeadingZeros(hours, 2, buffer);\n+\t\twithLeadingZeros(minutes, 2, buffer);\n+\t\tbreak;\n \t      default:\n-\t\tthrow new IllegalArgumentException (\"Illegal pattern character \" + p.field);\n+\t\tthrow new IllegalArgumentException (\"Illegal pattern character \" +\n+\t\t\t\t\t\t    cf.getCharacter());\n \t      }\n \t    if (pos != null && (buffer.getDefaultAttribute() == pos.getFieldAttribute()\n-\t\t\t\t|| p.field == pos.getField()))\n+\t\t\t\t|| cf.getField() == pos.getField()))\n \t      {\n \t\tpos.setBeginIndex(beginIndex);\n \t\tpos.setEndIndex(buffer.length());\n@@ -614,232 +861,265 @@ public Date parse (String dateStr, ParsePosition pos)\n     boolean saw_timezone = false;\n     int quote_start = -1;\n     boolean is2DigitYear = false;\n-    for (; fmt_index < fmt_max; ++fmt_index)\n+    try\n       {\n-\tchar ch = pattern.charAt(fmt_index);\n-\tif (ch == '\\'')\n+\tfor (; fmt_index < fmt_max; ++fmt_index)\n \t  {\n-\t    int index = pos.getIndex();\n-\t    if (fmt_index < fmt_max - 1\n-\t\t&& pattern.charAt(fmt_index + 1) == '\\'')\n+\t    char ch = pattern.charAt(fmt_index);\n+\t    if (ch == '\\'')\n+\t      {\n+\t\tint index = pos.getIndex();\n+\t\tif (fmt_index < fmt_max - 1\n+\t\t    && pattern.charAt(fmt_index + 1) == '\\'')\n+\t\t  {\n+\t\t    if (! expect (dateStr, pos, ch))\n+\t\t      return null;\n+\t\t    ++fmt_index;\n+\t\t  }\n+\t\telse\n+\t\t  quote_start = quote_start < 0 ? fmt_index : -1;\n+\t\tcontinue;\n+\t      }\n+\t    \n+\t    if (quote_start != -1\n+\t\t|| ((ch < 'a' || ch > 'z')\n+\t\t    && (ch < 'A' || ch > 'Z')))\n \t      {\n \t\tif (! expect (dateStr, pos, ch))\n \t\t  return null;\n-\t\t++fmt_index;\n+\t\tcontinue;\n \t      }\n-\t    else\n-\t      quote_start = quote_start < 0 ? fmt_index : -1;\n-\t    continue;\n-\t  }\n-\n-\tif (quote_start != -1\n-\t    || ((ch < 'a' || ch > 'z')\n-\t\t&& (ch < 'A' || ch > 'Z')))\n-\t  {\n-\t    if (! expect (dateStr, pos, ch))\n-\t      return null;\n-\t    continue;\n-\t  }\n-\n-\t// We've arrived at a potential pattern character in the\n-\t// pattern.\n-\tint first = fmt_index;\n-\twhile (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n-\t  ;\n-\tint fmt_count = fmt_index - first;\n-\n-\t// We might need to limit the number of digits to parse in\n-\t// some cases.  We look to the next pattern character to\n-\t// decide.\n-\tboolean limit_digits = false;\n-\tif (fmt_index < fmt_max\n-\t    && standardChars.indexOf(pattern.charAt(fmt_index)) >= 0)\n-\t  limit_digits = true;\n-\t--fmt_index;\n-\n-\t// We can handle most fields automatically: most either are\n-\t// numeric or are looked up in a string vector.  In some cases\n-\t// we need an offset.  When numeric, `offset' is added to the\n-\t// resulting value.  When doing a string lookup, offset is the\n-\t// initial index into the string array.\n-\tint calendar_field;\n-\tboolean is_numeric = true;\n-\tString[] match = null;\n-\tint offset = 0;\n-\tboolean maybe2DigitYear = false;\n-\tswitch (ch)\n-\t  {\n-\t  case 'd':\n-\t    calendar_field = Calendar.DATE;\n-\t    break;\n-\t  case 'D':\n-\t    calendar_field = Calendar.DAY_OF_YEAR;\n-\t    break;\n-\t  case 'F':\n-\t    calendar_field = Calendar.DAY_OF_WEEK_IN_MONTH;\n-\t    break;\n-\t  case 'E':\n-\t    is_numeric = false;\n-\t    offset = 1;\n-\t    calendar_field = Calendar.DAY_OF_WEEK;\n-\t    match = (fmt_count <= 3\n-\t\t     ? formatData.getShortWeekdays()\n-\t\t     : formatData.getWeekdays());\n-\t    break;\n-\t  case 'w':\n-\t    calendar_field = Calendar.WEEK_OF_YEAR;\n-\t    break;\n-\t  case 'W':\n-\t    calendar_field = Calendar.WEEK_OF_MONTH;\n-\t    break;\n-\t  case 'M':\n-\t    calendar_field = Calendar.MONTH;\n-\t    if (fmt_count <= 2)\n-\t      offset = -1;\n-\t    else\n+\t    \n+\t    // We've arrived at a potential pattern character in the\n+\t    // pattern.\n+\t    int fmt_count = 1;\n+\t    while (++fmt_index < fmt_max && pattern.charAt(fmt_index) == ch)\n \t      {\n-\t\tis_numeric = false;\n-\t\tmatch = (fmt_count <= 3\n-\t\t\t ? formatData.getShortMonths()\n-\t\t\t : formatData.getMonths());\n+\t\t++fmt_count;\n \t      }\n-\t    break;\n-\t  case 'y':\n-\t    calendar_field = Calendar.YEAR;\n-\t    if (fmt_count <= 2)\n-\t      maybe2DigitYear = true;\n-\t    break;\n-\t  case 'K':\n-\t    calendar_field = Calendar.HOUR;\n-\t    break;\n-\t  case 'h':\n-\t    calendar_field = Calendar.HOUR;\n-\t    break;\n-\t  case 'H':\n-\t    calendar_field = Calendar.HOUR_OF_DAY;\n-\t    break;\n-\t  case 'k':\n-\t    calendar_field = Calendar.HOUR_OF_DAY;\n-\t    break;\n-\t  case 'm':\n-\t    calendar_field = Calendar.MINUTE;\n-\t    break;\n-\t  case 's':\n-\t    calendar_field = Calendar.SECOND;\n-\t    break;\n-\t  case 'S':\n-\t    calendar_field = Calendar.MILLISECOND;\n-\t    break;\n-\t  case 'a':\n-\t    is_numeric = false;\n-\t    calendar_field = Calendar.AM_PM;\n-\t    match = formatData.getAmPmStrings();\n-\t    break;\n-\t  case 'z':\n-\t    // We need a special case for the timezone, because it\n-\t    // uses a different data structure than the other cases.\n-\t    is_numeric = false;\n-\t    calendar_field = Calendar.DST_OFFSET;\n-\t    String[][] zoneStrings = formatData.getZoneStrings();\n-\t    int zoneCount = zoneStrings.length;\n-\t    int index = pos.getIndex();\n-\t    boolean found_zone = false;\n-\t    for (int j = 0;  j < zoneCount;  j++)\n+\t    \n+\t    // We might need to limit the number of digits to parse in\n+\t    // some cases.  We look to the next pattern character to\n+\t    // decide.\n+\t    boolean limit_digits = false;\n+\t    if (fmt_index < fmt_max\n+\t\t&& standardChars.indexOf(pattern.charAt(fmt_index)) >= 0)\n+\t      limit_digits = true;\n+\t    --fmt_index;\n+\t    \n+\t    // We can handle most fields automatically: most either are\n+\t    // numeric or are looked up in a string vector.  In some cases\n+\t    // we need an offset.  When numeric, `offset' is added to the\n+\t    // resulting value.  When doing a string lookup, offset is the\n+\t    // initial index into the string array.\n+\t    int calendar_field;\n+\t    boolean is_numeric = true;\n+\t    int offset = 0;\n+\t    boolean maybe2DigitYear = false;\n+\t    Integer simpleOffset;\n+\t    String[] set1 = null;\n+\t    String[] set2 = null;\n+\t    switch (ch)\n \t      {\n-\t\tString[] strings = zoneStrings[j];\n-\t\tint k;\n-\t\tfor (k = 1; k < strings.length; ++k)\n+\t      case 'd':\n+\t\tcalendar_field = Calendar.DATE;\n+\t\tbreak;\n+\t      case 'D':\n+\t\tcalendar_field = Calendar.DAY_OF_YEAR;\n+\t\tbreak;\n+\t      case 'F':\n+\t\tcalendar_field = Calendar.DAY_OF_WEEK_IN_MONTH;\n+\t\tbreak;\n+\t      case 'E':\n+\t\tis_numeric = false;\n+\t\toffset = 1;\n+\t\tcalendar_field = Calendar.DAY_OF_WEEK;\n+\t\tset1 = formatData.getWeekdays();\n+\t\tset2 = formatData.getShortWeekdays();\n+\t\tbreak;\n+\t      case 'w':\n+\t\tcalendar_field = Calendar.WEEK_OF_YEAR;\n+\t\tbreak;\n+\t      case 'W':\n+\t\tcalendar_field = Calendar.WEEK_OF_MONTH;\n+\t\tbreak;\n+\t      case 'M':\n+\t\tcalendar_field = Calendar.MONTH;\n+\t\tif (fmt_count <= 2)\n+\t\t  offset = -1;\n+\t\telse\n \t\t  {\n-\t\t    if (dateStr.startsWith(strings[k], index))\n-\t\t      break;\n+\t\t    is_numeric = false;\n+\t\t    set1 = formatData.getMonths();\n+\t\t    set2 = formatData.getShortMonths();\n \t\t  }\n-\t\tif (k != strings.length)\n+\t\tbreak;\n+\t      case 'y':\n+\t\tcalendar_field = Calendar.YEAR;\n+\t\tif (fmt_count <= 2)\n+\t\t  maybe2DigitYear = true;\n+\t\tbreak;\n+\t      case 'K':\n+\t\tcalendar_field = Calendar.HOUR;\n+\t\tbreak;\n+\t      case 'h':\n+\t\tcalendar_field = Calendar.HOUR;\n+\t\tbreak;\n+\t      case 'H':\n+\t\tcalendar_field = Calendar.HOUR_OF_DAY;\n+\t\tbreak;\n+\t      case 'k':\n+\t\tcalendar_field = Calendar.HOUR_OF_DAY;\n+\t\tbreak;\n+\t      case 'm':\n+\t\tcalendar_field = Calendar.MINUTE;\n+\t\tbreak;\n+\t      case 's':\n+\t\tcalendar_field = Calendar.SECOND;\n+\t\tbreak;\n+\t      case 'S':\n+\t\tcalendar_field = Calendar.MILLISECOND;\n+\t\tbreak;\n+\t      case 'a':\n+\t\tis_numeric = false;\n+\t\tcalendar_field = Calendar.AM_PM;\n+\t\tset1 = formatData.getAmPmStrings();\n+\t\tbreak;\n+\t      case 'z':\n+\t      case 'Z':\n+\t\t// We need a special case for the timezone, because it\n+\t\t// uses a different data structure than the other cases.\n+\t\tis_numeric = false;\n+\t\tcalendar_field = Calendar.ZONE_OFFSET;\n+\t\tString[][] zoneStrings = formatData.getZoneStrings();\n+\t\tint zoneCount = zoneStrings.length;\n+\t\tint index = pos.getIndex();\n+\t\tboolean found_zone = false;\n+\t\tsimpleOffset = computeOffset(dateStr.substring(index));\n+\t\tif (simpleOffset != null)\n \t\t  {\n \t\t    found_zone = true;\n \t\t    saw_timezone = true;\n-\t\t    TimeZone tz = TimeZone.getTimeZone (strings[0]);\n-\t\t    calendar.set (Calendar.ZONE_OFFSET, tz.getRawOffset ());\n-\t\t    offset = 0;\n-\t\t    if (k > 2 && tz instanceof SimpleTimeZone)\n+\t\t    calendar.set(Calendar.DST_OFFSET, 0);\n+\t\t    offset = simpleOffset.intValue();\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    for (int j = 0;  j < zoneCount;  j++)\n \t\t      {\n-\t\t\tSimpleTimeZone stz = (SimpleTimeZone) tz;\n-\t\t\toffset = stz.getDSTSavings ();\n+\t\t\tString[] strings = zoneStrings[j];\n+\t\t\tint k;\n+\t\t\tfor (k = 0; k < strings.length; ++k)\n+\t\t\t  {\n+\t\t\t    if (dateStr.startsWith(strings[k], index))\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t\tif (k != strings.length)\n+\t\t\t  {\n+\t\t\t    found_zone = true;\n+\t\t\t    saw_timezone = true;\n+\t\t\t    TimeZone tz = TimeZone.getTimeZone (strings[0]);\n+\t\t\t    // Check if it's a DST zone or ordinary \n+\t\t\t    if(k == 3 || k == 4)\n+\t\t\t      calendar.set (Calendar.DST_OFFSET, tz.getDSTSavings());\n+\t\t\t    else\n+\t\t\t      calendar.set (Calendar.DST_OFFSET, 0);\n+                            offset = tz.getRawOffset ();\n+\t\t\t    pos.setIndex(index + strings[k].length());\n+\t\t\t    break;\n+\t\t\t  }\n \t\t      }\n-\t\t    pos.setIndex(index + strings[k].length());\n-\t\t    break;\n \t\t  }\n-\t      }\n-\t    if (! found_zone)\n-\t      {\n+\t\tif (! found_zone)\n+\t\t  {\n+\t\t\tpos.setErrorIndex(pos.getIndex());\n+\t\t\treturn null;\n+\t\t  }\n+\t\tbreak;\n+\t      default:\n \t\tpos.setErrorIndex(pos.getIndex());\n \t\treturn null;\n \t      }\n-\t    break;\n-\t  default:\n-\t    pos.setErrorIndex(pos.getIndex());\n-\t    return null;\n-\t  }\n-\n-\t// Compute the value we should assign to the field.\n-\tint value;\n-\tint index = -1;\n-\tif (is_numeric)\n-\t  {\n-\t    numberFormat.setMinimumIntegerDigits(fmt_count);\n-\t    if (limit_digits)\n-\t      numberFormat.setMaximumIntegerDigits(fmt_count);\n-\t    if (maybe2DigitYear)\n-\t      index = pos.getIndex();\n-\t    Number n = numberFormat.parse(dateStr, pos);\n-\t    if (pos == null || ! (n instanceof Long))\n-\t      return null;\n-\t    value = n.intValue() + offset;\n-\t  }\n-\telse if (match != null)\n-\t  {\n-\t    index = pos.getIndex();\n-\t    int i;\n-\t    for (i = offset; i < match.length; ++i)\n+      \n+\t    // Compute the value we should assign to the field.\n+\t    int value;\n+\t    int index = -1;\n+\t    if (is_numeric)\n \t      {\n-\t\tif (dateStr.startsWith(match[i], index))\n-\t\t  break;\n+\t\tnumberFormat.setMinimumIntegerDigits(fmt_count);\n+\t\tif (limit_digits)\n+\t\t  numberFormat.setMaximumIntegerDigits(fmt_count);\n+\t\tif (maybe2DigitYear)\n+\t\t  index = pos.getIndex();\n+\t\tNumber n = numberFormat.parse(dateStr, pos);\n+\t\tif (pos == null || ! (n instanceof Long))\n+\t\t  return null;\n+\t\tvalue = n.intValue() + offset;\n \t      }\n-\t    if (i == match.length)\n+\t    else if (set1 != null)\n \t      {\n-\t\tpos.setErrorIndex(index);\n-\t\treturn null;\n+\t\tindex = pos.getIndex();\n+\t\tint i;\n+\t\tboolean found = false;\n+\t\tfor (i = offset; i < set1.length; ++i)\n+\t\t  {\n+\t\t    if (set1[i] != null)\n+\t\t      if (dateStr.toUpperCase().startsWith(set1[i].toUpperCase(),\n+\t\t\t\t\t\t\t   index))\n+\t\t\t{\n+\t\t\t  found = true;\n+\t\t\t  pos.setIndex(index + set1[i].length());\n+\t\t\t  break;\n+\t\t\t}\n+\t\t  }\n+\t\tif (!found && set2 != null)\n+\t\t  {\n+\t\t    for (i = offset; i < set2.length; ++i)\n+\t\t      {\n+\t\t\tif (set2[i] != null)\n+\t\t\t  if (dateStr.toUpperCase().startsWith(set2[i].toUpperCase(),\n+\t\t\t\t\t\t\t       index))\n+\t\t\t    {\n+\t\t\t      found = true;\n+\t\t\t      pos.setIndex(index + set2[i].length());\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t      }\n+\t\t  }\n+\t\tif (!found)\n+\t\t  {\n+\t\t    pos.setErrorIndex(index);\n+\t\t    return null;\n+\t\t  }\n+\t\tvalue = i;\n \t      }\n-\t    pos.setIndex(index + match[i].length());\n-\t    value = i;\n-\t  }\n-\telse\n-\t  value = offset;\n+\t    else\n+\t      value = offset;\n \t  \n-\tif (maybe2DigitYear)\n-\t  {\n-\t    // Parse into default century if the numeric year string has \n-\t    // exactly 2 digits.\n-\t    int digit_count = pos.getIndex() - index;\n-\t    if (digit_count == 2)\n-\t      is2DigitYear = true;\n+\t    if (maybe2DigitYear)\n+\t      {\n+\t\t// Parse into default century if the numeric year string has \n+\t\t// exactly 2 digits.\n+\t\tint digit_count = pos.getIndex() - index;\n+\t\tif (digit_count == 2)\n+\t\t  {\n+\t\t    is2DigitYear = true;\n+\t\t    value += defaultCentury;\n+\t\t  }\n+\t      }\n+\t    \n+\t    // Assign the value and move on.\n+\t    calendar.set(calendar_field, value);\n \t  }\n-\n-\t// Assign the value and move on.\n-\tcalendar.set(calendar_field, value);\n-      }\n     \n-    if (is2DigitYear)\n-      {\n-\t// Apply the 80-20 heuristic to dermine the full year based on \n-\t// defaultCenturyStart. \n-\tint year = defaultCentury + calendar.get(Calendar.YEAR);\n-\tcalendar.set(Calendar.YEAR, year);\n-\tif (calendar.getTime().compareTo(defaultCenturyStart) < 0)\n-\t  calendar.set(Calendar.YEAR, year + 100);      \n-      }\n-\n-    try\n-      {\n+\tif (is2DigitYear)\n+\t  {\n+\t    // Apply the 80-20 heuristic to dermine the full year based on \n+\t    // defaultCenturyStart. \n+\t    int year = calendar.get(Calendar.YEAR);\n+\t    if (calendar.getTime().compareTo(defaultCenturyStart) < 0)\n+\t      calendar.set(Calendar.YEAR, year + 100);      \n+\t  }\n \tif (! saw_timezone)\n \t  {\n \t    // Use the real rules to determine whether or not this\n@@ -854,6 +1134,69 @@ else if (match != null)\n         pos.setErrorIndex(pos.getIndex());\n \treturn null;\n       }\n+      }\n+\n+  /**\n+   * <p>\n+   * Computes the time zone offset in milliseconds\n+   * relative to GMT, based on the supplied\n+   * <code>String</code> representation.\n+   * </p>\n+   * <p>\n+   * The supplied <code>String</code> must be a three\n+   * or four digit signed number, with an optional 'GMT'\n+   * prefix.  The first one or two digits represents the hours,\n+   * while the last two represent the minutes.  The\n+   * two sets of digits can optionally be separated by\n+   * ':'.  The mandatory sign prefix (either '+' or '-')\n+   * indicates the direction of the offset from GMT.\n+   * </p>\n+   * <p>\n+   * For example, 'GMT+0200' specifies 2 hours after\n+   * GMT, while '-05:00' specifies 5 hours prior to\n+   * GMT.  The special case of 'GMT' alone can be used\n+   * to represent the offset, 0.\n+   * </p>\n+   * <p>\n+   * If the <code>String</code> can not be parsed,\n+   * the result will be null.  The resulting offset\n+   * is wrapped in an <code>Integer</code> object, in\n+   * order to allow such failure to be represented.\n+   * </p>\n+   *\n+   * @param zoneString a string in the form \n+   *        (GMT)? sign hours : minutes\n+   *        where sign = '+' or '-', hours\n+   *        is a one or two digits representing\n+   *        a number between 0 and 23, and\n+   *        minutes is two digits representing\n+   *        a number between 0 and 59.\n+   * @return the parsed offset, or null if parsing\n+   *         failed.\n+   */\n+  private Integer computeOffset(String zoneString)\n+  {\n+    Pattern pattern =\n+      Pattern.compile(\"(GMT)?([+-])([012])?([0-9]):?([0-9]{2})\");\n+    Matcher matcher = pattern.matcher(zoneString);\n+    if (matcher.matches())\n+      {\n+\tint sign = matcher.group(2).equals(\"+\") ? 1 : -1;\n+\tint hour = (Integer.parseInt(matcher.group(3)) * 10)\n+\t  + Integer.parseInt(matcher.group(4));\n+\tint minutes = Integer.parseInt(matcher.group(5));\n+\n+\tif (hour > 23)\n+\t  return null;\n+\n+\tint offset = sign * ((hour * 60) + minutes) * 60000;\n+\treturn new Integer(offset);\n+      }\n+    else if (zoneString.startsWith(\"GMT\"))\n+      {\n+\treturn new Integer(0);\n+      }\n+    return null;\n   }\n \n   // Compute the start of the current century as defined by\n@@ -864,4 +1207,19 @@ private void computeCenturyStart()\n     calendar.set(Calendar.YEAR, year - 80);\n     set2DigitYearStart(calendar.getTime());\n   }\n+\n+  /**\n+   * Returns a copy of this instance of\n+   * <code>SimpleDateFormat</code>.  The copy contains\n+   * clones of the formatting symbols and the 2-digit\n+   * year century start date.\n+   */\n+  public Object clone()\n+  {\n+    SimpleDateFormat clone = (SimpleDateFormat) super.clone();\n+    clone.setDateFormatSymbols((DateFormatSymbols) formatData.clone());\n+    clone.set2DigitYearStart((Date) defaultCenturyStart.clone());\n+    return clone;\n+  }\n+\n }"}, {"sha": "8a37c5e695e849061cffe83dd7a0c79c1b73a16c", "filename": "libjava/java/util/Calendar.java", "status": "modified", "additions": 193, "deletions": 78, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FCalendar.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -51,7 +51,7 @@\n  * integer fields which represent <code>YEAR</code>,\n  * <code>MONTH</code>, <code>DAY</code>, etc.  The <code>Date</code>\n  * object represents a time in milliseconds since the Epoch. <br>\n- * \n+ *\n  * This class is locale sensitive.  To get the Object matching the\n  * current locale you can use <code>getInstance</code>.  You can even provide\n  * a locale or a timezone.  <code>getInstance</code> returns currently\n@@ -78,21 +78,21 @@\n  * and for the first line all fields are set, that line is used to\n  * compute the day. <br>\n  *\n- * \n+ *\n <pre>month + day_of_month\n month + week_of_month + day_of_week\n month + day_of_week_of_month + day_of_week\n day_of_year\n day_of_week + week_of_year</pre>\n- * \n+ *\n  * The hour_of_day-field takes precedence over the ampm and\n  * hour_of_ampm fields. <br>\n  *\n  * <STRONG>Note:</STRONG> This can differ for non-Gregorian calendar. <br>\n  *\n  * To convert a calendar to a human readable form and vice versa,  use\n  * the <code>java.text.DateFormat</code> class. <br>\n- * \n+ *\n  * Other useful things you can do with an calendar, is\n  * <code>roll</code>ing fields (that means increase/decrease a\n  * specific field by one, propagating overflows), or\n@@ -101,94 +101,112 @@\n  * @see Date\n  * @see GregorianCalendar\n  * @see TimeZone\n- * @see java.text.DateFormat \n+ * @see java.text.DateFormat\n  */\n public abstract class Calendar implements Serializable, Cloneable\n {\n   /**\n    * Constant representing the era time field.\n    */\n   public static final int ERA = 0;\n+\n   /**\n    * Constant representing the year time field.\n    */\n   public static final int YEAR = 1;\n+\n   /**\n    * Constant representing the month time field.  This field\n    * should contain one of the JANUARY,...,DECEMBER constants below.\n    */\n   public static final int MONTH = 2;\n+\n   /**\n    * Constant representing the week of the year field.\n    * @see #setFirstDayOfWeek(int)\n    */\n   public static final int WEEK_OF_YEAR = 3;\n+\n   /**\n    * Constant representing the week of the month time field.\n    * @see #setFirstDayOfWeek(int)\n    */\n   public static final int WEEK_OF_MONTH = 4;\n+\n   /**\n    * Constant representing the day time field, synonym for DAY_OF_MONTH.\n    */\n   public static final int DATE = 5;\n+\n   /**\n    * Constant representing the day time field.\n    */\n   public static final int DAY_OF_MONTH = 5;\n+\n   /**\n    * Constant representing the day of year time field.  This is\n    * 1 for the first day in month.\n    */\n   public static final int DAY_OF_YEAR = 6;\n+\n   /**\n    * Constant representing the day of week time field.  This field\n    * should contain one of the SUNDAY,...,SATURDAY constants below.\n    */\n   public static final int DAY_OF_WEEK = 7;\n+\n   /**\n    * Constant representing the day-of-week-in-month field.  For\n    * instance this field contains 2 for the second thursday in a\n    * month.  If you give a negative number here, the day will count\n    * from the end of the month.\n    */\n   public static final int DAY_OF_WEEK_IN_MONTH = 8;\n+\n   /**\n    * Constant representing the part of the day for 12-hour clock.  This\n    * should be one of AM or PM.\n    */\n   public static final int AM_PM = 9;\n+\n   /**\n    * Constant representing the hour time field for 12-hour clock.\n    */\n   public static final int HOUR = 10;\n+\n   /**\n    * Constant representing the hour of day time field for 24-hour clock.\n    */\n   public static final int HOUR_OF_DAY = 11;\n+\n   /**\n    * Constant representing the minute of hour time field.\n    */\n   public static final int MINUTE = 12;\n+\n   /**\n    * Constant representing the second time field.\n    */\n   public static final int SECOND = 13;\n+\n   /**\n    * Constant representing the millisecond time field.\n    */\n   public static final int MILLISECOND = 14;\n+\n   /**\n    * Constant representing the time zone offset time field for the\n    * time given in the other fields.  It is measured in\n-   * milliseconds.  The default is the offset of the time zone.  \n+   * milliseconds.  The default is the offset of the time zone.\n    */\n   public static final int ZONE_OFFSET = 15;\n+\n   /**\n    * Constant representing the daylight saving time offset in\n-   * milliseconds.  The default is the value given by the time zone.  \n+   * milliseconds.  The default is the value given by the time zone.\n    */\n   public static final int DST_OFFSET = 16;\n+\n   /**\n    * Number of time fields.\n    */\n@@ -198,26 +216,32 @@ public abstract class Calendar implements Serializable, Cloneable\n    * Constant representing Sunday.\n    */\n   public static final int SUNDAY = 1;\n+\n   /**\n    * Constant representing Monday.\n    */\n   public static final int MONDAY = 2;\n+\n   /**\n    * Constant representing Tuesday.\n    */\n   public static final int TUESDAY = 3;\n+\n   /**\n    * Constant representing Wednesday.\n    */\n   public static final int WEDNESDAY = 4;\n+\n   /**\n    * Constant representing Thursday.\n    */\n   public static final int THURSDAY = 5;\n+\n   /**\n    * Constant representing Friday.\n    */\n   public static final int FRIDAY = 6;\n+\n   /**\n    * Constant representing Saturday.\n    */\n@@ -227,50 +251,62 @@ public abstract class Calendar implements Serializable, Cloneable\n    * Constant representing January.\n    */\n   public static final int JANUARY = 0;\n+\n   /**\n    * Constant representing February.\n    */\n   public static final int FEBRUARY = 1;\n+\n   /**\n    * Constant representing March.\n    */\n   public static final int MARCH = 2;\n+\n   /**\n    * Constant representing April.\n    */\n   public static final int APRIL = 3;\n+\n   /**\n    * Constant representing May.\n    */\n   public static final int MAY = 4;\n+\n   /**\n    * Constant representing June.\n    */\n   public static final int JUNE = 5;\n+\n   /**\n    * Constant representing July.\n    */\n   public static final int JULY = 6;\n+\n   /**\n    * Constant representing August.\n    */\n   public static final int AUGUST = 7;\n+\n   /**\n    * Constant representing September.\n    */\n   public static final int SEPTEMBER = 8;\n+\n   /**\n    * Constant representing October.\n    */\n   public static final int OCTOBER = 9;\n+\n   /**\n    * Constant representing November.\n    */\n   public static final int NOVEMBER = 10;\n+\n   /**\n    * Constant representing December.\n    */\n   public static final int DECEMBER = 11;\n+\n   /**\n    * Constant representing Undecimber. This is an artificial name useful\n    * for lunar calendars.\n@@ -281,6 +317,7 @@ public abstract class Calendar implements Serializable, Cloneable\n    * Useful constant for 12-hour clock.\n    */\n   public static final int AM = 0;\n+\n   /**\n    * Useful constant for 12-hour clock.\n    */\n@@ -292,21 +329,25 @@ public abstract class Calendar implements Serializable, Cloneable\n    * @serial\n    */\n   protected int[] fields = new int[FIELD_COUNT];\n+\n   /**\n    * The flags which tell if the fields above have a value.\n    * @serial\n    */\n   protected boolean[] isSet = new boolean[FIELD_COUNT];\n+\n   /**\n    * The time in milliseconds since the epoch.\n    * @serial\n    */\n   protected long time;\n+\n   /**\n    * Tells if the above field has a valid value.\n    * @serial\n    */\n   protected boolean isTimeSet;\n+\n   /**\n    * Tells if the fields have a valid value.  This superseeds the isSet\n    * array.\n@@ -332,7 +373,7 @@ public abstract class Calendar implements Serializable, Cloneable\n \n   /**\n    * Sets what the first day of week is.  This is used for\n-   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields.\n    * @serial\n    */\n   private int firstDayOfWeek;\n@@ -347,7 +388,14 @@ public abstract class Calendar implements Serializable, Cloneable\n   private int minimalDaysInFirstWeek;\n \n   /**\n-   * The version of the serialized data on the stream. \n+   * Is set to true if DST_OFFSET is explicitly set. In that case\n+   * it's value overrides the value computed from the current\n+   * time and the timezone.\n+   */\n+  private boolean explicitDSTOffset = false;\n+\n+  /**\n+   * The version of the serialized data on the stream.\n    * <dl><dt>0 or not present</dt>\n    * <dd> JDK 1.1.5 or later.</dd>\n    * <dl><dt>1</dt>\n@@ -371,14 +419,14 @@ public abstract class Calendar implements Serializable, Cloneable\n   private static final String bundleName = \"gnu.java.locale.Calendar\";\n \n   /**\n-   * get resource bundle: \n+   * get resource bundle:\n    * The resources should be loaded via this method only. Iff an application\n-   * uses this method, the resourcebundle is required. \n+   * uses this method, the resourcebundle is required.\n    */\n-  private static ResourceBundle getBundle(Locale locale) \n+  private static ResourceBundle getBundle(Locale locale)\n   {\n     return ResourceBundle.getBundle(bundleName, locale,\n-      ClassLoader.getSystemClassLoader());\n+                                    ClassLoader.getSystemClassLoader());\n   }\n \n   /**\n@@ -404,8 +452,9 @@ protected Calendar(TimeZone zone, Locale locale)\n     ResourceBundle rb = getBundle(locale);\n \n     firstDayOfWeek = ((Integer) rb.getObject(\"firstDayOfWeek\")).intValue();\n-    minimalDaysInFirstWeek =\n-      ((Integer) rb.getObject(\"minimalDaysInFirstWeek\")).intValue();\n+    minimalDaysInFirstWeek = ((Integer) rb.getObject(\"minimalDaysInFirstWeek\"))\n+                             .intValue();\n+    clear();\n   }\n \n   /**\n@@ -437,15 +486,17 @@ public static synchronized Calendar getInstance(Locale locale)\n     return getInstance(TimeZone.getDefault(), locale);\n   }\n \n-  /** \n+  /**\n    * Cache of locale->calendar-class mappings. This avoids having to do a ResourceBundle\n-   * lookup for every getInstance call.  \n+   * lookup for every getInstance call.\n    */\n   private static HashMap cache = new HashMap();\n \n   /** Preset argument types for calendar-class constructor lookup.  */\n-  private static Class[] ctorArgTypes\n-    = new Class[] {TimeZone.class, Locale.class};\n+  private static Class[] ctorArgTypes = new Class[]\n+                                        {\n+                                          TimeZone.class, Locale.class\n+                                        };\n \n   /**\n    * Creates a calendar representing the actual time, using the given\n@@ -473,15 +524,15 @@ public static synchronized Calendar getInstance(TimeZone zone, Locale locale)\n \t      }\n \t  }\n \n-        // GregorianCalendar is by far the most common case. Optimize by \n+\t// GregorianCalendar is by far the most common case. Optimize by \n \t// avoiding reflection.\n \tif (calendarClass == GregorianCalendar.class)\n \t  return new GregorianCalendar(zone, locale);\n \n \tif (Calendar.class.isAssignableFrom(calendarClass))\n \t  {\n \t    Constructor ctor = calendarClass.getConstructor(ctorArgTypes);\n-\t    return (Calendar) ctor.newInstance(new Object[] {zone, locale});\n+\t    return (Calendar) ctor.newInstance(new Object[] { zone, locale });\n \t  }\n       }\n     catch (ClassNotFoundException ex)\n@@ -504,9 +555,9 @@ public static synchronized Calendar getInstance(TimeZone zone, Locale locale)\n       {\n \texception = ex;\n       }\n-    \n-    throw new RuntimeException(\"Error instantiating calendar for locale \" +\n-\t\t\t       locale, exception);\n+\n+    throw new RuntimeException(\"Error instantiating calendar for locale \"\n+                               + locale, exception);\n   }\n \n   /**\n@@ -530,7 +581,7 @@ public static synchronized Locale[] getAvailableLocales()\n    * Converts the milliseconds since the epoch UTC\n    * (<code>time</code>) to time fields\n    * (<code>fields</code>). Override this method if you write your\n-   * own Calendar.  \n+   * own Calendar.\n    */\n   protected abstract void computeFields();\n \n@@ -541,7 +592,7 @@ public static synchronized Locale[] getAvailableLocales()\n    */\n   public final Date getTime()\n   {\n-    if (!isTimeSet)\n+    if (! isTimeSet)\n       computeTime();\n     return new Date(time);\n   }\n@@ -562,7 +613,7 @@ public final void setTime(Date date)\n    */\n   public long getTimeInMillis()\n   {\n-    if (!isTimeSet)\n+    if (! isTimeSet)\n       computeTime();\n     return time;\n   }\n@@ -575,9 +626,9 @@ public long getTimeInMillis()\n    */\n   public void setTimeInMillis(long time)\n   {\n+    clear();\n     this.time = time;\n     isTimeSet = true;\n-    computeFields();\n   }\n \n   /**\n@@ -593,14 +644,14 @@ public void setTimeInMillis(long time)\n   public int get(int field)\n   {\n     // If the requested field is invalid, force all fields to be recomputed.\n-    if (!isSet[field])\n+    if (! isSet[field])\n       areFieldsSet = false;\n     complete();\n     return fields[field];\n   }\n \n   /**\n-   * Gets the value of the specified field. This method doesn't \n+   * Gets the value of the specified field. This method doesn't\n    * recompute the fields, if they are invalid.\n    * @param field the time field. One of the time field constants.\n    * @return the value of the specified field, undefined if\n@@ -626,34 +677,88 @@ protected final int internalGet(int field)\n    */\n   public void set(int field, int value)\n   {\n+    if (isTimeSet)\n+      for (int i = 0; i < FIELD_COUNT; i++)\n+\tisSet[i] = false;\n     isTimeSet = false;\n     fields[field] = value;\n     isSet[field] = true;\n+\n+    // The five valid date patterns, in order of priority\n+    // 1  YEAR + MONTH + DAY_OF_MONTH\n+    // 2  YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n+    // 3  YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n+    // 4  YEAR + DAY_OF_YEAR\n+    // 5  YEAR + DAY_OF_WEEK + WEEK_OF_YEAR\n     switch (field)\n       {\n-      case YEAR:\n-      case MONTH:\n-      case DATE:\n+      case MONTH: // pattern 1,2 or 3\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tbreak;\n+      case DAY_OF_MONTH: // pattern 1\n+\tisSet[YEAR] = true;\n+\tisSet[MONTH] = true;\n+\tisSet[WEEK_OF_MONTH] = true;\n+\tisSet[DAY_OF_WEEK] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tbreak;\n+      case WEEK_OF_MONTH: // pattern 2\n+\tisSet[YEAR] = true;\n+\tisSet[MONTH] = true;\n+\tisSet[DAY_OF_WEEK] = true;\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n \tisSet[WEEK_OF_YEAR] = false;\n+\tbreak;\n+      case DAY_OF_WEEK_IN_MONTH: // pattern 3\n+\tisSet[YEAR] = true;\n+\tisSet[MONTH] = true;\n+\tisSet[DAY_OF_WEEK] = true;\n \tisSet[DAY_OF_YEAR] = false;\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tbreak;\n+      case DAY_OF_YEAR: // pattern 4\n+\tisSet[YEAR] = true;\n+\tisSet[MONTH] = false;\n \tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_MONTH] = false;\n \tisSet[DAY_OF_WEEK] = false;\n+\tisSet[WEEK_OF_YEAR] = false;\n+\tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n+\tbreak;\n+      case WEEK_OF_YEAR: // pattern 5\n+\tisSet[YEAR] = true;\n+\tisSet[DAY_OF_WEEK] = true;\n+\tisSet[MONTH] = false;\n+\tisSet[DAY_OF_MONTH] = false;\n+\tisSet[WEEK_OF_MONTH] = false;\n+\tisSet[DAY_OF_YEAR] = false;\n \tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n \tbreak;\n       case AM_PM:\n+\tisSet[HOUR] = true;\n \tisSet[HOUR_OF_DAY] = false;\n \tbreak;\n       case HOUR_OF_DAY:\n \tisSet[AM_PM] = false;\n \tisSet[HOUR] = false;\n \tbreak;\n       case HOUR:\n+\tisSet[AM_PM] = true;\n \tisSet[HOUR_OF_DAY] = false;\n \tbreak;\n+      case DST_OFFSET:\n+\texplicitDSTOffset = true;\n       }\n \n     // May have crossed over a DST boundary.\n-    if (field != DST_OFFSET && field != ZONE_OFFSET)\n+    if (! explicitDSTOffset && (field != DST_OFFSET && field != ZONE_OFFSET))\n       isSet[DST_OFFSET] = false;\n   }\n \n@@ -675,8 +780,10 @@ public final void set(int year, int month, int date)\n     isSet[WEEK_OF_MONTH] = false;\n     isSet[DAY_OF_WEEK] = false;\n     isSet[DAY_OF_WEEK_IN_MONTH] = false;\n+    isSet[ERA] = false;\n \n-    isSet[DST_OFFSET] = false;  // May have crossed a DST boundary.\n+    if (! explicitDSTOffset)\n+      isSet[DST_OFFSET] = false; // May have crossed a DST boundary.\n   }\n \n   /**\n@@ -706,8 +813,8 @@ public final void set(int year, int month, int date, int hour, int minute)\n    * @param minute the minute.\n    * @param second the second.\n    */\n-  public final void set(int year, int month, int date,\n-\t\t\tint hour, int minute, int second)\n+  public final void set(int year, int month, int date, int hour, int minute,\n+                        int second)\n   {\n     set(year, month, date, hour, minute);\n     fields[SECOND] = second;\n@@ -721,11 +828,15 @@ public final void clear()\n   {\n     isTimeSet = false;\n     areFieldsSet = false;\n+    int zoneOffs = zone.getRawOffset();\n+    int[] tempFields = \n+                       {\n+                         1, 1970, JANUARY, 1, 1, 1, 1, THURSDAY, 1, AM, 0, 0, 0,\n+                         0, 0, zoneOffs, 0\n+                       };\n+    fields = tempFields;\n     for (int i = 0; i < FIELD_COUNT; i++)\n-      {\n-\tisSet[i] = false;\n-\tfields[i] = 0;\n-      }\n+      isSet[i] = false;\n   }\n \n   /**\n@@ -737,10 +848,15 @@ public final void clear()\n    */\n   public final void clear(int field)\n   {\n+    int[] tempFields = \n+                       {\n+                         1, 1970, JANUARY, 1, 1, 1, 1, THURSDAY, 1, AM, 0, 0, 0,\n+                         0, 0, zone.getRawOffset(), 0\n+                       };\n     isTimeSet = false;\n     areFieldsSet = false;\n     isSet[field] = false;\n-    fields[field] = 0;\n+    fields[field] = tempFields[field];\n   }\n \n   /**\n@@ -757,31 +873,31 @@ public final boolean isSet(int field)\n \n   /**\n    * Fills any unset fields in the time field list\n-   * @return true if the specified field has a value.  \n+   * @return true if the specified field has a value.\n    */\n   protected void complete()\n   {\n-    if (!isTimeSet)\n+    if (! isTimeSet)\n       computeTime();\n-    if (!areFieldsSet)\n+    if (! areFieldsSet)\n       computeFields();\n   }\n \n   /**\n-   * Compares the given calendar with this.  \n+   * Compares the given calendar with this.\n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, that represents\n    * the same time (but doesn't necessary have the same fields).\n    */\n   public boolean equals(Object o)\n   {\n     return (o instanceof Calendar)\n-      && getTimeInMillis() == ((Calendar) o).getTimeInMillis();\n+           && getTimeInMillis() == ((Calendar) o).getTimeInMillis();\n   }\n \n   /**\n    * Returns a hash code for this calendar.\n-   * @return a hash code, which fullfits the general contract of \n+   * @return a hash code, which fullfits the general contract of\n    * <code>hashCode()</code>\n    */\n   public int hashCode()\n@@ -791,7 +907,7 @@ public int hashCode()\n   }\n \n   /**\n-   * Compares the given calendar with this.  \n+   * Compares the given calendar with this.\n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, and this calendar\n    * represents a smaller time than the calendar o.\n@@ -804,7 +920,7 @@ public boolean before(Object o)\n   }\n \n   /**\n-   * Compares the given calendar with this.  \n+   * Compares the given calendar with this.\n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, and this calendar\n    * represents a bigger time than the calendar o.\n@@ -831,11 +947,11 @@ public boolean after(Object o)\n   /**\n    * Rolls the specified time field up or down.  This means add one\n    * to the specified field, but don't change the other fields.  If\n-   * the maximum for this field is reached, start over with the \n+   * the maximum for this field is reached, start over with the\n    * minimum value.  <br>\n    *\n    * <strong>Note:</strong> There may be situation, where the other\n-   * fields must be changed, e.g rolling the month on May, 31. \n+   * fields must be changed, e.g rolling the month on May, 31.\n    * The date June, 31 is automatically converted to July, 1.\n    * @param field the time field. One of the time field constants.\n    * @param up the direction, true for up, false for down.\n@@ -854,7 +970,7 @@ public boolean after(Object o)\n    *\n    * @param field the time field. One of the time field constants.\n    * @param amount the amount to roll by, positive for rolling up,\n-   * negative for rolling down.  \n+   * negative for rolling down.\n    * @throws ArrayIndexOutOfBoundsException if the field is outside\n    *         the valid range.  The value of field must be >= 0 and\n    *         <= <code>FIELD_COUNT</code>.\n@@ -874,7 +990,6 @@ public void roll(int field, int amount)\n       }\n   }\n \n-\n   /**\n    * Sets the time zone to the specified value.\n    * @param zone the new time zone\n@@ -918,7 +1033,7 @@ public boolean isLenient()\n \n   /**\n    * Sets what the first day of week is.  This is used for\n-   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields.\n    * @param value the first day of week.  One of SUNDAY to SATURDAY.\n    */\n   public void setFirstDayOfWeek(int value)\n@@ -928,7 +1043,7 @@ public void setFirstDayOfWeek(int value)\n \n   /**\n    * Gets what the first day of week is.  This is used for\n-   * WEEK_OF_MONTH and WEEK_OF_YEAR fields. \n+   * WEEK_OF_MONTH and WEEK_OF_YEAR fields.\n    * @return the first day of week.  One of SUNDAY to SATURDAY.\n    */\n   public int getFirstDayOfWeek()\n@@ -972,7 +1087,6 @@ public int getMinimalDaysInFirstWeek()\n    */\n   public abstract int getMaximum(int field);\n \n-\n   /**\n    * Gets the greatest minimum value that is allowed for the specified field.\n    * @param field the time field. One of the time field constants.\n@@ -984,7 +1098,7 @@ public int getMinimalDaysInFirstWeek()\n    * Gets the smallest maximum value that is allowed for the\n    * specified field.  For example this is 28 for DAY_OF_MONTH.\n    * @param field the time field. One of the time field constants.\n-   * @return the least maximum value.  \n+   * @return the least maximum value.\n    */\n   public abstract int getLeastMaximum(int field);\n \n@@ -1000,16 +1114,15 @@ public int getMinimalDaysInFirstWeek()\n    */\n   public int getActualMinimum(int field)\n   {\n-    Calendar tmp = (Calendar)clone();\t// To avoid restoring state\n+    Calendar tmp = (Calendar) clone(); // To avoid restoring state\n     int min = tmp.getGreatestMinimum(field);\n     int end = tmp.getMinimum(field);\n     tmp.set(field, min);\n     for (; min > end; min--)\n       {\n-\ttmp.add(field, -1);\t// Try to get smaller\n+\ttmp.add(field, -1); // Try to get smaller\n \tif (tmp.get(field) != min - 1)\n-\t  break;\t\t// Done if not successful\n-\n+\t  break; // Done if not successful\n       }\n     return min;\n   }\n@@ -1018,15 +1131,15 @@ public int getActualMinimum(int field)\n    * Gets the actual maximum value that is allowed for the specified field.\n    * This value is dependent on the values of the other fields.\n    * @param field the time field. One of the time field constants.\n-   * @return the actual maximum value.  \n+   * @return the actual maximum value.\n    * @throws ArrayIndexOutOfBoundsException if the field is outside\n    *         the valid range.  The value of field must be >= 0 and\n    *         <= <code>FIELD_COUNT</code>.\n    * @since jdk1.2\n    */\n   public int getActualMaximum(int field)\n   {\n-    Calendar tmp = (Calendar)clone();\t// To avoid restoring state\n+    Calendar tmp = (Calendar) clone(); // To avoid restoring state\n     int max = tmp.getLeastMaximum(field);\n     int end = tmp.getMaximum(field);\n     tmp.set(field, max);\n@@ -1048,7 +1161,7 @@ public Object clone()\n       {\n \tCalendar cal = (Calendar) super.clone();\n \tcal.fields = (int[]) fields.clone();\n-\tcal.isSet = (boolean[])isSet.clone();\n+\tcal.isSet = (boolean[]) isSet.clone();\n \treturn cal;\n       }\n     catch (CloneNotSupportedException ex)\n@@ -1057,16 +1170,19 @@ public Object clone()\n       }\n   }\n \n-  private static final String[] fieldNames = {\n-    \",ERA=\", \",YEAR=\", \",MONTH=\",\n-    \",WEEK_OF_YEAR=\", \",WEEK_OF_MONTH=\",\n-    \",DAY_OF_MONTH=\", \",DAY_OF_YEAR=\", \",DAY_OF_WEEK=\",\n-    \",DAY_OF_WEEK_IN_MONTH=\",\n-    \",AM_PM=\", \",HOUR=\", \",HOUR_OF_DAY=\",\n-    \",MINUTE=\", \",SECOND=\", \",MILLISECOND=\",\n-    \",ZONE_OFFSET=\", \",DST_OFFSET=\"\n-  };\n-\n+  private static final String[] fieldNames = \n+                                             {\n+                                               \",ERA=\", \",YEAR=\", \",MONTH=\",\n+                                               \",WEEK_OF_YEAR=\",\n+                                               \",WEEK_OF_MONTH=\",\n+                                               \",DAY_OF_MONTH=\",\n+                                               \",DAY_OF_YEAR=\", \",DAY_OF_WEEK=\",\n+                                               \",DAY_OF_WEEK_IN_MONTH=\",\n+                                               \",AM_PM=\", \",HOUR=\",\n+                                               \",HOUR_OF_DAY=\", \",MINUTE=\",\n+                                               \",SECOND=\", \",MILLISECOND=\",\n+                                               \",ZONE_OFFSET=\", \",DST_OFFSET=\"\n+                                             };\n \n   /**\n    * Returns a string representation of this object.  It is mainly\n@@ -1109,7 +1225,7 @@ public String toString()\n    * says, that it could be omitted.  */\n   private void writeObject(ObjectOutputStream stream) throws IOException\n   {\n-    if (!isTimeSet)\n+    if (! isTimeSet)\n       computeTime();\n     stream.defaultWriteObject();\n   }\n@@ -1121,7 +1237,7 @@ private void readObject(ObjectInputStream stream)\n     throws IOException, ClassNotFoundException\n   {\n     stream.defaultReadObject();\n-    if (!isTimeSet)\n+    if (! isTimeSet)\n       computeTime();\n \n     if (serialVersionOnStream > 1)\n@@ -1130,7 +1246,6 @@ private void readObject(ObjectInputStream stream)\n \t// Sun wants to remove all fields from the stream someday\n \t// and will then increase the serialVersion number again.\n \t// We prepare to be compatible.\n-\n \tfields = new int[FIELD_COUNT];\n \tisSet = new boolean[FIELD_COUNT];\n \tareFieldsSet = false;"}, {"sha": "710dd56f58bd0d51afa0b0130f5111659ad77e04", "filename": "libjava/java/util/GregorianCalendar.java", "status": "modified", "additions": 437, "deletions": 374, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FGregorianCalendar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FGregorianCalendar.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -39,14 +39,15 @@\n \n package java.util;\n \n+\n /**\n  * <p>\n  * This class represents the Gregorian calendar, that is used in most\n  * countries all over the world.  It does also handle the Julian calendar\n  * for dates smaller than the date of the change to the Gregorian calendar.\n  * The Gregorian calendar differs from the Julian calendar by a different\n  * leap year rule (no leap year every 100 years, except if year is divisible\n- * by 400).  \n+ * by 400).\n  * </p>\n  * <p>\n  * This change date is different from country to country, and can be changed with\n@@ -136,7 +137,7 @@ public class GregorianCalendar extends Calendar\n    * Constant representing the era BC (Before Christ).\n    */\n   public static final int BC = 0;\n-  \n+\n   /**\n    * Constant representing the era AD (Anno Domini).\n    */\n@@ -164,43 +165,46 @@ public class GregorianCalendar extends Calendar\n   private static final String bundleName = \"gnu.java.locale.Calendar\";\n \n   /**\n-   * Retrieves the resource bundle.  The resources should be loaded\n-   * via this method only. Iff an application uses this method, the\n-   * resourcebundle is required.\n+   * Days in the epoch. Relative Jan 1, year '0' which is not a leap year.\n+   * (although there is no year zero, this does not matter.)\n+   * This is consistent with the formula:\n+   * = (year-1)*365L + ((year-1) >> 2)\n+   *\n+   * Plus the gregorian correction:\n+   *  Math.floor((year-1) / 400.) - Math.floor((year-1) / 100.);\n+   * For a correct julian date, the correction is -2 instead.\n    *\n-   * @param locale the locale in use for this calendar.\n-   * @return A resource bundle for the calendar for the specified locale.\n+   * The gregorian cutover in 1582 was 10 days, so by calculating the\n+   * correction from year zero, we have 15 non-leap days (even centuries)\n+   * minus 3 leap days (year 400,800,1200) = 12. Subtracting two corrects\n+   * this to the correct number 10.\n    */\n-  private static ResourceBundle getBundle(Locale locale) \n-  {\n-    return ResourceBundle.getBundle(bundleName, locale,\n-      ClassLoader.getSystemClassLoader());\n-  }\n+  private static final int EPOCH_DAYS = 719162;\n \n   /**\n    * Constructs a new GregorianCalender representing the current\n-   * time, using the default time zone and the default locale.  \n+   * time, using the default time zone and the default locale.\n    */\n   public GregorianCalendar()\n   {\n     this(TimeZone.getDefault(), Locale.getDefault());\n   }\n-  \n+\n   /**\n    * Constructs a new GregorianCalender representing the current\n-   * time, using the specified time zone and the default locale. \n-   * \n+   * time, using the specified time zone and the default locale.\n+   *\n    * @param zone a time zone.\n    */\n   public GregorianCalendar(TimeZone zone)\n   {\n     this(zone, Locale.getDefault());\n   }\n-  \n+\n   /**\n    * Constructs a new GregorianCalender representing the current\n    * time, using the default time zone and the specified locale.\n-   *  \n+   *\n    * @param locale a locale.\n    */\n   public GregorianCalendar(Locale locale)\n@@ -212,15 +216,30 @@ public GregorianCalendar(Locale locale)\n    * Constructs a new GregorianCalender representing the current\n    * time with the given time zone and the given locale.\n    *\n-   * @param zone a time zone.  \n-   * @param locale a locale.  \n+   * @param zone a time zone.\n+   * @param locale a locale.\n    */\n   public GregorianCalendar(TimeZone zone, Locale locale)\n+  {\n+    this(zone, locale, false);\n+    setTimeInMillis(System.currentTimeMillis());\n+    complete();\n+  }\n+\n+  /**\n+   * Common constructor that all constructors should call.\n+   * @param zone a time zone.\n+   * @param locale a locale.\n+   * @param unused unused parameter to make the signature differ from\n+   * the public constructor (TimeZone, Locale).\n+   */\n+  private GregorianCalendar(TimeZone zone, Locale locale, boolean unused)\n   {\n     super(zone, locale);\n-    ResourceBundle rb = getBundle(locale);\n+    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale,\n+                                                 ClassLoader\n+                                                 .getSystemClassLoader());\n     gregorianCutover = ((Date) rb.getObject(\"gregorianCutOver\")).getTime();\n-    setTimeInMillis(System.currentTimeMillis());\n   }\n \n   /**\n@@ -232,7 +251,7 @@ public GregorianCalendar(TimeZone zone, Locale locale)\n    */\n   public GregorianCalendar(int year, int month, int day)\n   {\n-    super();\n+    this(TimeZone.getDefault(), Locale.getDefault(), false);\n     set(year, month, day);\n   }\n \n@@ -248,7 +267,7 @@ public GregorianCalendar(int year, int month, int day)\n    */\n   public GregorianCalendar(int year, int month, int day, int hour, int minute)\n   {\n-    super();\n+    this(TimeZone.getDefault(), Locale.getDefault(), false);\n     set(year, month, day, hour, minute);\n   }\n \n@@ -264,10 +283,10 @@ public GregorianCalendar(int year, int month, int day, int hour, int minute)\n    * @param minute corresponds to the MINUTE time field.\n    * @param second corresponds to the SECOND time field.\n    */\n-  public GregorianCalendar(int year, int month, int day,\n-\t\t\t   int hour, int minute, int second)\n+  public GregorianCalendar(int year, int month, int day, int hour, int minute,\n+                           int second)\n   {\n-    super();\n+    this(TimeZone.getDefault(), Locale.getDefault(), false);\n     set(year, month, day, hour, minute, second);\n   }\n \n@@ -308,70 +327,22 @@ public final Date getGregorianChange()\n    * </p>\n    *\n    * @param year a year (use a negative value for BC).\n-   * @return true, if the given year is a leap year, false otherwise.  \n+   * @return true, if the given year is a leap year, false otherwise.\n    */\n   public boolean isLeapYear(int year)\n   {\n+    // Only years divisible by 4 can be leap years\n     if ((year & 3) != 0)\n-      // Only years divisible by 4 can be leap years\n       return false;\n \n-    // compute the linear day of the 29. February of that year.\n-    // The 13 is the number of days, that were omitted in the Gregorian\n-    // Calender until the epoch.\n-    int julianDay = (((year-1) * (365*4+1)) >> 2) + (31+29 - \n-        (((1970-1) * (365*4+1)) / 4 + 1 - 13));\n-    \n-    // If that day is smaller than the gregorianChange the julian\n-    // rule applies:  This is a leap year since it is divisible by 4.\n-    if (julianDay * (24 * 60 * 60 * 1000L) < gregorianCutover)\n+    // Is the leap-day a Julian date? Then it's a leap year\n+    if (! isGregorian(year, 31 + 29 - 1))\n       return true;\n \n+    // Apply gregorian rules otherwise\n     return ((year % 100) != 0 || (year % 400) == 0);\n   }\n \n-  /**\n-   * Get the linear time in milliseconds since the epoch.  If you\n-   * specify a nonpositive year it is interpreted as BC as\n-   * following: 0 is 1 BC, -1 is 2 BC and so on.  The date is\n-   * interpreted as gregorian if the change occurred before that date.\n-   *\n-   * @param year the year of the date.\n-   * @param dayOfYear the day of year of the date; 1 based.\n-   * @param millis the millisecond in that day.\n-   * @return the days since the epoch, may be negative.  \n-   */\n-  private long getLinearTime(int year, int dayOfYear, int millis)\n-  {\n-    // The 13 is the number of days, that were omitted in the Gregorian\n-    // Calendar until the epoch.\n-    // We shift right by 2 instead of dividing by 4, to get correct\n-    // results for negative years (and this is even more efficient).\n-    int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -\n-      ((1970 * (365 * 4 + 1)) / 4 + 1 - 13);\n-    long time = julianDay * (24 * 60 * 60 * 1000L) + millis;\n-\n-    if (time >= gregorianCutover)\n-      {\n-\t// subtract the days that are missing in gregorian calendar\n-\t// with respect to julian calendar.\n-\t//\n-\t// Okay, here we rely on the fact that the gregorian\n-\t// calendar was introduced in the AD era.  This doesn't work\n-\t// with negative years.\n-\t//\n-\t// The additional leap year factor accounts for the fact that\n-\t// a leap day is not seen on Jan 1 of the leap year.\n-\t// And on and after the leap day, the leap day has already been\n-\t// included in dayOfYear. \n-\tint gregOffset = (year / 400) - (year / 100) + 2;\n-\tif (isLeapYear (year, true))\n-\t  --gregOffset;\n-\ttime += gregOffset * (24 * 60 * 60 * 1000L);\n-      }\n-    return time;\n-  }\n-\n   /**\n    * Retrieves the day of the week corresponding to the specified\n    * day of the specified year.\n@@ -382,8 +353,8 @@ private long getLinearTime(int year, int dayOfYear, int millis)\n    */\n   private int getWeekDay(int year, int dayOfYear)\n   {\n-    int day =\n-      (int) (getLinearTime(year, dayOfYear, 0) / (24 * 60 * 60 * 1000L));\n+    boolean greg = isGregorian(year, dayOfYear);\n+    int day = (int) getLinearDay(year, dayOfYear, greg);\n \n     // The epoch was a thursday.\n     int weekday = (day + THURSDAY) % 7;\n@@ -393,235 +364,360 @@ private int getWeekDay(int year, int dayOfYear)\n   }\n \n   /**\n-   * <p>\n-   * Calculate the dayOfYear from the fields array.  \n-   * The relativeDays is used, to account for weeks that begin before\n-   * the Gregorian change and end after it.\n-   * </p>\n-   * <p>\n-   * We return two values.  The first is used to determine, if we\n-   * should use the Gregorian calendar or the Julian calendar, in order\n-   * to handle the change year. The second is a relative day after the given\n-   * day.  This is necessary for week calculation in the year in\n-   * which the Gregorian change occurs. \n-   * </p>\n-   * \n-   * @param year the year, negative for BC.\n-   * @return an array of two integer values, the first containing a reference\n-   * day in the current year, the second a relative count since this reference\n-   * day.  \n+   * Returns the day of the week for the first day of a given month (0..11)\n    */\n-  private int[] getDayOfYear(int year)\n+  private int getFirstDayOfMonth(int year, int month)\n   {\n-    if (isSet[MONTH])\n-      {\n-\tint dayOfYear;\n-\tif (fields[MONTH] > FEBRUARY)\n-\t  {\n+    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n \n-\t    // The months after February are regular:\n-\t    // 9 is an offset found by try and error.\n-\t    dayOfYear = (fields[MONTH] * (31 + 30 + 31 + 30 + 31) - 9) / 5;\n-\t    if (isLeapYear(year))\n-\t      dayOfYear++;\n-\t  }\n-\telse\n-\t    dayOfYear = 31 * fields[MONTH];\n+    if (month > 11)\n+      {\n+\tyear += (month / 12);\n+\tmonth = month % 12;\n+      }\n \n-\tif (isSet[DAY_OF_MONTH])\n+    if (month < 0)\n+      {\n+\tyear += (int) month / 12;\n+\tmonth = month % 12;\n+\tif (month < 0)\n \t  {\n-\t    return new int[]\n-\t    {\n-\t    dayOfYear + fields[DAY_OF_MONTH], 0};\n+\t    month += 12;\n+\t    year--;\n \t  }\n-\tif (isSet[WEEK_OF_MONTH] && isSet[DAY_OF_WEEK])\n-\t  {\n-\t    // the weekday of the first day in that month is:\n-\t    int weekday = getWeekDay(year, ++dayOfYear);\n+      }\n \n-\t    return new int[]\n-\t    {\n-\t      dayOfYear,\n-\t\t// the day of week in the first week\n-\t\t// (weeks starting on sunday) is:\n-\t      fields[DAY_OF_WEEK] - weekday +\n-\t\t// Now jump to the right week and correct the possible\n-\t\t// error made by assuming sunday is the first week day.\n-\t      7 * (fields[WEEK_OF_MONTH]\n-\t\t   + (fields[DAY_OF_WEEK] < getFirstDayOfWeek()? 0 : -1)\n-\t\t   + (weekday < getFirstDayOfWeek()? -1 : 0))};\n-\t  }\n-\tif (isSet[DAY_OF_WEEK] && isSet[DAY_OF_WEEK_IN_MONTH])\n-\t  {\n-\t    // the weekday of the first day in that month is:\n-\t    int weekday = getWeekDay(year, ++dayOfYear);\n-\t    return new int[] { \n-\t\t  dayOfYear,\n-\t\t  fields[DAY_OF_WEEK] - weekday +\n-\t\t  7 * (fields[DAY_OF_WEEK_IN_MONTH]\n-\t\t       + (fields[DAY_OF_WEEK] < weekday ? 0 : -1))};\n-\t  }\n+    int dayOfYear = dayCount[month] + 1;\n+    if (month > 1)\n+      if (isLeapYear(year))\n+\tdayOfYear++;\n+\n+    boolean greg = isGregorian(year, dayOfYear);\n+    int day = (int) getLinearDay(year, dayOfYear, greg);\n+\n+    // The epoch was a thursday.\n+    int weekday = (day + THURSDAY) % 7;\n+    if (weekday <= 0)\n+      weekday += 7;\n+    return weekday;\n+  }\n+\n+  /**\n+   * Takes a year, and a (zero based) day of year and determines\n+   * if it is gregorian or not.\n+   */\n+  private boolean isGregorian(int year, int dayOfYear)\n+  {\n+    int relativeDay = (year - 1) * 365 + ((year - 1) >> 2) + dayOfYear\n+                      - EPOCH_DAYS; // gregorian days from 1 to epoch.\n+    int gregFactor = (int) Math.floor((double) (year - 1) / 400.)\n+                     - (int) Math.floor((double) (year - 1) / 100.);\n+\n+    return ((relativeDay + gregFactor) * 60L * 60L * 24L * 1000L >= gregorianCutover);\n+  }\n+\n+  /**\n+   * Check set fields for validity, without leniency.\n+   *\n+   * @throws IllegalArgumentException if a field is invalid\n+   */\n+  private void nonLeniencyCheck() throws IllegalArgumentException\n+  {\n+    int[] month_days = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n+    int year = fields[YEAR];\n+    int month = fields[MONTH];\n+    int leap = isLeapYear(year) ? 1 : 0;\n+\n+    if (isSet[ERA] && fields[ERA] != AD && fields[ERA] != BC)\n+      throw new IllegalArgumentException(\"Illegal ERA.\");\n+    if (isSet[YEAR] && fields[YEAR] < 1)\n+      throw new IllegalArgumentException(\"Illegal YEAR.\");\n+    if (isSet[MONTH] && (month < 0 || month > 11))\n+      throw new IllegalArgumentException(\"Illegal MONTH.\");\n+    if (isSet[WEEK_OF_YEAR])\n+      {\n+\tint daysInYear = 365 + leap;\n+\tdaysInYear += (getFirstDayOfMonth(year, 0) - 1); // pad first week\n+\tint last = getFirstDayOfMonth(year, 11) + 4;\n+\tif (last > 7)\n+\t  last -= 7;\n+\tdaysInYear += 7 - last;\n+\tint weeks = daysInYear / 7;\n+\tif (fields[WEEK_OF_YEAR] < 1 || fields[WEEK_OF_YEAR] > weeks)\n+\t  throw new IllegalArgumentException(\"Illegal WEEK_OF_YEAR.\");\n       }\n \n-    // MONTH + something did not succeed.\n-    if (isSet[DAY_OF_YEAR])\n+    if (isSet[WEEK_OF_MONTH])\n       {\n-\treturn new int[] {0, fields[DAY_OF_YEAR]};\n+\tint weeks = (month == 1 && leap == 0) ? 4 : 5;\n+\tif (fields[WEEK_OF_MONTH] < 1 || fields[WEEK_OF_MONTH] > weeks)\n+\t  throw new IllegalArgumentException(\"Illegal WEEK_OF_MONTH.\");\n       }\n-      \n-    if (isSet[DAY_OF_WEEK] && isSet[WEEK_OF_YEAR])\n+\n+    if (isSet[DAY_OF_MONTH])\n+      if (fields[DAY_OF_MONTH] < 1\n+          || fields[DAY_OF_MONTH] > month_days[month]\n+          + ((month == 1) ? leap : 0))\n+\tthrow new IllegalArgumentException(\"Illegal DAY_OF_MONTH.\");\n+\n+    if (isSet[DAY_OF_YEAR]\n+        && (fields[DAY_OF_YEAR] < 1 || fields[DAY_OF_YEAR] > 365 + leap))\n+      throw new IllegalArgumentException(\"Illegal DAY_OF_YEAR.\");\n+\n+    if (isSet[DAY_OF_WEEK]\n+        && (fields[DAY_OF_WEEK] < 1 || fields[DAY_OF_WEEK] > 7))\n+      throw new IllegalArgumentException(\"Illegal DAY_OF_WEEK.\");\n+\n+    if (isSet[DAY_OF_WEEK_IN_MONTH])\n       {\n-\tint dayOfYear = getMinimalDaysInFirstWeek();\n-\t// the weekday of the day, that begins the first week \n-\t// in that year is:\n-\tint weekday = getWeekDay(year, dayOfYear);\n-\n-\treturn new int[] { \n-\t    dayOfYear,\n-\t      // the day of week in the first week\n-\t      // (weeks starting on sunday) is:\n-\t    fields[DAY_OF_WEEK] - weekday\n-\t      // Now jump to the right week and correct the possible\n-\t      // error made by assuming sunday is the first week day.\n-\t    + 7 * (fields[WEEK_OF_YEAR]\n-\t\t   + (fields[DAY_OF_WEEK] < getFirstDayOfWeek()? 0 : -1)\n-\t\t   + (weekday < getFirstDayOfWeek()? -1 : 0))};\n+\tint weeks = (month == 1 && leap == 0) ? 4 : 5;\n+\tif (fields[DAY_OF_WEEK_IN_MONTH] < -weeks\n+\t    || fields[DAY_OF_WEEK_IN_MONTH] > weeks)\n+\t  throw new IllegalArgumentException(\"Illegal DAY_OF_WEEK_IN_MONTH.\");\n       }\n \n-    // As last resort return Jan, 1st.\n-    return new int[] {1, 0};\n+    if (isSet[AM_PM] && fields[AM_PM] != AM && fields[AM_PM] != PM)\n+      throw new IllegalArgumentException(\"Illegal AM_PM.\");\n+    if (isSet[HOUR] && (fields[HOUR] < 0 || fields[HOUR] > 12))\n+      throw new IllegalArgumentException(\"Illegal HOUR.\");\n+    if (isSet[HOUR_OF_DAY]\n+        && (fields[HOUR_OF_DAY] < 0 || fields[HOUR_OF_DAY] > 23))\n+      throw new IllegalArgumentException(\"Illegal HOUR_OF_DAY.\");\n+    if (isSet[MINUTE] && (fields[MINUTE] < 0 || fields[MINUTE] > 59))\n+      throw new IllegalArgumentException(\"Illegal MINUTE.\");\n+    if (isSet[SECOND] && (fields[SECOND] < 0 || fields[SECOND] > 59))\n+      throw new IllegalArgumentException(\"Illegal SECOND.\");\n+    if (isSet[MILLISECOND]\n+        && (fields[MILLISECOND] < 0 || fields[MILLISECOND] > 999))\n+      throw new IllegalArgumentException(\"Illegal MILLISECOND.\");\n+    if (isSet[ZONE_OFFSET]\n+        && (fields[ZONE_OFFSET] < -12 * 60 * 60 * 1000L\n+        || fields[ZONE_OFFSET] > 12 * 60 * 60 * 1000L))\n+      throw new IllegalArgumentException(\"Illegal ZONE_OFFSET.\");\n+    if (isSet[DST_OFFSET]\n+        && (fields[DST_OFFSET] < -12 * 60 * 60 * 1000L\n+        || fields[DST_OFFSET] > 12 * 60 * 60 * 1000L))\n+      throw new IllegalArgumentException(\"Illegal DST_OFFSET.\");\n   }\n \n   /**\n    * Converts the time field values (<code>fields</code>) to\n-   * milliseconds since the epoch UTC (<code>time</code>). \n+   * milliseconds since the epoch UTC (<code>time</code>).\n    *\n    * @throws IllegalArgumentException if any calendar fields\n    *         are invalid.\n    */\n   protected synchronized void computeTime()\n   {\n-    int era = isSet[ERA] ? fields[ERA] : AD;\n-    int year = isSet[YEAR] ? fields[YEAR] : 1970;\n-    if (era == BC)\n-      year = 1 - year;\n+    int millisInDay = 0;\n+    int era = fields[ERA];\n+    int year = fields[YEAR];\n+    int month = fields[MONTH];\n+    int day = fields[DAY_OF_MONTH];\n+\n+    int minute = fields[MINUTE];\n+    int second = fields[SECOND];\n+    int millis = fields[MILLISECOND];\n+    int[] month_days = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n+    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n+    int hour = 0;\n \n-    int[] daysOfYear = getDayOfYear(year);\n+    if (! isLenient())\n+      nonLeniencyCheck();\n \n-    int hour = 0;\n-    if (isSet[HOUR_OF_DAY])\n-      hour = fields[HOUR_OF_DAY];\n-    else if (isSet[HOUR])\n+    if (! isSet[MONTH] && (! isSet[DAY_OF_WEEK] || isSet[WEEK_OF_YEAR]))\n+      {\n+\t// 5: YEAR + DAY_OF_WEEK + WEEK_OF_YEAR\n+\tif (isSet[WEEK_OF_YEAR])\n+\t  {\n+\t    int first = getFirstDayOfMonth(year, 0);\n+\t    int offs = 1;\n+\t    int daysInFirstWeek = getFirstDayOfWeek() - first;\n+\t    if (daysInFirstWeek <= 0)\n+\t      daysInFirstWeek += 7;\n+\n+\t    if (daysInFirstWeek < getMinimalDaysInFirstWeek())\n+\t      offs += daysInFirstWeek;\n+\t    else\n+\t      offs -= 7 - daysInFirstWeek;\n+\t    month = 0;\n+\t    day = offs + 7 * (fields[WEEK_OF_YEAR] - 1);\n+\t    offs = fields[DAY_OF_WEEK] - getFirstDayOfWeek();\n+\n+\t    if (offs < 0)\n+\t      offs += 7;\n+\t    day += offs;\n+\t  }\n+\telse\n+\t  {\n+\t    // 4:  YEAR + DAY_OF_YEAR\n+\t    month = 0;\n+\t    day = fields[DAY_OF_YEAR];\n+\t  }\n+      }\n+    else\n+      {\n+\tif (isSet[DAY_OF_WEEK])\n+\t  {\n+\t    int first = getFirstDayOfMonth(year, month);\n+\n+\t    // 3: YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n+\t    if (isSet[DAY_OF_WEEK_IN_MONTH])\n+\t      {\n+\t\tint offs = fields[DAY_OF_WEEK] - first;\n+\t\tif (offs < 0)\n+\t\t  offs += 7;\n+\t\tday = 1 + 7 * (fields[DAY_OF_WEEK_IN_MONTH] - 1);\n+\t\tday += offs;\n+\t      }\n+\t    else\n+\t      { // 2: YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n+\t\tint offs = 1;\n+\t\tint daysInFirstWeek = getFirstDayOfWeek() - first;\n+\t\tif (daysInFirstWeek <= 0)\n+\t\t  daysInFirstWeek += 7;\n+\n+\t\tif (daysInFirstWeek < getMinimalDaysInFirstWeek())\n+\t\t  offs += daysInFirstWeek;\n+\t\telse\n+\t\t  offs -= 7 - daysInFirstWeek;\n+\n+\t\tday = offs + 7 * (fields[WEEK_OF_MONTH] - 1);\n+\t\toffs = fields[DAY_OF_WEEK] - getFirstDayOfWeek();\n+\t\tif (offs < 0)\n+\t\t  offs += 7;\n+\t\tday += offs;\n+\t      }\n+\t  }\n+\n+\t// 1:  YEAR + MONTH + DAY_OF_MONTH\n+      }\n+    if (era == BC && year > 0)\n+      year = 1 - year;\n+\n+    // rest of code assumes day/month/year set\n+    // should negative BC years be AD?\n+    // get the hour (but no check for validity)\n+    if (isSet[HOUR])\n       {\n \thour = fields[HOUR];\n-        if (isSet[AM_PM] && fields[AM_PM] == PM)\n+\tif (fields[AM_PM] == PM)\n \t  if (hour != 12) /* not Noon */\n-            hour += 12;\n+\t    hour += 12;\n \t/* Fix the problem of the status of 12:00 AM (midnight). */\n-\tif (isSet[AM_PM] && fields[AM_PM] == AM && hour == 12)\n+\tif (fields[AM_PM] == AM && hour == 12)\n \t  hour = 0;\n       }\n+    else\n+      hour = fields[HOUR_OF_DAY];\n \n-    int minute = isSet[MINUTE] ? fields[MINUTE] : 0;\n-    int second = isSet[SECOND] ? fields[SECOND] : 0;\n-    int millis = isSet[MILLISECOND] ? fields[MILLISECOND] : 0;\n-    int millisInDay;\n+    // Read the era,year,month,day fields and convert as appropriate.\n+    // Calculate number of milliseconds into the day\n+    // This takes care of both h, m, s, ms over/underflows.\n+    long allMillis = (((hour * 60L) + minute) * 60L + second) * 1000L + millis;\n+    day += allMillis / (24 * 60 * 60 * 1000L);\n+    millisInDay = (int) (allMillis % (24 * 60 * 60 * 1000L));\n \n-    if (isLenient())\n+    if (month < 0)\n       {\n-\t// prevent overflow\n-\tlong allMillis = (((hour * 60L) + minute) * 60L + second) * 1000L\n-\t  + millis;\n-\tdaysOfYear[1] += allMillis / (24 * 60 * 60 * 1000L);\n-\tmillisInDay = (int) (allMillis % (24 * 60 * 60 * 1000L));\n+\tyear += (int) month / 12;\n+\tmonth = month % 12;\n+\tif (month < 0)\n+\t  {\n+\t    month += 12;\n+\t    year--;\n+\t  }\n       }\n-    else\n+    if (month > 11)\n       {\n-\tif (hour < 0 || hour >= 24 || minute < 0 || minute > 59\n-\t    || second < 0 || second > 59 || millis < 0 || millis >= 1000)\n-\t  throw new IllegalArgumentException();\n-\tmillisInDay = (((hour * 60) + minute) * 60 + second) * 1000 + millis;\n+\tyear += (month / 12);\n+\tmonth = month % 12;\n       }\n-    time = getLinearTime(year, daysOfYear[0], millisInDay);\n \n-    // Add the relative days after calculating the linear time, to\n-    // get right behaviour when jumping over the gregorianCutover.\n-    time += daysOfYear[1] * (24 * 60 * 60 * 1000L);\n+    month_days[1] = isLeapYear(year) ? 29 : 28;\n \n+    while (day <= 0)\n+      {\n+\tif (month == 0)\n+\t  {\n+\t    year--;\n+\t    month_days[1] = isLeapYear(year) ? 29 : 28;\n+\t  }\n+\tmonth = (month + 11) % 12;\n+\tday += month_days[month];\n+      }\n+    while (day > month_days[month])\n+      {\n+\tday -= (month_days[month]);\n+\tmonth = (month + 1) % 12;\n+\tif (month == 0)\n+\t  {\n+\t    year++;\n+\t    month_days[1] = isLeapYear(year) ? 29 : 28;\n+\t  }\n+      }\n \n-    TimeZone zone = getTimeZone();\n-    int rawOffset = isSet[ZONE_OFFSET]\n-      ? fields[ZONE_OFFSET] : zone.getRawOffset();\n-\n-    int dayOfYear = daysOfYear[0] + daysOfYear[1];\n-    // This formula isn't right, so check for month as a quick fix.\n-    // It doesn't compensate for leap years and puts day 30 in month 1\n-    // instead of month 0.\n-    int month = isSet[MONTH]\n-\t? fields[MONTH] : (dayOfYear * 5 + 3) / (31 + 30 + 31 + 30 + 31);\n-    // This formula isn't right, so check for day as a quick fix.  It\n-    // doesn't compensate for leap years, either.\n-    int day = isSet[DAY_OF_MONTH] ? fields[DAY_OF_MONTH]\n-\t: (6 + (dayOfYear * 5 + 3) % (31 + 30 + 31 + 30 + 31)) / 5;\n-    int weekday = ((int) (time / (24 * 60 * 60 * 1000L)) + THURSDAY) % 7;\n+    // ok, by here we have valid day,month,year,era and millisinday\n+    int dayOfYear = dayCount[month] + day - 1; // (day starts on 1)\n+    if (isLeapYear(year) && month > 1)\n+      dayOfYear++;\n+\n+    int relativeDay = (year - 1) * 365 + ((year - 1) >> 2) + dayOfYear\n+                      - EPOCH_DAYS; // gregorian days from 1 to epoch.\n+    int gregFactor = (int) Math.floor((double) (year - 1) / 400.)\n+                     - (int) Math.floor((double) (year - 1) / 100.);\n+\n+    if ((relativeDay + gregFactor) * 60L * 60L * 24L * 1000L >= gregorianCutover)\n+      relativeDay += gregFactor;\n+    else\n+      relativeDay -= 2;\n+\n+    time = relativeDay * (24 * 60 * 60 * 1000L) + millisInDay;\n+\n+    // the epoch was a Thursday.\n+    int weekday = (int) (relativeDay + THURSDAY) % 7;\n     if (weekday <= 0)\n       weekday += 7;\n-    int dstOffset = isSet[DST_OFFSET]\n-      ? fields[DST_OFFSET] : (zone.getOffset((year < 0) ? BC : AD,\n-\t\t\t\t\t     (year < 0) ? 1 - year : year,\n-\t\t\t\t\t     month, day, weekday, millisInDay)\n-\t\t\t      - zone.getRawOffset());\n-    time -= rawOffset + dstOffset;\n-    isTimeSet = true;\n-  }\n+    fields[DAY_OF_WEEK] = weekday;\n \n-  /**\n-   * <p>\n-   * Determines if the given year is a leap year.  \n-   * </p>\n-   * <p>\n-   * To specify a year in the BC era, use a negative value calculated\n-   * as 1 - y, where y is the required year in BC.  So, 1 BC is 0,\n-   * 2 BC is -1, 3 BC is -2, etc.\n-   * </p>\n-   *\n-   * @param year a year (use a negative value for BC).\n-   * @param gregorian if true, use the gregorian leap year rule.\n-   * @return true, if the given year is a leap year, false otherwise.  \n-   */\n-  private boolean isLeapYear(int year, boolean gregorian)\n-  {\n-    if ((year & 3) != 0)\n-      // Only years divisible by 4 can be leap years\n-      return false;\n+    // Time zone corrections.\n+    TimeZone zone = getTimeZone();\n+    int rawOffset = isSet[ZONE_OFFSET] ? fields[ZONE_OFFSET]\n+                                       : zone.getRawOffset();\n \n-    if (!gregorian)\n-      return true;\n+    int dstOffset = isSet[DST_OFFSET] ? fields[DST_OFFSET]\n+                                      : (zone.getOffset((year < 0) ? BC : AD,\n+                                                        (year < 0) ? 1 - year\n+                                                                   : year,\n+                                                        month, day, weekday,\n+                                                        millisInDay)\n+                                      - zone.getRawOffset());\n \n-    // We rely on AD area here.\n-    return ((year % 100) != 0 || (year % 400) == 0);\n+    time -= rawOffset + dstOffset;\n+\n+    isTimeSet = true;\n   }\n \n   /**\n    * Get the linear day in days since the epoch, using the\n    * Julian or Gregorian calendar as specified.  If you specify a\n    * nonpositive year it is interpreted as BC as following: 0 is 1\n-   * BC, -1 is 2 BC and so on.  \n+   * BC, -1 is 2 BC and so on.\n    *\n    * @param year the year of the date.\n    * @param dayOfYear the day of year of the date; 1 based.\n    * @param gregorian <code>true</code>, if we should use the Gregorian rules.\n    * @return the days since the epoch, may be negative.\n    */\n-  private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n-  {\n-    // The 13 is the number of days, that were omitted in the Gregorian\n-    // Calender until the epoch.\n-    // We shift right by 2 instead of dividing by 4, to get correct\n-    // results for negative years (and this is even more efficient).\n-    int julianDay = ((year * (365 * 4 + 1)) >> 2) + dayOfYear -\n-      ((1970 * (365 * 4 + 1)) / 4 + 1 - 13);\n-\n+   public long getLinearDay(int year, int dayOfYear, boolean gregorian)\n+    {\n+     // The 13 is the number of days, that were omitted in the Gregorian\n+     // Calender until the epoch.\n+     // We shift right by 2 instead of dividing by 4, to get correct\n+     // results for negative years (and this is even more efficient).\n+     long julianDay = (year - 1) * 365L + ((year - 1) >> 2) + (dayOfYear - 1)\n+                      - EPOCH_DAYS; // gregorian days from 1 to epoch.\n+ \n     if (gregorian)\n       {\n \t// subtract the days that are missing in gregorian calendar\n@@ -633,11 +729,13 @@ private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n \t//\n \t// The additional leap year factor accounts for the fact that\n \t// a leap day is not seen on Jan 1 of the leap year.\n-\tint gregOffset = (year / 400) - (year / 100) + 2;\n-\tif (isLeapYear (year, true) && dayOfYear < 31 + 29)\n-\t  --gregOffset;\n-\tjulianDay += gregOffset;\n+\tint gregOffset = (int) Math.floor((double) (year - 1) / 400.)\n+\t                 - (int) Math.floor((double) (year - 1) / 100.);\n+\n+\treturn julianDay + gregOffset;\n       }\n+    else\n+      julianDay -= 2;\n     return julianDay;\n   }\n \n@@ -646,26 +744,27 @@ private int getLinearDay(int year, int dayOfYear, boolean gregorian)\n    * day_of_year, day_of_month, day_of_week, and writes the result\n    * into the fields array.\n    *\n-   * @param day the linear day.  \n+   * @param day the linear day.\n    * @param gregorian true, if we should use Gregorian rules.\n    */\n-  private void calculateDay(int day, boolean gregorian)\n+  private void calculateDay(int[] fields, long day, boolean gregorian)\n   {\n-    // the epoch is a Thursday.\n-    int weekday = (day + THURSDAY) % 7;\n+    // the epoch was a Thursday.\n+    int weekday = (int) (day + THURSDAY) % 7;\n     if (weekday <= 0)\n       weekday += 7;\n     fields[DAY_OF_WEEK] = weekday;\n \n     // get a first approximation of the year.  This may be one \n     // year too big.\n-    int year = 1970 + (gregorian\n-\t\t       ? ((day - 100) * 400) / (365 * 400 + 100 - 4 + 1)\n-\t\t       : ((day - 100) * 4) / (365 * 4 + 1));\n+    int year = 1970\n+               + (int) (gregorian\n+                        ? ((day - 100L) * 400L) / (365L * 400L + 100L - 4L\n+                        + 1L) : ((day - 100L) * 4L) / (365L * 4L + 1L));\n     if (day >= 0)\n       year++;\n \n-    int firstDayOfYear = getLinearDay(year, 1, gregorian);\n+    long firstDayOfYear = getLinearDay(year, 1, gregorian);\n \n     // Now look in which year day really lies.\n     if (day < firstDayOfYear)\n@@ -674,9 +773,9 @@ private void calculateDay(int day, boolean gregorian)\n \tfirstDayOfYear = getLinearDay(year, 1, gregorian);\n       }\n \n-    day -= firstDayOfYear - 1;\t// day of year,  one based.\n+    day -= firstDayOfYear - 1; // day of year,  one based.\n \n-    fields[DAY_OF_YEAR] = day;\n+    fields[DAY_OF_YEAR] = (int) day;\n     if (year <= 0)\n       {\n \tfields[ERA] = BC;\n@@ -688,16 +787,16 @@ private void calculateDay(int day, boolean gregorian)\n \tfields[YEAR] = year;\n       }\n \n-    int leapday = isLeapYear(year, gregorian) ? 1 : 0;\n+    int leapday = isLeapYear(year) ? 1 : 0;\n     if (day <= 31 + 28 + leapday)\n       {\n-\tfields[MONTH] = day / 32;\t// 31->JANUARY, 32->FEBRUARY\n-\tfields[DAY_OF_MONTH] = day - 31 * fields[MONTH];\n+\tfields[MONTH] = (int) day / 32; // 31->JANUARY, 32->FEBRUARY\n+\tfields[DAY_OF_MONTH] = (int) day - 31 * fields[MONTH];\n       }\n     else\n       {\n \t// A few more magic formulas\n-\tint scaledDay = (day - leapday) * 5 + 8;\n+\tint scaledDay = ((int) day - leapday) * 5 + 8;\n \tfields[MONTH] = scaledDay / (31 + 30 + 31 + 30 + 31);\n \tfields[DAY_OF_MONTH] = (scaledDay % (31 + 30 + 31 + 30 + 31)) / 5 + 1;\n       }\n@@ -716,25 +815,26 @@ protected synchronized void computeFields()\n     fields[ZONE_OFFSET] = zone.getRawOffset();\n     long localTime = time + fields[ZONE_OFFSET];\n \n-    int day = (int) (localTime / (24 * 60 * 60 * 1000L));\n+    long day = localTime / (24 * 60 * 60 * 1000L);\n     int millisInDay = (int) (localTime % (24 * 60 * 60 * 1000L));\n+\n     if (millisInDay < 0)\n       {\n \tmillisInDay += (24 * 60 * 60 * 1000);\n \tday--;\n       }\n \n-    calculateDay(day, gregorian);\n-    fields[DST_OFFSET] =\n-      zone.getOffset(fields[ERA], fields[YEAR], fields[MONTH],\n-\t\t     fields[DAY_OF_MONTH], fields[DAY_OF_WEEK],\n-\t\t     millisInDay) - fields[ZONE_OFFSET];\n+    calculateDay(fields, day, gregorian);\n+    fields[DST_OFFSET] = zone.getOffset(fields[ERA], fields[YEAR],\n+                                        fields[MONTH], fields[DAY_OF_MONTH],\n+                                        fields[DAY_OF_WEEK], millisInDay)\n+                         - fields[ZONE_OFFSET];\n \n     millisInDay += fields[DST_OFFSET];\n     if (millisInDay >= 24 * 60 * 60 * 1000)\n       {\n \tmillisInDay -= 24 * 60 * 60 * 1000;\n-\tcalculateDay(++day, gregorian);\n+\tcalculateDay(fields, ++day, gregorian);\n       }\n \n     fields[DAY_OF_WEEK_IN_MONTH] = (fields[DAY_OF_MONTH] + 6) / 7;\n@@ -749,13 +849,12 @@ protected synchronized void computeFields()\n     // Do the Correction: getMinimalDaysInFirstWeek() is always in the \n     // first week.\n     int minDays = getMinimalDaysInFirstWeek();\n-    int firstWeekday =\n-      (7 + getWeekDay(fields[YEAR], minDays) - getFirstDayOfWeek()) % 7;\n+    int firstWeekday = (7 + getWeekDay(fields[YEAR], minDays)\n+                       - getFirstDayOfWeek()) % 7;\n     if (minDays - firstWeekday < 1)\n       weekOfYear++;\n     fields[WEEK_OF_YEAR] = weekOfYear;\n \n-\n     int hourOfDay = millisInDay / (60 * 60 * 1000);\n     fields[AM_PM] = (hourOfDay < 12) ? AM : PM;\n     int hour = hourOfDay % 12;\n@@ -767,22 +866,15 @@ protected synchronized void computeFields()\n     fields[SECOND] = millisInDay / (1000);\n     fields[MILLISECOND] = millisInDay % 1000;\n \n-\n-    areFieldsSet = isSet[ERA] = isSet[YEAR] = isSet[MONTH] =\n-      isSet[WEEK_OF_YEAR] = isSet[WEEK_OF_MONTH] =\n-      isSet[DAY_OF_MONTH] = isSet[DAY_OF_YEAR] = isSet[DAY_OF_WEEK] =\n-      isSet[DAY_OF_WEEK_IN_MONTH] = isSet[AM_PM] = isSet[HOUR] =\n-      isSet[HOUR_OF_DAY] = isSet[MINUTE] = isSet[SECOND] =\n-      isSet[MILLISECOND] = isSet[ZONE_OFFSET] = isSet[DST_OFFSET] = true;\n-\n+    areFieldsSet = isSet[ERA] = isSet[YEAR] = isSet[MONTH] = isSet[WEEK_OF_YEAR] = isSet[WEEK_OF_MONTH] = isSet[DAY_OF_MONTH] = isSet[DAY_OF_YEAR] = isSet[DAY_OF_WEEK] = isSet[DAY_OF_WEEK_IN_MONTH] = isSet[AM_PM] = isSet[HOUR] = isSet[HOUR_OF_DAY] = isSet[MINUTE] = isSet[SECOND] = isSet[MILLISECOND] = isSet[ZONE_OFFSET] = isSet[DST_OFFSET] = true;\n   }\n \n   /**\n    * Compares the given calendar with this.  An object, o, is\n    * equivalent to this if it is also a <code>GregorianCalendar</code>\n    * with the same time since the epoch under the same conditions\n    * (same change date and same time zone).\n-   *  \n+   *\n    * @param o the object to that we should compare.\n    * @return true, if the given object is a calendar, that represents\n    * the same time (but doesn't necessarily have the same fields).\n@@ -794,48 +886,20 @@ protected synchronized void computeFields()\n    */\n   public boolean equals(Object o)\n   {\n-    if (!(o instanceof GregorianCalendar))\n+    if (! (o instanceof GregorianCalendar))\n       return false;\n \n     GregorianCalendar cal = (GregorianCalendar) o;\n     return (cal.getTimeInMillis() == getTimeInMillis());\n   }\n \n-//     /**\n-//      * Compares the given calender with this.  \n-//      * @param o the object to that we should compare.\n-//      * @return true, if the given object is a calendar, and this calendar\n-//      * represents a smaller time than the calender o.\n-//      */\n-//     public boolean before(Object o) {\n-//         if (!(o instanceof GregorianCalendar))\n-//             return false;\n-\n-//         GregorianCalendar cal = (GregorianCalendar) o;\n-//         return (cal.getTimeInMillis() < getTimeInMillis());\n-//     }\n-\n-//     /**\n-//      * Compares the given calender with this.  \n-//      * @param o the object to that we should compare.\n-//      * @return true, if the given object is a calendar, and this calendar\n-//      * represents a bigger time than the calender o.\n-//      */\n-//     public boolean after(Object o) {\n-//         if (!(o instanceof GregorianCalendar))\n-//             return false;\n-\n-//         GregorianCalendar cal = (GregorianCalendar) o;\n-//         return (cal.getTimeInMillis() > getTimeInMillis());\n-//     }\n-\n   /**\n    * Adds the specified amount of time to the given time field.  The\n    * amount may be negative to subtract the time.  If the field overflows\n    * it does what you expect: Jan, 25 + 10 Days is Feb, 4.\n    * @param field one of the time field constants.\n    * @param amount the amount of time to add.\n-   * @exception IllegalArgumentException if <code>field</code> is \n+   * @exception IllegalArgumentException if <code>field</code> is\n    *   <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code>, or invalid; or\n    *   if <code>amount</code> contains an out-of-range value and the calendar\n    *   is not in lenient mode.\n@@ -859,78 +923,76 @@ public void add(int field, int amount)\n \t    fields[MONTH] += 12;\n \t    fields[YEAR]--;\n \t  }\n-\tisTimeSet = false;\n \tint maxDay = getActualMaximum(DAY_OF_MONTH);\n \tif (fields[DAY_OF_MONTH] > maxDay)\n \t  {\n \t    fields[DAY_OF_MONTH] = maxDay;\n-\t    isTimeSet = false;\n \t  }\n+\tset(YEAR, fields[YEAR]);\n+\tset(MONTH, fields[MONTH]);\n \tbreak;\n       case DAY_OF_MONTH:\n       case DAY_OF_YEAR:\n       case DAY_OF_WEEK:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (24 * 60 * 60 * 1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case WEEK_OF_YEAR:\n       case WEEK_OF_MONTH:\n       case DAY_OF_WEEK_IN_MONTH:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (7 * 24 * 60 * 60 * 1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case AM_PM:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (12 * 60 * 60 * 1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case HOUR:\n       case HOUR_OF_DAY:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (60 * 60 * 1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case MINUTE:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (60 * 1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case SECOND:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount * (1000L);\n \tareFieldsSet = false;\n \tbreak;\n       case MILLISECOND:\n-\tif (!isTimeSet)\n+\tif (! isTimeSet)\n \t  computeTime();\n \ttime += amount;\n \tareFieldsSet = false;\n \tbreak;\n       case ZONE_OFFSET:\n-      case DST_OFFSET:\n-      default:\n+      case DST_OFFSET:default:\n \tthrow new IllegalArgumentException(\"Invalid or unknown field\");\n       }\n   }\n \n-\n   /**\n    * Rolls the specified time field up or down.  This means add one\n    * to the specified field, but don't change the other fields.  If\n-   * the maximum for this field is reached, start over with the \n-   * minimum value.  \n+   * the maximum for this field is reached, start over with the\n+   * minimum value.\n    *\n    * <strong>Note:</strong> There may be situation, where the other\n-   * fields must be changed, e.g rolling the month on May, 31. \n-   * The date June, 31 is automatically converted to July, 1. \n+   * fields must be changed, e.g rolling the month on May, 31.\n+   * The date June, 31 is automatically converted to July, 1.\n    * This requires lenient settings.\n    *\n    * @param field the time field. One of the time field constants.\n@@ -972,7 +1034,6 @@ private void cleanUpAfterRoll(int field, int delta)\n \tisSet[DAY_OF_YEAR] = false;\n \tisSet[WEEK_OF_YEAR] = false;\n \tbreak;\n-\n       case DAY_OF_MONTH:\n \tisSet[WEEK_OF_MONTH] = false;\n \tisSet[DAY_OF_WEEK] = false;\n@@ -981,7 +1042,6 @@ private void cleanUpAfterRoll(int field, int delta)\n \tisSet[WEEK_OF_YEAR] = false;\n \ttime += delta * (24 * 60 * 60 * 1000L);\n \tbreak;\n-\n       case WEEK_OF_MONTH:\n \tisSet[DAY_OF_MONTH] = false;\n \tisSet[DAY_OF_WEEK_IN_MONTH] = false;\n@@ -1013,7 +1073,6 @@ private void cleanUpAfterRoll(int field, int delta)\n \tisSet[DAY_OF_YEAR] = false;\n \ttime += delta * (7 * 24 * 60 * 60 * 1000L);\n \tbreak;\n-\n       case AM_PM:\n \tisSet[HOUR_OF_DAY] = false;\n \ttime += delta * (12 * 60 * 60 * 1000L);\n@@ -1027,7 +1086,6 @@ private void cleanUpAfterRoll(int field, int delta)\n \tisSet[AM_PM] = false;\n \ttime += delta * (60 * 60 * 1000L);\n \tbreak;\n-\n       case MINUTE:\n \ttime += delta * (60 * 1000L);\n \tbreak;\n@@ -1047,7 +1105,7 @@ private void cleanUpAfterRoll(int field, int delta)\n    * with the minimum value and vice versa for negative amounts.\n    *\n    * <strong>Note:</strong> There may be situation, where the other\n-   * fields must be changed, e.g rolling the month on May, 31. \n+   * fields must be changed, e.g rolling the month on May, 31.\n    * The date June, 31 is automatically corrected to June, 30.\n    *\n    * @param field the time field. One of the time field constants.\n@@ -1084,16 +1142,23 @@ public void roll(int field, int amount)\n   /**\n    * The minimum values for the calendar fields.\n    */\n-  private static final int[] minimums =\n-      { BC,       1,  0,  0, 1,  1,   1,   SUNDAY, 1, \n-        AM,  1,  0,  1,  1,   1, -(12*60*60*1000),               0 };\n+  private static final int[] minimums = \n+                                        {\n+                                          BC, 1, 0, 0, 1, 1, 1, SUNDAY, 1, AM,\n+                                          1, 0, 0, 0, 0, -(12 * 60 * 60 * 1000),\n+                                          0\n+                                        };\n \n   /**\n    * The maximum values for the calendar fields.\n    */\n-  private static final int[] maximums =\n-      { AD, 5000000, 11, 53, 5, 31, 366, SATURDAY, 5, \n-        PM, 12, 23, 59, 59, 999, +(12*60*60*1000), (12*60*60*1000) };\n+  private static final int[] maximums = \n+                                        {\n+                                          AD, 5000000, 11, 53, 5, 31, 366,\n+                                          SATURDAY, 5, PM, 12, 23, 59, 59, 999,\n+                                          +(12 * 60 * 60 * 1000),\n+                                          (12 * 60 * 60 * 1000)\n+                                        };\n \n   /**\n    * Gets the smallest value that is allowed for the specified field.\n@@ -1117,7 +1182,6 @@ public int getMaximum(int field)\n     return maximums[field];\n   }\n \n-\n   /**\n    * Gets the greatest minimum value that is allowed for the specified field.\n    * This is the largest value returned by the <code>getActualMinimum(int)</code>\n@@ -1142,7 +1206,7 @@ public int getGreatestMinimum(int field)\n    * 28 days).\n    *\n    * @param field the time field. One of the time field constants.\n-   * @return the least maximum value.  \n+   * @return the least maximum value.\n    * @see #getActualMaximum(int)\n    * @since 1.2\n    */\n@@ -1182,7 +1246,7 @@ public int getActualMinimum(int field)\n \tint min = getMinimalDaysInFirstWeek();\n \tif (min == 0)\n \t  return 1;\n-\tif (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+\tif (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n \t  complete();\n \n \tint year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n@@ -1203,45 +1267,46 @@ public int getActualMinimum(int field)\n    * 29, rather than 28.\n    *\n    * @param field the time field. One of the time field constants.\n-   * @return the actual maximum value.  \n+   * @return the actual maximum value.\n    */\n   public int getActualMaximum(int field)\n   {\n     switch (field)\n       {\n       case WEEK_OF_YEAR:\n-\t{\n-\t  if (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+        {\n+\t  if (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n \t    complete();\n+\n \t  // This is wrong for the year that contains the gregorian change.\n \t  // I.e it gives the weeks in the julian year or in the gregorian\n \t  // year in that case.\n \t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n \t  int lastDay = isLeapYear(year) ? 366 : 365;\n \t  int weekday = getWeekDay(year, lastDay);\n-\t  int week = (lastDay + 6\n-\t\t      - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n+\t  int week = (lastDay + 6 - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n \n \t  int minimalDays = getMinimalDaysInFirstWeek();\n \t  int firstWeekday = getWeekDay(year, minimalDays);\n-\t  /* \n+\t  /*\n \t   * Is there a set of days at the beginning of the year, before the\n \t   * first day of the week, equal to or greater than the minimum number\n \t   * of days required in the first week?\n \t   */\n \t  if (minimalDays - (7 + firstWeekday - getFirstDayOfWeek()) % 7 < 1)\n \t    return week + 1; /* Add week 1: firstWeekday through to firstDayOfWeek */\n-\t}\n-\tcase DAY_OF_MONTH:\n-\t{\n-\t  if (!areFieldsSet || !isSet[MONTH])\n+        }\n+      case DAY_OF_MONTH:\n+        {\n+\t  if (! areFieldsSet || ! isSet[MONTH])\n \t    complete();\n \t  int month = fields[MONTH];\n+\n \t  // If you change this, you should also change \n \t  // SimpleTimeZone.getDaysInMonth();\n \t  if (month == FEBRUARY)\n \t    {\n-\t      if (!isSet[YEAR] || !isSet[ERA])\n+\t      if (! isSet[YEAR] || ! isSet[ERA])\n \t\tcomplete();\n \t      int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n \t      return isLeapYear(year) ? 29 : 28;\n@@ -1250,33 +1315,31 @@ else if (month < AUGUST)\n \t    return 31 - (month & 1);\n \t  else\n \t    return 30 + (month & 1);\n-\t}\n+        }\n       case DAY_OF_YEAR:\n-\t{\n-\t  if (!areFieldsSet || !isSet[ERA] || !isSet[YEAR])\n+        {\n+\t  if (! areFieldsSet || ! isSet[ERA] || ! isSet[YEAR])\n \t    complete();\n \t  int year = fields[ERA] == AD ? fields[YEAR] : 1 - fields[YEAR];\n \t  return isLeapYear(year) ? 366 : 365;\n-\t}\n+        }\n       case DAY_OF_WEEK_IN_MONTH:\n-\t{\n+        {\n \t  // This is wrong for the month that contains the gregorian change.\n \t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n+\n \t  // That's black magic, I know\n \t  return (daysInMonth - (fields[DAY_OF_MONTH] - 1) % 7 + 6) / 7;\n-\t}\n+        }\n       case WEEK_OF_MONTH:\n-\t{\n+        {\n \t  int daysInMonth = getActualMaximum(DAY_OF_MONTH);\n \t  int weekday = (daysInMonth - fields[DAY_OF_MONTH]\n-\t\t\t + fields[DAY_OF_WEEK] - SUNDAY) % 7 + SUNDAY;\n-\t  return (daysInMonth + 6\n-\t\t  - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n-\t}\n+\t                + fields[DAY_OF_WEEK] - SUNDAY) % 7 + SUNDAY;\n+\t  return (daysInMonth + 6 - (7 + weekday - getFirstDayOfWeek()) % 7) / 7;\n+        }\n       default:\n \treturn maximums[field];\n       }\n   }\n-\n-\n }"}, {"sha": "e50d92fab49da581d5d827140c4151d85e329c49", "filename": "libjava/java/util/SimpleTimeZone.java", "status": "modified", "additions": 155, "deletions": 178, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSimpleTimeZone.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -38,6 +38,7 @@\n \n package java.util;\n \n+\n /**\n  * This class represents a simple time zone offset and handles\n  * daylight savings.  It can only handle one daylight savings rule, so\n@@ -49,14 +50,14 @@\n  * lying in the AD era.\n  *\n  * @see Calendar\n- * @see GregorianCalender \n+ * @see GregorianCalender\n  * @author Jochen Hoenicke\n  */\n public class SimpleTimeZone extends TimeZone\n {\n   /**\n    * The raw time zone offset in milliseconds to GMT, ignoring\n-   * daylight savings.  \n+   * daylight savings.\n    * @serial\n    */\n   private int rawOffset;\n@@ -70,23 +71,22 @@ public class SimpleTimeZone extends TimeZone\n   /**\n    * The daylight savings offset.  This is a positive offset in\n    * milliseconds with respect to standard time.  Typically this\n-   * is one hour, but for some time zones this may be half an hour.\n+   * is one hour, but for some time zones this may be half an our.\n    * @serial\n    * @since JDK1.1.4\n    */\n   private int dstSavings = 60 * 60 * 1000;\n \n   /**\n-   * The first year, in which daylight savings rules applies.  \n+   * The first year, in which daylight savings rules applies.\n    * @serial\n    */\n   private int startYear;\n-\n   private static final int DOM_MODE = 1;\n   private static final int DOW_IN_MONTH_MODE = 2;\n   private static final int DOW_GE_DOM_MODE = 3;\n   private static final int DOW_LE_DOM_MODE = 4;\n-  \n+\n   /**\n    * The mode of the start rule. This takes one of the following values:\n    * <dl>\n@@ -119,7 +119,7 @@ public class SimpleTimeZone extends TimeZone\n \n   /**\n    * The month in which daylight savings start.  This is one of the\n-   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.  \n+   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.\n    * @serial\n    */\n   private int startMonth;\n@@ -128,21 +128,21 @@ public class SimpleTimeZone extends TimeZone\n    * This variable can have different meanings.  See startMode for details\n    * @see #startMode;\n    * @serial\n-   */   \n+   */\n   private int startDay;\n-  \n+\n   /**\n-   * This variable specifies the day of week the change takes place.  If \n+   * This variable specifies the day of week the change takes place.  If\n    * startMode == DOM_MODE, this is undefined.\n    * @serial\n    * @see #startMode;\n-   */   \n+   */\n   private int startDayOfWeek;\n-  \n+\n   /**\n    * This variable specifies the time of change to daylight savings.\n    * This time is given in milliseconds after midnight local\n-   * standard time.  \n+   * standard time.\n    * @serial\n    */\n   private int startTime;\n@@ -157,17 +157,17 @@ public class SimpleTimeZone extends TimeZone\n \n   /**\n    * The month in which daylight savings ends.  This is one of the\n-   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.  \n+   * constants Calendar.JANUARY, ..., Calendar.DECEMBER.\n    * @serial\n-   */   \n+   */\n   private int endMonth;\n \n   /**\n    * This variable gives the mode for the end of daylight savings rule.\n    * It can take the same values as startMode.\n    * @serial\n    * @see #startMode\n-   */   \n+   */\n   private int endMode;\n \n   /**\n@@ -176,19 +176,19 @@ public class SimpleTimeZone extends TimeZone\n    * @see #startMode;\n    */\n   private int endDay;\n-  \n+\n   /**\n-   * This variable specifies the day of week the change takes place.  If \n+   * This variable specifies the day of week the change takes place.  If\n    * endMode == DOM_MODE, this is undefined.\n    * @serial\n    * @see #startMode;\n    */\n   private int endDayOfWeek;\n-  \n+\n   /**\n    * This variable specifies the time of change back to standard time.\n    * This time is given in milliseconds after midnight local\n-   * standard time.  \n+   * standard time.\n    * @serial\n    */\n   private int endTime;\n@@ -210,8 +210,11 @@ public class SimpleTimeZone extends TimeZone\n    * @serial\n    */\n   private byte[] monthLength = monthArr;\n-  private static final byte[] monthArr =\n-    {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+  private static final byte[] monthArr = \n+                                         {\n+                                           31, 28, 31, 30, 31, 30, 31, 31, 30,\n+                                           31, 30, 31\n+                                         };\n \n   /**\n    * The version of the serialized data on the stream.\n@@ -232,10 +235,9 @@ public class SimpleTimeZone extends TimeZone\n    * When streaming out this class it is always written in the latest\n    * version.\n    * @serial\n-   * @since JDK1.1.4 \n+   * @since JDK1.1.4\n    */\n   private int serialVersionOnStream = 2;\n-\n   private static final long serialVersionUID = -403250971215465050L;\n \n   /**\n@@ -257,9 +259,9 @@ public class SimpleTimeZone extends TimeZone\n \n   /**\n    * Create a <code>SimpleTimeZone</code> with the given time offset\n-   * from GMT and without daylight savings.  \n+   * from GMT and without daylight savings.\n    * @param rawOffset the time offset from GMT in milliseconds.\n-   * @param id The identifier of this time zone.  \n+   * @param id The identifier of this time zone.\n    */\n   public SimpleTimeZone(int rawOffset, String id)\n   {\n@@ -273,7 +275,7 @@ public SimpleTimeZone(int rawOffset, String id)\n    * Create a <code>SimpleTimeZone</code> with the given time offset\n    * from GMT and with daylight savings.  The start/end parameters\n    * can have different meaning (replace WEEKDAY with a real day of\n-   * week). Only the first two meanings were supported by earlier \n+   * week). Only the first two meanings were supported by earlier\n    * versions of jdk.\n    *\n    * <dl>\n@@ -296,12 +298,12 @@ public SimpleTimeZone(int rawOffset, String id)\n    * must make sure that this day lies in the same month. </dd>\n    * </dl>\n    *\n-   * If you give a non existing month, a day that is zero, or too big, \n+   * If you give a non existing month, a day that is zero, or too big,\n    * or a dayOfWeek that is too big,  the result is undefined.\n    *\n    * The start rule must have a different month than the end rule.\n    * This restriction shouldn't hurt for all possible time zones.\n-   * \n+   *\n    * @param rawOffset The time offset from GMT in milliseconds.\n    * @param id  The identifier of this time zone.\n    * @param startMonth The start month of daylight savings; use the\n@@ -312,29 +314,26 @@ public SimpleTimeZone(int rawOffset, String id)\n    * @param startTime A time in millis in standard time.\n    * @param endMonth The end month of daylight savings; use the\n    * constants in Calendar.\n-   * @param endday A day in month or a day of week number, as \n+   * @param endday A day in month or a day of week number, as\n    * described above.\n    * @param endDayOfWeek The end rule day of week; see above.\n    * @param endTime A time in millis in standard time.\n    * @throws IllegalArgumentException if parameters are invalid or out of\n    * range.\n    */\n-  public SimpleTimeZone(int rawOffset, String id,\n-\t\t\tint startMonth, int startDayOfWeekInMonth,\n-\t\t\tint startDayOfWeek, int startTime,\n-\t\t\tint endMonth, int endDayOfWeekInMonth,\n-\t\t\tint endDayOfWeek, int endTime)\n+  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n+                        int startDayOfWeekInMonth, int startDayOfWeek,\n+                        int startTime, int endMonth, int endDayOfWeekInMonth,\n+                        int endDayOfWeek, int endTime)\n   {\n     this.rawOffset = rawOffset;\n     setID(id);\n     useDaylight = true;\n \n-    setStartRule(startMonth, startDayOfWeekInMonth,\n-\t\t startDayOfWeek, startTime);\n+    setStartRule(startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime);\n     setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n     if (startMonth == endMonth)\n-      throw new IllegalArgumentException\n-\t(\"startMonth and endMonth must be different\");\n+      throw new IllegalArgumentException(\"startMonth and endMonth must be different\");\n     this.startYear = 0;\n   }\n \n@@ -347,15 +346,13 @@ public SimpleTimeZone(int rawOffset, String id,\n    * time in milliseconds.  This must be positive.\n    * @since 1.2\n    */\n-  public SimpleTimeZone(int rawOffset, String id,\n-\t\t\tint startMonth, int startDayOfWeekInMonth,\n-\t\t\tint startDayOfWeek, int startTime,\n-\t\t\tint endMonth, int endDayOfWeekInMonth,\n-\t\t\tint endDayOfWeek, int endTime, int dstSavings)\n+  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n+                        int startDayOfWeekInMonth, int startDayOfWeek,\n+                        int startTime, int endMonth, int endDayOfWeekInMonth,\n+                        int endDayOfWeek, int endTime, int dstSavings)\n   {\n-    this(rawOffset, id,\n-\t startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime,\n-\t endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n+    this(rawOffset, id, startMonth, startDayOfWeekInMonth, startDayOfWeek,\n+         startTime, endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n \n     this.dstSavings = dstSavings;\n   }\n@@ -376,12 +373,11 @@ public SimpleTimeZone(int rawOffset, String id,\n    * range.\n    * @since 1.4\n    */\n-  public SimpleTimeZone(int rawOffset, String id,\n-\t\t\tint startMonth, int startDayOfWeekInMonth,\n-\t\t\tint startDayOfWeek, int startTime, int startTimeMode,\n-\t\t\tint endMonth, int endDayOfWeekInMonth,\n-\t\t\tint endDayOfWeek, int endTime, int endTimeMode,\n-\t\t\tint dstSavings)\n+  public SimpleTimeZone(int rawOffset, String id, int startMonth,\n+                        int startDayOfWeekInMonth, int startDayOfWeek,\n+                        int startTime, int startTimeMode, int endMonth,\n+                        int endDayOfWeekInMonth, int endDayOfWeek,\n+                        int endTime, int endTimeMode, int dstSavings)\n   {\n     this.rawOffset = rawOffset;\n     setID(id);\n@@ -394,12 +390,10 @@ public SimpleTimeZone(int rawOffset, String id,\n     this.startTimeMode = startTimeMode;\n     this.endTimeMode = endTimeMode;\n \n-    setStartRule(startMonth, startDayOfWeekInMonth,\n-\t\t startDayOfWeek, startTime);\n+    setStartRule(startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime);\n     setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n     if (startMonth == endMonth)\n-      throw new IllegalArgumentException\n-\t(\"startMonth and endMonth must be different\");\n+      throw new IllegalArgumentException(\"startMonth and endMonth must be different\");\n     this.startYear = 0;\n \n     this.dstSavings = dstSavings;\n@@ -432,6 +426,7 @@ private int checkRule(int month, int day, int dayOfWeek)\n   {\n     if (month < 0 || month > 11)\n       throw new IllegalArgumentException(\"month out of range\");\n+\n     int daysInMonth = getDaysInMonth(month, 1);\n     if (dayOfWeek == 0)\n       {\n@@ -460,7 +455,6 @@ else if (dayOfWeek > 0)\n       }\n   }\n \n-\n   /**\n    * Sets the daylight savings start rule.  You must also set the\n    * end rule with <code>setEndRule</code> or the result of\n@@ -514,14 +508,16 @@ public void setStartRule(int month, int day, int dayOfWeek, int time)\n    * @since 1.2\n    * @see SimpleTimeZone\n    */\n-  public void setStartRule(int month, int day, int dayOfWeek, int time, boolean after)\n+  public void setStartRule(int month, int day, int dayOfWeek, int time,\n+                           boolean after)\n   {\n     // FIXME: XXX: Validate that checkRule and offset processing work with on\n     // or before mode.\n     this.startDay = after ? Math.abs(day) : -Math.abs(day);\n     this.startDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.startMode = (dayOfWeek != 0) ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-      : checkRule(month, day, dayOfWeek);\n+    this.startMode = (dayOfWeek != 0)\n+                     ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n+                     : checkRule(month, day, dayOfWeek);\n     this.startDay = Math.abs(this.startDay);\n     this.startDayOfWeek = Math.abs(this.startDayOfWeek);\n \n@@ -591,7 +587,7 @@ else if (this.endTimeMode == STANDARD_TIME)\n    *\n    * Note that this API isn't incredibly well specified.  It appears that the\n    * after flag must override the parameters, since normally, the day and\n-   * dayofweek can select this.  I.e., if day &lt; 0 and dayOfWeek &lt; 0, on or\n+   * dayofweek can select this.  I.e., if day < 0 and dayOfWeek < 0, on or\n    * before mode is chosen.  But if after == true, this implementation\n    * overrides the signs of the other arguments.  And if dayOfWeek == 0, it\n    * falls back to the behavior in the other APIs.  I guess this should be\n@@ -606,14 +602,16 @@ else if (this.endTimeMode == STANDARD_TIME)\n    * @since 1.2\n    * @see #setStartRule\n    */\n-  public void setEndRule(int month, int day, int dayOfWeek, int time, boolean after)\n+  public void setEndRule(int month, int day, int dayOfWeek, int time,\n+                         boolean after)\n   {\n     // FIXME: XXX: Validate that checkRule and offset processing work with on\n     // or before mode.\n     this.endDay = after ? Math.abs(day) : -Math.abs(day);\n     this.endDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.endMode = (dayOfWeek != 0) ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-      : checkRule(month, day, dayOfWeek);\n+    this.endMode = (dayOfWeek != 0)\n+                   ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n+                   : checkRule(month, day, dayOfWeek);\n     this.endDay = Math.abs(this.endDay);\n     this.endDayOfWeek = Math.abs(endDayOfWeek);\n \n@@ -648,7 +646,7 @@ public void setEndRule(int month, int day, int time)\n   }\n \n   /**\n-   * Gets the time zone offset, for current date, modified in case of \n+   * Gets the time zone offset, for current date, modified in case of\n    * daylight savings.  This is the offset to add to UTC to get the local\n    * time.\n    *\n@@ -674,44 +672,39 @@ public void setEndRule(int month, int day, int time)\n    * @return the time zone offset in milliseconds.\n    * @throws IllegalArgumentException if arguments are incorrect.\n    */\n-  public int getOffset(int era, int year, int month,\n-\t\t       int day, int dayOfWeek, int millis)\n+  public int getOffset(int era, int year, int month, int day, int dayOfWeek,\n+                       int millis)\n   {\n     int daysInMonth = getDaysInMonth(month, year);\n     if (day < 1 || day > daysInMonth)\n       throw new IllegalArgumentException(\"day out of range\");\n     if (dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY)\n       throw new IllegalArgumentException(\"dayOfWeek out of range\");\n     if (month < Calendar.JANUARY || month > Calendar.DECEMBER)\n-      throw new IllegalArgumentException(\"month out of range\");\n+      throw new IllegalArgumentException(\"month out of range:\" + month);\n \n     // This method is called by Calendar, so we mustn't use that class.\n     int daylightSavings = 0;\n     if (useDaylight && era == GregorianCalendar.AD && year >= startYear)\n       {\n \t// This does only work for Gregorian calendars :-(\n \t// This is mainly because setStartYear doesn't take an era.\n-\n-\tboolean afterStart = !isBefore(year, month, day, dayOfWeek, millis,\n-\t\t\t\t       startMode, startMonth,\n-\t\t\t\t       startDay, startDayOfWeek, startTime);\n+\tboolean afterStart = ! isBefore(year, month, day, dayOfWeek, millis,\n+\t                                startMode, startMonth, startDay,\n+\t                                startDayOfWeek, startTime);\n \tboolean beforeEnd = isBefore(year, month, day, dayOfWeek,\n \t\t\t\t     millis + dstSavings,\n-\t\t\t\t     endMode, endMonth,\n-\t\t\t\t     endDay, endDayOfWeek, endTime);\n+\t                             endMode, endMonth, endDay, endDayOfWeek,\n+\t                             endTime);\n \n \tif (startMonth < endMonth)\n-\t  {\n-\t    // use daylight savings, if the date is after the start of\n-\t    // savings, and before the end of savings.\n-\t    daylightSavings = afterStart && beforeEnd ? dstSavings : 0;\n-\t  }\n+\t  // use daylight savings, if the date is after the start of\n+\t  // savings, and before the end of savings.\n+\t  daylightSavings = afterStart && beforeEnd ? dstSavings : 0;\n \telse\n-\t  {\n-\t    // use daylight savings, if the date is before the end of\n-\t    // savings, or after the start of savings.\n-\t    daylightSavings = beforeEnd || afterStart ? dstSavings : 0;\n-\t  }\n+\t  // use daylight savings, if the date is before the end of\n+\t  // savings, or after the start of savings.\n+\t  daylightSavings = beforeEnd || afterStart ? dstSavings : 0;\n       }\n     return rawOffset + daylightSavings;\n   }\n@@ -740,7 +733,7 @@ public void setRawOffset(int rawOffset)\n    * milliseconds with respect to standard time.  Typically this\n    * is one hour, but for some time zones this may be half an our.\n    * @return the daylight savings offset in milliseconds.\n-   * \n+   *\n    * @since 1.2\n    */\n   public int getDSTSavings()\n@@ -760,7 +753,7 @@ public void setDSTSavings(int dstSavings)\n   {\n     if (dstSavings <= 0)\n       throw new IllegalArgumentException(\"illegal value for dstSavings\");\n-    \n+\n     this.dstSavings = dstSavings;\n   }\n \n@@ -774,23 +767,28 @@ public boolean useDaylightTime()\n   }\n \n   /**\n-   * Returns the number of days in the given month.  It does always\n-   * use the Gregorian leap year rule.  \n+   * Returns the number of days in the given month.\n+   * Uses gregorian rules prior to 1582 (The default and earliest cutover)\n    * @param month The month, zero based; use one of the Calendar constants.\n    * @param year  The year.\n    */\n   private int getDaysInMonth(int month, int year)\n   {\n-    // Most of this is copied from GregorianCalendar.getActualMaximum()\n     if (month == Calendar.FEBRUARY)\n       {\n-\treturn ((year & 3) == 0 && (year % 100 != 0 || year % 400 == 0))\n-\t  ? 29 : 28;\n+\tif ((year & 3) != 0)\n+\t  return 28;\n+\n+\t// Assume default Gregorian cutover, \n+\t// all years prior to this must be Julian\n+\tif (year < 1582)\n+\t  return 29;\n+\n+\t// Gregorian rules \n+\treturn ((year % 100) != 0 || (year % 400) == 0) ? 29 : 28;\n       }\n-    else if (month < Calendar.AUGUST)\n-        return 31 - (month & 1);\n     else\n-      return 30 + (month & 1);\n+      return monthArr[month];\n   }\n \n   /**\n@@ -804,23 +802,19 @@ else if (month < Calendar.AUGUST)\n    * @param mode  the change mode; same semantic as startMode.\n    * @param month the change month; same semantic as startMonth.\n    * @param day   the change day; same semantic as startDay.\n-   * @param dayOfWeek the change day of week; \n+   * @param dayOfWeek the change day of week;\n    * @param millis the change time in millis since midnight standard time.\n    * same semantic as startDayOfWeek.\n    * @return true, if cal is before the change, false if cal is on\n    * or after the change.\n    */\n-  private boolean isBefore(int calYear,\n-\t\t\t   int calMonth, int calDayOfMonth, int calDayOfWeek,\n-\t\t\t   int calMillis, int mode, int month,\n-\t\t\t   int day, int dayOfWeek, int millis)\n+  private boolean isBefore(int calYear, int calMonth, int calDayOfMonth,\n+                           int calDayOfWeek, int calMillis, int mode,\n+                           int month, int day, int dayOfWeek, int millis)\n   {\n-\n     // This method is called by Calendar, so we mustn't use that class.\n     // We have to do all calculations by hand.\n-\n     // check the months:\n-\n     // XXX - this is not correct:\n     // for the DOW_GE_DOM and DOW_LE_DOM modes the change date may\n     // be in a different month.\n@@ -835,7 +829,7 @@ private boolean isBefore(int calYear,\n \t  return calDayOfMonth < day;\n \tbreak;\n       case DOW_IN_MONTH_MODE:\n-\t{\n+        {\n \t  // This computes the day of month of the day of type\n \t  // \"dayOfWeek\" that lies in the same (sunday based) week as cal.\n \t  calDayOfMonth += (dayOfWeek - calDayOfWeek);\n@@ -844,7 +838,6 @@ private boolean isBefore(int calYear,\n \t  // after dividing by 7).  If we count from the end of the\n \t  // month, we get want a -7 based number counting the days from \n \t  // the end:\n-\n \t  if (day < 0)\n \t    calDayOfMonth -= getDaysInMonth(calMonth, calYear) + 7;\n \t  else\n@@ -857,17 +850,16 @@ private boolean isBefore(int calYear,\n \t  // 20 21 22 23 24 25 26      -23-22-21-20-19-18-17\n \t  // 27 28 29 30 31 32 33      -16-15-14-13-12-11-10\n \t  // 34 35 36                   -9 -8 -7\n-\n \t  // Now we calculate the day of week in month:\n \t  int week = calDayOfMonth / 7;\n+\n \t  //  day > 0                    day < 0\n \t  //  S  M  T  W  T  F  S        S  M  T  W  T  F  S\n \t  //     1  1  1  1  1  1          -5 -5 -4 -4 -4 -4\n \t  //  1  2  2  2  2  2  2       -4 -4 -4 -3 -3 -3 -3\n \t  //  2  3  3  3  3  3  3       -3 -3 -3 -2 -2 -2 -2\n \t  //  3  4  4  4  4  4  4       -2 -2 -2 -1 -1 -1 -1\n \t  //  4  5  5                   -1 -1 -1\n-\n \t  if (week != day)\n \t    return week < day;\n \n@@ -876,26 +868,25 @@ private boolean isBefore(int calYear,\n \n \t  // daylight savings starts/ends  on the given day.\n \t  break;\n-\t}\n-\n+        }\n       case DOW_LE_DOM_MODE:\n \t// The greatest sunday before or equal December, 12\n \t// is the same as smallest sunday after or equal December, 6.\n \tday = Math.abs(day) - 6;\n-\n       case DOW_GE_DOM_MODE:\n-\n \t// Calculate the day of month of the day of type\n \t// \"dayOfWeek\" that lies before (or on) the given date.\n-\tcalDayOfMonth -= (calDayOfWeek < dayOfWeek ? 7 : 0)\n-\t  + calDayOfWeek - dayOfWeek;\n+\tcalDayOfMonth -= (calDayOfWeek < dayOfWeek ? 7 : 0) + calDayOfWeek\n+\t- dayOfWeek;\n \tif (calDayOfMonth < day)\n \t  return true;\n \tif (calDayOfWeek != dayOfWeek || calDayOfMonth >= day + 7)\n \t  return false;\n+\n \t// now we have the same day\n \tbreak;\n       }\n+\n     // the millis decides:\n     return (calMillis < millis);\n   }\n@@ -914,40 +905,35 @@ public boolean inDaylightTime(Date date)\n   /**\n    * Generates the hashCode for the SimpleDateFormat object.  It is\n    * the rawOffset, possibly, if useDaylightSavings is true, xored\n-   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.  \n+   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.\n    */\n   public synchronized int hashCode()\n   {\n-    return rawOffset ^\n-      (useDaylight ?\n-       startMonth ^ startDay ^ startDayOfWeek ^ startTime\n-       ^ endMonth ^ endDay ^ endDayOfWeek ^ endTime : 0);\n+    return rawOffset\n+           ^ (useDaylight\n+              ? startMonth ^ startDay ^ startDayOfWeek ^ startTime ^ endMonth\n+              ^ endDay ^ endDayOfWeek ^ endTime : 0);\n   }\n \n   public synchronized boolean equals(Object o)\n   {\n     if (this == o)\n       return true;\n-    if (!(o instanceof SimpleTimeZone))\n+    if (! (o instanceof SimpleTimeZone))\n       return false;\n     SimpleTimeZone zone = (SimpleTimeZone) o;\n-    if (zone.hashCode() != hashCode()\n-\t|| !getID().equals(zone.getID())\n-\t|| rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n+    if (zone.hashCode() != hashCode() || ! getID().equals(zone.getID())\n+        || rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n       return false;\n-    if (!useDaylight)\n+    if (! useDaylight)\n       return true;\n-    return (startYear == zone.startYear\n-\t    && startMonth == zone.startMonth\n-\t    && startDay == zone.startDay\n-\t    && startDayOfWeek == zone.startDayOfWeek\n-\t    && startTime == zone.startTime\n-\t    && startTimeMode == zone.startTimeMode\n-\t    && endMonth == zone.endMonth\n-\t    && endDay == zone.endDay\n-\t    && endDayOfWeek == zone.endDayOfWeek\n-\t    && endTime == zone.endTime\n-\t    && endTimeMode == zone.endTimeMode);\n+    return (startYear == zone.startYear && startMonth == zone.startMonth\n+           && startDay == zone.startDay\n+           && startDayOfWeek == zone.startDayOfWeek\n+           && startTime == zone.startTime\n+           && startTimeMode == zone.startTimeMode && endMonth == zone.endMonth\n+           && endDay == zone.endDay && endDayOfWeek == zone.endDayOfWeek\n+           && endTime == zone.endTime && endTimeMode == zone.endTimeMode);\n   }\n \n   /**\n@@ -962,25 +948,21 @@ public boolean hasSameRules(TimeZone other)\n   {\n     if (this == other)\n       return true;\n-    if (!(other instanceof SimpleTimeZone))\n+    if (! (other instanceof SimpleTimeZone))\n       return false;\n     SimpleTimeZone zone = (SimpleTimeZone) other;\n-    if (zone.hashCode() != hashCode()\n-\t|| rawOffset != zone.rawOffset || useDaylight != zone.useDaylight)\n+    if (zone.hashCode() != hashCode() || rawOffset != zone.rawOffset\n+        || useDaylight != zone.useDaylight)\n       return false;\n-    if (!useDaylight)\n+    if (! useDaylight)\n       return true;\n-    return (startYear == zone.startYear\n-\t    && startMonth == zone.startMonth\n-\t    && startDay == zone.startDay\n-\t    && startDayOfWeek == zone.startDayOfWeek\n-\t    && startTime == zone.startTime\n-\t    && startTimeMode == zone.startTimeMode\n-\t    && endMonth == zone.endMonth\n-\t    && endDay == zone.endDay\n-\t    && endDayOfWeek == zone.endDayOfWeek\n-\t    && endTime == zone.endTime\n-\t    && endTimeMode == zone.endTimeMode);\n+    return (startYear == zone.startYear && startMonth == zone.startMonth\n+           && startDay == zone.startDay\n+           && startDayOfWeek == zone.startDayOfWeek\n+           && startTime == zone.startTime\n+           && startTimeMode == zone.startTimeMode && endMonth == zone.endMonth\n+           && endDay == zone.endDay && endDayOfWeek == zone.endDayOfWeek\n+           && endTime == zone.endTime && endTimeMode == zone.endTimeMode);\n   }\n \n   /**\n@@ -991,26 +973,17 @@ public String toString()\n   {\n     // the test for useDaylight is an incompatibility to jdk1.2, but\n     // I think this shouldn't hurt.\n-    return getClass().getName() + \"[\"\n-      + \"id=\" + getID()\n-      + \",offset=\" + rawOffset\n-      + \",dstSavings=\" + dstSavings\n-      + \",useDaylight=\" + useDaylight\n-      + (useDaylight ?\n-\t \",startYear=\" + startYear\n-\t + \",startMode=\" + startMode\n-\t + \",startMonth=\" + startMonth\n-\t + \",startDay=\" + startDay\n-\t + \",startDayOfWeek=\" + startDayOfWeek\n-\t + \",startTime=\" + startTime\n-\t + \",startTimeMode=\" + startTimeMode\n-\t + \",endMode=\" + endMode\n-\t + \",endMonth=\" + endMonth\n-\t + \",endDay=\" + endDay\n-\t + \",endDayOfWeek=\" + endDayOfWeek\n-\t + \",endTime=\" + endTime\n-\t + \",endTimeMode=\" + endTimeMode\n-\t : \"\") + \"]\";\n+    return getClass().getName() + \"[\" + \"id=\" + getID() + \",offset=\"\n+           + rawOffset + \",dstSavings=\" + dstSavings + \",useDaylight=\"\n+           + useDaylight\n+           + (useDaylight\n+              ? \",startYear=\" + startYear + \",startMode=\" + startMode\n+              + \",startMonth=\" + startMonth + \",startDay=\" + startDay\n+              + \",startDayOfWeek=\" + startDayOfWeek + \",startTime=\"\n+              + startTime + \",startTimeMode=\" + startTimeMode + \",endMode=\"\n+              + endMode + \",endMonth=\" + endMonth + \",endDay=\" + endDay\n+              + \",endDayOfWeek=\" + endDayOfWeek + \",endTime=\" + endTime\n+              + \",endTimeMode=\" + endTimeMode : \"\") + \"]\";\n   }\n \n   /**\n@@ -1029,7 +1002,8 @@ private void readObject(java.io.ObjectInputStream input)\n \tstartMode = DOW_IN_MONTH_MODE;\n \tstartTimeMode = WALL_TIME;\n \tendTimeMode = WALL_TIME;\n-\tserialVersionOnStream = 2;      }\n+\tserialVersionOnStream = 2;\n+      }\n     else\n       {\n \tint length = input.readInt();\n@@ -1054,29 +1028,31 @@ private void readObject(java.io.ObjectInputStream input)\n    * <code>start/endDay(OfWeek)</code>-Fields are written in the\n    * DOW_IN_MONTH_MODE rule, since this was the only supported rule\n    * in 1.1.\n-   * \n+   *\n    * In the optional section, we write first the length of an byte\n    * array as int and afterwards the byte array itself.  The byte\n    * array contains in this release four elements, namely the real\n    * startDay, startDayOfWeek endDay, endDayOfWeek in that Order.\n    * These fields are needed, because for compatibility reasons only\n    * approximative values are written to the required section, as\n-   * described above.  \n+   * described above.\n    */\n   private void writeObject(java.io.ObjectOutputStream output)\n     throws java.io.IOException\n   {\n     byte[] byteArray = new byte[]\n-    {\n-      (byte) startDay, (byte) startDayOfWeek,\n-\t(byte) endDay, (byte) endDayOfWeek};\n+                       {\n+                         (byte) startDay, (byte) startDayOfWeek, (byte) endDay,\n+                         (byte) endDayOfWeek\n+                       };\n \n     /* calculate the approximation for JDK 1.1 */\n     switch (startMode)\n       {\n       case DOM_MODE:\n-\tstartDayOfWeek = Calendar.SUNDAY;\t// random day of week\n-\t// fall through\n+\tstartDayOfWeek = Calendar.SUNDAY; // random day of week\n+\n+      // fall through\n       case DOW_GE_DOM_MODE:\n       case DOW_LE_DOM_MODE:\n \tstartDay = (startDay + 6) / 7;\n@@ -1085,7 +1061,8 @@ private void writeObject(java.io.ObjectOutputStream output)\n       {\n       case DOM_MODE:\n \tendDayOfWeek = Calendar.SUNDAY;\n-\t// fall through\n+\n+      // fall through\n       case DOW_GE_DOM_MODE:\n       case DOW_LE_DOM_MODE:\n \tendDay = (endDay + 6) / 7;"}, {"sha": "7c8117957904fd7af068514f78181521595a6ced", "filename": "libjava/java/util/TimeZone.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/933e5b284a41cc6e1d21805c350d9aea5ef84006/libjava%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.java?ref=933e5b284a41cc6e1d21805c350d9aea5ef84006", "patch": "@@ -447,6 +447,7 @@ static synchronized HashMap timezones()\n \t   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,\n \t   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);\n \ttimezones0.put(\"CET\", tz);\n+\ttimezones0.put(\"CEST\", tz);\n \ttimezones0.put(\"ECT\", tz);\n \ttimezones0.put(\"MET\", tz);\n \ttimezones0.put(\"Africa/Ceuta\", tz);"}]}