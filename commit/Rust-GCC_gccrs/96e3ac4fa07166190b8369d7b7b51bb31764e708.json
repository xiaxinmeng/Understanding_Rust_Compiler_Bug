{"sha": "96e3ac4fa07166190b8369d7b7b51bb31764e708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZlM2FjNGZhMDcxNjYxOTBiODM2OWQ3YjdiNTFiYjMxNzY0ZTcwOA==", "commit": {"author": {"name": "Tim Josling", "email": "tej@melbpc.org.au", "date": "2002-06-10T00:56:49Z"}, "committer": {"name": "Tim Josling", "email": "timjosling@gcc.gnu.org", "date": "2002-06-10T00:56:49Z"}, "message": "Fixes to make treelang worg with PCH gengtype.c changes.\n\nFrom-SVN: r54425", "tree": {"sha": "9e7b95f5c37fe34886027416a04f2f38a726fd28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e7b95f5c37fe34886027416a04f2f38a726fd28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96e3ac4fa07166190b8369d7b7b51bb31764e708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e3ac4fa07166190b8369d7b7b51bb31764e708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e3ac4fa07166190b8369d7b7b51bb31764e708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e3ac4fa07166190b8369d7b7b51bb31764e708/comments", "author": null, "committer": null, "parents": [{"sha": "02ef40d97cd6e94f95efd4e2319044bdf6eb0a1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ef40d97cd6e94f95efd4e2319044bdf6eb0a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ef40d97cd6e94f95efd4e2319044bdf6eb0a1d"}], "stats": {"total": 810, "additions": 417, "deletions": 393}, "files": [{"sha": "94b77eb8c66904c319d8982d5b50712a978a1acb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -1,3 +1,11 @@\n+2002-06-10  Tim Josling  <tej@melbpc.org.au>\n+\n+\t* gengtype.c (unnamed enum containing BASE_FILE_*): Add languages\n+\tTREELANG and COBOL.\n+\t(lang_names): Add treelang and cobol.\n+\t(get_file_basename): Add code to support treelang and cobol as\n+\t4th and 5th users of c-common.c.\n+\n 2002-06-09  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* Makefile.in (install-driver): Install driver as"}, {"sha": "f96b6b42322de30217c574e475e639ddac899f75", "filename": "gcc/gengtype.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -500,10 +500,13 @@ FILE * header_file;\n enum {\n   BASE_FILE_C,\n   BASE_FILE_OBJC,\n-  BASE_FILE_CPLUSPLUS\n+  BASE_FILE_CPLUSPLUS,\n+  BASE_FILE_TREELANG,\n+  BASE_FILE_COBOL\n };\n+\n static const char *lang_names[] = {\n-  \"c\", \"objc\", \"cp\", \"f\", \"ada\", \"java\"\n+  \"c\", \"objc\", \"cp\", \"treelang\", \"cobol\", \"f\", \"ada\", \"java\"\n };\n #define NUM_BASE_FILES (sizeof (lang_names) / sizeof (lang_names[0]))\n FILE *base_files[NUM_BASE_FILES];\n@@ -608,6 +611,10 @@ get_file_basename (f)\n     basename -= 5;\n   else if (startswith (basename - f, basename-5, \"objc/\"))\n     basename -= 5;\n+  else if (startswith (basename - f, basename-9, \"treelang/\"))\n+    basename -= 9;\n+  else if (startswith (basename - f, basename-6, \"cobol/\"))\n+    basename -= 6;\n \n   return basename;\n }\n@@ -643,6 +650,9 @@ get_base_file_bitmap (input_file)\n \t   || strcmp (basename, \"c-decl.c\") == 0\n \t   || strcmp (basename, \"c-objc-common.c\") == 0)\n     return 1 << BASE_FILE_C | 1 << BASE_FILE_OBJC;\n+  else if (startswith (len, basename, \"c-common.c\"))\n+    return 1 << BASE_FILE_C | 1 << BASE_FILE_OBJC| 1 << BASE_FILE_CPLUSPLUS\n+      |  1 << BASE_FILE_TREELANG | 1 << BASE_FILE_COBOL;\n   else if (startswith (len, basename, \"c-\"))\n     return 1 << BASE_FILE_C | 1 << BASE_FILE_OBJC | 1 << BASE_FILE_CPLUSPLUS;\n   else"}, {"sha": "bf9b6cc1e5ad5b29ace62193f715487c875959ba", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -1,3 +1,59 @@\n+2002-06-10  Tim Josling  <tej@melbpc.org.au>\n+\n+        Cleanup \n+\n+\t* Make-lang.in (check-treelang). Add. Remove direct dependency of\n+\t'check' on 'treelang.check' as redundant.\n+\t\n+\tPCH Garbage collection regime (gengtypes.c) phase 1.\n+\t\n+\t* Make-lang.in (treelang/tree1.o). Depend on gt-treelang-tree1.h\n+\tgt-treelang-treelang.h gtype-treelang.h.\n+\t(gt-treelang-tree1.h) Depend on s-gtype.\n+\t(gt-treelang-treelang.h) Depend on s-gtype.\n+\t(gtype-treelang.h) Depend on s-gtype.\n+\n+\t* config-lang.in (gtfiles): Define. \n+\n+\t* lex.l (main): Remove '#if 0' dead code.\n+\t(main): Move undef of IN_GCC so define of tree typedef works.\n+\t(all): Replace token and production by prod_token_parm_item.\n+\t\n+\t* parse.y\n+\t(all): Replace token and production by prod_token_parm_item.\n+\n+\t* tree1.c (main): Remove include of \"output.h\".\n+\t(symbol_table): Add GTY details.\n+\t(symbol_table_ggc): Remove.\n+\t(treelang_init): Remove root definitions for garage collection.\n+\t(mark_production_used): Remove.\n+\t(mark_token_used): Remove.\n+\t(main, at end): include generated garage collection routines.\n+\n+\t* treelang.h (category_enum ): Add parameter_category.\n+\t(all): Replace token and production and parameters by union\n+\tprod_token_parm_item containing production_part, token_part,\n+\tparameter_part.\n+\t(STATIC_STORAGE AUTOMATIC_STORAGE EXTERNAL_REFERENCE_STORAGE\n+\tEXTERNAL_DEFINITION_STORAGE SIGNED_CHAR UNSIGNED_CHAR SIGNED_INT\n+\tUNSIGNED_INT VOID_TYPE EXP_PLUS EXP_REFERENCE EXP_ASSIGN\n+\tEXP_FUNCTION_INVOCATION EXP_MINUS EXP_EQUALS): Move here from\n+\ttreetree.h.\n+\n+\t* treetree.c\n+\t(tm_p.h): Do not include.\n+\t(ansidecl.h): Move include after config.h.\n+\t(treelang.h): Include it.\n+\t(ADDROOT): Remove.\n+\t(all): Replace token, production and parameter by prod_token_parm_item.\n+\t(tree_parameter_list): Move to treelang.h as part of\n+\tprod_token_parm_item.\n+\t(STATIC_STORAGE AUTOMATIC_STORAGE EXTERNAL_REFERENCE_STORAGE\n+\tEXTERNAL_DEFINITION_STORAGE SIGNED_CHAR UNSIGNED_CHAR SIGNED_INT\n+\tUNSIGNED_INT VOID_TYPE EXP_PLUS EXP_REFERENCE EXP_ASSIGN\n+\tEXP_FUNCTION_INVOCATION EXP_MINUS EXP_EQUALS): Move from here to\n+\ttreelang.h.\n+\n 2002-05-19  Tim Josling  <tej@melbpc.org.au>\n \n \t* treetree.c (warn_format_zero_length): Add. "}, {"sha": "8caadaabaa9bf808a3662dede8289297d2dff988", "filename": "gcc/treelang/Make-lang.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FMake-lang.in?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -90,7 +90,8 @@ tree1$(exeext): treelang/tree1.o treelang/treetree.o treelang/lex.o treelang/par\n \n # object file makes\n \n-treelang/tree1.o: $(srcdir)/treelang/tree1.c $(srcdir)/treelang/treelang.h $(srcdir)/treelang/parse.h\n+treelang/tree1.o: $(srcdir)/treelang/tree1.c $(srcdir)/treelang/treelang.h $(srcdir)/treelang/parse.h\\\n+\tgt-treelang-tree1.h gt-treelang-treelang.h gtype-treelang.h\n \t$(CC) -o $@ -c $(ALL_CFLAGS) $(INCLUDES) $< \n \n treelang/treetree.o: $(srcdir)/treelang/treetree.c $(srcdir)/treelang/treetree.h\n@@ -114,6 +115,8 @@ $(srcdir)/treelang/parse.c $(srcdir)/treelang/parse.h: $(srcdir)/treelang/parse.\n \t--output=$(srcdir)/treelang/parse.c --defines\n # -v\n \n+gt-treelang-tree1.h gt-treelang-treelang.h gtype-treelang.h : s-gtype; @true\n+\n #\f\n # Build hooks:\n \n@@ -246,7 +249,7 @@ treelang.distdir:\n # test hook\n # the other languages are hard coded in the main makefile.in - that seems to be wrong \n \n-check: treelang.check\n+check-treelang: treelang.check\n \n TESTSUITEDIR = testsuite\n "}, {"sha": "6392b69bddfb8cc7f831a69f858eebf572ad05c6", "filename": "gcc/treelang/config-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fconfig-lang.in?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -35,3 +35,6 @@ stagestuff=\n diff_excludes=\"-x lex.c -x parse.c -x parse.h\"\n headers=\n build_by_default=\"no\"\n+\n+gtfiles=\"\\$(srcdir)/treelang/tree1.c \\$(srcdir)/treelang/treelang.h\"\n+"}, {"sha": "0d7af64ee47213b5ea1b48a79237916cf82eea44", "filename": "gcc/treelang/lex.l", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -33,22 +33,18 @@\n  \n */\n \n-/* Avoid poisoned malloc problem.  */\n-#undef IN_GCC\n-\n-#if 0\n-/* tree is defined as void* here to avoid any knowledge of tree stuff in this file.  */\n-typedef void *tree;\n-#endif\n #include <stdio.h>\n-#if 0\n-#include <ctype.h>\n-#endif\n #include <memory.h>\n #include \"ansidecl.h\"\n #include \"config.h\"\n #include \"system.h\"\n+\n+/* Avoid poisoned malloc problem.  */\n+#undef IN_GCC\n+\n+#include \"config.h\"\n #include \"diagnostic.h\"\n+#include \"tree.h\"\n \n /* Token defs.  */\n #include \"treelang.h\"\n@@ -81,9 +77,10 @@ static void dump_lex_value (int lexret);\n %%\n \n  { \n-   yylval = my_malloc (sizeof (struct token));\n-   ((struct token*)yylval)->lineno = next_tree_lineno;\n-   ((struct token*)yylval)->charno = next_tree_charno;\n+   /* Should really allocate only what we need. lll;.  */\n+   yylval = my_malloc (sizeof (struct prod_token_parm_item));\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.lineno = next_tree_lineno;\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n  }\n \n [ \\n]+ {\n@@ -221,8 +218,8 @@ static void dump_lex_value (int lexret);\n [^\\n]  {\n   update_lineno_charno ();\n   fprintf (stderr, \"%s:%i:%i: Unrecognized character %c\\n\", in_fname, \n-           ((struct token*)yylval)->lineno, \n-           ((struct token*)yylval)->charno, yytext[0]);\n+           ((struct prod_token_parm_item *)yylval)->tp.tok.lineno, \n+           ((struct prod_token_parm_item *)yylval)->tp.tok.charno, yytext[0]);\n   errorcount++;\n }\n \n@@ -238,8 +235,8 @@ update_lineno_charno (void)\n    /* Update the values we send to caller in case we sometimes don't\n       tell them about all the 'tokens' eg comments etc.  */\n    int yyl;\n-   ((struct token*)yylval)->lineno = next_tree_lineno;\n-   ((struct token*)yylval)->charno = next_tree_charno;\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.lineno = next_tree_lineno;\n+   ((struct prod_token_parm_item *)yylval)->tp.tok.charno = next_tree_charno;\n    for ( yyl = 0; yyl < yyleng; ++yyl ) \n       {\n          if ( yytext[yyl] == '\\n' ) \n@@ -257,16 +254,16 @@ update_lineno_charno (void)\n void \n update_yylval (int a)\n {\n-  struct token* tok;\n+  struct prod_token_parm_item * tok;\n   tok=yylval;\n   \n   tok->category = token_category;\n   tok->type = a;\n-  tok->length = yyleng;\n+  tok->tp.tok.length = yyleng;\n   /* Have to copy yytext as it is just a ptr into the buffer at the\n      moment.  */\n-  tok->chars = my_malloc (yyleng + 1);\n-  memcpy (tok->chars, yytext, yyleng);\n+  tok->tp.tok.chars = my_malloc (yyleng + 1);\n+  memcpy (tok->tp.tok.chars, yytext, yyleng);\n }\n \n /* Trace the value LEXRET and the position and token details being\n@@ -277,9 +274,9 @@ dump_lex_value (int lexret)\n {\n   int ix;\n   fprintf (stderr, \" %d l:%d c:%d ln:%d text=\", lexret,\n-         ((struct token*) yylval)->lineno,\n-         ((struct token*) yylval)->charno,\n-         ((struct token*) yylval)->length);\n+         ((struct prod_token_parm_item *) yylval)->tp.tok.lineno,\n+         ((struct prod_token_parm_item *) yylval)->tp.tok.charno,\n+         ((struct prod_token_parm_item *) yylval)->tp.tok.length);\n   for (ix = 0; ix < yyleng; ix++) \n     {\n       fprintf (stderr, \"%c\", yytext[ix]);"}, {"sha": "0588e2180f80dacccd1fdf2942c683e0f94ff859", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 179, "deletions": 178, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -71,16 +71,16 @@ static void yyerror (const char *error_message);\n int yylex (void);\n int yyparse (void);\n void print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value);\n-static struct production *reverse_prod_list (struct production *old_first);\n-static void ensure_not_void (unsigned int type, struct token* name);\n-static int check_type_match (int type_num, struct production *exp);\n-static int get_common_type (struct production *type1, struct production *type2);\n-static struct production *make_integer_constant (struct token* value);\n-static void set_storage (struct production *prod);\n+static struct prod_token_parm_item *reverse_prod_list (struct prod_token_parm_item *old_first);\n+static void ensure_not_void (unsigned int type, struct prod_token_parm_item* name);\n+static int check_type_match (int type_num, struct prod_token_parm_item *exp);\n+static int get_common_type (struct prod_token_parm_item *type1, struct prod_token_parm_item *type2);\n+static struct prod_token_parm_item *make_integer_constant (struct prod_token_parm_item* value);\n+static void set_storage (struct prod_token_parm_item *prod);\n \n /* File global variables.  */\n \n-static struct production *current_function=NULL;\n+static struct prod_token_parm_item *current_function=NULL;\n \n %}\n \n@@ -171,14 +171,14 @@ variable_def {\n \n variable_def:\n storage typename NAME init_opt SEMICOLON {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $3;\n   prod = make_production (PROD_VARIABLE_NAME, tok);\n   SYMBOL_TABLE_NAME (prod) = tok;\n   EXPRESSION_TYPE (prod) = $2;\n   VAR_INIT (prod) = $4;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -189,26 +189,26 @@ storage typename NAME init_opt SEMICOLON {\n \n   if (VAR_INIT (prod))\n     {\n-      if (! ((struct production*)VAR_INIT (prod))->code)\n+      if (! ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code)\n         abort ();\n     if (STORAGE_CLASS (prod) == EXTERNAL_REFERENCE_STORAGE)\n       {\n         fprintf (stderr, \"%s:%i:%i: External reference variables may not have initial value\\n\", in_fname, \n-                tok->lineno, tok->charno);\n+                tok->tp.tok.lineno, tok->tp.tok.charno);\n         print_token (stderr, 0, tok);\n         errorcount++;\n         YYERROR;\n       }\n     }\n-  prod->code = tree_code_create_variable\n+  prod->tp.pro.code = tree_code_create_variable\n     (STORAGE_CLASS (prod), \n-     ((struct token*)SYMBOL_TABLE_NAME (prod))->chars,\n-     ((struct token*)SYMBOL_TABLE_NAME (prod))->length,\n+     ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.chars,\n+     ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.length,\n      NUMERIC_TYPE (prod),\n-     VAR_INIT (prod)? ((struct production*)VAR_INIT (prod))->code:NULL,\n+     VAR_INIT (prod)? ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code:NULL,\n      in_fname,\n-     tok->lineno);\n-  if (!prod->code) \n+     tok->tp.tok.lineno);\n+  if (!prod->tp.pro.code) \n     abort ();\n }\n ;\n@@ -222,14 +222,14 @@ STATIC\n \n parameter:\n typename NAME {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *prod2;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *prod2;\n   tok = $2;\n   prod = make_production (PROD_VARIABLE_NAME, tok);\n   SYMBOL_TABLE_NAME (prod) = $2;\n   EXPRESSION_TYPE (prod) = $1;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -243,19 +243,19 @@ typename NAME {\n \n function_prototype:\n storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *type;\n-  struct tree_parameter_list* first_parms;\n-  struct tree_parameter_list* last_parms;\n-  struct tree_parameter_list* this_parms;\n-  struct production *this_parm;\n-  struct production *this_parm_var;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *type;\n+  struct prod_token_parm_item* first_parms;\n+  struct prod_token_parm_item* last_parms;\n+  struct prod_token_parm_item* this_parms;\n+  struct prod_token_parm_item *this_parm;\n+  struct prod_token_parm_item *this_parm_var;\n   tok = $3;\n   prod = make_production (PROD_FUNCTION_NAME, $3);\n   SYMBOL_TABLE_NAME (prod) = $3;\n   EXPRESSION_TYPE (prod) = $2;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   PARAMETERS (prod) = reverse_prod_list ($5); \n   insert_tree_name (prod);\n   STORAGE_CLASS_TOKEN (prod) = $1;\n@@ -268,7 +268,7 @@ storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n       \n     case AUTOMATIC_STORAGE:\n       fprintf (stderr, \"%s:%i:%i: A function cannot be automatic\\n\", in_fname, \n-              tok->lineno, tok->charno);\n+              tok->tp.tok.lineno, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -281,7 +281,7 @@ storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n   /* Create a parameter list in a non-front end specific format.  */\n   for (first_parms = NULL, last_parms = NULL, this_parm = PARAMETERS (prod);\n        this_parm;\n-       this_parm = this_parm->next)\n+       this_parm = this_parm->tp.pro.next)\n     {\n       if (this_parm->category != production_category)\n         abort ();\n@@ -290,70 +290,71 @@ storage typename NAME LEFT_PARENTHESIS parameters RIGHT_PARENTHESIS SEMICOLON {\n         abort ();\n       if (this_parm_var->category != production_category)\n         abort ();\n-      this_parms = my_malloc (sizeof (struct tree_parameter_list));\n-      if (!this_parm_var->main_token)\n+      this_parms = my_malloc (sizeof (struct prod_token_parm_item));\n+      if (!this_parm_var->tp.pro.main_token)\n         abort ();\n-      this_parms->variable_name = this_parm_var->main_token->chars;\n-      this_parms->type = NUMERIC_TYPE (( (struct production*)EXPRESSION_TYPE (this_parm_var)));\n+      this_parms->tp.par.variable_name = this_parm_var->tp.pro.main_token->tp.tok.chars;\n+      this_parms->type = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (this_parm_var)));\n       if (last_parms)\n         {\n-          last_parms->next = this_parms;\n+          last_parms->tp.par.next = this_parms;\n           last_parms = this_parms;\n         }\n       else\n         {\n           first_parms = this_parms;\n           last_parms = this_parms;\n         }\n-      this_parms->where_to_put_var_tree = & (( (struct production*)VARIABLE (this_parm))->code);\n+      this_parms->tp.par.where_to_put_var_tree = \n+        & (( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code);\n     }\n   FIRST_PARMS (prod) = first_parms;\n \n-  prod->code = tree_code_create_function_prototype\n-    (tok->chars, STORAGE_CLASS (prod), NUMERIC_TYPE (type),\n-     first_parms, in_fname, tok->lineno);\n+  prod->tp.pro.code = tree_code_create_function_prototype\n+    (tok->tp.tok.chars, STORAGE_CLASS (prod), NUMERIC_TYPE (type),\n+     first_parms, in_fname, tok->tp.tok.lineno);\n \n }\n ;\n \n function:\n NAME LEFT_BRACE {\n-  struct production *proto;\n-  struct production search_prod;\n-  struct token* tok;\n-  struct production *this_parm;\n+  struct prod_token_parm_item *proto;\n+  struct prod_token_parm_item search_prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *this_parm;\n   tok = $1;\n   SYMBOL_TABLE_NAME ((&search_prod)) = tok;\n   current_function = proto = lookup_tree_name (&search_prod);\n   if (!proto)\n     {\n       fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n-              tok->lineno, tok->charno);\n+              tok->tp.tok.lineno, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n     }\n-  if (!proto->code)\n+  if (!proto->tp.pro.code)\n     abort ();\n   tree_code_create_function_initial\n-    (proto->code, in_fname, tok->lineno,\n+    (proto->tp.pro.code, in_fname, tok->tp.tok.lineno,\n      FIRST_PARMS (current_function));\n \n   /* Check all the parameters have code.  */\n   for (this_parm = PARAMETERS (proto);\n        this_parm;\n-       this_parm = this_parm->next)\n+       this_parm = this_parm->tp.pro.next)\n     {\n-      if (! (struct production*)VARIABLE (this_parm))\n+      if (! (struct prod_token_parm_item*)VARIABLE (this_parm))\n         abort ();\n-      if (! (( (struct production*)VARIABLE (this_parm))->code))\n+      if (! (( (struct prod_token_parm_item*)VARIABLE (this_parm))->tp.pro.code))\n         abort ();\n     }\n }\n variable_defs_opt statements_opt RIGHT_BRACE {\n-  struct token* tok;\n+  struct prod_token_parm_item* tok;\n   tok = $1;\n-  tree_code_create_function_wrapup (in_fname, tok->lineno);\n+  tree_code_create_function_wrapup (in_fname, tok->tp.tok.lineno);\n   current_function = NULL;\n }\n ;\n@@ -387,48 +388,48 @@ variable_def {\n \n typename:\n INT {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n   NUMERIC_TYPE (prod) = SIGNED_INT;\n-  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  prod->tp.pro.code = tree_code_get_type (NUMERIC_TYPE (prod));\n   $$ = prod;\n }\n |UNSIGNED INT {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n   NUMERIC_TYPE (prod) = UNSIGNED_INT;\n-  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  prod->tp.pro.code = tree_code_get_type (NUMERIC_TYPE (prod));\n   $$ = prod;\n }\n |CHAR {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n   NUMERIC_TYPE (prod) = SIGNED_CHAR;\n-  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  prod->tp.pro.code = tree_code_get_type (NUMERIC_TYPE (prod));\n   $$ = prod;\n }\n |UNSIGNED CHAR {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n   NUMERIC_TYPE (prod) = UNSIGNED_CHAR;\n-  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  prod->tp.pro.code = tree_code_get_type (NUMERIC_TYPE (prod));\n   $$ = prod;\n }\n |VOID {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = $1;\n   prod = make_production (PROD_TYPE_NAME, tok);\n   NUMERIC_TYPE (prod) = VOID_TYPE;\n-  prod->code = tree_code_get_type (NUMERIC_TYPE (prod));\n+  prod->tp.pro.code = tree_code_get_type (NUMERIC_TYPE (prod));\n   $$ = prod;\n }\n ;\n@@ -439,9 +440,9 @@ parameter {\n   $$ = $1;\n }\n |parameters COMMA parameter {\n-  struct production *prod1;\n+  struct prod_token_parm_item *prod1;\n   prod1 = $3;\n-  prod1->next = $1; /* Insert in reverse order.  */\n+  prod1->tp.pro.next = $1; /* Insert in reverse order.  */\n   $$ = prod1;\n }\n ;\n@@ -457,9 +458,9 @@ statement {\n \n statement:\n expression SEMICOLON {\n-  struct production *exp;\n+  struct prod_token_parm_item *exp;\n   exp = $1;\n-  tree_code_output_expression_statement (exp->code, in_fname, exp->main_token->lineno);\n+  tree_code_output_expression_statement (exp->tp.pro.code, in_fname, exp->tp.pro.main_token->tp.tok.lineno);\n }\n |return SEMICOLON {\n   /* Nothing to do.  */\n@@ -471,67 +472,67 @@ expression SEMICOLON {\n \n if_statement:\n IF LEFT_PARENTHESIS expression RIGHT_PARENTHESIS {\n-  struct token* tok;\n-  struct production *exp;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *exp;\n   tok = $1;\n   exp = $3;\n-  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n-  tree_code_if_start (exp->code, in_fname, tok->lineno);\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->tp.pro.main_token);\n+  tree_code_if_start (exp->tp.pro.code, in_fname, tok->tp.tok.lineno);\n }\n LEFT_BRACE statements_opt RIGHT_BRACE {\n   /* Just let the statements flow.  */\n }\n ELSE {\n-  struct token* tok;\n+  struct prod_token_parm_item* tok;\n   tok = $1;\n-  tree_code_if_else (in_fname, tok->lineno);\n+  tree_code_if_else (in_fname, tok->tp.tok.lineno);\n }\n LEFT_BRACE statements_opt RIGHT_BRACE {\n-  struct token* tok;\n+  struct prod_token_parm_item* tok;\n   tok = $12;\n-  tree_code_if_end (in_fname, tok->lineno);\n+  tree_code_if_end (in_fname, tok->tp.tok.lineno);\n }\n ;\n \n \n return:\n RETURN expression_opt {\n-  struct production *type_prod;\n-  struct token* ret_tok;\n+  struct prod_token_parm_item *type_prod;\n+  struct prod_token_parm_item* ret_tok;\n   ret_tok = $1;\n   type_prod = EXPRESSION_TYPE (current_function);\n   if (NUMERIC_TYPE (type_prod) == VOID)\n     if ($2 == NULL)\n-      tree_code_generate_return (type_prod->code, NULL);\n+      tree_code_generate_return (type_prod->tp.pro.code, NULL);\n     else\n       {\n         fprintf (stderr, \"%s:%i:%i: Redundant expression in return\\n\", in_fname, \n-                ret_tok->lineno, ret_tok->charno);\n+                ret_tok->tp.tok.lineno, ret_tok->tp.tok.charno);\n         print_token (stderr, 0, ret_tok);\n         errorcount++;\n-        tree_code_generate_return (type_prod->code, NULL);\n+        tree_code_generate_return (type_prod->tp.pro.code, NULL);\n       }\n   else\n     if ($2 == NULL)\n       {\n         fprintf (stderr, \"%s:%i:%i: Expression missing in return\\n\", in_fname, \n-                ret_tok->lineno, ret_tok->charno); \n+                ret_tok->tp.tok.lineno, ret_tok->tp.tok.charno); \n         print_token (stderr, 0, ret_tok);\n         errorcount++;\n       }\n     else\n       {\n-        struct production *exp;\n+        struct prod_token_parm_item *exp;\n         exp = $2;\n         /* Check same type.  */\n         if (check_type_match (NUMERIC_TYPE (type_prod), $2))\n           {\n-            if (!type_prod->code)\n+            if (!type_prod->tp.pro.code)\n               abort ();\n-            if (!exp->code)\n+            if (!exp->tp.pro.code)\n               abort ();\n             /* Generate the code. */\n-            tree_code_generate_return (type_prod->code, exp->code);\n+            tree_code_generate_return (type_prod->tp.pro.code, exp->tp.pro.code);\n           }\n       }\n }\n@@ -542,9 +543,9 @@ expression_opt:\n   $$ = 0;\n }\n |expression {\n-  struct production *exp;\n+  struct prod_token_parm_item *exp;\n   exp = $1;\n-  if (!exp->code)\n+  if (!exp->tp.pro.code)\n     abort ();\n   \n   $$ = $1;\n@@ -559,17 +560,17 @@ INTEGER {\n   $$ = $1;\n }\n |expression PLUS expression {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *op1;\n-  struct production *op2;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *op1;\n+  struct prod_token_parm_item *op2;\n   tree type;\n   \n   op1 = $1;\n   op2 = $3;\n   tok = $2;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n   prod = make_production (PROD_PLUS_EXPRESSION, tok);\n   NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n   if (!NUMERIC_TYPE (prod))\n@@ -582,22 +583,22 @@ INTEGER {\n       OP1 (prod) = $1;\n       OP2 (prod) = $3;\n       \n-      prod->code = tree_code_get_expression\n-        (EXP_PLUS, type, op1->code, op2->code, NULL);\n+      prod->tp.pro.code = tree_code_get_expression\n+        (EXP_PLUS, type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n     }\n   $$ = prod;\n }\n |expression MINUS expression %prec PLUS {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *op1;\n-  struct production *op2;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *op1;\n+  struct prod_token_parm_item *op2;\n   tree type;\n   \n   op1 = $1;\n   op2 = $3;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n   tok = $2;\n   prod = make_production (PROD_PLUS_EXPRESSION, tok);\n   NUMERIC_TYPE (prod) = get_common_type (op1, op2);\n@@ -611,22 +612,22 @@ INTEGER {\n       OP1 (prod) = $1;\n       OP2 (prod) = $3;\n       \n-      prod->code = tree_code_get_expression (EXP_MINUS, \n-                                          type, op1->code, op2->code, NULL);\n+      prod->tp.pro.code = tree_code_get_expression (EXP_MINUS, \n+                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n     }\n   $$ = prod;\n }\n |expression EQUALS expression {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *op1;\n-  struct production *op2;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *op1;\n+  struct prod_token_parm_item *op2;\n   tree type;\n   \n   op1 = $1;\n   op2 = $3;\n-  ensure_not_void (NUMERIC_TYPE (op1), op1->main_token);\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op1), op1->tp.pro.main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n   tok = $2;\n   prod = make_production (PROD_PLUS_EXPRESSION, tok);\n   NUMERIC_TYPE (prod) = SIGNED_INT;\n@@ -640,22 +641,22 @@ INTEGER {\n       OP1 (prod) = $1;\n       OP2 (prod) = $3;\n       \n-      prod->code = tree_code_get_expression (EXP_EQUALS, \n-                                          type, op1->code, op2->code, NULL);\n+      prod->tp.pro.code = tree_code_get_expression (EXP_EQUALS, \n+                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n     }\n   $$ = prod;\n }\n |variable_ref ASSIGN expression {\n-  struct token* tok;\n-  struct production *prod;\n-  struct production *op1;\n-  struct production *op2;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *op1;\n+  struct prod_token_parm_item *op2;\n   tree type;\n   \n   op1 = $1;\n   op2 = $3;\n   tok = $2;\n-  ensure_not_void (NUMERIC_TYPE (op2), op2->main_token);\n+  ensure_not_void (NUMERIC_TYPE (op2), op2->tp.pro.main_token);\n   prod = make_production (PROD_ASSIGN_EXPRESSION, tok);\n   NUMERIC_TYPE (prod) = NUMERIC_TYPE (op1);\n   if (!NUMERIC_TYPE (prod))\n@@ -667,8 +668,8 @@ INTEGER {\n         abort ();\n       OP1 (prod) = $1;\n       OP2 (prod) = $3;\n-      prod->code = tree_code_get_expression (EXP_ASSIGN, \n-                                          type, op1->code, op2->code, NULL);\n+      prod->tp.pro.code = tree_code_get_expression (EXP_ASSIGN, \n+                                          type, op1->tp.pro.code, op2->tp.pro.code, NULL);\n     }\n   $$ = prod;\n }\n@@ -679,13 +680,13 @@ INTEGER {\n \n function_invocation:\n NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n-  struct production *prod;\n-  struct token* tok;\n-  struct production search_prod;\n-  struct production *proto;\n-  struct production *exp;\n-  struct production *exp_proto;\n-  struct production *var;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item search_prod;\n+  struct prod_token_parm_item *proto;\n+  struct prod_token_parm_item *exp;\n+  struct prod_token_parm_item *exp_proto;\n+  struct prod_token_parm_item *var;\n   int exp_proto_count;\n   int exp_count;\n   tree parms;\n@@ -700,7 +701,7 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n   if (!proto)\n     {\n       fprintf (stderr, \"%s:%i:%i: Function prototype not found\\n\", in_fname, \n-              tok->lineno, tok->charno);\n+              tok->tp.tok.lineno, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -709,67 +710,67 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n   NUMERIC_TYPE (prod) = NUMERIC_TYPE (proto);\n   /* Count the expressions and ensure they match the prototype.  */\n   for (exp_proto_count = 0, exp_proto = PARAMETERS (proto); \n-       exp_proto; exp_proto = exp_proto->next)\n+       exp_proto; exp_proto = exp_proto->tp.pro.next)\n     exp_proto_count++;\n \n-  for (exp_count = 0, exp = PARAMETERS (prod); exp; exp = exp->next)\n+  for (exp_count = 0, exp = PARAMETERS (prod); exp; exp = exp->tp.pro.next)\n     exp_count++;\n \n   if (exp_count !=  exp_proto_count)\n     {\n       fprintf (stderr, \"%s:%i:%i: expression count mismatch with prototype\\n\", in_fname, \n-              tok->lineno, tok->charno);\n+              tok->tp.tok.lineno, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n     }\n   parms = tree_code_init_parameters ();\n   for (exp_proto = PARAMETERS (proto), exp = PARAMETERS (prod);\n        exp_proto;\n-       exp = exp->next, exp_proto = exp_proto->next)\n+       exp = exp->tp.pro.next, exp_proto = exp_proto->tp.pro.next)\n   {\n     if (!exp)\n       abort ();\n     if (!exp_proto)\n       abort ();\n-    if (!exp->code)\n+    if (!exp->tp.pro.code)\n       abort ();\n     var = VARIABLE (exp_proto);\n     if (!var)\n       abort ();\n-    if (!var->code)\n+    if (!var->tp.pro.code)\n       abort ();\n-    parms = tree_code_add_parameter (parms, var->code, exp->code);\n+    parms = tree_code_add_parameter (parms, var->tp.pro.code, exp->tp.pro.code);\n   }\n   type = get_type_for_numeric_type (NUMERIC_TYPE (prod));\n-  prod->code = tree_code_get_expression\n-    (EXP_FUNCTION_INVOCATION, type, proto->code, parms, NULL);\n+  prod->tp.pro.code = tree_code_get_expression\n+    (EXP_FUNCTION_INVOCATION, type, proto->tp.pro.code, parms, NULL);\n   $$ = prod;\n }\n ;\n \n expressions_with_commas:\n expression {\n-  struct production *exp;\n+  struct prod_token_parm_item *exp;\n   exp = $1;\n-  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->tp.pro.main_token);\n   $$ = $1;\n }\n |expressions_with_commas COMMA expression {\n-  struct production *exp;\n+  struct prod_token_parm_item *exp;\n   exp = $3;\n-  ensure_not_void (NUMERIC_TYPE (exp), exp->main_token);\n-  exp->next = $1; /* Reverse order.  */\n+  ensure_not_void (NUMERIC_TYPE (exp), exp->tp.pro.main_token);\n+  exp->tp.pro.next = $1; /* Reverse order.  */\n   $$ = exp;\n }\n ;\n \n variable_ref:\n NAME {\n-  struct production search_prod;\n-  struct production *prod;\n-  struct production *symbol_table_entry;\n-  struct token* tok;\n+  struct prod_token_parm_item search_prod;\n+  struct prod_token_parm_item *prod;\n+  struct prod_token_parm_item *symbol_table_entry;\n+  struct prod_token_parm_item* tok;\n   tree type;\n \n   tok = $1;\n@@ -778,7 +779,7 @@ NAME {\n   if (!symbol_table_entry)\n     {\n       fprintf (stderr, \"%s:%i:%i: Variable referred to but not defined\\n\", in_fname, \n-              tok->lineno, tok->charno);\n+              tok->tp.tok.lineno, tok->tp.tok.charno);\n       print_token (stderr, 0, tok);\n       errorcount++;\n       YYERROR;\n@@ -791,8 +792,8 @@ NAME {\n     YYERROR;\n   OP1 (prod) = $1;\n   \n-  prod->code = tree_code_get_expression (EXP_REFERENCE, type, \n-                                      symbol_table_entry->code, NULL, NULL);\n+  prod->tp.pro.code = tree_code_get_expression (EXP_REFERENCE, type, \n+                                      symbol_table_entry->tp.pro.code, NULL, NULL);\n   $$ = prod;\n }\n ;\n@@ -824,26 +825,26 @@ INTEGER {\n void\n print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value) \n {\n-  struct token *tok;\n+  struct prod_token_parm_item *tok;\n   unsigned int  ix;\n \n   tok  =  value;\n-  fprintf (file, \"%d \\\"\", tok->lineno);\n-  for (ix  =  0; ix < tok->length; ix++)\n-    fprintf (file, \"%c\", tok->chars[ix]);\n+  fprintf (file, \"%d \\\"\", tok->tp.tok.lineno);\n+  for (ix  =  0; ix < tok->tp.tok.length; ix++)\n+    fprintf (file, \"%c\", tok->tp.tok.chars[ix]);\n   fprintf (file, \"\\\"\");\n }\n \n /* Output a message ERROR_MESSAGE from the parser.  */\n void\n yyerror (const char *error_message)\n {\n-  struct token *tok;\n+  struct prod_token_parm_item *tok;\n   \n   tok = yylval;\n   if (tok)\n     {\n-      fprintf (stderr, \"%s:%i:%i: %s\\n\", in_fname, tok->lineno, tok->charno, error_message);\n+      fprintf (stderr, \"%s:%i:%i: %s\\n\", in_fname, tok->tp.tok.lineno, tok->tp.tok.charno, error_message);\n       print_token (stderr, 0, tok);\n     }\n   else\n@@ -856,12 +857,12 @@ yyerror (const char *error_message)\n /* Reverse the order of a token list, linked by parse_next, old first\n    token is OLD_FIRST.  */\n \n-static struct production*\n-reverse_prod_list (struct production *old_first)\n+static struct prod_token_parm_item*\n+reverse_prod_list (struct prod_token_parm_item *old_first)\n {\n-  struct production *current;\n-  struct production *next;\n-  struct production *prev = NULL;\n+  struct prod_token_parm_item *current;\n+  struct prod_token_parm_item *next;\n+  struct prod_token_parm_item *prev = NULL;\n   \n   current = old_first;\n   prev = NULL;\n@@ -870,8 +871,8 @@ reverse_prod_list (struct production *old_first)\n     {\n       if (current->category != production_category)\n         abort ();\n-      next = current->next;\n-      current->next = prev;\n+      next = current->tp.pro.next;\n+      current->tp.pro.next = prev;\n       prev = current;\n       current = next; \n     }\n@@ -881,12 +882,12 @@ reverse_prod_list (struct production *old_first)\n /* Ensure TYPE is not VOID. Use NAME as the token for the error location.  */\n \n static void\n-ensure_not_void (unsigned int type, struct token* name)\n+ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n {\n   if (type == VOID)\n     {\n       fprintf (stderr, \"%s:%i:%i: Type must not be void in this context\\n\", in_fname, \n-              name->lineno, name->charno);\n+              name->tp.tok.lineno, name->tp.tok.charno);\n       print_token (stderr, 0, name);\n       errorcount++;\n     }\n@@ -896,7 +897,7 @@ ensure_not_void (unsigned int type, struct token* name)\n    common type (min is signed int).  */\n \n static int \n-get_common_type (struct production *type1, struct production *type2)\n+get_common_type (struct prod_token_parm_item *type1, struct prod_token_parm_item *type2)\n {\n   if (NUMERIC_TYPE (type1) == UNSIGNED_INT)\n     return UNSIGNED_INT;\n@@ -911,7 +912,7 @@ get_common_type (struct production *type1, struct production *type2)\n    integral type.  */\n \n static int \n-check_type_match (int type_num, struct production *exp)\n+check_type_match (int type_num, struct prod_token_parm_item *exp)\n {\n   switch (type_num)\n     {\n@@ -946,27 +947,27 @@ check_type_match (int type_num, struct production *exp)\n \n /* Make a production for an integer constant VALUE.  */\n \n-static struct production *\n-make_integer_constant (struct token* value)\n+static struct prod_token_parm_item *\n+make_integer_constant (struct prod_token_parm_item* value)\n {\n-  struct token* tok;\n-  struct production *prod;\n+  struct prod_token_parm_item* tok;\n+  struct prod_token_parm_item *prod;\n   tok = value;\n   prod = make_production (PROD_INTEGER_CONSTANT, tok);\n-  if ((tok->chars[0] == (unsigned char)'-')|| (tok->chars[0] == (unsigned char)'+'))\n+  if ((tok->tp.tok.chars[0] == (unsigned char)'-')|| (tok->tp.tok.chars[0] == (unsigned char)'+'))\n     NUMERIC_TYPE (prod) = SIGNED_INT;\n   else\n     NUMERIC_TYPE (prod) = UNSIGNED_INT;\n-  prod->code = tree_code_get_integer_value (tok->chars, tok->length);\n+  prod->tp.pro.code = tree_code_get_integer_value (tok->tp.tok.chars, tok->tp.tok.length);\n   return prod;\n }\n \n /* Set STORAGE_CLASS in PROD according to CLASS_TOKEN.  */\n \n static void\n-set_storage (struct production *prod)\n+set_storage (struct prod_token_parm_item *prod)\n {\n-  struct token* stg_class;\n+  struct prod_token_parm_item* stg_class;\n   stg_class = STORAGE_CLASS_TOKEN (prod);\n   switch (stg_class->type)\n     {"}, {"sha": "bc54710f15a7736b98761c26c450a866faaaa3a7", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 28, "deletions": 91, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -35,7 +35,6 @@\n #include \"system.h\"\n #include \"ansidecl.h\"\n #include \"flags.h\"\n-#include \"output.h\"\n #include \"toplev.h\"\n \n #include \"ggc.h\"\n@@ -55,7 +54,7 @@\n extern int yyparse (void);\n /* Linked list of symbols - all must be unique in treelang.  */\n \n-struct production *symbol_table = NULL;\n+static GTY(()) struct prod_token_parm_item *symbol_table = NULL;\n \n /* Language for usage for messages.  */\n \n@@ -65,9 +64,6 @@ const char *const language_string = \"TREELANG - sample front end for GCC \";\n \n void version (void);\n \n-/* GC routine for symbol table.  */\n-static void symbol_table_ggc (void *m);\n-\n /* Global variables.  */\n \n extern struct cbl_tree_struct_parse_tree_top* parse_tree_top;\n@@ -191,18 +187,6 @@ treelang_decode_option (num_options_left, first_option_left)\n const char*\n treelang_init (const char* filename)\n {\n-\n-  /* Define my garbage collection routines.  */\n-  ggc_add_root (&symbol_table, 1, \n-                /* Unused size.  */ sizeof (void*), symbol_table_ggc);\n-  /* Note: only storage that has to be kept across functions needs to\n-     be protected from GC.  */\n-  /* Define my garbage collection routines.  */\n-  ggc_add_root (&symbol_table, 1, \n-                /* Unused size.  */ sizeof (void*), symbol_table_ggc);\n-  /* Note: only storage that has to be kept across functions needs to\n-     be protected from GC.  */\n-\n   /* Set up the declarations needed for this front end.  */\n \n   input_filename = \"\";\n@@ -250,58 +234,6 @@ treelang_parse_file (int debug_flag ATTRIBUTE_UNUSED)\n   yyparse ();\n }\n \n-\n-/* Scan the symbol table* M, marking storage used.  */\n-\n-static void\n-symbol_table_ggc (void *m)\n-{\n-  struct production *pp;\n-  pp = * (struct production**)m;\n-  /* Actually it is a pointer to a pointer, to allow reallocation and\n-     relinking.  */\n-  mark_production_used (pp);\n-}\n-\n-/* Mark a production PP as used so it wont be garbage collected.  */\n-\n-void\n-mark_production_used (struct production *pp)\n-{\n-  int sub_ix;\n- loop:\n-  if (!pp)\n-    return;\n-  ggc_mark (pp);\n-  \n-  if (pp->category == token_category)\n-    {\n-      mark_token_used ((struct token*)pp);\n-      return;\n-    }\n-  if (pp->category != production_category)\n-    abort ();\n-  mark_token_used (pp->main_token);\n-  for (sub_ix = 0; sub_ix < SUB_COUNT; sub_ix++)\n-    mark_production_used (pp->sub[sub_ix]);\n-  /* The macro tests for NULL so I don't need to.  */\n-  ggc_mark_tree (pp->code);\n-  pp = pp->next;\n-  goto loop;\n-}\n-\n-/* Mark a token TT as used so it wont be garbage collected.  */\n-\n-void\n-mark_token_used (struct token* tt)\n-{\n-  if (!tt) \n-    return;\n-  ggc_mark (tt);\n-  if (tt->chars)\n-    ggc_mark (tt->chars);\n-}\n-\n /* Allocate SIZE bytes and clear them.  */\n \n void *\n@@ -322,61 +254,66 @@ my_malloc (size_t size)\n    return the symbol table entry from the symbol table if found there,\n    else 0.  */\n \n-struct production*\n-lookup_tree_name (struct production *prod)\n+struct prod_token_parm_item*\n+lookup_tree_name (struct prod_token_parm_item *prod)\n {\n-  struct production *this;\n-  struct token* this_tok;\n-  struct token* tok;\n+  struct prod_token_parm_item *this;\n+  struct prod_token_parm_item *this_tok;\n+  struct prod_token_parm_item *tok;\n   tok = SYMBOL_TABLE_NAME (prod);\n-  for (this = symbol_table; this; this = this->next)\n+  for (this = symbol_table; this; this = this->tp.pro.next)\n     {\n-      this_tok = this->main_token;\n-      if (tok->length != this_tok->length) \n+      this_tok = this->tp.pro.main_token;\n+      if (tok->tp.tok.length != this_tok->tp.tok.length) \n         continue;\n-      if (memcmp (tok->chars, this_tok->chars, this_tok->length))\n+      if (memcmp (tok->tp.tok.chars, this_tok->tp.tok.chars, this_tok->tp.tok.length))\n         continue;\n       if (option_parser_trace)\n-        fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\", tok->chars, \n-                tok->lineno, tok->charno, NUMERIC_TYPE (this));\n+        fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\", tok->tp.tok.chars, \n+                tok->tp.tok.lineno, tok->tp.tok.charno, NUMERIC_TYPE (this));\n       return this;\n     }\n   if (option_parser_trace)\n-    fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\", tok->chars, \n-            tok->lineno, tok->charno, tok->type);\n+    fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\", tok->tp.tok.chars, \n+            tok->tp.tok.lineno, tok->tp.tok.charno, tok->type);\n   return NULL;\n }\n \n /* Insert name PROD into the symbol table.  Return 1 if duplicate, 0 if OK.  */\n \n int\n-insert_tree_name (struct production *prod)\n+insert_tree_name (struct prod_token_parm_item *prod)\n {\n-  struct token* tok;\n+  struct prod_token_parm_item *tok;\n   tok = SYMBOL_TABLE_NAME (prod);\n   if (lookup_tree_name (prod))\n     {\n-      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\", in_fname, tok->lineno, tok->charno, tok->chars);\n+      fprintf (stderr, \"%s:%i:%i duplicate name %s\\n\", in_fname, tok->tp.tok.lineno, \n+               tok->tp.tok.charno, tok->tp.tok.chars);\n       errorcount++;\n       return 1;\n     }\n-  prod->next = symbol_table;\n+  prod->tp.pro.next = symbol_table;\n   NESTING_LEVEL (prod) = work_nesting_level;\n   symbol_table = prod;\n   return 0;\n }\n \n /* Create a struct productions of type TYPE, main token MAIN_TOK.  */\n \n-struct production *\n-make_production (int type, struct token* main_tok)\n+struct prod_token_parm_item *\n+make_production (int type, struct prod_token_parm_item *main_tok)\n {\n-  struct production *prod;\n-  prod = my_malloc (sizeof (struct production));\n+  struct prod_token_parm_item *prod;\n+  prod = my_malloc (sizeof (struct prod_token_parm_item));\n   prod->category = production_category;\n   prod->type = type;\n-  prod->main_token = main_tok;\n+  prod->tp.pro.main_token = main_tok;\n   return prod;\n } \n \n \n+/* New garbage collection regime see gty.texi.  */\n+#include \"gt-treelang-tree1.h\"\n+/*#include \"gt-treelang-treelang.h\"*/\n+#include \"gtype-treelang.h\""}, {"sha": "f42a2e2e2e94a394e4c9feeef401899fe0675fde", "filename": "gcc/treelang/treelang.h", "status": "modified", "additions": 79, "deletions": 43, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreelang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreelang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreelang.h?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -35,64 +35,57 @@ enum category_enum\n { /* These values less likely to be there by chance unlike 0/1,\n       make checks more meaningful */\n   token_category = 111,\n-  production_category = 222\n+  production_category = 222,\n+  parameter_category = 333\n };\n \n /* Input file name and FILE.  */\n extern unsigned char* in_fname;\n extern FILE* yyin;\n \n-#if 0\n-extern int errorcount; /* In toplev.c.  */\n-#endif\n+/* Forward references to satisfy mutually recursive definitions.  */\n+struct token_part;\n+struct production_part;\n+struct prod_token_parm_item;\n+typedef struct GTY(()) prod_token_parm_item item;\n \n-struct token\n+/* A token from the input file.  */\n+\n+struct token_part GTY(())\n {\n-  enum category_enum category; /* Token or production. */\n-  unsigned int type; /* Token type.  */\n-  /* Prior to this point, production must match token.  */\n   unsigned int lineno;\n   unsigned int charno;\n   unsigned int length; /* The value.  */\n   unsigned char* chars;\n };\n \n-struct production\n+/* Definitions for fields in production.  */\n+#define NESTING_LEVEL(a) a->tp.pro.info[0]  /* Level used for variable definitions.  */\n+#define NUMERIC_TYPE(a)  a->tp.pro.info[1]  /* Numeric type used in type definitions and expressions.  */\n+#define SUB_COUNT 5\n+#define SYMBOL_TABLE_NAME(a) (a->tp.pro.sub[0]) /* Name token.  */\n+#define EXPRESSION_TYPE(a) (a->tp.pro.sub[1]) /* Type identifier.  */\n+#define OP1(a) (a->tp.pro.sub[2]) /* Exp operand1.  */\n+#define PARAMETERS(a) (a->tp.pro.sub[2]) /* Function parameters.  */\n+#define VARIABLE(a) (a->tp.pro.sub[2]) /* Parameter variable ptr.  */\n+#define VAR_INIT(a) (a->tp.pro.sub[2]) /* Variable init.  */\n+#define OP2(a) (a->tp.pro.sub[3]) /* Exp operand2.  */\n+#define FIRST_PARMS(a) (a->tp.pro.sub[3]) /* Function parameters linked via struct tree_parameter_list.  */\n+#define OP3(a) (a->tp.pro.sub[4]) /* Exp operand3.  */\n+#define STORAGE_CLASS_TOKEN(a) (a->tp.pro.sub[4]) /* Storage class token.  */\n+#define STORAGE_CLASS(a) a->tp.pro.flag1 /* Values in treetree.h.  */\n+\n+struct production_part GTY(())\n {\n-  enum category_enum category; /* Token or Production. */\n-  unsigned int type; /* Production type - a fake token name.  */\n-  /* Prior to this point, production must match token.  */\n-  struct token* main_token; /* Main token for error msgs; variable name token.  */\n+  struct prod_token_parm_item *main_token; /* Main token for error msgs; variable name token.  */\n \n   unsigned int info[2]; /* Extra information.  */\n-#define NESTING_LEVEL(a) a->info[0]  /* Level used for variable definitions.  */\n-#define NUMERIC_TYPE(a)  a->info[1]  /* Numeric type used in type definitions and expressions.  */\n-\n-\n-#define SUB_COUNT 5\n-  void *sub[SUB_COUNT]; /* Sub productions or tokens.  */\n-\n-#define SYMBOL_TABLE_NAME(a) (a->sub[0]) /* Name token.  */\n-\n-#define EXPRESSION_TYPE(a) (a->sub[1]) /* Type identifier.  */\n-\n-#define OP1(a) (a->sub[2]) /* Exp operand1.  */\n-#define PARAMETERS(a) (a->sub[2]) /* Function parameters.  */\n-#define VARIABLE(a) (a->sub[2]) /* Parameter variable ptr.  */\n-#define VAR_INIT(a) (a->sub[2]) /* Variable init.  */\n-\n-#define OP2(a) (a->sub[3]) /* Exp operand2.  */\n-#define FIRST_PARMS(a) (a->sub[3]) /* Function parameters linked via struct tree_parameter_list.  */\n \n-#define OP3(a) (a->sub[4]) /* Exp operand3.  */\n-#define STORAGE_CLASS_TOKEN(a) (a->sub[4]) /* Storage class token.  */\n-\n-  void *code; /* Back end hook for this item.  */\n-  struct production *next; /* Next in chains of various types.  */\n+  struct prod_token_parm_item *sub[SUB_COUNT]; /* Sub productions or tokens.  */\n+  tree code; /* Back end hook for this item.  */\n+  struct prod_token_parm_item *next; /* Next in chains of various types.  */\n \n   unsigned int flag1:2;\n-#define STORAGE_CLASS(a) a->flag1 /* Values in treetree.h.  */\n-\n   unsigned int flag2:1;\n   unsigned int flag3:1;\n   unsigned int flag4:1;\n@@ -102,15 +95,58 @@ struct production\n \n };\n \n+/* Storage modes.  */\n+#define STATIC_STORAGE 0\n+#define AUTOMATIC_STORAGE 1\n+#define EXTERNAL_REFERENCE_STORAGE 2\n+#define EXTERNAL_DEFINITION_STORAGE 3\n+\n+/* Numeric types.  */\n+#define SIGNED_CHAR 1\n+#define UNSIGNED_CHAR 2\n+#define SIGNED_INT 3 \n+#define UNSIGNED_INT 4\n+#define VOID_TYPE 5\n+\n+/* Expression types.  */\n+#define EXP_PLUS 0 /* Addition expression.  */\n+#define EXP_REFERENCE 1 /* Variable reference.  */\n+#define EXP_ASSIGN 2 /* Assignment.  */\n+#define EXP_FUNCTION_INVOCATION 3  /* Call function.  */\n+#define EXP_MINUS 4  /* Subtraction.  */\n+#define EXP_EQUALS 5  /* Equality test.  */\n+\n+/* Parameter list passed to back end.  */\n+struct parameter_part GTY(())\n+{\n+  struct prod_token_parm_item *next; /* Next entry.  */\n+  unsigned char* variable_name; /* Name. */\n+  tree * GTY ((length (\"1\"))) where_to_put_var_tree; /* Where to save decl.  */\n+};\n+\n+/* A production or a token.  */\n+struct prod_token_parm_item GTY(())\n+{\n+  enum category_enum category; /* Token or production. */\n+  unsigned int type; /* Token or production type.  */\n+  union t_or_p\n+  {\n+    struct token_part GTY((tag (\"token_category\"))) tok;\n+    struct production_part GTY((tag (\"production_category\"))) pro;\n+    struct parameter_part GTY((tag (\"parameter_category\"))) par;\n+  } GTY((desc (\"((item *)&%1)->category\"))) tp;\n+};\n+\n+\n /* For parser. Alternatively you can define it using %union (bison) or\n    union. */\n #define YYSTYPE void *\n \n void *my_malloc (size_t size);\n-int insert_tree_name (struct production *prod);\n-struct production *lookup_tree_name (struct production *prod);\n-struct production *make_production (int type, struct token* main_tok);\n-void mark_production_used (struct production * pp);\n-void mark_token_used (struct token* tt);\n+int insert_tree_name (struct prod_token_parm_item *prod);\n+struct prod_token_parm_item *lookup_tree_name (struct prod_token_parm_item *prod);\n+struct prod_token_parm_item *make_production (int type, struct prod_token_parm_item *main_tok);\n+void mark_production_used (struct prod_token_parm_item *pp);\n+void mark_token_used (struct prod_token_parm_item *tt);\n void treelang_debug (void);\n "}, {"sha": "2d05ce1bbf4851885a1befcd96016c5926d4088f", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -70,21 +70,21 @@\n \n /* GCC headers.  */\n \n-#include \"ansidecl.h\"\n #include \"config.h\"\n+#include \"ansidecl.h\"\n #include \"system.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"c-tree.h\"\n #include \"rtl.h\"\n-#include \"tm_p.h\"\n #include \"ggc.h\"\n #include \"toplev.h\"\n #include \"varray.h\"\n #include \"langhooks-def.h\"\n #include \"langhooks.h\"\n \n+#include \"treelang.h\"\n #include \"treetree.h\"\n \n extern int option_main;\n@@ -163,14 +163,6 @@ const char *const tree_code_name[] = {\n unsigned int tree_code_int_size = 0;\n unsigned int tree_code_char_size = 0;\n \n-/* In this case there is very little to keep between functions - we\n-   keep the symbol table only and the things that hang off that - see\n-   tree1.c.  Garbage collection is only invoked when we call\n-   rest_of_compilation at the end of a function. */\n-\n-#define ADDROOT(where) ggc_add_root (&where, 1, /* Unused size.  */ sizeof (void*), \\\n- tree_ggc_storage_always_used);\n-\n /* Return the tree stuff for this type TYPE_NUM.  */\n \n tree \n@@ -242,21 +234,21 @@ tree\n tree_code_create_function_prototype (unsigned char* chars,\n                                     unsigned int storage_class,\n                                     unsigned int ret_type,\n-                                    struct tree_parameter_list* parms,\n+                                    struct prod_token_parm_item* parms,\n                                     unsigned char* filename,\n                                     int lineno)\n {\n \n   tree id;\n-  struct tree_parameter_list* parm;\n+  struct prod_token_parm_item* parm;\n   tree type_list = NULL_TREE;\n   tree type_node;\n   tree fn_type;\n   tree fn_decl;\n \n   /* Build the type.  */\n   id = get_identifier ((const char*)chars);\n-  for (parm = parms; parm; parm = parm->next)\n+  for (parm = parms; parm; parm = parm->tp.par.next)\n     {\n       type_node = get_type_for_numeric_type (parm->type);\n       type_list = tree_cons (NULL_TREE, type_node, type_list);\n@@ -328,7 +320,7 @@ void\n tree_code_create_function_initial (tree prev_saved, \n                                   unsigned char* filename,\n                                   int lineno,\n-                                  struct tree_parameter_list* parms)\n+                                  struct prod_token_parm_item* parms)\n {\n   tree fn_decl;\n   tree param_decl;\n@@ -337,8 +329,8 @@ tree_code_create_function_initial (tree prev_saved,\n   tree parm_decl;\n   tree parm_list;\n   tree resultdecl;\n-  struct tree_parameter_list* this_parm; \n-  struct tree_parameter_list* parm;\n+  struct prod_token_parm_item* this_parm; \n+  struct prod_token_parm_item* parm;\n \n   fn_decl = prev_saved;\n   if (!fn_decl)\n@@ -368,10 +360,11 @@ tree_code_create_function_initial (tree prev_saved,\n \n   /* Make the argument variable decls.  */\n   parm_list = NULL_TREE;\n-  for (parm = parms; parm; parm = parm->next)\n+  for (parm = parms; parm; parm = parm->tp.par.next)\n     {\n-      parm_decl = build_decl (PARM_DECL, get_identifier ((const char*) (parm->variable_name)), \n-                           get_type_for_numeric_type (parm->type));\n+      parm_decl = build_decl (PARM_DECL, get_identifier \n+                              ((const char*) (parm->tp.par.variable_name)), \n+                              get_type_for_numeric_type (parm->type));\n       \n       /* Some languages have different nominal and real types.  */\n       DECL_ARG_TYPE (parm_decl) = TREE_TYPE (parm_decl);\n@@ -395,11 +388,11 @@ tree_code_create_function_initial (tree prev_saved,\n          this_parm = parms;\n        param_decl;\n        param_decl = TREE_CHAIN (param_decl),\n-         this_parm = this_parm->next)\n+         this_parm = this_parm->tp.par.next)\n     {\n       if (!this_parm)\n         abort (); /* Too few.  */\n-      *this_parm->where_to_put_var_tree = param_decl;\n+      *this_parm->tp.par.where_to_put_var_tree = param_decl;\n     }\n   if (this_parm)\n     abort (); /* Too many.  */\n@@ -1032,8 +1025,16 @@ handle_format_arg_attribute (tree *node ATTRIBUTE_UNUSED,\n int\n cpp_handle_option (cpp_reader *pfile ATTRIBUTE_UNUSED,\n      int argc ATTRIBUTE_UNUSED,\n-     char **argv ATTRIBUTE_UNUSED,\n-     int ignore ATTRIBUTE_UNUSED)\n+     char **argv ATTRIBUTE_UNUSED)\n+{\n+  abort ();\n+}\n+\n+/* Should not be called for treelang.   */\n+\n+void \n+cpp_assert (cpp_reader * cr ATTRIBUTE_UNUSED, \n+            const char *s ATTRIBUTE_UNUSED)\n {\n   abort ();\n }"}, {"sha": "e394ebae8e022b4f6373903cfc3c9d829bfc4bb3", "filename": "gcc/treelang/treetree.h", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreetree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e3ac4fa07166190b8369d7b7b51bb31764e708/gcc%2Ftreelang%2Ftreetree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.h?ref=96e3ac4fa07166190b8369d7b7b51bb31764e708", "patch": "@@ -31,15 +31,6 @@\n \n  */\n \n-/* Parameter list passed to back end.  */\n-struct tree_parameter_list \n-{\n-  struct tree_parameter_list* next; /* Next entry.  */\n-  int   type; /* See numeric types below.  */\n-  unsigned char* variable_name; /* Name. */\n-  tree* where_to_put_var_tree; /* Where to save decl.  */\n-};\n-\n tree tree_code_init_parameters (void);\n tree tree_code_add_parameter (tree list, tree proto_exp, tree exp);\n tree tree_code_get_integer_value (unsigned char *chars, unsigned int length);\n@@ -49,12 +40,12 @@ tree tree_code_get_expression (unsigned int exp_type, tree type, tree op1, tree\n tree tree_code_get_numeric_type (unsigned int size1, unsigned int sign1);\n void tree_code_create_function_initial (tree prev_saved,\n                                        unsigned char* filename, int lineno,\n-                                       struct tree_parameter_list* parms);\n+                                       struct prod_token_parm_item* parms);\n void tree_code_create_function_wrapup (unsigned char* filename, int lineno);\n tree tree_code_create_function_prototype (unsigned char* chars,\n                                          unsigned int storage_class,\n                                          unsigned int ret_type,\n-                                         struct tree_parameter_list* parms,                                 \n+                                         struct prod_token_parm_item* parms,                                 \n                                          unsigned char* filename,\n                                          int lineno);\n tree tree_code_create_variable (unsigned int storage_class,\n@@ -78,24 +69,5 @@ void treelang_parse_file (int debug_flag);\n void push_var_level (void);\n void pop_var_level (void);\n \n-/* Storage modes.  */\n-#define STATIC_STORAGE 0\n-#define AUTOMATIC_STORAGE 1\n-#define EXTERNAL_REFERENCE_STORAGE 2\n-#define EXTERNAL_DEFINITION_STORAGE 3\n-\n-\n-/* Numeric types.  */\n-#define SIGNED_CHAR 1\n-#define UNSIGNED_CHAR 2\n-#define SIGNED_INT 3 \n-#define UNSIGNED_INT 4\n-#define VOID_TYPE 5\n \n \n-#define EXP_PLUS 0 /* Addition expression.  */\n-#define EXP_REFERENCE 1 /* Variable reference.  */\n-#define EXP_ASSIGN 2 /* Assignment.  */\n-#define EXP_FUNCTION_INVOCATION 3  /* Call function.  */\n-#define EXP_MINUS 4  /* Subtraction.  */\n-#define EXP_EQUALS 5  /* Equality test.  */"}]}