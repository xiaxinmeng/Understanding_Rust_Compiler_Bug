{"sha": "cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M4YmVhMGFlZWVlYjZlZDgwNDZlZGUxYTU3N2VlNjgxZGEyY2E2YQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-12-16T23:58:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-12-16T23:58:34Z"}, "message": "PR tree-optimization/78918 - missing -Wrestrict on memcpy copying over self\n\ngcc/c-family/ChangeLog:\n\n\tPR tree-optimization/78918\n\t* c-common.c (check_function_restrict): Avoid checking built-ins.\n\t* c.opt (-Wrestrict): Include in -Wall.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/78918\n\t* Makefile.in (OBJS): Add gimple-ssa-warn-restrict.o.\n\t* builtins.c (check_sizes): Rename...\n\t(check_access): ...to this.  Rename function arguments for clarity.\n\t(check_memop_sizes): Adjust names.\n\t(expand_builtin_memchr, expand_builtin_memcpy): Same.\n\t(expand_builtin_memmove, expand_builtin_mempcpy): Same.\n\t(expand_builtin_strcat, expand_builtin_stpncpy): Same.\n\t(check_strncat_sizes, expand_builtin_strncat): Same.\n\t(expand_builtin_strncpy, expand_builtin_memset): Same.\n\t(expand_builtin_bzero, expand_builtin_memcmp): Same.\n\t(expand_builtin_memory_chk, maybe_emit_chk_warning): Same.\n\t(maybe_emit_sprintf_chk_warning): Same.\n\t(expand_builtin_strcpy): Adjust.\n\t(expand_builtin_stpcpy): Same.\n\t(expand_builtin_with_bounds): Detect out-of-bounds accesses\n\tin pointer-checking forms of memcpy, memmove, and mempcpy.\n\t(gcall_to_tree_minimal, max_object_size): Define new functions.\n\t* builtins.h (max_object_size): Declare.\n\t* calls.c (alloc_max_size): Call max_object_size instead of\n\thardcoding ssizetype limit.\n\t(get_size_range): Handle new argument.\n\t* calls.h (get_size_range): Add a new argument.\n\t* cfgexpand.c (expand_call_stmt): Propagate no-warning bit.\n\t* doc/invoke.texi (-Wrestrict): Adjust, add example.\n\t* gimple-fold.c (gimple_fold_builtin_memory_op): Detect overlapping\n\toperations.\n\t(gimple_fold_builtin_memory_chk): Same.\n\t(gimple_fold_builtin_stxcpy_chk): New function.\n\t* gimple-ssa-warn-restrict.c: New source.\n\t* gimple-ssa-warn-restrict.h: New header.\n\t* gimple.c (gimple_build_call_from_tree): Propagate location.\n\t* passes.def (pass_warn_restrict): Add new pass.\n\t* tree-pass.h (make_pass_warn_restrict): Declare.\n\t* tree-ssa-strlen.c (handle_builtin_strcpy): Detect overlapping\n\toperations.\n\t(handle_builtin_strcat): Same.\n\t(strlen_optimize_stmt): Rename...\n\t(strlen_check_and_optimize_stmt): ...to this.  Handle strncat,\n\tstpncpy, strncpy, and their checking forms.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/78918\n\t* c-c++-common/Warray-bounds.c: New test.\n\t* c-c++-common/Warray-bounds-2.c: New test.\n\t* c-c++-common/Warray-bounds-3.c: New test.\n\t* c-c++-common/Warray-bounds-4.c: New test.\n\t* c-c++-common/Warray-bounds-5.c: New test.\n\t* c-c++-common/Wrestrict-2.c: New test.\n\t* c-c++-common/Wrestrict.c: New test.\n\t* c-c++-common/Wrestrict.s: New test.\n\t* c-c++-common/Wsizeof-pointer-memaccess1.c: Adjust\n\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Same.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Same.\n\t* gcc.dg/range.h: New header.\n\t* gcc.dg/memcpy-6.c: New test.\n\t* gcc.dg/pr69172.c: Adjust.\n\t* gcc.dg/pr79223.c: Same.\n\t* gcc.dg/pr81345.c: Adjust.\n\t* gcc.dg/Wobjsize-1.c: Same.\n\t* gcc.dg/Wrestrict-2.c: New test.\n\t* gcc.dg/Wrestrict.c: New test.\n\t* gcc.dg/Wsizeof-pointer-memaccess1.c: Adjust.\n\t* gcc.dg/builtin-stpncpy.c: Same.\n\t* gcc.dg/builtin-stringop-chk-1.c: Same.\n\t* gcc.target/i386/chkp-stropt-17.c: New test.\n\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Adjust.\n\nFrom-SVN: r255755", "tree": {"sha": "8ab48ffcd2c1abce152c9686d64db508a4f40a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ab48ffcd2c1abce152c9686d64db508a4f40a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d43568222a4564e22a6ffd370481e11ba031b318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43568222a4564e22a6ffd370481e11ba031b318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43568222a4564e22a6ffd370481e11ba031b318"}], "stats": {"total": 4712, "additions": 4422, "deletions": 290}, "files": [{"sha": "ad83f845bf34d4cda6cb04614a43f159da766dde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,3 +1,46 @@\n+2017-12-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78918\n+\t* Makefile.in (OBJS): Add gimple-ssa-warn-restrict.o.\n+\t* builtins.c (check_sizes): Rename...\n+\t(check_access): ...to this.  Rename function arguments for clarity.\n+\t(check_memop_sizes): Adjust names.\n+\t(expand_builtin_memchr, expand_builtin_memcpy): Same.\n+\t(expand_builtin_memmove, expand_builtin_mempcpy): Same.\n+\t(expand_builtin_strcat, expand_builtin_stpncpy): Same.\n+\t(check_strncat_sizes, expand_builtin_strncat): Same.\n+\t(expand_builtin_strncpy, expand_builtin_memset): Same.\n+\t(expand_builtin_bzero, expand_builtin_memcmp): Same.\n+\t(expand_builtin_memory_chk, maybe_emit_chk_warning): Same.\n+\t(maybe_emit_sprintf_chk_warning): Same.\n+\t(expand_builtin_strcpy): Adjust.\n+\t(expand_builtin_stpcpy): Same.\n+\t(expand_builtin_with_bounds): Detect out-of-bounds accesses\n+\tin pointer-checking forms of memcpy, memmove, and mempcpy.\n+\t(gcall_to_tree_minimal, max_object_size): Define new functions.\n+\t* builtins.h (max_object_size): Declare.\n+\t* calls.c (alloc_max_size): Call max_object_size instead of\n+\thardcoding ssizetype limit.\n+\t(get_size_range): Handle new argument.\n+\t* calls.h (get_size_range): Add a new argument.\n+\t* cfgexpand.c (expand_call_stmt): Propagate no-warning bit.\n+\t* doc/invoke.texi (-Wrestrict): Adjust, add example.\n+\t* gimple-fold.c (gimple_fold_builtin_memory_op): Detect overlapping\n+\toperations.\n+\t(gimple_fold_builtin_memory_chk): Same.\n+\t(gimple_fold_builtin_stxcpy_chk): New function.\n+\t* gimple-ssa-warn-restrict.c: New source.\n+\t* gimple-ssa-warn-restrict.h: New header.\n+\t* gimple.c (gimple_build_call_from_tree): Propagate location.\n+\t* passes.def (pass_warn_restrict): Add new pass.\n+\t* tree-pass.h (make_pass_warn_restrict): Declare.\n+\t* tree-ssa-strlen.c (handle_builtin_strcpy): Detect overlapping\n+\toperations.\n+\t(handle_builtin_strcat): Same.\n+\t(strlen_optimize_stmt): Rename...\n+\t(strlen_check_and_optimize_stmt): ...to this.  Handle strncat,\n+\tstpncpy, strncpy, and their checking forms.\n+\n 2017-12-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR rtl-optimization/82849"}, {"sha": "d9f27de0de38096b193b443211f1c3ff72cbb105", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1316,6 +1316,7 @@ OBJS = \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-ssa-sprintf.o \\\n \tgimple-ssa-warn-alloca.o \\\n+\tgimple-ssa-warn-restrict.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\\n \tgimple-walk.o \\"}, {"sha": "4b06f64c6300c1eee36d06498bfd28f10574fcf9", "filename": "gcc/builtins.c", "status": "modified", "additions": 186, "deletions": 160, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alias.h\"\n #include \"fold-const.h\"\n #include \"fold-const-call.h\"\n+#include \"gimple-ssa-warn-restrict.h\"\n #include \"stor-layout.h\"\n #include \"calls.h\"\n #include \"varasm.h\"\n@@ -3003,37 +3004,45 @@ determine_block_size (tree len, rtx len_rtx,\n \n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n-   the operation does not lead to buffer overflow.  Arguments other than\n-   EXP may be null.  When non-null, the arguments have the following\n-   meaning:\n-   SIZE is the user-supplied size argument to the function (such as in\n-   memcpy(d, s, SIZE) or strncpy(d, s, SIZE).  It specifies the exact\n-   number of bytes to write.\n-   MAXLEN is the user-supplied bound on the length of the source sequence\n+   the operation does not lead to buffer overflow or read past the end.\n+   Arguments other than EXP may be null.  When non-null, the arguments\n+   have the following meaning:\n+   DST is the destination of a copy call or NULL otherwise.\n+   SRC is the source of a copy call or NULL otherwise.\n+   DSTWRITE is the number of bytes written into the destination obtained\n+   from the user-supplied size argument to the function (such as in\n+   memcpy(DST, SRCs, DSTWRITE) or strncpy(DST, DRC, DSTWRITE).\n+   MAXREAD is the user-supplied bound on the length of the source sequence\n    (such as in strncat(d, s, N).  It specifies the upper limit on the number\n-   of bytes to write.\n-   SRC is the source string (such as in strcpy(d, s)) when the expression\n-   EXP is a string function call (as opposed to a memory call like memcpy).\n-   As an exception, SRC can also be an integer denoting the precomputed\n-   size of the source string or object (for functions like memcpy).\n-   OBJSIZE is the size of the destination object specified by the last\n+   of bytes to write.  If NULL, it's taken to be the same as DSTWRITE.\n+   SRCSTR is the source string (such as in strcpy(DST, SRC)) when the\n+   expression EXP is a string function call (as opposed to a memory call\n+   like memcpy).  As an exception, SRCSTR can also be an integer denoting\n+   the precomputed size of the source string or object (for functions like\n+   memcpy).\n+   DSTSIZE is the size of the destination object specified by the last\n    argument to the _chk builtins, typically resulting from the expansion\n-   of __builtin_object_size (such as in __builtin___strcpy_chk(d, s,\n-   OBJSIZE).\n+   of __builtin_object_size (such as in __builtin___strcpy_chk(DST, SRC,\n+   DSTSIZE).\n \n-   When SIZE is null LEN is checked to verify that it doesn't exceed\n+   When DSTWRITE is null LEN is checked to verify that it doesn't exceed\n    SIZE_MAX.\n \n-   If the call is successfully verified as safe from buffer overflow\n-   the function returns true, otherwise false..  */\n+   If the call is successfully verified as safe return true, otherwise\n+   return false.  */\n \n static bool\n-check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n+check_access (tree exp, tree, tree, tree dstwrite,\n+\t      tree maxread, tree srcstr, tree dstsize)\n {\n+  int opt = OPT_Wstringop_overflow_;\n+\n   /* The size of the largest object is half the address space, or\n-     SSIZE_MAX.  (This is way too permissive.)  */\n-  tree maxobjsize = TYPE_MAX_VALUE (ssizetype);\n+     PTRDIFF_MAX.  (This is way too permissive.)  */\n+  tree maxobjsize = max_object_size ();\n \n+  /* Either the length of the source string for string functions or\n+     the size of the source object for raw memory functions.  */\n   tree slen = NULL_TREE;\n \n   tree range[2] = { NULL_TREE, NULL_TREE };\n@@ -3042,28 +3051,28 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n      function like strcpy is not known and the only thing that is\n      known is that it must be at least one (for the terminating nul).  */\n   bool at_least_one = false;\n-  if (src)\n+  if (srcstr)\n     {\n-      /* SRC is normally a pointer to string but as a special case\n+      /* SRCSTR is normally a pointer to string but as a special case\n \t it can be an integer denoting the length of a string.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (src)))\n+      if (POINTER_TYPE_P (TREE_TYPE (srcstr)))\n \t{\n \t  /* Try to determine the range of lengths the source string\n \t     refers to.  If it can be determined and is less than\n-\t     the upper bound given by MAXLEN add one to it for\n+\t     the upper bound given by MAXREAD add one to it for\n \t     the terminating nul.  Otherwise, set it to one for\n-\t     the same reason, or to MAXLEN as appropriate.  */\n-\t  get_range_strlen (src, range);\n-\t  if (range[0] && (!maxlen || TREE_CODE (maxlen) == INTEGER_CST))\n+\t     the same reason, or to MAXREAD as appropriate.  */\n+\t  get_range_strlen (srcstr, range);\n+\t  if (range[0] && (!maxread || TREE_CODE (maxread) == INTEGER_CST))\n \t    {\n-\t      if (maxlen && tree_int_cst_le (maxlen, range[0]))\n-\t\trange[0] = range[1] = maxlen;\n+\t      if (maxread && tree_int_cst_le (maxread, range[0]))\n+\t\trange[0] = range[1] = maxread;\n \t      else\n \t\trange[0] = fold_build2 (PLUS_EXPR, size_type_node,\n \t\t\t\t\trange[0], size_one_node);\n \n-\t      if (maxlen && tree_int_cst_le (maxlen, range[1]))\n-\t\trange[1] = maxlen;\n+\t      if (maxread && tree_int_cst_le (maxread, range[1]))\n+\t\trange[1] = maxread;\n \t      else if (!integer_all_onesp (range[1]))\n \t\trange[1] = fold_build2 (PLUS_EXPR, size_type_node,\n \t\t\t\t\trange[1], size_one_node);\n@@ -3077,31 +3086,29 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n \t    }\n \t}\n       else\n-\tslen = src;\n+\tslen = srcstr;\n     }\n \n-  if (!size && !maxlen)\n+  if (!dstwrite && !maxread)\n     {\n       /* When the only available piece of data is the object size\n \t there is nothing to do.  */\n       if (!slen)\n \treturn true;\n \n       /* Otherwise, when the length of the source sequence is known\n-\t (as with with strlen), set SIZE to it.  */\n+\t (as with strlen), set DSTWRITE to it.  */\n       if (!range[0])\n-\tsize = slen;\n+\tdstwrite = slen;\n     }\n \n-  if (!objsize)\n-    objsize = maxobjsize;\n+  if (!dstsize)\n+    dstsize = maxobjsize;\n \n-  /* The SIZE is exact if it's non-null, constant, and in range of\n-     unsigned HOST_WIDE_INT.  */\n-  bool exactsize = size && tree_fits_uhwi_p (size);\n+  if (dstwrite)\n+    get_size_range (dstwrite, range);\n \n-  if (size)\n-    get_size_range (size, range);\n+  tree func = get_callee_fndecl (exp);\n \n   /* First check the number of bytes to be written against the maximum\n      object size.  */\n@@ -3114,38 +3121,42 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n \twarning_at (loc, opt,\n \t\t    \"%K%qD specified size %E \"\n \t\t    \"exceeds maximum object size %E\",\n-\t\t    exp, get_callee_fndecl (exp), range[0], maxobjsize);\n+\t\t    exp, func, range[0], maxobjsize);\n \t  else\n \t    warning_at (loc, opt,\n \t\t\t\"%K%qD specified size between %E and %E \"\n \t\t\t\"exceeds maximum object size %E\",\n-\t\t\texp, get_callee_fndecl (exp),\n+\t\t\texp, func,\n \t\t\trange[0], range[1], maxobjsize);\n       return false;\n     }\n \n+  /* The number of bytes to write is \"exact\" if DSTWRITE is non-null,\n+     constant, and in range of unsigned HOST_WIDE_INT.  */\n+  bool exactwrite = dstwrite && tree_fits_uhwi_p (dstwrite);\n+\n   /* Next check the number of bytes to be written against the destination\n      object size.  */\n-  if (range[0] || !exactsize || integer_all_onesp (size))\n+  if (range[0] || !exactwrite || integer_all_onesp (dstwrite))\n     {\n       if (range[0]\n-\t  && ((tree_fits_uhwi_p (objsize)\n-\t       && tree_int_cst_lt (objsize, range[0]))\n-\t      || (tree_fits_uhwi_p (size)\n-\t\t  && tree_int_cst_lt (size, range[0]))))\n+\t  && ((tree_fits_uhwi_p (dstsize)\n+\t       && tree_int_cst_lt (dstsize, range[0]))\n+\t      || (tree_fits_uhwi_p (dstwrite)\n+\t\t  && tree_int_cst_lt (dstwrite, range[0]))))\n \t{\n \t  location_t loc = tree_nonartificial_location (exp);\n \t  loc = expansion_point_location_if_in_system_header (loc);\n \n-\t  if (size == slen && at_least_one)\n+\t  if (dstwrite == slen && at_least_one)\n \t    {\n \t      /* This is a call to strcpy with a destination of 0 size\n \t\t and a source of unknown length.  The call will write\n \t\t at least one byte past the end of the destination.  */\n \t      warning_at (loc, opt,\n \t\t\t  \"%K%qD writing %E or more bytes into a region \"\n \t\t\t  \"of size %E overflows the destination\",\n-\t\t\t  exp, get_callee_fndecl (exp), range[0], objsize);\n+\t\t\t  exp, func, range[0], dstsize);\n \t    }\n \t  else if (tree_int_cst_equal (range[0], range[1]))\n \t    warning_at (loc, opt,\n@@ -3154,21 +3165,21 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n \t\t\t      \"of size %E overflows the destination\")\n \t\t\t : G_(\"%K%qD writing %E bytes into a region \"\n \t\t\t      \"of size %E overflows the destination\")),\n-\t\t\texp, get_callee_fndecl (exp), range[0], objsize);\n+\t\t\texp, func, range[0], dstsize);\n \t  else if (tree_int_cst_sign_bit (range[1]))\n \t    {\n \t      /* Avoid printing the upper bound if it's invalid.  */\n \t      warning_at (loc, opt,\n \t\t\t  \"%K%qD writing %E or more bytes into a region \"\n \t\t\t  \"of size %E overflows the destination\",\n-\t\t\t  exp, get_callee_fndecl (exp), range[0], objsize);\n+\t\t\t  exp, func, range[0], dstsize);\n \t    }\n \t  else\n \t    warning_at (loc, opt,\n \t\t\t\"%K%qD writing between %E and %E bytes into \"\n \t\t\t\"a region of size %E overflows the destination\",\n-\t\t\texp, get_callee_fndecl (exp), range[0],\trange[1],\n-\t\t\tobjsize);\n+\t\t\texp, func, range[0], range[1],\n+\t\t\tdstsize);\n \n \t  /* Return error when an overflow has been detected.  */\n \t  return false;\n@@ -3178,11 +3189,15 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n   /* Check the maximum length of the source sequence against the size\n      of the destination object if known, or against the maximum size\n      of an object.  */\n-  if (maxlen)\n+  if (maxread)\n     {\n-      get_size_range (maxlen, range);\n+      get_size_range (maxread, range);\n+\n+      /* Use the lower end for MAXREAD from now on.  */\n+      if (range[0])\n+\tmaxread = range[0];\n \n-      if (range[0] && objsize && tree_fits_uhwi_p (objsize))\n+      if (range[0] && dstsize && tree_fits_uhwi_p (dstsize))\n \t{\n \t  location_t loc = tree_nonartificial_location (exp);\n \t  loc = expansion_point_location_if_in_system_header (loc);\n@@ -3196,40 +3211,41 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n \t\twarning_at (loc, opt,\n \t\t\t    \"%K%qD specified bound %E \"\n \t\t\t    \"exceeds maximum object size %E\",\n-\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    exp, func,\n \t\t\t    range[0], maxobjsize);\n \t      else\n \t\twarning_at (loc, opt,\n \t\t\t    \"%K%qD specified bound between %E and %E \"\n \t\t\t    \"exceeds maximum object size %E\",\n-\t\t\t    exp, get_callee_fndecl (exp),\n+\t\t\t    exp, func,\n \t\t\t    range[0], range[1], maxobjsize);\n \n \t      return false;\n \t    }\n \n-\t  if (objsize != maxobjsize && tree_int_cst_lt (objsize, range[0]))\n+\t  if (dstsize != maxobjsize && tree_int_cst_lt (dstsize, range[0]))\n \t    {\n \t      if (tree_int_cst_equal (range[0], range[1]))\n \t\twarning_at (loc, opt,\n \t\t\t    \"%K%qD specified bound %E \"\n \t\t\t    \"exceeds destination size %E\",\n-\t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    range[0], objsize);\n+\t\t\t    exp, func,\n+\t\t\t    range[0], dstsize);\n \t      else\n \t\twarning_at (loc, opt,\n \t\t\t    \"%K%qD specified bound between %E and %E \"\n \t\t\t    \"exceeds destination size %E\",\n-\t\t\t    exp, get_callee_fndecl (exp),\n-\t\t\t    range[0], range[1], objsize);\n+\t\t\t    exp, func,\n+\t\t\t    range[0], range[1], dstsize);\n \t      return false;\n \t    }\n \t}\n     }\n \n+  /* Check for reading past the end of SRC.  */\n   if (slen\n-      && slen == src\n-      && size && range[0]\n+      && slen == srcstr\n+      && dstwrite && range[0]\n       && tree_int_cst_lt (slen, range[0]))\n     {\n       location_t loc = tree_nonartificial_location (exp);\n@@ -3239,20 +3255,20 @@ check_sizes (int opt, tree exp, tree size, tree maxlen, tree src, tree objsize)\n \t\t    (tree_int_cst_equal (range[0], integer_one_node)\n \t\t     ? G_(\"%K%qD reading %E byte from a region of size %E\")\n \t\t     : G_(\"%K%qD reading %E bytes from a region of size %E\")),\n-\t\t    exp, get_callee_fndecl (exp), range[0], slen);\n+\t\t    exp, func, range[0], slen);\n       else if (tree_int_cst_sign_bit (range[1]))\n \t{\n \t  /* Avoid printing the upper bound if it's invalid.  */\n \t  warning_at (loc, opt,\n \t\t      \"%K%qD reading %E or more bytes from a region \"\n \t\t      \"of size %E\",\n-\t\t      exp, get_callee_fndecl (exp), range[0], slen);\n+\t\t      exp, func, range[0], slen);\n \t}\n       else\n \twarning_at (loc, opt,\n \t\t    \"%K%qD reading between %E and %E bytes from a region \"\n \t\t    \"of size %E\",\n-\t\t    exp, get_callee_fndecl (exp), range[0], range[1], slen);\n+\t\t    exp, func, range[0], range[1], slen);\n       return false;\n     }\n \n@@ -3325,20 +3341,17 @@ compute_objsize (tree dest, int ostype)\n    (no overflow or invalid sizes), false otherwise.  */\n \n static bool\n-check_memop_sizes (tree exp, tree dest, tree src, tree size)\n+check_memop_access (tree exp, tree dest, tree src, tree size)\n {\n-  if (!warn_stringop_overflow)\n-    return true;\n-\n   /* For functions like memset and memcpy that operate on raw memory\n      try to determine the size of the largest source and destination\n      object using type-0 Object Size regardless of the object size\n      type specified by the option.  */\n   tree srcsize = src ? compute_objsize (src, 0) : NULL_TREE;\n   tree dstsize = compute_objsize (dest, 0);\n \n-  return check_sizes (OPT_Wstringop_overflow_, exp,\n-\t\t      size, /*maxlen=*/NULL_TREE, srcsize, dstsize);\n+  return check_access (exp, dest, src, size, /*maxread=*/NULL_TREE,\n+\t\t       srcsize, dstsize);\n }\n \n /* Validate memchr arguments without performing any expansion.\n@@ -3359,9 +3372,8 @@ expand_builtin_memchr (tree exp, rtx)\n   if (warn_stringop_overflow)\n     {\n       tree size = compute_objsize (arg1, 0);\n-      check_sizes (OPT_Wstringop_overflow_,\n-\t\t   exp, len, /*maxlen=*/NULL_TREE,\n-\t\t   size, /*objsize=*/NULL_TREE);\n+      check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n+\t\t    /*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE);\n     }\n \n   return NULL_RTX;\n@@ -3383,7 +3395,7 @@ expand_builtin_memcpy (tree exp, rtx target)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, src, len);\n+  check_memop_access (exp, dest, src, len);\n \n   return expand_builtin_memory_copy_args (dest, src, len, target, exp,\n \t\t\t\t\t  /*endp=*/ 0);\n@@ -3403,7 +3415,7 @@ expand_builtin_memmove (tree exp, rtx)\n   tree src = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, src, len);\n+  check_memop_access (exp, dest, src, len);\n \n   return NULL_RTX;\n }\n@@ -3462,7 +3474,7 @@ expand_builtin_mempcpy (tree exp, rtx target)\n   /* Avoid expanding mempcpy into memcpy when the call is determined\n      to overflow the buffer.  This also prevents the same overflow\n      from being diagnosed again when expanding memcpy.  */\n-  if (!check_memop_sizes (exp, dest, src, len))\n+  if (!check_memop_access (exp, dest, src, len))\n     return NULL_RTX;\n \n   return expand_builtin_mempcpy_args (dest, src, len,\n@@ -3668,8 +3680,8 @@ expand_builtin_strcat (tree exp, rtx)\n \n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n-  check_sizes (OPT_Wstringop_overflow_,\n-\t       exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n+  check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE, src,\n+\t\tdestsize);\n \n   return NULL_RTX;\n }\n@@ -3691,8 +3703,8 @@ expand_builtin_strcpy (tree exp, rtx target)\n   if (warn_stringop_overflow)\n     {\n       tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n-      check_sizes (OPT_Wstringop_overflow_,\n-\t\t   exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n+      check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n+\t\t    src, destsize);\n     }\n \n   return expand_builtin_strcpy_args (dest, src, target);\n@@ -3730,8 +3742,8 @@ expand_builtin_stpcpy (tree exp, rtx target, machine_mode mode)\n   if (warn_stringop_overflow)\n     {\n       tree destsize = compute_objsize (dst, warn_stringop_overflow - 1);\n-      check_sizes (OPT_Wstringop_overflow_,\n-\t\t   exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, src, destsize);\n+      check_access (exp, dst, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n+\t\t    src, destsize);\n     }\n \n   /* If return value is ignored, transform stpcpy into strcpy.  */\n@@ -3814,8 +3826,7 @@ expand_builtin_stpncpy (tree exp, rtx)\n   /* The size of the destination object.  */\n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n-  check_sizes (OPT_Wstringop_overflow_,\n-\t       exp, len, /*maxlen=*/NULL_TREE, src, destsize);\n+  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src, destsize);\n \n   return NULL_RTX;\n }\n@@ -3845,7 +3856,7 @@ check_strncat_sizes (tree exp, tree objsize)\n {\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree src = CALL_EXPR_ARG (exp, 1);\n-  tree maxlen = CALL_EXPR_ARG (exp, 2);\n+  tree maxread = CALL_EXPR_ARG (exp, 2);\n \n   /* Try to determine the range of lengths that the source expression\n      refers to.  */\n@@ -3869,32 +3880,32 @@ check_strncat_sizes (tree exp, tree objsize)\n \t\t\t\tsize_one_node)\n \t\t : NULL_TREE);\n \n-  /* Strncat copies at most MAXLEN bytes and always appends the terminating\n-     nul so the specified upper bound should never be equal to (or greater\n-     than) the size of the destination.  */\n-  if (tree_fits_uhwi_p (maxlen) && tree_fits_uhwi_p (objsize)\n-      && tree_int_cst_equal (objsize, maxlen))\n+  /* The strncat function copies at most MAXREAD bytes and always appends\n+     the terminating nul so the specified upper bound should never be equal\n+     to (or greater than) the size of the destination.  */\n+  if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (objsize)\n+      && tree_int_cst_equal (objsize, maxread))\n     {\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n       warning_at (loc, OPT_Wstringop_overflow_,\n \t\t  \"%K%qD specified bound %E equals destination size\",\n-\t\t  exp, get_callee_fndecl (exp), maxlen);\n+\t\t  exp, get_callee_fndecl (exp), maxread);\n \n       return false;\n     }\n \n   if (!srclen\n-      || (maxlen && tree_fits_uhwi_p (maxlen)\n+      || (maxread && tree_fits_uhwi_p (maxread)\n \t  && tree_fits_uhwi_p (srclen)\n-\t  && tree_int_cst_lt (maxlen, srclen)))\n-    srclen = maxlen;\n+\t  && tree_int_cst_lt (maxread, srclen)))\n+    srclen = maxread;\n \n-  /* The number of bytes to write is LEN but check_sizes will also\n+  /* The number of bytes to write is LEN but check_access will also\n      check SRCLEN if LEN's value isn't known.  */\n-  return check_sizes (OPT_Wstringop_overflow_,\n-\t\t      exp, /*size=*/NULL_TREE, maxlen, srclen, objsize);\n+  return check_access (exp, dest, src, /*size=*/NULL_TREE, maxread, srclen,\n+\t\t       objsize);\n }\n \n /* Similar to expand_builtin_strcat, do some very basic size validation\n@@ -3912,7 +3923,7 @@ expand_builtin_strncat (tree exp, rtx)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree src = CALL_EXPR_ARG (exp, 1);\n   /* The upper bound on the number of bytes to write.  */\n-  tree maxlen = CALL_EXPR_ARG (exp, 2);\n+  tree maxread = CALL_EXPR_ARG (exp, 2);\n   /* The length of the source sequence.  */\n   tree slen = c_strlen (src, 1);\n \n@@ -3935,52 +3946,34 @@ expand_builtin_strncat (tree exp, rtx)\n \t\t\t\tsize_one_node)\n \t\t : NULL_TREE);\n \n-  /* Strncat copies at most MAXLEN bytes and always appends the terminating\n-     nul so the specified upper bound should never be equal to (or greater\n-     than) the size of the destination.  */\n-  if (tree_fits_uhwi_p (maxlen) && tree_fits_uhwi_p (destsize)\n-      && tree_int_cst_equal (destsize, maxlen))\n+  /* The strncat function copies at most MAXREAD bytes and always appends\n+     the terminating nul so the specified upper bound should never be equal\n+     to (or greater than) the size of the destination.  */\n+  if (tree_fits_uhwi_p (maxread) && tree_fits_uhwi_p (destsize)\n+      && tree_int_cst_equal (destsize, maxread))\n     {\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n       warning_at (loc, OPT_Wstringop_overflow_,\n \t\t  \"%K%qD specified bound %E equals destination size\",\n-\t\t  exp, get_callee_fndecl (exp), maxlen);\n+\t\t  exp, get_callee_fndecl (exp), maxread);\n \n       return NULL_RTX;\n     }\n \n   if (!srclen\n-      || (maxlen && tree_fits_uhwi_p (maxlen)\n+      || (maxread && tree_fits_uhwi_p (maxread)\n \t  && tree_fits_uhwi_p (srclen)\n-\t  && tree_int_cst_lt (maxlen, srclen)))\n-    srclen = maxlen;\n+\t  && tree_int_cst_lt (maxread, srclen)))\n+    srclen = maxread;\n \n-  /* The number of bytes to write is LEN but check_sizes will also\n-     check SRCLEN if LEN's value isn't known.  */\n-  check_sizes (OPT_Wstringop_overflow_,\n-\t       exp, /*size=*/NULL_TREE, maxlen, srclen, destsize);\n+  /* The number of bytes to write is SRCLEN.  */\n+  check_access (exp, dest, src, NULL_TREE, maxread, srclen, destsize);\n \n   return NULL_RTX;\n }\n \n-/* Helper to check the sizes of sequences and the destination of calls\n-   to __builtin_strncpy (DST, SRC, CNT) and __builtin___strncpy_chk.\n-   Returns true on success (no overflow warning), false otherwise.  */\n-\n-static bool\n-check_strncpy_sizes (tree exp, tree dst, tree src, tree cnt)\n-{\n-  tree dstsize = compute_objsize (dst, warn_stringop_overflow - 1);\n-\n-  if (!check_sizes (OPT_Wstringop_overflow_,\n-\t\t    exp, cnt, /*maxlen=*/NULL_TREE, src, dstsize))\n-    return false;\n-\n-  return true;\n-}\n-\n /* Expand expression EXP, which is a call to the strncpy builtin.  Return\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n@@ -3999,7 +3992,16 @@ expand_builtin_strncpy (tree exp, rtx target)\n       /* The length of the source sequence.  */\n       tree slen = c_strlen (src, 1);\n \n-      check_strncpy_sizes (exp, dest, src, len);\n+      if (warn_stringop_overflow)\n+\t{\n+\t  tree destsize = compute_objsize (dest,\n+\t\t\t\t\t   warn_stringop_overflow - 1);\n+\n+\t  /* The number of bytes to write is LEN but check_access will also\n+\t     check SLEN if LEN's value isn't known.  */\n+\t  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src,\n+\t\t\tdestsize);\n+\t}\n \n       /* We must be passed a constant len and src parameter.  */\n       if (!tree_fits_uhwi_p (len) || !slen || !tree_fits_uhwi_p (slen))\n@@ -4093,7 +4095,7 @@ expand_builtin_memset (tree exp, rtx target, machine_mode mode)\n   tree val = CALL_EXPR_ARG (exp, 1);\n   tree len = CALL_EXPR_ARG (exp, 2);\n \n-  check_memop_sizes (exp, dest, NULL_TREE, len);\n+  check_memop_access (exp, dest, NULL_TREE, len);\n \n   return expand_builtin_memset_args (dest, val, len, target, mode, exp);\n }\n@@ -4282,7 +4284,7 @@ expand_builtin_bzero (tree exp)\n   tree dest = CALL_EXPR_ARG (exp, 0);\n   tree size = CALL_EXPR_ARG (exp, 1);\n \n-  check_memop_sizes (exp, dest, NULL_TREE, size);\n+  check_memop_access (exp, dest, NULL_TREE, size);\n \n   /* New argument list transforming bzero(ptr x, int y) to\n      memset(ptr x, int 0, size_t y).   This is done this way\n@@ -4341,14 +4343,12 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n   if (warn_stringop_overflow)\n     {\n       tree size = compute_objsize (arg1, 0);\n-      if (check_sizes (OPT_Wstringop_overflow_,\n-\t\t       exp, len, /*maxlen=*/NULL_TREE,\n-\t\t       size, /*objsize=*/NULL_TREE))\n+      if (check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n+\t\t\t/*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE))\n \t{\n \t  size = compute_objsize (arg2, 0);\n-\t  check_sizes (OPT_Wstringop_overflow_,\n-\t\t       exp, len, /*maxlen=*/NULL_TREE,\n-\t\t       size, /*objsize=*/NULL_TREE);\n+\t  check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n+\t\t\t/*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE);\n \t}\n     }\n \n@@ -7718,6 +7718,23 @@ expand_builtin_with_bounds (tree exp, rtx target,\n \treturn target;\n       break;\n \n+    case BUILT_IN_MEMCPY_CHKP:\n+    case BUILT_IN_MEMMOVE_CHKP:\n+    case BUILT_IN_MEMPCPY_CHKP:\n+      if (call_expr_nargs (exp) > 3)\n+\t{\n+\t  /* memcpy_chkp (void *dst, size_t dstbnd,\n+\t                  const void *src, size_t srcbnd, size_t n)\n+  \t     and others take a pointer bound argument just after each\n+\t     pointer argument.  */\n+\t  tree dest = CALL_EXPR_ARG (exp, 0);\n+\t  tree src = CALL_EXPR_ARG (exp, 2);\n+\t  tree len = CALL_EXPR_ARG (exp, 4);\n+\n+\t  check_memop_access (exp, dest, src, len);\n+\t  break;\n+\t}\n+\n     default:\n       break;\n     }\n@@ -9735,23 +9752,20 @@ static rtx\n expand_builtin_memory_chk (tree exp, rtx target, machine_mode mode,\n \t\t\t   enum built_in_function fcode)\n {\n-  tree dest, src, len, size;\n-\n   if (!validate_arglist (exp,\n \t\t\t POINTER_TYPE,\n \t\t\t fcode == BUILT_IN_MEMSET_CHK\n \t\t\t ? INTEGER_TYPE : POINTER_TYPE,\n \t\t\t INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-  dest = CALL_EXPR_ARG (exp, 0);\n-  src = CALL_EXPR_ARG (exp, 1);\n-  len = CALL_EXPR_ARG (exp, 2);\n-  size = CALL_EXPR_ARG (exp, 3);\n+  tree dest = CALL_EXPR_ARG (exp, 0);\n+  tree src = CALL_EXPR_ARG (exp, 1);\n+  tree len = CALL_EXPR_ARG (exp, 2);\n+  tree size = CALL_EXPR_ARG (exp, 3);\n \n-  bool sizes_ok = check_sizes (OPT_Wstringop_overflow_,\n-\t\t\t       exp, len, /*maxlen=*/NULL_TREE,\n-\t\t\t       /*str=*/NULL_TREE, size);\n+  bool sizes_ok = check_access (exp, dest, src, len, /*maxread=*/NULL_TREE,\n+\t\t\t\t/*str=*/NULL_TREE, size);\n \n   if (!tree_fits_uhwi_p (size))\n     return NULL_RTX;\n@@ -9860,7 +9874,7 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n   /* The maximum length of the source sequence in a bounded operation\n      (such as __strncat_chk) or null if the operation isn't bounded\n      (such as __strcat_chk).  */\n-  tree maxlen = NULL_TREE;\n+  tree maxread = NULL_TREE;\n   /* The exact size of the access (such as in __strncpy_chk).  */\n   tree size = NULL_TREE;\n \n@@ -9883,7 +9897,7 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n     case BUILT_IN_STRNCAT_CHK:\n       catstr = CALL_EXPR_ARG (exp, 0);\n       srcstr = CALL_EXPR_ARG (exp, 1);\n-      maxlen = CALL_EXPR_ARG (exp, 2);\n+      maxread = CALL_EXPR_ARG (exp, 2);\n       objsize = CALL_EXPR_ARG (exp, 3);\n       break;\n \n@@ -9896,14 +9910,14 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n \n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n-      maxlen = CALL_EXPR_ARG (exp, 1);\n+      maxread = CALL_EXPR_ARG (exp, 1);\n       objsize = CALL_EXPR_ARG (exp, 3);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n-  if (catstr && maxlen)\n+  if (catstr && maxread)\n     {\n       /* Check __strncat_chk.  There is no way to determine the length\n \t of the string to which the source string is being appended so\n@@ -9912,8 +9926,10 @@ maybe_emit_chk_warning (tree exp, enum built_in_function fcode)\n       return;\n     }\n \n-  check_sizes (OPT_Wstringop_overflow_, exp,\n-\t       size, maxlen, srcstr, objsize);\n+  /* The destination argument is the first one for all built-ins above.  */\n+  tree dst = CALL_EXPR_ARG (exp, 0);\n+\n+  check_access (exp, dst, srcstr, size, maxread, srcstr, objsize);\n }\n \n /* Emit warning if a buffer overflow is detected at compile time\n@@ -9969,8 +9985,9 @@ maybe_emit_sprintf_chk_warning (tree exp, enum built_in_function fcode)\n \n   /* Add one for the terminating nul.  */\n   len = fold_build2 (PLUS_EXPR, TREE_TYPE (len), len, size_one_node);\n-  check_sizes (OPT_Wstringop_overflow_,\n-\t       exp, /*size=*/NULL_TREE, /*maxlen=*/NULL_TREE, len, size);\n+\n+  check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, /*size=*/NULL_TREE,\n+\t\t/*maxread=*/NULL_TREE, len, size);\n }\n \n /* Emit warning if a free is called with address of a variable.  */\n@@ -10600,3 +10617,12 @@ target_char_cst_p (tree t, char *p)\n   *p = (char)tree_to_uhwi (t);\n   return true;\n }\n+\n+/* Return the maximum object size.  */\n+\n+tree\n+max_object_size (void)\n+{\n+  /* To do: Make this a configurable parameter.  */\n+  return TYPE_MAX_VALUE (ptrdiff_type_node);\n+}"}, {"sha": "7f34d296dedd1ae48f542f5f22e86548beb145b0", "filename": "gcc/builtins.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -103,4 +103,6 @@ extern bool target_char_cst_p (tree t, char *p);\n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);\n \n-#endif\n+extern tree max_object_size ();\n+\n+#endif /* GCC_BUILTINS_H */"}, {"sha": "0f0a370d8de10fad9e3bc3a8eb5e57d78947e103", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,3 +1,9 @@\n+2017-12-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78918\n+\t* c-common.c (check_function_restrict): Avoid checking built-ins.\n+\t* c.opt (-Wrestrict): Include in -Wall.\n+\n 2017-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-attribs.c (c_common_attribute_table,"}, {"sha": "197a71f5084c53352e7fa019131ad2635b984cc3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -5319,14 +5319,20 @@ check_function_restrict (const_tree fndecl, const_tree fntype,\n \t\t\t int nargs, tree *argarray)\n {\n   int i;\n-  tree parms;\n+  tree parms = TYPE_ARG_TYPES (fntype);\n \n   if (fndecl\n-      && TREE_CODE (fndecl) == FUNCTION_DECL\n-      && DECL_ARGUMENTS (fndecl))\n-    parms = DECL_ARGUMENTS (fndecl);\n-  else\n-    parms = TYPE_ARG_TYPES (fntype);\n+      && TREE_CODE (fndecl) == FUNCTION_DECL)\n+    {\n+      /* Skip checking built-ins here.  They are checked in more\n+\t detail elsewhere.  */\n+      if (DECL_BUILT_IN (fndecl)\n+\t  && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+\treturn;\n+\n+      if (DECL_ARGUMENTS (fndecl))\n+\tparms = DECL_ARGUMENTS (fndecl);\n+    }\n \n   for (i = 0; i < nargs; i++)\n     TREE_VISITED (argarray[i]) = 0;"}, {"sha": "5b929d9f15f8db77d2f27aabb969093d3e4d9dd6", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1178,7 +1178,7 @@ C ObjC Var(warn_duplicate_decl_specifier) Warning LangEnabledBy(C ObjC,Wall)\n Warn when a declaration has duplicate const, volatile, restrict or _Atomic specifier.\n \n Wrestrict\n-C ObjC C++ ObjC++ Var(warn_restrict) Warning LangEnabledBy(C ObjC C++ ObjC++)\n+C ObjC C++ ObjC++ Var(warn_restrict) Warning LangEnabledBy(C ObjC C++ ObjC++, Wall)\n Warn when an argument passed to a restrict-qualified parameter aliases with\n another argument.\n "}, {"sha": "da6c96b8131d9706f5a1c001e7d98ad0cad5e118", "filename": "gcc/calls.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"builtins.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -1194,7 +1195,7 @@ alloc_max_size (void)\n {\n   if (!alloc_object_size_limit)\n     {\n-      alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);\n+      alloc_object_size_limit = max_object_size ();\n \n       if (warn_alloc_size_limit)\n \t{\n@@ -1245,7 +1246,8 @@ alloc_max_size (void)\n \t\t{\n \t\t  widest_int w = wi::mul (limit, unit);\n \t\t  if (w < wi::to_widest (alloc_object_size_limit))\n-\t\t    alloc_object_size_limit = wide_int_to_tree (ssizetype, w);\n+\t\t    alloc_object_size_limit\n+\t\t      = wide_int_to_tree (ptrdiff_type_node, w);\n \t\t}\n \t    }\n \t}\n@@ -1254,13 +1256,17 @@ alloc_max_size (void)\n }\n \n /* Return true when EXP's range can be determined and set RANGE[] to it\n-   after adjusting it if necessary to make EXP a valid size argument to\n-   an allocation function declared with attribute alloc_size (whose\n-   argument may be signed), or to a string manipulation function like\n-   memset.  */\n+   after adjusting it if necessary to make EXP a represents a valid size\n+   of object, or a valid size argument to an allocation function declared\n+   with attribute alloc_size (whose argument may be signed), or to a string\n+   manipulation function like memset.  When ALLOW_ZERO is true, allow\n+   returning a range of [0, 0] for a size in an anti-range [1, N] where\n+   N > PTRDIFF_MAX.  A zero range is a (nearly) invalid argument to\n+   allocation functions like malloc but it is a valid argument to\n+   functions like memset.  */\n \n bool\n-get_size_range (tree exp, tree range[2])\n+get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n {\n   if (tree_fits_uhwi_p (exp))\n     {\n@@ -1269,20 +1275,33 @@ get_size_range (tree exp, tree range[2])\n       return true;\n     }\n \n+  tree exptype = TREE_TYPE (exp);\n+  bool integral = INTEGRAL_TYPE_P (exptype);\n+\n   wide_int min, max;\n-  enum value_range_type range_type\n-    = ((TREE_CODE (exp) == SSA_NAME && INTEGRAL_TYPE_P (TREE_TYPE (exp)))\n-       ? get_range_info (exp, &min, &max) : VR_VARYING);\n+  enum value_range_type range_type;\n+\n+  if (TREE_CODE (exp) == SSA_NAME && integral)\n+    range_type = get_range_info (exp, &min, &max);\n+  else\n+    range_type = VR_VARYING;\n \n   if (range_type == VR_VARYING)\n     {\n-      /* No range information available.  */\n+      if (integral)\n+\t{\n+\t  /* Use the full range of the type of the expression when\n+\t     no value range information is available.  */\n+\t  range[0] = TYPE_MIN_VALUE (exptype);\n+\t  range[1] = TYPE_MAX_VALUE (exptype);\n+\t  return true;\n+\t}\n+\n       range[0] = NULL_TREE;\n       range[1] = NULL_TREE;\n       return false;\n     }\n \n-  tree exptype = TREE_TYPE (exp);\n   unsigned expprec = TYPE_PRECISION (exptype);\n \n   bool signed_p = !TYPE_UNSIGNED (exptype);\n@@ -1320,11 +1339,16 @@ get_size_range (tree exp, tree range[2])\n \t{\n \t  /* EXP is unsigned and not in the range [1, MAX].  That means\n \t     it's either zero or greater than MAX.  Even though 0 would\n-\t     normally be detected by -Walloc-zero set the range to\n-\t     [MAX, TYPE_MAX] so that when MAX is greater than the limit\n-\t     the whole range is diagnosed.  */\n-\t  min = max + 1;\n-\t  max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t     normally be detected by -Walloc-zero, unless ALLOW_ZERO\n+\t     is true, set the range to [MAX, TYPE_MAX] so that when MAX\n+\t     is greater than the limit the whole range is diagnosed.  */\n+\t  if (allow_zero)\n+\t    min = max = wi::zero (expprec);\n+\t  else\n+\t    {\n+\t      min = max + 1;\n+\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "641166e23a3734fc493461fd04092c5fed8f8c02", "filename": "gcc/calls.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -38,8 +38,8 @@ extern bool pass_by_reference (CUMULATIVE_ARGS *, machine_mode,\n extern bool reference_callee_copied (CUMULATIVE_ARGS *, machine_mode,\n \t\t\t\t     tree, bool);\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n-extern bool get_size_range (tree, tree[2]);\n extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n extern void maybe_warn_nonstring_arg (tree, tree);\n+extern bool get_size_range (tree, tree[2], bool = false);\n \n #endif // GCC_CALLS_H"}, {"sha": "467bad5dab35f50247b1f8c45e806f689987af1e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -2639,6 +2639,9 @@ expand_call_stmt (gcall *stmt)\n   if (gimple_call_nothrow_p (stmt))\n     TREE_NOTHROW (exp) = 1;\n \n+  if (gimple_no_warning_p (stmt))\n+    TREE_NO_WARNING (exp) = 1;\n+\n   CALL_EXPR_TAILCALL (exp) = gimple_call_tail_p (stmt);\n   CALL_EXPR_MUST_TAIL_CALL (exp) = gimple_call_must_tail_p (stmt);\n   CALL_EXPR_RETURN_SLOT_OPT (exp) = gimple_call_return_slot_opt_p (stmt);"}, {"sha": "27b07b9e87f9743c06c4fb4d8eccd33bded7a229", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -3868,6 +3868,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wparentheses  @gol\n -Wpointer-sign  @gol\n -Wreorder   @gol\n+-Wrestrict   @gol\n -Wreturn-type  @gol\n -Wsequence-point  @gol\n -Wsign-compare @r{(only in C++)}  @gol\n@@ -6711,11 +6712,25 @@ reduce the padding and so make the structure smaller.\n Warn if anything is declared more than once in the same scope, even in\n cases where multiple declaration is valid and changes nothing.\n \n-@item -Wrestrict\n+@item -Wno-restrict\n @opindex Wrestrict\n @opindex Wno-restrict\n-Warn when an argument passed to a restrict-qualified parameter\n-aliases with another argument.\n+Warn when an object referenced by a @code{restrict}-qualified parameter\n+(or, in C++, a @code{__restrict}-qualified parameter) is aliased by another\n+argument, or when copies between such objects overlap.  For example,\n+the call to the @code{strcpy} function below attempts to truncate the string\n+by replacing its initial characters with the last four.  However, because\n+the call writes the terminating NUL into @code{a[4]}, the copies overlap and\n+the call is diagnosed.\n+\n+@smallexample\n+struct foo\n+@{\n+  char a[] = \"abcd1234\";\n+  strcpy (a, a + 4);\n+@};\n+@end smallexample\n+The @option{-Wrestrict} is included in @option{-Wall}.\n \n @item -Wnested-externs @r{(C and Objective-C only)}\n @opindex Wnested-externs"}, {"sha": "87ce3d887ce94aa6776744adbff6c716d5628975", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"cgraph.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"gimple-ssa-warn-restrict.h\"\n #include \"fold-const.h\"\n #include \"stmt.h\"\n #include \"expr.h\"\n@@ -663,13 +664,12 @@ size_must_be_zero_p (tree size)\n   return wi::eq_p (min, wone) && wi::geu_p (max, ssize_max);\n }\n \n-/* Fold function call to builtin mem{{,p}cpy,move}.  Return\n-   false if no simplification can be made.\n-   If ENDP is 0, return DEST (like memcpy).\n-   If ENDP is 1, return DEST+LEN (like mempcpy).\n-   If ENDP is 2, return DEST+LEN-1 (like stpcpy).\n-   If ENDP is 3, return DEST, additionally *SRC and *DEST may overlap\n-   (memmove).   */\n+/* Fold function call to builtin mem{{,p}cpy,move}.  Try to detect and\n+   diagnose (otherwise undefined) overlapping copies without preventing\n+   folding.  When folded, GCC guarantees that overlapping memcpy has\n+   the same semantics as memmove.  Call to the library memcpy need not\n+   provide the same guarantee.  Return false if no simplification can\n+   be made.  */\n \n static bool\n gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n@@ -681,6 +681,12 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n   tree destvar, srcvar;\n   location_t loc = gimple_location (stmt);\n \n+  tree func = gimple_call_fndecl (stmt);\n+  bool nowarn = gimple_no_warning_p (stmt);\n+  bool check_overlap = (DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE\n+\t\t\t&& DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE_CHK\n+\t\t\t&& !nowarn);\n+\n   /* If the LEN parameter is a constant zero or in range where\n      the only valid value is zero, return DEST.  */\n   if (size_must_be_zero_p (len))\n@@ -704,6 +710,15 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n      DEST{,+LEN,+LEN-1}.  */\n   if (operand_equal_p (src, dest, 0))\n     {\n+      /* Avoid diagnosing exact overlap in calls to __builtin_memcpy.\n+\t It's safe and may even be emitted by GCC itself (see bug\n+\t 32667).  However, diagnose it in explicit calls to the memcpy\n+\t function.  */\n+      if (check_overlap && *IDENTIFIER_POINTER (DECL_NAME (func)) != '_')\n+      \twarning_at (loc, OPT_Wrestrict,\n+      \t\t    \"%qD source argument is the same as destination\",\n+      \t\t    func);\n+\n       unlink_stmt_vdef (stmt);\n       if (gimple_vdef (stmt) && TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n \trelease_ssa_name (gimple_vdef (stmt));\n@@ -753,6 +768,13 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t  unsigned ilen = tree_to_uhwi (len);\n \t  if (pow2p_hwi (ilen))\n \t    {\n+\t      /* Detect invalid bounds and overlapping copies and issue\n+\t\t either -Warray-bounds or -Wrestrict.  */\n+\t      if (!nowarn\n+\t\t  && check_bounds_or_overlap (as_a <gcall *>(stmt),\n+\t\t\t\t\t      dest, src, len, len))\n+\t      \tgimple_set_no_warning (stmt, true);\n+\n \t      scalar_int_mode mode;\n \t      tree type = lang_hooks.types.type_for_size (ilen * 8, 1);\n \t      if (type\n@@ -1025,6 +1047,11 @@ gimple_fold_builtin_memory_op (gimple_stmt_iterator *gsi,\n \t    }\n \t}\n \n+      /* Detect invalid bounds and overlapping copies and issue either\n+\t -Warray-bounds or -Wrestrict.  */\n+      if (!nowarn)\n+\tcheck_bounds_or_overlap (as_a <gcall *>(stmt), dest, src, len, len);\n+\n       gimple *new_stmt;\n       if (is_gimple_reg_type (TREE_TYPE (srcvar)))\n \t{\n@@ -1418,7 +1445,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    tree op3 = gimple_assign_rhs3 (def_stmt);\n \t    return get_range_strlen (op2, length, visited, type, fuzzy, flexp)\n \t      && get_range_strlen (op3, length, visited, type, fuzzy, flexp);\n-          }\n+\t  }\n         return false;\n \n       case GIMPLE_PHI:\n@@ -1510,12 +1537,19 @@ static bool\n gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n \t\t\t    tree dest, tree src)\n {\n-  location_t loc = gimple_location (gsi_stmt (*gsi));\n+  gimple *stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n   tree fn;\n \n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (operand_equal_p (src, dest, 0))\n     {\n+      tree func = gimple_call_fndecl (stmt);\n+\n+      warning_at (loc, OPT_Wrestrict,\n+\t\t  \"%qD source argument is the same as destination\",\n+\t\t  func);\n+\n       replace_call_with_value (gsi, dest);\n       return true;\n     }\n@@ -2416,6 +2450,15 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n      (resp. DEST+LEN for __mempcpy_chk).  */\n   if (fcode != BUILT_IN_MEMSET_CHK && operand_equal_p (src, dest, 0))\n     {\n+      if (fcode != BUILT_IN_MEMMOVE && fcode != BUILT_IN_MEMMOVE_CHK)\n+\t{\n+\t  tree func = gimple_call_fndecl (stmt);\n+\n+\t  warning_at (loc, OPT_Wrestrict,\n+\t\t      \"%qD source argument is the same as destination\",\n+\t\t      func);\n+\t}\n+\n       if (fcode != BUILT_IN_MEMPCPY_CHK)\n \t{\n \t  replace_call_with_value (gsi, dest);\n@@ -2517,6 +2560,12 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n     {\n+      tree func = gimple_call_fndecl (stmt);\n+\n+      warning_at (loc, OPT_Wrestrict,\n+\t\t  \"%qD source argument is the same as destination\",\n+\t\t  func);\n+\n       replace_call_with_value (gsi, dest);\n       return true;\n     }"}, {"sha": "f524e1dc3d53a732efe5fa246e2995f09456f33b", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "added", "additions": 1761, "deletions": 0, "changes": 1761, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,1761 @@\n+/* Pass to detect and issue warnings for violations of the restrict\n+   qualifier.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Martin Sebor <msebor@redhat.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"domwalk.h\"\n+#include \"tree-pass.h\"\n+#include \"builtins.h\"\n+#include \"ssa.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"gimple-ssa-warn-restrict.h\"\n+#include \"diagnostic-core.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree-dfa.h\"\n+#include \"tree-ssa.h\"\n+#include \"params.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-object-size.h\"\n+#include \"calls.h\"\n+#include \"cfgloop.h\"\n+#include \"intl.h\"\n+\n+namespace {\n+\n+const pass_data pass_data_wrestrict = {\n+  GIMPLE_PASS,\n+  \"wrestrict\",\n+  OPTGROUP_NONE,\n+  TV_NONE,\n+  PROP_cfg, /* Properties_required.  */\n+  0,\t    /* properties_provided.  */\n+  0,\t    /* properties_destroyed.  */\n+  0,\t    /* properties_start */\n+  0,\t    /* properties_finish */\n+};\n+\n+/* Pass to detect violations of strict aliasing requirements in calls\n+   to built-in string and raw memory functions.  */\n+class pass_wrestrict : public gimple_opt_pass\n+{\n+ public:\n+  pass_wrestrict (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_wrestrict, ctxt)\n+    { }\n+\n+  opt_pass *clone () { return new pass_wrestrict (m_ctxt); }\n+\n+  virtual bool gate (function *);\n+  virtual unsigned int execute (function *);\n+};\n+\n+bool\n+pass_wrestrict::gate (function *fun ATTRIBUTE_UNUSED)\n+{\n+  return warn_array_bounds != 0 || warn_restrict != 0;\n+}\n+\n+/* Class to walk the basic blocks of a function in dominator order.  */\n+class wrestrict_dom_walker : public dom_walker\n+{\n+ public:\n+  wrestrict_dom_walker () : dom_walker (CDI_DOMINATORS) {}\n+\n+  edge before_dom_children (basic_block) FINAL OVERRIDE;\n+  bool handle_gimple_call (gimple_stmt_iterator *);\n+\n+ private:\n+  void check_call (gcall *);\n+};\n+\n+edge\n+wrestrict_dom_walker::before_dom_children (basic_block bb)\n+{\n+  /* Iterate over statements, looking for function calls.  */\n+  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n+    {\n+      gimple *stmt = gsi_stmt (si);\n+      if (!is_gimple_call (stmt))\n+\tcontinue;\n+\n+      if (gcall *call = as_a <gcall *> (stmt))\n+\tcheck_call (call);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Execute the pass for function FUN, walking in dominator order.  */\n+\n+unsigned\n+pass_wrestrict::execute (function *fun)\n+{\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  wrestrict_dom_walker walker;\n+  walker.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+\n+  return 0;\n+}\n+\n+/* Description of a memory reference by a built-in function.  This\n+   is similar to ao_ref but made especially suitable for -Wrestrict\n+   and not for optimization.  */\n+struct builtin_memref\n+{\n+  /* The original pointer argument to the built-in function.  */\n+  tree ptr;\n+  /* The referenced subobject or NULL if not available, and the base\n+     object of the memory reference or NULL.  */\n+  tree ref;\n+  tree base;\n+\n+  /* The size of the BASE object, PTRDIFF_MAX if indeterminate,\n+     and negative until (possibly lazily) initialized.  */\n+  offset_int basesize;\n+\n+  /* The non-negative offset of the referenced subobject.  Used to avoid\n+     warnings for (apparently) possibly but not definitively overlapping\n+     accesses to member arrays.  Negative when unknown/invalid.  */\n+  offset_int refoff;\n+\n+  /* The offset range relative to the base.  */\n+  offset_int offrange[2];\n+  /* The size range of the access to this reference.  */\n+  offset_int sizrange[2];\n+\n+  /* True for \"bounded\" string functions like strncat, and strncpy\n+     and their variants that specify either an exact or upper bound\n+     on the size of the accesses they perform.  For strncat both\n+     the source and destination references are bounded.  For strncpy\n+     only the destination reference is.  */\n+  bool strbounded_p;\n+\n+  builtin_memref (tree, tree);\n+\n+  tree offset_out_of_bounds (int, offset_int[2]) const;\n+};\n+\n+/* Description of a memory access by a raw memory or string built-in\n+   function involving a pair of builtin_memref's.  */\n+class builtin_access\n+{\n+ public:\n+  /* Destination and source memory reference.  */\n+  builtin_memref* const dstref;\n+  builtin_memref* const srcref;\n+  /* The size range of the access.  It's the greater of the accesses\n+     to the two references.  */\n+  HOST_WIDE_INT sizrange[2];\n+\n+  /* The minimum and maximum offset of an overlap of the access\n+     (if it does, in fact, overlap), and the size of the overlap.  */\n+  HOST_WIDE_INT ovloff[2];\n+  HOST_WIDE_INT ovlsiz[2];\n+\n+  /* True to consider valid only accesses to the smallest subobject\n+     and false for raw memory functions.  */\n+  bool strict () const\n+  {\n+    return detect_overlap != &builtin_access::generic_overlap;\n+  }\n+\n+  builtin_access (gcall *, builtin_memref &, builtin_memref &);\n+\n+  /* Entry point to determine overlap.  */\n+  bool overlap ();\n+\n+ private:\n+  /* Implementation functions used to determine overlap.  */\n+  bool generic_overlap ();\n+  bool strcat_overlap ();\n+  bool strcpy_overlap ();\n+\n+  bool no_overlap ()\n+  {\n+    return false;\n+  }\n+\n+  offset_int overlap_size (const offset_int [2], const offset_int[2],\n+\t\t\t   offset_int [2]);\n+\n+ private:\n+  /* Temporaries used to compute the final result.  */\n+  offset_int dstoff[2];\n+  offset_int srcoff[2];\n+  offset_int dstsiz[2];\n+  offset_int srcsiz[2];\n+\n+  /* Pointer to a member function to call to determine overlap.  */\n+  bool (builtin_access::*detect_overlap) ();\n+};\n+\n+/* Initialize a memory reference representation from a pointer EXPR and\n+   a size SIZE in bytes.  If SIZE is NULL_TREE then the size is assumed\n+   to be unknown.  */\n+\n+builtin_memref::builtin_memref (tree expr, tree size)\n+: ptr (expr),\n+  ref (),\n+  base (),\n+  basesize (-1),\n+  refoff (HOST_WIDE_INT_MIN),\n+  offrange (),\n+  sizrange (),\n+  strbounded_p ()\n+{\n+  /* Unfortunately, wide_int default ctor is a no-op so array members\n+     of the type must be set individually.  */\n+  offrange[0] = offrange[1] = 0;\n+  sizrange[0] = sizrange[1] = 0;\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      /* Try to tease the offset out of the pointer.  */\n+      gimple *stmt = SSA_NAME_DEF_STMT (expr);\n+      if (gimple_assign_single_p (stmt)\n+\t  && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+\texpr = gimple_assign_rhs1 (stmt);\n+      else if (is_gimple_assign (stmt))\n+\t{\n+\t  tree_code code = gimple_assign_rhs_code (stmt);\n+\t  if (code == NOP_EXPR)\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      if (POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\t\texpr = gimple_assign_rhs1 (stmt);\n+\t    }\n+\t  else if (code == POINTER_PLUS_EXPR)\n+\t    {\n+\t      expr = gimple_assign_rhs1 (stmt);\n+\n+\t      tree offset = gimple_assign_rhs2 (stmt);\n+\t      if (TREE_CODE (offset) == INTEGER_CST)\n+\t\t{\n+\t\t  offset_int off = int_cst_value (offset);\n+\t\t  offrange[0] = off;\n+\t\t  offrange[1] = off;\n+\n+\t\t  if (TREE_CODE (expr) == SSA_NAME)\n+\t\t    {\n+\t\t      gimple *stmt = SSA_NAME_DEF_STMT (expr);\n+\t\t      if (gimple_assign_single_p (stmt)\n+\t\t\t  && gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+\t\t\texpr = gimple_assign_rhs1 (stmt);\n+\t\t    }\n+\t\t}\n+\t      else if (TREE_CODE (offset) == SSA_NAME)\n+\t\t{\n+\t\t  wide_int min, max;\n+\t\t  value_range_type rng = get_range_info (offset, &min, &max);\n+\t\t  if (rng == VR_RANGE)\n+\t\t    {\n+\t\t      offrange[0] = min.to_shwi ();\n+\t\t      offrange[1] = max.to_shwi ();\n+\t\t    }\n+\t\t  else if (rng == VR_ANTI_RANGE)\n+\t\t    {\n+\t\t      offrange[0] = (max + 1).to_shwi ();\n+\t\t      offrange[1] = (min - 1).to_shwi ();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gimple *stmt = SSA_NAME_DEF_STMT (offset);\n+\t\t      if (is_gimple_assign (stmt)\n+\t\t\t  && gimple_assign_rhs_code (stmt) == NOP_EXPR)\n+\t\t\t{\n+\t\t\t  /* Use the bounds of the type of the NOP_EXPR operand\n+\t\t\t     even if it's signed.  The result doesn't trigger\n+\t\t\t     warnings but makes their output more readable.  */\n+\t\t\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t\t\t  offrange[0] = wi::to_offset (TYPE_MIN_VALUE (type));\n+\t\t\t  offrange[1] = wi::to_offset (TYPE_MAX_VALUE (type));\n+\t\t\t}\n+\t\t      else\n+\t\t\toffrange[1] = maxobjsize;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\toffrange[1] = maxobjsize;\n+\t    }\n+\t}\n+    }\n+\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    {\n+      HOST_WIDE_INT off;\n+      tree oper = TREE_OPERAND (expr, 0);\n+\n+      /* Determine the base object or pointer of the reference\n+\t and its constant offset from the beginning of the base.  */\n+      base = get_addr_base_and_unit_offset (oper, &off);\n+\n+      if (base)\n+\t{\n+\t  offrange[0] += off;\n+\t  offrange[1] += off;\n+\n+\t  /* Stash the reference for offset validation.  */\n+\t  ref = oper;\n+\n+\t  /* Also stash the constant offset for offset validation.  */\n+\t  tree_code code = TREE_CODE (oper);\n+\t  if (code == COMPONENT_REF)\n+\t    {\n+\t      tree field = TREE_OPERAND (ref, 1);\n+\t      tree fldoff = DECL_FIELD_OFFSET (field);\n+\t      if (TREE_CODE (fldoff) == INTEGER_CST)\n+\t\trefoff = off + wi::to_offset (fldoff);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  size = NULL_TREE;\n+\t  base = get_base_address (TREE_OPERAND (expr, 0));\n+\t}\n+    }\n+\n+  if (!base)\n+    base = build2 (MEM_REF, char_type_node, expr, null_pointer_node);\n+\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      offset_int off = mem_ref_offset (base);\n+      refoff += off;\n+      offrange[0] += off;\n+      offrange[1] += off;\n+      base = TREE_OPERAND (base, 0);\n+    }\n+\n+  if (TREE_CODE (base) == SSA_NAME)\n+    if (gimple *stmt = SSA_NAME_DEF_STMT (base))\n+      {\n+\tenum gimple_code code = gimple_code (stmt);\n+\tif (code == GIMPLE_ASSIGN)\n+\t  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      base = gimple_assign_rhs1 (stmt);\n+\n+\t      tree offset = gimple_assign_rhs2 (stmt);\n+\t      if (TREE_CODE (offset) == INTEGER_CST)\n+\t\t{\n+\t\t  offset_int off = int_cst_value (offset);\n+\t\t  refoff += off;\n+\t\t  offrange[0] += off;\n+\t\t  offrange[1] += off;\n+\t\t}\n+\t    }\n+\n+\tif (TREE_CODE (base) == SSA_NAME && SSA_NAME_VAR (base))\n+\t  base = SSA_NAME_VAR (base);\n+      }\n+\n+  if (size)\n+    {\n+      tree range[2];\n+      /* Determine the size range, allowing for the result to be [0, 0]\n+\t for SIZE in the anti-range ~[0, N] where N >= PTRDIFF_MAX.  */\n+      get_size_range (size, range, true);\n+      sizrange[0] = wi::to_offset (range[0]);\n+      sizrange[1] = wi::to_offset (range[1]);\n+      /* get_size_range returns SIZE_MAX for the maximum size.\n+\t Constrain it to the real maximum of PTRDIFF_MAX.  */\n+      if (sizrange[1] > maxobjsize)\n+\tsizrange[1] = maxobjsize;\n+    }\n+  else\n+    sizrange[1] = maxobjsize;\n+}\n+\n+/* Return error_mark_node if the signed offset exceeds the bounds\n+   of the address space (PTRDIFF_MAX).  Otherwise, return either\n+   BASE or REF when the offset exceeds the bounds of the BASE or\n+   REF object, and set OOBOFF to the past-the-end offset formed\n+   by the reference, including its size.  When STRICT is non-zero\n+   use REF size, when available, otherwise use BASE size.  When\n+   STRICT is greater than 1, use the size of the last array member\n+   as the bound, otherwise treat such a member as a flexible array\n+   member.  Return NULL when the offset is in bounds.  */\n+\n+tree\n+builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[2]) const\n+{\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  /* A temporary, possibly adjusted, copy of the offset range.  */\n+  offset_int offrng[2] = { offrange[0], offrange[1] };\n+\n+  if (DECL_P (base) && TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n+    {\n+      if (offrng[1] < offrng[0])\n+  \toffrng[1] = maxobjsize;\n+    }\n+\n+  /* Conservative offset of the last byte of the referenced object.  */\n+  offset_int endoff;\n+\n+  /* The bounds need not be ordered.  Set HIB to use as the index\n+     of the larger of the bounds and LOB as the opposite.  */\n+  bool hib = wi::les_p (offrng[0], offrng[1]);\n+  bool lob = !hib;\n+\n+  if (basesize < 0)\n+    {\n+      endoff = offrng[lob] + sizrange[0];\n+\n+      /* For a reference through a pointer to an object of unknown size\n+\t all initial offsets are considered valid, positive as well as\n+\t negative, since the pointer itself can point past the beginning\n+\t of the object.  However, the sum of the lower bound of the offset\n+\t and that of the size must be less than or equal than PTRDIFF_MAX.  */\n+      if (endoff > maxobjsize)\n+\treturn error_mark_node;\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* A reference to an object of known size must be within the bounds\n+     of the base object.  */\n+  if (offrng[hib] < 0 || offrng[lob] > basesize)\n+    return base;\n+\n+  /* The extent of the reference must also be within the bounds of\n+     the base object (if known) or the maximum object size otherwise.  */\n+  endoff = wi::smax (offrng[lob], 0) + sizrange[0];\n+  if (endoff > maxobjsize)\n+    return error_mark_node;\n+\n+  offset_int size = basesize;\n+  tree obj = base;\n+\n+  if (strict\n+      && DECL_P (obj)\n+      && ref\n+      && refoff >= 0\n+      && TREE_CODE (ref) == COMPONENT_REF\n+      && (strict > 1\n+\t  || !array_at_struct_end_p (ref)))\n+    {\n+      /* If the reference is to a member subobject, the offset must\n+\t be within the bounds of the subobject.  */\n+      tree field = TREE_OPERAND (ref, 1);\n+      tree type = TREE_TYPE (field);\n+      if (tree sz = TYPE_SIZE_UNIT (type))\n+\tif (TREE_CODE (sz) == INTEGER_CST)\n+\t  {\n+\t    size = refoff + wi::to_offset (sz);\n+\t    obj = ref;\n+\t  }\n+    }\n+\n+  if (endoff <= size)\n+    return NULL_TREE;\n+\n+  /* Set the out-of-bounds offset range to be one greater than\n+     that delimited by the reference including its size.  */\n+  ooboff[lob] = size + 1;\n+\n+  if (endoff > ooboff[lob])\n+    ooboff[hib] = endoff;\n+  else\n+    ooboff[hib] = wi::smax (offrng[lob], 0) + sizrange[1];\n+\n+  return obj;\n+}\n+\n+/* Create an association between the memory references DST and SRC\n+   for access by a call EXPR to a memory or string built-in funtion.  */\n+\n+builtin_access::builtin_access (gcall *call, builtin_memref &dst,\n+\t\t\t\tbuiltin_memref &src)\n+: dstref (&dst), srcref (&src), sizrange (), ovloff (), ovlsiz (),\n+  dstoff (), srcoff (), dstsiz (), srcsiz ()\n+{\n+  /* Zero out since the offset_int ctors invoked above are no-op.  */\n+  dstoff[0] = dstoff[1] = 0;\n+  srcoff[0] = srcoff[1] = 0;\n+  dstsiz[0] = dstsiz[1] = 0;\n+  srcsiz[0] = srcsiz[1] = 0;\n+\n+  /* Object Size Type to use to determine the size of the destination\n+     and source objects.  Overridden below for raw memory functions.  */\n+  int ostype = 1;\n+\n+  /* True when the size of one reference depends on the offset of\n+     itself or the other.  */\n+  bool depends_p = true;\n+\n+  /* True when the size of the destination reference DSTREF has been\n+     determined from SRCREF and so needs to be adjusted by the latter's\n+     offset.  Only meaningful for bounded string functions like strncpy.  */\n+  bool dstadjust_p = false;\n+\n+  /* The size argument number (depends on the built-in).  */\n+  unsigned sizeargno = 2;\n+  if (gimple_call_with_bounds_p (call))\n+    sizeargno += 2;\n+\n+  tree func = gimple_call_fndecl (call);\n+  switch (DECL_FUNCTION_CODE (func))\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMCPY_CHKP:\n+    case BUILT_IN_MEMCPY_CHK_CHKP:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHKP:\n+    case BUILT_IN_MEMPCPY_CHK_CHKP:\n+      ostype = 0;\n+      depends_p = false;\n+      detect_overlap = &builtin_access::generic_overlap;\n+      break;\n+\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMMOVE_CHKP:\n+    case BUILT_IN_MEMMOVE_CHK_CHKP:\n+      /* For memmove there is never any overlap to check for.  */\n+      ostype = 0;\n+      depends_p = false;\n+      detect_overlap = &builtin_access::no_overlap;\n+      break;\n+\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      dstref->strbounded_p = true;\n+      detect_overlap = &builtin_access::strcpy_overlap;\n+      break;\n+\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STPCPY_CHK:\n+    case BUILT_IN_STPCPY_CHKP:\n+    case BUILT_IN_STPCPY_CHK_CHKP:\n+    case BUILT_IN_STRCPY:\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STRCPY_CHKP:\n+    case BUILT_IN_STRCPY_CHK_CHKP:\n+      detect_overlap = &builtin_access::strcpy_overlap;\n+      break;\n+\n+    case BUILT_IN_STRCAT:\n+    case BUILT_IN_STRCAT_CHK:\n+    case BUILT_IN_STRCAT_CHKP:\n+    case BUILT_IN_STRCAT_CHK_CHKP:\n+      detect_overlap = &builtin_access::strcat_overlap;\n+      break;\n+\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+      dstref->strbounded_p = true;\n+      srcref->strbounded_p = true;\n+      detect_overlap = &builtin_access::strcat_overlap;\n+      break;\n+\n+    default:\n+      /* Handle other string functions here whose access may need\n+\t to be validated for in-bounds offsets and non-overlapping\n+\t copies.  (Not all _chkp functions have BUILT_IN_XXX_CHKP\n+\t macros so they need to be handled here.)  */\n+      return;\n+    }\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  /* Try to determine the size of the base object.  compute_objsize\n+     expects a pointer so create one if BASE is a non-pointer object.  */\n+  tree addr;\n+  if (dst.basesize < 0)\n+    {\n+      addr = dst.base;\n+      if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n+\taddr = build1 (ADDR_EXPR, (TREE_TYPE (addr)), addr);\n+\n+      if (tree dstsize = compute_objsize (addr, ostype))\n+\tdst.basesize = wi::to_offset (dstsize);\n+      else if (POINTER_TYPE_P (TREE_TYPE (addr)))\n+\tdst.basesize = HOST_WIDE_INT_MIN;\n+      else\n+\tdst.basesize = maxobjsize;\n+    }\n+\n+  if (src.basesize < 0)\n+    {\n+      addr = src.base;\n+      if (!POINTER_TYPE_P (TREE_TYPE (addr)))\n+\taddr = build1 (ADDR_EXPR, (TREE_TYPE (addr)), addr);\n+\n+      if (tree srcsize = compute_objsize (addr, ostype))\n+\tsrc.basesize = wi::to_offset (srcsize);\n+      else if (POINTER_TYPE_P (TREE_TYPE (addr)))\n+\tsrc.basesize = HOST_WIDE_INT_MIN;\n+      else\n+\tsrc.basesize = maxobjsize;\n+    }\n+\n+  /* If there is no dependency between the references or the base\n+     objects of the two references aren't the same there's nothing\n+     else to do.  */\n+  if (depends_p && dstref->base != srcref->base)\n+    return;\n+\n+  /* ...otherwise, make adjustments for references to the same object\n+     by string built-in functions to reflect the constraints imposed\n+     by the function.  */\n+\n+  /* For bounded string functions determine the range of the bound\n+     on the access.  For others, the range stays unbounded.  */\n+  offset_int bounds[2] = { maxobjsize, maxobjsize };\n+  if (dstref->strbounded_p)\n+    {\n+      tree size = gimple_call_arg (call, sizeargno);\n+      tree range[2];\n+      if (get_size_range (size, range, true))\n+\t{\n+\t  bounds[0] = wi::to_offset (range[0]);\n+\t  bounds[1] = wi::to_offset (range[1]);\n+\t}\n+\n+      /* If both references' size ranges are indeterminate use the last\n+\t (size) argument from the function call as a substitute.  This\n+\t may only be necessary for strncpy (but not for memcpy where\n+\t the size range would have been already determined this way).  */\n+      if (dstref->sizrange[0] == 0 && dstref->sizrange[1] == maxobjsize\n+\t  && srcref->sizrange[0] == 0 && srcref->sizrange[1] == maxobjsize)\n+\t{\n+\t  dstref->sizrange[0] = bounds[0];\n+\t  dstref->sizrange[1] = bounds[1];\n+\t}\n+    }\n+\n+  /* The size range of one reference involving the same base object\n+     can be determined from the size range of the other reference.\n+     This makes it possible to compute accurate offsets for warnings\n+     involving functions like strcpy where the length of just one of\n+     the two arguments is known (determined by tree-ssa-strlen).  */\n+  if (dstref->sizrange[0] == 0 && dstref->sizrange[1] == maxobjsize)\n+    {\n+      /* When the destination size is unknown set it to the size of\n+\t the source.  */\n+      dstref->sizrange[0] = srcref->sizrange[0];\n+      dstref->sizrange[1] = srcref->sizrange[1];\n+    }\n+  else if (srcref->sizrange[0] == 0 && srcref->sizrange[1] == maxobjsize)\n+    {\n+      /* When the source size is unknown set it to the size of\n+\t the destination.  */\n+      srcref->sizrange[0] = dstref->sizrange[0];\n+      srcref->sizrange[1] = dstref->sizrange[1];\n+\n+      if (depends_p)\n+\t{\n+\t  if (dstref->strbounded_p)\n+\t    {\n+\t      /* Read access by strncpy is bounded.  */\n+\t      if (bounds[0] < srcref->sizrange[0])\n+\t\tsrcref->sizrange[0] = bounds[0];\n+\t      if (bounds[1] < srcref->sizrange[1])\n+\t\tsrcref->sizrange[1] = bounds[1];\n+\t    }\n+\n+\t  /* For string functions, adjust the size range of the source\n+\t     reference by the inverse boundaries of the offset (because\n+\t     the higher  the offset into the string the shorter its\n+\t     length).  */\n+\t  if (srcref->offrange[1] < srcref->sizrange[0])\n+\t    srcref->sizrange[0] -= srcref->offrange[1];\n+\t  else\n+\t    srcref->sizrange[0] = 0;\n+\n+\t  if (srcref->offrange[0] > 0)\n+\t    {\n+\t      if (srcref->offrange[0] < srcref->sizrange[1])\n+\t\tsrcref->sizrange[1] -= srcref->offrange[0];\n+\t      else\n+\t\tsrcref->sizrange[1] = 0;\n+\t    }\n+\n+\t  dstadjust_p = true;\n+\t}\n+    }\n+\n+  if (detect_overlap == &builtin_access::generic_overlap)\n+    {\n+      if (dstref->strbounded_p)\n+\t{\n+\t  dstref->sizrange[0] = bounds[0];\n+\t  dstref->sizrange[1] = bounds[1];\n+\n+\t  if (dstref->sizrange[0] < srcref->sizrange[0])\n+\t    srcref->sizrange[0] = dstref->sizrange[0];\n+\n+\t  if (dstref->sizrange[1] < srcref->sizrange[1])\n+\t    srcref->sizrange[1] = dstref->sizrange[1];\n+\t}\n+    }\n+  else if (detect_overlap == &builtin_access::strcpy_overlap)\n+    {\n+      if (!dstref->strbounded_p)\n+\t{\n+\t  /* For strcpy, adjust the destination size range to match that\n+\t     of the source computed above.  */\n+\t  if (depends_p && dstadjust_p)\n+\t    {\n+\t      dstref->sizrange[0] = srcref->sizrange[0];\n+\t      dstref->sizrange[1] = srcref->sizrange[1];\n+\t    }\n+\t}\n+    }\n+\n+  if (dstref->strbounded_p)\n+    {\n+      /* For strncpy, adjust the destination size range to match that\n+\t of the source computed above.  */\n+      dstref->sizrange[0] = bounds[0];\n+      dstref->sizrange[1] = bounds[1];\n+\n+      if (bounds[0] < srcref->sizrange[0])\n+\tsrcref->sizrange[0] = bounds[0];\n+\n+      if (bounds[1] < srcref->sizrange[1])\n+\tsrcref->sizrange[1] = bounds[1];\n+    }\n+}\n+\n+offset_int\n+builtin_access::overlap_size (const offset_int a[2], const offset_int b[2],\n+\t\t\t      offset_int *off)\n+{\n+  const offset_int *p = a;\n+  const offset_int *q = b;\n+\n+  /* Point P at the bigger of the two ranges and Q at the smaller.  */\n+  if (wi::lts_p (a[1] - a[0], b[1] - b[0]))\n+    {\n+      p = b;\n+      q = a;\n+    }\n+\n+  if (p[0] < q[0])\n+    {\n+      if (p[1] < q[0])\n+\treturn 0;\n+\n+      *off = q[0];\n+      return wi::smin (p[1], q[1]) - q[0];\n+    }\n+\n+  if (q[1] < p[0])\n+    return 0;\n+\n+  off[0] = p[0];\n+  return q[1] - p[0];\n+}\n+\n+/* Return true if the bounded mempry (memcpy amd similar) or string function\n+   access (strncpy and similar) ACS overlaps.  */\n+\n+bool\n+builtin_access::generic_overlap ()\n+{\n+  builtin_access &acs = *this;\n+  const builtin_memref *dstref = acs.dstref;\n+  const builtin_memref *srcref = acs.srcref;\n+\n+  gcc_assert (dstref->base == srcref->base);\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  offset_int maxsize = dstref->basesize < 0 ? maxobjsize : dstref->basesize;\n+  gcc_assert (maxsize <= maxobjsize);\n+\n+  /* Adjust the larger bounds of the offsets (which may be the first\n+     element if the lower bound is larger than the upper bound) to\n+     make them valid for the smallest access (if possible) but no smaller\n+     than the smaller bounds.  */\n+  gcc_assert (wi::les_p (acs.dstoff[0], acs.dstoff[1]));\n+\n+  if (maxsize < acs.dstoff[1] + acs.dstsiz[0])\n+    acs.dstoff[1] = maxsize - acs.dstsiz[0];\n+  if (acs.dstoff[1] < acs.dstoff[0])\n+    acs.dstoff[1] = acs.dstoff[0];\n+\n+  gcc_assert (wi::les_p (acs.srcoff[0], acs.srcoff[1]));\n+\n+  if (maxsize < acs.srcoff[1] + acs.srcsiz[0])\n+    acs.srcoff[1] = maxsize - acs.srcsiz[0];\n+  if (acs.srcoff[1] < acs.srcoff[0])\n+    acs.srcoff[1] = acs.srcoff[0];\n+\n+  /* Determine the minimum and maximum space for the access given\n+     the offsets.  */\n+  offset_int space[2];\n+  space[0] = wi::abs (acs.dstoff[0] - acs.srcoff[0]);\n+  space[1] = space[0];\n+\n+  offset_int d = wi::abs (acs.dstoff[0] - acs.srcoff[1]);\n+  if (acs.srcsiz[0] > 0)\n+    {\n+      if (d < space[0])\n+\tspace[0] = d;\n+\n+      if (space[1] < d)\n+\tspace[1] = d;\n+    }\n+  else\n+    space[1] = acs.dstsiz[1];\n+\n+  d = wi::abs (acs.dstoff[1] - acs.srcoff[0]);\n+  if (d < space[0])\n+    space[0] = d;\n+\n+  if (space[1] < d)\n+    space[1] = d;\n+\n+  /* Treat raw memory functions both of whose references are bounded\n+     as special and permit uncertain overlaps to go undetected.  For\n+     all kinds of constant offset and constant size accesses, if\n+     overlap isn't certain it is not possible.  */\n+  bool overlap_possible = space[0] < acs.dstsiz[1];\n+  if (!overlap_possible)\n+    return false;\n+\n+  bool overlap_certain = space[1] < acs.dstsiz[0];\n+\n+  /* True when the size of one reference depends on the offset of\n+     the other.  */\n+  bool depends_p = detect_overlap != &builtin_access::generic_overlap;\n+\n+  if (!overlap_certain\n+      && !dstref->strbounded_p\n+      && !depends_p)\n+    return false;\n+\n+  /* True for stpcpy and strcpy.  */\n+  bool stxcpy_p = (!dstref->strbounded_p\n+\t\t   && detect_overlap == &builtin_access::strcpy_overlap);\n+\n+  if (dstref->refoff >= 0\n+      && srcref->refoff >= 0\n+      && dstref->refoff != srcref->refoff\n+      && (stxcpy_p || dstref->strbounded_p || srcref->strbounded_p))\n+    return false;\n+\n+  offset_int siz[2] = { maxobjsize + 1, 0 };\n+\n+  ovloff[0] = HOST_WIDE_INT_MAX;\n+  ovloff[1] = HOST_WIDE_INT_MIN;\n+\n+  /* Adjustment to the lower bound of the offset of the overlap to\n+     account for a subset of unbounded string calls where the size\n+     of the destination string depends on the length of the source\n+     which in turn depends on the offset into it.  */\n+  bool sub1;\n+\n+  if (stxcpy_p)\n+    {\n+      sub1 = acs.dstoff[0] <= acs.srcoff[0];\n+\n+      /* Iterate over the extreme locations (on the horizontal axis formed\n+\t by their offsets) and sizes of two regions and find their smallest\n+\t and largest overlap and the corresponding offsets.  */\n+      for (unsigned i = 0; i != 2; ++i)\n+\t{\n+\t  const offset_int a[2] = {\n+\t    acs.dstoff[i], acs.dstoff[i] + acs.dstsiz[!i]\n+\t  };\n+\n+\t  const offset_int b[2] = {\n+\t    acs.srcoff[i], acs.srcoff[i] + acs.srcsiz[!i]\n+\t  };\n+\n+\t  offset_int off;\n+\t  offset_int sz = overlap_size (a, b, &off);\n+\t  if (sz < siz[0])\n+\t    siz[0] = sz;\n+\n+\t  if (siz[1] <= sz)\n+\t    siz[1] = sz;\n+\n+\t  if (sz != 0)\n+\t    {\n+\t      if (wi::lts_p (off, ovloff[0]))\n+\t\tovloff[0] = off.to_shwi ();\n+\t      if (wi::lts_p (ovloff[1], off))\n+\t\tovloff[1] = off.to_shwi ();\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      sub1 = !depends_p;\n+\n+      /* Iterate over the extreme locations (on the horizontal axis\n+\t formed by their offsets) and sizes of two regions and find\n+\t their smallest and largest overlap and the corresponding\n+\t offsets.  */\n+\n+      for (unsigned io = 0; io != 2; ++io)\n+\tfor (unsigned is = 0; is != 2; ++is)\n+\t  {\n+\t    const offset_int a[2] = {\n+\t      acs.dstoff[io], acs.dstoff[io] + acs.dstsiz[is]\n+\t    };\n+\n+\t    for (unsigned jo = 0; jo != 2; ++jo)\n+\t      for (unsigned js = 0; js != 2; ++js)\n+\t\t{\n+\t\t  if (depends_p)\n+\t\t    {\n+\t\t      /* For st{p,r}ncpy the size of the source sequence\n+\t\t\t depends on the offset into it.  */\n+\t\t      if (js)\n+\t\t\tbreak;\n+\t\t      js = !jo;\n+\t\t    }\n+\n+\t\t  const offset_int b[2] = {\n+\t\t    acs.srcoff[jo], acs.srcoff[jo] + acs.srcsiz[js]\n+\t\t  };\n+\n+\t\t  offset_int off;\n+\t\t  offset_int sz = overlap_size (a, b, &off);\n+\t\t  if (sz < siz[0])\n+\t\t    siz[0] = sz;\n+\n+\t\t  if (siz[1] <= sz)\n+\t\t    siz[1] = sz;\n+\n+\t\t  if (sz != 0)\n+\t\t    {\n+\t\t      if (wi::lts_p (off, ovloff[0]))\n+\t\t\tovloff[0] = off.to_shwi ();\n+\t\t      if (wi::lts_p (ovloff[1], off))\n+\t\t\tovloff[1] = off.to_shwi ();\n+\t\t    }\n+\t\t}\n+\t  }\n+    }\n+\n+  ovlsiz[0] = siz[0].to_shwi ();\n+  ovlsiz[1] = siz[1].to_shwi ();\n+\n+  if (ovlsiz[0] == 0 && ovlsiz[1] > 1)\n+    ovloff[0] = ovloff[1] + ovlsiz[1] - 1 - sub1;\n+\n+  return true;\n+}\n+\n+/* Return true if the strcat-like access overlaps.  */\n+\n+bool\n+builtin_access::strcat_overlap ()\n+{\n+  builtin_access &acs = *this;\n+  const builtin_memref *dstref = acs.dstref;\n+  const builtin_memref *srcref = acs.srcref;\n+\n+  gcc_assert (dstref->base == srcref->base);\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  gcc_assert (dstref->base && dstref->base == srcref->base);\n+\n+  /* Adjust for strcat-like accesses.  */\n+\n+  /* As a special case for strcat, set the DSTREF offsets to the length\n+     of the source string since the function starts writing at the first\n+     nul, and set the size to 1 for the length of the nul.  */\n+  acs.dstoff[0] += acs.dstsiz[0];\n+  acs.dstoff[1] += acs.dstsiz[1];\n+\n+  bool strfunc_unknown_args = acs.dstsiz[0] == 0 && acs.dstsiz[1] != 0;\n+\n+  /* The lower bound is zero when the size is unknown because then\n+     overlap is not certain.  */\n+  acs.dstsiz[0] = strfunc_unknown_args ? 0 : 1;\n+  acs.dstsiz[1] = 1;\n+\n+  offset_int maxsize = dstref->basesize < 0 ? maxobjsize : dstref->basesize;\n+  gcc_assert (maxsize <= maxobjsize);\n+\n+  /* For references to the same base object, determine if there's a pair\n+     of valid offsets into the two references such that access between\n+     them doesn't overlap.  Adjust both upper bounds to be valid for\n+     the smaller size (i.e., at most MAXSIZE - SIZE).  */\n+\n+  if (maxsize < acs.dstoff[1] + acs.dstsiz[0])\n+    acs.dstoff[1] = maxsize - acs.dstsiz[0];\n+\n+  if (maxsize < acs.srcoff[1] + acs.srcsiz[0])\n+    acs.srcoff[1] = maxsize - acs.srcsiz[0];\n+\n+  /* Check to see if there's enough space for both accesses without\n+     overlap.  Determine the optimistic (maximum) amount of available\n+     space.  */\n+  offset_int space;\n+  if (acs.dstoff[0] <= acs.srcoff[0])\n+    {\n+      if (acs.dstoff[1] < acs.srcoff[1])\n+\tspace = acs.srcoff[1] + acs.srcsiz[0] - acs.dstoff[0];\n+      else\n+\tspace = acs.dstoff[1] + acs.dstsiz[0] - acs.srcoff[0];\n+    }\n+  else\n+    space = acs.dstoff[1] + acs.dstsiz[0] - acs.srcoff[0];\n+\n+  /* Overlap is certain if the distance between the farthest offsets\n+     of the opposite accesses is less than the sum of the lower bounds\n+     of the sizes of the two accesses.  */\n+  bool overlap_certain = space < acs.dstsiz[0] + acs.srcsiz[0];\n+\n+  /* For a constant-offset, constant size access, consider the largest\n+     distance between the offset bounds and the lower bound of the access\n+     size.  If the overlap isn't certain return success.  */\n+  if (!overlap_certain\n+      && acs.dstoff[0] == acs.dstoff[1]\n+      && acs.srcoff[0] == acs.srcoff[1]\n+      && acs.dstsiz[0] == acs.dstsiz[1]\n+      && acs.srcsiz[0] == acs.srcsiz[1])\n+    return false;\n+\n+  /* Overlap is not certain but may be possible.  */\n+\n+  offset_int access_min = acs.dstsiz[0] + acs.srcsiz[0];\n+\n+  /* Determine the conservative (minimum) amount of space.  */\n+  space = wi::abs (acs.dstoff[0] - acs.srcoff[0]);\n+  offset_int d = wi::abs (acs.dstoff[0] - acs.srcoff[1]);\n+  if (d < space)\n+    space = d;\n+  d = wi::abs (acs.dstoff[1] - acs.srcoff[0]);\n+  if (d < space)\n+    space = d;\n+\n+  /* For a strict test (used for strcpy and similar with unknown or\n+     variable bounds or sizes), consider the smallest distance between\n+     the offset bounds and either the upper bound of the access size\n+     if known, or the lower bound otherwise.  */\n+  if (access_min <= space && (access_min != 0 || !strfunc_unknown_args))\n+    return false;\n+\n+  /* When strcat overlap is certain it is always a single byte:\n+     the terminatinn NUL, regardless of offsets and sizes.  When\n+     overlap is only possible its range is [0, 1].  */\n+  acs.ovlsiz[0] = dstref->sizrange[0] == dstref->sizrange[1] ? 1 : 0;\n+  acs.ovlsiz[1] = 1;\n+  acs.ovloff[0] = (dstref->sizrange[0] + dstref->offrange[0]).to_shwi ();\n+  acs.ovloff[1] = (dstref->sizrange[1] + dstref->offrange[1]).to_shwi ();\n+\n+  acs.sizrange[0] = wi::smax (acs.dstsiz[0], srcref->sizrange[0]).to_shwi ();\n+  acs.sizrange[1] = wi::smax (acs.dstsiz[1], srcref->sizrange[1]).to_shwi ();\n+  return true;\n+}\n+\n+/* Return true if the strcpy-like access overlaps.  */\n+\n+bool\n+builtin_access::strcpy_overlap ()\n+{\n+  return generic_overlap ();\n+}\n+\n+\n+/* Return true if DSTREF and SRCREF describe accesses that either overlap\n+   one another or that, in order not to overlap, would imply that the size\n+   of the referenced object(s) exceeds the maximum size of an object.  Set\n+   Otherwise, if DSTREF and SRCREF do not definitely overlap (even though\n+   they may overlap in a way that's not apparent from the available data),\n+   return false.  */\n+\n+bool\n+builtin_access::overlap ()\n+{\n+  builtin_access &acs = *this;\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  acs.sizrange[0] = wi::smax (dstref->sizrange[0],\n+\t\t\t      srcref->sizrange[0]).to_shwi ();\n+  acs.sizrange[1] = wi::smax (dstref->sizrange[1],\n+\t\t\t      srcref->sizrange[1]).to_shwi ();\n+\n+  /* Check to see if the two references refer to regions that are\n+     too large not to overlap in the address space (whose maximum\n+     size is PTRDIFF_MAX).  */\n+  offset_int size = dstref->sizrange[0] + srcref->sizrange[0];\n+  if (maxobjsize < size)\n+    {\n+      acs.ovloff[0] = (maxobjsize - dstref->sizrange[0]).to_shwi ();\n+      acs.ovlsiz[0] = (size - maxobjsize).to_shwi ();\n+      return true;\n+    }\n+\n+  /* If both base objects aren't known return the maximum possible\n+     offset that would make them not overlap.  */\n+  if (!dstref->base || !srcref->base)\n+    return false;\n+\n+  /* If the base object is an array adjust the lower bound of the offset\n+     to be non-negative.  */\n+  if (dstref->base\n+      && TREE_CODE (TREE_TYPE (dstref->base)) == ARRAY_TYPE)\n+    acs.dstoff[0] = wi::smax (dstref->offrange[0], 0);\n+  else\n+    acs.dstoff[0] = dstref->offrange[0];\n+\n+  acs.dstoff[1] = dstref->offrange[1];\n+\n+  if (srcref->base\n+      && TREE_CODE (TREE_TYPE (srcref->base)) == ARRAY_TYPE)\n+    acs.srcoff[0] = wi::smax (srcref->offrange[0], 0);\n+  else\n+    acs.srcoff[0] = srcref->offrange[0];\n+\n+  acs.srcoff[1] = srcref->offrange[1];\n+\n+  /* When the lower bound of the offset is less that the upper bound\n+     disregard it and use the inverse of the maximum object size\n+     instead.  The upper bound is the result of a negative offset\n+     being represented as a large positive value.  */\n+  if (acs.dstoff[1] < acs.dstoff[0])\n+    acs.dstoff[0] = -maxobjsize;\n+\n+  /* Validate the offset and size of each reference on its own first.\n+     This is independent of whether or not the base objects are the\n+     same.  Normally, this would have already been detected and\n+     diagnosed by -Warray-bounds, unless it has been disabled.  */\n+  offset_int maxoff = acs.dstoff[0] + dstref->sizrange[0];\n+  if (maxobjsize < maxoff)\n+    {\n+      acs.ovlsiz[0] = (maxoff - maxobjsize).to_shwi ();\n+      acs.ovloff[0] = acs.dstoff[0].to_shwi () - acs.ovlsiz[0];\n+      return true;\n+    }\n+\n+  /* Repeat the same as above but for the source offsets.  */\n+  if (acs.srcoff[1] < acs.srcoff[0])\n+    acs.srcoff[0] = -maxobjsize;\n+\n+  maxoff = acs.srcoff[0] + srcref->sizrange[0];\n+  if (maxobjsize < maxoff)\n+    {\n+      acs.ovlsiz[0] = (maxoff - maxobjsize).to_shwi ();\n+      acs.ovlsiz[1] = (acs.srcoff[0] + srcref->sizrange[1]\n+\t\t       - maxobjsize).to_shwi ();\n+      acs.ovloff[0] = acs.srcoff[0].to_shwi () - acs.ovlsiz[0];\n+      return true;\n+    }\n+\n+  if (dstref->base != srcref->base)\n+    return false;\n+\n+  acs.dstsiz[0] = dstref->sizrange[0];\n+  acs.dstsiz[1] = dstref->sizrange[1];\n+\n+  acs.srcsiz[0] = srcref->sizrange[0];\n+  acs.srcsiz[1] = srcref->sizrange[1];\n+\n+  /* Call the appropriate function to determine the overlap.  */\n+  if ((this->*detect_overlap) ())\n+    {\n+      sizrange[0] = wi::smax (acs.dstsiz[0], srcref->sizrange[0]).to_shwi ();\n+      sizrange[1] = wi::smax (acs.dstsiz[1], srcref->sizrange[1]).to_shwi ();\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Attempt to detect and diagnose an overlapping copy in a call expression\n+   EXPR involving an an access ACS to a built-in memory or string function.\n+   Return true when one has been detected, false otherwise.  */\n+\n+static bool\n+maybe_diag_overlap (location_t loc, gcall *call, builtin_access &acs)\n+{\n+  if (!acs.overlap ())\n+    return false;\n+\n+  /* For convenience.  */\n+  const builtin_memref &dstref = *acs.dstref;\n+  const builtin_memref &srcref = *acs.srcref;\n+\n+  /* Determine the range of offsets and sizes of the overlap if it\n+     exists and issue diagnostics.  */\n+  HOST_WIDE_INT *ovloff = acs.ovloff;\n+  HOST_WIDE_INT *ovlsiz = acs.ovlsiz;\n+  HOST_WIDE_INT *sizrange = acs.sizrange;\n+\n+  tree func = gimple_call_fndecl (call);\n+\n+  /* To avoid a combinatorial explosion of diagnostics format the offsets\n+     or their ranges as strings and use them in the warning calls below.  */\n+  char offstr[3][64];\n+\n+  if (dstref.offrange[0] == dstref.offrange[1]\n+      || dstref.offrange[1] > HOST_WIDE_INT_MAX)\n+    sprintf (offstr[0], \"%lli\", (long long) dstref.offrange[0].to_shwi ());\n+  else\n+    sprintf (offstr[0], \"[%lli, %lli]\",\n+\t     (long long) dstref.offrange[0].to_shwi (),\n+\t     (long long) dstref.offrange[1].to_shwi ());\n+\n+  if (srcref.offrange[0] == srcref.offrange[1]\n+      || srcref.offrange[1] > HOST_WIDE_INT_MAX)\n+    sprintf (offstr[1], \"%lli\", (long long) srcref.offrange[0].to_shwi ());\n+  else\n+    sprintf (offstr[1], \"[%lli, %lli]\",\n+\t     (long long) srcref.offrange[0].to_shwi (),\n+\t     (long long) srcref.offrange[1].to_shwi ());\n+\n+  if (ovloff[0] == ovloff[1] || !ovloff[1])\n+    sprintf (offstr[2], \"%lli\", (long long) ovloff[0]);\n+  else\n+    sprintf (offstr[2], \"[%lli, %lli]\",\n+\t     (long long) ovloff[0], (long long) ovloff[1]);\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+  bool must_overlap = ovlsiz[0] > 0;\n+\n+  if (ovlsiz[1] == 0)\n+    ovlsiz[1] = ovlsiz[0];\n+\n+  if (must_overlap)\n+    {\n+      /* Issue definitive \"overlaps\" diagnostic in this block.  */\n+\n+      if (sizrange[0] == sizrange[1])\n+\t{\n+\t  if (ovlsiz[0] == ovlsiz[1])\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tsizrange[0] == 1\n+\t\t\t? (ovlsiz[0] == 1\n+\t\t\t   ? G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t\t\"and %s overlaps %wu byte at offset %s\")\n+\t\t\t   :  G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t\t \"and %s overlaps %wu bytes at offset \"\n+\t\t\t\t \"%s\"))\n+\t\t\t: (ovlsiz[0] == 1\n+\t\t\t   ? G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t\t\"and %s overlaps %wu byte at offset %s\")\n+\t\t\t   : G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t\t\"and %s overlaps %wu bytes at offset \"\n+\t\t\t\t\"%s\")),\n+\t\t\tcall, func, sizrange[0],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n+\t  else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tsizrange[0] == 1\n+\t\t\t? G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t     \"and %s overlaps between %wu and %wu bytes \"\n+\t\t\t     \"at offset %s\")\n+\t\t\t: G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t     \"and %s overlaps between %wu and %wu bytes \"\n+\t\t\t     \"at offset %s\"),\n+\t\t\tcall, func, sizrange[0],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], ovlsiz[1],\n+\t\t\toffstr[2]);\n+\t  else\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tsizrange[0] == 1\n+\t\t\t? G_(\"%G%qD accessing %wu byte at offsets %s and \"\n+\t\t\t     \"%s overlaps %wu or more bytes at offset %s\")\n+\t\t\t: G_(\"%G%qD accessing %wu bytes at offsets %s and \"\n+\t\t\t     \"%s overlaps %wu or more bytes at offset %s\"),\n+\t\t\tcall, func, sizrange[0],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n+\t  return true;\n+\t}\n+\n+      if (sizrange[1] >= 0 && sizrange[1] < maxobjsize.to_shwi ())\n+\t{\n+\t  if (ovlsiz[0] == ovlsiz[1])\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tovlsiz[0] == 1\n+\t\t\t? G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t     \"at offsets %s and %s overlaps %wu byte at \"\n+\t\t\t     \"offset %s\")\n+\t\t\t: G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t     \"at offsets %s and %s overlaps %wu bytes \"\n+\t\t\t     \"at offset %s\"),\n+\t\t\tcall, func, sizrange[0], sizrange[1],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n+\t  else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\t\"%G%qD accessing between %wu and %wu bytes at \"\n+\t\t\t\"offsets %s and %s overlaps between %wu and %wu \"\n+\t\t\t\"bytes at offset %s\",\n+\t\t\tcall, func, sizrange[0], sizrange[1],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], ovlsiz[1],\n+\t\t\toffstr[2]);\n+\t  else\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\t\"%G%qD accessing between %wu and %wu bytes at \"\n+\t\t\t\"offsets %s and %s overlaps %wu or more bytes \"\n+\t\t\t\"at offset %s\",\n+\t\t\tcall, func, sizrange[0], sizrange[1],\n+\t\t\toffstr[0], offstr[1], ovlsiz[0], offstr[2]);\n+\t  return true;\n+\t}\n+\n+      if (ovlsiz[0] != ovlsiz[1])\n+\tovlsiz[1] = maxobjsize.to_shwi ();\n+\n+      if (ovlsiz[0] == ovlsiz[1])\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    ovlsiz[0] == 1\n+\t\t    ? G_(\"%G%qD accessing %wu or more bytes at offsets \"\n+\t\t\t \"%s and %s overlaps %wu byte at offset %s\")\n+\t\t    :  G_(\"%G%qD accessing %wu or more bytes at offsets \"\n+\t\t\t  \"%s and %s overlaps %wu bytes at offset %s\"),\n+\t\t    call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t    ovlsiz[0], offstr[2]);\n+      else if (ovlsiz[1] >= 0 && ovlsiz[1] < maxobjsize.to_shwi ())\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t    \"and %s overlaps between %wu and %wu bytes \"\n+\t\t    \"at offset %s\",\n+\t\t    call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t    ovlsiz[0], ovlsiz[1], offstr[2]);\n+      else\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    \"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t    \"and %s overlaps %wu or more bytes at offset %s\",\n+\t\t    call, func, sizrange[0], offstr[0], offstr[1],\n+\t\t    ovlsiz[0], offstr[2]);\n+      return true;\n+    }\n+\n+  /* Issue \"may overlap\" diagnostics below.  */\n+  gcc_assert (ovlsiz[0] == 0\n+\t      && ovlsiz[1] > 0\n+\t      && ovlsiz[1] <= maxobjsize.to_shwi ());\n+\n+  /* Use more concise wording when one of the offsets is unbounded\n+     to avoid confusing the user with large and mostly meaningless\n+     numbers.  */\n+  bool open_range = ((dstref.offrange[0] == -maxobjsize - 1\n+\t\t      && dstref.offrange[1] == maxobjsize)\n+\t\t     || (srcref.offrange[0] == -maxobjsize - 1\n+\t\t\t && srcref.offrange[1] == maxobjsize));\n+\n+  if (sizrange[0] == sizrange[1] || sizrange[1] == 1)\n+    {\n+      if (ovlsiz[1] == 1)\n+\t{\n+\t  if (open_range)\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tsizrange[1] == 1\n+\t\t\t? G_(\"%G%qD accessing %wu byte may overlap \"\n+\t\t\t     \"%wu byte\")\n+\t\t\t: G_(\"%G%qD accessing %wu bytes may overlap \"\n+\t\t\t     \"%wu byte\"),\n+\t\t\tcall, func, sizrange[1], ovlsiz[1]);\n+\t  else\n+\t    warning_at (loc, OPT_Wrestrict,\n+\t\t\tsizrange[1] == 1\n+\t\t\t? G_(\"%G%qD accessing %wu byte at offsets %s \"\n+\t\t\t     \"and %s may overlap %wu byte at offset %s\")\n+\t\t\t: G_(\"%G%qD accessing %wu bytes at offsets %s \"\n+\t\t\t     \"and %s may overlap %wu byte at offset %s\"),\n+\t\t\tcall, func, sizrange[1], offstr[0], offstr[1],\n+\t\t\tovlsiz[1], offstr[2]);\n+\t  return true;\n+\t}\n+\n+      if (open_range)\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    sizrange[1] == 1\n+\t\t    ? G_(\"%G%qD accessing %wu byte may overlap \"\n+\t\t\t \"up to %wu bytes\")\n+\t\t    : G_(\"%G%qD accessing %wu bytes may overlap \"\n+\t\t\t \"up to %wu bytes\"),\n+\t\t    call, func, sizrange[1], ovlsiz[1]);\n+      else\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    sizrange[1] == 1\n+\t\t    ? G_(\"%G%qD accessing %wu byte at offsets %s and \"\n+\t\t\t \"%s may overlap up to %wu bytes at offset %s\")\n+\t\t    : G_(\"%G%qD accessing %wu bytes at offsets %s and \"\n+\t\t\t \"%s may overlap up to %wu bytes at offset %s\"),\n+\t\t    call, func, sizrange[1], offstr[0], offstr[1],\n+\t\t    ovlsiz[1], offstr[2]);\n+      return true;\n+    }\n+\n+  if (sizrange[1] >= 0 && sizrange[1] < maxobjsize.to_shwi ())\n+    {\n+      if (open_range)\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    ovlsiz[1] == 1\n+\t\t    ? G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t \"may overlap %wu byte\")\n+\t\t    : G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t \"may overlap up to %wu bytes\"),\n+\t\t    call, func, sizrange[0], sizrange[1], ovlsiz[1]);\n+      else\n+\twarning_at (loc, OPT_Wrestrict,\n+\t\t    ovlsiz[1] == 1\n+\t\t    ? G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t \"at offsets %s and %s may overlap %wu byte \"\n+\t\t\t \"at offset %s\")\n+\t\t    : G_(\"%G%qD accessing between %wu and %wu bytes \"\n+\t\t\t \"at offsets %s and %s may overlap up to %wu \"\n+\t\t\t \"bytes at offset %s\"),\n+\t\t    call, func, sizrange[0], sizrange[1],\n+\t\t    offstr[0], offstr[1], ovlsiz[1], offstr[2]);\n+      return true;\n+    }\n+\n+  warning_at (loc, OPT_Wrestrict,\n+\t      ovlsiz[1] == 1\n+\t      ? G_(\"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t   \"and %s may overlap %wu byte at offset %s\")\n+\t      : G_(\"%G%qD accessing %wu or more bytes at offsets %s \"\n+\t\t   \"and %s may overlap up to %wu bytes at offset %s\"),\n+\t      call, func, sizrange[0], offstr[0], offstr[1],\n+\t      ovlsiz[1], offstr[2]);\n+\n+  return true;\n+}\n+\n+/* Validate REF offsets in an EXPRession passed as an argument to a CALL\n+   to a built-in function FUNC to make sure they are within the bounds\n+   of the referenced object if its size is known, or PTRDIFF_MAX otherwise.\n+   Both initial values of the offsets and their final value computed by\n+   the function by incrementing the initial value by the size are\n+   validated.  Return true if the offsets are not valid and a diagnostic\n+   has been issued.  */\n+\n+static bool\n+maybe_diag_offset_bounds (location_t loc, gcall *call, tree func, int strict,\n+\t\t\t  tree expr, const builtin_memref &ref)\n+{\n+  if (!warn_array_bounds)\n+    return false;\n+\n+  offset_int ooboff[] = { ref.offrange[0], ref.offrange[1] };\n+  tree oobref = ref.offset_out_of_bounds (strict, ooboff);\n+  if (!oobref)\n+    return false;\n+\n+  if (EXPR_HAS_LOCATION (expr))\n+    loc = EXPR_LOCATION (expr);\n+\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  tree type;\n+\n+  char rangestr[2][64];\n+  if (ooboff[0] == ooboff[1]\n+      || (ooboff[0] != ref.offrange[0]\n+\t  && ooboff[0].to_shwi () >= ooboff[1].to_shwi ()))\n+    sprintf (rangestr[0], \"%lli\", (long long) ooboff[0].to_shwi ());\n+  else\n+    sprintf (rangestr[0], \"[%lli, %lli]\",\n+\t     (long long) ooboff[0].to_shwi (),\n+\t     (long long) ooboff[1].to_shwi ());\n+\n+  if (oobref == error_mark_node)\n+    {\n+      if (ref.sizrange[0] == ref.sizrange[1])\n+\tsprintf (rangestr[1], \"%lli\", (long long) ref.sizrange[0].to_shwi ());\n+      else\n+\tsprintf (rangestr[1], \"[%lli, %lli]\",\n+\t\t (long long) ref.sizrange[0].to_shwi (),\n+\t\t (long long) ref.sizrange[1].to_shwi ());\n+\n+      if (DECL_P (ref.base)\n+\t  && TREE_CODE (type = TREE_TYPE (ref.base)) == ARRAY_TYPE)\n+\t{\n+\t  if (warning_at (loc, OPT_Warray_bounds,\n+\t\t\t  \"%G%qD pointer overflow between offset %s \"\n+\t\t\t  \"and size %s accessing array %qD with type %qT\",\n+\t\t\t  call, func, rangestr[0], rangestr[1], ref.base, type))\n+\t    inform (DECL_SOURCE_LOCATION (ref.base),\n+\t\t    \"array %qD declared here\", ref.base);\n+\t  else\n+\t    warning_at (loc, OPT_Warray_bounds,\n+\t\t\t\"%G%qD pointer overflow between offset %s \"\n+\t\t\t\"and size %s\",\n+\t\t\tcall, func, rangestr[0], rangestr[1]);\n+\t}\n+      else\n+\twarning_at (loc, OPT_Warray_bounds,\n+\t\t    \"%G%qD pointer overflow between offset %s \"\n+\t\t    \"and size %s\",\n+\t\t    call, func, rangestr[0], rangestr[1]);\n+    }\n+  else if (oobref == ref.base)\n+    {\n+      const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+      /* True when the offset formed by an access to the reference\n+\t is out of bounds, rather than the initial offset wich is\n+\t in bounds.  This implies access past the end.  */\n+      bool form = ooboff[0] != ref.offrange[0];\n+\n+      if (DECL_P (ref.base))\n+\t{\n+\t  if ((ref.basesize < maxobjsize\n+\t       && warning_at (loc, OPT_Warray_bounds,\n+\t\t\t      form\n+\t\t\t      ? G_(\"%G%qD forming offset %s is out of \"\n+\t\t\t\t   \"the bounds [0, %wu] of object %qD with \"\n+\t\t\t\t   \"type %qT\")\n+\t\t\t      : G_(\"%G%qD offset %s is out of the bounds \"\n+\t\t\t\t   \"[0, %wu] of object %qD with type %qT\"),\n+\t\t\t      call, func, rangestr[0], ref.basesize.to_uhwi (),\n+\t\t\t      ref.base, TREE_TYPE (ref.base)))\n+\t      || warning_at (loc, OPT_Warray_bounds,\n+\t\t\t     form\n+\t\t\t     ? G_(\"%G%qD forming offset %s is out of \"\n+\t\t\t\t  \"the bounds of object %qD with type %qT\")\n+\t\t\t     : G_(\"%G%qD offset %s is out of the bounds \"\n+\t\t\t\t  \"of object %qD with type %qT\"),\n+\t\t\t     call, func, rangestr[0],\n+\t\t\t     ref.base, TREE_TYPE (ref.base)))\n+\t    inform (DECL_SOURCE_LOCATION (ref.base),\n+\t\t    \"%qD declared here\", ref.base);\n+\t}\n+      else if (ref.basesize < maxobjsize)\n+\twarning_at (loc, OPT_Warray_bounds,\n+\t\t    form\n+\t\t    ? G_(\"%G%qD forming offset %s is out of the bounds \"\n+\t\t\t \"[0, %wu]\")\n+\t\t    : G_(\"%G%qD offset %s is out of the bounds [0, %wu]\"),\n+\t\t    call, func, rangestr[0], ref.basesize.to_uhwi ());\n+      else\n+\twarning_at (loc, OPT_Warray_bounds,\n+\t\t    form\n+\t\t    ? G_(\"%G%qD forming offset %s is out of bounds\")\n+\t\t    : G_(\"%G%qD offset %s is out of bounds\"),\n+\t\t    call, func, rangestr[0]);\n+    }\n+  else if (TREE_CODE (ref.ref) == MEM_REF)\n+    {\n+      tree type = TREE_TYPE (TREE_OPERAND (ref.ref, 0));\n+      if (POINTER_TYPE_P (type))\n+\ttype = TREE_TYPE (type);\n+      type = TYPE_MAIN_VARIANT (type);\n+\n+      warning_at (loc, OPT_Warray_bounds,\n+\t\t  \"%G%qD offset %s from the object at %qE is out \"\n+\t\t  \"of the bounds of %qT\",\n+\t\t  call, func, rangestr[0], ref.base, type);\n+    }\n+  else\n+    {\n+      type = TYPE_MAIN_VARIANT (TREE_TYPE (ref.ref));\n+\n+      warning_at (loc, OPT_Warray_bounds,\n+\t\t\"%G%qD offset %s from the object at %qE is out \"\n+\t\t\"of the bounds of referenced subobject %qD with type %qT \"\n+\t\t\"at offset %wu\",\n+\t\tcall, func, rangestr[0], ref.base, TREE_OPERAND (ref.ref, 1),\n+\t\ttype, ref.refoff.to_uhwi ());\n+    }\n+\n+  return true;\n+}\n+\n+/* Check a CALL statement for restrict-violations and issue warnings\n+   if/when appropriate.  */\n+\n+void\n+wrestrict_dom_walker::check_call (gcall *call)\n+{\n+  /* Avoid checking the call if it has already been diagnosed for\n+     some reason.  */\n+  if (gimple_no_warning_p (call))\n+    return;\n+\n+  tree func = gimple_call_fndecl (call);\n+  if (!func || DECL_BUILT_IN_CLASS (func) != BUILT_IN_NORMAL)\n+    return;\n+\n+  bool with_bounds = gimple_call_with_bounds_p (call);\n+\n+  /* Argument number to extract from the call (depends on the built-in\n+     and its kind).  */\n+  unsigned dst_idx = -1;\n+  unsigned src_idx = -1;\n+  unsigned bnd_idx = -1;\n+\n+  /* Is this CALL to a string function (as opposed to one to a raw\n+     memory function).  */\n+  bool strfun = true;\n+\n+  switch (DECL_FUNCTION_CODE (func))\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMCPY_CHKP:\n+    case BUILT_IN_MEMCPY_CHK_CHKP:\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+    case BUILT_IN_MEMPCPY_CHKP:\n+    case BUILT_IN_MEMPCPY_CHK_CHKP:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMMOVE_CHKP:\n+    case BUILT_IN_MEMMOVE_CHK_CHKP:\n+      strfun = false;\n+      /* Fall through.  */\n+\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      dst_idx = 0;\n+      src_idx = 1 + with_bounds;\n+      bnd_idx = 2 + 2 * with_bounds;\n+      break;\n+\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STPCPY_CHK:\n+    case BUILT_IN_STPCPY_CHKP:\n+    case BUILT_IN_STPCPY_CHK_CHKP:\n+    case BUILT_IN_STRCPY:\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STRCPY_CHKP:\n+    case BUILT_IN_STRCPY_CHK_CHKP:\n+    case BUILT_IN_STRCAT:\n+    case BUILT_IN_STRCAT_CHK:\n+    case BUILT_IN_STRCAT_CHKP:\n+    case BUILT_IN_STRCAT_CHK_CHKP:\n+      dst_idx = 0;\n+      src_idx = 1 + with_bounds;\n+      break;\n+\n+    default:\n+      /* Handle other string functions here whose access may need\n+\t to be validated for in-bounds offsets and non-overlapping\n+\t copies.  (Not all _chkp functions have BUILT_IN_XXX_CHKP\n+\t macros so they need to be handled here.)  */\n+      return;\n+    }\n+\n+  unsigned nargs = gimple_call_num_args (call);\n+\n+  tree dst = dst_idx < nargs ? gimple_call_arg (call, dst_idx) : NULL_TREE;\n+  tree src = src_idx < nargs ? gimple_call_arg (call, src_idx) : NULL_TREE;\n+  tree dstwr = bnd_idx < nargs ? gimple_call_arg (call, bnd_idx) : NULL_TREE;\n+\n+  /* For string functions with an unspecified or unknown bound,\n+     assume the size of the access is one.  */\n+  if (!dstwr && strfun)\n+    dstwr = size_one_node;\n+\n+  if (check_bounds_or_overlap (call, dst, src, dstwr, NULL_TREE))\n+    return;\n+\n+  /* Avoid diagnosing the call again.  */\n+  gimple_set_no_warning (call, true);\n+}\n+\n+} /* anonymous namespace */\n+\n+/* Attempt to detect and diagnose invalid offset bounds and (except for\n+   memmove) overlapping copy in a call expression EXPR from SRC to DST\n+   and DSTSIZE and SRCSIZE bytes, respectively.  Both DSTSIZE and\n+   SRCSIZE may be NULL.  Return false when one or the other has been\n+   detected and diagnosed, true otherwise.  */\n+\n+bool\n+check_bounds_or_overlap (gcall *call, tree dst, tree src, tree dstsize,\n+\t\t\t tree srcsize, bool bounds_only /* = false */)\n+{\n+  location_t loc = gimple_location (call);\n+\n+  if (tree block = gimple_block (call))\n+    if (location_t *pbloc = block_nonartificial_location (block))\n+      loc = *pbloc;\n+\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  tree func = gimple_call_fndecl (call);\n+\n+  builtin_memref dstref (dst, dstsize);\n+  builtin_memref srcref (src, srcsize);\n+\n+  builtin_access acs (call, dstref, srcref);\n+\n+  /* Set STRICT to the value of the -Warray-bounds=N argument for\n+     string functions or when N > 1.  */\n+  int strict = (acs.strict () || warn_array_bounds > 1 ? warn_array_bounds : 0);\n+\n+  /* Validate offsets first to make sure they are within the bounds\n+     of the destination object if its size is known, or PTRDIFF_MAX\n+     otherwise.  */\n+  if (maybe_diag_offset_bounds (loc, call, func, strict, dst, dstref)\n+      || maybe_diag_offset_bounds (loc, call, func, strict, src, srcref))\n+    {\n+      gimple_set_no_warning (call, true);\n+      return false;\n+    }\n+\n+  bool check_overlap\n+    = (warn_restrict\n+       && (bounds_only\n+\t   || (DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE\n+\t       && DECL_FUNCTION_CODE (func) != BUILT_IN_MEMMOVE_CHK)));\n+\n+  if (!check_overlap)\n+    return true;\n+\n+  if (operand_equal_p (dst, src, 0))\n+    {\n+      warning_at (loc, OPT_Wrestrict,\n+\t\t  \"%G%qD source argument is the same as destination\",\n+\t\t  call, func);\n+      gimple_set_no_warning (call, true);\n+      return false;\n+    }\n+\n+  /* Return false when overlap has been detected.  */\n+  if (maybe_diag_overlap (loc, call, acs))\n+    {\n+      gimple_set_no_warning (call, true);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+gimple_opt_pass *\n+make_pass_warn_restrict (gcc::context *ctxt)\n+{\n+  return new pass_wrestrict (ctxt);\n+}"}, {"sha": "02581aaa07d93f7f5e108fc70efff600cd8c8404", "filename": "gcc/gimple-ssa-warn-restrict.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-ssa-warn-restrict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fgimple-ssa-warn-restrict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.h?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,26 @@\n+/* Warn on violations of the restrict qualifier.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Contributed by Martin Sebor <msebor@redhat.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GIMPLE_SSA_WARN_RESTRICT_H\n+\n+extern bool check_bounds_or_overlap (gcall *, tree, tree, tree, tree,\n+\t\t\t\t     bool = false);\n+\n+#endif /* GIMPLE_SSA_WARN_RESTRICT_H */"}, {"sha": "67adae57c6cdc664ca5f769877433e0ebb0b7bd9", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -332,6 +332,7 @@ along with GCC; see the file COPYING3.  If not see\n \t run the full propagators, run a specialized pass which\n \t only examines PHIs to discover const/copy propagation\n \t opportunities.  */\n+      NEXT_PASS (pass_warn_restrict);\n       NEXT_PASS (pass_phi_only_cprop);\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_cd_dce);"}, {"sha": "70e9bcf133b5aee83b2e67c969ae9bdad5c0515c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,3 +1,32 @@\n+2017-12-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/78918\n+\t* c-c++-common/Warray-bounds.c: New test.\n+\t* c-c++-common/Warray-bounds-2.c: New test.\n+\t* c-c++-common/Warray-bounds-3.c: New test.\n+\t* c-c++-common/Warray-bounds-4.c: New test.\n+\t* c-c++-common/Warray-bounds-5.c: New test.\n+\t* c-c++-common/Wrestrict-2.c: New test.\n+\t* c-c++-common/Wrestrict.c: New test.\n+\t* c-c++-common/Wrestrict.s: New test.\n+\t* c-c++-common/Wsizeof-pointer-memaccess1.c: Adjust\n+\t* c-c++-common/Wsizeof-pointer-memaccess2.c: Same.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess1.C: Same.\n+\t* g++.dg/torture/Wsizeof-pointer-memaccess2.C: Same.\n+\t* gcc.dg/range.h: New header.\n+\t* gcc.dg/memcpy-6.c: New test.\n+\t* gcc.dg/pr69172.c: Adjust.\n+\t* gcc.dg/pr79223.c: Same.\n+\t* gcc.dg/pr81345.c: Adjust.\n+\t* gcc.dg/Wobjsize-1.c: Same.\n+\t* gcc.dg/Wrestrict-2.c: New test.\n+\t* gcc.dg/Wrestrict.c: New test.\n+\t* gcc.dg/Wsizeof-pointer-memaccess1.c: Adjust.\n+\t* gcc.dg/builtin-stpncpy.c: Same.\n+\t* gcc.dg/builtin-stringop-chk-1.c: Same.\n+\t* gcc.target/i386/chkp-stropt-17.c: New test.\n+\t* gcc.dg/torture/Wsizeof-pointer-memaccess1.c: Adjust.\n+\n 2017-12-16  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/83239"}, {"sha": "becb3d4f9aaa31676b1d109232d1af4d4ca33623", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-2.c", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-2.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,204 @@\n+/* Test to exercise that -Warray-bounds warnings for memory and sring\n+   functions are issued even when they are declared in system headers\n+   (i.e., not just when they are explicitly declared in the source\n+   file.)\n+   Also verify that the warnings are issued even for calls where the\n+   source of the excessive array bound is in a different function than\n+   the call.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow\" } */\n+\n+#include <stddef.h>\n+#include <string.h>\n+\n+#define MAX  (__SIZE_MAX__ / 2)\n+\n+void sink (void*);\n+\n+struct __attribute__ ((packed)) Array\n+{\n+  char a13[13];\n+  char a15[15];\n+  char a17[17];\n+};\n+\n+/* Exercise memcpy out-of-bounds offsets with an array of known size.  */\n+\n+void wrap_memcpy_src_xsize (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  memcpy (d, s + i, n);   /* { dg-warning \"offset 46 is out of the bounds \\\\\\[0, 45] of object .ar. with type .(struct )?Array.\" \"memcpy\" } */\n+}\n+\n+void call_memcpy_src_xsize (char *d, size_t n)\n+{\n+  struct Array ar;\n+  sink (&ar);\n+  wrap_memcpy_src_xsize (d, ar.a13, 46, n);\n+  sink (&ar);\n+}\n+\n+/* Exercise memcpy out-of-bounds offsets with an array of unknown size.  */\n+\n+void wrap_memcpy_src_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  memcpy (d, s + i, n);   /* { dg-warning \"pointer overflow between offset \\[0-9\\]+ and size 3\" \"memcpy\" } */\n+}\n+\n+void call_memcpy_src_diff_max (char *d, const char *s, size_t n)\n+{\n+  wrap_memcpy_src_diff_max (d, s, MAX, 3);\n+}\n+\n+void wrap_memcpy_dst_xsize (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  memcpy (d + i, s, n);   /* { dg-warning \"offset 47 is out of the bounds \\\\\\[0, 45] of object .ar1. with type .(struct )?Array.\" \"memcpy\" } */\n+}\n+\n+void call_memcpy_dst_xsize (const char *s, size_t n)\n+{\n+  struct Array ar1;       /* { dg-message \".ar1. declared here\" } */\n+  sink (&ar1);\n+  wrap_memcpy_dst_xsize (ar1.a15, s, 34, n);\n+  sink (&ar1);\n+}\n+\n+void wrap_memcpy_dst_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  memcpy (d + i, s, n);   /* { dg-warning \"offset -?\\[0-9\\]+ is out of the bounds \\\\\\[0, 45] of object .ar2. with type .(struct )?Array.\" \"memcpy\" } */\n+}\n+\n+void call_memcpy_dst_diff_max (const char *s, size_t n)\n+{\n+  struct Array ar2;       /* { dg-message \".ar2. declared here\" } */\n+  sink (&ar2);\n+  wrap_memcpy_dst_diff_max (ar2.a15, s, MAX, n);\n+  sink (&ar2);\n+}\n+\n+\n+void wrap_strcat_src_xsize (char *d, const char *s, ptrdiff_t i)\n+{\n+  strcat (d, s + i);   /* { dg-warning \"offset 46 is out of the bounds \\\\\\[0, 45] of object .ar3. with type .(struct )?Array.\" \"strcat\" } */\n+}\n+\n+void call_strcat_src_xsize (char *d)\n+{\n+  struct Array ar3;       /* { dg-message \".ar3. declared here\" } */\n+  sink (&ar3);\n+  wrap_strcat_src_xsize (d, ar3.a15, 15 + 17 + 1);\n+  sink (&ar3);\n+}\n+\n+void wrap_strcat_dst_xsize (char *d, const char *s, ptrdiff_t i)\n+{\n+  strcat (d + i, s);   /* { dg-warning \"offset 47 is out of the bounds \\\\\\[0, 45] of object .ar4. with type .(struct )?Array.\" \"strcat\" } */\n+}\n+\n+void call_strcat_dst_xsize (const char *s)\n+{\n+  struct Array ar4;       /* { dg-message \".ar4. declared here\" } */\n+  sink (&ar4);\n+  wrap_strcat_dst_xsize (ar4.a15, s, 15 + 17 + 2);\n+  sink (&ar4);\n+}\n+\n+\n+void wrap_strcpy_src_xsize (char *d, const char *s, ptrdiff_t i)\n+{\n+  strcpy (d, s + i);   /* { dg-warning \"offset 48 is out of the bounds \\\\\\[0, 45] of object .ar5. with type .(struct )?Array.\" \"strcpy\" } */\n+}\n+\n+void call_strcpy_src_xsize (char *d)\n+{\n+  struct Array ar5;       /* { dg-message \".ar5. declared here\" } */\n+  sink (&ar5);\n+  wrap_strcpy_src_xsize (d, ar5.a15, 15 + 17 + 3);\n+  sink (&ar5);\n+}\n+\n+void wrap_strcpy_dst_xsize (char *d, const char *s, ptrdiff_t i)\n+{\n+  strcpy (d + i, s);   /* { dg-warning \"offset 49 is out of the bounds \\\\\\[0, 45] of object .ar6. with type .(struct )?Array.\" \"strcpy\" } */\n+}\n+\n+void call_strcpy_dst_xsize (const char *s)\n+{\n+  struct Array ar6;       /* { dg-message \".ar6. declared here\" } */\n+  sink (&ar6);\n+  wrap_strcpy_dst_xsize (ar6.a15, s, 15 + 17 + 4);\n+  sink (&ar6);\n+}\n+\n+\n+/* Exercise strncpy out-of-bounds offsets with an array of known size.  */\n+\n+void wrap_strncpy_src_xsize (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  strncpy (d, s + i, n);   /* { dg-warning \"offset 46 is out of the bounds \\\\\\[0, 45] of object .ar7. with type '(struct )?Array.\" \"strncpy\" } */\n+}\n+\n+void call_strncpy_src_xsize (char *d, size_t n)\n+{\n+  struct Array ar7;       /* { dg-message \".ar7. declared here\" } */\n+  sink (&ar7);\n+  wrap_strncpy_src_xsize (d, ar7.a17, 17 + 1, n);\n+  sink (&ar7);\n+}\n+\n+/* Exercise strncpy out-of-bounds offsets with an array of unknown size.  */\n+\n+void wrap_strncpy_src_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  /* Unlike in the similar call to memcpy(), there is no pointer\n+     overflow here because the size N is not added to the source\n+     offset.  */\n+  strncpy (d, s + i, n);\n+}\n+\n+void call_strncpy_src_diff_max (char *d, const char *s, size_t n)\n+{\n+  wrap_strncpy_src_diff_max (d, s, MAX, 3);\n+}\n+\n+void wrap_strncpy_dst_xsize (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  strncpy (d + i, s, n);   /* { dg-warning \"offset 47 is out of the bounds \\\\\\[0, 45] of object .ar8. with type .(struct )?Array.\" \"strncpy\" } */\n+}\n+\n+void call_strncpy_dst_xsize (const char *s, size_t n)\n+{\n+  struct Array ar8;       /* { dg-message \".ar8. declared here\" } */\n+  sink (&ar8);\n+  wrap_strncpy_dst_xsize (ar8.a17, s, 17 + 2, n);\n+  sink (&ar8);\n+}\n+\n+void wrap_strncpy_dst_diff_max (char *d, const char *s, ptrdiff_t i, size_t n)\n+{\n+  strncpy (d + i, s, n);   /* { dg-warning \"offset -\\[0-9\\]+ is out of the bounds \\\\\\[0, 45] of object .ar9. with type .(struct )?Array.\" \"strncpy\" } */\n+}\n+\n+void call_strncpy_dst_diff_max (const char *s, size_t n)\n+{\n+  struct Array ar9;       /* { dg-message \".ar9. declared here\" } */\n+  sink (&ar9);\n+  wrap_strncpy_dst_diff_max (ar9.a17, s, MAX, n);\n+  sink (&ar9);\n+}\n+\n+void wrap_strncpy_dstarray_diff_neg (char *d, const char *s, ptrdiff_t i,\n+\t\t\t\t     size_t n)\n+{\n+  strncpy (d + i, s, n);   /* { dg-warning \"offset -\\[0-9\\]+ is out of the bounds \\\\\\[0, 90] of object .ar10. with type .(struct )?Array ?\\\\\\[2].\" \"strncpy\" } */\n+}\n+\n+void call_strncpy_dstarray_diff_neg (const char *s, size_t n)\n+{\n+  struct Array ar10[2];    /* { dg-message \".ar10. declared here\" } */\n+  sink (&ar10);\n+\n+  int off = (char*)ar10[1].a17 - (char*)ar10 + 1;\n+  wrap_strncpy_dstarray_diff_neg (ar10[1].a17, s, -off, n);\n+\n+  sink (&ar10);\n+}"}, {"sha": "8bb4f1c1b3e1f451f6f539664a965980c0a49439", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,410 @@\n+/* Exercise that -Warray-bounds is issued for out-of-bounds offsets\n+   in calls to built-in functions.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" }  */\n+\n+#include \"../gcc.dg/range.h\"\n+\n+#if __cplusplus\n+#  define restrict __restrict\n+extern \"C\" {\n+#endif\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+extern void* mempcpy (void* restrict, const void* restrict, size_t);\n+extern void* memmove (void*, const void*, size_t);\n+\n+extern char* stpcpy (char* restrict, const char* restrict);\n+\n+extern char* strcat (char* restrict, const char* restrict);\n+extern char* strcpy (char* restrict, const char* restrict);\n+extern char* strncpy (char* restrict, const char* restrict, size_t);\n+\n+#if __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+void sink (void*, ...);\n+\n+#define CAT(x, y)      x ## y\n+#define CONCAT(x, y)   CAT (x, y)\n+#define UNIQUE_NAME(x) CONCAT(x, __LINE__)\n+\n+#define T(type, N, dst, src, n) do {\t\t\\\n+    extern type UNIQUE_NAME (a)[N];\t\t\\\n+    type *a = UNIQUE_NAME (a);\t\t\t\\\n+    type *pd = (dst);\t\t\t\t\\\n+    const type *ps = (src);\t\t\t\\\n+    FUNC (pd, ps, n);\t\t\t\t\\\n+    sink (a, pd, ps);\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_memcpy_bounds (char *d, const char *s, size_t n)\n+{\n+#define FUNC memcpy\n+\n+  /* Verify that invalid offsets into an array of known size are\n+     detected.  */\n+\n+  T (char, 1, a + SR (DIFF_MIN, -1), s, n);     /* { dg-warning \"offset \\\\\\[-\\[0-9\\]+, -1] is out of the bounds \\\\\\[0, 1] of object \\[^\\n\\r]* with type .char ?\\\\\\[1]\" } */\n+  T (char, 1, a + SR (-2, -1), s, n);     /* { dg-warning \"offset \\\\\\[-2, -1] is out of the bounds \\\\\\[0, 1] of object\" } */\n+  T (char, 1, a + SR (-2, 0), s, n);\n+\n+  T (char, 1, a + UR (0, 1), s, n);\n+  T (char, 1, a + UR (0, 2), s, n);\n+  T (char, 1, a + UR (1, 2), s, n);\n+  T (char, 1, a + UR (2, 3), s, n);       /* { dg-warning \"offset \\\\\\[2, 3] is out of the bounds \\\\\\[0, 1] of object \" } */\n+  T (char, 1, a + UR (2, DIFF_MAX), s, n);  /* { dg-warning \"offset \\\\\\[2, \\[0-9\\]+] is out of the bounds \\\\\\[0, 1] of object \" \"memcpy\" } */\n+\n+  /* Offsets in excess of DIFF_MAX are treated as negative even if\n+     they appear as large positive in the source.  It would be nice\n+     if they retained their type but unfortunately that's not how\n+     it works so be prepared for both in case it even gets fixed.  */\n+  T (char, 1, a + UR (3, SIZE_MAX - 1), s, n);   /* { dg-warning \"offset \\\\\\[3, -2] is out of the bounds \\\\\\[0, 1] of object\" \"memcpy\" } */\n+\n+  /* Verify that invalid offsets into an array of unknown size are\n+     detected.  */\n+  extern char arr[];\n+  T (char, 1, arr + SR (DIFF_MIN,             0), s, n);\n+  T (char, 1, arr + SR (DIFF_MIN + 1,        -1), s, n);   /* { dg-warning \"offset \\\\\\[-\\[0-9\\]+, -1] is out of the bounds of object \" \"memcpy\" } */\n+  T (char, 1, arr + SR (DIFF_MIN,             1), s, n);\n+  T (char, 1, arr + SR (DIFF_MIN,      DIFF_MAX), s, n);\n+  T (char, 1, arr + SR (       -2,           -1), s, n);   /* { dg-warning \"offset \\\\\\[-2, -1] is out of the bounds of object \" \"memcpy\" } */\n+  T (char, 1, arr + SR (       -1,            0), s, n);\n+  T (char, 1, arr + SR (       -1,            1), s, n);\n+  T (char, 1, arr + SR (       -1, DIFF_MAX - 1), s, n);\n+  T (char, 1, arr + SR (        0,            1), s, n);\n+  T (char, 1, arr + SR (        0, DIFF_MAX - 1), s, n);\n+  T (char, 1, arr + SR (        1,            2), s, n);\n+  T (char, 1, arr + SR (        1, DIFF_MAX - 1), s, n);\n+\n+  /* Verify that all offsets via a pointer to an uknown object are\n+     accepted.  */\n+\n+  /* Negative indices between [DIFF_MIN, DIFF_MAX] are valid since\n+     the pointer to which the offset is applied can be at a positive\n+     offset from the beginning of an object.  */\n+  T (char, 1, d + SR (DIFF_MIN,             0), s, n);\n+  T (char, 1, d + SR (DIFF_MIN,            -1), s, n);\n+  T (char, 1, d + SR (DIFF_MIN,             1), s, n);\n+  T (char, 1, d + SR (DIFF_MIN,  DIFF_MAX - 1), s, n);\n+  T (char, 1, d + SR (       -2,           -1), s, n);\n+  T (char, 1, d + SR (       -1,            0), s, n);\n+  T (char, 1, d + SR (       -1,            1), s, n);\n+  T (char, 1, d + SR (       -1, DIFF_MAX - 1), s, n);\n+  T (char, 1, d + SR (        0,            1), s, n);\n+  T (char, 1, d + SR (        0, DIFF_MAX - 1), s, n);\n+  T (char, 1, d + SR (        1,            2), s, n);\n+  T (char, 1, d + SR (        1, DIFF_MAX - 1), s, n);\n+}\n+\n+/* Verify offsets in an anti-range.  */\n+\n+void test_memcpy_bounds_anti_range (char *d, const char *s, size_t n)\n+{\n+  T (char, 9, a, a + SAR (-2, -1), 3);\n+  T (char, 9, a, a + SAR (-1,  1), 3);\n+  T (char, 9, a, a + SAR ( 0,  1), 3);\n+  T (char, 9, a, a + SAR ( 0,  2), 3);\n+  T (char, 9, a, a + SAR ( 0,  3), 3);\n+  T (char, 9, a, a + SAR ( 0,  4), 3);\n+  T (char, 9, a, a + SAR ( 0,  5), 3);\n+  /* The initial source range is valid but the final range after the access\n+     has complete cannot be.  The value mentioned in the warning is the final\n+     offset, i.e., 7 + 3.  Including the whole final range because would be\n+     confusing (the upper bound would either be negative or a very large\n+     positive number) so only the lower bound is included.  */\n+  T (char, 9, a, a + SAR ( 0,  6), 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+\n+  /* This fails because the offset isn't represented as an SSA_NAME\n+     but rather as a GIMPLE_PHI (offset, 0).  With some effort it is\n+     possible to extract the range from the PHI but it's not implemented\n+     (yet).  */\n+  T (char, 9, a, a + SAR ( 1,  6), 3);   /* { dg-warning \"forming offset \\\\\\[9, 0] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" { xfail *-*-* } } */\n+\n+  T (char, 9, a, a + SAR ( 2,  6), 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR ( 3,  6), 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+\n+  T (char, 9, a, a + SAR (-1,  7), 3);   /* { dg-warning \"forming offset \\\\\\[10, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR (-2,  8), 3);   /* { dg-warning \"forming offset \\\\\\[10, 12] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR (-3,  7), 5);   /* { dg-warning \"forming offset \\\\\\[10, 13] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+\n+  T (char, 9, a + SAR (-2, -1), a, 3);\n+  T (char, 9, a + SAR (-1,  1), a, 3);\n+  T (char, 9, a + SAR ( 0,  1), a, 3);\n+  T (char, 9, a + SAR ( 0,  2), a, 3);\n+  T (char, 9, a + SAR ( 0,  3), a, 3);\n+  T (char, 9, a + SAR ( 0,  6), a, 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a + SAR (-1,  7), a, 3);   /* { dg-warning \"forming offset \\\\\\[10, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a + SAR (-2,  8), a, 3);   /* { dg-warning \"forming offset \\\\\\[10, 12] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+\n+  ptrdiff_t i = SAR (DIFF_MIN + 1, DIFF_MAX - 4);\n+  T (char, 1, d, d + SAR (DIFF_MIN + 3, DIFF_MAX - 1), 3);\n+  T (char, 1, d, d + SAR (DIFF_MIN + 3, DIFF_MAX - 3), 5);\n+}\n+\n+/* Verify that pointer overflow in the computation done by memcpy\n+   (i.e., offset + size) is detected and diagnosed.  */\n+\n+void test_memcpy_overflow (char *d, const char *s, size_t n)\n+{\n+  extern char arr[];\n+\n+  /* Verify that offset overflow involving an array of unknown size\n+     but known access size is detected.  This works except with small\n+     sizes that are powers of 2 due to bug .  */\n+  T (char, 1, arr + SR (DIFF_MAX - 1, DIFF_MAX), s, 1);\n+  T (char, 1, arr + SR (DIFF_MAX - 1, DIFF_MAX), s, 2);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 2 accessing array \" \"bug \" { xfail *-*-* } } */\n+  T (char, 1, arr + SR (DIFF_MAX - 2, DIFF_MAX), s, 3);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 3 accessing array \" \"memcpy\" } */\n+  T (char, 1, arr + SR (DIFF_MAX - 4, DIFF_MAX), s, 5);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 5 accessing array \" \"memcpy\" } */\n+}\n+\n+void test_memcpy_bounds_memarray_range (void)\n+{\n+#undef TM\n+#define TM(mem, dst, src, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    struct MA { char a5[5]; int i; } ma;\t\\\n+    sink (&ma);   /* Initialize arrays.  */\t\\\n+    memcpy (dst, src, n);\t\t\t\\\n+    sink (&ma);\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t i = SR (1, 2);\n+\n+  TM (ma.a5, ma.a5 + i, ma.a5, 1);\n+  TM (ma.a5, ma.a5 + i, ma.a5, 3);\n+  TM (ma.a5, ma.a5 + i, ma.a5, 5);\n+  TM (ma.a5, ma.a5 + i, ma.a5, 7);     /* diagnosed with -Warray-bounds=2 */\n+}\n+\n+void test_memmove_bounds (char *d, const char *s, size_t n)\n+{\n+#undef FUNC\n+#define FUNC memmove\n+\n+    T (char, 1, a + SR (DIFF_MIN + 1, -1), s, n);     /* { dg-warning \"offset \\\\\\[-\\[0-9\\]+, -1] is out of the bounds \\\\\\[0, 1] of object \\[^\\n\\r]+ with type .char ?\\\\\\[1]\" } */\n+  T (char, 1, a + SR (-2, -1), s, n);     /* { dg-warning \"offset \\\\\\[-2, -1] is out of the bounds \\\\\\[0, 1] of object\" } */\n+  T (char, 1, a + SR (-2, 0), s, n);\n+\n+  const int *pi = (const int*)s;\n+  T (int,  2, a + SR (-1, 1), pi, n);\n+  T (int,  2, a + SR (-1, 2), pi, n);\n+  T (int,  2, a + SR ( 0, 2), pi, n);\n+  T (int,  2, a + SR ( 0, 3), pi, n);\n+  T (int,  2, a + SR ( 1, 3), pi, n);\n+  T (int,  2, a + SR ( 2, 3), pi, n);\n+\n+  T (int32_t, 2, a + SR ( 3, 4), pi, n);      /* { dg-warning \"offset \\\\\\[12, 16] is out of the bounds \\\\\\[0, 8] of object .\\[^\\n\\r]+. with type .int32_t ?\\\\\\[2].\" } */\n+}\n+\n+\n+void test_mempcpy_bounds (char *d, const char *s, size_t n)\n+{\n+#undef FUNC\n+#define FUNC mempcpy\n+\n+  /* Verify that invalid offsets into an array of known size are\n+     detected.  */\n+\n+  T (char, 1, a + SR (DIFF_MIN, -1), s, n);     /* { dg-warning \"offset \\\\\\[-\\[0-9\\]+, -1] is out of the bounds\"  \"mempcpy\" } */\n+T (char, 1, a + SR (-2, -1), s, n);     /* { dg-warning \"offset \\\\\\[-2, -1] is out of the bounds\"  \"mempcpy\" } */\n+  T (char, 1, a + SR (-2, 0), s, n);\n+\n+  T (char, 1, a + UR (0, 1), s, n);\n+  T (char, 1, a + UR (0, 2), s, n);\n+  T (char, 1, a + UR (1, 2), s, n);\n+  T (char, 1, a + UR (2, 3), s, n);       /* { dg-warning \"offset \\\\\\[2, 3] is out of the bounds \\\\\\[0, 1] of object \"  \"mempcpy\" } */\n+  T (char, 1, a + UR (2, DIFF_MAX), s, n);  /* { dg-warning \"offset \\\\\\[2, \\[0-9\\]+] is out of the bounds \\\\\\[0, 1] of object\"  \"mempcpy\" } */\n+\n+  /* Offsets in excess of DIFF_MAX are treated as negative even if\n+     they appear as large positive in the source.  It would be nice\n+     if they retained their type but unfortunately that's not how\n+     it works so be prepared for both in case it ever gets fixed.  */\n+  T (char, 1, a + UR (3, SIZE_MAX), s, n);   /* { dg-warning \"offset \\\\\\[3, -1] is out of the bounds \\\\\\[0, 1] of object \"  \"mempcpy\" } */\n+\n+  /* Verify that invalid offsets into an array of unknown size are\n+     detected.  */\n+  extern char arr[];\n+  T (char, 1, arr + SR (DIFF_MIN,         0), s, n);\n+  T (char, 1, arr + SR (DIFF_MIN,        -1), s, n);   /* { dg-warning \"offset \\\\\\[-\\[0-9\\]+, -1] is out of the bounds of object\"  \"mempcpy\" } */\n+  T (char, 1, arr + SR (DIFF_MIN,         1), s, n);\n+  T (char, 1, arr + SR (DIFF_MIN, DIFF_MAX), s, n);\n+  T (char, 1, arr + SR (       -2,        -1), s, n);   /* { dg-warning \"offset \\\\\\[-2, -1] is out of the bounds of object\"  \"mempcpy\" } */\n+  T (char, 1, arr + SR (       -1,         0), s, n);\n+  T (char, 1, arr + SR (       -1,         1), s, n);\n+  T (char, 1, arr + SR (       -1, DIFF_MAX), s, n);\n+  T (char, 1, arr + SR (        0,         1), s, n);\n+  T (char, 1, arr + SR (        0, DIFF_MAX), s, n);\n+  T (char, 1, arr + SR (        1,         2), s, n);\n+  T (char, 1, arr + SR (        1, DIFF_MAX), s, n);\n+\n+  /* Verify that all offsets via a pointer to an uknown object are\n+     accepted.  */\n+\n+  /* Negative indices between [DIFF_MIN, DIFF_MAX] are valid since\n+     the pointer to which the offset is applied can be at a positive\n+     offset from the beginning of an object.  */\n+  T (char, 1, d + SR (DIFF_MIN,         0), s, n);\n+  T (char, 1, d + SR (DIFF_MIN,        -1), s, n);\n+  T (char, 1, d + SR (DIFF_MIN,         1), s, n);\n+  T (char, 1, d + SR (DIFF_MIN, DIFF_MAX), s, n);\n+  T (char, 1, d + SR (       -2,        -1), s, n);\n+  T (char, 1, d + SR (       -1,         0), s, n);\n+  T (char, 1, d + SR (       -1,         1), s, n);\n+  T (char, 1, d + SR (       -1, DIFF_MAX), s, n);\n+  T (char, 1, d + SR (        0,         1), s, n);\n+  T (char, 1, d + SR (        0, DIFF_MAX), s, n);\n+  T (char, 1, d + SR (        1,         2), s, n);\n+  T (char, 1, d + SR (        1, DIFF_MAX), s, n);\n+}\n+\n+#define TI(type, N, init, dst, src) do {\t\\\n+    type UNIQUE_NAME (a)[N] = init;\t\t\\\n+    type *a = UNIQUE_NAME (a);\t\t\t\\\n+    type *pd = (dst);\t\t\t\t\\\n+    const type *ps = (src);\t\t\t\\\n+    FUNC (pd, ps);\t\t\t\t\\\n+    sink (a, pd, ps, s);\t\t\t\\\n+  } while (0)\n+\n+void test_strcpy_bounds (char *d, const char *s)\n+{\n+#undef FUNC\n+#define FUNC strcpy\n+\n+  ptrdiff_t i;\n+\n+  TI (char, 1, \"\",   a, a + SR (DIFF_MIN, 0));\n+  TI (char, 1, \"\",   a, a + SR (-1, 0));\n+  TI (char, 1, \"\",   a, a + SR (-1, 1));\n+  TI (char, 1, \"\",   a, a + SR (0, 1));\n+  TI (char, 1, \"\",   a, a + SR (0, DIFF_MAX - 1));\n+  TI (char, 2, \"0\",  a, a + SR (0, DIFF_MAX - 1));\n+  TI (char, 2, \"0\",  a, a + SR (1, DIFF_MAX - 1));\n+  /* The following needs a warning for reading past the end.  */\n+  TI (char, 2, \"0\",  a, a + SR (2, DIFF_MAX - 1));\n+  TI (char, 2, \"0\",  a, a + SR (3, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[3, \\[0-9\\]+] is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n+\n+  TI (char, 3, \"01\", a, a + SR (0, DIFF_MAX - 1));\n+  TI (char, 3, \"01\", a, a + SR (1, DIFF_MAX - 1));\n+  TI (char, 3, \"01\", a, a + SR (2, DIFF_MAX - 1));\n+  /* The following needs a warning for reading past the end.  */\n+  TI (char, 3, \"01\", a, a + SR (3, DIFF_MAX - 1));\n+  TI (char, 3, \"01\", a, a + SR (4, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[4, \\[0-9\\]+] is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n+\n+  TI (char, 4, \"012\", a, a + SR (DIFF_MAX - 2, DIFF_MAX - 1));   /* { dg-warning \"offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] is out of the bounds \\\\\\[0, 4] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[4\\\\\\].\"  \"strcpy\" } */\n+\n+\n+  TI (char, 1, \"\", a + SR (DIFF_MIN, 0), s);\n+  TI (char, 1, \"\", a + SR (-1, 0), s);\n+  TI (char, 1, \"\", a + SR (-1, 1), s);\n+  TI (char, 1, \"\", a + SR (0, 1), s);\n+  TI (char, 1, \"\", a + SR (0, DIFF_MAX - 1), s);\n+  TI (char, 2, \"\", a + SR (0, DIFF_MAX - 1), s);\n+  TI (char, 2, \"\", a + SR (1, DIFF_MAX - 1), s);\n+  /* The following is diagnosed not because the initial source offset\n+     it out of bounds (it isn't) but because the final source offset\n+     after the access has completed, is.  It would be clearer if\n+     the warning mentioned the final offset.  */\n+  TI (char, 2, \"\", a + SR (2, DIFF_MAX - 1), s);   /* { dg-warning \"forming offset 3 is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n+  TI (char, 2, \"\", a + SR (3, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[3, \\[0-9\\]+] is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n+\n+  TI (char, 3, \"\", a + SR (0, DIFF_MAX - 1), s);\n+  TI (char, 3, \"\", a + SR (1, DIFF_MAX - 1), s);\n+  TI (char, 3, \"\", a + SR (2, DIFF_MAX - 1), s);\n+  TI (char, 3, \"\", a + SR (3, DIFF_MAX - 1), s);   /* { dg-warning \"forming offset 4 is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n+  TI (char, 3, \"\", a + SR (4, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[4, \\[0-9\\]+] is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n+\n+  TI (char, 4, \"\", a + SR (DIFF_MAX - 2, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] is out of the bounds \\\\\\[0, 4] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[4\\\\\\].\"  \"strcpy\" } */\n+}\n+\n+struct MA\n+{\n+  int i;\n+  char a5[5];\n+  char a11[11];\n+};\n+\n+struct MA2\n+{\n+  struct MA ma3[3];\n+  struct MA ma5[5];\n+  char ax[];\n+};\n+\n+struct MA3\n+{\n+  struct MA2 ma5[3];\n+  struct MA2 ma7[7];\n+};\n+\n+void test_strcpy_bounds_memarray_range (void)\n+{\n+#undef TM\n+#define TM(mem, init, dst, src)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    struct MA ma;\t\t\t\t\\\n+    strcpy (ma.mem, init);\t\t\t\\\n+    strcpy (dst, src);\t\t\t\t\\\n+    sink (&ma);\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t i = SR (1, 2);\n+\n+  TM (a5, \"0\",    ma.a5 + i, ma.a5);\n+  TM (a5, \"01\",   ma.a5 + i, ma.a5);\n+  TM (a5, \"012\",  ma.a5 + i, ma.a5);\n+  TM (a5, \"0123\", ma.a5 + i, ma.a5);     /* { dg-warning \"offset 10 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char\\\\\\[5]. at offset 4\" \"strcpy\" { xfail *-*-* } } */\n+\n+  TM (a11, \"0\",       ma.a5, ma.a11);\n+  TM (a11, \"01\",      ma.a5, ma.a11);\n+  TM (a11, \"012\",     ma.a5, ma.a11);\n+  TM (a11, \"0123\",    ma.a5, ma.a11);\n+  TM (a11, \"01234\",   ma.a5, ma.a11);    /* { dg-warning \"offset 10 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+  TM (a11, \"012345\",  ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[10, 11] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+  TM (a11, \"0123456\", ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[10, 12] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+\n+  TM (a11, \"0123456\", ma.a11 + i, \"789abcd\");\n+}\n+\n+void test_strcpy_bounds_memarray_var (struct MA *pma,\n+\t\t\t\t      struct MA2 *pma2,\n+\t\t\t\t      struct MA3 *pma3,\n+\t\t\t\t      const char *s, size_t n)\n+{\n+#undef TM\n+#define TM(dst, src) do {\t\t\t\\\n+    strcpy (dst, src);\t\t\t\t\\\n+    sink (dst, src);\t\t\t\t\\\n+  } while (0)\n+\n+  TM (pma->a5, s);\n+  TM (pma->a5 + 0, s);\n+  TM (pma->a5 + 1, s);\n+  TM (pma->a5 + 4, s);\n+\n+  /* The following forms a pointer during the call that's outside\n+     the bounds of the array it was derived from (pma->a5) so\n+     it should be diagnosed but the representation of the pointer\n+     addition doesn't contain information to distinguish it from\n+     the valid pma->a11 + 1 so this is an XFAIL.  */\n+  TM (pma->a5 + 5, s);                 /* { dg-warning \"offset 17 from the object at .pma. is out of the bounds of .struct MA.\" \"strcpy\" { xfail *-*-* } } */\n+\n+  /* The following also forms an out-of-bounds pointer but similar\n+     to the above, there is no reliable way to distinguish it from\n+     (char*)&pma[1].i + 1 so this too is not diagnosed.  */\n+  TM (pma->a5 + sizeof *pma + 1, s);   /* { dg-warning \"offset 17 from the object at .pma. is out of the bounds of .struct MA.\" \"strcpy\" { xfail *-*-* } } */\n+\n+  TM (pma->a5 - 1, s);   /* { dg-warning \"offset -1 from the object at .pma. is out of the bounds of .struct MA.\" \"strcpy\" { xfail *-*-* } } */\n+\n+  TM (pma[1].a5, s);\n+  TM (pma[2].a5 + 0, s);\n+  TM (pma[3].a5 + 1, s);\n+  TM (pma[4].a5 + 4, s);\n+\n+\n+  extern struct MA3 ma3[3];\n+  TM (ma3[0].ma5[0].ma3[0].a5 + 6, s);\n+}"}, {"sha": "57b9ffa00ceae1536ea42730d64ef596eb31842d", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,68 @@\n+/* Exercise that -Warray-bounds is issued for out-of-bounds offsets\n+   in calls to built-in functions.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds=2 -Wno-stringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+#include \"../gcc.dg/range.h\"\n+\n+#if __cplusplus\n+#  define restrict __restrict\n+extern \"C\" {\n+#endif\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+extern void* mempcpy (void* restrict, const void* restrict, size_t);\n+extern void* memmove (void*, const void*, size_t);\n+\n+extern char* stpcpy (char* restrict, const char* restrict);\n+\n+extern char* strcat (char* restrict, const char* restrict);\n+extern char* strcpy (char* restrict, const char* restrict);\n+extern char* strncpy (char* restrict, const char* restrict, size_t);\n+\n+#if __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+struct MA { char a5[5], a7[7]; };\n+\n+void sink (void*, ...);\n+\n+void test_memcpy_bounds_memarray_range (void)\n+{\n+#undef TM\n+#define TM(mem, dst, src, n)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    struct MA ma;\t\t\t\t\\\n+    sink (&ma);   /* Initialize arrays.  */\t\\\n+    memcpy (dst, src, n);\t\t\t\\\n+    sink (&ma);\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t j = SR (1, 2);\n+\n+  TM (ma.a5, ma.a5 + j, ma.a5, 1);\n+  TM (ma.a5, ma.a5 + j, ma.a5, 3);\n+  TM (ma.a5, ma.a5 + j, ma.a5, 5);\n+  TM (ma.a5, ma.a5 + j, ma.a5, 7);        /* { dg-warning \"offset \\\\\\[6, 8] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n+  TM (ma.a5, ma.a5 + j, ma.a5, 9);        /* { dg-warning \"offset \\\\\\[6, 10] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n+}\n+\n+void test_strcpy_bounds_memarray_range (void)\n+{\n+#undef TM\n+#define TM(a5init, a7init, dst, src)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    struct MA ma = { a5init, a7init };\t\t\\\n+    strcpy (dst, src);\t\t\t\t\\\n+    sink (&ma);\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t i = SR (1, 2);\n+\n+  TM (\"0\", \"\",     ma.a5 + i, ma.a5);\n+  TM (\"01\", \"\",    ma.a5 + i, ma.a5);\n+  TM (\"012\", \"\",   ma.a5 + i, ma.a5);\n+  TM (\"0123\", \"\",  ma.a5 + i, ma.a5);     /* { dg-warning \"offset 6 from the object at .ma. is out of the bounds of referenced subobject .a5. with type .char\\\\\\[5]. at offset 0\" \"strcpy\" { xfail *-*-* } } */\n+  TM (\"\", \"012345\", ma.a7 + i, ma.a7);    /* { dg-warning \"offset 13 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a7. with type .char ?\\\\\\[7]. at offset 5\" } */\n+}"}, {"sha": "d864a47ffc8c867d531137af1aa177c5fa709245", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-5.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-5.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,40 @@\n+/* Exercise that -Warray-bounds is handled correctly for subobjects.\n+   Test case derived from the halt_fast_timekeeper function in Linux\n+   kernel/time/timekeeping.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds=2 -Wno-stringop-overflow -ftrack-macro-expansion=0\" }  */\n+\n+struct A\n+{\n+  int i;\n+  void *p;\n+  int j;\n+};\n+\n+struct B\n+{\n+  struct A a;\n+\n+  int i;\n+};\n+\n+void sink (void*);\n+\n+static void halt_fast_timekeeper (struct B *b)\n+{\n+  static struct A a;\n+\n+  struct A *pa = &b->a;\n+\n+  __builtin_memcpy (&a, pa, sizeof *pa);   /* { dg-bogus \"\\\\\\[-Warray-bounds\" } */\n+  sink (&a);\n+}\n+\n+struct C { int i; struct B b; } c;\n+\n+void timekeeping_suspend (void)\n+{\n+  struct B *p = &c.b;\n+\n+  halt_fast_timekeeper (p);\n+}"}, {"sha": "391e636c1bed2393bf39f08b22f233cb429942e1", "filename": "gcc/testsuite/c-c++-common/Warray-bounds.c", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -4,33 +4,10 @@\n    { dg-require-effective-target alloca }\n    { dg-options \"-O2 -Warray-bounds -ftrack-macro-expansion=0\" }  */\n \n-#define SIZE_MAX  __SIZE_MAX__\n-#define DIFF_MAX  __PTRDIFF_MAX__\n-#define DIFF_MIN  (-DIFF_MAX - 1)\n+#include \"../gcc.dg/range.h\"\n \n #define offsetof(T, m)   __builtin_offsetof (T, m)\n \n-typedef __PTRDIFF_TYPE__ ssize_t;\n-typedef __SIZE_TYPE__    size_t;\n-\n-extern ssize_t signed_value (void)\n-{\n-  extern volatile ssize_t signed_value_source;\n-  return signed_value_source;\n-}\n-\n-extern size_t unsigned_value (void)\n-{\n-  extern volatile size_t unsigned_value_source;\n-  return unsigned_value_source;\n-}\n-\n-ssize_t signed_range (ssize_t min, ssize_t max)\n-{\n-  ssize_t val = signed_value ();\n-  return val < min || max < val ? min : val;\n-}\n-\n typedef struct AX { int n; char ax[]; } AX;\n \n typedef struct A1 { int i; char a1[1]; } A1;\n@@ -98,7 +75,7 @@ void farr_s16_7 (void)\n   T (ax_7[DIFF_MAX / 2][0]);              /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds\" } */\n   T (ax_7[SIZE_MAX][0]);                  /* { dg-warning \"array subscript \\[0-9\\]+ is above array bounds\" } */\n \n-  ssize_t i = R (DIFF_MIN, -1);\n+  ptrdiff_t i = R (DIFF_MIN, -1);\n   T (ax_7[i][0]);                         /* { dg-warning \"array subscript -1 is below array bounds\" } */\n \n   T (ax_7[R (DIFF_MIN, -1)][0]);          /* { dg-warning \"array subscript -1 is below array bounds\" } */"}, {"sha": "f440e7b9a04114c3b379549da8f709db35a4897f", "filename": "gcc/testsuite/c-c++-common/Wrestrict-2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict-2.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,70 @@\n+/* PR 35503 - Warn about restricted pointers\n+   Test to exercise that -Wrestrict warnings are issued for memory and\n+   sring functions when they are declared in system headers (i.e., not\n+   just when they are explicitly declared in the source file.)\n+   Also verify that the warnings are issued even for calls where the\n+   source of the aliasing violation is in a different function than\n+   the restricted call.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict\" } */\n+\n+#include <string.h>\n+\n+void wrap_memcpy (void *d, const void *s, size_t n)\n+{\n+  memcpy (d, s, n);   /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+}\n+\n+void call_memcpy (void *d, size_t n)\n+{\n+  const void *s = d;\n+  wrap_memcpy (d, s, n);\n+}\n+\n+\n+void wrap_strcat (char *d, const char *s)\n+{\n+  strcat (d, s);   /* { dg-warning \"source argument is the same as destination\" \"strcat\" } */\n+}\n+\n+void call_strcat (char *d)\n+{\n+  const char *s = d;\n+  wrap_strcat (d, s);\n+}\n+\n+\n+void wrap_strcpy (char *d, const char *s)\n+{\n+  strcpy (d, s);   /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+}\n+\n+void call_strcpy (char *d)\n+{\n+  const char *s = d;\n+  wrap_strcpy (d, s);\n+}\n+\n+\n+void wrap_strncat (char *d, const char *s, size_t n)\n+{\n+  strncat (d, s, n);   /* { dg-warning \"source argument is the same as destination\" \"strncat\" } */\n+}\n+\n+void call_strncat (char *d, size_t n)\n+{\n+  const char *s = d;\n+  wrap_strncat (d, s, n);\n+}\n+\n+\n+void wrap_strncpy (char *d, const char *s, size_t n)\n+{\n+  strncpy (d, s, n);   /* { dg-warning \"source argument is the same as destination\" \"strncpy\" } */\n+}\n+\n+void call_strncpy (char *d, size_t n)\n+{\n+  const char *s = d;\n+  wrap_strncpy (d, s, n);\n+}"}, {"sha": "671497ea3e631e992d28b4eb6eb993b1eca72794", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "added", "additions": 992, "deletions": 0, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,992 @@\n+/* PR 35503 - Warn about restricted pointers\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict -ftrack-macro-expansion=0\" } */\n+\n+#include \"../gcc.dg/range.h\"\n+\n+#if !defined LINE\n+# define LINE 0\n+#endif\n+\n+#if __cplusplus\n+#  define restrict __restrict\n+extern \"C\" {\n+#endif\n+\n+extern void* memcpy (void* restrict, const void* restrict, size_t);\n+extern void* mempcpy (void* restrict, const void* restrict, size_t);\n+extern void* memmove (void*, const void*, size_t);\n+\n+extern char* stpcpy (char* restrict, const char* restrict);\n+\n+extern char* strcat (char* restrict, const char* restrict);\n+extern char* strcpy (char* restrict, const char* restrict);\n+extern char* strncpy (char* restrict, const char* restrict, size_t);\n+\n+#if __cplusplus\n+}   /* extern \"C\" */\n+#endif\n+\n+void sink (void*, ...);\n+\n+struct MemArrays\n+{\n+  char a8[8];\n+  char a16[16];\n+  char ax[];\n+};\n+\n+/* Exercise memcpy with constant or known arguments.  */\n+\n+void test_memcpy_cst (void *d, const void *s)\n+{\n+#undef T\n+#define T(dst, src, n) do {\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[9] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\t\\\n+      void *pd = (dst);\t\t\t\t\t\\\n+      const void *ps = (src);\t\t\t\t\\\n+      memcpy (pd, ps, (n));\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (a, a, 0);\n+  T (a, s = a, 3);           /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+\n+  /* This isn't detected because memcpy calls with small power-of-2 sizes\n+     are intentionally folded into safe copies equivalent to memmove.\n+     It's marked xfail only because there is value in detecting such\n+     invalid calls for portability, and as a reminder of why it isn't\n+     diagnosed.  */\n+  T (a, a + 1, 1);           /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy with a small power of 2 size\" { xfail *-*-* } } */\n+  T (a, a + 3, 3);\n+  T (a, a + 3, 5);           /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+\n+  {\n+    char a[3] = { 1, 2, 3 };\n+\n+    /* Verify that a call to memcpy with an exact overlap is diagnosed\n+       (also tested above) but an excplicit one to __builtin_memcpy is\n+       not.  See bug 32667 for the rationale.  */\n+    (memcpy)(a, a, sizeof a);   /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+    sink (a);\n+\n+    __builtin_memcpy (a, a, sizeof a);\n+    sink (a);\n+  }\n+\n+  {\n+    char a[3][7];\n+    sink (a);\n+\n+    void *d = a[0];\n+    const void *s = a[1];\n+    memcpy (d, s, sizeof a[0]);\n+    sink (&a);\n+\n+    d = a[0];\n+    s = a[1];\n+    /* The following is only diagnosed for sizes that aren't small\n+       powers of 2.  */\n+    memcpy (d, s, sizeof a[0] + 2); /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&a);\n+\n+    d = a[0] + 1;\n+    s = a[1] + 1;\n+    memcpy (d, s, sizeof a[0]);\n+    sink (&a);\n+\n+    d = a[0] + 1;\n+    s = a[1] + 1;\n+    memcpy (d, s, sizeof a[0] + 2); /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&a);\n+  }\n+\n+  {\n+    struct {\n+      char a[7];\n+      char b[7];\n+      char c[7];\n+    } x;\n+    sink (&x);\n+\n+    void *d = x.a;\n+    const void *s = x.b;\n+    memcpy (d, s, sizeof x.a);\n+    sink (&x);\n+\n+    d = x.a;\n+    s = x.a;\n+    memcpy (d, s, sizeof x.a);    /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&x);\n+\n+    d = x.a + 4;\n+    s = x.b;\n+    memcpy (d, s, sizeof x.a);    /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&x);\n+\n+    d = x.a + 6;\n+    s = x.b;\n+    memcpy (d, s, 1);\n+    sink (&x);\n+\n+    d = x.a + 7;\n+    s = x.b;\n+    memcpy (d, s, 3);             /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&x);\n+\n+    d = x.a + 7;\n+    s = x.b + 1;\n+    memcpy (d, s, 1);\n+    sink (&x);\n+\n+    d = x.b;\n+    s = x.a;\n+    memcpy (d, s, 1);\n+    sink (&x);\n+\n+    d = x.b;\n+    s = x.a;\n+    memcpy (d, s, sizeof x.b);\n+    sink (&x);\n+\n+    d = x.b + 2;\n+    s = x.a + 1;\n+    memcpy (d, s, sizeof x.b);\n+    sink (&x);\n+\n+    d = x.b + 2;\n+    s = x.a + 2;\n+    memcpy (d, s, sizeof x.b);\n+    sink (&x);\n+\n+    d = x.b + 2;\n+    s = x.a + 3;\n+    memcpy (d, s, sizeof x.b);    /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+    sink (&x);\n+  }\n+\n+  {\n+#undef T\n+#define T(dst, src, n) do {\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[9] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };\t\\\n+      memcpy ((dst), (src), (n));\t\t\t\\\n+      sink (a);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+    } while (0)\n+\n+    /* Verify the offset of the overlap is the same regardless of whether\n+       the destination is at lower or higher offset than the source.  */\n+    T (a, a + 1, 5);             /* { dg-warning \"accessing 5 bytes at offsets 0 and 1 overlaps 4 bytes at offset 1\" \"memcpy\" } */\n+    T (a, a + 2, 5);             /* { dg-warning \"accessing 5 bytes at offsets 0 and 2 overlaps 3 bytes at offset 2\" \"memcpy\" } */\n+    T (a, a + 3, 5);             /* { dg-warning \"accessing 5 bytes at offsets 0 and 3 overlaps 2 bytes at offset 3\" \"memcpy\" } */\n+\n+    T (a + 1, a, 5);             /* { dg-warning \"accessing 5 bytes at offsets 1 and 0 overlaps 4 bytes at offset 1\" \"memcpy\" } */\n+    T (a + 2, a, 5);             /* { dg-warning \"accessing 5 bytes at offsets 2 and 0 overlaps 3 bytes at offset 2\" \"memcpy\" } */\n+    T (a + 3, a, 5);             /* { dg-warning \"accessing 5 bytes at offsets 3 and 0 overlaps 2 bytes at offset 3\" \"memcpy\" } */\n+  }\n+}\n+\n+/* Exercise memcpy with destination or source offset or size in\n+   a determinate range.  */\n+\n+void test_memcpy_range (char *d, size_t sz)\n+{\n+#undef T\n+#define T(dst, src, n) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\\\n+      char a[9] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };\t\\\n+      void *pd = (dst);\t\t\t\t\t\\\n+      const void *ps = (src);\t\t\t\t\\\n+      memcpy (pd, ps, (n));\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t ir = SR (2, 3);\n+  T (a + ir, a, 0);\n+  T (a + ir, a, 1);\n+  T (a + ir, a, 2);\n+  T (a + ir, a, 3);\n+  /* The following fails because the size is a small power of 2.  */\n+  T (a + ir, a, 4);               /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 3] and 0 overlaps between 1 and 2 bytes at offset \\\\\\[3, 2]\" \"memcpy\" { xfail *-*-*} } */\n+  T (a + ir, a, 5);               /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 3] and 0 overlaps between 2 and 3 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n+\n+  T (d + ir, d, 0);\n+  T (d + ir, d, 1);\n+  T (d + ir, d, 2);\n+  T (d + ir, d, 3);\n+  T (d + ir, d, 4);               /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 3] and 0 overlaps 1 byte at offset 3\" \"bug 79220\" { xfail *-*-* } } */\n+  T (d + ir, d, 5);               /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 3] and 0 overlaps between 2 and 3 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n+\n+  /* Because the size is constant and a power of 2 the following is\n+     folded too early to detect the overlap.  */\n+  T (d + ir, d, 4);               /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 3] and 0 overlaps 2 byte at offset 2\" \"\" { xfail *-*-* } } */\n+  T (d + ir, d, 5);               /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 3] and 0 overlaps between 2 and 3 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n+\n+  /* Exercise the full range of size_t.  */\n+  T (d + sz, d, 0);\n+  T (d + sz, d, 1);\n+  T (d + sz, d, 9);\n+\n+  T (a, a + 1, SR (0, 1));\n+  T (a, a + 1, SR (0, 2));\n+  T (a, a + 1, SR (1, 2));\n+  T (a, a + 1, SR (2, 3));         /* { dg-warning \"accessing between 2 and 3 bytes at offsets 0 and 1 overlaps between 1 and 2 bytes at offset 1\" \"memcpy\" } */\n+  T (a, a + 1, UR (2, DIFF_MAX + (size_t)1));  /* { dg-warning \"accessing 2 or more bytes at offsets 0 and 1 overlaps 1 or more bytes at offset 1\" \"memcpy\" } */\n+  T (a, a + 1, UR (2, SIZE_MAX - 1));        /* { dg-warning \"accessing 2 or more bytes at offsets 0 and 1 overlaps 1 or more bytes at offset 1\" \"memcpy\" } */\n+  T (a, a + 2, SR (2, 3));\n+  T (a, a + 2, SR (3, 4));         /* { dg-warning \"accessing between 3 and 4 bytes at offsets 0 and 2 overlaps between 1 and 2 bytes at offset 2\" \"memcpy\" } */\n+  T (a, a + 3, SR (3, 4));\n+  T (a, a + 3, SR (4, 5));         /* { dg-warning \"accessing between 4 and 5 bytes at offsets 0 and 3 overlaps between 1 and 2 bytes at offset 3\" \"memcpy\" } */\n+  T (a, a + 3, SR (5, 6));         /* { dg-warning \"accessing between 5 and 6 bytes at offsets 0 and 3 overlaps between 2 and 3 bytes at offset 3\" \"memcpy\" } */\n+\n+  T (a + 1, a, SR (0, 1));\n+  T (a + 1, a, SR (0, 2));\n+  T (a + 1, a, SR (1, 2));\n+  T (a + 1, a, SR (2, 3));         /* { dg-warning \"accessing between 2 and 3 bytes at offsets 1 and 0 overlaps between 1 and 2 bytes at offset 1\" \"memcpy\" } */\n+  T (a + 1, a, UR (2, DIFF_MAX + (size_t)1)); /* { dg-warning \"accessing 2 or more bytes at offsets 1 and 0 overlaps 1 or more bytes at offset 1\" \"memcpy\" } */\n+  T (a + 1, a, UR (2, SIZE_MAX - 1)); /* { dg-warning \"accessing 2 or more bytes at offsets 1 and 0 overlaps 1 or more bytes at offset 1\" \"memcpy\" } */\n+  T (a + 2, a, SR (2, 3));\n+  T (a + 2, a, SR (3, 4));         /* { dg-warning \"accessing between 3 and 4 bytes at offsets 2 and 0 overlaps between 1 and 2 bytes at offset 2\" \"memcpy\" } */\n+  T (a + 3, a, SR (3, 4));\n+  T (a + 3, a, SR (4, 5));         /* { dg-warning \"accessing between 4 and 5 bytes at offsets 3 and 0 overlaps between 1 and 2 bytes at offset 3\" \"memcpy\" } */\n+  T (a + 3, a, SR (5, 6));         /* { dg-warning \"accessing between 5 and 6 bytes at offsets 3 and 0 overlaps between 2 and 3 bytes at offset 3\" \"memcpy\" } */\n+\n+  ir = SR (2, 5);\n+  T (a, a + ir, 4);\n+  T (a, a + ir, 5);                /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2, 5] overlaps between 1 and 3 bytes at offset \\\\\\[2, 4]\" \"memcpy\" } */\n+  T (a, a + ir, 6);                /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[2, 5] overlaps between 3 and 4 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n+\n+  /* Below, there are two possible regions for the source of the copy:\n+       1) one just before the high end of the address space that's 3\n+          bytes large close to the lower end of the offset range, and\n+       2) another in the [DIFF_MIN, -8] range from D and so at least\n+          8 bytes in size\n+     A copy from (1) overlaps but one from (2) does not.  Verify that\n+     the copy is not diagnosed.  (This test case was reduced from\n+     the Linux kernel.) */\n+  T (d, d + UR (DIFF_MAX - 3, SIZE_MAX - 7), 5);\n+  T (d, d + UR (DIFF_MAX - 3, SIZE_MAX - 7), 6);\n+  T (d, d + UR (DIFF_MAX - 3, SIZE_MAX - 7), 7);\n+  T (d, d + UR (DIFF_MAX - 3, SIZE_MAX - 7), 9);\n+\n+  T (d + UR (DIFF_MAX - 3, SIZE_MAX - 7), d, 5);\n+  T (d + UR (DIFF_MAX - 3, SIZE_MAX - 7), d, 6);\n+  T (d + UR (DIFF_MAX - 3, SIZE_MAX - 7), d, 7);\n+  T (d + UR (DIFF_MAX - 3, SIZE_MAX - 7), d, 9);\n+\n+  {\n+    /* Create an offset in the range [0, -1].  */\n+    size_t o = sz << 1;\n+    T (d, d + o, 12345);\n+    T (d + o, d, 23456);\n+  }\n+\n+  /* Exercise memcpy with both destination and source pointer offsets\n+     in some known range.  */\n+  size_t n = UR (3, 4);\n+  T (a + SR (1, 3), a + SR (1, 3), n);  /* { dg-warning \"accessing between 3 and 4 bytes at offsets \\\\\\[1, 3] and \\\\\\[1, 3] overlaps between 1 and 4 bytes at offset \\\\\\[1, 3]\" \"memcpy\" } */\n+\n+  /* This is an interesting case:\n+       memcpy (a + i, a + j, n) with i in [1, 3], j in [2, 3], and n in [3, 4]\n+     we have the following possibilities ('^' denotesthe destination offset,\n+     '*' marks the overlap, and '?' is the possible overlap for large n):\n+       i j | a = 012345678   SIZ  OFF (size and offset of the overlap)\n+       1 2 |      ^**?       2-3   2\n+       1 3 |      ^ *?       1-2   3\n+       2 2 |       ***?      3-4   2\n+       2 3 |       ^**?      2-3   3\n+       3 3 |        ***?     3-4   3\n+     There are two ways to present the results:\n+     1) overlaps between 1 and 4 bytes at offset [2, 3]\n+     2) overlaps between 1 and 4 bytes at offset 2.  */\n+  T (a + SR (1, 3), a + SR (2, 3), n);  /* { dg-warning \"accessing between 3 and 4 bytes at offsets \\\\\\[1, 3] and \\\\\\[2, 3] overlaps between 1 and 4 bytes at offset \\\\\\[2, 3]\" \"memcpy\" } */\n+  T (a + SR (1, 3), a + SR (3, 4), n);\n+\n+  T (a + SR (2, 3), a + SR (3, 4), n);  /* { dg-warning \"accessing between 3 and 4 bytes at offsets \\\\\\[2, 3] and \\\\\\[3, 4] overlaps between 1 and 4 bytes at offset \\\\\\[3, 4]\" \"memcpy\" } */\n+\n+  T (a + SR (1, 3), a + SR (4, 5), n);\n+  T (a + SR (2, 3), a + SR (4, 5), n);\n+  T (a + SR (3, 4), a + SR (4, 5), n);  /* { dg-warning \"accessing between 3 and 4 bytes at offsets \\\\\\[3, 4] and \\\\\\[4, 5] overlaps between 1 and 4 bytes at offset \\\\\\[4, 5]\" \"memcpy\" } */\n+\n+  /* Exercise the full range of size_t.  */\n+  T (d, d + sz, 0);\n+  T (d, d + sz, 1);\n+  T (d, d + sz, 9);\n+}\n+\n+/* Exercise memcpy with offset and/or size in a determinate anti-range.  */\n+\n+void test_memcpy_anti_range (char *d, const char *s)\n+{\n+  T (d, d + SAR (0, 3), 1);\n+  T (d, d + SAR (0, 3), 2);\n+  T (d, d + SAR (0, 3), 3);\n+  T (d, d + SAR (0, 3), DIFF_MAX - 2);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 2\" } */\n+  T (d, d + SAR (0, 3), DIFF_MAX - 1);   /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 1\" } */\n+  T (d, d + SAR (0, 3), DIFF_MAX);       /* { dg-warning \"overlaps \\[0-9\\]+ bytes at offset 0\" } */\n+\n+  T (d, d + SAR (0, 3), UR (DIFF_MAX - 2, DIFF_MAX));               /* { dg-warning \"accessing \\[0-9\\]+ or more bytes at offsets 0 and \\\\\\[-?\\[0-9\\]+, -?\\[0-9\\]+] overlaps \\[0-9\\]+ bytes at offset 2\" } */\n+\n+  /* Verify that a size in an anti-range ~[0, N] where N >= PTRDIFF_MAX\n+     doesn't trigger a warning.  */\n+  T (d, s, UAR (1, DIFF_MAX - 1));\n+  T (d, s, UAR (1, DIFF_MAX));\n+  T (d, s, UAR (1, SIZE_MAX - 1));\n+\n+  /* This causes the last dg-warning test to fail for some reason.\n+     T (d, s, UAR (1, SIZE_MAX)); */\n+}\n+\n+/* Verify calls to memcpy() where the combination of offsets in some\n+   range and size is such that either overlap is unavoidable or one\n+   or both offsets would exceed the maximum size of an object\n+   (DIFF_MAX).  */\n+\n+void test_memcpy_range_exceed (char *d, const char *s)\n+{\n+  /* Verify offset and size both in some range.  The memcpy checking\n+     is less strict than that of string functions like strncpy and\n+     doesn't trigger unless the overlap is certain.  The following\n+     overlaps for (r == 3 && n > 3) but not, for example, for\n+     (r == 4 && n == 4), and so it's not diagnosed.  */\n+  ptrdiff_t i = SR (3, 5);\n+  size_t n = UR (4, 6);\n+\n+  T (a, a + i, n);\n+  T (a + i, a, n);\n+  /* Ditto for objects of unknown sizes.  */\n+  T (d, d + i, n);\n+  T (d + i, d, n);\n+\n+  /* Verify that a warning is issued for a copy between two regions\n+     whose aggregate size would exceed DIFF_MAX if it were to not\n+     overlap.  */\n+  T (d, s, DIFF_MAX / 2);\n+  T (d, s, DIFF_MAX / 2 + 1);   /* { dg-warning \"overlaps 1 byte\" \"memcpy\" } */\n+  T (d, s, DIFF_MAX / 2 + 2);   /* { dg-warning \"overlaps 3 bytes\" \"memcpy\" } */\n+  T (d, s, DIFF_MAX / 2 + 3);   /* { dg-warning \"overlaps 5 bytes\" \"memcpy\" } */\n+\n+  i = SR (DIFF_MAX - 2, DIFF_MAX);\n+\n+  /* Verify a warning for an out-of-bounds offset range and constant\n+     size addition.  */\n+  T (d, d + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 byte\" \"memcpy\" } */\n+  T (d + i, d, 3);   /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 0 overlaps 1 byte\" \"memcpy\" } */\n+\n+  T (d + 1, d + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 1 and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 byte\" \"memcpy\" } */\n+  T (d + i, d + 1, 3);   /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 1 overlaps 1 byte\" \"memcpy\" } */\n+\n+  /* Verify that the warnings above are independent of whether the source\n+     and destination are known to be based on the same object.  */\n+  T (d, s + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 byte\" \"memcpy\" } */\n+  T (d + i, s, 3);   /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 0 overlaps 1 byte\" \"memcpy\" } */\n+\n+  T (d + 1, s + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 1 and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 byte\" \"memcpy\" } */\n+  T (d + i, s + 1, 3);   /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 1 overlaps 1 byte\" \"memcpy\" } */\n+\n+#if __SIZEOF_SIZE_T__ == 8\n+  /* Verfiy the offset and size computation is correct.  The overlap\n+     offset mentioned in the warning plus sthe size of the access must\n+     not exceed DIFF_MAX.  */\n+  T (d, d + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[9223372036854775805, 9223372036854775807] overlaps 3 bytes at offset 9223372036854775802\" \"LP64\" { target lp64 } } */\n+  T (d + i, d, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[9223372036854775805, 9223372036854775807] and 0 overlaps 3 bytes at offset 9223372036854775802\" \"LP64\" { target lp64 } } */\n+\n+  T (d, s + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[9223372036854775805, 9223372036854775807] overlaps 3 bytes at offset 9223372036854775802\" \"LP64\" { target lp64 } } */\n+  T (d + i, s, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[9223372036854775805, 9223372036854775807] and 0 overlaps 3 bytes at offset 9223372036854775802\" \"LP64\" { target lp64 } } */\n+#elif __SIZEOF_SIZE_T__ == 4\n+  T (d, d + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2147483645, 2147483647] overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32 } } */\n+  T (d + i, d, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2147483645, 2147483647] and 0 overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32} } */\n+\n+  T (d, s + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2147483645, 2147483647] overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32 } } */\n+  T (d + i, s, 5);   /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2147483645, 2147483647] and 0 overlaps 3 bytes at offset 2147483642\" \"ILP32\" { target ilp32} } */\n+#endif\n+\n+  ptrdiff_t j = SR (DIFF_MAX - 9, DIFF_MAX - 1);\n+  i = SR (DIFF_MAX - 5, DIFF_MAX - 1);\n+  n = UR (4, 5);\n+  T (d + i, d + j, n);\n+\n+  n = UR (4, DIFF_MAX - 1);\n+  T (d + i, d + j, n);\n+\n+  n = UR (4, SIZE_MAX - 1);\n+  T (d + i, d + j, n);\n+\n+  j = SR (DIFF_MAX - 8, DIFF_MAX - 1);\n+  T (d + i, d + j, n);\n+\n+  j = SR (DIFF_MAX - 7, DIFF_MAX - 1);\n+  T (d + i, d + j, n);   /* { dg-warning \"accessing 4( or more)? bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps\" \"memcpy\" } */\n+\n+  j = SR (DIFF_MAX - 6, DIFF_MAX - 1);\n+  T (d + i, d + j, n);   /* { dg-warning \"accessing 4( or more)? bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps\" \"memcpy\" } */\n+\n+  n = UR (3, DIFF_MAX);\n+  T (d + i, d + j, n);\n+\n+  j = SR (DIFF_MAX - 6, DIFF_MAX - 1);\n+  T (d + i, d + j, n);\n+\n+  j = SR (DIFF_MAX - 5, DIFF_MAX - 1);\n+  T (d + i, d + j, n);   /* { dg-warning \"accessing 3 or more bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 or more bytes\" \"memcpy\" } */\n+\n+  j = SR (DIFF_MAX - 4, DIFF_MAX - 1);\n+  T (d + i, d + j, n);   /* { dg-warning \"accessing 3 or more bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 or more bytes\" \"memcpy\" } */\n+\n+  j = SR (DIFF_MAX - 2, DIFF_MAX - 1);\n+  T (d + i, d + j, n);   /* { dg-warning \"accessing 3 or more bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and \\\\\\[\\[0-9\\]+, \\[0-9\\]+] overlaps 1 or more bytes\" \"memcpy\" } */\n+}\n+\n+/* Exercise memcpy with destination and source of unknown size.  */\n+\n+void test_memcpy_var (char *d, const char *s)\n+{\n+  size_t n = unsigned_value ();\n+\n+  memcpy (d, d, 0);\n+  sink (d);\n+\n+  memcpy (d, d, n);               /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+  sink (d);\n+\n+  memcpy (d, &d[0], n);           /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+  sink (d);\n+\n+  memcpy (&d[0], d,  n);          /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+  sink (d);\n+\n+  s = d;\n+  memcpy (d, s, n);               /* { dg-warning \"source argument is the same as destination\" \"memcpy\" } */\n+  sink (d);\n+\n+  /* The following overlaps if n is greater than 1.  */\n+  s = d + 1;\n+  memcpy (d, s, n);\n+  sink (d);\n+\n+  s = d + n;\n+  memcpy (d, s, n);\n+  sink (d);\n+\n+  s = d + signed_value ();\n+  memcpy (d, s, unsigned_value ());\n+  sink (d);\n+\n+  s = d + 3;\n+  n = 1;\n+  memcpy (d, s, n);\n+  sink (d);\n+\n+  s = d + 3;\n+  n = 2;\n+  memcpy (d, s, n);\n+  sink (d);\n+\n+  s = d + 3;\n+  n = 3;\n+  memcpy (d, s, n);\n+  sink (d);\n+\n+  s = d + 3;\n+  n = 4;\n+  memcpy (d, s, n);               /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+  sink (d);\n+\n+  s = d + 5;\n+  n = 7;\n+  memcpy (d, s, n);               /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+\n+  n = UR (0, 1);\n+  s = d;\n+  memcpy (d, s, n);               /* { dg-warning \"\\\\\\[-Wrestrict\" \"memcpy\" } */\n+}\n+\n+\n+void test_memcpy_memarrray (struct MemArrays *p)\n+{\n+#undef T\n+#define T(dst, src, n) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\\\n+      void *pd = (dst);\t\t\t\t\\\n+      const void *ps = (src);\t\t\t\\\n+      memcpy (pd, ps, (n));\t\t\t\\\n+      sink (pd, ps);\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (p->a8, p->a8, 0);\n+  T (p->a8, p->a8 + 1, 1);\n+  T (p->a8, p->a8 + 2, 2);\n+  T (p->a8, p->a8 + 8, 1);\n+\n+  T (p->a8, p->a8 + 2, 3);        /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" } */\n+}\n+\n+/* Exercise the absence of warnings with memmove.  */\n+\n+void test_memmove (void)\n+{\n+  {\n+    char d[7];\n+    sink (d);\n+\n+    const void *s = d;\n+    memmove (d, s, 7);\n+    sink (d);\n+\n+    s = d + 1;\n+    memmove (d, s, 6);\n+    sink (d);\n+\n+    s = d + 2;\n+    memmove (d + 1, s, 5);\n+    sink (d);\n+  }\n+}\n+\n+/* Exercise strcat with constant or known arguments.  */\n+\n+void test_strcat_cst (const char *s)\n+{\n+#undef T\n+#define T(init, dst, src) do {\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[9] = init;\t\t\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\t\\\n+      strcat (pd, ps);\t\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (\"0\",   a, a);                /* { dg-warning \"source argument is the same as destination\" \"strcat\" } */\n+  T (\"01\",  a, a);                /* { dg-warning \"source argument is the same as destination\" \"strcat\" } */\n+  T (\"012\", a, a);                /* { dg-warning \"source argument is the same as destination\" \"strcat\" } */\n+  /* The 3 bytes \"12\\0\" being appended to \"012\" overwrite the final NUL.  */\n+  T (\"012\", a, a + 1);            /* { dg-warning \"accessing 3 bytes at offsets 0 and 1 overlaps 1 byte at offset 3\" \"strcat\" } */\n+  T (\"012\", a, a + 2);            /* { dg-warning \"accessing 2 bytes at offsets 0 and 2 overlaps 1 byte at offset 3\" \"strcat\" } */\n+  /* The nul copied from a[3] to a[3] overwrites itself so this is\n+     diagnosed.  */\n+  T (\"012\", a, a + 3);            /* { dg-warning \"accessing 1 byte at offsets 0 and 3 overlaps 1 byte at offset 3\" \"strcat\" } */\n+\n+  T (\"012\", a, a + 4);\n+  T (\"012\", a, a + 5);\n+  T (\"012\", a, a + 6);\n+  T (\"012\", a, a + 7);\n+  T (\"012\", a, a + 8);\n+\n+  T (\"0\",   a + 1, a);            /* { dg-warning \"accessing 2 bytes at offsets 1 and 0 overlaps 1 byte at offset 1\" \"strcat\" } */\n+  T (\"0\",   a + 2, a);\n+\n+  /* The first of the two offsets in the diagnostic for strcat is that\n+     of the first write into the destination, not that of the initial\n+     read from it to compute its length.  */\n+  T (\"01\",  a + 1, a);            /* { dg-warning \"accessing 3 bytes at offsets 1 and 0 overlaps 1 byte at offset 2\" \"strcat\" } */\n+  T (\"01\",  a + 2, a);            /* { dg-warning \"accessing 3 bytes at offsets 2 and 0 overlaps 1 byte at offset 2\" \"strcat\" } */\n+  T (\"01\",  a + 3, a);\n+\n+  T (\"012\", a + 1, a);            /* { dg-warning \"accessing 4 bytes at offsets 1 and 0 overlaps 1 byte at offset 3\" \"strcat\" } */\n+  T (\"012\", a + 2, a);            /* { dg-warning \"accessing 4 bytes at offsets 2 and 0 overlaps 1 byte at offset 3\" \"strcat\" } */\n+  T (\"012\", a + 3, a);            /* { dg-warning \"accessing 4 bytes at offsets 3 and 0 overlaps 1 byte at offset 3 \" \"strcat\" } */\n+  T (\"012\", a + 4, a);\n+  T (\"012\", a + 5, a);\n+\n+  /* Verify that the obviously benign cases below aren't diagnosed.  */\n+  T (\"012\",      a, \"012\");\n+  T (\"012\",      a, s);\n+  T (\"01234567\", a, s);\n+}\n+\n+/* Exercise strcat with destination and source of unknown length.  */\n+\n+void test_strcat_var (char *d, const char *s)\n+{\n+#undef T\n+#define T(dst, src) do {\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\t\\\n+      strcat (pd, ps);\t\t\t\t\t\\\n+      sink (pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (d, d);                       /* { dg-warning \"source argument is the same as destination\" \"strcat\" } */\n+  T (d, d + 1);                   /* { dg-warning \"accessing 0 or more bytes at offsets 0 and 1 may overlap 1 byte\" \"strcat\" } */\n+  T (d, d + 2);                   /* { dg-warning \"accessing 0 or more bytes at offsets 0 and 2 may overlap 1 byte\" \"strcat\" } */\n+  T (d, d + 999);                 /* { dg-warning \"accessing 0 or more bytes at offsets 0 and 999 may overlap 1 byte\" \"strcat\" } */\n+  T (d, d + -99);                 /* { dg-warning \"accessing 0 or more bytes at offsets 0 and -99 may overlap 1 byte\" \"strcat\" } */\n+\n+  size_t n = unsigned_value ();\n+\n+  T (d + n, d + n);                       /* { dg-warning \"\\\\\\[-Wrestrict\" \"strcat\" } */\n+\n+  /* Verify that the obviously benign cases below aren't diagnosed.  */\n+  T (d, \"012\");\n+  T (d + 1, \"0123\");\n+  T (d + n, \"01234\");\n+  T (d, s);\n+  T (d + 1, s);\n+  T (d + n, s);\n+\n+  /* Since the offset is unknown the overlap in the call below, while\n+     possible, is certainly not inevitable.  Conservatively, it should\n+     not be diagnosed.  For safety, an argument for diagnosing can be\n+     made.  It's a judgment call, partly determined by the effort and\n+     complexity of treating this case differently from other similar\n+     to it.   */\n+  T (d, d + n); /* { dg-warning \"may overlap\" \"strcat\" } */\n+}\n+\n+/* Exercise strcpy with constant or known arguments.  */\n+\n+void test_strcpy_cst (ptrdiff_t i)\n+{\n+#undef T\n+#define T(init, dst, src) do {\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[8] = init;\t\t\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\t\\\n+      strcpy (pd, ps);\t\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (\"012\", a, a);                /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+  T (\"012\", a, a + 1);            /* { dg-warning \"accessing 3 bytes at offsets 0 and 1 overlaps 2 bytes at offset 1\" \"strcpy\" } */\n+  T (\"012\", a, a + 2);\n+  T (\"012\", a, a + 3);\n+  /* The following doesn't overlap but it should trigger -Wstringop-overflow\n+     for reading past the end.  */\n+  T (\"012\", a, a + sizeof a);\n+\n+  /* The terminating nul written to d[2] overwrites s[0].  */\n+  T (\"0123\", a, a + 2);           /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" } */\n+\n+  /* The '5' copied from s[2] to d[2] overwrites s[0].  */\n+  T (\"01234\", a, a + 2);          /* { dg-warning \"accessing 4 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2\" } */\n+\n+  /* This happens to be safe in GCC but it's still wrong.  */\n+  T (\"012\", a, a);                /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+\n+  T (\"012\", a + 1, a);            /* { dg-warning \"accessing 4 bytes at offsets 1 and 0 overlaps 3 bytes at offset 1\" \"strcpy\" } */\n+  T (\"012\", a + 2, a);            /* { dg-warning \"accessing 4 bytes at offsets 2 and 0 overlaps 2 bytes at offset 2\" \"strcpy\" } */\n+  T (\"012\", a + 3, a);            /* { dg-warning \"accessing 4 bytes at offsets 3 and 0 overlaps 1 byte at offset 3\" \"strcpy\" } */\n+  T (\"012\", a + 4, a);\n+  /* The following doesn't overlap but it should trigger -Wstrinop-ovewrflow\n+     for writing past the end.  */\n+  T (\"012\", a + sizeof a, a);\n+}\n+\n+/* Exercise strcpy with constant or known arguments offset by a range.\n+   The tests verify the use of the lower bound of the range which is\n+   more restrictive than using the upper bound for positive values.  */\n+\n+void test_strcpy_range (void)\n+{\n+#undef T\n+#define T(N, init, dst, src)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\\\n+      char a[N] = init;\t\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\\\n+      strcpy (pd, ps);\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t r;\n+\n+  r = SR (0, 1);\n+  T (8, \"0\", a + r, a);   /* { dg-warning \"accessing between 1 and 2 bytes at offsets \\\\\\[0, 1] and 0 overlaps up to 2 bytes at offset \\\\\\[0, 1]\" \"strcpy\" { xfail *-*-*} } */\n+\n+  r = SR (2, 5);\n+  T (8, \"01\",  a + r, a);            /* { dg-warning \"accessing 3 bytes at offsets \\\\\\[2, 5] and 0 may overlap 1 byte at offset 2\" } */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 2 bytes at offset \\\\\\[3, 2]\" \"strcpy\" } */\n+\n+  /* The highest offset to which to copy without overflowing the 8-byte\n+     destination is 3 and that overlaps 2 bytes.  */\n+  T (8, \"0123\", a + r, a);           /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 5] and 0 overlaps between 2 and 3 bytes at offset \\\\\\[2, 3]\" \"strcpy\" } */\n+\n+  /* With a 9-byte destination the highest offset is 4 and that still\n+     overlaps 1 byte (the final NUL).  */\n+  T (9, \"0123\", a + r, a);           /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 5] and 0 overlaps between 1 and 3 bytes at offset \\\\\\[2, 4]\" \"strcpy\" } */\n+\n+  /* With a 10-byte buffer it's possible to copy all 5 bytes without\n+     overlap at (a + 5).  Copying at offsets 2 through 4 overflows\n+     between 3 and 1 bytes, respectively.  */\n+  T (10, \"0123\", a + r, a);          /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[2, 5] and 0 may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strcpy\" } */\n+\n+\n+  r  = SR (3, 4);\n+  T (8, \"01\",  a + r, a);\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[3, 4] and 0 may overlap 1 byte at offset 3\" \"strcpy\" } */\n+\n+  /* The highest offset to which to copy without overflowing the 8-byte\n+     destination is 3 and that overlaps 2 bytes.  */\n+  T (8, \"0123\", a + r, a);           /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[3, 4] and 0 overlaps 2 bytes at offset 3\" \"strcpy\" } */\n+\n+  /* With a 9-byte destination the highest offset is 4 and that still\n+     overlaps 1 byte (the final NUL).  */\n+  T (9, \"0123\", a + r, a);           /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[3, 4] and 0 overlaps between 1 and 2 bytes at offset \\\\\\[3, 4]\" \"strcpy\" } */\n+\n+  /* With a 10-byte buffer it's possible to copy all 5 bytes without\n+     overlap at (a + 5).  Copying at offsets 2 through 4 overflows\n+     between 3 and 1 bytes, respectively.  */\n+  T (10, \"0123\", a + r, a);          /* { dg-warning \"accessing 5 bytes at offsets \\\\\\[3, 4] and 0 overlaps between 1 and 2 bytes at offset \\\\\\[3, 4]\" \"strcpy\" } */\n+\n+  T (8, \"01\",     a, a + r);\n+  T (8, \"012\",    a, a + r);\n+  T (8, \"0123\",   a, a + r);\n+  T (8, \"01234\",  a, a + r);\n+\n+  /* With the smaller offset of 3 the final NUL definitely overlaps\n+     the '4' at a[3], but with the larger offset of 4 there is no\n+     overlap, so the warning is a \"may overlap\" and the size of\n+     the overlap is 1 byte.  */\n+  T (8, \"012345\", a, a + r);         /* { dg-warning \"accessing between 3 and 4 bytes at offsets 0 and \\\\\\[3, 4] may overlap 1 byte at offset 3\" \"strcpy\" } */\n+  T (8, \"0123456\", a, a + r);        /* { dg-warning \"accessing between 4 and 5 bytes at offsets 0 and \\\\\\[3, 4] may overlap up to 2 bytes at offset 3\" \"strcpy\" } */\n+\n+  r = SR (3, DIFF_MAX - 3);\n+  T (8, \"01\",  a + r, a);\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[3, \\[0-9\\]+] and 0 may overlap 1 byte at offset 3\" \"strcpy\" } */\n+\n+  r = SR (DIFF_MAX - 2, DIFF_MAX - 1);\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes at offsets \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and 0 overlaps\" \"strcpy\" } */\n+\n+  /* Exercise the full range of ptrdiff_t.  */\n+  r = signed_value ();\n+\n+  /* The overlap in the cases below isn't inevitable but it is diagnosed\n+     because it is possible and so the code is considered unsafe.  */\n+  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte may overlap 1 byte\" \"strcpy\" } */\n+  T (8, \"0\", a + r, a);              /* { dg-warning \"accessing 2 bytes may overlap up to 2 bytes\" \"strcpy\" } */\n+  T (8, \"012\", a + r, a);            /* { dg-warning \"accessing 4 bytes may overlap up to 4 bytes\" \"strcpy\" } */\n+\n+  T (8, \"\", a, a + r);               /* { dg-warning \"accessing 1 byte may overlap\" \"strcpy\" } */\n+  T (8, \"0\", a, a + r);              /* { dg-warning \"accessing between 0 and 2 bytes may overlap up to 2 bytes\" \"strcpy\" } */\n+  T (8, \"012\", a, a + r);            /* { dg-warning \"accessing between 0 and 4 bytes may overlap up to 4 bytes\" \"strcpy\" } */\n+}\n+\n+/* Exercise strcpy with destination and/or source of unknown lengthu.  */\n+\n+void test_strcpy_var (char *d, const char *s)\n+{\n+#undef T\n+#define T(dst, src) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\t\\\n+      strcpy (pd, ps);\t\t\t\t\t\\\n+      sink (pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (d, s);\n+\n+  T (d, &d[0]);                   /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+  T (&d[0], d);                   /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+\n+  s = d;\n+  T (d, s);                       /* { dg-warning \"source argument is the same as destination\" \"strcpy\" } */\n+\n+  /* The following overlaps if *s is not nul.  It arguably should be\n+     diagnosed.  */\n+  T (d, d + 1);\n+\n+  /* The following overlaps if strlen (d) is greater than 1.  Like\n+     the above, it possibly should be diagnosed too.  */\n+  int r = SR (2, 3);\n+  T (d, d + r);\n+\n+  /* The following overlaps only if strlen (s + n) >= n so it's not\n+     diagnosed.  */\n+  s = d + signed_value ();\n+  T (d, s);\n+}\n+\n+/* Exercise strncpy with constant or known arguments.  */\n+\n+void test_strncpy_cst (void)\n+{\n+#undef T\n+#define T(init, dst, src, size) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[9] = init;\t\t\t\t\t\\\n+      char *pd = (dst);\t\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\t\\\n+      strncpy (pd, ps, (size));\t\t\t\t\\\n+      sink (a, pd, ps);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (\"012\", a, a, 0);\n+  T (\"012\", a, a, 1);             /* { dg-warning \"source argument is the same as destination \" \"strncpy\" } */\n+\n+  T (\"012\", a, a + 1, 1);\n+  T (\"012\", a, a + 1, 2);         /* { dg-warning \"accessing 2 bytes at offsets 0 and 1 overlaps 1 byte at offset 1\" \"strncpy\" } */\n+  T (\"012\", a, a + 1, 3);         /* { dg-warning \"accessing 3 bytes at offsets 0 and 1 overlaps 2 bytes at offset 1\" \"strncpy\" } */\n+  T (\"012\", a, a + 1, 4);         /* { dg-warning \"accessing 4 bytes at offsets 0 and 1 overlaps 3 bytes at offset 1\" \"strncpy\" } */\n+  T (\"012\", a, a + 1, 5);         /* { dg-warning \"accessing 5 bytes at offsets 0 and 1 overlaps 3 bytes at offset 1\" \"strncpy\" } */\n+  T (\"012\", a, a + 1, 6);         /* { dg-warning \"accessing 6 bytes at offsets 0 and 1 overlaps 3 bytes at offset 1\" \"strncpy\" } */\n+\n+  T (\"012\", a, a + 2, 1);\n+  T (\"012\", a, a + 2, 2);\n+  /* The third written byte (nul) overwrites a[2].  */\n+  T (\"012\", a, a + 2, 3);         /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" \"strncpy\" } */\n+  T (\"012\", a, a + 2, 4);         /* { dg-warning \"accessing 4 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2\" \"strncpy\" } */\n+  T (\"012\", a, a + 2, 5);         /* { dg-warning \"accessing 5 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2\" \"strncpy\" } */\n+\n+  T (\"0123\", a, a + 2, 1);\n+  T (\"0123\", a, a + 2, 2);\n+  /* The terminating nul written to a[2] overwrites s[0].  */\n+  T (\"0123\", a, a + 2, 3);        /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" \"strncpy\" } */\n+  T (\"0123\", a, a + 2, 4);        /* { dg-warning \"accessing 4 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2\" \"strncpy\" } */\n+  T (\"0123\", a, a + 2, 5);        /* { dg-warning \"accessing 5 bytes at offsets 0 and 2 overlaps 3 bytes at offset 2\" \"strncpy\" } */\n+  T (\"0123\", a, a + 2, 6);        /* { dg-warning \"accessing 6 bytes at offsets 0 and 2 overlaps 3 bytes at offset 2\" \"strncpy\" } */\n+\n+  T (\"01234\", a, a + 2, 1);\n+  T (\"01234\", a, a + 2, 2);\n+  T (\"01234\", a, a + 2, 3);       /* { dg-warning \"accessing 3 bytes at offsets 0 and 2 overlaps 1 byte at offset 2\" \"strncpy\" } */\n+  /* The '5' copied from s[2] to d[2] overwrites s[0].  */\n+  T (\"01234\", a, a + 2, 4);       /* { dg-warning \"accessing 4 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2\" \"strncpy\" } */\n+  T (\"01234\", a, a + 2, 5);       /* { dg-warning \"accessing 5 bytes at offsets 0 and 2 overlaps 3 bytes at offset 2\" \"strncpy\" } */\n+}\n+\n+\n+/* Exercise strncpy with one or more arguments in a determinate range.  */\n+\n+void test_strncpy_range (char *d, size_t n)\n+{\n+#undef T\n+#define T(init, dst, src, size) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\t\\\n+      char a[9] = init;\t\t\t\t\t\\\n+      strncpy ((dst), (src), (size));\t\t\t\\\n+      sink (a, (dst), (src));\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  ptrdiff_t i;\n+\n+  i = SR (0, 1);\n+  T (\"0123\", a, a + i, 0);\n+  T (\"0123\", a, a + i, 1);\n+  /* Offset in the range [0, i] is represented as a PHI (&a, &a + i)\n+     that the implementation isn't equipped to handle yet.  */\n+  T (\"0123\", a, a + i, 2);   /* { dg-warning \"accessing 2 bytes at offsets 0 and \\\\\\[0, 1] may overlap 1 byte at offset 1\" \"strncpy\" { xfail *-*-* } } */\n+\n+  i = SR (1, 5);\n+  T (\"0123\", a, a + i, 0);\n+  T (\"0123\", a, a + i, 1);\n+  T (\"0123\", a, a + i, 2);   /* { dg-warning \"accessing 2 bytes at offsets 0 and \\\\\\[1, 5] may overlap 1 byte at offset 1\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 2 bytes at offset \\\\\\[2, 1]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 3 bytes at offset \\\\\\[3, 1]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[1, 5] may overlap up to 4 bytes at offset \\\\\\[4, 1]\" \"strncpy\" } */\n+\n+  i = SR (2, 5);\n+  T (\"0123\", a, a + i, 0);\n+  T (\"0123\", a, a + i, 1);\n+  T (\"0123\", a, a + i, 2);\n+  T (\"0123\", a, a + i, 3);   /* { dg-warning \"accessing 3 bytes at offsets 0 and \\\\\\[2, 5] may overlap 1 byte at offset 2\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 2 bytes at offset \\\\\\[3, 2]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[2, 5] may overlap up to 3 bytes at offset \\\\\\[4, 2]\" \"strncpy\" } */\n+\n+  i = SR (3, 5);\n+  T (\"0123\", a, a + i, 0);\n+  T (\"0123\", a, a + i, 1);\n+  T (\"0123\", a, a + i, 2);\n+  T (\"0123\", a, a + i, 3);\n+  T (\"0123\", a, a + i, 4);   /* { dg-warning \"accessing 4 bytes at offsets 0 and \\\\\\[3, 5] may overlap 1 byte at offset 3\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[3, 5] may overlap up to 2 bytes at offset \\\\\\[4, 3]\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[3, 5] may overlap up to 2 bytes at offset \\\\\\[4, 3]\" \"strncpy\" } */\n+\n+  i = SR (4, 5);\n+  T (\"0123\", a, a + i, 0);\n+  T (\"0123\", a, a + i, 1);\n+  T (\"0123\", a, a + i, 2);\n+  T (\"0123\", a, a + i, 3);\n+  T (\"0123\", a, a + i, 4);\n+  T (\"0123\", a, a + i, 5);   /* { dg-warning \"accessing 5 bytes at offsets 0 and \\\\\\[4, 5] may overlap 1 byte at offset 4\" \"strncpy\" } */\n+  T (\"0123\", a, a + i, 6);   /* { dg-warning \"accessing 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap 1 byte at offset 4\" \"strncpy\" } */\n+\n+  /* Verify offset and size both in some range.  The strncpy checking\n+     is more strict than that of memcpy and triggers even when the\n+     overlap is possible but not inevitable.  The following overlaps\n+     like so ('*' denotes the terminating NUL, '.' the appended NUL\n+     that's not copied from the source):\n+        a:        01234567*  (also indicates offset)\n+        i = 4:    4567       none\n+                  4567*      overlaps 1 at offset 4\n+                  4567*.     overlaps 2 at offset 4\n+        i = 5:    567*       none\n+                  567*.      none\n+                  567*..     overlaps 1 at offset 5  */\n+  T (\"01234567\", a, a + i, UR (4, 6));   /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[5, 4]\" \"strncpy\" } */\n+\n+  /* Ditto for objects of unknown sizes.  */\n+  T (\"01234567\", d, d + i, UR (4, 6));  /* { dg-warning \"accessing between 4 and 6 bytes at offsets 0 and \\\\\\[4, 5] may overlap up to 2 bytes at offset \\\\\\[5, 4]\" \"strncpy\" } */\n+\n+  T (\"01234567\", a, a + i, UR (6, 7));  /* { dg-warning \"accessing between 6 and 7 bytes at offsets 0 and \\\\\\[4, 5] overlaps between 1 and 3 bytes at offset \\\\\\[4, 5]\" \"strncpy\" } */\n+\n+  /* The following overlaps except in the unlikely case that value ()\n+     is zero, so it's diagnosed.  */\n+  T (\"012\", a, a, n);             /* { dg-warning \"source argument is the same as destination \" \"strncpy\" } */\n+}\n+\n+\n+/* Exercise strncpy with destination and source of unknown length.  */\n+\n+void test_strncpy_var (char *d, const char *s, size_t n)\n+{\n+#undef T\n+#define T(dst, src, size) do {\t\t\t\\\n+    if (!LINE || LINE == __LINE__) {\t\t\\\n+      char *pd = (dst);\t\t\t\t\\\n+      const char *ps = (src);\t\t\t\\\n+      strncpy (pd, ps, (size));\t\t\t\\\n+      sink (pd, ps);\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+  T (d, s, 1);\n+  T (d, s, n);\n+\n+  T (d, d, 1);                    /* { dg-warning \"\\\\\\[-Wrestrict\" \"strncpy\" } */\n+  T (d, d, n);                    /* { dg-warning \"\\\\\\[-Wrestrict\" \"strncpy\" } */\n+\n+  T (d,     d + 1, 1);\n+  T (d,     d + 1, 2);            /* { dg-warning \"\\\\\\[-Wrestrict\" \"strncpy\" } */\n+  T (d + 1, d,     1);\n+  T (d + 1, d,     2);            /* { dg-warning \"\\\\\\[-Wrestrict\" \"strncpy\" } */\n+}\n+\n+struct MemberArrays\n+{\n+  char a[7];\n+  char b[8];\n+  char c[9];\n+};\n+\n+void test_strncpy_strcpy_var (struct MemberArrays *ar, const char *s)\n+{\n+  /* The following is safe and should not trigger a warning.  */\n+  strncpy (ar->b, s, sizeof ar->b - 1);\n+  ar->b[sizeof ar->b - 1] = '\\0';\n+  strcpy (ar->a, ar->b);\n+  sink (ar);\n+\n+  /* The following is not as safe (it might overflow ar->a) but there\n+     is no overlap so it also shouldn't trigger -Wrestrict.  */\n+  strncpy (ar->c, s, sizeof ar->c - 1);\n+  ar->c[sizeof ar->c - 1] = '\\0';\n+  strcpy (ar->a, ar->c);\n+  sink (ar);\n+}"}, {"sha": "4281e3b5a8ebe86d442aa5f14be60fa047f2c6b4", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,7 +1,7 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument\" } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-c++-compat\" { target c } } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-c++-compat\" { target c } } */\n /* { dg-require-effective-target alloca } */\n \n typedef __SIZE_TYPE__ size_t;"}, {"sha": "d9a1555e7ce9ac9ed765bbcd603fd0ba06d3db37", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess2.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,7 +1,7 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n-/* { dg-options \"-Wall -O2 -Wno-sizeof-array-argument -Wno-stringop-truncation -Wno-c++-compat -ftrack-macro-expansion=0\" {target c} } */\n+/* { dg-options \"-Wall -O2 -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-truncation -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-Wall -O2 -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-truncation -Wno-c++-compat -ftrack-macro-expansion=0\" {target c} } */\n /* { dg-require-effective-target alloca } */\n \n #define bos(ptr) __builtin_object_size (ptr, 1)"}, {"sha": "16340ebf73fd92cd62b1a27ec50d7790c76c0f30", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess1.C?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n+// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } }"}, {"sha": "2dff8f0bc92ac4175b40ce6389c96a2320d36039", "filename": "gcc/testsuite/g++.dg/torture/Wsizeof-pointer-memaccess2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2FWsizeof-pointer-memaccess2.C?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n // Test -Wsizeof-pointer-memaccess warnings.\n // { dg-do compile }\n-// { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n+// { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" }\n // Test just twice, once with -O0 non-fortified, once with -O2 fortified,\n // suppressing buffer overflow warnings.\n // { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } }"}, {"sha": "e80c8add3bbf3d5a07c7baeae25159c5e251d277", "filename": "gcc/testsuite/gcc.dg/Wobjsize-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWobjsize-1.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wall\" } */\n+/* { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n #include \"Wobjsize-1.h\"\n "}, {"sha": "d73e144170ad834ea92e4aaf4653d6c9f243dd87", "filename": "gcc/testsuite/gcc.dg/Wrestrict-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-2.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,41 @@\n+/* Test to verify that the temporary doesn't trigger a bogus -Warray-bounds\n+   warning.  Distilled from libat_exchange_large_inplace in libatomic/gexch.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" }  */\n+\n+typedef typeof (sizeof 0) size_t;\n+\n+extern void *memcpy (void*, const void*, size_t);\n+\n+void libat_exchange_large_inplace (size_t n, void *mptr, void *vptr)\n+{\n+  char temp[1024];\n+\n+  size_t i = 0;\n+\n+  for (i = 0; n >= 1024; i += 1024, n -= 1024)\n+    {\n+      memcpy (temp, mptr + i, 1024);\n+\n+      /* The memcpy call below results in the following:\n+\t unsigned long ivtmp.7;\n+\n+\t ivtmp.7_4 = (unsigned long) mptr_9(D);\n+\t ...\n+\t <bb 4>\n+\t # ivtmp.7_22 = PHI <ivtmp.7_4(3), ivtmp.7_5(4)>\n+\t ...\n+\t _1 = (void *) ivtmp.7_22;\n+\t ...\n+\t memcpy (_1, _2, 1024);\n+\n+\t Treating _1 as a pointer results in the bogus:\n+\t   warning: 'memcpy' offset 0 is out of the bounds [0, 8] of object 'ivtmp.7' with type 'long unsigned int' [-Warray-bounds]\n+\t   memcpy (mptr + i, vptr + i, 1024);\n+\t   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+      */\n+      memcpy (mptr + i, vptr + i, 1024);\n+\n+      memcpy (vptr + i, temp, 1024);\n+    }\n+}"}, {"sha": "076f87862d8a0fe2d57dc02148149c73e5f76095", "filename": "gcc/testsuite/gcc.dg/Wrestrict.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,34 @@\n+/* Test to verify that VLAs are handled gracefully by -Wrestrict\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wrestrict\" }  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define memcpy(d, s, n)  __builtin_memcpy (d, s, n)\n+#define strcpy(d, s)     __builtin_strcpy (d, s)\n+\n+void test_vla (void *d, const char *s1, const char *s2, int i, size_t n)\n+{\n+  char a[n];\n+  char b[n];\n+\n+  strcpy (a, s1);\n+  strcpy (b, s2);\n+\n+  memcpy (d, i ? a : b, n);\n+}\n+\n+\n+void test_vla_member (void *d, const char *s1, const char *s2, int i, size_t n)\n+{\n+  struct S\n+  {\n+    char a[n];\n+    char b[n];\n+  } s;\n+\n+  strcpy (s.a, s1);\n+  strcpy (s.b, s2);\n+\n+  memcpy (d, i ? s.a : s.b, n);\n+}"}, {"sha": "4d14de28b10a250a231fc0c9ed93e33de5bad54e", "filename": "gcc/testsuite/gcc.dg/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWsizeof-pointer-memaccess1.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow\" } */\n /* { dg-require-effective-target alloca } */\n \n typedef __SIZE_TYPE__ size_t;"}, {"sha": "938221b60e138ba1914195828bdabab68de42414", "filename": "gcc/testsuite/gcc.dg/builtin-stpncpy.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stpncpy.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/80669 - Bad -Wstringop-overflow warnings for stpncpy\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall -Wno-stringop-truncation\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -Wno-restrict -Wno-stringop-truncation\" } */\n \n #define SIZE_MAX __SIZE_MAX__\n "}, {"sha": "afd07ddd08ddce6301286390cf0d6d4a839170af", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-1.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-1.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -36,7 +36,10 @@ test (int arg, ...)\n   vx = stpcpy (&buf2[18], \"a\");\n   vx = stpcpy (&buf2[18], \"ab\"); /* { dg-warning \"writing 3\" \"stpcpy\" } */\n   strncpy (&buf2[18], \"a\", 2);\n-  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"writing 3 bytes into a region of size 2\" \"strncpy\" } */\n+\n+  /* Both warnings below are equally meaningful.  */\n+  strncpy (&buf2[18], \"a\", 3); /* { dg-warning \"(writing 3 bytes into a region of size 2|specified bound 3 exceeds destination size 2)\" \"strncpy\" } */\n+\n   strncpy (&buf2[18], \"abc\", 2);\n   strncpy (&buf2[18], \"abc\", 3); /* { dg-warning \"writing 3 \" \"strncpy\" } */\n   memset (buf2, '\\0', sizeof (buf2));\n@@ -93,7 +96,7 @@ void\n test2 (const H h)\n {\n   char c;\n-  strncpy (&c, str, 3); /* { dg-warning \"writing 3 bytes into a region of size 1\" \"strncpy\" } */\n+  strncpy (&c, str, 3); /* { dg-warning \"(writing 3 bytes into a region of size 1|specified bound 3 exceeds destination size 1)\" \"strncpy\" } */\n \n   struct { char b[4]; } x;\n   sprintf (x.b, \"%s\", \"ABCD\"); /* { dg-warning \"writing 5\" \"sprintf\" } */"}, {"sha": "1d76e7e77cf38a11944779459932e15d9c44ed40", "filename": "gcc/testsuite/gcc.dg/memcpy-6.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-6.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,40 @@\n+/* Test to verify that overlapping memcpy with const sizes that are powers\n+   of two are folded into into the same code as memmove, but that they\n+   are diagnosed nonetheless.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wrestrict -fdump-tree-optimized\" } */\n+\n+char a[32];\n+\n+void fold_copy_2 (void)\n+{\n+  __builtin_memcpy (a + 1, a, 2);   /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+}\n+\n+void fold_copy_4 (void)\n+{\n+  __builtin_memcpy (a + 2, a, 4);   /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+}\n+\n+void fold_copy_8 (void)\n+{\n+  __builtin_memcpy (a + 3, a, 8);   /* { dg-warning \"\\\\\\[-Wrestrict]\" } */\n+}\n+\n+void fold_move_2 (void)\n+{\n+  __builtin_memmove (a + 1, a, 2);\n+}\n+\n+void fold_move_4 (void)\n+{\n+  __builtin_memmove (a + 2, a, 4);\n+}\n+\n+void fold_move_8 (void)\n+{\n+  __builtin_memmove (a + 3, a, 8);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"memcpy\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"memmove\" \"optimized\" } } */"}, {"sha": "908d5a6e4757dbad9defc26d90b490b93cb22e8d", "filename": "gcc/testsuite/gcc.dg/pr69172.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69172.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69172.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr69172.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,4 +1,5 @@\n-/* PR tree-optimization/69172 */\n+/* PR tree-optimization/69172 - ICE in make_ssa_name_fn,\n+   at tree-ssanames.c:266 */\n /* { dg-do compile } */\n /* { dg-options \"-O2\" } */\n \n@@ -43,3 +44,7 @@ f6 (int x)\n {\n   return __builtin___mempcpy_chk (&a, &a, x, 0);\n }\n+\n+/* The calls above violate strict aliasing.  Eliminate the -Wrestrict\n+   warnings they trigger.\n+  { dg-prune-output \"\\\\\\[-Wrestrict]\" } */"}, {"sha": "ef0dd1b7bc5c09ddc013818ba077c4e51eab80e1", "filename": "gcc/testsuite/gcc.dg/pr79223.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79223.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79223.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr79223.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/79223 - missing -Wstringop-overflow on a memmove overflow\n    { dg-do compile }\n-   { dg-additional-options \"-O2 -Wall -std=gnu99\" }  */\n+   { dg-additional-options \"-O2 -Wall -Wno-array-bounds -std=gnu99\" }  */\n \n typedef __SIZE_TYPE__ size_t;\n "}, {"sha": "14661f5dac34a1d0247e083036f609fbb424ca98", "filename": "gcc/testsuite/gcc.dg/pr81345.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81345.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81345.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81345.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n /* PR other/81345 - -Wall resets -Wstringop-overflow to 1 from the default 2\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n char a[3];\n "}, {"sha": "0b4d9e80befefec5ef3bab066add4640d3e28be0", "filename": "gcc/testsuite/gcc.dg/range.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Frange.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Frange.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frange.h?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,57 @@\n+#ifndef RANGE_H\n+\n+/* Definitions of helper functions and macros to create expressions\n+   in a specified range.  Not all the symbols declared here are\n+   defined.  */\n+\n+#define SIZE_MAX __SIZE_MAX__\n+#define DIFF_MAX __PTRDIFF_MAX__\n+#define DIFF_MIN (-DIFF_MAX - 1)\n+\n+typedef __INT32_TYPE__   int32_t;\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+static inline ptrdiff_t signed_value (void)\n+{\n+  extern volatile ptrdiff_t signed_value_source;\n+  return signed_value_source;\n+}\n+\n+static inline size_t unsigned_value (void)\n+{\n+  extern volatile size_t unsigned_value_source;\n+  return unsigned_value_source;\n+}\n+\n+static inline ptrdiff_t signed_range (ptrdiff_t min, ptrdiff_t max)\n+{\n+  ptrdiff_t val = signed_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+static inline ptrdiff_t signed_anti_range (ptrdiff_t min, ptrdiff_t max)\n+{\n+  ptrdiff_t val = signed_value ();\n+  return min <= val && val <= max ? min == DIFF_MIN ? max + 1 : min - 1 : val;\n+}\n+\n+static inline size_t unsigned_range (size_t min, size_t max)\n+{\n+  size_t val = unsigned_value ();\n+  return val < min || max < val ? min : val;\n+}\n+\n+static inline size_t unsigned_anti_range (size_t min, size_t max)\n+{\n+  size_t val = unsigned_value ();\n+  return min <= val && val <= max ? min == 0 ? max + 1 : min - 1 : val;\n+}\n+\n+#define SR(min, max) signed_range ((min), (max))\n+#define UR(min, max) unsigned_range ((min), (max))\n+\n+#define SAR(min, max) signed_anti_range ((min), (max))\n+#define UAR(min, max) unsigned_anti_range ((min), (max))\n+\n+#endif /* RANGE_H */"}, {"sha": "11367d1ec7afbc9d0ee373bb7a489450bc86f099", "filename": "gcc/testsuite/gcc.dg/torture/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2FWsizeof-pointer-memaccess1.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -1,6 +1,6 @@\n /* Test -Wsizeof-pointer-memaccess warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" } */\n+/* { dg-options \"-Wall -Wno-array-bounds -Wno-sizeof-array-argument -Wno-stringop-overflow -Wno-stringop-truncation\" } */\n /* Test just twice, once with -O0 non-fortified, once with -O2 fortified.  */\n /* { dg-skip-if \"\" { *-*-* }  { \"*\" } { \"-O0\" \"-O2\" } } */\n /* { dg-skip-if \"\" { *-*-* }  { \"-flto\" } { \"\" } } */"}, {"sha": "1be4922fd53917aad05c08a7ddf72a1ad8fe0d92", "filename": "gcc/testsuite/gcc.target/i386/chkp-stropt-17.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-stropt-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-stropt-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fchkp-stropt-17.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile { target { ! x32 } } }\n+   { dg-require-effective-target mempcpy }\n+   { dg-options \"-O2 -Wrestrict -fcheck-pointer-bounds -mmpx\" } */\n+\n+#define USE_GNU\n+#include \"../../gcc.dg/strlenopt.h\"\n+\n+/* There is no BUILT_IN_ST{P,R}NCPY_CHKP or BUILT_IN_STRNCAT_CHKP\n+   so the test for them below are XFAIL.  */\n+char *stpncpy (char *__restrict, const char *__restrict, size_t);\n+char *strncpy (char *__restrict, const char *__restrict, size_t);\n+char *strncat (char *__restrict, const char *__restrict, size_t);\n+\n+\n+char a[8];\n+\n+void test_memcpy (void)\n+{\n+  memcpy (a, a + 1, 3);   /* { dg-warning \".memcpy\\.chkp. accessing 3 bytes at offsets 0 and 1 overlaps 2 bytes at offset 1\" } */\n+}\n+\n+void test_memmove (void)\n+{\n+  memmove (a, a + 1, 3);\n+}\n+\n+void* test_mempcpy (void)\n+{\n+  return mempcpy (a, a + 1, 3);   /* { dg-warning \".mempcpy\\.chkp. accessing 3 bytes at offsets 0 and 1 overlaps 2 bytes at offset 1\" } */\n+}\n+\n+char* test_stpcpy (void)\n+{\n+  strcpy (a, \"0123456\");\n+  return stpcpy (a, a + 2);   /* { dg-warning \".stpcpy\\.chkp. accessing 6 bytes at offsets 0 and 2 overlaps 4 bytes at offset 2\" } */\n+}\n+\n+char* test_stpncpy (void)\n+{\n+  strcpy (a, \"0123456\");\n+\n+  /* There is no BUILT_IN_STPNCPY_CHKP so this isn't handled.  */\n+  return stpncpy (a, a + 2, sizeof a);   /* { dg-warning \".stpcpy\\.chkp. accessing 7 bytes at offsets 0 and 2 overlaps 4 bytes at offset 2\" \"bug 82652\" { xfail *-*-* } } */\n+}\n+\n+void test_strcpy (void)\n+{\n+  strcpy (a, \"0123456\");\n+  strcpy (a, a + 1);   /* { dg-warning \".strcpy\\.chkp. accessing 7 bytes at offsets 0 and 1 overlaps 6 bytes at offset 1\" } */\n+}\n+\n+void test_strcat (int n)\n+{\n+  strcat (a, a + 3);   /* { dg-warning \".strcat\\.chkp. accessing 0 or more bytes at offsets 0 and 3 may overlap 1 byte\" } */\n+}\n+\n+void test_strncat (int n)\n+{\n+  strncat (a, a + 3, sizeof a);   /* { dg-warning \".strncat\\.chkp. accessing 0 or more bytes at offsets 0 and 3 may overlap 1 byte\" \"bug 82652\" { xfail *-*-* } } */\n+}\n+\n+void test_strncpy (int n)\n+{\n+  strcpy (a, \"0123456\");\n+\n+  /* There is no BUILT_IN_STRNCPY_CHKP so this isn't handled.  */\n+  strncpy (a, a + 2, sizeof a);   /* { dg-warning \".strncpy\\.chkp. accessing 7 bytes at offsets 0 and 2 overlaps 5 bytes at offset 2\" \"bug 82652\" { xfail *-*-* } } */\n+}"}, {"sha": "323f37da9465c78547d61bb944302f5e35e6fdb2", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -461,6 +461,7 @@ extern gimple_opt_pass *make_pass_build_cgraph_edges (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_local_pure_const (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_nothrow (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tracer (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_restrict (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_unused_result (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_diagnose_tm_blocks (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lower_tm (gcc::context *ctxt);"}, {"sha": "e75d13392f6e3ee48ebf4abca20faeed375cd162", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 182, "deletions": 52, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=cc8bea0aeeeeb6ed8046ede1a577ee681da2ca6a", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"cgraph.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"gimple-ssa-warn-restrict.h\"\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n #include \"gimple-fold.h\"\n@@ -173,6 +174,7 @@ struct laststmt_struct\n } laststmt;\n \n static int get_stridx_plus_constant (strinfo *, unsigned HOST_WIDE_INT, tree);\n+static void handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *);\n \n /* Return:\n \n@@ -1386,7 +1388,7 @@ static void\n handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n {\n   int idx, didx;\n-  tree src, dst, srclen, len, lhs, args, type, fn, oldlen;\n+  tree src, dst, srclen, len, lhs, type, fn, oldlen;\n   bool success;\n   gimple *stmt = gsi_stmt (*gsi);\n   strinfo *si, *dsi, *olddsi, *zsi;\n@@ -1502,6 +1504,23 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \t    }\n \t}\n       dsi->stmt = stmt;\n+\n+      /* Try to detect overlap before returning.  This catches cases\n+\t like strcpy (d, d + n) where n is non-constant whose range\n+\t is such that (n <= strlen (d) holds).\n+\n+\t OLDDSI->NONZERO_chars may have been reset by this point with\n+\t oldlen holding it original value.  */\n+      if (olddsi && oldlen)\n+\t{\n+\t  /* Add 1 for the terminating NUL.  */\n+\t  tree type = TREE_TYPE (oldlen);\n+\t  oldlen = fold_build2 (PLUS_EXPR, type, oldlen,\n+\t\t\t\tbuild_int_cst (type, 1));\n+\t  check_bounds_or_overlap (as_a <gcall *>(stmt), olddsi->ptr, src,\n+\t\t\t\t   oldlen, NULL_TREE);\n+\t}\n+\n       return;\n     }\n \n@@ -1574,14 +1593,32 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   if (zsi != NULL)\n     zsi->dont_invalidate = true;\n \n-  if (fn == NULL_TREE)\n-    return;\n-\n-  args = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  type = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+  if (fn)\n+    {\n+      tree args = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+      type = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+    }\n+  else\n+    type = size_type_node;\n \n   len = fold_convert_loc (loc, type, unshare_expr (srclen));\n   len = fold_build2_loc (loc, PLUS_EXPR, type, len, build_int_cst (type, 1));\n+\n+  /* Set the no-warning bit on the transformed statement?  */\n+  bool set_no_warning = false;\n+\n+  if (const strinfo *chksi = olddsi ? olddsi : dsi)\n+    if (si\n+\t&& !check_bounds_or_overlap (as_a <gcall *>(stmt), chksi->ptr, si->ptr,\n+\t\t\t\t     NULL_TREE, len))\n+      {\n+\tgimple_set_no_warning (stmt, true);\n+\tset_no_warning = true;\n+      }\n+\n+  if (fn == NULL_TREE)\n+    return;\n+\n   len = force_gimple_operand_gsi (gsi, len, true, NULL_TREE, true,\n \t\t\t\t  GSI_SAME_STMT);\n   if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n@@ -1629,6 +1666,21 @@ handle_builtin_strcpy (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n   else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n     fprintf (dump_file, \"not possible.\\n\");\n+\n+  if (set_no_warning)\n+    gimple_set_no_warning (stmt, true);\n+}\n+\n+/* Check the size argument to the built-in forms of stpncpy and strncpy\n+   for out-of-bounds offsets or overlapping access, and to see if the\n+   size argument is derived from a call to strlen() on the source argument,\n+   and if so, issue an appropriate warning.  */\n+\n+static void\n+handle_builtin_strncat (built_in_function bcode, gimple_stmt_iterator *gsi)\n+{\n+  /* Same as stxncpy().  */\n+  handle_builtin_stxncpy (bcode, gsi);\n }\n \n /* Return true if LEN depends on a call to strlen(SRC) in an interesting\n@@ -1909,9 +1961,10 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n   return false;\n }\n \n-/* Check the size argument to the built-in forms of stpncpy and strncpy\n-   to see if it's derived from calling strlen() on the source argument\n-   and if so, issue a warning.  */\n+/* Check the arguments to the built-in forms of stpncpy and strncpy for\n+   out-of-bounds offsets or overlapping access, and to see if the size\n+   is derived from calling strlen() on the source argument, and if so,\n+   issue the appropriate warning.  */\n \n static void\n handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n@@ -1923,8 +1976,51 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n \n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n \n+  tree dst = gimple_call_arg (stmt, with_bounds ? 1 : 0);\n   tree src = gimple_call_arg (stmt, with_bounds ? 2 : 1);\n   tree len = gimple_call_arg (stmt, with_bounds ? 3 : 2);\n+  tree dstsize = NULL_TREE, srcsize = NULL_TREE;\n+\n+  int didx = get_stridx (dst);\n+  if (strinfo *sidst = didx > 0 ? get_strinfo (didx) : NULL)\n+    {\n+      /* Compute the size of the destination string including the NUL.  */\n+      if (sidst->nonzero_chars)\n+\t{\n+\t  tree type = TREE_TYPE (sidst->nonzero_chars);\n+\t  dstsize = fold_build2 (PLUS_EXPR, type, sidst->nonzero_chars,\n+\t\t\t\t build_int_cst (type, 1));\n+\t}\n+      dst = sidst->ptr;\n+    }\n+\n+  int sidx = get_stridx (src);\n+  strinfo *sisrc = sidx > 0 ? get_strinfo (sidx) : NULL;\n+  if (sisrc)\n+    {\n+      /* strncat() and strncpy() can modify the source string by writing\n+\t over the terminating nul so SISRC->DONT_INVALIDATE must be left\n+\t clear.  */\n+\n+      /* Compute the size of the source string including the NUL.  */\n+      if (sisrc->nonzero_chars)\n+\t{\n+\t  tree type = TREE_TYPE (sisrc->nonzero_chars);\n+\t  srcsize = fold_build2 (PLUS_EXPR, type, sisrc->nonzero_chars,\n+\t\t\t\t build_int_cst (type, 1));\n+\t}\n+\n+\tsrc = sisrc->ptr;\n+    }\n+  else\n+    srcsize = NULL_TREE;\n+\n+  if (!check_bounds_or_overlap (as_a <gcall *>(stmt), dst, src,\n+\t\t\t\tdstsize, srcsize))\n+    {\n+      gimple_set_no_warning (stmt, true);\n+      return;\n+    }\n \n   /* If the length argument was computed from strlen(S) for some string\n      S retrieve the strinfo index for the string (PSS->FIRST) alonng with\n@@ -1938,13 +2034,6 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n       return;\n     }\n \n-  int sidx = get_stridx (src);\n-  strinfo *sisrc = sidx > 0 ? get_strinfo (sidx) : NULL;\n-\n-  /* strncat() and strncpy() can modify the source string by writing\n-     over the terminating nul so SISRC->DONT_INVALIDATE must be left\n-     clear.  */\n-\n   /* Retrieve the strinfo data for the string S that LEN was computed\n      from as some function F of strlen (S) (i.e., LEN need not be equal\n      to strlen(S)).  */\n@@ -1981,17 +2070,6 @@ handle_builtin_stxncpy (built_in_function, gimple_stmt_iterator *gsi)\n     }\n }\n \n-/* Check the size argument to the built-in forms of strncat to see if\n-   it's derived from calling strlen() on the source argument and if so,\n-   issue a warning.  */\n-\n-static void\n-handle_builtin_strncat (built_in_function bcode, gimple_stmt_iterator *gsi)\n-{\n-  /* Same as stxncpy().  */\n-  handle_builtin_stxncpy (bcode, gsi);\n-}\n-\n /* Handle a memcpy-like ({mem{,p}cpy,__mem{,p}cpy_chk}) call.\n    If strlen of the second argument is known and length of the third argument\n    is that plus one, strlen of the first argument is the same after this\n@@ -2172,16 +2250,22 @@ static void\n handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n {\n   int idx, didx;\n-  tree src, dst, srclen, dstlen, len, lhs, args, type, fn, objsz, endptr;\n+  tree srclen, args, type, fn, objsz, endptr;\n   bool success;\n   gimple *stmt = gsi_stmt (*gsi);\n   strinfo *si, *dsi;\n-  location_t loc;\n+  location_t loc = gimple_location (stmt);\n   bool with_bounds = gimple_call_with_bounds_p (stmt);\n \n-  src = gimple_call_arg (stmt, with_bounds ? 2 : 1);\n-  dst = gimple_call_arg (stmt, 0);\n-  lhs = gimple_call_lhs (stmt);\n+  tree src = gimple_call_arg (stmt, with_bounds ? 2 : 1);\n+  tree dst = gimple_call_arg (stmt, 0);\n+\n+  /* Bail if the source is the same as destination.  It will be diagnosed\n+     elsewhere.  */\n+  if (operand_equal_p (src, dst, 0))\n+    return;\n+\n+  tree lhs = gimple_call_lhs (stmt);\n \n   didx = get_stridx (dst);\n   if (didx < 0)\n@@ -2190,10 +2274,48 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   dsi = NULL;\n   if (didx > 0)\n     dsi = get_strinfo (didx);\n+\n+  srclen = NULL_TREE;\n+  si = NULL;\n+  idx = get_stridx (src);\n+  if (idx < 0)\n+    srclen = build_int_cst (size_type_node, ~idx);\n+  else if (idx > 0)\n+    {\n+      si = get_strinfo (idx);\n+      if (si != NULL)\n+\tsrclen = get_string_length (si);\n+    }\n+\n+  /* Set the no-warning bit on the transformed statement?  */\n+  bool set_no_warning = false;\n+\n   if (dsi == NULL || get_string_length (dsi) == NULL_TREE)\n     {\n+      {\n+\t  /* The concatenation always involves copying at least one byte\n+\t     (the terminating nul), even if the source string is empty.\n+\t     If the source is unknown assume it's one character long and\n+\t     used that as both sizes.  */\n+\ttree slen = srclen;\n+\tif (slen)\n+\t  {\n+\t    tree type = TREE_TYPE (slen);\n+\t    slen = fold_build2 (PLUS_EXPR, type, slen, build_int_cst (type, 1));\n+\t  }\n+\n+\ttree sptr = si && si->ptr ? si->ptr : src;\n+\n+\tif (!check_bounds_or_overlap (as_a <gcall *>(stmt), dst, sptr,\n+\t\t\t\t      NULL_TREE, slen))\n+\t  {\n+\t    gimple_set_no_warning (stmt, true);\n+\t    set_no_warning = true;\n+\t  }\n+      }\n+\n       /* strcat (p, q) can be transformed into\n-\t tmp = p + strlen (p); endptr = strpcpy (tmp, q);\n+\t tmp = p + strlen (p); endptr = stpcpy (tmp, q);\n \t with length endptr - p if we need to compute the length\n \t later on.  Don't do this transformation if we don't need\n \t it.  */\n@@ -2226,20 +2348,7 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n       return;\n     }\n \n-  srclen = NULL_TREE;\n-  si = NULL;\n-  idx = get_stridx (src);\n-  if (idx < 0)\n-    srclen = build_int_cst (size_type_node, ~idx);\n-  else if (idx > 0)\n-    {\n-      si = get_strinfo (idx);\n-      if (si != NULL)\n-\tsrclen = get_string_length (si);\n-    }\n-\n-  loc = gimple_location (stmt);\n-  dstlen = dsi->nonzero_chars;\n+  tree dstlen = dsi->nonzero_chars;\n   endptr = dsi->endptr;\n \n   dsi = unshare_strinfo (dsi);\n@@ -2300,7 +2409,25 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n   if (fn == NULL_TREE)\n     return;\n \n-  len = NULL_TREE;\n+  if (dsi && dstlen)\n+    {\n+      tree type = TREE_TYPE (dstlen);\n+\n+      /* Compute the size of the source sequence, including the nul.  */\n+      tree srcsize = srclen ? srclen : size_zero_node;\n+      srcsize = fold_build2 (PLUS_EXPR, type, srcsize, build_int_cst (type, 1));\n+\n+      tree sptr = si && si->ptr ? si->ptr : src;\n+\n+      if (!check_bounds_or_overlap (as_a <gcall *>(stmt), dst, sptr,\n+\t\t\t\t    dstlen, srcsize))\n+\t{\n+\t  gimple_set_no_warning (stmt, true);\n+\t  set_no_warning = true;\n+\t}\n+    }\n+\n+  tree len = NULL_TREE;\n   if (srclen != NULL_TREE)\n     {\n       args = TYPE_ARG_TYPES (TREE_TYPE (fn));\n@@ -2375,6 +2502,9 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n     }\n   else if (dump_file && (dump_flags & TDF_DETAILS) != 0)\n     fprintf (dump_file, \"not possible.\\n\");\n+\n+  if (set_no_warning)\n+    gimple_set_no_warning (stmt, true);\n }\n \n /* Handle a call to malloc or calloc.  */\n@@ -2866,11 +2996,11 @@ fold_strstr_to_strncmp (tree rhs1, tree rhs2, gimple *stmt)\n     }\n }\n \n-/* Attempt to optimize a single statement at *GSI using string length\n-   knowledge.  */\n+/* Attempt to check for validity of the performed access a single statement\n+   at *GSI using string length knowledge, and to optimize it.  */\n \n static bool\n-strlen_optimize_stmt (gimple_stmt_iterator *gsi)\n+strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -3146,7 +3276,7 @@ strlen_dom_walker::before_dom_children (basic_block bb)\n \n   /* Attempt to optimize individual statements.  */\n   for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n-    if (strlen_optimize_stmt (&gsi))\n+    if (strlen_check_and_optimize_stmt (&gsi))\n       gsi_next (&gsi);\n \n   bb->aux = stridx_to_strinfo;"}]}