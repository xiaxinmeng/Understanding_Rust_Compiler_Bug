{"sha": "b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNmNzU2NzI2MDI1N2I1OGE3N2E3YzQzYmE5ZWI0ODQwZjJhMDlkOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-05-16T11:08:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-05-16T11:08:53Z"}, "message": "* doc/gnat_rm/implementation_defined_attributes.rst\n\t(Scalar_Storage_Order): Adjust restriction for packed array types.\n\t* einfo.ads (Is_Bit_Packed_Array): Adjust description.\n\t(Is_Packed): Likewise.\n\t(Is_Packed_Array_Impl_Type): Likewise.\n\t(Packed_Array_Impl_Type): Likewise.\n\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not do anything special\n\tif the prefix is not a packed array implemented specially.\n\t* exp_ch6.adb (Expand_Actuals): Expand indexed components only for\n\tbit-packed array types.\n\t* exp_pakd.adb (Install_PAT): Set Is_Packed_Array_Impl_Type flag on\n\tthe PAT before analyzing its declaration.\n\t(Create_Packed_Array_Impl_Type): Remove redundant statements.\n\t* freeze.adb (Check_Component_Storage_Order): Reject packed array\n\tcomponents only if they are bit packed.\n\t(Freeze_Array_Type): Fix logic detecting bit packing and do not bit\n\tpack for composite types whose size is multiple of a byte.\n\tCreate the implementation type for packed array types only when it is\n\tneeded, i.e. bit packing or packing because of holes in index types.\n\tMake sure the Has_Non_Standard_Rep and Is_Packed flags agree.\n\t* gcc-interface/gigi.h (make_packable_type): Add MAX_ALIGN parameter.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tCall maybe_pad_type instead of building the padding type manually.\n\t(gnat_to_gnu_entity) <E_Array_Subtype>: Do not assert that\n\tPacked_Array_Impl_Type is present for packed arrays.\n\t(gnat_to_gnu_component_type): Also handle known alignment for packed\n\ttypes by passing it to make_packable_type.\n\t* gcc-interface/utils.c (make_packable_type): Add MAX_ALIGN parameter\n\tand deal with it in the array case.  Adjust recursive call.  Simplify\n\tcomputation of new size and cap the alignment to BIGGEST_ALIGNMENT.\n\nFrom-SVN: r236279", "tree": {"sha": "d15a8ba1c8aa9a9098735e4c0df5928335dae9d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d15a8ba1c8aa9a9098735e4c0df5928335dae9d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/comments", "author": null, "committer": null, "parents": [{"sha": "3362d76470c5b397b53a699130406f422b83bba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3362d76470c5b397b53a699130406f422b83bba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3362d76470c5b397b53a699130406f422b83bba7"}], "stats": {"total": 365, "additions": 191, "deletions": 174}, "files": [{"sha": "2f5620f2d07919c1d9d56d4d0722531fbedc831e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -1,3 +1,36 @@\n+2016-05-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_attributes.rst\n+\t(Scalar_Storage_Order): Adjust restriction for packed array types.\n+\t* einfo.ads (Is_Bit_Packed_Array): Adjust description.\n+\t(Is_Packed): Likewise.\n+\t(Is_Packed_Array_Impl_Type): Likewise.\n+\t(Packed_Array_Impl_Type): Likewise.\n+\t* exp_ch4.adb (Expand_N_Indexed_Component): Do not do anything special\n+\tif the prefix is not a packed array implemented specially.\n+\t* exp_ch6.adb (Expand_Actuals): Expand indexed components only for\n+\tbit-packed array types.\n+\t* exp_pakd.adb (Install_PAT): Set Is_Packed_Array_Impl_Type flag on\n+\tthe PAT before analyzing its declaration.\n+\t(Create_Packed_Array_Impl_Type): Remove redundant statements.\n+\t* freeze.adb (Check_Component_Storage_Order): Reject packed array\n+\tcomponents only if they are bit packed.\n+\t(Freeze_Array_Type): Fix logic detecting bit packing and do not bit\n+\tpack for composite types whose size is multiple of a byte.\n+\tCreate the implementation type for packed array types only when it is\n+\tneeded, i.e. bit packing or packing because of holes in index types.\n+\tMake sure the Has_Non_Standard_Rep and Is_Packed flags agree.\n+\t* gcc-interface/gigi.h (make_packable_type): Add MAX_ALIGN parameter.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tCall maybe_pad_type instead of building the padding type manually.\n+\t(gnat_to_gnu_entity) <E_Array_Subtype>: Do not assert that\n+\tPacked_Array_Impl_Type is present for packed arrays.\n+\t(gnat_to_gnu_component_type): Also handle known alignment for packed\n+\ttypes by passing it to make_packable_type.\n+\t* gcc-interface/utils.c (make_packable_type): Add MAX_ALIGN parameter\n+\tand deal with it in the array case.  Adjust recursive call.  Simplify\n+\tcomputation of new size and cap the alignment to BIGGEST_ALIGNMENT.\n+\n 2016-05-16  Thomas Quinot  <quinot@adacore.com>\n \n \t* freeze.adb (Check_Component_Storage_Order): Also get full view of"}, {"sha": "958ab2413f74df4eb716e975546603b3e2297ab9", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -969,7 +969,7 @@ must have the same scalar storage order as the parent type.\n If a component of `T` is of a record or array type, then that type must\n also have a `Scalar_Storage_Order` attribute definition clause.\n \n-A component of a record or array type that is a packed array, or that\n+A component of a record or array type that is a bit-packed array, or that\n does not start on a byte boundary, must have the same scalar storage order\n as the enclosing record or array type.\n "}, {"sha": "69492fc174837ca4fd26c1feaf678ccf4e070675", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -2268,9 +2268,9 @@ package Einfo is\n --       is bit packed (i.e. the component size is known by the front end and\n --       is in the range 1-7, 9-15, 17-31, or 33-63). Is_Packed is always set\n --       if Is_Bit_Packed_Array is set, but it is possible for Is_Packed to be\n---       set without Is_Bit_Packed_Array for the case of an array having one or\n---       more index types that are enumeration types with non-standard\n---       enumeration representations.\n+--       set without Is_Bit_Packed_Array if the component size is not known by\n+--       the front-end or for the case of an array having one or more index\n+--       types that are enumeration types with non-standard representation.\n \n --    Is_Boolean_Type (synthesized)\n --       Applies to all entities, true for boolean types and subtypes,\n@@ -2852,49 +2852,49 @@ package Einfo is\n \n --    Is_Packed (Flag51) [implementation base type only]\n --       Defined in all type entities. This flag is set only for record and\n---       array types which have a packed representation. There are three\n---       cases which cause packing:\n+--       array types which have a packed representation. There are four cases\n+--       which cause packing:\n --\n---         1. Explicit use of pragma Pack for an array of package components\n---         2. Explicit use of pragma Pack to pack a record\n---         4. Setting Component_Size of an array to a bit-packable value\n---         3. Indexing an array with a non-standard enumeration type.\n+--         1. Explicit use of pragma Pack to pack a record.\n+--         2. Explicit use of pragma Pack to pack an array.\n+--         3. Setting Component_Size of an array to a packable value.\n+--         4. Indexing an array with a non-standard enumeration type.\n --\n---       For records, Is_Packed is always set if Has_Pragma_Pack is set,\n---       and can also be set on its own in a derived type which inherited\n---       its packed status.\n---\n---       For arrays, Is_Packed is set if an array is bit packed (i.e. the\n---       component size is known at compile time and is 1-7, 9-15 or 17-31),\n---       or if the array has one or more index types that are enumeration\n---       types with non-standard representations (in GNAT, we store such\n---       arrays compactly, using the Pos of the enumeration type value).\n---\n---       As for the case of records, Is_Packed can be set on its own for a\n---       derived type, with the same dual before/after freeze meaning.\n---       Is_Packed can also be set as the result of an explicit component\n---       size clause that specifies an appropriate component size.\n---\n---       In the bit packed array case, Is_Bit_Packed_Array will be set in\n---       the bit packed case once the array type is frozen.\n+--       For records, Is_Packed is always set if Has_Pragma_Pack is set, and\n+--       can also be set on its own in a derived type which inherited its\n+--       packed status.\n --\n+--       For arrays, Is_Packed is set if either Has_Pragma_Pack is set and the\n+--       component size is either not known at compile time or known but not\n+--       8/16/32/64 bits, or a Component_Size clause exists and the specified\n+--       value is smaller than 64 bits but not 8/16/32, or if the array has one\n+--       or more index types that are enumeration types with a non-standard\n+--       representation (in GNAT, we store such arrays compactly, using the Pos\n+--       of the enumeration type value). As for the case of records, Is_Packed\n+--       can be set on its own for a derived type.\n+\n --       Before an array type is frozen, Is_Packed will always be set if\n --       Has_Pragma_Pack is set. Before the freeze point, it is not possible\n --       to know the component size, since the component type is not frozen\n --       until the array type is frozen. Thus Is_Packed for an array type\n --       before it is frozen means that packed is required. Then if it turns\n---       out that the component size is not suitable for bit packing, the\n---       Is_Packed flag gets turned off.\n+--       out that the component size doesn't require packing, the Is_Packed\n+--       flag gets turned off.\n \n+--       In the bit packed array case (i.e. component size is known at compile\n+--       time and is 1-7, 9-15, 17-31 or 33-63), Is_Bit_Packed_Array will be\n+--       set once the array type is frozen.\n+--\n --    Is_Packed_Array (synth)\n --       Applies to all entities, true if entity is for a packed array.\n \n --    Is_Packed_Array_Impl_Type (Flag138)\n --       Defined in all entities. This flag is set on the entity for the type\n---       used to implement a packed array (either a modular type, or a subtype\n---       of Packed_Bytes{1,2,4} as appropriate). The flag is set if and only\n+--       used to implement a packed array (either a modular type or a subtype\n+--       of Packed_Bytes{1,2,4} in the bit packed array case, a regular array\n+--       in the non-standard enumeration index case). It is set if and only\n --       if the type appears in the Packed_Array_Impl_Type field of some other\n---       entity. It is used by the backend to activate the special processing\n+--       entity. It is used by the back end to activate the special processing\n --       for such types (unchecked conversions that would not otherwise be\n --       allowed are allowed for such types). If Is_Packed_Array_Impl_Type is\n --       set in an entity, then the Original_Array_Type field of this entity\n@@ -3698,16 +3698,17 @@ package Einfo is\n --       with formal packages. ???\n \n --    Packed_Array_Impl_Type (Node23)\n---       Defined in array types and subtypes, including the string literal\n---       subtype case, if the corresponding type is packed (either bit packed\n---       or packed to eliminate holes in non-contiguous enumeration type index\n---       types). References the type used to represent the packed array, which\n---       is either a modular type for short static arrays, or an array of\n---       System.Unsigned. Note that in some situations (internal types, and\n---       references to fields of variant records), it is not always possible\n---       to construct this type in advance of its use. If this field is empty,\n---       then the necessary type is declared on the fly for each reference to\n---       the array.\n+--       Defined in array types and subtypes, except for the string literal\n+--       subtype case, if the corresponding type is packed and implemented\n+--       specially (either bit packed or packed to eliminate holes in the\n+--       non-contiguous enumeration index types). References the type used to\n+--       represent the packed array, which is either a modular type for short\n+--       static arrays or an array of System.Unsigned in the bit packed case,\n+--       or a regular array in the non-standard enumeration index case). Note\n+--       that in some situations (internal types and references to fields of\n+--       variant records), it is not always possible to construct this type in\n+--       advance of its use. If this field is empty, then the necessary type\n+--       is declared on the fly for each reference to the array.\n \n --    Parameter_Mode (synthesized)\n --       Applies to formal parameter entities. This is a synonym for Ekind,"}, {"sha": "e6ea474eec1f94d3627d5d321d8a539ecd99fca1", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -6216,9 +6216,11 @@ package body Exp_Ch4 is\n          Activate_Atomic_Synchronization (N);\n       end if;\n \n-      --  All done for the non-packed case\n+      --  All done if the prefix is not a packed array implemented specially\n \n-      if not Is_Packed (Etype (Prefix (N))) then\n+      if not (Is_Packed (Etype (Prefix (N)))\n+               and then Present (Packed_Array_Impl_Type (Etype (Prefix (N)))))\n+      then\n          return;\n       end if;\n "}, {"sha": "9f7c1dc01c6d7a71a4d8b0e5843c7ac292f7b151", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -2038,7 +2038,7 @@ package body Exp_Ch6 is\n          --  Processing for IN parameters\n \n          else\n-            --  For IN parameters is in the packed array case, we expand an\n+            --  For IN parameters in the bit packed array case, we expand an\n             --  indexed component (the circuit in Exp_Ch4 deliberately left\n             --  indexed components appearing as actuals untouched, so that\n             --  the special processing above for the OUT and IN OUT cases\n@@ -2047,7 +2047,7 @@ package body Exp_Ch6 is\n             --  easier simply to handle all cases here.)\n \n             if Nkind (Actual) = N_Indexed_Component\n-              and then Is_Packed (Etype (Prefix (Actual)))\n+              and then Is_Bit_Packed_Array (Etype (Prefix (Actual)))\n             then\n                Reset_Packed_Prefix;\n                Expand_Packed_Element_Reference (Actual);"}, {"sha": "0ec3ef4481409b9d9cc494623fe61e3d551dda5c", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -543,6 +543,7 @@ package body Exp_Pakd is\n          end if;\n \n          Set_Is_Itype (PAT, True);\n+         Set_Is_Packed_Array_Impl_Type (PAT, True);\n          Set_Packed_Array_Impl_Type (Typ, PAT);\n          Analyze (Decl, Suppress => All_Checks);\n \n@@ -569,7 +570,6 @@ package body Exp_Pakd is\n          Init_Alignment                (PAT);\n          Set_Parent                    (PAT, Empty);\n          Set_Associated_Node_For_Itype (PAT, Typ);\n-         Set_Is_Packed_Array_Impl_Type (PAT, True);\n          Set_Original_Array_Type       (PAT, Typ);\n \n          --  Propagate representation aspects\n@@ -701,8 +701,6 @@ package body Exp_Pakd is\n            Make_Defining_Identifier (Loc,\n              Chars => New_External_Name (Chars (Typ), 'P'));\n \n-         Set_Packed_Array_Impl_Type (Typ, PAT);\n-\n          declare\n             Indexes   : constant List_Id := New_List;\n             Indx      : Node_Id;\n@@ -798,9 +796,6 @@ package body Exp_Pakd is\n                 Type_Definition     => Typedef);\n          end;\n \n-         --  Set type as packed array type and install it\n-\n-         Set_Is_Packed_Array_Impl_Type (PAT);\n          Install_PAT;\n          return;\n \n@@ -819,13 +814,13 @@ package body Exp_Pakd is\n            Make_Defining_Identifier (Loc,\n              Chars => Make_Packed_Array_Impl_Type_Name (Typ, Csize));\n \n-         Set_Packed_Array_Impl_Type (Typ, PAT);\n          Set_PB_Type;\n \n          Decl :=\n            Make_Subtype_Declaration (Loc,\n              Defining_Identifier => PAT,\n                Subtype_Indication => New_Occurrence_Of (PB_Type, Loc));\n+\n          Install_PAT;\n          return;\n \n@@ -843,8 +838,6 @@ package body Exp_Pakd is\n            Make_Defining_Identifier (Loc,\n              Chars => Make_Packed_Array_Impl_Type_Name (Typ, Csize));\n \n-         Set_Packed_Array_Impl_Type (Typ, PAT);\n-\n          --  Build an expression for the length of the array in bits.\n          --  This is the product of the length of each of the dimensions\n "}, {"sha": "8b74f86addd0676a5b7a4cb093dc1ce113f77cdc", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -1254,24 +1254,24 @@ package body Freeze is\n             end if;\n \n          --  If component and composite SSO differs, check that component\n-         --  falls on byte boundaries and isn't packed.\n+         --  falls on byte boundaries and isn't bit packed.\n \n          elsif Comp_SSO_Differs then\n \n             --  Component SSO differs from enclosing composite:\n \n-            --  Reject if component is a packed array, as it may be represented\n+            --  Reject if component is a bit-packed array, as it is represented\n             --  as a scalar internally.\n \n-            if Is_Packed_Array (Comp_Base) then\n+            if Is_Bit_Packed_Array (Comp_Base) then\n                Error_Msg_N\n                  (\"type of packed component must have same scalar storage \"\n                   & \"order as enclosing composite\", Err_Node);\n \n-            --  Reject if composite is a packed array, as it may be rewritten\n+            --  Reject if composite is a bit-packed array, as it is rewritten\n             --  into an array of scalars.\n \n-            elsif Is_Packed_Array (Encl_Base) then\n+            elsif Is_Bit_Packed_Array (Encl_Base) then\n                Error_Msg_N\n                  (\"type of packed array must have same scalar storage order \"\n                   & \"as component\", Err_Node);\n@@ -2386,7 +2386,7 @@ package body Freeze is\n                   end if;\n                end if;\n \n-               --  Case of component size that may result in packing\n+               --  Case of component size that may result in bit packing\n \n                if 1 <= Csiz and then Csiz <= 64 then\n                   declare\n@@ -2451,44 +2451,58 @@ package body Freeze is\n                         end if;\n                      end if;\n \n-                     --  Actual packing is not needed for 8, 16, 32, 64. Also\n-                     --  not needed for multiples of 8 if alignment is 1, and\n-                     --  for multiples of 16 (i.e. only 48) if alignment is 2.\n+                     --  Bit packing is never needed for 8, 16, 32, 64\n \n                      if        Csiz = 8\n                        or else Csiz = 16\n                        or else Csiz = 32\n                        or else Csiz = 64\n-                       or else (Csiz mod 8 = 0 and then Alignment (Ctyp) = 1)\n-                       or else (Csiz = 48 and then Alignment (Ctyp) = 2)\n                      then\n-                        --  Here the array was requested to be packed, but\n-                        --  the packing request had no effect, so Is_Packed\n-                        --  is reset.\n-\n-                        --  Note: semantically this means that we lose track\n-                        --  of the fact that a derived type inherited a pragma\n-                        --  Pack that was non- effective, but that seems fine.\n-\n-                        --  We regard a Pack pragma as a request to set a\n-                        --  representation characteristic, and this request\n-                        --  may be ignored.\n-\n-                        Set_Is_Packed           (Base_Type (Arr), False);\n-                        Set_Is_Bit_Packed_Array (Base_Type (Arr), False);\n+                        --  If the Esize of the component is known and equal to\n+                        --  the component size then even packing is not needed.\n \n                         if Known_Static_Esize (Component_Type (Arr))\n                           and then Esize (Component_Type (Arr)) = Csiz\n                         then\n+                           --  Here the array was requested to be packed, but\n+                           --  the packing request had no effect whatsoever,\n+                           --  so flag Is_Packed is reset.\n+\n+                           --  Note: semantically this means that we lose track\n+                           --  of the fact that a derived type inherited pragma\n+                           --  Pack that was non-effective, but that is fine.\n+\n+                           --  We regard a Pack pragma as a request to set a\n+                           --  representation characteristic, and this request\n+                           --  may be ignored.\n+\n+                           Set_Is_Packed            (Base_Type (Arr), False);\n                            Set_Has_Non_Standard_Rep (Base_Type (Arr), False);\n+                        else\n+                           Set_Is_Packed            (Base_Type (Arr), True);\n+                           Set_Has_Non_Standard_Rep (Base_Type (Arr), True);\n                         end if;\n \n-                        --  In all other cases, packing is indeed needed\n+                        Set_Is_Bit_Packed_Array (Base_Type (Arr), False);\n+\n+                     --  Bit packing is not needed for multiples of the storage\n+                     --  unit if the type is composite because the back end can\n+                     --  byte pack composite types.\n+\n+                     elsif Csiz mod System_Storage_Unit = 0\n+                       and then Is_Composite_Type (Ctyp)\n+                     then\n+\n+                        Set_Is_Packed            (Base_Type (Arr), True);\n+                        Set_Has_Non_Standard_Rep (Base_Type (Arr), True);\n+                        Set_Is_Bit_Packed_Array  (Base_Type (Arr), False);\n+\n+                     --  In all other cases, bit packing is needed\n \n                      else\n+                        Set_Is_Packed            (Base_Type (Arr), True);\n                         Set_Has_Non_Standard_Rep (Base_Type (Arr), True);\n                         Set_Is_Bit_Packed_Array  (Base_Type (Arr), True);\n-                        Set_Is_Packed            (Base_Type (Arr), True);\n                      end if;\n                   end;\n                end if;\n@@ -2780,12 +2794,14 @@ package body Freeze is\n \n          Set_Component_Alignment_If_Not_Set (Arr);\n \n-         --  If the array is packed, we must create the packed array type to be\n-         --  used to actually implement the type. This is only needed for real\n-         --  array types (not for string literal types, since they are present\n-         --  only for the front end).\n+         --  If the array is packed and bit packed or packed to eliminate holes\n+         --  in the non-contiguous enumeration index types, we must create the\n+         --  packed array type to be used to actually implement the type. This\n+         --  is only needed for real array types (not for string literal types,\n+         --  since they are present only for the front end).\n \n          if Is_Packed (Arr)\n+           and then (Is_Bit_Packed_Array (Arr) or else Non_Standard_Enum)\n            and then Ekind (Arr) /= E_String_Literal_Subtype\n          then\n             Create_Packed_Array_Impl_Type (Arr);"}, {"sha": "8f2be234f8a993ff86f6f24dd14a8ac2f7b22faf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -1961,47 +1961,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n       /* If the type we are dealing with has got a smaller alignment than the\n \t natural one, we need to wrap it up in a record type and misalign the\n-\t latter; we reuse the padding machinery for this purpose.  Note that,\n-\t even if the record type is marked as packed because of misalignment,\n-\t we don't pack the field so as to give it the size of the type.  */\n+\t latter; we reuse the padding machinery for this purpose.  */\n       else if (align > 0)\n \t{\n-\t  tree gnu_field_type, gnu_field;\n-\n-\t  /* Set the RM size before wrapping up the type.  */\n-\t  SET_TYPE_RM_SIZE (gnu_type,\n-\t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n+\t  tree gnu_size = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n \n-\t  /* Create a stripped-down declaration, mainly for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n-\t\t\t    gnat_entity);\n+\t  /* Set the RM size before wrapping the type.  */\n+\t  SET_TYPE_RM_SIZE (gnu_type, gnu_size);\n \n-\t  /* Now save it and build the enclosing record type.  */\n-\t  gnu_field_type = gnu_type;\n+\t  gnu_type\n+\t    = maybe_pad_type (gnu_type, TYPE_SIZE (gnu_type), align,\n+\t\t\t      gnat_entity, false, true, definition, false);\n \n-\t  gnu_type = make_node (RECORD_TYPE);\n-\t  TYPE_PADDING_P (gnu_type) = 1;\n-\t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"PAD\");\n \t  TYPE_PACKED (gnu_type) = 1;\n-\t  TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_field_type);\n-\t  TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_field_type);\n-\t  SET_TYPE_ADA_SIZE (gnu_type, TYPE_RM_SIZE (gnu_field_type));\n-\t  SET_TYPE_ALIGN (gnu_type, align);\n-\t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n-\n-\t  /* Don't declare the field as addressable since we won't be taking\n-\t     its address and this would prevent create_field_decl from making\n-\t     a bitfield.  */\n-\t  gnu_field\n-\t    = create_field_decl (get_identifier (\"F\"), gnu_field_type,\n-\t\t\t\t gnu_type, TYPE_SIZE (gnu_field_type),\n-\t\t\t\t bitsize_zero_node, 0, 0);\n-\n-\t  finish_record_type (gnu_type, gnu_field, 2, false);\n-\t  compute_record_mode (gnu_type);\n-\n-\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    SET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n+\t  SET_TYPE_ADA_SIZE (gnu_type, gnu_size);\n \t}\n \n       break;\n@@ -2909,10 +2882,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    TREE_TYPE (TYPE_FIELDS (gnu_type)) = gnu_inner;\n \t\t}\n \t    }\n-\n-\t  else\n-\t    /* Abort if packed array with no Packed_Array_Impl_Type.  */\n-\t    gcc_assert (!Is_Packed (gnat_entity));\n \t}\n       break;\n \n@@ -5234,6 +5203,16 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   const Entity_Id gnat_type = Component_Type (gnat_array);\n   tree gnu_type = gnat_to_gnu_type (gnat_type);\n   tree gnu_comp_size;\n+  unsigned int max_align;\n+\n+  /* If an alignment is specified, use it as a cap on the component type\n+     so that it can be honored for the whole type.  But ignore it for the\n+     original type of packed array types.  */\n+  if (No (Packed_Array_Impl_Type (gnat_array))\n+      && Known_Alignment (gnat_array))\n+    max_align = validate_alignment (Alignment (gnat_array), gnat_array, 0);\n+  else\n+    max_align = 0;\n \n   /* Try to get a smaller form of the component if needed.  */\n   if ((Is_Packed (gnat_array) || Has_Component_Size_Clause (gnat_array))\n@@ -5243,7 +5222,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n       && RECORD_OR_UNION_TYPE_P (gnu_type)\n       && !TYPE_FAT_POINTER_P (gnu_type)\n       && tree_fits_uhwi_p (TYPE_SIZE (gnu_type)))\n-    gnu_type = make_packable_type (gnu_type, false);\n+    gnu_type = make_packable_type (gnu_type, false, max_align);\n \n   if (Has_Atomic_Components (gnat_array))\n     check_ok_for_atomic_type (gnu_type, gnat_array, true);\n@@ -5276,16 +5255,6 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))\n     {\n       tree orig_type = gnu_type;\n-      unsigned int max_align;\n-\n-      /* If an alignment is specified, use it as a cap on the component type\n-\t so that it can be honored for the whole type.  But ignore it for the\n-\t original type of packed array types.  */\n-      if (No (Packed_Array_Impl_Type (gnat_array))\n-\t  && Known_Alignment (gnat_array))\n-\tmax_align = validate_alignment (Alignment (gnat_array), gnat_array, 0);\n-      else\n-\tmax_align = 0;\n \n       gnu_type = make_type_from_size (gnu_type, gnu_comp_size, false);\n       if (max_align > 0 && TYPE_ALIGN (gnu_type) > max_align)"}, {"sha": "099923d97fb515f90759d7631781c28fb48f2f71", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -129,9 +129,11 @@ extern tree make_aligning_type (tree type, unsigned int align, tree size,\n    as the field type of a packed record if IN_RECORD is true, or as the\n    component type of a packed array if IN_RECORD is false.  See if we can\n    rewrite it either as a type that has a non-BLKmode, which we can pack\n-   tighter in the packed record case, or as a smaller type.  If so, return\n-   the new type.  If not, return the original type.  */\n-extern tree make_packable_type (tree type, bool in_record);\n+   tighter in the packed record case, or as a smaller type with at most\n+   MAX_ALIGN alignment if the value is non-zero.  If so, return the new\n+   type; if not, return the original type.  */\n+extern tree make_packable_type (tree type, bool in_record,\n+\t\t\t\tunsigned int max_align = 0);\n \n /* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n    If TYPE is the best type, return it.  Otherwise, make a new type.  We"}, {"sha": "74940655c68ca5396ea4e85d1d4f259c275d46aa", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f7567260257b58a77a7c43ba9eb4840f2a09d8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b3f7567260257b58a77a7c43ba9eb4840f2a09d8", "patch": "@@ -937,23 +937,24 @@ make_aligning_type (tree type, unsigned int align, tree size,\n /* TYPE is a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE that is being used\n    as the field type of a packed record if IN_RECORD is true, or as the\n    component type of a packed array if IN_RECORD is false.  See if we can\n-   rewrite it either as a type that has a non-BLKmode, which we can pack\n-   tighter in the packed record case, or as a smaller type.  If so, return\n-   the new type.  If not, return the original type.  */\n+   rewrite it either as a type that has non-BLKmode, which we can pack\n+   tighter in the packed record case, or as a smaller type with at most\n+   MAX_ALIGN alignment if the value is non-zero.  If so, return the new\n+   type; if not, return the original type.  */\n \n tree\n-make_packable_type (tree type, bool in_record)\n+make_packable_type (tree type, bool in_record, unsigned int max_align)\n {\n   unsigned HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE (type));\n   unsigned HOST_WIDE_INT new_size;\n-  tree new_type, old_field, field_list = NULL_TREE;\n-  unsigned int align;\n+  unsigned int align = TYPE_ALIGN (type);\n+  unsigned int new_align;\n \n   /* No point in doing anything if the size is zero.  */\n   if (size == 0)\n     return type;\n \n-  new_type = make_node (TREE_CODE (type));\n+  tree new_type = make_node (TREE_CODE (type));\n \n   /* Copy the name and flags from the old type to that of the new.\n      Note that we rely on the pointer equality created here for\n@@ -970,74 +971,75 @@ make_packable_type (tree type, bool in_record)\n      type with BLKmode.  */\n   if (in_record && size <= MAX_FIXED_MODE_SIZE)\n     {\n-      align = ceil_pow2 (size);\n-      SET_TYPE_ALIGN (new_type, align);\n-      new_size = (size + align - 1) & -align;\n+      new_size = ceil_pow2 (size);\n+      new_align = MIN (new_size, BIGGEST_ALIGNMENT);\n+      SET_TYPE_ALIGN (new_type, new_align);\n     }\n   else\n     {\n-      unsigned HOST_WIDE_INT align;\n-\n       /* Do not try to shrink the size if the RM size is not constant.  */\n       if (TYPE_CONTAINS_TEMPLATE_P (type)\n \t  || !tree_fits_uhwi_p (TYPE_ADA_SIZE (type)))\n \treturn type;\n \n       /* Round the RM size up to a unit boundary to get the minimal size\n-\t for a BLKmode record.  Give up if it's already the size.  */\n+\t for a BLKmode record.  Give up if it's already the size and we\n+\t don't need to lower the alignment.  */\n       new_size = tree_to_uhwi (TYPE_ADA_SIZE (type));\n       new_size = (new_size + BITS_PER_UNIT - 1) & -BITS_PER_UNIT;\n-      if (new_size == size)\n+      if (new_size == size && (max_align == 0 || align <= max_align))\n \treturn type;\n \n-      align = new_size & -new_size;\n-      SET_TYPE_ALIGN (new_type, MIN (TYPE_ALIGN (type), align));\n+      new_align = MIN (new_size & -new_size, BIGGEST_ALIGNMENT);\n+      if (max_align > 0 && new_align > max_align)\n+\tnew_align = max_align;\n+      SET_TYPE_ALIGN (new_type, MIN (align, new_align));\n     }\n \n   TYPE_USER_ALIGN (new_type) = 1;\n \n   /* Now copy the fields, keeping the position and size as we don't want\n      to change the layout by propagating the packedness downwards.  */\n-  for (old_field = TYPE_FIELDS (type); old_field;\n-       old_field = DECL_CHAIN (old_field))\n+  tree new_field_list = NULL_TREE;\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n     {\n-      tree new_field_type = TREE_TYPE (old_field);\n+      tree new_field_type = TREE_TYPE (field);\n       tree new_field, new_size;\n \n       if (RECORD_OR_UNION_TYPE_P (new_field_type)\n \t  && !TYPE_FAT_POINTER_P (new_field_type)\n \t  && tree_fits_uhwi_p (TYPE_SIZE (new_field_type)))\n-\tnew_field_type = make_packable_type (new_field_type, true);\n+\tnew_field_type = make_packable_type (new_field_type, true, max_align);\n \n       /* However, for the last field in a not already packed record type\n \t that is of an aggregate type, we need to use the RM size in the\n \t packable version of the record type, see finish_record_type.  */\n-      if (!DECL_CHAIN (old_field)\n+      if (!DECL_CHAIN (field)\n \t  && !TYPE_PACKED (type)\n \t  && RECORD_OR_UNION_TYPE_P (new_field_type)\n \t  && !TYPE_FAT_POINTER_P (new_field_type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (new_field_type)\n \t  && TYPE_ADA_SIZE (new_field_type))\n \tnew_size = TYPE_ADA_SIZE (new_field_type);\n       else\n-\tnew_size = DECL_SIZE (old_field);\n+\tnew_size = DECL_SIZE (field);\n \n       new_field\n-\t= create_field_decl (DECL_NAME (old_field), new_field_type, new_type,\n-\t\t\t     new_size, bit_position (old_field),\n+\t= create_field_decl (DECL_NAME (field), new_field_type, new_type,\n+\t\t\t     new_size, bit_position (field),\n \t\t\t     TYPE_PACKED (type),\n-\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n+\t\t\t     !DECL_NONADDRESSABLE_P (field));\n \n-      DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n-      SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n+      DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (field);\n+      SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, field);\n       if (TREE_CODE (new_type) == QUAL_UNION_TYPE)\n-\tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (old_field);\n+\tDECL_QUALIFIER (new_field) = DECL_QUALIFIER (field);\n \n-      DECL_CHAIN (new_field) = field_list;\n-      field_list = new_field;\n+      DECL_CHAIN (new_field) = new_field_list;\n+      new_field_list = new_field;\n     }\n \n-  finish_record_type (new_type, nreverse (field_list), 2, false);\n+  finish_record_type (new_type, nreverse (new_field_list), 2, false);\n   relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n   if (TYPE_STUB_DECL (type))\n     SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n@@ -1054,8 +1056,7 @@ make_packable_type (tree type, bool in_record)\n   else\n     {\n       TYPE_SIZE (new_type) = bitsize_int (new_size);\n-      TYPE_SIZE_UNIT (new_type)\n-\t= size_int ((new_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+      TYPE_SIZE_UNIT (new_type) = size_int (new_size / BITS_PER_UNIT);\n     }\n \n   if (!TYPE_CONTAINS_TEMPLATE_P (type))\n@@ -1069,8 +1070,8 @@ make_packable_type (tree type, bool in_record)\n     SET_TYPE_MODE (new_type,\n \t\t   mode_for_size_tree (TYPE_SIZE (new_type), MODE_INT, 1));\n \n-  /* If neither the mode nor the size has shrunk, return the old type.  */\n-  if (TYPE_MODE (new_type) == BLKmode && new_size >= size)\n+  /* If neither mode nor size nor alignment shrunk, return the old type.  */\n+  if (TYPE_MODE (new_type) == BLKmode && new_size >= size && max_align == 0)\n     return type;\n \n   return new_type;"}]}