{"sha": "50a0b056d2d003872d0421710bfd3343fe5e3363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhMGIwNTZkMmQwMDM4NzJkMDQyMTcxMGJmZDMzNDNmZTVlMzM2Mw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-05-21T18:38:25Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-05-21T18:38:25Z"}, "message": "rs6000.md (maxsf3): Use rs6000_emit_minmax.\n\n\t* config/rs6000/rs6000.md (maxsf3): Use rs6000_emit_minmax.\n\t(maxsf3+1): Delete.\n\t(minsf3): Use rs6000_emit_minmax.\n\t(minsf3+1): Generalize to handle both SMIN and SMAX.  Use\n\trs6000_emit_minmax.\n\t(movsfcc): Use rs6000_emit_cmove.\n\t(fselsfsf4): Don't compare a CONST_INT with a floating-point value.\n\tDon't generate emit_fselsfsf4.\n\t(fseldfsf4): Likewise.\n\t(maxdf3): Use rs6000_emit_minmax.\n\t(maxdf3+1): Delete.\n\t(mindf3): Use rs6000_emit_minmax.\n\t(mindf3+1): Generalize to handle both SMIN and SMAX.  Use\n\trs6000_emit_minmax.\n\t(movdfcc): Use rs6000_emit_cmove.\n\t(fseldfdf4): Don't compare a CONST_INT with a floating-point value.\n\tDon't generate emit_fselsfsf4.\n\t(fselsfdf4): Likewise.\n\t* config/rs6000/rs6000.c (zero_fp_constant): New predicate.\n\t(min_max_operator): New predicate.\n\t(rs6000_emit_cmove): New function.\n\t(rs6000_emit_minmax): New function.\n\t* config/rs6000/rs6000-protos.h: Prototype new functions.\n\t* config/rs6000/rs6000.h (PREDICATE_CODES): Add zero_fp_constant\n\tand min_max_operator.\n\n\t* config/rs6000/rs6000.c (output_cbranch): Handle all\n\tconditional types in the switch statement.\n\nFrom-SVN: r42404", "tree": {"sha": "667dbd661b4a10753314fb19f89f5ebbdf5dd998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/667dbd661b4a10753314fb19f89f5ebbdf5dd998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50a0b056d2d003872d0421710bfd3343fe5e3363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a0b056d2d003872d0421710bfd3343fe5e3363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50a0b056d2d003872d0421710bfd3343fe5e3363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a0b056d2d003872d0421710bfd3343fe5e3363/comments", "author": null, "committer": null, "parents": [{"sha": "0adc3c19711068a5fc3a1f97e7e77cac98606ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0adc3c19711068a5fc3a1f97e7e77cac98606ac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0adc3c19711068a5fc3a1f97e7e77cac98606ac4"}], "stats": {"total": 502, "additions": 297, "deletions": 205}, "files": [{"sha": "8b5df1ce49c892481ca21b0cc68a92a3c970408e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50a0b056d2d003872d0421710bfd3343fe5e3363", "patch": "@@ -1,3 +1,34 @@\n+2001-05-21  Geoff Keating  <geoffk@redhat.com>\n+\n+\t* config/rs6000/rs6000.md (maxsf3): Use rs6000_emit_minmax.\n+\t(maxsf3+1): Delete.\n+\t(minsf3): Use rs6000_emit_minmax.\n+\t(minsf3+1): Generalize to handle both SMIN and SMAX.  Use\n+\trs6000_emit_minmax.\n+\t(movsfcc): Use rs6000_emit_cmove.\n+\t(fselsfsf4): Don't compare a CONST_INT with a floating-point value.\n+\tDon't generate emit_fselsfsf4.\n+\t(fseldfsf4): Likewise.\n+\t(maxdf3): Use rs6000_emit_minmax.\n+\t(maxdf3+1): Delete.\n+\t(mindf3): Use rs6000_emit_minmax.\n+\t(mindf3+1): Generalize to handle both SMIN and SMAX.  Use\n+\trs6000_emit_minmax.\n+\t(movdfcc): Use rs6000_emit_cmove.\n+\t(fseldfdf4): Don't compare a CONST_INT with a floating-point value.\n+\tDon't generate emit_fselsfsf4.\n+\t(fselsfdf4): Likewise.\n+\t* config/rs6000/rs6000.c (zero_fp_constant): New predicate.\n+\t(min_max_operator): New predicate.\n+\t(rs6000_emit_cmove): New function.\n+\t(rs6000_emit_minmax): New function.\n+\t* config/rs6000/rs6000-protos.h: Prototype new functions.\n+\t* config/rs6000/rs6000.h (PREDICATE_CODES): Add zero_fp_constant\n+\tand min_max_operator.\n+\n+\t* config/rs6000/rs6000.c (output_cbranch): Handle all\n+\tconditional types in the switch statement.\n+\n 2001-05-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-decl.c (finish_decl): Don't set DECL_C_HARD_REGISTER for"}, {"sha": "6307503507932520d1bc42e5df219554726c105c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=50a0b056d2d003872d0421710bfd3343fe5e3363", "patch": "@@ -47,6 +47,7 @@ extern int got_operand PARAMS ((rtx, enum machine_mode));\n extern int got_no_const_operand PARAMS ((rtx, enum machine_mode));\n extern int num_insns_constant PARAMS ((rtx, enum machine_mode));\n extern int easy_fp_constant PARAMS ((rtx, enum machine_mode));\n+extern int zero_fp_constant PARAMS ((rtx, enum machine_mode));\n extern int volatile_mem_operand PARAMS ((rtx, enum machine_mode));\n extern int offsettable_mem_operand PARAMS ((rtx, enum machine_mode));\n extern int mem_or_easy_const_operand PARAMS ((rtx, enum machine_mode));\n@@ -79,6 +80,7 @@ extern int scc_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int trap_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n extern int boolean_or_operator PARAMS ((rtx, enum machine_mode));\n+extern int min_max_operator PARAMS ((rtx, enum machine_mode));\n extern int includes_lshift_p PARAMS ((rtx, rtx));\n extern int includes_rshift_p PARAMS ((rtx, rtx));\n extern int includes_lshift64_p PARAMS ((rtx, rtx));\n@@ -94,6 +96,8 @@ extern enum rtx_code rs6000_reverse_condition PARAMS ((enum machine_mode,\n extern void rs6000_emit_sCOND PARAMS ((enum rtx_code, rtx));\n extern void rs6000_emit_cbranch PARAMS ((enum rtx_code, rtx));\n extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n+extern int rs6000_emit_cmove PARAMS ((rtx, rtx, rtx, rtx));\n+extern void rs6000_emit_minmax PARAMS ((rtx, enum rtx_code, rtx, rtx));\n extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));\n extern int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern int rs6000_adjust_priority PARAMS ((rtx, int));"}, {"sha": "10b3b91cba250c7a72691b3d01468511f360fda0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 205, "deletions": 6, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=50a0b056d2d003872d0421710bfd3343fe5e3363", "patch": "@@ -914,6 +914,15 @@ easy_fp_constant (op, mode)\n     abort ();\n }\n \n+/* Return 1 if the operand is 0.0.  */\n+int\n+zero_fp_constant (op, mode)\n+     register rtx op;\n+     register enum machine_mode mode;\n+{\n+  return GET_MODE_CLASS (mode) == MODE_FLOAT && op == CONST0_RTX (mode);\n+}\n+\n /* Return 1 if the operand is in volatile memory.  Note that during the\n    RTL generation phase, memory_operand does not return TRUE for\n    volatile memory references.  So this function allows us to\n@@ -3440,6 +3449,15 @@ boolean_or_operator (op, mode)\n   enum rtx_code code = GET_CODE (op);\n   return (code == IOR || code == XOR);\n }\n+\n+int\n+min_max_operator (op, mode)\n+    rtx op;\n+    enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return (code == SMIN || code == SMAX || code == UMIN || code == UMAX);\n+}\n \f\n /* Return 1 if ANDOP is a mask that has no bits on that are not in the\n    mask required to convert the result of a rotate insn into a shift\n@@ -4676,12 +4694,18 @@ output_cbranch (op, label, reversed, insn)\n     {\n       /* Not all of these are actually distinct opcodes, but\n \t we distinguish them for clarity of the resulting assembler.  */\n-    case NE: ccode = \"ne\"; break;\n-    case EQ: ccode = \"eq\"; break;\n-    case GE: case GEU: ccode = \"ge\"; break;\n-    case GT: case GTU: ccode = \"gt\"; break;\n-    case LE: case LEU: ccode = \"le\"; break;\n-    case LT: case LTU: ccode = \"lt\"; break;\n+    case NE: case LTGT:\n+      ccode = \"ne\"; break;\n+    case EQ: case UNEQ:\n+      ccode = \"eq\"; break;\n+    case GE: case GEU: \n+      ccode = \"ge\"; break;\n+    case GT: case GTU: case UNGT: \n+      ccode = \"gt\"; break;\n+    case LE: case LEU: \n+      ccode = \"le\"; break;\n+    case LT: case LTU: case UNLT: \n+      ccode = \"lt\"; break;\n     case UNORDERED: ccode = \"un\"; break;\n     case ORDERED: ccode = \"nu\"; break;\n     case UNGE: ccode = \"nl\"; break;\n@@ -4731,6 +4755,181 @@ output_cbranch (op, label, reversed, insn)\n \n   return string;\n }\n+\n+/* Emit a conditional move: move TRUE_COND to DEST if OP of the\n+   operands of the last comparison is nonzero/true, FALSE_COND if it\n+   is zero/false.  Return 0 if the hardware has no such operation.  */\n+int\n+rs6000_emit_cmove (dest, op, true_cond, false_cond)\n+     rtx dest;\n+     rtx op;\n+     rtx true_cond;\n+     rtx false_cond;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  rtx op0 = rs6000_compare_op0;\n+  rtx op1 = rs6000_compare_op1;\n+  REAL_VALUE_TYPE c1;\n+  enum machine_mode mode = GET_MODE (op0);\n+  rtx temp;\n+\n+  /* First, work out if the hardware can do this at all, or\n+     if it's too slow...  */\n+  /* If the comparison is an integer one, since we only have fsel\n+     it'll be cheaper to use a branch.  */\n+  if (! rs6000_compare_fp_p)\n+    return 0;\n+\n+  /* Eliminate half of the comparisons by switching operands, this\n+     makes the remaining code simpler.  */\n+  if (code == UNLT || code == UNGT || code == UNORDERED || code == NE\n+      || code == LTGT || code == LT)\n+    {\n+      code = reverse_condition_maybe_unordered (code);\n+      temp = true_cond;\n+      true_cond = false_cond;\n+      false_cond = temp;\n+    }\n+\n+  /* UNEQ and LTGT take four instructions for a comparison with zero,\n+     it'll probably be faster to use a branch here too.  */\n+  if (code == UNEQ)\n+    return 0;\n+  \n+  if (GET_CODE (op1) == CONST_DOUBLE)\n+    REAL_VALUE_FROM_CONST_DOUBLE (c1, op1);\n+    \n+  /* We're going to try to implement comparions by performing\n+     a subtract, then comparing against zero.  Unfortunately,\n+     Inf - Inf is NaN which is not zero, and so if we don't\n+     know that the the operand is finite and the comparison\n+     would treat EQ different to UNORDERED, we can't do it.  */\n+  if (! flag_unsafe_math_optimizations\n+      && code != GT && code != UNGE\n+      && (GET_CODE (op1) != CONST_DOUBLE || target_isinf (c1))\n+      /* Constructs of the form (a OP b ? a : b) are safe.  */\n+      && ((! rtx_equal_p (op0, false_cond) && ! rtx_equal_p (op1, false_cond))\n+\t  || (! rtx_equal_p (op0, true_cond) \n+\t      && ! rtx_equal_p (op1, true_cond))))\n+    return 0;\n+  /* At this point we know we can use fsel.  */\n+\n+  /* Reduce the comparison to a comparison against zero.  */\n+  temp = gen_reg_rtx (mode);\n+  emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t  gen_rtx_MINUS (mode, op0, op1)));\n+  op0 = temp;\n+  op1 = CONST0_RTX (mode);\n+\n+  /* If we don't care about NaNs we can reduce some of the comparisons\n+     down to faster ones.  */\n+  if (flag_unsafe_math_optimizations)\n+    switch (code)\n+      {\n+      case GT:\n+\tcode = LE;\n+\ttemp = true_cond;\n+\ttrue_cond = false_cond;\n+\tfalse_cond = temp;\n+\tbreak;\n+      case UNGE:\n+\tcode = GE;\n+\tbreak;\n+      case UNEQ:\n+\tcode = EQ;\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+  /* Now, reduce everything down to a GE.  */\n+  switch (code)\n+    {\n+    case GE:\n+      break;\n+\n+    case LE:\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_NEG (mode, op0)));\n+      op0 = temp;\n+      break;\n+\n+    case ORDERED:\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_ABS (mode, op0)));\n+      op0 = temp;\n+      break;\n+\n+    case EQ:\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, \n+\t\t\t      gen_rtx_NEG (mode,\n+\t\t\t\t\t   gen_rtx_ABS (mode, op0))));\n+      op0 = temp;\n+      break;\n+\n+    case UNGE:\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t      gen_rtx_IF_THEN_ELSE (mode, \n+\t\t\t\t\t\t    gen_rtx_GE (VOIDmode,\n+\t\t\t\t\t\t\t\top0, op1),\n+\t\t\t\t\t\t    true_cond, false_cond)));\n+      false_cond = temp;\n+      true_cond = false_cond;\n+\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_NEG (mode, op0)));\n+      op0 = temp;\n+      break;\n+\n+    case GT:\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t      gen_rtx_IF_THEN_ELSE (mode, \n+\t\t\t\t\t\t    gen_rtx_GE (VOIDmode,\n+\t\t\t\t\t\t\t\top0, op1),\n+\t\t\t\t\t\t    true_cond, false_cond)));\n+      true_cond = temp;\n+      false_cond = true_cond;\n+\n+      temp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, temp, gen_rtx_NEG (mode, op0)));\n+      op0 = temp;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest,\n+\t\t\t  gen_rtx_IF_THEN_ELSE (mode, \n+\t\t\t\t\t\tgen_rtx_GE (VOIDmode,\n+\t\t\t\t\t\t\t    op0, op1),\n+\t\t\t\t\t\ttrue_cond, false_cond)));\n+  return 1;\n+}\n+\n+void\n+rs6000_emit_minmax (dest, code, op0, op1)\n+     rtx dest;\n+     enum rtx_code code;\n+     rtx op0;\n+     rtx op1;\n+{\n+  enum machine_mode mode = GET_MODE (op0);\n+  rtx target;\n+  if (code == SMAX || code == UMAX)\n+    target = emit_conditional_move (dest, GE, op0, op1, mode, \n+\t\t\t\t    op0, op1, mode, 0);\n+  else\n+    target = emit_conditional_move (dest, GE, op0, op1, mode, \n+\t\t\t\t    op1, op0, mode, 0);\n+  if (target == NULL_RTX)\n+    abort ();\n+  if (target != dest)\n+    emit_move_insn (dest, target);\n+}\n \f\n /* This page contains routines that are used to determine what the function\n    prologue and epilogue code will do and write them out.  */"}, {"sha": "1de9c7d259023310212c09f820bbc03fc44551b9", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=50a0b056d2d003872d0421710bfd3343fe5e3363", "patch": "@@ -2683,6 +2683,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n   {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\\n   {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n+  {\"zero_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n   {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\t   \\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\t   \\\n   {\"volatile_mem_operand\", {MEM}},\t\t\t\t\t   \\\n@@ -2718,7 +2719,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n \t\t\t\tGT, LEU, LTU, GEU, GTU}},\t\t   \\\n   {\"boolean_operator\", {AND, IOR, XOR}},\t\t\t\t   \\\n-  {\"boolean_or_operator\", {IOR, XOR}},\n+  {\"boolean_or_operator\", {IOR, XOR}},\t\t\t\t\t   \\\n+  {\"min_max_operator\", {SMIN, SMAX, UMIN, UMAX}},\n \n /* uncomment for disabling the corresponding default options */\n /* #define  MACHINE_no_sched_interblock */"}, {"sha": "dd22359a8d5f9bbd820594a1056941f469dd7c1d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 54, "deletions": 198, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50a0b056d2d003872d0421710bfd3343fe5e3363/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=50a0b056d2d003872d0421710bfd3343fe5e3363", "patch": "@@ -4822,60 +4822,35 @@\n ;; single DEFINE_INSN for fsel and the define_splits to make them if made by\n ;; combine.\n (define_expand \"maxsf3\"\n-  [(set (match_dup 3)\n-\t(minus:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (SFmode); }\")\n-\n-(define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(smax:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:SF 3 \"gpc_reg_operand\" \"\"))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  [(set (match_dup 3)\n-\t(minus:SF (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0)\n-\t(if_then_else:SF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n+\t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"gpc_reg_operand\" \"\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))]\n-  \"\")\n+  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n+  \"{ rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]); DONE;}\")\n \n (define_expand \"minsf3\"\n-  [(set (match_dup 3)\n-\t(minus:SF (match_operand:SF 2 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:SF 1 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:SF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:SF 2 \"gpc_reg_operand\" \"\"))\n+\t\t\t (match_dup 2)\n+\t\t\t (match_dup 1)))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (SFmode); }\")\n+  \"{ rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]); DONE;}\")\n \n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t(smin:SF (match_operand:SF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:SF 3 \"gpc_reg_operand\" \"\"))]\n+\t(match_operator:SF 3 \"min_max_operator\"\n+\t [(match_operand:SF 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:SF 2 \"gpc_reg_operand\" \"\")]))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  [(set (match_dup 3)\n-\t(minus:SF (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0)\n-\t(if_then_else:SF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"\")\n+  [(const_int 0)]\n+  \"\n+{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]), \n+\t\t      operands[1], operands[2]);\n+  DONE;\n+}\")\n \n (define_expand \"movsfcc\"\n    [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -4885,72 +4860,26 @@\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n   \"\n {\n-  rtx temp, op0, op1;\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  if (! rs6000_compare_fp_p)\n-    FAIL;\n-  switch (code)\n-    {\n-    case GE: case EQ:\n-      op0 = rs6000_compare_op0;\n-      op1 = rs6000_compare_op1;\n-      break;\n-    case GT:\n-      op0 = rs6000_compare_op1;\n-      op1 = rs6000_compare_op0;\n-      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n-      break;\n-    case LE:\n-      op0 = rs6000_compare_op1;\n-      op1 = rs6000_compare_op0;\n-      break;\n-    case LT:\n-      op0 = rs6000_compare_op0;\n-      op1 = rs6000_compare_op1;\n-      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n-      break;\n-    default:\n-      FAIL;\n-    }\n-  if (GET_MODE (rs6000_compare_op0) == DFmode)\n-    {\n-      temp = gen_reg_rtx (DFmode);\n-      emit_insn (gen_subdf3 (temp, op0, op1));\n-      emit_insn (gen_fseldfsf4 (operands[0], temp, operands[2], operands[3]));\n-      if (code == EQ)\n-\t{\n-\t  emit_insn (gen_negdf2 (temp, temp));\n-\t  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[0], operands[3]));\n-\t}\n-    }\n+  if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n+    DONE;\n   else\n-    {\n-      temp = gen_reg_rtx (SFmode);\n-      emit_insn (gen_subsf3 (temp, op0, op1));\n-      emit_insn (gen_fselsfsf4 (operands[0], temp, operands[2], operands[3]));\n-      if (code == EQ)\n-\t{\n-\t  emit_insn (gen_negsf2 (temp, temp));\n-\t  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[0], operands[3]));\n-\t}\n-    }\n-  DONE;\n+    FAIL;\n }\")\n \n-(define_insn \"fselsfsf4\"\n+(define_insn \"*fselsfsf4\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (const_int 0))\n+\t\t\t     (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n \t\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n \t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"fseldfsf4\"\n+(define_insn \"*fseldfsf4\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:SF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (const_int 0))\n+\t\t\t     (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n \t\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n \t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n@@ -5053,66 +4982,39 @@\n   \"fsqrt %0,%1\"\n   [(set_attr \"type\" \"dsqrt\")])\n \n-;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n-;; fsel instruction and some auxiliary computations.  Then we just have a\n-;; single DEFINE_INSN for fsel and the define_splits to make them if made by\n-;; combine.\n+;; The conditional move instructions allow us to perform max and min\n+;; operations even when \n \n (define_expand \"maxdf3\"\n-  [(set (match_dup 3)\n-\t(minus:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:DF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode); }\")\n-\n-(define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(smax:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:DF 3 \"gpc_reg_operand\" \"\"))]\n-  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  [(set (match_dup 3)\n-\t(minus:DF (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0)\n-\t(if_then_else:DF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n+\t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"gpc_reg_operand\" \"\"))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))]\n-  \"\")\n+  \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n+  \"{ rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]); DONE;}\")\n \n (define_expand \"mindf3\"\n-  [(set (match_dup 3)\n-\t(minus:DF (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:DF 1 \"gpc_reg_operand\" \"\")))\n-   (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(if_then_else:DF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:DF 2 \"gpc_reg_operand\" \"\"))\n+\t\t\t (match_dup 2)\n+\t\t\t (match_dup 1)))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  \"\n-{ operands[3] = gen_reg_rtx (DFmode); }\")\n+  \"{ rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]); DONE;}\")\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(smin:DF (match_operand:DF 1 \"gpc_reg_operand\" \"\")\n-\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"\")))\n-   (clobber (match_operand:DF 3 \"gpc_reg_operand\" \"\"))]\n+\t(match_operator:DF 3 \"min_max_operator\"\n+\t [(match_operand:DF 1 \"gpc_reg_operand\" \"\")\n+\t  (match_operand:DF 2 \"gpc_reg_operand\" \"\")]))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n-  [(set (match_dup 3)\n-\t(minus:DF (match_dup 2) (match_dup 1)))\n-   (set (match_dup 0)\n-\t(if_then_else:DF (ge (match_dup 3)\n-\t\t\t     (const_int 0))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))]\n-  \"\")\n+  [(const_int 0)]\n+  \"\n+{ rs6000_emit_minmax (operands[0], GET_CODE (operands[3]), \n+\t\t      operands[1], operands[2]);\n+  DONE;\n+}\")\n \n (define_expand \"movdfcc\"\n    [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -5122,72 +5024,26 @@\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n   \"\n {\n-  rtx temp, op0, op1;\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  if (! rs6000_compare_fp_p)\n-    FAIL;\n-  switch (code)\n-    {\n-    case GE: case EQ:\n-      op0 = rs6000_compare_op0;\n-      op1 = rs6000_compare_op1;\n-      break;\n-    case GT:\n-      op0 = rs6000_compare_op1;\n-      op1 = rs6000_compare_op0;\n-      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n-      break;\n-    case LE:\n-      op0 = rs6000_compare_op1;\n-      op1 = rs6000_compare_op0;\n-      break;\n-    case LT:\n-      op0 = rs6000_compare_op0;\n-      op1 = rs6000_compare_op1;\n-      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n-      break;\n-    default:\n-      FAIL;\n-    }\n-  if (GET_MODE (rs6000_compare_op0) == DFmode)\n-    {\n-      temp = gen_reg_rtx (DFmode);\n-      emit_insn (gen_subdf3 (temp, op0, op1));\n-      emit_insn (gen_fseldfdf4 (operands[0], temp, operands[2], operands[3]));\n-      if (code == EQ)\n-\t{\n-\t  emit_insn (gen_negdf2 (temp, temp));\n-\t  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[0], operands[3]));\n-\t}\n-    }\n+  if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n+    DONE;\n   else\n-    {\n-      temp = gen_reg_rtx (SFmode);\n-      emit_insn (gen_subsf3 (temp, op0, op1));\n-      emit_insn (gen_fselsfdf4 (operands[0], temp, operands[2], operands[3]));\n-      if (code == EQ)\n-\t{\n-\t  emit_insn (gen_negsf2 (temp, temp));\n-\t  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[0], operands[3]));\n-\t}\n-    }\n-  DONE;\n+    FAIL;\n }\")\n \n-(define_insn \"fseldfdf4\"\n+(define_insn \"*fseldfdf4\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (const_int 0))\n+\t\t\t     (match_operand:DF 4 \"zero_fp_constant\" \"F\"))\n \t\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n \t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n   \"TARGET_PPC_GFXOPT && TARGET_HARD_FLOAT\"\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"fselsfdf4\"\n+(define_insn \"*fselsfdf4\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:DF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n-\t\t\t     (const_int 0))\n+\t\t\t     (match_operand:SF 4 \"zero_fp_constant\" \"F\"))\n \t\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n \t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n   \"TARGET_PPC_GFXOPT\""}]}