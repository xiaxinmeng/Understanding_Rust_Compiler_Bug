{"sha": "a563c2869215ff2581159dc8fa429d8b969477e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2M2MyODY5MjE1ZmYyNTgxMTU5ZGM4ZmE0MjlkOGI5Njk0NzdlNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-03-10T11:16:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-03-10T11:16:33Z"}, "message": "re PR middle-end/63155 (memory hog)\n\n2015-03-10  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/63155\n\t* tree-ssa-coalesce.h (verify_ssa_coalescing): Declare.\n\t* tree-ssa-coalesce.c: Include timevar.h.\n\t(attempt_coalesce): Handle graph being NULL.\n\t(coalesce_partitions): Call verify_ssa_coalescing if ENABLE_CHECKING.\n\tSplit out abnormal coalescing to ...\n\t(perform_abnormal_coalescing): ... this function.\n\t(coalesce_ssa_name): Perform abnormal coalescing without computing\n\tlive/conflict.\n\t(verify_ssa_coalescing_worker): New function.\n\t(verify_ssa_coalescing): Likewise.\n\nFrom-SVN: r221318", "tree": {"sha": "4cbc47b87a03895c92aeef265dd610dc202a91b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cbc47b87a03895c92aeef265dd610dc202a91b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a563c2869215ff2581159dc8fa429d8b969477e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a563c2869215ff2581159dc8fa429d8b969477e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a563c2869215ff2581159dc8fa429d8b969477e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a563c2869215ff2581159dc8fa429d8b969477e6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77d68d9796d35dbd48513518b7ae338979038547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77d68d9796d35dbd48513518b7ae338979038547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77d68d9796d35dbd48513518b7ae338979038547"}], "stats": {"total": 169, "additions": 148, "deletions": 21}, "files": [{"sha": "363d56f22a69673ba5cb10b0a6c6627110433ee6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a563c2869215ff2581159dc8fa429d8b969477e6", "patch": "@@ -1,3 +1,17 @@\n+2015-03-10  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/63155\n+\t* tree-ssa-coalesce.h (verify_ssa_coalescing): Declare.\n+\t* tree-ssa-coalesce.c: Include timevar.h.\n+\t(attempt_coalesce): Handle graph being NULL.\n+\t(coalesce_partitions): Call verify_ssa_coalescing if ENABLE_CHECKING.\n+\tSplit out abnormal coalescing to ...\n+\t(perform_abnormal_coalescing): ... this function.\n+\t(coalesce_ssa_name): Perform abnormal coalescing without computing\n+\tlive/conflict.\n+\t(verify_ssa_coalescing_worker): New function.\n+\t(verify_ssa_coalescing): Likewise.\n+\n 2015-03-10  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/65296"}, {"sha": "dd6b9c04f8b5d4605bc38297701cfc7a9f865e55", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 133, "deletions": 21, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=a563c2869215ff2581159dc8fa429d8b969477e6", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-live.h\"\n #include \"tree-ssa-coalesce.h\"\n #include \"diagnostic-core.h\"\n+#include \"timevar.h\"\n \n \n /* This set of routines implements a coalesce_list.  This is an object which\n@@ -1121,8 +1122,8 @@ create_outofssa_var_map (coalesce_list_p cl, bitmap used_in_copy)\n \n \n /* Attempt to coalesce ssa versions X and Y together using the partition\n-   mapping in MAP and checking conflicts in GRAPH.  Output any debug info to\n-   DEBUG, if it is nun-NULL.  */\n+   mapping in MAP and checking conflicts in GRAPH if not NULL.\n+   Output any debug info to DEBUG, if it is nun-NULL.  */\n \n static inline bool\n attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n@@ -1154,7 +1155,8 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n     fprintf (debug, \" [map: %d, %d] \", p1, p2);\n \n \n-  if (!ssa_conflicts_test_p (graph, p1, p2))\n+  if (!graph\n+      || !ssa_conflicts_test_p (graph, p1, p2))\n     {\n       var1 = partition_to_var (map, p1);\n       var2 = partition_to_var (map, p2);\n@@ -1168,10 +1170,13 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n \n       /* z is the new combined partition.  Remove the other partition from\n \t the list, and merge the conflicts.  */\n-      if (z == p1)\n-\tssa_conflicts_merge (graph, p1, p2);\n-      else\n-\tssa_conflicts_merge (graph, p2, p1);\n+      if (graph)\n+\t{\n+\t  if (z == p1)\n+\t    ssa_conflicts_merge (graph, p1, p2);\n+\t  else\n+\t    ssa_conflicts_merge (graph, p2, p1);\n+\t}\n \n       if (debug)\n \tfprintf (debug, \": Success -> %d\\n\", z);\n@@ -1185,24 +1190,16 @@ attempt_coalesce (var_map map, ssa_conflicts_p graph, int x, int y,\n }\n \n \n-/* Attempt to Coalesce partitions in MAP which occur in the list CL using\n-   GRAPH.  Debug output is sent to DEBUG if it is non-NULL.  */\n+/* Perform all abnormal coalescing on MAP.\n+   Debug output is sent to DEBUG if it is non-NULL.  */\n \n static void\n-coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n-\t\t     FILE *debug)\n+perform_abnormal_coalescing (var_map map, FILE *debug)\n {\n-  int x = 0, y = 0;\n-  tree var1, var2;\n-  int cost;\n   basic_block bb;\n   edge e;\n   edge_iterator ei;\n \n-  /* First, coalesce all the copies across abnormal edges.  These are not placed\n-     in the coalesce list because they do not need to be sorted, and simply\n-     consume extra memory/compilation time in large programs.  */\n-\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -1226,11 +1223,23 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n \t\tif (debug)\n \t\t  fprintf (debug, \"Abnormal coalesce: \");\n \n-\t\tif (!attempt_coalesce (map, graph, v1, v2, debug))\n+\t\tif (!attempt_coalesce (map, NULL, v1, v2, debug))\n \t\t  fail_abnormal_edge_coalesce (v1, v2);\n \t      }\n \t  }\n     }\n+}\n+\n+/* Attempt to Coalesce partitions in MAP which occur in the list CL using\n+   GRAPH.  Debug output is sent to DEBUG if it is non-NULL.  */\n+\n+static void\n+coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n+\t\t     FILE *debug)\n+{\n+  int x = 0, y = 0;\n+  tree var1, var2;\n+  int cost;\n \n   /* Now process the items in the coalesce list.  */\n \n@@ -1285,6 +1294,11 @@ coalesce_ssa_name (void)\n   var_map map;\n   unsigned int i;\n \n+#ifdef ENABLE_CHECKING\n+  /* Verify we can perform all must coalesces.  */\n+  verify_ssa_coalescing ();\n+#endif\n+\n   cl = create_coalesce_list ();\n   map = create_outofssa_var_map (cl, used_in_copies);\n \n@@ -1341,6 +1355,15 @@ coalesce_ssa_name (void)\n       return map;\n     }\n \n+  /* First, coalesce all the copies across abnormal edges.  These are not placed\n+     in the coalesce list because they do not need to be sorted, and simply\n+     consume extra memory/compilation time in large programs.\n+     Performing abnormal coalescing also needs no live/conflict computation\n+     because it must succeed (but we lose checking that it indeed does).\n+     Still for PR63155 this reduces memory usage from 10GB to zero.  */\n+  perform_abnormal_coalescing (map,\n+\t\t\t       ((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);\n \n@@ -1371,11 +1394,100 @@ coalesce_ssa_name (void)\n \n   /* Now coalesce everything in the list.  */\n   coalesce_partitions (map, graph, cl,\n-\t\t       ((dump_flags & TDF_DETAILS) ? dump_file\n-\t\t\t\t\t\t   : NULL));\n+\t\t       ((dump_flags & TDF_DETAILS) ? dump_file : NULL));\n \n   delete_coalesce_list (cl);\n   ssa_conflicts_delete (graph);\n \n   return map;\n }\n+\n+\n+/* Helper for verify_ssa_coalescing.  Operates in two modes:\n+   1) scan the function for coalesces we must perform and store the\n+      SSA names participating in USED_IN_COPIES\n+   2) scan the function for coalesces and verify they can be performed\n+      under the constraints of GRAPH updating MAP in the process\n+   FIXME:  This can be extended to verify that the virtual operands\n+   form a factored use-def chain (coalescing the active virtual use\n+   with the virtual def at virtual def point).  */\n+\n+static void\n+verify_ssa_coalescing_worker (bitmap used_in_copies,\n+\t\t\t      var_map map, ssa_conflicts_p graph)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (e->flags & EDGE_ABNORMAL)\n+\t  {\n+\t    gphi_iterator gsi;\n+\t    for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t\t gsi_next (&gsi))\n+\t      {\n+\t\tgphi *phi = gsi.phi ();\n+\t\ttree arg = PHI_ARG_DEF (phi, e->dest_idx);\n+\t\tif (SSA_NAME_IS_DEFAULT_DEF (arg)\n+\t\t    && (!SSA_NAME_VAR (arg)\n+\t\t\t|| TREE_CODE (SSA_NAME_VAR (arg)) != PARM_DECL))\n+\t\t  continue;\n+\n+\t\ttree res = PHI_RESULT (phi);\n+\n+\t\tint v1 = SSA_NAME_VERSION (res);\n+\t\tint v2 = SSA_NAME_VERSION (arg);\n+\t\tif (used_in_copies)\n+\t\t  {\n+\t\t    bitmap_set_bit (used_in_copies, v1);\n+\t\t    bitmap_set_bit (used_in_copies, v2);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    int p1 = var_to_partition (map, res);\n+\t\t    int p2 = var_to_partition (map, arg);\n+\t\t    if (p1 != p2)\n+\t\t      {\n+\t\t\tif (ssa_conflicts_test_p (graph, p1, p2))\n+\t\t\t  fail_abnormal_edge_coalesce (v1, v2);\n+\t\t\tint z = var_union (map,\n+\t\t\t\t\t   partition_to_var (map, p1),\n+\t\t\t\t\t   partition_to_var (map, p2));\n+\t\t\tif (z == p1)\n+\t\t\t  ssa_conflicts_merge (graph, p1, p2);\n+\t\t\telse\n+\t\t\t  ssa_conflicts_merge (graph, p2, p1);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* Verify that we can coalesce SSA names we must coalesce.  */\n+\n+DEBUG_FUNCTION void\n+verify_ssa_coalescing (void)\n+{\n+  auto_timevar tv (TV_TREE_SSA_VERIFY);\n+  bitmap used_in_copies = BITMAP_ALLOC (NULL);\n+  verify_ssa_coalescing_worker (used_in_copies, NULL, NULL);\n+  if (bitmap_empty_p (used_in_copies))\n+    {\n+      BITMAP_FREE (used_in_copies);\n+      return;\n+    }\n+  var_map map = init_var_map (num_ssa_names);\n+  partition_view_bitmap (map, used_in_copies, true);\n+  BITMAP_FREE (used_in_copies);\n+  tree_live_info_p liveinfo = calculate_live_ranges (map, false);\n+  ssa_conflicts_p graph = build_ssa_conflict_graph (liveinfo);\n+  delete_tree_live_info (liveinfo);\n+  verify_ssa_coalescing_worker (NULL, map, graph);\n+  ssa_conflicts_delete (graph);\n+  delete_var_map (map);\n+}"}, {"sha": "06c33bfc7eeacbd238f6bcc9f87b374d423f33a1", "filename": "gcc/tree-ssa-coalesce.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2Ftree-ssa-coalesce.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a563c2869215ff2581159dc8fa429d8b969477e6/gcc%2Ftree-ssa-coalesce.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.h?ref=a563c2869215ff2581159dc8fa429d8b969477e6", "patch": "@@ -21,5 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_COALESCE_H\n \n extern var_map coalesce_ssa_name (void);\n+extern void verify_ssa_coalescing (void);\n \n #endif /* GCC_TREE_SSA_COALESCE_H */"}]}