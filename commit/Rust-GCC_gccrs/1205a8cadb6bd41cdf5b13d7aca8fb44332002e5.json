{"sha": "1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIwNWE4Y2FkYjZiZDQxY2RmNWIxM2Q3YWNhOGZiNDQzMzIwMDJlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-03-26T16:08:38Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-03-26T16:08:38Z"}, "message": "aarch64: Take issue rate into account for vector loop costs\n\nWhen SVE is enabled, GCC needs to do a three-way comparison\nbetween scalar, Advanced SIMD and SVE code.  The normal costs\ntend to be latency-based, which is well-suited to SLP.  However,\ncomparing sums of latency costs means that we effectively treat\nthe code as executing sequentially.  This can hide the effect of\npipeline bubbles or resource contention that in practice are quite\nimportant for loop vectorisation.  This is particularly true for\nloops that involve reductions.\n\nThis patch therefore tries to estimate how quickly each piece\nof code could issue, using a very (very) simplistic model.\nIt then uses this to adjust the loop vector costs up or down as\nappropriate.  Part of the Advanced SIMD vs. SVE adjustment is\nopt-in and is not enabled by default even for use_new_vector_costs.\n\nLike with the previous patches, this one only becomes active if\na CPU selects use_new_vector_costs.  It should therefore have\na very low impact on other CPUs.  The code also mostly ignores\nCPUs that have no issue information, even if use_new_vector_costs\nis enabled for some reason.\n\ngcc/\n\t* config/aarch64/aarch64.opt\n\t(-param=aarch64-loop-vect-issue-rate-niters=): New parameter.\n\t* doc/invoke.texi: Document it.\n\t* config/aarch64/aarch64-protos.h (aarch64_base_vec_issue_info)\n\t(aarch64_scalar_vec_issue_info, aarch64_simd_vec_issue_info)\n\t(aarch64_advsimd_vec_issue_info, aarch64_sve_vec_issue_info)\n\t(aarch64_vec_issue_info): New structures.\n\t(cpu_vector_cost): Write comments above the variables rather\n\tthan to the side.\n\t(cpu_vector_cost::issue_info): New member variable.\n\t* config/aarch64/aarch64.c: Include gimple-pretty-print.h\n\tand tree-ssa-loop-niter.h.\n\t(generic_vector_cost, a64fx_vector_cost, qdf24xx_vector_cost)\n\t(thunderx_vector_cost, tsv110_vector_cost, cortexa57_vector_cost)\n\t(exynosm1_vector_cost, xgene1_vector_cost, thunderx2t99_vector_cost)\n\t(thunderx3t110_vector_cost): Initialize issue_info to null.\n\t(neoversev1_scalar_issue_info, neoversev1_advsimd_issue_info)\n\t(neoversev1_sve_issue_info, neoversev1_vec_issue_info): New structures.\n\t(neoversev1_vector_cost): Use them.\n\t(aarch64_vec_op_count, aarch64_sve_op_count): New structures.\n\t(aarch64_vector_costs::saw_sve_only_op): New member variable.\n\t(aarch64_vector_costs::num_vector_iterations): Likewise.\n\t(aarch64_vector_costs::scalar_ops): Likewise.\n\t(aarch64_vector_costs::advsimd_ops): Likewise.\n\t(aarch64_vector_costs::sve_ops): Likewise.\n\t(aarch64_vector_costs::seen_loads): Likewise.\n\t(aarch64_simd_vec_costs_for_flags): New function.\n\t(aarch64_analyze_loop_vinfo): Initialize num_vector_iterations.\n\tCount the number of predicate operations required by SVE WHILE\n\tinstructions.\n\t(aarch64_comparison_type, aarch64_multiply_add_p): New functions.\n\t(aarch64_sve_only_stmt_p, aarch64_in_loop_reduction_latency): Likewise.\n\t(aarch64_count_ops): Likewise.\n\t(aarch64_add_stmt_cost): Record whether see an SVE operation\n\tthat cannot currently be implementing using Advanced SIMD.\n\tRecord issue information about the scalar, Advanced SIMD\n\tand (where relevant) SVE versions of a loop.\n\t(aarch64_vec_op_count::dump): New function.\n\t(aarch64_sve_op_count::dump): Likewise.\n\t(aarch64_estimate_min_cycles_per_iter): Likewise.\n\t(aarch64_adjust_body_cost): If issue information is available,\n\ttry to compare the issue rates of the various loop implementations\n\tand increase or decrease the vector body cost accordingly.", "tree": {"sha": "a926a061d24fdcbfe588e2dc7b37d5cbf8cb753e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a926a061d24fdcbfe588e2dc7b37d5cbf8cb753e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4180ab2fea0d3e8010f23b5e73095ac13cedafa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4180ab2fea0d3e8010f23b5e73095ac13cedafa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4180ab2fea0d3e8010f23b5e73095ac13cedafa"}], "stats": {"total": 987, "additions": 966, "deletions": 21}, "files": [{"sha": "ca1ed9e8758f9ce45f102d8f977795df2890ca74", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 168, "deletions": 10, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "patch": "@@ -281,19 +281,177 @@ struct sve_vec_cost : simd_vec_cost\n   const int scatter_store_elt_cost;\n };\n \n+/* Base information about how the CPU issues code, containing\n+   information that is relevant to scalar, Advanced SIMD and SVE\n+   operations.\n+\n+   The structure uses the general term \"operation\" to refer to\n+   whichever subdivision of an instruction makes sense for the CPU.\n+   These operations would typically be micro operations or macro\n+   operations.\n+\n+   Note that this structure and the ones derived from it are only\n+   as general as they need to be for the CPUs that currently use them.\n+   They will probably need to be extended or refined as more CPUs are\n+   added.  */\n+struct aarch64_base_vec_issue_info\n+{\n+  /* How many loads and stores can be issued per cycle.  */\n+  const unsigned int loads_stores_per_cycle;\n+\n+  /* How many stores can be issued per cycle.  */\n+  const unsigned int stores_per_cycle;\n+\n+  /* How many integer or FP/SIMD operations can be issued per cycle.\n+\n+     Currently we don't try to distinguish the two.  For vector code,\n+     we only really track FP/SIMD operations during vector costing;\n+     we don't for example try to cost arithmetic operations like\n+     address calculations, which are only decided later during ivopts.\n+\n+     For scalar code, we effectively assume that code operates entirely\n+     on integers or entirely on floating-point values.  Again, we don't\n+     try to take address calculations into account.\n+\n+     This is not very precise, but it's only meant to be a heuristic.\n+     We could certainly try to do better in future if there's an example\n+     of something that would benefit.  */\n+  const unsigned int general_ops_per_cycle;\n+\n+  /* How many FP/SIMD operations to count for a floating-point or\n+     vector load operation.\n+\n+     When constructing an Advanced SIMD vector from elements that have\n+     been loaded from memory, these values apply to each individual load.\n+     When using an SVE gather load, the values apply to each element of\n+     the gather.  */\n+  const unsigned int fp_simd_load_general_ops;\n+\n+  /* How many FP/SIMD operations to count for a floating-point or\n+     vector store operation.\n+\n+     When storing individual elements of an Advanced SIMD vector out to\n+     memory, these values apply to each individual store.  When using an\n+     SVE scatter store, these values apply to each element of the scatter.  */\n+  const unsigned int fp_simd_store_general_ops;\n+};\n+\n+using aarch64_scalar_vec_issue_info = aarch64_base_vec_issue_info;\n+\n+/* Base information about the issue stage for vector operations.\n+   This structure contains information that is relevant to both\n+   Advanced SIMD and SVE.  */\n+struct aarch64_simd_vec_issue_info : aarch64_base_vec_issue_info\n+{\n+  constexpr aarch64_simd_vec_issue_info (aarch64_base_vec_issue_info base,\n+\t\t\t\t\t unsigned int ld2_st2_general_ops,\n+\t\t\t\t\t unsigned int ld3_st3_general_ops,\n+\t\t\t\t\t unsigned int ld4_st4_general_ops)\n+    : aarch64_base_vec_issue_info (base),\n+      ld2_st2_general_ops (ld2_st2_general_ops),\n+      ld3_st3_general_ops (ld3_st3_general_ops),\n+      ld4_st4_general_ops (ld4_st4_general_ops)\n+  {}\n+\n+  /* How many FP/SIMD operations to count for each vector loaded or\n+     stored by an LD[234] or ST[234] operation, in addition to the\n+     base costs given in the parent class.  For example, the full\n+     number of operations for an LD3 would be:\n+\n+       load ops:    3\n+       general ops: 3 * (fp_simd_load_general_ops + ld3_st3_general_ops).  */\n+  const unsigned int ld2_st2_general_ops;\n+  const unsigned int ld3_st3_general_ops;\n+  const unsigned int ld4_st4_general_ops;\n+};\n+\n+using aarch64_advsimd_vec_issue_info = aarch64_simd_vec_issue_info;\n+\n+/* Information about the issue stage for SVE.  The main thing this adds\n+   is a concept of \"predicate operations\".  */\n+struct aarch64_sve_vec_issue_info : aarch64_simd_vec_issue_info\n+{\n+  constexpr aarch64_sve_vec_issue_info\n+    (aarch64_simd_vec_issue_info base,\n+     unsigned int pred_ops_per_cycle,\n+     unsigned int while_pred_ops,\n+     unsigned int int_cmp_pred_ops,\n+     unsigned int fp_cmp_pred_ops,\n+     unsigned int gather_scatter_pair_general_ops,\n+     unsigned int gather_scatter_pair_pred_ops)\n+    : aarch64_simd_vec_issue_info (base),\n+      pred_ops_per_cycle (pred_ops_per_cycle),\n+      while_pred_ops (while_pred_ops),\n+      int_cmp_pred_ops (int_cmp_pred_ops),\n+      fp_cmp_pred_ops (fp_cmp_pred_ops),\n+      gather_scatter_pair_general_ops (gather_scatter_pair_general_ops),\n+      gather_scatter_pair_pred_ops (gather_scatter_pair_pred_ops)\n+  {}\n+\n+  /* How many predicate operations can be issued per cycle.  */\n+  const unsigned int pred_ops_per_cycle;\n+\n+  /* How many predicate operations are generated by a WHILExx\n+     instruction.  */\n+  const unsigned int while_pred_ops;\n+\n+  /* How many predicate operations are generated by an integer\n+     comparison instruction.  */\n+  const unsigned int int_cmp_pred_ops;\n+\n+  /* How many predicate operations are generated by a floating-point\n+     comparison instruction.  */\n+  const unsigned int fp_cmp_pred_ops;\n+\n+  /* How many general and predicate operations are generated by each pair\n+     of elements in a gather load or scatter store.  These values apply\n+     on top of the per-element counts recorded in fp_simd_load_general_ops\n+     and fp_simd_store_general_ops.\n+\n+     The reason for using pairs is that that is the largest possible\n+     granule size for 128-bit SVE, which can load and store 2 64-bit\n+     elements or 4 32-bit elements.  */\n+  const unsigned int gather_scatter_pair_general_ops;\n+  const unsigned int gather_scatter_pair_pred_ops;\n+};\n+\n+/* Information related to instruction issue for a particular CPU.  */\n+struct aarch64_vec_issue_info\n+{\n+  const aarch64_base_vec_issue_info *const scalar;\n+  const aarch64_simd_vec_issue_info *const advsimd;\n+  const aarch64_sve_vec_issue_info *const sve;\n+};\n+\n /* Cost for vector insn classes.  */\n struct cpu_vector_cost\n {\n-  const int scalar_int_stmt_cost;\t /* Cost of any int scalar operation,\n-\t\t\t\t\t    excluding load and store.  */\n-  const int scalar_fp_stmt_cost;\t /* Cost of any fp scalar operation,\n-\t\t\t\t\t    excluding load and store.  */\n-  const int scalar_load_cost;\t\t /* Cost of scalar load.  */\n-  const int scalar_store_cost;\t\t /* Cost of scalar store.  */\n-  const int cond_taken_branch_cost;\t /* Cost of taken branch.  */\n-  const int cond_not_taken_branch_cost;  /* Cost of not taken branch.  */\n-  const advsimd_vec_cost *advsimd;\t /* Cost of Advanced SIMD operations.  */\n-  const sve_vec_cost *sve;\t\t /* Cost of SVE operations.  */\n+  /* Cost of any integer scalar operation, excluding load and store.  */\n+  const int scalar_int_stmt_cost;\n+\n+  /* Cost of any fp scalar operation, excluding load and store.  */\n+  const int scalar_fp_stmt_cost;\n+\n+  /* Cost of a scalar load.  */\n+  const int scalar_load_cost;\n+\n+  /* Cost of a scalar store.  */\n+  const int scalar_store_cost;\n+\n+  /* Cost of a taken branch.  */\n+  const int cond_taken_branch_cost;\n+\n+  /* Cost of a not-taken branch.  */\n+  const int cond_not_taken_branch_cost;\n+\n+  /* Cost of an Advanced SIMD operations.  */\n+  const advsimd_vec_cost *advsimd;\n+\n+  /* Cost of an SVE operations, or null if SVE is not implemented.  */\n+  const sve_vec_cost *sve;\n+\n+  /* Issue information, or null if none is provided.  */\n+  const aarch64_vec_issue_info *const issue_info;\n };\n \n /* Branch costs.  */"}, {"sha": "6d961bea5dc04055e6015d7616a01d553c9c3fd1", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 787, "deletions": 11, "changes": 798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "patch": "@@ -74,6 +74,8 @@\n #include \"intl.h\"\n #include \"expmed.h\"\n #include \"function-abi.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-ssa-loop-niter.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -652,7 +654,8 @@ static const struct cpu_vector_cost generic_vector_cost =\n   3, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &generic_advsimd_vector_cost, /* advsimd  */\n-  &generic_sve_vector_cost /* sve */\n+  &generic_sve_vector_cost, /* sve */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost a64fx_advsimd_vector_cost =\n@@ -719,7 +722,8 @@ static const struct cpu_vector_cost a64fx_vector_cost =\n   3, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &a64fx_advsimd_vector_cost, /* advsimd  */\n-  &a64fx_sve_vector_cost /* sve  */\n+  &a64fx_sve_vector_cost, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost qdf24xx_advsimd_vector_cost =\n@@ -756,7 +760,8 @@ static const struct cpu_vector_cost qdf24xx_vector_cost =\n   3, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &qdf24xx_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n \n@@ -794,7 +799,8 @@ static const struct cpu_vector_cost thunderx_vector_cost =\n   3, /* cond_taken_branch_cost  */\n   3, /* cond_not_taken_branch_cost  */\n   &thunderx_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost tsv110_advsimd_vector_cost =\n@@ -830,7 +836,8 @@ static const struct cpu_vector_cost tsv110_vector_cost =\n   1, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &tsv110_advsimd_vector_cost, /* advsimd  */\n-  NULL, /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost cortexa57_advsimd_vector_cost =\n@@ -867,7 +874,8 @@ static const struct cpu_vector_cost cortexa57_vector_cost =\n   1, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &cortexa57_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost exynosm1_advsimd_vector_cost =\n@@ -903,7 +911,8 @@ static const struct cpu_vector_cost exynosm1_vector_cost =\n   1, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &exynosm1_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost xgene1_advsimd_vector_cost =\n@@ -940,7 +949,8 @@ static const struct cpu_vector_cost xgene1_vector_cost =\n   2, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &xgene1_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost thunderx2t99_advsimd_vector_cost =\n@@ -977,7 +987,8 @@ static const struct cpu_vector_cost thunderx2t99_vector_cost =\n   2, /* cond_taken_branch_cost  */\n   1,  /* cond_not_taken_branch_cost  */\n   &thunderx2t99_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n static const advsimd_vec_cost thunderx3t110_advsimd_vector_cost =\n@@ -1013,7 +1024,8 @@ static const struct cpu_vector_cost thunderx3t110_vector_cost =\n   2, /* cond_taken_branch_cost  */\n   1,  /* cond_not_taken_branch_cost  */\n   &thunderx3t110_advsimd_vector_cost, /* advsimd  */\n-  NULL /* sve  */\n+  nullptr, /* sve  */\n+  nullptr /* issue_info  */\n };\n \n \n@@ -1696,6 +1708,58 @@ static const sve_vec_cost neoversev1_sve_vector_cost =\n   3 /* scatter_store_elt_cost  */\n };\n \n+static const aarch64_scalar_vec_issue_info neoversev1_scalar_issue_info =\n+{\n+  3, /* loads_stores_per_cycle  */\n+  2, /* stores_per_cycle  */\n+  4, /* general_ops_per_cycle  */\n+  0, /* fp_simd_load_general_ops  */\n+  1 /* fp_simd_store_general_ops  */\n+};\n+\n+static const aarch64_advsimd_vec_issue_info neoversev1_advsimd_issue_info =\n+{\n+  {\n+    3, /* loads_stores_per_cycle  */\n+    2, /* stores_per_cycle  */\n+    4, /* general_ops_per_cycle  */\n+    0, /* fp_simd_load_general_ops  */\n+    1 /* fp_simd_store_general_ops  */\n+  },\n+  2, /* ld2_st2_general_ops  */\n+  2, /* ld3_st3_general_ops  */\n+  3 /* ld4_st4_general_ops  */\n+};\n+\n+static const aarch64_sve_vec_issue_info neoversev1_sve_issue_info =\n+{\n+  {\n+    {\n+      2, /* loads_per_cycle  */\n+      2, /* stores_per_cycle  */\n+      2, /* general_ops_per_cycle  */\n+      0, /* fp_simd_load_general_ops  */\n+      1 /* fp_simd_store_general_ops  */\n+    },\n+    2, /* ld2_st2_general_ops  */\n+    2, /* ld3_st3_general_ops  */\n+    3 /* ld4_st4_general_ops  */\n+  },\n+  1, /* pred_ops_per_cycle  */\n+  2, /* while_pred_ops  */\n+  2, /* int_cmp_pred_ops  */\n+  1, /* fp_cmp_pred_ops  */\n+  1, /* gather_scatter_pair_general_ops  */\n+  1 /* gather_scatter_pair_pred_ops  */\n+};\n+\n+static const aarch64_vec_issue_info neoversev1_vec_issue_info =\n+{\n+  &neoversev1_scalar_issue_info,\n+  &neoversev1_advsimd_issue_info,\n+  &neoversev1_sve_issue_info\n+};\n+\n /* Neoverse V1 costs for vector insn classes.  */\n static const struct cpu_vector_cost neoversev1_vector_cost =\n {\n@@ -1706,7 +1770,8 @@ static const struct cpu_vector_cost neoversev1_vector_cost =\n   1, /* cond_taken_branch_cost  */\n   1, /* cond_not_taken_branch_cost  */\n   &neoversev1_advsimd_vector_cost, /* advsimd  */\n-  &neoversev1_sve_vector_cost /* sve  */\n+  &neoversev1_sve_vector_cost, /* sve  */\n+  &neoversev1_vec_issue_info /* issue_info  */\n };\n \n static const struct tune_params neoversev1_tunings =\n@@ -14120,6 +14185,38 @@ aarch64_first_cycle_multipass_dfa_lookahead_guard (rtx_insn *insn,\n \n /* Vectorizer cost model target hooks.  */\n \n+/* Information about how the CPU would issue the scalar, Advanced SIMD\n+   or SVE version of a vector loop, using the scheme defined by the\n+   aarch64_base_vec_issue_info hierarchy of structures.  */\n+struct aarch64_vec_op_count\n+{\n+  void dump () const;\n+\n+  /* The number of individual \"general\" operations.  See the comments\n+     in aarch64_base_vec_issue_info for details.  */\n+  unsigned int general_ops = 0;\n+\n+  /* The number of load and store operations, under the same scheme\n+     as above.  */\n+  unsigned int loads = 0;\n+  unsigned int stores = 0;\n+\n+  /* The minimum number of cycles needed to execute all loop-carried\n+     operations, which in the vector code become associated with\n+     reductions.  */\n+  unsigned int reduction_latency = 0;\n+};\n+\n+/* Extends aarch64_vec_op_count with SVE-specific information.  */\n+struct aarch64_sve_op_count : aarch64_vec_op_count\n+{\n+  void dump () const;\n+\n+  /* The number of individual predicate operations.  See the comments\n+     in aarch64_sve_vec_issue_info for details.  */\n+  unsigned int pred_ops = 0;\n+};\n+\n /* Information about vector code that we're in the process of costing.  */\n struct aarch64_vector_costs\n {\n@@ -14138,6 +14235,10 @@ struct aarch64_vector_costs\n      vectorization.  */\n   bool is_loop = false;\n \n+  /* True if we've seen an SVE operation that we cannot currently vectorize\n+     using Advanced SIMD.  */\n+  bool saw_sve_only_op = false;\n+\n   /* - If VEC_FLAGS is zero then we're costing the original scalar code.\n      - If VEC_FLAGS & VEC_ADVSIMD is nonzero then we're costing Advanced\n        SIMD code.\n@@ -14159,6 +14260,32 @@ struct aarch64_vector_costs\n      the heuristic.  */\n   unsigned HOST_WIDE_INT unrolled_advsimd_niters = 0;\n   unsigned HOST_WIDE_INT unrolled_advsimd_stmts = 0;\n+\n+  /* If we're vectorizing a loop that executes a constant number of times,\n+     this variable gives the number of times that the vector loop would\n+     iterate, otherwise it is zero.  */\n+  uint64_t num_vector_iterations = 0;\n+\n+  /* Used only when vectorizing loops.  Estimates the number and kind of scalar\n+     operations that would be needed to perform the same work as one iteration\n+     of the vector loop.  */\n+  aarch64_vec_op_count scalar_ops;\n+\n+  /* Used only when vectorizing loops.  If VEC_FLAGS & VEC_ADVSIMD,\n+     this structure estimates the number and kind of operations that the\n+     vector loop would contain.  If VEC_FLAGS & VEC_SVE, the structure\n+     estimates what the equivalent Advanced SIMD-only code would need in\n+     order to perform the same work as one iteration of the SVE loop.  */\n+  aarch64_vec_op_count advsimd_ops;\n+\n+  /* Used only when vectorizing loops with SVE.  It estimates the number and\n+     kind of operations that the SVE loop would contain.  */\n+  aarch64_sve_op_count sve_ops;\n+\n+  /* Used to detect cases in which we end up costing the same load twice,\n+     once to account for results that are actually used and once to account\n+     for unused results.  */\n+  hash_map<nofree_ptr_hash<_stmt_vec_info>, unsigned int> seen_loads;\n };\n \n /* Implement TARGET_VECTORIZE_INIT_COST.  */\n@@ -14190,6 +14317,16 @@ aarch64_simd_vec_costs (tree vectype)\n   return costs->advsimd;\n }\n \n+/* Return the appropriate SIMD costs for vectors with VEC_* flags FLAGS.  */\n+static const simd_vec_cost *\n+aarch64_simd_vec_costs_for_flags (unsigned int flags)\n+{\n+  const cpu_vector_cost *costs = aarch64_tune_params.vec_costs;\n+  if ((flags & VEC_ANY_SVE) && costs->sve)\n+    return costs->sve;\n+  return costs->advsimd;\n+}\n+\n /* Decide whether to use the unrolling heuristic described above\n    aarch64_vector_costs::unrolled_advsimd_niters, updating that\n    field if so.  LOOP_VINFO describes the loop that we're vectorizing\n@@ -14250,6 +14387,19 @@ aarch64_analyze_loop_vinfo (loop_vec_info loop_vinfo,\n {\n   costs->is_loop = true;\n \n+  /* Record the number of times that the vector loop would execute,\n+     if known.  */\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  auto scalar_niters = max_stmt_executions_int (loop);\n+  if (scalar_niters >= 0)\n+    {\n+      unsigned int vf = vect_vf_for_cost (loop_vinfo);\n+      if (LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n+\tcosts->num_vector_iterations = scalar_niters / vf;\n+      else\n+\tcosts->num_vector_iterations = CEIL (scalar_niters, vf);\n+    }\n+\n   /* Detect whether we're costing the scalar code or the vector code.\n      This is a bit hacky: it would be better if the vectorizer told\n      us directly.\n@@ -14265,6 +14415,20 @@ aarch64_analyze_loop_vinfo (loop_vec_info loop_vinfo,\n      apply the unrolling heuristic described above\n      aarch64_vector_costs::unrolled_advsimd_niters.  */\n   aarch64_record_potential_advsimd_unrolling (loop_vinfo, costs);\n+\n+  /* Record the issue information for any SVE WHILE instructions that the\n+     loop needs.  */\n+  auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n+  if (issue_info->sve && !LOOP_VINFO_MASKS (loop_vinfo).is_empty ())\n+    {\n+      unsigned int num_masks = 0;\n+      rgroup_controls *rgm;\n+      unsigned int num_vectors_m1;\n+      FOR_EACH_VEC_ELT (LOOP_VINFO_MASKS (loop_vinfo), num_vectors_m1, rgm)\n+\tif (rgm->type)\n+\t  num_masks += num_vectors_m1 + 1;\n+      costs->sve_ops.pred_ops += num_masks * issue_info->sve->while_pred_ops;\n+    }\n }\n \n /* Do one-time initialization of COSTS given that we're costing the block\n@@ -14407,6 +14571,17 @@ aarch64_embedded_comparison_type (stmt_vec_info stmt_info)\n   return NULL_TREE;\n }\n \n+/* If STMT_INFO is a comparison or contains an embedded comparison, return the\n+   scalar type of the values being compared.  Return null otherwise.  */\n+static tree\n+aarch64_comparison_type (stmt_vec_info stmt_info)\n+{\n+  if (auto *assign = dyn_cast<gassign *> (stmt_info->stmt))\n+    if (TREE_CODE_CLASS (gimple_assign_rhs_code (assign)) == tcc_comparison)\n+      return TREE_TYPE (gimple_assign_rhs1 (assign));\n+  return aarch64_embedded_comparison_type (stmt_info);\n+}\n+\n /* Return true if creating multiple copies of STMT_INFO for Advanced SIMD\n    vectors would produce a series of LDP or STP operations.  KIND is the\n    kind of statement that STMT_INFO represents.  */\n@@ -14470,6 +14645,79 @@ aarch64_integer_truncation_p (stmt_vec_info stmt_info)\n \t  && TYPE_PRECISION (lhs_type) < TYPE_PRECISION (rhs_type));\n }\n \n+/* Return true if STMT_INFO is the second part of a two-statement multiply-add\n+   or multiply-subtract sequence that might be suitable for fusing into a\n+   single instruction.  */\n+static bool\n+aarch64_multiply_add_p (vec_info *vinfo, stmt_vec_info stmt_info)\n+{\n+  gassign *assign = dyn_cast<gassign *> (stmt_info->stmt);\n+  if (!assign)\n+    return false;\n+  tree_code code = gimple_assign_rhs_code (assign);\n+  if (code != PLUS_EXPR && code != MINUS_EXPR)\n+    return false;\n+\n+  if (CONSTANT_CLASS_P (gimple_assign_rhs1 (assign))\n+      || CONSTANT_CLASS_P (gimple_assign_rhs2 (assign)))\n+    return false;\n+\n+  for (int i = 1; i < 3; ++i)\n+    {\n+      tree rhs = gimple_op (assign, i);\n+      /* ??? Should we try to check for a single use as well?  */\n+      if (TREE_CODE (rhs) != SSA_NAME)\n+\tcontinue;\n+\n+      stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n+      if (!def_stmt_info\n+\t  || STMT_VINFO_DEF_TYPE (def_stmt_info) != vect_internal_def)\n+\tcontinue;\n+      gassign *rhs_assign = dyn_cast<gassign *> (def_stmt_info->stmt);\n+      if (!rhs_assign || gimple_assign_rhs_code (rhs_assign) != MULT_EXPR)\n+\tcontinue;\n+\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true if the vectorized form of STMT_INFO is something that is only\n+   possible when using SVE instead of Advanced SIMD.  VECTYPE is the type of\n+   the vector that STMT_INFO is operating on.  */\n+static bool\n+aarch64_sve_only_stmt_p (stmt_vec_info stmt_info, tree vectype)\n+{\n+  if (!aarch64_sve_mode_p (TYPE_MODE (vectype)))\n+    return false;\n+\n+  if (STMT_VINFO_DATA_REF (stmt_info))\n+    {\n+      /* Check for true gathers and scatters (rather than just strided accesses\n+\t that we've chosen to implement using gathers and scatters).  Although\n+\t in principle we could use elementwise accesses for Advanced SIMD,\n+\t the vectorizer doesn't yet support that.  */\n+      if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\treturn true;\n+\n+      /* Check for masked loads and stores.  */\n+      if (auto *call = dyn_cast<gcall *> (stmt_info->stmt))\n+\tif (gimple_call_internal_p (call)\n+\t    && internal_fn_mask_index (gimple_call_internal_fn (call)) >= 0)\n+\t  return true;\n+    }\n+\n+  /* Check for 64-bit integer multiplications.  */\n+  auto *assign = dyn_cast<gassign *> (stmt_info->stmt);\n+  if (assign\n+      && gimple_assign_rhs_code (assign) == MULT_EXPR\n+      && GET_MODE_INNER (TYPE_MODE (vectype)) == DImode\n+      && !integer_pow2p (gimple_assign_rhs2 (assign)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* We are considering implementing STMT_INFO using SVE vector type VECTYPE.\n    If STMT_INFO is an in-loop reduction that SVE supports directly, return\n    its latency in cycles, otherwise return zero.  SVE_COSTS specifies the\n@@ -14507,6 +14755,59 @@ aarch64_sve_in_loop_reduction_latency (vec_info *vinfo,\n   return 0;\n }\n \n+/* STMT_INFO describes a loop-carried operation in the original scalar code\n+   that we are considering implementing as a reduction.  Return one of the\n+   following values, depending on VEC_FLAGS:\n+\n+   - If VEC_FLAGS is zero, return the loop carry latency of the original\n+     scalar operation.\n+\n+   - If VEC_FLAGS & VEC_ADVSIMD, return the loop carry latency of the\n+     the Advanced SIMD implementation.\n+\n+   - If VEC_FLAGS & VEC_ANY_SVE, return the loop carry latency of the\n+     SVE implementation.\n+\n+   VECTYPE is the type of vector that the vectorizer is considering using\n+   for STMT_INFO, which might be different from the type of vector described\n+   by VEC_FLAGS.  */\n+static unsigned int\n+aarch64_in_loop_reduction_latency (vec_info *vinfo, stmt_vec_info stmt_info,\n+\t\t\t\t   tree vectype, unsigned int vec_flags)\n+{\n+  const cpu_vector_cost *vec_costs = aarch64_tune_params.vec_costs;\n+  const sve_vec_cost *sve_costs = nullptr;\n+  if (vec_flags & VEC_ANY_SVE)\n+    sve_costs = aarch64_tune_params.vec_costs->sve;\n+\n+  /* If the caller is asking for the SVE latency, check for forms of reduction\n+     that only SVE can handle directly.  */\n+  if (sve_costs)\n+    {\n+      unsigned int latency\n+\t= aarch64_sve_in_loop_reduction_latency (vinfo, stmt_info, vectype,\n+\t\t\t\t\t\t sve_costs);\n+      if (latency)\n+\treturn latency;\n+    }\n+\n+  /* Handle scalar costs.  */\n+  if (vec_flags == 0)\n+    {\n+      if (FLOAT_TYPE_P (vectype))\n+\treturn vec_costs->scalar_fp_stmt_cost;\n+      return vec_costs->scalar_int_stmt_cost;\n+    }\n+\n+  /* Otherwise, the loop body just contains normal integer or FP operations,\n+     with a vector reduction outside the loop.  */\n+  const simd_vec_cost *simd_costs\n+    = aarch64_simd_vec_costs_for_flags (vec_flags);\n+  if (FLOAT_TYPE_P (vectype))\n+    return simd_costs->fp_stmt_cost;\n+  return simd_costs->int_stmt_cost;\n+}\n+\n /* STMT_COST is the cost calculated by aarch64_builtin_vectorization_cost\n    for STMT_INFO, which has cost kind KIND.  If this is a scalar operation,\n    try to subdivide the target-independent categorization provided by KIND\n@@ -14729,6 +15030,203 @@ aarch64_adjust_stmt_cost (vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n   return stmt_cost;\n }\n \n+/* VINFO, COSTS, COUNT, KIND, STMT_INFO and VECTYPE are the same as for\n+   TARGET_VECTORIZE_ADD_STMT_COST and they describe an operation in the\n+   body of a vector loop.  Record issue information relating to the vector\n+   operation in OPS, where OPS is one of COSTS->scalar_ops, COSTS->advsimd_ops\n+   or COSTS->sve_ops; see the comments above those variables for details.\n+   In addition:\n+\n+   - VEC_FLAGS is zero if OPS is COSTS->scalar_ops.\n+\n+   - VEC_FLAGS & VEC_ADVSIMD is nonzero if OPS is COSTS->advsimd_ops.\n+\n+   - VEC_FLAGS & VEC_ANY_SVE is nonzero if OPS is COSTS->sve_ops.\n+\n+   ISSUE_INFO provides the scalar, Advanced SIMD or SVE issue information\n+   associated with OPS and VEC_FLAGS.  FACTOR says how many iterations of\n+   the loop described by VEC_FLAGS would be needed to match one iteration\n+   of the vector loop in VINFO.  */\n+static void\n+aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n+\t\t   unsigned int count, enum vect_cost_for_stmt kind,\n+\t\t   _stmt_vec_info *stmt_info, tree vectype,\n+\t\t   unsigned int vec_flags, aarch64_vec_op_count *ops,\n+\t\t   const aarch64_base_vec_issue_info *issue_info,\n+\t\t   unsigned int factor)\n+{\n+  if (!issue_info)\n+    return;\n+\n+  const aarch64_simd_vec_issue_info *simd_issue = nullptr;\n+  if (vec_flags)\n+    simd_issue = static_cast<const aarch64_simd_vec_issue_info *> (issue_info);\n+\n+  const aarch64_sve_vec_issue_info *sve_issue = nullptr;\n+  if (vec_flags & VEC_ANY_SVE)\n+    sve_issue = static_cast<const aarch64_sve_vec_issue_info *> (issue_info);\n+\n+  /* Calculate the minimum cycles per iteration imposed by a reduction\n+     operation.  */\n+  if ((kind == vector_stmt || kind == vec_to_scalar)\n+      && aarch64_is_reduction (stmt_info))\n+    {\n+      unsigned int base\n+\t= aarch64_in_loop_reduction_latency (vinfo, stmt_info, vectype,\n+\t\t\t\t\t     vec_flags);\n+      if (aarch64_reduc_type (vinfo, stmt_info) == FOLD_LEFT_REDUCTION)\n+\t{\n+\t  if (aarch64_sve_mode_p (TYPE_MODE (vectype)))\n+\t    {\n+\t      /* When costing an SVE FADDA, the vectorizer treats vec_to_scalar\n+\t\t as a single operation, whereas for Advanced SIMD it is a\n+\t\t per-element one.  Increase the factor accordingly, both for\n+\t\t the reduction_latency calculation and for the op couting.  */\n+\t      if (vec_flags & VEC_ADVSIMD)\n+\t\tfactor = vect_nunits_for_cost (vectype);\n+\t    }\n+\t  else\n+\t    /* An Advanced SIMD fold-left reduction is the same as a\n+\t       scalar one and the vectorizer therefore treats vec_to_scalar\n+\t       as a per-element cost.  There is no extra factor to apply for\n+\t       scalar code, either for reduction_latency or for the op\n+\t       counting below.  */\n+\t    factor = 1;\n+\t}\n+\n+      /* ??? Ideally for vector code we'd do COUNT * FACTOR reductions in\n+\t parallel, but unfortunately that's not yet the case.  */\n+      ops->reduction_latency = MAX (ops->reduction_latency,\n+\t\t\t\t    base * count * factor);\n+    }\n+\n+  /* Assume that multiply-adds will become a single operation.  */\n+  if (stmt_info && aarch64_multiply_add_p (vinfo, stmt_info))\n+    return;\n+\n+  /* When costing scalar statements in vector code, the count already\n+     includes the number of scalar elements in the vector, so we don't\n+     need to apply the factor as well.  */\n+  if (kind == scalar_load || kind == scalar_store || kind == scalar_stmt)\n+    factor = 1;\n+\n+  /* This can go negative with the load handling below.  */\n+  int num_copies = count * factor;\n+\n+  /* Count the basic operation cost associated with KIND.  */\n+  switch (kind)\n+    {\n+    case cond_branch_taken:\n+    case cond_branch_not_taken:\n+    case vector_gather_load:\n+    case vector_scatter_store:\n+      /* We currently don't expect these to be used in a loop body.  */\n+      break;\n+\n+    case vec_perm:\n+    case vec_promote_demote:\n+    case vec_construct:\n+    case vec_to_scalar:\n+    case scalar_to_vec:\n+      /* Assume that these operations have no overhead in the original\n+\t scalar code.  */\n+      if (!vec_flags)\n+\tbreak;\n+      /* Fallthrough.  */\n+    case vector_stmt:\n+    case scalar_stmt:\n+      ops->general_ops += num_copies;\n+      break;\n+\n+    case scalar_load:\n+    case vector_load:\n+    case unaligned_load:\n+      /* When costing scalars, detect cases in which we are called twice for\n+\t the same load.  This happens for LD[234] operations if only some of\n+\t the results are used.  The first time represents the cost of loading\n+\t the unused vectors, while the second time represents the cost of\n+\t loading the useful parts.  Only the latter should count towards the\n+\t scalar costs.  */\n+      if (stmt_info && !vec_flags)\n+\t{\n+\t  bool existed = false;\n+\t  unsigned int &prev_count\n+\t    = costs->seen_loads.get_or_insert (stmt_info, &existed);\n+\t  if (existed)\n+\t    num_copies -= prev_count;\n+\t  else\n+\t    prev_count = num_copies;\n+\t}\n+      ops->loads += num_copies;\n+      if (vec_flags || FLOAT_TYPE_P (vectype))\n+\tops->general_ops += issue_info->fp_simd_load_general_ops * num_copies;\n+      break;\n+\n+    case vector_store:\n+    case unaligned_store:\n+    case scalar_store:\n+      ops->stores += num_copies;\n+      if (vec_flags || FLOAT_TYPE_P (vectype))\n+\tops->general_ops += issue_info->fp_simd_store_general_ops * num_copies;\n+      break;\n+    }\n+\n+  /* Add any embedded comparison operations.  */\n+  if ((kind == scalar_stmt || kind == vector_stmt || kind == vec_to_scalar)\n+      && aarch64_embedded_comparison_type (stmt_info))\n+    ops->general_ops += num_copies;\n+\n+  /* Detect COND_REDUCTIONs and things that would need to become\n+     COND_REDUCTIONs if they were implemented using Advanced SIMD.\n+     There are then two sets of VEC_COND_EXPRs, whereas so far we\n+     have only accounted for one.  */\n+  if (vec_flags && (kind == vector_stmt || kind == vec_to_scalar))\n+    {\n+      int reduc_type = aarch64_reduc_type (vinfo, stmt_info);\n+      if ((reduc_type == EXTRACT_LAST_REDUCTION && (vec_flags & VEC_ADVSIMD))\n+\t  || reduc_type == COND_REDUCTION)\n+\tops->general_ops += num_copies;\n+    }\n+\n+  /* Count the predicate operations needed by an SVE comparison.  */\n+  if (sve_issue && (kind == vector_stmt || kind == vec_to_scalar))\n+    if (tree type = aarch64_comparison_type (stmt_info))\n+      {\n+\tunsigned int base = (FLOAT_TYPE_P (type)\n+\t\t\t     ? sve_issue->fp_cmp_pred_ops\n+\t\t\t     : sve_issue->int_cmp_pred_ops);\n+\tcosts->sve_ops.pred_ops += base * num_copies;\n+      }\n+\n+  /* Add any extra overhead associated with LD[234] and ST[234] operations.  */\n+  if (simd_issue)\n+    switch (aarch64_ld234_st234_vectors (kind, stmt_info))\n+      {\n+      case 2:\n+\tops->general_ops += simd_issue->ld2_st2_general_ops * num_copies;\n+\tbreak;\n+\n+      case 3:\n+\tops->general_ops += simd_issue->ld3_st3_general_ops * num_copies;\n+\tbreak;\n+\n+      case 4:\n+\tops->general_ops += simd_issue->ld4_st4_general_ops * num_copies;\n+\tbreak;\n+      }\n+\n+  /* Add any overhead associated with gather loads and scatter stores.  */\n+  if (sve_issue\n+      && (kind == scalar_load || kind == scalar_store)\n+      && STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_GATHER_SCATTER)\n+    {\n+      unsigned int pairs = CEIL (count, 2);\n+      costs->sve_ops.pred_ops\n+\t+= sve_issue->gather_scatter_pair_pred_ops * pairs;\n+      ops->general_ops += sve_issue->gather_scatter_pair_general_ops * pairs;\n+    }\n+}\n+\n /* Implement targetm.vectorize.add_stmt_cost.  */\n static unsigned\n aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n@@ -14760,6 +15258,9 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \t of just looking at KIND.  */\n       if (stmt_info && aarch64_use_new_vector_costs_p ())\n \t{\n+\t  if (vectype && aarch64_sve_only_stmt_p (stmt_info, vectype))\n+\t    costs->saw_sve_only_op = true;\n+\n \t  stmt_cost = aarch64_detect_scalar_stmt_subtype\n \t    (vinfo, kind, stmt_info, stmt_cost);\n \n@@ -14781,6 +15282,44 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \t  stmt_cost = aarch64_adjust_stmt_cost (kind, stmt_info, vectype,\n \t\t\t\t\t\tstmt_cost);\n \n+\t  /* If we're recording a nonzero vector loop body cost, also estimate\n+\t     the operations that would need to be issued by all relevant\n+\t     implementations of the loop.  */\n+\t  auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n+\t  if (loop_vinfo\n+\t      && issue_info\n+\t      && costs->vec_flags\n+\t      && where == vect_body\n+\t      && vectype\n+\t      && stmt_cost != 0)\n+\t    {\n+\t      /* Record estimates for the scalar code.  */\n+\t      aarch64_count_ops (vinfo, costs, count, kind, stmt_info, vectype,\n+\t\t\t\t 0, &costs->scalar_ops, issue_info->scalar,\n+\t\t\t\t vect_nunits_for_cost (vectype));\n+\n+\t      if (aarch64_sve_mode_p (vinfo->vector_mode) && issue_info->sve)\n+\t\t{\n+\t\t  /* Record estimates for a possible Advanced SIMD version\n+\t\t     of the SVE code.  */\n+\t\t  aarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n+\t\t\t\t     vectype, VEC_ADVSIMD, &costs->advsimd_ops,\n+\t\t\t\t     issue_info->advsimd,\n+\t\t\t\t     aarch64_estimated_sve_vq ());\n+\n+\t\t  /* Record estimates for the SVE code itself.  */\n+\t\t  aarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n+\t\t\t\t     vectype, VEC_ANY_SVE, &costs->sve_ops,\n+\t\t\t\t     issue_info->sve, 1);\n+\t\t}\n+\t      else\n+\t\t/* Record estimates for the Advanced SIMD code.  Treat SVE like\n+\t\t   Advanced SIMD if the CPU has no specific SVE costs.  */\n+\t\taarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n+\t\t\t\t   vectype, VEC_ADVSIMD, &costs->advsimd_ops,\n+\t\t\t\t   issue_info->advsimd, 1);\n+\t    }\n+\n \t  /* If we're applying the SVE vs. Advanced SIMD unrolling heuristic,\n \t     estimate the number of statements in the unrolled Advanced SIMD\n \t     loop.  For simplicitly, we assume that one iteration of the\n@@ -14805,12 +15344,56 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n   return retval;\n }\n \n+/* Dump information about the structure.  */\n+void\n+aarch64_vec_op_count::dump () const\n+{\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"  load operations = %d\\n\", loads);\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"  store operations = %d\\n\", stores);\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"  general operations = %d\\n\", general_ops);\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"  reduction latency = %d\\n\", reduction_latency);\n+}\n+\n+/* Dump information about the structure.  */\n+void\n+aarch64_sve_op_count::dump () const\n+{\n+  aarch64_vec_op_count::dump ();\n+  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t   \"  predicate operations = %d\\n\", pred_ops);\n+}\n+\n+/* Use ISSUE_INFO to estimate the minimum number of cycles needed to issue\n+   the operations described by OPS.  This is a very simplistic model!  */\n+static unsigned int\n+aarch64_estimate_min_cycles_per_iter\n+  (const aarch64_vec_op_count *ops,\n+   const aarch64_base_vec_issue_info *issue_info)\n+{\n+  unsigned int cycles = MAX (ops->reduction_latency, 1);\n+  cycles = MAX (cycles, CEIL (ops->stores, issue_info->stores_per_cycle));\n+  cycles = MAX (cycles, CEIL (ops->loads + ops->stores,\n+\t\t\t      issue_info->loads_stores_per_cycle));\n+  cycles = MAX (cycles, CEIL (ops->general_ops,\n+\t\t\t      issue_info->general_ops_per_cycle));\n+  return cycles;\n+}\n+\n /* BODY_COST is the cost of a vector loop body recorded in COSTS.\n    Adjust the cost as necessary and return the new cost.  */\n static unsigned int\n aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n {\n   unsigned int orig_body_cost = body_cost;\n+  bool should_disparage = false;\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Original vector body cost = %d\\n\", body_cost);\n \n   if (costs->unrolled_advsimd_stmts)\n     {\n@@ -14841,10 +15424,203 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n \t\t\t\t \"Increasing body cost to %d to account for\"\n \t\t\t\t \" unrolling\\n\", min_cost);\n \t      body_cost = min_cost;\n+\t      should_disparage = true;\n \t    }\n \t}\n     }\n \n+  auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n+  if (!issue_info)\n+    return body_cost;\n+\n+  unsigned int scalar_cycles_per_iter\n+    = aarch64_estimate_min_cycles_per_iter (&costs->scalar_ops,\n+\t\t\t\t\t    issue_info->scalar);\n+  unsigned int advsimd_cycles_per_iter\n+    = aarch64_estimate_min_cycles_per_iter (&costs->advsimd_ops,\n+\t\t\t\t\t    issue_info->advsimd);\n+  bool could_use_advsimd\n+    = ((costs->vec_flags & VEC_ADVSIMD)\n+       || (aarch64_autovec_preference != 2\n+\t   && (aarch64_tune_params.extra_tuning_flags\n+\t       & AARCH64_EXTRA_TUNE_MATCHED_VECTOR_THROUGHPUT)\n+\t   && !costs->saw_sve_only_op));\n+\n+  if (dump_enabled_p ())\n+    {\n+      if (IN_RANGE (costs->num_vector_iterations, 0, 65536))\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Vector loop iterates at most %wd times\\n\",\n+\t\t\t costs->num_vector_iterations);\n+      dump_printf_loc (MSG_NOTE, vect_location, \"Scalar issue estimate:\\n\");\n+      costs->scalar_ops.dump ();\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"  estimated cycles per iteration = %d\\n\",\n+\t\t       scalar_cycles_per_iter);\n+      if (could_use_advsimd)\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"Advanced SIMD issue estimate:\\n\");\n+\t  costs->advsimd_ops.dump ();\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"  estimated cycles per iteration = %d\\n\",\n+\t\t\t   advsimd_cycles_per_iter);\n+\t}\n+      else\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Loop could not use Advanced SIMD\\n\");\n+    }\n+\n+  uint64_t vector_cycles_per_iter = advsimd_cycles_per_iter;\n+  unsigned int vector_reduction_latency = costs->advsimd_ops.reduction_latency;\n+  if ((costs->vec_flags & VEC_ANY_SVE) && issue_info->sve)\n+    {\n+      /* Estimate the minimum number of cycles per iteration needed to issue\n+\t non-predicate operations.  */\n+      unsigned int sve_cycles_per_iter\n+\t= aarch64_estimate_min_cycles_per_iter (&costs->sve_ops,\n+\t\t\t\t\t\tissue_info->sve);\n+\n+      /* Separately estimate the minimum number of cycles per iteration needed\n+\t to issue the predicate operations.  */\n+      unsigned int pred_cycles_per_iter\n+\t= CEIL (costs->sve_ops.pred_ops, issue_info->sve->pred_ops_per_cycle);\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"SVE issue estimate:\\n\");\n+\t  costs->sve_ops.dump ();\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"  estimated cycles per iteration for non-predicate\"\n+\t\t\t   \" operations = %d\\n\", sve_cycles_per_iter);\n+\t  if (costs->sve_ops.pred_ops)\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"  estimated cycles per\"\n+\t\t\t     \" iteration for predicate operations = %d\\n\",\n+\t\t\t     pred_cycles_per_iter);\n+\t}\n+\n+      vector_cycles_per_iter = MAX (sve_cycles_per_iter, pred_cycles_per_iter);\n+      vector_reduction_latency = costs->sve_ops.reduction_latency;\n+\n+      /* If the scalar version of the loop could issue at least as\n+\t quickly as the predicate parts of the SVE loop, make the SVE loop\n+\t prohibitively expensive.  In this case vectorization is adding an\n+\t overhead that the original scalar code didn't have.\n+\n+\t This is mostly intended to detect cases in which WHILELOs dominate\n+\t for very tight loops, which is something that normal latency-based\n+\t costs would not model.  Adding this kind of cliffedge would be\n+\t too drastic for scalar_cycles_per_iter vs. sve_cycles_per_iter;\n+\t code later in the function handles that case in a more\n+\t conservative way.  */\n+      uint64_t sve_estimate = pred_cycles_per_iter + 1;\n+      if (scalar_cycles_per_iter < sve_estimate)\n+\t{\n+\t  unsigned int min_cost\n+\t    = orig_body_cost * estimated_poly_value (BYTES_PER_SVE_VECTOR);\n+\t  if (body_cost < min_cost)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Increasing body cost to %d because the\"\n+\t\t\t\t \" scalar code could issue within the limit\"\n+\t\t\t\t \" imposed by predicate operations\\n\",\n+\t\t\t\t min_cost);\n+\t      body_cost = min_cost;\n+\t      should_disparage = true;\n+\t    }\n+\t}\n+\n+      /* If it appears that the Advanced SIMD version of a loop could issue\n+\t more quickly than the SVE one, increase the SVE cost in proportion\n+\t to the difference.  The intention is to make Advanced SIMD preferable\n+\t in cases where an Advanced SIMD version exists, without increasing\n+\t the costs so much that SVE won't be used at all.\n+\n+\t The reasoning is similar to the scalar vs. predicate comparison above:\n+\t if the issue rate of the SVE code is limited by predicate operations\n+\t (i.e. if pred_cycles_per_iter > sve_cycles_per_iter), and if the\n+\t Advanced SIMD code could issue within the limit imposed by the\n+\t predicate operations, the predicate operations are adding an\n+\t overhead that the original code didn't have and so we should prefer\n+\t the Advanced SIMD version.  However, if the predicate operations\n+\t do not dominate in this way, we should only increase the cost of\n+\t the SVE code if sve_cycles_per_iter is strictly greater than\n+\t advsimd_cycles_per_iter.  Given rounding effects, this should mean\n+\t that Advanced SIMD is either better or at least no worse.  */\n+      if (sve_cycles_per_iter >= pred_cycles_per_iter)\n+\tsve_estimate = sve_cycles_per_iter;\n+      if (could_use_advsimd && advsimd_cycles_per_iter < sve_estimate)\n+\t{\n+\t  /* This ensures that min_cost > orig_body_cost * 2.  */\n+\t  unsigned int min_cost\n+\t    = orig_body_cost * CEIL (sve_estimate, advsimd_cycles_per_iter) + 1;\n+\t  if (body_cost < min_cost)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Increasing body cost to %d because Advanced\"\n+\t\t\t\t \" SIMD code could issue as quickly\\n\",\n+\t\t\t\t min_cost);\n+\t      body_cost = min_cost;\n+\t      should_disparage = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* Decide whether to stick to latency-based costs or whether to try to\n+     take issue rates into account.  */\n+  unsigned int threshold = aarch64_loop_vect_issue_rate_niters;\n+  if (costs->vec_flags & VEC_ANY_SVE)\n+    threshold = CEIL (threshold, aarch64_estimated_sve_vq ());\n+\n+  if (costs->num_vector_iterations >= 1\n+      && costs->num_vector_iterations < threshold)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Low iteration count, so using pure latency\"\n+\t\t\t \" costs\\n\");\n+    }\n+  /* Increase the cost of the vector code if it looks like the scalar code\n+     could issue more quickly.  These values are only rough estimates,\n+     so minor differences should only result in minor changes.  */\n+  else if (scalar_cycles_per_iter < vector_cycles_per_iter)\n+    {\n+      body_cost = CEIL (body_cost * vector_cycles_per_iter,\n+\t\t\tscalar_cycles_per_iter);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Increasing body cost to %d because scalar code\"\n+\t\t\t \" would issue more quickly\\n\", body_cost);\n+    }\n+  /* In general, it's expected that the proposed vector code would be able\n+     to issue more quickly than the original scalar code.  This should\n+     already be reflected to some extent in the latency-based costs.\n+\n+     However, the latency-based costs effectively assume that the scalar\n+     code and the vector code execute serially, which tends to underplay\n+     one important case: if the real (non-serialized) execution time of\n+     a scalar iteration is dominated by loop-carried dependencies,\n+     and if the vector code is able to reduce both the length of\n+     the loop-carried dependencies *and* the number of cycles needed\n+     to issue the code in general, we can be more confident that the\n+     vector code is an improvement, even if adding the other (non-loop-carried)\n+     latencies tends to hide this saving.  We therefore reduce the cost of the\n+     vector loop body in proportion to the saving.  */\n+  else if (costs->scalar_ops.reduction_latency > vector_reduction_latency\n+\t   && costs->scalar_ops.reduction_latency == scalar_cycles_per_iter\n+\t   && scalar_cycles_per_iter > vector_cycles_per_iter\n+\t   && !should_disparage)\n+    {\n+      body_cost = CEIL (body_cost * vector_cycles_per_iter,\n+\t\t\tscalar_cycles_per_iter);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"Decreasing body cost to %d account for smaller\"\n+\t\t\t \" reduction latency\\n\", body_cost);\n+    }\n+\n   return body_cost;\n }\n "}, {"sha": "32191cf1acf43302c4a544b85db60b7b6e14da48", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "patch": "@@ -277,3 +277,6 @@ The number of Newton iterations for calculating the reciprocal for double type.\n \n -param=aarch64-autovec-preference=\n Target Joined UInteger Var(aarch64_autovec_preference) Init(0) IntegerRange(0, 4) Param\n+\n+-param=aarch64-loop-vect-issue-rate-niters=\n+Target Joined UInteger Var(aarch64_loop_vect_issue_rate_niters) Init(6) IntegerRange(0, 65536) Param"}, {"sha": "7f1231303bfc32ce7e366bded88fff1c34ee2796", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1205a8cadb6bd41cdf5b13d7aca8fb44332002e5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1205a8cadb6bd41cdf5b13d7aca8fb44332002e5", "patch": "@@ -14417,6 +14417,14 @@ Use both Advanced SIMD and SVE.  Prefer SVE when the costs are deemed equal.\n @end table\n The default value is 0.\n \n+@item aarch64-loop-vect-issue-rate-niters\n+The tuning for some AArch64 CPUs tries to take both latencies and issue\n+rates into account when deciding whether a loop should be vectorized\n+using SVE, vectorized using Advanced SIMD, or not vectorized at all.\n+If this parameter is set to @var{n}, GCC will not use this heuristic\n+for loops that are known to execute in fewer than @var{n} Advanced\n+SIMD iterations.\n+\n @end table\n \n @end table"}]}