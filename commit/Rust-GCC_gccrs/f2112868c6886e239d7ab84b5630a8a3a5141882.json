{"sha": "f2112868c6886e239d7ab84b5630a8a3a5141882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIxMTI4NjhjNjg4NmUyMzlkN2FiODRiNTYzMGE4YTNhNTE0MTg4Mg==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-10-22T22:10:42Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-10-22T22:10:42Z"}, "message": "re PR fortran/31244 (data initialization with more than 2**32 elements)\n\n2007-10-22  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n        PR fortran/31244\n        * gfortran.h (gfc_data_value): Change repeat from unsigned int\n        to mpz_t.\n        * decl.c(top_val_list): Remove msg variable.  Use mpz_t for\n        repeat count.\n        * resolve.c (values):  Change left from unsigned int to mpz_t.\n        (next_data_value): Change for mpz_t.\n        (check_data_variable): Change ??? to FIXME in a comment.  Use\n        \"mpz_t left\".\n        (resolve_data ): Use \"mpz_t left\".\n\nFrom-SVN: r129561", "tree": {"sha": "07dcd02cc9f258d2c47f0adb6d9278360de95d38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07dcd02cc9f258d2c47f0adb6d9278360de95d38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2112868c6886e239d7ab84b5630a8a3a5141882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2112868c6886e239d7ab84b5630a8a3a5141882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2112868c6886e239d7ab84b5630a8a3a5141882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2112868c6886e239d7ab84b5630a8a3a5141882/comments", "author": null, "committer": null, "parents": [{"sha": "61c9bbb782d2542c93e5675e113177e6253f4dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61c9bbb782d2542c93e5675e113177e6253f4dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61c9bbb782d2542c93e5675e113177e6253f4dd7"}], "stats": {"total": 60, "additions": 36, "deletions": 24}, "files": [{"sha": "a53692907379b6186e343dc7ab48da47e7baea78", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f2112868c6886e239d7ab84b5630a8a3a5141882", "patch": "@@ -1,3 +1,16 @@\n+2007-10-22  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/31244\n+\t* gfortran.h (gfc_data_value): Change repeat from unsigned int\n+\tto mpz_t.\n+\t* decl.c(top_val_list): Remove msg variable.  Use mpz_t for\n+\trepeat count.\n+\t* resolve.c (values):  Change left from unsigned int to mpz_t.\n+\t(next_data_value): Change for mpz_t.\n+\t(check_data_variable): Change ??? to FIXME in a comment.  Use\n+\t\"mpz_t left\".\n+\t(resolve_data ): Use \"mpz_t left\".\n+\n 2007-10-21  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33749"}, {"sha": "44bd695d46ab7f7934c1db4c09c00ed7664c77ca", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f2112868c6886e239d7ab84b5630a8a3a5141882", "patch": "@@ -383,7 +383,6 @@ top_val_list (gfc_data *data)\n {\n   gfc_data_value *new, *tail;\n   gfc_expr *expr;\n-  const char *msg;\n   match m;\n \n   tail = NULL;\n@@ -397,6 +396,7 @@ top_val_list (gfc_data *data)\n \treturn MATCH_ERROR;\n \n       new = gfc_get_data_value ();\n+      mpz_init (new->repeat);\n \n       if (tail == NULL)\n \tdata->value = new;\n@@ -408,19 +408,13 @@ top_val_list (gfc_data *data)\n       if (expr->ts.type != BT_INTEGER || gfc_match_char ('*') != MATCH_YES)\n \t{\n \t  tail->expr = expr;\n-\t  tail->repeat = 1;\n+\t  mpz_set_ui (tail->repeat, 1);\n \t}\n       else\n \t{\n-\t  signed int tmp;\n-\t  msg = gfc_extract_int (expr, &tmp);\n+\t  if (expr->ts.type == BT_INTEGER)\n+\t    mpz_set (tail->repeat, expr->value.integer);\n \t  gfc_free_expr (expr);\n-\t  if (msg != NULL)\n-\t    {\n-\t      gfc_error (msg);\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  tail->repeat = tmp;\n \n \t  m = match_data_constant (&tail->expr);\n \t  if (m == MATCH_NO)"}, {"sha": "347cced8074af5adf02d0b2c0d3dfd5a9491f048", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f2112868c6886e239d7ab84b5630a8a3a5141882", "patch": "@@ -1776,7 +1776,7 @@ gfc_data_variable;\n \n typedef struct gfc_data_value\n {\n-  unsigned int repeat;\n+  mpz_t repeat;\n   gfc_expr *expr;\n   struct gfc_data_value *next;\n }"}, {"sha": "3c7893c04060b7b74a86e2badae3fab5d78c661b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2112868c6886e239d7ab84b5630a8a3a5141882/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f2112868c6886e239d7ab84b5630a8a3a5141882", "patch": "@@ -8002,7 +8002,7 @@ resolve_symbol (gfc_symbol *sym)\n static struct\n {\n   gfc_data_value *vnode;\n-  unsigned int left;\n+  mpz_t left;\n }\n values;\n \n@@ -8012,13 +8012,14 @@ values;\n static try\n next_data_value (void)\n {\n-  while (values.left == 0)\n+\n+  while (mpz_cmp_ui (values.left, 0) == 0)\n     {\n       if (values.vnode->next == NULL)\n \treturn FAILURE;\n \n       values.vnode = values.vnode->next;\n-      values.left = values.vnode->repeat;\n+      mpz_set (values.left, values.vnode->repeat);\n     }\n \n   return SUCCESS;\n@@ -8121,23 +8122,23 @@ check_data_variable (gfc_data_variable *var, locus *where)\n       /* If we have more than one element left in the repeat count,\n \t and we have more than one element left in the target variable,\n \t then create a range assignment.  */\n-      /* ??? Only done for full arrays for now, since array sections\n+      /* FIXME: Only done for full arrays for now, since array sections\n \t seem tricky.  */\n       if (mark == AR_FULL && ref && ref->next == NULL\n-\t  && values.left > 1 && mpz_cmp_ui (size, 1) > 0)\n+\t  && mpz_cmp_ui (values.left, 1) > 0 && mpz_cmp_ui (size, 1) > 0)\n \t{\n \t  mpz_t range;\n \n-\t  if (mpz_cmp_ui (size, values.left) >= 0)\n+\t  if (mpz_cmp (size, values.left) >= 0)\n \t    {\n-\t      mpz_init_set_ui (range, values.left);\n-\t      mpz_sub_ui (size, size, values.left);\n-\t      values.left = 0;\n+\t      mpz_init_set (range, values.left);\n+\t      mpz_sub (size, size, values.left);\n+\t      mpz_set_ui (values.left, 0);\n \t    }\n \t  else\n \t    {\n \t      mpz_init_set (range, size);\n-\t      values.left -= mpz_get_ui (size);\n+\t      mpz_sub (values.left, values.left, size);\n \t      mpz_set_ui (size, 0);\n \t    }\n \n@@ -8151,7 +8152,7 @@ check_data_variable (gfc_data_variable *var, locus *where)\n       /* Assign initial value to symbol.  */\n       else\n \t{\n-\t  values.left -= 1;\n+\t  mpz_sub_ui (values.left, values.left, 1);\n \t  mpz_sub_ui (size, size, 1);\n \n \t  t = gfc_assign_data_value (var->expr, values.vnode->expr, offset);\n@@ -8324,13 +8325,17 @@ resolve_data_variables (gfc_data_variable *d)\n    variables list, expanding iterators and such.  */\n \n static void\n-resolve_data (gfc_data * d)\n+resolve_data (gfc_data *d)\n {\n+\n   if (resolve_data_variables (d->var) == FAILURE)\n     return;\n \n   values.vnode = d->value;\n-  values.left = (d->value == NULL) ? 0 : d->value->repeat;\n+  if (d->value == NULL)\n+    mpz_set_ui (values.left, 0);\n+  else\n+    mpz_set (values.left, d->value->repeat);\n \n   if (traverse_data_var (d->var, &d->where) == FAILURE)\n     return;"}]}