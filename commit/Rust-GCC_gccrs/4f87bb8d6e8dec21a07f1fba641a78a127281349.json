{"sha": "4f87bb8d6e8dec21a07f1fba641a78a127281349", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY4N2JiOGQ2ZThkZWMyMWEwN2YxZmJhNjQxYTc4YTEyNzI4MTM0OQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-12-13T20:33:55Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-12-13T20:33:55Z"}, "message": "PR libstdc++/71044 optimize std::filesystem::path construction\n\nThis new implementation has a smaller footprint than the previous\nimplementation, due to replacing std::vector<_Cmpt> with a custom pimpl\ntype that only needs a single pointer. The _M_type enumeration is also\ncombined with the pimpl type, by using a tagged pointer, reducing\nsizeof(path) further still.\n\nConstruction and modification of paths is now done more efficiently, by\nsplitting the input into a stack-based buffer of string_view objects\ninstead of a dynamically-allocated vector containing strings. Once the\nfinal size is known only a single allocation is needed to reserve space\nfor it.  The append and concat operations no longer require constructing\ntemporary path objects, nor re-parsing the entire native pathname.\n\nThis results in algorithmic improvements to path construction, and\nworking with large paths is much faster.\n\n\tPR libstdc++/71044\n\t* include/bits/fs_path.h (path::path(path&&)): Add noexcept when\n\tappropriate. Move _M_cmpts instead of reparsing the native pathname.\n\t(path::operator=(const path&)): Do not define as defaulted.\n\t(path::operator/=, path::append): Call _M_append.\n\t(path::concat): Call _M_concat.\n\t(path::path(string_type, _Type): Change type of first parameter to\n\tbasic_string_view<value_type>.\n\t(path::_M_append(basic_string_view<value_type>)): New member function.\n\t(path::_M_concat(basic_string_view<value_type>)): New member function.\n\t(_S_convert(value_type*, __null_terminated)): Return string view.\n\t(_S_convert(const value_type*, __null_terminated)): Return string view.\n\t(_S_convert(value_type*, value_type*))\n\t(_S_convert(const value_type*, const value_type*)): Add overloads for\n\tpairs of pointers.\n\t(_S_convert(_InputIterator, __null_terminated)): Construct string_type\n\texplicitly, for cases where _S_convert returns a string view.\n\t(path::_S_is_dir_sep): Replace with non-member is_dir_sep.\n\t(path::_M_trim, path::_M_add_root_name, path::_M_add_root_dir)\n\t(path::_M_add_filename): Remove.\n\t(path::_M_type()): New member function to replace _M_type data member.\n\t(path::_List): Define new struct type instead of using std::vector.\n\t(path::_Cmpt::_Cmpt(string_type, _Type, size_t)): Change type of\n\tfirst parameter to basic_string_view<value_type>.\n\t(path::operator+=(const path&)): Do not define inline.\n\t(path::operator+=(const string_type&)): Call _M_concat.\n\t(path::operator+=(const value_type*)): Likewise.\n\t(path::operator+=(value_type)): Likewise.\n\t(path::operator+=(basic_string_view<value_type>)): Likewise.\n\t(path::operator/=(const path&)): Do not define inline.\n\t(path::_M_append(path)): Remove.\n\t* python/libstdcxx/v6/printers.py (StdPathPrinter): New printer that\n\tunderstands the new path::_List type.\n\t* src/filesystem/std-path.cc (is_dir_sep): New function to replace\n\tpath::_S_is_dir_sep.\n\t(path::_Parser): New helper class to parse strings as paths.\n\t(path::_List::_Impl): Define container type for path components.\n\t(path::_List): Define members.\n\t(path::operator=(const path&)): Define explicitly, to provide the\n\tstrong exception safety guarantee.\n\t(path::operator/=(const path&)): Implement manually by processing\n\teach component of the argument, rather than using _M_split_cmpts\n\tto parse the entire string again.\n\t(path::_M_append(string_type)): Likewise.\n\t(path::operator+=(const path&)): Likewise.\n\t(path::_M_concat(string_type)): Likewise.\n\t(path::remove_filename()): Perform trim directly instead of calling\n\t_M_trim().\n\t(path::_M_split_cmpts()): Rewrite in terms of _Parser class.\n\t(path::_M_trim, path::_M_add_root_name, path::_M_add_root_dir)\n\t(path::_M_add_filename): Remove.\n\t* testsuite/27_io/filesystem/path/append/source.cc: Test appending a\n\tstring view that aliases the path.\n\ttestsuite/27_io/filesystem/path/concat/strings.cc: Test concatenating\n\ta string view that aliases the path.\n\nFrom-SVN: r267106", "tree": {"sha": "d38897ecb20141cf5a7c4fbf5cd5e446f41571b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d38897ecb20141cf5a7c4fbf5cd5e446f41571b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f87bb8d6e8dec21a07f1fba641a78a127281349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f87bb8d6e8dec21a07f1fba641a78a127281349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f87bb8d6e8dec21a07f1fba641a78a127281349", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f87bb8d6e8dec21a07f1fba641a78a127281349/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51beaeba8a619ac11fbc7fd26d7d82e298b81c49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51beaeba8a619ac11fbc7fd26d7d82e298b81c49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51beaeba8a619ac11fbc7fd26d7d82e298b81c49"}], "stats": {"total": 1705, "additions": 1461, "deletions": 244}, "files": [{"sha": "c1a25028f250cc0b7773a3ecc208913c2a00c2bb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -1,5 +1,61 @@\n 2018-12-13  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/71044\n+\t* include/bits/fs_path.h (path::path(path&&)): Add noexcept when\n+\tappropriate. Move _M_cmpts instead of reparsing the native pathname.\n+\t(path::operator=(const path&)): Do not define as defaulted.\n+\t(path::operator/=, path::append): Call _M_append.\n+\t(path::concat): Call _M_concat.\n+\t(path::path(string_type, _Type): Change type of first parameter to\n+\tbasic_string_view<value_type>.\n+\t(path::_M_append(basic_string_view<value_type>)): New member function.\n+\t(path::_M_concat(basic_string_view<value_type>)): New member function.\n+\t(_S_convert(value_type*, __null_terminated)): Return string view.\n+\t(_S_convert(const value_type*, __null_terminated)): Return string view.\n+\t(_S_convert(value_type*, value_type*))\n+\t(_S_convert(const value_type*, const value_type*)): Add overloads for\n+\tpairs of pointers.\n+\t(_S_convert(_InputIterator, __null_terminated)): Construct string_type\n+\texplicitly, for cases where _S_convert returns a string view.\n+\t(path::_S_is_dir_sep): Replace with non-member is_dir_sep.\n+\t(path::_M_trim, path::_M_add_root_name, path::_M_add_root_dir)\n+\t(path::_M_add_filename): Remove.\n+\t(path::_M_type()): New member function to replace _M_type data member.\n+\t(path::_List): Define new struct type instead of using std::vector.\n+\t(path::_Cmpt::_Cmpt(string_type, _Type, size_t)): Change type of\n+\tfirst parameter to basic_string_view<value_type>.\n+\t(path::operator+=(const path&)): Do not define inline.\n+\t(path::operator+=(const string_type&)): Call _M_concat.\n+\t(path::operator+=(const value_type*)): Likewise.\n+\t(path::operator+=(value_type)): Likewise.\n+\t(path::operator+=(basic_string_view<value_type>)): Likewise.\n+\t(path::operator/=(const path&)): Do not define inline.\n+\t(path::_M_append(path)): Remove.\n+\t* python/libstdcxx/v6/printers.py (StdPathPrinter): New printer that\n+\tunderstands the new path::_List type.\n+\t* src/filesystem/std-path.cc (is_dir_sep): New function to replace\n+\tpath::_S_is_dir_sep.\n+\t(path::_Parser): New helper class to parse strings as paths.\n+\t(path::_List::_Impl): Define container type for path components.\n+\t(path::_List): Define members.\n+\t(path::operator=(const path&)): Define explicitly, to provide the\n+\tstrong exception safety guarantee.\n+\t(path::operator/=(const path&)): Implement manually by processing\n+\teach component of the argument, rather than using _M_split_cmpts\n+\tto parse the entire string again.\n+\t(path::_M_append(string_type)): Likewise.\n+\t(path::operator+=(const path&)): Likewise.\n+\t(path::_M_concat(string_type)): Likewise.\n+\t(path::remove_filename()): Perform trim directly instead of calling\n+\t_M_trim().\n+\t(path::_M_split_cmpts()): Rewrite in terms of _Parser class.\n+\t(path::_M_trim, path::_M_add_root_name, path::_M_add_root_dir)\n+\t(path::_M_add_filename): Remove.\n+\t* testsuite/27_io/filesystem/path/append/source.cc: Test appending a\n+\tstring view that aliases the path.\n+\ttestsuite/27_io/filesystem/path/concat/strings.cc: Test concatenating\n+\ta string view that aliases the path.\n+\n \t* testsuite/27_io/filesystem/path/generation/proximate.cc: Use\n \tpreferred directory separators for normalized paths.\n \t* testsuite/27_io/filesystem/path/generation/relative.cc: Likewise."}, {"sha": "c69001bcc3c09c9bf8e7af37f49f1fd81705fb41", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 124, "deletions": 101, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -34,7 +34,6 @@\n \n #include <utility>\n #include <type_traits>\n-#include <vector>\n #include <locale>\n #include <iosfwd>\n #include <iomanip>\n@@ -45,6 +44,7 @@\n #include <bits/locale_conv.h>\n #include <ext/concurrence.h>\n #include <bits/shared_ptr.h>\n+#include <bits/unique_ptr.h>\n \n #if defined(_WIN32) && !defined(__CYGWIN__)\n # define _GLIBCXX_FILESYSTEM_IS_WINDOWS 1\n@@ -169,12 +169,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n     path(const path& __p) = default;\n \n-    path(path&& __p) noexcept\n-    : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)\n-    {\n-      _M_split_cmpts();\n-      __p.clear();\n-    }\n+    path(path&& __p)\n+#if _GLIBCXX_USE_CXX11_ABI || _GLIBCXX_FULLY_DYNAMIC_STRING == 0\n+      noexcept\n+#endif\n+    : _M_pathname(std::move(__p._M_pathname)),\n+      _M_cmpts(std::move(__p._M_cmpts))\n+    { __p.clear(); }\n \n     path(string_type&& __source, format = auto_format)\n     : _M_pathname(std::move(__source))\n@@ -213,8 +214,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n     // assignments\n \n-    path& operator=(const path& __p) = default;\n-    path& operator=(path&& __p) noexcept;\n+    path& operator=(const path&);\n+    path& operator=(path&&) noexcept;\n     path& operator=(string_type&& __source);\n     path& assign(string_type&& __source);\n \n@@ -240,17 +241,26 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     template <class _Source>\n       _Path<_Source>&\n       operator/=(_Source const& __source)\n-      { return _M_append(path(__source)); }\n+      {\n+\t_M_append(_S_convert(_S_range_begin(__source), _S_range_end(__source)));\n+\treturn *this;\n+      }\n \n     template<typename _Source>\n       _Path<_Source>&\n       append(_Source const& __source)\n-      { return _M_append(path(__source)); }\n+      {\n+\t_M_append(_S_convert(_S_range_begin(__source), _S_range_end(__source)));\n+\treturn *this;\n+      }\n \n     template<typename _InputIterator>\n       _Path<_InputIterator, _InputIterator>&\n       append(_InputIterator __first, _InputIterator __last)\n-      { return _M_append(path(__first, __last)); }\n+      {\n+\t_M_append(_S_convert(__first, __last));\n+\treturn *this;\n+      }\n \n     // concatenation\n \n@@ -271,12 +281,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     template<typename _Source>\n       _Path<_Source>&\n       concat(_Source const& __x)\n-      { return *this += _S_convert(_S_range_begin(__x), _S_range_end(__x)); }\n+      {\n+\t_M_concat(_S_convert(_S_range_begin(__x), _S_range_end(__x)));\n+\treturn *this;\n+      }\n \n     template<typename _InputIterator>\n       _Path<_InputIterator, _InputIterator>&\n       concat(_InputIterator __first, _InputIterator __last)\n-      { return *this += _S_convert(__first, __last); }\n+      {\n+\t_M_concat(_S_convert(__first, __last));\n+\treturn *this;\n+      }\n \n     // modifiers\n \n@@ -402,30 +418,41 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n   private:\n     enum class _Type : unsigned char {\n-\t_Multi, _Root_name, _Root_dir, _Filename\n+      _Multi = 0, _Root_name, _Root_dir, _Filename\n     };\n \n-    path(string_type __str, _Type __type) : _M_pathname(__str), _M_type(__type)\n+    path(basic_string_view<value_type> __str, _Type __type)\n+    : _M_pathname(__str)\n     {\n-      __glibcxx_assert(_M_type != _Type::_Multi);\n+      __glibcxx_assert(__type != _Type::_Multi);\n+      _M_cmpts.type(__type);\n     }\n \n     enum class _Split { _Stem, _Extension };\n \n-    path& _M_append(path __p);\n+    void _M_append(basic_string_view<value_type>);\n+    void _M_concat(basic_string_view<value_type>);\n \n     pair<const string_type*, size_t> _M_find_extension() const;\n \n     template<typename _CharT>\n       struct _Cvt;\n \n-    static string_type\n+    static basic_string_view<value_type>\n     _S_convert(value_type* __src, __null_terminated)\n-    { return string_type(__src); }\n+    { return __src; }\n \n-    static string_type\n+    static basic_string_view<value_type>\n     _S_convert(const value_type* __src, __null_terminated)\n-    { return string_type(__src); }\n+    { return __src; }\n+\n+    static basic_string_view<value_type>\n+    _S_convert(value_type* __first, value_type* __last)\n+    { return {__first, __last - __first}; }\n+\n+    static basic_string_view<value_type>\n+    _S_convert(const value_type* __first, const value_type* __last)\n+    { return {__first, __last - __first}; }\n \n     template<typename _Iter>\n       static string_type\n@@ -440,8 +467,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       static string_type\n       _S_convert(_InputIterator __src, __null_terminated)\n       {\n+\t// Read from iterator into basic_string until a null value is seen:\n \tauto __s = _S_string_from_iter(__src);\n-\treturn _S_convert(__s.c_str(), __s.c_str() + __s.size());\n+\t// Convert (if needed) from iterator's value type to path::value_type:\n+\treturn string_type(_S_convert(__s.data(), __s.data() + __s.size()));\n       }\n \n     static string_type\n@@ -469,27 +498,65 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       static basic_string<_CharT, _Traits, _Allocator>\n       _S_str_convert(const string_type&, const _Allocator& __a);\n \n-    bool _S_is_dir_sep(value_type __ch)\n-    {\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-      return __ch == L'/' || __ch == preferred_separator;\n-#else\n-      return __ch == '/';\n-#endif\n-    }\n-\n     void _M_split_cmpts();\n-    void _M_trim();\n-    void _M_add_root_name(size_t __n);\n-    void _M_add_root_dir(size_t __pos);\n-    void _M_add_filename(size_t __pos, size_t __n);\n+\n+    _Type _M_type() const noexcept { return _M_cmpts.type(); }\n \n     string_type _M_pathname;\n \n     struct _Cmpt;\n-    using _List = _GLIBCXX_STD_C::vector<_Cmpt>;\n-    _List _M_cmpts; // empty unless _M_type == _Type::_Multi\n-    _Type _M_type = _Type::_Filename;\n+\n+    struct _List\n+    {\n+      using value_type = _Cmpt;\n+      using iterator = value_type*;\n+      using const_iterator = const value_type*;\n+\n+      _List();\n+      _List(const _List&);\n+      _List(_List&&) = default;\n+      _List& operator=(const _List&);\n+      _List& operator=(_List&&) = default;\n+      ~_List() = default;\n+\n+      _Type type() const noexcept\n+      { return _Type{reinterpret_cast<uintptr_t>(_M_impl.get()) & 0x3}; }\n+\n+      void type(_Type) noexcept;\n+\n+      int size() const noexcept; // zero unless type() == _Type::_Multi\n+      bool empty() const noexcept; // true unless type() == _Type::_Multi\n+      void clear();\n+      void swap(_List& __l) noexcept { _M_impl.swap(__l._M_impl); }\n+      int capacity() const noexcept;\n+      void reserve(int, bool); ///< @pre type() == _Type::_Multi\n+\n+      // All the member functions below here have a precondition !empty()\n+      // (and they should only be called from within the library).\n+\n+      iterator begin();\n+      iterator end();\n+      const_iterator begin() const;\n+      const_iterator end() const;\n+\n+      value_type& front() noexcept;\n+      value_type& back() noexcept;\n+      const value_type& front() const noexcept;\n+      const value_type& back() const noexcept;\n+\n+      void erase(const_iterator);\n+      void erase(const_iterator, const_iterator);\n+\n+      struct _Impl;\n+      struct _Impl_deleter\n+      {\n+\tvoid operator()(_Impl*) const noexcept;\n+      };\n+      unique_ptr<_Impl, _Impl_deleter> _M_impl;\n+    };\n+    _List _M_cmpts;\n+\n+    struct _Parser;\n   };\n \n   inline void swap(path& __lhs, path& __rhs) noexcept { __lhs.swap(__rhs); }\n@@ -605,8 +672,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n   struct path::_Cmpt : path\n   {\n-    _Cmpt(string_type __s, _Type __t, size_t __pos)\n-      : path(std::move(__s), __t), _M_pos(__pos) { }\n+    _Cmpt(basic_string_view<value_type> __s, _Type __t, size_t __pos)\n+      : path(__s, __t), _M_pos(__pos) { }\n \n     _Cmpt() : _M_pos(-1) { }\n \n@@ -733,7 +800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   private:\n     friend class path;\n \n-    bool _M_is_multi() const { return _M_path->_M_type == _Type::_Multi; }\n+    bool _M_is_multi() const { return _M_path->_M_type() == _Type::_Multi; }\n \n     friend difference_type\n     __path_iter_distance(const iterator& __first, const iterator& __last)\n@@ -785,7 +852,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   {\n     _M_pathname = std::move(__p._M_pathname);\n     _M_cmpts = std::move(__p._M_cmpts);\n-    _M_type = __p._M_type;\n     __p.clear();\n     return *this;\n   }\n@@ -798,41 +864,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   path::assign(string_type&& __source)\n   { return *this = path(std::move(__source)); }\n \n-  inline path&\n-  path::operator+=(const path& __p)\n-  {\n-    return operator+=(__p.native());\n-  }\n-\n   inline path&\n   path::operator+=(const string_type& __x)\n   {\n-    _M_pathname += __x;\n-    _M_split_cmpts();\n+    _M_concat(__x);\n     return *this;\n   }\n \n   inline path&\n   path::operator+=(const value_type* __x)\n   {\n-    _M_pathname += __x;\n-    _M_split_cmpts();\n+    _M_concat(__x);\n     return *this;\n   }\n \n   inline path&\n   path::operator+=(value_type __x)\n   {\n-    _M_pathname += __x;\n-    _M_split_cmpts();\n+    _M_concat(basic_string_view<value_type>(&__x, 1));\n     return *this;\n   }\n \n   inline path&\n   path::operator+=(basic_string_view<value_type> __x)\n   {\n-    _M_pathname.append(__x.data(), __x.size());\n-    _M_split_cmpts();\n+    _M_concat(__x);\n     return *this;\n   }\n \n@@ -858,7 +914,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   {\n     _M_pathname.swap(__rhs._M_pathname);\n     _M_cmpts.swap(__rhs._M_cmpts);\n-    std::swap(_M_type, __rhs._M_type);\n   }\n \n   template<typename _CharT, typename _Traits, typename _Allocator>\n@@ -968,7 +1023,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #endif\n       string_type __str(__a);\n \n-      if (_M_type == _Type::_Root_dir)\n+      if (_M_type() == _Type::_Root_dir)\n \t__str.assign(1, __slash);\n       else\n \t{\n@@ -979,7 +1034,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t      if (__add_slash)\n \t\t__str += __slash;\n \t      __str += __elem._M_pathname;\n-\t      __add_slash = __elem._M_type == _Type::_Filename;\n+\t      __add_slash = __elem._M_type() == _Type::_Filename;\n \t    }\n \t}\n \n@@ -1026,14 +1081,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   {\n     if (empty())\n       return {};\n-    else if (_M_type == _Type::_Filename)\n+    else if (_M_type() == _Type::_Filename)\n       return *this;\n-    else if (_M_type == _Type::_Multi)\n+    else if (_M_type() == _Type::_Multi)\n       {\n \tif (_M_pathname.back() == preferred_separator)\n \t  return {};\n \tauto& __last = *--end();\n-\tif (__last._M_type == _Type::_Filename)\n+\tif (__last._M_type() == _Type::_Filename)\n \t  return __last;\n       }\n     return {};\n@@ -1084,56 +1139,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   inline path::iterator\n   path::begin() const\n   {\n-    if (_M_type == _Type::_Multi)\n+    if (_M_type() == _Type::_Multi)\n       return iterator(this, _M_cmpts.begin());\n     return iterator(this, empty());\n   }\n \n   inline path::iterator\n   path::end() const\n   {\n-    if (_M_type == _Type::_Multi)\n+    if (_M_type() == _Type::_Multi)\n       return iterator(this, _M_cmpts.end());\n     return iterator(this, true);\n   }\n \n-#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-  inline path& path::operator/=(const path& __p)\n-  {\n-    // Much simpler than the specification in the standard,\n-    // as any path with root-name or root-dir is absolute.\n-    if (__p.is_absolute())\n-      operator=(__p);\n-    else\n-      {\n-\tif (has_filename() || (_M_type == _Type::_Root_name))\n-\t  _M_pathname += preferred_separator;\n-\t_M_pathname += __p.native();\n-\t_M_split_cmpts();\n-      }\n-    return *this;\n-  }\n-#endif\n-\n-  inline path&\n-  path::_M_append(path __p)\n-  {\n-    if (__p.is_absolute())\n-      operator=(std::move(__p));\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-    else if (__p.has_root_name() && __p.root_name() != root_name())\n-      operator=(std::move(__p));\n-#endif\n-    else\n-      operator/=(const_cast<const path&>(__p));\n-    return *this;\n-  }\n-\n   inline path::iterator&\n   path::iterator::operator++()\n   {\n     __glibcxx_assert(_M_path != nullptr);\n-    if (_M_path->_M_type == _Type::_Multi)\n+    if (_M_path->_M_type() == _Type::_Multi)\n       {\n \t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.end());\n \t++_M_cur;\n@@ -1150,7 +1173,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   path::iterator::operator--()\n   {\n     __glibcxx_assert(_M_path != nullptr);\n-    if (_M_path->_M_type == _Type::_Multi)\n+    if (_M_path->_M_type() == _Type::_Multi)\n       {\n \t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.begin());\n \t--_M_cur;\n@@ -1167,7 +1190,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n   path::iterator::operator*() const\n   {\n     __glibcxx_assert(_M_path != nullptr);\n-    if (_M_path->_M_type == _Type::_Multi)\n+    if (_M_path->_M_type() == _Type::_Multi)\n       {\n \t__glibcxx_assert(_M_cur != _M_path->_M_cmpts.end());\n \treturn *_M_cur;\n@@ -1182,7 +1205,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       return false;\n     if (_M_path == nullptr)\n       return true;\n-    if (_M_path->_M_type == path::_Type::_Multi)\n+    if (_M_path->_M_type() == path::_Type::_Multi)\n       return _M_cur == __rhs._M_cur;\n     return _M_at_end == __rhs._M_at_end;\n   }"}, {"sha": "2baaf1e8b731002fa961b76fa91888d7262e1ba2", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -1244,6 +1244,77 @@ def __next__(self):\n     def children(self):\n         return self._iterator(self.val['_M_cmpts'])\n \n+class StdPathPrinter:\n+    \"Print a std::filesystem::path\"\n+\n+    def __init__ (self, typename, val):\n+        self.val = val\n+        self.typename = typename\n+        impl = self.val['_M_cmpts']['_M_impl']['_M_t']['_M_t']['_M_head_impl']\n+        self.type = impl.cast(gdb.lookup_type('uintptr_t')) & 3\n+        if self.type == 0:\n+            self.impl = impl\n+        else:\n+            self.impl = None\n+\n+    def _path_type(self):\n+        t = str(self.type.cast(gdb.lookup_type(self.typename + '::_Type')))\n+        if t[-9:] == '_Root_dir':\n+            return \"root-directory\"\n+        if t[-10:] == '_Root_name':\n+            return \"root-name\"\n+        return None\n+\n+    def to_string (self):\n+        path = \"%s\" % self.val ['_M_pathname']\n+        if self.type != 0:\n+            t = self._path_type()\n+            if t:\n+                path = '%s [%s]' % (path, t)\n+        return \"filesystem::path %s\" % path\n+\n+    class _iterator(Iterator):\n+        def __init__(self, impl, pathtype):\n+            if impl:\n+                # We can't access _Impl::_M_size because _Impl is incomplete\n+                # so cast to int* to access the _M_size member at offset zero,\n+                int_type = gdb.lookup_type('int')\n+                cmpt_type = gdb.lookup_type(pathtype+'::_Cmpt')\n+                char_type = gdb.lookup_type('char')\n+                impl = impl.cast(int_type.pointer())\n+                size = impl.dereference()\n+                #self.capacity = (impl + 1).dereference()\n+                if hasattr(gdb.Type, 'alignof'):\n+                    sizeof_Impl = max(2 * int_type.sizeof, cmpt_type.alignof)\n+                else:\n+                    sizeof_Impl = 2 * int_type.sizeof\n+                begin = impl.cast(char_type.pointer()) + sizeof_Impl\n+                self.item = begin.cast(cmpt_type.pointer())\n+                self.finish = self.item + size\n+                self.count = 0\n+            else:\n+                self.item = None\n+                self.finish = None\n+\n+        def __iter__(self):\n+            return self\n+\n+        def __next__(self):\n+            if self.item == self.finish:\n+                raise StopIteration\n+            item = self.item.dereference()\n+            count = self.count\n+            self.count = self.count + 1\n+            self.item = self.item + 1\n+            path = item['_M_pathname']\n+            t = StdPathPrinter(item.type.name, item)._path_type()\n+            if not t:\n+                t = count\n+            return ('[%s]' % t, path)\n+\n+    def children(self):\n+        return self._iterator(self.impl, self.typename)\n+\n \n class StdPairPrinter:\n     \"Print a std::pair object, with 'first' and 'second' as children\"\n@@ -1759,9 +1830,9 @@ def build_libstdcxx_dictionary ():\n     libstdcxx_printer.add_version('std::experimental::filesystem::v1::__cxx11::',\n                                   'path', StdExpPathPrinter)\n     libstdcxx_printer.add_version('std::filesystem::',\n-                                  'path', StdExpPathPrinter)\n+                                  'path', StdPathPrinter)\n     libstdcxx_printer.add_version('std::filesystem::__cxx11::',\n-                                  'path', StdExpPathPrinter)\n+                                  'path', StdPathPrinter)\n \n     # C++17 components\n     libstdcxx_printer.add_version('std::',"}, {"sha": "e9c78924b8e23b2a73bdd18aa7721303c686b1da", "filename": "libstdc++-v3/src/filesystem/std-path.cc", "status": "modified", "additions": 1152, "deletions": 141, "changes": 1293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ffilesystem%2Fstd-path.cc?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -27,19 +27,410 @@\n #endif\n \n #include <filesystem>\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-# include <algorithm>\n-#endif\n+#include <algorithm>\n+#include <bits/stl_uninitialized.h>\n \n namespace fs = std::filesystem;\n using fs::path;\n \n-constexpr path::value_type path::preferred_separator;\n+static inline bool is_dir_sep(path::value_type ch)\n+{\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    return ch == L'/' || ch == path::preferred_separator;\n+#else\n+    return ch == '/';\n+#endif\n+}\n+\n+struct path::_Parser\n+{\n+  using string_view_type = std::basic_string_view<value_type>;\n+\n+  struct cmpt\n+  {\n+    string_view_type str;\n+    _Type type = _Type::_Multi;\n+\n+    bool valid() const { return type != _Type::_Multi; }\n+  };\n+\n+  string_view_type input;\n+  string_view_type::size_type pos = 0;\n+  size_t origin;\n \n+  _Parser(string_view_type s, size_t o = 0) : input(s), origin(o) { }\n+\n+  pair<cmpt, cmpt> root_path() noexcept\n+  {\n+    pos = 0;\n+    pair<cmpt, cmpt> root;\n+\n+    const size_t len = input.size();\n+\n+    // look for root name or root directory\n+    if (is_dir_sep(input[0]))\n+      {\n+#ifdef __CYGWIN__\n+\t// look for root name, such as \"//foo\"\n+\tif (len > 2 && input[1] == input[0])\n+\t  {\n+\t    if (!is_dir_sep(input[2]))\n+\t      {\n+\t\t// got root name, find its end\n+\t\tpos = 3;\n+\t\twhile (pos < len && !is_dir_sep(input[pos]))\n+\t\t  ++pos;\n+\t\troot.first.str = input.substr(0, pos);\n+\t\troot.first.type = _Type::_Root_name;\n+\n+\t\tif (pos < len) // also got root directory\n+\t\t  {\n+\t\t    root.second.str = input.substr(pos, 1);\n+\t\t    root.second.type = _Type::_Root_dir;\n+\t\t    ++pos;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t// got something like \"///foo\" which is just a root directory\n+\t\t// composed of multiple redundant directory separators\n+\t\troot.first.str = input.substr(0, 1);\n+\t\troot.first.type = _Type::_Root_dir;\n+\t\tpos += 2;\n+\t      }\n+\t  }\n+\telse\n+#endif\n+\t  {\n+\t    root.first.str = input.substr(0, 1);\n+\t    root.first.type = _Type::_Root_dir;\n+\t    ++pos;\n+\t  }\n+\t// Find the start of the first filename\n+\twhile (pos < len && is_dir_sep(input[pos]))\n+\t  ++pos;\n+      }\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    else if (len > 1 && input[1] == L':')\n+      {\n+\t// got disk designator\n+\troot.first.str = input.substr(0, 2);\n+\troot.first.type = _Type::_Root_name;\n+\tif (len > 2 && is_dir_sep(input[2]))\n+\t  {\n+\t    root.second.str = input.substr(2, 1);\n+\t    root.second.type = _Type::_Root_dir;\n+\t  }\n+\tpos = input.find_first_not_of(L\"/\\\\\", 2);\n+      }\n+#endif\n+    return root;\n+  }\n+\n+  cmpt next() noexcept\n+  {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+    string_view_type sep = L\"/\\\\\";\n+#else\n+    char sep = '/';\n+#endif\n+\n+    cmpt f;\n+    pos = input.find_first_not_of(sep, pos);\n+    if (pos != input.npos)\n+      {\n+\tconst auto end = input.find_first_of(sep, pos);\n+\tf.str = input.substr(pos, end - pos);\n+\tf.type = _Type::_Filename;\n+\tpos = end;\n+      }\n+    return f;\n+  }\n+\n+  string_view_type::size_type\n+  offset(const cmpt& c) const noexcept\n+  { return origin + c.str.data() - input.data(); }\n+};\n+\n+struct path::_List::_Impl\n+{\n+  using value_type = _Cmpt;\n+\n+  _Impl(int cap) : _M_size(0), _M_capacity(cap) { }\n+\n+  alignas(value_type) int _M_size;\n+  int _M_capacity;\n+\n+  using iterator = value_type*;\n+  using const_iterator = const value_type*;\n+\n+  iterator begin() { return reinterpret_cast<value_type*>(this + 1); }\n+  iterator end() { return begin() + size(); }\n+\n+  const_iterator begin() const\n+  { return reinterpret_cast<const value_type*>(this + 1); }\n+  const_iterator end() const { return begin() + size(); }\n+\n+  const value_type& front() const { return *begin(); }\n+  const value_type& back() const { return end()[-1]; }\n+\n+  int size() const { return _M_size; }\n+  int capacity() const { return _M_capacity; }\n+  bool empty() const { return _M_size == 0; }\n+\n+  void clear() { std::destroy_n(begin(), _M_size); _M_size = 0; }\n+\n+  void erase(const_iterator cpos)\n+  {\n+    iterator pos = begin() + (cpos - begin());\n+    if (pos + 1 != end())\n+      std::move(pos + 1, end(), pos);\n+    pos->~_Cmpt();\n+    --_M_size;\n+  }\n+\n+  void erase(const_iterator cfirst, const_iterator clast)\n+  {\n+    iterator first = begin() + (cfirst - begin());\n+    iterator last = begin() + (clast - begin());\n+    if (last != end())\n+      std::move(last, end(), first);\n+    std::destroy(first + (end() - last), end());\n+    _M_size -= last - first;\n+  }\n+\n+  unique_ptr<_Impl, _Impl_deleter> copy() const\n+  {\n+    const auto n = size();\n+    void* p = ::operator new(sizeof(_Impl) + n * sizeof(value_type));\n+    unique_ptr<_Impl, _Impl_deleter> newptr(::new (p) _Impl{n});\n+    std::uninitialized_copy_n(begin(), n, newptr->begin());\n+    newptr->_M_size = n;\n+    return newptr;\n+  }\n+\n+  // Clear the lowest two bits from the pointer (i.e. remove the _Type value)\n+  static _Impl* notype(_Impl* p)\n+  {\n+    constexpr uintptr_t mask = ~(uintptr_t)0x3;\n+    return reinterpret_cast<_Impl*>(reinterpret_cast<uintptr_t>(p) & mask);\n+  }\n+};\n+\n+void path::_List::_Impl_deleter::operator()(_Impl* p) const noexcept\n+{\n+  p = _Impl::notype(p);\n+  if (p)\n+    {\n+      __glibcxx_assert(p->_M_size <= p->_M_capacity);\n+      p->clear();\n+      ::operator delete(p, sizeof(*p) + p->_M_capacity * sizeof(value_type));\n+    }\n+}\n+\n+path::_List::_List() : _M_impl(reinterpret_cast<_Impl*>(_Type::_Filename)) { }\n+\n+path::_List::_List(const _List& other)\n+{\n+  if (!other.empty())\n+    _M_impl = other._M_impl->copy();\n+  else\n+    type(other.type());\n+}\n+\n+path::_List&\n+path::_List::operator=(const _List& other)\n+{\n+  if (!other.empty())\n+    {\n+      // copy in-place if there is capacity\n+      const int newsize = other._M_impl->size();\n+      auto impl = _Impl::notype(_M_impl.get());\n+      if (impl && impl->capacity() >= newsize)\n+\t{\n+\t  const int oldsize = impl->_M_size;\n+\t  auto to = impl->begin();\n+\t  auto from = other._M_impl->begin();\n+\t  const int minsize = std::min(newsize, oldsize);\n+\t  for (int i = 0; i < minsize; ++i)\n+\t    to[i]._M_pathname.reserve(from[i]._M_pathname.length());\n+\t  if (newsize > oldsize)\n+\t    {\n+\t      std::uninitialized_copy_n(to + oldsize, newsize - oldsize,\n+\t\t\t\t\tfrom + oldsize);\n+\t      impl->_M_size = newsize;\n+\t    }\n+\t  else if (newsize < oldsize)\n+\t    impl->erase(impl->begin() + newsize, impl->end());\n+\t  std::copy_n(from, minsize, to);\n+\t  type(_Type::_Multi);\n+\t}\n+      else\n+\t_M_impl = other._M_impl->copy();\n+    }\n+  else\n+    {\n+      clear();\n+      type(other.type());\n+    }\n+  return *this;\n+}\n+\n+inline void\n+path::_List::type(_Type t) noexcept\n+{\n+  auto val = reinterpret_cast<uintptr_t>(_Impl::notype(_M_impl.release()));\n+  _M_impl.reset(reinterpret_cast<_Impl*>(val | (unsigned char)t));\n+}\n+\n+inline int\n+path::_List::size() const noexcept\n+{\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->size();\n+  return 0;\n+}\n+\n+inline int\n+path::_List::capacity() const noexcept\n+{\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->capacity();\n+  return 0;\n+}\n+\n+inline bool\n+path::_List::empty() const noexcept\n+{\n+  return size() == 0;\n+}\n+\n+inline auto\n+path::_List::begin() noexcept\n+-> iterator\n+{\n+  __glibcxx_assert(!empty());\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->begin();\n+  return nullptr;\n+}\n+\n+inline auto\n+path::_List::end() noexcept\n+-> iterator\n+{\n+  __glibcxx_assert(!empty());\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->end();\n+  return nullptr;\n+}\n+\n+auto\n+path::_List::begin() const noexcept\n+-> const_iterator\n+{\n+  __glibcxx_assert(!empty());\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->begin();\n+  return nullptr;\n+}\n+\n+auto\n+path::_List::end() const noexcept\n+-> const_iterator\n+{\n+  __glibcxx_assert(!empty());\n+  if (auto* ptr = _Impl::notype(_M_impl.get()))\n+    return ptr->end();\n+  return nullptr;\n+}\n+\n+inline auto\n+path::_List::front() noexcept\n+-> value_type&\n+{\n+  return *_M_impl->begin();\n+}\n+\n+inline auto\n+path::_List::back() noexcept\n+-> value_type&\n+{\n+  return _M_impl->begin()[_M_impl->size() - 1];\n+}\n+\n+inline auto\n+path::_List::front() const noexcept\n+-> const value_type&\n+{\n+  return *_M_impl->begin();\n+}\n+\n+inline auto\n+path::_List::back() const noexcept\n+-> const value_type&\n+{\n+  return _M_impl->begin()[_M_impl->size() - 1];\n+}\n+\n+inline void\n+path::_List::erase(const_iterator pos)\n+{\n+  _M_impl->erase(pos);\n+}\n+\n+inline void\n+path::_List::erase(const_iterator first, const_iterator last)\n+{\n+  _M_impl->erase(first, last);\n+}\n+\n+inline void\n+path::_List::clear()\n+{\n+  if (auto ptr = _Impl::notype(_M_impl.get()))\n+    ptr->clear();\n+}\n+\n+void\n+path::_List::reserve(int newcap, bool exact = false)\n+{\n+  // __glibcxx_assert(type() == _Type::_Multi);\n+\n+  _Impl* curptr = _Impl::notype(_M_impl.get());\n+\n+  int curcap = curptr ? curptr->capacity() : 0;\n+\n+  if (curcap < newcap)\n+    {\n+      if (!exact && newcap < int(1.5 * curcap))\n+\tnewcap = 1.5 * curcap;\n+\n+      void* p = ::operator new(sizeof(_Impl) + newcap * sizeof(value_type));\n+      std::unique_ptr<_Impl, _Impl_deleter> newptr(::new(p) _Impl{newcap});\n+      const int cursize = curptr ? curptr->size() : 0;\n+      if (cursize)\n+\t{\n+\t  std::uninitialized_move_n(curptr->begin(), cursize, newptr->begin());\n+\t  newptr->_M_size = cursize;\n+\t}\n+      std::swap(newptr, _M_impl);\n+    }\n+}\n+\n+path&\n+path::operator=(const path& p)\n+{\n+  _M_pathname.reserve(p._M_pathname.length());\n+  _M_cmpts = p._M_cmpts;\t// might throw\n+  _M_pathname = p._M_pathname;\t// won't throw because we reserved enough space\n+  return *this;\n+}\n+\n path&\n path::operator/=(const path& __p)\n {\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n   if (__p.is_absolute()\n       || (__p.has_root_name() && __p.root_name() != root_name()))\n     return operator=(__p);\n@@ -50,10 +441,10 @@ path::operator/=(const path& __p)\n   if (__p.has_root_directory())\n     {\n       // Remove any root directory and relative path\n-      if (_M_type != _Type::_Root_name)\n+      if (_M_type() != _Type::_Root_name)\n \t{\n \t  if (!_M_cmpts.empty()\n-\t      && _M_cmpts.front()._M_type == _Type::_Root_name)\n+\t      && _M_cmpts.front()._M_type() == _Type::_Root_name)\n \t    __lhs = _M_cmpts.front()._M_pathname;\n \t  else\n \t    __lhs = {};\n@@ -64,14 +455,14 @@ path::operator/=(const path& __p)\n \n   basic_string_view<value_type> __rhs = __p._M_pathname;\n   // Omit any root-name from the generic format pathname:\n-  if (__p._M_type == _Type::_Root_name)\n+  if (__p._M_type() == _Type::_Root_name)\n     __rhs = {};\n   else if (!__p._M_cmpts.empty()\n-      && __p._M_cmpts.front()._M_type == _Type::_Root_name)\n+      && __p._M_cmpts.front()._M_type() == _Type::_Root_name)\n     __rhs.remove_prefix(__p._M_cmpts.front()._M_pathname.size());\n \n   const size_t __len = __lhs.size() + (int)__add_sep + __rhs.size();\n-  const size_t __maxcmpts = _M_cmpts.size() + __p._M_cmpts.size();\n+  const int __maxcmpts = _M_cmpts.size() + __p._M_cmpts.size();\n   if (_M_pathname.capacity() < __len || _M_cmpts.capacity() < __maxcmpts)\n     {\n       // Construct new path and swap (strong exception-safety guarantee).\n@@ -90,36 +481,688 @@ path::operator/=(const path& __p)\n       if (__add_sep)\n \t_M_pathname += preferred_separator;\n       _M_pathname += __rhs;\n-      _M_split_cmpts();\n+      __try\n+\t{\n+\t  _M_split_cmpts();\n+\t}\n+      __catch (...)\n+\t{\n+\t  __try\n+\t    {\n+\t      // try to restore original state\n+\t      _M_pathname.resize(__lhs.length());\n+\t      _M_split_cmpts();\n+\t    }\n+\t  __catch (...)\n+\t    {\n+\t      // give up, basic exception safety guarantee only:\n+\t      clear();\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n     }\n+#else\n+  // POSIX version is simpler than the specification in the standard,\n+  // as any path with root-name or root-dir is absolute.\n+\n+  if (__p.is_absolute() || this->empty())\n+    {\n+      return operator=(__p);\n+    }\n+\n+  using string_view_type = basic_string_view<value_type>;\n+\n+  string_view_type sep;\n+  if (has_filename())\n+    sep = { &preferred_separator, 1 };  // need to add a separator\n+#ifdef __CYGWIN__\n+  else if (_M_type() == _Type::_Root_name) // root-name with no root-dir\n+    sep = { &preferred_separator, 1 };  // need to add a separator\n+#endif\n+  else if (__p.empty())\n+    return *this;\t\t\t    // nothing to do\n+\n+  const auto orig_pathlen = _M_pathname.length();\n+  const auto orig_size = _M_cmpts.size();\n+  const auto orig_type = _M_type();\n+\n+  int capacity = 0;\n+  if (_M_type() == _Type::_Multi)\n+    capacity += _M_cmpts.size();\n+  else if (!empty())\n+    capacity += 1;\n+  if (__p._M_type() == _Type::_Multi)\n+    capacity += __p._M_cmpts.size();\n+  else if (!__p.empty() || !sep.empty())\n+    capacity += 1;\n+\n+  if (orig_type == _Type::_Multi)\n+    {\n+      const int curcap = _M_cmpts._M_impl->capacity();\n+      if (capacity > curcap)\n+\tcapacity = std::max(capacity, (int) (curcap * 1.5));\n+    }\n+\n+  _M_pathname.reserve(_M_pathname.length() + sep.length()\n+\t\t      + __p._M_pathname.length());\n+\n+  __try\n+    {\n+      _M_pathname += sep;\n+      const auto basepos = _M_pathname.length();\n+      _M_pathname += __p.native();\n+\n+      _M_cmpts.type(_Type::_Multi);\n+      _M_cmpts.reserve(capacity);\n+      _Cmpt* output = _M_cmpts._M_impl->end();\n+\n+      if (orig_type == _Type::_Multi)\n+\t{\n+\t  // Remove empty final component\n+\t  if (_M_cmpts._M_impl->back().empty())\n+\t    _M_cmpts._M_impl->erase(--output);\n+\t}\n+      else if (orig_pathlen != 0)\n+\t{\n+\t  // Create single component from original path\n+\t  string_view_type s(_M_pathname.data(), orig_pathlen);\n+\t  ::new(output++) _Cmpt(s, orig_type, 0);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+\n+      if (__p._M_type() == _Type::_Multi)\n+\t{\n+\t  for (auto& c : *__p._M_cmpts._M_impl)\n+\t    {\n+\t      ::new(output++) _Cmpt(c._M_pathname, _Type::_Filename,\n+\t\t\t\t    c._M_pos + basepos);\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t    }\n+\t}\n+      else if (!__p.empty() || !sep.empty())\n+\t{\n+\t  __glibcxx_assert(__p._M_type() == _Type::_Filename);\n+\t  ::new(output) _Cmpt(__p._M_pathname, __p._M_type(), basepos);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+    }\n+  __catch (...)\n+    {\n+      _M_pathname.resize(orig_pathlen);\n+      if (orig_type == _Type::_Multi)\n+\t_M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+      else\n+\t_M_cmpts.clear();\n+      _M_cmpts.type(orig_type);\n+      __throw_exception_again;\n+    }\n+#endif\n   return *this;\n }\n+\n+// [fs.path.append]\n+void\n+path::_M_append(basic_string_view<value_type> s)\n+{\n+  _Parser parser(s);\n+  auto root_path = parser.root_path();\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  bool is_absolute = root_path.second.type == _Type::_Root_dir;\n+  bool has_root_name = root_path.first.type == _Type::_Root_name;\n+  if (is_absolute || (has_root_name && root_path.first.str != root_name()))\n+    {\n+      operator=(s);\n+      return;\n+    }\n+\n+  basic_string_view<value_type> lhs = _M_pathname;\n+  bool add_sep = false;\n+\n+  bool has_root_directory = root_path.first.type == _Type::_Root_dir\n+    || root_path.second.type == _Type::_Root_dir;\n+\n+  if (has_root_directory)\n+    {\n+      // Remove any root directory and relative path\n+      if (_M_type() != _Type::_Root_name)\n+\t{\n+\t  if (!_M_cmpts.empty()\n+\t      && _M_cmpts.front()._M_type() == _Type::_Root_name)\n+\t    lhs = _M_cmpts.front()._M_pathname;\n+\t  else\n+\t    lhs = {};\n+\t}\n+    }\n+  else if (has_filename() || (!has_root_directory && is_absolute))\n+    add_sep = true;\n+\n+  basic_string_view<value_type> rhs = s;\n+  // Omit any root-name from the generic format pathname:\n+  if (has_root_name)\n+    rhs.remove_prefix(root_path.first.str.length());\n+\n+  // Construct new path and swap (strong exception-safety guarantee).\n+  string_type tmp;\n+  tmp.reserve(lhs.size() + (int)add_sep + rhs.size());\n+  tmp = lhs;\n+  if (add_sep)\n+    tmp += preferred_separator;\n+  tmp += rhs;\n+  path newp = std::move(tmp);\n+  swap(newp);\n+#else\n+\n+  bool is_absolute = root_path.first.type == _Type::_Root_dir\n+    || root_path.second.type == _Type::_Root_dir;\n+  if (is_absolute || this->empty())\n+    {\n+      operator=(s);\n+      return;\n+    }\n+\n+  const auto orig_pathlen = _M_pathname.length();\n+  const auto orig_size = _M_cmpts.size();\n+  const auto orig_type = _M_type();\n+\n+  basic_string_view<value_type> sep;\n+  if (has_filename())\n+    sep = { &preferred_separator, 1 };  // need to add a separator\n+#ifdef __CYGWIN__\n+  else if (_M_type() == _Type::_Root_name) // root-name with no root-dir\n+    sep = { &preferred_separator, 1 };  // need to add a separator\n+#endif\n+  else if (s.empty())\n+    return;\t\t\t    // nothing to do\n+\n+  // Copy the input into _M_pathname:\n+  _M_pathname += s;\n+  _M_pathname.insert(orig_pathlen, sep);\n+  // Update s to refer to the new copy (this ensures s is not a dangling\n+  // reference to deallocated characters, in the case where it was referring\n+  // into _M_pathname or a member of _M_cmpts).\n+  s = _M_pathname;\n+  const auto orig_pathname = s.substr(0, orig_pathlen);\n+  s.remove_prefix(orig_pathlen + sep.length());\n+\n+  parser.input = s; // reset parser to use updated string view\n+  const auto basepos = orig_pathname.length() + sep.length();\n+  parser.origin = basepos;\n+\n+  std::array<_Parser::cmpt, 64> buf;\n+  auto next = buf.begin();\n+\n+  int capacity = 0;\n+  if (_M_type() == _Type::_Multi)\n+    capacity += _M_cmpts.size();\n+  else if (!empty())\n+    capacity += 1;\n+\n+  auto cmpt = parser.next();\n+  if (cmpt.valid())\n+    {\n+      do\n+\t{\n+\t  *next++ = cmpt;\n+\t  cmpt = parser.next();\n+\t}\n+      while (cmpt.valid() && next != buf.end());\n+\n+      capacity += next - buf.begin();\n+      if (cmpt.valid()) // filled buffer before parsing whole input\n+\t{\n+\t  ++capacity;\n+\t  _Parser parser2(parser);\n+\t  while (parser2.next().valid())\n+\t    ++capacity;\n+\t}\n+\n+      if (s.back() == '/')\n+\t++capacity;\n+    }\n+  else if (!sep.empty())\n+    ++capacity;\n+\n+  __try\n+    {\n+      _M_cmpts.type(_Type::_Multi);\n+      _M_cmpts.reserve(capacity);\n+      _Cmpt* output = _M_cmpts._M_impl->end();\n+\n+      if (orig_type == _Type::_Multi)\n+\t{\n+\t  // Remove empty final component\n+\t  if (_M_cmpts._M_impl->back().empty())\n+\t    _M_cmpts._M_impl->erase(--output);\n+\t}\n+      else if (orig_pathlen != 0)\n+\t{\n+\t  // Create single component from original path\n+\t  ::new(output++) _Cmpt(orig_pathname, orig_type, 0);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+\n+      if (next != buf.begin())\n+\t{\n+\t  for (auto it = buf.begin(); it != next; ++it)\n+\t    {\n+\t      auto c = *it;\n+\t      ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t    }\n+\t  for (auto c = parser.next(); c.valid(); c = parser.next())\n+\t    {\n+\t      ::new(output++) _Cmpt(c.str, c.type, parser.offset(c));\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t    }\n+\n+\t  if (s.back() == '/')\n+\t    {\n+\t      ::new(output++) _Cmpt({}, _Type::_Filename, _M_pathname.length());\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t    }\n+\t}\n+      else if (!sep.empty())\n+\t{\n+\t  // Empty filename at the end:\n+\t  ::new(output) _Cmpt({}, _Type::_Filename, basepos);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+    }\n+  __catch (...)\n+    {\n+      _M_pathname.resize(orig_pathlen);\n+      if (orig_type == _Type::_Multi)\n+\t_M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+      else\n+\t_M_cmpts.clear();\n+      _M_cmpts.type(orig_type);\n+      __throw_exception_again;\n+    }\n+#endif\n+}\n+\n+// [fs.path.concat]\n+path&\n+path::operator+=(const path& p)\n+{\n+  if (p.empty())\n+    return *this;\n+\n+  if (this->empty())\n+    {\n+      operator=(p);\n+      return *this;\n+    }\n+\n+  const auto orig_pathlen = _M_pathname.length();\n+  const auto orig_type = _M_type();\n+  const auto orig_size = _M_cmpts.size();\n+  int orig_filenamelen = -1;\n+  basic_string_view<value_type> extra;\n+\n+  // Ensure that '_M_pathname += p._M_pathname' won't throw:\n+  _M_pathname.reserve(orig_pathlen + p._M_pathname.length());\n+\n+  _Cmpt c;\n+  _Cmpt* it = nullptr;\n+  _Cmpt* last = nullptr;\n+  if (p._M_type() == _Type::_Multi)\n+    {\n+      it = p._M_cmpts._M_impl->begin();\n+      last = p._M_cmpts._M_impl->end();\n+    }\n+  else\n+    {\n+      c = _Cmpt(p._M_pathname, p._M_type(), 0);\n+      it = &c;\n+      last = it + 1;\n+    }\n+\n+  if (it->_M_type() == _Type::_Filename)\n+    {\n+      // See if there's a filename or root-name at the end of the original path\n+      // that we can add to.\n+      if (_M_type() == _Type::_Filename)\n+\t{\n+\t  if (p._M_type() == _Type::_Filename)\n+\t    {\n+\t      // Simplest case where we just add the whole of p to the\n+\t      // original path.\n+\t      _M_pathname += p._M_pathname;\n+\t      return *this;\n+\t    }\n+\t  // Only the first component of s should be appended, do so below:\n+\t  extra = it->_M_pathname;\n+\t  ++it;\n+\t}\n+      else if (_M_type() == _Type::_Multi\n+\t  && _M_cmpts.back()._M_type() == _Type::_Filename)\n+\t{\n+\t  auto& back = _M_cmpts.back();\n+\t  if (p._M_type() == _Type::_Filename)\n+\t    {\n+\t      basic_string_view<value_type> s = p._M_pathname;\n+\t      back._M_pathname += s;\n+\t      _M_pathname += s;\n+\t      return *this;\n+\t    }\n+\n+\t  orig_filenamelen = back._M_pathname.length();\n+\t  back._M_pathname += it->_M_pathname;\n+\t  extra = it->_M_pathname;\n+\t  ++it;\n+\t}\n+    }\n+  else if (is_dir_sep(_M_pathname.back()) && _M_type() == _Type::_Multi\n+      && _M_cmpts.back()._M_type() == _Type::_Filename)\n+    orig_filenamelen = 0; // current path has empty filename at end\n+\n+  // TODO handle \"//rootname\" + \"foo\" case for Cygwin.\n+\n+  int capacity = 0;\n+  if (_M_type() == _Type::_Multi)\n+    capacity += _M_cmpts.size();\n+  else\n+    capacity += 1;\n+  if (p._M_type() == _Type::_Multi)\n+    capacity += p._M_cmpts.size();\n+  else\n+    capacity += 1;\n+\n+  __try\n+    {\n+      _M_cmpts.type(_Type::_Multi);\n+      _M_cmpts.reserve(capacity);\n+      _Cmpt* output = _M_cmpts._M_impl->end();\n+\n+      if (orig_type != _Type::_Multi)\n+\t{\n+\t  // Create single component from original path\n+\t  auto ptr = ::new(output++) _Cmpt({}, orig_type, 0);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t  ptr->_M_pathname.reserve(_M_pathname.length() + extra.length());\n+\t  ptr->_M_pathname = _M_pathname;\n+\t  ptr->_M_pathname += extra;\n+\t}\n+      else if (orig_filenamelen == 0 && it != last)\n+\t{\n+\t  // Remove empty filename at end of original path.\n+\t  _M_cmpts.erase(std::prev(output));\n+\t}\n+\n+      if (it != last && it->_M_type() == _Type::_Root_name)\n+\t{\n+\t  basic_string_view<value_type> s = it->_M_pathname;\n+\t  auto pos = orig_pathlen;\n+#ifdef __CYGWIN__\n+\t  s.remove_prefix(2);\n+\t  pos += 2;\n #endif\n+\t  ::new(output++) _Cmpt(s, _Type::_Filename, pos);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t  ++it;\n+\t}\n+\n+      if (it != last && it->_M_type() == _Type::_Root_dir)\n+\t{\n+\t  ++it;\n+\t  if (it == last)\n+\t    {\n+\t      // This root-dir becomes a trailing slash\n+\t      auto pos = _M_pathname.length() + p._M_pathname.length();\n+\t      ::new(output++) _Cmpt({}, _Type::_Filename, pos);\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t    }\n+\t}\n+\n+      while (it != last)\n+\t{\n+\t  auto pos = it->_M_pos + orig_pathlen;\n+\t  ::new(output++) _Cmpt(it->_M_pathname, _Type::_Filename, pos);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t  ++it;\n+\t}\n+\n+      _M_pathname += p._M_pathname;\n+\n+      if (is_dir_sep(_M_pathname.back()))\n+\t{\n+\t  ::new(output++) _Cmpt({}, _Type::_Filename, _M_pathname.length());\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+      }\n+  __catch (...)\n+    {\n+      _M_pathname.resize(orig_pathlen);\n+      if (orig_type == _Type::_Multi)\n+\t{\n+\t  if (_M_cmpts.size() > orig_size)\n+\t    _M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t  if (orig_filenamelen != -1)\n+\t    {\n+\t      if (_M_cmpts.size() == orig_size)\n+\t\t{\n+\t\t  auto& back = _M_cmpts.back();\n+\t\t  back._M_pathname.resize(orig_filenamelen);\n+\t\t  if (orig_filenamelen == 0)\n+\t\t    back._M_pos = orig_pathlen;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  auto output = _M_cmpts._M_impl->end();\n+\t\t  ::new(output) _Cmpt({}, _Type::_Filename, orig_pathlen);\n+\t\t  ++_M_cmpts._M_impl->_M_size;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t_M_cmpts.clear();\n+      _M_cmpts.type(orig_type);\n+      __throw_exception_again;\n+    }\n+  return *this;\n+}\n+\n+// [fs.path.concat]\n+void\n+path::_M_concat(basic_string_view<value_type> s)\n+{\n+  if (s.empty())\n+    return;\n+\n+  if (this->empty())\n+    {\n+      operator=(s);\n+      return;\n+    }\n+\n+  const auto orig_pathlen = _M_pathname.length();\n+  const auto orig_type = _M_type();\n+  const auto orig_size = _M_cmpts.size();\n+  int orig_filenamelen = -1;\n+  basic_string_view<value_type> extra;\n+\n+  // Copy the input into _M_pathname:\n+  _M_pathname += s;\n+  // Update s to refer to the new copy (this ensures s is not a dangling\n+  // reference to deallocated characters, in the case where it was referring\n+  // into _M_pathname or a member of _M_cmpts).\n+  s = _M_pathname;\n+  const auto orig_pathname = s.substr(0, orig_pathlen);\n+  s.remove_prefix(orig_pathlen);\n+\n+  _Parser parser(s, orig_pathlen);\n+  auto cmpt = parser.next();\n+\n+  if (cmpt.str.data() == s.data())\n+    {\n+      // See if there's a filename or root-name at the end of the original path\n+      // that we can add to.\n+      if (_M_type() == _Type::_Filename)\n+\t{\n+\t  if (cmpt.str.length() == s.length())\n+\t    {\n+\t      // Simplest case where we just need to add the whole of s\n+\t      // to the original path, which was already done above.\n+\t      return;\n+\t    }\n+\t  // Only the first component of s should be appended, do so below:\n+\t  extra = cmpt.str;\n+\t  cmpt = {}; // so we don't process it again\n+\t}\n+      else if (_M_type() == _Type::_Multi\n+\t  && _M_cmpts.back()._M_type() == _Type::_Filename)\n+\t{\n+\t  auto& back = _M_cmpts.back();\n+\t  if (cmpt.str.length() == s.length())\n+\t    {\n+\t      back._M_pathname += s;\n+\t      return;\n+\t    }\n+\n+\t  orig_filenamelen = back._M_pathname.length();\n+\t  back._M_pathname += cmpt.str;\n+\t  extra = cmpt.str;\n+\t  cmpt = {};\n+\t}\n+    }\n+  else if (is_dir_sep(orig_pathname.back()) && _M_type() == _Type::_Multi\n+      && _M_cmpts.back()._M_type() == _Type::_Filename)\n+    orig_filenamelen = 0; // original path had empty filename at end\n+\n+\n+  // TODO handle \"//rootname\" + \"foo\" case for Cygwin.\n+\n+  std::array<_Parser::cmpt, 64> buf;\n+  auto next = buf.begin();\n+\n+  if (cmpt.valid())\n+    *next++ = cmpt;\n+\n+  cmpt = parser.next();\n+  while (cmpt.valid() && next != buf.end())\n+    {\n+      *next++ = cmpt;\n+      cmpt = parser.next();\n+    }\n+\n+  int capacity = 0;\n+  if (_M_type() == _Type::_Multi)\n+    capacity += _M_cmpts.size();\n+  else\n+    capacity += 1;\n+\n+  capacity += next - buf.begin();\n+\n+  if (cmpt.valid()) // filled buffer before parsing whole input\n+    {\n+      ++capacity;\n+      _Parser parser2(parser);\n+      while (parser2.next().valid())\n+\t++capacity;\n+    }\n+  if (is_dir_sep(s.back()))\n+    ++capacity;\n+\n+  __try\n+    {\n+      _M_cmpts.type(_Type::_Multi);\n+      _M_cmpts.reserve(capacity);\n+      _Cmpt* output = _M_cmpts._M_impl->end();\n+      auto it = buf.begin();\n+\n+      if (orig_type != _Type::_Multi)\n+\t{\n+\t  // Create single component from original path\n+\t  auto p = ::new(output++) _Cmpt({}, orig_type, 0);\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t  p->_M_pathname.reserve(orig_pathname.length() + extra.length());\n+\t  p->_M_pathname = orig_pathname;\n+\t  p->_M_pathname += extra;\n+\t}\n+      else if (orig_filenamelen == 0)\n+\t{\n+\t  // Replace empty filename at end of original path.\n+\t  std::prev(output)->_M_pathname = it->str;\n+\t  std::prev(output)->_M_pos = parser.offset(*it);\n+\t  ++it;\n+\t}\n+\n+      while (it != next)\n+\t{\n+\t  ::new(output++) _Cmpt(it->str, _Type::_Filename, parser.offset(*it));\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t  ++it;\n+\t}\n+\n+      if (next == buf.end())\n+\t{\n+\t  while (cmpt.valid())\n+\t    {\n+\t      auto pos = parser.offset(cmpt);\n+\t      ::new(output++) _Cmpt(cmpt.str, _Type::_Filename, pos);\n+\t      ++_M_cmpts._M_impl->_M_size;\n+\t      cmpt = parser.next();\n+\t    }\n+\t}\n+\n+      if (is_dir_sep(s.back()))\n+\t{\n+\t  // Empty filename at the end:\n+\t  ::new(output++) _Cmpt({}, _Type::_Filename, _M_pathname.length());\n+\t  ++_M_cmpts._M_impl->_M_size;\n+\t}\n+    }\n+  __catch (...)\n+    {\n+      _M_pathname.resize(orig_pathlen);\n+      if (orig_type == _Type::_Multi)\n+\t{\n+\t  _M_cmpts.erase(_M_cmpts.begin() + orig_size, _M_cmpts.end());\n+\t  if (orig_filenamelen != -1)\n+\t    {\n+\t      auto& back = _M_cmpts.back();\n+\t      back._M_pathname.resize(orig_filenamelen);\n+\t      if (orig_filenamelen == 0)\n+\t\tback._M_pos = orig_pathlen;\n+\t    }\n+\t}\n+      else\n+\t_M_cmpts.clear();\n+      _M_cmpts.type(orig_type);\n+      __throw_exception_again;\n+    }\n+}\n \n path&\n path::remove_filename()\n {\n-  if (_M_type == _Type::_Multi)\n+  if (_M_type() == _Type::_Multi)\n     {\n       if (!_M_cmpts.empty())\n \t{\n \t  auto cmpt = std::prev(_M_cmpts.end());\n-\t  if (cmpt->_M_type == _Type::_Filename && !cmpt->empty())\n+\t  if (cmpt->_M_type() == _Type::_Filename && !cmpt->empty())\n \t    {\n \t      _M_pathname.erase(cmpt->_M_pos);\n \t      auto prev = std::prev(cmpt);\n-\t      if (prev->_M_type == _Type::_Root_dir\n-\t\t  || prev->_M_type == _Type::_Root_name)\n+\t      if (prev->_M_type() == _Type::_Root_dir\n+\t\t  || prev->_M_type() == _Type::_Root_name)\n \t\t{\n \t\t  _M_cmpts.erase(cmpt);\n-\t\t  _M_trim();\n+\t\t  if (_M_cmpts.size() == 1)\n+\t\t    {\n+\t\t      _M_cmpts.type(_M_cmpts.front()._M_type());\n+\t\t      _M_cmpts.clear();\n+\t\t    }\n \t\t}\n \t      else\n \t\tcmpt->clear();\n \t    }\n \t}\n     }\n-  else if (_M_type == _Type::_Filename)\n+  else if (_M_type() == _Type::_Filename)\n     clear();\n   return *this;\n }\n@@ -201,15 +1244,15 @@ path::compare(const path& p) const noexcept\n \n   if (empty() && p.empty())\n     return 0;\n-  else if (_M_type == _Type::_Multi && p._M_type == _Type::_Multi)\n+  else if (_M_type() == _Type::_Multi && p._M_type() == _Type::_Multi)\n     return do_compare(_M_cmpts.begin(), _M_cmpts.end(),\n \t\t      p._M_cmpts.begin(), p._M_cmpts.end());\n-  else if (_M_type == _Type::_Multi)\n+  else if (_M_type() == _Type::_Multi)\n     {\n       CmptRef c[1] = { { &p } };\n       return do_compare(_M_cmpts.begin(), _M_cmpts.end(), c, c+1);\n     }\n-  else if (p._M_type == _Type::_Multi)\n+  else if (p._M_type() == _Type::_Multi)\n     {\n       CmptRef c[1] = { { this } };\n       return do_compare(c, c+1, p._M_cmpts.begin(), p._M_cmpts.end());\n@@ -222,9 +1265,9 @@ path\n path::root_name() const\n {\n   path __ret;\n-  if (_M_type == _Type::_Root_name)\n+  if (_M_type() == _Type::_Root_name)\n     __ret = *this;\n-  else if (_M_cmpts.size() && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+  else if (_M_cmpts.size() && _M_cmpts.begin()->_M_type() == _Type::_Root_name)\n     __ret = *_M_cmpts.begin();\n   return __ret;\n }\n@@ -233,17 +1276,17 @@ path\n path::root_directory() const\n {\n   path __ret;\n-  if (_M_type == _Type::_Root_dir)\n+  if (_M_type() == _Type::_Root_dir)\n     {\n-      __ret._M_type = _Type::_Root_dir;\n+      __ret._M_cmpts.type(_Type::_Root_dir);\n       __ret._M_pathname.assign(1, preferred_separator);\n     }\n   else if (!_M_cmpts.empty())\n     {\n       auto __it = _M_cmpts.begin();\n-      if (__it->_M_type == _Type::_Root_name)\n+      if (__it->_M_type() == _Type::_Root_name)\n         ++__it;\n-      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+      if (__it != _M_cmpts.end() && __it->_M_type() == _Type::_Root_dir)\n         __ret = *__it;\n     }\n   return __ret;\n@@ -253,23 +1296,23 @@ path\n path::root_path() const\n {\n   path __ret;\n-  if (_M_type == _Type::_Root_name)\n+  if (_M_type() == _Type::_Root_name)\n     __ret = *this;\n-  else if (_M_type == _Type::_Root_dir)\n+  else if (_M_type() == _Type::_Root_dir)\n     {\n       __ret._M_pathname.assign(1, preferred_separator);\n-      __ret._M_type = _Type::_Root_dir;\n+      __ret._M_cmpts.type(_Type::_Root_dir);\n     }\n   else if (!_M_cmpts.empty())\n     {\n       auto __it = _M_cmpts.begin();\n-      if (__it->_M_type == _Type::_Root_name)\n+      if (__it->_M_type() == _Type::_Root_name)\n         {\n           __ret = *__it++;\n-          if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+          if (__it != _M_cmpts.end() && __it->_M_type() == _Type::_Root_dir)\n \t    __ret /= *__it;\n         }\n-      else if (__it->_M_type == _Type::_Root_dir)\n+      else if (__it->_M_type() == _Type::_Root_dir)\n         __ret = *__it;\n     }\n   return __ret;\n@@ -279,14 +1322,14 @@ path\n path::relative_path() const\n {\n   path __ret;\n-  if (_M_type == _Type::_Filename)\n+  if (_M_type() == _Type::_Filename)\n     __ret = *this;\n   else if (!_M_cmpts.empty())\n     {\n       auto __it = _M_cmpts.begin();\n-      if (__it->_M_type == _Type::_Root_name)\n+      if (__it->_M_type() == _Type::_Root_name)\n         ++__it;\n-      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+      if (__it != _M_cmpts.end() && __it->_M_type() == _Type::_Root_dir)\n         ++__it;\n       if (__it != _M_cmpts.end())\n         __ret.assign(_M_pathname.substr(__it->_M_pos));\n@@ -314,24 +1357,24 @@ path::parent_path() const\n bool\n path::has_root_name() const\n {\n-  if (_M_type == _Type::_Root_name)\n+  if (_M_type() == _Type::_Root_name)\n     return true;\n-  if (!_M_cmpts.empty() && _M_cmpts.begin()->_M_type == _Type::_Root_name)\n+  if (!_M_cmpts.empty() && _M_cmpts.begin()->_M_type() == _Type::_Root_name)\n     return true;\n   return false;\n }\n \n bool\n path::has_root_directory() const\n {\n-  if (_M_type == _Type::_Root_dir)\n+  if (_M_type() == _Type::_Root_dir)\n     return true;\n   if (!_M_cmpts.empty())\n     {\n       auto __it = _M_cmpts.begin();\n-      if (__it->_M_type == _Type::_Root_name)\n+      if (__it->_M_type() == _Type::_Root_name)\n         ++__it;\n-      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+      if (__it != _M_cmpts.end() && __it->_M_type() == _Type::_Root_dir)\n         return true;\n     }\n   return false;\n@@ -340,11 +1383,11 @@ path::has_root_directory() const\n bool\n path::has_root_path() const\n {\n-  if (_M_type == _Type::_Root_name || _M_type == _Type::_Root_dir)\n+  if (_M_type() == _Type::_Root_name || _M_type() == _Type::_Root_dir)\n     return true;\n   if (!_M_cmpts.empty())\n     {\n-      auto __type = _M_cmpts.front()._M_type;\n+      auto __type = _M_cmpts.front()._M_type();\n       if (__type == _Type::_Root_name || __type == _Type::_Root_dir)\n         return true;\n     }\n@@ -354,14 +1397,14 @@ path::has_root_path() const\n bool\n path::has_relative_path() const\n {\n-  if (_M_type == _Type::_Filename && !_M_pathname.empty())\n+  if (_M_type() == _Type::_Filename && !_M_pathname.empty())\n     return true;\n   if (!_M_cmpts.empty())\n     {\n       auto __it = _M_cmpts.begin();\n-      if (__it->_M_type == _Type::_Root_name)\n+      if (__it->_M_type() == _Type::_Root_name)\n         ++__it;\n-      if (__it != _M_cmpts.end() && __it->_M_type == _Type::_Root_dir)\n+      if (__it != _M_cmpts.end() && __it->_M_type() == _Type::_Root_dir)\n         ++__it;\n       if (__it != _M_cmpts.end() && !__it->_M_pathname.empty())\n         return true;\n@@ -383,9 +1426,9 @@ path::has_filename() const\n {\n   if (empty())\n     return false;\n-  if (_M_type == _Type::_Filename)\n+  if (_M_type() == _Type::_Filename)\n     return !_M_pathname.empty();\n-  if (_M_type == _Type::_Multi)\n+  if (_M_type() == _Type::_Multi)\n     {\n       if (_M_pathname.back() == preferred_separator)\n \treturn false;\n@@ -436,7 +1479,7 @@ path::lexically_normal() const\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n       // Replace each slash character in the root-name\n-      if (p._M_type == _Type::_Root_name || p._M_type == _Type::_Root_dir)\n+      if (p._M_type() == _Type::_Root_name || p._M_type() == _Type::_Root_dir)\n \t{\n \t  string_type s = p.native();\n \t  std::replace(s.begin(), s.end(), L'/', L'\\\\');\n@@ -477,7 +1520,7 @@ path::lexically_normal() const\n \t\t    {\n \t\t      ret._M_pathname.erase(elem._M_cur->_M_pos);\n \t\t      // Do we still have a trailing slash?\n-\t\t      if (std::prev(elem)->_M_type == _Type::_Filename)\n+\t\t      if (std::prev(elem)->_M_type() == _Type::_Filename)\n \t\t\tret._M_cmpts.erase(elem._M_cur);\n \t\t      else\n \t\t\tret._M_cmpts.erase(elem._M_cur, ret._M_cmpts.end());\n@@ -560,12 +1603,12 @@ path::_M_find_extension() const\n {\n   const string_type* s = nullptr;\n \n-  if (_M_type == _Type::_Filename)\n+  if (_M_type() == _Type::_Filename)\n     s = &_M_pathname;\n-  else if (_M_type == _Type::_Multi && !_M_cmpts.empty())\n+  else if (_M_type() == _Type::_Multi && !_M_cmpts.empty())\n     {\n       const auto& c = _M_cmpts.back();\n-      if (c._M_type == _Type::_Filename)\n+      if (c._M_type() == _Type::_Filename)\n \ts = &c._M_pathname;\n     }\n \n@@ -586,120 +1629,88 @@ void\n path::_M_split_cmpts()\n {\n   _M_cmpts.clear();\n+\n   if (_M_pathname.empty())\n     {\n-      _M_type = _Type::_Filename;\n+      _M_cmpts.type(_Type::_Filename);\n+      return;\n+    }\n+  if (_M_pathname.length() == 1 && _M_pathname[0] == preferred_separator)\n+    {\n+      _M_cmpts.type(_Type::_Root_dir);\n       return;\n     }\n-  _M_type = _Type::_Multi;\n \n-  size_t pos = 0;\n-  const size_t len = _M_pathname.size();\n+  _Parser parser(_M_pathname);\n+\n+  std::array<_Parser::cmpt, 64> buf;\n+  auto next = buf.begin();\n \n   // look for root name or root directory\n-  if (_S_is_dir_sep(_M_pathname[0]))\n+  auto root_path = parser.root_path();\n+  if (root_path.first.valid())\n     {\n-#ifdef __CYGWIN__\n-      // look for root name, such as \"//foo\"\n-      if (len > 2 && _M_pathname[1] == _M_pathname[0])\n+      *next++ = root_path.first;\n+      if (root_path.second.valid())\n+\t*next++ = root_path.second;\n+    }\n+\n+  bool got_at_least_one_filename = false;\n+\n+  auto cmpt = parser.next();\n+  while (cmpt.valid())\n+    {\n+      got_at_least_one_filename = true;\n+      do\n \t{\n-\t  if (!_S_is_dir_sep(_M_pathname[2]))\n-\t    {\n-\t      // got root name, find its end\n-\t      pos = 3;\n-\t      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))\n-\t\t++pos;\n-\t      _M_add_root_name(pos);\n-\t      if (pos < len) // also got root directory\n-\t\t_M_add_root_dir(pos);\n-\t    }\n-\t  else\n-\t    {\n-\t      // got something like \"///foo\" which is just a root directory\n-\t      // composed of multiple redundant directory separators\n-\t      _M_add_root_dir(0);\n-\t    }\n+\t  *next++ = cmpt;\n+\t  cmpt = parser.next();\n \t}\n-      else\n-#endif\n-        {\n-\t  // got root directory\n-\t  if (_M_pathname.find_first_not_of('/') == string_type::npos)\n+      while (cmpt.valid() && next != buf.end());\n+\n+      if (next == buf.end())\n+\t{\n+\t  _M_cmpts.type(_Type::_Multi);\n+\t  _M_cmpts.reserve(_M_cmpts.size() + buf.size());\n+\t  auto output = _M_cmpts._M_impl->end();\n+\t  for (auto& c : buf)\n \t    {\n-\t      // entire path is just slashes\n-\t      _M_type = _Type::_Root_dir;\n-\t      return;\n+\t      auto pos = c.str.data() - _M_pathname.data();\n+\t      ::new(output++) _Cmpt(c.str, c.type, pos);\n+\t      ++_M_cmpts._M_impl->_M_size;\n \t    }\n-\t  _M_add_root_dir(0);\n-\t  ++pos;\n+\t  next = buf.begin();\n \t}\n     }\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-  else if (len > 1 && _M_pathname[1] == L':')\n+\n+  // [fs.path.itr]/4\n+  // An empty element, if trailing non-root directory-separator present.\n+  if (got_at_least_one_filename && is_dir_sep(_M_pathname.back()))\n     {\n-      // got disk designator\n-      _M_add_root_name(2);\n-      if (len > 2 && _S_is_dir_sep(_M_pathname[2]))\n-\t_M_add_root_dir(2);\n-      pos = 2;\n+      next->str = { _M_pathname.data() + _M_pathname.length(), 0 };\n+      next->type = _Type::_Filename;\n+      ++next;\n     }\n-#endif\n \n-  size_t back = pos;\n-  while (pos < len)\n+  if (auto n = next - buf.begin())\n     {\n-      if (_S_is_dir_sep(_M_pathname[pos]))\n+      if (n == 1 && _M_cmpts.empty())\n \t{\n-\t  if (back != pos)\n-\t    _M_add_filename(back, pos - back);\n-\t  back = ++pos;\n+\t  _M_cmpts.type(buf.front().type);\n+\t  return;\n \t}\n-      else\n-\t++pos;\n-    }\n \n-  if (back != pos)\n-    _M_add_filename(back, pos - back);\n-  else if (_S_is_dir_sep(_M_pathname.back()))\n-    {\n-      // [fs.path.itr]/4\n-      // An empty element, if trailing non-root directory-separator present.\n-      if (_M_cmpts.back()._M_type == _Type::_Filename)\n+      _M_cmpts.type(_Type::_Multi);\n+      _M_cmpts.reserve(_M_cmpts.size() + n, true);\n+      auto output = _M_cmpts._M_impl->end();\n+      for (int i = 0; i < n; ++i)\n \t{\n-\t  pos = _M_pathname.size();\n-\t  _M_cmpts.emplace_back(string_type(), _Type::_Filename, pos);\n+\t  auto c = buf[i];\n+\t  auto pos = c.str.data() - _M_pathname.data();\n+\t  ::new(output++) _Cmpt(c.str, c.type, pos);\n+\t  ++_M_cmpts._M_impl->_M_size;\n \t}\n     }\n-\n-  _M_trim();\n-}\n-\n-void\n-path::_M_add_root_name(size_t n)\n-{\n-  _M_cmpts.emplace_back(_M_pathname.substr(0, n), _Type::_Root_name, 0);\n-}\n-\n-void\n-path::_M_add_root_dir(size_t pos)\n-{\n-  _M_cmpts.emplace_back(_M_pathname.substr(pos, 1), _Type::_Root_dir, pos);\n-}\n-\n-void\n-path::_M_add_filename(size_t pos, size_t n)\n-{\n-  _M_cmpts.emplace_back(_M_pathname.substr(pos, n), _Type::_Filename, pos);\n-}\n-\n-void\n-path::_M_trim()\n-{\n-  if (_M_cmpts.size() == 1)\n-    {\n-      _M_type = _M_cmpts.front()._M_type;\n-      _M_cmpts.clear();\n-    }\n }\n \n path::string_type"}, {"sha": "e440ca921c7955e598afc41daaf21c6bea1a20f3", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/append/source.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fsource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fsource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fappend%2Fsource.cc?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -112,11 +112,39 @@ test04()\n #endif\n }\n \n+void\n+test05()\n+{\n+  std::basic_string_view<path::value_type> s;\n+\n+  path p = \"0/1/2/3/4/5/6\";\n+  // The string_view aliases the path's internal string:\n+  s = p.native();\n+  // Append that string_view, which must work correctly even though the\n+  // internal string will be reallocated during the operation:\n+  p /= s;\n+  VERIFY( p.string() == \"0/1/2/3/4/5/6/0/1/2/3/4/5/6\" );\n+\n+  // Same again with a trailing slash:\n+  path p2 = \"0/1/2/3/4/5/\";\n+  s = p2.native();\n+  p2 /= s;\n+  VERIFY( p2.string() == \"0/1/2/3/4/5/0/1/2/3/4/5/\" );\n+\n+  // And aliasing one of the components of the path:\n+  path p3 = \"0/123456789/a\";\n+  path::iterator second = std::next(p3.begin());\n+  s = second->native();\n+  p3 /= s;\n+  VERIFY( p3.string() == \"0/123456789/a/123456789\" );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n+  test05();\n }"}, {"sha": "eea9b6dc69b925353b164654845a2a1b026498be", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/concat/strings.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f87bb8d6e8dec21a07f1fba641a78a127281349/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconcat%2Fstrings.cc?ref=4f87bb8d6e8dec21a07f1fba641a78a127281349", "patch": "@@ -57,8 +57,36 @@ test01()\n   VERIFY( p.filename().string() == file );\n }\n \n+void\n+test02()\n+{\n+  std::basic_string_view<path::value_type> s;\n+\n+  path p = \"0/1/2/3/4/5/6\";\n+  // The string_view aliases the path's internal string:\n+  s = p.native();\n+  // Append that string_view, which must work correctly even though the\n+  // internal string will be reallocated during the operation:\n+  p += s;\n+  VERIFY( p.string() == \"0/1/2/3/4/5/60/1/2/3/4/5/6\" );\n+\n+  // Same again with a trailing slash:\n+  path p2 = \"0/1/2/3/4/5/\";\n+  s = p2.native();\n+  p2 += s;\n+  VERIFY( p2.string() == \"0/1/2/3/4/5/0/1/2/3/4/5/\" );\n+\n+  // And aliasing one of the components of the path:\n+  path p3 = \"0/123456789\";\n+  path::iterator second = std::next(p3.begin());\n+  s = second->native();\n+  p3 += s;\n+  VERIFY( p3.string() == \"0/123456789123456789\" );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}]}