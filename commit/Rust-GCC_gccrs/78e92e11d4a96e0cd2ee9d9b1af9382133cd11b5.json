{"sha": "78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhlOTJlMTFkNGE5NmUwY2QyZWU5ZDliMWFmOTM4MjEzM2NkMTFiNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-22T13:57:26Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:57:26Z"}, "message": "[Ada] Spurious error on private subtype of derived access type\n\nThis patch fixes a spurious type error on a dynamic predicate on a\nsubtype of a private type whose full view is a derived access type.\nPrior to it, the base type of the subtype would appear to be the parent\ntype of the derived type instead of the derived type itself, leading to\nproblems downstream.\n\nThe following package must now compile quietly:\n\nwith S;\n\npackage T is\n   type B_Pointer is private;\n   Null_B_Pointer : constant B_Pointer;\n   function OK (B : B_Pointer) return Boolean is (B /= Null_B_Pointer);\n   subtype Valid_B_Pointer is B_Pointer\n     with Dynamic_Predicate => OK (Valid_B_Pointer);\nprivate\n   type B_Pointer is new S.A_Pointer;\n   Null_B_Pointer : constant B_Pointer := B_Pointer (S.Null_A_Pointer);\nend;\n\npackage S is\n   type A_Type is new Integer;\n   type A_Pointer is access A_Type;\n   Null_A_Pointer : constant A_Pointer := null;\nend;\n\nMoreover, it also plugs a loophole in the compiler whereby an\ninstantiation of a generic with a formal subprogram declaration nested\nin an enclosing generic package would be done even if there was a\nmismatch between an original and a derived types involved in the\ninstantiation.\n\nThe compiler must now gives the following error:\np.adb:11:43: no visible subprogram matches the specification for \"Action\"\non\n\nwith Q;\nwith R;\nwith G;\n\nprocedure P is\n\n  package My_G is new G (Q.T);\n\n  procedure Proc (Value : R.T) is null;\n\n  procedure Iter is new My_G.Iteration_G (Proc);\n\nbegin\n  null;\nend;\n\nwith R;\n\npackage Q is\n\n  type T is new R.T;\n\nend Q;\n\npackage R is\n\n  type T is private;\n\nprivate\n\n  type T is access Integer;\n\nend R;\n\ngeneric\n\n  type Value_T is private;\n\npackage G is\n\n  generic\n    with procedure Action (Value : Value_T);\n  procedure Iteration_G;\n\nend G;\n\npackage body G is\n\n  procedure Iteration_G is null;\n\nend G;\n\n2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch3.adb (Complete_Private_Subtype): Rework the setting of\n\tthe Etype of the full view for full base types that cannot\n\tcontain any discriminant.  Remove code and comment about it in\n\tthe main path.\n\nFrom-SVN: r273681", "tree": {"sha": "f747cf7968abf3ed4e0183587b21f50e8e10c4b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f747cf7968abf3ed4e0183587b21f50e8e10c4b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5/comments", "author": null, "committer": null, "parents": [{"sha": "a517030d8b76ae338c7e33253fcd0177979dde2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a517030d8b76ae338c7e33253fcd0177979dde2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a517030d8b76ae338c7e33253fcd0177979dde2b"}], "stats": {"total": 125, "additions": 68, "deletions": 57}, "files": [{"sha": "f715f7165b821541094d6e0e74d93c7b758dab8a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "patch": "@@ -1,3 +1,10 @@\n+2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch3.adb (Complete_Private_Subtype): Rework the setting of\n+\tthe Etype of the full view for full base types that cannot\n+\tcontain any discriminant.  Remove code and comment about it in\n+\tthe main path.\n+\n 2019-07-22  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Convert_Bound): Subsidiary of"}, {"sha": "a6df5e4636eb1b07ae8c6972d03b01fcbd20523f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=78e92e11d4a96e0cd2ee9d9b1af9382133cd11b5", "patch": "@@ -12351,84 +12351,88 @@ package body Sem_Ch3 is\n       --  Next_Entity field of full to ensure that the calls to Copy_Node do\n       --  not corrupt the entity chain.\n \n-      --  Note that the type of the full view is the same entity as the type\n-      --  of the partial view. In this fashion, the subtype has access to the\n-      --  correct view of the parent.\n-      --  The list below included access types, but this leads to several\n-      --  regressions. How should the base type of the full view be\n-      --  set consistently for subtypes completed by access types?\n-\n       Save_Next_Entity := Next_Entity (Full);\n       Save_Homonym     := Homonym (Priv);\n \n-      case Ekind (Full_Base) is\n-         when Class_Wide_Kind\n-            | Private_Kind\n-            | Protected_Kind\n-            | Task_Kind\n-            | E_Record_Subtype\n-            | E_Record_Type\n-         =>\n-            Copy_Node (Priv, Full);\n+      if Ekind (Full_Base) in Private_Kind\n+        or else Ekind (Full_Base) in Protected_Kind\n+        or else Ekind (Full_Base) in Record_Kind\n+        or else Ekind (Full_Base) in Task_Kind\n+      then\n+         Copy_Node (Priv, Full);\n \n-            Set_Has_Discriminants\n-                             (Full, Has_Discriminants (Full_Base));\n-            Set_Has_Unknown_Discriminants\n-                             (Full, Has_Unknown_Discriminants (Full_Base));\n-            Set_First_Entity (Full, First_Entity (Full_Base));\n-            Set_Last_Entity  (Full, Last_Entity (Full_Base));\n+         --  Note that the Etype of the full view is the same as the Etype of\n+         --  the partial view. In this fashion, the subtype has access to the\n+         --  correct view of the parent.\n \n-            --  If the underlying base type is constrained, we know that the\n-            --  full view of the subtype is constrained as well (the converse\n-            --  is not necessarily true).\n+         Set_Has_Discriminants (Full, Has_Discriminants (Full_Base));\n+         Set_Has_Unknown_Discriminants\n+                                 (Full, Has_Unknown_Discriminants (Full_Base));\n+         Set_First_Entity (Full, First_Entity (Full_Base));\n+         Set_Last_Entity  (Full, Last_Entity (Full_Base));\n \n-            if Is_Constrained (Full_Base) then\n-               Set_Is_Constrained (Full);\n-            end if;\n+         --  If the underlying base type is constrained, we know that the\n+         --  full view of the subtype is constrained as well (the converse\n+         --  is not necessarily true).\n \n-         when others =>\n-            Copy_Node (Full_Base, Full);\n+         if Is_Constrained (Full_Base) then\n+            Set_Is_Constrained (Full);\n+         end if;\n \n-            Set_Chars         (Full, Chars (Priv));\n-            Conditional_Delay (Full, Priv);\n-            Set_Sloc          (Full, Sloc (Priv));\n-      end case;\n+      else\n+         Copy_Node (Full_Base, Full);\n+\n+         --  The following subtlety with the Etype of the full view needs to be\n+         --  taken into account here. One could think that it must naturally be\n+         --  set to the base type of the full base:\n+\n+         --    Set_Etype (Full, Base_Type (Full_Base));\n+\n+         --  so that the full view becomes a subtype of the full base when the\n+         --  latter is a base type, which must for example happen when the full\n+         --  base is declared as derived type. That's also correct if the full\n+         --  base is declared as an array type, or a floating-point type, or a\n+         --  fixed-point type, or a signed integer type, as these declarations\n+         --  create an implicit base type and a first subtype so the Etype of\n+         --  the full views must be the implicit base type. But that's wrong\n+         --  if the full base is declared as an access type, or an enumeration\n+         --  type, or a modular integer type, as these declarations directly\n+         --  create a base type, i.e. with Etype pointing to itself. Moreover\n+         --  the full base being declared in the private part, i.e. when the\n+         --  views are swapped, the end result is that the Etype of the full\n+         --  base is set to its private view in this case and that we need to\n+         --  propagate this setting to the full view in order for the subtype\n+         --  to be compatible with the base type.\n+\n+         if Is_Base_Type (Full_Base)\n+           and then (Is_Derived_Type (Full_Base)\n+                      or else Ekind (Full_Base) in Array_Kind\n+                      or else Ekind (Full_Base) in Fixed_Point_Kind\n+                      or else Ekind (Full_Base) in Float_Kind\n+                      or else Ekind (Full_Base) in Signed_Integer_Kind)\n+         then\n+            Set_Etype (Full, Full_Base);\n+         end if;\n+\n+         Set_Chars         (Full, Chars (Priv));\n+         Set_Sloc          (Full, Sloc (Priv));\n+         Conditional_Delay (Full, Priv);\n+      end if;\n \n       Link_Entities                 (Full, Save_Next_Entity);\n       Set_Homonym                   (Full, Save_Homonym);\n       Set_Associated_Node_For_Itype (Full, Related_Nod);\n \n       --  Set common attributes for all subtypes: kind, convention, etc.\n \n-      Set_Ekind (Full, Subtype_Kind (Ekind (Full_Base)));\n-      Set_Convention (Full, Convention (Full_Base));\n-\n-      --  The Etype of the full view is inconsistent. Gigi needs to see the\n-      --  structural full view, which is what the current scheme gives: the\n-      --  Etype of the full view is the etype of the full base. However, if the\n-      --  full base is a derived type, the full view then looks like a subtype\n-      --  of the parent, not a subtype of the full base. If instead we write:\n-\n-      --       Set_Etype (Full, Full_Base);\n-\n-      --  then we get inconsistencies in the front-end (confusion between\n-      --  views). Several outstanding bugs are related to this ???\n-\n+      Set_Ekind            (Full, Subtype_Kind (Ekind (Full_Base)));\n+      Set_Convention       (Full, Convention (Full_Base));\n       Set_Is_First_Subtype (Full, False);\n       Set_Scope            (Full, Scope (Priv));\n       Set_Size_Info        (Full, Full_Base);\n       Set_RM_Size          (Full, RM_Size (Full_Base));\n       Set_Is_Itype         (Full);\n \n-      --  For the unusual case of a type with unknown discriminants whose\n-      --  completion is an array, use the proper full base.\n-\n-      if Is_Array_Type (Full_Base)\n-        and then Has_Unknown_Discriminants (Priv)\n-      then\n-         Set_Etype (Full, Full_Base);\n-      end if;\n-\n       --  A subtype of a private-type-without-discriminants, whose full-view\n       --  has discriminants with default expressions, is not constrained.\n "}]}