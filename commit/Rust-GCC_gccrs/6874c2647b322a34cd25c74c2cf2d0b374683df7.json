{"sha": "6874c2647b322a34cd25c74c2cf2d0b374683df7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg3NGMyNjQ3YjMyMmEzNGNkMjVjNzRjMmNmMmQwYjM3NDY4M2RmNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-10-31T09:52:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-10-31T09:52:55Z"}, "message": "[multiple changes]\n\nFri Oct 31 01:45:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n\n\t* libgcc2.c (L_eh): Define __eh_pc.\n\tReplace __eh_type with generic pointer __eh_info.\n\nFri Oct 31 01:47:57 1997  Jason Merrill  <jason@yorick.cygnus.com>\n\n\tSupport for nested exceptions.\n\t* tinfo2.cc (__is_pointer): New fn.\n\t* exception.cc (struct cp_eh_info): Define.\n\t(__cp_exception_info, __uncatch_exception): New fns.\n\t(__cp_push_exception, __cp_pop_exception): New fns.\n\t* except.c: Lose saved_throw_{type,value,cleanup,in_catch}.\n \tLose empty_fndecl.\n\t(init_exception_processing): Likewise.  __eh_pc is now external.\n\t(push_eh_info): New fn.\n\t(get_eh_{info,value,type,caught}): New fns.\n\t(push_eh_cleanup): Just call __cp_pop_exception.\n\t(expand_start_catch_block): Use push_eh_info.  Start the eh region\n\tsooner.\n\t(expand_end_eh_spec): Use push_eh_info.\n\t(expand_throw): Call __cp_push_exception to set up the exception info.\n\tJust pass the destructor or 0 as the cleanup.  Call __uncatch_exception\n\twhen we rethrow.\n\t(expand_builtin_throw): Don't refer to empty_fndecl.\n\nFrom-SVN: r16248", "tree": {"sha": "4369bf2e164b02228c2c4a5d1ae1ceb8ded7b16a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4369bf2e164b02228c2c4a5d1ae1ceb8ded7b16a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6874c2647b322a34cd25c74c2cf2d0b374683df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6874c2647b322a34cd25c74c2cf2d0b374683df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6874c2647b322a34cd25c74c2cf2d0b374683df7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6874c2647b322a34cd25c74c2cf2d0b374683df7/comments", "author": null, "committer": null, "parents": [{"sha": "59fe8c2c207c0e4309ee5c9734ed16bd096eeedd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59fe8c2c207c0e4309ee5c9734ed16bd096eeedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59fe8c2c207c0e4309ee5c9734ed16bd096eeedd"}], "stats": {"total": 482, "additions": 365, "deletions": 117}, "files": [{"sha": "540f17f3a111406c788a7aa2b3a5080878a85fbc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -1,3 +1,8 @@\n+Fri Oct 31 01:45:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* libgcc2.c (L_eh): Define __eh_pc.\n+\tReplace __eh_type with generic pointer __eh_info.\n+\n Fri Oct 31 00:34:55 1996  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* expr.c (expand_increment): When enqueing a postincrement for a MEM,"}, {"sha": "5ff066ab51bc8b277e135e538d86fedb99800e30", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -1,3 +1,24 @@\n+Fri Oct 31 01:47:57 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tSupport for nested exceptions.\n+\t* tinfo2.cc (__is_pointer): New fn.\n+\t* exception.cc (struct cp_eh_info): Define.\n+\t(__cp_exception_info, __uncatch_exception): New fns.\n+\t(__cp_push_exception, __cp_pop_exception): New fns.\n+\t* except.c: Lose saved_throw_{type,value,cleanup,in_catch}.\n+ \tLose empty_fndecl.\n+\t(init_exception_processing): Likewise.  __eh_pc is now external.\n+\t(push_eh_info): New fn.\n+\t(get_eh_{info,value,type,caught}): New fns.\n+\t(push_eh_cleanup): Just call __cp_pop_exception.\n+\t(expand_start_catch_block): Use push_eh_info.  Start the eh region\n+\tsooner.\n+\t(expand_end_eh_spec): Use push_eh_info.\n+\t(expand_throw): Call __cp_push_exception to set up the exception info.\n+\tJust pass the destructor or 0 as the cleanup.  Call __uncatch_exception\n+\twhen we rethrow.\n+\t(expand_builtin_throw): Don't refer to empty_fndecl.\n+\n Thu Oct 23 02:01:30 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (instantiate_decl): SET_DECL_IMPLICIT_INSTANTIATION on new decl."}, {"sha": "4d3622bde90f719ecd8fc6a191ffbf2ccf673e0f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 244, "deletions": 110, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -180,8 +180,6 @@ static tree Unwind;\n /* Holds a ready to emit call to \"terminate\".  */\n static tree TerminateFunctionCall;\n \n-static tree empty_fndecl;\n-\n /* ====================================================================== */\n \n \n@@ -196,14 +194,6 @@ static tree empty_fndecl;\n \n /* Holds the pc for doing \"throw\" */\n static tree saved_pc;\n-/* Holds the type of the thing being thrown.  */\n-static tree saved_throw_type;\n-/* Holds the value being thrown.  */\n-static tree saved_throw_value;\n-/* Holds the cleanup for the value being thrown.  */\n-static tree saved_cleanup;\n-/* Indicates if we are in a catch clause.  */\n-static tree saved_in_catch;\n \n extern int throw_used;\n extern rtx catch_clauses;\n@@ -290,12 +280,6 @@ init_exception_processing ()\n \t\t\t\t\t     tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t\tvoid_list_node)),\n \t\t\tNOT_BUILT_IN, NULL_PTR);\n-  empty_fndecl\n-    = builtin_function (\"__empty\",\n-\t\t\tvtype,\n-\t\t\tNOT_BUILT_IN, NULL_PTR);\n-  DECL_EXTERNAL (empty_fndecl) = 1;\n-  TREE_PUBLIC (empty_fndecl) = 1;\n \n   Unexpected = default_conversion (unexpected_fndecl);\n   Terminate = default_conversion (terminate_fndecl);\n@@ -310,47 +294,118 @@ init_exception_processing ()\n \n   pop_lang_context ();\n \n-  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n-  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_pc\"));\n-  d = start_decl (d, declspecs, 0);\n-  DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-  saved_pc = lookup_name (get_identifier (\"__eh_pc\"), 0);\n-\n-  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n-  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_type\"));\n-  d = start_decl (d, declspecs, 0);\n-  DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-  saved_throw_type = lookup_name (get_identifier (\"__eh_type\"), 0);\n-\n-  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n-  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_value\"));\n-  d = start_decl (d, declspecs, 0);\n-  DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-  saved_throw_value = lookup_name (get_identifier (\"__eh_value\"), 0);\n-\n-  declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n-  d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_cleanup\"));\n-  d = make_call_declarator (d, void_list_node, NULL_TREE, NULL_TREE);\n-  d = start_decl (d, declspecs, 0);\n-  DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-  saved_cleanup = lookup_name (get_identifier (\"__eh_cleanup\"), 0);\n-\n-  declspecs = tree_cons (NULL_TREE, get_identifier (\"bool\"), NULL_TREE);\n-  d = get_identifier (\"__eh_in_catch\");\n-  d = start_decl (d, declspecs, 0);\n-  DECL_COMMON (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-  saved_in_catch = lookup_name (get_identifier (\"__eh_in_catch\"), 0);\n+  d = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), ptr_type_node);\n+  TREE_PUBLIC (d) = 1;\n+  DECL_EXTERNAL (d) = 1;\n+  DECL_ARTIFICIAL (d) = 1;\n+  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n+  saved_pc = d;\n \n   /* If we use setjmp/longjmp EH, arrange for all cleanup actions to\n      be protected with __terminate.  */\n   protect_cleanup_actions_with_terminate = 1;\n }\n \n+/* Retrieve a pointer to the cp_eh_info node for the current exception\n+   and save it in the current binding level.  */\n+\n+static void\n+push_eh_info ()\n+{\n+  tree decl, fn;\n+\n+  fn = get_identifier (\"__cp_exception_info\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    {\n+      tree t, fields[5];\n+\n+      /* Declare cp_eh_info * __cp_exception_info (void),\n+\t as defined in exception.cc. */\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+\n+      /* struct cp_eh_info.  This must match exception.cc.  Note that this\n+\t type is not pushed anywhere.  */\n+      t = make_lang_type (RECORD_TYPE);\n+      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier (\"value\"),\n+\t\t\t\t\t ptr_type_node);\n+      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier (\"type\"),\n+\t\t\t\t\t ptr_type_node);\n+      fields[2] = build_lang_field_decl\n+\t(FIELD_DECL, get_identifier (\"cleanup\"),\n+\t build_pointer_type (build_function_type\n+\t\t\t     (ptr_type_node, tree_cons\n+\t\t\t      (NULL_TREE, ptr_type_node, void_list_node))));\n+      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier (\"caught\"),\n+\t\t\t\t\t boolean_type_node);\n+      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier (\"next\"),\n+\t\t\t\t\t build_pointer_type (t));\n+      finish_builtin_type (t, \"cp_eh_info\", fields, 5, ptr_type_node);\n+      t = build_pointer_type (t);\n+\n+      /* And now the function.  */\n+      fn = build_lang_decl (FUNCTION_DECL, fn,\n+\t\t\t    build_function_type (t, void_list_node));\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      assemble_external (fn);\n+      pop_obstacks ();\n+    }\n+  fn = build_function_call (fn, NULL_TREE);\n+\n+  /* Remember the pointer to the current exception info; it won't change\n+     during this catch block.  */\n+  decl = build_decl (VAR_DECL, get_identifier (\"__exception_info\"),\n+\t\t     TREE_TYPE (fn));\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_INITIAL (decl) = fn;\n+  decl = pushdecl (decl);\n+  cp_finish_decl (decl, fn, NULL_TREE, 0, 0);\n+}\n+\n+/* Returns a reference to the cp_eh_info node for the current exception.  */\n+\n+static tree\n+get_eh_info ()\n+{\n+  /* Look for the pointer pushed in push_eh_info.  */\n+  tree t = lookup_name (get_identifier (\"__exception_info\"), 0);\n+  return build_indirect_ref (t, NULL_PTR);\n+}\n+\n+/* Returns a reference to the current exception object.  */\n+\n+static tree\n+get_eh_value ()\n+{\n+  return build_component_ref (get_eh_info (), get_identifier (\"value\"),\n+\t\t\t      NULL_TREE, 0);\n+}\n+\n+/* Returns a reference to the current exception type.  */\n+\n+static tree\n+get_eh_type ()\n+{\n+  return build_component_ref (get_eh_info (), get_identifier (\"type\"),\n+\t\t\t      NULL_TREE, 0);\n+}\n+\n+/* Returns a reference to whether or not the current exception\n+   has been caught.  */\n+\n+static tree\n+get_eh_caught ()\n+{\n+  return build_component_ref (get_eh_info (), get_identifier (\"caught\"),\n+\t\t\t      NULL_TREE, 0);\n+}\n+\n /* Build a type value for use at runtime for a type that is matched\n    against by the exception handling system.  */\n \n@@ -396,19 +451,37 @@ build_eh_type (exp)\n   return build_eh_type_type (TREE_TYPE (exp));\n }\n \n-/* This routine creates the cleanup for the exception handling object.  */\n+/* This routine creates the cleanup for the current exception.  */\n \n static void\n push_eh_cleanup ()\n {\n   /* All cleanups must last longer than normal.  */\n   int yes = suspend_momentary ();\n+  tree fn, cleanup;\n+\n+  fn = get_identifier (\"__cp_pop_exception\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    {\n+      /* Declare void __cp_pop_exception (void), as defined in exception.cc. */\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      fn = build_lang_decl (FUNCTION_DECL, fn,\n+\t\t\t    build_function_type (void_type_node,\n+\t\t\t\t\t\t void_list_node));\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      assemble_external (fn);\n+      pop_obstacks ();\n+    }\n \n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n-  tree cleanup = build_function_call (saved_cleanup, NULL_TREE);\n-  cleanup = build (COMPOUND_EXPR, void_type_node, cleanup,\n-\t\t   build_modify_expr (saved_in_catch, NOP_EXPR,\n-\t\t\t\t      build_modify_expr (saved_throw_type, NOP_EXPR, integer_zero_node)));\n+  cleanup = build_function_call (fn, NULL_TREE);\n   expand_decl_cleanup (NULL_TREE, cleanup);\n \n   resume_momentary (yes);\n@@ -456,6 +529,23 @@ expand_start_catch_block (declspecs, declarator)\n \n   emit_line_note (input_filename, lineno);\n \n+  push_eh_info ();\n+\n+  /* If we are not doing setjmp/longjmp EH, because we are reordered\n+     out of line, we arrange to rethrow in the outer context so as to\n+     skip through the terminate region we are nested in, should we\n+     encounter an exception in the catch handler.\n+\n+     If we are doing setjmp/longjmp EH, we need to skip through the EH\n+     object cleanup region.  This isn't quite right, as we really need\n+     to clean the object up, but we cannot do that until we track\n+     multiple EH objects.\n+\n+     Matches the end in expand_end_catch_block.  */\n+  expand_eh_region_start ();\n+\n+  push_eh_cleanup ();\n+\n   if (declspecs)\n     {\n       tree exp;\n@@ -467,12 +557,6 @@ expand_start_catch_block (declspecs, declarator)\n       if (decl == NULL_TREE)\n \t{\n \t  error (\"invalid catch parameter\");\n-\n-\t  /* This is cheap, but we want to maintain the data\n-             structures.  */\n-\n-\t  expand_eh_region_start ();\n-\n \t  return;\n \t}\n \n@@ -486,11 +570,11 @@ expand_start_catch_block (declspecs, declarator)\n \t  && TREE_CODE (init_type) != POINTER_TYPE)\n \tinit_type = build_reference_type (init_type);\n \n-      exp = saved_throw_value;\n+      exp = get_eh_value ();\n       exp = expr_tree_cons (NULL_TREE,\n \t\t       build_eh_type_type (TREE_TYPE (decl)),\n \t\t       expr_tree_cons (NULL_TREE,\n-\t\t\t\t  saved_throw_type,\n+\t\t\t\t  get_eh_type (),\n \t\t\t\t  expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n       exp = build_function_call (CatchMatch, exp);\n       call_rtx = expand_call (exp, NULL_RTX, 0);\n@@ -505,8 +589,6 @@ expand_start_catch_block (declspecs, declarator)\n       /* if it returned FALSE, jump over the catch block, else fall into it */\n       emit_jump_insn (gen_beq (false_label_rtx));\n \n-      push_eh_cleanup ();\n-\n       init = convert_from_reference (save_expr (make_tree (init_type, call_rtx)));\n \n       /* Do we need the below two lines? */\n@@ -515,27 +597,9 @@ expand_start_catch_block (declspecs, declarator)\n       decl = pushdecl (decl);\n       cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n-  else\n-    {\n-      push_eh_cleanup ();\n \n-      /* Fall into the catch all section.  */\n-    }\n-\n-  emit_move_insn (DECL_RTL (saved_in_catch), const1_rtx);\n-\n-  /* If we are not doing setjmp/longjmp EH, because we are reordered\n-     out of line, we arrange to rethrow in the outer context so as to\n-     skip through the terminate region we are nested in, should we\n-     encounter an exception in the catch handler.\n-\n-     If we are doing setjmp/longjmp EH, we need to skip through the EH\n-     object cleanup region.  This isn't quite right, as we really need\n-     to clean the object up, but we cannot do that until we track\n-     multiple EH objects.\n-\n-     Matches the end in expand_end_catch_block.  */\n-  expand_eh_region_start ();\n+  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);\n+  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   emit_line_note (input_filename, lineno);\n }\n@@ -845,7 +909,8 @@ expand_builtin_throw ()\n #ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE\n   if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)\n     {\n-      t = make_tree (build_pointer_type (TREE_TYPE (empty_fndecl)),\n+      t = build_function_type (void_type_node, void_list_node);\n+      t = make_tree (build_pointer_type (t),\n \t\t     hard_function_value (ptr_type_node,\n \t\t\t\t\t  NULL_TREE));\n       t = build_function_call (t, NULL_TREE);\n@@ -965,6 +1030,9 @@ expand_end_eh_spec (raises)\n   emit_label (check);\n   emit_move_insn (flag, const1_rtx);\n   cont = gen_label_rtx ();\n+\n+  push_eh_info ();\n+\n   while (raises)\n     {\n       tree exp;\n@@ -973,11 +1041,11 @@ expand_end_eh_spec (raises)\n       if (match_type)\n \t{\n \t  /* check TREE_VALUE (raises) here */\n-\t  exp = saved_throw_value;\n+\t  exp = get_eh_value ();\n \t  exp = expr_tree_cons (NULL_TREE,\n \t\t\t   build_eh_type_type (match_type),\n \t\t\t   expr_tree_cons (NULL_TREE,\n-\t\t\t\t      saved_throw_type,\n+\t\t\t\t      get_eh_type (),\n \t\t\t\t      expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n \t  exp = build_function_call (CatchMatch, exp);\n \t  assemble_external (TREE_OPERAND (CatchMatch, 0));\n@@ -1123,19 +1191,35 @@ expand_throw (exp)\n      tree exp;\n {\n   rtx label;\n+  tree fn;\n+  static tree cleanup_type;\n \n   if (! doing_eh (1))\n     return;\n \n   if (exp)\n     {\n       tree throw_type;\n-      tree cleanup = empty_fndecl, e;\n+      tree cleanup = NULL_TREE, e;\n \n       /* throw expression */\n       /* First, decay it.  */\n       exp = decay_conversion (exp);\n \n+      /* cleanup_type is void (*)(void *, int),\n+\t the internal type of a destructor. */\n+      if (cleanup_type == NULL_TREE)\n+\t{\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  cleanup_type = build_pointer_type\n+\t    (build_function_type\n+\t     (void_type_node, tree_cons\n+\t      (NULL_TREE, ptr_type_node, tree_cons\n+\t       (NULL_TREE, integer_type_node, void_list_node))));\n+\t  pop_obstacks ();\n+\t}\n+\n       if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)\n \t{\n \t  throw_type = build_eh_type (exp);\n@@ -1156,33 +1240,83 @@ expand_throw (exp)\n \t  object = build_indirect_ref (exp, NULL_PTR);\n \t  throw_type = build_eh_type (object);\n \n-       \t  /* Build __tcf_ function. */\n-\t  cleanup = start_anon_func ();\n-\t  object = build_delete (TREE_TYPE (exp), saved_throw_value, \n-\t\t\t\t integer_three_node, LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n-\t  expand_expr (object, const0_rtx, VOIDmode, 0);\n-\t  end_anon_func ();\n-\t  mark_addressable (cleanup);\n+\t  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n+\t    {\n+\t      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n+\t\t\t\t\t dtor_identifier, 0);\n+\t      cleanup = TREE_VALUE (cleanup);\n+\t      mark_addressable (cleanup);\n+\t      /* Pretend it's a normal function.  */\n+\t      cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);\n+\t    }\n \t}\n \n-      if (cleanup == empty_fndecl)\n-\tassemble_external (empty_fndecl);\n-\t\n-      e = build_modify_expr (saved_throw_type, NOP_EXPR, throw_type);\n-      expand_expr (e, const0_rtx, VOIDmode, 0);\n+      if (cleanup == NULL_TREE)\n+\t{\n+\t  cleanup = build_int_2 (0, 0);\n+\t  TREE_TYPE (cleanup) = cleanup_type;\n+\t}\n \n-      e = build_modify_expr (saved_throw_value, NOP_EXPR, exp);\n-      e = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (e), e);\n-      expand_expr (e, const0_rtx, VOIDmode, 0);\n+      fn = get_identifier (\"__cp_push_exception\");\n+      if (IDENTIFIER_GLOBAL_VALUE (fn))\n+\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n+      else\n+\t{\n+\t  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),\n+\t     as defined in exception.cc.  */\n+\t  tree tmp;\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  tmp = tree_cons\n+\t    (NULL_TREE, ptr_type_node, tree_cons\n+\t     (NULL_TREE, ptr_type_node, tree_cons\n+\t      (NULL_TREE, cleanup_type, void_list_node)));\n+\t  fn = build_lang_decl (FUNCTION_DECL, fn,\n+\t\t\t\tbuild_function_type (void_type_node, tmp));\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  TREE_PUBLIC (fn) = 1;\n+\t  DECL_ARTIFICIAL (fn) = 1;\n+\t  pushdecl_top_level (fn);\n+\t  make_function_rtl (fn);\n+\t  assemble_external (fn);\n+\t  pop_obstacks ();\n+\t}\n \n-      cleanup = build_unary_op (ADDR_EXPR, cleanup, 0);\n-      cleanup = build_modify_expr (saved_cleanup, NOP_EXPR, cleanup);\n-      expand_expr (cleanup, const0_rtx, VOIDmode, 0);\n+      /* The throw expression is a full-expression.  */\n+      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n+      e = expr_tree_cons (NULL_TREE, exp, expr_tree_cons\n+\t\t\t  (NULL_TREE, throw_type, expr_tree_cons\n+\t\t\t   (NULL_TREE, cleanup, NULL_TREE)));\n+      e = build_function_call (fn, e);\n+      expand_expr (e, const0_rtx, VOIDmode, 0);\n     }\n   else\n     {\n-      /* rethrow current exception */\n-      /* This part is easy, as we don't have to do anything else.  */\n+      /* rethrow current exception; note that it's no longer caught.  */\n+\n+      tree fn = get_identifier (\"__uncatch_exception\");\n+      if (IDENTIFIER_GLOBAL_VALUE (fn))\n+\tfn = IDENTIFIER_GLOBAL_VALUE (fn);\n+      else\n+\t{\n+\t  /* Declare void __uncatch_exception (void)\n+\t     as defined in exception.cc. */\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  fn = build_lang_decl (FUNCTION_DECL, fn,\n+\t\t\t\tbuild_function_type (void_type_node,\n+\t\t\t\t\t\t     void_list_node));\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  TREE_PUBLIC (fn) = 1;\n+\t  DECL_ARTIFICIAL (fn) = 1;\n+\t  pushdecl_top_level (fn);\n+\t  make_function_rtl (fn);\n+\t  assemble_external (fn);\n+\t  pop_obstacks ();\n+\t}\n+\n+      exp = build_function_call (fn, NULL_TREE);\n+      expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (exceptions_via_longjmp)"}, {"sha": "4099d4776203097450099d3ae312f253b0b11d91", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 77, "deletions": 3, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -73,6 +73,79 @@ unexpected ()\n   __unexpected_func ();\n }\n \n+/* C++-specific state about the current exception.\n+   This must match init_exception_processing().  */\n+\n+struct cp_eh_info\n+{\n+  void *value;\n+  void *type;\n+  void (*cleanup)(void *, int);\n+  bool caught;\n+  cp_eh_info *next;\n+};\n+\n+/* Language-specific EH info pointer, defined in libgcc2.  */\n+\n+extern cp_eh_info *__eh_info;  // actually void*\n+\n+/* Is P the type_info node for a pointer of some kind?  */\n+\n+extern bool __is_pointer (void *);\n+\n+/* Compiler hook to return a pointer to the info for the current exception.\n+   Used by get_eh_info ().  */\n+\n+extern \"C\" cp_eh_info *\n+__cp_exception_info (void)\n+{\n+  return __eh_info;\n+}\n+\n+/* Compiler hook to push a new exception onto the stack.\n+   Used by expand_throw().  */\n+\n+extern \"C\" void\n+__cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n+{\n+  cp_eh_info *p = new cp_eh_info;\n+  p->value = value;\n+  p->type = type;\n+  p->cleanup = cleanup;\n+  p->caught = false;\n+  p->next = __eh_info;\n+  __eh_info = p;\n+}\n+\n+/* Compiler hook to pop an exception that has been finalized.  Used by\n+   push_eh_cleanup().  */\n+\n+extern \"C\" void\n+__cp_pop_exception (void)\n+{\n+  cp_eh_info *p = __eh_info;\n+\n+  if (p->cleanup)\n+    /* 3 is a magic value for destructors; see build_delete().  */\n+    p->cleanup (p->value, 3);\n+  else if (__is_pointer (p->type))\n+    /* do nothing; pointers are passed directly in p->value.  */;\n+  else\n+    delete p->value;\n+\n+  __eh_info = p->next;\n+  delete p;\n+}\n+\n+extern \"C\" void\n+__uncatch_exception (void)\n+{\n+  cp_eh_info *p = __cp_exception_info ();\n+  if (p)\n+    p->caught = false;\n+  /* otherwise __throw will call terminate(); don't crash here.  */\n+}\n+\n extern \"C\" void\n __throw_bad_cast (void)\n {\n@@ -91,12 +164,13 @@ __throw_bad_exception (void)\n   throw bad_exception ();\n }\n \n+/* Has the current exception been caught?  */\n+\n bool\n uncaught_exception ()\n {\n-  extern void *__eh_type;\n-  extern bool __eh_in_catch;\n-  return __eh_type && ! __eh_in_catch;\n+  cp_eh_info *p = __cp_exception_info ();\n+  return p && ! p->caught;\n }\n \n const char * exception::"}, {"sha": "128661c1cd2e69f46ae51f296441549faad2e494", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -258,6 +258,18 @@ __throw_type_match_rtti (void *catch_type_r, void *throw_type_r, void *objptr)\n   return new_objptr;\n }\n \n+/* Called from __cp_pop_exception.  Is P the type_info node for a pointer\n+   of some kind?  */\n+\n+bool\n+__is_pointer (void *p)\n+{\n+  const type_info *t = reinterpret_cast <const type_info *>(p);\n+  const __pointer_type_info *pt =\n+    dynamic_cast <const __pointer_type_info *> (t);\n+  return pt != 0;\n+}\n+\n extern \"C\" void\n __rtti_ptr (void *addr, const char *n, const type_info *ti)\n { new (addr) __pointer_type_info (n, *ti); }"}, {"sha": "6c34da7acf5284c6ef086edf83b204e93dec2514", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6874c2647b322a34cd25c74c2cf2d0b374683df7/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=6874c2647b322a34cd25c74c2cf2d0b374683df7", "patch": "@@ -3109,7 +3109,9 @@ int _exit_dummy_decl = 0;\t/* prevent compiler & linker warnings */\n \n /* Shared exception handling support routines.  */\n \n-extern void *__eh_type;\n+/* Language-specific information about the active exception(s).  If there\n+   are no active exceptions, it is set to 0.  */\n+void *__eh_info;\n \n void\n __default_terminate ()\n@@ -3224,7 +3226,7 @@ __sjthrow ()\n   /* We must call terminate if we try and rethrow an exception, when\n      there is no exception currently active and when there are no\n      handlers left.  */\n-  if (! __eh_type || (*dhc) == top_elt)\n+  if (! __eh_info || (*dhc) == top_elt)\n     __terminate ();\n     \n   /* Find the jmpbuf associated with the top element of the dynamic\n@@ -3307,7 +3309,7 @@ __sjpopnthrow ()\n /* This value identifies the place from which an exception is being\n    thrown.  */\n \n-extern void *__eh_pc;\n+void *__eh_pc;\n \n #ifdef EH_TABLE_LOOKUP\n \n@@ -3652,7 +3654,7 @@ __throw ()\n   /* This is required for C++ semantics.  We must call terminate if we\n      try and rethrow an exception, when there is no exception currently\n      active.  */\n-  if (! __eh_type)\n+  if (! __eh_info)\n     __terminate ();\n     \n   /* Start at our stack frame.  */"}]}