{"sha": "c51e31a06f2c740c55852a683aa7ffdc20417362", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxZTMxYTA2ZjJjNzQwYzU1ODUyYTY4M2FhN2ZmZGMyMDQxNzM2Mg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-10T02:15:33Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-11-21T21:20:16Z"}, "message": "c++: Extend -Wrange-loop-construct for binding-to-temp [PR94695]\n\nThis patch finishes the second half of -Wrange-loop-construct I promised\nto implement: it warns when a loop variable in a range-based for-loop is\ninitialized with a value of a different type resulting in a copy.  For\ninstance:\n\n  int arr[10];\n  for (const double &x : arr) { ... }\n\nwhere in every iteration we have to create and destroy a temporary value\nof type double, to which we bind the reference.  This could negatively\nimpact performance.\n\nAs per Clang, this doesn't warn when the range returns a copy, hence the\nglvalue_p check.\n\ngcc/ChangeLog:\n\n\tPR c++/94695\n\t* doc/invoke.texi: Update the -Wrange-loop-construct description.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94695\n\t* parser.c (warn_for_range_copy): Warn when the loop variable is\n\tinitialized with a value of a different type resulting in a copy.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94695\n\t* g++.dg/warn/Wrange-loop-construct2.C: New test.", "tree": {"sha": "8e9427d27fc773b8f550807538315fc9bc9e6160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e9427d27fc773b8f550807538315fc9bc9e6160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c51e31a06f2c740c55852a683aa7ffdc20417362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c51e31a06f2c740c55852a683aa7ffdc20417362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c51e31a06f2c740c55852a683aa7ffdc20417362", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c51e31a06f2c740c55852a683aa7ffdc20417362/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f20c42cc162ac3725584547ab4933bae4c78665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f20c42cc162ac3725584547ab4933bae4c78665", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f20c42cc162ac3725584547ab4933bae4c78665"}], "stats": {"total": 258, "additions": 254, "deletions": 4}, "files": [{"sha": "88021243ee4cd220440b710e2679b31402c8853e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c51e31a06f2c740c55852a683aa7ffdc20417362", "patch": "@@ -12679,8 +12679,15 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n \n      for (const auto &x : range)\n \n-   if this version doesn't make a copy.  DECL is the RANGE_DECL; EXPR is the\n-   *__for_begin expression.\n+   if this version doesn't make a copy.\n+\n+  This function also warns when the loop variable is initialized with\n+  a value of a different type resulting in a copy:\n+\n+     int arr[10];\n+     for (const double &x : arr)\n+\n+   DECL is the RANGE_DECL; EXPR is the *__for_begin expression.\n    This function is never called when processing_template_decl is on.  */\n \n static void\n@@ -12698,7 +12705,22 @@ warn_for_range_copy (tree decl, tree expr)\n \n   if (TYPE_REF_P (type))\n     {\n-      /* TODO: Implement reference warnings.  */\n+      if (glvalue_p (expr) && !ref_conv_binds_directly_p (type, expr))\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (loc, OPT_Wrange_loop_construct,\n+\t\t\t  \"loop variable %qD of type %qT binds to a temporary \"\n+\t\t\t  \"constructed from type %qT\", decl, type,\n+\t\t\t  TREE_TYPE (expr)))\n+\t    {\n+\t      tree ref = cp_build_qualified_type (TREE_TYPE (expr),\n+\t\t\t\t\t\t  TYPE_QUAL_CONST);\n+\t      ref = cp_build_reference_type (ref, /*rval*/false);\n+\t      inform (loc, \"use non-reference type %qT to make the copy \"\n+\t\t      \"explicit or %qT to prevent copying\",\n+\t\t      non_reference (type), ref);\n+\t    }\n+\t}\n       return;\n     }\n   else if (!CP_TYPE_CONST_P (type))"}, {"sha": "26372a2435a4d28cefc83eb01bbc842045101e3c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c51e31a06f2c740c55852a683aa7ffdc20417362", "patch": "@@ -3681,7 +3681,23 @@ void fn () @{\n @end smallexample\n \n It does not warn when the type being copied is a trivially-copyable type whose\n-size is less than 64 bytes.  This warning is enabled by @option{-Wall}.\n+size is less than 64 bytes.\n+\n+This warning also warns when a loop variable in a range-based for-loop is\n+initialized with a value of a different type resulting in a copy.  For example:\n+\n+@smallexample\n+void fn() @{\n+  int arr[10];\n+  for (const double &x : arr) @{ @dots{} @}\n+@}\n+@end smallexample\n+\n+In the example above, in every iteration of the loop a temporary value of\n+type @code{double} is created and destroyed, to which the reference\n+@code{const double &} is bound.\n+\n+This warning is enabled by @option{-Wall}.\n \n @item -Wredundant-tags @r{(C++ and Objective-C++ only)}\n @opindex Wredundant-tags"}, {"sha": "5bb08cc5a1dcd703ddc006fd31b26f86517154e4", "filename": "gcc/testsuite/g++.dg/warn/Wrange-loop-construct2.C", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51e31a06f2c740c55852a683aa7ffdc20417362/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct2.C?ref=c51e31a06f2c740c55852a683aa7ffdc20417362", "patch": "@@ -0,0 +1,212 @@\n+// PR c++/94695\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wrange-loop-construct\" }\n+\n+struct Foo { };\n+struct Bar {\n+  char arr[100];\n+  Bar(Foo);\n+  Bar(int);\n+  operator int();\n+};\n+\n+template<typename T>\n+struct It {\n+  T operator*();\n+  It operator++();\n+  bool operator!=(const It);\n+};\n+\n+template<typename T>\n+struct Cont {\n+  using I = It<T>;\n+  I begin();\n+  I end();\n+};\n+\n+void\n+fn1 ()\n+{\n+  int arr[10];\n+  Cont<int> cont_int;\n+\n+  for (const double &x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const double x : arr) { (void) x; }\n+  for (const int &x : arr) { (void) x; }\n+  for (double &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (double x : arr) { (void) x; }\n+\n+  for (const int &&x : cont_int) { (void) x; }\n+  for (const int &x : cont_int) { (void) x; }\n+  for (const int x : cont_int) { (void) x; }\n+  for (int&& x : cont_int) { (void) x; }\n+  for (int x : cont_int) { (void) x; }\n+\n+  for (const double &&x : cont_int) { (void) x; }\n+  for (const double &x : cont_int) { (void) x; }\n+  for (const double x : cont_int) { (void) x; }\n+\n+  for (double &&x : cont_int) { (void) x; }\n+  for (double x : cont_int) { (void) x; }\n+\n+  for (const Bar &&x : cont_int) { (void) x; }\n+  for (const Bar x : cont_int) { (void) x; }\n+}\n+\n+void\n+fn2 ()\n+{\n+  Cont<int &> cont_int_ref;\n+\n+  for (const int &x : cont_int_ref) { (void) x; }\n+  for (const int x : cont_int_ref) { (void) x; }\n+  for (int &x : cont_int_ref) { (void) x; }\n+  for (int x : cont_int_ref) { (void) x; }\n+\n+  for (const double &&x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const double &x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const double x : cont_int_ref) { (void) x; }\n+  for (double &&x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (double x : cont_int_ref) { (void) x; }\n+\n+  for (const Bar &&x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar &x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar x : cont_int_ref) { (void) x; }\n+  for (Bar &&x : cont_int_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (Bar x : cont_int_ref) { (void) x; }\n+}\n+\n+void\n+fn3 ()\n+{\n+  Cont<Bar> cont_bar;\n+\n+  for (const Bar &&x : cont_bar) { (void) x; }\n+  for (const Bar &x : cont_bar) { (void) x; }\n+  for (const Bar x : cont_bar) { (void) x; }\n+  for (Bar &&x : cont_bar) { (void) x; }\n+  for (Bar x : cont_bar) { (void) x; }\n+\n+  for (const int &&x : cont_bar) { (void) x; }\n+  for (const int &x : cont_bar) { (void) x; }\n+  for (const int x : cont_bar) { (void) x; }\n+  for (int &&x : cont_bar) { (void) x; }\n+  for (int x : cont_bar) { (void) x; }\n+}\n+\n+void\n+fn4 ()\n+{\n+  Cont<Bar &> cont_bar_ref;\n+\n+  for (const Bar &x : cont_bar_ref) { (void) x; }\n+  for (Bar &x : cont_bar_ref) { (void) x; }\n+  for (Bar x : cont_bar_ref) { (void) x; }\n+\n+  for (const int &&x : cont_bar_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int &x : cont_bar_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int x : cont_bar_ref) { (void) x; }\n+  for (int &&x : cont_bar_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (int x : cont_bar_ref) { (void) x; }\n+}\n+\n+void\n+fn5 ()\n+{\n+  Cont<Foo> cont_foo;\n+\n+  for (const Bar &&x : cont_foo) { (void) x; }\n+  for (const Bar &x : cont_foo) { (void) x; }\n+  for (const Bar x : cont_foo) { (void) x; }\n+  for (Bar &&x : cont_foo) { (void) x; }\n+  for (Bar x : cont_foo) { (void) x; }\n+}\n+\n+void\n+fn6 ()\n+{\n+  Cont<Foo &> cont_foo_ref;\n+\n+  for (const Bar &&x : cont_foo_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar &x : cont_foo_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar x : cont_foo_ref) { (void) x; }\n+  for (Bar &&x : cont_foo_ref) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (Bar x : cont_foo_ref) { (void) x; }\n+}\n+\n+void\n+fn7 ()\n+{\n+  double arr[2];\n+\n+  for (const double &x : arr) { (void) x; }\n+  for (const double x : arr) { (void) x; }\n+  for (double &x : arr) { (void) x; }\n+  for (double x : arr) { (void) x; }\n+\n+  for (const int &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int &x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int x : arr) { (void) x; }\n+  for (int &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (int x : arr) { (void) x; }\n+\n+  for (const Bar &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar &x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar x : arr) { (void) x; }\n+  for (Bar &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (Bar x : arr) { (void) x; }\n+}\n+\n+void\n+fn8 ()\n+{\n+  Foo arr[2];\n+\n+  for (const Foo &x : arr) { (void) x; }\n+  for (const Foo x : arr) { (void) x; }\n+  for (Foo &x : arr) { (void) x; }\n+  for (Foo x : arr) { (void) x; }\n+\n+  for (const Bar &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar &x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const Bar x : arr) { (void) x; }\n+  for (Bar &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (Bar x : arr) { (void) x; }\n+}\n+\n+void\n+fn9 ()\n+{\n+  Bar arr[2] = { 1, 2 };\n+\n+  for (const Bar &x : arr) { (void) x; }\n+  for (Bar &x : arr) { (void) x; }\n+  for (Bar x : arr) { (void) x; }\n+\n+  for (const int &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int &x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (const int x : arr) { (void) x; }\n+  for (int &&x : arr) { (void) x; } // { dg-warning \"binds to a temporary constructed from type\" }\n+  for (int x : arr) { (void) x; }\n+}\n+\n+template<typename T>\n+void\n+fn10 ()\n+{\n+  Cont<Bar> cont_bar;\n+\n+  for (const Bar &x : cont_bar) { (void) x; }\n+\n+  Cont<T> cont_dep;\n+  for (const T &x : cont_dep) { (void) x; }\n+}\n+template void fn10<Bar>();\n+\n+struct S {\n+  void fn()\n+  {\n+    Cont<Bar> cont_bar;\n+    for (const Bar &x : cont_bar) { (void) x; }\n+  }\n+};"}]}