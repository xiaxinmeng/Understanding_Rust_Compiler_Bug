{"sha": "0059501924049e53b3a019bacfe12eff6a1827a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA1OTUwMTkyNDA0OWU1M2IzYTAxOWJhY2ZlMTJlZmY2YTE4MjdhMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-08-18T20:50:43Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-08-18T20:50:43Z"}, "message": "46 Cygnus<->FSF merge\n\nFrom-SVN: r7943", "tree": {"sha": "6747ca958f69d8b092f8818920358ab30e18ca99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6747ca958f69d8b092f8818920358ab30e18ca99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0059501924049e53b3a019bacfe12eff6a1827a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0059501924049e53b3a019bacfe12eff6a1827a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0059501924049e53b3a019bacfe12eff6a1827a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0059501924049e53b3a019bacfe12eff6a1827a3/comments", "author": null, "committer": null, "parents": [{"sha": "07d0cbddd457e587413cc203a724165676855099", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d0cbddd457e587413cc203a724165676855099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d0cbddd457e587413cc203a724165676855099"}], "stats": {"total": 914, "additions": 663, "deletions": 251}, "files": [{"sha": "3df3180fda7e232d09d9a1fb982eed5a946c3aaa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -1,3 +1,211 @@\n+Thu Aug 18 12:48:09 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING up to left_curly time.\n+\t* decl.c (xref_tag): Move setting of CLASSTYPE_INTERFACE and\n+        CLASSTYPE_VTABLE_NEEDS_WRITING down to left_curly time.\n+\t* parse.y (left_curly): New final resting place for setting\n+\tCLASSTYPE_INTERFACE and CLASSTYPE_VTABLE_NEEDS_WRITING.\n+\n+Thu Aug 11 11:32:42 1994  H.J. Lu  (hjl@nynexst.com)\n+\n+\t* g++.c (main): Only decrement \"added\" and set \"library\" to\n+\t  NULL when \"library\" != NULL.\n+\n+Sat Aug 13 00:14:52 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Don't set TREE_PUBLIC on a function decl\n+\tjust because its class has a known interface.\n+\t(decls_match): Deal with new format of template parms.\n+\n+\t* lex.c (cons_up_default_function): Don't play with TREE_PUBLIC and\n+\tDECL_EXTERNAL here.\n+\n+Fri Aug 12 01:55:15 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (pushtag): SET_DECL_ARTIFICIAL on gratuitous typedefs.\n+\t(xref_defn_tag): Ditto.\n+\t(pushdecl): Only allow artificial typedefs to be shadowed.\n+\n+\t* init.c (emit_base_init): Pass the right binfos to\n+\texpand_aggr_init_1.\n+\n+\t* class.c (delete_duplicate_fields_1): Make it work right.\n+\t(finish_struct): Catch function/field name conflict.\n+\n+\t* decl2.c (check_classfn): Pass the function to cp_error, not just\n+\tthe name.\n+\n+\t* init.c (sort_member_init): Warn when order of member initializers\n+\tdoes not match order of member declarations.\n+\t(emit_base_init): Call expand_aggr_init_1 with LOOKUP_PROTECT.\n+\n+\t* error.c (dump_expr): Handle lists of functions.\n+\n+\t* decl.c (start_function): #pragma interface only affects functions\n+\tthat would otherwise be static.\n+\t(finish_decl): Don't warn about an unused variable if it has both\n+\tconstructor and destructor, since the 'resource allocation is\n+\tinitialization' idiom is relatively common.\n+\n+\t* typeck.c (comp_target_types): Don't handle TEMPLATE_TYPE_PARMs.\n+\t(comp_target_parms): Ditto.\n+\t(compparms): Never consider default parms.\n+\t(common_base_type): Don't choose a virtual baseclass if there is a\n+\tmore derived class in common.\n+\t(build_conditional_expr): If pedantic, pedwarn about conversion to\n+\tcommon base in conditional expr.\n+\n+\t* class.c (instantiate_type): Handle template instantiation better.\n+\n+\t* typeck.c (convert_arguments): Don't try to get tricky and convert\n+\tto int directly when PROMOTE_PROTOTYPES is set, as it breaks\n+\tuser-defined conversions.\n+\n+\t* lex.c (check_for_missing_semicolon): Also give error at end of\n+\tfile.\n+\n+\t* call.c (build_method_call): Don't promote arrays to pointers here.\n+\n+\t* typeck.c (convert_arguments): Don't require the actual parameter\n+\tto be of a complete type if the formal parameter is a reference.\n+\n+Thu Aug 11 15:21:40 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Soften 'static' on member function error\n+\tto pedwarn.\n+\n+\t* init.c (build_new): Don't automatically save rval.\n+\t(build_offset_ref): Do field lookup with proper basetype_path.\n+\n+Thu Aug 11 12:46:54 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* errfn.c (cp_silent): Declare to mark when we should avoid\n+\temitting warnings and errors.\n+\t(cp_error): Check it.\n+\t(cp_warning): Likewise.\n+\t(cp_pedwarn): Likewise.\n+\t(cp_compiler_error): Likewise.\n+\t(cp_error_at): Likewise.\n+\t(cp_warning_at): Likewise.\n+\t(cp_pedwarn_at): Likewise.\n+\t* call.c (compute_conversion_costs): Set CP_SILENT when we start\n+\tout, and make sure we turn it off before we leave.\n+\n+Thu Aug 11 00:02:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* decl2.c (grok_array_decl): Try computing *(A+B) if neither\n+\targument is obviously an array.\n+\n+Wed Aug 10 15:32:04 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (c_expand_start_case): Do cleanups here.\n+\n+\t* parse.y (xcond): Do bool conversion here, too.\n+\t(simple_stmt, SWITCH case): Don't do cleanups here.\n+\n+\t* decl.c (duplicate_decls): Don't treat builtins that have been\n+\texplicitly declared specially.\n+\n+Tue Aug  9 01:16:09 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* tree.c (make_deep_copy): Support copying pointer, reference,\n+\tfunction, array, offset and method types.\n+\n+\t* decl.c (init_decl_processing): Mark exit and abort as\n+\tBUILT_IN_NONANSI so that duplicate_decls is kinder about\n+\tredeclaration.\n+\t(duplicate_decls): Don't give two errors for redeclaring a C\n+\tfunction with the same parms but a different return type.\n+\n+\t* parse.y (paren_cond_or_null): Do cleanup and bool conversion here.\n+\t(condition): Instead of here.\n+\t(simple_stmt, SWITCH case): Also do cleanup here.\n+\n+\t* decl2.c (finish_anon_union): Only break out FIELD_DECLs.\n+\n+\t* call.c (build_method_call): Don't throw away the side effects of\n+\tthe object in a call to a non-existent constructor.\n+\t* parse.y (primary): Ditto.\n+\n+\t* method.c (build_decl_overload): Oop.\n+\n+\t* decl2.c (lang_decode_option): Deal with flag_no_nonansi_builtin,\n+\twarn about uselessness of specifying -fansi-overloading.\n+\n+\t* method.c (build_decl_overload): Treat any non-member new with one\n+\tparameter as __builtin_new.\n+\n+\t* decl.c (init_decl_processing): Setup built-in meanings of exit,\n+\t_exit and abort.\n+\n+Mon Aug  8 15:03:30 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* error.c (dump_readonly_or_volatile): Put a space between const and\n+\tvolatile if both apply.\n+\n+\t* init.c (perform_member_init): Clean up after this initialization.\n+\t(emit_base_init): Clean up after each base init, not after all have\n+\tbeen done.\n+\t(expand_aggr_vbase_init_1): Clean up after this init.\n+\n+Sun Aug  7 14:55:05 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Deal with destroying references.\n+\n+\t* parse.y (condition): Do bool_truthvalue_conversion here.\n+\t(paren_expr_or_null): And here.\n+\t(simple_if): Not here.\n+\t(simple_stmt): Or here.\n+\n+Sat Aug  6 22:29:45 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* parse.y (paren_expr_or_null): Wrap the expression in a\n+\tCLEANUP_POINT_EXPR.\n+\t(condition): Ditto.\n+\n+Sat Aug  6 19:46:37 1994  Rohan Lenard  (rjl@easams.com.au)\n+\n+\t* call.c (build_scoped_method_call): Fix error message when\n+\tdestructor call refers to a nonexistent type.\n+\n+Sat Apr 16 22:43:30 1993  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* lex.h (rid): Deleted RID_RAISES, it's never used.\n+\tMoved RID_PUBLIC, RID_PRIVATE, RID_PROTECTED, RID_EXCEPTION,\n+\tRID_TEMPLATE and RID_SIGNATURE to the end of the enumeration,\n+\tthey don't need to be touched in `grokdeclarator.'\n+\t(RID_LAST_MODIFIER): Defined macro to be RID_MUTABLE.\n+\n+\t* decl.c (grokdeclarator): Use RID_LAST_MODIFIER instead of\n+\tRID_MAX as loop limit for finding declaration specifiers.\n+\n+Sat Apr  3 21:59:07 1993  Gerald Baumgartner  (gb@cs.purdue.edu)\n+\n+\t* lex.c (debug_yytranslate): Moved to parse.y since it needs to\n+\taccess `yytname,' which is static in parse.c.\n+\n+Fri Apr  2 23:36:57 1993  Gerald Baumgarnter  (gb@cs.purdue.edu)\n+\n+\t* cp-tree.h (GNU_xref_ref): Fixed typo in extern declaration, it\n+\twas `GNU_xref_def' instead of `GNU_xref_ref.'\n+\n+Fri Aug  5 14:20:16 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* pt.c (do_function_instantiation): Don't set TREE_PUBLIC and\n+\tDECL_EXTERNAL on 'extern' instantiations; wait until EOF to do that.\n+\t(do_type_instantiation): Ditto.\n+\n+\t* decl2.c (import_export_inline): Decides at EOF what an inline's\n+\tlinkage should be.\n+\t(finish_file): Call it.\n+\n+\t* decl.c (start_function): Don't rely on the settings of TREE_PUBLIC\n+\tand DECL_EXTERNAL from do_*_instantiation.  Only set\n+\tDECL_DEFER_OUTPUT on inlines whose linkage might actually change.\n+\t(finish_function): Use DECL_DEFER_OUTPUT to decide which inlines to\n+\tmark for later consideration, rather than DECL_FUNCTION_MEMBER_P.\n+\n Fri Aug  5 01:12:20 1994  Mike Stump  (mrs@cygnus.com)\n \n \t* class.c (get_class_offset_1, get_class_offset): New routine to"}, {"sha": "05e1d50c9f592729e44f756ff3f5f440bedeb194", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -700,11 +700,17 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \n   int strike_index = 0, win;\n   struct harshness_code lose;\n+  extern int cp_silent;\n \n #ifdef GATHER_STATISTICS\n   n_compute_conversion_costs++;\n #endif\n \n+#ifndef DEBUG_MATCHING\n+  /* We don't emit any warnings or errors while trying out each candidate.  */\n+  cp_silent = 1;\n+#endif\n+\n   cp->function = function;\n   cp->arg = tta ? TREE_VALUE (tta) : NULL_TREE;\n   cp->u.bad_arg = 0;\t\t/* optimistic!  */\n@@ -812,6 +818,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \t{\n \t  cp->h.code = EVIL_CODE;\n \t  cp->u.bad_arg = -1;\n+\t  cp_silent = 0;\n \t  return;\n \t}\n       else\n@@ -833,6 +840,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \t{\n \t  cp->h.code = EVIL_CODE;\n \t  cp->u.bad_arg = -2;\n+\t  cp_silent = 0;\n \t  return;\n \t}\n       /* Store index of first default.  */\n@@ -855,6 +863,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n       if (dont_convert_types)\n \t{\n \t  cp->h.code = EVIL_CODE;\n+\t  cp_silent = 0;\n \t  return;\n \t}\n \n@@ -1002,6 +1011,7 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n     cp->h.code |= ELLIPSIS_CODE;\n   if (user_strikes)\n     cp->h.code |= USER_CODE;\n+  cp_silent = 0;\n #ifdef DEBUG_MATCHING\n   cp_error (\"final eval %s\", print_harshness (&cp->h));\n #endif\n@@ -1428,7 +1438,9 @@ build_scoped_method_call (exp, scopes, name, parms)\n       if (type != basetype)\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t  exp, basetype, type);\n-      name = IDENTIFIER_TYPE_VALUE (TREE_OPERAND (name, 0));\n+      name = TREE_OPERAND (name, 0);\n+      if (IDENTIFIER_HAS_TYPE_VALUE (name))\n+\tname = IDENTIFIER_TYPE_VALUE (name);\n       if (basetype != name)\n \tcp_error (\"qualified type `%T' does not match destructor type `%T'\",\n \t\t  basetype, name);\n@@ -1604,17 +1616,19 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       if (parms)\n \terror (\"destructors take no parameters\");\n       basetype = TREE_TYPE (instance);\n+      if (TREE_CODE (basetype) == REFERENCE_TYPE)\n+\tbasetype = TREE_TYPE (basetype);\n       if (! ((IS_AGGR_TYPE (basetype)\n \t      && name == constructor_name (basetype))\n \t     || basetype == get_type_value (name)))\n \t{\n \t  cp_error (\"destructor name `~%D' does not match type `%T' of expression\",\n \t\t    name, basetype);\n-\t  return void_zero_node;\n+\t  return convert (void_type_node, instance);\n \t}\n \n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n-\treturn void_zero_node;\n+\treturn convert (void_type_node, instance);\n       instance = default_conversion (instance);\n       instance_ptr = build_unary_op (ADDR_EXPR, instance, 0);\n       return build_delete (build_pointer_type (basetype),\n@@ -1891,13 +1905,16 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t{\n \t  TREE_VALUE (parm) = build_unary_op (ADDR_EXPR, TREE_VALUE (parm), 0);\n \t}\n+#if 0\n+      /* This breaks reference-to-array parameters.  */\n       if (TREE_CODE (t) == ARRAY_TYPE)\n \t{\n \t  /* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place.\n \t     This eliminates needless calls to `compute_conversion_costs'.  */\n \t  TREE_VALUE (parm) = default_conversion (TREE_VALUE (parm));\n \t  t = TREE_TYPE (TREE_VALUE (parm));\n \t}\n+#endif\n       if (t == error_mark_node)\n \treturn error_mark_node;\n       last = build_tree_list (NULL_TREE, t);"}, {"sha": "f907d17f01206150412ffffcded136a7c374baa0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 75, "deletions": 39, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -992,20 +992,18 @@ add_method (type, fields, method)\n    not duplicates, they are just anonymous fields.  This happens\n    when we have unnamed bitfields, for example.  */\n static tree\n-delete_duplicate_fields_1 (field, field_ptr, fields)\n-     tree field, *field_ptr, fields;\n+delete_duplicate_fields_1 (field, fields)\n+     tree field, fields;\n {\n   tree x;\n-  tree prev = field_ptr ? *field_ptr : 0;\n+  tree prev = 0;\n   if (DECL_NAME (field) == 0)\n     {\n       if (TREE_CODE (TREE_TYPE (field)) != UNION_TYPE)\n \treturn fields;\n \n       for (x = TYPE_FIELDS (TREE_TYPE (field)); x; x = TREE_CHAIN (x))\n-\tfields = delete_duplicate_fields_1 (x, field_ptr, fields);\n-      if (prev)\n-\tTREE_CHAIN (prev) = fields;\n+\tfields = delete_duplicate_fields_1 (x, fields);\n       return fields;\n     }\n   else\n@@ -1017,7 +1015,7 @@ delete_duplicate_fields_1 (field, field_ptr, fields)\n \t      if (TREE_CODE (TREE_TYPE (x)) != UNION_TYPE)\n \t\tcontinue;\n \t      TYPE_FIELDS (TREE_TYPE (x))\n-\t\t= delete_duplicate_fields_1 (field, (tree *)0, TYPE_FIELDS (TREE_TYPE (x)));\n+\t\t= delete_duplicate_fields_1 (field, TYPE_FIELDS (TREE_TYPE (x)));\n \t      if (TYPE_FIELDS (TREE_TYPE (x)) == 0)\n \t\t{\n \t\t  if (prev == 0)\n@@ -1039,7 +1037,7 @@ delete_duplicate_fields_1 (field, field_ptr, fields)\n \t\t\t\tx);\n \t\t  else if (TREE_CODE (field) == TYPE_DECL\n \t\t\t   && TREE_CODE (x) == TYPE_DECL)\n-\t\t    cp_error_at (\"duplicate class scope type `%D'\", x);\n+\t\t    cp_error_at (\"duplicate nested type `%D'\", x);\n \t\t  else if (TREE_CODE (field) == TYPE_DECL\n \t\t\t   || TREE_CODE (x) == TYPE_DECL)\n \t\t    cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n@@ -1063,7 +1061,7 @@ delete_duplicate_fields (fields)\n {\n   tree x;\n   for (x = fields; x && TREE_CHAIN (x); x = TREE_CHAIN (x))\n-    TREE_CHAIN (x) = delete_duplicate_fields_1 (x, &x, TREE_CHAIN (x));\n+    TREE_CHAIN (x) = delete_duplicate_fields_1 (x, TREE_CHAIN (x));\n }\n \n /* Change the access of FDECL to ACCESS in T.\n@@ -1937,8 +1935,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t\t  && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n \t\t  && DECL_FRIENDLIST (TYPE_NAME (t)) == NULL_TREE\n \t\t  && warn_ctor_dtor_privacy)\n-\t\twarning (\"class `%s' only defines a private destructor and has no friends\",\n-\t\t\t TYPE_NAME_STRING (t));\n+\t\tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n+\t\t\t    t);\n \t      break;\n \t    }\n \t}\n@@ -2774,17 +2772,12 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-  /* A signature type will contain the fields of the signature table.\n-     Therefore, it's not only an interface.  */\n-  if (IS_SIGNATURE (t))\n-    {\n-      CLASSTYPE_INTERFACE_ONLY (t) = 0;\n-      SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-    }\n-  else\n+  /* This is in general too late to do this.  I moved the main case up to\n+     left_curly, what else needs to move?  */\n+  if (! IS_SIGNATURE (t))\n     {\n-      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n+      my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n+      my_friendly_assert (CLASSTYPE_INTERFACE_KNOWN (t) == ! interface_unknown, 999);\n     }\n \n   if (flag_dossier)\n@@ -2848,14 +2841,13 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       needs_virtual_dtor = 0;\n     }\n \n+  /* Both of these should be done before now.  */\n   if (write_virtuals == 3 && CLASSTYPE_INTERFACE_KNOWN (t)\n       && ! IS_SIGNATURE (t))\n     {\n-      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! interface_only;\n+      my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n+      my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);\n     }\n-  else if (IS_SIGNATURE (t))\n-    CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 0;\n \n   /* The three of these are approximations which may later be\n      modified.  Needed at this point to make add_virtual_function\n@@ -3520,6 +3512,31 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   /* Delete all duplicate fields from the fields */\n   delete_duplicate_fields (fields);\n \n+  /* Catch function/field name conflict, removing the field (since it's\n+     easier).  */\n+  {\n+    int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n+    tree last = NULL_TREE;\n+    for (x = fields; x; x = TREE_CHAIN (x))\n+      {\n+\ttree name = DECL_NAME (x);\n+\tint i;\n+\tfor (i = 0; i < n_methods; ++i)\n+\t  if (DECL_NAME (TREE_VEC_ELT (method_vec, i)) == name)\n+\t    {\n+\t      cp_error_at (\"data member `%#D' conflicts with\", x);\n+\t      cp_error_at (\"function member `%#D'\",\n+\t\t\t   TREE_VEC_ELT (method_vec, i));\n+\t      if (last)\n+\t\tTREE_CHAIN (last) = TREE_CHAIN (x);\n+\t      else\n+\t\tfields = TREE_CHAIN (x);\n+\t      break;\n+\t    }\n+\tlast = x;\n+      }\n+  }\n+\n   /* Now we have the final fieldlist for the data fields.  Record it,\n      then lay out the structure or union (including the fields).  */\n \n@@ -4701,11 +4718,42 @@ instantiate_type (lhstype, rhs, complain)\n \t  {\n \t    elem = get_first_fn (rhs);\n \t    while (elem)\n-\t      if (TREE_TYPE (elem) != lhstype)\n+\t      if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n \t\telem = DECL_CHAIN (elem);\n \t      else\n \t\treturn elem;\n-\t    /* No exact match found, look for a compatible function.  */\n+\n+\t    /* No exact match found, look for a compatible template.  */\n+\t    {\n+\t      tree save_elem = 0;\n+\t      for (elem = get_first_fn (rhs); elem; elem = DECL_CHAIN (elem))\n+\t\tif (TREE_CODE (elem) == TEMPLATE_DECL)\n+\t\t  {\n+\t\t    int n = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (elem));\n+\t\t    tree *t = (tree *) alloca (sizeof (tree) * n);\n+\t\t    int i, d;\n+\t\t    i = type_unification (DECL_TEMPLATE_PARMS (elem), t,\n+\t\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (elem)),\n+\t\t\t\t\t  TYPE_ARG_TYPES (lhstype), &d, 0);\n+\t\t    if (i == 0)\n+\t\t      {\n+\t\t\tif (save_elem)\n+\t\t\t  {\n+\t\t\t    cp_error (\"ambiguous template instantiation converting to `%#T'\", lhstype);\n+\t\t\t    return error_mark_node;\n+\t\t\t  }\n+\t\t\tsave_elem = instantiate_template (elem, t);\n+\t\t\t/* Check the return type.  */\n+\t\t\tif (! comptypes (TREE_TYPE (lhstype),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (save_elem)), 1))\n+\t\t\t  save_elem = 0;\n+\t\t      }\n+\t\t  }\n+\t      if (save_elem)\n+\t\treturn save_elem;\n+\t    }\n+\n+\t    /* No match found, look for a compatible function.  */\n \t    elem = get_first_fn (rhs);\n \t    while (elem && ! comp_target_types (lhstype, TREE_TYPE (elem), 1))\n \t      elem = DECL_CHAIN (elem);\n@@ -4727,18 +4775,6 @@ instantiate_type (lhstype, rhs, complain)\n \t\t      }\n \t\t    return error_mark_node;\n \t\t  }\n-\t\tif (TREE_CODE (save_elem) == TEMPLATE_DECL)\n-\t\t  {\n-\t\t    int ntparms = TREE_VEC_LENGTH\n-\t\t      (DECL_TEMPLATE_PARMS (save_elem));\n-\t\t    tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n-\t\t    int i, dummy;\n-\t\t    i = type_unification\n-\t\t      (DECL_TEMPLATE_PARMS (save_elem), targs,\n-\t\t       TYPE_ARG_TYPES (TREE_TYPE (save_elem)),\n-\t\t       TYPE_ARG_TYPES (lhstype), &dummy, 0);\n-\t\t    save_elem = instantiate_template (save_elem, targs);\n-\t\t  }\n \t\treturn save_elem;\n \t      }\n \t    if (complain)"}, {"sha": "4f848c727c559e74a09a0a341d0206fbabca9bfc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -2359,7 +2359,7 @@ extern void GNU_xref_end\t\t\tPROTO((int));\n extern void GNU_xref_file\t\t\tPROTO((char *));\n extern void GNU_xref_start_scope\t\tPROTO((HOST_WIDE_INT));\n extern void GNU_xref_end_scope\t\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, int, int, int));\n-extern void GNU_xref_def\t\t\tPROTO((tree, char *));\n+extern void GNU_xref_ref\t\t\tPROTO((tree, char *));\n extern void GNU_xref_decl\t\t\tPROTO((tree, tree));\n extern void GNU_xref_call\t\t\tPROTO((tree, char *));\n extern void GNU_xref_function\t\t\tPROTO((tree, tree));"}, {"sha": "a47075be5600c6d108ec7a7b0f1558ee32532465", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -1233,11 +1233,9 @@ cp_convert (type, expr, convtype, flags)\n \t{\n \t  tree rval;\n \t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n-\t  if (rval) return rval;\n-\t  if (code == BOOLEAN_TYPE)\n-\t    cp_error (\"`%#T' used where a `bool' was expected\", intype);\n-\t  else\n-\t    cp_error (\"`%#T' used where an `int' was expected\", intype);\n+\t  if (rval)\n+\t    return rval;\n+\t  cp_error (\"`%#T' used where a `%T' was expected\", intype, type);\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)"}, {"sha": "233232d0d40ef604833f4c7539096f5f34134a3b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 77, "deletions": 62, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -401,6 +401,11 @@ extern int flag_short_double;\n \n extern int flag_no_builtin;\n \n+/* Nonzero means don't recognize the non-ANSI builtin functions.\n+   -ansi sets this.  */\n+\n+extern int flag_no_nonansi_builtin;\n+\n /* Nonzero means disable GNU extensions.  */\n \n extern int flag_ansi;\n@@ -1743,6 +1748,7 @@ pushtag (name, type, globalize)\n #else\n \t\t  d = build_decl (TYPE_DECL, name, type);\n #endif\n+\t\t  SET_DECL_ARTIFICIAL (d);\n #ifdef DWARF_DEBUGGING_INFO\n \t\t  if (write_symbols == DWARF_DEBUG)\n \t\t    {\n@@ -1778,6 +1784,7 @@ pushtag (name, type, globalize)\n \t      /* Make nested declarations go into class-level scope.  */\n \t      newdecl = 1;\n \t      d = build_decl (TYPE_DECL, name, type);\n+\t      SET_DECL_ARTIFICIAL (d);\n #ifdef DWARF_DEBUGGING_INFO\n \t      if (write_symbols == DWARF_DEBUG)\n \t\t{\n@@ -1981,11 +1988,11 @@ decls_match (newdecl, olddecl)\n \t\n \tfor (i = 0; i < len; i++)\n \t  {\n-\t    tree newarg = TREE_VEC_ELT (newargs, i);\n-\t    tree oldarg = TREE_VEC_ELT (oldargs, i);\n+\t    tree newarg = TREE_VALUE (TREE_VEC_ELT (newargs, i));\n+\t    tree oldarg = TREE_VALUE (TREE_VEC_ELT (oldargs, i));\n \t    if (TREE_CODE (newarg) != TREE_CODE (oldarg))\n \t      return 0;\n-\t    else if (TREE_CODE (newarg) == IDENTIFIER_NODE)\n+\t    else if (TREE_CODE (newarg) == TYPE_DECL)\n \t      /* continue */;\n \t    else if (! comptypes (TREE_TYPE (newarg), TREE_TYPE (oldarg), 1))\n \t      return 0;\n@@ -2104,6 +2111,7 @@ duplicate_decls (newdecl, olddecl)\n        after implicit decl.  */\n     ;\n   else if (TREE_CODE (olddecl) == FUNCTION_DECL\n+\t   && DECL_ARTIFICIAL (olddecl)\n \t   && (DECL_BUILT_IN (olddecl) || DECL_BUILT_IN_NONANSI (olddecl)))\n     {\n       /* If you declare a built-in or predefined function name as static,\n@@ -2188,9 +2196,8 @@ duplicate_decls (newdecl, olddecl)\n \t\t\tnewdecl);\n \t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n \t    }\n-\n-\t  if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n-\t\t\t TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 2))\n+\t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n+\t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl)), 2))\n \t    {\n \t      cp_error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n@@ -2678,7 +2685,8 @@ pushdecl (x)\n \t    /* don't do anything just yet */;\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n-\t      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (x) == TYPE_DECL)\n+\t      if ((TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t))\n+\t\t  || (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n \t\t{\n \t\t  /* We do nothing special here, because C++ does such nasty\n \t\t     things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n@@ -4540,14 +4548,31 @@ init_decl_processing ()\n \t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t    endlink)),\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n-#if 0\n-  builtin_function (\"alloca\",\n-\t\t    build_function_type (ptr_type_node,\n-\t\t\t\t\t tree_cons (NULL_TREE,\n-\t\t\t\t\t\t    sizetype,\n-\t\t\t\t\t\t    endlink)),\n-\t\t    BUILT_IN_ALLOCA, NULL_PTR);\n+  /* Define alloca, ffs as builtins.\n+     Declare _exit just to mark it as volatile.  */\n+  if (! flag_no_builtin && !flag_no_nonansi_builtin)\n+    {\n+#if 0\t\t\t\t/* Why is this disabled? (jason 8/9/94) */\n+      temp = builtin_function (\"alloca\",\n+\t\t\t       build_function_type (ptr_type_node,\n+\t\t\t\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t       sizetype,\n+\t\t\t\t\t\t\t       endlink)),\n+\t\t\t       BUILT_IN_ALLOCA, NULL_PTR);\n+      /* Suppress error if redefined as a non-function.  */\n+      DECL_BUILT_IN_NONANSI (temp) = 1;\n #endif\n+      temp = builtin_function (\"ffs\", int_ftype_int, BUILT_IN_FFS, NULL_PTR);\n+      /* Suppress error if redefined as a non-function.  */\n+      DECL_BUILT_IN_NONANSI (temp) = 1;\n+      temp = builtin_function (\"_exit\", build_function_type (void_type_node,\n+\t\t\t\t\t\t\t     int_endlink),\n+\t\t\t       NOT_BUILT_IN, NULL_PTR);\n+      TREE_THIS_VOLATILE (temp) = 1;\n+      TREE_SIDE_EFFECTS (temp) = 1;\n+      /* Suppress error if redefined as a non-function.  */\n+      DECL_BUILT_IN_NONANSI (temp) = 1;\n+    }\n \n   builtin_function (\"__builtin_abs\", int_ftype_int,\n \t\t    BUILT_IN_ABS, NULL_PTR);\n@@ -4647,6 +4672,23 @@ init_decl_processing ()\n       builtin_function (\"strlen\", sizet_ftype_string, BUILT_IN_STRLEN, NULL_PTR);\n       builtin_function (\"sin\", double_ftype_double, BUILT_IN_SIN, NULL_PTR);\n       builtin_function (\"cos\", double_ftype_double, BUILT_IN_COS, NULL_PTR);\n+\n+      /* Declare these functions volatile\n+\t to avoid spurious \"control drops through\" warnings.  */\n+      temp = builtin_function (\"abort\",\n+\t\t\t       build_function_type (void_type_node, endlink),\n+\t\t\t       NOT_BUILT_IN, NULL_PTR);\n+      TREE_THIS_VOLATILE (temp) = 1;\n+      TREE_SIDE_EFFECTS (temp) = 1;\n+      /* Well, these are actually ANSI, but we can't set DECL_BUILT_IN on\n+         them...  */\n+      DECL_BUILT_IN_NONANSI (temp) = 1;\n+      temp = builtin_function (\"exit\", build_function_type (void_type_node,\n+\t\t\t\t\t\t\t    int_endlink),\n+\t\t\t       NOT_BUILT_IN, NULL_PTR);\n+      TREE_THIS_VOLATILE (temp) = 1;\n+      TREE_SIDE_EFFECTS (temp) = 1;\n+      DECL_BUILT_IN_NONANSI (temp) = 1;\n     }\n \n #if 0\n@@ -6315,9 +6357,11 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t  expand_aggr_init (decl, init, 0);\n \t\t}\n \n-\t      /* Set this to 0 so we can tell whether an aggregate\n-\t\t which was initialized was ever used.  */\n-\t      if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t      /* Set this to 0 so we can tell whether an aggregate which\n+\t\t was initialized was ever used.  Don't do this if it has a\n+\t\t destructor, so we don't complain about the 'resource\n+\t\t allocation is initialization' idiom.  */\n+\t      if (TYPE_NEEDS_CONSTRUCTING (type) && cleanup == NULL_TREE)\n \t\tTREE_USED (decl) = 0;\n \n \t      /* Store the cleanup, if there was one.  */\n@@ -7283,7 +7327,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      goto found;\n \t    }\n \n-\t  for (i = (int) RID_FIRST_MODIFIER; i < (int) RID_MAX; i++)\n+\t  for (i = (int) RID_FIRST_MODIFIER; i < (int) RID_LAST_MODIFIER; i++)\n \t    {\n \t      if (ridpointers[i] == id)\n \t\t{\n@@ -8965,14 +9009,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  type = build_cplus_method_type (build_type_variant (ctype, constp, volatilep),\n \t\t\t\t\t  TREE_TYPE (type), TYPE_ARG_TYPES (type));\n \n-\t/* Record presence of `static'.  In C++, `inline' is like `static'.\n-\t   Methods of classes should be public, unless we're dropping them\n-\t   into some other file, so we don't clear TREE_PUBLIC for them.  */\n+\t/* Record presence of `static'.  In C++, `inline' is like `static'.  */\n \tpublicp\n-\t  = ((ctype\n-\t      && CLASSTYPE_INTERFACE_KNOWN (ctype))\n-\t     || !(RIDBIT_SETP (RID_STATIC, specbits)\n-\t\t  || RIDBIT_SETP (RID_INLINE, specbits)));\n+\t  = !(RIDBIT_SETP (RID_STATIC, specbits)\n+\t      || RIDBIT_SETP (RID_INLINE, specbits));\n \n \tdecl = grokfndecl (ctype, type, original_name,\n \t\t\t   virtualp, flags, quals,\n@@ -8993,7 +9033,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n-\t\tcp_error_at (\"cannot declare member function `%D' to have static linkage\", decl);\n+\t\tcp_pedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n \t\tillegal_static = 1;\n \t      }\n \t    else if (! ctype\n@@ -9795,6 +9835,7 @@ xref_defn_tag (code_type_node, name, binfo)\n       if (! ANON_AGGRNAME_P (name))\n       {\n \tregister tree type_decl = build_decl (TYPE_DECL, ncp, rv);\n+\tSET_DECL_ARTIFICIAL (type_decl);\n #ifdef DWARF_DEBUGGING_INFO\n \t/* Mark the TYPE_DECL node created just above as a gratuitous one\n \t   so that dwarfout.c will know not to generate a TAG_typedef DIE\n@@ -9943,9 +9984,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t}\n       else\n \t{\n-\t  extern tree pending_vtables;\n \t  struct binding_level *old_b = class_binding_level;\n-\t  int needs_writing;\n \n \t  ref = make_lang_type (code);\n \n@@ -9955,36 +9994,10 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t    {\n \t      SET_SIGNATURE (ref);\n \t      CLASSTYPE_INTERFACE_ONLY (ref) = 0;\n-\t      CLASSTYPE_INTERFACE_UNKNOWN (ref) = 0;\n-\t    }\n-\n-\t  /* Record how to set the access of this class's\n-\t     virtual functions.  If write_virtuals == 2 or 3, then\n-\t     inline virtuals are ``extern inline''.  */\n-\t  switch (write_virtuals)\n-\t    {\n-\t    case 0:\n-\t    case 1:\n-\t      needs_writing = 1;\n-\t      break;\n-\t    case 2:\n-\t      needs_writing = !! value_member (name, pending_vtables);\n-\t      break;\n-\t    case 3:\n-\t      needs_writing = ! CLASSTYPE_INTERFACE_ONLY (ref)\n-\t\t&& CLASSTYPE_INTERFACE_KNOWN (ref);\n-\t      break;\n-\t    default:\n-\t      needs_writing = 0;\n+\t      SET_CLASSTYPE_INTERFACE_UNKNOWN (ref);\n+\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ref) = 0;\n \t    }\n \n-\t  /* Signatures don't have a vtable.  As long as we don't have default\n-\t     implementations, they behave as if `write_virtuals' were 3.  */\n-\t  if (tag_code == signature_type)\n-\t    CLASSTYPE_VTABLE_NEEDS_WRITING (ref) = 0;\n-\t  else\n-\t    CLASSTYPE_VTABLE_NEEDS_WRITING (ref) = needs_writing;\n-\n #ifdef NONNESTED_CLASSES\n \t  /* Class types don't nest the way enums do.  */\n \t  class_binding_level = (struct binding_level *)0;\n@@ -10682,15 +10695,14 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   /* If this function belongs to an interface, it is public.\n      If it belongs to someone else's interface, it is also external.\n      It doesn't matter whether it's inline or not.  */\n-  if (interface_unknown == 0)\n+  if (interface_unknown == 0\n+      && ! TREE_PUBLIC (decl1))\n     {\n       TREE_PUBLIC (decl1) = 1;\n       DECL_EXTERNAL (decl1)\n \t= (interface_only\n \t   || (DECL_INLINE (decl1) && ! flag_implement_inlines));\n     }\n-  else if (DECL_EXPLICIT_INSTANTIATION (decl1))\n-    /* PUBLIC and EXTERNAL set by do_*_instantiation */;\n   else\n     {\n       /* This is a definition, not a reference.\n@@ -10699,7 +10711,10 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n       DECL_EXTERNAL (decl1) = current_extern_inline;\n \n-      DECL_DEFER_OUTPUT (decl1) = DECL_INLINE (decl1);\n+      DECL_DEFER_OUTPUT (decl1)\n+\t= DECL_INLINE (decl1) && ! TREE_PUBLIC (decl1)\n+\t  && (DECL_FUNCTION_MEMBER_P (decl1)\n+\t      || DECL_TEMPLATE_INSTANTIATION (decl1));\n     }\n \n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1))\n@@ -11567,8 +11582,8 @@ finish_function (lineno, call_poplevel)\n       rest_of_compilation (fndecl);\n     }\n \n-  if (DECL_INLINE (fndecl)\n-      && !TREE_ASM_WRITTEN (fndecl) && DECL_FUNCTION_MEMBER_P (fndecl))\n+  if (DECL_INLINE (fndecl) && !TREE_ASM_WRITTEN (fndecl)\n+      && DECL_DEFER_OUTPUT (fndecl))\n     {\n       mark_inline_for_output (fndecl);\n     }"}, {"sha": "25c517d2c946941bf4098a377d77c3f8413bd46c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 63, "deletions": 35, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -84,6 +84,11 @@ int flag_no_asm;\n \n int flag_no_builtin;\n \n+/* Nonzero means don't recognize the non-ANSI builtin functions.\n+   -ansi sets this.  */\n+\n+int flag_no_nonansi_builtin;\n+\n /* Nonzero means do some things the same way PCC does.  */\n \n int flag_traditional;\n@@ -361,6 +366,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n   {\"short-temps\", &flag_short_temps, 1},\n+  {\"nonansi-builtins\", &flag_no_nonansi_builtin, 0}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -447,6 +453,10 @@ lang_decode_option (p)\n \t  flag_alt_external_templates = 0;\n \t  found = 1;\n \t}\n+      else if (!strcmp (p, \"ansi-overloading\"))\n+\t{\n+\t  warning (\"-fansi-overloading is no longer meaningful\");\n+\t}\n       else for (j = 0;\n \t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n \t\tj++)\n@@ -544,7 +554,8 @@ lang_decode_option (p)\n       else return 0;\n     }\n   else if (!strcmp (p, \"-ansi\"))\n-    flag_no_asm = 1, dollars_in_ident = 0, flag_ansi = 1;\n+    flag_no_asm = 1, dollars_in_ident = 0, flag_no_nonansi_builtin = 1,\n+    flag_ansi = 1;\n #ifdef SPEW_DEBUG\n   /* Undocumented, only ever used when you're invoking cc1plus by hand, since\n      it's probably safe to assume no sane person would ever want to use this\n@@ -983,7 +994,7 @@ grok_array_decl (array_expr, index_exp)\n   if (TYPE_LANG_SPECIFIC (type)\n       && TYPE_OVERLOADS_ARRAY_REF (type))\n     return build_opfncall (ARRAY_REF, LOOKUP_NORMAL,\n-\t\t\t array_expr, index_exp, NULL_TREE);\n+\t\t\t   array_expr, index_exp, NULL_TREE);\n \n   /* Otherwise, create an ARRAY_REF for a pointer or array type.  */\n   if (TREE_CODE (type) == POINTER_TYPE\n@@ -1000,17 +1011,14 @@ grok_array_decl (array_expr, index_exp)\n       || TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n-  if (TYPE_LANG_SPECIFIC (type)\n-      && TYPE_OVERLOADS_ARRAY_REF (type))\n-    error (\"array expression backwards\");\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   || TREE_CODE (type) == ARRAY_TYPE)\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      || TREE_CODE (type) == ARRAY_TYPE)\n     return build_array_ref (index_exp, array_expr);\n-  else\n-    error(\"`[]' applied to non-pointer type\");\n \n-  /* We gave an error, so give an error.  Huh?  */\n-  return error_mark_node;\n+  /* The expression E1[E2] is identical (by definition) to *((E1)+(E2)).  */\n+  return build_indirect_ref (build_binary_op (PLUS_EXPR, array_expr,\n+\t\t\t\t\t      index_exp, 1),\n+\t\t\t     \"array indexing\");\n }\n \n /* Given the cast expression EXP, checking out its validity.   Either return\n@@ -1128,13 +1136,13 @@ check_classfn (ctype, cname, function)\n     }\n \n   if (methods != end)\n-    cp_error (\"argument list for `%D' does not match any in class `%T'\",\n-\t      fn_name, ctype);\n+    cp_error (\"argument list for `%#D' does not match any in class `%T'\",\n+\t      function, ctype);\n   else\n     {\n       methods = 0;\n-      cp_error (\"no `%D' member function declared in class `%T'\",\n-\t\tfn_name, ctype);\n+      cp_error (\"no `%#D' member function declared in class `%T'\",\n+\t\tfunction, ctype);\n     }\n \n   /* If we did not find the method in the class, add it to\n@@ -2067,9 +2075,13 @@ finish_anon_union (anon_union_decl)\n       return;\n     }\n \n-  while (field)\n+  for (; field; field = TREE_CHAIN (field))\n     {\n-      tree decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n+      tree decl;\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n       /* tell `pushdecl' that this is not tentative.  */\n       DECL_INITIAL (decl) = error_mark_node;\n       TREE_PUBLIC (decl) = public_p;\n@@ -2096,7 +2108,6 @@ finish_anon_union (anon_union_decl)\n \t TREE_PURPOSE of the following TREE_LIST.  */\n       elems = tree_cons (NULL_TREE, decl, elems);\n       TREE_TYPE (elems) = type;\n-      field = TREE_CHAIN (field);\n     }\n   if (static_p)\n     {\n@@ -2530,6 +2541,37 @@ walk_sigtables (typedecl_fn, vardecl_fn)\n     }\n }\n \n+/* Determines the proper settings of TREE_PUBLIC and DECL_EXTERNAL for an\n+   inline function at end-of-file.  */\n+\n+void\n+import_export_inline (decl)\n+     tree decl;\n+{\n+  if (TREE_PUBLIC (decl))\n+    return;\n+\n+  /* If an explicit instantiation doesn't have TREE_PUBLIC set, it was with\n+     'extern'.  */\n+  if (DECL_EXPLICIT_INSTANTIATION (decl)\n+      || (DECL_IMPLICIT_INSTANTIATION (decl) && ! flag_implicit_templates))\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      DECL_EXTERNAL (decl) = 1;\n+    }\n+  else if (DECL_FUNCTION_MEMBER_P (decl))\n+    {\n+      tree ctype = DECL_CLASS_CONTEXT (decl);\n+      if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n+\t{\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  DECL_EXTERNAL (decl)\n+\t    = (CLASSTYPE_INTERFACE_ONLY (ctype)\n+\t       || (DECL_INLINE (decl) && ! flag_implement_inlines));\n+\t}\n+    }\n+}\n+  \n extern int parse_time, varconst_time;\n \n #define TIMEVAR(VAR, BODY)    \\\n@@ -2835,24 +2877,12 @@ finish_file ()\n \t   0; don't crash.  */\n \tif (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n \t  continue;\n-\tif (DECL_FUNCTION_MEMBER_P (decl) && !TREE_PUBLIC (decl))\n-\t  {\n-\t    tree ctype = DECL_CLASS_CONTEXT (decl);\n-\t    if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n-\t      {\n-\t\tTREE_PUBLIC (decl) = 1;\n-\t\tDECL_EXTERNAL (decl)\n-\t\t  = (CLASSTYPE_INTERFACE_ONLY (ctype)\n-\t\t     || (DECL_INLINE (decl) && ! flag_implement_inlines));\n-\t      }\n-\t  }\n+\timport_export_inline (decl);\n \tif (TREE_PUBLIC (decl)\n \t    || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t    || flag_keep_inline_functions)\n \t  {\n-\t    if (DECL_EXTERNAL (decl)\n-\t\t|| (DECL_IMPLICIT_INSTANTIATION (decl)\n-\t\t    && ! flag_implicit_templates))\n+\t    if (DECL_EXTERNAL (decl))\n \t      assemble_external (decl);\n \t    else\n \t      {\n@@ -2879,9 +2909,7 @@ finish_file ()\n \t\tif (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t\t    && ! TREE_ASM_WRITTEN (decl))\n \t\t  {\n-\t\t    if (DECL_EXTERNAL (decl)\n-\t\t\t|| (DECL_IMPLICIT_INSTANTIATION (decl)\n-\t\t\t    && ! flag_implicit_templates))\n+\t\t    if (DECL_EXTERNAL (decl))\n \t\t      assemble_external (decl);\n \t\t    else\n \t\t      {"}, {"sha": "2f78164b1460b52aed32e62b8a334f6aa2c03865", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -30,6 +30,11 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n typedef char* cp_printer PROTO((HOST_WIDE_INT, int));\n extern cp_printer * cp_printers[256];\n \n+/* Whether or not we should try to be quiet for errors and warnings; this is\n+   used to avoid being too talkative about problems with tentative choices\n+   when we're computing the conversion costs for a method call.  */\n+int cp_silent = 0;\n+\n typedef void errorfn ();\t/* deliberately vague */\n \n extern char* cp_file_of PROTO((tree));\n@@ -150,7 +155,8 @@ cp_error (format, arglist)\n      arglist_dcl\n {\n   extern errorfn error;\n-  cp_thing (error, 0, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (error, 0, format, arglist);\n }\n \n void\n@@ -159,7 +165,8 @@ cp_warning (format, arglist)\n      arglist_dcl\n {\n   extern errorfn warning;\n-  cp_thing (warning, 0, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (warning, 0, format, arglist);\n }\n \n void\n@@ -168,7 +175,8 @@ cp_pedwarn (format, arglist)\n      arglist_dcl\n {\n   extern errorfn pedwarn;\n-  cp_thing (pedwarn, 0, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (pedwarn, 0, format, arglist);\n }\n \n void\n@@ -177,7 +185,8 @@ cp_compiler_error (format, arglist)\n      arglist_dcl\n {\n   extern errorfn compiler_error;\n-  cp_thing (compiler_error, 0, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (compiler_error, 0, format, arglist);\n }\n \n void\n@@ -195,7 +204,8 @@ cp_error_at (format, arglist)\n      arglist_dcl\n {\n   extern errorfn error_with_file_and_line;\n-  cp_thing (error_with_file_and_line, 1, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (error_with_file_and_line, 1, format, arglist);\n }\n \n void\n@@ -204,7 +214,8 @@ cp_warning_at (format, arglist)\n      arglist_dcl\n {\n   extern errorfn warning_with_file_and_line;\n-  cp_thing (warning_with_file_and_line, 1, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (warning_with_file_and_line, 1, format, arglist);\n }\n \n void\n@@ -213,5 +224,6 @@ cp_pedwarn_at (format, arglist)\n      arglist_dcl\n {\n   extern errorfn pedwarn_with_file_and_line;\n-  cp_thing (pedwarn_with_file_and_line, 1, format, arglist);\n+  if (! cp_silent)\n+    cp_thing (pedwarn_with_file_and_line, 1, format, arglist);\n }"}, {"sha": "4bb9316b22db13a485b471f2cfed7de79059cd96", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -104,6 +104,8 @@ dump_readonly_or_volatile (t, p)\n       if (p == before) OB_PUTC (' ');\n       if (TYPE_READONLY (t))\n \tOB_PUTS (\"const\");\n+      if (TYPE_READONLY (t) && TYPE_VOLATILE (t))\n+\tOB_PUTC (' ');\n       if (TYPE_VOLATILE (t))\n \tOB_PUTS (\"volatile\");\n       if (p == after) OB_PUTC (' ');\n@@ -1228,6 +1230,14 @@ dump_expr (t, nop)\n \tbreak;\n       }\n \n+    case TREE_LIST:\n+      if (TREE_VALUE (t) && TREE_CODE (TREE_VALUE (t)) == FUNCTION_DECL)\n+\t{\n+\t  OB_PUTID (DECL_NAME (TREE_VALUE (t)));\n+\t  break;\n+\t}\n+      /* else fall through */\t\n+\n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */"}, {"sha": "d259398948c4b6bea787c4e544c96367e48fbbfe", "filename": "gcc/cp/init.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -217,6 +217,7 @@ perform_member_init (member, name, init, explicit)\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n+  expand_cleanups_to (NULL_TREE);\n   if (flag_handle_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n     cp_warning (\"caution, member `%D' may not be destroyed in the presense of an exception during construction\", member);\n }\n@@ -230,11 +231,14 @@ sort_member_init (t)\n   tree init_list = NULL_TREE;\n   tree fields_to_unmark = NULL_TREE;\n   int found;\n+  int last_pos = 0;\n+  tree last_field;\n \n   for (member = TYPE_FIELDS (t); member ; member = TREE_CHAIN (member))\n     {\n+      int pos;\n       found = 0;\n-      for (x = current_member_init_list ; x ; x = TREE_CHAIN (x))\n+      for (x = current_member_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n \t{\n \t  /* If we cleared this out, then pay no attention to it.  */\n \t  if (TREE_PURPOSE (x) == NULL_TREE)\n@@ -264,6 +268,17 @@ sort_member_init (t)\n \t\t\t      field);\n \t\t  continue;\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  if (pos < last_pos && extra_warnings)\n+\t\t    {\n+\t\t      cp_warning_at (\"member initializers for `%#D'\", last_field);\n+\t\t      cp_warning_at (\"  and `%#D'\", field);\n+\t\t      warning (\"  will be re-ordered to match declaration order\");\n+\t\t    }\n+\t\t  last_pos = pos;\n+\t\t  last_field = field;\n+\t\t}\n \n \t      init_list = chainon (init_list,\n \t\t\t\t   build_tree_list (name, TREE_VALUE (x)));\n@@ -500,9 +515,10 @@ emit_base_init (t, immediately)\n \t    continue;\n \n \t  member = convert_pointer_to (binfo, current_class_decl);\n-\t  expand_aggr_init_1 (t_binfo, 0,\n+\t  expand_aggr_init_1 (binfo, 0,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n-\t\t\t      BINFO_OFFSET_ZEROP (binfo), LOOKUP_COMPLAIN);\n+\t\t\t      BINFO_OFFSET_ZEROP (binfo), LOOKUP_NORMAL);\n+\t  expand_cleanups_to (NULL_TREE);\n \t}\n \n       if (pass == 0)\n@@ -568,9 +584,10 @@ emit_base_init (t, immediately)\n \t\t\t      current_class_decl, BINFO_OFFSET (base_binfo));\n \n \t      ref = build_indirect_ref (base, NULL_PTR);\n-\t      expand_aggr_init_1 (t_binfo, 0, ref, NULL_TREE,\n+\t      expand_aggr_init_1 (base_binfo, 0, ref, NULL_TREE,\n \t\t\t\t  BINFO_OFFSET_ZEROP (base_binfo),\n-\t\t\t\t  LOOKUP_COMPLAIN);\n+\t\t\t\t  LOOKUP_NORMAL);\n+\t      expand_cleanups_to (NULL_TREE);\n \t    }\n \t}\n       CLEAR_BINFO_BASEINIT_MARKED (base_binfo);\n@@ -655,11 +672,6 @@ emit_base_init (t, immediately)\n \n   current_member_init_list = NULL_TREE;\n \n-  /* It is possible for the initializers to need cleanups.\n-     Expand those cleanups now that all the initialization\n-     has been done.  */\n-  expand_cleanups_to (NULL_TREE);\n-\n   if (! immediately)\n     {\n       extern rtx base_init_insns;\n@@ -734,6 +746,7 @@ expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n   /* Call constructors, but don't set up vtables.  */\n   expand_aggr_init_1 (binfo, exp, ref, init, 0,\n \t\t      LOOKUP_COMPLAIN|LOOKUP_SPECULATIVELY);\n+  expand_cleanups_to (NULL_TREE);\n   CLEAR_BINFO_VBASE_INIT_MARKED (binfo);\n }\n \n@@ -1966,12 +1979,6 @@ build_offset_ref (cname, name)\n \t\t\t\t      name, NULL_TREE, 1);\n #endif\n \n-  fnfields = lookup_fnfields (TYPE_BINFO (type), name, 1);\n-  fields = lookup_field (type, name, 0, 0);\n-\n-  if (fields == error_mark_node || fnfields == error_mark_node)\n-    return error_mark_node;\n-\n   if (current_class_type == 0\n       || get_base_distance (type, current_class_type, 0, &basetypes) == -1)\n     {\n@@ -1986,6 +1993,12 @@ build_offset_ref (cname, name)\n   else\n     decl = C_C_D;\n \n+  fnfields = lookup_fnfields (basetypes, name, 1);\n+  fields = lookup_field (basetypes, name, 0, 0);\n+\n+  if (fields == error_mark_node || fnfields == error_mark_node)\n+    return error_mark_node;\n+\n   /* A lot of this logic is now handled in lookup_field and\n      lookup_fnfield. */\n   if (fnfields)\n@@ -2018,7 +2031,6 @@ build_offset_ref (cname, name)\n \t{\n \t  extern int flag_save_memoized_contexts;\n \n-\t  /* This does not handle access checking yet.  */\n \t  if (DECL_CHAIN (t) == NULL_TREE || dtor)\n \t    {\n \t      enum access_type access;\n@@ -3261,7 +3273,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t\t\t\t\t\tbuild_tree_list (NULL_TREE, rval))));\n     }\n \n-  return save_expr (rval);\n+  return rval;\n }\n \f\n /* `expand_vec_init' performs initialization of a vector of aggregate"}, {"sha": "fb6ba52653023c4f6f1221f19ad8fdb7c91dcfdd", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -960,15 +960,6 @@ set_yydebug (value)\n #endif\n }\n \n-#ifdef SPEW_DEBUG\n-const char *\n-debug_yytranslate (value)\n-    int value;\n-{\n-  return yytname[YYTRANSLATE (value)];\n-}\n-\n-#endif\n \f\n /* Functions and data structures for #pragma interface.\n \n@@ -1786,13 +1777,6 @@ cons_up_default_function (type, name, fields, kind)\n       warn_if_unknown_interface ();\n     t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n     store_pending_inline (fn, t);\n-    if (interface_unknown)\n-      TREE_PUBLIC (fn) = 0;\n-    else\n-      {\n-\tTREE_PUBLIC (fn) = 1;\n-\tDECL_EXTERNAL (fn) = interface_only;\n-      }\n   }\n \n   finish_method (fn);\n@@ -2182,17 +2166,17 @@ check_for_missing_semicolon (type)\n   if (yychar < 0)\n     yychar = yylex ();\n \n-  if (yychar > 255\n-      && yychar != SCSPEC\n-      && yychar != IDENTIFIER\n-      && yychar != TYPENAME)\n+  if ((yychar > 255\n+       && yychar != SCSPEC\n+       && yychar != IDENTIFIER\n+       && yychar != TYPENAME)\n+      || end_of_file)\n     {\n       if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n \terror (\"semicolon missing after %s declaration\",\n \t       TREE_CODE (type) == ENUMERAL_TYPE ? \"enum\" : \"struct\");\n       else\n-\terror (\"semicolon missing after declaration of `%s'\",\n-\t       TYPE_NAME_STRING (type));\n+\tcp_error (\"semicolon missing after declaration of `%T'\", type);\n       shadow_tag (build_tree_list (0, type));\n     }\n   /* Could probably also hack cases where class { ... } f (); appears.  */"}, {"sha": "291b9cde6e31b74e9be4f36aa5a890bdd0874bda", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -58,14 +58,16 @@ enum rid\n   RID_VOLATILE,\n   RID_FRIEND,\n   RID_VIRTUAL,\n+  RID_SIGNED,\n+  RID_AUTO,\n+  RID_MUTABLE,\n+\n+  /* This is where grokdeclarator ends its search when setting the specbits. */\n+\n   RID_PUBLIC,\n   RID_PRIVATE,\n   RID_PROTECTED,\n-  RID_SIGNED,\n   RID_EXCEPTION,\n-  RID_RAISES,\n-  RID_AUTO,\n-  RID_MUTABLE,\n   RID_TEMPLATE,\n   RID_SIGNATURE,\n   /* Before adding enough to get up to 64, the RIDBIT_* macros\n@@ -76,6 +78,7 @@ enum rid\n #define NORID RID_UNUSED\n \n #define RID_FIRST_MODIFIER RID_EXTERN\n+#define RID_LAST_MODIFIER RID_MUTABLE\n \n /* The type that can represent all values of RIDBIT.  */\n /* We assume that we can stick in at least 32 bits into this. */"}, {"sha": "aabd63550e322cb7a917844b2d67818d08beb800", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -852,18 +852,17 @@ build_decl_overload (dname, parms, for_method)\n   /* member operators new and delete look like methods at this point.  */\n   if (! for_method && parms != NULL_TREE && TREE_CODE (parms) == TREE_LIST)\n     {\n-      if (TREE_VALUE (parms) == sizetype\n-\t  && TREE_CHAIN (parms) == void_list_node)\n+      if (dname == ansi_opname[(int) DELETE_EXPR])\n+\treturn get_identifier (\"__builtin_delete\");\n+      else if (dname == ansi_opname[(int) VEC_DELETE_EXPR])\n+\treturn get_identifier (\"__builtin_vec_delete\");\n+      else if (TREE_CHAIN (parms) == void_list_node)\n \t{\n \t  if (dname == ansi_opname[(int) NEW_EXPR])\n \t    return get_identifier (\"__builtin_new\");\n \t  else if (dname == ansi_opname[(int) VEC_NEW_EXPR])\n \t    return get_identifier (\"__builtin_vec_new\");\n \t}\n-      else if (dname == ansi_opname[(int) DELETE_EXPR])\n-\treturn get_identifier (\"__builtin_delete\");\n-      else if (dname == ansi_opname[(int) VEC_DELETE_EXPR])\n-\treturn get_identifier (\"__builtin_vec_delete\");\n     }\n \n   OB_INIT ();"}, {"sha": "ce0a6376cc786ea021fe30dbbc1e247a2c2a3e4c", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -895,7 +895,8 @@ paren_expr_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' expr ')'\n-\t\t{ $$ = $2; }\n+\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, bool_type_node, \n+\t\t\t       bool_truthvalue_conversion ($2)); }\n \t;\n \n paren_cond_or_null:\n@@ -904,13 +905,16 @@ paren_cond_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' condition ')'\n-\t\t{ $$ = $2; }\n+\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, bool_type_node, \n+\t\t\t       bool_truthvalue_conversion ($2)); }\n \t;\n \n xcond:\n \t/* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| condition\n+\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, bool_type_node, \n+\t\t\t       bool_truthvalue_conversion ($$)); }\n \t| error\n \t\t{ $$ = NULL_TREE; }\n \t;\n@@ -1548,7 +1552,7 @@ primary:\n \t\t  if (TREE_CODE (TREE_TYPE ($1)) \n \t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $3);\n-\t\t  $$ = void_zero_node;\n+\t\t  $$ = convert (void_type_node, $1);\n \t\t}\n \t| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT\n \t\t{ \n@@ -1557,7 +1561,7 @@ primary:\n \t\t  if (TREE_CODE (TREE_TYPE ($1))\n \t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($2))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $2);\n-\t\t  $$ = void_zero_node; \n+\t\t  $$ = convert (void_type_node, $1);\n \t\t}\n \t;\n \n@@ -2398,25 +2402,59 @@ base_class_access_list:\n \t;\n \n left_curly: '{'\n-\t\t{ tree t;\n+\t\t{ tree t = $<ttype>0;\n \t\t  push_obstacks_nochange ();\n \t\t  end_temporary_allocation ();\n \n-\t\t  if (! IS_AGGR_TYPE ($<ttype>0))\n+\t\t  if (! IS_AGGR_TYPE (t))\n \t\t    {\n-\t\t      $<ttype>0 = make_lang_type (RECORD_TYPE);\n-\t\t      TYPE_NAME ($<ttype>0) = get_identifier (\"erroneous type\");\n+\t\t      t = $<ttype>0 = make_lang_type (RECORD_TYPE);\n+\t\t      TYPE_NAME (t) = get_identifier (\"erroneous type\");\n \t\t    }\n-\t\t  if (TYPE_SIZE ($<ttype>0))\n-\t\t    duplicate_tag_error ($<ttype>0);\n-                  if (TYPE_SIZE ($<ttype>0) || TYPE_BEING_DEFINED ($<ttype>0))\n+\t\t  if (TYPE_SIZE (t))\n+\t\t    duplicate_tag_error (t);\n+                  if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))\n                     {\n-                      t = make_lang_type (TREE_CODE ($<ttype>0));\n+                      t = make_lang_type (TREE_CODE (t));\n                       pushtag (TYPE_IDENTIFIER ($<ttype>0), t, 0);\n                       $<ttype>0 = t;\n                     }\n-\t\t  pushclass ($<ttype>0, 0);\n-\t\t  TYPE_BEING_DEFINED ($<ttype>0) = 1;\n+\t\t  pushclass (t, 0);\n+\t\t  TYPE_BEING_DEFINED (t) = 1;\n+\t\t  /* Reset the interface data, at the earliest possible\n+\t\t     moment, as it might have been set via a class foo;\n+\t\t     before.  */\n+\t\t  /* Don't change signatures.  */\n+\t\t  if (! IS_SIGNATURE (t))\n+\t\t    {\n+\t\t      extern tree pending_vtables;\n+\t\t      int needs_writing;\n+\t\t      tree name = TYPE_IDENTIFIER (t);\n+\n+\t\t      CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n+\t\t      SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n+\n+\t\t      /* Record how to set the access of this class's\n+\t\t\t virtual functions.  If write_virtuals == 2 or 3, then\n+\t\t\t inline virtuals are ``extern inline''.  */\n+\t\t      switch (write_virtuals)\n+\t\t\t{\n+\t\t\tcase 0:\n+\t\t\tcase 1:\n+\t\t\t  needs_writing = 1;\n+\t\t\t  break;\n+\t\t\tcase 2:\n+\t\t\t  needs_writing = !! value_member (name, pending_vtables);\n+\t\t\t  break;\n+\t\t\tcase 3:\n+\t\t\t  needs_writing = ! CLASSTYPE_INTERFACE_ONLY (t)\n+\t\t\t    && CLASSTYPE_INTERFACE_KNOWN (t);\n+\t\t\t  break;\n+\t\t\tdefault:\n+\t\t\t  needs_writing = 0;\n+\t\t\t}\n+\t\t      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;\n+\t\t    }\n #if 0\n \t\t  t = TYPE_IDENTIFIER ($<ttype>0);\n \t\t  if (t && IDENTIFIER_TEMPLATE (t))\n@@ -3053,7 +3091,7 @@ simple_if:\n \t\t{ cond_stmt_keyword = \"if\"; }\n \t  .pushlevel paren_cond_or_null\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_start_cond (bool_truthvalue_conversion ($4), 0); }\n+\t\t  expand_start_cond ($4, 0); }\n \t  implicitly_scoped_stmt\n \t;\n \n@@ -3108,7 +3146,7 @@ simple_stmt:\n \t\t  expand_start_loop (1);\n \t\t  cond_stmt_keyword = \"while\"; }\n \t  .pushlevel paren_cond_or_null\n-\t\t{ expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n+\t\t{ expand_exit_loop_if_false (0, $4); }\n \t  already_scoped_stmt\n \t\t{ expand_end_bindings (getdecls (), kept_level_p (), 1);\n \t\t  poplevel (kept_level_p (), 1, 0);\n@@ -3124,7 +3162,7 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"do\"; }\n \t  paren_expr_or_null ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  expand_exit_loop_if_false (0, bool_truthvalue_conversion ($6));\n+\t\t  expand_exit_loop_if_false (0, $6);\n \t\t  expand_end_loop ();\n \t\t  clear_momentary ();\n \t\t  finish_stmt (); }\n@@ -3135,7 +3173,7 @@ simple_stmt:\n \t\t  expand_start_loop_continue_elsewhere (1); }\n \t  .pushlevel xcond ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n+\t\t  if ($4) expand_exit_loop_if_false (0, $4); }\n \t  xexpr ')'\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n@@ -3156,7 +3194,7 @@ simple_stmt:\n \t\t  expand_start_loop_continue_elsewhere (1); }\n \t  .pushlevel xcond ';'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  if ($4) expand_exit_loop_if_false (0, bool_truthvalue_conversion ($4)); }\n+\t\t  if ($4) expand_exit_loop_if_false (0, $4); }\n \t  xexpr ')'\n \t\t/* Don't let the tree nodes for $7 be discarded\n \t\t   by clear_momentary during the parsing of the next stmt.  */\n@@ -3175,7 +3213,7 @@ simple_stmt:\n \t\t}\n \t| SWITCH .pushlevel '(' condition ')'\n \t\t{ emit_line_note (input_filename, lineno);\n-\t\t  c_expand_start_case ($4); \n+\t\t  c_expand_start_case ($4);\n \t\t  /* Don't let the tree nodes for $4 be discarded by\n \t\t     clear_momentary during the parsing of the next stmt.  */\n \t\t  push_momentary (); }\n@@ -3761,3 +3799,13 @@ operator_name:\n \t;\n \n %%\n+\n+#ifdef SPEW_DEBUG\n+const char *\n+debug_yytranslate (value)\n+    int value;\n+{\n+  return yytname[YYTRANSLATE (value)];\n+}\n+\n+#endif"}, {"sha": "94dc9fad940f5979f2ed47df78ac490b88aa32ef", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -2408,16 +2408,19 @@ do_function_instantiation (declspecs, declarator, storage)\n   if (flag_external_templates)\n     return;\n \n-  if (DECL_EXPLICIT_INSTANTIATION (result) && ! DECL_EXTERNAL (result))\n+  if (DECL_EXPLICIT_INSTANTIATION (result) && TREE_PUBLIC (result))\n     return;\n \n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n-  TREE_PUBLIC (result) = 1;\n \n   if (storage == NULL_TREE)\n-    DECL_EXTERNAL (result) = DECL_INLINE (result) && ! flag_implement_inlines;\n+    {\n+      TREE_PUBLIC (result) = 1;\n+      DECL_EXTERNAL (result) = (DECL_INLINE (result)\n+\t\t\t\t&& ! flag_implement_inlines);\n+    }\n   else if (storage == ridpointers[(int) RID_EXTERN])\n-    DECL_EXTERNAL (result) = 1;\n+    ;\n   else\n     cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n@@ -2454,19 +2457,19 @@ do_type_instantiation (name, storage)\n     }\n \n   /* We've already instantiated this.  */\n-  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && ! CLASSTYPE_INTERFACE_ONLY (t))\n+  if (CLASSTYPE_EXPLICIT_INSTANTIATION (t) && CLASSTYPE_INTERFACE_KNOWN (t))\n     {\n       if (! extern_p)\n \tcp_pedwarn (\"multiple explicit instantiation of `%#T'\", t);\n       return;\n     }\n \n   SET_CLASSTYPE_EXPLICIT_INSTANTIATION (t);\n-  CLASSTYPE_VTABLE_NEEDS_WRITING (t) = ! extern_p;\n-  SET_CLASSTYPE_INTERFACE_KNOWN (t);\n-  CLASSTYPE_INTERFACE_ONLY (t) = extern_p;\n   if (! extern_p)\n     {\n+      SET_CLASSTYPE_INTERFACE_KNOWN (t);\n+      CLASSTYPE_INTERFACE_ONLY (t) = 0;\n+      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n       CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n       TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (t)) = 0;\n       rest_of_type_compilation (t, 1);\n@@ -2478,9 +2481,12 @@ do_type_instantiation (name, storage)\n     for (; tmp; tmp = TREE_CHAIN (tmp))\n       {\n \tSET_DECL_EXPLICIT_INSTANTIATION (tmp);\n-\tTREE_PUBLIC (tmp) = 1;\n-\tDECL_EXTERNAL (tmp)\n-\t  = (extern_p || (DECL_INLINE (tmp) && ! flag_implement_inlines));\n+\tif (! extern_p)\n+\t  {\n+\t    TREE_PUBLIC (tmp) = 1;\n+\t    DECL_EXTERNAL (tmp) = (DECL_INLINE (tmp)\n+\t\t\t\t   && ! flag_implement_inlines);\n+\t  }\n       }\n \n #if 0"}, {"sha": "e22ec293aa3cc463bd270af0dbcb535c7287f25a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -1626,6 +1626,31 @@ make_deep_copy (t)\n       TREE_OPERAND (t, 0) = make_deep_copy (TREE_OPERAND (t, 0));\n       return t;\n \n+    case POINTER_TYPE:\n+      return build_pointer_type (make_deep_copy (TREE_TYPE (t)));\n+    case REFERENCE_TYPE:\n+      return build_reference_type (make_deep_copy (TREE_TYPE (t)));\n+    case FUNCTION_TYPE:\n+      return build_function_type (make_deep_copy (TREE_TYPE (t)),\n+\t\t\t\t  make_deep_copy (TYPE_ARG_TYPES (t)));\n+    case ARRAY_TYPE:\n+      return build_array_type (make_deep_copy (TREE_TYPE (t)),\n+\t\t\t       make_deep_copy (TYPE_DOMAIN (t)));\n+    case OFFSET_TYPE:\n+      return build_offset_type (make_deep_copy (TYPE_OFFSET_BASETYPE (t)),\n+\t\t\t\tmake_deep_copy (TREE_TYPE (t)));\n+    case METHOD_TYPE:\n+      return build_method_type\n+\t(make_deep_copy (TYPE_METHOD_BASETYPE (t)),\n+\t build_function_type\n+\t (make_deep_copy (TREE_TYPE (t)),\n+\t  make_deep_copy (TREE_CHAIN (TYPE_ARG_TYPES (t)))));\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\treturn build_ptrmemfunc_type\n+\t  (make_deep_copy (TYPE_PTRMEMFUNC_FN_TYPE (t)));\n+      /* else fall through */\n+      \n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */"}, {"sha": "4d7e3346f9f06e3d58c902325fdebb471263e356", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -734,8 +734,6 @@ comp_target_types (ttl, ttr, nptrs)\n   ttr = TYPE_MAIN_VARIANT (ttr);\n   if (ttl == ttr)\n     return 1;\n-  if (TREE_CODE (ttr) == TEMPLATE_TYPE_PARM)\n-    return 1;\n \n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n@@ -813,12 +811,14 @@ common_base_type (tt1, tt2)\n   if (UNIQUELY_DERIVED_FROM_P (tt2, tt1))\n     return tt2;\n \n+#if 0\n   /* If they share a virtual baseclass, that's good enough.  */\n   for (tmp = CLASSTYPE_VBASECLASSES (tt1); tmp; tmp = TREE_CHAIN (tmp))\n     {\n       if (binfo_member (BINFO_TYPE (tmp), CLASSTYPE_VBASECLASSES (tt2)))\n \treturn BINFO_TYPE (tmp);\n     }\n+#endif\n \n   /* Otherwise, try to find a unique baseclass of TT1\n      that is shared by TT2, and follow that down.  */\n@@ -904,6 +904,8 @@ compparms (parms1, parms2, strict)\n \t    return t2 == void_list_node && TREE_PURPOSE (t1);\n \t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n \t}\n+#if 0\n+      /* Default parms are not part of the type of a function.  */\n       if (strict != 3 && TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n \t{\n \t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n@@ -912,6 +914,7 @@ compparms (parms1, parms2, strict)\n \t  if (cmp == 0)\n \t    return 0;\n \t}\n+#endif\n \n       t1 = TREE_CHAIN (t1);\n       t2 = TREE_CHAIN (t2);\n@@ -959,8 +962,6 @@ comp_target_parms (parms1, parms2, strict)\n       p2 = TREE_VALUE (t2);\n       if (p1 == p2)\n \tcontinue;\n-      if (TREE_CODE (p2) == TEMPLATE_TYPE_PARM)\n-\tcontinue;\n \n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n \t  || (TREE_CODE (p1) == REFERENCE_TYPE && TREE_CODE (p2) == REFERENCE_TYPE))\n@@ -970,9 +971,6 @@ comp_target_parms (parms1, parms2, strict)\n \t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (p2))))\n \t    continue;\n \n-\t  if (TREE_CODE (TREE_TYPE (p2)) == TEMPLATE_TYPE_PARM)\n-\t    continue;\n-\n \t  /* The following is wrong for contravariance,\n \t     but many programs depend on it.  */\n \t  if (TREE_TYPE (p1) == void_type_node)\n@@ -2530,13 +2528,15 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  && (type == 0 || TREE_CODE (type) != REFERENCE_TYPE))\n \tval = TREE_OPERAND (val, 0);\n \n-      if ((type == 0 || TREE_CODE (type) != REFERENCE_TYPE)\n-\t  && (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n+      if (type == 0 || TREE_CODE (type) != REFERENCE_TYPE)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n-\t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE))\n-\tval = default_conversion (val);\n+\t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n+\t    val = default_conversion (val);\n \n-      val = require_complete_type (val);\n+\t  val = require_complete_type (val);\n+\t}\n \n       if (val == error_mark_node)\n \tcontinue;\n@@ -2555,7 +2555,8 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    }\n \t  else\n \t    {\n-#ifdef PROMOTE_PROTOTYPES\n+#if 0 && defined (PROMOTE_PROTOTYPES)\n+\t      /* This breaks user-defined conversions.  */\n \t      /* Rather than truncating and then reextending,\n \t\t convert directly to int, if that's the type we will want.  */\n \t      if (! flag_traditional\n@@ -4682,11 +4683,20 @@ build_conditional_expr (ifexp, op1, op2)\n \t{\n \t  if (result_type == error_mark_node)\n \t    {\n-\t      message_2_types (error, \"common base type of types `%s' and `%s' is ambiguous\",\n-\t\t\t       TREE_TYPE (type1), TREE_TYPE (type2));\n+\t      cp_error (\"common base type of types `%T' and `%T' is ambiguous\",\n+\t\t\tTREE_TYPE (type1), TREE_TYPE (type2));\n \t      result_type = ptr_type_node;\n \t    }\n-\t  else result_type = TYPE_POINTER_TO (result_type);\n+\t  else\n+\t    {\n+\t      if (pedantic\n+\t\t  && result_type != TREE_TYPE (type1)\n+\t\t  && result_type != TREE_TYPE (type2))\n+\t\tcp_pedwarn (\"`%T' and `%T' converted to `%T *' in conditional expression\",\n+\t\t\t    type1, type2, result_type);\n+\n+\t      result_type = TYPE_POINTER_TO (result_type);\n+\t    }\n \t}\n       else\n \t{\n@@ -7210,7 +7220,8 @@ c_expand_start_case (exp)\n \texp = index;\n     }\n \n-  expand_start_case (1, exp, type, \"switch statement\");\n+  expand_start_case (1, build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp),\n+\t\t     type, \"switch statement\");\n \n   return exp;\n }"}, {"sha": "8813b4808f3454369e3ea48f35647bcec1690999", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0059501924049e53b3a019bacfe12eff6a1827a3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0059501924049e53b3a019bacfe12eff6a1827a3", "patch": "@@ -631,7 +631,7 @@ digest_init (type, init, tail)\n      tree type, init, *tail;\n {\n   enum tree_code code = TREE_CODE (type);\n-  tree element = 0;\n+  tree element = NULL_TREE;\n   tree old_tail_contents;\n   /* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR\n      tree node which has no TREE_TYPE.  */"}]}