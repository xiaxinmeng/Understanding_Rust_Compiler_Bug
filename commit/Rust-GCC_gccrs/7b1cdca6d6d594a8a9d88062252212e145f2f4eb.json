{"sha": "7b1cdca6d6d594a8a9d88062252212e145f2f4eb", "node_id": "C_kwDOANBUbNoAKDdiMWNkY2E2ZDZkNTk0YThhOWQ4ODA2MjI1MjIxMmUxNDVmMmY0ZWI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-31T19:18:00Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-11-01T13:05:20Z"}, "message": "Remove builtin_unreachable in VRP\n\nRemoval of __builtin_unreachable calls were handled in an inconsistent\nway.  This removes then in the VRP pass, and sets the global range\nappropriately.\n\n\t* tree-vrp.cc (class remove_unreachable): New.\n\t(remove_unreachable::maybe_register_block): New.\n\t(remove_unreachable::remove_and_update_globals): New.\n\t(rvrp_folder::rvrp_folder): Initialize m_unreachable.\n\t(rvrp_folder::post_fold_bb): Maybe register unreachable block.\n\t(rvrp_folder::m_unreachable): New member.\n\t(execute_ranger_vrp): Add final_pass flag, remove unreachables.", "tree": {"sha": "9fe234c5b99e729daec61ecbc6e78199ea4f0324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fe234c5b99e729daec61ecbc6e78199ea4f0324"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1cdca6d6d594a8a9d88062252212e145f2f4eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1cdca6d6d594a8a9d88062252212e145f2f4eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1cdca6d6d594a8a9d88062252212e145f2f4eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1cdca6d6d594a8a9d88062252212e145f2f4eb/comments", "author": null, "committer": null, "parents": [{"sha": "592bbe3d7eb3cff656c731e84ad872719a4a9d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592bbe3d7eb3cff656c731e84ad872719a4a9d16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592bbe3d7eb3cff656c731e84ad872719a4a9d16"}], "stats": {"total": 190, "additions": 187, "deletions": 3}, "files": [{"sha": "f0e4d37bef094a7b6da3205fb8cf50aecbcfb632", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 187, "deletions": 3, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1cdca6d6d594a8a9d88062252212e145f2f4eb/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1cdca6d6d594a8a9d88062252212e145f2f4eb/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=7b1cdca6d6d594a8a9d88062252212e145f2f4eb", "patch": "@@ -51,6 +51,183 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-pointer-equiv.h\"\n #include \"gimple-fold.h\"\n #include \"tree-dfa.h\"\n+#include \"tree-ssa-dce.h\"\n+\n+// This class is utilized by VRP and ranger to remove __builtin_unreachable\n+// calls, and reflect any resulting global ranges.\n+//\n+// maybe_register_block () is called on basic blocks, and if that block\n+// matches the pattern of one branch being a builtin_unreachable, register\n+// the resulting executable edge in a list.\n+//\n+// After all blocks have been processed, remove_and_update_globals() will\n+// - check all exports from registered blocks\n+// - ensure the cache entry of each export is set with the appropriate range\n+// - rewrite the conditions to take the executable edge\n+// - perform DCE on any feeding instructions to those rewritten conditions\n+//\n+// Then each of the immediate use chain of each export is walked, and a new\n+// global range created by unioning the ranges at all remaining use locations.\n+\n+class remove_unreachable {\n+public:\n+  remove_unreachable (gimple_ranger &r) : m_ranger (r) { m_list.create (30); }\n+  ~remove_unreachable () { m_list.release (); }\n+  void maybe_register_block (basic_block bb);\n+  bool remove_and_update_globals (bool final_p);\n+  vec<edge> m_list;\n+  gimple_ranger &m_ranger;\n+};\n+\n+// Check if block BB has a __builtin_unreachable () call on one arm, and\n+// register the executable edge if so.\n+\n+void\n+remove_unreachable::maybe_register_block (basic_block bb)\n+{\n+  gimple *s = gimple_outgoing_range_stmt_p (bb);\n+  if (!s || gimple_code (s) != GIMPLE_COND)\n+    return;\n+\n+  edge e0 = EDGE_SUCC (bb, 0);\n+  basic_block bb0 = e0->dest;\n+  bool un0 = EDGE_COUNT (bb0->succs) == 0\n+\t     && gimple_seq_unreachable_p (bb_seq (bb0));\n+  edge e1 = EDGE_SUCC (bb, 1);\n+  basic_block bb1 = e1->dest;\n+  bool un1 = EDGE_COUNT (bb1->succs) == 0\n+\t     && gimple_seq_unreachable_p (bb_seq (bb1));\n+\n+  // If the 2 blocks are not different, ignore.\n+  if (un0 == un1)\n+    return;\n+\n+  if (un0)\n+    m_list.safe_push (e1);\n+  else\n+    m_list.safe_push (e0);\n+}\n+\n+// Process the edges in the list, change the conditions and removing any\n+// dead code feeding those conditions.  Calculate the range of any\n+// names that may have been exported from those blocks, and determine if\n+// there is any updates to their global ranges..\n+// FINAL_P indicates all builtin_unreachable calls should be removed.\n+// Return true if any builtin_unreachables/globals eliminated/updated.\n+\n+bool\n+remove_unreachable::remove_and_update_globals (bool final_p)\n+{\n+  if (m_list.length () == 0)\n+    return false;\n+\n+  bool change = false;\n+  tree name;\n+  unsigned i;\n+  bitmap_iterator bi;\n+  auto_bitmap all_exports;\n+  for (i = 0; i < m_list.length (); i++)\n+    {\n+      edge e = m_list[i];\n+      gimple *s = gimple_outgoing_range_stmt_p (e->src);\n+      gcc_checking_assert (gimple_code (s) == GIMPLE_COND);\n+      bool lhs_p = TREE_CODE (gimple_cond_lhs (s)) == SSA_NAME;\n+      bool rhs_p = TREE_CODE (gimple_cond_rhs (s)) == SSA_NAME;\n+      // Do not remove __builtin_unreachable if it confers a relation, or\n+      // that relation will be lost in subsequent passes.  Unless its the\n+      // final pass.\n+      if (!final_p && lhs_p && rhs_p)\n+\tcontinue;\n+      // If this is already a constant condition, don't look either\n+      if (!lhs_p && !rhs_p)\n+\tcontinue;\n+\n+      bool dominate_exit_p = true;\n+      FOR_EACH_GORI_EXPORT_NAME (m_ranger.gori (), e->src, name)\n+\t{\n+\t  // Ensure the cache is set for NAME in the succ block.\n+\t  Value_Range r(TREE_TYPE (name));\n+\t  Value_Range ex(TREE_TYPE (name));\n+\t  m_ranger.range_on_entry (r, e->dest, name);\n+\t  m_ranger.range_on_entry (ex, EXIT_BLOCK_PTR_FOR_FN (cfun), name);\n+\t  // If the range produced by this __builtin_unreachacble expression\n+\t  // is not fully reflected in the range at exit, then it does not\n+\t  // dominate the exit of the funciton.\n+\t  if (ex.intersect (r))\n+\t    dominate_exit_p = false;\n+\t}\n+\n+      // If the exit is dominated, add to the export list.  Otherwise if this\n+      // isn't the final VRP pass, leave the call in the IL.\n+      if (dominate_exit_p)\n+\tbitmap_ior_into (all_exports, m_ranger.gori ().exports (e->src));\n+      else if (!final_p)\n+\tcontinue;\n+\n+      change = true;\n+      // Rewrite the condition.\n+      if (e->flags & EDGE_TRUE_VALUE)\n+\tgimple_cond_make_true (as_a<gcond *> (s));\n+      else\n+\tgimple_cond_make_false (as_a<gcond *> (s));\n+      update_stmt (s);\n+    }\n+\n+  if (bitmap_empty_p (all_exports))\n+    return false;\n+  // Invoke DCE on all exported names to elimnate dead feeding defs\n+  auto_bitmap dce;\n+  bitmap_copy (dce, all_exports);\n+  // Don't attempt to DCE parameters.\n+  EXECUTE_IF_SET_IN_BITMAP (all_exports, 0, i, bi)\n+    if (SSA_NAME_IS_DEFAULT_DEF (ssa_name (i)))\n+      bitmap_clear_bit (dce, i);\n+  simple_dce_from_worklist (dce);\n+\n+  // Loop over all uses of each name and find maximal range. This is the\n+  // new global range.\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+  EXECUTE_IF_SET_IN_BITMAP (all_exports, 0, i, bi)\n+    {\n+      name = ssa_name (i);\n+      if (!name || SSA_NAME_IN_FREE_LIST (name))\n+\tcontinue;\n+      Value_Range r (TREE_TYPE (name));\n+      Value_Range exp_range (TREE_TYPE (name));\n+      r.set_undefined ();\n+      FOR_EACH_IMM_USE_FAST (use_p, iter, name)\n+\t{\n+\t  gimple *use_stmt = USE_STMT (use_p);\n+\t  if (is_gimple_debug (use_stmt))\n+\t    continue;\n+\t  if (!m_ranger.range_of_expr (exp_range, name, use_stmt))\n+\t    exp_range.set_varying (TREE_TYPE (name));\n+\t  r.union_ (exp_range);\n+\t  if (r.varying_p ())\n+\t    break;\n+\t}\n+      // Include the on-exit range to ensure non-dominated unreachables\n+      // don't incorrectly impact the global range.\n+      m_ranger.range_on_entry (exp_range, EXIT_BLOCK_PTR_FOR_FN (cfun), name);\n+      r.union_ (exp_range);\n+      if (r.varying_p () || r.undefined_p ())\n+\tcontinue;\n+      if (!set_range_info (name, r))\n+\tcontinue;\n+      change = true;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Global Exported (via unreachable): \");\n+\t  print_generic_expr (dump_file, name, TDF_SLIM);\n+\t  fprintf (dump_file, \" = \");\n+\t  gimple_range_global (r, name);\n+\t  r.dump (dump_file);\n+\t  fputc ('\\n', dump_file);\n+\t}\n+    }\n+  return change;\n+}\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -4260,6 +4437,7 @@ class rvrp_folder : public substitute_and_fold_engine\n public:\n \n   rvrp_folder (gimple_ranger *r) : substitute_and_fold_engine (),\n+\t\t\t\t   m_unreachable (*r),\n \t\t\t\t   m_simplifier (r, r->non_executable_edge_flag)\n   {\n     m_ranger = r;\n@@ -4312,6 +4490,8 @@ class rvrp_folder : public substitute_and_fold_engine\n   void post_fold_bb (basic_block bb) override\n   {\n     m_pta->leave (bb);\n+    if (cfun->after_inlining)\n+      m_unreachable.maybe_register_block (bb);\n   }\n \n   void pre_fold_stmt (gimple *stmt) override\n@@ -4328,6 +4508,7 @@ class rvrp_folder : public substitute_and_fold_engine\n     return ret;\n   }\n \n+  remove_unreachable m_unreachable;\n private:\n   DISABLE_COPY_AND_ASSIGN (rvrp_folder);\n   gimple_ranger *m_ranger;\n@@ -4339,7 +4520,8 @@ class rvrp_folder : public substitute_and_fold_engine\n   from anywhere to perform a VRP pass, including from EVRP.  */\n \n unsigned int\n-execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p)\n+execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p,\n+\t\t    bool final_p)\n {\n   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n@@ -4350,6 +4532,8 @@ execute_ranger_vrp (struct function *fun, bool warn_array_bounds_p)\n   gimple_ranger *ranger = enable_ranger (fun, false);\n   rvrp_folder folder (ranger);\n   folder.substitute_and_fold ();\n+  // Remove tagged builtin-unreachable and maybe update globals.\n+  folder.m_unreachable.remove_and_update_globals (final_p);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     ranger->dump (dump_file);\n \n@@ -4428,11 +4612,11 @@ class pass_vrp : public gimple_opt_pass\n     {\n       // Early VRP pass.\n       if (my_pass == 0)\n-\treturn execute_ranger_vrp (fun, /*warn_array_bounds_p=*/false);\n+\treturn execute_ranger_vrp (fun, /*warn_array_bounds_p=*/false, false);\n \n       if ((my_pass == 1 && param_vrp1_mode == VRP_MODE_RANGER)\n \t  || (my_pass == 2 && param_vrp2_mode == VRP_MODE_RANGER))\n-\treturn execute_ranger_vrp (fun, warn_array_bounds_p);\n+\treturn execute_ranger_vrp (fun, warn_array_bounds_p, my_pass == 2);\n       return execute_vrp (fun, warn_array_bounds_p);\n     }\n "}]}